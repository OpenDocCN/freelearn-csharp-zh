- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Interactive AR Experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having mastered the basics of crafting and implementing an AR experience in
    Unity for Android and iOS platforms in [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011),
    we’ll now embark on the engaging journey of enhancing your AR scenes with intriguing
    interactions. This chapter will open a whole new world of user experiences for
    you as we strive to augment reality with utility-based overlays.
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing the robust capabilities of C#, our adventure will take a turn toward
    creating an innovative AR application tailored to the food industry. This application
    will revolutionize the way customers make their selections, offering an unprecedented
    method for placing orders.
  prefs: []
  type: TYPE_NORMAL
- en: As we unravel the creation process of this AR app, you’ll discover how to anchor
    and scale 3D models in the real world, facilitate user interactions with the elements
    of your AR app, and comprehend the broad principles to contemplate when architecting
    your own AR application. This immersive journey will equip you with a rich set
    of skills, offering a deeper understanding of the boundless possibilities of AR.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the design patterns and core components of an interactive AR application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the foundation of our AR menu application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding interactivity to our AR menu application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully participate in and benefit from the AR application development process
    detailed in this chapter, there are several technical requirements your hardware
    must meet. If you followed along with the project we built in [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011),
    you can skip these requirements, so long as your Unity setup hasn’t changed.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure you can follow along with the content and examples in this book, confirm
    that your computer system can handle *Unity 2021.3* LTS or a more recent edition,
    including Android or iOS Build Support.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, as we delve into the fascinating world of AR, it is helpful to
    have either an Android or iOS device that can support *ARKit* or *ARCore*. You
    can check the compatibility of your device at [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices).
  prefs: []
  type: TYPE_NORMAL
- en: However, if you don’t have a device that fits these requirements, you can still
    participate in these tutorials and test your application on your PC. The *Deploying
    AR experiences onto mobile devices* section of [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011)
    detailed how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the design patterns and core components of an interactive AR application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will delve into the commonly used design patterns and applications
    of AR, equipping you with the knowledge to choose the appropriate use case for
    your AR application. This includes familiarizing yourself with the core concepts
    and integral components of the AR menu application that we will construct in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the right applications for interactive AR apps is essential before
    embarking on your journey to develop your first full-fledged AR application. Let’s
    take a look at the various types of AR apps that currently exist, highlighting
    the different ways they enhance the user experience. Not only will this give you
    a clearer picture of the current state of AR applications, but it will also shed
    light on what types of AR experiences resonate most with users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at these different kinds of applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AR gaming apps**: Games such as Pokémon Go and Minecraft Earth are popular
    examples of AR apps. They place virtual objects such as creatures or blocks into
    the user’s real-world surroundings. Interaction is usually done through touchscreen
    commands, with the game responding to physical location data from the device’s
    GPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AR navigation apps**: Apps such as Google Maps Live View and CityViewAR overlay
    directional cues and points of interest onto real-world images. These apps use
    GPS data and device orientation to decide which AR elements to show and where.
    These elements can include arrows, labels, and even 3D models of buildings. Users
    primarily interact by moving and looking around. Some apps also allow users to
    touch screen elements for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AR shopping apps**: IKEA Place and Amazon AR View let users visualize products
    in their own homes before buying. These apps access the users’ camera feeds so
    that they can place 3D models of products in their rooms. Advanced apps use environmental
    understanding to place objects on surfaces and scale them correctly. Users move
    around to view the product from different angles and use touch commands to select
    different items, change colors or features, and make a purchase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AR education apps**: Apps such as Star Walk 2 and AR Anatomy Learning are
    designed to provide immersive, interactive learning experiences. These apps often
    use image recognition to anchor 3D models such as a star system or a human organ
    to specific locations in the real world. Users can interact with the 3D models
    through touch commands, for example, to rotate the model or activate animations.
    Users may also move around to view the model from different angles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These different AR applications may cater to different user groups and industries,
    but they share a core pattern: projecting 3D models into real-world contexts using
    AR. These apps use the camera feed, device orientation, and GPS data to position
    and scale the 3D models. User interaction is achieved through touch commands or
    physical movement, with the interaction often centered on manipulating specific
    features of the 3D models. This pattern, which emphasizes simplicity and focus,
    is the current standard in AR app development and will serve as our blueprint
    for the interactive AR app we’ll discuss in this chapter. It’s also a pattern
    we recommend for our own AR projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the goal is not to force AR functionality into an app but to use
    it where it enhances user experience. For instance, using AR to display a restaurant
    menu on a table might seem novel, but it doesn’t necessarily add value for the
    user. A traditional 2D app or physical menu would serve the same purpose. However,
    if you create an AR experience where users can visualize each dish on the table,
    scaled to the actual serving size, the user gets a clear sense of what to expect.
    This enhances the dining experience and overall satisfaction, showing how AR can
    create meaningful and beneficial interactions when applied appropriately. And
    this is exactly what we are going to create in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s proceed and build the foundation of our AR menu
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the foundation of our AR menu application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start crafting this AR menu application, you’ll set the groundwork for
    your AR project by assembling the essential components. The following sections
    will guide you through the process of sourcing and importing a variety of dishes
    from the Unity Asset Store and adding UI buttons and text elements to your scene,
    providing the basis for your interactive AR menu application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the key components of our AR application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will be building an AR application that allows
    users to place 3D models of food items that have been detected by their mobile
    device’s camera onto real-world surfaces. Before we get into the project, it is
    always good to visualize the functionality of the app we are going to create.
    Our AR application will consist of several key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AR Session and AR Session Origin**: These are the primary components for
    any AR Foundation application. These form the stage for our performance. For an
    in-depth understanding of AR Session Origin and AR Session, you’re invited to
    revisit the *Exploring the AR Session Origin GameObject* and *Understanding the
    AR Session GameObject* sections of [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AR Raycast Manager and AR Plane Manager**: These components come by default
    with AR Session Origin. AR Raycast Manager performs raycasts against tracked AR
    features and geometry, such as detected planes. We’ll use it to find where we
    can place our 3D models in the real world. AR Plane Manager, on the other hand,
    allows you to detect and track horizontal and vertical surfaces in the real world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Food prefabs**: These are 3D models of food items that users can place in
    the real world. They are the tangible objects that the user will interact with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI buttons and text elements**: These UI elements are needed to guide the
    user on how the app works, to swap the current food prefab to the next or previous
    one in line, and to display nutritional information for each dish. Consider these
    UI elements as the interactive elements of our application where the users can
    participate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ARPlacePrefab script**: This is our main script, and it’s responsible
    for managing the placement of the 3D models and a UI button in the AR space. It
    also handles the user interactions for placing objects and updates the placement
    indicator based on AR raycast results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The SwapPrefab script**: This script works in conjunction with the **ARPlacePrefab**
    script to switch between different food prefabs when the UI button is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Food`, which enables us to create `Food` objects with certain characteristics
    or properties, such as a name, ingredients, calories, and diet type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By implementing these components, we will have a working AR application that
    lets users place, view, and swap different 3D models of food in their real-world
    environment using their smartphone in place of a traditional printed menu. To
    ensure that the users understand what they are supposed to do in this application,
    dedicated UI elements will be added to the start scene of the application. By
    using visual cues such as grids, the process of finding the optimal position to
    place a dish will be facilitated for the user. By adding a scaling functionality,
    the user will be able to adjust the size of the displayed dish for an enhanced
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will set up our AR application so that we’re one
    step closer to building an interactive AR app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To initiate our journey, let’s start by creating a new project, as explained
    in the *Creating an AR project with Unity’s AR template* section in [*Chapter
    4*](B20869_04.xhtml#_idTextAnchor011). If you’ve already completed these steps,
    you can simply open the existing project for this chapter. After your project
    loads, follow this step-by-step guide to set up your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s kick-start the process by crafting a new empty scene. This can be achieved
    by going to `ARFoodMenu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A quick double-click will transport you into your newly minted scene, which
    currently only houses **Main Camera** and **Directional Light**. **Main Camera**
    can be removed as it won’t be needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before diving into the AR setup, it’s important to lay the groundwork for our
    AR app. In our situation, this means incorporating **AR Session Origin** and **AR
    Session**. You can accomplish this by right-clicking in the **Scene Hierarchy**
    window, choosing **XR** | **AR Session Origin**, and repeating the same step for
    **AR Session**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once `AR Plane Manager` script, and select it. Repeat this process for the **AR
    Raycast** **Manager** script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ARPlane` and drag the prefab into the **Plane Prefab** cell of the **AR
    Plane Manager** script component in the **Inspector** window. As we just want
    to detect horizontal planes for our AR menu application, select **Horizontal**
    for **Detection Mode**. We don’t need to assign any prefabs for **AR Raycast Manager**
    as we just need the functionality to calculate when the ray encounters the surface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there you have it! With a few clicks, we’ve added **AR Session**, **AR Session
    Origin**, **AR Raycast Manager**, and **AR Plane Manager** to our scene. Our next
    move is to import food models from the Asset Store, which will showcase the meals
    we aim to present to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Designing 3D food models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a restaurant proprietor, you need to produce 3D models of your meals at
    this stage. The following are a few strategies you could employ to design 3D models
    of food or dishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**3D modeling software**: There are many 3D modeling software tools you can
    use to create 3D models. These include *Blender*, *3ds Max*, *Autodesk Maya*,
    and *SketchUp*. Among these, *Blender* is a popular choice because it’s free and
    open source. There are many online tutorials available to help beginners get started
    with *Blender*, such as *CGFastTrack*’s YouTube channel ([https://www.youtube.com/@CGFastTrack/featured](https://www.youtube.com/@CGFastTrack/featured)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Photogrammetry**: Photogrammetry is a technique where you take multiple photographs
    of an object from different angles and then use software to stitch them together
    into a 3D model. Tools such as *Luma Labs*, *Reality Capture*, *Meshroom*, and
    *Agisoft Metashape* can help with this. For food models, this can give a very
    realistic result, but it may also be more complex to get right, particularly with
    foods that are uniform in color or texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download pre-made 3D models**: If creating models is too time-consuming or
    outside your current skill set, you can download pre-made models from sites such
    as *Sketchfab*, *TurboSquid*, or the *Unity Asset Store*, which is what we will
    do for this project. Just make sure you check the licensing terms to see if they
    fit your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hire a 3D artist**: If you have a budget for your project, you might consider
    hiring a 3D artist to create custom food models for you. This can give you exactly
    what you want, tailored to your specifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we pointed out previously, we are going to import our models through the
    Unity Asset Store for the sake of this AR menu application. Follow these instructions
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Unity Asset Store ([https://assetstore.unity.com/](https://assetstore.unity.com/))
    and search for the `French Fries – Free` package. Alternatively, you can access
    the **French Fries** package page via this link: [https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017](https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the package to your assets, click the **Open in Unity** button
    that now appears on the Asset Store’s website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your Unity project should open, and you should be prompted with the option to
    import the package. Click the **Import** button to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the package has been successfully imported into your project, repeat the
    previous three steps for the **Japanese Food Tofu – FREE** package ([https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533](https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533))
    and the **Japanese Food Kashipan – FREE** package ([https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938](https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve imported the appropriate food meals into our scene, we fulfilled
    the food prefabs requisite. In the next section, we will add the UI button and
    text components that will guide the user through the AR menu application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding UI buttons and text elements to our AR menu application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll focus on integrating three buttons and two text elements
    into our scene. These buttons are divided into one for initiating the app and
    two for transitioning between the dishes. The first text element serves to guide
    the user through the AR menu application, while the second acts as a placeholder
    to contain information about the displayed dish, such as its name, ingredients,
    caloric content, and dietary type.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding the second text element, these UI elements should remain within the
    user’s field of view, regardless of how the device is rotated. This can be accomplished
    by assigning them as child objects to the AR camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the two dish-swapping buttons. Follow these steps to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Scene Hierarchy** window, right-click on the **AR Camera**
    component, and select **UI** | **Canvas**. This action will add **Canvas** as
    a child object of **AR Camera**. The **Canvas** component is necessary for all
    UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alter the Canvas’s `0.01`, `0.01`, `0.01`) with `480` and `90`. Position the
    `0`,`0`,`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the buttons by right-clicking on the `ButtonNext` and `ButtonPrevious`.
    Rescale both buttons to (`0.07`, `0.32`, `1`) with `160` and `30`. Position `10`,`40`,`0`)
    and `-10`, `40`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the child objects of both buttons, enter arrows such as `->` and `<-` as
    the text input in the **Inspector** window. These arrows tell the user which button
    switches to the next or previous dish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, the two buttons have been fully initialized. Next, we need to
    create an instructional piece of text to guide users on how to use the AR menu
    application. To achieve this, follow these step-by-step instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on `0.17`, `0.17`, `0.17`). Adjust the panel top to `-46.5` and
    the panel bottom to `-3.4`. This panel will act as a backdrop for our text. You’re
    free to choose its color; in our case, we chose red. Rename this panel `InfoPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the instructional text, right-click `InstructionText`. Adjust its scale
    to (`0.7`, `0.7`, `0.7`) with `600` and `150`; then, position it at (`0`, `0`,
    `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input the following text: `Wait until the blue surface is visible. This shows
    the area where the food is placed`. This instruction will be critical for the
    user as we’ll implement a blue grid area that indicates where the food prefabs
    will be placed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent the user seeing a meal directly when the application starts, create
    another button below the instruction text. This button is responsible for spawning
    the first dish. To do this, right-click `PlaceFirstMealButton`, scale it to (`2.2`,
    `2.2`, `2.2`), and position it at (`0`, `-292`, `0`) with `160` and `30`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the child text component of `Place First Meal` as the text input in the
    **Inspector** window. Activate the **Active auto size** checkbox to make sure
    that the text is adjusted with the button. Both **InstructionText** and **PlaceFirstMealButton**
    are child objects of **InfoPanel**. They are designed to disappear after the first
    meal is placed. This means we only need to target **InfoPanel** in our code instead
    of all three objects individually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we require another text element, but this time, it should not be a child
    object of **AR camera**. This text needs to spawn above the dishes and remain
    there consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, let’s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another `0.1`, `0.1`, `0.1`) and position it at (`0.3`, `0.3`, `1`) with
    `480` and `90`. Rename this `FoodInfoCanvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click `FoodInfoText`, scale it to (`0.005`, `0.005`, `0.005`), and position
    it at (`-3.4`, `0`,`31`, `0`) with `200` and `50`. **FoodInfoText** does not need
    text input as this will be assigned programmatically in correspondence with the
    displayed dish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, your **Scene Hierarchy** window should look like what is shown
    in *Figure 6**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.1 – \uFEFFOur project’s Scene Hierarchy window, showcasing all components\
    \ in our scene](img/B20869_06_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Our project’s Scene Hierarchy window, showcasing all components
    in our scene
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, all your UI elements should be aligned in your Game view, as shown
    in *Figure 6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.2 – \uFEFFOur project’s Game view, showcasing the alignment of the\
    \ different UI elements in the scene](img/B20869_06_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Our project’s Game view, showcasing the alignment of the different
    UI elements in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Please note that all UI elements are positioned and scaled concerning the **Canvas**
    component. If your UI elements have a different alignment to the one shown in
    *Figure 6**.2*, you can manually adjust the position and scale of your **Canvas**
    component.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully added all the necessary UI elements to our scene
    and therefore finished adding UI buttons and text elements to create an interactive
    AR application. Next, we’ll add scripts to our scene to introduce some interactivity
    and life to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactivity to our AR menu application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To infuse life into our currently modest AR scene, we must incorporate some
    C# scripts into our project. This key step will empower the users of our AR app,
    allowing them to interact with our imported food prefabs dynamically and engagingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will get an overview of the short but decisive **Food**
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Food script to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into scripting, let’s first organize our project workspace so
    that we can work more efficiently by finding the needed components quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding a new folder to the `Assets` directory in the `Scripts` and
    enter it. Right-click in this empty folder and select `Food`. After double-clicking
    on this script, it should be opened in your preferred **integrated development**
    **environment** (**IDE**).
  prefs: []
  type: TYPE_NORMAL
- en: The `Food` objects that are created will have certain characteristics or properties,
    just like how every car has a make, model, and color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple breakdown of this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`[System.Serializable]` is a directive that tells Unity to make this class
    serializable. This means that Unity will be able to save and load `Food` objects
    and that you’ll be able to edit `Food` objects directly in the Unity editor.'
  prefs: []
  type: TYPE_NORMAL
- en: After defining a new, public class called `Food`, a public property called `name`
    is declared. This property represents the name of the food, such as `French Fries`.
    Next, we declare additional properties such as `ingredients`, `calories`, and
    `dietType`. The latter property stores the type of diet the food fits into, such
    as `Vegetarian`, `Vegan`, or `Paleo`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, a public property that will hold a `GameObject` is declared that represents
    the 3D model of the food that will be displayed in the AR environment.
  prefs: []
  type: TYPE_NORMAL
- en: As we venture into the next section, we’ll continue our journey by incorporating
    the most pivotal C# script in our scene – the **ARPlacePrefab** script. It is
    this crucial component that will truly open the doors of interactivity within
    our AR menu application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ARPlacePrefab script to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous scripts we created in this chapter, navigate to the
    `Assets` folder in the `ARPlacePrefab`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We highly recommend that you clone the [*Chapter 6*](B20869_06.xhtml#_idTextAnchor020)
    project, which can be found in the GitHub repository of this book, and open it
    in parallel, enabling you to revisit and mimic the steps described in this project
    tutorial more easily.
  prefs: []
  type: TYPE_NORMAL
- en: We can open the just-created `ARPlacePrefab` script by double-clicking on it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The script will launch in the default IDE that you usually utilize. If you wish
    to switch to a different IDE, simply go to **Edit** | **Preferences** in the Unity
    editor. In the newly opened **Preferences** window, navigate to the **External
    Tools** tab and alter **External Script Editor** to the IDE of your preference.
  prefs: []
  type: TYPE_NORMAL
- en: The `ARPlacePrefab` script, as previously highlighted, will serve as our primary
    script. It carries out the crucial role of handling the placement of the 3D models
    and UI buttons within the AR space. Moreover, it manages user interactions so
    that it can position objects and dynamically update the placement indicator based
    on AR raycast outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the various methods and functions in the `ARPlacePrefab`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ARPlacePrefab script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the `ARPlacePrefab` script is the core of our AR menu application, we must
    understand every method of it to truly grasp the mechanisms of interactive AR
    experiences and successfully replicate the script’s functionality in a wide range
    of projects and contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code snippets, you’ll notice some lines that have been commented
    out. This is because they reference the **SwabPrefab** script, which hasn’t been
    created yet, and would result in compile errors if left uncommented.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `ARPlacePrefab` script, various public and private variables
    are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The public variables of the `ARPlacePrefab` script allow users to interact with
    the AR space, such as positioning `ObjectToPlace` or cycling between 3D models
    using `NextPrefabButton` and `PreviousPrefabButton`. They also enable users to
    view details via `InfoText` and `InfoPanel`, as well as activate specific AR placements
    with `PlaceFirstMealButton`. Additionally, they provide a space for extended details
    or options.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the private variables govern the internal mechanics of the
    AR experience. `_arRaycastManager` handles surface detection in the real-world
    environment, while `_placementPose` denotes the desired position for the AR object.
    Its validity is tracked by `_placementPoseIsValid`. Once an object is placed in
    the AR space, it’s referred to as `_placedObject`. Touch gestures utilize `_oldTouchDistance`.
    Lastly, `_placementIndicator` and `_placementGrid` offer visual cues to users,
    indicating where an AR object will be positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Some lines, related to the yet-to-be-introduced **SwapPrefab** script, have
    been commented out to prevent any compilation issues. We will uncomment them toward
    the end of our scripting process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method of the `ARPlacePrefab` script is the `Start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function is called when the program first starts. It’s where the initial
    setup for the script is done, such as finding the `_nextButton` and `_previousButton`
    have been commented out because they reference the yet-to-be-created **SwapPrefab**
    script. This script is associated with the two buttons that enable users to cycle
    through various food choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method that is called in the `ARPlacePrefab` class is the `Update()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Update()` method is like the heartbeat of the script, constantly checking
    on things every moment the game is running. If a two-finger touch input is detected,
    it adjusts the scale of the placed object based on how much the distance between
    the fingers changes, similar to a pinch or stretch movement. It also updates the
    placement pose and indicator, which determines where the object will be placed,
    and listens for a single touch input. If a single touch input is detected, it
    places the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaceObject()` method follows after the `Update()` method and looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function is called when a single touch input is detected in the `Update()`
    function. It places the selected object in the real world at the location determined
    by the placement pose. It also positions and activates the next and previous buttons.
    Then, it fetches some information about the currently selected food item and updates
    the `InfoText` UI with this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method in the `ARPlacePrefab` class is the `UpdatePlacementPose()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method is called in the `Update()` function. It acts like the script’s
    eyes in the sense that it’s always looking at the middle of your screen and figuring
    out where in the real world that corresponds to in the virtual world. This method
    updates the placement pose, which is the position and orientation where the new
    object will be placed. It does this by casting a ray from the center of the screen
    and checking if it hits a plane in the AR environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UpdatePlacementIndicator()` method works similarly to the `UpdatePlacementPose()`
    method and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function is also called in the `Update()` function. It simply moves and
    rotates the placement indicator to match the placement pose, showing the user
    where the object will be placed. It also turns `LineRenderer` on or off, depending
    on whether a suitable location for placing the object was found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is called `InstantiateButton()` and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InstantiateButton` method serves as a vital cog in the `ARPlacePrefab`
    class. Its primary role is to create and set up the buttons that users interact
    with to navigate between food choices. When invoked, the method takes in two parameters:
    a button prefab and an action to be executed upon clicking the button.'
  prefs: []
  type: TYPE_NORMAL
- en: The method begins by creating a new instance of the button using the provided
    prefab. Once instantiated, the button is initially set to be inactive, ensuring
    it doesn’t immediately appear or interfere with the user interface. Then, the
    method fetches the button’s built-in **On Click** event and attaches the specified
    action to it, ensuring the desired function is executed when the button is pressed.
    Finally, the newly created and configured button is returned by the method, ready
    for use in the AR interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two methods in the script act as helper functions. They are called
    `CreatePlacementGrid()` and `PlaceObjectIfNeeded()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreatePlacementGrid()` method creates a little grid in the virtual world
    to help you see where your dish will be placed before you place it. If everything
    has been set up correctly, the `PlaceObjectIfNeeded()` method places the food
    prefab in the virtual world and then hides `InfoPanel`, cleaning up your screen.
    Pay attention to the following line in the `CreatePlacementGrid()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assign a `grid` so that the user sees a visual cue of where the food
    prefab will be placed. Besides using the Unity editor’s interface, C# scripting
    provides us with another way to assign materials to `GameObject` – that is, by
    defining the precise path and name of the material that we want to use. In this
    case, a material named `GridMaterial` is expected to be in the `Resources` folder
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing with the next few methods, let’s quickly create a material
    called `GridMaterial` in the `Resources` folder of our project. Simply head to
    the `Assets` folder, and select `Resources` and enter it. Right-click inside this
    folder and select `GridMaterial` and select a blue albedo color of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in the `ARPlacePrefab` class, let’s have a look at the `PinchToScale()`
    and `ScalePlacedObject()` methods, which look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As the names of these two methods already suggest, they enable the zoom feature
    of the food prefabs. The `PinchToScale()` method checks whether you’re using two
    fingers to pinch the screen, and if you are, it changes the size of your placed
    object by calling the `ScalePlacedObject()` method. This functionality is very
    useful in the context of our AR menu application as it enables the user to scale
    the displayed food prefab to the desired size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PositionButton()` method provides another useful functionality for application
    users. It consists of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `PositionButton()` method ensures the next and previous buttons are always
    near your placed object so that you can easily press them. Hence, this method
    is fundamental to ensure a satisfying user experience of the AR menu application
    across different devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UpdateFoodInfoText()` method is another integral part of the`ARPlacePrefab`
    class. Let’s see what the method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve placed a food prefab in the environment, the `UpdateFoodInfoText()`
    method tells you more about this specific dish, such as its name, ingredients,
    how many calories it has, and which diet it aligns with. As before, the initial
    lines have been commented out due to their reference to the yet-to-be-created
    **SwapPrefab** script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is only one small script left for you to understand in the `ARPlacePrefab`
    class. It’s the `PositionGrid()` method and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method simply moves the placement grid to the right spot in the virtual
    world so that it matches where your indicator is pointing in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have successfully understood the `ARPlacePrefab` script, which
    is the primary script that’s used in our AR menu application. In the next section,
    you will learn how to attach this script to **AR Session Origin** as a component.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the ARPlacePrefab script as a component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By attaching the main script of any AR application to `ARPlacePrefab` script
    as a component of **AR Session Origin** in the **Inspector** window in the Unity
    editor before progressing to the next step. To do this, simply follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `ARPlacePrefab` script. By selecting it, the script’s public fields are
    shown in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Object to Place** field, you can assign one of the food prefabs, such
    as **Tofu**, by dragging and dropping it from the **Project** window into the
    corresponding cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the same principle, you can drag and drop **ButtonNext** into the
    **Next Prefab Button** cell, **ButtonPrevious** into the **Previous Prefab Button**
    cell, **FoodInfoText** into the **InfoText** cell, **PlaceFirstMealButton** into
    the **Place First Meal Button** cell, and **InfoPanel** into the **Info** **Panel**
    cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **SwapPrefab** cell expects the **SwapPrefab** script, which we are going
    to create and assign in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations – you have successfully fulfilled the `ARPlacePrefab` script
    requirement on our roadmap to create an interactive AR menu application! In the
    next section, you will come even closer to the final application by delving into
    the script that swaps our food prefabs: the **SwapPrefab** script.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SwapPrefab script to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the `Assets` folder in the `SwapPrefab`. Double-click on the script to
    open it in your preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SwapPrefab` script is tied to the two buttons that allow the user to cycle
    through different food options. It starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see the declaration of a list of `Food`
    objects called `AvailableFoods`, a variable to keep track of the current food
    called `currentFoodIndex`, and a reference to the `ARPlacePrefab` script called
    `ARPlacePrefab`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at the methods of the `SwapPrefab` class to understand
    how the user can cycle through the different dishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method that is relevant for this is the `Start()` method. It looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when the scene starts. It grabs a reference to the `ARPlacePrefab`
    script and sets the first food object in the list as the one to be placed in the
    AR environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, there is the `SwapFoodPrefab()` method, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This method is linked to a button. When the button is clicked, it advances `currentFoodIndex`
    to the next food in the list or back to the start if it’s at the end and updates
    `objectToPlace` in the `ARPlacePrefab` script to the new food. Then, it immediately
    places the new food object in the AR environment and updates the displayed information
    about the food.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SwapToPreviousFoodPrefab()` method in the `SwapPrefab` class consists
    of the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method works similarly to `SwapFoodPrefab()`, but it goes back to the previous
    food in the list instead of moving forward. If it’s already at the start of the
    list, it loops back to the end. Like `SwapFoodPrefab()`, it then immediately places
    the new food object and updates the displayed information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, there is the short `GetCurrentFood()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple helper method that other parts of the program can call to find
    out what the current food is.
  prefs: []
  type: TYPE_NORMAL
- en: Remember those lines we commented out in the `ARPlacePrefab` script because
    they referenced the `SwapPrefab` script? Now is the time to go back to the `ARPlacePrefab`
    script and uncomment those lines. Once you’ve done this, we can dive into the
    last missing snippets of our AR menu application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up On Click events for the buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to link `SwapPrefab` script by adding **On Click** events to both.
    Follow these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to attach the `SwapPrefab` script to a `GameObject` object in our scene.
    We can do this by creating an empty `GameObject` object in the `GameObject` to
    `PrefabManager` and attach the `SwapPrefab` script to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we must link `SwapPrefab` script. Let’s start with `PrefabManager` `GameObject`
    into the object cell. In the drop-down menu, select the `SwapPrefab` | `SwapFoodPrefab()`
    function. This calls the `SwapFoodPrefab()` function of the `SwapPrefab` script,
    whenever **ButtonNext** is pressed. *Figure 6**.3* shows what the **On Click**
    event of **ButtonNext** should look like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 6.3 – \uFEFFButtonNext’s On Click event](img/B20869_06_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – ButtonNext’s On Click event
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for `SwapPrefab` | `SwapToPreviousFoodPrefab()` function
    from the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do you remember the takeaway from the *Assigning the ARPlacePrefab script as
    a component* section in that the `SwapPrefab` script is the last missing cell
    input of the `ARPlacePrefab` script that is attached to `SwapPrefab` script to
    this cell. You can do this in a few, simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **AR Session Origin** in the **Scene** **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `SwapPrefab` via the search bar of the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag and drop the script into the respective cell of the AR Session Origin’s
    `ARPlacePrefab` script component in the `ARPlacePrefab` script component should
    look like now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 6.4 – \uFEFFThe ARPlacePrefab script component of AR Session Origin\
    \ once all of its cells have been correctly assigned](img/B20869_06_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The ARPlacePrefab script component of AR Session Origin once all
    of its cells have been correctly assigned
  prefs: []
  type: TYPE_NORMAL
- en: 'Before testing the scene on your PC or deploying it to your phone, there is
    one last step you have to take: add some nutritional information to our food prefabs.
    This can be done very easily:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **PrefabManager** in the **Scene Hierarchy** window and navigate to the
    **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `SwapPrefab` script component, click the **+** button three times to
    add three dishes to our AR menu application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the names, nutritional information, diet type, and prefabs of our three
    dishes, namely **French Fries**, **Tofu**, and **Kashipan**, into the respective
    cells, as shown in *Figure 6**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 6.5 – \uFEFFThe inserted names, nutritional information, diet type,\
    \ and prefabs of our three dishes in the PrefabManager’s SwapPrefab script component](img/B20869_06_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The inserted names, nutritional information, diet type, and prefabs
    of our three dishes in the PrefabManager’s SwapPrefab script component
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have completed the final step in our roadmap to create an interactive
    AR menu application. To celebrate this milestone, the next section explains how
    you can explore the different features of your newly developed AR application
    on your mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the completed, interactive AR menu application on a mobile device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test your interactive AR menu application on your PC or deploy it onto your
    mobile device, please refer to the step-by-step instructions provided in the *Deploying
    AR experiences onto mobile devices* section of [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011).
    *Figure 6**.6* shows you what should be displayed on your screen once you have
    successfully deployed the AR menu application onto your mobile device and opened
    it.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.6 – \uFEFFThe initial screen of the newly deployed AR menu application\
    \ on a mobile device](img/B20869_06_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The initial screen of the newly deployed AR menu application on
    a mobile device
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we can see the instruction text, which familiarizes the user with
    the nature of the application, and the button at the bottom of the application,
    which the user has to press to place the first dish on the detected plane. You
    can also see the two buttons that the user can press to see the next or previous
    prefab. If there is a horizontal plane in your scene, you will see the blue placement
    grid element in the center of your screen.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.7* shows what the screen of your device should look like once you
    have pressed the **Place First** **Meal** button.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.7 – \uFEFFThe screen of the AR menu application on a mobile device\
    \ once the “Place First Meal” button has been pressed](img/B20869_06_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The screen of the AR menu application on a mobile device once the
    “Place First Meal” button has been pressed
  prefs: []
  type: TYPE_NORMAL
- en: By touching the screen with two of your fingers and moving them closer together
    or further apart, you can scale the **French Fries** to become bigger or smaller.
    By changing the rotation of your mobile device after the first food prefab has
    been placed and clicking on the **->** button, the next food prefab should be
    placed at the new position, as indicated by the blue placement grid element.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming section offers a summary of the valuable skills you’ve acquired
    in your journey to create XR applications in Unity. Specifically, you’ve harnessed
    the power of C# scripting to craft interactive AR applications. This newfound
    expertise marks a significant enhancement to your repertoire, expanding your capacity
    to develop sophisticated XR experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ve embarked on the exciting journey of building
    your very first interactive AR application, testing it meticulously on your mobile
    device. This experience should have empowered you to evaluate prospective AR app
    ideas critically in terms of their utility.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging intuitive design patterns, you should now feel equipped to create
    engaging AR applications that allow users to interact seamlessly with virtual
    objects within a real-world context. From establishing the core components of
    the AR app, such as user interface and text elements, to invoking their interactivity
    through C# scripting, you’re now well-equipped to create a diverse array of interactive
    AR applications.
  prefs: []
  type: TYPE_NORMAL
- en: These applications will breathe life into virtual objects placed within real-world
    environments, inviting users to interact with them in significant and captivating
    ways. Congratulations on reaching this milestone in your AR development journey.
    You are now more than capable of bringing your creative AR ideas to life.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward, the next chapter promises to elevate your VR development skills
    to a new level. It’s all about adding magic to your VR scenes through audio and
    visual effects. The upcoming chapter will delve into the theory of audio in Unity,
    guide you through the process of incorporating audio sources and mixers, and unveil
    the secrets of adding particle effects and animations to your VR experiences.
    The road ahead is set to be an exciting journey of discovery and application.
  prefs: []
  type: TYPE_NORMAL
