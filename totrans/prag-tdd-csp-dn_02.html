<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor037"/>2</h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor038"/>Understanding Dependency Injection by Example</h1>
<p><strong class="bold">Dependency injection</strong> (<strong class="bold">DI</strong>) is a software design pattern that exists in every modern architecture. However, you may wonder how this pattern found its way into the second chapter of a <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>)-focused book.</p>
<p>DI is a pattern that has several benefits that we are going to discover throughout the book, though the core benefit is that <em class="italic">DI opens an application for unit testing</em>. We cannot exercise unit testing without a solid understanding of this pattern, and if we cannot unit test, by virtue, we cannot practice TDD. Considering this, DI understanding forms the foundation of <em class="italic">Section 1</em>, <em class="italic">Getting Started and Basics</em>, and <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, which explains the early introduction.</p>
<p>We will build an application and then modify it to support DI while learning the concepts, but the ideas in this chapter will be repeated and exercised throughout this book.</p>
<p>In this chapter, you will be exploring these topics:</p>
<ul>
<li>The <strong class="bold">weather forecaster application</strong> (<strong class="bold">WFA</strong>)</li>
<li>Understanding dependency</li>
<li>Introducing DI </li>
<li>Using DI containers</li>
</ul>
<p>By the end of this chapter, the application will be unit test-ready by having the necessary DI changes implemented. You will have a fair understanding of dependency and will have gained confidence in refactoring code to support DI. You will have also covered half the way to write your first proper unit test.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch02">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch02</a></p>
<p>There, you will find four directories. Each one will be a snapshot of our progress.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>The WFA</h1>
<p>Throughout this chapter, we will be<a id="_idIndexMarker075"/> using an <strong class="bold">ASP.NET Web API</strong> application in our learning process. We will be refactoring all the code in this application to enable DI. Then, in <a href="B18370_03.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting Started with Unit Testing</em>, we will apply unit tests on the refactored application.</p>
<p>When a new ASP.NET Web API application is created, it comes with a sample random weather forecaster. The application in this chapter will build on top of the original weather sample and will add a real weather forecasting capability to the existing random one. We will creatively call our application the WFA. </p>
<p>The first step is going to be creating a WFA application and making sure it is running.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Creating a sample weather forecaster</h2>
<p>To create a sample application, navigate<a id="_idIndexMarker076"/> your console to the directory where you want to create this application and execute the following commands:</p>
<pre>md UqsWeather
cd UqsWeather
dotnet new sln
dotnet new webapi -o Uqs.Weather -f net6.0
dotnet sln add Uqs.Weather</pre>
<p>The preceding code will<a id="_idIndexMarker077"/> create a <code>UqsWeather</code> and will add an ASP.NET Web API project to it. This will produce a similar output to this console window:</p>
<div><div><img alt="Figure 2.1 – The output of creating a weather application via the command-line interface (CLI) " height="659" src="img/Figure_2.1_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The output of creating a weather application via the command-line interface (CLI)</p>
<p>To check what we have<a id="_idIndexMarker078"/> created, go to the directory and open the solution using VS, and you will see the following:</p>
<div><div><img alt="Figure 2.2 – Newly created project opened in VS " height="774" src="img/Figure_2.2_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Newly created project opened in VS</p>
<p>What is interesting here is the sample files that were generated automatically: <code>WeatherForecast Controller.cs</code> and <code>WeatherForecast.cs</code>.</p>
<p>This is the default template; we<a id="_idIndexMarker079"/> haven’t done any modification yet. It would make sense to check whether, so far, the application is loading properly. You can run the application and it will launch your default browser with<a id="_idIndexMarker080"/> the Swagger UI interface. We can see the only available <code>GET</code> <code>WeatherForecast</code>, as illustrated in the following screenshot:</p>
<div><div><img alt="Figure 2.3 – Swagger UI showing the available GET API " height="378" src="img/Figure_2.3_B18370.jpg" width="702"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Swagger UI showing the available GET API</p>
<p>To manually call this API and check whether it is generating output, from the Swagger UI page, expand the down<a id="_idIndexMarker081"/> arrow on the right of <strong class="bold">/WeatherForecast</strong>. Hit <strong class="bold">Try it out</strong>. Then, hit <strong class="bold">Execute</strong>. You will get a response like this:</p>
<div><div><img alt="Figure 2.4 – Swagger API call response " height="510" src="img/Figure_2.4_B18370.jpg" width="760"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Swagger API call response</p>
<p>You can find this sample under the GitHub chapter directory, in a directory called <code>01-UqsWeather</code>. Now, it’s time to make the application a bit realistic by adding a real forecasting feature.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Adding a real weather forecaster</h2>
<p>The template app <a id="_idIndexMarker082"/>has a sample random weather generator. I decided to give the app a spin by adding a real weather forecast as <a id="_idIndexMarker083"/>well. For this, I am going to use a weather service called <em class="italic">OpenWeather</em>. <em class="italic">OpenWeather</em> provides a free RESTful API weather service (where <strong class="bold">REST</strong> stands for <strong class="bold">REpresentational State Transfer</strong>) and will act as a<a id="_idIndexMarker084"/> more realistic example.</p>
<p>I have also created a public NuGet package to serve the chapter and act as a client for the <em class="italic">OpenWeather</em> RESTful APIs. So, rather than dealing with the REST API calls, you call a C# method, and it does the RESTful API calls in the background. In the following sections, we will obtain an API key and write the <code>GetReal</code> API.</p>
<h3>Getting an API key</h3>
<p>To be able to run the <a id="_idIndexMarker085"/>application from the companion source code or to create one yourself, you need an API key. You can sign up at <a href="https://openweathermap.org">https://openweathermap.org</a> and then obtain an API key. After signing up, you can generate a key by going to <strong class="bold">My API keys</strong> and hitting <strong class="bold">Generate</strong>, similar to this:</p>
<div><div><img alt="Figure 2.5 – Generating an API key " height="343" src="img/Figure_2.5_B18370.jpg" width="947"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Generating an API key</p>
<p>Once you have obtained the key, save it in your <code>appsettings.json</code> file, like this:</p>
<pre class="source-code">{
  "OpenWeather": {
    "Key": "yourapikeygoeshere"
  },
  "Logging": {
  …</pre>
<p>The API key is done. Let’s <a id="_idIndexMarker086"/>get a client library to access the API.</p>
<h3>Getting the client NuGet package</h3>
<p>There are many OpenWeather API client libraries; however, I chose to create one to specifically fit the <a id="_idIndexMarker087"/>requirements of this chapter. The code of the package and how it is tested are discussed in <a href="B18370_15.xhtml#_idTextAnchor326"><em class="italic">Appendix 2</em></a>, <em class="italic">Advanced Mocking Scenarios</em>. If you are curious and would like to check the source code, you can visit its GitHub repository at <a href="https://github.com/AdamTibi/OpenWeatherClient">https://github.com/AdamTibi/OpenWeatherClient</a>.</p>
<p>You can install the NuGet <a id="_idIndexMarker088"/>package via the VS <code>AdamTibi.OpenWeather</code> or via the .NET CLI, by going to the project directory and writing this:</p>
<pre>dotnet add package AdamTibi.OpenWeather</pre>
<p>The configuration is done, so now, we can modify the code.</p>
<h3>Mapping feeling to temperature</h3>
<p>Here is a simple method that<a id="_idIndexMarker089"/> will map the temperature in °C to a single word describing it:</p>
<pre class="source-code">private static readonly string[] Summaries = new[]
{
    "Fr<a id="_idTextAnchor043"/>eezing", "Bracing", "Chilly", "Cool", "Mild",
    "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
};
priva<a id="_idTextAnchor044"/>te string MapFeelToTemp(int temperatureC)
{
    if (temperatureC &lt;= 0) return Summaries.First();
    int summariesIndex = (temperatureC / 5) + 1;
    if (summariesIndex &gt;= Summaries.Length) return 
       Summaries.Last();
    return Summaries[summariesIndex];
}</pre>
<p>The output for <code>0</code> or less is <code>Freezing</code>, between <code>0</code> and <code>5</code> it is <code>Bracing</code>, then it is going to change every <code>5</code> degrees. <code>45</code> degrees onward, it is <code>Scorching</code>. Don’t take my word for the output—we will <a id="_idIndexMarker090"/>unit test it. Imagine if we didn’t!</p>
<h3>Random weather API</h3>
<p>I kept the random <a id="_idIndexMarker091"/>weather API, but I made it use the preceding <code>MapFeelToTemp</code> string, as follows:</p>
<pre class="source-code">[HttpGet("GetRandomWeatherForecast")]
public IEnumerable&lt;WeatherForecast&gt; GetRandom()
{
    WeatherForecast[] wfs = new 
        WeatherForecast[FORECAST_DAYS];
    for(int i = 0;i &lt; wfs.Length;i++)
    {
        var wf = wfs[i] = new WeatherForecast();
        wf.Date = DateTime.Now.AddDays(i + 1);
        wf.TemperatureC = Random.Shared.Next(-20, 55);
        wf.Summary = <strong class="bold">MapFeelToTemp</strong>(wf.TemperatureC);
    }
    return wfs;
}</pre>
<p>This is a trivial API generating a random temperature and then making a summary out of the generated temperature. We are generating <code>FORECAST_DAYS = 5</code> days, starting from the next day.</p>
<p>Running this project <a id="_idIndexMarker092"/>and hitting the Swagger UI output will give us this:</p>
<pre class="source-code">[
  {
    "date": "2021-11-26T22:23:38.6987801+00:00",
    "temperatureC": 30,
    "temperatureF": 85,
    "summary": "Hot"
  },
  {
    "date": "2021-11-27T22:23:38.7001358+00:00",
    "temperatureC": -15,
    "temperatureF": 6,
    "summary": "Freezing"
  },
…</pre>
<p>You can see how random the output is, as the next day is hot but the day after is freezing.</p>
<h3>Real weather API</h3>
<p>The real weather API <a id="_idIndexMarker093"/>should make more sense. This is the newly added API:</p>
<pre class="source-code">[HttpGet("GetRealWeatherForecast")]
public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetReal()
{
    …
    string apiKey = _config["OpenWeather:Key"];
    HttpClient httpClient = new HttpClient();
    Client openWeatherClient = 
       new Client(apiKey, httpClient);
    OneCallResponse res = await 
      openWeatherClient.OneCallAsync
        (GREENWICH_LAT, GREENWICH_LON, new [] {
            Excludes.Current, Excludes.Minutely,
            Excludes.Hourly, Excludes.Alerts }, 
            Units.Metric);
    …
}</pre>
<p>The method creates a <code>HttpClient</code> class for the sake of passing it to the <em class="italic">OpenWeather</em> <code>Client</code> class. It then<a id="_idIndexMarker094"/> fetches the API key and creates an <em class="italic">OpenWeather</em> <code>Client</code> class. To limit our scope, this will only forecast for Greenwich, London.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">The previous code is not clean and will be cleaned shortly in this chapter. If you really want to know the reason right now, it is instantiating (newing) the <code>HttpClient</code> and the <code>Client</code> classes in the controller, and this is not a good practice.</p>
<p>We are calling a RESTful <a id="_idIndexMarker095"/>API of <em class="italic">OpenWeather</em> called <strong class="bold">OneCall</strong>. This API returns today’s weather and forecasts 6 consecutive days; this is good as we only need the next 5 consecutive days. The Swagger UI output of this one is shown here:</p>
<pre class="source-code">[
  {
    "date": "2021-11-26T11:00:00Z",
    "temperatureC": 8,
    "temperatureF": 46,
    "summary": "Chilly"
  },
  {
    "date": "2021-11-27T11:00:00Z",
    "temperatureC": 4,
    "temperatureF": 39,
    "summary": "Bracing"
  },
…</pre>
<p>The best way to explain<a id="_idIndexMarker096"/> concepts is by example, so consider this test problem that will give you a firsthand experience of what DI is. </p>
<h3>C to F conversion API</h3>
<p>To have all the world <a id="_idIndexMarker097"/>come together and to keep everybody happy, we will add another method to convert °C to °F. We will have an API on our controller called <code>ConvertCToF</code>, and it looks like this:</p>
<pre class="source-code">[HttpGet("ConvertCToF")]
public double ConvertCToF(double c)
{
    double f = c * (9d / 5d) + 32;
    _logger.LogInformation("conversion requested");
    return f;
}</pre>
<p>This API converts a temperature from °C to °F and logs every time this API is requested, for statistical purposes. You <a id="_idIndexMarker098"/>can invoke this API from Swagger UI as before, or invoke it from the browser like this:</p>
<pre>https://localhost:7218/WeatherForecast/ConvertCToF?c=27</pre>
<p>The output will look like this:</p>
<div><div><img alt="Figure 2.6 – Results of executing the ConvertCToF API from the browser " height="191" src="img/Figure_2.6_B18370.jpg" width="802"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Results of executing the ConvertCToF API from the browser</p>
<p>This is a <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) diagram <a id="_idIndexMarker099"/>showing what we have so far:</p>
<div><div><img alt="Figure 2.7 – UML diagram showing the WFA application " height="513" src="img/Figure_2.7_B18370.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – UML diagram showing the WFA application</p>
<p>You can see all the changes in <code>WeatherForecastController.cs</code>; it is always in the <code>Ch02</code> source code in GitHub under a directory called <code>02-UqsWeather</code>.</p>
<p>The application is ready for critique, and I can tell you from now that the code you’ve just seen is not unit-testable. We can perform other categories of testing, but not unit testing, although it will be unit-testable by the end of this chapter. I invite you to open the project in VS and follow along, as we will implement exciting and important concepts. </p>
<p>Now that the project is ready, we<a id="_idIndexMarker100"/> need to set some basics right, and the first in the list is understanding dependency.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor045"/>Understanding dependency</h1>
<p>If your code does something useful, chances <a id="_idIndexMarker101"/>are your code depends on other code or another component, which in turn depends on another component. A clear understanding of the <strong class="bold">dependency</strong> terminology should give you a better grasp of unit testing and will definitely aid in having clearer conversations with your colleagues.</p>
<p>The plan in this section is to familiarize you with the concept of dependency, which should make understanding the DI pattern easier. Understanding dependency and DI are prerequisites for writing any serious unit testing. Next, we will explore what dependencies are, though when it comes to unit testing, we don’t care for all dependencies, so we will define what a relevant dependency is.</p>
<p>Before we dive into dependencies, let’s first define abstraction types and concrete types.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor046"/>Abstractions and concrete types</h2>
<p>To have you and me <a id="_idIndexMarker102"/>on the same channel, I will define the terminology to be used. </p>
<p>A concrete class is a class that can be instantiated; it could be something like this:</p>
<pre class="source-code"><strong class="bold">FileStream</strong> fileStream = new FileStream(…)</pre>
<p><code>FileStream</code> is a concrete type that can be instantiated and used directly in the code.</p>
<p>An abstraction type can be an abstract class or an interface. Examples of abstract classes are <code>Stream</code>, <code>ControllerBase</code>, and <code>HttpContext</code>. Examples of interfaces are <code>IEnumerable</code>, <code>IDisposable</code>, and <code>ILogger</code>.</p>
<p>I will be overusing these terms in the book, so it’s worth defining them.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor047"/>What is a dependency?</h2>
<p>First, what it isn’t: it is not <a id="_idIndexMarker103"/>equivalent to the same term used in UML.</p>
<p>In this book’s context and when speaking with other developers within unit testing boundaries, it can be defined in this way: if class A <em class="italic">uses</em> a type of B where B is an abstraction type or a concrete class, then A has a dependency on B. </p>
<p>The term <em class="italic">uses</em> can be narrowed down to the following:</p>
<ul>
<li>B is passed to the constructor of A. Example from WFA: the logger is passed to the controller’s constructor, which makes <code>ILogger&lt;WeatherForecastController&gt;</code> a dependency, as illustrated here:<pre>public WeatherForecastController(
  <strong class="bold">ILogger&lt;WeatherForecastController&gt;</strong> logger, …)</pre></li>
<li>B is passed to a method in A, as follows:<pre>public void DoSomething(B b) { …</pre></li>
<li>B has a static method that is called from a method in A. Example from WFA: <code>DateTime.Now</code> is called from <code>GetRandom</code>, which makes <code>DateTime</code> a dependency, as illustrated here:<pre>wf.Date = DateTime.Now.AddDays(i + 1);</pre></li>
<li>B is instantiated anywhere inside A, whether instantiated in a method, in a field, or in a property. In the following example, <code>HttpClient</code> is instantiated in the code:<pre>HttpClient httpClient = new HttpClient();</pre></li>
</ul>
<p>Based on this definition, we have all of the following as dependencies on <code>WeatherForecast Controller</code>:</p>
<ul>
<li><code>Random</code></li>
<li><code>DateTime</code></li>
<li><code>Client</code></li>
<li><code>HttpClient</code></li>
<li><code>ILogger&lt;WeatherForecastController&gt;</code></li>
<li><code>IConfiguration</code></li>
<li><code>WeatherForecast</code></li>
</ul>
<p><strong class="bold">Data transfer objects</strong> (<strong class="bold">DTOs</strong>) are not <a id="_idIndexMarker104"/>considered dependencies, although they<a id="_idIndexMarker105"/> look like concrete classes, but they act as a vehicle to carry data from one place to another. We will show an example of a DTO in the <em class="italic">The WeatherForecast class dependency</em> section.</p>
<p>Note that <code>record</code>, <code>record struct</code>, and <code>struct</code> usually follow the same concept as a DTO.</p>
<p>We will have more analysis of dependencies across <em class="italic">Part 1</em>, <em class="italic">Getting Started and Basics</em>, and <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>. For an experienced TDD practitioner, spotting dependencies is second nature.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor048"/>Dependency relevance</h2>
<p>Dependencies lead our <a id="_idIndexMarker106"/>class to interact with components external to our code. A dependency is relevant for DI in the context of unit testing if it has a method or a property that might cause a side effect when triggered or when it leads to other behavior that is not very relevant to the class being tested.</p>
<p>This is an overloaded definition, and it is not meant to be all clear at this point. Examples will be provided from here until the end of <em class="italic">Part 2</em> to show when a dependency is relevant. </p>
<p>We care for pinpointing a dependency if we want to change its behavior when testing it. If <code>_logger.LogInformation</code> is writing to the disk, we want sometimes to change this behavior, especially when testing. As always, clarifying with examples is best, so in this section, we will demonstrate multiple examples and explain why they are relevant.</p>
<h3>The logging dependency</h3>
<p>Consider this <code>_logger</code> field:</p>
<pre class="source-code">private readonly ILogger&lt;WeatherForecastController&gt; 
    _logger;</pre>
<p>During the application<a id="_idIndexMarker107"/> lifespan, the <code>_logger</code> field might be triggered to write logs. Depending on the configuration of the logger, it might write logs in memory, in the console while debugging, in a log file on the disk, in the database, or on a cloud <a id="_idIndexMarker108"/>service such as <code>_logger</code> field when we log in the <code>ConvertCToF</code> method, as follows:</p>
<pre class="source-code">_logger.LogInformation("conversion requested");</pre>
<p><em class="italic">It is relevant</em> because we have a side effect that will extend to other components in the system, and when unit testing at a later stage, we want to eliminate this side effect.</p>
<h3>The configuration dependency</h3>
<p>There is another <a id="_idIndexMarker109"/>field in the class, the <code>_config</code> field, as illustrated here:</p>
<pre class="source-code">private readonly IConfiguration _config;</pre>
<p>The <code>_config</code> field is needed to get the API key from the configuration. It is passed through the constructor of the controller class, similar to the <code>_logger</code> field.</p>
<p>During runtime <code>_config</code> can load configuration based on configuration; pun not intended. Your configuration can be in the cloud, in <code>appsettings</code>, or in a custom format. We can see this dependency in use here:</p>
<pre class="source-code">string apiKey = _config["OpenWeather:Key"];</pre>
<p><em class="italic">It is relevant</em> as we need to go through the configuration to read the API key. Accessing configuration is also causing a side effect.</p>
<h3>The HTTP dependency</h3>
<p>Digging through the code, you<a id="_idIndexMarker110"/> find that we have<a id="_idIndexMarker111"/> instantiated <code>HttpClient</code> and used it in the code:</p>
<pre class="source-code">HttpClient httpClient = new HttpClient();</pre>
<p>It is obvious that we have a dependency on <code>GetReal</code> API, is invoked, it issues an HTTP call.</p>
<p>Unlike the logging and configuration dependencies, where the dependency is built against an abstraction (<code>IConfiguration</code> and <code>ILogging&lt;&gt;</code>), <code>httpClient</code> is instantiated in the code—this <a id="_idIndexMarker113"/>makes what is called a <strong class="bold">hard</strong> or a <strong class="bold">concrete dependency</strong>.</p>
<p>We do care about the distinction between instantiating a dependency in code or passing it from outside, through the <a id="_idIndexMarker114"/>constructor. It’ll be clear why later on.</p>
<p><em class="italic">It is relevant</em> as we don’t want to depend on the network while we are testing.</p>
<h3>The OpenWeather client dependency</h3>
<p>The OpenWeather <a id="_idIndexMarker115"/>client is a dependency on a dependency. It is a dependency itself and it is relying on the HTTP dependency, represented by <code>httpClient</code>, as well. You can see this in the following snippet:</p>
<pre class="source-code">Client openWeatherClient = new Client(apiKey, <strong class="bold">httpClient</strong>);</pre>
<p>Also, this is another example of a concrete dependency as it is being instantiated inline.</p>
<p><em class="italic">It is relevant</em> as we don’t want to depend on HTTP (or the network) while we are testing.</p>
<h3>The time dependency</h3>
<p>Consider this line<a id="_idIndexMarker116"/> in the code:</p>
<pre class="source-code">wf.Date = DateTime.<strong class="bold">Now</strong>.AddDays(i + 1);</pre>
<p>What is important here is the <code>Now</code> property. <code>Now</code> has code that will call the <code>Now</code> property is static, as we can see here:</p>
<pre class="source-code">public static DateTime Now { get; }</pre>
<p>The fact that this is static will make it slightly more difficult to deal with regarding DI, as we will see soon.</p>
<p><em class="italic">It is relevant</em> as we want a predictable time during testing. Taking the current time will not lead to consistent results, as time is changing.</p>
<h3>The randomness dependency</h3>
<p>This is an example of <a id="_idIndexMarker118"/>depending on an algorithm to generate randomness:</p>
<pre class="source-code">wf.TemperatureC = Random.Shared.<strong class="bold">Next</strong>(-20, 55);</pre>
<p>The <code>Next</code> method is a static method as well and it is calling the time in the background to generate a seed; also, it is depending on a <em class="italic">randomization algorithm</em>. We want to control the outcome so that we can test it.</p>
<p><em class="italic">It is relevant</em> as we want predictable output.</p>
<h3>The WeatherForecast class dependency</h3>
<p>We are instantiating this<a id="_idIndexMarker119"/> class as a DTO, as we want to<a id="_idIndexMarker120"/> transfer the data from our method to the client. This data structure will be serialized into <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>). The code is illustrated here:</p>
<pre class="source-code">WeatherForecast[] wfs = new WeatherForecast[FORECAST_DAYS];</pre>
<p><em class="italic">It is not relevant</em> as this object does not cause a side effect and it just carries data.</p>
<p>If the code depends on abstractions and the objects are not instantiated in the class (the controller in the previous example), then this is generally good. If the code depends on concrete classes that <a id="_idIndexMarker121"/>are instantiated in the class, then we are not following best practices as we are violating one good <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) practice: <em class="italic">depend on abstraction, not concrete</em>. This will be our next topic.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor049"/>Depend on abstraction, not concrete</h2>
<p>The title is popular advice in OOP best practices. This advice applies to two cases: the method signatures and the code inside the methods. We will explore both cases in this section.</p>
<h3>Abstracted parameters in the method signature</h3>
<p>When designing a method, including a class constructor, the advice is to check whether you can accept an abstracted type rather than a concrete type. As always, let’s explain this with examples. </p>
<p>For an example <a id="_idIndexMarker122"/>of an abstract class, take the well-known <code>Stream</code> class from .NET, as illustrated in the following code snippet:</p>
<pre class="source-code">public <strong class="bold">abstract</strong> class Stream : …</pre>
<p>A <code>Stream</code> object represents a sequence of bytes, but the class doesn’t care about the physical source of the<a id="_idIndexMarker123"/> bytes—let it be from a file or from memory or others. This is the wisdom behind making it an abstract class.</p>
<p>We have <code>FileStream</code>, which inherits <code>Stream</code> as an example of a concrete class, as illustrated here:</p>
<pre class="source-code">public class FileStream : Stream</pre>
<p><code>FileStream</code> understands the specifications of reading a stream of bytes from a disk file.</p>
<p>We have also <code>MemoryStream</code>, which inherits <code>Stream</code> as another example of a concrete class, as illustrated here:</p>
<pre class="source-code">public class MemoryStream : Stream</pre>
<p>Here is a UML diagram to summarize the relationship:</p>
<div><div><img alt="Figure 2.8 – Stream and its children " height="211" src="img/Figure_2.8_B18370.jpg" width="427"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Stream and its children</p>
<p>Having <code>Stream</code> as an abstract class opened the way for <code>System.Text.Json.JsonSerializer</code> class, which accepts a parameter of the type <code>Stream</code>:</p>
<pre class="source-code">public static void Serialize (<strong class="bold">Stream utf8Json</strong>, object? 
    value, …);</pre>
<p>This method converts the provided value to <code>Stream</code> class.</p>
<p>Because this method doesn’t care for the way the <code>Stream</code> class is dealing with the underlying physical persistence, it is accepting the <code>Stream</code> parent abstract class as a parameter. If there is no abstraction, then you will have <strong class="bold">multiple</strong> overloads of the same method. Each one<a id="_idIndexMarker124"/> of them accepts a different stream type, like this (these overloads don’t exist; they are hypothetical):</p>
<pre class="source-code">public static void Serialize (FileStream utf8Json, …);
public static void Serialize (MemoryStream utf8Json, …);
public static void Serialize (SqlFileStream utf8Json, …);
public static void Serialize (BufferedStream utf8Json, …);
More Stream overloads…</pre>
<p>This is an example of the benefits of accepting an abstraction type as a method argument. Here is another example. Consider this code:</p>
<pre class="source-code">public static int Sum(int[] elements) 
{
    int sum = 0;
    foreach (int e in elements) sum += e;
    return sum;
}</pre>
<p>This method takes an array and returns the sum of its elements. At first glance, the method’s signature looks fine, but if you think about it, this method forces the caller to convert any collection to an array before calling the method, which is an unnecessary conversion and a waste of performance as this method doesn’t depend on the specific features of an array. It is just doing a <code>foreach</code> construct, which means it is accessing the array elements sequentially. Does it really need to accept an array?</p>
<p>Converting the signature parameter to <code>IEnumerable&lt;int&gt;</code>, which is an abstraction, would allow this method to accept a considerable number of concrete classes, as illustrated here:</p>
<pre class="source-code">public static int Sum(<strong class="bold">IEnumerable&lt;int&gt;</strong> elements)</pre>
<p>You initially were <a id="_idIndexMarker125"/>only able to call this method with an <code>int[]</code> array; now, it can be passed to any object of a class that implements <code>IEnumerable&lt;int&gt;</code>, and there are plenty of them. Here are a few:</p>
<pre class="source-code">int[] array = new int[] { 1, 2 };
List&lt;int&gt; list = new List&lt;int&gt; { 1, 2 };
Queue&lt;int&gt; queue = new Queue&lt;int&gt;();
queue.Enqueue(1);
queue.Enqueue(2);
// More collections
Sum(array);
<strong class="bold">Sum(list); // new benefit</strong>
<strong class="bold">Sum(queue); // new benefit</strong></pre>
<p>Going back to the WFA application, our controller constructor is already doing something right as it depends on abstractions, as illustrated in the following code snippet:</p>
<pre class="source-code">public WeatherForecastController(
  <strong class="bold">ILogger&lt;WeatherForecastController&gt;</strong> logger, 
    <strong class="bold">IConfiguration</strong> config)</pre>
<p>Always think of the common denominator abstraction type that satisfies the requirement to have your method as open as possible. </p>
<h3>Direct instantiation of a dependency</h3>
<p>We have just <a id="_idIndexMarker126"/>discussed using abstractions, when possible, in our method signature. This reduces coupling and increases the usability of the method. This section will extend the advice to the code.</p>
<p>If we are instantiating classes directly in the code, we depend on concrete objects. If we depend on concrete objects, then we cannot change their behavior at runtime. Let’s take an example from our WFA application where we are instantiating the <code>Client</code> class in our method, as per this line of code:</p>
<pre class="source-code">Client openWeatherClient = new Client(apiKey, httpClient); </pre>
<p>Then, whenever we use the <code>openWeatherClient</code> object, such as calling the <code>OneCallAsync</code> method, we will be firing an HTTP request over the network to a RESTful API on the <em class="italic">OpenWeather</em> end. This is good for the production code, but not good for testing the code; when<a id="_idIndexMarker127"/> we are testing, we want to eliminate this behavior.</p>
<p class="callout-heading">Isolation</p>
<p class="callout">In this case, we can avoid the HTTP call and work around this using an <em class="italic">isolation framework</em> during testing. However, this is only kept as a last resort. We will explain what isolation frameworks are in <a href="B18370_03.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting Started with Unit Testing</em>.</p>
<p>When testing the code, we don’t want it to fire an HTTP request for many reasons, including the following:</p>
<ul>
<li>We have a limited number of calls that we can make per time—a quota.</li>
<li>Our testing environment is behind a firewall that bans outbound traffic.</li>
<li>The REST service on the other end of the network is temporarily down, so we will get a false-negative result that our test has failed.</li>
<li>Calling a service over the internet is slow, compared to dealing with CPU and memory.</li>
</ul>
<p>Can you see where we’re going? The code works, but it is not testable in isolation of the HTTP calls.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Some test categories should fire HTTP and reach the other end, such as integration tests. In the previous context, I meant tests that validate the business logic and do not test for connectivity—one of them is a unit test.</p>
<p>Instantiating concrete classes would not work if we were to unit test a piece of functionality. What we want to do during unit testing is to check if a <em class="italic">false attempt</em> to fire a call is made but not actually executed, and that would be enough. So far, the takeaway is that creating<a id="_idIndexMarker128"/> concrete classes in code is not compatible with DI and, accordingly, not compatible with unit testing.</p>
<p>The main solution to avoid instantiating classes in the business logic is DI, which is what we will see shortly.</p>
<h3>Best practices recap</h3>
<p>Our discussion in the <em class="italic">Depend on abstraction, not concrete</em> section boils down to these two <a id="_idIndexMarker129"/>examples of <em class="italic">do</em> and <em class="italic">do not</em>. Let’s start with the bad or the do-not-do example, as follows:</p>
<pre class="source-code">public class BadClass 
{
    public BadClass() {}
    public void DoSometing()
    {
      MyConcreteType t = new MyConcreteType();
      t.UseADependency();
    }
}</pre>
<p>Here’s the equivalent good class example:</p>
<pre class="source-code">public class GoodClass 
{
    private readonly IMyClass _myClass; 
    public GoodClass(IMyClass myClass) 
        { _myClass = myClass; }
    public void DoSometing()
    {
      _myClass.UseADependency();
    }
    public void DoSometingElse(SecondClass second)
    {
      second.UseAnotherDependency();
    }
}</pre>
<p>Here are the good practices:</p>
<ul>
<li>Having abstractions as parameters encourages decoupling and opens the method to accept more types.</li>
<li>Depending on<a id="_idIndexMarker130"/> abstractions allows changing an object’s behavior without changing the code in the class.</li>
</ul>
<p>One question you would ask is this: <em class="italic">If I did not instantiate the objects that were passed to the constructor or the method at runtime, then who did? Surely somewhere along the line, some process has instantiated my dependencies and passed them to my class.</em> The answer to this question can be found in the next section.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor050"/>Introducing DI</h1>
<p>When I first learned how to do<a id="_idIndexMarker131"/> DI in code, I had a euphoria as if I had discovered a secret in software engineering; it is like <em class="italic">code magic</em>. We have been exploring dependencies in the previous sections and now, we are about to discover injecting these dependencies into our classes. The next step is explaining what DI is and using practical samples from the WFA application to make sure you are experimenting with a variety of scenarios. The best way to introduce DI is with a familiar example.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor051"/>First example of DI</h2>
<p>DI is all over any modern .NET code. In fact, we<a id="_idIndexMarker132"/> have one example right here in the ASP.NET template code:</p>
<pre class="source-code">public WeatherForecastController(
    ILogger&lt;WeatherForecastController&gt; <strong class="bold">logger</strong>) 
{
    _logger = logger;</pre>
<p>The <code>logger</code> object, which is a dependency, is injected into the controller when a new instance of the controller is created. There is nowhere in the controller that we are instantiating the <code>logger</code> class. It has been injected into the controller’s constructor. </p>
<p>What does injection in this context mean? It means the ASP.NET framework found an incoming request that needs this controller to be instantiated. The framework realized that to create a new instance of <code>WeatherForecastController</code>, it needs to create an instance of a concrete class that implements <code>ILogger&lt;WeatherForecastController&gt;</code>, to do something similar to this:</p>
<pre class="source-code">ILogger&lt;WeatherForecastController&gt; logger = new 
    Logger&lt;WeatherForecastController&gt;(…); 
var controller = new WeatherForecastController(logger);</pre>
<p>The constructor of the controller required an instance of a concrete class that implements <code>ILogger&lt;WeatherForecastController&gt;</code>, and the framework resolved that <code>Logger&lt;&gt;</code> implements <code>ILogger&lt;&gt;</code> and can be used as a parameter for the construction of the controller.</p>
<p>How did it resolve this? We will learn<a id="_idIndexMarker133"/> about this in the DI containers; what is important now is that it knew what to do in order to instantiate the controller class.</p>
<p>Now is the time to give every subject in our play a DI-related name, as follows:</p>
<ul>
<li><strong class="bold">DI container</strong>: The software library that is managing the injection</li>
<li><code>ILogger&lt;&gt;</code> descendant object)</li>
<li><strong class="bold">Client</strong>: The class requesting the service (the controller, in the previous example)</li>
<li><strong class="bold">Activation</strong>: The process of instantiating the client</li>
<li><strong class="bold">Resolution</strong>: The DI container<a id="_idIndexMarker134"/> finding the right service required to activate the client</li>
</ul>
<h2 id="_idParaDest-49"><a id="_idTextAnchor052"/>Testing an API</h2>
<p>Let’s dig deeper into DI with an <a id="_idIndexMarker135"/>example. Consider this test problem that will give you firsthand experience of what DI is. Take the <code>ConvertCToF</code> method we created earlier in our WFA application.</p>
<p>We want to do some tests for this method in order to validate whether the temperature conversion is done accurately. We have been given a few examples of °C and the equivalent °F for our tests, as follows:</p>
<ol>
<li>-1.0 C = 30.20 F</li>
<li>1.2 C = 34.16 F</li>
</ol>
<p>To satisfy the tests, we want to use an old-school console application that will throw an exception if the conversion doesn’t match the examples.</p>
<p>You can add the console <a id="_idIndexMarker136"/>application via the VS GUI or you can execute the following lines from the solution directory:</p>
<pre>dotnet new console -o Uqs.Weather.TestRunner
dotnet sln add Uqs.Weather.TestRunner
dotnet add Uqs.Weather.TestRunner reference Uqs.Weather</pre>
<p>This adds a new console application called <code>Uqs.Weather.TestRunner</code> to the existing solution, and references the existing ASP.NET Web API application. In VS, add this code to the <code>Program.cs</code> file of the console application:</p>
<pre class="source-code">using Microsoft.Extensions.Logging;
using Uqs.Weather.Controllers;
<strong class="bold">var logger = new Logger&lt;WeatherForecastController&gt;(null);</strong> 
//fails
var controller = new WeatherForecastController(logger, 
    null!);
double f1 = controller.ConvertCToF(-1.0);
if (f1 != 30.20d) throw new Exception("Invalid");
double f2 = controller.ConvertCToF(1.2);
if (f2 != 34.16d) throw new Exception("Invalid");
Console.WriteLine("Test Passed");</pre>
<p>The code in the current format doesn’t run as it fails at the <code>var logger</code> line. We’ll fix that in a moment, but let’s analyze the code first. The code instantiates a controller, in the way we instantiate any class in .NET; then, it calls the <code>ConvertCToF</code> method and tries different values. If all values pass, then it will print <strong class="bold">Test Passed</strong>; otherwise, it will throw an exception.</p>
<p>To instantiate a <code>Logger&lt;&gt;</code> object, we need to pass to its constructor an object of <code>ILoggerFactory</code> type. If you pass <code>null</code>, it will fail at runtime. Besides, the bad news is that an instance of a concrete implementation of <code>ILoggerFactory</code> is not meant to be instantiated <a id="_idIndexMarker137"/>manually unless you are integrating a logging framework or handling a special case, and testing is not a special case! In brief, we cannot easily do this.</p>
<p>What if we try to pass to the controller’s constructor two null values, and ignore creating a <code>Logger&lt;&gt;</code> object, like this:</p>
<pre class="source-code">var controller = new WeatherForecastController(null, null);</pre>
<p>The problem is that if you pass a <code>null</code> value, your <code>_logger</code> object in the controller will be null and your code will fail at this line with the infamous <code>NullReferenceException</code> exception, as illustrated here:</p>
<pre class="source-code">_logger.LogInformation("conversion requested");</pre>
<p>What we really want is just to instantiate the controller. We are not testing the logger; we want to pass to the constructor anything that will create an object from our controller, but the logger is standing in our way. It turns out that Microsoft has a class called <code>NullLogger&lt;&gt;</code> that does just that—getting out of the way! The documentation from Microsoft states “<em class="italic">Minimalistic logger that does nothing</em>”.</p>
<p>With the enlightenment of this class, the first few lines of the code will look like this:</p>
<pre class="source-code">var <strong class="bold">logger</strong> = <strong class="bold">NullLogger</strong>&lt;WeatherForecastController&gt;
    .Instance;
var controller = new WeatherForecastController(<strong class="bold">logger</strong>, …);</pre>
<p>We are getting a reference to <code>NullLogger&lt;&gt;</code> through the <code>Instance</code> field. When we call <code>_logger.LogInformation</code>, nothing will happen, which fits what we’re looking for. If we run this console application now, we will get a <strong class="bold">Test Passed</strong> message.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Testing methods via a console application is not the best practice for testing. Also, throwing exceptions and writing messages are not ideal for reporting failed and passed tests. The right way will be covered in the next chapter.</p>
<p>The constructor of the controller accepts an <code>ILogger&lt;&gt;</code> object, which gave us the flexibility of passing a <code>NullLogger&lt;&gt;</code> object as the latter implements <code>ILogger&lt;&gt;</code>, as illustrated here:</p>
<pre class="source-code">public class NullLogger&lt;T&gt; : Microsoft.Extensions.Logging
    .ILogger&lt;T&gt;</pre>
<p>And the UML diagram of the logging classes looks like this:</p>
<div><div><img alt="Figure 2.9 – UML of Logger&lt;&gt;, NullLogger&lt;&gt;, and ILogger&lt;&gt; " height="182" src="img/Figure_2.9_B18370.jpg" width="540"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – UML of Logger&lt;&gt;, NullLogger&lt;&gt;, and ILogger&lt;&gt;</p>
<p>At this point, it is worth <a id="_idIndexMarker138"/>analyzing what we’ve done so far. Here’s what we’ve achieved:</p>
<ol>
<li value="1">At runtime (when the APIs are launched), <code>Logger&lt;&gt;</code> was injected into the controller and it should be writing logs as expected.</li>
<li>At test time, we are not interested in the activities of logging; we are testing another scenario, so we’ve passed <code>NullLogger&lt;&gt;</code>.</li>
<li>We were allowed to inject into <code>ILogger&lt;&gt;</code> different types as <code>ILogger&lt;&gt;</code> is an interface, which is an abstraction. We would have failed to do this if our constructor expects a <code>Logger&lt;&gt;</code> type (the concrete type with no <code>I</code>).</li>
</ol>
<p>In the first scenario, it was the <strong class="bold">DI container</strong> that injected the object at runtime. In the second scenario, this was us manually injecting a different logger for testing purposes. The annotated code in the following screenshot shows a summary of this section:</p>
<div><div><img alt="Figure 2.10 – Annotated code showing DI at test time and at runtime " height="848" src="img/Figure_2.10_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Annotated code showing DI at test time and at runtime</p>
<p>The conclusion here is that if <a id="_idIndexMarker139"/>our parameters use abstract types such as interfaces, <code>ILogger&lt;&gt;</code>-type interfaces, or abstract classes, we can open our classes for more reusability where DI can be utilized.</p>
<p>The <code>LogInformation</code> method is changing behavior based on the injected object, so it is acting as a seam. This drives us naturally to our next section about seams.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor053"/>What are seams?</h2>
<p>As an English term, a <em class="italic">seam</em> is where<a id="_idIndexMarker140"/> two pieces of fabric are stitched together. The term in a DI context resembles areas in the code where we can <em class="italic">change</em> the <a id="_idIndexMarker141"/>behavior without changing the code explicitly. We can point to the example from our previous convert method, shown here:</p>
<pre class="source-code">public double ConvertCToF(double c)
{
    double f = c * (9d / 5d) + 32;
    _logger.<strong class="bold">LogInformation</strong>("conversion requested");
    return f;
}</pre>
<p>Take the <code>LogInformation</code> method. We want this method to write into some production instrument, but when we’re testing, we want it to do nothing (if our test scenario is not about logging). We want to test other functionality, but <code>_logger.LogInformation</code> is standing in our way, trying to write somewhere, so we want to change its behavior.</p>
<p><code>LogInformation</code> is a seam, as the behavior can change here. From the previous section, if we inject into the class a <code>Logger&lt;&gt;</code> object, then <code>LogInformation</code> will behave in one way, and if we inject <code>NullLogger&lt;&gt;</code>, it will behave in another way.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor054"/>Inversion of control</h2>
<p>You will often hear the term <strong class="bold">inversion of control</strong> (<strong class="bold">IoC</strong>) used to mean DI. You may also hear IoC container, as well, to mean a<a id="_idIndexMarker142"/> DI container. From a pragmatic point of view, you don’t need to<a id="_idIndexMarker143"/> worry about the differences in the meaning of these terms. Practitioners have different definitions of IoC and how it relates to DI. Just search for one term versus the other and you’ll find forums full of contradicting definitions.</p>
<p>Here are the common points that practitioners agree on:</p>
<ul>
<li>IoC is reversing the flow of <a id="_idIndexMarker144"/>events from the software to the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) or the other way around.</li>
<li>DI is a form of IoC.</li>
</ul>
<p><em class="italic">DI</em> is the most popular term and the most modern one. The term <em class="italic">IoC</em> is from a different era, is more generic, and has a less practical use, so I recommend using the term <em class="italic">DI</em>.</p>
<p>After all these examples, best practices, and definitions, I kept the best to last, which is the practical section of this chapter. This is how you can take all the previous literature and write useful code with it.</p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor055"/>Using DI containers</h1>
<p>A <strong class="bold">DI container</strong> is a library that<a id="_idIndexMarker145"/> injects a service into the client. A DI container provides extra functionality other than injecting dependencies, such as the following:</p>
<ul>
<li>Registering the classes that need to be injected (registering the services)</li>
<li>Implementing how the services need to be instantiated</li>
<li>Instantiating what has already been registered</li>
<li>Managing the created service lifetime</li>
</ul>
<p>Let’s clarify a DI container role with an example from the previous code. We have the <code>logger</code> service being injected, but who is responsible for this?</p>
<p>There is a DI container called <code>Microsoft.Extensions.DependencyInjection</code> that will inject <code>_logger</code>. This happened in the first line of <code>Program.cs</code>, as illustrated here:</p>
<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
<p>This previous method call registers a default logger. Unfortunately, while we can see the code in the .NET source code, it is not obvious in our <code>Program.cs</code> source code. In fact, the previous line registers plenty of other services.</p>
<p>By adding a single line for experimentation, directly following the previous line in <code>Program.cs</code>, we can see how many registered services are created:</p>
<pre class="source-code">int servicesCount = builder.Services.Count;</pre>
<p>This will give us 82 services. A few of these services are for logging-related activities. So, if you want to see what they are, you can have this line directly after the previous line:</p>
<pre class="source-code">var logServices = builder.Services.Where(_ =&gt; 
    x.ServiceType.Name.Contains("Log")).ToArray();</pre>
<p>You can see here that we are filtering on any service that has the word <code>Log</code> as part of its name. If you have a breakpoint after this line and go to VS <code>logServices</code>, you can see a glimpse of all the registered log-related services, as illustrated in the following screenshot:</p>
<div><div><img alt="Figure 2.11 – Immediate window showing the registered logging-related services " height="609" src="img/Figure_2.11_B18370.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Immediate window showing the registered logging-related services</p>
<p>The screenshot shows that we<a id="_idIndexMarker146"/> have 10 registered logging-related services. The one being injected for us at runtime is the second one (index number 1).</p>
<p class="callout-heading">Note</p>
<p class="callout">You might get a different list of pre-registered services than this, depending on your ASP.NET version.</p>
<p>We will change our implementation in the controller to move everything to be dependency-injected and experiment with various scenarios of writing DI-ready code.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor056"/>Container role</h2>
<p>The container activities<a id="_idIndexMarker147"/> are being executed in the background by the DI container. A container is involved in booting up classes in your application, as illustrated in the following screenshot:</p>
<div><div><img alt="Figure 2.12 – Container in action (pseudo code) " height="518" src="img/Figure_2.12_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Container in action (pseudo code)</p>
<p>The code of the <strong class="bold">DI Container</strong> box is a pseudo code. It is trying to summarize how the DI <em class="italic">resolves</em> the <em class="italic">service</em> required by the <em class="italic">client</em> from a list of already <em class="italic">registered</em> services. Then, the DI <em class="italic">activates</em> the client and passes it to the service. This is all happening at runtime.</p>
<p>The registration is an activity we will explore in many examples later on. In this scenario, there was an instruction that stated whenever an <code>ILogger&lt;&gt;</code> object is requested by the client, substitute it with a concrete class of the <code>Logger&lt;&gt;</code> type.</p>
<p>It is important to note that<a id="_idIndexMarker148"/> while the client is requesting an interface, the DI has been instructed earlier on how to construct a concrete class for this abstraction; the DI container knew earlier that to construct an <code>Ilogger&lt;&gt;</code> object, it needs to initialize a <code>Logger&lt;&gt;</code> object.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor057"/>Third-party containers</h2>
<p>We have been working<a id="_idIndexMarker149"/> so far with a <em class="italic">built-in</em> DI container that is automatically wired with new ASP.NET projects, and that is the <code>Microsoft.Extensions.DependencyInjection</code> Microsoft DI container, but this is not the only DI container available for .NET 6—there are other third-party options.</p>
<p>Microsoft has developed a DI container in recent years. Third-party containers gradually diminished in popularity in favor of the one shipped with .NET. Also, some frameworks did not make<a id="_idIndexMarker150"/> the leap with the<a id="_idIndexMarker151"/> introduction of .NET 5. Who’s left strong today, with .NET 6, are <strong class="bold">Autofac</strong> and <strong class="bold">StructureMap</strong>. There are other containers supporting .NET 6, but they are not as popular.</p>
<p>If you are experienced in unit testing and you want more features that are not supported in <code>Microsoft.Extensions.DependencyInjection</code>, then have a look at other frameworks such as Autofac. But for non-monolithic, mid-size projects, I would recommend<a id="_idIndexMarker152"/> sticking with the Microsoft one as it is fairly supported and there are plenty of third-party plugin components. You can always swap to another framework at a later stage. My advice is not to spend valuable time choosing a DI container. Start with the Microsoft one until your requirements exceed it.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor058"/>Service lifetime</h2>
<p>When a service is<a id="_idIndexMarker153"/> registered to be passed to the client, the DI container has to decide about the lifetime of the service. The lifetime is the time interval from when the service is created until when it is released for garbage collection or disposed of.</p>
<p>The Microsoft DI container has three major lifetimes that you can specify when registering a service: <strong class="bold">transient</strong>, <strong class="bold">singleton</strong>, and <strong class="bold">scoped lifetime scopes</strong>.</p>
<p>Note that if the service implements the <code>IDisposable</code> interface, the <code>Dispose</code> method is invoked when the service is released. When a service is released, if it has dependencies, they are also released and disposed of. Next, we will explore the three major lifetimes.</p>
<h3>Transient lifetime</h3>
<p>Transient services are <a id="_idIndexMarker154"/>created every time they are injected or requested. The container simply creates a new instance for every request.</p>
<p>This is good in terms of not having to<a id="_idIndexMarker155"/> worry about thread safety or service state modification (by another requesting object). But creating an object for every request has adverse performance implications, especially when the service is in high demand, and activating it may not be cheap.</p>
<p>You will see an example of a transient service in the <em class="italic">Refactoring for DI</em> section later on.</p>
<h3>Singleton lifetime</h3>
<p>Singleton services are <a id="_idIndexMarker156"/>created once on the first client request and released when the<a id="_idIndexMarker157"/> application terminates. The same activated service will be passed to all requesters.</p>
<p>This is the most efficient lifetime as the object is created once, but this is the most dangerous one as a singleton service should allow concurrent access, which means it needs to be thread-safe.</p>
<p>You will see an example of a singleton service in the <em class="italic">Refactoring for DI</em> section later on.</p>
<h3>Scoped lifetime</h3>
<p>Scoped services are created once<a id="_idIndexMarker158"/> per HTTP request. They stay alive from the beginning of the HTTP request until the end of the HTTP response and they will be<a id="_idIndexMarker159"/> shared between clients.</p>
<p>This is good if you want one service to be used by several clients and the service applies to a single request only.</p>
<p>This lifetime is the least popular compared to the transient and the singleton lifetimes. Performance-wise, it sits in the middle between the transient and the singleton lifetimes. There is only one thread executing each client request at a given time, and because each request gets a separate DI scope, you don’t have to worry about thread safety.</p>
<p>One popular example of using scoped services is using <strong class="bold">Entity Framework’s</strong> (<strong class="bold">EF’s</strong>) DB context object as scoped, which allows the request to share the same data and to cache data when required between clients.</p>
<p>Here is another example. Suppose you have a logging service that will allow the client to log, but it will only flush from memory to the destination media (say, saving to the database) when the HTTP request is over. Ignoring other conditions, this could be a candidate for a scoped lifetime.</p>
<p>We will have an example of a scoped lifetime in <a href="B18370_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>, <em class="italic">Building an Appointment Booking App with Entity Framework and Relational DB</em>.</p>
<h3>Choosing a lifetime</h3>
<p>If your concern is <a id="_idIndexMarker160"/>performance, then think of a singleton. Then, the next step is checking whether the service is thread-safe, either by reading its documentation or doing other types of investigation. </p>
<p>Then, fall down to scoped if relevant, and then fall down to transient. The safest option is always transient—if in doubt, then choose transient!</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Any class that gets injected into the singleton will become a singleton, regardless of the lifetime of the injected object.</p>
<h3>Container workflow</h3>
<p>Before we see some examples <a id="_idIndexMarker161"/>of service registration and lifetime, it’s a good time to generalize our understanding of DI containers and look at a workflow diagram of the DI activation process: </p>
<div><div><img alt="Figure 2.13 – The workflow of a DI container " height="1002" src="img/Figure_2.13_B18370.jpg" width="1168"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – The workflow of a DI container</p>
<p>In this diagram, it is<a id="_idIndexMarker162"/> clear that the DI container has two major concerns when activating a class, which are registration and lifetime.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor059"/>Refactoring for DI</h2>
<p>If you have done <a id="_idIndexMarker163"/>your DI right, then you are halfway with respect to implementing your unit tests. When writing a unit test, you will be thinking about how everything should be DI-ready.</p>
<p>There are certain factors that will determine how your services should be injected, as outlined here:</p>
<ol>
<li value="1">Does my seam belong to an abstracted method? In another way, does the method in question exist in an abstraction? This is the case with the <code>ILogger.LogInformation</code> method that we saw earlier, but we will cover this scenario again in more detail in the <em class="italic">Injecting the OpenWeather client</em> section.</li>
<li>Is my seam a static<a id="_idIndexMarker164"/> method? This will be covered in the <em class="italic">Injecting DateTime</em> and <em class="italic">Injecting the random generator</em> sections.</li>
</ol>
<h3>Injecting the OpenWeather client</h3>
<p>One offending line <a id="_idIndexMarker165"/>is the <code>Client</code> class instantiation in <code>WeatherForecastController.cs</code>, as illustrated here:</p>
<pre class="source-code">string apiKey = _config["OpenWeather:Key"];
HttpClient httpClient = new HttpClient();
<strong class="bold">Client openWeatherClient = new Client(apiKey, httpClient);</strong>
OneCallResponse res = 
   await openWeatherClient.OneCallAsync(…)</pre>
<p>The sole purpose of accessing <code>_config</code> was to get the API key for <code>Client</code> and the sole purpose of instantiating <code>HttpClient</code> was to pass it to the constructor of  <code>Client</code>. So, if we were to inject <code>openWeatherClient</code>, then the first two lines would not be needed.</p>
<p>Which method or property are we using from the to-be-injected class? The answer, by looking through the code, is <code>OneCallAsync</code> only. Then, what is the highest type (a class, an abstract class, or an interface) in the hierarchy of <code>Client</code> that has this member? To do this, hold the <em class="italic">Ctrl</em> button and click on the class name in VS, and you will find that <code>Client</code> implements <code>IClient</code>, as illustrated here:</p>
<pre class="source-code">public class Client : IClient</pre>
<p>Then, hold <em class="italic">Ctrl</em> and click <code>IClient</code>, and you will find the following interface:</p>
<pre class="source-code">public interface IClient
{
    Task&lt;OneCallResponse&gt; OneCallAsync(decimal latitude, 
       decimal longitude, IEnumerable&lt;Excludes&gt; excludes,
       Units unit);
}</pre>
<p>Clearly, my implementation can depend on <code>IClient</code> rather than <code>Client</code>.</p>
<p>In the controller <a id="_idIndexMarker166"/>constructor, add <code>IClient</code> and add <code>_client</code> as a field, as follows:</p>
<pre class="source-code"><strong class="bold">private readonly IClient _client;</strong>
public WeatherForecastController(<strong class="bold">IClient client</strong>, …
{
    <strong class="bold">_client = client;</strong>
    …</pre>
<p>The last step is doing the following modifications to these two lines:</p>
<pre class="source-code">Client openWeatherClient = new Client(apiKey, httpClient);
OneCallResponse res = 
    await openWeatherClient.OneCallAsync(…);</pre>
<p>Remove the first line as we are no longer instantiating <code>Client</code>, and modify your second line to use <code>_client</code> instead of the previous <code>openWeatherClient</code>. This will result in this code:</p>
<pre class="source-code">OneCallResponse res = await _client.OneCallAsync(…);</pre>
<p>We have done all our modifications to the controller. What is left is registering with the DI container how to inject an object that matches <code>IClient</code> for our controller constructor. Let’s run the project in its current state and we will get the following error:</p>
<pre class="source-code">System.InvalidOperationException: Unable to resolve service 
  for type IClient' while attempting to activate 
    'WeatherForecastController'</pre>
<p>The DI container tried to look for a concrete class that implements <code>IClient</code> so that it can create it and pass it to the constructor of <code>WeatherForecastController</code>. We know that there is a concrete class called <code>Client</code> that implements <code>IClient</code>, but we have not told the<a id="_idIndexMarker167"/> DI container about it yet.</p>
<p>In order for the DI container to register a service, it requires two bits of information, as follows:</p>
<ol>
<li value="1">How to create the required service?</li>
<li>What is the lifetime of the created service?</li>
</ol>
<p>The answer to <em class="italic">point 1</em> is we need to create an instance of <code>Client</code> whenever <code>IClient</code> is requested.</p>
<p><em class="italic">Point 2</em> is the trickier one. <code>Client</code> is a third-party class that is documented online. The first action is looking through the documentation to see whether it has a recommended lifetime and in this case, the documentation of <code>Client</code> specifies <code>Singleton</code> as the recommended one. In other cases where this is not documented, we have to figure it out in other ways. We will have more examples later on.</p>
<p>To register our dependency, in the <code>Program.cs</code> file, look for the comment provided by the <code>Add services to the container</code> template and add your code underneath it, as follows:</p>
<pre class="source-code">// Add services to the container.
builder.Services.AddSingleton&lt;IClient&gt;(_ =&gt; {
    string apiKey = 
        builder.Configuration["OpenWeather:Key"];
    HttpClient httpClient = new HttpClient();
    return new Client(apiKey, httpClient);
});</pre>
<p>Here, we are constructing <code>Client</code> in the same way we did it before. Once <code>Client</code> is first requested, only one instance will be created per application, and the same instance will be provided for all clients upon request.</p>
<p>Now, as we have finished with the DI of all dependencies required by the <code>GetReal</code> method, let’s tackle the <code>Now</code> dependency in the <code>GetRandom</code> method.</p>
<h3>Injecting DateTime</h3>
<p>We are using <code>DateTime</code> in our <code>GetRandom</code> method and it is tricky to inject. Let’s look at <code>DateTime</code> class usage<a id="_idIndexMarker168"/> in the code. We are using the following:</p>
<ul>
<li><code>AddDays</code> method</li>
<li><code>Now</code> property, which returns a <code>DateTime</code> object</li>
</ul>
<p>All this is clear in one line of code, shown here:</p>
<pre class="source-code">wf.Date = DateTime.Now.AddDays(i + 1);</pre>
<p>The <code>AddDays</code> method is a method that relies on an arithmetic calculation of days, which can be verified by looking at the <code>DateTime</code> source code on GitHub, at <a href="https://github.com/microsoft/referencesource/blob/master/mscorlib/system/datetime.cs">https://github.com/microsoft/referencesource/blob/master/mscorlib/system/datetime.cs</a>.</p>
<p>We don’t have to worry about injecting it as it is not reaching an external dependency; it is just executing some C# code, or we might want to inject it to control how the <code>AddDays</code> method is being calculated. In our case here, injecting <code>AddDays</code> is not required.</p>
<p>The second point is the <code>Now</code> property. If we were to write a unit test that involves testing the value of <code>Now</code>, then we’d want to freeze it to a constant value to be able to test. At this stage, the picture of freezing it may not be clear, but it will be clearer when we unit test <code>GetRandom</code> in the next chapter.</p>
<p>We need to provide an<a id="_idIndexMarker169"/> injected <code>Now</code> property, but <code>Now</code> is a <strong class="bold">static property</strong>, as we can see here:</p>
<pre class="source-code">public static DateTime Now</pre>
<p>Static properties (and methods) do not adhere to the same polymorphism principles that instance properties adhere to. So, we need to figure out another way to inject <code>Now</code> than what we used before. </p>
<p>The next code is preparing <code>Now</code> in a way suitable to work polymorphically. Create an interface like this one to act as an abstraction:</p>
<pre class="source-code">public interface INowWrapper
{
    DateTime Now { get; }
}</pre>
<p>We will have our code depending on this abstraction type. Also, we will have to provide an implementation for a concrete <code>NowWrapper</code> class, so our code simply looks like this: </p>
<pre class="source-code">public class NowWrapper : INowWrapper
{
    public DateTime Now =&gt; DateTime.Now;
}</pre>
<p>I have added two files under a directory called <code>Wrappers</code> in the project. I have added <code>INowWrapper.cs</code> and <code>NowWrapper.cs</code> under it.</p>
<p class="callout-heading">Wrapper and Provider</p>
<p class="callout">Some developers like to have a <code>Wrapper</code> suffix for this category of types, and others like to use a <code>Provider</code> suffix such as <code>NowProvider</code>. I don’t like to use the name <code>Provider</code> as it is already a design pattern and it might be misleading. My advice is to pick one convention and stay consistent.</p>
<p>As usual, we have two<a id="_idIndexMarker170"/> points to consider when registering a non-concrete type for injection, as follows:</p>
<ol>
<li value="1">How to create the required service?</li>
<li>What is the lifetime of the created service?</li>
</ol>
<p>The first point is easy—we just instantiate the <code>NowWrapper</code> class. The second point depends on the <code>DateTime.Now</code> original property. Since I know that this is a web environment where multiple requests may be hitting my static property simultaneously, the first thing I would be checking is the popular .NET thread-safety topic. In other words, if this property is accessed simultaneously by multiple threads, would that lead to undetermined behavior?</p>
<p>Static members of <code>DateTime</code>, including the <code>Now</code> property, are written with thread safety in mind, so calling <code>Now</code> simultaneously should not lead to an undetermined behavior. </p>
<p>Given this is the case, then I can have my DI as a singleton. Let’s register <code>INowWrapper</code> for<a id="_idIndexMarker171"/> injection. As with the previous example, add <code>INowWrapper</code> to the controller constructor, like this:</p>
<pre class="source-code">public WeatherForecastController(, <strong class="bold">INowWrapper nowWrapper</strong>, )
{
    <strong class="bold">_nowWrapper = nowWrapper;</strong>
…</pre>
<p>Replace <code>DateTime.Now</code> with <code>_nowWrapper.Now</code>, as follows:</p>
<pre class="source-code">wf.Date = _nowWrapper.Now.AddDays(i + 1);</pre>
<p>And lastly, register your dependency in the <code>Program.cs</code> file, using the following code:</p>
<pre class="source-code">builder.Services.AddSingleton&lt;INowWrapper&gt;(_ =&gt; 
    new NowWrapper());</pre>
<p>This means that when the first <code>INowWrapper</code> instance is requested, the DI container will instantiate it and keep it for the lifetime of the application.</p>
<h3>Injecting the random generator</h3>
<p>The random number<a id="_idIndexMarker172"/> generator is unpredictable by design; otherwise, it wouldn’t be random! There is a problem in unit testing it if it is not DI-injected, because the unit tests should be testing against a fixed (determined) value. Let’s look at the offending line here:</p>
<pre class="source-code">wf.TemperatureC = Random.Shared.Next(-20, 55);</pre>
<p><code>Shared</code> is a static method, so we have the same issue that we had in the previous task with <code>Now</code>. First, we need to determine thread safety. There is no definite mention in the <code>Next</code> documentation if it is thread-safe; on the contrary, claims online mention that it is not thread-safe. So, the safest option here is to assume that it is not thread-safe. Here, we can wrap the entire class or the particular method. I will choose to wrap the entire class in case we need it<a id="_idIndexMarker173"/> later to use another method from the <code>Random</code> class. Let’s write our interface, as follows:</p>
<pre class="source-code">public interface IRandomWrapper
{
    int Next(int minValue, int maxValue);
}</pre>
<p>And here, we have the concrete class implementing it:</p>
<pre class="source-code">public class RandomWrapper : IRandomWrapper
{
    private readonly Random _random = Random.Shared;
    public int Next(int minValue, int maxValue)
        =&gt; _random.Next(minValue, maxValue);
}</pre>
<p>Add this as usual to the controller constructor and replace the code in <code>GetRandom</code> with this:</p>
<pre class="source-code">wf.TemperatureC = _randomWrapper.Next(-20, 55);</pre>
<p>I did change the behavior slightly in the class; initially, it was creating a new <code>Random</code> instance every time we call <code>Next</code>, but now it is creating one <code>_randomWrapper</code> per requesting class.</p>
<p>As our <code>Next</code> class implementation depends on the thread-unsafe <code>_random.Next</code>, then our class is not thread-safe as well. So, when injecting it, we cannot inject it as a singleton; we have to inject it as a transient, so our <code>Program.cs</code> code looks like this:</p>
<pre class="source-code">builder.Services.AddTransient&lt;IRandomWrapper&gt;(_ =&gt; 
    new RandomWrapper());</pre>
<p>This might have worked as a <code>AddScoped</code> registration method, but the documentation is insufficient for me to decide, and transient is always the safest.</p>
<p>You can now run the application, and from the Swagger UI, execute both APIs to make sure that everything is working as expected.</p>
<p>The DI changes that we<a id="_idIndexMarker174"/> have done are all in the <code>Ch02</code> source code in GitHub under a directory called <code>03-UqsWeather</code>.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor060"/>Lifelike DI scenario</h2>
<p>The most common scenario for<a id="_idIndexMarker175"/> using DI is with unit testing, though I have seen it being used elsewhere to change the behavior of a certain component at runtime. Take the case where you want to change a functionality of a system based on a configuration, and another case where you want to change a system behavior per hosting environment. Consider the next example of <strong class="bold">load-testing</strong> our WFA application.</p>
<h3>Using DI as a load-testing example</h3>
<p>A common <strong class="bold">non-functional requirement</strong> (<strong class="bold">NFR</strong>) for critical systems is load testing. Load testing is an artificial simulation of calls to a system to measure how it handles high volumes of concurrent calls. For our WFA, load testing would look like this:</p>
<div><div><img alt="Figure 2.14 – WFA under load testing " height="575" src="img/Figure_2.14_B18370.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – WFA under load testing</p>
<p>A load-testing framework would start the test by issuing a pre-agreed number of calls to the APIs and measuring response times and failures. In turn, the APIs will exert loads on their dependencies. </p>
<p>The complete WFA might have multiple dependencies, but what we are interested in specifically, in this<a id="_idIndexMarker176"/> example, is the <em class="italic">OpenWeather</em> API that we are calling in the background. If we are to load-test the WFA application, we will, by design, issue a heavy number of calls to <em class="italic">OpenWeather</em> and this <em class="italic">should not</em> be the case, for many reasons. Here are a few:</p>
<ul>
<li>Consuming the number of allocated calls quota</li>
<li>Contractual agreement against load-testing their system through yours</li>
<li>Being banned for an exorbitant number of calls in a short period</li>
<li>Ethical reasons, as this might affect their overall service quality</li>
</ul>
<p>Unless your system requires specifically to load-test with the third party connected and you have an agreement with the third party to do so, I wouldn’t do it.</p>
<p>What can we do to work around this and conduct our load test without calling <em class="italic">OpenWeather</em>?</p>
<p>A solution could be to add a configuration key to the WFA. When this key is <code>true</code>, we want every call in all our application to <em class="italic">OpenWeather</em> to return a stubbed response (canned response). More about dummy, mock, stub, and fake will be discussed in the next chapter. For now, we will refer to this type of response as a stubbed response.</p>
<h4>Enabling an OpenWeather stubbed response</h4>
<p>Let’s enable a stub response representing OpenWeather. Where do we start? I would directly look for the <em class="italic">seam</em> that is causing the call to OpenWeather. It is in our <code>WeatherForecastController</code> class, as illustrated here:</p>
<pre class="source-code">OneCallResponse res = await _client.<strong class="bold">OneCallAsync</strong>(…)</pre>
<p>What we need to do is to keep the previous code the same but make this method change behavior by not going over the network and instead return some saved value when under a load test. Here is the plan to achieve this:</p>
<ol>
<li value="1">Add a configuration to denote load testing.</li>
<li>Add a stubbed response class.</li>
<li>Register a condition to swap responses based on the configuration.</li>
</ol>
<h4>Adding configuration</h4>
<p>We want the configuration to be off by default unless we explicitly set it <em class="italic">on</em>. In your <code>appsettings.json</code> file, add the following code:</p>
<pre class="source-code">"LoadTest": {
  "IsActive" : false 
}, …</pre>
<p>And in our <code>appsettings.Development.json</code> file, add the same configuration, but set it to <code>true</code>. This should result in <code>true</code> when you load the application locally.</p>
<h4>Adding the stub class</h4>
<p><code>OneCallAsync</code> is a method on the <code>IClient</code> interface. If you look at the code, we are passing the <code>client</code> object, which becomes <code>_client</code>, as an argument to the constructor. Here is where we can do some magic—we need to pass to the constructor our stubbed implementation of <code>IClient</code>, then figure out a way to pass it through the constructor.</p>
<p>Add a class called <code>ClientStub</code> to the root of your project to hold the implementation of our stubbed <code>IClient</code> interface, as follows:</p>
<pre class="source-code">public class ClientStub : IClient
{
    public Task&lt;OneCallResponse&gt; OneCallAsync(
        decimal latitude, decimal longitude, 
        IEnumerable&lt;Excludes&gt; excludes, Units unit) 
    {
        const int DAYS = 7;
        OneCallResponse res = new OneCallResponse();
        res.Daily = new Daily[DAYS];
        DateTime now = DateTime.Now;
        for (int i = 0; i &lt; DAYS; i++)
        {
            res.Daily[i] = new Daily();
            res.Daily[i].Dt = now.AddDays(i);
            res.Daily[i].Temp = new Temp();
            res.Daily[i].Temp.Day = 
                Random.Shared.Next(-20, 55);
        }
        return Task.FromResult(res);
    }
}</pre>
<p><code>IClient</code> is defined in the NuGet package for the <em class="italic">OpenWeather </em>client. It has one method to implement <code>OneCallAsync</code>. I looked for the used properties and generated a 7-day fake forecast. Note that you might need to make a full stub in other scenarios.</p>
<p>Now, both <code>Client</code> and <code>ClientStub</code> implement <code>IClient</code>, as per this diagram:</p>
<div><div><img alt="Figure 2.15 – IClient, Client, and ClientStub relationship " height="288" src="img/Figure_2.15_B18370.jpg" width="446"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – IClient, Client, and ClientStub relationship</p>
<p>Now comes the step that developers forget to do often: registering the service. Remember that every time you forget to register a service, you are not alone. </p>
<h4>Updating IClient registration</h4>
<p>We are going to use our DI container to decide when to inject an instance of <code>Client</code> and when to inject an instance of <code>ClientStub</code>. In <code>Program.cs</code>, modify the initial register of <code>IClient</code> so that it looks like this:</p>
<pre class="source-code">builder.Services.AddSingleton&lt;IClient&gt;(_ =&gt; {
    bool isLoad =      
    bool.Parse(builder.Configuration["LoadTest:IsActive"]);
    if (isLoad) return new ClientStub();
    else
    {
        string apiKey = 
            builder.Configuration["OpenWeather:Key"];
        HttpClient httpClient = new HttpClient();
        return new Client(apiKey, httpClient);
    }
});</pre>
<p>Whenever an instance of <code>IClient</code> is requested, the DI container will decide what to inject, <code>ClientStub</code> or <code>Client</code>, based on the configuration.</p>
<p>We now have the stubbing implementation completed and ready to run. Have a look at the output of the <code>GetReal</code> method when you run the project. You will notice you are getting the stubbed version if you’ve enabled load testing.</p>
<h3>Points to note</h3>
<p>We have seen, dare I say it, a beautiful way of swapping implementation. While this example is small and contained, the implementation will shine more in larger projects. Consider these points:</p>
<ul>
<li><strong class="bold">Separation of concerns</strong> where the code to load different versions is taken away from the controller class to the registration section.</li>
<li>The developer will not need to worry about or remember to do additional implementation when passing <code>IClient</code> to new controllers.</li>
</ul>
<p>Similar to this scenario, you can use DI whenever a swap of implementation is required under certain conditions.</p>
<p>This scenario is located in the <code>Ch02</code> source code in GitHub under a directory called <code>04-UqsWeather</code>.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor061"/>Method injection</h2>
<p>You have seen across the chapter that we have been injecting parameters through the constructor. There is another less popular form of injection, called <strong class="bold">method injection</strong>. This is an example from the WFA controller:</p>
<pre class="source-code">public double ConvertCToF(double c,
    <strong class="bold">[FromServices] ILogger&lt;WeatherForecastController&gt;</strong>
       <strong class="bold">logger</strong>)
{
    double f = c * (9d / 5d) + 32;
    <strong class="bold">logger</strong>.LogInformation("conversion requested");
    return f;
}</pre>
<p>Notice the <code>FromServices</code> attribute. This instructs the DI container to inject a dependency into a method in the same way it is injected into a constructor. Obviously, this is not needed in a constructor.</p>
<p>You would use method injection when you have multiple methods in a class. One of them uses a special service. The benefit here is a cleaner class constructor and a bit of performance saving because the class—for example, the controller—might be instantiated, but the injection service would have a chance of not being used. So, there is a performance waste in injecting it but not using it.</p>
<p>In this example case, the logger was only used in the <code>ConvertCToF</code> method, so it can be moved from the constructor to the method. It needs to be injected only when <code>ConvertCToF</code>, not the controller, is instantiated to serve any other method.</p>
<p>Best practices recommend classes with a single responsibility. This leads to related methods with related services, so you won’t find method injection as a popular pattern, but method injection is there if you need it.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor062"/>Property injection</h2>
<p><strong class="bold">Property injection</strong> is injecting a service into a property on a class. This is not supported by Microsoft containers, but it is supported by third-party containers.</p>
<p>I have seen this used with legacy systems where a DI container is gradually being introduced and code changes are at a minimum. However, I have never seen or used this in a greenfield application.</p>
<p>I trust that it was not added to the Microsoft container, as it is not popular and not encouraged.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor063"/>Service locator</h2>
<p>Every container comes with or integrates with a <strong class="bold">service locator</strong>. A service locator finds and activates a registered service. So, the DI container registers a service and the service locator resolves what is already registered. Here is a typical pattern of using a service locator:</p>
<pre class="source-code">public class SampleClass
{
    private readonly IServiceProvider _serviceProvider;
    public SampleClass(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    public void Method()
    {
        MyClass myClass = 
            <strong class="bold">_serviceProvider.GetService</strong>&lt;IMyClass&gt;();
        myClass.DoSomething();
    }
}</pre>
<p><code>IServiceProvider</code> is an abstraction that supports service location. It can be injected into a class like any other service. Notice when we called the <code>GetService</code> method that it got us whatever is registered with <code>IMyClass</code>.</p>
<p>Obviously, you could have done the same thing by injecting <code>IMyClass</code> into the constructor, and it is even better to do so. You can see this being done here: </p>
<pre class="source-code">public SampleClass(IMyClass myClass) </pre>
<p>But there are situations where you will want to avoid injection and prefer to use a service locator. This is more often used in legacy applications where DI is not fully implemented.</p>
<p>Using a service locator in code will complicate your unit tests, so it is better avoided, and some practitioners would consider using it as an anti-pattern.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>Summary</h1>
<p>This is a long chapter, I admit, but my defense is that it has plenty of examples to cover many real-life DI scenarios. Also, DI automatically encourages good software engineering practices, so we had to include the relevant practices. If you were to develop TDD-style, you would spend around 10% of your coding time doing DI-related tasks, and I hope this chapter did the right job and added to your knowledge.</p>
<p>DI is mainly used with unit tests, so without it, DI may feel less interesting. The next chapter, <em class="italic">Getting Started with Unit Testing</em>, will use the WFA application that we refactored here, and hopefully, you will appreciate further this design pattern.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor065"/>Further reading</h1>
<p>To learn more about the topics discussed in the chapter, you can refer to the following links:</p>
<ul>
<li><em class="italic">IoC</em>: <a href="https://martinfowler.com/bliki/InversionOfControl.xhtml">https://martinfowler.com/bliki/InversionOfControl.xhtml</a></li>
<li><em class="italic">DI in ASP.NET Core</em>: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</a></li>
</ul>
</div>
</div>
</body></html>