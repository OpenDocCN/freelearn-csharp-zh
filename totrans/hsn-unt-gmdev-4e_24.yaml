- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: AR/VR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AR/VR
- en: Unity has expanded beyond gaming into various fields, such as simulations, training,
    and app development. In its latest versions, notable improvements in augmented
    reality (AR) technologies have been introduced. In the latest versions of Unity,
    we have seen lots of improvements in the field of augmented reality, which allows
    us to add a layer of virtuality on top of our reality, thereby augmenting what
    our device can perceive to create games that rely on real-world data, such as
    the camera’s image, our real-world position, and the current weather. This can
    also be applied to work environments, such as when viewing the building map or
    checking the electrical ducts inside a wall. Welcome to the extra section of this
    book, where we are going to discuss how to create **Augmented Reality** (**AR**)
    applications using Unity’s AR Foundation package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity已经从游戏扩展到各个领域，如模拟、培训和应用程序开发。在其最新版本中，引入了显著的增强现实（AR）技术改进。在Unity的最新版本中，我们在增强现实领域看到了许多改进，这使得我们能够在我们的现实之上添加一层虚拟性，从而增强我们的设备所能感知的内容，以创建依赖于现实世界数据的游戏，例如摄像机的图像、我们的现实世界位置和当前的天气。这也可以应用于工作环境，例如查看建筑图或检查墙内的电线管道。欢迎来到本书的额外部分，我们将讨论如何使用Unity的AR
    Foundation包创建**增强现实**（**AR**）应用程序。
- en: 'In this chapter, we will examine the following AR Foundation concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下AR Foundation概念：
- en: Using AR Foundation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AR Foundation
- en: Building for mobile devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Creating a simple AR game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的AR游戏
- en: By the end of this chapter, you will be able to create AR apps using AR Foundation
    and will have a fully functional game that uses its framework so that you can
    test the framework’s capabilities.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用AR Foundation创建AR应用程序，并将拥有一个使用其框架的完整功能游戏，以便你可以测试框架的功能。
- en: Let’s start by exploring the AR Foundation framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索AR Foundation框架。
- en: Using AR Foundation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AR Foundation
- en: 'In this section, we will examine the following AR Foundation concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下AR Foundation概念：
- en: Creating an AR Foundation project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建AR Foundation项目
- en: Using tracking features
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: Let’s start by discussing how to prepare our project so that it can run AR Foundation
    apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何准备我们的项目，以便它可以运行AR Foundation应用程序。
- en: Creating an AR Foundation project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AR Foundation项目
- en: Transitioning to AR development not only changes coding practices but also the
    game design approach. For instance, in AR, user interaction and camera control
    are significantly different.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 转向AR开发不仅改变了编码实践，还改变了游戏设计方法。例如，在AR中，用户交互和相机控制有显著的不同。
- en: Something to consider when creating AR projects is that we will change not only
    the way we code our game but also the game design aspect. AR apps have differences,
    especially in the way the user interacts, and also limitations, such as the user
    being in control of the camera all the time. We cannot simply port an existing
    game to AR without changing the very core experience of the game. That’s why,
    in this chapter, we are going to work on a brand-new project; it would be too
    difficult to change the game we’ve created so far so that it works well in AR.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建AR项目时需要考虑的是，我们将改变不仅是我们编写游戏的方式，还有游戏设计方面。AR应用程序有差异，尤其是在用户交互的方式上，以及限制，例如用户始终控制相机。我们不能简单地将现有游戏移植到AR，而不改变游戏的核心体验。这就是为什么在本章中，我们将着手一个全新的项目；改变我们迄今为止创建的游戏以使其在AR中运行将非常困难。
- en: 'In our case, we are going to create a game where the user controls a player
    moving a “marker,” a physical image you can print that will allow our app to recognize
    where the player is in the real world. We will be able to move the player while
    moving that image, and this virtual player will automatically shoot at the nearest
    enemy. Those enemies will spawn from certain spawn points that the user will need
    to place in different parts of the home. As an example, we can put two spawn points
    on the walls and place our player marker on a table in the middle of the room
    so that the enemies will go toward them. In the following image, you can see a
    preview of what the game will look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建一个游戏，用户控制一个移动“标记”的玩家，这是一个你可以打印的物理图像，它将允许我们的应用程序识别玩家在现实世界中的位置。我们可以在移动该图像的同时移动玩家，这个虚拟玩家将自动射击最近的敌人。这些敌人将从用户需要在房屋不同部分放置的特定出生点生成。例如，我们可以在墙上放置两个出生点，并将我们的玩家标记放在房间中间的桌子上，这样敌人就会朝它们走去。在下面的图像中，你可以看到游戏的预览：
- en: '![A computer on a table  Description automatically generated with low confidence](img/B21361_20_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![桌子上的一台电脑  描述由低置信度自动生成](img/B21361_20_01.png)'
- en: 'Figure 20.1: Finished game. The Cylinder is an enemy spawner, the Capsule is
    the enemy, and the Cube is the player. These are positioned in a marker image
    displayed by the cellphone'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1：完成的游戏。圆柱体是敌人生成器，胶囊体是敌人，立方体是玩家。这些都在手机显示的标记图像中定位
- en: We’ll start creating a new URP-based project in the same way we created our
    previous game. Something to consider is that AR Foundation works with other pipelines,
    including built-in ones, in case you want to use it in already existing projects.
    If you don’t remember how to create a project or use the Package Manager, please
    refer to *Chapter 1*, *Embark on Your Unity Journey*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以创建我们之前游戏相同的方式开始创建一个新的基于URP的项目。需要考虑的是，AR Foundation可以与其他管道一起工作，包括内置的管道，如果您想在现有项目中使用它。如果您不记得如何创建项目或使用包管理器，请参阅*第1章*，*踏上您的Unity之旅*。
- en: Once you’re in your new blank project, install the AR Foundation package from
    the Package Manager, just like we’ve installed other packages previously—that
    is, from **Window** | **Package Manager**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入您的新空白项目，就像我们之前安装其他包一样，从包管理器安装AR Foundation包——即从**窗口** | **包管理器**。
- en: Remember to set the Package Manager so that it shows all packages, not only
    the ones in the project (the **Packages** button at the top-left part of the window
    needs to be set to **Unity Registry**) and also the preview versions (click on
    the wheel icon, then **Project Settings**, and check **Enable Pre-release Packages**
    on the window that appears).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住设置包管理器，使其显示所有包，而不仅仅是项目中的包（窗口左上角的**包**按钮需要设置为**Unity注册表**）以及预览版本（点击轮形图标，然后**项目设置**，并在出现的窗口上检查**启用预发布包**）。
- en: At the time of writing this book, the latest stable release is 5.1.0 version.
    While we use version 5.1.0 of AR Foundation for this example, always check for
    the most current stable version for your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新稳定版本是5.1.0版本。虽然我们在这个例子中使用AR Foundation的5.1.0版本，但始终检查您项目中最新的稳定版本。
- en: 'As usual, if a warning prompting you to enable the new input system appears,
    click **Yes**:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，如果出现提示您启用新输入系统的警告，请点击**是**：
- en: '![](img/B21361_20_02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_02.png)'
- en: 'Figure 20.2: Installing AR Foundation'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2：安装AR Foundation
- en: Before we install any other needed packages, now is a good moment to discuss
    some core ideas of the AR Foundation framework. This package, by itself, does
    nothing; it defines a series of AR features that mobile devices offer, such as
    image tracking, cloud points, and object tracking, but the actual implementation
    of how to do that is contained in the **Provider** packages, such as the **Apple
    ARKit XR Plugin** and **Google ARCore XR plugin** packages. This is designed like
    this because, depending on the target device you want to work with, the way those
    features are implemented changes. As an example, in iOS, Unity implements those
    features using ARKit, while in Android, it uses ARCore; they are platform-specific
    frameworks. Remember to install the same version of these platform packages as
    the AR Foundation one (5.0.0 preview 13 in this case).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装任何其他需要的包之前，现在是讨论AR Foundation框架核心思想的好时机。这个包本身没有任何作用；它定义了一系列移动设备提供的AR功能，如图像跟踪、云点和对象跟踪，但实际如何实现这些功能的实现包含在**Provider**包中，例如**Apple
    ARKit XR插件**和**Google ARCore XR插件**包。这样设计是因为，根据您想要与之合作的目标设备，实现这些功能的方式会改变。例如，在iOS中，Unity使用ARKit实现这些功能，而在Android中，它使用ARCore；它们是平台特定的框架。请记住安装与AR
    Foundation相同版本的这些平台包（在本例中为5.0.0预览版13）。
- en: 'Something to consider here is that not all iOS or Android devices support AR
    Foundation apps. You might find an updated list of supported devices when searching
    for ARCore- and ARKit-supported devices on the internet. At the time of writing,
    the following links provide the supported devices lists:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的是，并非所有iOS或Android设备都支持AR Foundation应用。您在网上搜索ARCore和ARKit支持的设备时，可能会找到一个更新的支持设备列表。在撰写本书时，以下链接提供了支持设备列表：
- en: '**iOS**: [https://www.apple.com/lae/augmented-reality](https://www.apple.com/lae/augmented-reality)
    (at the bottom of the page)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**: [https://www.apple.com/lae/augmented-reality](https://www.apple.com/lae/augmented-reality)（页面底部）'
- en: '**Android**: [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**: [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)'
- en: Also, there isn’t a PC provider package, so the only way to test AR Foundation
    apps so far is directly on the device, but testing tools are going to be released
    soon. In my case, I will be creating an app for iOS, so aside from the **AR Foundation**
    package, I need to install the **ARKit XR** plugin.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，目前还没有PC提供程序包，因此迄今为止测试AR Foundation应用程序的唯一方法是直接在设备上，但测试工具很快就会发布。在我的情况下，我将为iOS创建一个应用程序，因此除了**AR
    Foundation**程序包之外，我还需要安装**ARKit XR**插件。
- en: However, if you want to develop for Android, install the **ARCore XR** plugin
    instead (or both if you’re targeting both platforms). Also, I will be using the
    5.1.1 version of these packages. Usually, the versions of the **AR Foundation**
    and **Provider** packages match but apply the same logic as when you picked the
    **AR Foundation** version.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要为Android开发，请安装**ARCore XR**插件（或者如果你针对两个平台，则两者都安装）。此外，我将使用这些包的5.1.1版本。通常，**AR
    Foundation**和**Provider**包的版本是一致的，但应用相同的逻辑，就像你选择**AR Foundation**版本时一样。
- en: 'Now that we have the needed plugins, we need to prepare a scene for AR as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的插件，我们需要为AR准备一个场景，如下所示：
- en: Create a new Scene in **File | New Scene** and select the **Basic (URP)** template.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件 | 新场景**中创建一个新的场景，并选择**基本（URP）**模板。
- en: Delete the **Main Camera**; we are going to use a different one.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**主摄像头**；我们将使用不同的一个。
- en: In the **GameObject | XR** menu, create an **AR Session** GameObject.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**GameObject | XR**菜单中，创建一个**AR会话**GameObject。
- en: In the same menu, create an **XR Origin (Mobile AR)** object that has a **Camera**
    inside it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的菜单中，创建一个包含**摄像头**的**XR原点（移动AR）**对象。
- en: Select **Main Camera** inside **XR Origin**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**XR原点**内部选择**主摄像头**。
- en: Set the **Render Mode** property of the **AR Camera Manager** component to **After
    Opaques**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR摄像头管理器**组件的**渲染模式**属性设置为**在不透明物体之后**。
- en: 'Your hierarchy should look as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的层次结构应该如下所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_20_03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B21361_20_03.png)'
- en: 'Figure 20.3: Starter AR Scene'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.3：AR入门场景
- en: The **AR Session** object will be responsible for initializing the AR framework
    and will handle all the update logic for the AR systems. The **XR Origin** object
    will allow the framework to locate tracked objects, such as images and point clouds,
    in a relative position to the scene. The devices inform the positions of tracked
    objects relative to what the device considers “the origin.” This is usually the
    first area of your house you were pointing at when the app started detecting objects,
    so the **XR Origin** object will represent that point in your physical space.
    Finally, you can check the camera inside the origin, which contains some extra
    components, the most important being the **Tracked Pose Driver**, which will make
    your **Camera** object move along with your device. Since the device’s position
    is relative to the Session Origin object’s point, the camera needs to be inside
    the origin object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话**对象将负责初始化AR框架，并将处理AR系统的所有更新逻辑。**XR原点**对象将允许框架定位跟踪对象，如图像和点云，相对于场景的相对位置。设备会告知跟踪对象相对于设备认为的“原点”的位置。这通常是在应用程序开始检测对象时你指向的第一个区域，因此**XR原点**对象将代表你物理空间中的那个点。最后，你可以检查原点内的摄像头，它包含一些额外的组件，其中最重要的是**跟踪姿态驱动器**，它将使你的**摄像头**对象随着设备移动。由于设备的位姿是相对于会话原点对象点的，因此摄像头需要位于原点对象内部。'
- en: 'One extra step in case you are working on a URP project (our case) is that
    you need to set up the render pipeline so that it supports rendering the camera
    image in the app. To do that, go to the `Settings` folder that was generated when
    we created the project, look for the `URP-HighFidelity-Renderer` file, and select
    it. In the **Renderer Features** list, click the **Add Renderer Feature** button
    and select **AR Background Renderer Feature**. In the following screenshot, you
    can see what the Forward Renderer asset should look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在进行URP项目（我们的情况），还需要额外的一步，即你需要设置渲染管线，以便它支持在应用程序中渲染摄像头图像。为此，前往我们创建项目时生成的`Settings`文件夹，查找`URP-HighFidelity-Renderer`文件，并选择它。在**渲染器功能**列表中，点击**添加渲染器功能**按钮并选择**AR背景渲染器功能**。在下面的屏幕截图中，你可以看到前向渲染器资产应该看起来是什么样子：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_20_04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B21361_20_04.png)'
- en: 'Figure 20.4: Adding support for URP'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.4：为URP添加支持
- en: And that’s all! We are ready to start exploring the AR Foundation components
    so that we can implement tracking features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们准备好开始探索 AR Foundation 组件，以便我们可以实现跟踪功能。
- en: Using tracking features
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: 'For our project, we are going to need two of the most common tracking features
    in AR (but not the only ones): image recognition and plane detection. The first
    one consists of detecting the position in the real world of a specific image so
    that we can place digital objects on top of it, such as the player. The second
    one, plane detection, consists of recognizing real-life surfaces, such as floors,
    tables, and walls, so that we have a reference of where we can put objects, such
    as the enemy’s spawn points. Only horizontal and vertical surfaces are recognized
    (just vertical surfaces on some devices).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们需要两个最常用的 AR 跟踪功能（但不是唯一的）：图像识别和平面检测。第一个功能是检测特定图像在现实世界中的位置，以便我们可以在其上方放置数字对象，例如玩家。第二个功能，平面检测，包括识别现实生活中的表面，例如地板、桌子和墙壁，以便我们有放置对象（例如敌人的出生点）的参考。只有水平和垂直表面被识别（某些设备上仅识别垂直表面）。
- en: 'The first thing we need to do is tell our app which images it needs to detect,
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是告诉我们的应用程序它需要检测哪些图片，如下所示：
- en: Add an image to the project that you can print or display on a mobile device.
    Having a way to display the image in the real world is necessary to test this.
    In this case, I will use the following image:![A picture containing gravel, pebble,
    rock, rubble  Description automatically generated](img/B21361_20_05.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一张可以打印或显示在移动设备上的图片添加到项目中。在现实世界中显示图片的方式对于测试这是必要的。在这种情况下，我将使用以下图片：![包含砾石、鹅卵石、岩石、碎石的图片  自动生成的描述](img/B21361_20_05.png)
- en: 'Figure 20.5: Image to track'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 20.5：要跟踪的图片
- en: Try to get an image that contains as many features as you can. This means an
    image with lots of little details, such as contrasts, sharp corners, and so on.
    Those are what our AR systems use to detect it; the more detail, the better the
    recognition. If your device has trouble detecting our current image, try other
    images (the classic QR code might help).
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽量获取包含尽可能多特征的图片。这意味着一张有很多小细节的图片，例如对比度、尖锐的角落等。这些都是我们的 AR 系统用来检测它的；细节越多，识别效果越好。如果你的设备在检测我们当前的图片时遇到困难，请尝试其他图片（经典的
    QR 码可能有所帮助）。
- en: Consider that some devices might have trouble with certain images, such as the
    image suggested in this book. If this generates issues when testing, please try
    using another one. You will be testing this on your device in the upcoming sections
    of this chapter, so just keep this in mind.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到某些设备可能对某些图片有困难，例如这本书中建议的图片。如果在测试时产生问题，请尝试使用另一张图片。你将在本章接下来的部分中在自己的设备上测试这个功能，所以请记住这一点。
- en: 'Create a **Reference Image Library**, an asset containing all the images we
    wish our app to recognize, by clicking the **+** button in **Project Panel** and
    selecting **XR | Reference Image Library**:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **项目面板** 中点击 **+** 按钮，并选择 **XR | Reference Image Library** 来创建一个 **Reference
    Image Library**，这是一个包含我们希望应用程序识别的所有图片的资产：
- en: '![](img/B21361_20_06.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_06.png)'
- en: 'Figure 20.6: Creating a Reference Image Library'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.6：创建参考图像库
- en: Select the **Reference Image Library** asset we created and click the **Add
    Image** button to add a new image to the library.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们创建的 **Reference Image Library** 资产，并点击 **添加图片** 按钮将新图片添加到库中。
- en: Drag the texture to the texture slot (the one that says **None**).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理拖动到纹理槽中（标有 **None** 的那个）。
- en: 'Turn **Specify Size** on and set **Physical Size** to the size that your image
    will be printed in, in real life, in meters. Try to be accurate here; on some
    devices, not having this value right might result in the image not being tracked:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **指定大小** 并将 **物理大小** 设置为图片在现实生活中的打印尺寸，单位为米。在这里尽量准确；在某些设备上，如果没有这个值，可能会导致图片无法被跟踪：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_20_07.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  使用低置信度自动生成的描述](img/B21361_20_07.png)'
- en: 'Figure 20.7: Adding an image to be recognized'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.7：添加要识别的图片
- en: 'Now that we’ve specified the images to be detected, let’s test this by placing
    a cube on top of the real-life image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了要检测的图片，让我们通过在现实生活中的图片上放置一个立方体来测试这个功能：
- en: Create a Prefab of a cube and add the **AR Tracked Image** component to it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体的 Prefab 并将其 **AR Tracked Image** 组件添加到其中。
- en: Remember to set a small scale, like `0.1`, on each axis, given that the default
    cube will be 1 meter by 1 meter, which will be huge in AR.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，在x轴、y轴和z轴上设置一个小的比例，例如`0.1`，因为默认的立方体将是1米乘1米，这在增强现实（AR）中会显得非常大。
- en: Add the **AR Tracked Image Manager** component to the **XR Origin** object.
    This will be responsible for detecting images and creating objects in their position.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR跟踪图像管理器**组件添加到**XR起源**对象中。这将负责检测图像并在其位置创建对象。
- en: Drag the **Image Library** asset created in the previous steps to the **Serialized
    Library** property of the component to specify the images to recognize.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前步骤中创建的**图像库**资产拖放到组件的**序列化库**属性中，以指定要识别的图像。
- en: 'Drag the **Cube** Prefab to the **Tracked Image Prefab** property of the component:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**立方体**Prefab拖放到组件的**跟踪图像Prefab**属性中：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_20_08.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![电脑的截图  描述由中等置信度自动生成](img/B21361_20_08.png)'
- en: 'Figure 20.8: Setting up Tracked Image Manager'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.8：设置跟踪图像管理器
- en: 'And that’s all! Later, in the *Building for mobile* section in this chapter,
    when we create an iOS or Android build, we will see a cube spawning in the same
    position that the image is located in in the real world. Remember that you need
    to test this on the device, which we will do in the next section, so for now,
    let’s keep coding our test app:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！稍后，在本章的*为移动设备构建*部分，当我们创建iOS或Android版本时，我们将看到在现实世界中图像所在的位置生成一个立方体。请记住，您需要在设备上测试此功能，我们将在下一节中这样做，所以现在让我们继续编写我们的测试应用程序：
- en: '![A computer on a table  Description automatically generated with low confidence](img/B21361_20_09.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![桌子上的一台电脑  描述由低置信度自动生成](img/B21361_20_09.png)'
- en: 'Figure 20.9: Cube located on top of the image being displayed by the cellphone'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.9：位于手机显示图像顶部的立方体
- en: Let’s also prepare our app so that it can detect and display the plane surfaces
    the camera has recognized. This is simply done by adding the **AR Plane Manager**
    component to the **XR Origin** object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也准备我们的应用程序，以便它可以检测并显示相机识别的平面表面。这很简单，只需将**AR平面管理器**组件添加到**XR起源**对象中即可。
- en: '![](img/B21361_20_10.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_10.png)'
- en: 'Figure 20.10: Adding the AR Plane Manager component'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.10：添加AR平面管理器组件
- en: 'This component will detect surface planes over our house as we move the camera
    over it. It can take a while to detect them, so it’s important to visualize the
    detected areas to get feedback about this to ensure it’s working properly. We
    can manually get information about the plane from a component reference to AR
    Plane Manager, but luckily, Unity allows us to visualize planes easily. Let’s
    take a look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移动相机覆盖它时，该组件将检测我们房子上的表面平面。检测它们可能需要一段时间，因此可视化检测区域以获取有关此操作的反馈非常重要，以确保其正常工作。我们可以从AR平面管理器的组件引用手动获取有关平面的信息，但幸运的是，Unity允许我们轻松地可视化平面。让我们看看：
- en: Create a Prefab of a plane, first by creating the plane in **GameObject | 3D
    Object | Plane**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过在**GameObject | 3D Object | Plane**中创建平面来创建一个平面的Prefab。
- en: Add a **Line Renderer** to it. This will allow us to draw a line over the edges
    of the detected areas.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加一个**线渲染器**。这将允许我们在检测区域的边缘绘制线条。
- en: 'For more information about what a Line Renderer is, check this link: [https://docs.unity3d.com/Manual/class-LineRenderer.html](https://docs.unity3d.com/Manual/class-LineRenderer.html)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于线渲染器的更多信息，请查看此链接：[https://docs.unity3d.com/Manual/class-LineRenderer.html](https://docs.unity3d.com/Manual/class-LineRenderer.html)
- en: 'Set the **Width** property of the `Line Renderer` to a small value such as
    `0.01`, the **Color** gradient property to black, and uncheck **Use World Space**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Line Renderer`的**宽度**属性设置为一个小值，例如`0.01`，将**颜色渐变**属性设置为黑色，并取消选中**使用世界空间**：
- en: '![](img/B21361_20_11.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_11.png)'
- en: 'Figure 20.11: Setting the Line Renderer'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.11：设置线渲染器
- en: 'Remember to create a material with the appropriate shader (Universal Render
    Pipeline/Unlit) and set it as the material of the Line Renderer component under
    the Materials list property:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，创建一个具有适当着色器（通用渲染管线/无光照）的材质，并将其设置为线渲染器组件下材料列表属性的材料：
- en: '![](img/B21361_20_12.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_12.png)'
- en: 'Figure 20.12: Creating the Line Renderer material'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.12：创建线渲染器材质
- en: 'Also, create a transparent material and use it in the **MeshRenderer** plane.
    We want to be able to see through it so that we can easily see the real surface
    beneath:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，创建一个透明材质，并在**MeshRenderer**平面中使用它。我们希望能够透过它，这样我们就可以轻松地看到下面的真实表面：
- en: '![](img/B21361_20_13.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_13.png)'
- en: 'Figure 20.13: Material for the detected plane'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.13：检测平面的材质
- en: Add the **AR Plane** and **AR Plane Mesh Visualizer** components to the **Plane**
    Prefab.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AR Plane** 和 **AR Plane Mesh Visualizer** 组件添加到 **Plane** Prefab。
- en: 'Drag the Prefab to the **Plane Prefab** property of the **AR Plane Manager**
    component of the **XR Origin** object:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Prefab 拖动到 **XR Origin** 对象的 **AR Plane Manager** 组件的 **Plane Prefab** 属性中：
- en: '![](img/B21361_20_14.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_20_14.png)'
- en: 'Figure 20.14: Setting the plane visualization Prefab'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.14：设置平面可视化 Prefab
- en: Now, we have a way to see the planes, but seeing them is not the only thing
    we can do (sometimes, we don’t even want them to be visible). The real power of
    planes resides in placing virtual objects on top of real-life surfaces, tapping
    into a specific plane area, and getting its real-life position. We can access
    the plane data using **AR Plane Manager** or by accessing the **AR Plane** component
    of our visualization planes, but something easier is to use the **AR Raycast Manager**
    component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了查看平面的方法，但查看平面并不是我们能做的唯一事情（有时，我们甚至不希望它们可见）。平面的真正力量在于在现实生活中的表面上放置虚拟对象，点击特定的平面区域，并获取其实际位置。我们可以使用
    **AR Plane Manager** 或通过访问我们的可视化平面的 **AR Plane** 组件来访问平面数据，但更简单的方法是使用 **AR Raycast
    Manager** 组件。
- en: 'The **AR Raycast Manager** component provides us with the equivalent of the
    `Physics.Raycast` function of the Unity Physics system, which, as you may recall,
    is used to create imaginary rays that start from one position and go in a specified
    direction in order to make them hit surfaces and detect the exact hit point. The
    version provided by **AR Raycast Manager**, instead of colliding with physics
    colliders, collides with tracked objects, mostly point clouds (we are not using
    them) and the “planes” we are tracking. We can test this feature by following
    these steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Raycast Manager** 组件为我们提供了与 Unity 物理系统中的 `Physics.Raycast` 函数等效的功能，如您所记得，它用于创建从某个位置开始并沿指定方向延伸的假想射线，以便它们击中表面并检测确切的击中点。**AR
    Raycast Manager** 提供的版本，而不是与物理碰撞体碰撞，而是与跟踪对象碰撞，主要是点云（我们未使用它们）和我们正在跟踪的“平面”。我们可以通过以下步骤测试此功能：'
- en: Add the **AR Raycast Manager** component to the **XR Origin** object.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AR Raycast Manager** 组件添加到 **XR Origin** 对象中。
- en: Create a custom script called `SpawnerPlacer` in the **XR Origin** object.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **XR Origin** 对象中创建一个名为 `SpawnerPlacer` 的自定义脚本。
- en: In the **Awake** cache, add the reference to `ARRaycastManager`. You will need
    to add the `using UnityEngine.XR.ARFoundation;` line to the top of the script
    for this class to be usable in our script.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Awake** 缓存中添加 `ARRaycastManager` 的引用。您需要将 `using UnityEngine.XR.ARFoundation;`
    语句添加到脚本顶部，以便在这个类在我们的脚本中使用。
- en: 'Create a private field of the `List<ARRaycastHit>` type and instantiate it;
    the Raycast function is going to detect every plane our ray hit, not just the
    first one:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `List<ARRaycastHit>` 类型的私有字段并实例化它；射线函数将检测我们的射线击中的每个平面，而不仅仅是第一个平面：
- en: '![](img/B21361_20_15.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_20_15.png)'
- en: 'Figure 20.15: List to store hits'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.15：存储碰撞的列表
- en: Under **Update**, check if the touch screen is pressed (`Touchscreen.current.primaryTouch.press.isPressed`).
    You will need `using UnityEngine.InputSystem;` `using` is at the top of the file
    to use the new input system.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Update** 中检查触摸屏是否被按下（`Touchscreen.current.primaryTouch.press.isPressed`）。您需要添加
    `using UnityEngine.InputSystem;` 语句到文件顶部以使用新的输入系统。
- en: Inside the `if` statement from the previous step, add another condition for
    calling the `Raycast` function of **AR Raycast Manager**, passing the position
    of the touch as the first parameter and the list of hits as the second (`Touchscreen.current.primaryTouch.position.ReadValue()`).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的 `if` 语句中，为调用 **AR Raycast Manager** 的 `Raycast` 函数添加另一个条件，将触摸位置作为第一个参数，将碰撞列表作为第二个参数（`Touchscreen.current.primaryTouch.position.ReadValue()`）。
- en: This will throw a Raycast in the direction in which the player touches the screen
    and stores the hits inside the list we provided. This will return `true` if something
    has been hit and `false` if not.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在玩家触摸屏幕的方向上发射一条射线，并将碰撞存储在我们提供的列表中。如果击中某个物体，则返回 `true`，如果没有击中，则返回 `false`。
- en: Add a public field to specify the Prefab to instantiate in the place we touched.
    You can just create a `Sphere` Prefab and assign it to this field to test this;
    there’s no need to add any special component to the Prefab here. Remember to set
    a small scale.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触摸的位置添加一个公共字段以指定要实例化的 Prefab。您只需创建一个 `Sphere` Prefab 并将其分配给此字段以进行测试；这里不需要添加任何特殊组件。请记住设置一个小的缩放比例。
- en: 'Instantiate the Prefab in the **Position** and **Rotation** fields of the **Pose**
    property of the first hit stored in the list. The hits are sorted by distance,
    so the first hit is the closest one. Your final script should look as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中存储的第一个击中对象的**姿态**属性的**位置**和**旋转**字段中实例化Prefab。击中按距离排序，所以第一个击中是最接近的。您的最终脚本应如下所示：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_20_16.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，中等置信度](img/B21361_20_16.png)'
- en: 'Figure 20.16: Raycaster component'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.16：射线投射器组件
- en: In this section, we learned how to create a new AR project using AR Foundation.
    We discussed how to install and set up the framework, as well as how to detect
    real-life image positions and surfaces and then how to place objects on top of
    them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用AR Foundation创建新的AR项目。我们讨论了如何安装和设置框架，以及如何检测现实生活中的图像位置和表面，然后如何将对象放置在其上方。
- en: As you may have noticed, we never hit **Play** to test this, and sadly, at the
    time of writing this book, we cannot test this in the Editor. Instead, we need
    to test this directly on the device. Due to this, in the next section, we are
    going to learn how to do builds for mobile devices such as Android and iOS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们从未点击**播放**来测试这个，遗憾的是，在撰写这本书的时候，我们无法在编辑器中测试这个。相反，我们需要直接在设备上测试。因此，在下一节中，我们将学习如何为移动设备（如Android和iOS）进行构建。
- en: Building for mobile devices
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Unity is a very powerful tool that solves the most common problems in game development
    very easily, and one of them is building the game for several target platforms.
    Now, the Unity part of building our project for such devices is easy to do, but
    each device has its non-Unity-related nuances when installing development builds.
    In order to test our AR app, we need to test it directly on the device. So, let’s
    explore how we can make our app run on Android and iOS, the most common mobile
    platforms.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Unity是一个非常强大的工具，它能够轻松解决游戏开发中最常见的问题，其中之一就是为多个目标平台构建游戏。现在，为这些设备构建我们的项目部分在Unity中很容易完成，但每个设备在安装开发版本时都有其与Unity无关的细微差别。为了测试我们的AR应用程序，我们需要直接在设备上测试它。所以，让我们探索如何使我们的应用程序在Android和iOS（最常见的移动平台）上运行。
- en: Before diving into this topic, it is worth mentioning that the following procedures
    change a lot over time, so you will need to find the latest instructions on the
    internet. The Unity Learn portal site ([https://learn.unity.com/tutorial/how-to-publish-to-android-2](https://learn.unity.com/tutorial/how-to-publish-to-android-2))
    may be a good alternative in case the instructions in this book fail, but try
    the steps here first.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入这个主题之前，值得提到的是，以下程序会随着时间的推移而大量变化，因此您需要在互联网上找到最新的说明。如果本书中的说明失败，Unity Learn门户网站（[https://learn.unity.com/tutorial/how-to-publish-to-android-2](https://learn.unity.com/tutorial/how-to-publish-to-android-2)）可能是一个很好的替代方案，但请先尝试这里的步骤。
- en: 'In this section, we will examine the following mobile building concepts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下移动构建概念：
- en: Building for Android
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Android构建
- en: Building for iOS
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为iOS构建
- en: Let’s start by discussing how to build our app so that it runs on Android phones.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何构建我们的应用程序，使其能够在Android手机上运行。
- en: Building for Android
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Android构建
- en: Close Unity and open **Unity Hub**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Unity并打开**Unity Hub**。
- en: Go to the **Installs** section and locate the Unity version you are working
    on.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**安装**部分，找到您正在工作的Unity版本。
- en: 'Click the wheel icon button in the top-right corner of the Unity version you
    are using and click **Add modules**:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您正在使用的Unity版本右上角的轮形图标按钮，然后点击**添加模块**：
- en: '![](img/B21361_20_17.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_17.png)'
- en: 'Figure 20.17: Adding modules to the Unity version'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.17：向Unity版本添加模块
- en: 'Make sure **Android Build Support** and the sub-options that are displayed
    when you click the arrow on its left are checked. If not, check them and click
    the **Continue** button at the bottom right to install them:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选**Android构建支持**以及点击其左侧箭头时显示的子选项。如果没有，请勾选它们，然后点击右下角的**继续**按钮以安装它们：
- en: '![](img/B21361_20_18.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_18.png)'
- en: 'Figure 20.18: Adding Android support to Unity'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.18：将Android支持添加到Unity
- en: Accept all the terms and conditions prompts by checking the **Accept Terms**
    checkbox and clicking the **Continue** button.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过勾选**接受条款**复选框并点击**继续**按钮，接受所有条款和条件提示。
- en: Open the AR project we created in this chapter.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章中创建的AR项目。
- en: Go to **Build Settings** (**File | Build Settings**).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**构建设置**（**文件 | 构建设置**）。
- en: 'Select the **Android** platform from the list and click the **Switch Platform**
    button in the bottom-right part of the window:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择 **Android** 平台并点击窗口右下角的 **切换平台**按钮：
- en: '![Table  Description automatically generated with low confidence](img/B21361_20_19.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![表格，低置信度自动生成描述](img/B21361_20_19.png)'
- en: 'Figure 20.19: Switching to Android builds'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.19：切换到 Android 构建
- en: 'To build an app on Android, there are some requirements we need to meet, such
    as having the Java SDK (not the regular Java runtime) and Android SDK installed,
    but luckily, the new versions of Unity take care of that. Just to double-check
    that we have installed the needed dependencies, follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Android 上构建应用程序，我们需要满足一些要求，例如安装 Java SDK（不是常规的 Java 运行时）和 Android SDK，但幸运的是，Unity
    的新版本会处理这些。为了确保我们已安装所需的依赖项，请按照以下步骤操作：
- en: Go to Unity **Preferences** (**Edit | Preferences on Windows or Unity | Preferences
    on Mac**).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Unity **首选项**（**编辑 | 首选项（Windows 或 Unity）或首选项（Mac**））。
- en: Click **External Tools**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **外部工具**。
- en: 'Check that all the options that say **…Installed with Unity** in the **Android**
    section are checked. This means we will be using all the dependencies installed
    by Unity:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认 **Android** 部分中所有标有 **…与 Unity 安装**的选项都已勾选。这意味着我们将使用 Unity 安装的全部依赖项：
- en: '![A picture containing text, newspaper, screenshot, document  Description automatically
    generated](img/B21361_20_20.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、报纸、截图、文档的图片，自动生成描述](img/B21361_20_20.png)'
- en: 'Figure 20.20: Using installed dependencies'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.20：使用已安装的依赖项
- en: 'There are some additional Android ARCore-specific related settings to check,
    which you can find at [https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android).
    These can change if you are using newer versions of ARCore. You can apply them
    by following these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的 Android ARCore 特定相关设置需要检查，您可以在 [https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android)
    找到。如果您使用的是 ARCore 的新版本，这些设置可能会有所不同。您可以通过以下步骤应用它们：
- en: Go to **Player Settings** (**Edit | Project Settings | Player**).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **玩家设置**（**编辑 | 项目设置 | 玩家**）。
- en: Uncheck **Multithreaded Rendering** and **Auto Graphics API** from the **Other
    Settings** section.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **其他设置**部分取消选择 **多线程渲染**和 **自动图形 API**。
- en: Remove **Vulkan** from the **Graphics APIs** list if it’s there.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，从 **图形 API** 列表中删除 **Vulkan**。
- en: 'Set **Minimum API Level** to **Android 7.0**:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **最小 API 级别**设置为 **Android 7.0**：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_20_21.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成描述](img/B21361_20_21.png)'
- en: 'Figure 20.21: ARCore settings'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.21：ARCore 设置
- en: Set the **Scripting Backend** to **IL2CPP**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **脚本后端**设置为 **IL2CPP**。
- en: Check the **ARM64** checkbox to give support to Android 64-bit devices.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **ARM64** 复选框以支持 Android 64 位设备。
- en: Check **Override Default Bundle Identifier** and set something custom, like
    `com.MyCompany.MyARApp`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **覆盖默认包标识符**并设置一些自定义内容，例如 `com.MyCompany.MyARApp`。
- en: Go to **Edit | Project Settings** and select the **XR Plug-in Management** option.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **编辑 | 项目设置**并选择 **XR 插件管理**选项。
- en: 'Check **Google ARCore** under **Plug-in Providers** to make sure it will be
    enabled in our build; if not, we won’t see anything:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **插件提供者**下检查 **Google ARCore**以确保它将在我们的构建中启用；如果没有，我们将看不到任何内容：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_20_22.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成描述](img/B21361_20_22.png)'
- en: 'Figure 20.22: ARCore plugin enabled'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.22：启用 ARCore 插件
- en: Now, you can finally build the app from **File | Build Settings**, as usual,
    by using the **Build** button. This time, the output will be a single APK file
    that you can install by copying the file to your device and opening it. Remember
    that in order to install APKs that weren’t downloaded from the Play Store, you
    need to set your device to **Install Unknown Apps**. The location for that option
    varies a lot, depending on the Android version and the device you are using, but
    this option is usually located in the **Security** settings. Some Android versions
    prompt you to view these settings when installing the APK.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从 **文件 | 构建设置**中通过使用 **构建**按钮构建应用程序，就像往常一样。这次，输出将是一个单独的 APK 文件，您可以通过将文件复制到您的设备并打开它来安装。请记住，为了安装未从
    Play 商店下载的 APK，您需要将设备设置为 **安装未知应用**。该选项的位置因 Android 版本和您使用的设备而异，但通常位于 **安全**设置中。一些
    Android 版本在安装 APK 时会提示您查看这些设置。
- en: 'Now, we can copy and install the generated APK build file every time we want
    to create a build. However, we can let Unity do that for us using the **Build
    and Run** button. This option, after building the app, will look for the first
    Android device connected to your computer via USB and will automatically install
    the app. For this to work, we need to prepare our device and PC as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在每次想要创建构建时复制并安装生成的APK构建文件。但是，我们可以让Unity为我们完成这项工作，使用**构建和运行**按钮。在构建应用后，此选项将查找通过USB连接到您的电脑的第一台Android设备，并自动安装应用。为了使此功能正常工作，我们需要按照以下方式准备我们的设备和电脑：
- en: 'On your device, find the build number in the **Settings** section of the device,
    whose location, again, can change depending on the device. On my device, it is
    located in the **About Phone | Software Information** section:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上，在设备的**设置**部分找到构建号，其位置，同样，可能会根据设备的不同而变化。在我的设备上，它位于**关于手机 | 软件信息**部分：
- en: '![A screenshot of a phone  Description automatically generated with medium
    confidence](img/B21361_20_23.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![手机的截图  描述由中等置信度自动生成](img/B21361_20_23.png)'
- en: 'Figure 20.23: Locating the build number'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.23：定位构建号
- en: Tap it a few times until the device says you are now a programmer. This procedure
    enables the hidden developer option in the device, which you can now find in the
    settings.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续点击几次，直到设备提示您现在是一名程序员。此过程启用了设备中的隐藏开发者选项，您现在可以在设置中找到它。
- en: Open the developer options and turn on **USB Debugging**, which allows your
    PC to have special permissions on your device. In this case, it allows you to
    install apps.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者选项并开启**USB调试**，这允许您的电脑在您的设备上拥有特殊权限。在这种情况下，它允许您安装应用。
- en: Install the USB drivers from your phone manufacturer’s site onto your computer
    if using Windows. For example, if you have a Samsung device, search for `Samsung
    USB Driver`. Also, if you can’t find that, you can look for `Android USB Driver`
    to get the generic drivers, but that might not work if your device manufacturer
    has their own. On Mac, this step is usually not necessary.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用Windows，请从手机制造商的网站上安装USB驱动程序到您的电脑上。例如，如果您有一部三星设备，搜索`Samsung USB Driver`。另外，如果您找不到它，您可以查找`Android
    USB Driver`以获取通用驱动程序，但如果您的设备制造商有自己的驱动程序，这可能不起作用。在Mac上，这一步通常不是必要的。
- en: 'Connect your device (or reconnect it if it’s already connected). The **Allow
    USB Debugging** option for your computer will appear on the device. Check **Always
    allow from this computer** and click **OK**:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备（如果它已经连接，请重新连接）。您的电脑的**允许USB调试**选项将出现在设备上。选择**始终允许来自此电脑**并点击**确定**：
- en: '![Enabling USB Debugging on an Android Device](img/B21361_20_24.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![在Android设备上启用USB调试](img/B21361_20_24.png)'
- en: 'Figure 20.24: Allowing USB debugging'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.24：允许USB调试
- en: Accept the **Allow Data** prompt that appears.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受出现的**允许数据**提示。
- en: If these options don’t appear, check that the **USB Mode** of your device is
    set to **Debugging** and not any other.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些选项没有出现，请检查您的设备**USB模式**是否设置为**调试**，而不是其他任何模式。
- en: In Unity, build with the **Build and Run** button, and save the `apk` into a
    folder. Be patient because this will take a while the first time.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，使用**构建和运行**按钮进行构建，并将`apk`保存到文件夹中。请耐心等待，因为第一次可能需要一段时间。
- en: Please remember to try another image if you have trouble detecting the image
    where we instantiate the player (the Unity logo, in my case). This might vary
    a lot, according to your device’s capabilities.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您在检测我们实例化播放器（我的情况是Unity标志）的图像时遇到问题，请尝试另一个图像。这可能会根据您的设备功能有很大的不同。
- en: And that’s all! Now that you have your app running on your device, let’s learn
    how to do the same for the iOS platform.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在您的应用已经在设备上运行，让我们学习如何为iOS平台做同样的事情。
- en: Building for iOS
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建iOS
- en: Developing for iOS involves certain costs and requirements. This includes using
    Xcode, which is available only on macOS, and potentially acquiring a Mac device
    and an iOS device. Also, while an Apple Developer account, costing 99 USD per
    year, is necessary for releasing games, it’s optional for testing purposes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开发iOS应用涉及一定的成本和要求。这包括使用仅在macOS上可用的Xcode，以及可能需要获取Mac设备和iOS设备。此外，虽然拥有一个每年99美元的Apple开发者账户对于发布游戏是必要的，但对于测试目的则是可选的。
- en: 'To create an AR Foundation iOS build, you should do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建AR Foundation iOS构建，您应该执行以下操作：
- en: Get a Mac computer and an iOS device.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一台Mac电脑和一台iOS设备。
- en: Create an Apple Developer account (at the time of writing this book, you can
    create one at [https://developer.apple.com/](https://developer.apple.com/)).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Apple开发者账户（在撰写本书时，您可以在[https://developer.apple.com/](https://developer.apple.com/)创建一个）。
- en: Install the latest version of Xcode from the App Store onto your Mac.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从App Store将最新版本的Xcode安装到您的Mac上。
- en: Check if you have iOS build support in your Unity installation on Unity Hub.
    Please refer to the *Building for Android* section for more information about
    this step.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您在Unity Hub上的Unity安装中是否有iOS构建支持。有关此步骤的更多信息，请参阅*为Android构建*部分。
- en: 'Switch to the iOS platform under **Build Settings**, by selecting **iOS** and
    clicking the **Switch Platform** button:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**下切换到iOS平台，通过选择**iOS**并点击**切换平台**按钮：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_20_25.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B21361_20_25.png)'
- en: 'Figure 20.25: Switching to iOS build'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.25：切换到iOS构建
- en: Go to **Edit | Project Settings** and select the **Player** option.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑 | 项目设置**并选择**玩家**选项。
- en: 'In **Other Settings**, set the **Camera Usage Description** property if not
    already set. This will be a message shown to the user to tell them why we need
    access to their camera:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**其他设置**中，如果尚未设置，请设置**相机使用描述**属性。这将是一个显示给用户的消息，告诉他们为什么我们需要访问他们的相机：
- en: '![](img/B21361_20_26.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_26.png)'
- en: 'Figure 20.26: Message regarding camera usage'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.26：关于相机使用的消息
- en: Go to **Edit | Project Settings** and select the **XR Plug-in Management** option.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑 | 项目设置**并选择**XR插件管理**选项。
- en: 'Check **ARKit** under **Plug-in Providers** to make sure it will be enabled
    in our build; if not, we won’t see anything:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**插件提供者**下检查**ARKit**，以确保它将在我们的构建中启用；如果没有，我们将看不到任何内容：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_20_27.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B21361_20_27.png)'
- en: 'Figure 20.27: ARKit plugin enabled'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.27：启用ARKit插件
- en: Click the **Build** button in the **Build Settings** window, create a folder
    for the build, and wait for the build to finish. A folder containing the generated
    files should open when finished.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**窗口中点击**构建**按钮，创建一个构建文件夹，并等待构建完成。完成后，将打开一个包含生成文件的文件夹。
- en: 'You will notice that the result of the build process will be a folder containing
    an Xcode project. Unity cannot create the build directly, so it generates a project
    you can open with the Xcode software we mentioned previously. The steps you need
    to follow to create a build with the Xcode version being used in this book (13.4.1)
    are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到构建过程的结果将是一个包含Xcode项目的文件夹。Unity无法直接创建构建，因此它生成一个可以打开的Xcode软件项目。您需要遵循以下步骤来使用本书中使用的Xcode版本（13.4.1）创建构建：
- en: 'Double-click the `.xcodeproj` file inside the generated folder:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击生成文件夹内的`.xcodeproj`文件：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_20_28.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B21361_20_28.png)'
- en: 'Figure 20.28: Xcode project file'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.28：Xcode项目文件
- en: Go to **Xcode | Preferences**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Xcode | 预设**。
- en: 'In the **Accounts** tab, hit the **+** button in the bottom-left part of the
    window and log in with the Apple account you registered as an Apple developer:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**账户**选项卡中，点击窗口左下角的**+**按钮，并使用您注册为Apple开发者的Apple账户登录：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_20_29.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B21361_20_29.png)'
- en: 'Figure 20.29: Account settings'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.29：账户设置
- en: 'Connect your device and select it from the top-left part of the window, which
    should now say **Any iOS device**. You might need to unblock your device first,
    click on the **Trust** button, and wait for Xcode to finish setting up your device
    to see your device in the list:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的设备连接并从窗口的左上角选择它，现在应该显示为**任何iOS设备**。您可能需要首先解除设备的锁定，点击**信任**按钮，并等待Xcode完成设置您的设备，以便在列表中看到您的设备：
- en: '![](img/B21361_20_30.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_30.png)'
- en: 'Figure 20.30: Selecting the device'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.30：选择设备
- en: Xcode might ask you to install certain updates to support your device; please
    install them if needed.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode可能会要求您安装某些更新以支持您的设备；如果需要，请安装它们。
- en: In the left panel, click the folder icon and then the **Unity-iPhone** settings
    to display the project settings.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中，点击文件夹图标，然后点击**Unity-iPhone**设置以显示项目设置。
- en: From the **TARGETS** list, select **Unity-iPhone** and click on the **Signing
    & Capabilities** tab.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**TARGETS**列表中选择**Unity-iPhone**，然后点击**Signing & Capabilities**标签。
- en: Check **Automatically manage signing** and click on the **Enable Automatic**
    button on the prompt.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Automatically manage signing**，并在提示中点击**Enable Automatic**按钮。
- en: In the **Team** settings, select the option that says **Personal Team**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Team**设置中，选择说**Personal Team**的选项。
- en: If you see a **Failed to register bundle identifier** error, just change the
    **Bundle Identifier** setting for another one, always respecting the format (`com.XXXX.XXXX`),
    and then click on **Try Again** until it is solved.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到一个**Failed to register bundle identifier**错误，只需将**Bundle Identifier**设置更改为另一个，始终遵守格式（`com.XXXX.XXXX`），然后点击**Try
    Again**直到问题解决。
- en: 'Once you find one that works, set it in Unity (**Bundle Identifier** under
    **Player Settings**) to avoid needing to change it in every build:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个有效的配置，在Unity中将其设置为（**Player Settings**下的**Bundle Identifier**）以避免在每次构建时都需要更改它：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_20_31.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述由中等置信度自动生成](img/B21361_20_31.png)'
- en: 'Figure 20.31: Setting up your iOS project'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.31：设置你的iOS项目
- en: Hit the **Play** button in the top-left part of the window and wait for the
    build to complete. You might be prompted to enter your password a couple of times
    in the process, so please do so.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口左上角的**Play**按钮，等待构建完成。在这个过程中，你可能需要输入密码几次，所以请这样做。
- en: When the build is complete, remember to unlock the device. A prompt will ask
    you to do that. Note that the process won’t continue unless you unlock the phone.
    If that fails, click **Cancel Running** and try again, this time with the device
    unlocked; remember to select your device in the list again. Also, try to use the
    latest Xcode version available to support the latest iOS versions installed on
    your device.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当构建完成时，请记住解锁设备。会有一个提示要求你这样做。请注意，除非你解锁手机，否则过程不会继续。如果失败，点击**Cancel Running**并再次尝试，这次确保设备已解锁；记得再次在列表中选择你的设备。此外，尝试使用可用的最新Xcode版本来支持设备上安装的最新iOS版本。
- en: If you see a **Fetching Debug Symbols** prompt that never ends, restart your
    device.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到一个**Fetching Debug Symbols**提示永远不会结束，请重新启动你的设备。
- en: After completion, you may see an error saying that the app couldn’t be launched
    but that it was installed anyway. If you try to open it, it will say you need
    to trust the developer of the app, which you can do by going to your device settings.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，你可能看到一个错误，说应用无法启动，但无论如何它已经被安装了。如果你尝试打开它，它会告诉你需要信任该应用的开发者，你可以通过访问你的设备设置来完成这一操作。
- en: From there, go to **General | VPN & Device Management** and select the first
    developer in the list.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，转到**General | VPN & Device Management**并选择列表中的第一个开发者。
- en: Click the blue **Trust…** button and then **Trust**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色**Trust…**按钮，然后**Trust**。
- en: Try to open the app again.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次打开应用。
- en: Please remember to try another image if you’re having trouble detecting the
    image where we instantiate the player (the pebbles image, in my case). This might
    vary a lot, depending on your device’s capabilities.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，如果你在检测我们实例化玩家（我的情况是鹅卵石图像）的位置的图像时遇到麻烦，请尝试另一个图像。这可能会根据你设备的性能有很大的不同。
- en: In this section, we discussed how to build a Unity project that can run on iOS
    and Android, thus allowing us to create mobile apps—AR mobile apps, specifically.
    Like any build, there are methods we can follow to profile and debug, as we saw
    when we looked at PC builds, but we are not going to discuss that here. Now that
    we have discussed the building process for iOS, let’s shift our focus to the exciting
    task of creating a simple AR game. We’ll start by developing the core gameplay
    mechanics, including spawning players and enemies.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何构建一个可以在iOS和Android上运行的Unity项目，从而让我们能够创建移动应用——具体来说是AR移动应用。像任何构建一样，我们有一些方法可以遵循来分析和调试，就像我们在查看PC构建时看到的那样，但在这里我们不会讨论这一点。既然我们已经讨论了iOS的构建过程，让我们将注意力转向创建一个简单的AR游戏这个令人兴奋的任务。我们将从开发核心游戏机制开始，包括生成玩家和敌人。
- en: Creating a simple AR game
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的AR游戏
- en: As we discussed previously, the idea is to create a simple game where we can
    move our player while moving a real-life image and also put in some enemy spawners
    by just tapping where we want them to be, such as a wall, the floor, a table,
    and so on. Our player will automatically shoot at the nearest enemy, and the enemies
    will shoot directly at the player, so our only task will be to move the player
    so that they avoid bullets. We are going to implement these game mechanics using
    scripts very similar to the ones we used in this book’s main project.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，想法是创建一个简单的游戏，我们可以移动我们的玩家，同时移动现实生活中的图像，并且只需点击我们想要它们出现的位置，例如墙壁、地板、桌子等，就可以添加一些敌人生成器。我们的玩家将自动射击最近的敌人，敌人将直接射击玩家，因此我们唯一的任务就是移动玩家以避免子弹。我们将使用与本书主要项目非常相似的脚本来实现这些游戏机制。
- en: 'In this section, we will develop the following AR game features:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发以下AR游戏功能：
- en: Spawning the player and enemies
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建玩家和敌人
- en: Coding the player and enemy behavior
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写玩家和敌人行为代码
- en: First, we are going to discuss how to make our players and enemies appear in
    the app, specifically in real-world positions, and then we will make them move
    and shoot each other to create the specified gameplay mechanics. Let’s start with
    **spawning**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何让我们的玩家和敌人在应用中显示，特别是现实世界的位置，然后我们将让它们移动并互相射击以创建特定的游戏机制。让我们从**生成**开始。
- en: Spawning the player and enemies
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建玩家和敌人
- en: 'Your **Player** Prefab should look as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**Player** Prefab应该看起来如下：
- en: '![](img/B21361_20_32.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_32.png)'
- en: 'Figure 20.32: The starting “Player” Prefab'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.32：初始“Player”Prefab
- en: 'The enemies will require a little bit more work, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人需要做更多的工作，如下所示：
- en: Create a Prefab called `Spawner` with the graphic you want your spawner to have
    (in my case, a cylinder) and its real-life size (small scale).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Spawner`的Prefab，其图形是你想要的生成器图形（在我的情况下是一个圆柱体）及其实际生活大小（小规模）。
- en: Add a custom script that spawns a Prefab every few seconds, such as the one
    shown in the following screenshot.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个自定义脚本，每隔几秒生成一个Prefab，如下面的截图所示。
- en: 'You will notice the usage of `Physics.IgnoreCollision` to prevent the `Spawner`
    GameObject from colliding with the spawned GameObject, getting the colliders of
    both objects and passing them to the function. You can also use the **Layer Collision
    Matrix** to prevent collisions, just like we did in this book’s main project,
    if you prefer to:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到使用`Physics.IgnoreCollision`来防止`Spawner` GameObject与生成的GameObject发生碰撞，获取两个对象的碰撞器并将它们传递给函数。你也可以使用**层碰撞矩阵**来防止碰撞，如果你更喜欢这样做的话：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_20_33.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，置信度中等](img/B21361_20_33.png)'
- en: 'Figure 20.33: Spawner script'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.33：生成器脚本
- en: Create an `Enemy` Prefab with the desired graphic (a capsule, in my case) and
    a `Rigidbody` component with the **Is Kinematic** checkbox checked. This way,
    the enemy will move, but not with physics. Remember to consider the real-life
    size of the enemy.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有所需图形（在我的情况下是一个胶囊）和带有**Is Kinematic**复选框勾选的`Rigidbody`组件的`Enemy` Prefab。这样，敌人会移动，但不是通过物理。请记住考虑敌人的实际生活大小。
- en: 'Set the **Prefab** property of **Spawner** so that it spawns our enemy at our
    desired time frequency:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**Spawner**的**Prefab**属性，以便它以我们希望的时间频率生成敌人：
- en: '![](img/B21361_20_34.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_20_34.png)'
- en: 'Figure 20.34: Configuring Spawner'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.34：配置生成器
- en: Set the Prefab of `SpawnerPlacer` in the XR Origin object so that it spawns
    the **Spawner** Prefab we created earlier.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XR Origin对象中设置`SpawnerPlacer`的Prefab，以便它生成我们之前创建的**Spawner** Prefab。
- en: And that’s all for the first part. If you test the game now, you will be able
    to tap on the detected planes in the app and see how the spawner starts creating
    enemies. You can also look at the target image and see our cube player appear.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分就到这里。如果你现在测试游戏，你将能够点击应用中检测到的飞机，并看到生成器开始创建敌人。你还可以查看目标图像，看到我们的立方体玩家出现。
- en: Now that we have the objects in the scene, let’s make them do something more
    interesting, starting with the enemies.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中有对象了，让我们让它们做一些更有趣的事情，从敌人开始。
- en: Coding the player and enemy behavior
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写玩家和敌人行为代码
- en: 'The enemy must move toward the player in order to shoot at them, so it will
    need to have access to the player’s position. Since the enemy is instantiated,
    we cannot drag the player reference to the Prefab. However, the player has also
    been instantiated, so we can add a PlayerManager script to the player that uses
    the Singleton pattern. Remember, the Singleton pattern ensures that only one instance
    of a script exists within a game, a concept we covered in *Chapter 8*, *Victory
    or Defeat: Win and Lose Conditions)*.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人必须移动到玩家位置才能射击，因此它需要能够访问玩家的位置。由于敌人已经被实例化，我们不能将玩家引用拖动到预制体中。然而，玩家也已经实例化，因此我们可以向玩家添加一个使用Singleton模式的PlayerManager脚本。记住，Singleton模式确保在游戏中只有一个脚本的实例，这是我们之前在*第8章*，*胜利或失败：胜利和失败条件*中讨论的概念。
- en: 'To do that, follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: 'Create a `PlayerManager` script similar to the one shown in the following screenshot
    and add it to the player:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图所示的`PlayerManager`脚本并将其添加到玩家中：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_35.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_35.png)'
- en: 'Figure 20.35: Creating the PlayerManager script'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.35：创建PlayerManager脚本
- en: 'Now that the enemy has a reference to the player, let’s make them look at the
    player by adding a `LookAtPlayer` script, as shown here:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在敌人有了玩家的引用，让我们通过添加一个`LookAtPlayer`脚本，如图所示，让他们看向玩家：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_20_36.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，置信度低](img/B21361_20_36.png)'
- en: 'Figure 20.36: Creating the LookAtPlayer script'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.36：创建LookAtPlayer脚本
- en: 'Also, add a simple `MoveForward` script like the one shown in the following
    screenshot to make the **enemy** not only look at the player but also move toward
    them. Since the `LookAtPlayer` script is making the enemy face the player, this
    script moving along the *Z* axis is just enough:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加一个类似于以下截图所示的简单`MoveForward`脚本，使**敌人**不仅查看玩家，而且向他们移动。由于`LookAtPlayer`脚本使敌人面向玩家，因此沿着*Z*轴移动的脚本就足够了：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_37.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_37.png)'
- en: 'Figure 20.37: Creating the MoveForward script'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.37：创建MoveForward脚本
- en: 'Now, we will take care of the player movement. Remember that our player is
    controlled by moving the image, so here, we are actually referring to the rotation
    since the player will need to automatically look and shoot at the nearest enemy.
    To do this, follow these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理玩家移动。记住，我们的玩家是通过移动图像来控制的，所以在这里，我们实际上是在指旋转，因为玩家需要自动查看并射击最近的敌人。要完成此操作，请按照以下步骤操作：
- en: Create an `Enemy` script and add it to the **Enemy** Prefab.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Enemy`脚本并将其添加到**Enemy**预制体中。
- en: 'Create an `EnemyManager` script like the one shown in the following screenshot
    and add it to an empty `EnemyManager` object in the scene:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图所示的`EnemyManager`脚本并将其添加到场景中的空`EnemyManager`对象中：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_38.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_38.png)'
- en: 'Figure 20.38: Creating the EnemyManager script'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.38：创建EnemyManager脚本
- en: 'In the `Enemy` script, make sure to register the object in the **all** list
    of `EnemyManager`, as we did previously with `WavesManager` in this book’s main
    project:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemy`脚本中，确保将对象注册到`EnemyManager`的**all**列表中，就像我们在本书的主要项目中使用`WavesManager`时那样：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_39.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_39.png)'
- en: 'Figure 20.39: Creating the Enemy script'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.39：创建Enemy脚本
- en: 'Create a `LookAtNearestEnemy` script like the one shown in the following screenshot
    and add it to the **Player** Prefab to make it look at the nearest enemy:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图所示的`LookAtNearestEnemy`脚本并将其添加到**Player**预制体中，使其查看最近的敌人：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_20_40.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，置信度中等](img/B21361_20_40.png)'
- en: 'Figure 20.40: Looking at the nearest enemy'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.40：查看最近的敌人
- en: 'Now that our objects are rotating and moving as expected, the only thing missing
    is shooting and damaging:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到对象按预期旋转和移动，唯一缺少的是射击和造成伤害：
- en: 'Create a `Life` script like the one shown in the following screenshot and add
    it to both the **Player** and **Enemy** components. Remember to set a value for
    the amount of life field. You will see this version of `Life` instead of needing
    to check whether the life reached zero every frame. We have created a `Damage`
    function to check that damage is dealt (the `Damage` function is executed), but
    the other version of this book’s project also works:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于以下截图所示的`Life`脚本，并将其添加到**玩家**和**敌人**组件中。请记住设置生命值字段的值。你将看到这个版本的`Life`，而无需在每一帧检查生命值是否达到零。我们已经创建了一个`Damage`函数来检查是否造成了伤害（`Damage`函数被执行），但这本书项目的另一个版本也可以工作：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_41.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_41.png)'
- en: 'Figure 20.41: Creating a Life component'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.41：创建生命组件
- en: Create a `Bullet` Prefab with the desired graphics, the collider with the **Is
    Trigger** checkbox on the collider checked, a `Rigidbody` component with **Is
    Kinematic** checked (a kinematic trigger collider), and the proper real-life size.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有所需图形的`Bullet`预制体，将碰撞器上的**是触发器**复选框勾选，一个带有**是运动学**复选框勾选的`Rigidbody`组件（运动学触发碰撞器），以及适当的真实尺寸。
- en: Add the `MoveForward` script to the **Bullet** Prefab to make it move. Remember
    to set the speed.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MoveForward`脚本添加到**子弹**预制体中，使其移动。请记住设置速度。
- en: Add a `Spawner` script to both the **Player** and the **Enemy** components and
    set the **Bullet** Prefab as the Prefab to spawn, as well as the desired spawn
    frequency.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Spawner`脚本添加到**玩家**和**敌人**组件中，并将**子弹**预制体设置为要实例化的预制体，以及所需的实例化频率。
- en: 'Add a `Damager` script to the **Bullet** Prefab like the one shown in the following
    screenshot to make bullets inflict damage on the objects they touch. Remember
    to set the damage:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类似于以下截图所示的`Damager`脚本添加到**子弹**预制体中，使子弹对其接触的对象造成伤害。请记住设置伤害值：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_42.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_42.png)'
- en: 'Figure 20.42: Creating a Damager script – part 1'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.42：创建伤害脚本 – 第1部分
- en: 'Add an `AutoDestroy` script like the one shown in the following screenshot
    to the **Bullet** Prefab to make it despawn after a while. Remember to set the
    destroy time:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类似于以下截图所示的`AutoDestroy`脚本添加到**子弹**预制体中，使其在一段时间后消失。请记住设置销毁时间：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_20_43.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行描述自动生成](img/B21361_20_43.png)'
- en: 'Figure 20.43: Creating a Damager script – part 2'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.43：创建伤害脚本 – 第2部分
- en: And that’s all! As you can see, we basically created a new game using almost
    the same scripts we used in the main game, mostly because we designed them to
    be generic (and the game genres are almost the same). Of course, this project
    could be improved a lot, but we have a nice base project to create amazing AR
    apps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！正如你所见，我们基本上是使用与主游戏几乎相同的脚本创建了一个新游戏，主要是因为我们设计它们时考虑了通用性（而且游戏类型几乎相同）。当然，这个项目还有很多可以改进的地方，但我们有一个很好的基础项目来创建令人惊叹的AR应用。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the AR Foundation Unity framework, explored how
    to set it up, and how to implement several tracking features so that we can position
    virtual objects on top of real-life objects. We also discussed how to build our
    project so that it can run on both iOS and Android platforms, which is the only
    way we can test our AR apps at the time of writing. Finally, we created a simple
    AR game based on the game we created in the main project but modified it so that
    it’s suitable for use in AR scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了AR Foundation Unity框架，探讨了如何设置它，以及如何实现几个跟踪功能，以便我们可以在真实物体上定位虚拟对象。我们还讨论了如何构建我们的项目，使其能够在iOS和Android平台上运行，这是我们在撰写本文时测试AR应用的唯一方式。最后，我们基于主项目中创建的游戏创建了一个简单的AR游戏，但对其进行了修改，使其适合在AR场景中使用。
- en: With this new knowledge, you will be able to start your path as an AR app developer,
    creating apps that augment real objects with virtual objects by detecting the
    positions of the real objects. This can be applied to games, training apps, and
    simulations. You may even be able to find new fields of usage, so take advantage
    of this new technology and its new possibilities!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些新知识，你将能够开始作为AR应用开发者的职业生涯，通过检测真实物体的位置，创建将虚拟物体添加到真实物体上的应用。这可以应用于游戏、培训应用和模拟。你甚至可能发现新的应用领域，所以利用这项新技术及其新可能性吧！
- en: 'Well, this is the end of this journey through Unity 2023\. We are really glad
    you reached this point in the book. We hope this knowledge will help you to improve
    or start your game development career with one of the most versatile and powerful
    tools on the market: Unity. We hope to see your creations someday! See you on
    the road!'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是通过Unity 2023的旅程的结束。我们非常高兴你在书中达到了这个阶段。我们希望这些知识能帮助你利用市场上最灵活和强大的工具之一：Unity来提升或开始你的游戏开发职业生涯。我们希望有一天能看到你的作品！路上见！
- en: Learn more on Discord
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
