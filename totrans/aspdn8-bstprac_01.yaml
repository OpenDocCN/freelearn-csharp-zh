- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Taking Control with Source Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用源代码管理来掌握控制权
- en: Source control is a developer’s best friend and provides them with a way to
    experiment with code without losing important changes. Source control is the ability
    to track and maintain changes made to code throughout a development process. While
    this could include code, it can also be used for documentation, assets (such as
    images), and other resources. Being able to test certain conditions and the ability
    to refactor code without worrying about the code base is what most developers
    consider a superpower.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理是开发者的最佳拍档，并为他们提供了一个在不丢失重要更改的情况下实验代码的方法。源代码管理是在整个开发过程中跟踪和维护对代码所做的更改的能力。虽然这可能包括代码，但它也可以用于文档、资产（如图像）和其他资源。能够测试某些条件，以及无需担心代码库就能重构代码，是大多数开发者认为的超级能力。
- en: Source control is extremely important when working in a team environment. If
    a developer checks in code and later realizes they made a mistake, source control
    gives developers a way to revert changes or update a branch and re-commit. Companies
    not using some type of source control almost always raises a red flag.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队环境中工作，源代码管理非常重要。如果开发者提交了代码，后来意识到他们犯了一个错误，源代码管理为开发者提供了一个回滚更改或更新分支并重新提交的方法。几乎总是不使用某种类型源代码管理的企业会引发红旗。
- en: In this chapter, we’ll look at common practices developers use in the industry
    when using source control. We’ll also cover various ways to implement branching
    workflows for your code as well as examine the different types of branches in
    each workflow. To finish off the chapter, we’ll review common etiquette among
    developers when using source control.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨开发者在使用源代码管理时在行业中使用的常见做法。我们还将涵盖实现代码分支工作流程的各种方法，并检查每个流程中的不同分支类型。为了结束本章，我们将回顾开发者在使用源代码管理时的常见礼仪。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Branching Strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支策略
- en: Creating short-lived branches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建短期分支
- en: Always “Get Latest” Before Committing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交前始终“获取最新”
- en: Understanding Common Practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解常见实践
- en: By the end of this chapter, you’ll have learned the best approach to creating
    a repository of your code in an organized fashion, along with common guidelines
    in the developer community.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会以有组织的方式创建代码库的最佳方法，以及开发社区中的常见指南。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: While this section touches on a number of guidelines regarding source control,
    the only requirement for this chapter is a computer with any OS. Git is optional.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节涉及许多有关源代码管理的指南，但本章的唯一要求是任何操作系统的计算机。Git是可选的。
- en: 'If you don’t have Git installed, you can download and install it at the following
    URL:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装Git，你可以从以下网址下载并安装它：
- en: '[https://git-scm.com/](https://git-scm.com/)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://git-scm.com/](https://git-scm.com/)'
- en: We have used mermaid-js to visually show the branching strategies. As of February
    2022, GitHub pages now support Mermaid-js. Some of the sections will include mermaid
    diagrams to demonstrate the different branching hierarchies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用mermaid-js来直观地展示分支策略。截至2022年2月，GitHub页面现在支持Mermaid-js。一些章节将包含mermaid图表来展示不同的分支层次结构。
- en: 'For more information on Mermaid-js, navigate to the following URL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于Mermaid-js的信息，请访问以下网址：
- en: '[https://mermaid-js.github.io](https://mermaid-js.github.io)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mermaid-js.github.io](https://mermaid-js.github.io)'
- en: Branching Strategies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支策略
- en: In this section, we’ll explore various branching strategies, explaining how
    each one works, and highlighting the differences between them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨各种分支策略，解释每个策略的工作原理，并突出它们之间的差异。
- en: While every company has its unique workflow, we’ll focus on some commonly used
    strategies in the industry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个公司都有其独特的流程，但我们将关注行业中的常用策略。
- en: With GitFlow being the initial workflow, everyone is familiar with it in the
    industry and its successors have improved by making minor changes to the workflow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitFlow是初始流程，因此在行业中每个人都熟悉它，其后续者通过微调流程进行了改进。
- en: In the next sections, we’ll discuss each workflow, but first, we have to understand
    the fundamentals of GitFlow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论每个流程，但首先，我们必须了解GitFlow的基础知识。
- en: GitFlow
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitFlow
- en: One of the most common and most mature workflows in the industry is GitFlow.
    It was created by *Vincent Driessen* in 2010.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中最常见且最成熟的流程之一是GitFlow。它由*文森特·德里森*于2010年创建。
- en: 'A minimal Git repository should have the following branches:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最小Git仓库应包含以下分支：
- en: main/master/trunk (referred to as main from this point on)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: main/master/trunk（从现在起称为main）
- en: develop
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: develop
- en: The `main` branch is what you start with when creating a new repository. The
    purpose of this branch is to *always* have stable and production-ready code for
    release at any time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 分支是在创建新仓库时开始的。这个分支的目的是始终拥有稳定且可用于发布的生产就绪代码。'
- en: The `develop` branch is for writing new code and preventing untested code from
    being merged into `main`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`develop` 分支用于编写新代码，并防止未经测试的代码被合并到 `main`。'
- en: If you’re a standalone developer working on a side project, this may be a suitable
    workflow. If everything works in `develop`, you merge your changes into `main`
    and deploy your first version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个独立开发者，正在从事一个侧项目，这可能是一个合适的流程。如果 `develop` 上的所有内容都正常，你可以将你的更改合并到 `main`
    并部署你的第一个版本。
- en: The good news is you can evolve your branching hierarchy even further. You can
    easily create additional branches, such as feature, release, or hotfix branches,
    for a better workflow, which we’ll cover later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是你可以进一步发展你的分支层次结构。你可以轻松创建额外的分支，例如功能分支、发布分支或热修复分支，以获得更好的工作流程，我们将在后面介绍。
- en: Keep in mind that each branching workflow discussed as follows allows any team,
    whether it’s 1 developer or 50 developers, to have a solid understanding of GitFlow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以下讨论的每个分支工作流程都允许任何团队，无论是1个开发者还是50个开发者，都能对GitFlow有一个稳固的理解。
- en: 'In any source control system, there are usually three types of branches used
    to assist with managing a software workflow: feature, release, and hotfix branches.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何源代码管理系统中，通常有三种类型的分支用于帮助管理软件工作流程：功能分支、发布分支和热修复分支。
- en: Feature Branches
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能分支
- en: Feature branching isolates a new feature into a single branch so a developer
    can write code without worrying about affecting the core code in the `develop`
    branch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分支将新功能隔离到单个分支中，这样开发者就可以编写代码，而不用担心会影响 `develop` 分支中的核心代码。
- en: In the following example (see *Figure 1**.1*), a team created a GitHub repository.
    It called its primary branch `main` and the development branch `develop`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中（见 *图1**.1*），一个团队创建了一个GitHub仓库。它将其主分支命名为 `main`，将开发分支命名为 `develop`。
- en: '![Figure 1.1: Feature branches in GitFlow](img/Figure_1.01_B19493.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：GitFlow中的功能分支](img/Figure_1.01_B19493.jpg)'
- en: 'Figure 1.1: Feature branches in GitFlow'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：GitFlow中的功能分支
- en: Once everyone received their tasks, one developer was assigned to create the
    `feature/settings` from the `develop` branch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个人都收到了他们的任务，一位开发者被分配从 `develop` 分支创建 `feature/settings`。
- en: Another developer was assigned the `feature/printing` branch also from the `develop`
    branch.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一位开发者被分配了从 `develop` 分支来的 `feature/printing` 分支。
- en: Naming Branches
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 分支命名
- en: 'Apart from the standardized main and develop branches, one common way to name
    branches is to prefix the names. Some examples include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准化的 `main` 和 `develop` 分支之外，一种常见的命名分支的方式是使用前缀。以下是一些示例：
- en: '* `feature/`, `features/`, or `feature-`: The branch name should be as descriptive
    and helpful as possible. For example, `feature/1234-settings` relates to the `feature/jd-settings`).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* `feature/`, `features/`, 或 `feature-`: 分支名称应尽可能具有描述性和帮助性。例如，`feature/1234-settings`
    与 `feature/jd-settings` 相关)。'
- en: '* `"bug/<userstory/task number>-<problem>/"`: This example is helpful for immediately
    identifying bugs. An example of this technique could be `bug/1234-string-overflow`.
    Prefixing a branch with “bugfix” is also acceptable.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '* `"bug/<userstory/task number>-<problem>/"`: 这个例子有助于立即识别错误。这种技术的例子可以是 `bug/1234-string-overflow`。在分支前缀为“bugfix”也是可接受的。'
- en: Once they are finished and everything’s approved, each developer merges their
    changes into the `develop` branch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成并得到批准，每个开发者都会将他们的更改合并到 `develop` 分支。
- en: Release Branches
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布分支
- en: Release branches are meant for last-minute polishing, minor bug fixes, and/or
    preparing for a new release of your software (how exciting!)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 发布分支用于最后的润色、小错误修复以及/或为你的软件的新版本做准备（多么令人兴奋啊！）
- en: 'Let’s examine how a release branch fits into our previous example. The following
    diagram shows what a release branch in GitFlow looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看发布分支是如何融入我们之前的示例中的。以下图表展示了GitFlow中发布分支的样子：
- en: '![Figure 1.2: Release branch in GitFlow](img/Figure_1.02_B19493.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：GitFlow中的发布分支](img/Figure_1.02_B19493.jpg)'
- en: 'Figure 1.2: Release branch in GitFlow'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：GitFlow中的发布分支
- en: Initially, developers create a feature branch based on what they were assigned.
    Once they merge their changes to `develop`, a new release is created from the
    `develop` branch. The release branch is merged into `main` and tagged with the
    version number. The main branch will now merge into the `develop` branch so developers
    have the latest changes in case there were code changes during the release process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，开发者根据分配的任务创建一个功能分支。一旦他们将更改合并到`develop`，就会从`develop`分支创建一个新的发布。发布分支会合并到`main`并打上版本号。现在，`main`分支将合并到`develop`分支，以便开发者在发布过程中如果有代码更改，可以拥有最新的更改。
- en: It’s exactly the same as the feature branch, but if you notice, we’re creating
    the `release` branch from the `develop` branch and not from the `main` branch.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它与功能分支完全相同，但如果你注意到，我们是从`develop`分支而不是从`main`分支创建`release`分支的。
- en: After the `release` branch is created and confirmed to work as expected, the
    `release` branch is merged into the `main` branch.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建并确认`release`分支按预期工作后，将`release`分支合并到`main`分支。
- en: Once merged into `main`, it’s recommended to somehow identify a successful release.
    By convention, a tag with the version number is the best approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合并到`main`，建议以某种方式标识一个成功的发布。按照惯例，带有版本号的标签是最好的方法。
- en: Hotfix branches
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热修复分支
- en: While most developers don’t make coding mistakes (uh-huh), there are times when
    immediate changes are required to the `main` branch.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数开发者不会犯编码错误（嗯嗯），但有时需要对`main`分支进行即时更改。
- en: Going back to our example, it seems there was a problem with a developer’s code.
    The application bombs when anyone selects the **Settings** option, making the
    application unusable. It requires a hotfix branch.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，似乎有一个开发者的代码出现了问题。当任何人选择**设置**选项时，应用程序会崩溃，使得应用程序无法使用。这需要一个热修复分支。
- en: 'The following diagram shows an example of how to implement a hotfix branch:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了如何实现热修复分支的示例：
- en: '![Figure 1.3: Hotfix branch in GitFlow](img/Figure_1.03_B19493.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![**图1.3**：GitFlow中的热修复分支](img/Figure_1.03_B19493.jpg)'
- en: 'Figure 1.3: Hotfix branch in GitFlow'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.3**：GitFlow中的热修复分支'
- en: Hotfix branches are created from the `main` branch and, once the code is verified,
    need to be merged back into `main` and also the `develop` branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 热修复分支是从`main`分支创建的，一旦代码经过验证，需要合并回`main`分支和`develop`分支。
- en: The long-running branches in GitFlow are main and develop. The short-lived branches
    include the features, hotfix, and bugfix branches.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitFlow中，长期运行的分支是`main`和`develop`。短期分支包括功能、热修复和错误修复分支。
- en: Now that we’ve covered GitFlow and its branch types, we’ll look at the next
    workflow, called GitHub Flow, and how it’s different from GitFlow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了GitFlow及其分支类型，接下来我们将探讨下一个工作流程，称为GitHub Flow，以及它与GitFlow的不同之处。
- en: GitHub Flow
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: Over time, GitFlow has evolved into easier workflows. The first of these workflows
    was GitHub Flow, which was created in 2011.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，GitFlow已经演变成更简单的流程。这些流程中的第一个是GitHub Flow，它于2011年创建。
- en: GitHub Flow was meant to simplify things by removing the `develop` branch and
    creating features off the `main` branch.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow旨在通过删除`develop`分支并在`main`分支上创建功能来简化流程。
- en: The following diagram shows how feature branches work along with a hotfix branch.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了功能分支和热修复分支是如何工作的。
- en: '![Figure 1.4: Hotfix branch in GitHub flow](img/Figure_1.04_B19493.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![**图1.4**：GitHub flow中的热修复分支](img/Figure_1.04_B19493.jpg)'
- en: 'Figure 1.4: Hotfix branch in GitHub flow'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.4**：GitHub flow中的热修复分支'
- en: In *Figure 1**.4*, two features were created and both features were merged back
    into `main`. Immediately, version 1.0.0 was released. After the release of 1.0.0,
    some text was wrong on the site and the legal team requested for it to be fixed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图1.4**中，创建了两个特征，并将这两个特征合并回`main`。立即，发布了版本1.0.0。在1.0.0版本发布后，网站上的一些文本出现了错误，法律团队要求修复这些问题。
- en: One of the developers created a hotfix branch, changed the label, requested
    a PR, got it approved, merged the change into `main`, updated the version, and
    immediately deployed the code to production.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一位开发者创建了一个热修复分支，更改了标签，提交了一个PR，得到了批准，将更改合并到`main`，更新了版本，并立即将代码部署到生产环境中。
- en: What’s the difference between a hotfix and a feature branch? A hotfix is a branch
    created from *main/master*, with the code checked in, reviewed, updated, and immediately
    merged back into main/master. A feature branch is more of an organized or scheduled
    approach. The feature branch is created from the *develop branch*, with the code
    checked in, reviewed, and merged back into the feature branch. The feature branch
    is scheduled to be merged into a release branch.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 热修复和功能分支之间的区别是什么？热修复是从`main/master`创建的分支，代码已检查、审查、更新，并立即合并回`main/master`。功能分支更像是组织或计划的方法。功能分支是从`develop`分支创建的，代码已检查、审查并合并回功能分支。功能分支被计划合并到发布分支。
- en: So, where is the release branch? In each workflow, there is a release branch
    of some kind, which we’ll review as follows. The concept of this branch is to
    always have a version error-free, tested, and ready to deploy at any time. Some
    small start-up companies use this type of workflow when starting out. With GitFlow
    considered as a baseline in the industry, it’s easy to apply the GitFlow concepts
    when the team grows and is looking for a more structured workflow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发布分支在哪里？在每个工作流程中，都存在某种类型的发布分支，我们将如下进行审查。这个分支的概念是始终有一个没有版本错误、经过测试且随时可以部署的版本。一些小型初创公司在起步时使用这种类型的工作流程。由于GitFlow在行业中被视为基准，当团队扩大并寻求更结构化的工作流程时，很容易应用GitFlow的概念。
- en: In GitHub flow, the long-running branch here is, again, main, where the short-lived
    branches are the features, hotfix, and bugfix branches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub Flow中，这里的长期分支仍然是`main`，而短期分支是功能、热修复和错误修复分支。
- en: After reviewing GitHub flow, let’s move on to the last commonly used branching
    strategy, called GitLab Flow.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了GitHub Flow之后，让我们继续到最后一个常用的分支策略，称为GitLab Flow。
- en: GitLab Flow
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab Flow
- en: The final workflow that we’ll cover is GitLab Flow. Created in 2014, GitLab
    Flow takes a different approach to the GitFlow workflow and combines feature branches
    with issue tracking using feature-driven development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个工作流程是GitLab Flow。GitLab Flow于2014年创建，它对GitFlow工作流程采取了不同的方法，并结合了以功能驱动的发展来使用功能分支和问题跟踪。
- en: GitLab Flow takes release branches and turns them into stable environment branches,
    such as production and QA. Of course, you can create as many “environment branches”
    as necessary. If we had a QA environment branch, this may be used to test the
    final product. In *Figure 1**.5*, we see the standard `feature` branches created
    from the `main` branch along with two other environment branches (pre-production
    and production).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Flow将发布分支转换为稳定的环镜分支，例如生产和QA。当然，你可以根据需要创建尽可能多的“环境分支”。如果我们有一个QA环境分支，这可能被用来测试最终产品。在*图1*.5中，我们看到从`main`分支创建的标准`feature`分支，以及另外两个环境分支（预生产和生产）。
- en: '![Figure 1.5: GitLab Flow](img/Figure_1.05_B19493.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：GitLab Flow](img/Figure_1.05_B19493.jpg)'
- en: 'Figure 1.5: GitLab Flow'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：GitLab Flow
- en: In GitLab Flow, main is considered a testing branch. Whether it’s QA or a manager,
    it’s a place to test the feature branches.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab Flow中，`main`被视为一个测试分支。无论是QA还是经理，它都是一个测试功能分支的地方。
- en: Similar to GitHub Flow, everything merges into the `main` branch. When the feature
    branch is committed, code reviews are conducted (these are mandatory), and merged
    to main, all tests (yes, *all*) run. If the tests run for longer than five minutes,
    configure them to run in parallel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与GitHub Flow类似，所有内容都合并到`main`分支。当功能分支被提交时，会进行代码审查（这是强制性的），并合并到`main`，所有测试（是的，*所有*）都会运行。如果测试运行时间超过五分钟，请将它们配置为并行运行。
- en: Once the testing is complete in main, `main` is pushed to `pre-production` for
    further testing and, finally, pushed to production. Since releases in GitLab Flow
    are based on tags, each tag should create a new release.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在`main`上完成测试，`main`就会被推送到`预生产`进行进一步测试，最后推送到生产环境。由于GitLab Flow中的发布基于标签，每个标签都应该创建一个新的发布。
- en: If a developer introduced a bug, it would have to be fixed in main first, then
    the environment branches second. The developer would have to create a bugfix branch,
    commit with a PR approval, conduct a code review, and merge the code along with
    running tests related to the bug before they could continue through the workflow.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者引入了一个错误，它首先必须在主分支上修复，然后是环境分支。开发者必须创建一个修复错误的分支，提交带有PR批准的代码，进行代码审查，并在继续工作流程之前，合并代码并运行与错误相关的测试。
- en: Once tested in main, it’s tagged and automatically promoted to pre-production
    and then production. Long-running branches in this workflow include main and the
    environment branches. Short-lived branches are the features, hotfix, and bugfix
    branches.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在主分支上测试通过，它就会被标记并自动提升到预生产环境，然后是生产环境。在这个工作流程中，长期运行的分支包括主分支和环境分支。短期分支是功能、热修复和错误修复分支。
- en: With each strategy we discussed in this section, we’ve seen how each one evolved
    from the initial GitFlow and (excuse the pun) branched into a better workflow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中讨论的每个策略中，我们都看到了每个策略是如何从最初的 GitFlow 发展而来，并且（请原谅这个双关语）分支到一个更好的工作流程。
- en: The next sections refer to common etiquette when using source control.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍使用源代码控制时的常见礼仪。
- en: Creating short-lived branches
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建短期分支
- en: Once you have initialized your repository and created your first branch, you
    can start writing code for your feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您初始化了您的仓库并创建了您的第一个分支，您就可以开始为您的功能编写代码。
- en: While this is exciting, this guideline is meant more for teams as opposed to
    an individual building a side project. The larger the team, the more critical
    this becomes to your workflow.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很令人兴奋，但这个指南更多的是针对团队，而不是个人构建的副项目。团队越大，这对您的工作流程就越关键。
- en: Let’s look at an example using multiple feature branches in *Figure 1**.6*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 *图 1.6* 来看看一个使用多个功能分支的例子。
- en: '![Figure 1.6: Long-lived feature branch (feature/settings)](img/Figure_1.06_B19493.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：长期存在的功能分支（功能/设置）](img/Figure_1.06_B19493.jpg)'
- en: 'Figure 1.6: Long-lived feature branch (feature/settings)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：长期存在的功能分支（功能/设置）
- en: Everyone is assigned their respective feature branches, which are created for
    them. As you can see, the developers are completing their features and checking
    them into `develop`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都被分配了他们各自的功能分支，这些分支是为他们创建的。正如您所看到的，开发者在完成他们的功能并将它们检查到 `develop` 中。
- en: However, the developer working on the settings feature (`feature/settings`)
    is behind. Their branch is becoming stale since they haven’t updated their code
    over the week. It only contains their feature from when they first created their
    branch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正在设置功能（`feature/settings`）的开发者落后了。由于他们一周内没有更新代码，他们的分支正在变得过时。它只包含他们第一次创建分支时的功能。
- en: What do you think will happen if they decide to commit their code to the repository
    without updating their branch? There will be a lot of unhappy developers. Why?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们决定在未更新分支的情况下将代码提交到仓库，你认为会发生什么？会有很多不高兴的开发者。为什么？
- en: The `feature/settings` branch will be committed and overwrite everyone who merged
    into the `develop` branch’s changes. The shorter your branch’s life expectancy,
    the less likely you’ll experience merge conflicts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature/settings` 分支将被提交并覆盖合并到 `develop` 分支的所有人的更改。您的分支寿命越短，您遇到合并冲突的可能性就越小。'
- en: It’s best to perform updates on a daily basis, if not twice a day, to keep your
    branch from becoming stale.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是每天两次，最好是每天进行更新，以防止您的分支变得过时。
- en: Understanding Common Practices
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见实践
- en: Technically, knowing how to use source control is only half the battle. The
    other half is working as a team player while using source control. The ability
    to keep your fellow teammates in mind will take you further in your career as
    you become a considerate and trusted developer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，了解如何使用源代码控制只是战斗的一半。另一半是在使用源代码控制的同时作为一个团队玩家。考虑到你的队友的能力将使你在职业生涯中走得更远，成为一个周到和值得信赖的开发者。
- en: The following sections are meant as guidelines to help you succeed in working
    in a team environment. If you work as an individual developer on an open source
    project, it doesn’t hurt to implement these practices as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节旨在作为指南，帮助您在团队环境中取得成功。如果您作为一个个人开发者在一个开源项目中工作，实施这些实践也不会有害。
- en: Rebase when Private, Merge when Public
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私下重置，公开合并
- en: When working on a feature branch privately, there may be times where multiple
    commits are necessary. These commits add unnecessary noise to the `main`/`master`
    branch.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当在私有功能分支上工作时，可能会有多个提交是必要的。这些提交会给 `main`/`master` 分支添加不必要的噪音。
- en: Rebasing your code takes a number of local commits and updates another branch
    with a single commit. It essentially rewrites the commit history. Of course, this
    differs from a merge. Merging is the process of taking all of the commits from
    one branch and merging the entire progress into another branch. Merging maintains
    the entire history of commits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 变基代码会将多个本地提交合并为一个提交，并更新另一个分支。这本质上重写了提交历史。当然，这与合并不同。合并是将一个分支的所有提交合并到另一个分支的过程。合并保留了所有提交的历史。
- en: Think of rebasing as cleaning up your house before showing it to a potential
    buyer. If you make a number of mistakes in your local branch, you want your main/master
    branch to provide clear and concise comments as to what was applied to the code
    when committed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将变基想象成在向潜在买家展示房子之前打扫房子。如果你在本地分支中犯了许多错误，你希望主/主分支提供清晰简洁的注释，说明提交代码时应用了哪些代码。
- en: Always “Get Latest” Before Committing
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交代码前始终“获取最新版本”
- en: On the topic of keeping branches fresh, it’s a good habit to “Get Latest” before
    you commit your code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持分支最新这个话题上，在你提交代码之前“获取最新版本”是一个好习惯。
- en: “Get Latest” pertains to you retrieving any updates from a central repository
    and applying updates to your local repository of code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “获取最新版本”是指从中央仓库检索任何更新并将这些更新应用到你的本地代码仓库。
- en: Whether you’re using Git, **Team Foundation Server** (**TFS**), or another source
    control system, you need to keep your team in mind by always retrieving the latest
    code updates. Each source control tool has its own way of getting the latest version
    of the code. No matter what tool you use, it’s always a good habit to get the
    latest version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用Git、**团队基础服务器**（**TFS**）还是其他源代码控制系统，你都需要始终考虑团队，获取最新的代码更新。每个源代码工具都有获取代码最新版本的方式。无论你使用什么工具，获取最新版本总是一个好习惯。
- en: Since Git is considered the standard in the industry because of its flexibility
    and granular approach to source control, most development environments provide
    an interface (graphical or command line) out of the box for interacting with Git.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Git因其灵活性和对源控制的细粒度方法而被视为行业标准，大多数开发环境都提供与Git交互的界面（图形界面或命令行界面）。
- en: 'With Git, there are a couple of ways to push and pull changes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git，有几种推送和拉取更改的方法：
- en: '**Fetch**: Retrieves remote metadata to your local repository.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取**：从远程仓库检索元数据到本地仓库。'
- en: '**Pull**: Retrieves remote metadata *and* pulls a copy of those changes to
    the local repository.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取**：检索远程元数据并从远程仓库拉取这些更改的副本到本地仓库。'
- en: '**Push**: Pushes commits to your remote branch.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**：将提交推送到远程分支。'
- en: '**Sync**: The process of performing a *pull* first, then a *push* second. Remember,
    get the latest changes and apply those changes to your own code, then push your
    committed changes to the server’s repository.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：先执行一次*拉取*，然后执行一次*推送*。记住，获取最新更改并将这些更改应用到你的代码上，然后推送你的提交更改到服务器的仓库。'
- en: Right before a commit, it’s best to issue a pull to retrieve everything before
    committing your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交代码之前，最好先执行一次拉取操作，以获取所有内容。
- en: Always Build and Test Before Committing
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交代码前始终构建和测试
- en: While this may seem like a simple concept after mentioning our previous guideline,
    there are a number of developers who continue to miss this step when committing
    code. Once you’ve pulled the latest, the next step is to compile the code and
    run your local unit tests against it. Don’t assume the code you pulled is error-free.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在提到我们之前的指南后，这听起来可能是一个简单的概念，但仍有不少开发者继续在提交代码时遗漏这一步。一旦你拉取了最新版本，下一步就是编译代码，并运行本地单元测试。不要假设你拉取的代码没有错误。
- en: It’s a common circumstance that on a Friday afternoon, Developer B performs
    a pull to update their code, commits their code without compiling, and runs for
    the door.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 周五下午，开发者B执行了拉取操作来更新他们的代码，提交代码时没有编译，然后匆匆离开。
- en: What they didn’t know is Developer-A committed code before Developer-B. It didn’t
    compile and Developer-A already left for the weekend. Now Developer-B pulled the
    code and he was unable to compile it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不知道的是，开发者A在开发者B之前提交了代码。代码无法编译，而开发者A已经离开去周末了。现在开发者B拉取了代码，但他无法编译它。
- en: On Monday, they find out their code didn’t build at all and the unit tests didn’t
    pass.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在周一，他们发现他们的代码根本无法构建，单元测试也没有通过。
- en: Or worse, they receive a call on Friday night with this news.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更糟糕的是，他们在周五晚上接到这个消息的电话。
- en: Avoid Committing Binaries
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免提交二进制文件
- en: Source control systems have been around for a while, and most are long in the
    tooth (SourceForge, anyone?), but all of them have been used as source code repositories.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码控制系统已经存在了一段时间，大多数都已经过时（比如SourceForge，对吗？），但它们都已被用作源代码仓库。
- en: Recently, there have been a number of **Content Management Systems** (**CMSes**)
    using source code systems as content repositories where they manage and version
    the assets of a website, such as images, MP3s, and videos.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，有相当多的**内容管理系统**（**CMSes**）使用源代码系统作为内容存储库，在那里它们管理和版本控制网站的资产，例如图片、MP3和视频。
- en: However, in the case of developers, our content is our source code. Most developer
    repositories aren’t even as big as a Word document.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于开发者来说，我们的内容是我们的源代码。大多数开发者仓库甚至没有Word文档大。
- en: If developers want to keep a “snapshot” of the system by committing everything,
    this defeats the purpose of source control.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者想要通过提交所有内容来保持系统的“快照”，这将违背源代码控制的目的。
- en: For .NET applications, compiling an application means the `\bin` and `\obj`
    folders will contain assemblies. These assemblies are automatically created when
    compiled and *do not* need to be committed to a repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于.NET应用程序，编译应用程序意味着`\bin`和`\obj`文件夹将包含程序集。这些程序集在编译时自动创建，*不需要*提交到仓库。
- en: In most source control systems, an ignore file of some kind exists to filter
    and remove bloat from your repository before checking in your code. For example,
    in Git, there is a `.gitignore` file, which should include these `\bin` and `\obj`
    directories along with other file types not necessary for building your solution
    or project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数源代码控制系统中，存在某种类型的忽略文件，用于在提交代码之前过滤和删除仓库中的冗余。例如，在Git中，有一个`.gitignore`文件，它应该包括这些`\bin`和`\obj`目录以及其他对于构建解决方案或项目不必要的文件类型。
- en: As a general guideline, when you clone a repository and immediately build it
    on a new machine, no errors should appear whether it’s an internal corporate project
    or an open source framework on GitHub.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般准则，当你从一个仓库克隆并立即在新机器上构建它时，无论是内部企业项目还是GitHub上的开源框架，都不应该出现错误。
- en: If committing assemblies to Git from either your own project or third-party
    projects is to keep it in a runnable state, you’re doing it wrong. It’s best not
    to commit any binaries into Git.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从自己的项目或第三方项目中提交程序集到Git，目的是保持其可运行状态，那么你做错了。最好不要将任何二进制文件提交到Git。
- en: If you need a specific version of a third-party library, consider NuGet package
    management. When adding a NuGet package to your project, it automatically connects
    and retrieves the specific version and places it into the `\bin` folder, making
    the application compile, build, and successfully run every time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个第三方库的特定版本，考虑使用NuGet包管理器。当你将NuGet包添加到项目中时，它会自动连接并检索特定版本，并将其放置到`\bin`文件夹中，使应用程序每次都能编译、构建并成功运行。
- en: Use tags for versioning
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签进行版本控制
- en: Tags are extremely helpful when using source control. As a matter of fact, they’re
    what drives GitLab Flow. While tags are awesome for source control, they can be
    used for evil as well. For example, some companies use tags as comments throughout
    the entire workflow process, which is not recommended. Tags provide a way to place
    a flag in the ground to say, “This is version x.x.x.” They’re a marker of a code
    snapshot of a solid release. This signifies the code at this tag should build,
    compile, be tested, and run *with no changes made to the code and* *no errors*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标签在源代码控制中使用时非常有帮助。事实上，它们是GitLab Flow的驱动力。虽然标签对于源代码控制来说很棒，但它们也可以被用于邪恶的目的。例如，一些公司在整个工作流程过程中使用标签作为注释，这是不建议的。标签提供了一种方式，可以在地面上放置一个标志来表示，“这是版本x.x.x。”它们是稳定发布的代码快照的标记。这表示这个标签下的代码应该构建、编译、测试和运行*不修改代码*和*没有错误*。
- en: It’s best to use tags strictly for versioning your releases throughout your
    workflow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个工作流程中，最好严格使用标签来版本控制你的发布。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the different types of branching workflows
    available, including GitFlow, GitHub Flow, and GitLab Flow, and how each one works.
    Along with the workflows, you learned the industry-standard branch names, such
    as main/trunk/master, develop, features, release, and hotfix branches, and how
    they work in each workflow. You also learned the proper way to work with source
    control, such as always getting the latest code, when to rebase your code versus
    merging, allowing your branches to have a short lifespan, compiling and testing
    your code before committing, never checking in assemblies, and the proper use
    of tagging.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了可用的不同分支工作流程，包括GitFlow、GitHub Flow和GitLab Flow，以及每个工作流程是如何运作的。除了工作流程，你还学习了行业标准化的分支名称，例如main/trunk/master、develop、features、release和hotfix分支，以及它们在每个工作流程中的运作方式。你还学习了与源代码控制一起工作的正确方法，例如始终获取最新代码，何时进行变基而不是合并，让分支拥有短暂的生命周期，在提交前编译和测试你的代码，永远不要提交程序集，以及正确使用标签。
- en: In the next chapter, we’ll take the source code in our repository and create
    an automated build to create artifacts. We’ll also cover how to automatically
    deploy it to a server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从我们的仓库中提取源代码，创建一个自动构建过程以生成工件。我们还将介绍如何自动将其部署到服务器上。
