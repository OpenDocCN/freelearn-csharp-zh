<html><head></head><body>
		<div><h1 id="_idParaDest-331" class="chapter-number"><a id="_idTextAnchor330"/>14</h1>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor331"/>gRPC for Binary Communication</h1>
			<p>Service-to-service communication does not need to be via REST passing JSON data. Performance and cost are important factors to consider when it comes to using <strong class="bold">gRPC</strong>, a binary<a id="_idIndexMarker1073"/> and platform-independent communication technology. Reducing the data that’s transferred can increase performance and reduce costs.</p>
			<p>In this chapter, we’ll change some services in the Codebreaker solution so that they offer gRPC instead or in addition to REST services. You’ll learn how gRPC differs from REST, as well as how to create services and clients using this binary communication technology.</p>
			<p>In this chapter, you’ll learn how to do the following:</p>
			<ul>
				<li>Configure a service project to use gRPC</li>
				<li>Create a platform-independent communication contract with Protobuf</li>
				<li>Create gRPC services</li>
				<li>Create clients that call gRPC services</li>
			</ul>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor332"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription and Docker Desktop.</p>
			<p>The code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</a>.</p>
			<p>The <code>ch14</code> folder contains the projects we’ll be looking at in this chapter, as well as their results. To add the functionality from this chapter, you can start with the source code from the previous chapter.</p>
			<p>The projects we’ll be considering are as follows:</p>
			<ul>
				<li><code>Codebreaker.AppHost</code>: The .NET Aspire host project. The app model has been updated to use HTTPS with the <code>game-apis</code> service and <code>live-service</code> so that it supports gRPC.</li>
				<li><code>Codebreaker.Live</code>: The project we created in the previous chapter has been changed to offer a gRPC service instead of a REST service.</li>
				<li><code>Codebreaker.GameAPIs</code>: This project has been updated so that it includes a gRPC client to invoke <code>live-service</code>. In addition to the REST service used by many different clients, a gRPC service has been added as an alternative. This is invoked by the bot service.</li>
				<li><code>Codebreaker.Bot</code>: The bot service has been updated to use a gRPC client instead of REST to invoke the <code>game-apis</code> service.</li>
				<li><code>LiveTestClient</code>: You will need to use the live test client from the previous chapter to verify the SignalR service.</li>
			</ul>
			<p>Before digging into gRPC, let’s compare it with <strong class="bold">Representational State </strong><strong class="bold">Transfer</strong> (<strong class="bold">REST</strong>).</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor333"/>Comparing REST with gRPC</h1>
			<p>The <a id="_idIndexMarker1074"/>most important difference between REST and gRPC is that REST is a <em class="italic">guideline</em> that builds upon HTTP, whereas gRPC is a <em class="italic">protocol</em>. Both are used for communication between clients and services. Let’s take a closer look.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/>Communication style</h2>
			<p>REST is a guideline that<a id="_idIndexMarker1075"/> defines services to be stateless, makes use of HTTP verbs (GET, POST, PUT, DELETE) to manipulate resources, typically uses a human-readable format such as JSON or XML, and is commonly used with web APIs.</p>
			<p>gRPC uses a <em class="italic">strongly defined contract</em> to specify the operations that are available with the services. While other specifications can be used as well, most services make use of <strong class="bold">Protocol Buffers</strong> (<strong class="bold">Protobuf</strong>) to <a id="_idIndexMarker1076"/>specify the contract. With this, gRPC has a compact payload size and efficient serialization.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/>Performance</h2>
			<p>When it <a id="_idIndexMarker1077"/>comes to textual representation, REST has a higher overhead and a higher latency. With gRPC, because of its efficient serialization, latency is lower, and the binary serialization reduces the payload’s size. With gRPC, multiplexing allows for concurrent requests across a single connection.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor336"/>Flexibility</h2>
			<p>REST adds <a id="_idIndexMarker1078"/>flexibility by using URIs for resources and is not strictly based on HTTP and HTTPS. Other protocols can be used as well that fulfill REST principles.</p>
			<p>With gRPC, contracts strictly specify the communication. gRPC is based on HTTP/2, which offers some advantages compared to HTTP/1, such as multiplexing concurrent calls over a single connection. gRPC-Web is an alternative that allows a subset of gRPC to be used with HTTP/1.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/>Language support</h2>
			<p>REST just <a id="_idIndexMarker1079"/>needs HTTP and works with any language that supports HTTP. With gRPC, based on the protobuf contract, code is created – and this requires supported languages to be used. Check out the list of supported languages at <a href="https://grpc.io/docs/languages/">https://grpc.io/docs/languages/</a>. It includes C#, C++, Dart, Java, Go, Python, PHP, and others.</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/>Security</h2>
			<p>REST relies <a id="_idIndexMarker1080"/>on transport security (HTTPS). Authentication and authorization are done at the application level. With gRPC, transport security (TLS/SSL) is supported, and authentication via OAuth and JWT is built-in. gRPC supports per-message encryption.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/>Use cases</h2>
			<p>REST <a id="_idIndexMarker1081"/>allows for easy interoperability. Only HTTP calls need to be made. It’s used with web APIs and simple services, as well as for interoperability with existing services.</p>
			<p>With cloud services, we pay for compute and memory resources. With a lot of communication going on, the number of instances needed can be reduced by using memory and CPU-efficient technologies. Communication between services can be done using gRPC.</p>
			<p>Let’s start by updating the solution so that it makes use of gRPC (with the logging collectors, gRPC is already in use).</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>Updating a service project so that it uses gRPC</h1>
			<p>When<a id="_idIndexMarker1082"/> using .NET templates to create new projects, a gRPC service can be created by running the following command:</p>
			<pre class="console">
dotnet new grpc</pre>
			<p>When using such a project, you can check the project file to see the NuGet packages and other configurations that are needed.</p>
			<p>Because we already have existing projects, we’ll update these to offer a gRPC service. But first, let’s have a look at the communication between the Codebreaker services shown in <em class="italic">Figure 14</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21217_14_01.jpg" alt="Figure 14.1 – Codebreaker communication technologies"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Codebreaker communication technologies</p>
			<p>Let’s start <a id="_idIndexMarker1083"/>with the right-hand side. In <a href="B21217_13.xhtml#_idTextAnchor317"><em class="italic">Chapter 13</em></a>, we implemented the Codebreaker live service using a SignalR hub, which notifies SignalR clients. For the SignalR client, we created a console client application. Also in <a href="B21217_13.xhtml#_idTextAnchor317"><em class="italic">Chapter 13</em></a>, we used minimal ASP.NET Core APIs which allowed us to call the <code>game-apis</code> service to send completed games. This is a form of service-to-service communication that can be replaced by gRPC. The <code>game-apis</code> service itself is called by clients and the bot service. With this service, a REST API must be invoked by any client technology. The communication between the bot and the <code>game-apis</code> service can be done using gRPC as well. Thus, when it comes to the <code>game-apis</code> service, we’ll offer an alternative communication technology so that communication between the <code>game-apis</code> service and <code>live-service</code> will be replaced. Thus, in this chapter, we’ll do the following:</p>
			<ul>
				<li>Replace the minimal API implementation of <code>live-service</code> with gRPC</li>
				<li>Add an alternative option for the <code>game-apis</code> service so that we offer gRPC as well</li>
				<li>Implement a gRPC client with the <code>game-apis</code> service to invoke <code>live-service</code></li>
				<li>Implement a gRPC client with clients of the <code>game-apis</code> service</li>
			</ul>
			<p>Let’s start by creating a gRPC service contract for <code>live-service</code> that’s invoked by the <code>game-apis</code> service.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor341"/>Creating service contracts</h1>
			<p>First, we <a id="_idIndexMarker1084"/>need to add the <code>Grpc.AspNetCore</code> NuGet package to the <code>Codebreaker.Live</code> project. Then, we must add a Protobuf file as a contract to the service. The contract file is language and platform-independent, so a .NET service can communicate with a Dart application using the same Protobuf file.</p>
			<p>Using Visual Studio, add a <code>Protos</code> folder, and use the Visual Studio template to create a <code>Codebreaker.Live</code>, you can run the following command to create the <code>LiveGame.proto</code> file inside the <code>Protos</code> folder:</p>
			<pre class="console">
dotnet new proto -o Protos -n LiveGame</pre>
			<p>Now, let’s create contracts for both <code>live-service</code> and <code>game-apis</code>.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor342"/>Creating a gRPC service contract for live-service</h2>
			<p>The <a id="_idIndexMarker1086"/>simpler contract is <a id="_idIndexMarker1087"/>the one for <code>live-service</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Protos/LiveGame.proto</p>
			<pre class="source-code">
syntax = "proto3";
option csharp_namespace = "Codebreaker.Live.Grpc";
package ReportGame;
import "google/protobuf/empty.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
<strong class="bold">service ReportGameService {</strong>
<strong class="bold">  rpc ReportGameCompleted (ReportGameCompletedRequest)</strong>
<strong class="bold">    </strong><strong class="bold">returns (google.protobuf.Empty);</strong>
<strong class="bold">}</strong>
<strong class="bold">message ReportGameCompletedRequest {</strong>
<strong class="bold">  string id = 1;</strong>
<strong class="bold">  string gameType = 2;</strong>
<strong class="bold">  string playerName = 3;</strong>
<strong class="bold">  bool isCompleted = 4;</strong>
<strong class="bold">  bool isVictory = 5;</strong>
<strong class="bold">  int32 numberMoves = 6;</strong>
<strong class="bold">  google.protobuf.Timestamp startTime = 7;</strong>
<strong class="bold">  google.protobuf.Duration duration = 8;</strong>
<strong class="bold">}</strong></pre>
			<p>The <code>syntax</code> keyword<a id="_idIndexMarker1088"/> specifies the Protobus version that should be used. Version 3 added <a id="_idIndexMarker1089"/>features such as <code>maps</code> and <code>oneof</code> fields. The <code>option</code> keyword allows us to add language-specific features. <code>option csharp_namespace</code> sets the C# namespace that should be used by the generated classes, postfixed with the name set by the <code>package</code> keyword. The <code>service</code> keyword describes the list of operations offered by the gRPC service. Every operation within the service uses the <code>rpc</code> keyword (remote procedure call). In our code, the operation is called <code>ReportGameCompleted</code>, uses <code>ReportGameCompletedRequest</code> as a parameter, and returns <code>google.protobuf.Empty</code>. <code>google.protobuf.Empty</code> is one of the well-known Protobuf types that’s available. When used, this type must be imported using the <code>import</code> keyword. The <code>google.protobuf.Duration</code> and <code>google.protobuf.Timestamp</code> types are imported as well. <code>ReportGameCompletedRequest</code> is a message that’s specified using the <code>message</code> keyword. Every field within a message needs a unique identifier. The serializer and deserializers use this number to get a match. Thus, if you specify a contract once, don’t change the number in future versions, as this breaks existing clients or services. The types used need to be platform-independent as the same Protobuf file can be used by all platforms <a id="_idIndexMarker1090"/>that support gRPC. <code>string</code>, <code>bool</code>, and <code>int32</code> are types that are defined by the Protobuf specification. With .NET, these types map to <code>string</code>, <code>bool</code>, and <code>int</code>, respectively. <code>Id</code> is a GUID, but there’s no representation for GUIDs with Protobuf. <code>string</code> can be <a id="_idIndexMarker1091"/>used for the identifier. With the .NET <code>GameSummary</code> class, the <code>StartTime</code> property is of the <code>DateTime</code> type and the <code>Duration</code> property is of the <code>TimeSpan</code> type. To map these types with Protobuf, you can use <code>Timestamp</code> and <code>Duration</code>. These types are defined in the <code>Google.Protobuf.WellKnownTypes</code> .NET namespace. <code>Timestamp</code> and <code>Duration</code> offer conversion methods to convert to and from <code>DateTime</code> and <code>TimeSpan</code>.</p>
			<p>To create .NET classes from the Protobuf file, a <code>Protobuf</code> entry needs to be added to the project file, like so:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Codebreaker.Live.csproj</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
<code>  &lt;Protobuf Include="Protos\LiveGame.proto"</code>
<code>    GrpcServices="Server" /&gt;</code>
&lt;/ItemGroup&gt;</pre>
			<p>This <code>Protobuf</code> entry references the Protobuf file with the <code>Include</code> attribute and specifies the code to be generated for the server by setting <code>GrpcServices</code> to <code>Server</code>. With the server, classes for all the defined messages and base classes for every service specified are generated. Later in this chapter, we’ll use the <code>Protobuf</code> element to generate classes for the client.</p>
			<p>In the previous chapter, we created the <code>GameSummary</code> class to report game completions. To convert this class into the gRPC-generated <code>ReportGameCompletedRequest</code> class, we must define a conversion method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Extensions/ReportGameCompletedRequestExtensions.cs</p>
			<pre class="source-code">
public static class ReportGameCompletedRequestExtensions
{
<strong class="bold">  public static GameSummary ToGameSummary(</strong>
<strong class="bold">    this ReportGameCompletedRequest request)</strong>
  {
<strong class="bold">    Guid id = Guid.Parse(request.Id);</strong>
<strong class="bold">    DateTime startTime = request.StartTime.ToDateTime();</strong>
<strong class="bold">    TimeSpan duration = request.Duration.ToTimeSpan();</strong>
    return new GameSummary(
      id,
      request.GameType,
      request.PlayerName,
      request.IsComleted,
      request.IsVictory,
      request.NumberMoves,
      startTime,
      duration);
  }
}</pre>
			<p>In this<a id="_idIndexMarker1092"/> implementation, we <a id="_idIndexMarker1093"/>create a new <code>GameSummary</code> instance and use conversion methods – for example, we parse a string to a <code>Guid</code> value and invoke the <code>ToDateTime</code> and <code>ToTimeSpan</code> methods to convert the <code>Timestamp</code> and <code>Duration</code> values.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To see the generated code with Visual Studio, click on the <code>ReportGameCompletedRequest</code> class, use the context menu, and select <strong class="bold">Go To Implementation</strong>. This directly opens the generated code.</p>
			<p>With <code>ReportGameService</code>, we just have a very simple contract. To allow <code>game-apis</code> to <a id="_idIndexMarker1094"/>be called <a id="_idIndexMarker1095"/>and moves to be made by the bot service, we need a more complex contract.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>Creating a gRPC service contract for the game-apis service</h2>
			<p>The gRPC <a id="_idIndexMarker1096"/>contracts <a id="_idIndexMarker1097"/>of the <code>game-apis</code> service are lengthier than for <code>live-service</code>. Here, we’ll focus on some specific parts of the contract. Check out this book’s GitHub repository for the complete definition.</p>
			<p>The service contract specifies operations to play the game:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
syntax = "proto3";
option csharp_namespace = "Codebreaker.Grpc";
package GamesAPI;
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
service GrpcGame {
<strong class="bold">  rpc CreateGame(CreateGameRequest)</strong>
<strong class="bold">    returns (CreateGameResponse);</strong>
<strong class="bold">  rpc SetMove(SetMoveRequest) returns (SetMoveResponse);</strong>
<strong class="bold">  rpc GetGame(GetGameRequest) returns (GetGameResponse);</strong>
}
// code removed for brevity</pre>
			<p>The <a id="_idIndexMarker1098"/>alternative option to the REST interface, <code>GrpcGameService</code>, defines operations to create a game (<code>CreateGame</code>), set a move (<code>SetMove</code>), and get information about a game (<code>GetGame</code>).</p>
			<p>Most <a id="_idIndexMarker1099"/>messages that are used to send a request to the service just contain scalar values. The <code>SetMoveRequest</code> message is different. This message contains a list of guess pegs:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
message <strong class="bold">SetMoveRequest</strong> {
  string id = 1;
  string gameType = 2;
  int32 moveNumber = 3;
  bool end = 4;
<strong class="bold">  repeated string guessPegs = 5;</strong>
}</pre>
			<p>Lists are specified using the <code>repeated</code> keyword.</p>
			<p>Not only pre-defined types can be repeated – it’s also possible to repeat an inner message type:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
message <strong class="bold">GetGameResponse</strong> {
  string id = 1;
  string gameType = 2;
  string playerName = 3;
  // code removed for brevity
<strong class="bold">  repeated Move moves = 14;</strong>
}
<strong class="bold">message Move {</strong>
<strong class="bold">  string id = 1;</strong>
<strong class="bold">  int32 moveNumber = 2;</strong>
<strong class="bold">  repeated string guessPegs = 3;</strong>
<strong class="bold">  repeated string keyPegs = 4;</strong>
<strong class="bold">}</strong></pre>
			<p>The <code>GetGameResponse</code> message type contains a repeated list of <code>Move</code> messages. The <code>Move</code> message<a id="_idIndexMarker1100"/> type<a id="_idIndexMarker1101"/> contains a list of strings for the guess pegs and the key pegs.</p>
			<p>Protobuf also defines a list of keys and values via the <code>map</code> type:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Protos/GameService.proto</p>
			<pre class="source-code">
<strong class="bold">message FieldNames {</strong>
<strong class="bold">  repeated string values = 1;</strong>
<strong class="bold">}</strong>
<strong class="bold">message CreateGameResponse </strong>{
  string id = 1;
  string gameType = 2;
  string playerName = 3;
  int32 numberCodes = 4;
  int32 maxMoves = 5;
<strong class="bold">  map&lt;string, FieldNames&gt; fieldValues = 6;</strong>
}</pre>
			<p>With a map, the<a id="_idIndexMarker1102"/> key and value types are specified. With the <code>fieldValues</code> field, the key is a string. The corresponding REST API specifies a string array for the value. Using <code>repeated</code> with the value type is not possible with Protobuf. Instead, <code>FieldMessage</code> is defined to contain a <code>repeated string</code>, and this is used with the <code>map</code> value.</p>
			<p>The <a id="_idIndexMarker1103"/>message contracts create .NET classes that are specific to gRPC. When it comes to the local service classes, it’s better if they’re independent of communication technologies. So, we need to create conversion methods.</p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor344"/>Creating conversion methods</h2>
			<p>The<a id="_idIndexMarker1104"/> gRPC service of <code>live-service</code> receives <code>ReportGameCompletedRequest</code>. This is forwarded to the SignalR service we created in the previous chapter as a <code>GameSummary</code> method. So, we need to convert <code>ReportGameCompletedRequest</code> into a <code>GameSummary</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Extensions/GrpcExtensions.cs</p>
			<pre class="source-code">
internal static class GrpcExtensions
{
<strong class="bold">  public static GameSummary ToGameSummary(</strong>
<strong class="bold">    this ReportGameCompletedRequest request)</strong>
  {
<strong class="bold">    Guid id = Guid.Parse(request.Id);</strong>
<strong class="bold">    DateTime startTime = request.StartTime.ToDateTime();</strong>
<strong class="bold">    TimeSpan duration = request.Duration.ToTimeSpan();</strong>
    return new GameSummary(
      id,
      request.GameType,
      request.PlayerName,
      request.IsCompleted,
      request.IsVictory,
      request.NumberMoves,
      startTime,
      duration);
  }
}</pre>
			<p>This is done<a id="_idIndexMarker1105"/> in the form of an extension method where we extend the <code>ReportGameCompletedRequest</code> type. With the implementation of the <code>ToGameSummary</code> method, simple scalar types can be passed on, creating a <code>GameSummary</code> object. Google’s <code>Timestamp</code> and <code>Duration</code> types offer the <code>ToDateTime</code> and <code>ToTimeSpan</code> methods to convert <code>DateTime</code> and <code>TimeSpan</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Libraries such as <code>AutoMapper</code>, <code>Mapster</code>, and others can be used to automatically implement such conversions. While this works out of the box with simple properties without the need to add custom code, some customization is needed when converting different types. What you need to be aware of is that mapper libraries that use .NET reflection instead of source generators increase memory and CPU usage and cannot be used with native AOT. Depending on the types you need to map, you might prefer a custom extension method.</p>
			<p>Check out this book’s GitHub repository for additional conversion methods that can be used with the <code>game-apis</code> service.</p>
			<p>With the conversion methods in place, let’s create the gRPC service implementations.</p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor345"/>Creating gRPC services</h1>
			<p>To implement a <a id="_idIndexMarker1106"/>gRPC service for the <code>Codebreaker.Live</code> project, create the <code>GRPCLiveGameService</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/GRPCLiveGameService.cs</p>
			<pre class="source-code">
using Codebreaker.Grpc;
using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
namespace Codebreaker.Live.Endpoints;
public class <strong class="bold">GRPCLiveGameService</strong>(
  <strong class="bold">IHubContext&lt;LiveHub&gt; hubContext</strong>,
  ILogger&lt;LiveGameService&gt; logger) :
    <strong class="bold">ReportGame.ReportGameBase</strong>
{
<strong class="bold">  async public override Task&lt;Empty&gt; ReportGameCompleted(</strong>
<strong class="bold">    ReportGameCompletedRequest request,</strong>
<strong class="bold">    ServerCallContext context)</strong>
  {
    logger.LogInformation("Received game ended {type} " +
      "{gameid}", request.GameType, request.Id);
<strong class="bold">    await hubContext.Clients.Group(request.GameType)</strong>
<strong class="bold">      .SendAsync("GameCompleted", request.ToGameSummary());</strong>
<strong class="bold">    return new Empty();</strong>
  }
}</pre>
			<p>With the <code>GRPCLiveGameService</code> class, using constructor injection, the hub context we created in<a id="_idIndexMarker1107"/> the previous chapter is injected to send a <code>GameSummary</code> method to all connected clients participating with the group that is named with <code>game-type</code>. The <code>GRPCLiveGameService</code> class needs to derive from the base class – that is, <code>ReportGame.ReportGameBase</code>. <code>ReportGameBase</code> is implemented as an inner class of <code>ReportGame</code> based on the Protobuf contract.</p>
			<p>Next, use the <code>GRPCLiveGameService</code> class to map it as a gRPC endpoint:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static WebApplication MapApplicationEndpoints(this WebApplication app)
{
<strong class="bold">  app.MapGrpcService&lt;GRPCLiveGameService&gt;();</strong>
  app.MapHub&lt;LiveHub&gt;("/livesubscribe");
  return app;
 }</pre>
			<p>You can remove the mapping of the minimal API endpoint and just configure the gRPC endpoint with the <code>WebApplication</code> class known as <code>MapGrpcService</code>, passing the service class as a generic parameter.</p>
			<p>gRPC requires HTTP/2. So, we need to configure the <code>Kestrel</code> server:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/appsettings.json</p>
			<pre class="source-code">
{
<strong class="bold">  "Kestrel": {</strong>
<strong class="bold">    "EndpointDefaults": {</strong>
<strong class="bold">      "Protocols": "Http1And2"</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Configuring <code>Protocols</code> to <code>Http1And2</code> starts the <code>Kestrel</code> server and ensures it supports both HTTP/1 and HTTP/2. The gRPC service needs HTTP/2. When it comes to <code>live-service</code>, SignalR is offered from the same server. To allow the SignalR service to connect <a id="_idIndexMarker1108"/>via HTTP/1 or HTTP/2, the server must be configured to offer both versions.</p>
			<p>The <code>game-apis</code> service’s implementation has similarities. In the project file, we need to add the <code>Grpc.AspNetCore</code> package, add a <code>Protobuf</code> element to the project file, and specify that we wish to create classes for the server:</p>
			<p>Implementing this aspect of the gRPC service is simple: we can inject the <code>IGameService</code> interface. This uses the same classes we already used to implement the minimal API service:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/GrpcGameEndpoints.cs</p>
			<pre class="source-code">
public class GrpcGameEndpoints(
  IGamesService gamesService,
  ILogger&lt;GrpcGameEndpoints&gt; logger) :
  <strong class="bold">Grpc.GrpcGame.GrpcGameBase</strong>
{
<strong class="bold">  public override async</strong>
<strong class="bold">    Task&lt;Grpc.CreateGameResponse&gt; CreateGame</strong>(
    Grpc.CreateGameRequest request,
    ServerCallContext context)
  {
    logger.GameStart(request.GameType);
<strong class="bold">    Game game = await gamesService.StartGameAsync(</strong>
<strong class="bold">      request.GameType, request.PlayerName);</strong>
<strong class="bold">    return game.ToGrpcCreateGameResponse();</strong>
  }
<strong class="bold">  public override async Task&lt;SetMoveResponse&gt; SetMove(</strong>
<strong class="bold">    SetMoveRequest request, ServerCallContext context)</strong>
  {
    Guid id = Guid.Parse(request.Id);
    string[] guesses = request.GuessPegs.ToArray();
    (Game game, Models.Move move) =
      await gamesService.SetMoveAsync(
        id, request.GameType, guesses, request.MoveNumber);
    return game.ToGrpcSetMoveResponse(move);
  }
<strong class="bold">  public override async Task&lt;GetGameResponse&gt; GetGame(</strong>
<strong class="bold">    GetGameRequest request, ServerCallContext context)</strong>
  {
    Guid id = Guid.Parse(request.Id);
    Game? game = await gamesService.GetGameAsync(id);
    if (game is null)
      return new GetGameResponse()
      {
        Id = Guid.Empty.ToString()
      };
    return game.ToGrpcGetGameResponse();
  }
}</pre>
			<p>In gRPC, we can derive from the generated base class, <code>GrpcGame.GrpcGameBase</code>, override the base<a id="_idIndexMarker1109"/> class methods that have been specified with the service contracts, and use the conversion methods to convert the input and output types into their corresponding gRPC representations.</p>
			<p>Similar to <code>live-service</code>, the <code>game-apis</code> service needs gRPC to be added to the DI container and mapped to the endpoint, and <code>Kestrel</code> needs to be configured so that it supports both HTTP/1 and HTTP/2.</p>
			<p>With the services implemented, let’s consider the gRPC clients.</p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor346"/>Creating gRPC clients</h1>
			<p>If you’re <a id="_idIndexMarker1110"/>using Visual Studio 2022, you can take advantage of its built-in support to add a gRPC client. From Solution Explorer, select the project, open the context menu, and select <strong class="bold">Add</strong> | <strong class="bold">Connected Service</strong>. This opens the dialogue shown in <em class="italic">Figure 14</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21217_14_02.jpg" alt="Figure 14.2 – Add service reference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Add service reference</p>
			<p>Select <strong class="bold">gRPC</strong> and <a id="_idIndexMarker1111"/>click <strong class="bold">Next</strong>. This opens the dialogue shown in <em class="italic">Figure 14</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/B21217_14_03.jpg" alt="Figure 14.3 – Add new gRPC service reference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Add new gRPC service reference</p>
			<p>Select the Protobuf file, then select <strong class="bold">Client</strong> from the <strong class="bold">Select the type of class to be generated</strong> dropdown to create the classes for messages and the code for the client.</p>
			<p>If you’re not<a id="_idIndexMarker1112"/> using Visual Studio, you can use a .NET command-line tool called <code>dotnet</code>. To install this tool, run the following command:</p>
			<pre class="console">
dotnet tool install -g dotnet-grpc</pre>
			<p>With this tool globally installed, you can use the <code>dotnet-grpc</code> command to create the proxy classes for the <code>game-apis</code> client:</p>
			<pre class="console">
cd Codebreaker.GameAPIs
dotnet-grpc add-file ..\Codebreaker.Live\Protos\LiveGame.proto</pre>
			<p>You can run the following for the bot service client:</p>
			<pre class="console">
cd ..
cd Codebreaker.Bot
dotnet-grpc add-file ..\Codebreaker.GameAPIs\Protos\GameService.proto</pre>
			<p>What happened with these commands or with the Visual Studio integration?</p>
			<ul>
				<li>The <code>Grpc.AspNetCore</code> NuGet package was added to the project</li>
				<li>A <code>Protobuf</code> element was added to the project file</li>
			</ul>
			<p>Using the <a id="_idIndexMarker1113"/>command-line tool, code for both the client and the server is created when the <code>Protobuf</code> entry is created. To only create code for the client, the <code>GrpcServices="Client"</code> attribute needs to be added:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPis/Codebreaker.GameAPIs.csproj</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
  <strong class="bold">&lt;Protobuf</strong>
<strong class="bold">    Include="..\Codebreaker.Live\Protos\LiveGame.proto"</strong>
<strong class="bold">    GrpcServices="Client" /&gt;</strong>
<strong class="bold">  &lt;Protobuf Include=".\Protos\GameService.proto" GrpcServices="Server" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
			<p>Regarding the <code>game-apis</code> service, the project file now includes two <code>Protobuf</code> entries. One is used to create the service part (which we did in the previous section), while the new entry is for the client code.</p>
			<p>The bot invokes the <code>game-apis</code> service. So, the proto file of the <code>game-apis</code> service needs to be referenced in the bot project file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/Codebreaker.Bot.csproj</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
  <strong class="bold">&lt;Protobuf Include=</strong>
<strong class="bold">    "..\Codebreaker.GameApis\Protos\GameService.proto"</strong>
<strong class="bold">    GrpcServices="Client" /&gt;</strong>
&lt;/ItemGroup&gt;</pre>
			<p>Again, for the client, <code>GrpcServices</code> is set to <code>Client</code>.</p>
			<p>Upon using<a id="_idIndexMarker1114"/> the proto files, client proxy classes are created, offering methods to invoke the service with the names of the operations. These proxy classes can be injected. In the following code snippet, the generated <code>ReportGameClient</code> class is being injected into the <code>GrpcLiveReportClient</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameApis/GrpcLiveReportClient.cs</p>
			<pre class="source-code">
public class <strong class="bold">GrpcLiveReportClient</strong>(
<strong class="bold">  ReportGame.ReportGameClient client,</strong>
  ILogger&lt;LiveReportClient&gt; logger) : <strong class="bold">ILiveReportClient</strong>
{
  public async Task ReportGameEndedAsync(GameSummary gameSummary, 
    CancellationToken cancellationToken = default)
  {
    try
    {
<strong class="bold">      ReportGameCompletedRequest request = gameSummary.</strong>
<strong class="bold">        ToReportGameCompletedRequest();</strong>
<strong class="bold">      await client.ReportGameCompletedAsync(request);</strong>
    }
    catch (Exception ex) when (ex is RpcException or
      SocketException)
    {
      logger.ErrorWritingGameCompletedEvent(
        gameSummary.Id, ex);
    }
  }
}</pre>
			<p><code>ReportGameClient</code> implements the <code>ILiveReportClient</code> interface – the same interface we defined and implemented in the previous chapter to invoke the SignalR service on <a id="_idIndexMarker1115"/>completion of a game. When implementing the same interface, we just need to change the configuration of the DI container so that it invokes the service via gRPC instead of using the REST interface. With the implementation of the <code>ReportGameEndedAsync</code> method, we can invoke the generated method from the proxy and need to convert the parameter with the help of an extension method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameApis/ApplicationServices.cs</p>
			<pre class="source-code">
builder.Services.<strong class="bold">AddSingleton&lt;ILiveReportClient,</strong>
<strong class="bold">  GrpcLiveReportClient&gt;()</strong>
<strong class="bold">  .AddGrpcClient&lt;ReportGame.ReportGameClient&gt;(</strong>
<strong class="bold">    grpcClient =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      grpcClient.Address = new Uri("https://live");</strong>
<strong class="bold">    });</strong>
// code removed for brevity</pre>
			<p>Similarly, for the bot service, <code>GrpcGamesClient</code> implements the <code>IGamesClient</code> interface and injects <code>GrpcGame.GrpcGameClient</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/GrpcGamesClient.cs</p>
			<pre class="source-code">
<strong class="bold">public class GrpcGamesClient(</strong>
<strong class="bold">  GrpcGame.GrpcGameClient client,</strong>
<strong class="bold">  ILogger&lt;GrpcGamesClient&gt; logger) : IGamesClient</strong>
{
  // code removed for brevity
<strong class="bold">  public async Task&lt;(string[] Results, bool Ended,</strong>
<strong class="bold">    bool IsVictory)&gt; SetMoveAsync(</strong>
    Guid id, string playerName, GameType gameType,
    int moveNumber, string[] guessPegs,
    CancellationToken cancellationToken = default)
  {
    <strong class="bold">SetMoveRequest</strong> request = new()
    {
      Id = id.ToString(),
      GameType = gameType.ToString(),
      MoveNumber = moveNumber,
      End = false
    };
    request.GuessPegs.AddRange(guessPegs);
<strong class="bold">    var response = await client.SetMoveAsync(request,</strong>
<strong class="bold">      cancellationToken: cancellationToken);</strong>
    return (response.Results.ToArray(), response.Ended,
      response.IsVictory);
  }</pre>
			<p>The <code>IGamesClient</code> interface<a id="_idIndexMarker1116"/> was the same one that’s implemented by <code>GameClient</code>, which calls the REST API. This interface is injected into <code>CodebreakerGameRunner</code>, so no changes are required when switching to gRPC.</p>
			<p>The <code>SetMoveAsync</code> method makes a request to the gRPC service by invoking the <code>SetMoveAsync</code> method of <code>GrpcGame.GrpcGameClient</code>. Similar to before, it aims to convert the parameters into the ones needed by gRPC.</p>
			<p>For help <a id="_idIndexMarker1117"/>with implementing the other methods of the interface, check out this book’s GitHub repository. Note that it’s similar to what we did previously.</p>
			<p>To glue <code>IGamesClient</code> to the new implementation, and to configure the gRPC client, we need to update the DI container’s configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/ApplicationServices.cs</p>
			<pre class="source-code">
<strong class="bold">builder.Services.AddSingleton&lt;IGamesClient,</strong>
<strong class="bold">  </strong><strong class="bold">GrpcGamesClient&gt;()</strong>
<strong class="bold">  .AddGrpcClient&lt;GrpcGame.GrpcGameClient&gt;(client) =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    client.Address = new Uri("https://gameapis");</strong>
<strong class="bold">  });</strong></pre>
			<p>The <code>AddGrpcClient</code> method configures the generated class with the address of the <code>game-apis</code> service.</p>
			<p>Now, run the application and start one or multiple instances of the live test client to see if completed games show up. Start the bot service and send requests to the bot service to play several games. At the same time, use another client to play a game. How many games does the bot run until you complete one? Of course, this depends on the think time you configure with the bot. Do the results show up in the console of the live test client? Check the logs and the environment variables of the different services in the .NET Aspire dashboard.</p>
			<h1 id="_idParaDest-348"><a id="_idTextAnchor347"/>Summary</h1>
			<p>In this chapter, you learned the differences between REST APIs and gRPC, as well as the advantages when using gRPC with service-to-service communication.</p>
			<p>You created a service contract using Protobuf syntax to define services and messages. Contrary to REST, gRPC is strict when it comes to messages and service operations. You created servers and clients using the classes that were generated with the proto files.</p>
			<p>To reduce cost in the cloud, it can be cost-effective to use protocols with lower overhead for service-to-service communication. However, other options are available as well. Upon completion of the game, it’s not required to inform the listener immediately. There’s also a price aspect to this: with the current implementation, the live service is running when accessed from the game APIs service. If nobody is listening, this is not required. By using asynchronous communication, the <code>live-service</code> can register to receive information when it’s started – this is when a listener is active. Asynchronous communication will be covered in the next chapter.</p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor348"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the following links:</p>
			<ul>
				<li><em class="italic">Protobuf Language </em><em class="italic">Guide</em>: <a href="https://protobuf.dev/programming-guides/proto3/">https://protobuf.dev/programming-guides/proto3/</a></li>
				<li><em class="italic">gRPC on .NET-supported </em><em class="italic">platforms</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms">https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms</a></li>
				<li><em class="italic">grpc-dotnet GitHub </em><em class="italic">repository</em>: <a href="https://github.com/grpc/grpc-dotnet">https://github.com/grpc/grpc-dotnet</a></li>
				<li><em class="italic">Call gRPC services with the .NET </em><em class="italic">client</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/client">https://learn.microsoft.com/en-us/aspnet/core/grpc/client</a></li>
			</ul>
		</div>
	</body></html>