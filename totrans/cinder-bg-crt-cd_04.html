<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Prepare Your Brushes &#x2013; Drawing Basic Shapes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Prepare Your Brushes – Drawing Basic Shapes</h1></div></div></div><p>In this chapter, we will learn how to use Cinder for drawing different basic shapes. The shapes are basic but you can create fairly complicated images by combining these shapes. We will go through the available drawing methods one by one and try them out.</p><div class="section" title="Preparing your workspace"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Preparing your workspace</h1></div></div></div><p>Open <a class="indexterm" id="id127"/>TinderBox (<code class="literal">yourCinderPath/tools/TinderBox</code>) and create a new <a class="indexterm" id="id128"/>project with the name <code class="literal">BasicShapes</code>. This time enter <code class="literal">BasicShapes</code> as <span class="strong"><strong>Naming Prefix</strong></span>. Create it somewhere safe and open up <code class="literal">xcode/BasicShapes.xcodeproj</code>. Windows users should open the project file from <code class="literal">vc10\BasicShapes.sln</code>. Open <code class="literal">BasicShapesApp.cpp</code> in the editor and navigate to a place in code that looks similar to the <a class="indexterm" id="id129"/>following snippet:</p><div class="informalexample"><pre class="programlisting">void BasicShapesApp::draw()
{
  // clear out the window with black
  gl::clear( Color( 0, 0, 0 ) );
}</pre></div><p>This is the implementation of the main drawing method of the application. Just one line of code is executed here (<code class="literal">gl::clear( Color( 0, 0, 0 ) );</code>) and as it is already said in the comment preceding it that it clears out the color buffer with black, and it essentially means everything that has been drawn before in the previous <code class="literal">draw()</code> loop is replaced with black.</p><p>The <code class="literal">draw()</code> method<a class="indexterm" id="id130"/> is being executed once per frame. The default frame rate in Cinder is 30 frames per second. So the background is cleared 30 times per second.</p><p>Let's try to change the color of the background! As you can see, you have to pass a <code class="literal">Color</code> parameter to the<a class="indexterm" id="id131"/> <code class="literal">gl::clear()</code> function. In this case the <code class="literal">Color</code> object<a class="indexterm" id="id132"/> consists of three parameters that define the color in the RGB color system. In the <code class="literal">Color( 0, 0, 0 )</code> parameter there are three zeroes inside the brackets. The first <a class="indexterm" id="id133"/>one defines the amount of red color, second is for green, and third is for blue respectively. Let's say we want the background to be red. Then, we have to pass <code class="literal">1</code> as the first parameter for the color. It should look similar to the following:</p><div class="informalexample"><pre class="programlisting">gl::clear( Color( 1, 0, 0 ) );</pre></div><p>Compile and run the project to see if we succeeded. You should see a window with a bright-red background. Colors in Cinder are defined as numbers from 0 to 1. So if you don't want the background to be so bright, try this:</p><div class="informalexample"><pre class="programlisting">gl::clear( Color( 0.5f, 0, 0 ) );</pre></div><p>Compile and run the project again. You should see a lesser bright-red background now. Nice! Now let's give yellow color to the background. We will need to change two of the <code class="literal">Color</code> parameters to do this as there is no separate parameter for the amount of yellow color in the <a class="indexterm" id="id134"/>RGB color system. When we look at the color wheel, we can see that yellow resides there between red and green. When we examine the space between these colors closely, you will see that, red becomes orange, orange becomes yellow, and yellow becomes green.</p><p>So we have to mix the two colors in the same amount to get the yellow color. In code it will look similar to the following:</p><div class="informalexample"><pre class="programlisting">gl::clear( Color( 1, 1, 0 ) );</pre></div><p>Compile and run the project. Good work! You will now see a nice, bright yellow background. Let's do one last adjustment to it and change it to white. To do so, we have to set all the RGB components to their maximum values. As we know from the world of physics that white color consists of all the visible light wavelengths and when we shoot a white light beam through a glass prism, we get a rainbow—a full visible color spectrum. When we combine all the colors of the spectrum together in the same amount, we get white:</p><div class="informalexample"><pre class="programlisting">gl::clear( Color( 1, 1, 1 ) );</pre></div><p>Now, we have a nice white background. Let's draw something on it!</p></div></div>
<div class="section" title="Drawing lines"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Drawing lines</h1></div></div></div><p>Let's change our <a class="indexterm" id="id135"/>
<a class="indexterm" id="id136"/>background to black again and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">// draw a line
gl::drawLine( Vec2f(0,0), Vec2f(100,100) );</pre></div><p>Compile and run the project to see what happens. You should see a relatively short white line on the screen. This is what the function<a class="indexterm" id="id137"/> <code class="literal">gl::drawLine()</code> just did. As we can see, there are two parameters that have to be passed to it. The first one represents the start coordinates of the line, the second one defines the end coordinates of the line. These two points are defined as <code class="literal">Vec2f</code> objects. It is possible to tell from the name of these objects that they are vectors that store two float values. These are vectors that can be used in a two-dimensional space. <code class="literal">Vec2f(0,0)</code> represents a point in the two-dimensional space that resides at the top-left corner of the screen. Let's draw two diagonal lines across the whole window. Add the following code instead of <code class="literal">gl::drawLine( Vec2f(0,0), Vec2f(100,100) );</code>:</p><div class="informalexample"><pre class="programlisting">gl::drawLine( Vec2f(0,0),
Vec2f(getWindowWidth(),getWindowHeight()) );
gl::drawLine( Vec2f(0,getWindowHeight()),
Vec2f(getWindowWidth(),0) );</pre></div><p>As you can see we used two new methods here, <code class="literal">getWindowWidth()</code> <a class="indexterm" id="id138"/>and<a class="indexterm" id="id139"/> <code class="literal">getWindowHeight()</code>, which are meant for determining the window size while the application is running. It is a very handy way of drawing graphics that can be independent from the window size. Instead of changing the parameters manually each time we decide to change our application window size. We can just place the <code class="literal">getWindowWidth()</code> and <code class="literal">getWindowHeight()</code> methods in place of the parameters and the graphics will be adjusted automatically whenever the application window is being resized.</p><p>Compile and run the application and try to change the size of the window by dragging its lower-right corner—the lines should adjust to the new window size.</p><p>Doing this is good but what if we need the lines to be in a color other than white? How about cyan? No problem! Add the following line of code before the <code class="literal">drawLine()</code> calls:</p><div class="informalexample"><pre class="programlisting">gl::color( 0, 1, 1 );</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> . If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/">http://www.packtpub.com/</a>support and register to have the files e-mailed directly to you.</p></div></div><p>That was not so hard. We just have to remember to change the color (if we want to) before we call a function that is supposed to draw something. So if we want to draw one line in red and another in cyan, we do it in the following way:</p><div class="informalexample"><pre class="programlisting">gl::color( 0, 1, 1 ); // set color to cyan
gl::drawLine( Vec2f(0,0),
Vec2f(getWindowWidth(),getWindowHeight()) );
gl::color( 1, 0, 0 ); // set color to red
gl::drawLine( Vec2f(0,getWindowHeight()),
Vec2f(getWindowWidth(),0) );</pre></div><p>So now <a class="indexterm" id="id140"/>
<a class="indexterm" id="id141"/>we know how to change the color of the lines. How about changing the thickness? No problem! Place the following line of code before the line draw calls:</p><div class="informalexample"><pre class="programlisting">glLineWidth( 10.0f );</pre></div><p>So now our lines are being drawn with the thickness of <code class="literal">10</code> pixels. Compile and run the project to see how it looks. Now you should see the lines as shown in the following screenshot:</p><div class="mediaobject"><img alt="Drawing lines" src="graphics/9564_04_01.jpg"/></div><p>The following is <a class="indexterm" id="id142"/>
<a class="indexterm" id="id143"/>the full draw method, if you failed to understand something before (I have changed the line width to <code class="literal">2</code> in the following code):</p><div class="informalexample"><pre class="programlisting">void BasicShapesApp::draw(){
  // clear out the window with black
  gl::clear( Color( 0, 0, 0 ) );
  
  // draw some lines
  glLineWidth( 2 ); // set line width to 2
  gl::color( 0, 1, 1 ); // set color to cyan
  gl::drawLine( Vec2f(0,0),
      Vec2f(getWindowWidth(),getWindowHeight()) );
  gl::color( 1, 0, 0 ); // set color to red
  gl::drawLine( Vec2f(0,getWindowHeight()),
      Vec2f(getWindowWidth(),0) );
}</pre></div></div>
<div class="section" title="Drawing circles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Drawing circles</h1></div></div></div><p>How about adding some circles <a class="indexterm" id="id144"/>
<a class="indexterm" id="id145"/>to the composition? Add the following lines after the last <code class="literal">drawLine</code> call:</p><div class="informalexample"><pre class="programlisting">gl::drawSolidCircle( Vec2f(getWindowWidth()/2,
  getWindowHeight()/2), 50 );</pre></div><p>After you compile and run the application, you should see a circle in the middle of the screen. The <code class="literal">drawSolidCircle()</code> function<a class="indexterm" id="id146"/> takes two parameters. First is the position of the center of the circle. Second is the radius of the circle. We define the position by using the <code class="literal">Vec2f</code> object again. As you can see, we use <code class="literal">getWindowWidth()</code> <a class="indexterm" id="id147"/>and<a class="indexterm" id="id148"/> <code class="literal">getWindowHeight()</code> again. This time we need them to get the center coordinates of the screen. We get it by dividing the window's width and height by <code class="literal">2</code>. Again, by using these methods we make sure that our circle will be drawn in the middle of the screen no matter what size the window is.</p><p>There is a shorter way to do this though that is by using the <code class="literal">getWindowCenter()</code> <a class="indexterm" id="id149"/>method. If we use it, we get the same result but the code looks a bit more clear:</p><div class="informalexample"><pre class="programlisting">gl::drawSolidCircle( getWindowCenter(), 50 );</pre></div><p>Let's <a class="indexterm" id="id150"/>
<a class="indexterm" id="id151"/>change the color of the circle to something else. You can chose your own color, but I will use magenta this time. Add the following line of code right before the <code class="literal">drawSolidCircle()</code> function call:</p><div class="informalexample"><pre class="programlisting">gl::color( 1, 0, 1 ); // set color to magenta</pre></div><p>Try to experiment with the position, radius, and color of the circle. Try to draw more than one shape and also try giving them different colors.</p><p>What if we want to draw just the outline of the circle? Cinder has a separate function for this called<a class="indexterm" id="id152"/> <code class="literal">drawStrokedCircle()</code>. After the<a class="indexterm" id="id153"/> <code class="literal">drawSolidCircle()</code> function add another line of code as follows:</p><div class="informalexample"><pre class="programlisting">gl::drawStrokedCircle( getWindowCenter(), 100 );</pre></div><p>Similar to the <code class="literal">drawSolidCircle()</code> function, <code class="literal">drawStrokedCircle()</code> also takes two parameters—position and radius. The difference is just that it draws just the outline. The outline has the same thickness that we defined earlier <a class="indexterm" id="id154"/>with the help of the <code class="literal">glLineWidth()</code> function. Let's change it to something else by adding the following line of code just before the <code class="literal">drawStrokedCircle()</code> line:</p><div class="informalexample"><pre class="programlisting">glLineWidth( 4 );</pre></div><p>Compile and run the project, and see what happens. You should see a screen similar to the following screenshot:</p><div class="mediaobject"><img alt="Drawing circles" src="graphics/9564_04_02.jpg"/></div><p>There<a class="indexterm" id="id155"/>
<a class="indexterm" id="id156"/> is a hidden third parameter for the <code class="literal">drawSolidCircle()</code> <a class="indexterm" id="id157"/>and<a class="indexterm" id="id158"/> <code class="literal">drawStrokedCircle()</code> functions. As the circles are drawn by using triangles, each time a circle is being drawn, it has to be decided how many triangles to use. Cinder does it automatically but it is possible to define the triangle count by ourselves. So let's change the amount of triangle segments:</p><div class="informalexample"><pre class="programlisting">gl::color( 1, 0, 1 ); // set color to magenta
gl::drawSolidCircle( getWindowCenter(), 50, 5 );
glLineWidth( 4 );
gl::drawStrokedCircle( getWindowCenter(), 100, 5 );</pre></div><p>Note the highlighted parts of the code. We told the circle drawing functions to draw circles by using just five triangles. By doing this we get pentagons instead of circles. Compile and run the project to see it yourself!</p><p>Try to <a class="indexterm" id="id159"/>
<a class="indexterm" id="id160"/>experiment with all the properties to get the most out of it. You can draw almost any kind of regular polygon shape with this function.</p></div>
<div class="section" title="Drawing rectangles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Drawing rectangles</h1></div></div></div><p>Now that we know how<a class="indexterm" id="id161"/>
<a class="indexterm" id="id162"/> to draw lines and circles, let's move to another geometric primitive that we can use—the rectangle.</p><p>As in the case of a circle, there is one function for drawing a filled rectangle and one function for drawing just the outline. They are<a class="indexterm" id="id163"/> <code class="literal">drawSolidRect()</code> and<a class="indexterm" id="id164"/> <code class="literal">drawStrokedRect()</code> respectively.</p><div class="informalexample"><pre class="programlisting">gl::color( 0, 0, 1 ); // set color to blue
gl::drawSolidRect( Rectf( getWindowWidth()/2-20.0f,
  getWindowHeight()/2-20.0f,
  getWindowWidth()/2+20.0f,
  getWindowHeight()/2+20.0f ) );
gl::drawStrokedRect( Rectf( getWindowWidth()/2-120.0f,
  getWindowHeight()/2-120.0f,
  getWindowWidth()/2+120.0f,
  getWindowHeight()/2+120.0f ) );</pre></div><p>Here we draw two rectangles, one filled (or solid) and one as an outline. Note that we pass just one parameter of the type <code class="literal">Rectf</code> to both the functions. The simplest version of <code class="literal">Rectf</code> is being constructed by using the coordinates of top-left and bottom-right corners of the rectangle. Most of the drawing APIs use x and y coordinates of the top-left corner and the width and height of the rectangle, so it could be a bit difficult to get used to this.</p></div>
<div class="section" title="Other useful drawing functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Other useful drawing functions</h1></div></div></div><p>These are the very basic <a class="indexterm" id="id165"/>drawing functions, and actually you can do a lot with them if you use them in a creative way. But here are a couple of other functions that are worth checking out. They are given in the following code snippet:</p><div class="informalexample"><pre class="programlisting">gl::color( 1, 1, 0 );
gl::drawSolidEllipse( Vec2f(150,100), 100, 50, 10);
gl::drawStrokedEllipse( Vec2f(400,300), 100, 175, 15);
gl::drawSolidRoundedRect(
Rectf(550,150,600,300), 20, 4 );
gl::drawStrokedRoundedRect(
Rectf(20,300,200,400), 10, 10 );</pre></div><p>Experiment with the <a class="indexterm" id="id166"/>properties of these functions to fully understand what they mean. Compile and run the project and you should see an image similar to the following screenshot:</p><div class="mediaobject"><img alt="Other useful drawing functions" src="graphics/9564_04_03.jpg"/></div><p>Try to re-size the window by dragging the bottom right corner. You will see the difference between graphics that are drawn relative to the window's size and the ones that are not. Keep this in mind when creating your own application.</p><p>The following is the full code for drawing all the shapes, in case you did not understand which line of code goes where:</p><div class="informalexample"><pre class="programlisting">void BasicShapesApp::draw(){
  // clear out the window with black
  gl::clear( Color( 0, 0, 0 ) );
  
  // draw some lines
  glLineWidth( 2 ); // set line width to 2
  gl::color( 0, 1, 1 ); // set color to cyan
  gl::drawLine( Vec2f(0,0),
        Vec2f(getWindowWidth(),getWindowHeight()) );
  gl::color( 1, 0, 0 ); // set color to red
  gl::drawLine( Vec2f(0,getWindowHeight()),
        Vec2f(getWindowWidth(),0) );
    
  // draw some circles
    gl::color( 1, 0, 1 ); // set color to magenta
    gl::drawSolidCircle( getWindowCenter(), 50, 5 );
    glLineWidth( 4 );
    gl::drawStrokedCircle( getWindowCenter(), 100, 5 );
    
  // draw rectangles
    gl::color( 0, 0, 1 ); // set color to blue
    gl::drawSolidRect( Rectf( getWindowWidth()/2-20.0f,
         getWindowHeight()/2-20.0f,
         getWindowWidth()/2+20.0f,
         getWindowHeight()/2+20.0f ) );
    gl::drawStrokedRect( Rectf( getWindowWidth()/2-120.0f,
         getWindowHeight()/2-120.0f,
         getWindowWidth()/2+120.0f,
         getWindowHeight()/2+120.0f ) );
    
  // draw rest
    gl::color( 1, 1, 0 );
    gl::drawSolidEllipse( Vec2f(150,100), 100, 50, 10);
    gl::drawStrokedEllipse( Vec2f(400,300), 100, 175, 15);
    gl::drawSolidRoundedRect(
         Rectf(550,150,600,300), 20, 4 );
    gl::drawStrokedRoundedRect(
         Rectf(20,300,200,400), 10, 10 );
}</pre></div><p>That's it! This is one of the simplest way to draw basic shapes with Cinder.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter we went through the most essential drawing functions in Cinder. You can draw a lot with these. However, there are limitations of what can be done with them. If you need to draw something really complex and it has to perform well or extremely well, consider obtaining some OpenGL knowledge.</p><p>Here you can find a full list of drawing functions that are currently available in Cinder at <a class="ulink" href="http://libcinder.org/docs/v0.8.4/namespacecinder_1_1gl.html">http://libcinder.org/docs/v0.8.4/namespacecinder_1_1gl.html</a>. On the web page, scroll down to the functions section and look at functions that start with "draw".</p><p>We will use some of the functions from this list in the next chapters, so this is not the only place where we use drawing.</p></div></body></html>