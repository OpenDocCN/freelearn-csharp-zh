- en: Generating Network Requests in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now we've got a deep and complete understanding of the nature of networks.
    We understand the demands that networks place on the design and implementation
    of the software and hardware that is meant to be deployed on those networks. But
    what are we supposed to do with this knowledge? In this chapter, we'll finally
    explore the most common paradigms for leveraging network resources in .NET Core.
    We'll be looking at the common interface for implementing the request/response
    transaction model on the internet (the most ubiquitous network with which you'll
    work), and examine some of the specific implementations of it. Along the way,
    we'll take a look at what happens under the hood by taking apart some of the source
    code for the .NET classes that we'll be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure of the `WebRequest` class, and what functionality each of
    its sub-classes is assured to expose through their methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to leverage different sub-classes of the `WebRequest` class, based on different
    use cases you may encounter, and understanding the distinct operations that they
    provide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal phases of request execution as implemented by C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the code for this chapter is available at the GitHub repository for this
    book at [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    5](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%205).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, all of the code in this chapter can be read, manipulated,
    built, and deployed with Visual Studio Code or Visual Studio Community Edition
    (or Visual Studio for macOS, for those of you on a macOS system). The specific
    source control editor you use is typically a matter of opinion, but I assure you
    that whatever you use to work with the code in this chapter will be sufficient
    for all of the code throughout the rest of this book. I'd encourage you to stick
    with that decision and take some time to familiarize yourself with it. I expect
    most of the readers of this book will already have some deeply entrenched opinions
    about the best environment for .NET Core development. If you don't, however, I
    encourage you to pick whichever one feels most comfortable for you (either the
    feature-richness of Visual Studio Community Edition, or the lightweight, multiplatform
    friendliness of Visual Studio Code). Once you do, make sure you take a significant
    amount of time to familiarize yourself with the tools of that environment. Learn
    the keyboard shortcuts and set your auto-formatting options. Make it yours; once
    you do, you'll be ready to begin.
  prefs: []
  type: TYPE_NORMAL
- en: One class to rule them all – the WebRequest abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As any software craftsman will tell you, if you want to understand how to leverage
    a library or toolset provided to you by another developer, just look at the public
    interface. If the interface is designed well enough, it will be obvious as to
    how that tool shouldbe used. A good interface design communicates a lot about
    the limits and original intentions for the use of a piece of library software,
    and that's what we'll be looking at in this section. The `WebRequest` abstract
    class of the `System.Net` namespace is the public interface for creating and working
    with general-purpose network requests that are meant to be sent over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The interface or abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've been describing the abstract `WebRequest` base class as providing an interfacefor
    how Microsoft intends developers to interact with network operations. However,
    I must admit that this isn't entirely accurate; `WebRequest` is, technically,
    an abstractclass. For those readers who are unfamiliar with the distinction, it's
    actually quite trivial for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes do, in fact, define an interfacefor working with their implementations.
    The relevant distinction between the two is that, with an abstract class, any
    given method provided as part of the interface will typically have a default implementation
    defined within the abstract base class itself. So, the methods provided by an
    abstract class still define the interface through which you, as a consumer of
    the concrete classes, will interact with the implementations of the class. It's
    really just a distinction of where the obligation falls to define the expected
    behavior for that interface. Since you can't instantiate an abstract class any
    more than you can instantiate an interface definition, the difference is entirely
    trivial. Unless, of course, you choose to inherit from the `WebRequest` class
    yourself (which we will do at the end of this chapter). For now, though, let's
    just review the specification provided by `WebRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: The interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any type of abstract class or interface definition, their proper use can
    best be understood through two distinct lenses. The shapeof the abstraction is
    made clear by the properties of the interface. This gives users a concrete idea
    of the proper context in which instances of the interface should be used. It should
    clearly convey the domain around which the abstraction should operate. Meanwhile,
    the scope of the abstraction is conveyed by the classes' method signatures. This
    is what tells users howthe class operates over the domain, as defined by its shape
    or properties.
  prefs: []
  type: TYPE_NORMAL
- en: An interface of well-named methods should give clear boundaries to the limits
    of the usefulness of the class. If an interface is well defined, as with the `WebRequest` base
    class, its properties and method signatures should make it clear exactly when
    it should, and should not be used. What's more, if it should be used, well-named
    and well-scoped method signatures will tell users exactly how to use the method.
  prefs: []
  type: TYPE_NORMAL
- en: So, with that perspective in mind, let's take a look at what is in the base
    definition of the `WebRequest` class. This specification will tell us how it is
    meant to be used and how to extend or implement it for ourselves. And what better
    place to start than with the constructors?
  prefs: []
  type: TYPE_NORMAL
- en: The constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WebRequest` defines only two base constructors for its sub-classes. The first
    is the default  parameter-less constructor. The second allows developers to specify
    an instance of the `SerializationInfo` and `StreamingContext` classes to more
    narrowly define the scope of valid use cases for the newly-created instance of
    the class. So, our constructor signatures will look like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So far this is pretty straightforward, but why use the second constructor at
    all? What is so common about using `SerializationInfo` and `StreamingContext` in
    `WebRequest` instances that the base class defines a constructor which accepts
    instances of those classes?
  prefs: []
  type: TYPE_NORMAL
- en: We'll look more closely at streaming contexts in later chapters, but we did
    briefly discuss the need for reliably serialized data in the previous chapter,
    and this is a good place to consider the concept more fully. Every request or
    response payload will need to be serializedprior to transport, and deserializedupon
    arrival at the destination machine. As we discussed before, this is the process
    of taking unordered, locally-addressed chunks of data and converting it into ordered
    strings of zeros and ones. Specifically, it must be ordered in such a way that
    the same strings can be traversed in order and used to compose locally-addressed
    in-memory objects by the recipient machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, while our software might store an ordered list of integers as an array
    of contiguous memory addresses, this is an implementation detail that is fundamentally
    independent of the data structure it represents. The only key details are that
    the list is ordered, and that it is a list of integers. It could just as easily
    be represented as a linked list under the hood, with each node in the list containing
    the integer stored at that node, as well as the address of the next node in the
    list, which may or may not be contiguous. In memory, these two data structures
    are significantly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c8afb08-4fb0-4f04-af71-38a5fc678881.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, as long as the proper serialization information is given for how those
    two lists should be represented, they should look the same to any recipient receiving
    those lists as the payload to a request or response over the network. They should
    be nothing more than a well-delimited list of the integers. If your serialization
    mechanism is in the typical **Javascript Object-Notation** (**JSON**) format,
    both of those implementations would serialize the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Often, you'll find that `WebRequest` and `WebResponse` instances are instantiated
    and leveraged over and over again for the same kinds of messages, and their payloads
    should be serialized in the same way each and every time. Being able to provide
    `SerializationInfo` as a constructor input gives you the flexibility to define
    your serialization rules and details once, and then leverage them for a theoretically
    infinite number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for the `StreamingContext` parameter. As most network software
    is written to facilitate the same sorts of operations that are being executed
    in the same way over the lifespan of the software, it's unlikely that in a given
    application, your requests will need to leverage different kinds of I/O streams.
    Later on, we'll look more closely at the different kinds of streams available
    to you. It's a dense topic; however, for now, just know that this input parameter
    gives you the same flexibility as the `SerializationInfo` parameter. It allows
    you to define your streaming context once, and use it over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: And with only those two signatures, we've covered the only constructors explicitly
    defined by the `WebRequest` base class. This should give you a pretty clear idea
    of how the writers of this library anticipated it would likely be used. Of course,
    if you wanted to, you could write a sub-class that accepted HTTP verbs and default
    header values, and all sorts of other aspects of a given request that you will
    likely need to define before you can send the request. But at its most basic,
    these constructor signatures tell you that this is a class that is meant to provide
    **reliable serialization** of data over a **reliable data stream**.
  prefs: []
  type: TYPE_NORMAL
- en: Class properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, your constructors give you a clear idea of the context in which the classes
    are expected to be used, and your properties define the overall shape of a request.
    They define the clearest and most unambiguous description of what the class actuallyis.
    What can we learn about `WebRequest`, based on its properties? Well, let's take
    a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the base class specification, the public properties of the class
    are in alphabetical order ( as they''re listed in the Microsoft documentation,
    here: [https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0](https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0)),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthenticationLevel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CachePolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionGroupName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Credentials`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultCachePolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultWebProxy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Headers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImpersonationLevel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Method`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreAuthenticate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Proxy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequestUri`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timeout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseDefaultCredentials`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what does this tell us about instances derived from this abstract class?
    Well, the obvious information is that it encapsulates common aspects of requests
    made over any protocol leveraged on the internet. `Headers`, `Method` (that is,
    the specific protocol method, such as a `GET`, `POST`, or `PUT` HTTP method),
    and `RequestUri` are all that you would expect from a utility class. Others, though,
    such as `ImpersonationLevel`, `AuthenticationLevel`, and `CachePolicy` indicate
    that more than simply encapsulating a request payload, the `WebRequest` class
    is truly meant to encapsulate an operation.
  prefs: []
  type: TYPE_NORMAL
- en: The actions of authenticating and caching responses fall outside of the responsibility
    of the simple-request payload and fall more into the segment of your software
    responsible for brokering requests and responses between your application and
    external resources. The presence of these methods indicates to us that this class
    (and its sub-classes) is intended to be the broker of requests and responses network
    resources. Its definition makes clear that it can handle the nitty-gritty details
    of connecting to remote hosts, authenticating itself, and, by extension, your
    application, serializing payloads, deserializing responses, and providing all
    of this through a clean and simple interface.
  prefs: []
  type: TYPE_NORMAL
- en: With the `ContentType` and `ContentLength` properties, it provides a clean way
    to access and set the values for the most commonly required headers for any request
    with a payload. The specification is telling you to just give me that package,
    tell me where you want to send it, and let me handle the rest*.* It even gives
    you an interface for lumping similar operations together in a connection group
    through the `ConnectionGroupName` property.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have multiple requests to the same external RESTful API living
    at `https://financial-details.com/market/api`, and there are a dozen different
    endpoints that your application accesses over the course of its runtime. Meanwhile,
    you also have a handful of requests that need to be routed to `https://real-estate-details.com/market/api`.
    You can simply associate all of the requests made to the financial details API
    under one connection group name, and the real estate details API requests under
    another. Doing so allows .NET to more reliably manage connections to a single
    `ServicePoint` instance. This allows multiple requests to a single endpoint to
    be routed over the same active connection, improving performance and reducing
    the risk of what's known as connection pool starvation.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, make sure you're using `ConnectionGroupName` to associate
    requests to a single endpoint through a single connection. There is a finite number
    of active connections that you can hold at a given time in any .NET Core application,
    and without `ConnectionGroupName` tying requests to a single connection, each
    request will be given its own connection from the .NET Core runtime's pool of
    available connections. In applications with high network traffic or frequent external
    requests, this can lead to thread-starvation and unreliable performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this feature is quite trivial, but it can save you a mountain
    of time in performance tuning and chasing bugs. Simply define a static constant
    name for each connection group that you want to leverage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, whenever you need to instantiate a new request for the target endpoint,
    you can simply specify the connection group name through the assignment, and under
    the hood, the `ServicePoint` instance that is associated with the `WebRequest` instance
    will check for any connections that share the group name, and, if one is discovered,
    leverage the connection for your new request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And just like that, your request will take advantage of any established connections
    to that same external resource. If there are no other requests associated with
    the specified `ConnectionGroupName` property, then .NET Core will create a connection
    in its connection pool, and associate your request as the first in the connection
    group. This is especially useful if a set of requests are targeting a resource
    that requires access credentials, as the connection is established with those
    access credentials once, and then shared with the subsequent requests!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the connection is established, we''ll need to know what to do with the
    responses for that request. For that, we have the `CachePolicy` property. This
    specifies how your requests should handle the availability of a cached response
    from your remote resource. This property gives us granular control over exactly
    how and when we should rely on a cached response, if at all. So, for example,
    if we have a dataset that is updated almost constantly, and we always want the
    most up-to-date response, we could avoid the cache entirely, by setting the policy
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And just like that, the request will ignore any available cached responses,
    and likewise, it won't cache whatever response it receives from the external resource
    itself. As you can see, the property expects an instance of a `RequestCachePolicy`
    object, which is typically initialized with a value from the `RequestCacheLevel`
    enum definition found in the `System.Net.Cache` namespace (as indicated by its
    inclusion at the top of the code block).
  prefs: []
  type: TYPE_NORMAL
- en: This is another instance where familiarizing yourself with the IntelliSense
    tools of Visual Studio can give you a clear idea of what values are available
    in that enum. Of course, if you're using something such as Visual Studio Code
    or another source code editor, you can always look up the source code or the documentation
    for it on the manufacture's website. No matter which editor you use, in the case
    of properties or methods whose use is not easy to infer, make a habit of looking
    up implementation details and notes on Microsoft's documentation. But with something
    as obvious and straightforward as an enum defining cache policies, Visual Studio's
    autocomplete and IntelliSense functionality can save you the time and mental energy
    of context-switching away from your IDE to look up valid values.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that you define the behavior around cached or cache-able responses,
    you can use the public properties of the `WebRequest` instance to define and specify
    the expected behavior for authentication of your application and any expectations
    you have of the remote resource to authenticate. This is exposed through the `AuthenticationLevel`
    property and behaves much the same way as the `CachePolicy` property that we just
    looked at.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for instance, that your software depends on a remote resource that
    is explicitly configured to work with only your software. The remote server would
    need to authenticate requests to ensure that they are generated from valid instances
    of your software. Likewise, you will want to make sure that you are communicating
    directly with the properly configured server, and not some man-in-the-middle agent
    looking to swipe your valuable financial and real-estate details. In that case,
    you would likely want to ensure that every request is mutually authenticated*, *and
    I'm sure you can already see where I'm about to go with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `WebRequest` class is designed to encapsulate the entire operation
    of interacting with remote resources, we should expect that we can configure our
    instance of that class with the appropriate authentication policies, and not have
    to manage it ourselves. And that''s exactly what we can do. Building on our earlier
    example, we can define the `AuthenticationLevel` property to enforce the policy
    we want to use once, and then let the `WebRequest` instance take it from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note the inclusion of the `System.Net.Security` namespace in our `using` directives.
    This is where the `AuthenticationLevel` enum is defined. This makes sense, as
    authentication is one-half of the authentication and authorization security components
    of most network software. But we'll get more into that later.
  prefs: []
  type: TYPE_NORMAL
- en: As you can guess, getting your own software authenticated will likely require
    some credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning credentials is as easy to do as defining your authentication or caching
    policies. In the `WebRequest` class definition, the `Credentials` property is
    an instance of the `ICredentials` interface from the `System.Net` namespace, typically
    implemented as an instance of the `NetworkCredential` class. Again, the full scope
    of implementing reliable security for network requests will be covered later in
    this book, but for now, let''s take look at how we might add some credentials
    to our mutually- authenticated web requests. It uses the `System.Net` namespace,
    so no additional `using` statements are required. Instead, we can simply set the
    property to a new instance of `NetworkCredential` and move on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We should actually be storing the password as `SecureString`, but this constructor
    is valid, and as I said, we'll look closer at security in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: With this short, straightforward example, we can clearly see how the class properties
    of `WebRequest` define the expected use case for instances of the concrete sub-classes
    that implement and extend it. Now that we understand the shape and scope of the
    operations `WebRequest` intends to abstract away for us, let's take a look at
    the actual execution of those operations through the public methods exposed by
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: The class methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a sufficiently complete picture of the shape of the `WebRequest`
    class, let''s explore its scope, or proper use. Let''s take a look at its public
    methods. Understanding what''s available through the base class will give you
    everything you need to leverage any concrete implementation in the vast majority
    of your use cases, with perhaps only minor modifications. So, just as we did with
    the class properties, let''s take look at the following list of public methods
    and see what we can infer about how the class is meant to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Abort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginGetRequestStream(AsyncCallback, Object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginGetResponse(AsyncCallback, Object)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create(string)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create(Uri)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateDefault(Uri)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateHttp(string)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EndGetRequestStream(IAsyncResult)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EndGetResponse(IAsyncResult)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetObjectData(SerializationInfo, StreamingContext)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetRequestStream()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetRequestStreamAsync()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetResponse()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetResponseAsync()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetSystemWebProxy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterPrefix(string, IWebRequestCreate)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I only included the methods specific to the `WebRequest` class, and left out
    the public methods inherited from parent classes, such as `MarshalByRefObject`
    and `Object`, since those aren't relevant to our purpose. However, with this basic
    list of operations, the utility of the class should be pretty obvious.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that likely stands out is that the class should be used asynchronously.
    All of the `Begin` and `End` methods, as well as the `Async` suffix on a number
    of other methods, tell you that the class supports fine-grained control of the
    lifetime of your requests through the asynchronous features of .NET Core. Now,
    if you've never done async programming (as I often find to be the case with newer
    programmers just starting out of school, or programmers new to web development)
    we'll be covering that mental leap in much greater detail in the next chapter.
    It's not always intuitively obvious how best to leverage the features of async,
    or what's going on behind the scenes; so, for now, just think of it as deferring
    the actual execution of the method until later. Just like all those methods suggest,
    you `Begin` doing a task, and whenever you're ready to, you `End` it and look
    at your result.
  prefs: []
  type: TYPE_NORMAL
- en: The methods in this class can be broken up into two conceptual groups. There
    are methods for state management and methods for request execution. The state
    management methods allow you to modify or further define the state of your instance
    of the `WebRequest` utility class. Leveraging them to further configure and define
    the behavior of your instance is similar to setting any of the public properties
    on the class as we did in the last section on *Class properties*. The reason there
    are methods to do this, instead of simply having more settable properties, is
    because doing so involves at least some non-trivial logic or circumstance-specific
    details that are applied with each invocation of the methods. Meanwhile, the request
    execution functions allow you to define, invoke, and resolve web requests using
    the behavior of your instance. They're the workhorse methods that make all of
    the earlier configuration worthwhile. So, let's take a look at each of these sets
    of methods in turn and fully crystalize our understanding of this class.
  prefs: []
  type: TYPE_NORMAL
- en: State management methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'd encourage you to try to sort the methods I've listed into the two categories
    I'm about to describe for you. And in the future, I'd encourage you to try to
    categorize interfaces and public class definitions in this way. Doing so will
    improve your ability to read and internalize new software features quickly, and
    leverage them efficiently, instead of copying code snippets from [StackOverflow.com](https://stackoverflow.com/) until
    you find something that works. That said, let's take a look at the state management
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the `Create` methods. Each of these methods will return a usable
    instance of a concrete `WebRequest` sub-class. They''re all static, and so can
    be invoked from the class definition without first needing to create an instance
    of it (for obvious reasons; why would you need to create an instance of a class
    to then create an instance of a class?). Depending on the specific method used,
    this sets up an instance of the default sub-class for the given scheme specified
    in the URI supplied to the method. So, if we wanted instances of `WebRequest`
    for accessing data from a RESTful HTTP service, collecting files from a designated
    FTP server, and reading data from a remote file system, we could do all of this
    with a simple call to `Create(uriString)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may recognize this code from the `SubmitRealEstateRequest` sample method
    we wrote in the *Class properties* section. I didn't explain it until now, but
    because the class is so clearly and simply defined, I expect you were able to
    infer its use just fine from my code without this explanation. But in case you
    were wondering why it seemed like I was creating an instance of an abstract class
    (a compile-time error in C#), that's why. I was actually requesting an instance
    of an appropriate sub-class from the abstract base-classes, static definition.
  prefs: []
  type: TYPE_NORMAL
- en: Those three use cases in the preceding code block cover just about everything
    you can do with `Create()` out of the box, but that certainly doesn't mean those
    are the only use cases `Create()` can apply to. The functionality uses common
    protocol prefixes for URIs to determine default sub-classes to instantiate. So,
    simply passing [http://test-domain.com](http://test-domain.com) to the method
    is all the default implementation needs to then return an instance of the `HttpWebRequest`
    class. The same logic that allows the `Uri` class to parse the preceding string
    is used to tell `WebRequest` which protocol it should be creating a sub-class
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, though, the default behavior is only defined for a limited set of
    use cases out of the box. There are four specific protocols whose concrete sub-classes
    are preregistered with the `WebRequest` class at runtime; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ftp://`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file://`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, any URI string given to the `Create` method with any of these four prefixes
    as the first characters in the string will be reliably handled by the `WebRequest` base
    class. And since the base class provides a sufficient interface for executing
    the core operations of its sub-classes, you don't even have to know specifically
    what sub-class was returned. Thanks to type inheritance, you can just declare
    your instance as being of type `WebRequest`, and use it accordingly, just like
    I did in the sample method from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you don't want to work with one of these four preregistered types?
    What if you wrote your own custom `WebRequest` sub-class specifically for working
    with a **WebSocket** (**WS**) protocol, and you'd like to get the same support
    from `WebRequest` just by passing in a URI with the WebSocket prefix of `ws://`?
    Well, that exact use case leads us to another state management method: `RegisterPrefix(string,
    IWebRequestCreate)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RegisterPrefix` is a powerful new tool that supports what''s known as **pluggable
    protocols**. It''s basically a way for you to incorporate custom implementations
    and sub-classes of the `WebRequest` and `WebResponse` base classes into the runtime
    of your application. When done properly, your custom code can be treated as a
    first-class citizen in the `System.Net` namespace, being appropriately delegated
    to by system types and methods, and having full access to the network stack, just
    like the native library classes you''ll be learning about next.'
  prefs: []
  type: TYPE_NORMAL
- en: The scope and depth of fully implementing a custom protocol handler are beyond
    this chapter, and will be explored in more detail later in this book. For now
    though, just know that once the work of writing a custom protocol handler is completed,
    wiring it in is as simple as calling `RegisterPrefix`. That's why this falls under
    the domain of state management methods; because it's about configuring the working
    conditions of `WebRequest` for the duration of your application's runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method returns a `bool` to indicate the success or failure of your attempt
    to register your custom protocol, and throw or process exceptions accordingly.
    So, while the process of setting up a pluggable protocol is outside the scope
    of this chapter, for now just trust that, once the work is done, configuring it
    as part of the valid state of the `WebRequest` class is a straightforward affair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we have every tool we need to properly configure and initialize
    network requests. State management is complete, and all that's left is to begin
    submitting requests and processing responses.
  prefs: []
  type: TYPE_NORMAL
- en: Request execution methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I said before, most of these methods are designed to be leveraged asynchronously,
    but at least a few of them have synchronous, or blocking, counterparts. While
    we'll talk more about async programming later, what's important now is to note
    that there are two primary operations or tasks around which the `WebRequest` class
    is focused. The first is accessing the actual request data stream, and the second
    is accessing the response returned by the remote resource.
  prefs: []
  type: TYPE_NORMAL
- en: With a `WebRequest` instance, the `RequestStream` is .NET's representation of
    the open connection. Think of it as the wire over which you can transmit your
    signal. Anytime you want to pass data through a `WebRequest` instance, you'll
    first need to access that wire. Once you have it, you can start passing data through
    that stream, and trust that the `WebRequest` class is going to broker its transmission
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that writing to a stream typically requires the raw byte array
    for a given object (this is where serialization comes into play), so once we have
    our stream, writing to it isn''t as simple as passing our objects or messages
    directly over the wire, although it''s not prohibitively complicated either. In
    practice, however you choose to access the request stream for an active instance
    of `WebRequest`, writing to it will typically look similar to the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And that's all there is to it. There are some nuances with this method in some
    of the common sub-classes of `WebRequest`, but the basic principle will always
    apply.
  prefs: []
  type: TYPE_NORMAL
- en: That, right there, accounts for about half of the request execution methods.
    The `BeginGetRequestStream()/EndGetRequestStream()`, `GetRequestStream()`, and `GetRequestStreamAsync()` methods
    are three different ways of accessing the same logical component of your network
    transaction. They simply provide varying degrees of control over the synchronization
    of the operation. For example, the `BeginGetRequestStream()/EndGetRequestStream()`
    method provides an opportunity for the user to cancel the request before it has
    completed transmission by explicitly calling the `Abort()` method. Meanwhile,
    the `GetRequestStreamAsync()` method doesn't provide the opportunity to explicitly
    abort the operation, but it does perform the operation asynchronously. Circumstances
    will dictate what method or methods you should be using, but if handled correctly
    and resolved properly by the underlying connection, the result object is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can look at the response processing methods, and it should be no
    surprise to you that in the request/response pattern that is typical of most network
    transactions, the response handlers match, almost exactly, with the request handler
    method signatures. So, where the act of retrieving a request stream from the `WebRequest`
    instance was exposed through four different methods with various levels of granular
    control over the synchronization of the operations, so too is response processing.
    The methods we have available to us are `BeginGetResponse()/EndGetResponse()`
    (the processing for which cannot be interrupted by `Abort()`, however), `GetResponseAsync()`,
    and of course, `GetResponse()`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the shape of a given response will depend on the specific protocol
    over which it was received. Just as the `WebRequest` class has protocol-specific
    sub-classes, so too does the `WebResponse` base class. We'll explore each of them
    in their respective chapters, and look at how their responses can be handled more
    concretely. But for now, it is sufficient to say that the `WebResponse` class
    provides us with a reliable enough interface to meaningfully interact with whatever
    we get back from our request.
  prefs: []
  type: TYPE_NORMAL
- en: So, by now, you should have an extremely clear understanding of exactly what
    problem the `WebRequest` class was written to solve. You should understand its
    scope and the limits of its use cases, and hopefully, you will know exactly how
    to tune it so that you can fully leverage it for any scenario in which it could
    save you time and effort. With this understanding in mind, let's take a look at
    some of the most common ways the base class is explicitly leveraged through some
    of the sub-classes provided as part of the .NET Standard.
  prefs: []
  type: TYPE_NORMAL
- en: The sub-classes of the WebRequest class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a lot of typical use cases, you can rely on the basic functionality provided
    by the underlying `WebRequest` class. However, you'll never actually be using
    instances of it directly in your code (you can't... it's abstract, remember?),
    so now is the time to look at what other functionality or features exist when
    you're using common concrete instances of it. We'll look at each of the sub-classes
    for which `WebRequest` has a default, preregistered handler.
  prefs: []
  type: TYPE_NORMAL
- en: A note on obsolete sub-classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, it's important to note that the `WebRequest` class is primarily a tool
    for creating lower-level, protocol agnostic request/response transactions with
    other resources on your network. The .NET Standard provided sub-classes that,
    while not explicitly deprecated, have been made mostly obsolete by slightly more
    robust client classes, such as the `HttpClient` or `WebClient` classes.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, Microsoft recently released a recommendation for always
    using the newer client classes over any of the slightly older sub-classes that
    I'm about to discuss. That's precisely why so little of this chapter is dedicated
    to the concrete classes. The important aspects of the request/response model are
    still handled by .NET's `WebRequest` and `WebResponse` classes under the hood
    of the new `WebClient` class. More importantly, those base classes are the most
    basic building blocks from which you can build your own custom protocol handlers.
    That's why it's so important to understand, especially for readers new to any
    sort of web or network programming, how and why the `WebRequest` class is written
    the way it is. However, as is often the case with software, times are changing,
    and so the extent that this lesson will remain useful as a practical guide for
    specific implementation of common patterns will only diminish with time.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, it is worth examining what is different about those classes
    and how they can be used to build up a network request from scratch, so let's
    take a brief look.
  prefs: []
  type: TYPE_NORMAL
- en: HttpWebRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HttpWebRequest` class is interesting in that until very recently, it wasthe workhorse
    class of network programming in .NET. This is evident in the huge explosion of
    the class specification when compared to the relative simplicity of the `WebRequest`
    class. There are properties for each standard HTTP header that could be defined
    for a given payload, as well as a headers property inherited from the base class
    for specifying custom or non-standard headers. There are properties to specify
    the transport details, such as the `TransferEncoding`, or whether or not to send
    data in chunked segments. There are properties to specify how to handle exceptional
    behaviors from the remote host, such as the `MaximumResponseHeadersLength` and
    `MaximumAutomaticRedirections` properties. All of these properties allowed you
    to build a complete and strong payload for an HTTP request from scratch. As you
    can imagine, though, it was often tedious, error-prone, and verbose to do this
    for every request to every HTTP resource. Often, developers would hand-roll custom
    HTTP client classes of their own to isolate that aspect of their application in
    a write once, use everywhere approach. This degree of granularity is why the engineers
    at Microsoft decided to write a more robust and easy-to-use client for brokering
    common HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: It isinteresting to note, however, that if you look at class specifications
    side by side, the method signatures exposed by `HttpWebRequest` are exactly the
    same as those exposed by `WebRequest`. The only meaningful distinction between
    the two is the context-specific configurations that `HttpWebRequest` provides
    as class properties. This further highlights the elegance of the design of `WebRequest`.
    By taking a straightforward, generic approach to the problem, it can serve all
    possible specific use cases using the same patterns.
  prefs: []
  type: TYPE_NORMAL
- en: FtpWebRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FtpWebRequest` class provides many of the same properties as the `HttpWebRequest`
    class. The distinction comes in the form of a few specific properties for configuring
    reliable behavior when processing potentially large files over a potentially unreliable
    or slow connection. To that end, it provides the `ReadWriteTimeout` property that
    specifies the maximum amount of time allowed for processing the file stream. There's
    also the FTP-specific `UsePassive` property that allows a user to specify the
    use of the passive transfer process, leaving an open listening connection on the
    server for clients to access files accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's also the explicit `EnableSsl` parameter, which you might have noticed
    was not a property of `HttpWebRequest`. Interestingly, this is necessary for the
    `FtpWebRequest` class but not the `HttpWebRequest` class because the use of **Secure
    Sockets Layer** (**SSL**) in HTTP is actually specified in the protocol component
    of the URI (that is, HTTP versus HTTPS); whereas with FTP, that feature must be
    enabled explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the actual use of the `FtpWebRequest` class is exactly the same
    as with the `WebRequest` base class. Once the protocol-specific settings are properly
    configured through the class properties, FTP is ultimately just another request/response
    protocol for accessing remote resources.
  prefs: []
  type: TYPE_NORMAL
- en: FileWebRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FileWebRequest` is probably the least commonly used sub-class of them all.
    Its signature almost perfectly matches that of the `WebRequest` base class. Its
    purpose is to expose the same reliable request/response pattern for accessing
    resources on the local file system.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may be wondering why on earth such a class would ever be
    useful. Well, like any good engineer, we'll eventually want to be able to do a
    unit and integration test on our network software. However, that won't always
    be feasible, since remote resources that we can expect to be available to our
    production environment might not always be available to our development environment.
    In that case, you'd want to be able to access your mock resources on your local
    system. Thanks to the shared parent class of the `WebRequest` class, it's a trivial
    matter to swap out an instance of `FileWebRequest` and `HttpWebRequest` in your
    development and production environments, respectively. Since each of these sub-classes
    is only ever instantiated through the `Create()` method on the `WebRequest` class,
    doing so is as easy as changing the URI of the remote resource stored in your
    application's configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: The power of the `FileWebRequest` class comes from the consistency of its interface.
    So, while there are no special properties or methods associated with this instance
    of the class, extending the behavior of `WebRequest` to local file access is really
    what makes this class valuable.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, our crash-course on the building blocks of network interactions
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a thorough look at the `WebRequest` utility class,
    and how it can be used to handle a wide variety of common network operations within
    the context of a .NET application. We used the public interface of the class definition
    to infer the proper use and use cases for the class, as well as identifying the
    limits of its scope and operations. We considered the proper use and invocation
    of each of the public properties and methods defined on the base class, and wrote
    out some broadly applicable examples to demonstrate the simplicity and utility
    of the class and its children. Then, we considered the three most common concrete
    sub-classes of `WebRequest`. We examined some of the nuances between each of them
    and looked at how they facilitate the specific details of the protocols they were
    designed to operate over. Now we're ready to look at how to process the results
    of those requests in the most optimal way for the .NET runtime. It's time we looked
    at data stream processing, multi-threading, and asynchronous programming, which
    we'll explore in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the valid values for the `CachePolicy` property of the `WebRequest`
    class, and where can they be found?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the method used to associate the custom sub-classes of the `WebRequest`
    class with requests to the associated protocol for that custom sub-class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What property is used to associate multiple requests to the same connection
    in the .NET connection pool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four preregistered protocols for which the `WebRequest` class is
    configured to return a valid sub-class from the `Create(uri)` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `BeginGetRequestStream()`, `GetRequestStreamAsync()`,
    and `GetRequestStream()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some of the ways the `HttpWebRequest` class differs from the default behavior
    of the `WebRequest` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to always leverage `ConnectionGroupName` whenever possible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For additional reading on this subject, or to expand your horizons once you've
    conquered the realm of network programming, check out *Building Microservices
    with .NET Core*,* Gaurav Aroraa, Lalit Kale, and Kanwar Manish*, available through
    Packt Publishing at [https://www.packtpub.com/web-development/building-microservices-net-core](https://www.packtpub.com/web-development/building-microservices-net-core).
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, I''d recommend checking out *C# 7 and .NET: Designing Modern
    Cross-platform Applications, Mark J. Price and Ovais Mehboob Ahmed Khan, Packt
    Publishing,* for some solid advice for practical applications of the concepts
    discussed here. You can find this book at [https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications](https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications).'
  prefs: []
  type: TYPE_NORMAL
