<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with Mono"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Mono</h1></div></div></div><p>Unity supports two main scripting languages, namely, C# and <a id="id442" class="indexterm"/>JavaScript. Developers should select one of these two from<a id="id443" class="indexterm"/> the outset and apply it consistently throughout their project; this writes all scripts in the selected language. Failure to do so (by mixing script files in different languages) typically causes unnecessary headache and confusion. However, once you've settled on a language, such as C#, it usually won't offer everything you need it to do to create games. C#, on its own, can neither load and parse XML files to<a id="id444" class="indexterm"/> support save-game data, nor can it create window objects and GUI widgets to perform advanced search and query behaviors on complex data sets and collections. To achieve these additional behaviors and lots more, we must turn to external libraries. Some libraries can be purchased directly from the Unity's Asset Store, and these are typically used for a specific and dedicated purpose. However, Unity ships with the Mono Framework, which is a free, cross-platform, and open source implementation of the Microsoft .NET Framework (a programming library), and it offers most classes available in this library. The .NET Framework features classes to handle strings, file input-output, search and sort data, keep track of dynamic lists, parse XML, and more. This means that through Mono an extensive toolkit is open to you to effectively and efficiently manage data in your application. This chapter explores some of the many ways in which Mono can be deployed in a Unity application by considering lists, stacks, <span class="strong"><strong>Language Integrated Query</strong></span> (<span class="strong"><strong>Linq</strong></span>), regular expressions, enumerators, and so on.</p><p>The following screenshot shows the Mono Framework interface:</p><div class="mediaobject"><img src="graphics/0655OT_06_01.jpg" alt="Working with Mono"/><div class="caption"><p>The Mono Framework ships with the Unity engine</p></div></div><div class="section" title="Lists and collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Lists and collections</h1></div></div></div><p>Perhaps, the most common task when programming games is to <a id="id445" class="indexterm"/>store lists of data. The nature of this data varies tremendously: high scores, player stats, enemy stats, inventory items, weapons, power-ups, level lists, and more. Wherever possible, choose static arrays to hold data due to their speed and efficiency. Static arrays were considered in detail in <a class="link" href="ch01.html" title="Chapter 1. Unity C# Refresher">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>. In short, static arrays are created ahead of time, and their maximum capacity is fixed from the outset. Items can be added and removed from them at runtime, but their total size can never change. If their maximum capacity is not<a id="id446" class="indexterm"/> utilized, then space would be wasted. Static arrays, as their name implies, are an excellent choice for storing lists of data that remain constant, such as all levels in the game, all weapons that can possibly be collected, all power-ups that can possibly be collected, and so on.</p><p>However, you'll often need dynamic arrays, which can grow and shrink in capacity to exactly accommodate the data you need as it changes, such as when enemies are spawned and destroyed, inventory items come and go, weapons are collected and discarded, and so on. The Mono Framework offers many classes to maintain lists of data. The three main classes are <code class="literal">List</code>, <code class="literal">Stack</code>, and <code class="literal">Dictionary</code>. Each of these is useful for a specific purpose.</p><div class="section" title="The List class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>The List class</h2></div></div></div><p>If you need an <a id="id447" class="indexterm"/>unordered, sequential list<a id="id448" class="indexterm"/> of items of any single data type, that is, a list that grows and shrinks to match the size of the stored data, then the <code class="literal">List</code> class is ideal. <code class="literal">List</code> is especially good to add and remove<a id="id449" class="indexterm"/> items and sequentially iterating through all stored items. In addition, the <code class="literal">List</code> objects are editable from the Unity Object Inspector. The following code sample 6-1 uses a sample C# file <code class="literal">Using_List.cs</code>:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
<span class="strong"><strong>03 using System.Collections.Generic;</strong></span>
04 //----------------------------------------
05 //Sample enemy class for holding enemy data
<span class="strong"><strong>06 [System.Serializable]</strong></span>
07 public class Enemy
08 {
09 public int Health = 100;
10 public int Damage = 10;
11 public int Defense = 5;
12 public int Mana = 20;
13 public int ID = 0;
14 }
15 //----------------------------------------
16 public class Using_List : MonoBehaviour 
17 {
18 //----------------------------------------
19 //List of active enemies in the scene
<span class="strong"><strong>20 public List&lt;Enemy&gt; Enemies = new List&lt;Enemy&gt;();</strong></span>
21 //----------------------------------------
22 // Use this for initialization
23 void Start () 
24 {
25        //Add 5 enemies to the list
26        for(int i=0; i&lt;5; i++)
<span class="strong"><strong>27              Enemies.Add (new Enemy()); //Add method inserts item to end of the list</strong></span>
28 
29        //Remove 1 enemy from start of list (index 0)
<span class="strong"><strong>30        Enemies.RemoveRange(0,1);</strong></span>
31 
32        //Iterate through list 
<span class="strong"><strong>33        foreach (Enemy E in Enemies)</strong></span>
34        {
35              //Print enemy ID
36              Debug.Log (E.ID);
37        }
38 }
39 }
40 //----------------------------------------</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>More details on using <code class="literal">List</code> can be found in the book's companion files (code bundle) at <code class="literal">Chapter06\Collections</code>. You can also see the <code class="literal">List</code> class reference documentation in<a id="id450" class="indexterm"/> the MSDN at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx</a>.</p></div></div><p>The following are the comments for code sample 6-1:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 03</strong></span>: To use the <code class="literal">List</code> class, you must include the <code class="literal">System.Collections.Generic</code> namespace.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 06</strong></span>: If your list data type is declared as a <code class="literal">System.Serializable</code> class, then the list would be shown in the Object Inspector.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 20</strong></span>: You can declare and initialize a new list instance in just one statement inside the class members' declaration.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 27</strong></span>: New objects are immediately added to the end of the list using the <code class="literal">Add</code> method.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 30</strong></span>: Items can be removed using several methods. <code class="literal">RemoveRange</code> lets you delete several consecutive items from the list. Other removal methods include <code class="literal">Remove</code>, <code class="literal">RemoveAll</code>, and <code class="literal">RemoveAt</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 33</strong></span>: You can cycle through all items in a list using a <code class="literal">foreach</code> loop.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 27-33</strong></span>: Generally, don't add or remove items to or from a list while looping through it.</li></ul></div><p>The following screenshot shows the <code class="literal">List</code> class in the Object Inspector:</p><div class="mediaobject"><img src="graphics/0655OT_06_02.jpg" alt="The List class"/><div class="caption"><p>Viewing the List class in the Object Inspector</p></div></div><p>The <code class="literal">List</code> class supports several methods to remove items either individually or collectively, and these are intended to be used outside list iterations (loops). However, there are times when it's convenient, or seems simplest, to remove items while iterating through a loop, such as<a id="id451" class="indexterm"/> when you need to remove each item after processing it. A classic case is when you need to delete all reference type objects in the scene, such as enemies, while also removing their entry in the array to avoid null references. Item removal in a loop, however, can cause problems, because it's easy for an iterator to lose track of where it is and where it should go within the array as the total item count changes during the loop. To loop and remove in one process, you should traverse the array backwards from the end to the start, as opposed to forwards, as shown in the following code sample 6-2:</p><div class="informalexample"><pre class="programlisting"> //Remove all items from a loop 
 void RemoveAllItems()
 {
    //Traverse list backwards
<span class="strong"><strong>    for(int i = Enemies.Count-1; i&gt;=0; i--)</strong></span>
    {
         //Call function on enemy before removal
         Enemies[i].MyFunc();
 
        //Remove this enemy from list
        <span class="strong"><strong>Enemies.RemoveAt(i);</strong></span>
    }
 }</pre></div></div><div class="section" title="The Dictionary class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>The Dictionary class</h2></div></div></div><p>The <code class="literal">List</code> class is, perhaps, one of the<a id="id452" class="indexterm"/> most useful classes in the Mono Framework for in-memory data storage. However, let's not forget the <code class="literal">Dictionary</code> class (similar to the <code class="literal">std::map</code> class in C++). This class is especially useful when <a id="id453" class="indexterm"/>you need more than just a simple list of items. If you need to search for and get instant access to specific elements based on a key value, then the <code class="literal">Dictionary</code> class is essential. For each item in the list, you must save a corresponding key or ID that uniquely identifies the item from all others. The <code class="literal">Dictionary</code> class then allows you to get instant access to this item, based solely on its key. This makes the <code class="literal">Dictionary</code> class useful as a true dictionary for word games, for example, if you need to look up the meaning or score-value of specific words in a large dictionary or database of words. The word itself would be the key, and the word definition would be the value.</p><p>Now, of course, you can replicate this kind of behavior using multiple <code class="literal">List</code> objects instead of the <code class="literal">Dictionary</code> class. However, the <code class="literal">Dictionary</code> class is extremely fast in terms of performance, almost lightning fast. You can store vast quantities of data inside the dictionary at very little performance cost. This makes them highly valuable for a quick data lookup from key values, as shown in the following code sample 6-3;</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
<span class="strong"><strong>03 using System.Collections.Generic; </strong></span>
04 
05 public class Using_Dictionary : MonoBehaviour 
06 {
07 //Database of words. &lt;Word, Score&gt; key-value pair
<span class="strong"><strong>08 public Dictionary&lt;string, int&gt; WordDatabase = new Dictionary&lt;string, int&gt;();</strong></span>

09 
10 // Use this for initialization
11 void Start () 
12 {
13        //Create some words
14        string[] Words = new string[5];
15        Words[0]="hello";
16        Words[1]="today";
17        Words[2]="car";
18        Words[3]="vehicle";
19        Words[4]="computers";
20 
21        //add to dictionary with scores 
22        foreach(string Word in Words)
23             WordDatabase.Add(Word, Word.Length);
24  
25       //Pick word from list using key value
26       //Uses array syntax! 
27       Debug.Log ("Score is: " + <span class="strong"><strong>WordDatabase["computers"].ToString()</strong></span>);

28 }
29 }</pre></div><p>The following are the <a id="id454" class="indexterm"/>comments for code sample 6-3:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 03</strong></span>: As with the <code class="literal">List</code> class, you must include the <code class="literal">System.Collections.Generic</code> namespace</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 08</strong></span>: Here, the dictionary is declared and created in one line; unlike the <code class="literal">List</code> class, <code class="literal">Dictionary</code> does not appear in the Unity Object Inspector</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 13-23</strong></span>: The <code class="literal">Dictionary</code> class is populated using the <code class="literal">Add</code> method</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 27</strong></span>: Elements in the <code class="literal">Dictionary</code> class are accessed much like arrays, except by specifying each element using its key data instead of an array index<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>More details on using <code class="literal">Dictionary</code> can be found in <a class="link" href="ch04.html" title="Chapter 4. Event-driven Programming">Chapter 4</a>, <span class="emphasis"><em>Event-driven Programming</em></span>, when considering event-driven programming with an <code class="literal">EventManager</code>.</p></div></div></li></ul></div></div><div class="section" title="The Stack class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>The Stack class</h2></div></div></div><p>If you're making a card game <a id="id455" class="indexterm"/>where players should pick the top<a id="id456" class="indexterm"/> card from a deck, if you need an undo history, if you're coding customized path finding, or if you're creating a complex spell-casting system or even a Tower of a <a id="id457" class="indexterm"/>Hanoi puzzle game (<a class="ulink" href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">http://en.wikipedia.org/wiki/Tower_of_Hanoi</a>), the chances are high that you'll need a stack somewhere along the line. A stack is a special kind of list based on<a id="id458" class="indexterm"/> the <span class="strong"><strong>Last in, first out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) model. The concept is about stacking. You can push items into the list, and these stack up one atop the other in a vertical tower, with the most recently pushed item always at the top. Then, you can pop items from the top of the stack (remove them from the array) one by one. The order in which you pop items is always the inverse of the order in which they were pushed.</p><p>This is why <code class="literal">Stack</code> is especially useful for the undo or rewind functionality. Refer to the following code sample 6-4 for an example on how to use <code class="literal">Stack</code>:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 using System.Collections.Generic;
 //------------------------------------------
 [System.Serializable]
 public class PlayingCard
 {
    public string Name;
    public int Attack;
    public int Defense;
 }
 //------------------------------------------
 public class Using_Stack : MonoBehaviour 
 {
    //------------------------------------------
   //Stack of cards
   public Stack&lt;PlayingCard&gt; CardStack = new Stack&lt;PlayingCard&gt;();
   //------------------------------------------
    // Use this for initialization
    void Start () 
   {
         //Create card array
         PlayingCard[] Cards = new PlayingCard[5];
 
        //Create cards with sample data
        for(int i=0; i&lt;5; i++)
        {
                Cards[i] = new PlayingCard();
                Cards[i].Name = "Card_0" + i.ToString();
                Cards[i].Attack = Cards[i].Defense = i * 3;
  
                //Push card onto stack
                CardStack.Push(Cards[i]);
          }
 
          //Remove cards from stack while(CardStack.Count &gt; 0)
          {
                PlayingCard PickedCard = CardStack.Pop();
 
                //Print name of selected card
                Debug.Log (PickedCard.Name);
          }
   }
   //------------------------------------------
 }
 //------------------------------------------</pre></div></div></div></div>
<div class="section" title="IEnumerable and IEnumerator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>IEnumerable and IEnumerator</h1></div></div></div><p>When you're working with collections of data, whether <code class="literal">List</code>, <code class="literal">Dictionary</code>, <code class="literal">Stack</code>, or others, you'll typically want to iterate (or traverse) all items in the list or at least some items, based on a specific criteria. In some cases, you'll want to loop through all items in sequence or some items. Most often, you'll want to traverse the items forwards in sequence, but as we've seen, there <a id="id459" class="indexterm"/>are times when reverse traversing is also suitable. You can loop through items using a standard for loop. However, this raises some<a id="id460" class="indexterm"/> annoyances that the interfaces of <code class="literal">IEnumerable</code> and <code class="literal">IEnumerator</code> can help us solve. Let's see what the annoyances are. Consider the <code class="literal">for</code> loop in the following code sample 6-5:</p><div class="informalexample"><pre class="programlisting"> //Create a total variable
 int Total = 0;
 
 //Loop through List object, from left to right
<span class="strong"><strong> for(int i=0; i&lt;MyList.Count; i++)</strong></span>
 {
    //Pick number from list
    int MyNumber = MyList[i];
 
    //Increment total
    Total += MyNumber;
 }</pre></div><p>There are three main annoyances while using a <code class="literal">for</code> loop. Let's start with the first two. The first is that the syntax is not especially inviting for a loop that just cycles from left to right, from beginning to end, and we must always use an integer iterator variable (<code class="literal">i</code>) to access each array element as the loop proceeds. The second is that the iterator itself is not truly "bounds safe". It can, in fact, be incremented or decremented either above or below the array limits and cause an out-of-bounds error.</p><p>These issues can, to some extent, be fixed using the neater <code class="literal">foreach</code> loop, which is bounds safe and uses a simpler syntax, as shown in following code sample 6-6:</p><div class="informalexample"><pre class="programlisting"> //Create a total variable
 int Total = 0;
 
 //Loop through List object, from left to right
 foreach(int Number in MyList)
 {
    //Increment total
    Total += Number;
 }</pre></div><p>The <code class="literal">foreach</code> loop is simpler and is to be preferred for readability, but there's more going on here than first meets the eye. The <code class="literal">foreach</code> loop works only for classes that implement the <code class="literal">IEnumerable</code> interface. Objects that implement <code class="literal">IEnumerable</code> must return a valid instance to an <code class="literal">IEnumerator</code> interface. So, for an object to work in a <code class="literal">foreach</code> loop, it must depend on two other interfaces. The question that then arises is why is there all this internal complexity for simple<a id="id461" class="indexterm"/> looping or traversal behavior. The answer is, not only do the <code class="literal">IEnumerable</code> and <code class="literal">IEnumerator</code> solve the first two problems of simpler syntax and bounds-safe iteration by way of the <code class="literal">foreach</code> loop, but they also solve a third problem. Specifically, they<a id="id462" class="indexterm"/> allow us to loop through or iterate groups of objects that are not even truly array types; that is, they let us iterate through many different types of objects, whether or not they're in an array, as though they were in an array. This can be very powerful. Let's see this in action in a practical example.</p><div class="section" title="Iterating through enemies with IEnumerator"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Iterating through enemies with IEnumerator</h2></div></div></div><p>Take, for example, an RPG game that features a medieval world inhabited by many different and evil wizard characters (coded in class <code class="literal">Wizard</code>). For the sake of example, these wizards will spawn into the level at random places and random intervals, potentially causing untold trouble for the gamer, casting spells, and performing evil deeds. The result of such random<a id="id463" class="indexterm"/> spawning is that, by default, we cannot know in advance how many wizards there will be in the scene at any one time, nor can we know where they've been spawned, because it's random. However, there are still legitimate reasons why we'd need to find all the wizards; perhaps, all the wizards must be disabled, hidden, paused, or killed, or, perhaps, we need a head count to prevent overspawning. So, regardless of the wizard spawning and its randomness, there are still good justifications for being able to access all the wizards in the level on demand.</p><p>We've seen already, in <a class="link" href="ch02.html" title="Chapter 2. Debugging">Chapter 2</a>, <span class="emphasis"><em>Debugging</em></span>, one way in which we can retrieve a traversable list of all wizards, as shown in the following code sample 6-7:</p><div class="informalexample"><pre class="programlisting"> //Get all wizards
<span class="strong"><strong> Wizard[] WizardsInScene = Object.FindObjectsOfType&lt;Wizard&gt;();</strong></span>
 
 //Cycle through wizards
 foreach (Wizard W in WizardsInScene)
 {
    //Access each wizard through W
 }</pre></div><p>The problem with the<a id="id464" class="indexterm"/> <code class="literal">FindObjectsOfType</code> function is that it's slow and performance prohibitive when used frequently. Even the <a id="id465" class="indexterm"/>Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html">http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html</a> recommends against its repeated use.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>A sample Unity project using the <code class="literal">IEnumerator</code> and <code class="literal">IEnumerable</code> interfaces can be found in the book's companion files (code bundle) at <code class="literal">Chapter06\Enumerators</code>.</p></div></div><p>So, instead, we can achieve similar behavior using <code class="literal">IEnumerable</code> and <code class="literal">IEnumerator</code>, and this avoids significant performance penalties. Using these two interfaces, we'll be able to efficiently iterate<a id="id466" class="indexterm"/> through all the wizards in the scene, using a <code class="literal">foreach</code> loop, as though they were in an array, as shown in the following code sample 6-8:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 using System.Collections.Generic;
04 //----------------------------------------------------
05 //Class derives from IEnumerator
06 //Handles bounds safe iteration of all wizards in scene
<span class="strong"><strong>07 public class WizardEnumerator : IEnumerator</strong></span>
08 {
09 //Current wizard object pointed to by enumerator
10 private Wizard CurrentObj = null;
11 //----------------------------------------------------
12 //Overrides movenext
<span class="strong"><strong>13 public bool MoveNext()</strong></span>
14 {
15       //Get next wizard
16       CurrentObj = (CurrentObj==null) ? Wizard.FirstCreated : CurrentObj.NextWizard;

17 
18       //Return the next wizard
19       return (CurrentObj != null);
20 }
21 //----------------------------------------------------
22 //Resets the iterator back to the first wizard
<span class="strong"><strong>23 public void Reset()</strong></span>
24 {
25       CurrentObj = null;
26 }
27 //----------------------------------------------------
28 //C# Property to get current wizard
<span class="strong"><strong>29 public object Current</strong></span>
30 {
31       get{return CurrentObj;} 
32 }
33 //----------------------------------------------------
34 }
35 //----------------------------------------------------
36 //Sample class defining a wizard object
37 //Derives from IEnumerable, allowing looping with foreach
38 [System.Serializable]
<span class="strong"><strong>39 public class Wizard : MonoBehaviour, IEnumerable</strong></span>
40 {
41 //----------------------------------------------------
42 //Reference to last created wizard
43 public static Wizard LastCreated = null;
44 
45 //Reference to first created wizard
46 public static Wizard FirstCreated = null;
47 
48 //Reference to next wizard in the list
49 public Wizard NextWizard = null;
50 
51 //Reference to previous wizard in the list
52 public Wizard PrevWizard = null;
53 
54 //Name of this wizard
55 public string WizardName = "";
56 //----------------------------------------------------
57 //Constructor
58 void Awake()
59 {
60       //Should we update first created
61      if(FirstCreated==null)
62             FirstCreated = this;
63 
64       //Should we update last created
65       if(Wizard.LastCreated != null) 
66       {
67              Wizard.LastCreated.NextWizard = this;
68              PrevWizard = Wizard.LastCreated;
69       }
70 
71        Wizard.LastCreated = this;
72 }
73 //----------------------------------------------------
74 //Called on object destruction
75 void OnDestroy()
76 {
77       //Repair links if object in chain is destroyed
78       if(PrevWizard!=null)
79              PrevWizard.NextWizard = NextWizard;
80 
81       if(NextWizard!=null) 
82              NextWizard.PrevWizard = PrevWizard;
83 }
84 //----------------------------------------------------
85 //Get this class as enumerator
86 public IEnumerator GetEnumerator()
87 {
88        return new WizardEnumerator();
89 }
90 //----------------------------------------------------
91 }
92 //-------------------------------------------------------------------</pre></div><p>The following are the <a id="id467" class="indexterm"/>comments for code sample 6-8:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 07 and 39</strong></span>: Two classes are created here: the first is <code class="literal">WizardEnumerator</code>, which implements <code class="literal">IEnumerator</code>, and the second is <code class="literal">Wizard</code>, which implements <code class="literal">IEnumerable</code>. The <code class="literal">WizardEnumerator</code> class is instantiated simply to iterate over a collection of wizards that keeps track of the current wizard in the iteration process. To loop through or iterate over all wizards in the scene, it relies on member variables for the <code class="literal">Wizard</code> class, as we'll see in the upcoming sections.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 13, 23, and 29</strong></span>: The<a id="id468" class="indexterm"/> <code class="literal">WizardEnumerator</code> class implements the methods and properties of <code class="literal">IEnumerator</code>, specifically, <code class="literal">MoveNext</code> (which iterates over to the next wizard in the cycle), <code class="literal">Reset</code> (which resets the iterator back to the first wizard), and <code class="literal">Current</code> (which returns the active wizard in the cycle).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 39</strong></span>: The <a id="id469" class="indexterm"/><code class="literal">Wizard</code> class encapsulates a wizard character in the scene and inherits from two classes: <code class="literal">MonoBehaviour</code> and <code class="literal">IEnumerable</code>. This means that all the features of both classes come together in this derived class. It internally maintains several variables that allow the enumerator to loop through all the wizard instances in the scene at any time. First, <code class="literal">Wizard</code> holds the <code class="literal">FirstCreated</code> and <code class="literal">LastCreated</code> static members (which are global to all the wizard instances). These variables are set when objects are created (see the <code class="literal">Awake</code> function in line 58). <code class="literal">FirstCreated</code> always refers to the instance of a wizard that was created first, and <code class="literal">LastCreated</code> always to the most recently created instance.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 48 and 52</strong></span>: The <code class="literal">Wizard</code> class also maintains the instance variables, <code class="literal">NextWizard</code> and <code class="literal">PrevWizard</code>. This implements a doubly-linked list; that is, each instance of the wizard points to the previously and subsequently created instance, which allows a chain-like connection between all wizards. The first wizard will have <code class="literal">PrevWizard</code> or <code class="literal">null</code>, and the last wizard will have <code class="literal">NextWizard</code> or <code class="literal">null</code>. These variables make it possible for the iterator to cycle through all wizard instances even when none of them are in an array.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 86</strong></span>: The <code class="literal">GetEnumerator</code> method<a id="id470" class="indexterm"/> returns an instance to an <code class="literal">Enumerator</code> object. This is required<a id="id471" class="indexterm"/> by the <code class="literal">IEnumerable</code> interface and allows a <code class="literal">foreach</code> loop across all wizards.</li></ul></div><p>Together, the <code class="literal">Wizard</code> and <code class="literal">WizardEnumerator</code> classes offer fast, direct, and efficient <code class="literal">Wizard</code> object cycling, even though no array of wizards need to truly exist. To see this in practice, in a scene of wizards, the following code sample 6-9 can enumerate all wizards:</p><div class="informalexample"><pre class="programlisting">void Update()
{
   //Press space to list all wizards in scene
   if(Input.GetKeyDown(KeyCode.Space))
   {
         //Get first wizard through static member
         Wizard WizardCollection= Wizard.FirstCreated;

         //If there is at least one wizard, then loop them all
         if(Wizard.FirstCreated != null)
          {
                //Loop through all wizards in foreach
                foreach(Wizard W in WizardCollection)
                       Debug.Log (W.WizardName);

          }
   }
}</pre></div><p>You can also enumerate through all wizards outside a <code class="literal">foreach</code> loop by accessing the <code class="literal">Enumerator</code> object directly, as shown in the following code sample 6-10:</p><div class="informalexample"><pre class="programlisting">void Update()
{
   //Press space to list all wizards in scene
   if(Input.GetKeyDown(KeyCode.Space))
   {
         //Get Enumerator
         IEnumerator WE = Wizard.FirstCreated.GetEnumerator();

          while(WE.MoveNext())
          {
                Debug.Log(((Wizard)WE.Current).WizardName);
          }
   }
}</pre></div></div></div>
<div class="section" title="Strings and regular expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Strings and regular expressions</h1></div></div></div><p>Working with text data is critical and for many reasons. If you need to display subtitles, show in-game text, and implement localization functionality (supporting multiple languages), then you<a id="id472" class="indexterm"/> would be working with text, specifically with Text Assets. In Unity, Text Assets refer to any text files included in the Unity project, and each asset is treated as <a id="id473" class="indexterm"/>one long string even when multiple lines are involved (each line is separated by a <code class="literal">\n</code> escape character). Once your code is presented with a string like this, however, there're typically many ways in which you'll want to process it. Let's see some common but important string operations.</p><div class="section" title="Null, empty strings, and white space"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Null, empty strings, and white space</h2></div></div></div><p>When processing strings, you<a id="id474" class="indexterm"/> can't always guarantee validity; sometimes, strings are <a id="id475" class="indexterm"/>badly formed and don't make sense. For this reason, you'll frequently need to validate them before processing. A common way to validate them initially is to see whether a string is null, and then (if not<a id="id476" class="indexterm"/> null) check the string's length, because<a id="id477" class="indexterm"/> if the length is <code class="literal">0</code>, then the string is empty and, therefore, invalid, even though it's not <code class="literal">null</code>.</p><p>Again, you'll probably also want to eliminate the possibility that a string consists entirely of spaces, because a string<a id="id478" class="indexterm"/> that is not <code class="literal">null</code> and features only white space characters will not, in fact, be of <code class="literal">0</code> length, even though it usually means there's nothing to process. You can validate a <a id="id479" class="indexterm"/>string for each of these states individually, but the string class in .NET offers a compound or all-in-one convenience check for you, specifically the method<a id="id480" class="indexterm"/> <code class="literal">IsNullOrWhiteSpace</code>. However, this method was introduced in .NET 4.5, and Mono does not support this version. This means a manual implementation is required for equivalent behavior, as shown in the following code sample 6-11:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 //-------------------------------------------------------------
 //Class extension to add Null or White Space functionality
 public static class StringExtensions {
<span class="strong"><strong>    public static bool IsNullOrWhitespace(this string s){</strong></span>
          return s == null || s.Trim().Length == 0;
    }
 }
 //-------------------------------------------------------------
 public class StringOps : MonoBehaviour 
 {
    //Validate string
    public bool IsValid(string MyString)
    {
          //Check for null or white space
<span class="strong"><strong>          if(MyString.IsNullOrWhitespace()) return false;</strong></span>
 
          //Now validate further
          return true;
    }
 }
 //-------------------------------------------------------------</pre></div></div><div class="section" title="String comparison"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>String comparison</h2></div></div></div><p>You'll frequently need to compare two separate strings, typically, for equality to determine whether two strings are identical. You can do this using the <code class="literal">==</code> operator such as <code class="literal">string1 == string2</code>, but for best performance, use the <code class="literal">theString.Equals</code> method. This method has<a id="id481" class="indexterm"/> several versions, all of varying computational expense. In general, you should prefer any version that contains an argument of type <code class="literal">StringComparison</code>. When the comparison type is explicitly stated, the operation will perform best, as shown in the following code sample 6-12:</p><div class="informalexample"><pre class="programlisting">   //Compare strings
   public bool IsSame(string Str1, string Str2)
   {
        //Ignore case
         return string.Equals(Str1, Str2, System.StringComparison.CurrentCultureIgnoreCase);
   }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/>Tip</h3><p>More information <a id="id482" class="indexterm"/>on the <code class="literal">String.Compare</code> method can be found online in MSDN at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx</a>.</p></div></div><p>Another method to quickly and regularly compare the same two strings for equality is to use string hashes, that<a id="id483" class="indexterm"/> is, to convert each string into a unique integer and then to compare the integers instead, as shown in the following code sample 6-13:</p><div class="informalexample"><pre class="programlisting">   //Compare strings as hash
   public bool StringHashCompare(string Str1, string Str2)
   {
          int Hash1 = Animator.StringToHash(Str1);
          int Hash2 = Animator.StringToHash(Str2);

         return Hash1 == Hash2;
   }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip42"/>Tip</h3><p>You can also <a id="id484" class="indexterm"/>use the <code class="literal">String.GetHashCode</code> function from the Mono library to retrieve a string's hash code. For more information, visit <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx</a>.</p></div></div><p>Sometimes, however, you don't want to compare for equality. Your intention might be to determine which string takes more priority alphabetically, that is, whether one string would appear before the other if they were both listed alphabetically in a dictionary. You can achieve this using the <a id="id485" class="indexterm"/>
<code class="literal">String.Compare</code> function. However, again, be sure to use a version that features a <code class="literal">StringComparison</code> type in the arguments, as shown in the following code sample 6-14. With this version, <code class="literal">-1</code> would be returned if <code class="literal">Str1</code> comes before <code class="literal">Str2</code>, <code class="literal">1</code> would be returned if <code class="literal">Str2</code> comes before <code class="literal">Str1</code>, and <code class="literal">0</code> would be returned if the two strings are equal:</p><div class="informalexample"><pre class="programlisting">   //Sort comparison
   public int StringOrder (string Str1, string Str2)
   {
          //Ignores case
          return string.Compare(Str1, Str2, 
System.StringComparison.CurrentCultureIgnoreCase);
   }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>Although <code class="literal">String.Compare</code> returns <code class="literal">0</code> to indicate that two strings are equal, never use this function for equality testing. For equality testing, use <code class="literal">String.Equals</code> or hashes, as both perform much faster than <code class="literal">String.Compare</code>.</p></div></div></div><div class="section" title="String formatting"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>String formatting</h2></div></div></div><p>If you're creating GUI elements, such as high-score HUDs, player names, cash counters, or resources indicators, you'll <a id="id486" class="indexterm"/>not only need to show literal text but also numerical values inside the strings, for example, by combing the word <code class="literal">Score:</code> with a string representation of the actual score, which will change over time depending on player performance. One way to achieve this is the <code class="literal">String.Format</code> method, as shown in the following code sample 6-15:</p><div class="informalexample"><pre class="programlisting">//Construct string from three numbers
public void BuildString(int Num1, int Num2, float Num3)
{
   string Output = string.Format("Number 1 is: {0}, Number 2 is: {1}, Number 3 is: {2}", Num1, Num2, Num3);

   Debug.Log (Output.ToString("n2"));
}</pre></div></div><div class="section" title="String looping"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>String looping</h2></div></div></div><p>So far, we've seen <code class="literal">IEnumerable</code> and <code class="literal">IEnumerator</code>. Thankfully, these interfaces apply to strings and can be used to<a id="id487" class="indexterm"/> loop or cycle through every letter in a string. This can be achieved using either the <code class="literal">IEnumerator</code> interface itself or via a <code class="literal">foreach</code> loop. Let's see both ways, as shown in the following code sample 6-16 and 6-17:</p><div class="informalexample"><pre class="programlisting">   //Sample 6-16
//Loops through string in foreach
   public void LoopLettersForEach(string Str)
   {
          //For each letter
          foreach(char C in Str)
          {
               //Print letter to console
               Debug.Log (C);
          }
   }

//Sample 6-17
   //Loop through string as iterator
   public void LoopLettersEnumerator(string Str)
   {
         //Get Enumerator
         IEnumerator StrEnum = Str.GetEnumerator();

         //Move to nextletter
         while(StrEnum.MoveNext())
        {
               Debug.Log ((char)StrEnum.Current);
        }
   }</pre></div></div><div class="section" title="Creating strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Creating strings</h2></div></div></div><p>To make your code read better, work<a id="id488" class="indexterm"/> in a cleaner way, and generally, be more consistent with .NET and the way it's intended to be used. It's a good practice to avoid initializing string variables as: <code class="literal">string MyString = "";</code>. Instead, try the following code for string declaration and assignment using <code class="literal">String.empty</code>:</p><div class="informalexample"><pre class="programlisting">string MyString = string.Empty;</pre></div></div><div class="section" title="Searching strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Searching strings</h2></div></div></div><p>If you're dealing with multiple lines of text read from a file, such as a Text Asset, you might need to find the first occurrence of a smaller string inside the larger one, for example, finding a smaller and separate word within the larger string. You can achieve this using the <a id="id489" class="indexterm"/>
<code class="literal">String.IndexOf</code> method. If a match is found, the function would return a positive integer that indicates the<a id="id490" class="indexterm"/> position in the larger string of the first character of the found word as a measured offset from the first letter. If no match is found, the function returns <code class="literal">-1</code>, as shown in the following code sample 6-18:</p><div class="informalexample"><pre class="programlisting">   //Searches string for a specified word and returns found index of first occurrence
   public int SearchString(string LargerStr, string SearchStr)
   {
          //Ignore case
          return LargerStr.IndexOf(SearchStr, System.StringComparison.CurrentCultureIgnoreCase);
   }</pre></div></div><div class="section" title="Regular expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Regular expressions</h2></div></div></div><p>Occasionally, you might need to perform more complex searches on very large strings, such as finding all words in a string beginning with a specific letter, all words starting with <code class="literal">a</code> and ending in <code class="literal">t</code>, and so on. In these cases, you would want the results available in an array if there are any. You can <a id="id491" class="indexterm"/>achieve this effectively using regular expressions (<code class="literal">Regex</code>). Regular expressions let you define a string value using a conventional and specialized syntax, specifying a search pattern. For example, the string <code class="literal">[dw]ay</code> means "find all words that end with <code class="literal">ay</code> and that also begin with either <code class="literal">d</code> or <code class="literal">w</code>. Thus, find all occurrences of either day or way". The regular expression can then be applied to a larger string to perform a search using the <code class="literal">Regex</code> class. The .NET framework provides access to regular expression searches through the <code class="literal">RegularExpressions</code> namespace, as shown in the following code sample 6-19:</p><div class="informalexample"><pre class="programlisting">01 //-------------------------------------------------------
02 using UnityEngine;
03 using System.Collections;
04 //Must include Regular Expression Namespace
05 using System.Text.RegularExpressions;
06 //-------------------------------------------------------
07 public class RGX : MonoBehaviour 
08 {
09 //Regular Expression Search Pattern
10 string search = "[dw]ay";
11 
12 //Larger string to search
13 string txt = "hello, today is a good day to do things my way";
14 
15 // Use this for initialization
16 void Start () 
17 {
18        //Perform search and get first result in m
19        Match m = Regex.Match(txt, search);
20 
21        //While m refers to a search result, loop
22        while(m.Success)
23        {
24              //Print result to console
25              Debug.Log (m.Value);
26 
27             //Get next result, if any
28             m = m.NextMatch();
29        }
30 }
31 }
32 //-------------------------------------------------------</pre></div><p>The following are the <a id="id492" class="indexterm"/>comments for code sample 6-19:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 05</strong></span>: The <code class="literal">RegularExpressions</code> namespace must be included in all source files using regular expression searches.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 09 and 13</strong></span>: The string <code class="literal">Search</code> defines the regular expression itself. The string <code class="literal">txt</code> defines the larger string to be searched by the regular expression. The string <code class="literal">Search</code> searches for all occurrences of the words, <code class="literal">day</code> and <code class="literal">way</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 19</strong></span>: The method <code class="literal">Regex.Match</code> is called to apply a regular expression search on the string <code class="literal">txt</code>. The results are stored in the local variable <code class="literal">m</code>. This variable can be iterated to scan for all results.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 25</strong></span>: The<a id="id493" class="indexterm"/> results in <code class="literal">m</code> will include three matches (not two) based on the string <code class="literal">txt</code>. These will include <span class="emphasis"><em>day</em></span> as found in to<span class="emphasis"><em>day</em></span> as well as <span class="emphasis"><em>day</em></span> and <span class="emphasis"><em>way</em></span> by themselves.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>More information<a id="id494" class="indexterm"/> on regular expressions can be found online at <a class="ulink" href="http://en.wikipedia.org/wiki/Regular_expression">http://en.wikipedia.org/wiki/Regular_expression</a>.</p></div></div></li></ul></div></div></div>
<div class="section" title="Infinite arguments"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Infinite arguments</h1></div></div></div><p>Though not technically a part of .NET or Mono, our exploration of both these libraries has touched several<a id="id495" class="indexterm"/> times on functions that accept seemingly an endless chain of arguments, such as the <code class="literal">String.Format</code> function. With <code class="literal">String.Format</code>, it's possible to plug in as many object arguments as you need for inclusion into a formatted string. In this section, I want to take a small (and very quick) diversion to show that you can code your own functions that accept and process limitless arguments; they're simple to create. Refer to the following code sample 6-20 for a function that can sum a potentially limitless array of integers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>01 public int Sum(params int[] Numbers)</strong></span>
02 {
03 int Answer = 0;
04 
<span class="strong"><strong>05 for(int i=0; i&lt;Numbers.Length; i++)</strong></span>
06         Answer += Numbers[i];
07 
08 return Answer;
09 }</pre></div><p>The following are the comments for code sample 6-20:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 01</strong></span>: To accept a potentially infinite number of arguments, use the <code class="literal">params</code> keyword and declare the argument as an array type</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 05</strong></span>: The <code class="literal">params</code> argument can be accessed like a regular array</li></ul></div></div>
<div class="section" title="Language Integrated Query"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Language Integrated Query</h1></div></div></div><p>Obviously, games<a id="id496" class="indexterm"/> work with lots of data. They work with not just strings but also with objects, databases, tables, documents, and plenty more, too many to list here. However, despite the extensiveness and variety of data, there's always a common need to filter it, viewing smaller subsets of it as is relevant to our needs at the time. For example, given a complete array (or enumerated list) of all wizard objects in the scene, we might want to restrict the results even further, viewing only wizards whose health is less than 50 percent<a id="id497" class="indexterm"/> and whose defense points are less than 5. The purpose is, perhaps, to initiate a mass flee behavior on the wizards to find a nearby potion and restore their health before resuming an attack on the player. Let's now consider the implementation of this scenario and how a technology, Linq, can help us.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>A complete Linq sample project can be found in the book's companion files (code bundle) at <code class="literal">Chapter06\Linq\</code>.</p></div></div><p>First, a very basic and sample definition of a wizard enemy class can be given, as shown in the following code sample 6-21. This class includes both the <code class="literal">Health</code> and <code class="literal">Defense</code> member variables that are critical to our behavior logic:</p><div class="informalexample"><pre class="programlisting"> //-------------------------------------------
 using UnityEngine;
 using System.Collections;
 //-------------------------------------------
 public class Enemy : MonoBehaviour 
 {
    public int Health = 100;
    public int Mana = 20;
   public int Attack = 5; 
    public int Defense = 10;
 }
 //-------------------------------------------</pre></div><p>Now, given a collection of all enemy objects in the scene, we could filter the data into a smaller array according to our criteria with the code, as shown in the following code sample 6-22.</p><p>This code effectively loops through all members, runs them through a conditional <code class="literal">if</code> statement, and then, finally adds the enemy to a results array if it passes the condition. The condition, in this case, is whether an enemy's health is less than 50 percent and their defense is less than 5:</p><div class="informalexample"><pre class="programlisting"> //Get list of enemies matching search criteria
 public void FindEnemiesOldWay()
 {
    //Get all enemies in scene
    Enemy[] Enemies = Object.FindObjectsOfType&lt;Enemy&gt;();
 
    //Filtered Enemies
    List&lt;Enemy&gt; FilteredData = new List&lt;Enemy&gt;();
 
    //Loop through enemies and check
<span class="strong"><strong>    foreach(Enemy E in Enemies)</strong></span>
    {
<span class="strong"><strong>         if(E.Health &lt;= 50 &amp;&amp; E.Defense &lt; 5)</strong></span>
         {
               //Found appropriate enemy
               <span class="strong"><strong>FilteredData.Add (E);</strong></span>
         }
    }
 
    //Now we can process filtered data
    //All items in FilteredData match search criteria
    foreach(Enemy E in FilteredData)
    {
         //Process Enemy E
         Debug.Log (E.name);
    }
 }</pre></div><p>This code works insofar as it restricts a larger data set into a smaller one on the basis of a specific criterion. However, Linq lets us <a id="id498" class="indexterm"/>achieve the same results with less code and often greater performance. Linq is a high-level and specialized language to run queries on data sets, including arrays and objects, as well as on databases and XML documents. The queries are translated automatically by Linq, under the hood, into an appropriate language for the data set used (for example, SQL for databases). The aim is to extract the results we need into a regular array.</p><p>The following code sample 6-23 demonstrates an alternative approach to the preceding code sample 6-22 using Linq:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
<span class="strong"><strong>03 using System.Collections.Generic;</strong></span>
<span class="strong"><strong>04 using System.Linq;</strong></span>
05 //-------------------------------------------------
06 public void FindEnemiesLinqWay()
07 {
08 //Get all enemies in scene
09 Enemy[] Enemies = Object.FindObjectsOfType&lt;Enemy&gt;();
10 
11 //Perform search
<span class="strong"><strong>12 Enemy[] FilteredData = (from EnemyChar in Enemies</strong></span>
<span class="strong"><strong>13         where EnemyChar.Health &lt;= 50 &amp;&amp; EnemyChar.Defense &lt; 5</strong></span>
<span class="strong"><strong>14         select EnemyChar).ToArray();</strong></span>
15 
16 //Now we can process filtered data
17 //All items in FilteredData match search criteria
18 foreach(Enemy E in FilteredData)
19 {
20       //Process Enemy E
21       Debug.Log (E.name);
22 }
23 }
24 //-------------------------------------------------</pre></div><p>The following are the<a id="id499" class="indexterm"/> comments for code sample 6-23:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 03-04</strong></span>: To use Linq, you must include the <code class="literal">System.Collections.Linq</code> namespace, and to use <code class="literal">List</code> objects, you must include the <code class="literal">System.Collections.Generic</code> namespace.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 12-14</strong></span>: The main body of Linq code occurs here. It consists of three main parts. First, we indicated the items to pick from the source data, specifically, enemy objects from the data set <code class="literal">Enemies</code>. Second, we defined the criteria to search for, specifically where <code class="literal">EnemyChar.Health &lt;= 50 &amp;&amp; EnemyChar.Defense &lt; 5</code>. Then, when the criterion is met, we selected that object to add to the results; we selected <code class="literal">EnemyChar</code>. Finally, we converted the results to an array with the <code class="literal">ToArray</code> function.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>More information on Linq can be<a id="id500" class="indexterm"/> found online in MSDN at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/bb397926.aspx">http://msdn.microsoft.com/en-gb/library/bb397926.aspx</a>.</p></div></div></div>
<div class="section" title="Linq and regular expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Linq and regular expressions</h1></div></div></div><p>Linq, of course, need not work in isolation. It can, for example, be combined with regular expressions to extract specific string patterns from a larger string that converts the matched results into a<a id="id501" class="indexterm"/> traversable array. This can be especially useful in processing comma-separated value files (CSV files), for example, where data is formatted inside a text file, each entry being separated<a id="id502" class="indexterm"/> by a comma character. Both Linq and regular expressions can be used to read each value into a unique array element very quickly and easily. For example, consider an RTS game where human names must be generated for new units. The names themselves are stored in a CSV format and are divided into two groups: male and female. On generating a character, it can be either male or female, and an appropriate name must be assigned to them from the CSV data, as shown in the following code sample 6-24:</p><div class="informalexample"><pre class="programlisting">01 //Generate female name
02 //Regular Expression Search Pattern
03 //Find all names prefixed with 'female:' but do not include the prefix in the results
04 string search = @"(?&lt;=\bfemale:)\w+\b";
05 
06 //CSV Data - names of characters
07 string CSVData = "male:john,male:tom,male:bob,female:betty,female:jessica,male:dirk";

08 
09 //Retrieve all prefixed with 'female'. Don't include prefix
10 string[] FemaleNames = (from Match m in Regex.Matches(CSVData, search)

11          select m.Groups[0].Value).ToArray();
12 
13 //Print all female names in results
14 foreach(string S in FemaleNames)
15 Debug.Log (S);
16 
17 //Now pick a random female name from collection
18 string RandomFemaleName = FemaleNames[Random.Range(0, FemaleNames.Length)];</pre></div><p>The following are the comments for code sample 6-24:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 04</strong></span>: The member variable <code class="literal">Search</code> defines a regular expression search pattern. The <code class="literal">Search</code> variable, in this case, is for all words prefixed with <code class="literal">female:</code>. More than<a id="id503" class="indexterm"/> this, however, the prefix itself should not be included in the resultant strings.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line 07</strong></span>: The member<a id="id504" class="indexterm"/> variable <code class="literal">CSVData</code> defines a complete CSV string with both male and female names that are structured in the expected format. This string essentially represents the database or data source.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lines 10-11</strong></span>: Here, Linq is used in conjunction with a regular expression search to retrieve all female names from the CSV, minus the prefixes. This list is then converted into a string array <code class="literal">FemaleNames</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>
<span class="strong"><strong>Strings and the @ symbol</strong></span>
</p><p>Notice from line 04 <a id="id505" class="indexterm"/>of the code sample 6-24 that the regular expression string is prefixed with the symbol <code class="literal">@</code>. This is a C# convention that allows<a id="id506" class="indexterm"/> you to write a string literal in a source file; this string literal can contain escape sequences (such as <code class="literal">\</code>) without breaking or invalidating the string itself.</p></div></div></li></ul></div></div>
<div class="section" title="Working with Text Data Assets"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Working with Text Data Assets</h1></div></div></div><p>Throughout all examples<a id="id507" class="indexterm"/> so far, we've considered text directly stored in string objects, but you can also work with text files in Unity. Specifically, you can load in text from external sources. Here, I will demonstrate how.</p><div class="section" title="Text Assets – static loading"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Text Assets – static loading</h2></div></div></div><p>The first method is to<a id="id508" class="indexterm"/> drag-and-drop a text file into a Unity <a id="id509" class="indexterm"/>project that imports the text asset. The file is imported as a <span class="strong"><strong>TextAssets</strong></span> type, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_06_03.jpg" alt="Text Assets – static loading"/><div class="caption"><p>Importing text files into Unity as TextAssets</p></div></div><p>You can access the file and its text data from any script file by exposing a <code class="literal">TextAsset</code> public member, as shown in the following code sample 6-25:</p><div class="informalexample"><pre class="programlisting">//--------------------------------------------------
using UnityEngine;
using System.Collections;
//--------------------------------------------------
public class TextFileAccess : MonoBehaviour 
{
   //Reference a text file
   public TextAsset TextData = null;

   // Use this for initialization
   void Start () 
   {
         //Display text in file
         Debug.Log (TextData.text);
   }
}
//--------------------------------------------------</pre></div><p>This code means <a id="id510" class="indexterm"/>you just need to drag-and-drop the <code class="literal">TextAsset</code> file <a id="id511" class="indexterm"/>onto the <span class="strong"><strong>Text Data</strong></span> slot in the Object Inspector, as shown here:</p><div class="mediaobject"><img src="graphics/0655OT_06_04.jpg" alt="Text Assets – static loading"/><div class="caption"><p>Accessing text file assets from script</p></div></div></div></div>
<div class="section" title="Text Assets &#x2013; loading from the local files"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Text Assets – loading from the local files</h1></div></div></div><p>Another method to load in text data is externally from the project, that is, from files on the local hard drive. Text Data loaded in this way is read into the project dynamically from script, not necessarily<a id="id512" class="indexterm"/> at scene startup, but whenever you<a id="id513" class="indexterm"/> execute the necessary code. This means that for longer text files that involve heavy processing, lag becomes a serious consideration. In general, therefore, it is best to prefer statically loaded Text Assets to dynamic forms. For any dynamic assets, I recommend that you load and process them at scene startup to avoid in-game lagging, as shown in the following code sample 6-26:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
<span class="strong"><strong> using System.IO;</strong></span>
 
 //Function to load text data from external file
 public static string LoadTextFromFile(string Filename)
 {
    //If file does not exist on system, then return empty string
    if(!File.Exists(Filename)) return string.Empty;
 
    //File exists, now load text from file
    return <span class="strong"><strong>File.ReadAllText(Filename);</strong></span>
 }</pre></div><p>The code sample 6-26 loads a complete text file into one string object. You might, however, prefer to<a id="id514" class="indexterm"/> process a text file line by line instead, especially if the file is a configuration file where values<a id="id515" class="indexterm"/> are specified in separate lines. For this, see the following code sample 6-27:</p><div class="informalexample"><pre class="programlisting"> //Function to load text data, line by line, into a string array
 public static string[] LoadTextAsLines(string Filename)
 {
    //If file does not exist on system, then return empty array
    if(!File.Exists(Filename)) return null; 
 
    //Get lines
    return <span class="strong"><strong>File.ReadAllLines(Filename);</strong></span>
 }</pre></div><div class="section" title="Text Assets – loading from the INI files"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Text Assets – loading from the INI files</h2></div></div></div><p>Among the many text file types, you can load a common format is the INI file. It's, perhaps, not as common with Unity games, because many developers use the <code class="literal">PlayerPreferences</code> class<a id="id516" class="indexterm"/> instead to store application settings. Even so, the INI files offer the advantage of storing application configuration data in only one place and in the same format across many different platforms. For<a id="id517" class="indexterm"/> this reason, there are strong reasons to use INI files. Refer to the code sample 6-28 for an example INI that uses a key-value pairing format:</p><div class="informalexample"><pre class="programlisting">ApplicationName=MyTestApp
Date=1st Nov 2014
Author=Alan Thorn
Engine=Unity
Build=Production</pre></div><p>An ideal data structure to load INI files is the dictionary that mirrors a key-value pair structure. For this reason, it'd be great to load an INI file into a dictionary.</p><p>However, neither Unity nor Mono offers native support for this, which means we have to code the functionality ourselves, as shown in the following code sample 6-29:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Text;
 
 //Function to read basic ini file to dictionary
 public static Dictionary&lt;string, string&gt; ReadINIFile(string Filename)
 {
    //If file does not exist on system, then return null
    if(!File.Exists(Filename)) return null;
 
    //Create new dictionary
    Dictionary&lt;string, string&gt; INIFile = new Dictionary&lt;string, string&gt;();
 
    //Create new stream reader
    using (StreamReader SR = new StreamReader(Filename))
   {
         //String for current line
         string Line;
 
         //Keep reading valid lines
         while(!string.IsNullOrEmpty(Line = SR.ReadLine()))
         {
                //Trim line of leading and trailing white space
                Line.Trim();
 
                //Split the line at key=value
                string[] Parts = Line.Split(new char[] {'='});
 
                //Now add to dictionary
                INIFile.Add(Parts[0].Trim(), Parts[1].Trim());
         }
    }
 
    //Return dictionary
    return INIFile;
 }</pre></div><p>A dictionary returned<a id="id518" class="indexterm"/> from this function will match the structure of the INI file. Therefore, values can be accessed in the form string <code class="literal">Value = MyDictionary["Key"];</code>. You can also enumerate<a id="id519" class="indexterm"/> through all key and value members of a dictionary inside a <code class="literal">foreach</code>, as shown in the following code sample 6-30:</p><div class="informalexample"><pre class="programlisting"> //Build a dictionary from an INI file
 Dictionary&lt;string,string&gt; DB = ReadINIFile(@"c:\myfile.ini");
 
 //List all entries in dictionary
 foreach(KeyValuePair&lt;string, string&gt; Entry in DB)
 {
    //Loop through each key and value pair
    Debug.Log("Key: " + Entry.Key + " Value: " + Entry.Value);
 }</pre></div></div><div class="section" title="Text Assets – loading from the CSV files"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Text Assets – loading from the CSV files</h2></div></div></div><p>Earlier in this<a id="id520" class="indexterm"/> chapter, we saw how to process a CSV file that features character names, both male and female. Let's now<a id="id521" class="indexterm"/> see some source code to load CSV from a file on disk into an array of strings, with each string separated by a comma, as shown in the following code sample 6-31:</p><div class="informalexample"><pre class="programlisting"> //Function to load a string array from a CSV file
 public static string[] LoadFromCSV(string Filename)
 {
    //If file does not exist on system, then return null
    if(!File.Exists(Filename)) return null;
 
    //Get all text
    string AllText = File.ReadAllText(Filename);
 
    //Return string array
    return AllText.Split(new char[] {','});
 }</pre></div></div><div class="section" title="Text Assets – loading from the Web"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Text Assets – loading from the Web</h2></div></div></div><p>If you're making multiplayer games and need to access player or game data across the Web, if you need to<a id="id522" class="indexterm"/> verify passwords with hashes online, or if you need<a id="id523" class="indexterm"/> to access a web page to process its elements, then you will need the <code class="literal">WWW</code> class to retrieve text data online, as shown in the following code sample 6-32:</p><div class="informalexample"><pre class="programlisting"> //Gets text from the web in a string
 public IEnumerator GetTextFromURL(string URL)
 {
    //Create new WWW object
<span class="strong"><strong>    WWW TXTSource = new WWW(URL);</strong></span>
 
    //Wait for data to load
    yield return TXTSource;
 
    //Now get text data
<span class="strong"><strong>    string ReturnedText = TXTSource.text;</strong></span>
 }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip47"/>Tip</h3><p>More information<a id="id524" class="indexterm"/> on the <code class="literal">WWW</code> class can be found in the<a id="id525" class="indexterm"/> online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/WWW.html">http://docs.unity3d.com/ScriptReference/WWW.html</a>.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Summary</h1></div></div></div><p>This chapter considered a wide range of applications for the Mono Framework in practical contexts. It took a three-part structure. First, we explored common data structures used in C#, including <code class="literal">List</code>, <code class="literal">Dictionary</code>, and <code class="literal">Stack</code>. From there, we moved on to investigate their common usages in storing and searching data and in organizing and processing strings. We also explored regular expressions for searching strings for patterns of data and the Linq language for filtering not only strings but all the collection-type objects available in Mono. Then, finally, we examined various methods to import text data, both internally to the project and from local files, as well as text data streamed across the Web. The next chapter moves into the world of artificial intelligence; it considers path-finding, finite state machines, line of sight, decision making, ray casting, and more.</p></div></body></html>