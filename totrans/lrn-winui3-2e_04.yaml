- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced MVVM Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning the basics of the MVVM pattern and its implementation in WinUI,
    it’s now time to build on that knowledge base to handle some more advanced techniques.
    Now, you will learn how to keep components loosely coupled and testable when adding
    new dependencies to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Few modern applications have only a single page or window. There are MVVM techniques
    that can be leveraged to navigate between pages from a `ViewModel` command without
    being coupled to the UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of **Dependency** **Injection** (**DI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging DI to expose `ViewModel` classes to WinUI views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MVVM and `x:Bind` to handle additional UI events with event handlers in
    the ViewModel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating between pages with MVVM and DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deeper understanding of the MVVM
    pattern and will know how to decouple your view models from any external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the examples in this chapter, please reference the *Technical
    requirements* section in [*Chapter 2*](B20908_02.xhtml#_idTextAnchor044), *Configuring
    the Development Environment and Creating* *the Project*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the code files for this chapter here: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting down the path of using DI in our project, we should take some
    time to understand what DI is and why it is fundamental for building modern applications.
    You will often see DI referenced with another related concept, **Inversion of
    Control** (**IoC**). Let’s discuss these two concepts by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clarify the relationship between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare you to use DI properly in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DI is used by modern developers to inject dependent objects into a class rather
    than creating instances of the objects inside the class. There are several ways
    to inject those objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method injection**: Objects are passed as parameters to a method in the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property injection**: Objects are set through properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor injection**: Objects are passed as constructor parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common method of DI is constructor injection. In this chapter, we will
    be using both property injection and constructor injection. Method injection will
    not be used because it is not common to use methods to set a single object’s value
    in .NET projects. Most developers use properties for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'IoC is the concept that a class should not be responsible for (or have knowledge
    of) the creation of its dependencies. You’re inverting control over object creation.
    This sounds a bit like DI, doesn’t it? Well, DI is one method of achieving this
    IoC in your code. There are other ways to implement IoC, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delegate**: This holds a reference to a method that can be used to create
    and return an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event**: Like a delegate, this is typically used in association with user
    input or other outside actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Locator Pattern**: This is used to inject the implementation of a
    service at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you separate the responsibilities of object creation and use, it facilitates
    code reuse and increases testability.
  prefs: []
  type: TYPE_NORMAL
- en: The classes that will be taking advantage of DI in this chapter are views and
    ViewModels. So, if we will not be creating instances of objects in those classes,
    where will they be created? Aren’t we just moving the tight coupling somewhere
    else? In a way, that is true, but the coupling will be minimized by centralizing
    it to one part of the project, the `App.xaml.cs` file. If you remember from the
    previous chapter, the `App` class is where we handle application-wide actions
    and data.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a `App` class to manage the application’s dependencies.
    A DI container is responsible for creating and maintaining the lifetime of the
    objects it manages. The object’s lifetime in the container is usually either *per
    instance* (each object request returns a new instance of the object) or a *singleton*
    (every object request returns the same instance of the object). The container
    is configured in the `App` class, and it makes instances available to other classes
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 6 and later, DI is now a part of .NET itself. We will leverage the **host
    builder** configuration in .NET to register our application’s dependencies and
    resolve them in the classes where they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of other DI implementations that can be leveraged from MVVM
    frameworks. If you would like to explore some of them, here are their respective
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity**: This DI implementation supports all types of .NET applications and
    has a full-featured IOC container ([http://unitycontainer.org/articles/introduction.html)](http://unitycontainer.org/articles/introduction.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**DryIoc**: This small, lightweight IOC container supports .NET Standard 2.0
    and .NET 4.5 and later applications ([https://github.com/dadhi/DryIoc](https://github.com/dadhi/DryIoc))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prism**: This MVVM framework does not support WinUI 3, but developers can
    still leverage the DI capabilities ([https://prismlibrary.com/docs/dependency-injection/index.html](https://prismlibrary.com/docs/dependency-injection/index.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These concepts will be easier to understand as we implement the code in our
    application. Now, it’s time to see DI and DI containers in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Using DI with ViewModel classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the popular MVVM frameworks today include a DI container to manage
    dependencies. Because .NET now includes its own DI container, we will use that
    one. The .NET team has incorporated the DI container that used to be bundled with
    **ASP.NET Core**. It’s both lightweight and easy to use. Luckily, this container
    is now available to all types of .NET projects via a **NuGet** package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project from the previous chapter or use the project in the `Start`
    folder in the GitHub repository for this chapter. In the `MyMediaCollection` project,
    open `Microsoft.Extensions.Hosting`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Microsoft’s DI NuGet package](img/B20908_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Microsoft’s DI NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: Select the package and install the latest stable version. After the installation
    completes, close the `App.xaml.cs`. We will make a few changes here to start using
    the DI container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DI container implements DI through interfaces called `IHostBuilder` and
    `IServiceCollection`. As the names imply, they are intended to create a collection
    of services for the application through a shared host. However, we can add any
    type of class to the container. Its use is not restricted to services. `IServiceCollection`
    builds the container, implementing the `IServiceProvider` interface. In the following
    steps, you will add support for DI to the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first thing you should do is add a `public` property to the `App` class
    that makes the host container available to the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, `get` is public, but the property has a `private set` accessor. This
    restricts the creation of the container to the `App` class. Don’t forget to add
    the required `using` statements to the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create a new method that initializes the container, sets
    it to the `public` property, and adds our first dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the new `RegisterComponents` method, we are creating `HostContainer` and
    its service collection, registering `MainViewModel` as a `Build` method to create
    and return the DI container. Although it’s not strictly required, when adding
    multiple types to the container, it’s a good practice to add dependent objects
    to the service collection first. We’ll be adding more items to the container soon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you will call `RegisterComponents` before creating the instance of
    `MainWindow` in the `App.OnLaunched` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all the code needed to create and expose the DI container to the application.
    Now that we are delegating the creation of `MainViewModel` to the container, you
    can remove the property that exposes a static instance of `MainViewModel` from
    the `App` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the ViewModel controlled by the container is simple. Go ahead and open
    `MainWindow.xaml.cs` and update the `ViewModel` property to remove the initialization.
    Then, set the value of the `ViewModel` property using `HostContainer.Services.GetService`
    from the `App` class before the call to `InitializeComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you build and run the application now, it will work just as it did before.
    However, now our `MainViewModel` instance will be registered in the `App` class
    and managed by the container. As new models, view models, services, and other
    dependencies are added to the project, they can be added to the `HostContainer`
    in the `RegisterComponents` method.
  prefs: []
  type: TYPE_NORMAL
- en: We will be adding page navigation to the app later in this chapter. First, let’s
    discuss the **event-to-command** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging x:Bind with events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we bound `ViewModel` commands to the `Command` properties
    of the `Command` property? For this scenario, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a custom behavior such as `EventToCommandBehavior` in the .NET MAUI Community
    Toolkit. This allows you to wire up a command in the ViewModel to any event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `x:Bind` in the view to bind directly to an event handler on the view model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this application, we will use `x:Bind`. This option will provide compile-time
    type checking and added performance. If you want to learn more about the .NET
    MAUI Community Toolkit, you can read the documentation on Microsoft Learn: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to provide users of the **My Media Collection** application with the
    option to double-click (or double-tap) a row on the list to view or edit its details.
    The new **Item Details** window will be added in the next section. Until then,
    double-clicking an item will invoke the same code as the **Add Item** button,
    as this will become the **Add/Edit Item** button later:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding an `ItemRowDoubleTapped` event handler to the `MainViewModel`
    class that calls the existing `AddEdit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, bind the `ListView.DoubleTapped` event to the ViewModel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ListView.ItemTemplate>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <DataTemplate x:DataType="model:MediaItem">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Grid IsHitTestVisible="False">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Grid>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </DataTemplate>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </ListView.ItemTemplate>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now when you run the application, you can either click the **Add Item** button
    or double-click a row in the list to add new items. In the next section, you will
    update the **Add Item** button to be an **Add/Edit** **Item** button.
  prefs: []
  type: TYPE_NORMAL
- en: Page navigation with MVVM and DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until this point, the application has consisted of only a single window. Now
    it’s time to implement page navigation by adding a host `Frame` and two `Page`
    objects so we can handle adding new items or editing existing items. The new `Page`
    will be accessible from the **Add/Edit Item** button or by double-clicking on
    an item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating MainWindow to MainPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re familiar with UWP app development, you should already understand
    page navigation. In UWP, the application consists of only a single window. At
    the root of the window, there is a `Frame` object, which hosts pages and handles
    the navigation between them. To achieve the same result in a desktop WinUI 3 app,
    we will create a new `MainPage`, move all the XAML content from `MainWindow` into
    `MainPage`, and update the `App` class to create a `Frame` as the new content
    of `MainWindow`. Then we can display the same contents by navigating to `MainPage`.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add a new folder to the project named `Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Views** folder and select **Add** | **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `MainPage` and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainWindow.xaml` and cut the entire XAML contents of the `Window`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainPage.xaml` and paste the XAML from `MainWindow`, replacing the empty
    `Grid` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will also need to cut and paste the `xmlns` declaration for `model` from
    `MainWindow` to `MainPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `MainWindow.xaml.cs`, remove the `ViewModel` variable and the constructor
    code that fetches it from the `HostContainer`. Put this same code into `MainPage.xaml.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open `App.xaml.cs` and add some code inside `OnLaunched` to create a
    `rootFrame`, add it to the `MainWindow`, and navigate to `MainPage` before activating
    the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve also added an event handler to handle navigation failures for the `Frame`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure to add the necessary `using` statements to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the app now, it should look and behave just as it did before, but
    now the controls are nested within a `Page` and a `Frame` on the `Window`. Let’s
    add a second page and get ready to start navigating between our list and detail
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ItemDetailsPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full `ItemDetailsPage.xaml` code can be found on GitHub ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml)).
    You can follow along with the steps in this section or review the final code on
    GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The project will not compile successfully until we have added the new ViewModel
    to the project and added it to the DI container for consumption by the view. Before
    we add the ViewModel, we need to create some services to enable navigation and
    data persistence between views.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be showing `Page` control. The `Page` will be set as the content and
    navigated to by the `Frame` we created. For more information about page navigation
    with WinUI, you can read this Microsoft Learn article: [https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk](https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add `ItemDetailsPage`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the **Views** folder in **Solution Explorer** and select **Add**
    | **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new item dialog, select `ItemDetailsPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are going to be several input controls with some common attributes on
    the page. Start by adding three styles to a `Page.Resources` section just before
    the top-level `Grid` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next step, we can assign `AttributeTitleStyle` to each `TextBlock`, `AttributeValueStyle`
    to each `TextBox`, and `AttributeComboValueStyle` to each `ComboBox`. If you need
    to add any other attributes to input labels later, you will only update `AttributeTitleStyle`
    and the attributes will automatically be applied to every `TextBlock` using that
    style.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The top-level `Grid` will contain three child `Grid` controls to partition
    the view into three areas—a header, the input controls, and the `Grid.RowDefinitions`
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The header area will contain only a `TextBlock`. You are welcome to design
    this area however you like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The input area contains a `Grid` with four `RowDefinitions` and two `ColumnDefinitions`
    for the labels and input controls for the four fields that users can currently
    edit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The item’s `Name` is a free-text entry field, while the others are `ComboBox`
    controls to allow the user to pick values from lists bound to `ItemsSource`. The
    final child element of the top-level `Grid` is a right-aligned horizontal `StackPanel`
    containing the **Save** and **Cancel** buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next stage is to add interfaces and services, so let’s work on this next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new interfaces and services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have more than a single page to manage in the application, we need
    some services to centralize the page management and abstract the details from
    the `ViewModel` code. Start by creating `Services` and `Interfaces` folders in
    the project. Each service will implement an interface. This interface will be
    used for DI and later, if you were to add unit tests to a test project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a navigation service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first service we need is a `INavigationService` interface in the `Interfaces`
    folder. The interface defines methods to get the current page name, navigate to
    a specific page, or navigate back to the previous page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a `NavigationService` class in the `Services` folder. In the class
    definition, make sure that `NavigationService` implements the `INavigationService`
    interface. The full class can be viewed on GitHub ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs)).
    Let’s discuss a few highlights.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a navigation service in MVVM is to store a collection of available
    pages in the application so that when its `NavigateTo` method is called, the service
    can find a page that matches the requested `Name` or `Type` and navigate to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection of pages will be stored in a `ConcurrentDictionary<T>` collection.
    The `ConcurrentDictionary<T>` functions like the standard `Dictionary<T>`, but
    it can automatically add locks to prevent changes to the dictionary simultaneously
    across multiple threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Configure` method will be called when you create `NavigationService` before
    adding it to the DI container. This method is not a part of the `INavigationService`
    interface and will not be available to classes that consume the service from the
    container. There is a check here to ensure views are only added to the service
    once. We check the dictionary to determine whether any pages of the same data
    type exist. If this condition is `true`, then the page has already been registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the implementations of the three navigation methods in the service.
    The two `NavigateTo` methods navigate to a specific page, with the second providing
    the ability to pass a parameter to the page. The third is `GoBack`, which does
    what you would think: it navigates to the previous page in the application. They
    wrap the `Frame` navigation calls to abstract the UI implementation from the view
    models that will be consuming this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’re ready to start using `NavigationService`, but first, let’s create a data
    service for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can jump ahead to implementing the services in the next section if you
    like. The `DataService` and `IDataService` code is available in the completed
    solution on GitHub: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data on `MainPage` of `MainViewModel`. This isn’t going to work very well
    across multiple pages. By using a data service, view models will not need to know
    how the data is created or stored.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the data will still be sample records that are not saved between sessions.
    Later, we can update the data service to save and load data from a database without
    any changes to the view models that use the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add an interface named `IDataService` to the `Interfaces`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods should look familiar to you from previous chapters, but let’s
    briefly review the purpose of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetItems`: Returns all the available media items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetItem`: Finds a media item with the provided `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddItem`: Adds a new media item to the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateItem`: Updates a media item in the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetItemTypes`: Gets the list of media item types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMedium`: Gets a `Medium` with the provided name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMediums`: These two methods either get all available mediums or any available
    for the provided `ItemType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetLocationTypes`: Gets all the available media locations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedItemId`: Persists the ID of the selected item on `MainPage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, create the `DataService` class in the `Services` folder. Make sure that
    `DataService` implements `IDataService` in the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we will only review parts of the code. You can review the entire implementation
    on GitHub ([https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs)).
    The data in `DataService` will be persisted in four lists and the `SelectedItemId`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `PopulateItems` method from `MainViewModel` and modify it to use `List<T>`
    collections and add the `Location` property assignment to each item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the three `MediaItem` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize the `_items` list and add the three `MediaItem` objects you
    just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three other methods to pre-populate the sample data: `PopulateMediums`,
    `Populate``     ItemTypes`, and `PopulateLocationTypes`. All of these are called from the `Data``     Service` constructor. These methods will be updated later to use an **SQLite**
    data store for data persistence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the `Get` method implementations are very straightforward. The `GetMediums(ItemType
    itemType)` method uses `Medium` objects for the selected `ItemType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with LINQ expressions, Microsoft has some good documentation
    on the topic: [https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/](https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddItem` and `UpdateItems` methods are also simple. They add to and update
    the `_items` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AddItem` method has some basic logic to find the highest `Id` and increment
    it by `1` to use at the new item’s `Id`. `Id` is also returned to the calling
    method in case the caller needs the information.
  prefs: []
  type: TYPE_NORMAL
- en: The services are all created. It is time to set them up when the application
    launches and consume them in the view models.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing maintainability by consuming services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before using the services in view models, open the `RegisterServices` method
    in `App.xaml.cs` and add the following code to register the new services in the
    DI container and register a new `ItemDetailsViewModel` (yet to be created). We’re
    also adding a parameter to the method to pass along to the constructor of the
    `NavigationService`. This will provide access to the `Frame` for page navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Both `INavigationService` and `IDataService` are registered as **singletons**.
    This means that there will be only a single instance of each stored in the container.
    Any state held in these services is shared across all classes that consume them.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that when we’re registering `INavigationService`, we are passing
    the instance we already created to the constructor. This is a feature of Microsoft’s
    DI container and most other DI containers. It allows for initialization and configuration
    of instances before they’re added to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make a few changes to `MainViewModel` to consume `IDataService`
    and `INavigationService`, update the `PopulateData` method, and navigate to `ItemDetailsPage`
    when `AddEdit()` is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding properties to `MainViewModel` for `INavigationService` and
    `IDataService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don’t forget to add a `using` statement for `MyMediaCollection.Interfaces`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update the constructor to receive and store the services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait, we’ve added two parameters to the constructor but haven’t changed the
    code that adds them to the DI container. How does that work? Well, the container
    is smart enough to pass them because both of those interfaces are also registered.
    Pretty cool!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update `PopulateData` to get the data the view model needs from `_dataService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to add the `AllMediums` string constant with a value of `"All"` to
    the `mediums` collection because it’s not part of the persisted data. It’s only
    needed for the UI filter. Be sure to add this constant definition to `MainViewModel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, when the hidden `AddEditCommand` calls the `AddEdit` method, instead
    of adding hardcoded items to the collection, you will pass `selectedItemId` as
    a parameter when navigating to `ItemDetailsPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it for `MainViewModel`. Now let’s work on the `ItemDetailsPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling parameters in ItemDetailsPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accept a parameter passed from another page during navigation, you must
    override the `OnNavigatedTo` method in `ItemDetailsPage.xaml.cs`. The `NavigationEventArgs`
    parameter contains a property named `Parameter`. In our case, we passed an `int`
    containing the selected item’s `Id`. Cast this `Parameter` property to `int` and
    pass it to a method on the `ViewModel` named `InitializeItemDetailData`, which
    will be created in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll add the final piece of the puzzle, the `ItemDetailsViewModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ItemDetailsViewModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add or edit items in the application, you will need a view model to bind
    to `ItemDetails``     Page`. Right-click the `ViewModels` folder in `ItemDetailsViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: The class will inherit from `ObservableObject` like `MainViewModel`. The full
    class can be found on GitHub at [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs).
    Let’s review some of the important members of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor receives the two services from the container and calls `PopulateLists`
    to populate `ComboBox` data from the data service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A `public` method named `InitializeItemDetailData` will accept the `itemId`
    parameter passed by `ItemDetailsPage.OnNavigatedTo`. It will call methods to populate
    the lists and initializes an `IsDirty` flag to enable or disable the `SaveCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PopulateExistingItem` method will add existing item data if the page is
    in edit mode, and `PopulateLists`, called from the constructor, fills the drop-down
    data to be bound to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this view model’s properties are straightforward, but `SelectedItemType`
    has some logic to repopulate the list of `Mediums` based on the `ItemType` selected.
    For instance, if you are adding a book to the collection, there’s no need to see
    the DVD or CD mediums in the selection list. We’ll handle this custom logic in
    `OnSelectedItemTypeChanged`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let’s look at the code that `SaveCommand` and `CancelCommand` will
    invoke to save and navigate back to `MainPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The other change needed before you run the application to test the new page
    is to consume `ItemDetailsViewModel` from `ItemDetailsPage.xaml.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the app and try to add or edit an item—you should see the new page.
    If you are editing, you should also see the existing item data in the controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The Item Details page with edited data populated](img/B20908_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The Item Details page with edited data populated
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now when you save, you should see any added records or edited data appear
    on `MainPage`. Things are really starting to take shape in our project. Let’s
    review what we have learned about WinUI and MVVM in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned quite a bit about MVVM and WinUI page navigation in this chapter.
    You have learned how to create and consume services in your application, and you
    have leveraged DI and DI containers to keep your view models and services loosely
    coupled. Understanding and using DI is key to building testable, maintainable
    code. At this point, you should have enough knowledge to create a robust, testable
    WinUI application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about more of the available controls and
    libraries in WinUI 3.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do DI and IoC relate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you navigate to the previous page in a WinUI application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What object do we use to manage dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Microsoft’s DI container, what method can you call to get an object instance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the framework that queries objects in memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What event argument property can you access to get a parameter passed to another
    `Page`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which dictionary type is safe to use across threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
