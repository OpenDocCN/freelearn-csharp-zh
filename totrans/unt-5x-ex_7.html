<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Project D – Intelligent Enemies</h1></div></div></div><p>In this chapter, we'll start the final project, which will cover extensive ground. This project, unlike the previous three, will not be a fully completed game with a clear win and loss condition but will be a functional prototype and <em>proof of concept</em> style project that highlights a range of important coding techniques and ideas prevalent in games. Specifically, we'll create a world with a terrain, first-person character, and some enemies. The enemies will <a id="id415" class="indexterm"/>have <strong>Artificial Intelligence</strong> (<strong>AI</strong>), patrol the level searching for the player, and attack the player when found. In this chapter, we will explore the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to build levels and landscapes with the Terrain tools</li><li class="listitem" style="list-style-type: disc">How to generate and use navigation meshes</li><li class="listitem" style="list-style-type: disc">How to prepare for Artificial Intelligence development<div><div><h3 class="title"><a id="note24"/>Note</h3><p>The starting project and assets can be found in the book companion files in the <code class="literal">Chapter07/Start</code> folder. You can start here and follow along with this chapter if you do not have your own project already.</p></div></div></li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>An overview of the project</h1></div></div></div><p>The project to be <a id="id416" class="indexterm"/>created is a first-person prototype in which the player character can wander and explore a terrain environment. The terrain features hills, valleys, and varied terrain elements. Among the terrain will be scattered several enemy characters (NPCs). Each character features artificial intelligence. Specifically, each character will wander around (Patrol mode) searching for the player. If the player is sighted, the NPC will chase and pursue the player (Chase mode). If, during the chase, the enemy loses sight of the player, they will return to patrolling. On the other hand, if the enemy approaches the player during the chase, the enemy will attack the player (Attack mode). In short, therefore, the AI features three main states: Patrol, Chase, and Attack. This, in short, constitutes the enemy AI and represents the main challenge for the player on this project. See <em>Figure 7.1</em> for the completed project:</p><div><img src="img/B05118_07_01.jpg" alt="An overview of the project"/><div><p>Figure 7.1: Building a world of intelligent NPCs</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Getting started</h1></div></div></div><p>To get started from the <a id="id417" class="indexterm"/>beginning, create a new project. The details on this are covered amply in all previous chapters. Throughout this project, we'll be using three main asset packages included with Unity. Specifically, these are Characters, Effects, and Environment. These can be imported via the application menu, through <strong>Assets</strong> | <strong>Import Packages</strong>. See <em>Figure 7.2</em>:</p><div><img src="img/B05118_07_02.jpg" alt="Getting started"/><div><p>Figure 7.2: Importing asset packages</p></div></div><p>To start, we'll need to create the game world itself (the terra firma), which will be an outdoor (exterior) environment. In other words, we'll create a game world with grassy plains, hills, and <a id="id418" class="indexterm"/>mountains. Such a landscape can be made in 3D modeling software, such as 3DS Max, Maya, or Blender, and then imported to Unity. However, Unity features native terrain design tools that, though limited in important ways (as we'll see), are still powerful and versatile. To create a new terrain, navigate to <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Terrain</strong> from the application menu. See <em>Figure 7.3</em>:</p><div><img src="img/B05118_07_03.jpg" alt="Getting started"/><div><p>Figure 7.3: Creating a new terrain</p></div></div><p>Once created, a terrain object is added to the scene at the world origin (0,0,0). It may not immediately appear in the <a id="id419" class="indexterm"/>viewport due to its size. To address this, select the terrain in the <strong>Hierarchy</strong> panel and then press <em>F</em> on the keyboard to center it in the view. It initially looks like a flat plane object but, unlike planes, it can be reshaped and sculpted, as we'll see soon. <em>See Figure 7.4</em>:</p><div><img src="img/B05118_07_04.jpg" alt="Getting started"/><div><p>Figure 7.4: A terrain is added to the scene</p></div></div><p>Before sculpting and shaping the terrain, you should first set some initial topological settings from the <strong>Object Inspector</strong> in order to ensure that terrain topology is appropriate and sized to support the <a id="id420" class="indexterm"/>kind of terrain you need. To do this, select the terrain in the viewport, and then click on the cog icon from the <strong>Object Inspector</strong> to display the terrain settings. See <em>Figure 7.5</em>:</p><div><img src="img/B05118_07_05.jpg" alt="Getting started"/><div><p>Figure 7.5: Viewing and editing the terrain settings</p></div></div><p>By default, the terrain is too large for most purposes (500 x 500 meters). Let's shrink this to 256 x 256, or even smaller, if you prefer! Simply enter <code class="literal">256</code> in the <strong>Width</strong> and <strong>Length</strong> fields. The <strong>Height</strong> field represents the maximum height that any terrain peak or mountain can possibly reach. For optimization reasons, the terrain should be no larger than needed, as terrain <a id="id421" class="indexterm"/>objects are highly tessellated <a id="id422" class="indexterm"/>and performance-intensive. See <em>Figure 7.6</em>. Be sure to set the terrain dimensions before sculpting as resizing afterward can invalidate or erase sculpting work.</p><div><img src="img/B05118_07_06.jpg" alt="Getting started"/><div><p>Figure 7.6: Setting terrain resolution in width and length</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Terrain construction</h1></div></div></div><p>Now let's <a id="id423" class="indexterm"/>start sculpting the terrain. With the terrain object selected, click the leftmost palette icon from the <strong>Object Inspector</strong> (the Raise/Lower terrain tool), available from the Terrain component. This lets you select brush shapes to paint terrain details. Select a soft, round brush and use a large brush size (using the <strong>Brush Size</strong> slider), along with the <strong>Opacity</strong> setting to set brush strength. Click and drag over the terrain to paint landscape details. Create some hills and mountains for the landscape. See <em>Figure 7.7</em>. Remember, you can hold down the <em>Shift</em> key while clicking to reverse (or lower) the terrain painting, if needed.</p><div><img src="img/B05118_07_07.jpg" alt="Terrain construction"/><div><p>Figure 7.7: Viewing and editing the terrain settings</p></div></div><p>If the terrain appears too rough to be natural, you can easily smooth out details by switching to the <strong>Smooth Height</strong> tool. To do this, click on the third button in the <strong>Terrain</strong> component. See <em>Figure 7.8</em>. When you select this tool, you can choose the <strong>Brush Shape</strong>, <strong>Brush Size</strong>, and <a id="id424" class="indexterm"/>
<strong>Opacity</strong> as before, but clicking over the terrain will smooth out variations in terrain height.</p><div><img src="img/B05118_07_08.jpg" alt="Terrain construction"/><div><p>Figure 7.8: Accessing the Smooth Height tool</p></div></div><p>Now that the terrain is sculpted, shaped, and smooth as needed, we're ready to start painting it. As it stands, the terrain is grey, dull, and under-defined. It has no clear texture or <em>look</em>, such as grass or rock. We'll fix this using the <strong>Paint Texture</strong> tool. To access this, click on the <strong>Paint Texture</strong> button (fourth button) in the <strong>Terrain</strong> component from the <strong>Object Inspector</strong>. When you do this for the first time, you'll need to load in and prepare a set of textures for <a id="id425" class="indexterm"/>the painting. See <em>Figure 7.9</em>:</p><div><img src="img/B05118_07_09.jpg" alt="Terrain construction"/><div><p>Figure 7.9: Preparing textures for terrain painting</p></div></div><p>Click on the <strong>Edit Textures</strong> button, and then select <strong>Add Texture…</strong> from the context menu that appears. Afterward, a texture configuration dialog appears, allowing you to add new textures to a palette. See <em>Figure 7.10</em>:</p><div><img src="img/B05118_07_10.jpg" alt="Terrain construction"/><div><p>Figure 7.10: Adding textures to the Texture Paint palette</p></div></div><p>With the <strong>Texture Selection</strong> dialog open and ready to load our first texture, use the <strong>Project</strong> panel to find the native terrain textures included with the Unity Environment asset package. These can be found in the <strong>Standard Assets</strong> | <strong>Environment</strong> | <strong>TerrainAssets</strong> | <strong>SurfaceTextures</strong> folder. For this example, I'll select a grassy texture. This texture will be used as a base texture to flood-fill the terrain. Click and drag the grass texture from the <a id="id426" class="indexterm"/>
<strong>Project</strong> panel to the Albedo slot of the <strong>Texture Selection</strong> dialog. The normal channel can be left empty. See <em>Figure 7.11</em>:</p><div><img src="img/B05118_07_11.jpg" alt="Terrain construction"/><div><p>Figure 7.11: Selecting a base texture</p></div></div><p>After adding the first texture to the <strong>Texture Selection</strong> dialog, be sure to set the texture size. This refers to the size (in meters) that a single tile of the texture should cover. Smaller values decrease texture tiling but make each tile seem larger. Larger values increase texture tiling but each tile seems smaller. Getting the tiling values correct is a process of trial and error—tweaking values until it looks correct on the terrain. For this example, I've used the values 75 x 75. Then, click on the <strong>Add</strong> button. See <em>Figure 7.12</em>:</p><div><img src="img/B05118_07_12.jpg" alt="Terrain construction"/><div><p>Figure 7.12: Setting texture tile Size</p></div></div><p>After clicking on the <strong>Add</strong> button, the base texture will be tiled across the terrain. From a distance, the <a id="id427" class="indexterm"/>tiling may look obvious and unpleasant in the scene viewport. You may be tempted, on the basis of this, to adjust the tiling settings. However, from a first-person perspective, the terrain will look very different. For this reason, use a First-person Controller prefab (from the native assets) to preview the terrain in first-person mode, seeing how texture tiling appears at ground-level.</p><div><img src="img/B05118_07_13.jpg" alt="Terrain construction"/><div><p>Figure 7.13: Previewing texture tiling on a terrain</p></div></div><p>If you need to edit the existing texture tiling, simply select the texture thumbnail from the <strong>Textures</strong> palette in the <strong>Terrain</strong> component of the <strong>Object Inspector</strong>, and then choose the <strong>Edit Textures</strong> button. Refer to the preceding <em>Figure 7.10</em>.</p><p>At this stage, the terrain object features a grass texture, tiled seamlessly across the surface, which is the base texture. While this looks acceptable, it'd be great to include greater texture variety in the terrain, including some grassy, rocky, and maybe even desert style terrain. This is achieved by adding more textures via the <strong>Terrain Selection</strong> dialog. Just click on the <strong>Edit Textures</strong> button, and then choose <strong>Add Texture</strong> from the context menu. Then, drag and drop a new and different texture to the Albedo slot of the texture selection dialog, and finally repeat this process to add as many textures as needed. On closing the <a id="id428" class="indexterm"/>dialog, all added textures will appear in the <strong>Textures Palette</strong> from the <strong>Object Inspector</strong>. See <em>Figure 7.14</em>:</p><div><img src="img/B05118_07_14.jpg" alt="Terrain construction"/><div><p>Figure 7.14: Adding textures to the Texture Palette</p></div></div><p>The active texture assigned to the painter brush is highlighted with a blue border in the <strong>Inspector</strong>. You can click on a texture thumbnail to select a different texture. When you do this, the selected texture is assigned to the painter brush and can be applied to the terrain just by clicking on it. Clicking and dragging on the terrain will paint the texture to the terrain. You can also use the <strong>Brush Shape</strong>, <strong>Brush Size</strong>, <strong>Opacity</strong>, and <strong>Target Strength</strong> values to control how strongly the texture is applied and how it is blended into the terrain beneath. See <em>Figure 7.15</em>:</p><div><img src="img/B05118_07_15.jpg" alt="Terrain construction"/><div><p>Figure 7.15: Layered painting and blended textures</p></div></div><p>Now, go ahead and complete terrain painting, creating a look and feel that you like. Once completed, select <a id="id429" class="indexterm"/>the scene <strong>Directional Light</strong> from the <strong>Hierarchy</strong> panel and change its rotation to position the sun wherever it looks good. As an aside, notice that you can control a complete day and night cycle (in terms of lighting and appearance) by rotating the light a complete 360 degrees. Therefore, you can create an easy day and night cycle for games just by animating a directional light using the <strong>Animation</strong> window, seen in earlier chapters. See <em>Figure 7.16</em>:</p><div><img src="img/B05118_07_16.jpg" alt="Terrain construction"/><div><p>Figure 7.16: Completed terrain</p></div></div><p>Finally, take a tour of the terrain using a first-person controller asset. Press the play icon on the toolbar <a id="id430" class="indexterm"/>and explore around the level! Congratulations, you now have a game world with a terrain included. See <em>Figure 7.17</em>:</p><div><img src="img/B05118_07_17.jpg" alt="Terrain construction"/><div><p>Figure 7.17: First-person terrain exploration</p></div></div><p>Before moving forward, let's consider the technical limitations of Unity terrains and the impact that this can potentially have for your games. Specifically, the Unity terrain is height map-based. This means that the elevation (ups and downs) of the terrain are generated internally based on grayscale pixels in an image file (the height map). When painting the terrain using the brushes from the <strong>Inspector</strong>, you are (under the hood) painting pixels onto the height map, which is used to deform the terrain. This is a clever and fascinating process, but it comes with an important limitation. Namely, a height map is a 2D topographical texture. The result is that Unity terrains are not truly 3D at a procedural level; they cannot contain caves, crevices, caverns, or any inward cutouts. The player cannot <em>go under</em> anything. Rather, it consists simply of up and down sections, none of which may <a id="id431" class="indexterm"/>have interior spaces. Now, in many cases, this won't be a problem. However, sometimes you'll need these internal spaces, and when you do, you'll want to consider alternatives to the native terrain system. Alternatives include Asset Store plugins, but also manual terrains in 3D modeling software such as 3DS Max, Maya, and Blender.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Navigation and navigation meshes</h1></div></div></div><p>The <a id="id432" class="indexterm"/>world terrain is now fully created. In reaching this stage, we must now start thinking about the main aims of our project. Specifically, the level should be an AI experiment: we want to create enemy NPC characters that can wander freely around the terrain and will chase and attack the player whenever the player enters their field of view. To achieve this, the level must be properly configured for path-finding, which is considered here.</p><p>On thinking about NPC AI and NPC movement around the level, it's clear that the terrain is bumpy and features many hills, mountains, dips, and inclines. For an NPC character to navigate this terrain successfully, many complexities are involved. For example, an NPC cannot simply travel in only straight lines from point A to point B because doing so would cause the NPC to pass through solid objects and terrain. The NPC needs to maneuver intelligently around, under, and over appropriate parts of the terrain, just as human intelligence would. This is important to create believable characters. The computational processes involved in calculating appropriate paths for NPCs is called <strong>Path-Finding</strong>, and <a id="id433" class="indexterm"/>the processes to make a character travel those paths is termed <strong>Navigation</strong>. Unity <a id="id434" class="indexterm"/>comes with path-finding and navigation features built-in, making it easy for NPCs to calculate and travel paths.</p><p>To prepare for this, a Navigation Mesh must be generated. This is a special mesh asset included in the scene, which uses non-rendered geometry to approximate the total walkable surface of a scene. This is used by the path-finding and navigation processes to move a character around. To get started with generating a navigation mesh, select <strong>Window</strong> | <strong>Navigation</strong> from the application menu. See <em>Figure 7.18</em>:</p><div><img src="img/B05118_07_18.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.18: Accessing the Navigation window</p></div></div><p>The <a id="id435" class="indexterm"/>purpose of the <strong>Navigation</strong> window is to generate a low-fidelity terrain mesh that actually approximates the level floor. For this process to work effectively, all non-movable floor meshes in the scene must be marked as <strong>Navigation Static</strong>. To do this, select the terrain in the <strong>Hierarchy</strong> panel and, from the <strong>Inspector</strong>, click on the <strong>Static</strong> drop-down and enable the <strong>Navigation Static</strong> option. See <em>Figure 7.19</em>:</p><div><img src="img/B05118_07_19.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.19: Marking non-movable floor objects as Static</p></div></div><p>Now access the <strong>Navigation</strong> window (which I typically dock into the <strong>Inspector</strong>). From here, click on the <strong>Bake</strong> tab to access the main <strong>Navigation</strong> settings. From this panel, you can control <a id="id436" class="indexterm"/>a range of settings to influence Navigation Mesh (NavMesh) generation. See <em>Figure 7.20</em>:</p><div><img src="img/B05118_07_20.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.20: The Bake contains the main settings for Navigation Mesh generation</p></div></div><p>To get started, let's just generate an initial Navigation Mesh to see how the default settings look. We can easily erase and regenerate the mesh under new settings if needed. To do this, click on the <strong>Bake</strong> button from the <strong>Inspector</strong>. When you do this, a default Navigation Mesh is generated and appears in blue above the terrain from the <strong>Scene</strong> viewport. See <em>Figure 7.21</em>:</p><div><img src="img/B05118_07_21.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.21: A default Navigation Mesh</p></div></div><p>The default navigation mesh is problematic. It should represent the entire walkable regions of the level. It is, essentially, the area to which NPCs will be restricted when they move around. You'll see from the navigation mesh in the preceding image that it's fractured and broken in many places—some areas are totally isolated and disconnected from others. This is often undesirable because it means that any NPC walking within one isolated region cannot access or move to another as there is no connection between the two areas and the NPC can only move on the navigation mesh. To fix this properly, two settings must be adjusted. First, adjust the <strong>Agent Radius</strong> setting. This controls how large an average agent (NPC) is, and it affects how close the Navigation Mesh can expand toward the surrounding mesh floor and its edges. Lower (smaller) settings allow the mesh to encroach <a id="id437" class="indexterm"/>nearer to the mesh edges, resulting in an expanded navigation mesh. Try reducing <strong>Agent Radius</strong> and then clicking on <strong>Bake</strong> again to observe the result. See <em>Figure 7.22</em>:</p><div><img src="img/B05118_07_22.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.22: Refining the mesh via Agent Radius</p></div></div><p>This improves the meshes but we still have broken or fractured areas. This is also because of the <strong>Max Slope</strong> setting, which controls how steep a surface should be (such as the incline of a mountain) before it becomes unwalkable for an NPC. Increase this setting to expand the navigation mesh further, and click on <strong>Bake</strong>:</p><div><img src="img/B05118_07_23.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.23: Increasing Max Slope to expand the navigation mesh over the terrain</p></div></div><p>Congratulations. You have now constructed a Navigation Mesh for the level. The NavMesh asset itself is stored in a folder matching the scene name. When selected in the <strong>Project</strong> <a id="id438" class="indexterm"/>panel, you can preview various read-only properties describing the Navigation Mesh, such as <strong>Height</strong> and <strong>Walkable Radius</strong> settings. See <em>Figure 7.24</em>:</p><div><img src="img/B05118_07_24.jpg" alt="Navigation and navigation meshes"/><div><p>Figure 7.24: Previewing Navigation Mesh properties from the Project panel</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Building an NPC</h1></div></div></div><p>Now we'll build <a id="id439" class="indexterm"/>an NPC character that'll display artificial intelligence. To get started, we'll use the Ethan mesh included in the Unity native <a id="id440" class="indexterm"/>companion assets. This can be found in the <strong>Project</strong> panel under the <strong>Standard Assets</strong> | <strong>Characters</strong> | <strong>ThirdPersonCharacter</strong> | <strong>Models</strong> folder. From here, drag and drop the Ethan model to the scene and position it on the terrain. We'll refine and edit this model and, eventually, create a prefab from it to represent an NPC character. See <em>Figure 7.25</em>:</p><div><img src="img/B05118_07_25.jpg" alt="Building an NPC"/><div><p>Figure 7.25: Starting an NPC character</p></div></div><p>When adding the Ethan model to the level, ensure that the blue forward vector of the character is pointing forward, facing the direction in which the character is actually looking. If the forward vector is not front-aligned, then create an empty object and align the character model to that as a child object so that the forward vector of the parent is pointing straight ahead, along the character's line of sight. That is, the blue forward vector should align with the character's eye (be looking in the same direction). This is highly important to make your character move around believably. See <em>Figure 7.26</em>:</p><div><img src="img/B05118_07_26.jpg" alt="Building an NPC"/><div><p>Figure 7.26: Forward vector (blue arrow) pointing forward at the character's feet</p></div></div><p>The NPC <a id="id441" class="indexterm"/>should navigate and walk around the terrain intelligently using the Navigation Mesh generated for the level. For this, a NavMesh <a id="id442" class="indexterm"/>agent component should be attached to the character. Select the Ethan model in the level and, from the application menu, choose <strong>Component</strong> | <strong>Navigation NavMesh Agent</strong>. The NavMesh Agent component contains both Path-Finding and Steering (Navigation) behaviors that allow a GameObject to move around a Navigation Mesh. See <em>Figure 7.27</em>:</p><div><img src="img/B05118_07_27.jpg" alt="Building an NPC"/><div><p>Figure 7.27: Attaching a NavMeshAgent component to an NPC</p></div></div><p>By default, the Navigation Mesh assigns a Cylinder Collision volume to the Agent—the object that will navigate and move around. This is not a true collider that acts with the physics system but a pseudo-collider used to determine when the character nears the edge of a navigation mesh. Select the Ethan NPC and, from the <strong>Inspector</strong> in the NavMesh Agent component, set the <strong>Height</strong> to <code class="literal">1.66</code> and <strong>Radius</strong> to <code class="literal">0.22</code>. This approximates the mesh more <a id="id443" class="indexterm"/>closely. See <em>Figure 7.28</em>:</p><div><img src="img/B05118_07_28.jpg" alt="Building an NPC"/><div><p>Figure 7.28: Sizing the Agent Collider</p></div></div><p>For test purposes, let's make the mesh move; just to see that everything is working as it should be. To do this, we'll need to make a new script. First, create a new empty object, which will act as a <em>Destination</em>, that is, a target object that the NPC should reach, wherever it is. Select <a id="id444" class="indexterm"/>
<strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu. Name it <code class="literal">Destination</code>, and then assign it a Gizmo icon to make it visible in the viewport. See <em>Figure 7.29</em>. Simply click on the cube icon at the top left of the <strong>Object Inspector</strong> with the object selected, and then choose an icon representation.</p><div><img src="img/B05118_07_29.jpg" alt="Building an NPC"/><div><p>Figure 7.29: Creating a Destination object</p></div></div><p>Next, create a new C# script file (<code class="literal">FollowDestination.cs</code>) and attach it to the NPC object in <a id="id445" class="indexterm"/>the scene. The code is included in <a id="id446" class="indexterm"/>
<em>Code Sample 7.1</em>, and comments, which is as follows:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class FollowDestination : MonoBehaviour
{
  private NavMeshAgent ThisAgent = null;
  public Transform Destination = null;

  // Use this for initialization
  void Awake () 
  {
    ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
  }
  
  // Update is called once per frame
  void Update () 
  {
    ThisAgent.SetDestination(Destination.position);
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec28"/>Code Sample 7.1</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id447" class="indexterm"/><code class="literal">FollowDestination</code> class can be attached to any object with a NavMeshAgent. This object should follow the destination object as it moves.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Destination</code> variable maintains the destination object to follow.</li></ul></div><p>Once attached to the NPC object, drag and drop the destination empty object to the <strong>Destination</strong> slot for the FollowDestination component in the <strong>Inspector</strong>. This assigns a destination <a id="id448" class="indexterm"/>for the script. See <em>Figure 7.30</em>:</p><div><img src="img/B05118_07_30.jpg" alt="Code Sample 7.1"/><div><p>Figure 7.30: Configuring a FollowDestination object</p></div></div><p>Now give the game a test run. During gameplay, move the destination object around via the <strong>Scene</strong> tab and see how the NPC responds. The NPC should continually chase the destination object. In addition, if you play the game with the <strong>Navigation</strong> window open in the <strong>Inspector</strong> and with the NPC selected in the <strong>Hierarchy</strong> panel, the <strong>Scene</strong> view will display diagnostic information and gizmos, allowing you to preview and visualize the route calculated by the NPC. See <em>Figure 7.31</em>:</p><div><img src="img/B05118_07_31.jpg" alt="Code Sample 7.1"/><div><p>Figure 7.31: Testing NPC Navigation</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Creating patrolling NPCs</h1></div></div></div><p>We now have an <a id="id449" class="indexterm"/>NPC that follows a destination object, which is valuable in itself as an exercise, but we'll need more sophisticated <a id="id450" class="indexterm"/>behavior than this. Specifically, we'll need the NPC to patrol, that is, move across multiple destinations in order via a waypoint system, moving from one destination to the next in sequence. There are multiple approaches that could be taken to achieve this. One method is through script. Through this method, we'd create an array of different waypoint objects and iterate through them on a loop such that when the NPC reaches one destination, they'll move on to the next one. Now, this approach can be very efficient and effective, but there's another method. Specifically, instead of using script, we can create an animation to move a single destination object to different waypoint locations over time, and because the NPC continually follows the destination wherever it moves, it will continually patrol.</p><p>Let's take this second approach. Start by opening the <strong>Animation</strong> window by selecting <strong>Window</strong> | <strong>Animation</strong> from the application menu. See <em>Figure 7.32</em>. Dock the <strong>Animation</strong> window into a horizontal view in the <strong>Project</strong> panel, if you prefer, for ease of viewing.</p><div><img src="img/B05118_07_32.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.32: Accessing the Animation window</p></div></div><p>Next, select the object to animate (the destination object) from the <strong>Hierarchy</strong> panel and, from the <strong>Animation</strong> window, click on the <strong>Create</strong> button. From here, you will be asked to name and save <a id="id451" class="indexterm"/>the animation. I've called the animation <code class="literal">anim_DestPatrol</code>. See <em>Figure 7.33</em>:</p><div><img src="img/B05118_07_33.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.33: Creating a new Animation</p></div></div><p>Once the animation is <a id="id452" class="indexterm"/>created you can proceed to define animation channels. For the destination object, we'll need a channel for the position field as the object should change position around the scene. Click on the <strong>Add Property</strong> button from the <strong>Animation</strong> window, and then choose <strong>Transform</strong> | <strong>Position</strong> to add a new position channel. This will automatically create starting and ending key frames in the timeline, which are identical and hold the object position. See <em>Figure 7.34</em>:</p><div><img src="img/B05118_07_34.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.34: Creating a new Animation</p></div></div><p>Now, simply click and drag the vertical, red time slider across the timeline in the <strong>Animation</strong> window, between the 0-1 range, and then change the position of the destination <a id="id453" class="indexterm"/>object in the <strong>Scene</strong> tab to a new position. When you do this, Unity records the object position for that key frame. Repeat this process across the timeline, moving the destination object to different positions each time, and this creates a complete patrol animation. See <em>Figure 7.35</em>:</p><div><img src="img/B05118_07_35.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.35: Building a Patrol Animation..</p></div></div><p>Play the animation <a id="id454" class="indexterm"/>back by pressing play from either the <strong>Animation</strong> window or via the toolbar. By default, the animation will probably play back too fast (that's an easy fix, as we'll see), but notice also that, as expected, the destination object is <em>tweened</em>. That is, the Unity Animation interpolates between the key frames in the timeline, causing the destination object to slide or move smoothly between waypoints. For animation like this, however, we just want the destination to teleport or snap between waypoints immediately without any transition. To achieve this, we need to adjust the interpolation mode of the animation curves. Click on the <strong>Curves</strong> button at the bottom left corner of the <strong>Animation</strong> window. By default, the <strong>Animation</strong> <a id="id455" class="indexterm"/>window is in the <strong>DopeSheet</strong> mode, allowing us to see key frames easily and reposition them. The Curve mode, however, lets us adjust the interpolation between key frames. See <em>Figure 7.36</em>:</p><div><img src="img/B05118_07_36.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.36: Accessing Animation Curves</p></div></div><p>Now, box-select (click and drag a selection box) across all key frames in the graph view to select them <a id="id456" class="indexterm"/>all. Then, right-click to display the key frame context menu and, from the menu, choose <strong>Right Tangent</strong> | <strong>Constant</strong> to change all handles to a flat constant shape, meaning all key frames retain their values over the destination object until the next key frame only. See <em>Figure 7.37</em>:</p><div><img src="img/B05118_07_37.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.37: Changing Key Frame handles for interpolation</p></div></div><p>When the <strong>Constant</strong> option is chosen from the menu, the curves between key frames will look very <a id="id457" class="indexterm"/>different in the graph—a straight line joining them. See <em>Figure 7.38</em>:</p><div><img src="img/B05118_07_38.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.38: Constant interpolation</p></div></div><p>Now test this by pressing play on the toolbar. When you do this, the Destination should jump between waypoints as the animation progresses, and the NPC will continually move and travel towards the <a id="id458" class="indexterm"/>destination. Due to the default speed of the animation, the NPC may seem confused or crazed as he is torn between rapidly changing destinations. To fix this, select the Destination object in the <strong>Hierarchy</strong> panel and, from the <strong>Object Inspector</strong>, double-click on the <strong>Controller</strong> field of the Animator component to open the animator graph attached to the object, which controls when specific animations should play. See <em>Figure 7.39</em>:</p><div><img src="img/B05118_07_39.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.39: Accessing the Animator asset</p></div></div><p>You can also show the <strong>Animator</strong> window manually by choosing <strong>Window</strong> | <strong>Animator</strong> from the application menu. In the <strong>Animator</strong> window, the default node is highlighted in orange. This <a id="id459" class="indexterm"/>node (animation) will play when the object is first activated in the level, which is normally on level startup. See <em>Figure 7.40</em>:</p><div><img src="img/B05118_07_40.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.40: The orange DestPatrol animation is the default in the Animator window</p></div></div><p>Select the <strong>DestPatrol</strong> node in the graph and reduce its <strong>Speed</strong> from the <strong>Object Inspector</strong>. In my case, I've used a <a id="id460" class="indexterm"/>value of <code class="literal">0.2</code>, which works <a id="id461" class="indexterm"/>well. Once the speed is changed, replay your game to observe the effect. See <em>Figure 7.41</em>:</p><div><img src="img/B05118_07_41.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.41: Reducing animation speed</p></div></div><p>On pressing play, the NPC should now move between destinations at a believable speed, moving from one waypoint to the next. If the NPC moves too fast or too slow between waypoints, increase or decrease the animation speed further to get the result you need. Congratulations! You <a id="id462" class="indexterm"/>now have a complete, animated waypoint system. See <em>Figure 7.42</em>:</p><div><img src="img/B05118_07_42.jpg" alt="Creating patrolling NPCs"/><div><p>Figure 7.42: Waypoint system in action</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Summary</h1></div></div></div><p>Great work! We've now completed the first part of the AI project: building a terrain, generating a navigation mesh, and creating a basic waypoint system in which the character can move between destinations. This is a good beginning to simulate intelligence, but there is a lot more code to work on to achieve the intended effect. We'll be focusing on that in the next and final chapter.</p></div></body></html>