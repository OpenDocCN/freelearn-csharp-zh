<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer083">
<h1 id="_idParaDest-174"><em class="italic"><a id="_idTextAnchor173"/>Chapter 11</em>: Canceling Asynchronous Work</h1>
<p>In the previous chapters, we’ve looked at a few examples of how to cancel threads and tasks. This chapter will explore more of the methods available to cancel concurrent and parallel work with C# and .NET. The methods in this chapter will provide alternative ways to cancel background operations using callbacks, polling, and wait handles. You will gain a deeper<a id="_idIndexMarker564"/> understanding of how to safely cancel asynchronous work with a variety of methods using some practical scenarios.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Canceling managed threads</li>
<li>Canceling parallel work</li>
<li>Discovering patterns for thread cancellation</li>
<li>Handling multiple cancelation sources</li>
</ul>
<p>By the end of this chapter, you will understand how to cancel different types of asynchronous and parallel tasks.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.2 or later.</li>
<li>.NET 6.</li>
<li>To complete any WinForms or WPF samples, you will need to install the .NET desktop development workload for Visual Studio. These projects will only run on Windows.</li>
</ul>
<p>All the code examples for this chapter can be found on GitHub at<span class="superscript"> </span><a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11</a>.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Canceling managed threads</h1>
<p>Canceling <a id="_idIndexMarker565"/>asynchronous work in .NET is based on the use of a <strong class="bold">cancellation token</strong>. A <a id="_idIndexMarker566"/>token is a simple object that is used to signal that a cancellation request has been made to another thread. The <strong class="source-inline">CancellationTokenSource</strong> object manages these requests and contains a token. If you want to cancel several operations with the same trigger, the same token should be provided to all of the threads to be canceled.</p>
<p>A <strong class="source-inline">CancellationTokenSource</strong> instance has a <strong class="source-inline">Token</strong> property to access the <strong class="source-inline">CancellationToken</strong> property and pass it to one or more asynchronous operations. The request to cancel can only be made from the <strong class="source-inline">CancellationTokenSource</strong> object. The <strong class="source-inline">CancellationToken</strong> property provided to the other operations receives the signal to cancel but cannot initiate a cancellation.</p>
<p><strong class="source-inline">CancellationTokenSource</strong> implements the <strong class="source-inline">IDisposable</strong> interface, so be sure to call <strong class="source-inline">Dispose</strong> when you are freeing your managed resources. A <strong class="source-inline">using</strong> statement or block to automatically dispose of the token source would be preferred if it is practical for your workflow.</p>
<p>It is important to understand that cancellation is not forced on the listening code. The asynchronous code that receives a cancellation request must determine whether it can currently cancel its work. It might decide to immediately cancel, cancel after finishing some intermediate tasks, or finish its work and ignore the request. There can be valid reasons why a routine will ignore a request to cancel. It is possible that the work is almost complete or that canceling in the current state will cause some data corruption. The decision to cancel must be mutual between the requestor and the listener.</p>
<p>Let’s look at an example of how to cooperatively cancel some work being processed on a background thread on the <strong class="source-inline">ThreadPool</strong> thread:</p>
<ol>
<li>In Visual Studio, create a new .NET 6 console application named <strong class="source-inline">CancelThreadsConsoleApp.</strong></li>
<li>Add a new class named <strong class="source-inline">ManagedThreadsExample</strong>.</li>
<li>Create a method named <strong class="source-inline">ProcessText</strong> in the <strong class="source-inline">ManagedThreadsExample</strong> class:<p class="source-code">public static void ProcessText(object? cancelToken)</p><p class="source-code">{</p><p class="source-code">    var token = cancelToken as CancellationToken?;</p><p class="source-code">    string text = "";</p><p class="source-code">    for (int x = 0; x &lt; 75000; x++)</p><p class="source-code">    {</p><p class="source-code">        if (token != null &amp;&amp; token.Value</p><p class="source-code">            .IsCancellationRequested)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine($"Cancellation request </p><p class="source-code">                received. String value: {text}");</p><p class="source-code">            break;</p><p class="source-code">        }</p><p class="source-code">        text += x + " ";</p><p class="source-code">        Thread.Sleep(500);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>This <a id="_idIndexMarker567"/>method appends the value of the iterator variable, <strong class="source-inline">x</strong>, to the <strong class="source-inline">string</strong> variable of <strong class="source-inline">text</strong> until a cancellation request is received. There is a <strong class="source-inline">Thread.Sleep(500)</strong> statement to allow the calling method some time to cancel the operation.</p>
<ol>
<li value="4">Next, create a method named <strong class="source-inline">CancelThread</strong>, in <strong class="source-inline">Program.cs</strong>:<p class="source-code">private static void CancelThread()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    Console.WriteLine("Starting operation.");</p><p class="source-code">    ThreadPool.QueueUserWorkItem(new </p><p class="source-code">        WaitCallback(ManagedThreadsExample</p><p class="source-code">            .ProcessText), tokenSource.Token);</p><p class="source-code">    Thread.Sleep(5000);</p><p class="source-code">    Console.WriteLine("Requesting cancellation.");</p><p class="source-code">    tokenSource.Cancel();</p><p class="source-code">    Console.WriteLine("Cancellation requested.");</p><p class="source-code">}</p></li>
</ol>
<p>This <a id="_idIndexMarker568"/>method calls <strong class="source-inline">ThreadPool.QueueUserWorkItem</strong> to queue the <strong class="source-inline">ProcessText</strong> method in the <strong class="source-inline">ThreadPool</strong> thread. The method also receives a cancellation token from <strong class="source-inline">tokenSource.Token</strong>. After waiting for five seconds, <strong class="source-inline">tokenSource.Cancel</strong> is called, and <strong class="source-inline">ProcessText</strong> will receive the cancellation request.</p>
<p>Notice that <strong class="source-inline">tokenSource</strong> is created in a <strong class="source-inline">using</strong> statement. This ensures that it will be properly disposed of when it goes out of scope.</p>
<ol>
<li value="5">Add a call to <strong class="source-inline">CancelThread</strong> to the <strong class="source-inline">Main</strong> method in <strong class="source-inline">Program.cs</strong>:<p class="source-code">static void Main(string[] args)</p><p class="source-code">{</p><p class="source-code">    CancelThread();</p><p class="source-code">    Console.ReadKey();</p><p class="source-code">}</p></li>
<li>Finally, run the application and observe the console output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 11.1 – Running the CancelThreadsConsoleApp project " height="297" src="image/Figure_11.1_B18852.jpg" width="936"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Running the CancelThreadsConsoleApp project</p>
<p>The <strong class="source-inline">for</strong> loop should <a id="_idIndexMarker569"/>have enough time to execute 9 or 10 times before receiving the request to cancel. How does your output match up?</p>
<p>Now that we have covered some basics of cancellation and worked with a common method of using a cancellation token, let’s create some examples of how to cancel parallel loops and PLINQ queries.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Canceling parallel work</h1>
<p>In this <a id="_idIndexMarker570"/>section, we will work with some examples of canceling parallel operations. There are a few operations that fall into this realm. There are static parallel operations that are part of the <strong class="source-inline">System.Threading.Tasks.Parallel</strong> class and there are PLINQ operations. Both of these types use a <strong class="source-inline">CancellationToken</strong> property, as we used in our managed threading example in the previous section. However, handling the cancellation request is slightly different. Let’s look at an example to understand the differences.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Canceling a parallel loop</h2>
<p>In this <a id="_idIndexMarker571"/>section, we will create a sample that illustrates how to cancel a <strong class="source-inline">Parallel.For</strong> loop. The same method of cancellation is leveraged for the <strong class="source-inline">Parallel.ForEach</strong> method. Perform the following steps:</p>
<ol>
<li value="1">Open the <strong class="source-inline">CancelThreadsConsoleApp</strong> project from the previous section.</li>
<li>In the <strong class="source-inline">ManagedThreadsExample</strong> class, create a new <strong class="source-inline">ProcessTextParallel</strong> method with the following implementation:<p class="source-code">public static void ProcessTextParallel(object? </p><p class="source-code">    cancelToken)</p><p class="source-code">{</p><p class="source-code">    var token = cancelToken as CancellationToken?;</p><p class="source-code">    if (token == null) return;</p><p class="source-code">    string text = "";</p><p class="source-code">    ParallelOptions options = new()</p><p class="source-code">    {</p><p class="source-code">        CancellationToken = token.Value,</p><p class="source-code">        MaxDegreeOfParallelism = </p><p class="source-code">            Environment.ProcessorCount</p><p class="source-code">    };</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        Parallel.For(0, 75000, options, (x) =&gt;</p><p class="source-code">        {</p><p class="source-code">            text += x + " ";</p><p class="source-code">            Thread.Sleep(500);</p><p class="source-code">        });</p><p class="source-code">    }</p><p class="source-code">    catch (OperationCanceledException e)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine($"Text value: {text}. </p><p class="source-code">            {Environment.NewLine} Exception </p><p class="source-code">                encountered: {e.Message}");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Essentially, the preceding code does the same thing as the <strong class="source-inline">ProcessText</strong> method in our last example. It appends a numeric value to the <strong class="source-inline">text</strong> variable until a <a id="_idIndexMarker572"/>cancellation is requested. Let’s examine the differences:</p>
<ul>
<li>First, we are setting <strong class="source-inline">token.Value</strong> to the <strong class="source-inline">CancellationToken</strong> property of a <strong class="source-inline">ParallelOptions</strong> object. These options are passed as the third parameter to the <strong class="source-inline">Parallel.For</strong> method.</li>
<li>The second major difference is that we handle the cancellation request by catching an <strong class="source-inline">OperationCanceledException</strong> type. This exception type will be thrown when our other code in <strong class="source-inline">Program.cs</strong> requests a cancellation.</li>
</ul>
<ol>
<li value="3">Next, add a method named <strong class="source-inline">CancelParallelFor</strong> to <strong class="source-inline">Program.cs</strong>:<p class="source-code">private static void CancelParallelFor()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    Console.WriteLine("Press a key to start, then </p><p class="source-code">        press 'x' to send cancellation.");</p><p class="source-code">    Console.ReadKey();</p><p class="source-code">    Task.Run(() =&gt;</p><p class="source-code">    {</p><p class="source-code">        if (Console.ReadKey().KeyChar == 'x')</p><p class="source-code">            tokenSource.Cancel();</p><p class="source-code">        Console.WriteLine();</p><p class="source-code">        Console.WriteLine("press a key");</p><p class="source-code">    });</p><p class="source-code">    ManagedThreadsExample.ProcessTextParallel</p><p class="source-code">        (tokenSource.Token);</p><p class="source-code">}</p></li>
</ol>
<p>In this<a id="_idIndexMarker573"/> method, the user is instructed to press a key to start the operation and to press the <em class="italic">X</em> key when they are ready to cancel the operation. The code to handle receiving <strong class="source-inline">x</strong> <strong class="source-inline">KeyChar</strong> from the console and sending a <strong class="source-inline">Cancel</strong> request is performed on another thread in order to keep the current thread free to call <strong class="source-inline">ProcessTextParallel</strong>.</p>
<ol>
<li value="4">Finally, update the <strong class="source-inline">Main</strong> method to call <strong class="source-inline">CancelParallelFor</strong> and comment out the call to <strong class="source-inline">CancelThread</strong>:<p class="source-code">static void Main(string[] args)</p><p class="source-code">{</p><p class="source-code">    //CancelThread();</p><p class="source-code">    CancelParallelFor();</p><p class="source-code">    Console.ReadKey();</p><p class="source-code">}</p></li>
<li>Now run the project. Follow the prompts to cancel the <strong class="source-inline">Parallel.For</strong> loop, and examine the output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 11.2 – Canceling a Parallel.For loop from the console " height="373" src="image/Figure_11.2_B18852.jpg" width="1010"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Canceling a Parallel.For loop from the console</p>
<p>Notice how the numbers are not in sequence at all. In this case, it appears that the <strong class="source-inline">Parallel.For</strong> operation used two different threads. The first thread started at <strong class="source-inline">0</strong>, while the second thread was operating on integers starting with <strong class="source-inline">37500</strong>. This <a id="_idIndexMarker574"/>is the midway point of the maximum value of <strong class="source-inline">75000</strong> provided to the method parameter.</p>
<p>In the next section, we will briefly examine how to cancel a PLINQ query.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Canceling a PLINQ query</h2>
<p>Canceling a<a id="_idIndexMarker575"/> PLINQ query is also achieved by catching the <strong class="source-inline">OperationCanceledException</strong> type. However, instead of using the <strong class="source-inline">ParallelOptions</strong> object that is used with parallel loops, you can call <strong class="source-inline">WithCancellation</strong> as part of the query.</p>
<p>To learn how to cancel a PLINQ query, let’s walk through an example:</p>
<ol>
<li value="1">Start this example by adding a method named <strong class="source-inline">ProcessNumsPlinq</strong>, to the <strong class="source-inline">ManagedThreadsExample</strong> class:<p class="source-code">public static void ProcessNumsPlinq(object? </p><p class="source-code">    cancelToken)</p><p class="source-code">{</p><p class="source-code">    int[] input = Enumerable.Range(1, </p><p class="source-code">        25000000).ToArray();</p><p class="source-code">    var token = cancelToken as CancellationToken?;</p><p class="source-code">    if (token == null) return;</p><p class="source-code">    int[]? result = null;</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        result =</p><p class="source-code">            (from value in input.AsParallel()</p><p class="source-code">                .WithCancellation(token.Value)</p><p class="source-code">                where value % 7 == 0</p><p class="source-code">                orderby value</p><p class="source-code">                select value).ToArray();</p><p class="source-code">    }</p><p class="source-code">    catch (OperationCanceledException e)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine($"Exception encountered: </p><p class="source-code">            {e.Message}");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>This method<a id="_idIndexMarker576"/> creates an array of 25 million integers and uses the PLINQ query to determine which of them are divisible by seven. The <strong class="source-inline">token.Value</strong> is passed to the <strong class="source-inline">WithCancellation</strong> operation in the query. When an exception is thrown by a cancellation request, the exception details are written to the console.</p>
<ol>
<li value="2">Next, add <a id="_idIndexMarker577"/>a method named <strong class="source-inline">CancelPlinq</strong> to <strong class="source-inline">Program.cs</strong>:<p class="source-code">private static void CancelPlinq()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    Console.WriteLine("Press a key to start.");</p><p class="source-code">    Console.ReadKey();</p><p class="source-code">    Task.Run(() =&gt;</p><p class="source-code">    {</p><p class="source-code">        Thread.Sleep(100);</p><p class="source-code">        Console.WriteLine("Requesting cancel.");</p><p class="source-code">        tokenSource.Cancel();</p><p class="source-code">        Console.WriteLine("Cancel requested.");</p><p class="source-code">    });</p><p class="source-code">    ManagedThreadsExample.ProcessNumsPlinq</p><p class="source-code">        (tokenSource.Token);</p><p class="source-code">}</p></li>
</ol>
<p>This time, the cancellation will be triggered automatically after 100 milliseconds.</p>
<ol>
<li value="3">Update the <strong class="source-inline">Main</strong> method to call <strong class="source-inline">CancelPlinq</strong>, and run the application:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 11.3 – Canceling a PLINQ operation in the console application " height="398" src="image/Figure_11.3_B18852.jpg" width="1113"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Canceling a PLINQ operation in the console application</p>
<p>Unlike<a id="_idIndexMarker578"/> the previous examples, there is no query output to examine. You cannot get partial output from a PLINQ query. The <strong class="source-inline">result</strong> variable will be <strong class="source-inline">null</strong>.</p>
<p>In the next section, we will work with some different methods of cancellation.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/>Discovering patterns for thread cancellation</h1>
<p>There are<a id="_idIndexMarker579"/> different methods of listening for <a id="_idIndexMarker580"/>cancellation requests from a thread or task. So far, we have seen examples of managing these requests by either handling the <strong class="source-inline">OperationCanceledException</strong> type or checking the value of <strong class="source-inline">IsCancellationRequested</strong>. The pattern of checking <strong class="source-inline">IsCancellationRequested</strong>, usually inside a loop, is<a id="_idIndexMarker581"/> called <strong class="bold">polling</strong>. First, we will see another example of this pattern. The second pattern we will examine is receiving the notification by <strong class="bold">registering a callback method</strong>. The final pattern that we will cover in this section is <strong class="bold">listening to cancellation requests with wait handles</strong> using <strong class="source-inline">ManualResetEvent</strong> or <strong class="source-inline">ManualResetEventSlim</strong>.</p>
<p>Let’s start by trying another <a id="_idIndexMarker582"/>example of handling a cancellation request by polling.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Canceling with polling</h2>
<p>In this<a id="_idIndexMarker583"/> section, we will create another example that <a id="_idIndexMarker584"/>uses polling to cancel a background task. The previous example of polling was running in a background thread on the <strong class="source-inline">ThreadPool</strong> thread. This example will also start a <strong class="source-inline">ThreadPool</strong> thread, but it will leverage <strong class="source-inline">Task.Run</strong> to start the background thread. We will create and process a million <strong class="source-inline">System.Drawing.Point</strong> objects, finding those with a <strong class="source-inline">Point.X</strong> value of less than <strong class="source-inline">50</strong>. Users will have the option to cancel processing by pressing the <em class="italic">X</em> key:</p>
<ol>
<li value="1">Start by creating a new .NET console application project named <strong class="source-inline">CancellationPatterns</strong></li>
<li>Add a new class to the project named <strong class="source-inline">PollingExample</strong></li>
<li>Add a private static method to <strong class="source-inline">PollingExample</strong> named <strong class="source-inline">GeneratePoints</strong>. This will generate the number of <strong class="source-inline">Point</strong> objects that we desire with random <strong class="source-inline">X</strong> values:<p class="source-code">private static List&lt;Point&gt; GeneratePoints(int count)</p><p class="source-code">{</p><p class="source-code">    var rand = new Random();</p><p class="source-code">    var points = new List&lt;Point&gt;();</p><p class="source-code">    for (int i = 0; i &lt;= count; i++)</p><p class="source-code">    {</p><p class="source-code">        points.Add(new Point(rand.Next(1, count * 2), </p><p class="source-code">            100));</p><p class="source-code">    }</p><p class="source-code">    return points;</p><p class="source-code">}</p></li>
<li>Don’t forget to add a <strong class="source-inline">using</strong> statement to use the <strong class="source-inline">Point</strong> type:<p class="source-code">using System.Drawing;</p></li>
<li>Next, add <a id="_idIndexMarker585"/>a private static method <a id="_idIndexMarker586"/>named <strong class="source-inline">FindSmallXValues</strong> to <strong class="source-inline">PollingExample</strong>. This method loops through the list of points and outputs those with an <strong class="source-inline">X</strong> value of less than <strong class="source-inline">50</strong>. Each time through the loop, it checks the token for cancellation and breaks out of the loop when it occurs:<p class="source-code">private static void FindSmallXValues(List&lt;Point&gt; </p><p class="source-code">    points, CancellationToken token)</p><p class="source-code">{</p><p class="source-code">    foreach (Point point in points)</p><p class="source-code">    {</p><p class="source-code">        if (point.X &lt; 50)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine($"Point with small X </p><p class="source-code">                coordinate found. Value: {point.X}");</p><p class="source-code">        }</p><p class="source-code">        if (token.IsCancellationRequested)</p><p class="source-code">        {</p><p class="source-code">            break;</p><p class="source-code">        }</p><p class="source-code">        Thread.SpinWait(5000);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>A <strong class="source-inline">Thread.SpinWait</strong> statement is added at the end of the loop to give users some time to cancel the operation.</p>
<ol>
<li value="6">Add a public static <a id="_idIndexMarker587"/>method to <strong class="source-inline">PollingExample</strong> named <strong class="source-inline">CancelWithPolling</strong>:<p class="source-code">public static void CancelWithPolling()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    Task.Run(() =&gt; FindSmallXValues(GeneratePoints</p><p class="source-code">        (1000000), tokenSource.Token), tokenSource</p><p class="source-code">            .Token);</p><p class="source-code">    if (Console.ReadKey(true).KeyChar == 'x')</p><p class="source-code">    {</p><p class="source-code">        tokenSource.Cancel();</p><p class="source-code">        Console.WriteLine("Press a key to quit");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>The <a id="_idIndexMarker588"/>preceding method creates the <strong class="source-inline">CancellationTokenSource</strong> object and passes it to <strong class="source-inline">FindSmallXValues</strong> and also <strong class="source-inline">Task.Run</strong>. If you wanted to cancel the <strong class="source-inline">Task</strong>, instead of breaking out of the loop when <strong class="source-inline">IsCancellationRequested</strong> becomes <strong class="source-inline">true</strong>, you would call <strong class="source-inline">token.ThrowIfCancellationRequested</strong>. This would throw an exception in the <strong class="source-inline">Task</strong>. The <strong class="source-inline">CancelWithPolling</strong> method would then require a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block around the <strong class="source-inline">Task.Run</strong> call. It’s a best practice to use exception handling with all multithreaded code anyway. In this case, you would have two exception handlers: one to handle <strong class="source-inline">OperationCanceledException</strong> and a second to handle <strong class="source-inline">AggregateException</strong>.</p>
<p>Additionally, the <strong class="source-inline">CancelWithPolling</strong> method has code to determine when the user<a id="_idIndexMarker589"/> presses the <em class="italic">X</em> key to cancel the operation.</p>
<ol>
<li value="7">Finally, open <strong class="source-inline">Program.cs</strong> and add some code to execute the sample:<p class="source-code">using CancellationPatterns;</p><p class="source-code">Console.WriteLine("Hello, World! Press a key to start, </p><p class="source-code">    then press 'x' to cancel.");</p><p class="source-code">Console.ReadKey();</p><p class="source-code">PollingExample.CancelWithPolling();</p><p class="source-code">Console.ReadKey();</p></li>
<li>Now run<a id="_idIndexMarker590"/> the application, and examine the output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 11.4 – Running the cancellation polling example " height="536" src="image/Figure_11.4_B18852.jpg" width="911"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Running the cancellation polling example</p>
<p>Depending on how long you wait before canceling, you might have a different number of points found <a id="_idIndexMarker591"/>by the process.</p>
<p>In the next section, we will learn how you can register a callback method to handle cancellation requests.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Canceling with callbacks</h2>
<p>Some <a id="_idIndexMarker592"/>code in .NET <a id="_idIndexMarker593"/>supports the registration of a callback method to cancel processing. One class that supports cancellation with callbacks is <strong class="source-inline">System.Net.WebClient</strong>. In this example, we will use <strong class="source-inline">WebClient</strong> to start downloading a file. The download will be canceled after three seconds. To ensure the file download is large enough that it has not been completed after three seconds, we will download a large lossless audiobook file <a id="_idIndexMarker594"/>from <strong class="bold">Internet Archive</strong> (https://archive.org/). We will download the first part of the audiobook of <em class="italic">The Odyssey</em> by Homer. This file is 471.1 MB. You can view all of the free downloads for this book at https://archive.org/details/lp_the-odyssey_homer-anthony-quayle. Perform the following steps:</p>
<ol>
<li value="1">Open the <strong class="bold">CancellationPatterns</strong> project and add a new class named <strong class="source-inline">CallbackExample</strong></li>
<li>Start by adding a method named <strong class="source-inline">GetDownloadFileName</strong> to build the path where the file will be downloaded. We will download it to the same folder where our assembly is executing:<p class="source-code">private static string GetDownloadFileName()</p><p class="source-code">{</p><p class="source-code">    string path = System.Reflection.Assembly</p><p class="source-code">       .GetAssembly(typeof(CallbackExample)).Location;</p><p class="source-code">    string folder = Path.GetDirectoryName(path);</p><p class="source-code">    return Path.Combine(folder, "audio.flac");</p><p class="source-code">}</p></li>
<li>Next, add an <strong class="source-inline">async</strong> method named <strong class="source-inline">DownloadAudioAsync</strong>. This method will handle the file download and cancellation. There are several exception handlers to <a id="_idIndexMarker595"/> catch any type of exception that the <strong class="source-inline">DownloadFileTaskAsync</strong> method might throw. In turn, all of them throw an <strong class="source-inline">OperationCanceledException</strong> type to<a id="_idIndexMarker596"/> be handled by the parent method:<p class="source-code">private static async Task DownloadAudioAsync</p><p class="source-code">    (CancellationToken token)</p><p class="source-code">{</p><p class="source-code">    const string url = "https://archive.org/download/</p><p class="source-code">        lp_the-odyssey_homer-anthony-quayle/disc1/</p><p class="source-code">            lp_the-odyssey_homer-anthony-quayle</p><p class="source-code">                _disc1side1.flac";</p><p class="source-code">    using WebClient webClient = new();</p><p class="source-code">    token.Register(webClient.CancelAsync);</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        await webClient.DownloadFileTaskAsync(url, </p><p class="source-code">            GetDownloadFileName());</p><p class="source-code">    }</p><p class="source-code">    catch (WebException we)</p><p class="source-code">    {</p><p class="source-code">        if (we.Status == WebExceptionStatus</p><p class="source-code">            .RequestCanceled)</p><p class="source-code">            throw new OperationCanceledException();</p><p class="source-code">    }</p><p class="source-code">    catch (AggregateException ae)</p><p class="source-code">    {</p><p class="source-code">        foreach (Exception ex in ae.InnerExceptions)</p><p class="source-code">        {</p><p class="source-code">            if (ex is WebException exWeb &amp;&amp;</p><p class="source-code">                exWeb.Status == WebExceptionStatus</p><p class="source-code">                    .RequestCanceled)</p><p class="source-code">                throw new OperationCanceled</p><p class="source-code">                    Exception();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    catch (TaskCanceledException)</p><p class="source-code">    {</p><p class="source-code">        throw new OperationCanceledException();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Add a <strong class="source-inline">using</strong> statement <a id="_idIndexMarker597"/>for the <strong class="source-inline">WebClient</strong> type:<p class="source-code">using System.Net;</p></li>
<li>Now add a <a id="_idIndexMarker598"/> public <strong class="source-inline">async</strong> method named <strong class="source-inline">CancelWithCallback</strong>. This method calls <strong class="source-inline">DownloadAudioAsync</strong>, waits for three seconds, and calls <strong class="source-inline">Cancel</strong> on the <strong class="source-inline">CancellationTokenSource</strong> object. Awaiting the task in a <strong class="source-inline">try</strong> block means we can handle the <strong class="source-inline">OperationCanceledException</strong> type directly. If you used <strong class="source-inline">task.Wait</strong> instead, you would have to catch <strong class="source-inline">AggregateException</strong> and check whether one of the <strong class="source-inline">InnerException</strong> objects is an <strong class="source-inline">OperationCanceledException</strong> type:<p class="source-code">public static async Task CancelWithCallback()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    Console.WriteLine("Starting download");</p><p class="source-code">    var task = DownloadAudioAsync(tokenSource.Token);</p><p class="source-code">    tokenSource.Token.WaitHandle.WaitOne</p><p class="source-code">        (TimeSpan.FromSeconds(3));</p><p class="source-code">    tokenSource.Cancel();</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        await task;</p><p class="source-code">    }</p><p class="source-code">    catch (OperationCanceledException ex)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine($"Download canceled. </p><p class="source-code">            Exception: {ex.Message}");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>In this<a id="_idIndexMarker599"/> step, it might be necessary to <a id="_idIndexMarker600"/> adjust the number of seconds in the <strong class="source-inline">tokenSource.Token.WaitHandle.WaitOne</strong> call. The timing can vary based on your computer’s download speed and processing speed. Try adjusting the value if you do not see a <strong class="source-inline">Download canceled</strong> message in the console output.</p>
<ol>
<li value="6">Finally, comment out the existing code in <strong class="source-inline">Program.cs</strong>, and add the following code to <a id="_idIndexMarker601"/> call the <strong class="source-inline">CallbackExample</strong> class:<p class="source-code">using CancellationPatterns;</p><p class="source-code">await CallbackExample.CancelWithCallback();</p><p class="source-code">Console.ReadKey();</p></li>
<li>Now run the application, and examine the output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 11.5 – Canceling a download with CancellationToken and a callback " height="346" src="image/Figure_11.5_B18852.jpg" width="958"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Canceling a download with CancellationToken and a callback</p>
<p>You can<a id="_idIndexMarker602"/> verify that the download started and did not complete by looking in the folder where your assembly was running. You should see a file named <strong class="bold">audio.flac</strong> with a file size of <strong class="bold">0 KB</strong>. You can safely delete this file as it could cause exceptions if you try to download it again.</p>
<p>Now that we have seen how to cancel a background task with a callback method, let’s wrap up this section by working through<a id="_idIndexMarker603"/> an example with wait handles.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Canceling with wait handles</h2>
<p>In this <a id="_idIndexMarker604"/>section, we will use <strong class="source-inline">ManualResetEventSlim</strong> to cancel a background task that would not otherwise be responsive to<a id="_idIndexMarker605"/> user input. This object has <strong class="source-inline">Set</strong> and <strong class="source-inline">Reset</strong> events to start/resume or pause an operation. When operations have not yet started or have been paused, calling <strong class="source-inline">ManualResetEventSlim.Wait</strong> will cause the operation to pause on that statement until another thread calls <strong class="source-inline">Set</strong> to start or resume processing.</p>
<p>This example will iterate over 100,000 integers and output to the console for each even number. This process can be started, paused, resumed, or canceled thanks to the <strong class="source-inline">ManualResetEventSlim</strong> object and <strong class="source-inline">CancellationToken</strong>. Let’s try this example in our <a id="_idIndexMarker606"/>project:</p>
<ol>
<li value="1">Start by adding a <strong class="source-inline">WaitHandleExample</strong> class to the <strong class="bold">CancellationPatterns</strong> project.</li>
<li>Add a private variable named <strong class="source-inline">resetEvent</strong> to the new class:<p class="source-code">private static ManualResetEventSlim resetEvent = </p><p class="source-code">    new(false);</p></li>
<li>Add a private static method named <strong class="source-inline">ProcessNumbers</strong> to the class. This method iterates over the numbers and only continues processing when <strong class="source-inline">resetEvent.Wait</strong> allows it to proceed:<p class="source-code">private static void ProcessNumbers(IEnumerable&lt;int&gt; </p><p class="source-code">    numbers, CancellationToken token)</p><p class="source-code">{</p><p class="source-code">    foreach (var number in numbers)</p><p class="source-code">    {</p><p class="source-code">        if (token.IsCancellationRequested)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("Cancel requested");</p><p class="source-code">            token.ThrowIfCancellationRequested();</p><p class="source-code">        }</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            resetEvent.Wait(token);</p><p class="source-code">        }</p><p class="source-code">        catch (OperationCanceledException)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("Operation canceled.");</p><p class="source-code">            break;</p><p class="source-code">        }</p><p class="source-code">        if (number % 2 == 0)</p><p class="source-code">            Console.WriteLine($"Found even number: </p><p class="source-code">                {number}");</p><p class="source-code">        Thread.Sleep(500);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Next, add <a id="_idIndexMarker607"/>a public static async method <a id="_idIndexMarker608"/>named <strong class="source-inline">CancelWithResetEvent</strong> to the class. This method creates the list of numbers to process, calls <strong class="source-inline">ProcessNumbers</strong> within a <strong class="source-inline">Task.Run</strong> call, and uses a <strong class="source-inline">while</strong> loop to listen for user input:<p class="source-code">public static async Task CancelWithResetEvent()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    var numbers = Enumerable.Range(0, 100000);</p><p class="source-code">    _ = Task.Run(() =&gt; ProcessNumbers(numbers, </p><p class="source-code">        tokenSource.Token), tokenSource.Token);</p><p class="source-code">    Console.WriteLine("Use x to cancel, p to pause, or </p><p class="source-code">        s to start or resume,");</p><p class="source-code">    Console.WriteLine("Use any other key to quit the </p><p class="source-code">        program.");</p><p class="source-code">    bool running = true;</p><p class="source-code">    while (running)</p><p class="source-code">    {</p><p class="source-code">        char key = Console.ReadKey(true).KeyChar;</p><p class="source-code">        switch (key)</p><p class="source-code">        {</p><p class="source-code">            case 'x':</p><p class="source-code">                tokenSource.Cancel();</p><p class="source-code">                break;</p><p class="source-code">            case 'p':</p><p class="source-code">                resetEvent.Reset();</p><p class="source-code">                break;</p><p class="source-code">            case 's':</p><p class="source-code">                resetEvent.Set();</p><p class="source-code">                break;</p><p class="source-code">            default:</p><p class="source-code">                running = false;</p><p class="source-code">                break;</p><p class="source-code">        }</p><p class="source-code">        await Task.Delay(100);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Finally, update <strong class="source-inline">Program.cs</strong> to <a id="_idIndexMarker609"/>contain<a id="_idIndexMarker610"/> the following code:<p class="source-code">using CancellationPatterns;</p><p class="source-code">await WaitHandleExample.CancelWithResetEvent();</p><p class="source-code">Console.ReadKey();</p></li>
<li>Run the program to test it. Follow the console prompts to start, pause, resume, and cancel the process:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 11.6 – Testing the CancelWithResetEvent method in the console " height="381" src="image/Figure_11.6_B18852.jpg" width="865"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Testing the CancelWithResetEvent method in the console</p>
<p>You should<a id="_idIndexMarker611"/> see in the console output that several <a id="_idIndexMarker612"/>event numbers have been found before the operation is canceled. The amount of processing completed could vary based on your computer’s processors.</p>
<p>In the next section, we will wrap up cancellation by learning how to handle cancellation requests from multiple sources.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Handling multiple cancellation sources</h1>
<p>Background tasks <a id="_idIndexMarker613"/>can leverage <strong class="source-inline">CancellationTokenSource</strong> to receive cancellation requests from as many sources as necessary. The static <strong class="source-inline">CancellationTokenSource.CreateLinkedTokenSource</strong> method accepts an array of <strong class="source-inline">CancellationToken</strong> objects to create a new <strong class="source-inline">CancellationTokenSource</strong> object that will notify us of cancellation if any of the source tokens receives a request to cancel.</p>
<p>Let’s look at a<a id="_idIndexMarker614"/> quick example of how to implement this in our <strong class="bold">CancellationPatterns</strong> project:</p>
<ol>
<li value="1">First, open the <strong class="source-inline">PollingExample</strong> class. We are going to create an overload of the <strong class="source-inline">CancelWithPolling</strong> method that accepts a <strong class="source-inline">CancellationTokenSource</strong> parameter. The two overloads of <strong class="source-inline">CancelWithPolling</strong> will look like this:<p class="source-code">public static void CancelWithPolling()</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    CancelWithPolling(tokenSource);</p><p class="source-code">}</p><p class="source-code"><strong class="bold">public static void CancelWithPolling</strong></p><p class="source-code"><strong class="bold">    (CancellationTokenSource tokenSource)</strong></p><p class="source-code">{</p><p class="source-code">    Task.Run(() =&gt; FindSmallXValues(GeneratePoints</p><p class="source-code">        (1000000), tokenSource.Token), </p><p class="source-code">            tokenSource.Token);</p><p class="source-code">    if (Console.ReadKey(true).KeyChar == 'x')</p><p class="source-code">    {</p><p class="source-code">        tokenSource.Cancel();</p><p class="source-code">        Console.WriteLine("Press a key to quit");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Next, add a new class named <strong class="source-inline">MultipleTokensExample</strong>.</li>
<li>Create a method named <strong class="source-inline">CancelWithMultipleTokens</strong> in the <strong class="source-inline">MultipleTokensExample</strong> class. This method accepts <strong class="source-inline">parentToken</strong> as a parameter, creates its own <strong class="source-inline">tokenSource</strong>, and then combines them into a <strong class="source-inline">combinedSource</strong> object<a id="_idIndexMarker615"/> to pass to the <strong class="source-inline">CancelWithPolling</strong> method:<p class="source-code">public static void CancelWithMultipleTokens</p><p class="source-code">    (CancellationToken parentToken)</p><p class="source-code">{</p><p class="source-code">    using CancellationTokenSource tokenSource = new();</p><p class="source-code">    using CancellationTokenSource combinedSource =  </p><p class="source-code">        CancellationTokenSource.CreateLinked</p><p class="source-code">           TokenSource(parentToken, tokenSource</p><p class="source-code">               .Token);</p><p class="source-code">    PollingExample.CancelWithPolling(combinedSource);</p><p class="source-code">    Thread.Sleep(1000);</p><p class="source-code">    tokenSource.Cancel();</p><p class="source-code">}</p></li>
</ol>
<p>We’re calling <strong class="source-inline">tokenSource.Cancel</strong>, but if <strong class="source-inline">Cancel</strong> is invoked on any of the three <strong class="source-inline">CancellationTokenSource</strong> objects, the processing in <strong class="source-inline">CancellWithPolling</strong> will receive a cancellation request.</p>
<ol>
<li value="4">Add some code to <strong class="source-inline">Program.cs</strong> to call <strong class="source-inline">CancelWithMultipleTokens</strong>:<p class="source-code">using CancellationPatterns;</p><p class="source-code">CancellationTokenSource tokenSource = new();</p><p class="source-code">MultipleTokensExample.CancelWithMultipleTokens</p><p class="source-code">    (tokenSource.Token);</p><p class="source-code">Console.ReadKey();</p></li>
<li>Run the program, and you should see an output similar to what you saw in the subsection <em class="italic">Canceling with polling</em> of the section <em class="italic">Discovering patterns for thread cancellation</em>.</li>
</ol>
<p>Try <a id="_idIndexMarker616"/>changing which <strong class="source-inline">CancellationTokenSource</strong> object is used to invoke <strong class="source-inline">Cancel</strong>. The output should remain the same regardlesss of the source of the cancellation request.</p>
<p>A background <strong class="source-inline">Task</strong> will also end if you throw an exception within the <strong class="source-inline">Task</strong>. This has a similar effect of ending the background processing, but <strong class="source-inline">TaskStatus</strong> will be <strong class="source-inline">Faulted</strong> instead of <strong class="source-inline">Canceled</strong>.</p>
<p>This completes our review of cancellation requests from multiple sources and our tour of canceling tasks and threads with C# and .NET. Let’s review what we have learned in this chapter.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>Summary</h1>
<p>In this chapter, we learned a number of new ways to cancel background threads and tasks. It is important to provide your users with a method of canceling long-running tasks or automatically canceling them when users or the operating system closes or suspends your application. </p>
<p>After working through the examples in this chapter, you now understand how to use polling, callbacks, and wait handles to cooperatively cancel background tasks. Additionally, you learned how to handle cancellation requests from more than one source.</p>
<p>In the next chapter, we will look at how .NET developers can unit test code that employs multithreaded constructs.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Questions</h1>
<ol>
<li value="1">Which property of a <strong class="source-inline">CancellationToken</strong> object indicates whether a cancellation request has been made?</li>
<li>Which data type provides a <strong class="source-inline">CancellationToken</strong> object?</li>
<li>What exception type is thrown when <strong class="source-inline">ThrowIfCancellationRequested</strong> is invoked?</li>
<li>What cancellation pattern is used by the <strong class="source-inline">WebClient</strong> object in .NET?</li>
<li>Which .NET type can pause or resume operations with a <strong class="source-inline">CancellationToken</strong> object?</li>
<li>Which reset event is used to pause processing?</li>
<li>Which static method in <strong class="source-inline">CancellationTokenSource</strong> can combine multiple <strong class="source-inline">CancellationToken</strong> objects into a single source?</li>
</ol>
</div>
</div>
</body></html>