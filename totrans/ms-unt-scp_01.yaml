- en: Chapter 1. Unity C# Refresher
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. Unity C# 复习
- en: This book is about mastering scripting for Unity, specifically mastering C#
    in the context of Unity game development. The concept of mastering needs a definition
    and qualification, before proceeding further. By mastering, I mean this book will
    help you transition from having intermediate and theoretical knowledge to having
    more fluent, practical, and advanced knowledge of scripting. Fluency is the keyword
    here. From the outset of learning any programming language, the focus invariably
    turns to language syntax and its rules and laws—the formal parts of a language.
    This includes concepts such as variables, loops, and functions. However, as a
    programmer gets experience, the focus shifts from language specifically to the
    creative ways in which language is applied to solve real-world problems. The focus
    changes from language-oriented problems to questions of context-sensitive application.
    Consequently, most of this book will not primarily be about the formal language
    syntax of C#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书关于掌握 Unity 脚本编写，特别是掌握在 Unity 游戏开发背景下的 C#。在进一步讨论之前，需要定义和限定“掌握”的概念。通过“掌握”，我的意思是这本书将帮助你从拥有中级和理论知识过渡到拥有更流利、实用和高级的脚本知识。流利是关键词。从学习任何编程语言的开始，重点总是转向语言的语法和规则和法律——语言的正式部分。这包括诸如变量、循环和函数等概念。然而，随着程序员经验的积累，重点从语言本身转移到语言在解决现实世界问题中的应用方式上。重点从语言导向的问题转变为上下文敏感的应用问题。因此，本书的大部分内容将不会主要关于
    C# 的正式语言语法。
- en: After this chapter, I'll assume that you already know the basics. Instead, the
    book will be about case studies and real-world examples of the use of C#. However,
    before turning to that, this chapter will focus on the C# basics generally. This
    is intentional. It'll cover, quickly and in summary, all the C# foundational knowledge
    you'll need to follow along productively with subsequent chapters. I strongly
    recommend that you read it through from start to finish, whatever your experience.
    It's aimed primarily at readers who are reasonably new to C# but fancy jumping
    in at the deep end. However, it can also be valuable to experienced developers
    to consolidate their existing knowledge and, perhaps, pick up new advice and ideas
    along the way. In this chapter, then, I'll outline the fundamentals of C# from
    the ground up, in a step-by-step, summarized way. I will speak as though you already
    understand the very basics of programming generally, perhaps with another language,
    but have never encountered C#. So, let's go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，我将假设你已经掌握了基础知识。相反，本书将关于案例研究和 C# 的实际应用案例。然而，在转向这一点之前，本章将专注于 C# 的基础知识。这是故意的。它将快速、简要地涵盖你需要跟随后续章节有效进行的所有
    C# 基础知识。我强烈建议你从头到尾阅读一遍，无论你的经验如何。本书主要面向那些对 C# 比较陌生但想深入学习的读者。然而，它对经验丰富的开发者来说也很有价值，可以帮助他们巩固现有知识，也许还能在过程中获得新的建议和想法。因此，在这一章中，我将从零开始，以逐步、总结的方式概述
    C# 的基础知识。我将假设你已经理解了编程的基本概念，可能使用另一种语言，但从未接触过 C#。那么，让我们开始吧。
- en: Why C#?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 C#？
- en: When it comes to Unity scripting, an early question when making a new game is
    which language to choose, because Unity offers a choice. The official choices
    are C# or JavaScript. However, there's a debate about whether JavaScript should
    more properly be named "JavaScript" or "UnityScript" due to the Unity-specific
    adaptations made to the language. This point is not our concern here. The question
    is which language should be chosen for your project. Now, it initially seems that
    as we have a choice, we can actually choose all two languages and write some script
    files in one language and other script files in another language, thus effectively
    mixing up the languages. This is, of course, technically possible. Unity won't
    stop you from doing this. However, it's a "bad" practice because it typically
    leads to confusion as well as compilation conflicts; it's like trying to calculate
    distances in miles and kilometers at the same time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Unity 脚本编写时，在制作新游戏时早期的一个问题就是选择哪种语言，因为 Unity 提供了选择。官方的选择是 C# 或 JavaScript。然而，由于对语言进行的
    Unity 特定适配，关于 JavaScript 是否应该更恰当地被称为 "JavaScript" 或 "UnityScript" 存在争议。这一点在此处不是我们的关注点。问题是应该为你的项目选择哪种语言。现在，最初看起来，既然我们有选择，我们实际上可以选择这两种语言，并在一种语言中编写一些脚本文件，在另一种语言中编写其他脚本文件，从而有效地混合语言。这当然是技术上可行的。Unity
    不会阻止你这样做。然而，这是一个“不好的”做法，因为它通常会导致混淆以及编译冲突；这就像同时尝试用英里和公里计算距离一样。
- en: The recommended approach, instead, is to choose one of the three languages and
    apply it consistently across your project as the authoritative language. This
    is a slicker, more efficient workflow, but it means one language must be chosen
    at the expense of others. This book chooses C#. Why? First, it's not because C#
    is "better" than the others. There is no absolute "better" or "worse" in my view.
    Each and every language has its own merits and uses, and all the Unity languages
    are equally serviceable for making games. The main reason is that C# is, perhaps,
    the most widely used and supported Unity language, because it connects most readily
    to the existing knowledge that most developers already have when they approach
    Unity. Most Unity tutorials are written with C# in mind, as it has a strong presence
    in other fields of application development. C# is historically tied to the .NET
    framework, which is also used in Unity (known as Mono there), and C# most closely
    resembles C++, which generally has a strong presence in game development. Further,
    by learning C#, you're more likely to find that your skill set aligns with the
    current demand for Unity programmers in the contemporary games industry. Therefore,
    I've chosen C# to give this book the widest appeal and one that connects to the
    extensive body of external tutorials and literature. This allows you to more easily
    push your knowledge even further after reading this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，建议选择三种语言中的一种，并在整个项目中一致地应用它作为权威语言。这是一个更流畅、更高效的流程，但这意味着必须选择一种语言，而牺牲其他语言。这本书选择了
    C#。为什么？首先，并不是因为 C# 比“其他”更好。在我看来，没有绝对的“更好”或“更差”。每种语言都有其自身的优点和用途，并且所有 Unity 语言在制作游戏方面都是同样有用的。主要原因可能是
    C# 是最广泛使用和受支持的 Unity 语言，因为它与大多数开发者接触 Unity 时已有的现有知识联系最为紧密。大多数 Unity 教程都是针对 C#
    编写的，因为它在其他应用开发领域有很强的存在感。C# 历史上与 .NET 框架相关联，该框架也用于 Unity（在那里称为 Mono），C# 与 C++ 最相似，C++
    通常在游戏开发中占有很强的地位。此外，通过学习 C#，你更有可能发现你的技能集与当代游戏行业中 Unity 程序员的需求相匹配。因此，我选择了 C#，以使这本书具有最广泛的吸引力，并且与大量的外部教程和文献相连接。这让你在阅读这本书之后更容易将你的知识进一步深化。
- en: Creating script files
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建脚本文件
- en: If you need to define a logic or behavior for your game, then you'll need to
    write a script. Scripting in Unity begins by creating a new script file, which
    is a standard text file added to the project. This file defines a program that
    lists all the instructions for Unity to follow. As mentioned, the instructions
    can be written in either C#, JavaScript, or Boo; for this book, the language will
    be C#. There are multiple ways to create a script file in Unity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为你的游戏定义逻辑或行为，那么你需要编写脚本。Unity 中的脚本编写从创建一个新的脚本文件开始，这是一个添加到项目中的标准文本文件。该文件定义了一个程序，列出了
    Unity 需要遵循的所有指令。如前所述，指令可以用 C#、JavaScript 或 Boo 编写；对于这本书，语言将是 C#。在 Unity 中创建脚本文件有多种方法。
- en: 'One way is to go to **Assets** | **Create** | **C# Script** from the application
    menu, as shown in the following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是前往应用程序菜单中的**资产** | **创建** | **C# 脚本**，如图下所示：
- en: '![Creating script files](img/0655OT_01_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![创建脚本文件](img/0655OT_01_01.jpg)'
- en: Creating a script file via the application menu
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用程序菜单创建脚本文件
- en: Another way is to right-click on the empty space anywhere within the **Project**
    panel and choose the **C# Script** option in the **Create** menu from the context
    menu, as shown in the following screenshot. This creates the asset in the currently
    open folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是右键单击**项目**面板中的任何空白区域，然后在上下文菜单中选择**创建**菜单中的**C# 脚本**选项，如图下所示。这将在当前打开的文件夹中创建资产。
- en: '![Creating script files](img/0655OT_01_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![创建脚本文件](img/0655OT_01_02.jpg)'
- en: Creating a script file via the Project panel context menu
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过项目面板上下文菜单创建脚本文件
- en: Once created, a new script file will be generated inside the `Project` folder
    with a `.cs` file extension (representing C Sharp). The filename is especially
    important and has serious implications on the validity of your script files because
    Unity uses the filename to determine the name of a C# class to be created inside
    the file. Classes are considered in more depth later in this chapter. In short,
    be sure to give your file a unique and meaningful name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，将在 `Project` 文件夹内生成一个新的脚本文件，文件扩展名为 `.cs`（代表 C Sharp）。文件名尤为重要，并且对脚本文件的有效性有重大影响，因为
    Unity 使用文件名来确定文件内要创建的 C# 类的名称。类将在本章后面更深入地讨论。简而言之，务必给你的文件起一个独特且具有意义的名称。
- en: 'By unique, we mean that no other script file anywhere in your project should
    have the same name, whether it is located in a different folder or not. All the
    script files should have a unique name across the project. The name should also
    be meaningful by expressing clearly what your script intends to do. Further, there
    are rules of validity governing filenames as well as class names in C#. The formal
    definition of these rules can be found online at [http://msdn.microsoft.com/en-us/library/aa664670%28VS.71%29.aspx](http://msdn.microsoft.com/en-us/library/aa664670%28VS.71%29.aspx).
    In short, the filename should start with a letter or underscore character only
    (numbers are not permitted for the first character), and the name should include
    no spaces, although underscores (_) are allowed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说独特时，指的是在整个项目中，无论文件位于不同的文件夹中与否，都不应有其他脚本文件与它同名。所有脚本文件在整个项目中都应具有唯一名称。名称还应具有意义，清楚地表达脚本打算做什么。此外，C#中还有关于文件名以及类名的有效性规则。这些规则的正式定义可以在网上找到，地址为[http://msdn.microsoft.com/en-us/library/aa664670%28VS.71%29.aspx](http://msdn.microsoft.com/en-us/library/aa664670%28VS.71%29.aspx)。简而言之，文件名应以字母或下划线字符开头（不允许以数字开头），并且名称中不应包含空格，尽管允许使用下划线（_）：
- en: '![Creating script files](img/0655OT_01_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建脚本文件](img/0655OT_01_03.jpg)'
- en: Name your script files in a unique way and according to the C# class naming
    conventions
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以独特的方式并根据C#类命名约定命名脚本文件
- en: Unity script files can be opened and examined in any text editor or IDE, including
    Visual Studio and Notepad++, but Unity provides the free and open source editor,
    **MonoDevelop**. This software is part of the main Unity package included in the
    installation and doesn't need to be downloaded separately. By double-clicking
    on the script file from the **Project** panel, Unity will automatically open the
    file inside MonoDevelop. If you later decide to, or need to, rename the script
    file, you also need to rename the C# class inside the file to match the filename
    exactly, as shown in the following screenshot. Failure to do so will result in
    invalid code and compilation errors or problems when attaching the script file
    to your objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unity脚本文件可以在任何文本编辑器或IDE中打开和检查，包括Visual Studio和Notepad++，但Unity还提供了免费的开放源代码编辑器**MonoDevelop**。此软件是安装包中的主要Unity部分，无需单独下载。通过双击**项目**面板中的脚本文件，Unity将自动在MonoDevelop中打开该文件。如果您后来决定或需要重命名脚本文件，您还需要将文件中的C#类重命名为与文件名完全匹配，如下面的截图所示。如果不这样做，将导致代码无效和编译错误或问题，当将脚本文件附加到对象时会出现问题。
- en: '![Creating script files](img/0655OT_01_04.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![创建脚本文件](img/0655OT_01_04.jpg)'
- en: Renaming classes to match the renamed script files
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将类重命名为与重命名的脚本文件匹配
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Compiling code**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译代码**'
- en: To compile code in Unity, you just need to save your script file in MonoDevelop
    by choosing the **Save** option in the **File** menu from the application menu
    (or by pressing *Ctrl* + *S* on the keyboard) and then return to the main Unity
    Editor. On refocusing on the Unity window, Unity automatically detects code changes
    in the files and then compiles your code in response. If there are errors, the
    game cannot be run, and the errors are printed to the **Console** window. If the
    compile was successful, you don't need to do anything else, except press **Play**
    on the **Editor** toolbar and test run your game. Take care here; if you forget
    to save your file in MonoDevelop after making code changes, then Unity will still
    use the older, compiled version of your code. For this reason as well as for the
    purpose of backup, it's really important to save your work regularly, so be sure
    to press *Ctrl* + *S* to save in MonoDevelop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中编译代码，您只需在MonoDevelop中保存您的脚本文件，通过从应用程序菜单中选择**文件**菜单中的**保存**选项（或按键盘上的*Ctrl*
    + *S*）然后返回到主Unity编辑器。当重新聚焦到Unity窗口时，Unity会自动检测文件中的代码更改，然后响应地编译您的代码。如果有错误，游戏无法运行，错误将打印到**控制台**窗口。如果编译成功，您不需要做任何事情，只需在**编辑器**工具栏上按**播放**并测试运行您的游戏。请注意，如果您在修改代码后忘记在MonoDevelop中保存文件，Unity仍然会使用较旧的、编译过的代码版本。因此，出于此原因以及备份的目的，定期保存您的作品非常重要，所以请确保按*Ctrl*
    + *S*在MonoDevelop中保存。
- en: Instantiating scripts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化脚本
- en: 'Each script file in Unity defines one main class that is like a blueprint or
    design that can be instantiated. It is a collection of related variables, functions,
    and events (as we''ll see soon). By default, a script file is like any other kind
    of Unity asset, such as meshes and audio files. Specifically, it remains dormant
    in the `Project` folder and does nothing until it''s added to a specific scene
    (by being added to an object as a component), where it comes alive at runtime.
    Now, scripts, being logical and mathematical in nature, are not added to the scene
    as tangible, independent objects as meshes are. You cannot see or hear them directly,
    because they have no visible or audible presence. Instead, they''re added onto
    existing game objects as components, where they define the behavior of those objects.
    This process of bringing scripts to life as a specific component on a specific
    object is known as instantiation. Of course, a single script file can be instantiated
    on multiple objects to replicate the behavior for them all, saving us from making
    multiple script files for each object, such as when multiple enemy characters
    must use the same artificial intelligence. The point of the script file, ideally,
    is to define an abstract formula or behavior pattern for an object that can be
    reused successfully across many similar objects in all possible scenarios. To
    add a script file onto an object, simply drag-and-drop the script from the **Project**
    panel onto the destination object in the scene. The script will be instantiated
    as a component, and its public variables will be visible in the **Object Inspector**
    whenever the object is selected, as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的每个脚本文件定义了一个主类，类似于蓝图或设计，可以被实例化。它是一系列相关的变量、函数和事件（我们很快就会看到）。默认情况下，脚本文件就像任何其他类型的Unity资产，例如网格和音频文件。具体来说，它保持在`Project`文件夹中处于休眠状态，不执行任何操作，直到它被添加到特定的场景中（通过将其作为组件添加到对象中），在那里它在运行时变得活跃。现在，由于脚本本质上是逻辑和数学的，它们不会像网格那样作为有形的、独立的对象添加到场景中。您无法直接看到或听到它们，因为它们没有可见或可听的存在。相反，它们作为组件添加到现有的游戏对象上，定义了这些对象的行为。将脚本作为特定对象上的特定组件激活的过程被称为实例化。当然，单个脚本文件可以在多个对象上实例化，以复制它们的行为，从而避免为每个对象创建多个脚本文件，例如当多个敌人角色必须使用相同的人工智能时。理想情况下，脚本文件的目的是为对象定义一个抽象公式或行为模式，该模式可以在所有可能的场景中成功地在许多类似的对象之间重用。要将脚本文件添加到对象上，只需将脚本从**Project**面板拖放到场景中的目标对象即可。脚本将以组件的形式实例化，并且其公共变量将在选择对象时在**Object
    Inspector**中可见，如下面的截图所示：
- en: '![Instantiating scripts](img/0655OT_01_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![实例化脚本](img/0655OT_01_05.jpg)'
- en: Attaching scripts onto game objects as components
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本作为组件附加到游戏对象上
- en: Variables are considered in more depth in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量将在下一节中做更深入的讨论。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on creating and using scripts in Unity can be found online
    at [http://docs.unity3d.com/412/Documentation/Manual/Scripting.html](http://docs.unity3d.com/412/Documentation/Manual/Scripting.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在线可以找到更多关于在Unity中创建和使用脚本的详细信息，请访问[http://docs.unity3d.com/412/Documentation/Manual/Scripting.html](http://docs.unity3d.com/412/Documentation/Manual/Scripting.html)。
- en: Variables
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Perhaps, the core concept in programming and in C# is the variable. Variables
    often correspond to the letters used in algebra and stand in for numerical quantities,
    such as *X*, *Y*, and *Z* and *a*, *b*, and *c*. If you need to keep track of
    information, such as the player name, score, position, orientation, ammo, health,
    and a multitude of other types of quantifiable data (expressed by nouns), then
    a variable will be your friend. A variable represents a single unit of information.
    This means that multiple variables are needed to hold multiple units, one variable
    for each. Further, each unit will be of a specific type or kind. For example,
    the player''s name represents a sequence of letters, such as "John", "Tom", and
    "David". In contrast, the player''s health refers to numerical data, such as 100
    percent (1) or 50 percent (0.5), depending on whether the player has sustained
    damage. So, each variable necessarily has a data type. In C#, variables are created
    using a specific kind of syntax or grammar. Consider the following code sample
    1-1 that defines a new script file and class called `MyNewScript`, which declares
    three different variables with class scope, each of a unique type. The word "declare"
    means that we, as programmers, are telling the C# compiler about the variables
    required:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程和 C# 中，核心概念可能是变量。变量通常对应于代数中使用的字母，并代表数值量，如 *X*、*Y*、*Z* 和 *a*、*b*、*c*。如果你需要跟踪信息，例如玩家名称、分数、位置、方向、弹药、健康以及众多其他可量化的数据类型（由名词表示），那么变量将是你的朋友。变量代表单个信息单位。这意味着需要多个变量来存储多个单位，每个变量对应一个。此外，每个单位都将具有特定的类型或种类。例如，玩家的名字代表一系列字母，如
    "John"、"Tom" 和 "David"。相比之下，玩家的健康指的是数值数据，如 100%（1）或 50%（0.5），这取决于玩家是否受到伤害。因此，每个变量必然有一个数据类型。在
    C# 中，变量使用特定的语法或语法创建。考虑以下代码示例 1-1，它定义了一个名为 `MyNewScript` 的新脚本文件和类，该类声明了三个具有类作用域的不同变量，每个变量具有唯一的数据类型。单词
    "声明" 的意思是我们，作为程序员，正在告诉 C# 编译器所需的变量：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Variable data types**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量数据类型**'
- en: 'Each variable has a data type. A few of the most common ones include `int`,
    `float`, `bool`, `string`, and `Vector3`. Here, are a few examples of these types:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个数据类型。其中一些最常见的数据类型包括 `int`、`float`、`bool`、`string` 和 `Vector3`。以下是一些这些类型的示例：
- en: '`int` (integer or whole number) = -3, -2, -1, 0, 1, 2, 3…'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`（整数或整个数字）= -3、-2、-1、0、1、2、3…'
- en: '`float` (floating point number or decimal) = -3.0, -2.5, 0.0, 1.7, 3.9…'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`（浮点数或小数）= -3.0、-2.5、0.0、1.7、3.9…'
- en: '`bool` (Boolean or `true`/`false`) = `true` or `false` (1 or 0)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`（布尔或 `true`/`false`）= `true` 或 `false`（1 或 0）'
- en: '`string` (string of characters) = "hello world", "a", "another word…"'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`（字符序列）= "hello world"、"a"、"another word…"'
- en: '`Vector3` (a position value) = (0, 0, 0), (10, 5, 0)…'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3`（位置值）= (0, 0, 0)、(10, 5, 0)…'
- en: Notice from lines 06-08 of code sample 1-1 that each variable is assigned a
    starting value, and its data type is explicitly stated as `int` (integer), `string`,
    and `Vector3`, which represent the points in a 3D space (as well as directions,
    as we'll see). There's no full list of possible data types, as this will vary
    extensively, depending on your project (and you'll also create your own!). Throughout
    this book, we'll work with the most common types, so you'll see plenty of examples.
    Finally, each variable declaration line begins with the keyword public. Usually,
    variables can be either `public` or `private` (and there is another one called
    `protected`, which is not covered here).The `public` variables will be accessible
    and editable in Unity's Object Inspector (as we'll see soon, you can also refer
    to the preceding screenshot), and they can also be accessed by other classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码示例 1-1 的第 06-08 行中可以看出，每个变量都被分配了一个起始值，并且其数据类型被明确声明为 `int`（整数）、`string` 和
    `Vector3`，它们代表 3D 空间中的点（以及我们将看到的方向）。没有可能的完整数据类型列表，因为这将根据你的项目而广泛变化（你也会创建自己的数据类型！）。在这本书的整个过程中，我们将使用最常见的数据类型，所以你会看到很多示例。最后，每个变量声明行都以关键字
    `public` 开头。通常，变量可以是 `public` 或 `private`（还有一个叫做 `protected` 的，这里没有涉及）。`public`
    变量将在 Unity 的对象检查器中可访问和可编辑（我们很快就会看到，你还可以参考前面的截图），并且其他类也可以访问它们。
- en: 'Variables are so named because their values might vary (or change) over time.
    Of course, they don''t change in arbitrary and unpredictable ways. Rather, they
    change whenever we explicitly change them, either through direct assignment in
    code, from the Object Inspector, or through methods and function calls. They can
    be changed both directly and indirectly. Variables can be assigned values directly,
    such as the following one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 变量之所以被这样命名，是因为它们的值可能会随时间变化（或改变）。当然，它们不会以任意和不可预测的方式改变。相反，它们会在我们明确更改它们时改变，无论是通过代码中的直接赋值、从对象检查器，还是通过方法和函数调用。它们可以直接和间接地改变。变量可以直接赋值，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'They can also be assigned indirectly using expressions, that is, statements
    whose final value must be evaluated before the assignment can be finally made
    to the variable as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以通过表达式间接赋值，即，最终值必须在赋值最终完成到变量之前评估的语句，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Variable scope**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量作用域**'
- en: Each variable is declared with an implicit scope. The scope determines the lifetime
    of a variable, that is, the places inside a source file where a variable can be
    successfully referenced and accessed. Scope is determined by the place where the
    variable is declared. The variables declared in code sample 1-1 have class scope,
    because they are declared at the top of a class and outside any functions. This
    means they can be accessed everywhere throughout the class, and (being public)
    they can also be accessed from other classes. Variables can also be declared inside
    specific functions. These are known as local variables, because their scope is
    restricted to the function, that is, a local variable cannot be accessed outside
    the function in which it was declared. Classes and functions are considered later
    in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都使用隐式作用域声明。作用域决定了变量的生命周期，即，在源文件内可以成功引用和访问变量的地方。作用域由变量声明的位置决定。代码示例 1-1 中声明的变量具有类作用域，因为它们是在类的顶部声明的，并且在任何函数之外。这意味着它们可以在整个类中访问，并且（因为是公共的）也可以从其他类中访问。变量也可以在特定的函数内部声明。这些被称为局部变量，因为它们的作用域限制在函数内，即，局部变量不能在其声明的函数外部访问。类和函数将在本章的后面讨论。
- en: More information on variables and their usage in C# can be found at [http://msdn.microsoft.com/en-us/library/aa691160%28v=vs.71%29.aspx](http://msdn.microsoft.com/en-us/library/aa691160%28v=vs.71%29.aspx).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量及其在 C# 中的使用的更多信息，请参阅[http://msdn.microsoft.com/en-us/library/aa691160%28v=vs.71%29.aspx](http://msdn.microsoft.com/en-us/library/aa691160%28v=vs.71%29.aspx)。
- en: Conditional statements
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Variables change in potentially many different circumstances: when the player
    changes their position, when enemies are destroyed, when the level changes, and
    so on. Consequently, you''ll frequently need to check the value of a variable
    to branch the execution of your scripts that perform different sets of actions,
    depending on the value. For example, if `PlayerHealth` reaches 0 percent, you''ll
    perform a death sequence, but if `PlayerHealth` is at 20 percent, you might only
    display a warning message. In this specific example, the `PlayerHealth` variable
    drives the script in a specified direction. C# offers two main conditional statements
    to achieve a program branching like this. These are the `if` statement and the
    `Switch` statement. Both are highly useful.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可能在许多不同的情况下发生变化：当玩家改变他们的位置，当敌人被摧毁，当关卡改变，等等。因此，你将经常需要检查变量的值，以便根据值分支执行你的脚本，执行不同的动作集。例如，如果
    `PlayerHealth` 达到 0%，你将执行死亡序列，但如果 `PlayerHealth` 在 20%，你可能只显示一个警告消息。在这个特定的例子中，`PlayerHealth`
    变量驱动脚本向指定的方向执行。C# 提供了两种主要的条件语句来实现这种程序分支。这些是 `if` 语句和 `Switch` 语句。两者都非常有用。
- en: The if statement
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The `if` statement has various forms. The most basic form checks for a condition
    and will perform a subsequent block of code if, and only if, that condition is
    `true`. Consider the following code sample 1-2:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句有多种形式。最基本的形式是检查一个条件，如果且仅当该条件为 `true` 时，将执行后续的代码块。考虑以下代码示例 1-2：'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code is executed like all other types of code in Unity, by pressing
    the **Play** button from the toolbar, as long as the script file has previously
    been instantiated on an object in the active scene. The `if` statement at line
    18 continually checks the `PlayerHealth` class variable for its current value.
    If the `PlayerHealth` variable is exactly equal to (`==`) `100`, then the code
    inside the `{}` braces (in lines 19–21) will be executed. This works because all
    conditional checks result in a Boolean value of either `true` or `false`; the
    conditional statement is really checked to see whether the queried condition (`PlayerHealth
    == 100`) is `true`. The code inside the braces can, in theory, span across multiple
    lines and expressions. However, here, there is just a single line in line 20:
    the `Debug.Log` Unity function outputs the **Player has full health** string to
    the console, as shown in the following screenshot. Of course, the `if` statement
    could potentially have gone the other way, that is, if `PlayerHealth` was not
    equal to `100` (perhaps, it was `99` or `101`), then no message would be printed.
    Its execution always depends on the previous `if` statement evaluating to `true`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与其他类型的Unity代码一样执行，通过从工具栏中按下**播放**按钮，只要脚本文件之前已经在活动场景中的对象上实例化。第18行的`if`语句持续检查`PlayerHealth`类变量的当前值。如果`PlayerHealth`变量正好等于（`==`）`100`，则在大括号`{}`（第19-21行）内的代码将被执行。这是因为所有条件检查都会产生`true`或`false`的布尔值；条件语句实际上检查查询的条件（`PlayerHealth
    == 100`）是否为`true`。理论上，大括号内的代码可以跨越多行和多个表达式。然而，在这里，第20行只有一行：`Debug.Log` Unity函数将**玩家健康值满**字符串输出到控制台，如下面的屏幕截图所示。当然，`if`语句可能以另一种方式执行，即如果`PlayerHealth`不等于`100`（可能是`99`或`101`），则不会打印任何消息。它的执行始终取决于前面的`if`语句评估为`true`。
- en: '![The if statement](img/0655OT_01_06.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![if语句](img/0655OT_01_06.jpg)'
- en: The Unity Console is useful for printing and viewing debug messages
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Unity控制台对于打印和查看调试消息非常有用
- en: More information on the `if` statements, the `if-else` statement, and their
    usage in C# can be found online at [http://msdn.microsoft.com/en-GB/library/5011f09h.aspx](http://msdn.microsoft.com/en-GB/library/5011f09h.aspx).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在线可以找到有关C#中的`if`语句、`if-else`语句及其使用的更多信息，请访问[http://msdn.microsoft.com/en-GB/library/5011f09h.aspx](http://msdn.microsoft.com/en-GB/library/5011f09h.aspx)。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Unity Console**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity控制台**'
- en: As you can see in the preceding screenshot, the console is a debugging tool
    in Unity. It's a place where messages can be printed from the code using the `Debug.Log`
    statement (or the `Print` function) to be viewed by developers. They are helpful
    to diagnose issues at runtime and compile time. If you get a compile time or runtime
    error, it should be listed in the **Console** tab. The **Console** tab should
    be visible in the Unity Editor by default, but it can be displayed manually by
    selecting **Console** in the **Window** menu from the Unity application file menu.
    More information on the `Debug.Log` function can be found at [http://docs.unity3d.com/ScriptReference/Debug.Log.html](http://docs.unity3d.com/ScriptReference/Debug.Log.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，控制台是Unity中的一个调试工具。这是一个可以通过`Debug.Log`语句（或`Print`函数）从代码中打印消息的地方，以便开发者查看。它们有助于在运行时和编译时诊断问题。如果您遇到编译时或运行时错误，它应该列在**控制台**选项卡中。默认情况下，**控制台**选项卡在Unity编辑器中应该是可见的，但可以通过从Unity应用程序文件菜单中选择**窗口**菜单中的**控制台**来手动显示。有关`Debug.Log`函数的更多信息，请访问[http://docs.unity3d.com/ScriptReference/Debug.Log.html](http://docs.unity3d.com/ScriptReference/Debug.Log.html)。
- en: 'You can, of course, check for more conditions than just equality (`==`), as
    we did in code sample 1-2\. You can use the `>` and `<` operators to check whether
    a variable is greater than or less than another value, respectively. You can also
    use the `!=` operator to check whether a variable is not equal to another value.
    Further, you can even combine multiple conditional checks into the same `if` statement
    using the `&&` (AND) operator and the `||` (OR) operator. For example, check out
    the following `if` statement. It performs the code block between the `{}` braces
    only if the `PlayerHealth` variable is between `0` and `100` and is not equal
    to `50`, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您当然可以检查比仅仅等于（`==`）更多的条件，就像我们在代码示例1-2中所做的那样。您可以使用`>`和`<`运算符来检查一个变量是否大于或小于另一个值。您还可以使用`!=`运算符来检查一个变量是否不等于另一个值。此外，您甚至可以使用`&&`（AND）运算符和`||`（OR）运算符将多个条件检查组合到同一个`if`语句中。例如，查看以下`if`语句。它仅在`PlayerHealth`变量在`0`到`100`之间且不等于`50`的情况下执行大括号`{}`之间的代码块，如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The if-else statement**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**`if-else` 语句**'
- en: 'One variation of the `if` statement is the `if-else` statement. The `if` statement
    performs a code block if its condition evaluates to `true`. However, the `if-else`
    statement extends this. It would perform an `X` code block if its condition is
    `true` and a `Y` code block if its condition is `false`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句的一种变体是 `if-else` 语句。如果 `if` 语句的条件评估为 `true`，则执行代码块。然而，`if-else` 语句扩展了这一点。如果其条件为
    `true`，则执行 `X` 代码块；如果条件为 `false`，则执行 `Y` 代码块：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The switch statement
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: 'As we''ve seen, the `if` statement is useful to determine whether a single
    and specific condition is `true` or `false` and to perform a specific code block
    on the basis of this. The `switch` statement, in contrast, lets you check a variable
    for multiple possible conditions or states, and then lets you branch the program
    in one of many possible directions, not just one or two as is the case with `if`
    statements. For example, if you''re creating an enemy character that can be in
    one of the many possible states of action (`CHASE`, `FLEE`, `FIGHT`, `HIDE`, and
    so on), you''ll probably need to branch your code appropriately to handle each
    state specifically. The `break` keyword is used to exit from a state returning
    to the end of the `switch` statement. The following code sample 1-3 handles a
    sample enemy using enumerations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`if` 语句用于确定单个特定条件是 `true` 还是 `false`，并根据此执行特定的代码块。相比之下，`switch` 语句允许您检查变量的多个可能条件或状态，然后允许您根据许多可能的方向之一分支程序，而不仅仅是
    `if` 语句中的一个或两个方向。例如，如果您正在创建一个可以处于许多可能动作状态之一（`CHASE`、`FLEE`、`FIGHT`、`HIDE` 等）的敌人角色，您可能需要适当地分支代码以处理每个状态。`break`
    关键字用于退出状态，返回到 `switch` 语句的末尾。以下代码示例 1-3 使用枚举处理了一个示例敌人：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Enumerations**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**'
- en: This line 07 in code sample 1-3 declares an enumeration (enum) named `EnemyState`.
    An enum is a special structure used to store a range of potential values for one
    or more other variables. It's not a variable itself per se, but a way of specifying
    the limits of values that a variable might have. In code sample 1-3, the `ActiveState`
    variable declared in line 10 makes use of `EnemyState`. Its value can be any valid
    value from the `ActiveState` enumeration. Enums are a great way of helping you
    validate your variables, limiting their values within a specific range and series
    of options.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例 1-3 中的第 07 行声明了一个名为 `EnemyState` 的枚举（enum）。枚举是一种特殊结构，用于存储一个或多个其他变量的潜在值范围。它本身不是一个变量，而是一种指定变量可能具有的值范围的方式。在代码示例
    1-3 中，第 10 行声明的 `ActiveState` 变量使用了 `EnemyState`。它的值可以是 `ActiveState` 枚举中的任何有效值。枚举是帮助您验证变量、限制它们在特定范围和一系列选项中的值的一种很好的方式。
- en: 'Another great benefit of enums is that variables based on them have their values
    appear as selectable options from drop-down boxes in the Object Inspector, as
    shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的另一个巨大好处是，基于它们的变量在对象检查器中显示为可选择的选项，如下面的截图所示：
- en: '![The switch statement](img/0655OT_01_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![`switch` 语句](img/0655OT_01_07.jpg)'
- en: Enumerations offer you drop-down options for your variables from the Object
    Inspector
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举为您在对象检查器中提供了变量下拉选项
- en: More information on enums and their usage in C# can be found online at [http://msdn.microsoft.com/en-us/library/sbbt4032.aspx](http://msdn.microsoft.com/en-us/library/sbbt4032.aspx).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在线可以找到有关枚举及其在 C# 中使用的更多信息，请访问 [http://msdn.microsoft.com/en-us/library/sbbt4032.aspx](http://msdn.microsoft.com/en-us/library/sbbt4032.aspx)。
- en: 'The following are the comments for code sample 1-3:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 1-3 的注释：
- en: '**Line 20**: The `switch` statement begins. Parentheses, `()`, are used to
    select the variable whose value or state must be checked. In this case, the `ActiveState`
    variable is being queried.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 20 行**: `switch` 语句开始。括号 `()` 用于选择需要检查其值或状态的变量。在这种情况下，正在查询 `ActiveState`
    变量。'
- en: '**Line 22**: The first case statement is made inside the `switch` statement.
    The following block of code (lines 24 and 25) will be executed if the `ActiveState`
    variable is set to `EnemyState.Fight`. Otherwise, the code will be ignored.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 22**: 第一个 case 语句是在 `switch` 语句内部做出的。如果 `ActiveState` 变量被设置为 `EnemyState.Fight`，则以下代码块（第
    24 和 25 行）将被执行。否则，代码将被忽略。'
- en: '**Lines 30 and 31**: Here, two case statements follow one another. The code
    block in lines 33 and 34 will be executed if, and only if, `ActiveState` is either
    `EnemyState.Flee` or `EnemyState.Hide`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 30 和 31 行**: 在这里，两个 case 语句依次出现。如果 `ActiveState` 是 `EnemyState.Flee` 或
    `EnemyState.Hide`，则第 33 和 34 行的代码块将被执行。'
- en: '**Line 38**: The default statement is optional for a `switch` statement. When
    included, it will be entered if no other case statements are `true`. In this case,
    it would apply if `ActiveState` is `EnemyState.Chase`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第38行**：对于`switch`语句，默认语句是可选的。当包含时，如果没有其他情况语句为`true`，它将被进入。在这种情况下，如果`ActiveState`是`EnemyState.Chase`，它将适用。'
- en: '**Lines 27, 36, and 44**: The `break` statement should occur at the end of
    a case statement. When it is reached, it will exit the complete `switch` statement
    to which it belongs, resuming program execution in the line after the `switch`
    statement, in this case, line 45.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第27、36和44行**：`break`语句应出现在情况语句的末尾。当它被达到时，它将退出它所属的完整`switch`语句，然后从`switch`语句之后的行恢复程序执行，在这种情况下，是第45行。'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `switch` statement and its usage in C# can be found
    at [http://msdn.microsoft.com/en-GB/library/06tc147t.aspx](http://msdn.microsoft.com/en-GB/library/06tc147t.aspx).
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于`switch`语句及其在C#中的使用的更多信息，可以在[http://msdn.microsoft.com/en-GB/library/06tc147t.aspx](http://msdn.microsoft.com/en-GB/library/06tc147t.aspx)找到。
- en: Arrays
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Lists and sequences are everywhere in games. For this reason, you''ll frequently
    need to keep track of lists of data of the same type: all enemies in the level,
    all weapons that have been collected, all power ups that could be collected, all
    spells and items in the inventory, and so on. One type of list is the array. Each
    item in the array is, essentially, a unit of information that has the potential
    to change during gameplay, and so a variable is suitable to store each item. However,
    it''s useful to collect together all the related variables (all enemies, all weapons,
    and so on) into a single, linear, and traversable list structure. This is what
    an array achieves. In C#, there are two kinds of arrays: static and dynamic. Static
    arrays might hold a fixed and maximum number of possible entries in memory, decided
    in advance, and this capacity remains unchanged throughout program execution,
    even if you only need to store fewer items than the capacity. This means some
    slots or entries could be wasted. Dynamic arrays might grow and shrink in capacity,
    on demand, to accommodate exactly the number of items required. Static arrays
    typically perform better and faster, but dynamic arrays feel cleaner and avoid
    memory wastage. This chapter considers only static arrays, and dynamic arrays
    are considered later, as shown in the following code sample 1-4:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和序列在游戏中无处不在。因此，你经常会需要跟踪同一类型的数据列表：关卡中的所有敌人、收集到的所有武器、可能收集到的所有升级、库存中的所有法术和物品等等。列表的一种类型是数组。本质上，数组中的每个项目都是一个信息单元，在游戏过程中可能发生变化，因此变量适合存储每个项目。然而，将所有相关变量（所有敌人、所有武器等等）收集到一个单一、线性且可遍历的列表结构中是有用的。这正是数组所实现的。在C#中，有两种类型的数组：静态和动态。静态数组可能在内存中保留一个固定和最大的可能条目数，这是预先决定的，并且在整个程序执行过程中，即使你只需要存储少于容量数的项目，这个容量也不会改变。这意味着一些槽位或条目可能会被浪费。动态数组可以根据需要增长和缩小容量，以适应所需的确切项目数。静态数组通常性能更好且速度更快，但动态数组看起来更整洁，避免了内存浪费。本章仅考虑静态数组，动态数组将在后续章节中讨论，如下面的代码示例1-4所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In code sample 1-4, line 07 declares a completely empty array of `GameObjects`,
    named `MyObjects`. To create this, it uses the `[]` syntax after the data type
    `GameObject` to designate an array, that is, to signify that a list of `GameObjects`
    is being declared as opposed to a single `GameObject`. Here, the declared array
    will be a list of all objects in the scene. It begins empty, but you can use the
    Object Inspector in the Unity Editor to build the array manually by setting its
    maximum capacity and populating it with any objects you need. To do this, select
    the object to which the script is attached in the scene and type in a **Size**
    value for the **My Objects** field to specify the capacity of the array. This
    should be the total number of objects you want to hold. Then, simply drag-and-drop
    objects individually from the scene hierarchy panel into the array slots in the
    Object Inspector to populate the list with items, as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例1-4中，第07行声明了一个完全空的`GameObjects`数组，命名为`MyObjects`。为了创建这个数组，它在`GameObject`数据类型之后使用`[]`语法来指定一个数组，即表示正在声明一个`GameObjects`列表，而不是单个`GameObject`。在这里，声明的数组将是场景中所有对象的列表。它开始是空的，但你可以使用Unity编辑器中的对象检查器手动构建数组，通过设置其最大容量并用所需的任何对象填充它。为此，在场景中选择附加脚本的对象，并在`My
    Objects`字段中输入一个**大小**值来指定数组的容量。这应该是你想要持有的对象总数。然后，只需将场景层次结构面板中的对象单独拖放到对象检查器中的数组槽位中，以用项目填充列表，如图所示：
- en: '![Arrays](img/0655OT_01_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![数组](img/0655OT_01_08.jpg)'
- en: Building arrays from the Unity Object Inspector
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unity对象检查器构建数组
- en: 'You can also build the array manually in code via the `Start` function instead
    of using the Object Inspector. This ensures that the array is constructed as the
    level begins. Either method works fine, as shown in the following code sample
    1-5:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过 `Start` 函数手动在代码中构建数组，而不是使用对象检查器。这确保了数组在级别开始时构建。两种方法都很好，如下面的代码示例1-5所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are the comments for code sample 1-5:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例1-5的注释：
- en: '**Line 10**: The `Start` function is executed at level startup. Functions are
    considered in more depth later in this chapter.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10行**: `Start` 函数在启动级别执行。函数将在本章后面更深入地讨论。'
- en: '**Line 13**: The `new` keyword is used to create a new array with a capacity
    of three. This means that the list can hold no more than three elements at any
    one time. By default, all elements are set to the starting value of `null` (meaning
    nothing). They are empty.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第13行**: 使用 `new` 关键字创建一个容量为三个的新数组。这意味着列表在任何时候都不能容纳超过三个元素。默认情况下，所有元素都设置为起始值
    `null`（表示无内容）。它们是空的。'
- en: '**Line 15**: Here, the first element in the array is set to the main camera
    object in the scene. Two important points should be noted here. First, elements
    in the array can be accessed using the array subscript operator `[]`. Thus, the
    first element of `MyObjects` can be accessed with `MyObjects[0]`. Second, C# arrays
    are "zero indexed". This means the first element is always at position `0`, the
    next is at `1`, the next at `2`, and so on. For the `MyObjects` three-element
    array, each element can be accessed with `MyObjects[0]`, `MyObjects[1]`, and `MyObjects[2]`.
    Notice that the last element is `2` and not `3`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第15行**: 在这里，数组中的第一个元素被设置为场景中的主相机对象。这里应该注意两个重要点。首先，可以使用数组索引运算符 `[]` 访问数组中的元素。因此，`MyObjects`
    的第一个元素可以通过 `MyObjects[0]` 访问。其次，C# 数组是“零索引”的。这意味着第一个元素始终位于位置 `0`，下一个位于 `1`，再下一个位于
    `2`，依此类推。对于 `MyObjects` 的三个元素数组，每个元素都可以通过 `MyObjects[0]`、`MyObjects[1]` 和 `MyObjects[2]`
    访问。请注意，最后一个元素是 `2` 而不是 `3`。'
- en: '**Lines 18 and 19**: Elements `1` and `2` of the `MyObjects` array are populated
    with objects using the function `GameObject.Find`. This searches the active scene
    for game objects with a specified name (case sensitive), inserting a reference
    to them at the specified element in the `MyObjects` array. If no object of a matching
    name is found, then `null` is inserted instead.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第18行和第19行**: 使用 `GameObject.Find` 函数在 `MyObjects` 数组的元素 `1` 和 `2` 中填充对象。这将在活动场景中搜索具有指定名称（区分大小写）的游戏对象，并在
    `MyObjects` 数组的指定元素中插入它们的引用。如果没有找到匹配名称的对象，则插入 `null`。'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on arrays and their usage in C# can be found online at [http://msdn.microsoft.com/en-GB/library/9b9dty7d.aspx](http://msdn.microsoft.com/en-GB/library/9b9dty7d.aspx).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在线可以找到有关数组和它们在C#中使用的更多信息，请参阅[http://msdn.microsoft.com/en-GB/library/9b9dty7d.aspx](http://msdn.microsoft.com/en-GB/library/9b9dty7d.aspx)。
- en: Loops
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Loops are one of the most powerful tools in programming. Imagine a game where
    the entire level can be nuked. When this happens, you'll want to destroy almost
    everything in the scene. Now, you can do this by deleting each and every object
    individually in code, one line at a time. If you did this, then a small scene
    with only a few objects would take just a few lines of code, and this wouldn't
    be problematic. However, for larger scenes with potentially hundreds of objects,
    you'd have to write a lot of code, and this code would need to be changed if you
    altered the contents of the scene. This would be tedious. Loops can simplify the
    process to just a few lines, regardless of scene complexity or object number.
    They allow you to repeatedly perform operations on potentially many objects. There
    are several kinds of loops in C#. Let's see some examples.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是编程中最强大的工具之一。想象一个整个关卡都可以被核爆的游戏。当这种情况发生时，您会希望销毁场景中的几乎所有内容。现在，您可以通过在代码中逐行删除每个对象来实现这一点。如果您这样做，那么只有几个对象的场景只需要几行代码，这不会成问题。然而，对于可能包含数百个对象的较大场景，您将不得不编写大量的代码，并且如果更改场景内容，则需要更改此代码。这将很繁琐。循环可以将过程简化为几行代码，无论场景复杂度或对象数量如何。它们允许您对可能许多对象重复执行操作。C#
    中有几种循环类型。让我们看看一些示例。
- en: The foreach loop
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foreach 循环
- en: 'Perhaps, the simplest loop type in C# is the `foreach` loop. Using `foreach`,
    you can cycle through every element in an array, sequentially from start to end,
    processing each item as required. Consider the following code sample 1-6; it destroys
    all `GameObjects` from a `GameObject` array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，在C#中最简单的循环类型就是`foreach`循环。使用`foreach`，你可以按顺序遍历数组中的每个元素，从开始到结束，按需处理每个项目。考虑以下代码示例1-6；它销毁了`GameObject`数组中的所有`GameObjects`：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Downloading the example code**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: The `foreach` loop repeats the code block `{}` between lines 14–17, once for
    each element in the array `MyObjects`. Each pass or cycle in the loop is known
    as an iteration. The loop depends on array size; this means that larger arrays
    require more iterations and more processing time. The loop also features a local
    variable `obj`. This is declared in the `foreach` statement in line 13\. This
    variable stands in for the selected or active element in the array as the loop
    passes each iteration, so `obj` represents the first element in the loop on the
    first iteration, the second element on the second iteration, and so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环重复第14-17行之间的代码块`{}`，对于数组`MyObjects`中的每个元素执行一次。循环的每次通过或循环称为一次迭代。循环依赖于数组大小；这意味着较大的数组需要更多的迭代和更多的时间。循环还包含一个局部变量`obj`。它在第13行的`foreach`语句中声明。当循环通过每个迭代时，这个变量代表数组中被选择或激活的元素，因此`obj`代表第一次迭代的第一个元素，第二次迭代的第二个元素，依此类推。'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `foreach` loop and its usage in C# can be found at [http://msdn.microsoft.com/en-GB/library/ttw7t8t6.aspx](http://msdn.microsoft.com/en-GB/library/ttw7t8t6.aspx).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中关于`foreach`循环及其使用的更多信息可以在[http://msdn.microsoft.com/en-GB/library/ttw7t8t6.aspx](http://msdn.microsoft.com/en-GB/library/ttw7t8t6.aspx)找到。
- en: The for loop
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `foreach` loop is handy when you need to iterate through a single array
    sequentially from start to end, processing each element one at a time. But sometimes
    you need more control over the iterations. You might need to process a loop backwards
    from the end to the start, you might need to process two arrays of equal length
    simultaneously, or you might need to process every alternate array element as
    opposed to every element. You can achieve this using the `for` loop, as shown
    here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要按顺序从开始到结束遍历单个数组时，`foreach`循环非常方便。但有时您需要对迭代有更多的控制。您可能需要从末尾到开始处理循环，您可能需要同时处理两个长度相等的数组，或者您可能需要处理每隔一个数组元素而不是每个元素。您可以使用`for`循环实现这一点，如下所示：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following are the comments for the preceding code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码片段的注释：
- en: Here, the `for` loop traverses the `MyObjects` array backwards from the end
    to the start, deleting each `GameObject` in the scene. It does this using a local
    variable `i`. This is sometimes known as an `Iterator` variable, because it controls
    how the loop progresses.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`for`循环从`MyObjects`数组的末尾开始向前遍历，删除场景中的每个`GameObject`。它使用局部变量`i`来完成这项工作。这有时也被称为`Iterator`变量，因为它控制着循环的进展。
- en: 'The `for` loop line has the following three main parts, each separated by a
    semicolon character:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环行有三个主要部分，每个部分由分号字符分隔：'
- en: '`i`: This is initialized to `MyObjects.Length – 1` (the last element in the
    array). Remember that arrays are zero-indexed, so the last element is always `Array
    Length -1`. This ensures that loop iteration begins at the array end.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：它初始化为`MyObjects.Length – 1`（数组的最后一个元素）。请记住，数组是零索引的，所以最后一个元素总是`Array Length
    -1`。这确保了循环迭代从数组的末尾开始。'
- en: '`i >= 0`: This expression indicates the condition when the loop should terminate.
    The `i` variable acts like a countdown variable, decrementing backwards through
    the array. In this case, the loop should end when `i` is no longer greater than
    or equal to `0`, because `0` represents the start of the array.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i >= 0`：这个表达式表示循环应该终止的条件。`i`变量像一个倒计时变量，通过数组向后递减。在这种情况下，当`i`不再大于或等于`0`时，循环应该结束，因为`0`代表数组的开始。'
- en: '`i--`: This expression controls how the variable `i` changes on each iteration
    of the loop moving from the array end to the beginning. Here, `i` will be decremented
    by one on each iteration, that is, a value of `1` will be subtracted from `i`
    on each pass of the loop. In contrast, the statement `++` will add `1`.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i--`: 这个表达式控制变量 `i` 在循环的每次迭代中如何变化，从数组末尾向开头移动。在这里，`i` 将在每次迭代中减一，也就是说，每次循环迭代都会从
    `i` 中减去一个值 `1`。相比之下，`++` 语句将添加 `1`。'
- en: During the loop, the expression `MyObjects[i]` is used to access array elements.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环期间，表达式 `MyObjects[i]` 用于访问数组元素。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on the `for` loop and its usage in C# can be found at [http://msdn.microsoft.com/en-gb/library/ch45axte.aspx](http://msdn.microsoft.com/en-gb/library/ch45axte.aspx).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `for` 循环及其在 C# 中的使用，更多信息可以在 [http://msdn.microsoft.com/en-gb/library/ch45axte.aspx](http://msdn.microsoft.com/en-gb/library/ch45axte.aspx)
    找到。
- en: The while loop
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: 'Both the `for` and `foreach` loops were especially useful when cycling through
    an array, performing specific operations on each iteration. The `while` loop,
    in contrast, is useful to continually repeat a specific behavior until a specified
    condition evaluates to `false`. For example, if you must deal damage to the player
    as long as they''re standing on hot lava or continually move a vehicle until the
    breaks are applied, then a `while` loop could be just what you need, as shown
    in the following code sample 1-7:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环和 `foreach` 循环在遍历数组时特别有用，在每次迭代上执行特定操作。相比之下，`while` 循环用于不断重复特定的行为，直到指定的条件评估为
    `false`。例如，如果你必须在对玩家造成伤害，只要他们站在热熔岩上，或者不断移动车辆直到刹车被应用，那么 `while` 循环可能正是你所需要的，如下面的代码示例
    1-7 所示：'
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**ToString**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**ToString**'
- en: Many classes and objects in Unity have a `ToString` function (see line 16 of
    code sample 1-7). This function converts the object, such as an integer (whole
    number), to a human-readable word or statement that can be printed to the **Console**
    or **Debugging** window. This is useful for printing objects and data to the console
    when debugging. Note that converting numerical objects to strings requires an
    implicit conversion.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的许多类和对象都有一个 `ToString` 函数（参见代码示例 1-7 的第 16 行）。这个函数将对象，例如整数（整数），转换为人类可读的单词或语句，可以打印到
    **控制台** 或 **调试** 窗口。这在调试时将对象和数据打印到控制台时非常有用。请注意，将数值对象转换为字符串需要隐式转换。
- en: 'The following are the comments for code sample 1-7:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 1-7 的注释：
- en: Line 13 begins the `while` loop with the condition that it repeats until the
    integer variable `NumberOfMessages` exceeds or equals 5
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 13 行开始 `while` 循环，条件是它重复执行，直到整数变量 `NumberOfMessages` 大于或等于 5
- en: The code block between lines 15 and 19 is repeated as the body of the `while`
    loop
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块在第 15 行和第 19 行之间被重复用作 `while` 循环的主体
- en: Line 19 increments the variable `NumberOfMessages` on each iteration
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 19 行在每次迭代中增加变量 `NumberOfMessages`
- en: 'The result of code sample 1-7, when executed in the game mode, will be to print
    five text messages to the Unity Console when the level begins, as shown in the
    following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当在游戏模式下执行代码示例 1-7 的结果时，会在关卡开始时将五条文本消息打印到 Unity 控制台，如下面的截图所示：
- en: '![The while loop](img/0655OT_01_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![while 循环](img/0655OT_01_09.jpg)'
- en: Printing messages to Console in a while loop
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中打印消息到控制台
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on the `while` loop and its usage in C# can be found at [http://msdn.microsoft.com/en-gb/library/2aeyhxcd.aspx](http://msdn.microsoft.com/en-gb/library/2aeyhxcd.aspx).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `while` 循环及其在 C# 中的使用，更多信息可以在 [http://msdn.microsoft.com/en-gb/library/2aeyhxcd.aspx](http://msdn.microsoft.com/en-gb/library/2aeyhxcd.aspx)
    找到。
- en: Infinite loops
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环
- en: 'One danger of using loops, especially `while` loops, is to accidentally create
    an infinite loop, that is, a loop that cannot end. If your game enters an infinite
    loop, it will normally freeze, perhaps permanently, requiring you to force a quit
    by terminating the application or even worse, causing a complete system crash!
    Often, Unity will catch the problem and exit but don''t rely on this. For example,
    removing line 19 of the code sample 1-7 would create an infinite loop because
    the `NumberOfMessages` variable will never increment to a level that satisfies
    the `while` loop condition, thereby causing an exit. The message of this section,
    then, is first and foremost, "Take care when writing and planning loops to avoid
    infinite loops." The following is another classic example of an infinite loop
    that will certainly cause problems for your game, so be sure to avoid them:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环的一个危险，尤其是 `while` 循环，是意外创建一个无限循环，即一个无法结束的循环。如果你的游戏进入无限循环，它通常会冻结，可能是永久性的，需要你通过终止应用程序来强制退出！通常，Unity
    会捕捉到这个问题并退出，但不要依赖这一点。例如，删除代码示例 1-7 中的第 19 行将创建一个无限循环，因为 `NumberOfMessages` 变量永远不会增加到满足
    `while` 循环条件的水准，从而引起退出。本节的要点首先是，“在编写和规划循环时要小心，以避免无限循环。”以下是一个经典的无限循环示例，它肯定会给你的游戏带来问题，所以请务必避免它们：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, believe it or not, there are times when infinite loops are technically
    what you need for your game under the right conditions! If you need a moving platform
    to travel up and down endlessly, a magical orb to continually spin round and round,
    or a day-night cycle to perpetually repeat, then an infinite loop can be serviceable,
    provided it's implemented appropriately. Later in this book, we'll see examples
    where infinite loops can be put to good use. Loops are powerful, fun structures,
    but when coded inappropriately, whether infinite or not, they can be the source
    of crashes, stalls, and performance issues, so take care. In this book, we'll
    see good practices for creating loops.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，信不信由你，在某些条件下，无限循环实际上可能是你游戏所需要的！如果你需要一个可以无限上下移动的平台，一个不断旋转的魔法球，或者一个永无止境的昼夜循环，那么无限循环可能是可用的，只要它被适当地实现。在本书的后续部分，我们将看到无限循环如何被良好地利用。循环是强大而有趣的构造，但如果不恰当地编写，无论是无限循环还是非无限循环，都可能是崩溃、停滞和性能问题的来源，所以请小心。在本书中，我们将看到创建循环的良好实践。
- en: Functions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'We already used functions in this chapter, such as the `Start` and `Update`
    functions. However, now, it''s time to consider them more formally and precisely.
    In essence, a function is a collection of statements bundled together as a single,
    identifiable block, which is given a collective name and can be executed on demand,
    each line of the function being executed in sequence. When you think about the
    logic of your game, there are times when you need to perform some operations repeatedly
    on your objects, such as, firing a weapon, jumping in the air, killing enemies,
    updating the score, and playing a sound. You can copy and paste your code throughout
    the source file, wherever you need to reuse it; this is not a good habit to cultivate.
    It''s easier to consolidate the recyclable code into a function that can be executed
    by a name when you need it, as shown in the following code sample 1-8:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经使用了函数，例如 `Start` 和 `Update` 函数。然而，现在，我们需要更正式和精确地考虑它们。本质上，一个函数是一系列语句的组合，作为一个单一的、可识别的块，被赋予一个集体名称，可以在需要时执行，函数中的每一行按顺序执行。当你思考你游戏的逻辑时，有时你需要对你的对象重复执行某些操作，例如，开火、跳跃、杀死敌人、更新分数和播放声音。你可以在源文件中复制和粘贴你的代码，无论你需要在哪里重用它；这不是一个应该培养的好习惯。将可重用的代码合并到一个函数中，当你需要时可以通过名称来执行它，这比在源文件中复制粘贴代码要容易得多，如下面的代码示例
    1-8 所示：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the breakdown of the code present for code sample 1-8:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码示例 1-8 中现有代码的分解：
- en: '**Line 08**: A private, integer class variable `Score` is declared to keep
    track of a sample score value. This variable will be used later in the function
    `UpdateScore`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 08**：声明了一个私有的整型类变量 `Score`，用于跟踪样本分数值。这个变量将在后续的 `UpdateScore` 函数中使用。'
- en: '**Lines 11, 23, and 28**: The class `MyScriptFile` has three functions (sometimes
    called methods or member functions). These are `Start`, `Update`, and `UpdateScore`.
    `Start` and `Update` are special functions that Unity provides, as we''ll see
    shortly. `UpdateScore` is a custom function for `MyScriptFile`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11行、第23行和第28行**: 类 `MyScriptFile` 有三个函数（有时也称为方法或成员函数）。这些是 `Start`、`Update`
    和 `UpdateScore`。`Start` 和 `Update` 是Unity提供的特殊函数，我们将在稍后看到。`UpdateScore` 是 `MyScriptFile`
    的自定义函数。'
- en: '**Line 28**: The `UpdateScore` function represents a complete block of code
    between lines 29 and 38\. This specific function should be invoked every time
    the game score must change. When called, the code block (lines 29–38) will be
    executed sequentially. In this way, functions offer us code recyclability.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第28行**: `UpdateScore` 函数代表从第29行到第38行之间的一个完整的代码块。这个特定的函数应该在游戏分数必须更改时每次被调用。当被调用时，代码块（第29-38行）将按顺序执行。通过这种方式，函数为我们提供了代码的可复用性。'
- en: '**Lines 14-19**: The `UpdateScore` function is called several times during
    the `Start` function. For each call, the execution of the `Start` function pauses
    until the `UpdateScore` function completes. At this point, the execution resumes
    in the next line.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第14-19行**: 在 `Start` 函数中，`UpdateScore` 函数被多次调用。对于每次调用，`Start` 函数的执行将暂停，直到
    `UpdateScore` 函数完成。此时，执行将从下一行继续。'
- en: '**Line 28**: `UpdateScore` accepts two parameters or arguments. These are an
    integer `AmountToAdd` and a Boolean `PrintToConsole`. Arguments act like inputs
    we can plug in to the function to affect how they operate. The `AmountToAdd` variable
    expresses how much should be added to the current `Score` variable, and `PrintToConsole`
    determines whether the `Score` variable should be shown in the **Console** window
    when the function is executed. There is theoretically no limit to the number of
    arguments a function can have, and a function can also have no arguments at all,
    such as the `Start` and `Update` functions.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第28行**: `UpdateScore` 接受两个参数或参数。这些是一个整数 `AmountToAdd` 和一个布尔值 `PrintToConsole`。参数就像我们可以插入到函数中以影响其操作的输入。`AmountToAdd`
    变量表示应该添加到当前 `Score` 变量的数值，而 `PrintToConsole` 决定在函数执行时是否应该在 **Console** 窗口中显示 `Score`
    变量。理论上，函数可以有的参数数量没有限制，一个函数也可以没有任何参数，例如 `Start` 和 `Update` 函数。'
- en: '**Lines 31–34**: Here, the score is actually updated and printed to **Console**,
    if required. Notice that the `PrintToConsole` argument has a default value of
    `true` already assigned to the function declaration in line 28\. This makes the
    argument optional whenever the function is called. Lines 14, 15, and 16 explicitly
    override the default value by passing a value of `false`. Line 19, in contrast,
    omits a second value and thereby accepts the default of `true`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第31-34行**: 在这里，分数实际上被更新并打印到 **Console**，如果需要的话。注意，`PrintToConsole` 参数在行28的函数声明中已经分配了一个默认值
    `true`。这使得在调用函数时参数是可选的。第14、15和16行明确地通过传递一个值为 `false` 来覆盖默认值。相比之下，第19行省略了第二个值，因此接受默认的
    `true`。'
- en: '**Lines 28 and 37**: The `UpdateScore` function has a return value, which is
    a data type specified in line 28 before the function name. Here, the value is
    an `int`. This means on exiting or completion, the function will output an integer.
    The integer, in this case, will be the current `Score`. This is actually output
    in line 37 using the `return` statement. Functions don''t have to return a value,
    it''s not essential. If no return value is needed, the return type should be `void`
    as with `Start` and `Update`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第28行和第37行**: `UpdateScore` 函数有一个返回值，这是一个在函数名之前第28行指定的数据类型。在这里，值是一个 `int`。这意味着在退出或完成时，函数将输出一个整数。在这种情况下，这个整数将是当前的
    `Score`。实际上，这是在第37行使用 `return` 语句输出的。函数不一定要返回一个值，这不是必需的。如果不需要返回值，返回类型应该是 `void`，就像
    `Start` 和 `Update` 一样。'
- en: Tip
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on functions and their usage in C# can be found at [http://csharp.net-tutorials.com/basics/functions/](http://csharp.net-tutorials.com/basics/functions/).
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于函数及其在C#中的使用，更多信息可以在[http://csharp.net-tutorials.com/basics/functions/](http://csharp.net-tutorials.com/basics/functions/)找到。
- en: Events
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Events are essentially functions used in a distinctive way. Both the `Start`
    and `Update` functions, which we have already seen, would more accurately be described
    as Unity-specific events. Events are functions called to notify an object that
    something significant has happened: the level has begun, a new frame has started,
    an enemy has died, the player has jumped, and others. In being called at these
    critical times, they offer objects the chance to respond if necessary. The `Start`
    function is called automatically by Unity when the object is first created, typically
    at level startup. The `Update` function is also called automatically, once on
    each frame. The `Start` function, therefore, gives us an opportunity to perform
    specific actions when the level begins, and the `Update` function on each frame
    many times per second. The `Update` function is especially useful, therefore,
    to achieve motion and animation in your games. Refer to code sample 1-9, which
    rotates an object over time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 事件本质上是在特定方式下使用的函数。我们之前已经看到的`Start`和`Update`函数，更准确地描述应该是Unity特定的事件。事件是在某些关键时刻被调用的函数，用来通知一个对象发生了重要的事情：关卡开始，新帧开始，敌人死亡，玩家跳跃，以及其他情况。在这些关键时刻被调用，它们为对象提供了必要的响应机会。`Start`函数在对象首次创建时由Unity自动调用，通常在关卡启动时。`Update`函数也会自动调用，每帧调用一次。因此，`Start`函数为我们提供了在关卡开始时执行特定操作的机会，而`Update`函数每秒可以多次调用。因此，`Update`函数特别适用于在游戏中实现运动和动画。请参考代码示例1-9，它会在一段时间内旋转一个对象：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Line 15 in code sample 1-9 is called once per frame. It continually rotates
    an object 2 degrees around the *y* axis. This code is frame rate dependent, which
    means that it''ll turn objects faster when run on machines with higher frame rates,
    because `Update` will be called more often. There are techniques to achieve frame
    rate independence, ensuring that your games perform consistently across all machines,
    regardless of the frame rate. We''ll see these in the next chapter. You can easily
    check the frame rate for your game directly from the Unity Editor **Game** tab.
    Select the **Game** tab and click on the **Stats** button in the top-right hand
    corner of the toolbar. This will show the **Stats** panel, offering a general,
    statistical overview of the performance of your game. This panels displays the
    game **frames per second** (**FPS**), which indicates both how often `Update`
    is called on your objects and the general performance of your game on your system.
    In general, an FPS lower than 15 indicates a significant performance problem.
    Strive for FPS rates of 30 or above. Refer to the following screenshot to access
    the **Stats** panel:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例1-9的第15行每帧调用一次。它持续围绕*y*轴旋转对象2度。这段代码依赖于帧率，这意味着在帧率更高的机器上运行时，它会更快地旋转对象，因为`Update`会被更频繁地调用。有一些技术可以实现帧率无关性，确保你的游戏在所有机器上都能保持一致的性能，无论帧率如何。我们将在下一章中看到这些技术。你可以直接从Unity编辑器的**游戏**标签中轻松检查游戏的帧率。选择**游戏**标签，然后在工具栏右上角点击**统计信息**按钮。这将显示**统计信息**面板，提供游戏性能的一般统计概述。此面板显示游戏的**每秒帧数**（**FPS**），这表明了`Update`在对象上被调用的频率以及游戏在系统上的整体性能。一般来说，低于15的FPS表明存在重大的性能问题。努力实现30或更高的FPS。请参考以下截图以访问**统计信息**面板：
- en: '![Events](img/0655OT_01_10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![事件](img/0655OT_01_10.jpg)'
- en: Accessing the Stats panel for the Game tab to view FPS
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 访问游戏标签页的“统计信息”面板以查看每秒帧数（FPS）
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are too many event types to list comprehensively. However, some common
    events in Unity, such as `Start` and `Update`, can be found in the `MonoBehaviour`
    class. More information on `MonoBehaviour` is available at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型太多，无法一一列举。然而，在Unity中，一些常见的事件，如`Start`和`Update`，可以在`MonoBehaviour`类中找到。有关`MonoBehaviour`的更多信息，请参阅[http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html)。
- en: Classes and object-oriented programming
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和面向对象编程
- en: A class is an amalgam of many related variables and functions, all brought together
    into a self-contained unit or "thing". To put it another way, if you think about
    a game (such as a fantasy RPG), it's filled with many independent things such
    as wizards, orcs, trees, houses, the player, quests, inventory items, weapons,
    spells, doorways, bridges, force fields, portals, guards, and so on. Many of these
    objects parallel objects in the real world too. However, crucially, each of these
    things is an independent object; a wizard is different and separate from a force
    field, and a guard is different and separate from a tree. Each of these things,
    then, can be thought of as an object—a custom type. If we focus our attention
    on one specific object, an orc enemy, for example, we can identify the properties
    and behaviors in this object. The orc will have a position, rotation, and scale;
    these correspond to variables.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类是由许多相关变量和函数组成的混合体，所有这些都被组合成一个自包含的单元或“事物”。换句话说，如果你考虑一个游戏（例如幻想RPG），它充满了许多独立的事物，如法师、精灵、树木、房屋、玩家、任务、库存物品、武器、法术、门、桥梁、力场、传送门、守卫等等。其中许多对象与现实世界中的对象平行。然而，关键的是，这些事物中的每一个都是一个独立的对象；法师不同于力场，守卫不同于树木。然后，这些事物可以被视为对象——一个自定义类型。如果我们专注于一个特定的对象，例如一个精灵敌人，我们可以在该对象中识别出属性和行为。精灵将有一个位置、旋转和缩放；这些对应于变量。
- en: 'The orc might have several kinds of attacks too, such as a melee attack with
    an axe and a ranged attack with a crossbow. These attacks are performed through
    functions. In this way, a collection of variables and functions are brought together
    into a meaningful relationship. The process of bringing these things together
    is known as encapsulation. In this example, an orc has been encapsulated into
    a class. The class, in this case, represents the template for a general, abstract
    orc (the concept of an orc). Objects, in contrast, are particular, concrete instantiations
    of the `Orc` class in the level. In Unity, script files define a class. To instantiate
    the class as an object in the level, add it to `GameObject`. As we''ve seen, classes
    are attached to game objects as components. Components are objects, and multiple
    components together form a `GameObject`. Refer to code sample 1-10 for a sample
    `Orc` class stub:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵可能也有几种攻击方式，例如用斧头进行的近战攻击和用弩进行的远程攻击。这些攻击是通过函数来执行的。通过这种方式，一系列变量和函数被组合在一起，形成一个有意义的关联。将这些事物组合在一起的过程被称为封装。在这个例子中，精灵已经被封装成一个类。在这种情况下，这个类代表了一个通用、抽象的精灵（精灵的概念）。相比之下，对象是`Orc`类在关卡中的具体、实例化的体现。在Unity中，脚本文件定义了一个类。要将类作为关卡中的对象实例化，需要将其添加到`GameObject`中。正如我们所看到的，类作为组件附加到游戏对象上。组件是对象，多个组件组合在一起形成一个`GameObject`。请参考代码示例1-10，以获取一个示例`Orc`类框架：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following are the comments for code sample 1-10:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例1-10的注释：
- en: '**Line 04**: Here, the class `keyword` is used to define a class named `Orc`.
    This class derives from `MonoBehaviour`. The next section of this chapter will
    consider inheritance and derived classes further.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第04行**：在这里，使用`class`关键字定义了一个名为`Orc`的类。这个类继承自`MonoBehaviour`。下一节将更深入地探讨继承和派生类。'
- en: '**Lines 09-19**: Several variables and an enum are added to the `Orc` class.
    The variables are of different types, but all are related to the concept of an
    orc.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第09-19行**：在`Orc`类中添加了几个变量和一个枚举。这些变量的类型不同，但都与精灵的概念相关。'
- en: '**Lines 35-45**: The orc has two methods: `AttackMelee` and `AttackRange`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第35-45行**：精灵有两个方法：`AttackMelee`和`AttackRange`。'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on classes and their usage in C# can be found at [http://msdn.microsoft.com/en-gb/library/x9afc042.aspx](http://msdn.microsoft.com/en-gb/library/x9afc042.aspx).
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于类及其在C#中的使用的更多信息，请参阅[http://msdn.microsoft.com/en-gb/library/x9afc042.aspx](http://msdn.microsoft.com/en-gb/library/x9afc042.aspx)。
- en: Classes and inheritance
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和继承
- en: Imagine a scenario where you create an `Orc` class to encode an orc object in
    the game. Having done so, you then decide to make two upgraded types. One is an
    Orc Warlord, with better armor and weapons, and the other is an Orc Mage who,
    as the name implies, is a spell caster. Both can do everything that the ordinary
    orc can do, but more besides. Now, to implement this, you can create three separate
    classes, `Orc`, `OrcWarlord`, and `OrcMage`, by copying and pasting common code
    between them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你创建了一个 `Orc` 类来在游戏中编码一个兽人对象。完成之后，你决定创建两个升级类型。一个是兽人首领，拥有更好的盔甲和武器，另一个是兽人法师，正如其名所示，是一个施法者。两者都能做普通兽人能做的所有事情，但不仅如此。现在，为了实现这一点，你可以通过在它们之间复制和粘贴共同代码来创建三个单独的类，`Orc`、`OrcWarlord`
    和 `OrcMage`。
- en: The problem is that as Orc Warlord and Orc Mage share a lot of common ground
    and behaviors with orc, a lot of code will be wastefully copied and pasted to
    replicate the common behaviors. Furthermore, if you discovered a bug in the shared
    code of one class, you'd need to copy and paste the fix to the other classes to
    propagate it. This is both tedious and technically dangerous, as it risks wasting
    time, introducing bugs, and causing needless confusion. Instead, the object-oriented
    concept of inheritance can help us. Inheritance allows you to create a completely
    new class that implicitly absorbs or contains the functionality of another class,
    that is, it allows you to build a new class that extends an existing class without
    affecting the original one. When inheritance happens, two classes are brought
    into a relationship with each other. The original class (such as the `Orc` class)
    is known as the case class or ancestor class. The new class (such as the Orc Warlord
    or Orc Mage), which extends on the ancestor class, is called a super class or
    derived class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，由于兽人首领和兽人法师与兽人有很多共同的基础和行为，因此会浪费地复制和粘贴大量代码来复制这些共同行为。此外，如果你在某个类的共享代码中发现了错误，你需要将修复复制粘贴到其他类中，以传播它。这既麻烦又技术上危险，因为它可能会浪费时间，引入错误，并造成不必要的混淆。相反，面向对象的概念——继承可以帮助我们。继承允许你创建一个完全新的类，该类隐式地吸收或包含另一个类的功能，即它允许你创建一个扩展现有类的新类，而不会影响原始类。当发生继承时，两个类之间就建立了一种关系。原始类（如
    `Orc` 类）被称为案例类或祖先类。扩展祖先类的新类（如兽人首领或兽人法师），被称为超类或派生类。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on inheritance in C# can be found at [http://msdn.microsoft.com/en-gb/library/ms173149%28v=vs.80%29.aspx](http://msdn.microsoft.com/en-gb/library/ms173149%28v=vs.80%29.aspx).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中有关继承的更多信息可以在 [http://msdn.microsoft.com/en-gb/library/ms173149%28v=vs.80%29.aspx](http://msdn.microsoft.com/en-gb/library/ms173149%28v=vs.80%29.aspx)
    找到。
- en: 'By default, every new Unity script file creates a new class derived from `MonoBehaviour`.
    This means every new script contains all the `MonoBehaviour` functionality and
    has the potential to go beyond, based on the additional code that you add. To
    prove this, refer to the following code sample 1-11:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个新的 Unity 脚本文件都会创建一个从 `MonoBehaviour` 继承的新类。这意味着每个新脚本都包含所有 `MonoBehaviour`
    功能，并且有可能根据你添加的额外代码进行扩展。为了证明这一点，请参考以下代码示例 1-11：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the comments for code sample 1-11:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 1-11 的注释：
- en: '**Line 04**: The class `NewScript` is derived from `MonoBehaviour`. You can,
    however, substitute `MonoBehaviour` for almost any valid class name from which
    you want to derive.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 04 行**: 类 `NewScript` 继承自 `MonoBehaviour`。然而，你可以用几乎任何有效的类名替换 `MonoBehaviour`，只要你想要从它那里继承。'
- en: '**Line 10**: Here, the variable name is assigned a string during the `Start`
    event. However, notice that the name is not explicitly declared as a variable
    anywhere in the `NewScript` source file. If `NewScript` were a completely new
    class with no ancestor defined in line 04, then line 10 would be invalid. However,
    because `NewScript` derives from `MonoBehaviour`, it automatically inherits all
    of its variables, allowing us to access and edit them from `NewScript`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 10 行**: 在 `Start` 事件中，变量名被赋予了一个字符串。但是，请注意，该名称在 `NewScript` 源文件的任何地方都没有明确声明为变量。如果
    `NewScript` 是一个完全新的类，且在第 04 行没有定义任何祖先，那么第 10 行将是无效的。然而，因为 `NewScript` 继承自 `MonoBehaviour`，它自动继承了所有变量，这使得我们能够从
    `NewScript` 中访问和编辑它们。'
- en: Note
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**When to inherit**'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**何时继承**'
- en: Only use inheritance where it's really appropriate; otherwise, you'll make your
    classes large, heavy, and confusing. If you're creating a class that shares a
    lot of common functionality with another and it makes sense to establish connection
    between them, then use inheritance. Another use of inheritance, as we'll see next,
    is when you want to override specific functions.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有在真正合适的情况下才使用继承；否则，你会使你的类变得庞大、笨重且难以理解。如果你正在创建一个与另一个类共享大量公共功能并且建立它们之间联系是有意义的类，那么请使用继承。继承的另一个用途，正如我们将看到的，是在你想覆盖特定函数时。
- en: Classes and polymorphism
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和多态性
- en: 'To illustrate polymorphism in C#, let''s start by considering the following
    code sample 1-12\. This sample doesn''t demonstrate polymorphism immediately but
    represents the start of a scenario where polymorphism will be useful, as we''ll
    see. Here, a basic skeleton class is defined for a potential **non-player character**
    (**NPC**) in a generic RPG game. The class is intentionally not comprehensive
    and features basic variables that only mark the starting point for a character.
    The most important thing here is that the class features a `SayGreeting` function,
    which should be invoked when the player engages the NPC in conversation. It displays
    a generic welcome message to **Console** as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明C#中的多态性，让我们首先考虑以下代码示例1-12。这个示例并不立即展示多态性，但它代表了多态性将变得有用的场景的开始，正如我们将看到的。在这里，为通用RPG游戏中的潜在**非玩家角色**（**NPC**）定义了一个基本的骨架类。这个类故意不是全面的，只包含标记角色起点的基本变量。这里最重要的是，该类具有一个`SayGreeting`函数，当玩家与NPC进行对话时应该调用它。它向**控制台**显示一个通用的欢迎消息，如下所示：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first problem to arise relates to the diversity and believability of the
    `MyCharacter` class if we try imagining how it''d really work in a game. Specifically,
    every character instantiated from `MyCharacter` will offer exactly the same greeting
    when `SayGreeting` is invoked: men, women, orcs, and everybody. They''ll all say
    the same thing, namely, `"Hello, my friend"`. This is neither believable nor desirable.
    Perhaps, the most elegant solution would be to just add a public string variable
    to the class, thus allowing customization over the message printed. However, to
    illustrate polymorphism clearly, let''s try a different solution. We could create
    several additional classes instead, all derived from `MyCharacter`, one for each
    new NPC type and each offering a unique greeting from a `SayGreeting` function.
    This is possible with `MyCharacter`, because `SayGreeting` has been declared using
    the virtual keyword (line 13). This allows derived classes to override the behavior
    of `SayGreeting` in the `MyCharacter` class. This means the `SayGreeting` function
    in derived classes will replace the behavior of the original function in the base
    class. Such a solution might look similar to the code sample 1-13:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个出现的问题与`MyCharacter`类的多样性和可信度有关，如果我们尝试想象它在游戏中的实际工作方式。具体来说，从`MyCharacter`实例化的每个角色在调用`SayGreeting`时都会提供完全相同的问候：男性、女性、兽人和所有人。他们都会说同样的话，即“你好，我的朋友”。这既不可信也不理想。也许，最优雅的解决方案就是给类添加一个公共字符串变量，从而允许对打印的消息进行定制。然而，为了清楚地说明多态性，让我们尝试一个不同的解决方案。我们可以创建几个额外的类，所有这些类都从`MyCharacter`派生而来，每个新NPC类型一个，每个都从`SayGreeting`函数提供独特的问候。这是可能的，因为`SayGreeting`已经使用虚拟关键字（第13行）声明。这允许派生类覆盖`MyCharacter`类中`SayGreeting`的行为。这意味着派生类中的`SayGreeting`函数将替换基类中原始函数的行为。这样的解决方案可能看起来类似于代码示例1-13：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this code, some improvement is made, that is, different classes are created
    for each NPC type, namely, `ManCharacter`, `WomanCharacter`, and `OrcCharacter`.
    Each offers a different greeting in the `SayGreeting` function. Further, each
    NPC inherits all the common behaviors from the shared base class `MyCharacter`.
    However, a technical problem regarding type specificity arises. Now, imagine creating
    a tavern location inside which there are many NPCs of the different types defined,
    so far, all enjoying a tankard of grog. As the player enters the tavern, all NPCs
    should offer their unique greeting. To achieve this functionality, it''d be great
    if we could have a single array of all NPCs and simply call their `SayGreeting`
    function from a loop, each offering their own greeting. However, it seems, initially,
    that we cannot do this. This is because all elements in a single array must be
    of the same data type, such as `MyCharacter[]` or `OrcCharacter[]`. We cannot
    mix types for the same array. We could, of course, declare multiple arrays for
    each NPC type, but this feels awkward and doesn''t easily allow for the seamless
    creation of more NPC types after the array code has been written. To solve this
    problem, we''ll need a specific and dedicated solution. This is where polymorphism
    comes to the rescue. Refer to the following sample 1-14, which defines a new `Tavern`
    class in a completely separate script file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，进行了一些改进，即为每种NPC类型创建不同的类，即`ManCharacter`、`WomanCharacter`和`OrcCharacter`。每个类在`SayGreeting`函数中提供不同的问候。此外，每个NPC从共享的基类`MyCharacter`继承所有共同的行为。然而，关于类型特定性的技术问题出现了。现在，想象一下在酒馆内部创建一个位置，其中有许多不同类型的NPC，到目前为止，他们都在享受一桶麦酒。当玩家进入酒馆时，所有NPC都应该提供他们独特的问候。为了实现这个功能，如果我们能够有一个包含所有NPC的单个数组，并简单地从循环中调用他们的`SayGreeting`函数，每个NPC提供他们自己的问候，那就太好了。然而，最初似乎不能这样做。这是因为单个数组中的所有元素必须是相同的数据类型，例如`MyCharacter[]`或`OrcCharacter[]`。我们不能在同一个数组中混合类型。当然，我们可以为每种NPC类型声明多个数组，但这感觉很不方便，并且不容易在编写数组代码后无缝创建更多NPC类型。为了解决这个问题，我们需要一个特定且专门的解决方案。这就是多态性发挥作用的地方。参考以下示例1-14，它在一个完全独立的脚本文件中定义了一个新的`Tavern`类：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following are the comments for code sample 1-14:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例1-14的注释：
- en: '**Line 07**: To keep track of all NPCs in the tavern, regardless of the NPC
    type, a single array (`Characters`) of type `MyCharacter` is declared.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第07行**: 为了跟踪酒馆中的所有NPC，无论NPC的类型如何，声明了一个类型为`MyCharacter`的单个数组（`Characters`）。'
- en: '**Lines 16-20**: The `Characters` array is populated with multiple NPCs of
    different types. This works because, though they are of different types, each
    NPC derives from the same base class.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第16-20行**: `Characters`数组被填充了多种不同类型的多个NPC。这是因为尽管它们属于不同的类型，但每个NPC都派生自同一个基类。'
- en: '**Line 27**: The `EnterTavern` function is called at level startup.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第27行**: 在等级启动时调用`EnterTavern`函数。'
- en: '**Line 34**: A `foreach` loop cycles through all NPCs in the `Characters` array,
    calling the `SayGreeting` function. The result is shown in the following screenshot.
    The unique messages for each NPC are printed instead of the generic message defined
    in the base class. Polymorphism allows the overridden method in the derived classes
    to be called instead.![Classes and polymorphism](img/0655OT_01_11.jpg)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第34行**: 一个`foreach`循环遍历`Characters`数组中的所有NPC，调用`SayGreeting`函数。结果如下面的截图所示。每个NPC的独特消息被打印出来，而不是基类中定义的通用消息。多态性允许在派生类中调用重写的方法。![类和多态](img/0655OT_01_11.jpg)'
- en: Polymorphism produces a backwards transparency between data types that share
    a common lineage
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多态性在共享共同血统的数据类型之间产生向后透明性
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on polymorphism in C# can be found at [http://msdn.microsoft.com/en-GB/library/ms173152.aspx](http://msdn.microsoft.com/en-GB/library/ms173152.aspx).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[C#中的多态性](http://msdn.microsoft.com/en-GB/library/ms173152.aspx)方面更多信息可以在此处找到。
- en: C# properties
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#属性
- en: 'When assigning values to class variables, such as `MyClass.x = 10;`, there
    are a couple of important things to take care of. First, you''ll typically want
    to validate the value being assigned, ensuring that the variable is always valid.
    Typical cases include clamping an integer between a minimum and maximum range
    or allowing only a limited set of strings for a string variable. Second, you might
    need to detect when a variable changes, initiating other dependent functions and
    behaviors. C# properties let you achieve both these features. Refer to the following
    code sample 1-15, which limits an integer between `1` and `10` and prints a message
    to the console whenever it changes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当将值赋给类变量，例如`MyClass.x = 10;`时，有几个重要的事项需要注意。首先，你通常会想要验证被赋予的值，确保变量始终有效。典型的情况包括将整数限制在最小和最大范围之间，或者只允许字符串变量具有有限的字符串集。其次，你可能需要检测变量何时发生变化，从而启动其他依赖函数和行为。C#属性让你实现这两个功能。参考以下代码示例1-15，它将整数限制在`1`和`10`之间，并在值发生变化时向控制台打印一条消息：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following are the comments for code sample 1-15:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例1-15的注释：
- en: '**Line 10**: A public integer property is declared. This property is not an
    independent variable but simply a `wrapper` and `accessor` interface for the private
    variable `iMyNumber`, declared in line 34.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10行**：声明了一个公共整数属性。这个属性不是一个独立的变量，而是一个`wrapper`和`accessor`接口，用于访问在第34行声明的私有变量`iMyNumber`。'
- en: '**Line 13**: When `MyNumber` is used or referenced, the internal `get` function
    is called.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第13行**：当使用或引用`MyNumber`时，会调用内部的`get`函数。'
- en: '**Line 14**: When `MyNumber` is assigned a value, the internal `set` function
    is called.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第14行**：当`MyNumber`被赋予一个值时，会调用内部的`set`函数。'
- en: '**Line 25**: The `set` function features an implicit argument value that represents
    the value to be assigned.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第25行**：`set`函数具有一个隐含的参数值，它代表要赋予的值。'
- en: '**Line 28**: The event `NumberChanged` is called when the `iMyNumber` variable
    is assigned a value.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第28行**：当`iMyNumber`变量被赋予一个值时，会调用`NumberChanged`事件。'
- en: Note
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Properties and Unity**'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**属性和Unity**'
- en: Properties are useful to validate and control the assignment of values to variables.
    The main problem with using them in Unity concerns their visibility in the Object
    Inspector. Specifically, C# properties are not shown in the Object Inspector.
    You can neither get nor set their values in the editor. However, community-made
    scripts and solutions are available that can change this default behavior, for
    example exposing C# properties. These scripts and solutions can be found at [http://wiki.unity3d.com/index.php?title=Expose_properties_in_inspector](http://wiki.unity3d.com/index.php?title=Expose_properties_in_inspector).
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性对于验证和控制变量值的赋值非常有用。在Unity中使用它们的主要问题在于它们在对象检查器中的可见性。具体来说，C#属性在对象检查器中不会显示。你既不能在编辑器中获取也不能设置它们的值。然而，社区制作的脚本和解决方案可以改变这种默认行为，例如暴露C#属性。这些脚本和解决方案可以在[http://wiki.unity3d.com/index.php?title=Expose_properties_in_inspector](http://wiki.unity3d.com/index.php?title=Expose_properties_in_inspector)找到。
- en: More information on **Properties** in C# can be found at [http://msdn.microsoft.com/en-GB/library/x9fsa0sw.aspx](http://msdn.microsoft.com/en-GB/library/x9fsa0sw.aspx).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#中**属性**的更多信息，可以在[http://msdn.microsoft.com/en-GB/library/x9fsa0sw.aspx](http://msdn.microsoft.com/en-GB/library/x9fsa0sw.aspx)找到。
- en: Commenting
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Commenting is the practice of inserting human readable messages into your code,
    purely for annotation, description, and to make things clearer to the reader.
    In C#, one-line comments are prefixed with the `//` symbol, and multiline comments
    begin with `/*` and end with `*/`. Comments are used throughout the code samples
    in this book. Comments are important, and I recommend that you get into the habit
    of using them if you''re not already in the habit. They benefit not only other
    developers in your team (if you work with others), but you too! They help remind
    you of what your code is doing when you return to it weeks or months later, and
    they even help you get clear and straight about the code you''re writing right
    now. Of course, all these benefits depend on you writing concise and meaningful
    comments and not long essays filled with irrelevance. However, MonoDevelop offers
    XML-based comments too to describe functions and arguments specifically and which
    integrates with code completion. It can significantly boost your workflow, especially
    when working in teams. Let''s see how to use this. Start by writing your function
    or any function, as shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是将可读性强的消息插入到你的代码中的实践，纯粹用于注释、描述，并使读者更清楚。在 C# 中，单行注释以 `//` 符号开头，多行注释以 `/*` 开头，以
    `*/` 结尾。本书中的代码示例中使用了注释。注释很重要，如果你还没有养成使用注释的习惯，我建议你养成这个习惯。它们不仅对团队中的其他开发者有益（如果你与他人一起工作），对你自己也有好处！它们有助于你在几周或几个月后再次回到代码时回忆起代码的功能，甚至有助于你清晰地了解你现在正在编写的代码。当然，所有这些好处都取决于你编写简洁且富有意义的注释，而不是充满无关紧要的长篇大论。然而，MonoDevelop
    也提供了基于 XML 的注释来描述函数和参数，并且与代码补全集成。它可以显著提高你的工作效率，尤其是在团队工作中。让我们看看如何使用它。首先，编写你的函数或任何函数，如下面的截图所示：
- en: '![Commenting](img/0655OT_01_12.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/0655OT_01_12.jpg)'
- en: Writing a function (AddNumbers) in MonoDevelop (preparing for code commenting)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中编写一个函数（AddNumbers）（准备代码注释）
- en: 'Then insert three forward-slash characters on the line above the function title
    (`///`), as shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在函数标题上方的行插入三个正斜杠字符（`///`），如下面的截图所示：
- en: '![Commenting](img/0655OT_01_13.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/0655OT_01_13.jpg)'
- en: Inserting /// above the function title to create an XML comment
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数标题上方插入 `///` 以创建 XML 注释
- en: 'When you do this, MonoDevelop automatically inserts a template XML comment
    ready for you to complete with appropriate descriptions. It creates a summary
    section that describes the function generally and param entries for each argument
    in the function, as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，MonoDevelop 会自动插入一个模板 XML 注释，供你完成适当的描述。它会创建一个摘要部分，一般描述该函数，并为函数中的每个参数创建参数条目，如下面的截图所示：
- en: '![Commenting](img/0655OT_01_14.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/0655OT_01_14.jpg)'
- en: Inserting /// above the function title will autogenerate an XML comment
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数标题上方插入 `///` 将自动生成 XML 注释
- en: 'Next, fill in the XML template completely with comments for your function.
    Be sure to give each parameter an appropriate comment too, as shown in the following
    screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，填写你的函数的 XML 模板，并添加注释。务必为每个参数也提供一个适当的注释，如下面的截图所示：
- en: '![Commenting](img/0655OT_01_15.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/0655OT_01_15.jpg)'
- en: Commenting your functions using XML comments
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XML 注释注释你的函数
- en: 'Now, when calling the `AddNumbers` function elsewhere in code, the code-completion
    pop-up helper will display both the summary comment for the function as well as
    the parameter comments'' context sensitively, as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在代码的其他地方调用 `AddNumbers` 函数时，代码补全弹出助手将显示函数的摘要注释以及参数注释的上下文敏感信息，如下所示：
- en: '![Commenting](img/0655OT_01_16.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/0655OT_01_16.jpg)'
- en: Viewing comments when making function calls
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时查看注释
- en: Variable visibility
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量可见性
- en: One excellent feature of Unity specifically is that it exposes (shows) public
    class variables inside the Object Inspector in the Unity Editor, allowing you
    to edit and preview variables, even at runtime. This is especially convenient
    for debugging. However, by default, the Object Inspector doesn't expose private
    variables. They are typically hidden from the inspector. This isn't always a good
    thing because there are many cases where you'll want to debug or, at least, monitor
    private variables from the inspector without having to change their scope to public.
    There are two main ways to overcome this problem easily.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的一个特别出色的功能是，它在Unity编辑器的对象检查器中公开显示公共类变量，允许你在运行时编辑和预览变量。这对于调试来说特别方便。然而，默认情况下，对象检查器不会公开私有变量。它们通常被检查器隐藏起来。这并不总是好事，因为在很多情况下，你可能希望从检查器中调试或至少监控私有变量，而不必将它们的范围更改为公共。有两种主要方法可以轻松解决这个问题。
- en: The first solution would be useful if you want to view all public and private
    variables in a class. You can toggle the Object Inspector in the **Debug** mode.
    To do this, click on the context menu icon in the top-right corner of the **Inspector**
    window and select **Debug** from the context menu, as shown in the following screenshot.
    When **Debug** is selected, all the public and private variables for a class will
    show.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看类中的所有公共和私有变量，第一个解决方案将很有用。你可以在**调试**模式下切换对象检查器。为此，点击**检查器**窗口右上角的下拉菜单图标，并从下拉菜单中选择**调试**，如下面的截图所示。当选择**调试**时，类中的所有公共和私有变量都将显示。
- en: '![Variable visibility](img/0655OT_01_17.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![变量可见性](img/0655OT_01_17.jpg)'
- en: Enabling the Debug mode in the Object Inspector will show all the variables
    in a class
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象检查器中启用调试模式将显示类中的所有变量
- en: 'The second solution is useful for displaying specific private variables, variables
    that you mark explicitly as wanting to display in the Object Inspector. These
    will show in both the **Normal** and **Debug** modes. To achieve this, declare
    the private variable with the attribute `[SerializeField]`. C# attributes are
    considered later in this book, as shown here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案对于显示特定的私有变量很有用，这些变量是你明确标记为希望在对象检查器中显示的。这些变量将在**正常**和**调试**模式下都显示。为了实现这一点，请使用属性`[SerializeField]`声明私有变量。C#属性将在本书的后面部分进行讨论，如下所示：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also use the `[HideInInspector]` attribute to hide a global variable
    from the inspector.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`[HideInInspector]`属性来从检查器中隐藏全局变量。
- en: The ? operator
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`?`运算符'
- en: 'The `if-else` statements are so common and widely used in C# that a specialized
    shorthand notation is available for writing simpler ones, without resorting to
    the full multiline `if-else` statements. This shorthand is called the `?` operator.
    The basic form of this statement is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`语句在C#中非常常见且广泛使用，因此有一个专门的简写符号可用于编写更简单的语句，而无需使用完整的多行`if-else`语句。这个简写符号称为`?`运算符。这个语句的基本形式如下：'
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see the `?` operator in a practical example as shown here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例看看`?`运算符的实际应用：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `?` operator is useful for shorter statements, but for long and more intricate
    statements, it can make your code harder to read.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`运算符对于简短的语句很有用，但对于长且复杂的语句，它可能会使你的代码更难阅读。'
- en: SendMessage and BroadcastMessage
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SendMessage和BroadcastMessage
- en: 'The `MonoBehaviour` class included in the Unity API, which acts as the base
    class for most new scripts, offers the `SendMessage` and `BroadcastMessage` methods.
    Using these, you can easily execute functions by name on all components attached
    to an object. To invoke a method of a class, you typically need a local reference
    to that class to access and run its functions as well as to access its variables.
    However, the `SendMessage` and `BroadcastMessage` functions let you run functions
    using string values by simply specifying the name of a function to run. This is
    very convenient and makes your code look a lot simpler and shorter at the cost
    of efficiency, as we''ll see later. Refer to the following code sample 1-16:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Unity API中包含的`MonoBehaviour`类，作为大多数新脚本的基础类，提供了`SendMessage`和`BroadcastMessage`方法。使用这些方法，你可以通过指定要运行的函数的名称来轻松地在对象的所有组件上执行函数。要调用类的某个方法，通常需要一个对该类的本地引用，以便访问和运行其函数以及访问其变量。然而，`SendMessage`和`BroadcastMessage`函数允许你通过简单地指定要运行的函数的名称来使用字符串值运行函数。这非常方便，并且可以使你的代码看起来更简单、更短，但如我们稍后所见，这会牺牲效率。请参考以下代码示例1-16：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following are the comments for code sample 1-16:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例1-16的注释：
- en: '**Line 09**: `SendMessage` is called to invoke the function `MyFunction`. `MyFunction`
    will be invoked not only on this class but on all other components attached to
    `GameObject`, if they have a `MyFunction` member, including the `Transform` component
    as well as others.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 09**：调用 `SendMessage` 来调用函数 `MyFunction`。`MyFunction` 不仅会在本类中调用，如果 `GameObject`
    上其他组件（包括 `Transform` 组件等）有 `MyFunction` 成员，也会在其他组件上调用。'
- en: '**Line 09**: The parameter `SendMessageOptions.DontRequireReceiver` defines
    what happens if `MyFunction` is not present on a component. Here, it specifies
    that Unity should ignore the component and move on to the next calling `MyFunction`
    wherever it is found.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 09**：参数 `SendMessageOptions.DontRequireReceiver` 定义了如果组件上不存在 `MyFunction`
    时会发生什么。在这里，它指定 Unity 应该忽略该组件，并继续在找到的任何地方调用 `MyFunction`。'
- en: Tip
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The term function and member function mean the same thing when the function
    belongs to a class. A function that belongs to a class is said to be a member
    function.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当函数属于一个类时，术语函数和成员函数意思相同。属于类的函数被称为成员函数。
- en: We've seen that `SendMessage` invokes a specified function across all components
    attached to a single `GameObject`. `BroadcastMessage` incorporates the `SendMessage`
    behavior and goes a stage further, that is, it invokes a specified function for
    all components on `GameObject` and then repeats this process recursively for all
    child objects in the scene hierarchy, cascading downwards to all children.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，`SendMessage` 在单个 `GameObject` 所附着的所有组件中调用指定的函数。`BroadcastMessage` 结合了
    `SendMessage` 的行为，并更进一步，即它为 `GameObject` 上的所有组件调用指定的函数，然后递归地对场景层次结构中所有子对象重复此过程，向下级联到所有子对象。
- en: More information on `SendMessage` and `BroadcastMessage` can be found at [http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)
    and [http://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html](http://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `SendMessage` 和 `BroadcastMessage` 的更多信息可以在 [http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)
    和 [http://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html](http://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html)
    找到。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Reflection**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射**'
- en: '`SendMessage` and `BroadcastMessage` are effective ways to facilitate inter-object
    communication and inter-component communication, that is, it''s a great way to
    make components talk to one another if they need to, to synchronize behavior and
    recycle functionality. However, both `SendMessage` and `BroadcastMessage` rely
    internally on a C# feature known as **reflection**. By invoking a function using
    a string, your application is required to look at itself at runtime (to reflect),
    searching its code for the intended function to run. This process is computationally
    expensive compared to running a function in the normal way. For this reason, seek
    to minimize the usage of `SendMessage` and `BroadcastMessage`, especially during
    `Update` events or other frame-based scenarios, as the impact on performance can
    be significant. This doesn''t mean you should never use them. There might be times
    when their use is rare, infrequent, and convenient and has practically no appreciable
    impact. However, later chapters in this book will demonstrate alternative and
    faster techniques using delegates and interfaces.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessage` 和 `BroadcastMessage` 是促进对象间通信和组件间通信的有效方法，也就是说，如果组件需要相互通信、同步行为和回收功能，这是一个非常好的方法。然而，`SendMessage`
    和 `BroadcastMessage` 都依赖于一个名为 **反射** 的 C# 功能。通过使用字符串调用一个函数，你的应用程序需要在运行时查看自身（进行反射），搜索其代码以找到要运行的预期函数。与正常方式运行函数相比，这个过程计算成本较高。因此，尽量减少使用
    `SendMessage` 和 `BroadcastMessage`，尤其是在 `Update` 事件或其他基于帧的场景中，因为它们对性能的影响可能很大。这并不意味着你永远不应该使用它们。可能会有一些时候，它们的使用很少、不频繁且方便，实际上没有明显的负面影响。然而，本书的后续章节将展示使用代理和接口的替代和更快的技术。'
- en: 'If you''d like more information on C# and its usage before proceeding further
    with this book, then I recommend the following sources:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在继续阅读本书之前需要更多关于 C# 及其使用的详细信息，那么我推荐以下资源：
- en: '*Learning C# by Developing Games with Unity 3D Beginner''s Guide*, *Terry Norton*,
    *Packt Publishing*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《通过使用 Unity 3D 开发游戏学习 C# 入门指南》*，作者：*特里·诺顿*，出版社：*Packt Publishing*'
- en: '*Intro to C# Programming and Scripting for Games in Unity*, *Alan Thorn* (3DMotive
    video course found at [https://www.udemy.com/3dmotive-intro-to-c-programming-and-scripting-for-games-in-unity/](https://www.udemy.com/3dmotive-intro-to-c-programming-and-scripting-for-games-in-unity/))'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Unity中C#编程和脚本入门》*，作者：*艾伦·桑恩*（3DMotive视频课程，可在[https://www.udemy.com/3dmotive-intro-to-c-programming-and-scripting-for-games-in-unity/](https://www.udemy.com/3dmotive-intro-to-c-programming-and-scripting-for-games-in-unity/)找到）'
- en: '*Pro Unity Game Development with C#*, *Alan Thorn*, *Apress*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用C#进行专业Unity游戏开发》*，作者：*艾伦·桑恩*，*Apress*'
- en: 'The following are a few online resources:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在线资源：
- en: '[http://msdn.microsoft.com/en-gb/library/aa288436%28v=vs.71%29.aspx](http://msdn.microsoft.com/en-gb/library/aa288436%28v=vs.71%29.aspx)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MSDN库](http://msdn.microsoft.com/en-gb/library/aa288436%28v=vs.71%29.aspx)'
- en: '[http://www.csharp-station.com/tutorial.aspx](http://www.csharp-station.com/tutorial.aspx)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C#教程站](http://www.csharp-station.com/tutorial.aspx)'
- en: '[http://docs.unity3d.com/ScriptReference/](http://docs.unity3d.com/ScriptReference/)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档](http://docs.unity3d.com/ScriptReference/)'
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter offered a general, Unity-specific overview of Unity's C#, exploring
    the most common and widely-used language features for game development. Later
    chapters will revisit some of these subjects in a more advanced way, but everything
    covered here will be critical for understanding and writing the code featured
    in subsequent chapters.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一个通用的、针对Unity的C#概述，探讨了游戏开发中最常见和广泛使用的语言特性。后续章节将以更深入的方式回顾一些这些主题，但这里涵盖的所有内容对于理解和使用后续章节中的代码都将是关键的。
