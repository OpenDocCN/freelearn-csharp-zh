<html><head></head><body>
		<div><h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor172"/>Chapter 12</em>: Content Negotiation Using a Custom OutputFormatter</h1>
			<p>In this chapter, we are going to learn about how to send your data to the client in different formats and types. By default, the ASP.NET Core web API sends data as JSON, but there are some more ways to distribute data.</p>
			<p>We'll cover the following sections in this chapter:</p>
			<ul>
				<li>Introducing <code>OutputFormatter</code> objects </li>
				<li>Creating custom <code>Outputformatter</code> objects </li>
			</ul>
			<p>The topics in this chapter relate to the WebAPI layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_12.1_B17996.jpg" alt="Figure 12.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor173"/>Technical requirements</h1>
			<p>To follow the examples in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<pre>dotnet new webapi -n OutputFormatterSample -o OutputFormatterSample</pre>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<pre>cd OutputFormatterSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-100">I<a id="_idTextAnchor174"/><a id="_idTextAnchor175"/>ntroducing OutputFormatter objects</h1>
			<p>In ASP.NET Core, <code>OutputFormatters</code> are classes that transform your existing data into different formats to send it<a id="_idIndexMarker174"/> through HTTP to clients. The web API uses a default <code>OutputFormatters</code> to turn objects into JSON, which is the default format to send structured data. Other built-in formatters include an XML formatter and a plain text formatter.</p>
			<p>With so-called <em class="italic">content negotiation</em>, clients are able to decide which format they want to retrieve. The client needs to specify the content type of the format in the <code>Accept</code> header. Content negotiation is implemented in <code>ObjectResult</code>.</p>
			<p>By default, the web API always returns JSON, even if you accept text/XML in the header. This is why the built-in XML formatter is not registered by default.</p>
			<p>There are two ways to add <code>XmlSerializerOutputFormatter</code> to <a id="_idIndexMarker175"/>ASP.NET Core: </p>
			<ul>
				<li>The first is shown in the following code snippet:<pre>builder.Services.AddControllers()
    .AddXmlSerializerFormatters();</pre></li>
				<li>Or, alternatively, you can use the following:<pre>builder.Services.AddControllers()
    .AddMvcOptions(options =&gt;
    {
        options.OutputFormatters.Add(
            new XmlSerializerOutputFormatter());
    });</pre></li>
			</ul>
			<p>You might need to add the <code>Microsoft.AspNetCore.Mvc.Formatters</code> namespace to the <code>using</code> statements.</p>
			<p>There is also a formatter called <code>XmlDataContractSerializerOutputFormatter</code> available, which uses <code>DataContractSerializer</code> internally and is more flexible in its configurations.</p>
			<p>By default, any <code>Accept</code> header will automatically be turned into <code>application/json</code>, even if you use one of these methods. However, we can fix that.</p>
			<p>If you want to allow the <a id="_idIndexMarker176"/>clients to accept different headers, you need to switch that translation off:</p>
			<pre>builder.Services.AddControllers()
    .AddMvcOptions(options =&gt;
    {
        options.RespectBrowserAcceptHeader = true; 
          // false by default
    });</pre>
			<p>Some third-party components that don't completely support ASP.NET Core 5.0 or later won't write asynchronously to the response stream, but the default configuration since ASP.NET Core 3.0 <em class="italic">only</em> allows asynchronous writing. </p>
			<p>To enable synchronous writing access, you will need to add these lines to the <code>ConfigureServices</code> method:</p>
			<pre>builder.Services.Configure&lt;KestrelServerOptions&gt;(options =&gt;
{
    options.AllowSynchronousIO = true;
});</pre>
			<p>Add the <code>Microsoft.AspNetCore.Server.Kestrel.Core</code> namespace to the <code>using</code> statements to get access to the options.</p>
			<p>To try the formatters, let's set up a small test project<a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor178"/>Preparing a test project</h2>
			<p>Using the console, we <a id="_idIndexMarker177"/>will create a small ASP.NET Core web API project, using the command shown previously in the <em class="italic">Technical requirements</em> section:</p>
			<ol>
				<li>First, execute the following commands to add the necessary <code>GenFu</code> is an awesome library to easily create test data, and the second package, <code>CsvHelper</code>, helps us to easily write CSV data.</p></li>
				<li>Now, open the project in Visual Studio or in VS Code and create a new API controller called <code>PersonsController</code> in the <code>controller</code> folder:<pre>[Route("api/[controller]")]
[ApiController]
public class PersonsController : ControllerBase
{
}</pre></li>
				<li>Open <code>PersonsController.cs</code> and add a <code>Get()</code> method like this:<pre>[HttpGet]
public ActionResult&lt;IEnumerable&lt;Person&gt;&gt; Get()
{
    var persons = A.ListOf&lt;Person&gt;(25);
    return persons;
}</pre><p>You might need to add the following <code>using</code> statements at the beginning of the file:</p><pre>using GenFu;
using Microsoft.AspNetCore.Mvc;
using OutputFormatterSample.Models;</pre><p>This creates a list of 25 persons by using <code>GenFu</code>. The properties will automatically be filled with realistic data. <code>GenFu</code> is an open source, fast, lightweight, and extendable test data generator. It contains built-in lists of names, cities, countries, phone numbers, and so on, and it fills the data automatically into the right properties of a class, depending on the property names. For example, a property called <code>City</code> will be filled with the name of a city, and a<a id="_idIndexMarker178"/> property called <code>Phone</code>, <code>Telephone</code>, or <code>Phonenumber</code> will be filled with a well-formatted fake phone number. You'll see the magic of <code>GenFu</code> and the results later on.</p></li>
				<li>Now, create a <code>Models</code> folder, and create a new file called <code>Person.cs</code> with the <code>Person</code> class inside:<pre>public class Person
{
    public int Id { get; set; }
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
    public int Age { get; set; }
    public string? EmailAddress { get; set; }
    public string? Address { get; set; }
    public string? City { get; set; }
    public string? Phone { get; set; }
}</pre></li>
				<li>Open <code>Program.cs</code> as well, add the XML formatters, and allow other <code>AcceptHeader</code>, as described earlier:<pre>builder.Services.AddControllers()
    .AddMvcOptions(options =&gt;
    {
        options.RespectBrowserAcceptHeader = true; 
          // false by default
        options.OutputFormatters.Add(
            new XmlSerializerOutputFormatter());
    });</pre><p>That's it <a id="_idIndexMarker179"/>for now. Now, you are able to retrieve the data from the web API.</p></li>
				<li>Start the project by using the <code>dotnet run</code> command.</li>
			</ol>
			<p>Next, we'll test the API.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor179"/>Testing the web API</h1>
			<p>The best tools <a id="_idIndexMarker180"/>to test a <a id="_idIndexMarker181"/>web API <a id="_idIndexMarker182"/>are <strong class="bold">Fiddler</strong> (<a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a>) or <strong class="bold">Postman</strong> (<a href="https://www.postman.com/">https://www.postman.com/</a>). I prefer Postman because I find it easier to use. You can use either tool, but in these demos, we will use P<a id="_idTextAnchor180"/>ostman:</p>
			<ol>
				<li value="1">In Postman, create a new request. Enter the API URL, which is <a href="https://localhost:5001/api/persons">https://localhost:5001/api/persons</a> (the port of the URL might vary), into the <code>address</code> field, and then, add a header with the <code>Accept</code> key and the <code>application/json</code> value.</li>
				<li>After<a id="_idIndexMarker183"/> clicking <code>GenFu</code> object puts the data into the person's properties, based on the property type and the property name: real first names and real last names, as well as real cities and properly formatted phone numbers.</p></li>
				<li>Next, let's<a id="_idIndexMarker184"/> test the XML output formatter. In Postman, change the <code>Accept</code> header from <code>application/json</code> to <code>text/xml</code> and click <strong class="bold">Send</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_12.3_B17996.jpg" alt="Figure 12.3 – A screenshot of XML output in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3 – A screenshot of XML output in Postman</p>
			<p>We now have an XML-formatted output. Now, let's go a step further and create some custom <code>OutputFormatter</code> o<a id="_idTextAnchor181"/><a id="_idTextAnchor182"/>bjects.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor183"/>Creating custom OutputFormatter objects</h1>
			<p>In this <a id="_idIndexMarker185"/>example, our aim is to create a <strong class="bold">VCard</strong> output to be able to import the person's contact details directly into <strong class="bold">Microsoft</strong> <strong class="bold">Outlook</strong> or any other contact database that supports VCards. Later in this section, we also want to create a CSV output formatter.</p>
			<p>Both are text-based output formatters, and they will derive their values from <code>TextOutputFormatter</code>. Let's look at the steps to create the VCard output:</p>
			<ol>
				<li value="1">Create a new class in a new file called <code>VcardOutputFormatter.cs</code>.</li>
				<li>Now, insert the following class skeleton in the new file. You will find the implementations of the empty methods in the following code snippets. The constructor contains the supported media types and content encodings:<pre>public class VcardOutputFormatter : TextOutputFormatter
{
    public string? ContentType { get; }
    public VcardOutputFormatter()
    {
        SupportedMediaTypes.Add(
            MediaTypeHeaderValue.Parse("text/vcard"));
        SupportedEncodings.Add(Encoding.UTF8);
        SupportedEncodings.Add(Encoding.Unicode);
    }
    protected override bool CanWriteType(Type type)
    {
    }
    public override Task WriteResponseBodyAsync(
        OutputFormatterWriteContext context,
         Encoding selectedEncoding)
    {
    }
    private static void FormatVcard(
        StringBuilder buffer, 
        Person person, 
        ILogger logger)
    {
    }
}</pre><p>You might <a id="_idIndexMarker186"/>need to add the following <code>using</code> statements:</p><pre>using Microsoft.AspNetCore.Mvc.Formatters;
using System.Text;
using Microsoft.Extensions.Logging;
using Microsoft.Net.Http.Headers;
using OutputFormatterSample.Models;</pre></li>
				<li>The next code snippet shows the implementation of the <code>CanWriteType</code> method. It is optional to override this method, but it makes sense to restrict it to a specific condition. In this case, the <code>OutputFormatter</code> can only format objects of the <code>Person</code> type:<pre>protected override bool CanWriteType(Type type)
{
    if (typeof(Person).IsAssignableFrom(type)
        || typeof(IEnumerable&lt;Person&gt;)
            .IsAssignableFrom(type))
    {
        return base.CanWriteType(type);
    }
    return false;
}</pre></li>
				<li>You need to<a id="_idIndexMarker187"/> override <code>WriteResponseBodyAsync</code> to convert the actual <code>Person</code> objects into the output you want to have. To get the objects to convert, you need to extract them from <code>OutputFormatterWriteContext</code> object that gets passed into the method. You also get the HTTP response from this context. This is needed to write the results and send them to the client. </li>
				<li>Inside the method, we check whether we get one person or a list of persons and call the not yet implemented <code>FormatVcard</code> method:<pre>public override Task WriteResponseBodyAsync(
    OutputFormatterWriteContext context,
    Encoding selectedEncoding)
{
    var serviceProvider = 
      context.HttpContext.RequestServices;
    var logger = serviceProvider.GetService(
        typeof(ILogger&lt;VcardOutputFormatter&gt;)) as 
          ILogger;
    var response = context.HttpContext.Response;
    var buffer = new StringBuilder();
    if (context.Object is IEnumerable&lt;Person&gt;)
    {
        foreach (var person in context.Object as 
          IEnumerable&lt;Person&gt;)
        {
            FormatVcard(buffer, person, logger);
        }
    }
    else
    {
        var person = context.Object as Person;
        FormatVcard(buffer, person, logger);
    }
    return response.WriteAsync(buffer.ToString());
}</pre></li>
				<li>To format<a id="_idIndexMarker188"/> the output to support standard <code>Vcard</code>, you need to do some manual work:<pre>private static void FormatVcard(
    StringBuilder buffer, 
    Person person, 
    ILogger logger)
{
    buffer.AppendLine("BEGIN:VCARD");
    buffer.AppendLine("VERSION:2.1");
    buffer.AppendLine(
        $"FN:{person.FirstName} {person.LastName}");
    buffer.AppendLine(
        $"N:{person.LastName};{person.FirstName}");
    buffer.AppendLine(
        $"EMAIL:{person.EmailAddress}");
    buffer.AppendLine(
        $"TEL;TYPE=VOICE,HOME:{person.Phone}");
    buffer.AppendLine(
         $"ADR;TYPE=home:;;{person.Address};
             {person.City}");
    buffer.AppendLine($"UID:{person.Id}");
    buffer.AppendLine("END:VCARD");
    logger.LogInformation(
        $"Writing {person.FirstName}  
          {person.LastName}");
}</pre></li>
				<li>Then, we<a id="_idIndexMarker189"/> need to register the new <code>VcardOutputFormatter</code> object in <code>Program.cs</code>:<pre>builder.Services.AddControllers()
    .AddMvcOptions(options =&gt;
    {
        options.RespectBrowserAcceptHeader = true; 
          // false by default
        options.OutputFormatters.Add(
            new XmlSerializerOutputFormatter());
        // register the VcardOutputFormatter
        options.OutputFormatters.Add(
            new VcardOutputFormatter());
    });</pre><p>You might need to add a <code>using</code> statement to <code>OutputFormatterSample</code>.</p></li>
				<li>Start the <a id="_idIndexMarker190"/>app again using <code>dotnet run</code>.</li>
				<li>Now, change the <code>Accept</code> header to <code>text/vcard</code>, and let's see what happens:<div><img src="img/Figure_12.4_B17996.jpg" alt="Figure 12.4 – A screenshot of VCard output in Postman&#13;&#10;"/></div><p class="figure-caption">Figure 12.4 – A screenshot of VCard output in Postman</p><p>We now should see all of our data in <code>VCard</code> format.</p></li>
				<li>Now, let's do <a id="_idIndexMarker191"/>the same for a CSV output. We already added the <code>CsvHelper</code> library to the project. So, go to the following URL and download <code>CsvOutputFormatter</code> to put it into your project: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs</a></li>
				<li>Let's have a quick look at the <code>WriteResponseBodyAsync</code> method:<pre>public override async Task WriteResponseBodyAsync(
    OutputFormatterWriteContext context,
    Encoding selectedEncoding)
{
    var response = context.HttpContext.Response;
    var csv = new CsvWriter(
        new StreamWriter(response.Body),
        CultureInfo.InvariantCulture);
    IEnumerable&lt;Person&gt; persons;
    if (context.Object is IEnumerable&lt;Person&gt;)
    {
        persons = context.Object as 
          IEnumerable&lt;Person&gt;;
    }
    else
    {
        var person = context.Object as Person;
        persons = new List&lt;Person&gt; { person };
    }
    await csv.WriteRecordsAsync(persons);
}</pre></li>
				<li>This almost <a id="_idIndexMarker192"/>works the same way as <code>VcardOutputFormatter</code>. We can pass the response stream via <code>StreamWriter</code> directly into <code>CsvWriter</code>. After that, we are able to feed the persons or the list of persons to the writer. That's it.</li>
				<li>We also need to register <code>CsvOutputFormatter</code> before we can test it:<pre>builder.Services.AddControllers()
    .AddMvcOptions(options =&gt;
    {
        options.RespectBrowserAcceptHeader = true; 
           // false by default
        options.OutputFormatters.Add(
            new XmlSerializerOutputFormatter());
        // register the VcardOutputFormatter
        options.OutputFormatters.Add(
            new VcardOutputFormatter());
        // register the CsvOutputFormatter
        options.OutputFormatters.Add(
            new CsvOutputFormatter());
    });</pre></li>
				<li>In Postman, change<a id="_idIndexMarker193"/> the <code>Accept</code> header to <code>text/csv</code> and click <strong class="bold">Send</strong> again:</li>
			</ol>
			<div><div><img src="img/Figure_12.5_B17996.jpg" alt="Figure 12.5 – A screenshot of text/CSV output in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – A screenshot of text/CSV output in Postman</p>
			<p>There we go – Postman was able to open all of the form<a id="_idTextAnchor184"/>ats we tested.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor185"/>Summary</h1>
			<p>Isn't that cool? The ability to change the format based on the <code>Accept</code> header is very handy. This way, you are able to create a web API for many different clients – an API that accepts many different formats, depending on the clients' preferences. There are still many potential clients out there that don't use JSON and prefer XML or CSV.</p>
			<p>The other way around would be an option to consume CSV or any other format inside the web API. For example, let's assume your client sends you a list of people in CSV format. How would you solve this? Parsing the string manually in the <code>action</code> method would work, but it's not an easy option.</p>
			<p>This is what <code>ModelBinder</code> objects can do for us. Let's see how they work in the next chapter.</p>
		</div>
	</body></html>