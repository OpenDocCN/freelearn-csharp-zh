- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentals of Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s world, **web APIs** are the backbone of the web. Millions of people
    use web APIs every day to purchase commodities, book a flight, get weather information,
    and more. In this chapter, we will learn about the fundamentals of web APIs. You
    might be wondering why we will start with the fundamental concepts. The answer
    is simple – we need to understand the basic concepts of web APIs before we build
    one.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces a couple of different web API styles, such as a REST-based
    API, a **remote procedure call** (**RPC**)-based API, a GraphQL API, and a real-time
    API. We will also learn about how to design them. If you would like to start developing
    a web API, feel free to jump to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a web API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a REST API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a REST-based API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are RPC and GraphQL APIs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a real-time API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a basic understanding of web APIs
    and be able to pick the right style for your project. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: What is a web API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**API** stands for **application programming interface**. A web API, as the
    name suggests, is a set of programming interfaces for the web. For example, when
    you book a flight on a website, the browser makes a request to the airline’s server
    through a web API to access the airline’s database. The airline’s server then
    returns the information about the flight to the browser, allowing you to book
    your flight in it.'
  prefs: []
  type: TYPE_NORMAL
- en: APIs have been delivered by organizations for decades. With the appearance of
    the World Wide Web, people needed a way to communicate between the server and
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: We can build web APIs using different technologies, such as Java, Python, Ruby,
    PHP, .NET, and so on. Also, they have various styles. You might have heard of
    terms such as **SOAP**, **Web Service**, and **REST**. They are all based on the
    **HTTP** protocol but communicate in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we consider web APIs as a wider concept than REST. In the digital
    world, the way machines communicate with each other changes as either the demands
    or the infrastructure evolves. In the 1990s, people focused on how to improve
    the internal networks that used the same platforms. TCP/IP came to be the standard
    for this kind of communication. After a few years, people needed to find a way
    to optimize communication across multiple platforms. Web Services appeared, and
    they used the **Simple Object Access Protocol** (**SOAP**), which was defined
    for enterprises, and it ensured that programs built on different platforms could
    easily exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: However, SOAP XML is quite heavy, which means it requires more bandwidth for
    its usage. In the early 2000s, **Windows Communication Foundation** (**WCF**)
    was released by Microsoft. This helped developers manage the complexities of working
    with SOAP. WCF is RPC-based but still uses SOAP as the underlying protocol. Over
    time, some old standards, such as SOAP, have been transitioned to REST APIs, which
    will be discussed in the next section. We will start with REST APIs and then move
    on to the other styles of web-based APIs, such as gRPC APIs, GraphQL APIs, and
    SignalR APIs.
  prefs: []
  type: TYPE_NORMAL
- en: What is a REST API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST**, also known as **Representational State Transfer**, is an architectural
    style of web APIs that was created by Roy Fielding in his Ph.D. dissertation *Architectural
    Styles and the Design of Network-based Software Architectures* in 2000\. Today,
    generally speaking, REST APIs are based on HTTP, but actually, Roy Fielding’s
    paper just outlines the core concepts and constraints for understanding an architectural
    style, and it does not require any specific protocol for REST-based architecture,
    such as HTTP. However, since HTTP is the most widely used protocol for web APIs,
    we will use HTTP as the protocol for REST APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Just keep in mind that REST is just a style, not a rule. When you build a web
    API, you do not have to follow the REST style. You can use any other style you
    like. You can build a web API that works well, but it might not be *REST enough*.
    REST is the recommended style because it helps us establish constraints, which
    contribute to the design of web APIs. It also helps developers easily integrate
    with other REST APIs if they follow the same style.
  prefs: []
  type: TYPE_NORMAL
- en: The core concept of REST is the term *representational state transfer*. Think
    about a web system, which is a collection of resources. For example, it might
    have a resource called *books*. The collection of books is a resource. A book
    is a resource too. When you request the list of the books, you select a link (for
    example, [http://www.example.com/books](http://www.example.com/books)), which
    will return a JSON string that contains all the books, resulting in the next resource’s
    representation, such as the link of a specific book (for example, [http://www.example.com/books/1](http://www.example.com/books/1)).
    You can continue to request the book with this link. In this process, the representation
    state is transferred to the client and rendered for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are loads of resources that explain REST. If you would like to know more
    about REST, you can read the following article on Wikipedia: *REST: The Web Framework
    for Representational State* *Transfer* ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the constraints of REST, following which we will show you
    a simple example of REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The constraints of REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Roy Fielding’s paper defines the following six constraints for REST APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server**: This pattern enforces the principle of separation of concerns.
    The server and the client act independently. The client sends the request and
    the server responds, following which the client receives and interprets the response.
    The client does not need to know how the server works, and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statelessness**: The server does not maintain any state of the client. The
    client should provide the necessary information in the request. This stateless
    protocol is important to scale out the capacity of the server because it does
    not need to remember the session state of the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheability**: The response of the server must implicitly or explicitly
    contain information about whether the response is cacheable, allowing the client
    and intermediaries to cache the response. The cache can be performed on the client
    machine in memory, in browser cache storage, or in a **content delivery network**
    (**CDN**). It is also important to improve the scalability and performance of
    web APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The layered system**: The client does not know how it is connected to the
    server. There may be multiple layers between the client and the server. For example,
    a security layer, a proxy, or a load balancer can be placed between the client
    and the server without impacting the client or server code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand (optional)**: The client can request code from the server
    for client-side use. For example, the web browser can request JavaScript files
    to perform some tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: This one is essential for a RESTful system. It contains
    resource identification, resource manipulation through representations, self-descriptive
    messages, and hypermedia as the engine of the application state. It simplifies
    and decouples the architecture of the system, which enables each part to evolve
    independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you feel these principles are a little bit distant or theoretical, let’s
    look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: A REST API example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The website [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    is a fake REST API that generates fake JSON data. Open the following link in your
    browser: [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    You will see a JSON string returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding request, we can get the resource for the collection of the
    posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can request a specific post by its ID. For example, we can request
    the post with ID `1` using the following URL: [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1).
    The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! The URLs we used in the preceding examples are the identifiers
    of the resources. The responses (the JSON strings) are the representations of
    the resources. A resource is manipulated through hypertext representations that
    are transferred in messages between clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Some documents use URI. A `http`, `https` or `ftp`. Nowadays, the term *URL*
    remains widely used, so, we will use that in this book. However, we should know
    they have different scopes. URI is the superset of URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a post resource, we send a `GET` request. There are some other methods
    for manipulating resources, such as `POST`, `PUT`, `PATCH`, and `DELETE`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **URL** | **Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``posts` | Read | Read the collection of the posts |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``posts/1` | Read | Read a post by its ID |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``posts/1/comments` | Read | Read the comments of the post |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/``posts` | Create | Create a new post |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/``posts/1` | Update | Update a post by its ID |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | `/``posts/1` | Update (partial) | Update part of a post by its
    ID |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/``posts/1` | Delete | Delete a post by its ID |'
  prefs: []
  type: TYPE_TB
- en: Table 1.1 – HTTP methods and URLs for manipulating resources
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods that are less frequently used, such as `HEAD`, `OPTIONS`,
    and `TRACE`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the HTTP methods are mapped to the **create, update, read, and
    delete** (**CURD**) operations. But was it always this way?
  prefs: []
  type: TYPE_NORMAL
- en: Is my web API RESTful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already mentioned, REST is not a rule or a specification. There is no *official*
    standard for REST APIs. Contrary to popular opinion, it does not require JSON.
    Furthermore, it does not require the use of CRUD patterns. But REST implementation
    does make use of standards, such as HTTP, URL, JSON, XML, and so on. People apply
    HTTP methods and JSON to implement REST, but they may not intentionally apply
    the constraints as originally described in Fielding’s paper. This leads people
    to disagree on whether their APIs are RESTful or not. Many developers describe
    their APIs as RESTful, even though these APIs do not satisfy all of the constraints
    described in Fielding’s paper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Frankly, it is not beneficial to argue whether a web API is *REST enough* or
    not. The goal is to make something work, rather than wasting time on a discussion
    of this kind of problem. Not everyone has read the original paper. Technology
    also evolves rapidly. There is a Chinese saying: *It doesn’t matter whether it
    is a white cat or a black cat; as long as it catches mice, it is a* *good cat.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it would be ideal if we follow conventions when we start a greenfield
    project. Generally, a REST-based API is defined with the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: A base URL, which is the root of the API, such as `http://api.example.com`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantics of HTTP methods, such as `GET`, `POST`, `PUT`, `DELETE`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A media type, which defines state transition data elements, such as `application/json`,
    `application/xml`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will try to follow these conventions when we develop the REST
    APIs with ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had an overview of a REST API, let’s see how to design one
    following the conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a REST-based API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build a REST-based API, there are many steps to take before we write code.
    The development team needs to communicate with stakeholders and analyze the requirements.
    Then, they need to write user stories (or job stories) to define the desired outcomes.
    This requires the insights of domain experts or subject matter experts. We will
    not cover this part in this book. Instead, next, we will focus on the API design,
    which is closer to what developers do.
  prefs: []
  type: TYPE_NORMAL
- en: In the past few years, the concept of **API-first** has gained more traction.
    The API-first approach means that the APIs are treated as first-class citizens
    for your project. This creates a contract for how the API is supposed to behave
    before any code is written. In this way, the development teams can work in parallel
    because the contract will be established first. Developers do not have to wait
    for the API to be released before integrating with frontend or mobile apps. They
    can mock and test the APIs based on the contract. Using tools such as **Swagger**,
    the process of building APIs can be automated, such as API documentation, mock
    APIs, SDKs, and so on. Automation can significantly speed up the development of
    APIs and applications, which helps to increase the speed to market.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some steps we can follow to design a REST-based API:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the relationships between resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify operation events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design the URL paths for resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map API operations to HTTP methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign response codes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Document the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are familiar with the preceding steps, you can skip them. However, if
    you are not, read the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: A popular API description format is **OpenAPI Specification** (**OAS**). We
    can use it to describe API modeling and other details of an API. We do not need
    to include the implementation details at this stage, because we just want to make
    a contract. SwaggerHub ([https://app.swaggerhub.com/home](https://app.swaggerhub.com/home))
    is a tool we can use to design an API.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST-based APIs center on resources. A resource is a collection of data, such
    as a collection of posts or a collection of users. A resource is identified by
    a URL. The client requests a resource using the URL, and the server responds with
    a representation of the resource. The representation of the resource is sent in
    the hypertext format, which can be interpreted by the widest possible range of
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to identify the scope of the domain and the relationships between
    the resources. For example, if you are building a blog system, you may have a
    collection of posts, and each post has a collection of comments. The scope of
    an API may evolve as time goes by. More resources may be added to the current
    domain, or some resources will be removed. Also, relationships may change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start small. We can use the blog system as an example. After the requirement
    analysis, we can identify the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may want to include some properties of each resource in this step. For example,
    a post has a title, a body, and a published datetime. A comment has a body, a
    publish datetime. A user has a name and an email. You may find more properties
    during development.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the relationships between resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the resources are identified, we can define the relationships between them.
    For example, a post has a collection of comments. A comment has a post. A user
    has a collection of posts.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship is defined by how these resources relate to each other. Sometimes,
    these relationships exist in the database as well, but sometimes, they are specific
    to the REST resources only.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some terms we can use to describe the relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent resource**: This resource can exist independently. It does not
    require another resource to exist. An independent resource can reference other
    independent or dependent resources. For example, a post is an independent resource,
    and it can reference its author. The authors resource is also an independent resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependent resource**: This resource requires another resource to exist. It
    can still reference other independent or dependent resources, but it cannot exist
    without the existence of the parent resource. For example, a comment requires
    a post as its parent resource; otherwise, it cannot exist. A comment can reference
    its author, which is an independent resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Id` property, which can uniquely identify itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostId` property, which references a post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three relationship types that these resources can have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-to-many**: This is when a resource has many related resources. For example,
    a user has many posts, but a post has only one author. This is also called the
    *parent-child (children)* relationship, which is the most common pattern for relationships
    we can see in the REST-based API world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-one**: This is when a resource has one related resource. For example,
    a post has a single author, and one house has only one address. The one-to-one
    relationship is a special case of the one-to-many relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-many**: This is when a resource has many related resources and vice
    versa. For example, a blog has many tags, and a tag has many blogs. A movie can
    have many genres, and a genre can have many movies. In many systems, a user can
    have many roles, and a role can have many users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we can think about what operations are needed for each resource. These
    operations may come from user stories that are defined beforehand. Generally,
    each resource has its CRUD operations. Note that the operations may include more
    beyond CRUD. For example, a post can be published, or it can be unpublished. A
    comment can be approved, or it can be rejected. During this process, we may need
    to create a new resource or property to reflect the operation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to consider the scope of the domain. CRUD operations are easy
    to understand, but for some complicated relationships, we may need help from domain
    experts.
  prefs: []
  type: TYPE_NORMAL
- en: When we work on these operations, we need to include important input and output
    details. We will use them in the next steps. However, it is not necessary to include
    all the details of each resource. We have enough time later to capture the complete
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example of the blog system, we can identify these operations for the
    `Post` resource (including but not limited to the following):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **Resource(s)** | **Input** | **Output** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createPost()` | `Post, category,` `user, tag` | Post detail |  | Create
    a new post |'
  prefs: []
  type: TYPE_TB
- en: '| `listPosts()` | `Post` |  | A list of posts | List all posts |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByCategory()` | `Post` `and category` | Category ID | A list of
    posts | List posts by category |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByTag()` | `Post` `and tag` | Tag or Tag ID | A list of posts |
    List posts by tag |'
  prefs: []
  type: TYPE_TB
- en: '| `searchPosts()` | `Post` | Search keyword | A list of posts | Search for
    Posts by title, author, and content |'
  prefs: []
  type: TYPE_TB
- en: '| `viewPost()` | `Post, category,` `and user` | Post ID | Post detail | View
    a post detail |'
  prefs: []
  type: TYPE_TB
- en: '| `deletePost()` | `Post` | Post ID |  | Delete a post |'
  prefs: []
  type: TYPE_TB
- en: '| `updatePost()` | `Post` `and category` | Post detail |  | Update a post |'
  prefs: []
  type: TYPE_TB
- en: '| `publishPost()` | `Post` | Post ID |  | Publish a post |'
  prefs: []
  type: TYPE_TB
- en: '| `unpublishPost()` | `Post` | Post ID |  | Unpublish a post |'
  prefs: []
  type: TYPE_TB
- en: Table 1.2 – Operations for the Post resource
  prefs: []
  type: TYPE_NORMAL
- en: For some operations, such as `createPost` and `deletePost`, the output is the
    results of the operation. This can be represented with the HTTP status code. We
    will discuss this later.
  prefs: []
  type: TYPE_NORMAL
- en: We can list more operations for other resources as well.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the URL paths for resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to design the URL paths for each resource. The clients use
    URLs to access the resources. Even though REST is not a standard, there are some
    guidelines or conventions for designing URL paths.
  prefs: []
  type: TYPE_NORMAL
- en: Using nouns instead of verbs
  prefs: []
  type: TYPE_NORMAL
- en: The operation events we identified in the previous step are some actions, such
    as `Create`, `List`, `View`, `Delete`, and so on. However, the URL paths are not
    usually presented by verbs. Because HTTP methods such as `GET`, `POST`, `PUT`,
    and `DELETE` are already verbs, it is not necessary to include verbs in the URL
    paths. Instead, we should use nouns to represent the resources – for example,
    `/posts`.
  prefs: []
  type: TYPE_NORMAL
- en: Using plural nouns to represent collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a resource is a collection, we should use plural nouns to represent the resource.
    For example, `/posts` is the URL path for the collection of posts. To get a single
    post by its ID, we can use `/posts/{postId}`.
  prefs: []
  type: TYPE_NORMAL
- en: Using logical nesting to represent relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the resources that have a relationship, normally, the child resource (i.e.,
    the dependent resource) should be nested under the parent resource, and the path
    should include the parent identifier. However, this does not reflect the database
    structure. For example, a post can have a collection of comments; the URL looks
    like `/posts/{postId}/comments`. It clearly shows that the comments are related
    to the post.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the relationships are too deep or complicated, the nesting URL path
    can be too long. In this case, we can rethink how to better represent those resources.
    For example, if we want to retrieve an author’s information from one comment,
    we could use `/posts/{postId}/comments/{commentId}/author`. But this goes too
    far. Instead, if we know the `UserId` of the author, we can use `/users/{userId}`.
    Avoid using deep nesting in URL paths because it makes an API more complicated
    and not readable.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing filtering, sorting, and pagination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returning all records simultaneously is not a good idea. We can use filtering,
    sorting, and pagination to return a subset of the records that a client needs.
    These operations can improve the performance of the APIs and provide a better
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to search a list of posts for a specific keyword, we
    can use a query parameter, such as `/posts?search=keyword`. If we want to sort
    posts by the date, we can use `/posts?sort=date`. To get the second page of the
    posts, we can use `/posts?page=2`. These query parameters can be combined with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: What if I cannot find a proper verb in HTTP methods for an operation?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, HTTP methods can represent CRUD operations. However, in the real
    world, there are many more complexities! For example, besides the basic CRUD operations,
    there are other operations, such as publishing or unpublishing a post. So, what
    HTTP methods should we use?
  prefs: []
  type: TYPE_NORMAL
- en: This is where things can get tricky. This subject is open to debate, but remember
    that we are not arguing whether an API is *RESTful* enough. We just want to make
    it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different approaches for these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution could be treating such operations like a sub-resource.
    So, you can use `/posts/{postId}/publish` to publish a post. GitHub uses the following
    URL to star a gist: `/gists/{gist_id}/star`. For more information, check out [https://docs.github.com/en/rest/gists/gists#star-a-gist](https://docs.github.com/en/rest/gists/gists#star-a-gist).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The post should have an `IsPublished` field to indicate whether it is published.
    So, actually, the `publish` action is an update action, which updates the `IsPublished`
    field only. Then, you can treat it the same as the `updatePost()` operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some resource URLs for the blog system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **URL** | **Input** | **Output** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createPost()` | `/``posts` | Post detail |  | Create a new post |'
  prefs: []
  type: TYPE_TB
- en: '| `listPosts()` | `/``posts` |  | A list of posts | List all posts |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByCategory()` | `/``posts?categoryId={categoryId}` | Category ID
    | A list of posts | List posts by category |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByTag()` | `/``posts?tag={tagId}` | Tag or Tag ID | A list of posts
    | List posts by tag |'
  prefs: []
  type: TYPE_TB
- en: '| `searchPosts()` | `/``posts?search={keyword}` | Search keyword | A list of
    posts | Search for posts by title, author, and content |'
  prefs: []
  type: TYPE_TB
- en: '| `viewPost()` | `/``posts/{postId}` | Post ID | Post detail | View a post
    detail |'
  prefs: []
  type: TYPE_TB
- en: '| `deletePost()` | `/``posts/{postId}` | Post ID |  | Delete a post |'
  prefs: []
  type: TYPE_TB
- en: '| `updatePost()` | `/``posts/{postId}` | Post detail |  | Update a post |'
  prefs: []
  type: TYPE_TB
- en: '| `publishPost()` | `/``posts/{postId}/publish` | Post ID |  | Publish a post
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unpublishPost()` | `/``posts/{postId}/unpublish` | Post ID |  | Unpublish
    a post |'
  prefs: []
  type: TYPE_TB
- en: Table 1.3 – URLs for the Post resource
  prefs: []
  type: TYPE_NORMAL
- en: Some URLs are identical, such as `deletePost()` and `updatePost()`, because
    we will use HTTP methods to differentiate those operations.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping API operations to HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need to identify which HTTP method is appropriate for each operation.
    As we mentioned before, there are some common HTTP methods for CRUD operations.
    For example, when we request a resource, we should use the `GET` method. When
    we create a new resource, we should use the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we map the API operations to HTTP methods, we also need to consider the
    safety of the operations and HTTP methods. There are three types of safety for
    HTTP operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` request to `/posts/{postId}`, it will return the same result, no matter
    how many times the same request is sent. For some cases, the resource might be
    updated by a third party, and the next `GET` request will return the updated result.
    But this was not caused by the client, so it is important to understand whether
    the state change is caused by the client who sent the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` request to `/posts/{postId}` to delete it. If the request is a success,
    we will get a `200 OK` or a `204 No Content` response. If we send the same request
    to `/posts/{postId}` again, it may return a `404 Not found` response because the
    resource was already deleted, but it will not cause any other side effects. If
    an operation is idempotent and the client knows whether the previous request failed,
    it is safe to reissue the request without any side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` request to `/posts` to create a new post. If we send the same `POST`
    request again, it will create another new post with the same title and content,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All safe methods are also idempotent, but not all idempotent methods are safe.
    The following table lists the safety of each HTTP method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **Safe** | **Idempotent** | **Common operations** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Yes | Yes | Read, list, view, search, show, and retrieve |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | Yes | Yes | `HEAD` is used to check the availability of a resource
    without actually downloading it. |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Yes | Yes | `OPTIONS` is used to retrieve the available HTTP
    methods for a given resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `TRACE` | Yes | Yes | `TRACE` is used to get diagnostic information about
    a request/response cycle. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | No | Yes | Update and replace |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | No | Yes | Delete, remove, and clear |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | No | No | Create, add, and update |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | No | No | Update |'
  prefs: []
  type: TYPE_TB
- en: Table 1.4 – Safety of HTTP methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows how operations are mapped to HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **URL** | **HTTP method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createPost()` | `/``posts` | `POST` | Create a new post |'
  prefs: []
  type: TYPE_TB
- en: '| `listPosts()` | `/``posts` | `GET` | List all posts |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByCategory()` | `/``posts?categoryId={categoryId}` | `GET` | List
    posts by category |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByTag()` | `/``posts?tag={tagId}` | `GET` | List posts by tag |'
  prefs: []
  type: TYPE_TB
- en: '| `searchPosts()` | `/``posts?search={keyword}` | `GET` | Search for posts
    by title, author, and content |'
  prefs: []
  type: TYPE_TB
- en: '| `viewPost()` | `/``posts/{postId}` | `GET` | View a post detail |'
  prefs: []
  type: TYPE_TB
- en: '| `deletePost()` | `/``posts/{postId}` | `DELETE` | Delete a post |'
  prefs: []
  type: TYPE_TB
- en: '| `updatePost()` | `/``posts/{postId}` | `PUT` | Update a post |'
  prefs: []
  type: TYPE_TB
- en: '| `publishPost()` | `/``posts/{postId}/publish` | `PUT` | Publish a post |'
  prefs: []
  type: TYPE_TB
- en: '| `unpublishPost()` | `/``posts/{postId}/unpublish` | `PUT` | Unpublish a post
    |'
  prefs: []
  type: TYPE_TB
- en: Table 1.5 – Mapping HTTP methods for the Post resource
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have seen some other cases, such as using `POST` to update a resource.
    That works, but it does not follow the HTTP standard. Generally speaking, we can
    state the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` is used to read resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` is used to create child resources with a server-defined URL, such as
    `/posts`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` is used to create or replace the resource with a client-defined URL,
    such as `/posts/{postId}`.. In many cases, `PUT` can also be used to update a
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH` is used to update parts of the resource with a client-defined URL,
    such as `/posts/{postId}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning response codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to assign the HTTP response codes for the operations. There are
    some main response code categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2xx` **codes – success**: The action requested by the client was received,
    understood, and accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3xx` **codes – redirection**: The client must take additional action to complete
    the request. It is often used to indicate that the client should be redirected
    to a new location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4xx` **code – client errors**: The operation was not successful, but the client
    can try again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5xx` **codes – server errors**: The server has encountered an error or is
    incapable of performing the request. The client can retry in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common issue is that some developers invent their own response codes. For
    example, if we create a new post, we expect the server to return a `201 Created`
    response code. Some developers may use `200 OK` and include a status code in the
    response body. This is not a good idea. There are many layers between the server
    and the client. Using your own codes will probably cause problems for these middleware
    components. Make sure to use the right code for the right reason. Here are some
    common response codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP** **response code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `200 OK` | The standard response for successful HTTP requests. |'
  prefs: []
  type: TYPE_TB
- en: '| `201 Created` | The request has been fulfilled, resulting in a new resource
    being created. |'
  prefs: []
  type: TYPE_TB
- en: '| `202 Accepted` | The request has been accepted for processing, but processing
    has not been completed. |'
  prefs: []
  type: TYPE_TB
- en: '| `204` `No Content` | The server has successfully processed the request but
    does not return any content. This is common for delete operations. |'
  prefs: []
  type: TYPE_TB
- en: '| `400` `Bad Request` | The server cannot understand or process the request
    due to a client error, such as malformed syntax, a request size too large, or
    invalid input. The client should not repeat the request without modifications.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `401 Unauthorized` | The request requires user authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `403 Forbidden` | The server understood the request but is refusing action.
    This may be due to the fact that the client does not have the necessary permissions
    or is attempting a prohibited action. |'
  prefs: []
  type: TYPE_TB
- en: '| `404` `Not Found` | The requested resource could not be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Internal` `Server Error` | A generic error message. The server encountered
    an unexpected condition, so it cannot process the request, and no more specific
    messages are suitable at this time. |'
  prefs: []
  type: TYPE_TB
- en: '| `503` `Service Unavailable` | The server is currently unable to handle the
    request due to temporary overloading or maintenance of the server. The response
    should contain a `Retry-After` header if possible so that the client can retry
    after the estimated time, |'
  prefs: []
  type: TYPE_TB
- en: Table 1.6 – Common HTTP response codes
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the table that shows the response codes for each operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation name** | **URL** | **HTTP method** | **Response** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createPost()` | `/``posts` | `POST` | `Post, 201` | Create a new post |'
  prefs: []
  type: TYPE_TB
- en: '| `listPosts()` | `/``posts` | `GET` | `Post[], 200` | List all posts |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByCategory()` | `/``posts?categoryId={categoryId}` | `GET` | `Post[],
    200` | List posts by category |'
  prefs: []
  type: TYPE_TB
- en: '| `listPostsByTag()` | `/``posts?tag={tagId}` | `GET` | `Post[], 200` | List
    posts by tag |'
  prefs: []
  type: TYPE_TB
- en: '| `searchPosts()` | `/``posts?search={keyword}` | `GET` | `Post[], 200` | Search
    for posts by title, author, and content |'
  prefs: []
  type: TYPE_TB
- en: '| `viewPost()` | `/``posts/{postId}` | `GET` | `Post, 200` | View a post detail
    |'
  prefs: []
  type: TYPE_TB
- en: '| `deletePost()` | `/``posts/{postId}` | `DELETE` | `204, 404` | Delete a post
    |'
  prefs: []
  type: TYPE_TB
- en: '| `updatePost()` | `/``posts/{postId}` | `PUT` | `200` | Update a post |'
  prefs: []
  type: TYPE_TB
- en: '| `publishPost()` | `/``posts/{postId}/publish` | `PUT` | `200` | Publish a
    post |'
  prefs: []
  type: TYPE_TB
- en: '| `unpublishPost()` | `/``posts/{postId}/unpublish` | `PUT` | `200` | Unpublish
    a post |'
  prefs: []
  type: TYPE_TB
- en: Table 1.7 – Response codes for the Post resource
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to utilize the correct response code in order to prevent any
    misunderstandings. This will ensure that all communication is clear and concise,
    thus avoiding any potential confusion.
  prefs: []
  type: TYPE_NORMAL
- en: What if I want to create my own status codes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Technically, you can create your own status codes, but in practice, please
    stick as closely to the standards as possible. If you invent your own status codes,
    that would be risky. Your users might be in trouble consuming your APIs because
    they do not know your status codes. You should think about what the benefits are
    to have your own status codes. The convention is to respect the HTTP status codes
    defined in RFC. Before you create your own status codes, make sure you check the
    list of HTTP status codes first. Do not create your own status code unless you
    have strong reasons. You can find more information here: [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there might be some special situations where you want to indicate
    a more specific status in the response. For example, you might have an API that
    can process a task, but it might fail for different reasons. You might want to
    indicate a more detailed message in the response to let your users know what happened,
    rather than returning a common `4xx` code. You should think about the business
    logic carefully and differentiate between HTTP status codes and business status
    codes. If you cannot find a proper code in the HTTP status codes, and you do want
    to show a business-related status in the response, you can choose the HTTP status
    code to indicate the category of the response, and then attach a response body
    that contains your business status code. For example, you can return a response
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, the HTTP status code represents the common status of the operation, and
    in the response body, you can include some information that is specific to your
    system. We will discuss how to handle errors using the `Problem Details` object
    in [*Chapter 16*](B18971_16.xhtml#_idTextAnchor671).
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI is a popular REST API specification. It is a programming language-agnostic
    interface description for REST APIs, allowing both humans and computers to discover
    and understand the capabilities of a service without access to source code. Similar
    to an interface, it describes the inputs and outputs of an API, as well as how
    they should be transmitted. It is also known as the Swagger specification.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger versus OpenAPI
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, *Swagger* and *OpenAPI* are used interchangeably. The Swagger project
    was developed in early 2010s to define a simple contract for an API that contains
    everything needed to produce or consume an API. It was donated to the OpenAPI
    initiative in 2015\. So, OpenAPI refers to the API specification, and Swagger
    refers to the open-source and commercial projects from SmartBear, which work with
    the OpenAPI specification. In short, OpenAPI is a specification, and Swagger is
    tooling that uses the OpenAPI specification. Swagger UI is also one of the Swagger
    tools. At the time of writing, the latest version of OpenAPI was 3.1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use SwaggerHub to design an API based on the previous steps. Here is
    an example, which defines a simple API for a blog system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The other file of this file has been omitted.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding API documentation is a YAML file, which defines two models (resources)
    – `Post` and `Category` – and two operations – `GET` for searching posts and `POST`
    for creating a new post. For each operation, there are details about the input
    and output, including the expected response codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the API design is done, we can share the API documentation with other
    developers for integrations, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The SwaggerHub UI](img/B18971_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The SwaggerHub UI
  prefs: []
  type: TYPE_NORMAL
- en: Note that you might need to add more properties, based on your user stories
    and domains, before you share the API documentation with other teams. The API
    contract should be quite stable; otherwise, it will impact the consumers.
  prefs: []
  type: TYPE_NORMAL
- en: We have explained how to design a REST API. If you would like to learn how to
    start developing with ASP.NET Core, you can move on to [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068).
  prefs: []
  type: TYPE_NORMAL
- en: REST API is one of the most popular API styles. In the next section, we will
    introduce other API styles, such as RPC APIs, GraphQL APIs, and real-time APIs.
  prefs: []
  type: TYPE_NORMAL
- en: RPC and GraphQL APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While REST-based APIs are widely used in many scenarios today, it is not the
    only style of web API. For some scenarios, RPC-based APIs or GraphQL APIs may
    be better suited. It is important to understand the advantages and disadvantages
    of each style of API so that you can choose the right styles for your scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: What is an RPC-based API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RPC has existed for many years. It is the earliest, simplest form of web interaction.
    It is like a local call in some other languages, but it executes over a network.
    The client is given a list of available methods. Each method takes pre-defined,
    typed, and ordered parameters, returning a structured response result. So, the
    client can run on a different machine or in a different process but still work
    with the server, such as in the same application.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the client is tightly coupled to the server. If the server changes
    these methods or any parameters, the client will be affected. Developers must
    update the code of the client to match the new server methods. This can be a disadvantage
    of RPC-based APIs, but it can offer better performance.
  prefs: []
  type: TYPE_NORMAL
- en: The remote procedures are defined with the **interface definition language**
    (**IDL**). The IDL defines the methods and parameters of the remote procedure.
    Normally, some code generators can generate the client and server stubs based
    on the IDL. The code is strongly typed, which provides better type safety and
    error handling.
  prefs: []
  type: TYPE_NORMAL
- en: To implement an RPC-based API, there are some specifications for different languages.
    For example, WCF was a popular framework for RPC a couple of years ago. Some other
    popular frameworks include XML-RPC, SOAP PRC, JSON-RPC, and gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because RPC is like a local method call, you often see verbs in the method
    names. Unlike REST, RPC supports various operations beyond CRUD. Here is an example
    of a JSON-RPC request and response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One of the most popular RPC frameworks is gRPC, which we will discuss in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: What is gRPC?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most popular RPC frameworks is gRPC. It is a high-performance, open-source
    modern RPC framework for building network services and distributed applications.
    gRPC was initially created by Google, which used a RPC framework called Stubby.
    In March 2015, Google decided to make it open-source, resulting in gRPC, which
    is now used in many organizations outside of Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC has some awesome features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interoperability**: gRPC uses a **Protocol Buffer** (**protobuf**) file to
    declare services and messages, which enables gRPC to be completely language- and
    platform-agnostic. You can find gRPC tools and libraries for all major programming
    languages and platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protobuf` is a binary format, which has a smaller size and faster performance
    than JSON. It is not readable by humans, but it is readable by computers. HTTP/2
    also supports multiplexing requests over a single connection. It needs fewer resources,
    even in slower networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming**: gRPC is based on the HTTP/2 protocol, which makes it support
    bidirectional streaming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.proto`) to describe services with input and output. Then, they can use the
    `.proto` files to generate stubs for different languages or platforms. It is similar
    to the OpenAPI specification. Teams can focus on business logic and work on the
    same service in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: gRPC is designed to be secure. HTTP/2 is built on top of **Transport
    Layer Security** (**TLS**) end-to-end encrypted connection. It also supports client
    certificate authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these benefits, gRPC is a good choice for microservices-style architecture.
    It can efficiently connect services in and across data centers, even across load
    balancers. It is applicable in the last mile of distributed systems because service-to-service
    communication needs low latency and high performance. Also, the polyglot systems
    may have multiple languages or platforms, and gRPC can support different languages
    and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a gRPC `.``proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ASP.NET Core provides great support for gRPC. With the `.proto` file, the .NET
    types for services, clients, and messages can be automatically generated in a
    .NET project. We will learn how to develop the gRPC service in [*Chapter 11*](B18971_11.xhtml#_idTextAnchor438).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, gRPC is not a silver bullet. There are several factors we need to
    consider before we choose gRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight coupling due to protocol changes**: The client and server are tightly
    coupled because of the protocol. Once the protocol changes, the client and server
    must be updated, even just changing the order of the parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protobuf` is a non-human readable format, so debugging is not convenient.
    Developers need additional tools to analyze the payloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grpcweb`, that can provide a library to perform conversions between gRPC and
    HTTP/1.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` method, which is not cacheable for the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A steeper learning curve**: Unlike REST, which is human-readable, many teams
    find gRPC challenging to learn. They need to learn protobuf and HTTP/2 and look
    for proper tools to deal with the message content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, should we choose gRPC or REST?
  prefs: []
  type: TYPE_NORMAL
- en: Should I use gRPC instead of a REST API?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is challenging to choose gRPC over REST for most server-client scenarios.
    A REST-based API is well supported by all browsers, so it has a wider adoption
    nowadays. If you need to support browser clients, REST is a better choice compared
    with gRPC. However, gRPC has some features that are useful in certain circumstances,
    such as high-performance communication, real-time communication, low bandwidth,
    and multiple language environments. So, it is a good choice for microservices-style
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a microservices architecture, the services are loosely coupled, and each
    one does a specific task or processes specific data. They need to be able to communicate
    with each other with simplicity and efficiency without considering browser compatibility.
    gRPC is suitable for this scenario because it is based on HTTP/2, which is a high-performance
    protocol and provides bidirectional streaming, binary messaging, and multiplexing.
    **Dapr**, which is a portable, event-driven runtime for microservices, implements
    gRPC APIs so that apps can communicate with each other via gRPC. We will not discuss
    Dapr in this book, but if you are interested, you can find more information here:
    [https://dapr.io/](https://dapr.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, using gRPC or REST depends on your use-case demands.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC API design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The gRPC API design process is very similar to the REST API design process.
    In fact, the first three steps are similar to the REST API design process. We
    need to identify the resources, define the relationships between resources, and
    identify operation events as well.
  prefs: []
  type: TYPE_NORMAL
- en: Next, use the information from the first three steps to design and document
    the gRPC API. When we convert the operation events to gRPC operations, there are
    some differences. REST API uses HTTP methods to represent the operations. In gRPC,
    these operations are like the methods of the service, which means we can use verbs
    in the method names. For example, the method to get a post can be represented
    as `GetPost()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC uses protobuf as the IDL. When we design a gRPC API, we actually need
    to author the `.proto` files. These `.proto` files consist of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the gRPC service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messages that are used in the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is similar to the REST OpenAPI definition but has a different syntax.
    Each request needs a type-defined message that includes the sorted input parameters.
    Each response returns a message, an array of messages, or an error status response.
    We can have a `.proto` file for the blog system, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Now, the `.proto` file has a basic gRPC service definition, including
    the message definitions. Next, we can use various tools to generate the code for
    the gRPC service and the client. In the development stage, we may need to frequently
    change the gRPC protocol definition by updating the `.proto` files. The changes
    will be reflected in the generated code. So, please consider carefully before
    you publish the service for consumption. We will discuss more about gRPC in [*Chapter
    11*](B18971_11.xhtml#_idTextAnchor438). If you would like to start gRPC development
    with .NET 8 now, please jump to that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: What is a GraphQL API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think about the scenarios that use REST APIs. We may find some issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/posts` endpoint, which returns a list of the posts. When we show a post list
    page, we only need some properties such as `Title`, `PublishDate`, and `Category`.
    But the posts returned from the endpoint may contain more information about the
    posts, such as `IsPublished`, which is useless for clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/posts/{postId}` endpoint that shows the post information and a `/posts/{postId}/related`
    endpoint that shows related posts. If we want to show a post detail, the client
    will need to call the `/posts/{postId}` endpoint, but the related posts are not
    provided in the response. So, the client will have to make another request to
    `/posts/{postId}/related` to get the related posts. The N+1 problem often refers
    to the parent-child relationship. The endpoint that returns the collection resource
    does not provide enough information about the child resources for the clients.
    For example, the `/posts` endpoint returns a list of posts, but the response does
    not have the content summary for each post. To show the content summary on the
    post list page, the client will have to call the `/posts/{postId}` endpoint for
    each post to get the content summary. So, the total number of requests will be
    `n + 1`, where `n` is the number of posts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The over- and under-fetching problems are some of the most common problems with
    REST-based APIs. Because REST-based APIs center on resources, for each endpoint,
    the response structure is fixed and encoded in the URL, so it is not flexible
    for client requirements.
  prefs: []
  type: TYPE_NORMAL
- en: These problems can be overcome with a GraphQL API. A GraphQL API is another
    API style, which offers powerful query capabilities. It supports fetching data
    with a flexible structure based on the client’s needs. It can fetch data by a
    resource identifier, paginated listing, filtering, and sorting. It also supports
    mutating data as well, like CRUD in REST.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GraphQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL is a powerful query language for executing queries with a flexible data
    structure. It was developed internally by Facebook in 2012, following which it
    was released publicly in 2015\. Now, it is open-source and maintained by a large
    community of companies and individuals from all around the world.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL solves the over- and under-fetching problem by providing more flexibility
    and efficiency. It is not tied to any database or storage engine, nor to any specific
    languages. There are many libraries to implement GraphQL services and clients.
    A GraphQL service defines types and fields on your resource types, and then provides
    functions for each field on each type.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike REST, which uses *resources* as its core concept and defines URLs that
    return a fixed data structure for each resource, the conceptual model of GraphQL
    is an entity graph. So, all GraphQL operations are performed through a single
    HTTP `POST`- or `GET`-based endpoint, which is usually `/graphql`. It is completely
    flexible and allows the client to decide what data structure it needs. The GraphQL
    service receives GraphQL queries to validate whether a query refers to the correct
    types and fields defined, and then it executes the functions to return the correct
    data structure. The format of requests and responses is JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides solving the over- and under-fetching problem, GraphQL has some other
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL reduces the complexity of maintaining API versions. There is only one
    endpoint and one version of the graph. It allows the API to evolve without breaking
    the existing clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL uses a strong type system to define the types and fields in a schema
    using SDL. The schema behaves as the contract, which reduces the miscommunication
    between the client and the server. Developers can develop frontend applications
    by mocking the required data structures. Once the server is ready, they can switch
    to the actual API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL does not define the specific application architecture, which means it
    can work on top of an existing REST API to reuse some code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The payload is smaller because clients get what they exactly request without
    over-fetching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also some disadvantages of using GraphQL:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL presents a high learning curve for REST API developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the server is more complicated. The query could be complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL uses a single endpoint, which means it cannot leverage the full capabilities
    of HTTP. It does not support HTTP content negotiation for multiple media types
    beyond JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is challenging to enforce the authorization because, normally, the API gateway
    enforces access control based on URLs. Rate-limiting is also often associated
    with the path and HTTP methods. So, you need more consideration to adopt the new
    style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching is complicated to implement because the service does not know what data
    clients need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File uploads are not allowed, so a separate API for file handling is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL API design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A GraphQL query is flexible, so clients can send various queries based on their
    requirements. To design the GraphQL API, we need to define the GraphQL schema
    first, which is the core of every GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL uses the GraphQL SDL to define GraphQL schemas. SDL has a type system
    that allows us to define the data structure, like the other strongly typed languages,
    such as C#, Java, TypeScript, Go, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the following types and fields in the GraphQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A GraphQL request uses a query language to describe the desired fields and
    structure the client needs. The following is a simple query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding query, we can omit the `isPublished` field and include related
    posts in the response, so the client does not need to send more requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify data or perform a calculation logic, GraphQL establishes a convention
    called *mutation*. We can think of mutation as a way to update the data. The following
    request is a mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are some tools to generate GraphQL documents and test the service, such
    as GraphiQL,GraphQL Playground, and so on. We will not discuss GraphQL much further
    now. In [*Chapter 12*](B18971_12.xhtml#_idTextAnchor484), we will learn how to
    use ASP.NET Core 8 to develop GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss another API style, which is the real-time API.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have introduced some web API styles, such as REST-based APIs, gRPC APIs,
    and GraphQL APIs. They all follow the request/response pattern – the client sends
    a request to the server, and the server returns a response. This pattern is easy
    to understand. However, this pattern may not be suitable for some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we have an application that contains two parts – the server, which
    is a fire station, and the clients, which are the fire engines. How can we notify
    the fire engines when an incident occurs?
  prefs: []
  type: TYPE_NORMAL
- en: If we use the request/response pattern, the clients need to send requests to
    the server to get the latest notification regarding the incident. But what is
    the best frequency of sending requests? 1 minute, or 10 seconds? Think about how
    urgent the incident is. If the fire engine gets a notification after a 10-second
    delay, this might be a problem, as the fire might be more serious and urgent!
    So, what about sending requests every 1 second? Then, the server would be very
    busy, and most of the time, it just returns a `No incident` response. With the
    request/response pattern, the server cannot push the notifications to the clients,
    so it is not suitable for this case. This leads us to the problem of API polling.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with API polling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The request/response pattern has limitations. The server cannot notify the clients
    about what changes are happening on the server side. If the client needs to get
    the latest data, it has to frequently send requests to the server before receiving
    any updates.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the client would like to know when a new post is published,
    it needs to call `/posts/latest` to get the latest post. The client may set up
    an interval to send the request periodically. This pattern is called API polling,
    which is a common solution for clients that need to be updated for resource changes.
  prefs: []
  type: TYPE_NORMAL
- en: API polling does not have many differences from the common REST APIs. It can
    be implemented based on the request/response pattern. However, it is not the ideal
    solution for this kind of scenario. Normally, the frequency of resource changes
    is not predictable, so it is hard to decide the frequency of the requests. If
    the interval is too short, the client may send too many unnecessary requests and
    the server will handle too many queries. However, if the interval is too long,
    the clients cannot get the latest changes in time. In particular, if the application
    needs to notify clients in real-time, then the system would be very busy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more challenges when we use API polling:'
  prefs: []
  type: TYPE_NORMAL
- en: The logic to check the resource changes is complex. It may implement the logic
    in the server, so the server needs to check the timestamp in the request and then
    query the data, based on the timestamp. Alternatively, the client queries all
    the data and compares the collection with the data from the previous request.
    It brings a lot of complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hard to check whether a specific event has occurred – for example, creating
    resources and updating resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate-limiting may block the client from sending too many requests at the desired
    intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ideal way to solve the problem of API polling is to allow the server to
    send events to the clients in real-time, rather than constantly polling and implementing
    the logic to check for changes. This is a different pattern from the request/response
    pattern. It supports real-time communication between servers and clients, which
    enables new possibilities for the application. This is what a real-time API can
    do.
  prefs: []
  type: TYPE_NORMAL
- en: What is a real-time API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A real-time API goes beyond the traditional REST APIs. It provides some benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The application can respond to internal events in real-time. For example, if
    a new post is published, the client can get the notification immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can improve API efficiency by reducing the number of requests. The clients
    do not need API polling to check the resource changes. Instead, the server sends
    messages to clients when some events occur. It reduces the resources required
    during communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some technologies can implement real-time APIs, such as long polling, **Server-Sent
    Events** (**SSE**), WebSocket, SignalR, and gRPC streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a quick look at these.
  prefs: []
  type: TYPE_NORMAL
- en: Long polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The API polling problem we described previously is called short polling or regular
    polling, which is easy to implement but less efficient. The client cannot receive
    an update from the server in real-time. To overcome this issue, long polling is
    another choice.
  prefs: []
  type: TYPE_NORMAL
- en: Long polling is a variation of short polling, but it is based on *Comet*, which
    is a web application model in which a long-held HTTPS request allows a web server
    to push data to a browser, without it having to request it explicitly. Comet contains
    multiple techniques to implement long polling. It also has many names, such as
    Ajax push, HTTP streaming, and HTTP server push.
  prefs: []
  type: TYPE_NORMAL
- en: To use long polling, the client sends the request to the server but with the
    expectation that the server may not respond immediately. When the server receives
    the request, if there is no new data for the client, the server will keep the
    connection alive. If there is something available, the server will send the response
    to the client and complete the open request. The client receives the response
    and usually makes a new request right away or after a pre-defined interval to
    establish the connection again. The operation is repeated. In this way, it can
    effectively emulate the server push feature.
  prefs: []
  type: TYPE_NORMAL
- en: There are some considerations when using long polling. The server needs to manage
    multiple connections and preserve the session state. If the architecture becomes
    more complex (for example, when multiple servers or load balancers are in use),
    then it leads to the session stickiness issue, which means the subsequent client
    requests with the same session must be routed to the same server to which the
    original request was handled. It is hard to scale the application. Also, it is
    hard to manage the message order. If the browser has two tabs open and sends multiple
    requests simultaneously to write data, the server will not know which request
    is the latest.
  prefs: []
  type: TYPE_NORMAL
- en: Long polling is supported by many web browsers. In recent years, SSE and WebSocket
    have been widely adopted, so long polling is not the first choice anymore. Now,
    it is usually accompanied by other technologies or as a fallback. For example,
    SignalR uses long polling as a fallback when WebSocket and SSE are not available.
  prefs: []
  type: TYPE_NORMAL
- en: SSE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SSE is a server push technology that allows the server to send events to the
    web browser. SSE was first proposed in 2004 as part of the *WHATWG Web Applications
    1.0*. It is based on the EventSource API, which is a standard API of HTML5\. The
    Opera web browser implemented this feature in 2006\. Now, all modern browsers
    support SSE.
  prefs: []
  type: TYPE_NORMAL
- en: In SSE, the client behaves as a subscriber, initializing the connection by creating
    a new JavaScript `EventSource` object, passing the URL of the endpoint to the
    server over a regular HTTP `GET` request with the media type of `text/event-stream`.
    Once connected, the server keeps the connection open and pushes new events separated
    by a newline character to the client, until it has no more events to send, or
    until the client explicitly closes the connection by calling the `EventSource.close()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If the client lost the connection for any reason, it could reconnect to receive
    new events. To recover from the failure, the client can provide a `Last-Event-ID`
    header to the server to specify the last event ID that the client received. Then,
    the server can use this information to determine whether the client missed any
    events.
  prefs: []
  type: TYPE_NORMAL
- en: SSE is suitable for scenarios where real-time notifications have to be sent
    to the client when the data changes from the server, in order to keep a user interface
    in sync with the latest data state. Examples include Twitter updates, stock price
    updates, news feeds, alerts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of SSE is that it is unidirectional, so it cannot be used to
    send data from the client to the server. Once the client connects to the server,
    it can receive responses only, but it cannot send new requests on the same connection.
    If you need bidirectional communication, WebSocket may be a better option.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebSocket is a protocol that provides full-duplex communication between a client
    and a server within a single TCP connection. It allows the client to send requests
    to the server, while the server can push events and responses back to the client
    in real-time. WebSocket was first referenced as a TCP-based socket API in the
    HTML5 specification. In 2008, the WebSocket protocol was standardized by W3C.
    Google Chrome was the first browser to support WebSocket in 2009\. Now, WebSocket
    is supported in most modern browsers, including Google Chrome, Microsoft Edge,
    Firefox, Safari, and Opera.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the HTTP protocol, WebSocket enables a two-way ongoing conversation between
    the client and server. The communication is usually done over a TCP port `443`
    connection (or `80` if there is an unsecure connection), so it can be easily configured
    in a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a WebSocket perspective, the message content is opaque. A subprotocol
    is required to specify an agreement between the client and server. WebSocket can
    support both text and binary format subprotocols. As part of the initial handshake
    process, the client can specify which subprotocols it supports. Then, the server
    must pick one of the protocols that the client supports. This is called subprotocol
    negotiation. You can find many subprotocols officially registered here: [https://www.iana.org/assignments/websocket/websocket.xml](https://www.iana.org/assignments/websocket/websocket.xml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The WebSocket protocol defines `ws` and `wss` as the URI schemas that are used
    for unencrypted and encrypted connections, respectively. It is always recommended
    to use `wss` to make sure the transport security layer encrypts data. For example,
    we can use the following code to create a WebSocket connection in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: WebSocket does not define how to manage the events for the connections, such
    as reconnection, authentication, and so on. The client and server would need to
    manage those events. There are various libraries to implement WebSocket for different
    languages. For example, *Socket.IO* ([https://socket.io](https://socket.io)) is
    a popular library that implements WebSocket servers and clients in JavaScript,
    Java, Python, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket is a great choice for real-time communications, such as online games,
    sales updates, sports updates, online chat, real-time dashboards, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Uni-directional versus bidirectional
  prefs: []
  type: TYPE_NORMAL
- en: Uni-directional communication is like a radio. SSE is uni-directional because
    the server broadcasts data to clients, but clients cannot send data to the server.
    Bidirectional communication supports two-way communication. There are two types
    of bidirectional communication – half-duplex and full-duplex.
  prefs: []
  type: TYPE_NORMAL
- en: Half-duplex communication is like a walkie-talkie. Both the server and client
    can send messages to each other, but only one party may send messages at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Full-duplex communication is like a telephone. The message can be sent from
    either side at the same time. WebSocket is full-duplex.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduced gRPC in the previous section. As we mentioned, gRPC is based on
    the HTTP/2 protocol, which provides a foundation for long-lived, real-time communication.
    Unlike HTTP/1.1, which requires a new TCP socket connection for each request,
    one HTTP/2 connection can be used for one or more simultaneous requests, so this
    avoids the overhead of creating new connections for each request. Also, HTTP/2
    supports pushing data to clients without them having to request it. It is a huge
    improvement over the request/response pattern of HTTP/1.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC takes advantage of the HTTP/2 protocol to support bidirectional communication.
    A gRPC service supports these streaming combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: Unary (No streaming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-to-client streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-to-server streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both gRPC and WebSocket support full-duplex communication, but, unlike WebSocket,
    gRPC uses `protobuf` by default, so it does not need to select a subprotocol.
    However, browsers have no built-in support for gRPC, so gRPC streaming is often
    used for service-to-service communication.
  prefs: []
  type: TYPE_NORMAL
- en: Which real-time communication technology is best for your application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of choices for your real-time application. So, how do we
    choose? It is important to note that it depends on the circumstances and constraints
    of your application. For example, do you need a push-only application or bidirectional
    communication? Do you want to support most browsers or just server-to-service
    communication? Do you need to push data to multiple clients or just one client?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Microsoft provides **SignalR** in ASP.NET Core to implement real-time
    communication. SignalR is an open-source library that enables real-time communication
    between clients and servers. It can automatically manage the connections and allow
    servers to send messages to all connected clients or a specific group of clients.
    Note that SignalR encapsulates multiple technologies, including WebSocket, SSE,
    and long polling. It hides the details and the complex implementations of these
    protocols. As a result, we do not need to worry about which technology is used
    for real-time communication. SignalR automatically chooses the best transport
    method for your application. WebSocket is the default protocol. If WebSocket is
    unavailable, SignalR will fall back to SSE, and then long polling.
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalR is a good choice for these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When clients require high-frequency updates or alerts/notifications from the
    server – for example, games, social networks, voting, auctions, maps, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboard and monitoring applications – for example, system dashboard applications,
    instant diagram applications, sales data monitoring applications, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative applications – for example, chat applications,whiteboard applications,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core also provides good support to gRPC. So, the next question is, how
    do you choose between gRPC and SignalR?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some thoughts you may want to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If your need to build a real-time application that supports multiple clients
    (browsers), you may use SignalR because it is well-supported by browsers, and
    gPRC is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to build a distributed application or a microservices architecture
    application where you want to communicate between multiple servers, you may use
    gRPC because it is more suitable for server-to-server communication, and is more
    efficient than SignalR in this scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced some different API styles, including REST-based
    APIs, gRPC APIs, and GraphQL APIs, and explored how to design them. We also introduced
    a couple of different ways to implement real-time communication, including WebSocket,
    gRPC streaming, and SignalR. So far, we have not touched on much code, but we
    have reviewed the basic concepts of web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to learn how to use ASP.NET Core to implement
    them.
  prefs: []
  type: TYPE_NORMAL
