- en: '*Chapter 1*: Designing and Architecting the Enterprise Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise applications are software solutions designed to solve large and complex
    problems for enterprise organizations. They enable *Order-to-Fulfillment* capabilities
    for enterprise customers in the IT, government, education, and public sectors.
    They empower them to digitally transform their businesses with capabilities such
    as product purchasing, payment processing, automated billing, and customer management.
    When it comes to enterprise applications, the number of integrations is quite
    high, and the volume of users is also very high as, typically, applications are
    targeted at a global audience.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that enterprise systems remain highly reliable, highly available,
    and highly performant, getting the design and architecture right is very important.
    Design and architecture form the foundation of any good software. They form the
    basis of the rest of the software development life cycle; therefore, it is very
    important to, first, get the right design to avoid any rework later, which could
    prove very expensive, depending on the changes required. So, you need a flexible,
    scalable, extensible, and maintainable design and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A primer on common design principles and patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding common enterprise architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying enterprise application requirements (business and technical)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting an enterprise application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution structuring for an enterprise application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to start designing and architecting
    enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: A primer on common design principles and patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every piece of software in the world solves at least one real-world problem.
    As time goes by, things change, including what we expect from any specific software.
    To manage this change and deal with various aspects of software, engineers have
    developed several programming paradigms, frameworks, tools, techniques, processes,
    and principles. These principles and patterns, proven over time, have become guiding
    stars for engineers to build quality software.
  prefs: []
  type: TYPE_NORMAL
- en: Principles are high-level abstract guidelines to be followed while designing.
    They are applicable regardless of the programming language being used. They do
    not provide implementation guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns are low-level specific implementation guidelines that are proven, reusable
    solutions for recurring problems. First, let's start with design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Techniques become principles if they are widely accepted, practiced, and proven
    to be useful in any industry. Those principles become solutions to make software
    designs more understandable, flexible, and maintainable. In this section, we will
    cover the SOLID, KISS, and DRY design principles.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SOLID principles are a subset of the many principles promoted by an American
    software engineer and instructor, Robert C. Martin. These principles have become
    the de facto standard principles in the OOP world and have become part of the
    core philosophy for other methodologies and paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID is an acronym for the following five principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-responsibility principle** (**SRP**): An entity or software module
    should only have a single responsibility. You should avoid granting multiple responsibilities
    to one entity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – SRP'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – SRP
  prefs: []
  type: TYPE_NORMAL
- en: '**Open-closed principle** (**OCP**): Entities should be designed in such a
    way that they are open for extension but closed for modification. This means the
    regression testing of existing behaviors can be avoided; only extensions need
    to be tested.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.2 – OCP'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – OCP
  prefs: []
  type: TYPE_NORMAL
- en: '**Liskov substitution principle** (**LSP**): Parent or base class instances
    should be replaceable with instances of their derived classes or subtypes without
    altering the sanity of the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – LSP'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – LSP
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface segregation principle** (**ISP**): Instead of one common large
    interface, you should plan multiple, scenario-specific interfaces for better decoupling
    and change management:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – ISP'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – ISP
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency inversion principle** (**DIP**): You should avoid having any direct
    dependency on concrete implementations. High-level modules and low-level modules
    should not depend on each other directly. Instead, both should depend on abstractions
    as much as possible. Abstractions should not depend on details, and details should
    depend on abstractions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – DIP'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – DIP
  prefs: []
  type: TYPE_NORMAL
- en: Don't Repeat Yourself (DRY)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With DRY, a system should be designed in such a way that the implementation
    of a feature or a pattern should not be repeated in multiple places. This would
    result in maintenance overhead, as a change in requirements would result in modifications
    being needed at multiple places. If you fail to make a necessary update in one
    place by mistake, the behavior of the system will become inconsistent. Rather,
    the feature should be wrapped into a package and should be reused in all places.
    In the case of a database, you should look at using data normalization to reduce
    redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – DRY'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – DRY
  prefs: []
  type: TYPE_NORMAL
- en: This strategy helps in reducing redundancy and promoting reuse. This principle
    helps an organization's culture too, encouraging more collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Keep it simple, stupid (KISS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With KISS, a system should be designed as simply as possible, avoiding complicated
    designs, algorithms, new untried technologies, and more. You should focus on leveraging
    the right OOP concepts and reusing proven patterns and principles. Include new
    or non-simple things only if it is necessary and adds value to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you keep it simple, you will be able to do the following better:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid mistakes while designing/developing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the train running (there is always a team whose job is to maintain the
    system, even though they are not the team that developed the system in the first
    place).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and understand your system code (your system code needs to be understandable
    to people who are new to it or for people who will use it in the future).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do better and less error-prone change management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we are done with our primer on common design principles; we have
    learned about SOLID, DRY, and KISS. In the next section, we'll look at some common
    design patterns in the context of real-world examples to help you understand the
    difference between principles and patterns and when to leverage which pattern—a
    skill that's essential for good design and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While following design principles in the OOP paradigm, you might see the same
    structures and patterns repeating over and again. These repeating structures and
    techniques are proven solutions to common problems and are known as **design patterns**.
    Proven design patterns are easy to reuse, implement, change, and test. The well-known
    book, *Design Patterns: Elements of Reusable Object-Oriented Software*, comprising
    what is known as the **Gang of Four** (**GOF**) design patterns, is considered
    the bible of patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can categorize the GOF patterns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creative**: Helpful in creating objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural**: Helpful in dealing with the composition of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: Helpful in defining the interactions between objects and distributing
    responsibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these patterns with some real-life examples.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at some creational design patterns, along with relevant
    examples, in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.1 – Creational design patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_1.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1 – Creational design patterns
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table includes some examples of structural design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.2 – Structural design patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_1.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.2 – Structural design patterns
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table includes some examples of behavioral design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.3 – Behavioral design patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_1.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.3 – Behavioral design patterns
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you can become overwhelmed by all these patterns being inside the
    table. But really, any design is a good design until it violates the basic principles.
    One rule of thumb that we can use is to *go back to the basics*, and in design,
    principles are the basics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Patterns versus principles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Patterns versus principles
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with our primer on common design principles and patterns.
    By now, you should have a good understanding of the different principles and patterns,
    where to use them, and what it takes to build a great solution. Now, let's spend
    some time looking at common enterprise architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding common enterprise architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few principles and architectures that are commonly practiced when
    designing enterprise applications. First and foremost, the goal of any architecture
    is to support business needs at the lowest cost possible (costs being time and
    resources). A business wants software to enable it rather than act as a bottleneck.
    In today's world, availability, reliability, and performance are the three KPIs
    of any system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, first, we will look at the issues with monolithic architectures,
    and then we will see how to avoid them by using widely adopted and proven architectures
    for developing enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a classical monolithic e-commerce website application, such as the
    one shown in the following diagram, with all the business providers and functionality
    in a single app and data being stored in a classical SQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – A monolithic app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – A monolithic app
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic architecture was widely adopted 15–20 years ago, but plenty of
    problems arose for software engineering teams when systems grew and business needs
    expanded over time. Let's look at some of the common issues with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Common issues with monolithic apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the scaling issues:'
  prefs: []
  type: TYPE_NORMAL
- en: In a monolithic app, the only way to horizontally scale is by adding more compute
    to the system. This leads to higher operational costs and unoptimized resource
    utilization. Sometimes, scaling becomes impossible due to conflicting needs in
    terms of resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As all the features mostly use single storage, there is the possibility of locks
    leading to high latency, and there will also be physical limits as to how far
    a single storage instance can scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a list of issues associated with availability, reliability, and performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Any changes in the system will require the redeployment of all components, leading
    to downtime and low availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any non-persistent state, such as sessions stored in a web app, will be lost
    after every deployment. This will lead to the abandonment of all workflows that
    were triggered by users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any bugs in a module, such as memory leaks or security bugs, make all the modules
    vulnerable and have the potential to impact the whole system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the highly coupled nature and sharing of resources within modules, there
    will always be unoptimized use of resources, leading to high latency in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, let''s see what the impact on the business and engineering teams is:'
  prefs: []
  type: TYPE_NORMAL
- en: The impact of a change is difficult to quantify and requires extensive testing.
    Hence, it slows down the rate of delivery to production. Even a small change will
    require the entire system to be deployed again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a single highly coupled system, there will always be physical limits on collaborations
    across teams to deliver any features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New scenarios such as mobile apps, chatbots, and analysis engines will take
    more effort as there are no independent reusable components or services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment is almost impossible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try to solve these common problems by adopting some proven principles/
    architectures.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Separation of concerns/single-responsibility architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software should be divided into components or modules based on the kind of work
    it performs where every module or component owns a single responsibility from
    the entire software's responsibility. Interaction between components happens via
    interfaces or messaging systems. Let's look at the n-tier and microservices architecture
    and how the separation of concerns is taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: N-tier architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'N-tier architecture divides the application of a system into three (or n) tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation** (known as the UX layer, the UI layer, or the work surface)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business** (known as the business rules layer or the services layer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data** (known as the data storage and access layer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – N-tier architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.9_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – N-tier architecture
  prefs: []
  type: TYPE_NORMAL
- en: These tiers can be owned/managed/deployed separately. For example, multiple
    presentation layers, such as the web, mobile, and bot layers, can leverage the
    same business and data tier.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Microservices architecture consists of small, loosely coupled, independent,
    and autonomous services. Let''s see their benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Services can be deployed and scaled independently. An issue in one service will
    have a local impact and can be fixed by just deploying the impacted service. There
    is no compulsion to share technology or frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services communicate with each other via well-defined APIs or messaging systems
    such as the Azure service bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Microservices architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.10_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – Microservices architecture
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, a service can be owned by independent
    teams and have its own cycle. Services are responsible for managing their own
    data stores. Scenarios demanding lower latency can be optimized by bringing in
    a cache or high-performance NoSQL stores.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless services architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services should not have any state. State and data should be managed independently
    from services, that is, externally through a data store such as a distributed
    cache or a database. By delegating the state externally, services will have the
    resources to serve more requests with high reliability. The following diagram
    shows an example of stateful services on the left-hand side. Here, state is maintained
    in each service through an in-memory cache or session provider, whereas a stateless
    service, as shown on the right-hand side, manages state and data externally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Stateful (left) versus stateless (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.11_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – Stateful (left) versus stateless (right)
  prefs: []
  type: TYPE_NORMAL
- en: Session affinity should not be enabled as it leads to sticky session issues
    and will stop you from getting the benefits of load balancing, scalability, and
    the distribution of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main features of event-driven architectures are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In an event-driven architecture, communication, which is generally known as
    **publisher-subscriber communication**, between modules, is primarily asynchronous
    and achieved via events. Producers and consumers are totally decoupled from each
    other. The structure of the event is the only contract that is exchanged between
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be multiple consumers of the same event taking care of their specific
    operations; ideally, they won't even be aware of each other. Producers can continuously
    push events without worrying about the availability of consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishers publish events via a messaging infrastructure such as queues or a
    service bus. Once an event has been published, the messaging infrastructure is
    responsible for sending the event to eligible subscribers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Event-driven architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.12_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – Event-driven architecture
  prefs: []
  type: TYPE_NORMAL
- en: This architecture is best suited for scenarios that are asynchronous in nature.
    For example, long-running operations can be queued for processing. A client might
    poll for status or even act as a subscriber for an event.
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the communication between components increases, so does the possibility of
    failures. A system should be designed to recover from any kind of failure. We
    will cover a few strategies for building a fault-tolerant system that can heal
    itself in the case of failures.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Azure, you'll know that applications, services, and
    data should be replicated globally in at least two Azure regions for planned downtime
    and unplanned transient or permanent failures, as shown in the following screenshot.
    In these scenarios, choosing Azure App Service to host web applications, using
    REST APIs, and choosing a globally distributed database service, such as Azure
    Cosmos DB, is wise. Choosing Azure paired regions will help in **business continuity
    and disaster recovery** (**BCDR**), as at least one region in each pair will be
    prioritized for recovery if an outage affects multiple regions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Resiliency architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.13_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – Resiliency architecture
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to tackle different types of faults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transient faults can occur in any type of communication or service. You need
    to have a strategy to recover from transient faults, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the operation and type of transient fault. Then, determine the appropriate
    retry count and interval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid anti-patterns such as endless retry mechanisms with a finite number of
    retries or circuit breakers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a failure is not transient, you should respond to the failure gracefully
    by choosing some of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Failing over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compensating for any failed operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling/blocking the bad client/actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a leader election to select a leader in the case of a failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, telemetry plays a big role; you should have custom metrics to keep a tab
    on the health of any component. Alerts can be raised when a custom event occurs
    or a specific metric reaches a certain threshold.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with our coverage of common enterprise architectures.
    Next, we will look at the requirements of enterprise applications and their different
    architectures through the lens of the design principles and common architectures
    that we learned about earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying enterprise application requirements (business and technical)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next few chapters, we will build a working e-commerce application. It
    will be a three-tier application consisting of a UI layer, a service layer, and
    a database. Let's look at the requirements for this e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: The solution requirements are the capabilities to be implemented and made available
    in the product to solve a problem or achieve an objective.
  prefs: []
  type: TYPE_NORMAL
- en: The business requirements are simply the end customer's needs. In the IT world,
    *business, generally, refers to customers*. These requirements are collected from
    various stakeholders and documented as a single source of truth for everyone's
    preference. Eventually, this becomes the backlog and scope of work to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: The technical requirements are the technology-related aspects that a system
    should implement, such as reliability, availability, performance, and BCDR. These
    are also known as **quality-of-service** (**QoS**) requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break the typical business requirements for an e-commerce application
    site down into the following categories: **Epic**, **Feature**, and **User Story**.'
  prefs: []
  type: TYPE_NORMAL
- en: The application's business requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following screenshot, from Azure DevOps, shows a summary of the backlog
    of our business requirements. You can see the different features that are expected
    in our application along with the user stories.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – Requirement backlog from Azure DevOps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.14_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – Requirement backlog from Azure DevOps
  prefs: []
  type: TYPE_NORMAL
- en: The application's technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having seen the business requirements, let''s now go through the technical
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The e-commerce application should be **highly available**, that is, available
    for 99.99% of the time during any 24-hour period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The e-commerce application should be **highly reliable**, that is, reliable
    for 99.99% of the time during any 24-hour period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The e-commerce application should be **highly performant**, that is, 95% of
    operations should take less than or be equal to 3 seconds during any 24-hour period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The e-commerce application should be **highly scalable**: It should automatically
    scale up/down based on the varying load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The e-commerce application should have **monitoring and alerts**: An alert
    should be sent to a support engineer in the case of any system failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the **technical aspects** and requirements that have been identified
    for the e-commerce application:'
  prefs: []
  type: TYPE_NORMAL
- en: The frontend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A web application (e-commerce) using ASP.Net 6.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logging/caching/configuration in C# 10.0 and .Net 6.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle tier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Azure API gateway to implement authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user management service through an ASP.NET 6.0 web API to add/remove users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product and pricing services through an ASP.NET 6.0 web API to get products
    from the data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A domain data service through an ASP.NET 6.0 web API to get the domain data,
    such as country data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A payment service through an ASP.NET 6.0 web API to complete payments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An order processing service through an ASP.NET 6.0 web API to submit and search
    orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An invoice processing service through an ASP.NET 6.0 web API to generate invoices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notification service through an ASP.NET 6.0 web API to send notifications
    such as emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data tier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A data access service through an ASP.NET 6.0 web API to talk to Azure Cosmos
    DB to read/write data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity Framework Core to access data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Cosmos DB as a backend data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Service Bus for asynchronous message processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure App Service to host the web application and web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Traffic Manager for high availability and responsiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Application Insights for diagnostics and telemetry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure paired regions for better resiliency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure resource groups to create **Azure Resource Manager** (**ARM**) templates
    and deploy them to the Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Pipelines for **continuous integration and continuous deployment** (**CI/CD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now done with the requirements of the enterprise application. Next, we
    will look at how to architect an enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting an enterprise application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following architectural diagram depicts what we are building. We need to
    bear in mind all of the design principles, patterns, and requirements that we
    have seen in this chapter when we are architecting and developing the application.
    The following diagram shows the proposed architecture for our e-commerce enterprise
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – The e-commerce application''s three-tier architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.15_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.15 – The e-commerce application's three-tier architecture
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns/SRP** has been taken care of at each tier. The presentation
    tier, containing the UI, is separated from the services tier containing the business
    logic. This is again separated from the data access tier containing the data store.'
  prefs: []
  type: TYPE_NORMAL
- en: The high-level components are unaware of the low-level components consuming
    them. The data access tier is unaware of the services consuming it, and the services
    are unaware of the UX tier consuming them.
  prefs: []
  type: TYPE_NORMAL
- en: Each service is separated based on the business logic and functionality it is
    supposed to perform.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** has been taken care of at the architecture level and should
    be taken care of during development, too. Each component in the architecture will
    be interacting with other components through well-defined interfaces and contracts.
    We should be able to replace any component in the diagram without having to worry
    about its internal implementation and whether it adheres to the contracts.'
  prefs: []
  type: TYPE_NORMAL
- en: The loosely coupled architecture here also helps with faster development and
    faster deployment to the market for customers. Multiple teams can work, in parallel,
    on each of their components independently. They share the contracts and timelines
    for integration testing at the start, and once the internal implementation and
    unit tests are done, they can start with integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 – The eCommerce application''s three-tier architecture with highlighted
    chapters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.16_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.16 – The eCommerce application's three-tier architecture with highlighted
    chapters
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can identify the chapters in which different
    parts of the e-commerce application that we will build will be covered. They can
    be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ASP.NET web application (our e-commerce portal) will be covered
    in [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228), *Creating an ASP.NET
    Core 6 Web Application*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication will be covered in [*Chapter 12*](B18507_12_Epub.xhtml#_idTextAnchor1389),
    *Understanding Authentication*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order processing service and the invoice processing service are the two
    core services for generating orders and invoicing. They will be the heart of the
    e-commerce application as they are the ones that are responsible for the revenue.
    Creating an ASP.NET Core web API will be covered in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*, and cross-cutting concerns will be covered
    in [*Chapter 5*](B18507_05_Epub.xhtml#_idTextAnchor445), *Dependency Injection
    in .NET 6*, [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473), *Configuration
    in .NET 6*, and [*Chapter 7*](B18507_07_Epub.xhtml#_idTextAnchor596), *Logging
    in .NET 6*, respectively. The DRY principle will be taken care of by reusing core
    components and cross-cutting concerns instead of repeating implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching will be covered as part of the product pricing service in [*Chapter
    8*](B18507_08_Epub.xhtml#_idTextAnchor714), *All You Need to Know about Caching*.
    Caching will help us to improve the performance and scalability of our system,
    with temporary copies of frequently accessed data being available in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storage, access, and the number of providers will be covered as part of
    the data access layer in [*Chapter 9*](B18507_09_Epub.xhtml#_idTextAnchor860),
    *Working with Data in .NET 6*. The kind of architecture that we have adopted,
    where data and access to it are separate from the rest of the application, gives
    us better maintenance. Azure Cosmos DB is our choice to scale throughput and storage
    elastically and independently across any number of Azure regions worldwide. Additionally,
    it is secure by default and enterprise-ready.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion on architecting our enterprise application. Next,
    we will look at the solution structure for our enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution structuring of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep things simple, we will go with a single solution for all our projects,
    as shown in the following screenshot. The other approach of having separate solutions
    for the UI, shared components, and web APIs can also be considered when the number
    of projects in the solution explodes and causes maintenance issues. The following
    screenshot shows our application''s solution structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17 – The solution structure of the e-commerce application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.17_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.17 – The solution structure of the e-commerce application
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have adopted separation of concerns by having separate folder structures
    and projects for UX, Service, Data, Core, and Testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about common design principles such as SOLID, DRY,
    and KISS. Also, we looked at various design patterns with real-world examples.
    Then, we looked at different enterprise architectures, identified the requirements
    for the e-commerce application that we are going to build, and applied what we
    learned to architect our e-commerce application. You can now apply what you have
    learned here when you design any application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about .NET 6 Core and Standard.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the LSP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Base class instances should be replaceable with instances of their derived
    type.
  prefs: []
  type: TYPE_NORMAL
- en: b. Derived class instances should be replaceable with instances of their base
    type.
  prefs: []
  type: TYPE_NORMAL
- en: c. Designing for generics that can work with any data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: What is SRP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Instead of one common large interface, plan for multiple scenario-specific
    interfaces for better decoupling and change management.
  prefs: []
  type: TYPE_NORMAL
- en: b. You should avoid taking a direct dependency approach on concrete implementation.
    Instead, you should depend on abstractions as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: c. An entity should only have a single responsibility. You should avoid empowering
    one entity with multiple responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: d. Entities should be designed in such a way that they should be open for extension
    but closed for modification.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: What is OCP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Entities should be open to modification but closed for extension.
  prefs: []
  type: TYPE_NORMAL
- en: b. Entities should be open to extension but closed for modification.
  prefs: []
  type: TYPE_NORMAL
- en: c. Entities should be open to composition but closed for extension.
  prefs: []
  type: TYPE_NORMAL
- en: d. Entities should be open to abstraction but closed for inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: Which pattern is used to make two incompatible interfaces work together?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Proxy
  prefs: []
  type: TYPE_NORMAL
- en: b. Bridge
  prefs: []
  type: TYPE_NORMAL
- en: c. Iterator
  prefs: []
  type: TYPE_NORMAL
- en: d. Adapter
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  prefs: []
  type: TYPE_NORMAL
- en: Which principle ensures that services can be deployed and scaled independently
    and that an issue in one service will have a local impact, which can be fixed
    by just redeploying the impacted service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The domain-driven design principle
  prefs: []
  type: TYPE_NORMAL
- en: b. The single-responsibility principle
  prefs: []
  type: TYPE_NORMAL
- en: c. The stateless service principle
  prefs: []
  type: TYPE_NORMAL
- en: d. The resiliency principle
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
