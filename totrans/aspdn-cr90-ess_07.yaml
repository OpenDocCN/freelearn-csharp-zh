- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Capabilities to Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides different features and tools that enable us to develop
    powerful web-based solutions. However, we often need more specialized features
    in order to provide a better end-to-end experience. In this chapter, we will learn
    good practices related to web applications such as adding caching, using asynchronous
    mechanisms, resilience mechanisms, and logging. We will explore essential best
    practices for developing applications with ASP.NET Core 9, covering the correct
    use of asynchronous mechanisms, HTTP requests, and application instrumentation
    through logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with ASP.NET Core 9 best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance with a cache strategy and making the application resilient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** : Docker Engine must be installed on your operating system and have
    a SQL Server container running. You can find more details about Docker and the
    SQL Server container in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis Insight** : This tool is used to connect to a Redis Server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Working with ASP.NET Core 9 best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have already learned about several features and benefits of ASP.NET
    Core 9 in creating quality web systems. Of course, just like any other software
    development technology, there is no restriction on the way we will handle our
    code. In this way, we have the freedom to create solutions and new standards with
    the aim of meeting a specific need.
  prefs: []
  type: TYPE_NORMAL
- en: However, relying on good practices can not only expand our capacity to develop
    quality applications but also avoid wasting several hours to achieve a goal.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will address some good practices necessary to bring greater
    quality to our applications, starting with the correct use of **HTTP requests**
    .
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP request is a fundamental component when working with web applications.
    Proper handling of HTTP requests can significantly impact the performance and
    reliability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: We have already learned about the types of HTTP verbs and status codes in [*Chapter
    3*](B21788_03.xhtml#_idTextAnchor044) . However, each HTTP method provided by
    the application must be treated appropriately, to avoid inconsistencies in the
    application and avoid vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the way HTTP requests are made directly impacts the experience
    of users or consumers of your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand some good practices related to HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Validate and sanitize input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always validate and sanitize input to prevent security vulnerabilities such
    as SQL injection and **cross-site** **scripting** ( **XSS** ).
  prefs: []
  type: TYPE_NORMAL
- en: XSS
  prefs: []
  type: TYPE_NORMAL
- en: XSS is a security vulnerability where the attacker injects scripts into web
    pages. To know more, go to [https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where a user submits a form with a username. To prevent
    harmful data from being processed, you should validate the input to ensure it
    meets the expected criteria and sanitize it to remove any malicious content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates a simple validation of the username parameter,
    **if(string.IsNullOrEmpty)** , avoiding using it incorrectly. The **HttpUtility.HtmlEncode(username)**
    method is used to convert characters such as **<** , **>** , **&** , and so on
    into an HTML-encoded format.
  prefs: []
  type: TYPE_NORMAL
- en: Use asynchronous methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During the execution flow of an HTTP request, we must avoid making the processing
    actions synchronous. Otherwise, this could degrade the user experience and cause
    some problems for the application, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread blocking** : Synchronous methods block the thread while waiting for
    I/O operations (such as database queries, file access, or network requests) to
    complete. In an ASP.NET Core application, the thread pool is a limited resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread pool exhaustion** : When an application heavily relies on synchronous
    methods, the thread pool can become exhausted, especially under high load, which
    occurs when all available threads are blocked and no new threads are available
    to handle incoming requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a recommendation and good practice to use asynchronous methods to improve
    performance and scalability. For example, when using the **HttpClient** object
    to make a request in an API, use the **HttpClient.SendAsync** method instead of
    **HttpClient.Send** .
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming allows your application to handle multiple tasks simultaneously
    without waiting for each task to complete before starting the next one. This is
    similar to how a chef in a busy kitchen might prepare multiple dishes at once,
    rather than finishing one dish before starting another.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the use of asynchronous programming in more detail in the *Asynchronous
    requests and I/O optimization* section. Now, let’s understand another good practice
    in relation to HTTP requests, regarding caching and compression.
  prefs: []
  type: TYPE_NORMAL
- en: Caching and compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Requests via the HTTP protocol have some attributes, including headers and body.
    During communication between an application and the backend, this information
    is transmitted, and the headers are used both by the client (in this case, the
    browser) and by the backend.
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of HTTP headers, including those associated with caching
    and compression.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing caching and response compression, we can reduce bandwidth usage
    and improve load times. Browsers also identify these headers, avoiding unnecessary
    requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Caching and dating compression work similarly to how a library might keep frequently
    borrowed books readily accessible or how a vacuum-sealed package takes up less
    space. These practices reduce the load on your server and speed up responses to
    user requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the following code snippet extracted from a **Program.cs** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the preceding code. When you add **app.UseResponseCaching**
    to the application’s **middleware** pipeline, it performs the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checks for** **Cache-Control headers** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middleware checks whether the incoming request can be cached based on the
    presence of Cache-Control headers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a valid Cache-Control header is found and it allows caching, the middleware
    proceeds to handle the request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stores responses in** **the cache** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the response to the request can be cached, the middleware stores the response
    in the cache
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsequent requests that match the cache criteria will be served directly from
    the cache, bypassing the need to generate the response again
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serves** **cached responses** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For requests that match previously cached responses, the middleware serves the
    cached response
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This reduces the processing time and load on the server, as the response is
    retrieved directly from the cache
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **app.Use(async (context, next)** method adds the necessary parameters for
    the Cache-Control header to the middleware pipeline, such as the cache duration
    time. This is necessary so that the client can know how the response should be
    cached.
  prefs: []
  type: TYPE_NORMAL
- en: The cache is managed in the application’s memory and, therefore, it is not interesting
    to keep the cache for a large amount of time in memory, which could cause problems.
    However, it is good practice to use it. We will go into more detail about cache
    usage in the next section, *Improving performance with a cache strategy and making
    the* *application resilient* .
  prefs: []
  type: TYPE_NORMAL
- en: To further improve response performance, we can perform compression automatically
    with a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we must add the **Microsoft.AspNetCore.ResponseCompression**
    NuGet package to the project. You can do this by typing the following command
    in your application’s project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In any case, it is important that you understand how to use this functionality
    in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the NuGet package, we must add the compression services to the
    **Program.cs** file. When doing so, we have the following modified file taking
    into account caching and compression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add response** **compression middleware** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **builder.Services.AddResponseCompression** method is used to add response
    compression services to the **Dependency Injection** ( **DI** ) container.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options.EnableForHttps** is set to **true** to enable compression for HTTPS
    responses.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options.Providers.Add<GzipCompressionProvider>()** and **options.Providers.Add<BrotliCompressionProvider>()**
    are used to add support for **Gzip** and **Brotli** compression providers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure** **compression options** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.Services.Configure<GzipCompressionProvider** **Options>(options =>
    options.Level = System.IO.Compression.CompressionLevel.Fastest)** is used to configure
    the compression level for Gzip. You can adjust the compression level based on
    your needs ( **Optimal** , **Fastest** , or **NoCompression** ).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use middleware** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**app.UseResponseCompression()** adds the response compression middleware to
    the request pipeline.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of middleware is important
  prefs: []
  type: TYPE_NORMAL
- en: When combining response caching and compression, the order of the middleware
    is important. Make sure compression middleware is included before caching middleware.
    This way, responses are compressed before being cached, ensuring that cached responses
    are already compressed and ready to be served efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: With these practices, you can reduce the size of responses, leading to better
    performance and faster loading times for users.
  prefs: []
  type: TYPE_NORMAL
- en: The time has come to understand asynchronous requests in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous requests and I/O optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous programming is a fundamental aspect of modern web development,
    enabling non-blocking operations that improve application responsiveness and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: The great complexity of asynchronous programming is abstracted by the resources
    available in C#, making applications and functionalities even more powerful. But
    to better understand the importance of this asynchronous process, let’s analyze
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are waiting in line at a coffee shop. If the barista had to wait
    for each cup of coffee to finish brewing before starting the next one, the line
    would move very slowly. Instead, the barista starts preparing the next drink while
    the previous one is being prepared. Similarly, asynchronous programming allows
    your application to start other tasks while waiting for a previous task to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications can respond to a large number of requests from users at a given
    time. ASP.NET Core 9 is optimized enough to manage requests and memory efficiently.
    However, if you choose to use a synchronous approach, which is also possible,
    some problems may be caused. Let’s see how we can develop asynchronous methods.
  prefs: []
  type: TYPE_NORMAL
- en: Use async and await keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, the **async** and **await** keywords let you write asynchronous code
    that is easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the context of an ASP.NET Core application, using **async**
    and **await** allows your server to handle more requests simultaneously by not
    blocking threads during I/O operations, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the details highlighted in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**async** : This is the keyword used to indicate that the method is asynchronous.
    When declaring an asynchronous method, it is mandatory to use at least one **await**
    keyword to perform asynchronous operations in the method body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task<IActionResult>** : This specifies that the method returns a task that
    will eventually be completed with **IActionResult** . The **Task** type represents
    an asynchronous operation in C#. **IActionResult** is a common return type in
    ASP.NET Core MVC that represents the result of an action method. The return type
    could be any type of class or structure, for example, returning an integer such
    as **Task<int>** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**await** : The **await** keyword is used to asynchronously wait for the **GetDataAsync**
    method to complete. This means that the method will return a task and execution
    will be paused until the task is completed, without blocking the thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**_dataService.GetDataAsync()** : This line calls an asynchronous **GetDataAsync**
    method on the **_dataService** object. **_dataService** is presumably an instance
    of a service class that handles data retrieval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# has several asynchronous methods and you can identify them by using the **async**
    suffix, added to the name of the methods as a convention.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous programming in C# has several other details and ways of application,
    and it is not possible to consider them as part of this book. However, to continue
    your learning, I suggest this great content from Microsoft Learn: [https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: With some simple changes, using the features available in ASP.NET Core 9, we
    have the ability to implement asynchronous requests with some keywords.
  prefs: []
  type: TYPE_NORMAL
- en: These resources can be used in conjunction, for example, with Entity Framework
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement asynchronous data access using Entity Framework Core with methods
    such as **ToListAsync()** and **SaveChangesAsync()** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The asynchronous data access lets your application perform other operations
    while waiting for data from the database, as exemplified in the following code,
    where an asynchronous query is made to obtain all records from the **Customers**
    table through Entity Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Consider the use of asynchronous programming in the design of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although the ASP.NET Core 9 platform provides us with several mechanisms to
    create robust applications, it is important to keep in mind that the use of best
    practices for HTTP requests, compression, and information caching, in addition
    to the asynchronous programming model, must be taken into consideration in all
    applications developed. This guarantees the best experience for users and integrated
    systems, in addition to ensuring that applications can be optimized enough to
    support large demands correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see in more detail the use of caching strategies
    and how to make applications resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with a cache strategy and making the application resilient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *HTTP request best practices* subsection of the *Working with ASP.NET
    Core 9 best practices* section, we learned about some mechanisms capable of bringing
    several improvements to our applications. Some approaches were discussed, including
    a brief introduction to the use of caching.
  prefs: []
  type: TYPE_NORMAL
- en: To expand our knowledge and add techniques to our robust application development
    model, we will explore the use of caching strategies and how to make our applications
    resilient, a fundamental requirement for modern solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with first understanding the different types of caching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Caching strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caching is a powerful technique to improve application performance by storing
    frequently accessed data in a temporary storage location. This reduces the need
    to retrieve data from the original source repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Caching and compression* subsection, a code was demonstrated that enabled
    the application to manage a cache, adding functionality to ASP.NET Core 9 middleware,
    used during request processing. For this case, the **in-memory** cache strategy
    was used, which stores data in memory for quick access. This is suitable for small
    to medium-sized datasets that are frequently accessed.
  prefs: []
  type: TYPE_NORMAL
- en: However, for more robust applications, another strategy called the **distributed
    cache** is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: A distributed cache uses some type of resource specialized in distributed caching,
    such as Redis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis** is a powerful technology for large datasets or when running in a
    distributed environment.'
  prefs: []
  type: TYPE_NORMAL
- en: What is Redis?
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote DIctionary Server** ( **Redis** ) is an open source, in-memory data
    structure store. It is known for its high performance, flexibility, and support
    for diverse data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Redis stores data in memory, which makes it extremely fast compared to disk-based
    databases, and also supports data persistence on disk periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Redis’ persistence model is key/value, supporting data structures such as strings,
    hashes, lists, sets, sorted sets, bitmaps, HyperLogLogs, and geospatial indexes.
    This flexibility allows for diverse use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redis is a resource widely used by several applications; if you want to know
    more, go to this link: [https://redis.io/](https://redis.io/) .'
  prefs: []
  type: TYPE_NORMAL
- en: Several modern applications, hosted mainly in cloud environments, use Redis
    as a solution for distributed caching, in addition to being fully integrated with
    ASP.NET Core 9.
  prefs: []
  type: TYPE_NORMAL
- en: So that we can better understand how Redis works when integrated with ASP.NET
    Core 9, let’s implement an application.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to take into account the requirements mentioned in the *Technical
    requirements* section. Let’s learn how to integrate Redis into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Redis in our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating an application. Therefore, open the terminal in a
    directory of your choice and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new ASP.NET Core 9 project by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Redis cache package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the following command to open Visual Studio Code in the application
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **appsettings.json** file and change the content to the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding JSON defines a connection string for the Redis server that we
    will create later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the **Program.cs** file and change all its contents with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should already be used to most of the code described previously. The **builder.Services.AddStackExchangeRedisCache**
    method adds the default required objects, as part of the added library **Microsoft.Extensions.Caching.StackExchangeRedis**
    , to manage the cache when configuring the DI container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have two main configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**options.Configuration** : This is where the connection address to the Redis
    server is provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options.InstanceName** : This is an optional parameter that defines a prefix
    for the cache keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foundation of the application has been configured, and now it’s time to
    implement a controller that will interact with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cache in the controller class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do this, still in Visual Studio Code, follow the following steps to create
    the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: If it does not exist, in the root of the project, create a folder named **Controllers**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class called **CacheController** in the **Controller** folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify all content of the previously created class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code creates an API called **Cache** containing **GET** and **POST**
    methods. Let’s analyze the important points of the code in more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Microsoft.Extensions.Caching.Distributed** : This is a namespace that references
    the NuGet package containing the dependencies necessary for handling the cache
    in the **CacheController** class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private readonly IDistributedCache _cache** : This is a private property
    of the class that abstracts a cache handling object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public CacheController(IDistributedCache cache)** : As a dependency, the
    class constructor has the **IDistributedCache** interface that will be injected
    by DI and assigns the instance to the class’s **_cache** property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**var cachedData = await _cache.GetStringAsync(key)** : During the execution
    of the **Get** method, the _ **cache** object, which abstracts a connection to
    the Redis server, will search for a string using the key and return it in the
    request; otherwise, it will return a **NotFound()** status.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post** method: The **Post** method receives as a parameter an object of the
    **MyData** type, a class created at the end of the file. When obtaining the **MyData**
    object, the **Key** property will be used as the cache key, **var cacheKey = data.Key**
    . Then, the **MyData** object is serialized into JSON, **JsonSerializer.Serialize(data)**
    . Subsequently, an object of the **DistributedCacheEntryOptions** type is created,
    where expiration parameters for information in the cache are specified. Finally,
    the cache persisted in Redis by running **await_cache.SetStringAsync(cacheKey,**
    **serializedData, options)** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SetSlidingExpiration and SetAbsoluteExpiration
  prefs: []
  type: TYPE_NORMAL
- en: The **.SetSlidingExpiration(TimeSpan.FromMinutes(5))** and **.SetAbsoluteExpiration(TimeSpan.FromHours(1))**
    methods are used to configure cache entry expiration options in **DistributedCacheEntryOptions**
    . These methods help manage how long the cached data should be kept in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: '**SlidingExpiration** specifies the amount of time a cache entry can be inactive
    (not accessed) before it is removed from the cache. The expiration time is reset
    every time the cache entry is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AbsoluteExpiration** specifies the maximum time a cache entry should be kept
    in the cache, regardless of how often it is accessed. The cache entry will be
    removed from the cache after the specified time has elapsed, no matter how many
    times it has been accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the application developed, we must create a Redis server, and for this,
    we will use Docker to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application directory, open the terminal and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this is your first time running Redis on your machine, wait for it to download
    and then the server will start.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Still in the application terminal, use the following command to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running the application, open Postman and create a new request by accessing
    the **File** | **New** **Tab** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, define the request type as **GET** , and in the URL field, enter the
    URL made available in the terminal after executing the application with the suffix
    **/api/Cache/DataInCache** . *Figure 7* *.1* demonstrates an example of the request
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Configuring the API request on Postman](img/B21788_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Configuring the API request on Postman
  prefs: []
  type: TYPE_NORMAL
- en: API URL port
  prefs: []
  type: TYPE_NORMAL
- en: The number **5277** added to the URL shown in *Figure 7* *.1* represents the
    API execution port. This value may vary from environment to environment. Make
    sure to enter the execution port available in your terminal after executing the
    **docker** **run** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **DataInCache** value represents the key we want to get the cached value
    from. However, when clicking on the **Send** button in Postman, we have the following
    return ( *Figure 7* *.2* ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Requesting data in cache](img/B21788_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Requesting data in cache
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7* *.2* , the HTTP status and JSON return in the response
    body represent the **404** not found state.
  prefs: []
  type: TYPE_NORMAL
- en: The API return is correct, as the **GET** method tries to obtain a value from
    the cache, and if not found, an HTTP status of **404** is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in Postman, open a new tab ( **File** | **New Tab** ), set the request
    type as **POST** , and define the API URL with the following suffix: **/api/Cache**
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click **Body** , select the **raw** option, and add the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire configuration of this request is demonstrated in *Figure 7* *.3*
    :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Post request configuration](img/B21788_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Post request configuration
  prefs: []
  type: TYPE_NORMAL
- en: The **POST** request, demonstrated in *Figure 7* *.3* , will make a call to
    the API’s **POST** method, which will add the value defined in the request body
    to the Redis cache.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Send** button to make the request and you should receive the HTTP
    **201** status code in return, indicating that the information was created in
    the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to confirm the cached value, in Postman, open the previous tab containing
    the **GET** request and you should receive the HTTP **200** status code in return,
    along with the JSON object that represents the cached data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another way to check the values available in the Redis cache is to use a UI
    tool such as Redis Insight, mentioned in the *Technical requirements* section,
    which we’ll configure now.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Redis Insight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s configure Redis Insight to connect to the Redis server running on Docker
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the application’s main screen, click on the **Add connection details manually**
    option, as shown in *Figure 7* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Configuring the Redis connection](img/B21788_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Configuring the Redis connection
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, we must add the connection parameters to the Redis server.
    As this server is running through Docker, the default parameters will be used,
    already available on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Host** : This defines the Redis server address.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port** : This defines the server execution port.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other parameters** : Not important at this time. However, in productive environments,
    the host address, port, user, and password may be different and necessary.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For our example, just keep the default values and click the **+ Add Redis**
    **database** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the connection is created, the list of servers connected to Redis Insights
    will be displayed, as shown in *Figure 7* *.5* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Connected Redis cache in the Redis Insight tool](img/B21788_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Connected Redis cache in the Redis Insight tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the created connection displayed in the list of connections. Then,
    click on the magnifying glass icon, as highlighted in *Figure 7* *.6* , to view
    the data available in the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – List of data in the cache](img/B21788_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – List of data in the cache
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot view any information when clicking the magnifying glass icon,
    it means that the previously added key has expired. In this case, just make another
    **POST** request to add another key and view it in Redis Insight.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example created so that we can learn how to communicate with
    the cache and add information to memory. In this case, we are using Redis, a powerful
    distributed data management resource, as a server for the information that will
    be kept in memory.
  prefs: []
  type: TYPE_NORMAL
- en: In real scenarios, this approach can be used in conjunction with a database.
    This way, before executing a request to the database, the existence of information
    in the cache will be checked. If it exists, it will not be necessary to make a
    call to the database, optimizing processes.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, caching is a powerful solution for making our applications more
    performant and available.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to quickly retrieve information from a cache server,
    we will understand how to make our applications more resilient in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build robust applications, it is essential to implement resilience mechanisms
    that deal with transient failures and ensure continuous availability.
  prefs: []
  type: TYPE_NORMAL
- en: Think of resilience mechanisms as safety nets that catch us if something goes
    wrong. They help your application recover from unexpected crashes and maintain
    a smooth user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common resilience strategies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retry pattern** : Automatically retries a failed operation a specified number
    of times before giving up. This is useful for dealing with transient faults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaker pattern** : Prevents an application from performing an operation
    that is likely to fail. It stops the flow of requests to a service when a failure
    is detected, allowing the system to recover.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to have the ability to implement these patterns in our applications,
    we will use a library called **Polly** .
  prefs: []
  type: TYPE_NORMAL
- en: Polly
  prefs: []
  type: TYPE_NORMAL
- en: Polly is a library that is part of the .NET Foundation used to add various resilience
    features to applications. It is constantly updated by the open source community
    and used in various applications in production environments. To learn more about
    Polly, go to [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Polly in our applications, we just need to add it to the project through
    the following command executed in the application’s project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the implementation of the retry strategy in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the implementation process is quite simple
    and integrates with the ASP.NET Core 9 development model. In this example, the
    objective is to obtain data from a service in a resilient way. Let’s analyze the
    main points of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**var retryPolicy = Policy.Handle<Exception>().RetryAsync(3)** aims to create
    a retry policy. In this case, the policy is related to an exception. During execution,
    if an exception is identified, the request will be made again. Trials were configured
    to run a maximum of three times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **return await retryPolicy.ExecuteAsync** command is a method that executes
    an action using the previously configured retry policy. All code executing the
    **GetDataAsync** method request is defined within the scope of the policy that
    automatically manages the retry mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very common to use the retry strategy when consuming external APIs. There
    may be intermittences or momentary unavailability and, in this case, **retry**
    helps to guarantee greater resilience in cases of momentary unavailability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of implementing the circuit breaker strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the details of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CircuitBreakerAsync** : This method creates an asynchronous circuit breaker
    policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit breaker will open (break the circuit) after three consecutive exceptions
    (faults).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TimeSpan.FromMinutes(1)** : Once the circuit is open, it will remain open
    for one minute. During this time, any attempt to perform the action will immediately
    throw **BrokenCircuitException** without performing the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The circuit breaker has the following states:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Closed** : The normal state where all calls are allowed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open** : The state in which calls are blocked after a specified number of
    consecutive failures.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-open** : After the open period, the circuit breaker allows a limited
    number of test calls to verify that the underlying problem has been resolved.
    If these calls are successful, the circuit returns to the closed state. If they
    fail, the circuit returns to the open state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**circuitBreakerPolicy.ExecuteAsync** : This method executes the given asynchronous
    delegate (the code block inside) under the control of the circuit breaker policy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **_dataService.GetDataAsync()** call succeeds, the method returns the
    data wrapped in an **OkObjectResult** (HTTP **200** response).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the **_dataService.GetDataAsync()** call throws an exception, the circuit
    breaker policy handles it:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If fewer than three exceptions have occurred consecutively, the circuit breaker
    remains closed, and the exception is propagated.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After three consecutive exceptions, the circuit breaker opens for one minute.
    Any further calls within this period will immediately throw **BrokenCircuitException**
    .
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit breaker policy helps prevent repeated failures from overloading
    the system by interrupting the circuit after three consecutive failures and keeping
    it open for one minute. During this period, any attempt to call the data service
    will result in an immediate exception without attempting to execute the service
    call. This allows the system to recover and prevents cascading failures in dependent
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit breaker and retry strategies are powerful resilience strategies
    that, despite appearing similar, have different objectives, as shown in *Table
    7.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aspect** | **Circuit Breaker** | **Retry** |'
  prefs: []
  type: TYPE_TB
- en: '| Purpose | Prevent overwhelming a failing service | Handle transient faults
    by retrying |'
  prefs: []
  type: TYPE_TB
- en: '| Behavior | Stops requests after a certain number of failures and opens the
    circuit for a specified time | Retries the operation a specified number of times
    with a delay between retries |'
  prefs: []
  type: TYPE_TB
- en: '| States | Closed, open, half-open | No states, just retries |'
  prefs: []
  type: TYPE_TB
- en: '| Failure Handling | Fails fast once the circuit is open | Retries multiple
    times before failing |'
  prefs: []
  type: TYPE_TB
- en: '| When to Use | When repeated failures need to be avoided to protect a system
    | When temporary faults are expected to be resolved with retries |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | Higher, with state transitions and monitoring | Lower, with
    simple retry logic |'
  prefs: []
  type: TYPE_TB
- en: '| Feedback to Users | Immediate failure feedback when the circuit is open |
    Delayed feedback after all retries fail |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 –The circuit breaker and retry objectives
  prefs: []
  type: TYPE_NORMAL
- en: In practice, these patterns are often used together to provide a robust fault-handling
    mechanism. For example, you can use a retry policy to handle transient failures,
    and if the attempts consistently fail, the circuit breaker can be used to prevent
    retries and allow the system to recover.
  prefs: []
  type: TYPE_NORMAL
- en: Polly offers several other resilience mechanisms that can be combined to make
    applications even more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The use of these strategies greatly contributes to the creation of robust solutions
    prepared for large-scale execution models, especially in cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, even by adding several mechanisms to avoid failures, they may arise.
    In this case, we must be able to obtain sufficient information to make corrections
    and keep applications free from non-conformities. For this, it is important to
    add logs in applications, and ASP.NET Core 9 provides a powerful mechanism for
    this, which we will learn about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing logging and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having optimized performance and resilience, we now turn to logging and monitoring,
    essential practices for maintaining and troubleshooting your ASP.NET Core 9 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to logging and monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging and monitoring are crucial to understanding your application’s behavior,
    diagnosing problems, and ensuring it runs smoothly. Logs provide visibility into
    application processes and help detect anomalies early.
  prefs: []
  type: TYPE_NORMAL
- en: Think of logging like keeping a diary and monitoring like installing surveillance
    cameras in your home. The diary helps you remember past events, while the cameras
    let you see what’s happening in real time, maintaining safety and order.
  prefs: []
  type: TYPE_NORMAL
- en: Logging with ILogger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET provides abstractions that allow ASP.NET Core 9 applications to handle
    different logging strategies. The **ILogger** and **ILoggerFactory** interfaces,
    provided by the **Microsoft.Extensions.Logging** namespace, are essential for
    implementing logging in your applications, allowing you to capture and record
    information about the operation of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Logging provides insights into the behavior of your application and is essential
    for debugging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ILogger** interface in ASP.NET Core allows you to log information at
    various levels of details as described in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace** : Detailed information, typically of interest only when diagnosing
    problems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug** : Information useful for debugging the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information** : Informational messages that highlight the progress of the
    application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning** : Potentially harmful situations that are not errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error** : Errors that prevent the application from performing a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Critical** : Critical errors causing complete failure of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **ILogger** interface provides some useful methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log methods** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception,
    Func<TState, Exception, string> formatter)** : The core method to log messages.
    It allows you to specify the log level, event ID, state, exception, and a formatter
    function.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convenience methods** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogTrace(string message, params object[] args)** : Logs a trace message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogDebug(string message, params object[] args)** : Logs a debug message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogInformation(string message, params object[] args)** : Logs an informational
    message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogWarning(string message, params object[] args)** : Logs a warning message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogError(string message, params object[] args)** : Logs an error message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogCritical(string message, params object[] args)** : Logs a critical error
    message.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope Method** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BeginScope<TState>(TState state)** : This method starts a logical operation
    scope. It returns an **IDisposable** interface that ends the scope on disposal.
    Scopes are useful for correlating a set of operations with a common context.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of using the **ILogger** interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code uses several methods provided by the **ILogger** interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ILogger<MyService> _logger** : This declares a private **readonly** field,
    **_logger** , of the **ILogger<MyService>** type. The **ILogger<T>** interface
    is part of the .NET logging infrastructure, where **T** is the type that is being
    logged. By specifying **MyService** , the logger is associated with this class,
    which helps in identifying where the log messages are coming from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MyService(ILogger<MyService> logger)** : The **ILogger<MyService>** instance
    is typically provided via dependency injection. This allows the logging infrastructure
    to be configured and managed centrally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**_logger.LogInformation("Starting work.")** : Log the information type with
    the string **Starting work** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**_logger.LogError(ex, "An error occurred while doing work.")** : Log the information
    type with the string **An error occurred while** **doing work** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **ILogger** interface offers a powerful abstraction for logging your application’s
    execution data in a technology-agnostic manner, facilitating maintenance and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful abstraction mechanism available in .NET is **ILoggerFactory**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The **ILoggerFactory** interface is responsible for creating **ILogger** instances.
    It is generally used to create loggers for specific categories or to configure
    logging providers and settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CreateLogger(string categoryname)** : Creates an **ILogger** instance for
    the specified category. The category is usually the name of the class or component
    that the logger is associated with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AddProvider (ILoggerProvider provider)** : Adds **ILoggerProvider** to the
    factory. This method is used to configure where and how log messages are sent,
    such as to the console, a file, or a remote log service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To discard()** : Discards the logger factory and all loggers it created.
    Typically used to release any resources held by log providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the **ILoggerFactory** interface as in the following example of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The big difference between using the **ILoggerFactory** interface and the **ILogger**
    interface is the creation of a new category of logs that will be used to group
    the application’s log messages. The constructor receives an **ILoggerFactory**
    instance via dependency injection and then an **ILogger** instance is created
    for the **MyService** class. In this case, all log messages of this class will
    be grouped by the **MyService** category.
  prefs: []
  type: TYPE_NORMAL
- en: '**ILoggerFactory** allows for centralized configuration of logging settings.
    This means you can set up logging providers, filters, and other settings in one
    place, typically during application startup, and apply these configurations across
    all loggers created by the factory. You can also dynamically create loggers for
    different categories or components within your application. This is useful for
    associating log messages with specific parts of the application, making it easier
    to filter and analyze logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Logs work with providers, which are different sources where the logs will be
    made available. An application may contain different types of providers for each
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Each provider is centrally configured during application startup. This way,
    the **ILogger** and **ILoggerFactory** abstractions will use the configured providers
    for submitting the logs.
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of providers that can be used in ASP.NET Core 9, such
    as providers for writing to the console, adding debug information, and even providers
    for writing logs to external services such as Azure Application Insights and Elasticsearch,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of log settings in the following code from a **Program.cs**
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code example, different providers were added
    for writing logs. This means that when using a method such as **_logger.LogInformation**
    , **_logger.LogError** , these logs will be distributed to the configured providers.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are a powerful tool, essential in any application, helping to detect failures
    and even optimize systems.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B21788_08.xhtml#_idTextAnchor132) , we will explore the use
    of logs in conjunction with middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this chapter, we learned about implementing best practices in ASP.NET
    Core 9, working correctly with HTTP requests, adding comprehension to responses,
    and understanding the use of caching to bring better performance and resilience
    to applications. We also understood the concepts related to asynchronous requests
    and how we can use this approach in ASP.NET Core applications through the use
    of the **async** and **await** keywords. Finally, we learned about the importance
    of using application monitoring, taking advantage of internal mechanisms that
    abstract writing and logs, such as the use of the **ILogger** and **ILoggerFactory**
    classes, allowing us to have enough inputs to fix inconsistencies in applications
    and optimize them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to expand the request pipeline of ASP.NET
    Core 9 applications through the use of middleware.
  prefs: []
  type: TYPE_NORMAL
