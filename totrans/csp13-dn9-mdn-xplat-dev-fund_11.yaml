- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Querying and Manipulating Data Using LINQ
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ查询和操作数据
- en: This chapter is about **Language INtegrated Query** (**LINQ**) expressions.
    LINQ is a set of language extensions that enable you to work with sequences of
    data and then filter, sort, and project them into different outputs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于**语言集成查询**（**LINQ**）表达式。LINQ是一组语言扩展，使您能够处理数据序列，然后过滤、排序并将它们投影到不同的输出中。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Writing LINQ expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写LINQ表达式
- en: LINQ in practice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ实践
- en: Sorting and more
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序等更多功能
- en: Using LINQ with EF Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ与EF Core
- en: Joining, grouping, and lookups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接、分组和查找
- en: Writing LINQ expressions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写LINQ表达式
- en: 'The first question we need to answer is a fundamental one: *Why does LINQ exist?*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要回答的第一个基本问题是：*为什么LINQ存在？*
- en: Comparing imperative and declarative language features
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较命令式和声明式语言特性
- en: 'LINQ was introduced in 2008 with C# 3 and .NET Framework 3\. Before that, if
    a C# and .NET programmer wanted to process a sequence of items, they had to use
    procedural, aka imperative, code statements. For example, a loop:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ于2008年随C# 3和.NET Framework 3.0一起推出。在此之前，如果C#和.NET程序员想要处理一系列项目，他们必须使用过程式，即命令式的代码语句。例如，一个循环：
- en: Set the current position to the first item.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前位置设置为第一个项目。
- en: Check if the item is one that should be processed by comparing one or more properties
    against specified values. For example, is the unit price greater than 50, or is
    the country equal to Belgium?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将一个或多个属性与指定的值进行比较来检查项目是否应该被处理。例如，单价是否大于50，或者国家是否等于比利时？
- en: If there’s a match, process that item. For example, output one or more of its
    properties to the user, update one or more properties to new values, delete the
    item, or perform an aggregate calculation, like counting or summing values.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有匹配项，处理该项目。例如，将一个或多个属性输出给用户，将一个或多个属性更新为新值，删除项目，或执行聚合计算，如计数或求和值。
- en: Move on to the next item. Repeat until all items have been processed.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到下一个项目。重复，直到所有项目都已处理。
- en: Procedural code tells the compiler *how* to achieve a goal. Do this, then do
    that. Since the compiler does not know what you are trying to achieve, it cannot
    help you as much. You are 100% responsible for ensuring that every *how-to* step
    is correct.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 过程式代码告诉编译器*如何*实现目标。这样做，然后那样做。由于编译器不知道你试图实现什么，因此它无法提供太多帮助。你必须100%负责确保每个*如何做*步骤都是正确的。
- en: LINQ makes these common tasks much easier, with less opportunity to introduce
    subtle bugs. Instead of needing to explicitly state each individual action, like
    move, read, update, and so on, LINQ enables the programmer to use a declarative
    aka functional style of writing statements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ使这些常见任务变得更加容易，减少了引入微妙错误的可能。不再需要明确地声明每个单独的操作，如移动、读取、更新等，LINQ使程序员能够使用声明性即函数式风格的语句编写。
- en: Declarative, aka functional, code tells the compiler *what* goal to achieve.
    The compiler works out the best way to achieve it. The statements also tend to
    be more concise.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性，即函数式，代码告诉编译器*要实现什么*目标。编译器会找出实现它的最佳方式。这些语句通常也更简洁。
- en: '**Good Practice**: If you do not fully understand how LINQ works, then the
    statements you write can introduce their own subtle bugs! A code teaser doing
    the rounds in 2022 involved a sequence of tasks and understanding when they are
    executed ([https://twitter.com/amantinband/status/1559187912218099714](https://twitter.com/amantinband/status/1559187912218099714)).
    Most experienced developers got it wrong! To be fair, it is the combination of
    LINQ behavior with multi-threading behavior that confused most. But by the end
    of this chapter, you will be better informed to understand why the code was dangerous
    due to LINQ behavior.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果你不完全理解LINQ的工作原理，那么你编写的语句可能会引入自己的微妙错误！2022年流传的一个代码谜题涉及一系列任务和了解它们何时执行([https://twitter.com/amantinband/status/1559187912218099714](https://twitter.com/amantinband/status/1559187912218099714))。大多数经验丰富的开发者都答错了！公平地说，是LINQ行为与多线程行为的组合让大多数人感到困惑。但到本章结束时，你将更好地了解为什么代码因为LINQ行为而危险。'
- en: Although we wrote a few LINQ expressions in *Chapter 10*, *Working with Data
    Using Entity Framework Core*, they weren’t the focus, so I didn’t properly explain
    how LINQ works. Let’s now take the time to properly understand them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在第10章*使用Entity Framework Core处理数据*中编写了一些LINQ表达式，但它们并不是重点，因此我没有正确解释LINQ是如何工作的。现在让我们花时间正确理解它们。
- en: LINQ components
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ组件
- en: 'LINQ has several parts; some are required, and some are optional:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 有几个部分；一些是必需的，一些是可选的：
- en: '**Extension methods** (**required**): These include examples such as `Where`,
    `OrderBy`, and `Select`. These are what provide the functionality of LINQ.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展方法**（**必需**）：这些包括 `Where`、`OrderBy` 和 `Select` 等示例。这些提供了 LINQ 的功能。'
- en: '**LINQ providers** (**required**): These include **LINQ to Objects** for processing
    in-memory objects, **LINQ to Entities** for processing data stored in external
    databases and modeled with EF Core, and **LINQ to XML** for processing data stored
    as XML. These providers are the part of LINQ that executes LINQ expressions in
    a way specific to different types of data.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ 提供程序**（**必需**）：这些包括用于处理内存中对象的 **LINQ to Objects**，用于处理存储在外部数据库中并由 EF
    Core 模型的 **LINQ to Entities**，以及用于处理存储为 XML 的数据的 **LINQ to XML**。这些提供程序是 LINQ
    的组成部分，以针对不同类型数据的方式执行 LINQ 表达式。'
- en: '**Lambda expressions** (**optional**): These can be used instead of named methods
    to simplify LINQ queries, for example, for the conditional logic of the `Where`
    method for filtering.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda 表达式**（**可选**）：这些可以用作替代命名方法来简化 LINQ 查询，例如，用于 `Where` 方法的条件逻辑进行过滤。'
- en: '**LINQ query comprehension syntax** (**optional**): These include C# keywords
    like `from`, `in`, `where`, `orderby`, `descending`, and `select`. These are aliases
    for some of the LINQ extension methods, and their use can simplify the queries
    you write, especially if you already have experience with other query languages,
    such as **Structured Query Language** (**SQL**).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ 查询理解语法**（**可选**）：这些包括 `from`、`in`、`where`、`orderby`、`descending` 和 `select`
    等C# 关键字。这些是某些 LINQ 扩展方法的别名，它们的使用可以简化你编写的查询，特别是如果你已经熟悉其他查询语言，如 **结构化查询语言**（**SQL**）。'
- en: When programmers are first introduced to LINQ, they often believe that LINQ
    query comprehension syntax is LINQ, but ironically, that is one of the parts of
    LINQ that is optional!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员第一次接触 LINQ 时，他们常常认为 LINQ 查询理解语法就是 LINQ，但讽刺的是，这正是 LINQ 中可选的部分之一！
- en: Building LINQ expressions with the Enumerable class
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Enumerable` 类构建 LINQ 表达式
- en: The LINQ extension methods, such as `Where` and `Select`, are appended by the
    `Enumerable` static class to any type, known as a **sequence**, that implements
    `IEnumerable<T>`. A sequence contains zero, one, or more items.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 扩展方法，如 `Where` 和 `Select`，由 `Enumerable` 静态类附加到任何实现 `IEnumerable<T>` 的类型上，称为
    **序列**。一个序列包含零个、一个或多个项。
- en: For example, an array of any type implements the `IEnumerable<T>` class, where
    `T` is the type of item in the array. This means that all arrays support LINQ
    to query and manipulate them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何类型的数组都实现了 `IEnumerable<T>` 类，其中 `T` 是数组中项的类型。这意味着所有数组都支持 LINQ 进行查询和操作。
- en: All generic collections, such as `List<T>`, `Dictionary<TKey, TValue>`, `Stack<T>`,
    and `Queue<T>`, implement `IEnumerable<T>`, so they can be queried and manipulated
    with LINQ too.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有泛型集合，如 `List<T>`、`Dictionary<TKey, TValue>`、`Stack<T>` 和 `Queue<T>`，都实现了 `IEnumerable<T>`，因此它们也可以使用
    LINQ 进行查询和操作。
- en: '`Enumerable` defines more than 50 extension methods, as summarized in *Table
    11.1* and *Table 11.2*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable` 定义了 50 多个扩展方法，总结在 *表 11.1* 和 *表 11.2* 中。'
- en: 'These tables will be useful for you for future reference, but for now, you
    might want to briefly scan them to get a feel for what extension methods exist
    and come back later to review them properly. An online version of these tables
    is available at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-methods.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-methods.md).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表格将对你未来的参考很有用，但就目前而言，你可能想简要地浏览它们，以了解存在哪些扩展方法，稍后再回来仔细审查。这些表格的在线版本可在以下链接找到：[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-methods.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-methods.md)。
- en: 'First, here are the deferred methods that return a new sequence of `IEnumerable<T>`
    items:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一些返回新的 `IEnumerable<T>` 项序列的延迟方法：
- en: '| **Method(s)** | **Description** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Where` | Returns a sequence of items that match a specified filter. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Where` | 返回与指定过滤器匹配的项的序列。|'
- en: '| `Index` | Returns a sequence of both the items and their indices. Introduced
    with .NET 9. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `索引` | 返回一个包含项及其索引的序列。从 .NET 9 开始引入。|'
- en: '| `Select` and `SelectMany` | Project items into a different shape, that is,
    a different type, and flattens a nested hierarchy of items. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Select` 和 `SelectMany` | 将项投影到不同的形状，即不同的类型，并扁平化项的嵌套层次结构。|'
- en: '| `Skip` | Skips a number of items. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Skip` | 跳过一定数量的项。|'
- en: '| `SkipWhile` | Skips while an expression is `true`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `SkipWhile` | 在表达式为 `true` 时跳过项目。 |'
- en: '| `SkipLast` | Returns a new enumerable collection that contains elements from
    the source, with the last count elements of the source collection omitted. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `SkipLast` | 返回一个新的可枚举集合，包含从源中获取的元素，但省略了源集合的最后 `count` 个元素。 |'
- en: '| `Take` | Takes a number of items. .NET 6 introduced an overload that can
    be passed a `Range`, for example, `Take(range: 3..^5)`, meaning take a subset
    starting three items in from the start and ending five items in from the end,
    or instead of `Skip(4)`, you could use `Take(4..)`. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Take` | 获取一定数量的项目。.NET 6 引入了一个可以传递 `Range` 的重载，例如，`Take(range: 3..^5)`，意味着从开始处取三个项目，并在结束处取五个项目，或者而不是
    `Skip(4)`，你可以使用 `Take(4..)`。 |'
- en: '| `TakeWhile` | Takes items while an expression is `true`. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `TakeWhile` | 在表达式为 `true` 时获取项目。 |'
- en: '| `TakeLast` | Returns a new enumerable collection that contains the last count
    elements from the source. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `TakeLast` | 返回一个新的可枚举集合，包含从源中获取的最后一个 `count` 个元素。 |'
- en: '| `OrderBy`, `OrderByDescending`, `ThenBy`, and `ThenByDescending` | Sort items
    by a specified field or property. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `OrderBy`, `OrderByDescending`, `ThenBy`, 和 `ThenByDescending` | 根据指定的字段或属性对项目进行排序。
    |'
- en: '| `Order` and `OrderDescending` | Sort items by the item itself. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `Order` 和 `OrderDescending` | 根据项目本身进行排序。 |'
- en: '| `Reverse` | Reverses the order of the items. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `Reverse` | 反转项目的顺序。 |'
- en: '| `GroupBy`, `GroupJoin`, and `Join` | Group and/or join two sequences. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `GroupBy`, `GroupJoin`, 和 `Join` | 对两个序列进行分组和/或连接。 |'
- en: '| `AggregateBy`, `CountBy`, `DistinctBy`, `ExceptBy`, `IntersectBy`, `UnionBy`,
    `MinBy`, and `MaxBy` | Allow the comparison to be performed on a subset of items
    rather than all of them. For example, instead of removing duplicates with `Distinct`
    by comparing an entire `Person` object, you could remove duplicates with `DistinctBy`
    by comparing just their `LastName` and `DateOfBirth` properties. The `CountBy`
    and `AggregateBy` extension methods were introduced with .NET 9. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `AggregateBy`, `CountBy`, `DistinctBy`, `ExceptBy`, `IntersectBy`, `UnionBy`,
    `MinBy`, 和 `MaxBy` | 允许在项目的一个子集上而不是所有项目上执行比较。例如，而不是通过比较整个 `Person` 对象来使用 `Distinct`
    移除重复项，你可以使用 `DistinctBy` 通过比较它们的 `LastName` 和 `DateOfBirth` 属性来移除重复项。`CountBy`
    和 `AggregateBy` 扩展方法是在 .NET 9 中引入的。 |'
- en: '| `AsEnumerable` | Returns the input sequence typed as `IEnumerable<T>`. This
    is useful when the type has its own implementation of any of the LINQ extension
    methods, like `Where`, and you want to call the standard LINQ `Where` method instead.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `AsEnumerable` | 返回输入序列作为 `IEnumerable<T>` 类型。这在类型有自己的 `Where` 等LINQ扩展方法实现时很有用，而你想要调用标准的LINQ
    `Where` 方法。 |'
- en: '| `DefaultIfEmpty` | Returns the elements of an `IEnumerable<T>`, or a default
    valued singleton collection if the sequence is empty. For example, if the sequence
    is an empty `IEnumerable<int>`, it will return an `IEnumerable<int>` containing
    a single item, `0`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultIfEmpty` | 返回 `IEnumerable<T>` 的元素，如果序列为空，则返回默认值的单例集合。例如，如果序列是一个空的
    `IEnumerable<int>`，它将返回一个包含单个项目 `0` 的 `IEnumerable<int>`。 |'
- en: '| `Cast<T>` | Casts items into a specified type. It is useful to convert non-generic
    objects into a generic type in scenarios where the compiler would otherwise complain.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Cast<T>` | 将项目转换为指定的类型。在编译器会报错的情况下，将非泛型对象转换为泛型类型很有用。 |'
- en: '| `OfType<T>` | Removes items that do not match a specified type. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `OfType<T>` | 移除不匹配指定类型的项。 |'
- en: '| `Distinct` | Removes duplicate items. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Distinct` | 移除重复项。 |'
- en: '| `Except`, `Intersect`, and `Union` | Perform operations that return sets.
    Sets cannot have duplicate items. Although the inputs can be any sequence and,
    thereby, the inputs can have duplicates, the result is always a set. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Except`, `Intersect`, 和 `Union` | 执行返回集合的操作。集合不能有重复的项目。尽管输入可以是任何序列，因此输入可以有重复，但结果始终是集合。
    |'
- en: '| `Chunk` | Divides a sequence into sized batches. The `size` parameter specifies
    the number of items in each chunk. The last chunk will contain the remaining items
    and could be smaller than `size`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Chunk` | 将序列分割成固定大小的批次。`size` 参数指定每个批次中的项目数量。最后一个批次将包含剩余的项目，并且可能小于 `size`。
    |'
- en: '| `Append`, `Concat`, and `Prepend` | Perform sequence-combining operations.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Append`, `Concat`, 和 `Prepend` | 执行序列组合操作。 |'
- en: '| `Zip` | Performs a match operation on two or three sequences based on the
    position of items; for example, the item at position 1 in the first sequence matches
    the item at position 1 in the second sequence. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Zip` | 根据项目位置在两个或三个序列上执行匹配操作；例如，第一个序列位置 1 的项目与第二个序列位置 1 的项目匹配。 |'
- en: 'Table 11.1: Deferred LINQ extension methods'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1：延迟的 LINQ 扩展方法
- en: 'Next, here are the non-deferred methods that return a single scalar value,
    like a single `TSource` item, a number, or a `bool`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这里是一些返回单个标量值的非延迟方法，例如单个 `TSource` 项目、一个数字或一个 `bool`：
- en: '| `First`, `FirstOrDefault`, `Last`, and `LastOrDefault` | Get the first or
    last item in the sequence, throw an exception, or return the default value for
    the type, for example, `0` for an `int` and `null` for a reference type, if there
    is not a first or last item. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `First`, `FirstOrDefault`, `Last`, 和 `LastOrDefault` | 获取序列中的第一个或最后一个项目，如果没有则抛出异常，或返回该类型的默认值，例如对于
    `int` 类型是 `0`，对于引用类型是 `null`。 |'
- en: '| `Single` and `SingleOrDefault` | Return an item that matches a specific filter,
    throw an exception, or return the default value for the type if there is not one
    exact match. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Single` 和 `SingleOrDefault` | 返回匹配特定过滤器的项目，如果没有则抛出异常，或返回该类型的默认值。 |'
- en: '| `ElementAt` and `ElementAtOrDefault` | Return an item at a specified index
    position, throw an exception, or return the default value for the type if there
    is not an item at that position. .NET 6 introduced overloads that can be passed
    as an `Index` instead of an `int`, which is more efficient when working with `Span<T>`
    sequences. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ElementAt` 和 `ElementAtOrDefault` | 返回指定索引位置的项目，如果没有则抛出异常，或返回该类型的默认值。.NET
    6 引入了可以传递 `Index` 而不是 `int` 的重载，这在处理 `Span<T>` 序列时更有效。 |'
- en: '| `Aggregate`, `Average`, `Count`, `LongCount`, `Max`, `Min`, and `Sum` | Calculate
    aggregate values. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Aggregate`, `Average`, `Count`, `LongCount`, `Max`, `Min`, 和 `Sum` | 计算聚合值。
    |'
- en: '| `TryGetNonEnumeratedCount` | `Count()` checks if a `Count` property is implemented
    on the sequence and returns its value, or it enumerates the entire sequence to
    count its items. Introduced in .NET 6, this method only checks for `Count`; if
    it is missing, it returns `false` and sets the `out` parameter to `0` to avoid
    a potentially poor-performing operation. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `TryGetNonEnumeratedCount` | `Count()` 检查序列是否实现了 `Count` 属性并返回其值，或者枚举整个序列以计数其项目。在
    .NET 6 中引入，此方法仅检查 `Count`；如果它不存在，则返回 `false` 并将 `out` 参数设置为 `0` 以避免潜在的较差性能操作。
    |'
- en: '| `SequenceEqual` | Returns `true` or `false`, depending on whether two sequences
    are equal according to an equality comparer. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `SequenceEqual` | 根据相等比较器判断两个序列是否相等，返回 `true` 或 `false`。 |'
- en: '| `All`, `Any`, and `Contains` | Return `true` if all or any of the items match
    the filter, or if the sequence contains a specified item. If the sequence is a
    `List<T>`, they use its native `TrueForAll` method instead of LINQ’s `All` method.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `All`, `Any`, 和 `Contains` | 如果所有或任何项目匹配过滤器，或者序列包含指定的项目，则返回 `true`。如果序列是
    `List<T>`，则它们使用其本地的 `TrueForAll` 方法而不是 LINQ 的 `All` 方法。 |'
- en: '| `ToArray`, `ToList`, `ToDictionary`, `ToHashSet`, and `ToLookup` | Convert
    a sequence into an array or collection. These are the only extension methods that
    force the execution of a LINQ expression immediately, rather than wait for deferred
    execution, which you will learn about shortly. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `ToArray`, `ToList`, `ToDictionary`, `ToHashSet`, 和 `ToLookup` | 将序列转换为数组或集合。这些是唯一强制立即执行
    LINQ 表达式而不是延迟执行的扩展方法，你将在稍后了解。 |'
- en: 'Table 11.2: Non-deferred LINQ extension methods'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.2：非延迟 LINQ 扩展方法
- en: '**Good Practice**: Make sure that you understand and remember the difference
    between LINQ extension methods that start with `As` and `To`. The `AsEnumerable`
    method casts the sequence into a different type but does not allocate memory,
    so that method are fast. Methods that start with `To`, like `ToList`, allocate
    memory for a new sequence of items, so they can be slow and will always use more
    memory resources.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：确保你理解并记住以 `As` 和 `To` 开头的 LINQ 扩展方法之间的区别。`AsEnumerable` 方法将序列转换为不同的类型但不分配内存，因此该方法很快。以
    `To` 开头的方法，如 `ToList`，为新的项目序列分配内存，因此它们可能较慢，并且总是使用更多的内存资源。'
- en: 'The `Enumerable` class also has some methods that are not extension methods,
    as shown in *Table 11.3*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable` 类还有一些不是扩展方法的方法，如表 11.3 所示：'
- en: '| **Method** | **Description** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Empty<T>` | Returns an empty sequence of the specified type `T`. It is useful
    for passing an empty sequence to a method that requires an `IEnumerable<T>`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `Empty<T>` | 返回指定类型 `T` 的空序列。当需要传递空序列给需要 `IEnumerable<T>` 的方法时很有用。 |'
- en: '| `Range` | Returns a sequence of integers from the `start` value with `count`
    items. For example, `Enumerable.Range(start: 5, count: 3)` would contain the integers
    5, 6, and 7. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `Range` | 返回从 `start` 值开始的整数序列，包含 `count` 个项目。例如，`Enumerable.Range(start:
    5, count: 3)` 将包含整数 5、6 和 7。 |'
- en: '| `Repeat` | Returns a sequence that contains the same element repeated `count`
    times. For example, `Enumerable.Repeat(element: "5", count: 3)` would contain
    the `string` values `"5"`, `"5"`, and `"5"`. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `Repeat` | 返回一个包含重复 `count` 次相同元素的序列。例如，`Enumerable.Repeat(element: "5",
    count: 3)` 将包含 `string` 值 `"5"`、`"5"` 和 `"5"`。 |'
- en: 'Table 11.3: Enumerable non-extension methods'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.3：Enumerable 非扩展方法
- en: LINQ in practice
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的 LINQ
- en: Now, we can build a console app to explore practical examples of using LINQ.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个控制台应用程序来探索使用 LINQ 的实际示例。
- en: Understanding deferred execution
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解延迟执行
- en: 'LINQ uses **deferred execution**. It is important to understand that calling
    most of the above extension methods does not execute a query and get the results.
    Most of these extension methods return a LINQ expression that represents a *question*,
    not an *answer*. Let’s explore:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 使用**延迟执行**。重要的是要理解，调用上述大多数扩展方法并不会执行查询并获取结果。这些扩展方法中的大多数返回一个表示**问题**而不是**答案**的
    LINQ 表达式。让我们来探索：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器创建一个新项目，如下列列表中定义：
- en: 'Project template: **Console App** / `console`'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `LinqWithObjects`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`LinqWithObjects`
- en: 'Solution file and folder: `Chapter11`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter11`
- en: In the project file, globally and statically import the `System.Console` class.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，全局和静态导入 `System.Console` 类。
- en: Add a new class file named `Program.Helpers.cs`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, delete any existing statements, and then define a
    partial `Program` class with a method to output a section title, as shown in the
    following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，删除任何现有语句，然后定义一个部分 `Program` 类，其中包含一个用于输出部分标题的方法，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add a new class file named `Program.Functions.cs`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Functions.cs` 的新类文件。
- en: 'In `Program.Functions.cs`, delete any existing statements, define a partial
    `Program` class with a method named `DeferredExecution` that is passed an array
    of `string` values, and then define two queries, as shown in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，删除任何现有语句，定义一个部分 `Program` 类，其中包含一个名为 `DeferredExecution`
    的方法，该方法接受一个 `string` 值数组作为参数，然后定义两个查询，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `Program.cs`, delete the existing statements, add statements to define a
    sequence of `string` values for people who work in an office, and then pass it
    as an argument to the `DeferredExecution` method, as shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有语句，添加定义一个包含在办公室工作的人的 `string` 值序列的语句，然后将它作为参数传递给 `DeferredExecution`
    方法，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `Program.Functions.cs`, in the `DeferredExecution` method, to get the answer
    (in other words, to execute the query), you must **materialize** it by either
    calling one of the `To` methods, like `ToArray`, `ToDictionary`, or `ToLookup`,
    or by enumerating the query. Add statements to do this, as shown in the following
    code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 的 `DeferredExecution` 方法中，要获取答案（换句话说，要执行查询），您必须通过调用
    `To` 方法之一，如 `ToArray`、`ToDictionary` 或 `ToLookup`，或通过枚举查询来**实现**它。添加执行此操作的语句，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the console app and note the result, as shown in the following output:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意结果，如下面的输出所示：
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Due to deferred execution, after outputting the first result, `Pam`, if the
    original array values change, then by the time we loop back around, there are
    no more matches because `Jim` has become `Jimmy` and does not end with an `m`,
    so only `Pam` is output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于延迟执行，在输出第一个结果 `Pam` 后，如果原始数组值发生变化，那么当我们循环回来时，将没有更多匹配项，因为 `Jim` 变成了 `Jimmy`
    并且不以 `m` 结尾，所以只有 `Pam` 被输出。
- en: Before we get too deep into the weeds, let’s slow down and look at some common
    LINQ extension methods and how to use them, one at a time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，让我们放慢速度，看看一些常见的 LINQ 扩展方法和如何逐个使用它们。
- en: Filtering entities using Where
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Where 过滤实体
- en: 'The most common reason for using LINQ is to filter items in a sequence using
    the `Where` extension method. Let’s explore filtering by defining a sequence of
    names and then applying LINQ operations to it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LINQ 最常见的原因是使用 `Where` 扩展方法来过滤序列中的项目。让我们通过定义一个名称序列并对其应用 LINQ 操作来探索过滤：
- en: 'In the project file, add an element to prevent the `System.Linq` namespace
    from automatically being imported globally, as shown highlighted in the following
    markup:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加一个元素以防止 `System.Linq` 命名空间自动全局导入，如下面高亮显示的标记所示：
- en: '[PRE5]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `Program.Functions.cs`, add a new method named `FilteringUsingWhere`, as
    shown in the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个名为 `FilteringUsingWhere` 的新方法，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using Visual Studio, navigate to **Tools** | **Options**. In the
    **Options** dialog box, navigate to **Text Editor** | **C#** | **IntelliSense**,
    clear the **Show items from unimported namespaces** checkbox, and then click **OK**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio，导航到 **工具** | **选项**。在 **选项** 对话框中，导航到 **文本编辑器** | **C#**
    | **IntelliSense**，清除 **显示未导入命名空间中的项** 复选框，然后点击 **确定**。
- en: 'In `FilteringUsingWhere`, attempt to call the `Where` extension method on the
    array of names, as shown in the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FilteringUsingWhere` 中，尝试在名称数组上调用 `Where` 扩展方法，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you type the `W`, note that in older code editors (or code editors with
    the option to show items from unimported namespaces disabled), the `Where` method
    is missing from the IntelliSense list of members of a `string` array, as shown
    in *Figure 11.1*:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入 `W` 时，注意在较老的代码编辑器（或者禁用了显示未导入命名空间项的选项的代码编辑器）中，`Where` 方法在 `string` 数组的 IntelliSense
    成员列表中缺失，如图 *11.1* 所示：
- en: '![](img/B22322_11_01.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_11_01.png)'
- en: 'Figure 11.1: IntelliSense with the Where extension method missing'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：缺少 Where 扩展方法的 IntelliSense
- en: This is because `Where` is an extension method. It does not exist on the array
    type. To make the `Where` extension method available, we must import the `System.Linq`
    namespace. This is implicitly imported by default in new .NET 6 and later projects,
    but we removed it to illustrate the point. Recent versions of code editors are
    smart enough to suggest using the `Where` method anyway and indicate that they
    will import the `System.Linq` namespace for you automatically.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `Where` 是一个扩展方法。它不存在于数组类型上。为了使 `Where` 扩展方法可用，我们必须导入 `System.Linq` 命名空间。在新的
    .NET 6 及以后的项目中，它默认隐式导入，但我们移除了它以说明这一点。代码编辑器的最新版本足够智能，会建议使用 `Where` 方法，并指示它们将自动为你导入
    `System.Linq` 命名空间。
- en: If you are using Visual Studio, navigate to **Tools** | **Options**. In the
    **Options** dialog box, navigate to **Text Editor** | **C#** | **IntelliSense**,
    select the **Show items from unimported namespaces** checkbox, and then click
    **OK**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio，导航到 **工具** | **选项**。在 **选项** 对话框中，导航到 **文本编辑器** | **C#**
    | **IntelliSense**，选择 **显示未导入命名空间中的项** 复选框，然后点击 **确定**。
- en: 'In the project file, comment out the element that removed `System.Linq`, as
    shown in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，注释掉移除 `System.Linq` 的元素，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the change and build the project.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并构建项目。
- en: 'Retype the `W` for the `Where` method, and note that the IntelliSense list
    now includes the extension methods added by the `Enumerable` class, as shown in
    *Figure 11.2*:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新输入 `Where` 方法的 `W`，注意 IntelliSense 列表现在包括由 `Enumerable` 类添加的扩展方法，如图 *11.2*
    所示：
- en: '![](img/B22322_11_02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_11_02.png)'
- en: 'Figure 11.2: IntelliSense showing LINQ extension methods when System.Linq is
    imported'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：导入 System.Linq 时 IntelliSense 显示 LINQ 扩展方法
- en: Interestingly, as you can see in the screenshot of Visual Studio on my computer,
    GitHub Copilot even suggests autocompleting with a lambda expression, very similar
    to the one that we will eventually end up writing. But there are some important
    intermediate steps you need to see before we get to that, so do not insert any
    GitHub Copilot suggestions if you have that feature enabled.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，正如你在我的计算机上 Visual Studio 的截图中所见，GitHub Copilot 甚至建议使用 lambda 表达式自动完成，这与我们最终将编写的表达式非常相似。但在我们到达那里之前，有一些重要的中间步骤你需要看到，所以如果你启用了该功能，请不要插入任何
    GitHub Copilot 建议。
- en: As you type the parentheses for the `Where` method, IntelliSense tells us that,
    to call `Where`, we must pass in an instance of a `Func<string, bool>` delegate.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入 `Where` 方法的括号时，IntelliSense 告诉我们，要调用 `Where`，我们必须传递一个 `Func<string, bool>`
    委托实例。
- en: 'Enter an expression to create a new instance of a `Func<string, bool>` delegate,
    and for now, note that we have not yet supplied a method name because we will
    define it in the next step, as shown in the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个表达式来创建一个 `Func<string, bool>` 委托的新实例，目前请注意，我们尚未提供方法名，因为我们将在下一步定义它，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Leave the statement unfinished for now.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前先不要完成该语句。
- en: The `Func<string, bool>` delegate tells us that for each `string` variable passed
    to the method, the method must return a `bool` value. If the method returns `true`,
    it indicates that we should include the `string` in the results, and if the method
    returns `false`, it indicates that we should exclude it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func<string, bool>` 委托告诉我们，对于传递给方法的每个 `string` 变量，方法必须返回一个 `bool` 值。如果方法返回
    `true`，则表示我们应该将 `string` 包含在结果中，如果方法返回 `false`，则表示我们应该排除它。'
- en: Targeting a named method
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对命名方法的定位
- en: 'Let’s define a method that only includes names that are longer than four characters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个只包含长度超过四个字符的名称的方法：
- en: 'In `Program.Functions.cs`, add a method that will return `true` only for names
    longer than four characters, as shown in the following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个方法，该方法仅对长度超过四个字符的名称返回 `true`，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `FilteringUsingWhere` method, pass the method’s name into the `Func<string,
    bool>` delegate, as shown highlighted in the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FilteringUsingWhere` 方法中，将方法名称传递给 `Func<string, bool>` 委托，如下面的代码所示（高亮显示）：
- en: '[PRE11]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `FilteringUsingWhere` method, add statements to enumerate the `names`
    array using `foreach`, as shown in the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FilteringUsingWhere` 方法中，添加使用 `foreach` 遍历 `names` 数组的语句，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `Program.cs`, comment out the call to `DeferredExecution`, and then pass
    `names` as an argument to the `FilteringUsingWhere` method, as shown in the following
    code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉对 `DeferredExecution` 的调用，然后将 `names` 作为参数传递给 `FilteringUsingWhere`
    方法，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the code and view the results, noting that only names longer than four
    letters are listed, as shown in the following output:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，注意只列出了长度超过四个字母的名称，如下面的输出所示：
- en: '[PRE14]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Simplifying code by removing the explicit delegate instantiation
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过移除显式委托实例化简化代码
- en: 'We can simplify code by deleting the explicit instantiation of the `Func<string,
    bool>` delegate because the C# compiler can instantiate the delegate for us:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除 `Func<string, bool>` 委托的显式实例化来简化代码，因为 C# 编译器可以为我们实例化委托：
- en: 'To help you learn by seeing progressively improved code, in the `FilteringUsingWhere`
    method, comment out the query and add a comment about how it works, as shown in
    the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助你通过查看逐步改进的代码来学习，在 `FilteringUsingWhere` 方法中，注释掉查询并添加关于其工作方式的注释，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Enter the query a second time but, this time, without the explicit instantiation
    of the delegate, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次输入查询，但这次，不要显式实例化委托，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the code, and note that it has the same behavior.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意它具有相同的行为。
- en: Targeting a lambda expression
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对lambda表达式
- en: We can simplify our code even further using a **lambda expression** in place
    of a named method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **lambda 表达式** 代替命名方法来进一步简化我们的代码。
- en: 'Although it can look complicated at first, a lambda expression is simply a
    *nameless function*. It uses the `=>` (read as “goes to”) symbol to indicate the
    return value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始看起来可能很复杂，但 lambda 表达式实际上是一个无名的函数。它使用 `=>`（读作“走向”）符号来表示返回值：
- en: 'Comment out the second query, and then add a third version of the query that
    uses a lambda expression, as shown in the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个查询注释掉，然后添加一个使用 lambda 表达式的查询的第三个版本，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that the syntax for a lambda expression includes all the important parts
    of the `NameLongerThanFour` method, and nothing more. A lambda expression only
    needs to define the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，lambda 表达式的语法包括了 `NameLongerThanFour` 方法的重要部分，没有更多。lambda 表达式只需要定义以下内容：
- en: 'The names of input parameters: `name`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数的名称：`name`
- en: 'A return value expression: `name.Length > 4`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值表达式：`name.Length > 4`
- en: The type of the `name` input parameter is inferred from the fact that the sequence
    contains `string` values, and the return type must be a `bool` value, as defined
    by the delegate, for `Where` to work; therefore, the expression after the `=>`
    symbol must return a `bool` value. The compiler does most of the work for us,
    so our code can be as concise as possible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 输入参数的类型是根据序列包含 `string` 值这一事实推断出来的，并且返回类型必须是委托定义的 `bool` 值，以便 `Where`
    方法能够工作；因此，`=>` 符号后面的表达式必须返回一个 `bool` 值。编译器为我们做了大部分工作，所以我们的代码可以尽可能简洁。'
- en: Run the code, and note that it has the same behavior.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意它具有相同的行为。
- en: Lambda expressions with default parameter values
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有默认参数值的lambda表达式
- en: 'Introduced with C# 12, you can now provide default values for parameters in
    lambda expressions, as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 12 开始引入，你现在可以为 lambda 表达式中的参数提供默认值，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our purpose for using this lambda expression means that setting a default value
    is not necessary, but later, you will see more useful examples.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 lambda 表达式的目的是，设置默认值不是必要的，但稍后你将看到更多有用的示例。
- en: Sorting and more
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序及其他
- en: Other commonly used extension methods are `OrderBy` and `ThenBy`, used to sort
    a sequence.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常用扩展方法有 `OrderBy` 和 `ThenBy`，用于对序列进行排序。
- en: Sorting by a single property using OrderBy
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OrderBy 按单个属性排序
- en: Extension methods can be chained if the previous method returns another sequence,
    that is, a type that implements the `IEnumerable<T>` interface.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一个方法返回另一个序列，即实现 `IEnumerable<T>` 接口的类型，则可以链式调用扩展方法。
- en: 'Let’s continue working with the current project to explore sorting:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用当前项目来探索排序：
- en: 'In the `FilteringUsingWhere` method, append a call to `OrderBy` to the end
    of the existing query, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FilteringUsingWhere` 方法中，将 `OrderBy` 方法的调用附加到现有查询的末尾，如下所示代码：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Good Practice**: Format the LINQ statement so that each extension method
    call happens on its own line, making it easier to read.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：格式化 LINQ 语句，使每个扩展方法调用都单独一行，这样更容易阅读。'
- en: 'Run the code, and note that the names are now sorted by the shortest first,
    as shown in the following output:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意现在名字是按最短的先排序，如下所示输出：
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To put the longest name first, you would use `OrderByDescending`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将最长的名字放在第一位，可以使用 `OrderByDescending`。
- en: Sorting by a subsequent property using ThenBy
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ThenBy 按后续属性排序
- en: 'We might want to sort by more than one property, for example, to sort names
    of the same length in alphabetical order:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要按多个属性排序，例如，按相同长度的名字按字母顺序排序：
- en: 'In the `FilteringUsingWhere` method, append a call to the `ThenBy` method at
    the end of the existing query, as highlighted in the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FilteringUsingWhere` 方法中，将 `ThenBy` 方法的调用附加到现有查询的末尾，如下所示代码高亮显示：
- en: '[PRE21]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code, and note the slight difference in the following sort order. Within
    a group of names of the same length, the names are sorted alphabetically by the
    full value of the `string`, so `Creed` comes before `Kevin`, and `Angela` comes
    before `Dwight`, as shown in the following output:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意以下排序顺序中的细微差别。在相同长度的名字组中，名字按字符串的完整值进行字母排序，因此“Creed”排在“Kevin”之前，而“Angela”排在“Dwight”之前，如下所示输出：
- en: '[PRE22]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sorting by the item itself
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按项目本身排序
- en: '.NET 7 introduced the `Order` and `OrderDescending` extension methods. These
    simplify ordering by the item itself. For example, if you have a sequence of `string`
    values, then before .NET 7, you would have had to call the `OrderBy` method and
    pass a lambda that selects the items themselves, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 7 引入了 `Order` 和 `OrderDescending` 扩展方法。这些简化了按项目本身的排序。例如，如果您有一个 `string`
    值的序列，那么在 .NET 7 之前，您必须调用 `OrderBy` 方法并传递一个选择项目的 lambda 表达式，如下所示代码：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With .NET 7 or later, we can simplify the statement, as shown in the following
    code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 或更高版本中，我们可以简化语句，如下所示代码：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`OrderDescending` does a similar thing but in descending order.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderDescending` 做类似的事情，但按降序排列。'
- en: Remember that the `names` array contains instances of the `string` type, which
    implements the `IComparable` interface. This is why they can be ordered, aka sorted.
    If the array contained instances of a complex type, like `Person` or `Product`,
    then those types would have to implement the `IComparable` interface so that they
    could be ordered too.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `names` 数组包含 `string` 类型的实例，该类型实现了 `IComparable` 接口。这就是为什么它们可以被排序，也就是排序。如果数组包含
    `Person` 或 `Product` 等复杂类型的实例，那么这些类型必须实现 `IComparable` 接口，以便它们也可以被排序。
- en: Declaring a query using var or a specified type
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 var 或指定类型声明查询
- en: 'While writing a LINQ expression, it is convenient to use `var` to declare the
    query object. This is because the return type frequently changes as you work on
    a LINQ expression. For example, our query started as an `IEnumerable<string>`
    and is currently an `IOrderedEnumerable<string>`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 LINQ 表达式时，使用 `var` 声明查询对象很方便。这是因为返回类型在编写 LINQ 表达式时经常变化。例如，我们的查询最初是 `IEnumerable<string>`，现在是
    `IOrderedEnumerable<string>`：
- en: 'Hover your mouse over the `var` keyword, and note that its type is `IOrderedEnumerable<string>`,
    as shown in *Figure 11.3*:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 `var` 关键字上，并注意其类型为 `IOrderedEnumerable<string>`，如图 *11.3* 所示：
- en: '![](img/B22322_11_03.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_11_03.png)'
- en: 'Figure 11.3: Hover over var to see the actual implied type of the query expression'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：将鼠标悬停在 var 上，查看查询表达式的实际隐含类型
- en: In *Figure 11.3*, I added extra vertical space between `names` and `.Where`
    so that the tooltip did not cover up the query.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.3* 中，我在 `names` 和 `.Where` 之间添加了额外的垂直空间，这样工具提示就不会覆盖查询。
- en: 'Replace `var` with the actual type, as shown highlighted in the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `var` 替换为实际类型，如下所示代码高亮显示：
- en: '[PRE25]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Good practice**: Once you have finished working on a query, you could change
    the declared type from `var` to the actual type to make it clearer what the type
    is. This is easy because your code editor can tell you what it is. Doing this
    is just for clarity. It has no effect on performance because C# changes all `var`
    declarations to the actual types at compile time.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：一旦你完成对一个查询的工作，你可以将声明的类型从 `var` 改为实际类型，以使类型更清晰。这很容易，因为你的代码编辑器可以告诉你它是什么。这样做只是为了清晰。它对性能没有影响，因为
    C# 在编译时会将所有 `var` 声明转换为实际类型。'
- en: Run the code, and note that it has the same behavior.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意它具有相同的行为。
- en: Filtering by type
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按类型过滤
- en: The `Where` extension method is great for filtering by values, such as text
    and numbers. But what if the sequence contains multiple types and you want to
    filter by a specific type, respecting any inheritance hierarchy?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where` 扩展方法非常适合按值过滤，例如文本和数字。但如果序列包含多个类型，并且你想按特定类型过滤，同时尊重任何继承层次结构，该怎么办呢？'
- en: 'Imagine that you have a sequence of exceptions. There are hundreds of exception
    types that form a complex inheritance hierarchy, as partially shown in *Figure
    11.4*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个异常序列。有数百种异常类型构成了一个复杂的继承层次结构，部分如图 11.4 所示：
- en: '![](img/B22322_11_04.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4](img/B22322_11_04.png)'
- en: 'Figure 11.4: A partial exception inheritance hierarchy'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：部分异常继承层次结构
- en: 'Let’s explore filtering by type:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索按类型过滤：
- en: 'In `Program.Functions.cs`, define a new method to list, and then filter exception-derived
    objects using the `OfType<T>` extension method to remove exceptions that are not
    arithmetic exceptions, writing only the arithmetic exceptions to the console,
    as shown in the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，定义一个新的方法来列出，然后使用 `OfType<T>` 扩展方法过滤异常派生对象，以移除非算术异常的异常，只将算术异常写入控制台，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `Program.cs`, comment out the call to `FilteringUsingWhere`, and then add
    a call to the `FilteringByType` method, as shown in the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉对 `FilteringUsingWhere` 的调用，然后添加对 `FilteringByType` 方法的调用，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the code, and note that the results only include exceptions of the `ArithmeticException`
    type or the `ArithmeticException`-derived types, as shown in the following output:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意结果只包括 `ArithmeticException` 类型或 `ArithmeticException` 派生类型的异常，如下面的输出所示：
- en: '[PRE28]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Working with sets and bags
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合和包
- en: Sets are one of the most fundamental concepts in mathematics. A **set** is a
    collection of one or more unique objects. A **multiset**, aka a **bag**, is a
    collection of one or more objects that can have duplicates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是数学中最基本的概念之一。**集合**是一组一个或多个独特的对象。**多集**，也称为**包**，是一组一个或多个可以重复的对象。
- en: You might remember being taught about Venn diagrams in school. Common set operations
    include the **intersect** or **union** between sets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得在学校学过关于文氏图的内容。常见的集合操作包括集合之间的**交集**或**并集**。
- en: 'Let’s write some code that will define three arrays of `string` values for
    cohorts of apprentices, and then we’ll perform some common set and multiset operations
    on them:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来定义三个代表学徒群体的 `string` 值数组，然后我们将对它们执行一些常见的集合和多集操作：
- en: 'In `Program.Functions.cs`, add a method that outputs any sequence of `string`
    variables as a comma-separated single `string` to the console output, along with
    an optional description, as shown in the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个方法，该方法将任何 `string` 变量的序列输出为逗号分隔的单个 `string` 到控制台输出，并可选地包含一个描述，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `Program.Functions.cs`, add a method that defines three arrays of names,
    outputs them, and then performs various set operations on them, as shown in the
    following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个方法，该方法定义三个名称数组，输出它们，然后对它们执行各种集合操作，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `Program.cs`, comment out the call to `FilteringByType`, and then add a
    call to the `WorkingWithSets` method, as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉对 `FilteringByType` 的调用，然后添加对 `WorkingWithSets` 方法的调用，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE32]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With `Zip`, if there are unequal numbers of items in the two sequences, then
    some items will not have a matching partner. Those without a partner, like `Jared`,
    will not be included in the result.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Zip`，如果两个序列中的项目数量不相等，则某些项目将没有匹配的伙伴。那些没有伙伴的，比如 `Jared`，将不会包含在结果中。
- en: For the `DistinctBy` example, instead of removing duplicates by comparing the
    whole name, we define a lambda key selector to remove duplicates by comparing
    the first two characters, so `Jared` is removed because `Jack` is already a name
    that starts with `Ja`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `DistinctBy` 示例，我们不是通过比较整个名称来移除重复项，而是定义了一个 lambda 键选择器，通过比较前两个字符来移除重复项，因此
    `Jared` 被移除，因为 `Jack` 已经是一个以 `Ja` 开头的名字。
- en: Getting the index as well as items
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取索引以及项目。
- en: .NET 9 introduced the `Index` LINQ extension method. In previous versions of
    .NET, if you wanted to get the index position of each item as well as the items
    themselves, you could do it using the `Select` method, but it was a bit messy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 9 引入了 `Index` LINQ 扩展方法。在 .NET 的早期版本中，如果你想获取每个项目的索引位置以及项目本身，你可以使用 `Select`
    方法，但这有点混乱。
- en: 'Let’s see an example of the old way and the new way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看旧方法和新方法的示例：
- en: 'In `Program.Functions.cs`, add a method that defines an array of names and
    outputs them with their index position, using the old way (the `Select` method)
    and then the new way (the `Index` method), as shown in the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个方法，定义一个包含名称的数组，并使用旧方法（`Select` 方法）和新技术（`Index`
    方法）输出它们及其索引位置，如下所示：
- en: '[PRE33]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Warning!** Note the order of the two declared variables that will hold the
    index and the item. When using the `Select` method, you must declare the `item`
    first and then the `index` second. When using the `Index` method, you must declare
    the `index` first and then the `item` second.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 注意两个声明变量的顺序，这两个变量将保存索引和项目。当使用 `Select` 方法时，你必须先声明 `item`，然后是 `index`。当使用
    `Index` 方法时，你必须先声明 `index`，然后是 `item`。'
- en: 'In `Program.cs`, comment out the call to `WorkingWithSets`, and then add a
    call to the `WorkingWithIndices` method, as shown in the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉对 `WorkingWithSets` 的调用，然后添加对 `WorkingWithIndices` 方法的调用，如下所示：
- en: '[PRE34]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So far, we have used the LINQ to Objects provider to work with in-memory objects.
    Next, we will use the LINQ to Entities provider to work with entities stored in
    a database.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 LINQ to Objects 提供程序来处理内存中的对象。接下来，我们将使用 LINQ to Entities 提供程序来处理存储在数据库中的实体。
- en: Using LINQ with EF Core
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 中的 LINQ。
- en: We have looked at LINQ queries that filter and sort, but none that change the
    shape of the items in the sequence. This operation is called **projection** because
    it’s about projecting items of one shape into another shape. To learn about projection,
    it is best to have some more complex types to work with, so in the next project,
    instead of using `string` sequences, we will use sequences of entities from the
    Northwind sample database that you were introduced to in *Chapter 10*, *Working
    with Data Using Entity Framework Core*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了过滤和排序的 LINQ 查询，但没有改变序列中项目形状的查询。这种操作称为 **投影**，因为它涉及到将一个形状的项目投影到另一个形状。要了解投影，最好有一些更复杂的数据类型来处理，因此，在下一个项目中，我们不会使用
    `string` 序列，而是使用你在 *第 10 章* 中介绍的 Northwind 示例数据库中的实体序列。
- en: I will give instructions to use SQLite because it is cross-platform, but if
    you prefer to use SQL Server, then feel free to do so. I have included some commented
    code to enable SQL Server if you choose.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给出使用 SQLite 的说明，因为它跨平台，但如果你更喜欢使用 SQL Server，那么请随意这样做。如果你选择使用 SQL Server，我已经包含了一些注释代码来启用
    SQL Server。
- en: Creating a console app for exploring LINQ to Entities
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于探索 LINQ to Entities 的控制台应用程序。
- en: 'First, we must create a console app and Northwind database to work with:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个控制台应用程序和 Northwind 数据库来工作：
- en: Use your preferred code editor to add a new **Console App** / `console` project,
    named `LinqWithEFCore`, to the `Chapter11` solution.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器添加一个新的 **Console App** / `console` 项目，命名为 `LinqWithEFCore`，到 `Chapter11`
    解决方案中。
- en: In the project file, globally and statically import the `System.Console` class.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，全局和静态导入 `System.Console` 类。
- en: 'In the `LinqWithEFCore` project, add a package reference to the EF Core provider
    for SQLite and/or SQL Server, as shown in the following markup:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinqWithEFCore` 项目中，添加对 SQLite 和/或 SQL Server 的 EF Core 提供程序的包引用，如下所示：
- en: '[PRE36]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Build the `LinqWithEFCore` project to restore packages.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建用于恢复包的 `LinqWithEFCore` 项目。
- en: Copy the `Northwind4Sqlite.sql` file to the `LinqWithEFCore` folder.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Northwind4Sqlite.sql` 文件复制到 `LinqWithEFCore` 文件夹。
- en: 'At a command prompt or terminal in the `LinqWithEFCore` folder, create the
    Northwind database by executing the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinqWithEFCore` 文件夹的命令提示符或终端中，通过执行以下命令创建 Northwind 数据库：
- en: '[PRE37]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually, you will see the SQLite command prompt, as shown in the following
    output:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请耐心等待，因为这个命令可能需要一段时间来创建数据库结构。最终，您将看到如下所示的 SQLite 命令提示符：
- en: '[PRE38]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To exit SQLite command mode, press *Ctrl* + *C* twice on Windows or *Cmd* +
    *D* on macOS or Linux.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出 SQLite 命令模式，在 Windows 上按 *Ctrl* + *C* 两次，在 macOS 或 Linux 上按 *Cmd* + *D*。
- en: If you prefer to work with SQL Server, then you should already have the Northwind
    database created in SQL Server from the previous chapter.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用 SQL Server，那么您应该已经从上一章创建了 SQL Server 中的 Northwind 数据库。
- en: Building an EF Core model
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 EF Core 模型
- en: 'We must define an EF Core model to represent the database and tables that we
    will work with. We will define the model manually to take complete control, and
    to prevent a relationship from being automatically defined between the `Categories`
    and `Products` tables. Later, you will use LINQ to join the two entity sets:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义一个 EF Core 模型来表示我们将要工作的数据库和表。我们将手动定义模型以完全控制，并防止在 `Categories` 和 `Products`
    表之间自动定义关系。稍后，您将使用 LINQ 来连接这两个实体集：
- en: In the `LinqWithEFCore` project, add a new folder named `EntityModels`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinqWithEFCore` 项目中，添加一个名为 `EntityModels` 的新文件夹。
- en: In the `EntityModels` folder, add three class files to the project, named `NorthwindDb.cs`,
    `Category.cs`, and `Product.cs`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `EntityModels` 文件夹中，向项目添加三个类文件，分别命名为 `NorthwindDb.cs`、`Category.cs` 和 `Product.cs`。
- en: 'Modify the class file named `Category.cs`, as shown in the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `Category.cs` 的类文件，如下所示：
- en: '[PRE39]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Modify the class file named `Product.cs`, as shown in the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `Product.cs` 的类文件，如下所示：
- en: '[PRE40]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have deliberately not defined any relationships between `Category` and `Product`
    so that we can see how to manually associate them with each other using LINQ later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意没有定义 `Category` 和 `Product` 之间的任何关系，以便我们可以在稍后使用 LINQ 手动将它们关联起来。
- en: 'Modify the class file named `NorthwindDb.cs`, as shown in the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `NorthwindDb.cs` 的类文件，如下所示：
- en: '[PRE41]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you want to use SQL Server, then comment out the statement that calls `UseSqlite`
    and uncomment the statement that calls `UseSqlServer`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 SQL Server，那么请注释掉调用 `UseSqlite` 的语句，并取消注释调用 `UseSqlServer` 的语句。
- en: Build the project and fix any compiler errors.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并修复任何编译错误。
- en: Filtering and sorting sequences
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和排序序列
- en: 'Now, let’s write statements to filter and sort sequences of rows from the tables:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写语句来过滤和排序来自表的行序列：
- en: In the `LinqWithEFCore` project, add a new class file named `Program.Helpers.cs`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinqWithEFCore` 项目中，添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, define a partial `Program` class with a method to
    configure the console to support special characters, like the Euro currency symbol,
    and control the current culture, as well as a method to output a section title,
    as shown in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，定义一个部分 `Program` 类，其中包含一个配置控制台以支持特殊字符（如欧元货币符号）、控制当前区域设置以及输出部分标题的函数，如下所示：
- en: '[PRE42]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the `LinqWithEFCore` project, add a new class file named `Program.Functions.cs`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinqWithEFCore` 项目中，添加一个名为 `Program.Functions.cs` 的新类文件。
- en: 'In `Program.Functions.cs`, define a partial `Program` class, and add a method
    to filter and sort products, as shown in the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中定义一个部分 `Program` 类，并添加一个过滤和排序产品的函数，如下所示：
- en: '[PRE43]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note the following about the preceding code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下关于前面代码的内容：
- en: '`DbSet<T>` implements `IEnumerable<T>`, so LINQ can be used to query and manipulate
    sequences of entities in models built for EF Core. (Actually, I should say `TEntity`
    instead of `T`, but the name of this generic type has no functional effect. The
    only requirement is that the type is a `class`. The name just indicates that the
    class is expected to be an entity model.)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbSet<T>` 实现 `IEnumerable<T>`，因此 LINQ 可以用于查询和操作为 EF Core 构建的模型中的实体序列。（实际上，我应该说是
    `TEntity` 而不是 `T`，但这个泛型类型的名称没有功能上的影响。唯一的要求是这个类型是一个 `class`。这个名称只是表明这个类预期是一个实体模型。）'
- en: The sequences implement `IQueryable<T>` (or `IOrderedQueryable<T>` after a call
    to an ordering LINQ method) instead of `IEnumerable<T>` or `IOrderedEnumerable<T>`.
    This is an indication that we are using a LINQ provider that builds the query,
    using expression trees. They represent code in a tree-like data structure and
    enable the creation of dynamic queries, which is useful for building LINQ queries
    for external data providers, like SQLite.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列实现 `IQueryable<T>`（或调用排序 LINQ 方法后的 `IOrderedQueryable<T>`），而不是 `IEnumerable<T>`
    或 `IOrderedEnumerable<T>`。这表明我们正在使用一个 LINQ 提供程序，该提供程序使用表达式树构建查询。它们代表以树状数据结构中的代码，并允许创建动态查询，这对于构建针对外部数据提供程序（如
    SQLite）的 LINQ 查询非常有用。
- en: The LINQ expression will be converted into another query language, such as SQL.
    Enumerating the query with `foreach` or calling a method such as `ToArray` will
    force the execution of the query and materialize the results.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ 表达式将被转换为另一种查询语言，例如 SQL。使用 `foreach` 遍历查询或调用 `ToArray` 等方法将强制执行查询并使结果具体化。
- en: 'In `Program.cs`, delete any existing statements, and then call the `ConfigureConsole`
    and `FilterAndSort` methods, as shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除任何现有语句，然后调用 `ConfigureConsole` 和 `FilterAndSort` 方法，如下所示代码：
- en: '[PRE44]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the project and view the result, as shown in the following output:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并查看结果，如下所示输出：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although this query outputs the information we want, it does so inefficiently
    because it gets all the columns from the `Products` table, instead of just the
    three columns we need. Let’s log the generated SQL.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此查询输出了我们想要的信息，但它效率低下，因为它从 `Products` 表中获取所有列，而不是我们需要的三个列。让我们记录生成的 SQL。
- en: 'In the `FilterAndSort` method, before enumerating the results using `foreach`,
    add a statement to output the SQL, as shown highlighted in the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FilterAndSort` 方法中，在用 `foreach` 遍历结果之前，添加一个输出 SQL 的语句，如下所示的高亮代码：
- en: '[PRE46]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the code, and view the result that shows the SQL executed before the product
    details, as shown in the following partial output:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看显示在产品详情之前执行的 SQL 的结果，如下所示的部分输出：
- en: '[PRE47]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Projecting sequences into new types
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将序列投影到新类型
- en: 'Before we look at **projection**, we should review object initialization syntax.
    If you have a class defined, then you can instantiate an object using the class
    name, `new()`, and curly braces to set initial values for fields and properties,
    as shown in the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看**投影**之前，我们应该回顾对象初始化语法。如果您有一个类定义，则可以使用类名、`new()` 和花括号来设置字段和属性的初始值，如下所示代码：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'C# 3 and later allow instances of **anonymous types** to be instantiated using
    the `var` keyword, as shown in the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 及以后的版本允许使用 `var` 关键字实例化匿名类型实例，如下所示代码：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Although we did not specify a type, the compiler can infer an anonymous type
    from the setting of two properties, named `Name` and `DateOfBirth`. The compiler
    can infer the types of the two properties from the values assigned: a literal
    `string` and a new instance of a date/time value.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有指定类型，但编译器可以从两个属性的设置中推断出匿名类型，这两个属性分别命名为 `Name` 和 `DateOfBirth`。编译器可以从分配的值推断出两个属性的类型：一个字面量
    `string` 和一个日期/时间值的新实例。
- en: This capability is especially useful when writing LINQ queries to project an
    existing type into a new type, without having to explicitly define the new type.
    Since the type is anonymous, this can only work with `var`-declared local variables.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写 LINQ 查询将现有类型投影到新类型时，此功能特别有用，无需显式定义新类型。由于类型是匿名的，这只能与 `var` 声明的局部变量一起工作。
- en: 'Let’s make the SQL command executed against the database table more efficient
    by adding a call to the `Select` method, projecting instances of the `Product`
    class into instances of a new anonymous type with only three properties:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加对 `Select` 方法的调用，使针对数据库表的 SQL 命令更高效，将 `Product` 类的实例投影到仅具有三个属性的新匿名类型实例：
- en: 'In `Program.Functions.cs`, in the `FilterAndSort` method, add a statement to
    extend the LINQ query to use the `Select` method to return only the three properties
    (that is, table columns) that we need, modify the call to `ToQueryString` to use
    the new `projectedProducts` query, and modify the `foreach` statement to use the
    `var` keyword and the new `projectedProducts` query, as shown highlighted in the
    following code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件中，在 `FilterAndSort` 方法中，添加一条语句以扩展 LINQ 查询，使用 `Select`
    方法仅返回我们需要的三个属性（即表列），修改对 `ToQueryString` 的调用以使用新的 `projectedProducts` 查询，并修改 `foreach`
    语句以使用 `var` 关键字和新的 `projectedProducts` 查询，如下所示（代码高亮）：
- en: '[PRE50]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Hover your mouse over the `new` keyword in the `Select` method call, or the
    `var` keyword in the `foreach` statement, and note that it is an anonymous type,
    as shown in *Figure 11.5*:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 `Select` 方法调用中的 `new` 关键字或 `foreach` 语句中的 `var` 关键字上，并注意它是一个匿名类型，如图 *图
    11.5* 所示：
- en: '![](img/B22322_11_05.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_11_05.png)'
- en: 'Figure 11.5: An anonymous type used during LINQ projection'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：在 LINQ 投影期间使用的匿名类型
- en: 'Run the project, and confirm that the output is the same as before and the
    generated SQL is more efficient, as shown in the following output:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目，并确认输出与之前相同，生成的 SQL 更高效，如下所示（输出）：
- en: '[PRE51]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**More Information**: You can learn more about projection using the `Select`
    method at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于使用 `Select` 方法进行投影的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations)。'
- en: Let’s continue to look at common LINQ queries by learning how to join, group,
    and perform lookups.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过学习如何连接、分组和执行查找来查看常见的 LINQ 查询。
- en: Joining, grouping, and lookups
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入、分组和查找
- en: 'There are three extension methods for joining, grouping, and creating grouped
    lookups:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个用于连接、分组和创建分组查找的扩展方法：
- en: '`Join`: This method has four parameters: the sequence that you want to join
    with, the property or properties on the *left* sequence to match on, the property
    or properties on the *right* sequence to match on, and a projection.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Join`：此方法有四个参数：您想要与之连接的序列、在 *左侧* 序列上匹配的属性或属性、在 *右侧* 序列上匹配的属性或属性，以及一个投影。'
- en: '`GroupJoin`: This method has the same parameters, but it combines the matches
    into a group object with a `Key` property for the matching value and an `IEnumerable<T>`
    type for the multiple matches.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupJoin`：此方法具有相同的参数，但它将匹配项组合成一个具有 `Key` 属性的组对象，该属性用于匹配值，以及用于多个匹配项的 `IEnumerable<T>`
    类型。'
- en: '`ToLookup`: This method creates a new data structure with the sequence grouped
    by a key.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToLookup`：此方法创建一个新的数据结构，该结构按键对序列进行分组。'
- en: Joining sequences
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接序列
- en: 'Let’s explore these methods when working with two tables, `Categories` and
    `Products`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索在处理两个表 `Categories` 和 `Products` 时这些方法：
- en: 'In `Program.Functions.cs`, add a method to select categories and products,
    join them, and output them, as shown in the following code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个选择类别和产品、将它们连接并输出的方法，如下所示（代码）：
- en: '[PRE52]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In a join, there are two sequences, `outer` and `inner`. In the preceding example,
    `categories` is the outer sequence and `products` is the inner sequence.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接中，有两个序列，`outer` 和 `inner`。在上面的示例中，`categories` 是外部序列，`products` 是内部序列。
- en: 'In `Program.cs`, comment out the call to `FilterAndSort`, and then call the
    `JoinCategoriesAndProducts` method, as shown highlighted in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉对 `FilterAndSort` 的调用，然后调用 `JoinCategoriesAndProducts` 方法，如下所示（代码高亮）：
- en: '[PRE53]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, as shown in the following output (edited to only
    include the first four items):'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。注意，对于每个 77 个产品，都有一行输出，如下所示（输出，仅包括前四项）：
- en: '[PRE54]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `Program.Functions.cs`, in the `JoinCategoriesAndProducts` method, at the
    end of the existing query, call the `OrderBy` method to sort by `CategoryName`,
    as shown highlighted in the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，在 `JoinCategoriesAndProducts` 方法中，在现有查询的末尾调用 `OrderBy`
    方法按 `CategoryName` 排序，如下所示（代码高亮）：
- en: '[PRE55]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, and the results show all products in the `Beverages`
    category first, then the `Condiments` category, and so on, as shown in the following
    partial output:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。请注意，每个 77 个产品都有一行输出，结果首先显示 `Beverages` 类别中的所有产品，然后是 `Condiments` 类别，依此类推，如下面的部分输出所示：
- en: '[PRE56]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Group-joining sequences
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组连接序列
- en: 'Let’s explore group joining when working with the same two tables that we used
    to explore joining, `Categories` and `Products`, so that we can compare the subtle
    differences:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用与探索连接时相同的两个表（`Categories` 和 `Products`），以便我们可以比较细微的差异：
- en: 'In `Program.Functions.cs`, add a method to group and join, show the group name,
    and then show all the items within each group, as shown in the following code:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中，添加一个分组和连接的方法，显示组名，然后显示每个组中的所有项目，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we had not called the `AsEnumerable` method, then a runtime exception would
    have been thrown, as shown in the following output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有调用 `AsEnumerable` 方法，那么将抛出一个运行时异常，如下面的输出所示：
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is because not all LINQ extension methods can be converted from expression
    trees into some other query syntax, like SQL. In these cases, we can convert from
    `IQueryable<T>` to `IEnumerable<T>` by calling the `AsEnumerable` method, which
    forces query processing to use LINQ to EF Core only to bring the data into the
    application, and then LINQ to Objects to execute more complex processing in memory.
    But, often, this is less efficient.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为并非所有 LINQ 扩展方法都可以从表达式树转换为其他查询语法，如 SQL。在这些情况下，我们可以通过调用 `AsEnumerable` 方法将
    `IQueryable<T>` 转换为 `IEnumerable<T>`，这强制查询处理仅使用 LINQ to EF Core 将数据带入应用程序，然后使用
    LINQ to Objects 在内存中执行更复杂的处理。但是，这通常效率较低。
- en: In `Program.cs`, call the `GroupJoinCategoriesAndProducts` method.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，调用 `GroupJoinCategoriesAndProducts` 方法。
- en: 'Run the code, view the results, and note that the products inside each category
    have been sorted by their name, as defined in the query and as shown in the following
    partial output:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意每个类别内的产品已按查询中定义的名称排序，如下面的部分输出所示：
- en: '[PRE59]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Grouping for lookups
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询分组
- en: Instead of writing a LINQ query expression to join and group and running it
    once, you might want to use a LINQ extension method to create, and then store
    a reusable in-memory collection that has entities that have been grouped.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写一个 LINQ 查询表达式来连接和分组，然后运行一次，您可能希望使用 LINQ 扩展方法来创建，然后存储一个可重用的内存集合，该集合包含已分组的实体。
- en: 'We have a table named `Products` in the Northwind database that includes a
    column for the categories that they reside in, as partially shown in *Table 11.4*:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Northwind 数据库中有一个名为 `Products` 的表，其中包含一个列，表示它们所在的类别，部分如下所示 *表 11.4*：
- en: '| **ProductName** | **CategoryID** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **产品名称** | **分类ID** |'
- en: '| Chai | 1 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 奶茶 | 1 |'
- en: '| Chang | 1 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 长颈瓶 | 1 |'
- en: '| Aniseed Syrup | 2 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 八角糖浆 | 2 |'
- en: '| Chef Anton’s Cajun Seasoning | 2 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 安东大厨的卡真调味料 | 2 |'
- en: '| Chef Anton’s Gumbo Mix | 2 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 安东大厨的 gumbo 混合料 | 2 |'
- en: '| ... | ... |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... |'
- en: 'Table 11.4: The first five rows of the Products table'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.4：产品表的前五行
- en: You might want to create a data structure in memory that can group the `Product`
    entities by their category, and then provide a quick way to look up all the products
    in a specific category.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在内存中创建一个数据结构，可以按类别对 `Product` 实体进行分组，然后提供一个快速的方法来查找特定类别中的所有产品。
- en: 'You can create this using the `ToLookup` LINQ method, as shown in the following
    code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ToLookup` LINQ 方法创建此内容，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When you call the `ToLookup` method, you must specify a **key selector** to
    choose what value you want to group by. This value can then later be used to look
    up the group and its items.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用 `ToLookup` 方法时，您必须指定一个 **键选择器** 来选择您想要按什么值分组。然后，此值可以稍后用于查找组和其项目。
- en: 'The `ToLookup` method creates a dictionary-like data structure of key-value
    pairs in memory that has unique category IDs for the key and a collection of `Product`
    objects for the value, as partially shown in *Table 11.5*:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToLookup` 方法在内存中创建一个类似于字典的数据结构，其中包含键值对，键是唯一的类别 ID，值是 `Product` 对象的集合，部分如下所示
    *表 11.5*：'
- en: '| **Key** | **Value (each one is a collection of Product objects)** |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值（每个都是一个 Product 对象的集合）** |'
- en: '| 1 | [Chai], [Chang], and so on |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [奶茶], [长颈瓶]，等等 |'
- en: '| 2 | [Aniseed Syrup], [Chef Anton’s Cajun Seasoning], [Chef Anton’s Gumbo
    Mix], and so on |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [八角糖浆], [安东大厨的卡真调味料], [安东大厨的 gumbo 混合料]，等等 |'
- en: '| ... | ... |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... |'
- en: 'Table 11.5: The first two rows in the lookup'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.5：查找的前两行
- en: Note that the product names in square brackets, such as [`Chai`], represent
    an entire `Product` object.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，方括号中的产品名称，如 `[Chai]`，代表一个完整的 `Product` 对象。
- en: Instead of using the `CategoryId` values as the key to the lookup, we could
    use the category names from the related categories table.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相关类别表中的类别名称，而不是使用 `CategoryId` 值作为查找的关键。
- en: 'Let’s do this in a code example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码示例中这样做：
- en: 'In `Program.Functions.cs`, add a method to join products to category names,
    and then convert them into a lookup, enumerate through the whole lookup using
    an `IGrouping<string, Product>` to represent each row in the lookup dictionary,
    and look up an individual collection of products for a specific category, as shown
    in the following code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 中添加一个方法，将产品与类别名称连接起来，然后将其转换为查找，使用 `IGrouping<string,
    Product>` 枚举整个查找，以表示查找字典中的每一行，并查找特定类别的单个产品集合，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Selector** parameters are lambda expressions that select sub-elements for
    different purposes. For example, `ToLookup` has a `keySelector` to select the
    part of each item that will be the key and an `elementSelector` to select the
    part of each item that will be the value. You can learn more at the following
    link: [https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolookup](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolookup).'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器**参数是用于选择不同目的的 lambda 表达式。例如，`ToLookup` 有一个 `keySelector` 用于选择每个项的部分，该部分将成为键，还有一个
    `elementSelector` 用于选择每个项的部分，该部分将成为值。你可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolookup](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolookup)。'
- en: In `Program.cs`, call the `ProductsLookup` method.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中调用 `ProductsLookup` 方法。
- en: 'Run the code, view the results, enter a category name like `Seafoods`, and
    note that the products have been looked up and listed for that category, as shown
    in the following partial output:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，输入一个类别名称，例如 `Seafoods`，并注意该类别下的产品已经被查找并列出，如下面的部分输出所示：
- en: '[PRE62]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is a lot more to LINQ, and in the final section, you will have the opportunity
    to explore further with some online material to walk through.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 有很多内容，在最后一节中，你将有机会通过一些在线材料进一步探索。
- en: Practicing and exploring
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring with deeper research the topics covered in this
    chapter.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践，并深入探索本章涵盖的主题来测试你的知识和理解。
- en: Exercise 11.1 – Online material
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.1 – 在线材料
- en: Online materials can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是为我这本书写的额外内容，也可以是引用 Microsoft 或第三方创建的内容。
- en: Aggregating and paging sequences
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合和分页序列
- en: 'You can learn how to use LINQ aggregate methods and implement paging for data
    at the following link:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中学习如何使用 LINQ 聚合方法和实现数据分页：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-aggregating.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-aggregating.md)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-aggregating.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-aggregating.md)'
- en: Using multiple threads with parallel LINQ
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用并行 LINQ 进行多线程操作
- en: 'You can improve performance and scalability by using multiple threads to run
    LINQ queries. Learn how by completing the online-only section found at the following
    link:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用多线程运行 LINQ 查询来提高性能和可伸缩性。通过完成以下链接中找到的仅在线部分来学习如何操作：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-plinq.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-plinq.md)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-plinq.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-plinq.md)'
- en: Working with LINQ to XML
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 LINQ to XML 进行操作
- en: 'If you want to process or generate XML using LINQ, then you can learn the basics
    of how by completing the online-only section found at the following link:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用 LINQ 处理或生成 XML，那么你可以通过完成以下链接中找到的在线部分来学习其基础知识：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-to-xml.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-to-xml.md)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-to-xml.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-to-xml.md)'
- en: Creating your own LINQ extension methods
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自己的 LINQ 扩展方法
- en: 'If you want to create your own LINQ extension methods, then you can learn the
    basics of how by completing the online-only section found at the following link:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建自己的 LINQ 扩展方法，那么您可以通过完成以下链接中仅在线部分来学习基础知识：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-custom-linq-methods.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-custom-linq-methods.md)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-custom-linq-methods.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-custom-linq-methods.md)'
- en: Design of the new LINQ methods in .NET 9
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 9 中新 LINQ 方法的设计
- en: 'You can read about the design of the new LINQ extension methods introduced
    in .NET 9 at the following links:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中阅读有关 .NET 9 中引入的新 LINQ 扩展方法的设计：
- en: '`AggregateBy`: [https://github.com/dotnet/runtime/issues/91533](https://github.com/dotnet/runtime/issues/91533).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AggregateBy`: [https://github.com/dotnet/runtime/issues/91533](https://github.com/dotnet/runtime/issues/91533).'
- en: '`CountBy`: [https://github.com/dotnet/runtime/issues/77716](https://github.com/dotnet/runtime/issues/77716).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountBy`: [https://github.com/dotnet/runtime/issues/77716](https://github.com/dotnet/runtime/issues/77716).'
- en: '`Index`: [https://github.com/dotnet/runtime/issues/95563](https://github.com/dotnet/runtime/issues/95563).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index`: [https://github.com/dotnet/runtime/issues/95563](https://github.com/dotnet/runtime/issues/95563).'
- en: Exercise 11.2 – Practice querying with LINQ
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.2 – 使用 LINQ 进行查询练习
- en: 'In the `Chapter11` solution, create a console application, named `Exercise_LinqQueries`,
    that prompts the user for a city and then lists the company names for Northwind
    customers in that city, as shown in the following output:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter11` 解决方案中，创建一个名为 `Exercise_LinqQueries` 的控制台应用程序，提示用户输入一个城市，然后列出在该城市中
    Northwind 客户的公司名称，如下面的输出所示：
- en: '[PRE63]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, enhance the application by displaying a list of all the unique cities
    that customers already reside in as a prompt to the user before they enter their
    preferred city, as shown in the following output:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在用户输入首选城市之前显示所有已居住的独特城市列表来增强应用程序，如下面的输出所示：
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Exercise 11.3 – Test your knowledge
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.3 – 测试您的知识
- en: 'Answer the following questions:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What are the two required parts of LINQ?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LINQ 的两个必需部分是什么？
- en: Which LINQ extension method would you use to return a subset of properties from
    a type?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个 LINQ 扩展方法来返回类型的一个子集属性？
- en: Which LINQ extension method would you use to filter a sequence?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个 LINQ 扩展方法来过滤序列？
- en: List five LINQ extension methods that perform aggregation.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出五个执行聚合操作的 LINQ 扩展方法。
- en: What is the difference between the `Select` and `SelectMany` extension methods?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Select` 和 `SelectMany` 扩展方法之间的区别是什么？'
- en: What is the difference between `IEnumerable<T>` and `IQueryable<T>`? How do
    you switch between them?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 和 `IQueryable<T>` 之间的区别是什么？您如何在这两者之间切换？'
- en: What does the last type parameter `T` in generic `Func` delegates like `Func<T1,
    T2, T>` represent?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型 `Func` 委托（如 `Func<T1, T2, T>`）中的最后一个类型参数 `T` 代表什么？
- en: What is the benefit of a LINQ extension method that ends with `OrDefault`?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 `OrDefault` 结尾的 LINQ 扩展方法有什么好处？
- en: Why is query comprehension syntax optional?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么查询理解语法是可选的？
- en: How can you create your own LINQ extension methods?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何创建自己的 LINQ 扩展方法？
- en: Exercise 11.4 – Explore topics
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.4 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to write LINQ queries to perform common tasks
    like:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何编写 LINQ 查询以执行常见任务，如：
- en: Selecting just the properties of an item that you need.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅选择您需要的项目属性。
- en: Filtering items based on conditions.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据条件过滤项目。
- en: Sorting items.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序项目。
- en: Projecting items into different types.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目投影到不同的类型中。
- en: Joining and grouping items.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接和分组项目。
- en: In the next chapter, you will be introduced to web development using ASP.NET
    Core. In the remaining chapters, you will learn how to implement modern features
    of ASP.NET Core, like Blazor and Minimal APIs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解如何使用 ASP.NET Core 进行 Web 开发。在剩余的章节中，您将学习如何实现 ASP.NET Core 的现代功能，如
    Blazor 和 Minimal APIs。
