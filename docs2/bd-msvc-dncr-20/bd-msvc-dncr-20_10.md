# 创建完整的微服务解决方案

在我们理解微服务和它们演变的旅程中，我们经历了各种阶段。我们探讨了导致微服务出现的原因以及利用它们的各种优势。我们还讨论了各种集成技术和测试策略。让我们回顾一下到目前为止我们所讨论的内容：

+   测试微服务

+   安全性

+   监控

+   扩展性

+   反应式微服务

# 微服务之前的架构

微服务并非从一开始就被设计成现在的形式。相反，它们是从其他流行的架构风格逐渐过渡到微服务的。在微服务之前，我们有单体架构和统治企业开发世界的面向服务的架构。

在快速回顾微服务和它们的各种属性和优势之前，让我们深入探讨这两者。

# 单体架构

单体架构已经存在很长时间了，它导致了具有单个.NET 组件的自包含软件。它包括以下组件：

+   用户界面

+   业务逻辑

+   数据库访问

为了实现自包含而付出的代价是所有组件都是相互关联和相互依赖的。任何模块的微小变化都有可能影响整个软件。由于所有组件以这种方式紧密耦合，因此测试整个应用程序是必要的。此外，由于如此紧密耦合，整个应用程序必须重新部署。让我们总结一下由于采用这种架构风格而面临的全部挑战：

+   大量相互依赖的代码

+   代码复杂性

+   可扩展性

+   系统部署

+   新技术的采用

# 标准化.NET 堆栈的挑战

当涉及到单体架构时，技术的采用并不容易。它带来了一定的挑战。安全性、响应时间、吞吐率和技术的采用就是其中的一些。并不是这种架构风格没有反击的解决方案。挑战在于，在单体架构中，代码的可重用性真的很低或者不存在，这使得技术的采用变得困难。

# 扩展性

我们还讨论了扩展性是一个可行的选择，但回报递减且成本增加。垂直扩展和水平扩展都有各自的优缺点。垂直扩展似乎更容易开始：投资于 IT 基础设施，如内存升级和磁盘驱动器。然而，回报很快就会达到顶峰。垂直扩展所需的停机时间的不利因素在水平扩展中不存在。然而，超过某个点，水平扩展的成本变得过高。

# 面向服务的架构

行业中广泛使用的另一种架构是面向服务的架构（**SOA**）。这种架构是从单体架构的转变，并涉及解决前述部分中提到的一些挑战。首先，它基于服务集合。提供服务是 SOA 的核心概念。

服务是一段代码、程序或软件，它为其他系统组件提供某些功能。这段代码能够直接与数据库交互，或者通过其他服务间接交互。它在一定程度上是自包含的，使得服务可以轻松被桌面和移动应用程序消费。

SOA 相对于单体架构提供的某些明确优势包括：

+   可重用性

+   无状态

+   可扩展性

+   基于合同

+   升级能力

# 微服务风格架构

除了 SOA 的一些明确优势外，微服务还提供了一些额外的差异化因素，使它们成为明显的赢家。在核心上，微服务被定义为完全独立于系统中的其他服务，并在它们自己的进程中运行。独立的属性要求在应用程序设计中有一定的纪律和策略。它们提供的一些好处包括：

+   清晰的代码边界：这导致了代码更改更加容易。其独立的模块提供了隔离的功能，导致一个微服务的更改对其他微服务的影响很小。

+   易于部署：如果需要，可以一次部署一个微服务。

+   技术适应性：上述属性导致了这一备受追求的益处。这使得我们能够在不同的模块中采用不同的技术。

+   经济可扩展性：这允许我们仅扩展选定的组件/模块，而不是整个应用程序。

+   分布式系统：这是隐含的，但在这里需要提醒一句。确保你的异步调用得到良好使用，而同步调用不会阻塞整个信息流。合理使用数据分区。我们稍后会提到这一点，所以现在不用担心。

+   快速市场响应：在竞争激烈的世界中，这是一个明显的优势，因为用户如果对新功能请求或系统内采用新技术反应迟缓，往往会迅速失去兴趣。

# 微服务中的消息传递

这是需要讨论的另一个重要领域。在微服务中主要使用两种主要类型的消息传递：

+   同步

+   异步

# 单体过渡

作为我们练习的一部分，我们决定将现有的单体应用程序 FlixOne 过渡到微服务风格的架构。我们看到了如何根据以下参数在单体中识别分解候选者：

+   代码复杂性

+   技术采用

+   资源需求

+   人力资源依赖

除了技术独立性之外，它还提供了在成本、安全和可扩展性方面的明确优势，这也使应用程序更符合业务目标。

转变整个过程的步骤需要你识别出像微服务边界一样的缝隙，沿着这些缝隙你可以开始分离。你必须小心选择正确的参数来挑选缝隙。我们已经讨论了模块依赖性、团队结构、数据库和技术是一些可能的候选者。处理主数据需要特别注意。这更多的是一个选择，即你想要通过独立的服务还是通过配置来处理主数据。你将是判断你场景的最佳裁判。微服务拥有自己的数据库的基本要求是它消除了许多现有的外键关系。这将带来选择你的事务处理策略的智能需求，以保持数据完整性。

# 集成技术

我们已经探讨了微服务之间的同步和异步通信方式，并讨论了服务的协作风格。这些风格包括请求/响应和基于事件的。尽管请求/响应在本质上看起来是同步的，但事实是，实现方式决定了集成风格的最终结果。另一方面，基于事件的风格则是完全异步的。

当处理大量微服务时，我们利用集成模式来促进微服务之间复杂交互是很重要的。我们探讨了 API 网关以及事件驱动模式。

API 网关为你提供了一系列服务，以下是一些：

+   路由 API 调用

+   验证 API 密钥、JWT 令牌和证书

+   强制使用配额和速率限制

+   在不修改代码的情况下动态转换 API

+   设置缓存后端响应

+   为分析目的记录调用元数据

事件驱动模式通过一些服务发布它们的事件，而另一些服务则订阅这些可用的事件来实现。订阅服务简单地根据事件及其元数据独立于事件发布服务做出反应。发布者不知道订阅者将执行的业务逻辑。

# 部署

对于企业应用来说，单体部署可能由于多个原因而具有挑战性。拥有一个难以分解的中心数据库，不仅增加了整体挑战，还增加了上市时间。

对于微服务来说，情况非常不同。好处并不仅仅来自于架构是微服务的事实。相反，它是从最初阶段就开始的计划。你不能期望一个企业规模的微服务在没有**持续交付**（**CD**）和**持续集成**（**CI**）的情况下得到管理。CI 和 CD 的需求如此之强，以至于没有它们，生产阶段可能永远看不到光明。

CFEngine、Chef、Puppet、Ansible 和 PowerShell DSC 等工具可以帮助你用代码表示基础设施，并让你轻松地使不同的环境完全相同。Azure 在这里可以成为盟友：快速和重复的配置需求可以轻松满足。

与其最接近的竞争对手虚拟机相比，容器可以更有效地满足隔离需求。我们已经探讨了 Docker 作为容器化的热门候选之一，并看到了如何部署它。

# 测试微服务

我们都知道单元测试的重要性以及为什么每个开发者都应该编写它们。单元测试是验证对构建更大系统有贡献的最小功能的好方法。

然而，测试微服务并不像测试单体那样是常规事务，因为一个微服务可能会与多个其他微服务交互。在这种情况下，我们应该利用对实际微服务的调用来确保整个工作流程运行良好吗？答案是否定的，因为这会使微服务的开发依赖于另一个部分。如果我们这样做，那么拥有基于微服务的架构的全部目的就丧失了。为了解决这个问题，我们将使用模拟和存根方法。这种方法不仅使测试独立于其他微服务，而且使测试数据库变得更加容易，因为我们还可以模拟数据库交互。

使用单元测试测试一个小型的隔离功能或通过模拟外部微服务的响应来测试一个组件，都有其适用范围，并且在该范围内工作良好。然而，如果你已经在思考如何测试更大的上下文，那么你并不孤单。集成测试和合约测试是测试微服务的下一步。

在集成测试中，我们关注外部微服务，并在测试过程中与之通信。为此，我们模拟外部服务。在合约测试中，我们更进一步，独立测试每一个服务调用，然后验证响应。一个值得花时间研究的重要概念是消费者驱动的合约。请参考第四章，*测试策略*，以详细了解这一内容。

# 安全性

在单体架构中，拥有单一认证和授权点的传统方法运作得很好。然而，在微服务的情况下，你需要为每个服务都这样做。这不仅会带来实施上的挑战，还会带来保持同步的挑战。

OAuth 2.0 授权框架和 OpenID Connect 1.0 规范结合在一起可以解决我们的问题。OAuth 2.0 详细描述了授权过程中涉及的所有角色，很好地满足了我们的需求。我们只需确保选择了正确的授权类型；否则，安全将受到威胁。OpenID Connect 身份验证建立在 OAuth 2.0 协议之上。

**Azure Active Directory**（**Azure AD**）是 OAuth 2.0 和 OpenID Connect 规范的提供者之一。在这里理解到，Azure AD 与应用程序的扩展性非常好，并且与任何组织的 Windows Server Active Directory 很好地集成。

如我们已讨论的容器，了解容器非常接近宿主操作系统的内核是很重要且有趣的。确保它们的安全是另一个不容忽视的方面。我们考虑的工具是 Docker，它通过最小权限原则提供了必要的安全保障。

# 监控

单体世界有其自身的优势。监控和日志记录是那些与微服务相比更容易处理的领域之一。企业系统可能分布的微服务数量可能令人难以置信。

如第一章中“微服务架构的先决条件”部分所讨论的，*《微服务简介》*，组织应该为这种深刻的变化做好准备。监控框架是这一需求的关键之一。

与单体架构不同，在基于微服务的架构中，监控从一开始就非常必要。监控可以归类的理由有很多：

+   健康性：我们需要预先知道何时服务故障即将发生。关键参数，如 CPU 和内存利用率，以及其他元数据，可能是即将发生的故障的先兆，或者是需要修复的服务中的缺陷。想象一下，当几百名现场执行董事试图与潜在客户分享成本时，保险公司的费率引擎过载并停止服务，或者运行缓慢。如今没有人喜欢等待。

+   可用性：可能存在一种情况，服务可能不需要进行广泛的计算，但服务本身的可用性对整个系统可能至关重要。在这种情况下，我记得依赖于向等待几分钟的监听器发送 ping，然后向系统管理员发送电子邮件。这对于只有一到两个服务需要监控的单一服务系统是有效的。然而，在微服务中，涉及更多的元数据。

+   性能：对于像银行和电子商务这样的高流量平台，仅仅保证可用性并不能提供所需的服务。考虑到在非常短的时间内（从几分钟到甚至几十秒）汇聚到平台的人数，性能不再是奢侈品。你需要通过数据来了解系统的响应情况，例如正在服务的并发用户数，并将其与后台的健康参数进行比较。这可能使电子商务平台能够在即将到来的假日季节之前决定是否需要升级。为了获得更多销售，你需要服务更多的人。

+   安全性：在任何系统中，你只能计划到一定程度的弹性。无论系统设计得多好，总会有系统无法承受的阈值，这可能导致连锁反应。然而，拥有一个精心设计的网络安全系统可以轻松避免拒绝服务（DoS）和 SQL 注入攻击。当处理微服务时，这一点在系统之间非常重要。因此，在设置微服务之间的信任级别时，要提前思考和仔细考虑。我看到的默认策略是使用微服务来保护端点。然而，覆盖这一方面可以提高系统的安全性，值得花些时间。

+   审计：医疗保健、金融和银行是几个对相关服务有最严格合规标准的领域。而且，这在全世界都是一样的。根据你处理的合规类型，你可能需要保留数据一段时间作为记录，以特定格式保留数据以与监管机构共享，甚至与当局提供的系统同步。税收系统也可能是另一个例子。在分布式架构中，你不希望因为丢失与单个交易相关的数据记录集而面临合规失败的风险。

+   故障排除系统故障：我相信，对于刚开始接触微服务的人来说，这将是长期以来的一个热门话题。我记得最初我尝试排除涉及两个 Windows 服务的场景。我从未想过再次推荐类似的设计。但时代已经改变，技术也是如此。

当向其他客户提供服务时，监控变得更加重要。在当今竞争激烈的世界里，SLA 将是任何交易的一部分，并且与其相关联的成本，无论是成功还是失败。你是否曾经想过，我们是如何轻易地假设微软 Azure 的 SLA 无论如何都会成立的？我已经习惯了它，以至于当客户担心云资源可用性时，我甚至没有眨一下眼，就给出了 99.9%正常运行时间的直接回复。

所以除非你能够自信地与客户达成服务级别的协议（SLA），否则他们不能指望你承诺未来提供相同的 SLA。事实上，没有 SLA 可能意味着你的服务可能不够稳定，无法提供 SLA。

# 监控挑战

在你成功建立监控系统之前，可能需要解决多个关键点。这些需要被识别并分配解决方案。以下是一些关键点的讨论。

# 规模

如果你已经拥有一个运行良好的系统，其中几十个微服务成功协调完美和谐的交易，那么你已经赢得了第一场战斗。恭喜！然而，如果你还没有这样做，你必须接入必要的监控部分。理想情况下，这应该是第一步本身的一部分。

# 组件生命周期

使用虚拟机和容器时，我们需要弄清楚哪些部分值得监控。在你查看监控产生的数据时，其中一些组件可能已经不存在了。因此，明智地选择要监控的信息变得极其重要。

# 信息可视化

有一些工具，如 AppDynamics 和 New Relic，可以让你可视化多达 100 个微服务的数据。然而，在实际应用中，这仅仅是数量的一小部分。必须明确这些信息的目的，并围绕它设计良好的可视化。这是我们可以选择逆向设计的一个领域。首先，考虑你想要的报告/可视化，然后看看它是如何被监控的。

# 监控策略

首先，在开始监控时，你可以将不同的常用策略视为解决你问题的方案。一些常用的策略包括：

+   应用程序/系统监控

+   真实用户监控

+   语义监控和合成事务

+   性能分析

+   端点监控

只需记住，这些策略中的每一个都是针对特定目的的。虽然其中一个可能在分析事务传播时有所帮助，但另一个可能适合测试目的。因此，在设计整个系统时，选择这些策略的组合非常重要，因为仅仅使用单一策略无法满足需求。

# 可扩展性

我们已经详细讨论了可扩展性的立方模型，并发现了每个轴向上扩展的含义。请注意，*x* 轴扩展是通过在多个实例之间使用负载均衡器以及微服务的用户来实现的。我们还看到了基于事务起源的 *z* 轴扩展存在一些缺点。

在微服务世界中，扩展可以大致分为两个不同的方面：

+   基础设施

+   服务设计

# 基础设施扩展

虚拟机是微服务世界不可或缺的组成部分。作为微软 Azure 平台的一部分，可用的功能使您能够轻松地完成这项看似复杂的任务。

通过与 Azure 自动扩展集成的扩展集功能，我们可以轻松地管理一组相同的虚拟机。

自动扩展允许您为各种支持的参数定义阈值，例如 CPU 使用率。一旦阈值被突破，根据参数是扩展内还是扩展外，扩展集将启动。

这意味着如果扩展集预测需要添加更多虚拟机来应对增加的负载，它将继续这样做，直到阈值恢复正常。同样，如果受管理的资源需求下降，它将决定从扩展集中移除虚拟机。对我来说，这听起来像是网络团队的和平。可以进一步探索自动扩展的选项，因为它能够处理复杂的扩展需求，在扩展内或扩展外时运行数百个虚拟机。

# 服务设计

在我们的微服务中，我们已经实现了每个微服务的数据隔离。然而，读取和写入数据库的模型仍然是相同的。由于底层的关系数据库强制执行 ACID 模型，这可能会是一笔昂贵的交易。或者说，我们可以稍微修改这种方法，以不同的方式实现数据库的读写操作。

我们可以使用常见的查询责任分离，也称为 CQRS，在我们的微服务中进行有效的设计变更。一旦完成模型级别的分离，我们将能够自由地使用不同的策略来优化读取和写入数据模型。

# 响应式微服务

在将我们的单体应用程序过渡到微服务风格的架构过程中，我们已经取得了良好的进展。我们还简要地提到了向我们的服务引入响应式特性的可能性。我们现在知道响应式微服务的关键属性是什么：

+   响应性

+   弹性

+   自主

+   以消息驱动

我们也看到了响应式微服务的益处，在管理微服务之间的通信时，我们所需的工作量减少。这种益处不仅体现在工作量减少，还在于能够专注于执行业务逻辑的核心工作，而不是试图处理服务间通信的复杂性。

# 绿色田野应用

现在让我们从头开始创建 FlixOne 书店。首先，我们将确定我们的微服务和它们的职能，并识别服务间的交互。

我们的 FlixOne 书店将提供以下一系列功能：

+   搜索可用的书籍

+   根据类别过滤书籍

+   将书籍添加到购物车

+   修改购物车

+   从购物车下订单

+   用户身份验证

# 服务范围

为了理解这些功能如何映射为不同的微服务，我们首先需要了解支持它们需要什么，什么可以组合成一个微服务。我们将看到数据存储是如何从微服务的视角开始的。

# 书籍列表微服务

让我们尝试分解通过书籍搜索的第一个功能。为了使用户能够浏览书店中的书籍，我们需要维护一个提供的书籍列表。在这里，我们的第一个候选者被划为一个微服务。书籍目录服务不仅负责搜索可用的书籍，还要维护一个数据存储，该存储将包含所有与书籍相关的信息。该微服务应该能够处理系统中可用的书籍所需的各项更新。我们将称之为书籍目录微服务，并且它将拥有自己的书籍数据存储。

# 书籍搜索微服务

检查过滤书籍的下一个功能似乎属于书籍目录微服务本身的范畴。然而，话虽如此，让我们通过质疑我们对业务领域的理解来确认这一点。我心中浮现的问题是关于用户执行的所有搜索对服务的影响。因此，书籍搜索功能应该是一个不同的服务吗？在这里，答案在于微服务应该有自己的数据存储。如果将书籍目录和书籍目录搜索功能作为不同的服务，将需要我们在两个不同的位置维护书籍列表，并面临额外的挑战，例如需要同步它们。解决方案很简单：拥有一个单一的微服务，如果需要，可以扩展并负载均衡书籍目录微服务。

# 购物车微服务

下一个候选者是因亚马逊等在线购物革命而闻名，并由智能手机进一步推动的购物车微服务。它应该允许我们在最终决定结账并支付之前添加或删除书籍。毫无疑问，这应该是一个独立的微服务。然而，这引发了一个有趣的问题，即它是否处理产品的数据存储；为了获取一些基本细节，例如库存可用性，它必须这样做。跨服务访问数据存储是不可能的，因为这是最基本的前提之一。我们问题的答案是服务间通信。一个微服务使用另一个微服务提供的服务是可以接受的。我们将称之为我们的购物车微服务。

# 订单微服务

下一个要考虑的业务功能是下单。当用户认为他们的购物车中正好有足够的书籍时，他们决定下单。在那个时刻，一些与订单相关的信息必须被确认/传达给其他微服务。例如，在确认订单之前，我们需要从图书目录中确认是否有足够的库存来满足订单。确认之后，应该从图书目录中减少相应数量的项目。在订单成功确认后，购物车也应该被清空。

尽管我们的订单微服务听起来更具有普遍性，并且与微服务之间数据不共享的规则相矛盾，但事实并非如此，正如我们很快就会看到的。所有操作都将保持清晰的边界，每个微服务管理自己的数据存储。

# 用户身份验证

我们最后的候选者是用户身份验证微服务，它将验证登录到我们的书店的客户提供的用户凭据。这个微服务的唯一目的是确认提供的凭据是否正确，以限制未经授权的访问。对于一个微服务来说，这似乎很简单；然而，我们必须记住这样一个事实，如果决定更改身份验证机制，将这个功能作为任何其他微服务的一部分将对多个业务功能产生影响。这种变化可能以使用基于 OAuth 2.0 授权框架和 OpenID Connect 1.0 身份验证生成的 JWT 令牌并进行验证的形式出现。

以下是为微服务准备的最终候选列表：

+   图书目录微服务

+   购物车微服务

+   订单微服务

+   用户身份验证微服务

在以下图像中，我们可以可视化四个服务：目录、购物车、订单和身份验证：

![图片](img/f9ac8893-2bd9-446a-9cd9-d3a4530dcaea.png)

# 同步与异步

在我们开始简要介绍微服务之前，这里有一个重要的观点需要考虑。我们的微服务将相互通信，并且它们可能会依赖于响应来进一步操作。这给我们带来了困境，因为我们经历了从心爱的单体架构中解脱出来并陷入同样可能因故障点而引发系统级联崩溃的境地。

# 书籍目录微服务

此微服务通过 HTTP API 组件公开了六个主要功能。处理这些功能的所有 HTTP 请求是此 HTTP API 组件的责任。

这些功能包括：

| **API 资源描述** | **API 资源描述** |
| --- | --- |
| `GET` /`api`/`book` | 获取可用书籍列表 |
| `GET` /`api`/`book{category}` | 获取特定类别的书籍列表 |
| `GET` /`api`/`book{name}` | 根据名称获取书籍列表 |
| `GET` /`api`/`book{isbn}` | 根据 ISBN 号获取书籍 |
| `GET` /`api`/`bookquantity{id}` | 获取目标书籍的可用库存 |
| `PUT` /`api`/`bookquantity{id, changecount}` | 增加或减少特定书籍的可用库存数量 |

以下图像可视化了目录服务的表：

![](img/dd32657b-5aa1-4ca3-a92c-6ba3e0c8a338.png)

# 购物车微服务

此微服务将以下功能作为 HTTP 端点公开供消费：

| **API 资源描述** | **API 资源描述** |
| --- | --- |
| `POST` /`api`/`book {customerid }` | 将特定书籍添加到客户的购物车中 |
| `DELETE` /`api`/`book {customerid }` | 从客户的购物车中删除书籍 |
| `GET` /`api`/`book{customerid}` | 获取客户购物车中的书籍列表 |
| `PUT` /`api`/`empty` | 删除购物车中当前包含的所有书籍。 |

以下图像可视化了购物车服务的所有支持表：

![](img/e99e8356-0ac3-45c3-8aff-442655e8f63d.png)

# 订单微服务

此微服务将以下功能作为 HTTP 端点公开供消费：

| **API 资源描述** | **API 资源描述** |
| --- | --- |
| `POST` /`api`/`order {customerid }` | 获取客户购物车中的所有书籍并为同一订单创建订单 |
| `DELETE` /`api`/`order {customerid }` | 从客户的购物车中删除书籍 |
| `GET` /`api`/`order{orderid}` | 获取特定订单中的所有书籍 |

以下图像展示了订单服务的所有表：

![](img/598e49f5-aca5-46e7-86fe-02c2b447c065.png)

# 用户身份验证微服务

此微服务将以下功能作为 HTTP 端点公开供消费：

| **API 资源描述** | **API 资源描述** |
| --- | --- |
| `GET` /`api`/`verifyuser{customerid, password}` | 验证用户 |

以下截图显示了认证服务的用户表：

![图片](img/36041ba3-4ca1-4b99-b021-aec19d71dab0.png)

您可以查看应用程序源代码并根据需要进行分析。

# 摘要

我们希望这本书能够向您介绍微服务风格架构的基本概念，并帮助您通过清晰的概念示例深入理解微服务的细微之处。最终的应用程序可供您仔细查看，并根据自己的节奏分析到目前为止所学到的内容。我们祝愿您在使用本书中学到的技能并将其应用于现实世界挑战时一切顺利。
