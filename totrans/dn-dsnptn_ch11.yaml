- en: Chapter 11. What is Reactive Programming?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。什么是响应式编程？
- en: By now we have seen how parallel and functional programming constructs in the
    .NET world help one naturally compose algorithms/business logic and model programs/data
    flows. These paradigms help realize a software system that has close correlation
    with the real world in which they exist. We have seen relevance of data structures
    and their role in program composition. We also saw the benefits (in terms of concurrency
    and parallelism) of keeping the data structures (modeled in an object-oriented
    way) different from the algorithms (modelled as pure function compositions) that
    consume them. To take this one knot further, in order to keep up with growing
    system complexity, there's a growing software revolution called **reactive programming**,
    which defines how to model applications from a behavior stand-point. In this chapter,
    we will try to unravel the concept through some examples, and understand how this
    programming paradigm becomes a natural succession, but more importantly, a unifying
    model for creating responsive systems. We will look at the various reactive programming
    constructs (including key data structures, interfaces, and operators) available
    in .NET **Reactive Extensions** (**Rx**). By the end of the chapter, you will
    understand how natural it is to model responsiveness, which becomes quite relevant
    in this new world of multicore, cloud, mobile, and web-scale systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了.NET世界中并行和函数式编程结构如何帮助人们自然地组合算法/业务逻辑以及模型程序/数据流。这些范式有助于实现与现实世界紧密相关的软件系统。我们已经看到了数据结构及其在程序组合中的作用。我们还看到了保持数据结构（以面向对象的方式建模）与消耗它们的算法（作为纯函数组合建模）不同的好处（在并发和并行性方面）。为了进一步解开这个结，为了跟上不断增长的系统复杂性，出现了一场名为**响应式编程**的软件革命，它定义了如何从行为角度建模应用程序。在本章中，我们将通过一些示例来尝试解开这个概念，并了解这种编程范式如何成为一种自然延续，但更重要的是，成为一种统一模型，用于创建响应式系统。我们将探讨.NET
    **响应式扩展**（**Rx**）中可用的各种响应式编程结构（包括关键数据结构、接口和运算符）。到本章结束时，你将理解建模响应性是多么自然，这在多核、云、移动和Web规模系统的这个新世界中变得相当相关。
- en: Being reactive
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为响应式
- en: To start with, let's look at the classic definition of reactive programming,
    and try to understand the concept brought forth by this model. This is important
    to undo any misconceptions that govern one's mind on this topic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看响应式编程的经典定义，并尝试理解这个模型带来的概念。这对于消除关于这个主题的任何误解很重要。
- en: '|   | *In computing, reactive programming is a programming paradigm that maintains
    a continuous interaction with their environment, but at a speed which is determined
    by the environment, not the program itself.* |   |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   | *在计算机科学中，响应式编程是一种编程范式，它与其环境保持持续交互，但速度由环境决定，而不是程序本身决定。* |   |'
- en: '|   | --*Gèrard Berry* |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Gèrard Berry* |'
- en: This implies that this programming model helps, or rather, has an inherent capability
    to propagate changes without the programmer having to explicitly wire any such
    logic (the conventional way, which was error prone and rendered programs inconsistent;
    a nightmare that still haunts some of us). This would mean that the programming
    model would be declarative and provide the needed constructs (including data structures
    and interfaces) to capture the relationship between attributes in order to ensure
    seamless propagation or synchronization of changes through data flows.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这种编程模型有助于，或者更确切地说，具有内在的能力来传播变化，而无需程序员显式地连接任何此类逻辑（传统方式，容易出错并使程序不一致；一些人的噩梦）。这意味着编程模型将是声明性的，并提供所需的结构（包括数据结构和接口）来捕获属性之间的关系，以确保通过数据流无缝传播或同步变化。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The design pattern that really powers this model is observer, where the relationships
    between subscribers and publishers are declaratively modeled.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 真正推动这个模型的设计模式是观察者模式，其中订阅者和发布者之间的关系被声明性地建模。
- en: Let's try to understand this further via this example. In typical assignment
    statements (in the imperative world), relations are implicitly declared (say *c²
    = a² + b²* , the Pythagorean equation that symbolizes the Pythagorean theorem),
    or functions (in the functional programming world) are defined explicitly, say
    *c = Compute Hypotenuse(a, b)*. On the other hand, in the reactive world, computation
    (value of *c*) is automatically done with new values of the sides (*a* and *b*).
    The computation is automatically triggered every time the value changes for *a*
    and *b* in the relation *c² = a² + b²*. This behavior is termed as **reactive**.
    You could say that this is similar to event-driven programming, but there is a
    very distinct difference here that you need to understand.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个例子进一步理解。在典型的赋值语句（在命令式世界中），关系是隐式声明的（例如 *c² = a² + b²*，这是代表勾股定理的毕达哥拉斯方程），或者函数（在函数式编程世界中）是明确定义的，例如
    *c = Compute Hypotenuse(a, b)*。另一方面，在反应式世界中，计算（*c* 的值）会自动使用新的边长值（*a* 和 *b*）进行。每当关系
    *c² = a² + b²* 中的 *a* 和 *b* 的值发生变化时，计算会自动触发。这种行为被称为 **反应式**。您可以说这类似于事件驱动编程，但这里有一个非常明显的区别，您需要理解。
- en: This behavior is extremely important to model concurrent real-world systems
    including real-time analytics, control systems with feedback loops, electronic
    circuits and **printed circuit board** (**PCB**) design, rule engine, state machines,
    simulators, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于模拟并发现实世界系统非常重要，包括实时分析、具有反馈环的控制系统、电子电路和 **印刷电路板**（**PCB**）设计、规则引擎、状态机、模拟器等等。
- en: Electronic spread sheets - A quintessential example
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子表格 - 一个典型的例子
- en: 'Electronic spreadsheets such as Excel software help one to input values in
    Cells, in a program-specific manner (for example-*A7* , *B6*, and so on). They
    also allow you to embed computation as a value of a cell (such as *=$A7*$B6* )
    using formulas. Whenever a value is changed in *A7* or *B6*, the resulting formula
    will be recomputed. Actually, the change is propagated to cells where there is
    reference to the cell which changed. This can be called a type of reactive computation.
    Let''s see our Pythagorean triple generation in action on Excel:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格软件，如 Excel，帮助用户以特定程序的方式在单元格中输入值（例如-*A7*，*B6*，等等）。它们还允许您使用公式将计算嵌入为单元格的值（例如 *=$A7*$B6*）。每当
    *A7* 或 *B6* 中的值发生变化时，结果公式将重新计算。实际上，这种变化会传播到引用了变化单元格的单元格中。这可以称为一种反应式计算。让我们看看在 Excel
    上 Pythagorean 三重生成是如何实际操作的：
- en: '![Electronic spread sheets - A quintessential example](img/B05691_11_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![电子表格 - 一个典型的例子](img/B05691_11_01.jpg)'
- en: In the preceding table, you can see that column **F** indicates (achieved with
    conditional formatting using icon sets) whether **a**, **b,** and **c** are Pythagorean
    triples or not.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，您可以看到列 **F** 指示（通过使用图标集的条件格式实现）*a*，*b* 和 *c* 是否是毕达哥拉斯三重组。
- en: The hidden columns **D** and **F** compute the values of (**a² + b²**) and **c²**
    independently, and column F just checks for an equality in order to display a
    potential match. All these are done, of course, using formulas, and the changes
    across cells are propagated automatically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的列 **D** 和 **F** 独立计算 (*a² + b²*) 和 **c²** 的值，而列 **F** 只检查是否存在相等，以便显示潜在的匹配。所有这些当然都是使用公式完成的，并且单元格之间的变化会自动传播。
- en: 'The following screenshot illustrates this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图说明了这一点：
- en: '![Electronic spread sheets - A quintessential example](img/B05691_11_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![电子表格 - 一个典型的例子](img/B05691_11_02.jpg)'
- en: This example should give you an idea of how reactive programming works, and
    more interestingly, we will use this trivial example to illustrate a deep consequence
    beyond reactive programming. This spreadsheet program elegantly models the **Model-View-ViewModel**
    (**MVVM**) pattern, an architectural pattern heavily employed in WPF, Silverlight,
    and now, most of the prevalent HTML UI frameworks (JS-based). The Model in this
    case would be columns **A** and **B** (consider each row as entities and the columns
    as entity attributes). The View Model would be columns **D** and **E** (derived
    attributes from the model attributes). And column **F** would be the View which
    is bound to the View Model (and any change in View Model would be synchronized
    with the View; as a matter of fact, any changes in the Model would be propagated
    to the View Model and further down to the View).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子应该能让你了解响应式编程是如何工作的，更有趣的是，我们将使用这个简单的例子来展示响应式编程之外的深远影响。这个电子表格程序优雅地模拟了**模型-视图-视图模型**（**MVVM**）模式，这是一个在WPF、Silverlight中大量使用，现在在大多数流行的HTML
    UI框架（基于JS）中也广泛使用的架构模式。在这个例子中，模型将是列**A**和**B**（将每一行视为实体，将列视为实体属性）。视图模型将是列**D**和**E**（从模型属性派生出的属性）。而列**F**将是视图，它与视图模型绑定（任何视图模型的变化都会与视图同步；实际上，模型中的任何变化都会传播到视图模型，然后进一步传播到视图）。
- en: Reactive programming model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程模型
- en: Simply put, reactive programming is nothing but programming with asynchronous
    data streams. By applying various operations on stream, we can achieve different
    computational goals. The primary task in a reactive program is to convert the
    data into streams, regardless of what the source of the data is. While writing
    modern graphical user interface applications, we process mouse move-and-click
    events. Currently, most systems get a callback, and process these events as and
    when they happen. Most of the time, the handler does a series of filtering operations
    before it invokes the action methods associated with the event calls.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应式编程就是使用异步数据流进行编程。通过对流应用各种操作，我们可以实现不同的计算目标。在响应式程序中的主要任务是无论数据的来源是什么，都将数据转换为流。在编写现代图形用户界面应用程序时，我们处理鼠标移动和点击事件。目前，大多数系统都会收到回调，并在事件发生时处理这些事件。大多数情况下，处理程序会在调用与事件相关的操作方法之前执行一系列过滤操作。
- en: In this particular context, reactive programming helps us in aggregating the
    mouse move-and-click events into a collection, and sets filters on them before
    notifying the handler logic. In this way, the application/handler logic does not
    get executed unnecessarily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的上下文中，响应式编程帮助我们将鼠标移动和点击事件聚合到一个集合中，并在通知处理程序逻辑之前对它们设置过滤器。这样，应用程序/处理程序逻辑就不会被无谓地执行。
- en: Stream-processing model is well known, and it is very easy to encode by application
    developers. Pretty much anything can be converted into a stream. Such candidates
    include messages, logs, properties, twitter feeds, blog posts, RSS feeds, and
    so on. Functional programming techniques are really good at processing streams.
    A language like C#, with its inherent support for functional programming idioms,
    becomes a natural choice for writing reactive programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 流处理模型是众所周知的，并且对于应用程序开发者来说非常容易编码。几乎任何东西都可以转换成一个流。这些候选者包括消息、日志、属性、推特动态、博客文章、RSS源等等。函数式编程技术非常适合处理流。像C#这样的语言，由于其固有的函数式编程习惯语支持，成为编写响应式程序的自然选择。
- en: The basic idea behind reactive programming is that there are certain datatypes
    that represent a value over time. These datatypes (or rather data sequences) are
    represented as observable sequences in this programming paradigm. Computations
    that involve these changing (time dependent) values will, in turn, themselves
    have values that change over time, and would need to asynchronously receive notifications
    (as and when the dependent data changes). Remember the spreadsheet application
    discussed earlier?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程背后的基本思想是存在某些数据类型表示随时间变化的值。在这些编程范式中的这些数据类型（或更确切地说，数据序列）被表示为可观察的序列。涉及这些变化（时间依赖）值的计算将反过来具有随时间变化的值，并且需要异步接收通知（当依赖数据变化时）。还记得之前讨论过的电子表格应用程序吗？
- en: Functional reactive programming
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能响应式编程
- en: Most modern programming languages support functional programming constructs.
    Functional programming constructs such as Map/Reduce, Filter, Fold, and so on
    are good for processing streams. Programming asynchronous data streams using functional
    programming constructs is called functional reactive programming. This is gaining
    more traction among the developers these days.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言都支持函数式编程结构。例如，Map/Reduce、Filter、Fold 等函数式编程结构非常适合处理流数据。使用函数式编程结构编程异步数据流被称为函数式响应式编程。这种编程方式在开发者中越来越受欢迎。
- en: The FRP programs can be classified as **push-based** and **pull-based**. The
    pull-based system waits for a demand to push the data streams to the requestor
    (or subscriber in our case). This is the classic case where the data source is
    actively polled for more information. This employs the iterator pattern, and `IEnumerable
    <T>`/`IEnumerator <T>` interfaces are specifically designed for such scenarios
    that are synchronous in nature (application can block while pulling data). On
    the other hand, a push-based system aggregates the events and pushes through a
    signal network to achieve the computation. In this case, unlike the pull-based
    system, data and related updates are handed to the subscriber from the source
    (observable sequences in this case). This asynchronous nature is achieved by not
    blocking the subscriber, but rather making it react to the changes. The observer
    pattern is put to extensive use here using the `IObservable <T>` and `IObserver<T>`
    interfaces (which have been introduced as part of .NET framework 4.0). As you
    can see, employing this push pattern is more beneficial in rich UI environments
    where you wouldn't want to block the main UI thread while waiting for some events.
    This becomes ideal, thus making reactive programs responsive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FRP 程序可以分为**基于推**和**基于拉**两种。基于拉的系统等待请求者（或在我们的情况下，订阅者）的需求来推送数据流。这是一个经典案例，其中数据源被主动轮询以获取更多信息。这采用了迭代器模式，`IEnumerable
    <T>`/`IEnumerator <T>`接口专门为这种本质上是同步的场景设计（应用程序在拉取数据时可能会阻塞）。另一方面，基于推的系统通过信号网络聚合事件并执行计算。在这种情况下，与基于拉的系统不同，数据和相关的更新是由源（在这种情况下是可观察序列）直接传递给订阅者的。这种异步性是通过不阻塞订阅者，而是使其对变化做出反应来实现的。在这里，广泛使用了观察者模式，使用了`IObservable
    <T>`和`IObserver<T>`接口（这些接口作为.NET框架4.0的一部分被引入）。正如你所看到的，在丰富的UI环境中采用这种推模式更有益，你不会希望在等待某些事件时阻塞主UI线程。这使得响应式程序变得理想，从而使得程序响应迅速。
- en: Reactive programming principles
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式编程原则
- en: Reactive systems are composed of small subsystems, which have got reactive properties
    at the subsystems level. This is possible, because reactive applications apply
    sound design principles to maintain the responsiveness of their constituents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式系统由具有反应性属性的小子系统组成。这是可能的，因为响应式应用程序应用了良好的设计原则来保持其组成部分的响应性。
- en: 'According to the reactive manifesto, the following are the four principles
    of reactive programming:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据响应式宣言，以下为响应式编程的四个原则：
- en: '**Responsiveness**: A reactive system is supposed to respond to events in a
    time-bound manner. This helps in usability and utilizability of the systems. Responsive
    systems help us to detect anomalies very early, and can maintain good **Quality
    of Service** (**QoS**). This is very important for systems that have **service
    level agreement** (**SLA**) and **operations level agreement** (**OLA**).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：响应式系统应按时间限制的方式对事件做出响应。这有助于系统的可用性和实用性。响应式系统可以帮助我们非常早期地检测异常，并可以保持良好的**服务质量**（**QoS**）。这对于具有**服务级别协议**（**SLA**）和**操作级别协议**（**OLA**）的系统非常重要。'
- en: '**Resilience**: Reactive systems should stay responsive even in the case of
    a system failure. Failures are contained in each component by careful isolation
    of subsystems, and making sure that failure does not get propagated to other parts.
    By good modularization, we can recover from failure by replacing components that
    fail without affecting the other modules of the system.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：即使在系统出现故障的情况下，响应式系统也应保持响应。通过仔细隔离子系统并确保故障不会传播到其他部分，可以在每个组件中包含故障。通过良好的模块化，我们可以通过替换失败的组件来恢复故障，而不会影响系统的其他模块。'
- en: '**Elasticity**: Reactive systems should stay responsive under varying levels
    of stress due to the workloads. By effective throttling of event streams and dynamic
    resource management, we can write systems that can handle varying workloads.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：反应式系统应该在不同的工作负载压力下保持响应。通过有效节流事件流和动态资源管理，我们可以编写能够处理不同工作负载的系统。'
- en: '**Message driven**: Reactive systems rely on asynchronous messaging-based programming
    models to establish strict boundaries between components by maintaining loose
    coupling and location transparency (in the case of distributed systems). Employing
    explicit message-passing helps to manage load better, and to provide elasticity
    and explicit flow control through throttling. Non-blocking communication between
    components makes sure that resource management is done diligently. Moreover, system
    failures can be propagated as messages.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：反应式系统依赖于基于异步消息的编程模型，通过保持松散耦合和位置透明性（在分布式系统中）来建立组件之间的严格边界。使用显式的消息传递有助于更好地管理负载，并通过节流提供弹性和显式的流控制。组件之间的非阻塞通信确保资源管理得到妥善处理。此外，系统故障可以以消息的形式传播。'
- en: '![Reactive programming principles](img/B05691_11_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![反应式编程原则](img/B05691_11_03.jpg)'
- en: Rx from Microsoft
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软的 Rx
- en: 'Microsoft brought out **software development kit** (**SDK**) for reactive programming,
    which it monikers as .NET Rx. According to them, Rx extensions is a unified library
    for composing asynchronous and event-based programs using observable sequences
    and LINQ style query operations. The key aspects of their descriptions are as
    follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 推出了用于反应式编程的 **软件开发工具包**（**SDK**），它将其命名为 .NET Rx。根据他们的说法，Rx 扩展是一个用于使用可观察序列和
    LINQ 风格查询操作来组合异步和基于事件的程序的统一库。他们描述的关键方面如下：
- en: Asynchronous event streams
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步事件流
- en: Composition
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Observable sequences (streams)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察序列（流）
- en: LINQ style queries
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ 风格查询
- en: The sequences can be contents of a file, network socket, web service response,
    input streams, and so on. Microsoft gives a symbolic formula for Rx, that is,
    *Rx = Observables + LINQ + Schedulers*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列可以是文件内容、网络套接字、Web 服务响应、输入流等。Microsoft 为 Rx 提供了一个符号公式，即 *Rx = Observables
    + LINQ + Schedulers*。
- en: Key data structures of Rx
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rx 的关键数据结构
- en: 'The Microsoft Rx SDK specifies some key data types, which a programmer can
    leverage to implement reactive programs. Some of the key types are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Rx SDK 指定了一些关键数据类型，程序员可以利用这些类型来实现反应式程序。以下是一些关键类型：
- en: '`IObservable<T>`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObservable<T>`'
- en: '`IObserver<T>`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObserver<T>`'
- en: '`Subject<T>`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject<T>`'
- en: 'The signature of `IObserver` and `IObservable` is given as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObserver` 和 `IObservable` 的签名如下：'
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: IEnumberable/IObservable duality
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IEnumberable/IObservable 双重性
- en: 'The .NET framework has built-in support for the Iterator pattern (through `IEnumerable<T>`)
    and observer pattern (through `IObservable<T>`). If you take a closer look, there
    is only a subtle difference between these two patterns. `IEnumerable<T>` can be
    considered the pull-based equivalent of the push-based `IObservable<T>`. In fact,
    they are duals. When two entities exchange information, one entity''s action of
    pull corresponds to other entity pushing the information. This duality is illustrated
    in the following image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架内置了对迭代器模式（通过 `IEnumerable<T>`）和观察者模式（通过 `IObservable<T>`）的支持。如果你仔细观察，这两个模式之间只有细微的差别。`IEnumerable<T>`
    可以被认为是基于拉取的 `IObservable<T>` 的基于推送的等价物。实际上，它们是互为对方的对立面。当两个实体交换信息时，一个实体的拉取动作对应于另一个实体推送信息。这种双重性在以下图像中得到了说明：
- en: '![IEnumberable/IObservable duality](img/B05691_11_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![IEnumberable/IObservable 双重性](img/B05691_11_04.jpg)'
- en: 'Let''s understand this duality by looking at this sample code, an even number
    sequence generator:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看以下示例代码来理解这种双重性，这是一个偶数序列生成器：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will write a number sequence generator to demonstrate how these data types
    work together in converting a pull-based program to an Rx push program. First
    we will write a toy implementation of `IDisposable` to be used later: The robustness
    aspect is given low priority to keep the listing terse:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个数字序列生成器来演示这些数据类型如何协同工作，将基于拉取的程序转换为 Rx 推送程序。首先，我们将编写一个用于后续使用的玩具实现 `IDisposable`：为了保持列表简洁，健壮性方面被赋予较低的优先级：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code snippet invokes the preceding code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段调用了前面的代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From this preceding example, you see how one can naturally subscribe for even
    numbers from an observable sequence of natural numbers. The system will automatically
    push (publish) the values to the observer (subscriber) when an even number is
    detected. The code gives explicit implementations for the key interfaces so that
    one can understand or speculate what really happens under the hood.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的例子中，你可以看到如何从自然数的可观察序列中自然地订阅偶数。当检测到偶数时，系统将自动将值推送到观察者（订阅者）。代码为关键接口提供了显式实现，以便人们可以理解或推测底层实际发生了什么。
- en: 'Another example would be Pythagorean triple generation from observable sequences
    of base, altitude, and hypotenuse. We have already seen the **functional** code
    for achieving this, and now, let''s see the **reactive** equivalent (or should
    we say, a better one):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是从底边、高边和斜边的可观察序列生成毕达哥拉斯三元组。我们已经看到了实现此目的的 **函数式** 代码，现在，让我们看看 **响应式** 等效（或者说，更好的一种）：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Converting entities to streams (IObservable<T>)
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实体转换为流（`IObservable<T>`）
- en: 'The following constructs can be converted to a sequence source. `IObservable<T>`
    can be generated from the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下构造可以转换为序列源。`IObservable<T>` 可以从以下生成：
- en: Events
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Delegates
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Tasks
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务
- en: '`IEnumerable<T>`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`'
- en: Asynchronous programming model
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程模型
- en: Converting events into stream
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将事件转换为流
- en: 'We have now understood how one can convert an `IEnumerable<T>`-based pull program
    to an `IObservable<T>`/`IObserver<T>`-based push program. In real life, the event
    source is not as simple as we found in the number stream example given previously.
    Let us see how we can convert a `MouseMove` event into a stream with a small WinForms
    program:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了如何将基于 `IEnumerable<T>` 的拉取程序转换为基于 `IObservable<T>`/`IObserver<T>` 的推送程序。在现实生活中，事件源并不像我们在先前的数字流示例中找到的那样简单。让我们看看我们如何可以通过一个小
    WinForms 程序将 `MouseMove` 事件转换为流：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please see the following form, which displays the mouse positions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见以下形式，它显示了鼠标位置：
- en: '![Converting events into stream](img/B05691_11_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![将事件转换为流](img/B05691_11_05.jpg)'
- en: Reduction of streams (sequences)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流（序列）的减少
- en: 'The whole idea of converting data to streams is to apply functional programming
    operators such as Reduce, Aggregate, Fold, and so on. This is quite relevant in
    terms of choosing the needed data (and also in an efficient way) from an enormous
    pile that is ever growing with respect to time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据转换为流的整体想法是应用函数式编程运算符，如 Reduce、Aggregate、Fold 等。这在从不断增长的数据堆中选择所需数据（以及以有效的方式）方面非常相关：
- en: '**Filter and partition operators**: These operations help to reduce the source
    sequence into a sequence of elements that we are interested in'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤和分区运算符**：这些操作有助于将源序列减少到我们感兴趣的元素序列'
- en: '**Aggregation operators**: Reduce the source sequence to a sequence with a
    single element'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合运算符**：将源序列减少到只有一个元素的序列'
- en: '**Fold operators**: Reduce the source sequence to a single element as a scalar
    value'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠运算符**：将源序列减少到单个标量值'
- en: 'Some of the common sequence/stream operators supported by Rx/LINQ are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rx/LINQ 支持的一些常见序列/流运算符如下：
- en: '`Where`: As the name implies, and for those familiar with this operator from
    LINQ days, it does the very purpose of filtering of sequences. If we were to rewrite
    our earlier example-that of extracting/filtering even numbers-it would declaratively
    be as simple as this:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where`: 如其名所示，对于那些熟悉 LINQ 时代此运算符的人来说，它执行序列过滤的非常目的。如果我们重写先前的例子——提取/过滤偶数——它将声明性简化为如下：'
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, the input is 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, and
    the output will be 2, 4, 6, and 8.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在先前的例子中，输入是 0, 1, 2, 3, 4, 5, 6, 7, 8 和 9，输出将是 2, 4, 6 和 8。
- en: '`Skip`: This helps in skipping *n* items in a sequence.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Skip`: 这有助于在序列中跳过 *n* 个项目。'
- en: '`Take`: This helps in taking *n* items (skipping the rest) in a sequence.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Take`: 这有助于在序列中获取 *n* 个项目（跳过其余部分）。'
- en: '`SkipWhile`: This helps in skipping items (while a certain condition is satisfied)
    in a sequence. Please note that the element would be skipped until the predicate
    evaluates to `true`. Beyond this, all items would be returned.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipWhile`: 这有助于在序列中跳过项目（当满足某个条件时）。请注意，元素将被跳过，直到谓词评估为 `true`。在此之后，将返回所有其他项目。'
- en: '`TakeWhile`: This is the converse of `SkipWhile`, and helps in taking items
    (while a certain condition is satisfied) in a sequence.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeWhile`: 这是 `SkipWhile` 的逆操作，有助于在序列中跳过项目（当满足某个条件时）。'
- en: '`SkipUntil`: This requires two observable sequences, and continues to skip
    all the values in the first sequence until any value is produced by the second
    sequence.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipUntil`: 这需要两个可观察序列，并继续跳过第一个序列中的所有值，直到第二个序列产生任何值。'
- en: '`TakeUntil`: Again, this requires two observable sequences, and forces the
    first sequence to completion when the second sequence starts producing any value.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeUntil`: 再次，这需要两个可观察序列，并在第二个序列开始产生任何值时强制第一个序列完成。'
- en: '`SkipLast`: Intelligently queues elements, skips the last *n* elements, and
    returns the rest.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipLast`: 智能地排队元素，跳过最后 *n* 个元素，并返回其余部分。'
- en: '`TakeLast`: Returns the last *n* elements.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeLast`: 返回最后 *n* 个元素。'
- en: '`Zip`: Merges two observable sequences into one observable sequence.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zip`: 将两个可观察序列合并为一个可观察序列。'
- en: Inspection of streams (sequences)
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流（序列）的检查
- en: 'Rx provides a set of operators, which can help us to inspect the contents of
    a stream. Some of them are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Rx提供了一套操作符，可以帮助我们检查流的内容。其中一些如下：
- en: '`Any`: This returns an observable sequence (result), which returns one value
    (`True` or `False`) and completes. `True` indicates that the source sequence produced
    a value that caused the result sequence to produce `True`. On the other hand,
    the result sequence returns `False` if the source sequence completes without any
    values.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`: 这返回一个可观察序列（结果），返回一个值（`True` 或 `False`）并完成。`True` 表示源序列产生了一个导致结果序列产生
    `True` 的值。另一方面，如果源序列在没有任何值的情况下完成，结果序列返回 `False`。'
- en: '`All`: This works similar to `Any` except that the results sequence returns
    `True` if the predicate is evaluated to `True` and `False` vice versa.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`All`: 这与 `Any` 的工作方式类似，除了结果序列在谓词评估为 `True` 时返回 `True`，反之亦然。'
- en: '`Contains`: This shows the same behavior as `All` except that it helps seek
    a specific value instead of a value that fits the predicate.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains`: 这与 `All` 的行为相同，但有助于寻找特定值而不是符合谓词的值。'
- en: '`ElementAt`: This returns an observable sequence (result), which returns the
    value in the source sequence (specified by the index) and completes. It uses a
    0-based index.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementAt`: 这返回一个可观察序列（结果），返回源序列（由索引指定）中的值并完成。它使用基于0的索引。'
- en: Aggregation of streams (sequences)
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流（序列）的聚合
- en: 'Rx provides a series of operators, which help us to aggregate the content of
    a stream. Some of the most important ones are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Rx提供了一系列操作符，帮助我们聚合流的内容。其中一些最重要的如下：
- en: '`Count`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`'
- en: '`Min`, `Max`, `Average`, `Sum` (descriptive statistics)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Min`, `Max`, `Average`, `Sum` (描述性统计)'
- en: '`MinBy`, `MaxBy`, `GroupBy` (partitioning)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinBy`, `MaxBy`, `GroupBy` (分区)'
- en: Custom aggregators and scans
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义聚合器和扫描
- en: Transformation of streams (sequences)
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流（序列）的转换
- en: The values produced by our event source are not in the formats that we might
    want, and we are required to make the transformation on each element in the sequence.
    The most important functional transformation is bind, where we apply a function
    (morphism) on each element of the sequence to produce a new sequence.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件源产生的值不是我们可能想要的格式，我们需要对序列中的每个元素进行转换。最重要的函数转换是绑定，其中我们对序列的每个元素应用一个函数（形态），以产生一个新的序列。
- en: 'In functional programming parlance, the transformations available are the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程术语中，可用的转换如下：
- en: 'Anamorphism, which transforms `T` to `IObservable<T>`:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '演化，将 `T` 转换为 `IObservable<T>`:'
- en: '`Unfold`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unfold`'
- en: '`Generate`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Generate`'
- en: 'Catamorphism, which transforms an `IObservable<T>` to `T`:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '递归归纳，将 `IObservable<T>` 转换为 `T`:'
- en: '`Fold`'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fold`'
- en: '`Reduce`'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reduce`'
- en: '`Accumulate`'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accumulate`'
- en: 'Bind, which transforms an `IObservable<T>` to `IObservable<T>`:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '绑定，将 `IObservable<T>` 转换为 `IObservable<T>`:'
- en: '`Map`'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`'
- en: '`SelectMany`'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectMany`'
- en: '`Projection`'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Projection`'
- en: '`Transform`'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform`'
- en: Combining streams (sequences)
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流（序列）的组合
- en: 'We get data from different data sources, and it is necessary to combine streams
    to do processing. Rx provides a series of operators, which can be grouped into
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从不同的数据源获取数据，需要组合流来进行处理。Rx提供了一系列操作符，可以分组如下：
- en: 'Sequential concatenation:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序连接：
- en: '`Concat`: As the name indicates, the resulting sequence concatenates multiple
    input sequences without interleaving them'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Concat`: 如其名所示，结果序列将多个输入序列连接起来，而不交错它们'
- en: '`Repeat`: Creates a sequence that emits a particular item multiple times'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repeat`: 创建一个序列，多次发出特定项'
- en: '`StartWith`: Emits a specified sequence of items before beginning to emit the
    items from the source sequence'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartWith`: 在开始从源序列发出项之前，发出指定序列的项'
- en: 'Concurrent sequences:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发序列：
- en: '`Amb`: This returns one of the sequences (from two or more source sequences),
    which first starts emitting an item or notification'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Amb`：这个操作返回来自两个或更多源序列中的一个序列，该序列首先开始发出一个项或通知'
- en: '`Merge`: As the name indicates, this operator combines multiple sequences into
    one'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Merge`：正如其名称所示，这个算子将多个序列合并为一个'
- en: '`Switch`: This returns a sequence (from two or more source sequences) that
    emits the items emitted by the most recently emitted one of those input/source
    sequences'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`：这个操作返回一个序列（来自两个或更多源序列），该序列发出最近发出的输入/源序列中的项'
- en: 'Pairing sequences:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对序列：
- en: '`CombineLatest`: Combines the most recently emitted items from each of the
    participating input sequences using a function that is provided, and emits the
    return value of that function'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CombineLatest`：使用提供的函数结合每个参与输入序列最近发出的项，并发出该函数的返回值'
- en: '`Zip`: The behavior is similar to that of `CombineLatest` except that the function
    is applied in a strict sequence (in terms of combining items from the participating
    input sequences)'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zip`：其行为类似于`CombineLatest`，但函数是按照严格的顺序（在结合参与输入序列的项方面）应用的'
- en: '`And`/`Then`/`When`: The behavior is very similar to `Zip`, but certain intermediary
    data structures (namely pattern and plan objects) are used as part of combining
    the input sequences before emitting the resulting sequence'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`And`/`Then`/`When`：其行为与`Zip`非常相似，但在发出结果序列之前，使用某些中间数据结构（即模式和计划对象）作为结合输入序列的一部分'
- en: A philosophy for reactive programming
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程的哲学
- en: We started this chapter with a lot of verbose description about the reactive
    programming model. Then, we showed how one can convert an `IEnumerable<T>`-based
    sequence generator to an `IObservable<T>`/`IObserver<T>-`based push program. We
    also demonstrated how one can convert mouse-event data to a stream, using a toy
    program. The rest of the chapter was about the tools available for manipulating
    streams or sequences. You learned about the different genres of stream processing
    operators. One needs to consult the Microsoft documentation on Rx to understand
    the specifics of stream processors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以大量关于反应式编程模型的详细描述开始了这一章。然后，我们展示了如何将基于`IEnumerable<T>`的序列生成器转换为基于`IObservable<T>`/`IObserver<T>`的推送程序。我们还演示了如何使用玩具程序将鼠标事件数据转换为流。本章的其余部分是关于可用于操作流或序列的工具。你了解了不同类型的流处理算子。需要查阅Microsoft关于Rx的文档来了解流处理器的具体细节。
- en: 'The basic philosophy here can be summarized as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本哲学可以总结如下：
- en: Aggregate data into asynchronous or synchronous streams from the event source.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件源的数据聚合到异步或同步流中。
- en: Apply preprocessing methods using various operators available at the data source
    itself (outside the stream consumer).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据源本身（在流消费者外部）可用的各种算子应用预处理方法。
- en: Process the resulting stream pushed from the data source at the data sink level
    by applying functional transformation techniques. We can compose stream operations
    to produce compound operations. By doing this, the whole program becomes a linear
    chain of functions applied on a stream. If the data stream is not mutated, there
    is no need for a compensating transaction logic as well.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用函数转换技术，在数据源端点级别处理从数据源推送的结果流。我们可以组合流操作以产生复合操作。通过这样做，整个程序成为应用在流上的函数的线性链。如果数据流没有发生突变，则不需要补偿事务逻辑。
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Schematically, the preceding code snippets can be interpreted as that we can
    apply a series of functions on a stream to produce output stream. Since the input
    stream is immutable when we process at the data sink level, there is no need for
    a compensating transaction in the catch handler. The whole processing can be easily
    debugged as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从图示上看，前面的代码片段可以解释为我们可以对数据流应用一系列函数以产生输出流。由于在数据处理端点级别，输入流是不可变的，因此在捕获处理程序中不需要补偿事务。整个处理过程也可以轻松调试。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the conceptual underpinnings of (functional) reactive
    programming, and how Microsoft Rx helps you to write reactive programs using a
    scheduler, observable interface, and LINQ. We have avoided API documentation in
    this book (as that is exhaustive and redundant considering the nature of this
    book). We urge you to refer to the ReactiveX website ([http://reactivex.io/documentation/operators](http://reactivex.io/documentation/operators)),
    MSDN, interactive Rx illustrations website ([http://rxmarbles.com](http://rxmarbles.com)),
    and the online book *Introduction to Rx* by Lee Campbell ([http://www.introtorx.com](http://www.introtorx.com))
    for specifics and usage examples on the various operators that we have discussed.
    In the following chapters, we will see detailed examples in C# and JavaScript-based
    functional reactive programs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了（功能）响应式编程的概念基础，以及微软Rx如何帮助你使用调度器、可观察接口和LINQ来编写响应式程序。我们在这本书中避免了对API文档的介绍（因为考虑到本书的性质，这些内容已经详尽且重复）。我们强烈建议你参考ReactiveX网站([http://reactivex.io/documentation/operators](http://reactivex.io/documentation/operators))、MSDN、交互式Rx图示网站([http://rxmarbles.com](http://rxmarbles.com))以及Lee
    Campbell撰写的在线书籍《Rx简介》(*Introduction to Rx*)([http://www.introtorx.com](http://www.introtorx.com))，以获取我们讨论的各种操作符的详细信息和使用示例。在接下来的章节中，我们将看到基于C#和JavaScript的详细功能响应式程序示例。
