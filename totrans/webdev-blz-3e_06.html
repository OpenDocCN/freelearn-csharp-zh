<html><head></head><body>
<div><h1 class="chapterNumber">6</h1>
<h1 class="chapterTitle" id="_idParaDest-121">Building Forms with Validation</h1>
<p class="normal">In this chapter, we will learn about creating forms and validating them, which is an excellent opportunity to build our admin interface, where we can manage our blog posts and also take a look at the new enhanced form navigation. We will also build multiple reusable components and learn about some of the new functionalities in Blazor.</p>
<p class="normal">This chapter will be super fun, and we will use a lot of the things we have learned up until now.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Exploring form elements</li>
<li class="bulletList">Adding validation</li>
<li class="bulletList">Custom validation class attributes</li>
<li class="bulletList">Looking at bindings</li>
<li class="bulletList">Building an admin interface</li>
<li class="bulletList">Adding an abstraction layer</li>
</ul>
<h1 class="heading-1" id="_idParaDest-122">Technical requirements</h1>
<p class="normal">Make sure you have followed the previous chapters or use the <code class="inlineCode">Chapter05</code> folder as a starting point.</p>
<p class="normal">You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06</a>.</p>
<h1 class="heading-1" id="_idParaDest-123">Exploring form elements</h1>
<p class="normal">There are many<a id="_idIndexMarker261"/> form elements in HTML, and we can use them all in Blazor. In the end, what Blazor outputs is HTML.</p>
<p class="normal">Blazor does have components that will add to the functionality, so we can and should try to use those components instead of HTML elements. The built-in components give us great functionality for free.</p>
<p class="normal">Blazor offers the following components:</p>
<ul>
<li class="bulletList"><code class="inlineCode">EditForm</code></li>
<li class="bulletList"><code class="inlineCode">InputBase&lt;&gt;</code></li>
<li class="bulletList"><code class="inlineCode">InputCheckbox</code></li>
<li class="bulletList"><code class="inlineCode">InputDate&lt;TValue&gt;</code></li>
<li class="bulletList"><code class="inlineCode">InputNumber&lt;TValue&gt;</code></li>
<li class="bulletList"><code class="inlineCode">InputSelect&lt;TValue&gt;</code></li>
<li class="bulletList"><code class="inlineCode">InputText</code></li>
<li class="bulletList"><code class="inlineCode">InputTextArea</code></li>
<li class="bulletList"><code class="inlineCode">InputRadio</code></li>
<li class="bulletList"><code class="inlineCode">InputRadioGroup</code></li>
<li class="bulletList"><code class="inlineCode">ValidationMessage</code></li>
<li class="bulletList"><code class="inlineCode">ValidationSummary</code></li>
</ul>
<p class="normal">Let’s go through them all in the next sections.</p>
<h2 class="heading-2" id="_idParaDest-124">EditForm</h2>
<p class="normal"><code class="inlineCode">EditForm</code> renders<a id="_idIndexMarker262"/> as a <code class="inlineCode">form</code> tag, but it<a id="_idIndexMarker263"/> has a lot more functionalities.</p>
<p class="normal">First, we will not create an action or method like traditional <code class="inlineCode">form</code> tags; Blazor will handle all of that.</p>
<p class="normal"><code class="inlineCode">EditForm</code> will create an <code class="inlineCode">EditContext</code> instance as a cascading value so that all the components you put inside of <code class="inlineCode">EditForm</code> will access the same <code class="inlineCode">EditContext</code>. <code class="inlineCode">EditContext</code> tracks the metadata regarding the editing process, such as what fields have been edited, and keeps track of any validation messages.</p>
<p class="normal">You need to assign either a model (a class you wish to edit) or an <code class="inlineCode">EditContext</code> instance.</p>
<p class="normal">For most use cases, assigning a model is the way to go, but for more advanced scenarios, you might want to be able to trigger <code class="inlineCode">EditContext.Validate()</code>, for example, to validate all the controls connected to <code class="inlineCode">EditContext</code>. This is very rarely done, but it might be good to know it is possible.</p>
<p class="normal"><code class="inlineCode">EditForm</code> has the following events that you can use to handle form submissions:</p>
<ul>
<li class="bulletList"><code class="inlineCode">OnValidSubmit</code> gets triggered when the data in the form validates correctly (we will come back to validation in just a bit).</li>
<li class="bulletList"><code class="inlineCode">OnInvalidSubmit</code> gets triggered if the form does not validate correctly.</li>
<li class="bulletList"><code class="inlineCode">OnSubmit</code> gets triggered when the form is submitted, regardless of whether the form validates correctly or not. Use <code class="inlineCode">OnSubmit</code> if you want to control the validation yourself.</li>
</ul>
<p class="normal">Let’s take a look at an example.</p>
<p class="normal">Consider a class that holds a person; the class has a name and an age for that person and looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
</code></pre>
<p class="normal"><code class="inlineCode">EditForm</code> for this class would look like this (without any other elements for now):</p>
<pre class="programlisting code"><code class="hljs-code">&lt;EditForm Model="personmodel" OnValidSubmit="@validSubmit"&gt;
    ...
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/EditForm&gt;
@code {
    Person personmodel = new Person();
    private Task validSubmit()
    {
        //Do database stuff
return Task.CompletedTask;
    }
}
</code></pre>
<p class="normal"><code class="inlineCode">EditForm</code> specifies <a id="_idIndexMarker264"/>a <a id="_idIndexMarker265"/>model (in this case, <code class="inlineCode">personmodel</code>), and we are listening to the <code class="inlineCode">OnValidSubmit</code> event.</p>
<p class="normal">The <code class="inlineCode">Submit</code> button is a regular HTML button that is not a specific Blazor component.</p>
<h2 class="heading-2" id="_idParaDest-125">InputBase&lt;&gt;</h2>
<p class="normal">All the Blazor<a id="_idIndexMarker266"/> input <a id="_idIndexMarker267"/>classes derive from the <code class="inlineCode">InputBase</code> class. It has a bunch of things we can use for all of the <code class="inlineCode">input</code> components; we will go through the most important ones.</p>
<p class="normal"><code class="inlineCode">InputBase</code> handles <code class="inlineCode">AdditionalAttributes</code>, which means that if we add any other attributes to the tag, they will automatically get transferred to the output. This means that the components derived from this class can leverage any HTML attributes since they will be part of the output.</p>
<p class="normal"><code class="inlineCode">InputBase</code> has properties for <code class="inlineCode">Value</code>, which we can bind to, and an event callback for when the value changes called <code class="inlineCode">ValueChanged</code>.</p>
<p class="normal">We can also change <code class="inlineCode">DisplayName</code> so that the automated validation messages will reflect the correct name and not the property’s name, which is the default behavior.</p>
<p class="normal">Not all controls support the <code class="inlineCode">DisplayName</code> property. Some properties are only used inside the component, and we will return to those in a bit.</p>
<h2 class="heading-2" id="_idParaDest-126">InputCheckbox</h2>
<p class="normal">The <code class="inlineCode">InputCheckbox</code> component<a id="_idIndexMarker268"/> will<a id="_idIndexMarker269"/> render as <code class="inlineCode">&lt;input type="checkbox"&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-127">InputDate&lt;TValue&gt;</h2>
<p class="normal">The <code class="inlineCode">InputDate</code> component will <a id="_idIndexMarker270"/>render as <code class="inlineCode">&lt;input type="date"&gt;</code>. We can <a id="_idIndexMarker271"/>use <code class="inlineCode">DateTime, DateOnly, TimeOnly,</code> and <code class="inlineCode">DateTimeOffset</code> as values for the <code class="inlineCode">InputDate</code> component.</p>
<p class="normal">There is no way to format the date; it will use the web browser’s current setting. This behavior is by design and is part of the HTML5 spec.</p>
<h2 class="heading-2" id="_idParaDest-128">InputNumber&lt;TValue&gt;</h2>
<p class="normal">The <code class="inlineCode">InputNumber</code> component <a id="_idIndexMarker272"/>will render <a id="_idIndexMarker273"/>as <code class="inlineCode">&lt;input type="number"&gt;</code>. We can use <code class="inlineCode">Int32</code>, <code class="inlineCode">Int64</code>, <code class="inlineCode">Single</code>, <code class="inlineCode">Double</code>, and <code class="inlineCode">Decimal</code> as values for the <code class="inlineCode">InputNumber</code> component.</p>
<h2 class="heading-2" id="_idParaDest-129">InputSelect&lt;TValue&gt;</h2>
<p class="normal">The <code class="inlineCode">InputSelect</code> component will <a id="_idIndexMarker274"/>render as <code class="inlineCode">&lt;select&gt;</code>. We will create <code class="inlineCode">InputSelect</code> later in this<a id="_idIndexMarker275"/> chapter, so I won’t go into further detail here.</p>
<h2 class="heading-2" id="_idParaDest-130">InputText</h2>
<p class="normal">The <code class="inlineCode">InputText</code> component <a id="_idIndexMarker276"/>will <a id="_idIndexMarker277"/>render as <code class="inlineCode">&lt;input type="text"&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-131">InputTextArea</h2>
<p class="normal">The <code class="inlineCode">InputSelect</code> component will <a id="_idIndexMarker278"/>render as <code class="inlineCode">&lt;textarea&gt;</code>. In this chapter, we will build our<a id="_idIndexMarker279"/> own version of this control.</p>
<h2 class="heading-2" id="_idParaDest-132">InputRadio</h2>
<p class="normal">The <code class="inlineCode">InputRadio</code> component will<a id="_idIndexMarker280"/> render as <code class="inlineCode">&lt;input type="radio"&gt;</code>. Use this for individual<a id="_idIndexMarker281"/> options.</p>
<h2 class="heading-2" id="_idParaDest-133">InputRadioGroup</h2>
<p class="normal">The <code class="inlineCode">InputRadioGroup</code> component<a id="_idIndexMarker282"/> is not an element itself but rather groups other <code class="inlineCode">InputRadioInputs</code>. Use <a id="_idIndexMarker283"/>this to group options. We can add multiple <code class="inlineCode">InputRadio</code> components inside of the <code class="inlineCode">InputRadioGroup</code>.</p>
<h2 class="heading-2" id="_idParaDest-134">InputFile</h2>
<p class="normal">The <code class="inlineCode">InputFile</code> component <a id="_idIndexMarker284"/>will <a id="_idIndexMarker285"/>render as <code class="inlineCode">&lt;Input type="file"&gt;</code>. This component will make it easier to get the file data. It will supply us with a stream for each file’s content.</p>
<div><p class="normal">We can dive into <code class="inlineCode">InputFile</code> further by <a id="_idIndexMarker286"/>checking out the documentation here: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0">https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0</a>.</p>
</div>
<p class="normal">As we can see, there is a Blazor component for almost all the HTML form controls, with some added functionality such as validation, which we will see in the next section.</p>
<h1 class="heading-1" id="_idParaDest-135">Adding validation</h1>
<p class="normal">We have already touched on <a id="_idIndexMarker287"/>validation; there are some built-in functionalities in the <code class="inlineCode">input</code> components and <code class="inlineCode">EditForm</code> to handle validation.</p>
<p class="normal">One way to add validation to our form is to use <code class="inlineCode">DataAnnotations</code>. Using DataAnnotations, we don’t have to write any custom logic to ensure the data in the form is correct; instead, we can add attributes to the data model and let <code class="inlineCode">DataAnnotationsValidator</code> take care of the rest.</p>
<p class="normal">There are a bunch of <code class="inlineCode">DataAnnotations</code> instances in .NET already that we can use; we can also build our own annotations.</p>
<p class="normal">Some of the built-in data annotations are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Required</code>: This makes the field required.</li>
<li class="bulletList"><code class="inlineCode">Email</code>: This will check that the entered value is an email address.</li>
<li class="bulletList"><code class="inlineCode">MinLength</code>: This will check that the number of characters is not fewer than the value specified.</li>
<li class="bulletList"><code class="inlineCode">MaxLength</code>: This will check that the number of characters is not exceeded.</li>
<li class="bulletList"><code class="inlineCode">Range</code>: This will check that the value is within a specific range.</li>
</ul>
<p class="normal">There are many more annotations that can help us validate our data. To test this out, let’s add data annotations to our data classes:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">Data.Models</code> project, open <code class="inlineCode">Models/BlogPost.cs</code>.</li>
<li class="numberedList">At the top of the file, add a <code class="inlineCode">using</code> statement for System.ComponentModel.DataAnnotations:
        <pre class="programlisting code"><code class="hljs-code">using System.ComponentModel.DataAnnotations;
</code></pre>
</li>
<li class="numberedList">Add the <code class="inlineCode">Required</code> and <code class="inlineCode">MinLength</code> attributes to the <code class="inlineCode">Title</code> property:
        <pre class="programlisting code"><code class="hljs-code">[Required]
[MinLength(5)]
public string Title { get; set; } = string.Empty;
</code></pre>
<p class="normal">The <code class="inlineCode">Required</code> attribute will ensure we can’t leave the title empty, and <code class="inlineCode">MinLength</code> will make sure it has at least <code class="inlineCode">5</code> characters.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Add the <code class="inlineCode">Required</code> attribute to the <code class="inlineCode">Text</code> property:
        <pre class="programlisting code"><code class="hljs-code">[Required]
public string Text { get; set; } = string.Empty;
</code></pre>
<p class="normal">The <code class="inlineCode">Required</code> attribute will ensure the <code class="inlineCode">Text</code> property cannot be empty, which makes sense – why would we create an empty blog post?</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Open <code class="inlineCode">Models/Category.cs</code>, and at the top of the file, add a <code class="inlineCode">using</code> statement for <code class="inlineCode">System.ComponentModel.DataAnnotations</code>.</li>
<li class="numberedList">Add the <code class="inlineCode">Required</code> attribute to the <code class="inlineCode">Name</code> property:
        <pre class="programlisting code"><code class="hljs-code">[Required]
public string Name { get; set; } = string.Empty;
</code></pre>
<p class="normal">The <code class="inlineCode">Required</code> attribute will make sure we can’t leave the name empty.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">Open <code class="inlineCode">Models/Tag.cs</code>, and at the top of the file, add a <code class="inlineCode">using</code> statement for <code class="inlineCode">System.ComponentModel.DataAnnotations</code>.</li>
<li class="numberedList">Add the <code class="inlineCode">Required</code> attribute to the <code class="inlineCode">Name</code> property:
        <pre class="programlisting code"><code class="hljs-code">[Required]
public string Name { get; set; } = string.Empty;
</code></pre>
<p class="normal">The <code class="inlineCode">Required</code> attribute will make sure we can’t leave the name empty.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Open <code class="inlineCode">Models/Comment.cs</code>, and at the top of the file, add a <code class="inlineCode">using</code> statement for <code class="inlineCode">System.ComponentModel.DataAnnotations</code>.</li>
<li class="numberedList">Add the <code class="inlineCode">Required</code> attribute to the <code class="inlineCode">Name</code> and <code class="inlineCode">Text</code> properties:
        <pre class="programlisting code"><code class="hljs-code">[Required]
public string Text { get; set; } = string.Empty;
[Required]
public string Name { get; set; } = string.Empty;
</code></pre>
</li>
</ol>
<p class="normal">Great, now our data <a id="_idIndexMarker288"/>models have validation built into them. We need to give our users feedback on what went wrong with the validation.</p>
<p class="normal">We can do that by using the <code class="inlineCode">ValidationMessage</code> or <code class="inlineCode">ValidationSummary</code> components.</p>
<h2 class="heading-2" id="_idParaDest-136">ValidationMessage</h2>
<p class="normal">The <code class="inlineCode">ValidationMessage</code> component can <a id="_idIndexMarker289"/>show us individual error messages for a specific property. We want to use this component to show validation errors under a form element.</p>
<p class="normal">To add a <code class="inlineCode">ValidationMessage</code> component, we have to specify the <code class="inlineCode">For</code> property with the name of the property we want to show the validation errors for:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ValidationMessage For="@(() =&gt; personmodel.Name)"/&gt;
</code></pre>
<h2 class="heading-2" id="_idParaDest-137">ValidationSummary</h2>
<p class="normal">The <code class="inlineCode">ValidationSummary</code> component<a id="_idIndexMarker290"/> will show all the validation errors as a list for the entire <code class="inlineCode">EditContext</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ValidationSummary/&gt;
</code></pre>
<p class="normal">We don’t need to supply any model or property to the <code class="inlineCode">ValidationSummary</code> component since it gets access to the <code class="inlineCode">EditContext</code> using the cascading value.</p>
<p class="normal">I prefer to show the error close to the problem so the user can see where the issue is. However, we also have the option to show the validation errors as a list using <code class="inlineCode">ValidationSummary</code>.</p>
<p class="normal">To ensure our input controls match the Bootstrap theme (or whatever theme we might use), we can create our <strong class="keyWord">custom validation class</strong>.</p>
<h1 class="heading-1" id="_idParaDest-138">Custom validation class attributes</h1>
<p class="normal">By <a id="_idIndexMarker291"/>simply using the edit form, input components, and <code class="inlineCode">DataAnnotationValidator</code>, the framework will automatically add classes to the components when it is and isn’t valid.</p>
<p class="normal">By default, these classes are <code class="inlineCode">.valid</code> and <code class="inlineCode">.invalid</code>. In .NET 5, we were given a way to customize these class names ourselves.</p>
<p class="normal">When using Bootstrap, the default class names are <code class="inlineCode">.is-valid</code> and <code class="inlineCode">.is-invalid</code> , and the list of class names must also include <code class="inlineCode">.form-control</code> to get the proper styles.</p>
<p class="normal">The next component we build will help us get the proper Bootstrap styling on all our form components.</p>
<p class="normal">We will create <a id="_idIndexMarker292"/>our own <code class="inlineCode">FieldCssClassProvider</code> to customize what classes Blazor will use:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, inside the <code class="inlineCode">ResuableComponents</code> folder, add a new class called <code class="inlineCode">BootstrapFieldCssClassProvider.cs</code>.</li>
<li class="numberedList">Open the new class and add the following code:
        <pre class="programlisting code"><code class="hljs-code">using Microsoft.AspNetCore.Components.Forms;
namespace SharedComponents.ResuableComponents ;
public class BootstrapFieldCssClassProvider : FieldCssClassProvider
{
    public override string GetFieldCssClass(EditContext editContext, in FieldIdentifier fieldIdentifier)
   {
        var isValid = !editContext.GetValidationMessages(fieldIdentifier).Any();
        var isModified = editContext.IsModified(fieldIdentifier);
        return (isModified, isValid) switch
        {
            (true, true) =&gt; "form-control modified is-valid",
            (true, false) =&gt; "form-control modified is-invalid",
            (false, true) =&gt; "form-control",
            (false, false) =&gt; "form-control"
        };
    }
}
</code></pre>
<p class="normal"><code class="inlineCode">BootstrapFieldCssClassProvider</code> needs an <code class="inlineCode">EditContext</code> instance to work.</p>
<p class="normal">The code will check whether the form (or <code class="inlineCode">EditContext</code> to be specific) is valid and whether or not it has been modified. Based on that, it returns the correct CSS classes.</p>
<p class="normal">It returns the form control for all elements; that way, we don’t have to add it to every element in the form. We could validate an untouched form as valid or invalid, but we don’t want it to show that the form is OK just because it hasn’t been changed yet.</p>
<p class="normal">Without the code we are about to build, we need to get the <code class="inlineCode">EditContext</code> instance from our <code class="inlineCode">EditForm</code> and then set <code class="inlineCode">FieldCssClassProvider</code> on <code class="inlineCode">EditContext</code> as follows:</p>
<p class="normal"><code class="inlineCode">CurrentEditContext.SetFieldCssClassProvider(provider);</code></p>
<p class="normal">Next, we will do that more elegantly (in my humble opinion) with the <code class="inlineCode">CustomCssClassProvider</code> we will create next.</p>
<p class="normal">Earlier in this chapter, I mentioned that <code class="inlineCode">EditForm</code> exposes its <code class="inlineCode">EditContext</code> as <code class="inlineCode">CascadingValue</code>.</p>
<p class="normal">That means <a id="_idIndexMarker293"/>we will build a component that we can just put inside of our <code class="inlineCode">EditForm</code> and access <code class="inlineCode">EditContext</code> that way.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">In the <code class="inlineCode">SharedComponents</code> project, in the root of the project, add a new class and name it <code class="inlineCode">CustomCssClassProvider.cs</code>.</li>
<li class="numberedList">Open the new file and replace the content with the following code:
        <pre class="programlisting code"><code class="hljs-code">using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
namespace SharedComponents;
public class CustomCssClassProvider&lt;ProviderType&gt; : ComponentBase where ProviderType : FieldCssClassProvider, new()
{
    [CascadingParameter]
    EditContext? CurrentEditContext { get; set; }
    public ProviderType Provider { get; set; } = new();
    protected override void OnInitialized()
    {
        if (CurrentEditContext == null)
        {
            throw new InvalidOperationException($"{nameof(CustomCssClassProvider &lt;ProviderType&gt;)} requires a cascading parameter of type {nameof(EditContext)}. For example, you can use {nameof(CustomCssClassProvider&lt;ProviderType&gt;)} inside an EditForm.");
        }
        CurrentEditContext.SetFieldCssClassProvider
         (Provider);
    }
}
</code></pre>
</li>
</ol>
<p class="normal">This generic<a id="_idIndexMarker294"/> component takes a <code class="inlineCode">type</code> value, in this case, the type of <code class="inlineCode">Provider</code>.</p>
<p class="normal">We specified that <code class="inlineCode">type</code> must inherit from <code class="inlineCode">FieldCssClassProvider</code> and must have a constructor without parameters.</p>
<p class="normal">The component inherits from <code class="inlineCode">ComponentBase</code>, which makes it possible to place the component inside a Blazor component.</p>
<p class="normal">In this case, we are writing our component with C# only, but it is not rendering anything.</p>
<p class="normal">We have a <code class="inlineCode">Cascading</code> parameter that will be populated from <code class="inlineCode">EditForm</code>. We throw an exception if <code class="inlineCode">EditContext</code> is missing for some reason (for example, if we place the component outside of <code class="inlineCode">EditForm</code>).</p>
<p class="normal">Finally, we set <code class="inlineCode">FieldCssClassProvider</code> on <code class="inlineCode">EditContext</code>.</p>
<p class="normal">To use the component, we have to add the following code inside of <code class="inlineCode">EditForm</code> (don’t worry, we will create an <code class="inlineCode">EditForm</code> soon):</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CustomCssClassProvider ProviderType="BootstrapFieldCssClassProvider"/&gt;
</code></pre>
<p class="normal">We provide our <code class="inlineCode">CustomCssClassProvider</code> component with the right <code class="inlineCode">ProviderType</code>: <code class="inlineCode">BootstrapFieldCssClassProvider</code>.</p>
<p class="normal">This is one way of implementing components to help us encapsulate functionality. We could have written the code this way:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;EditForm Model="personmodel" @ref="CurrentEditForm"&gt;
…
&lt;/EditForm&gt;
@code {
    public EditForm CurrentEditForm { get; set; }
    protected override Task OnInitializedAsync()
    {
        CurrentEditForm.EditContext.SetFieldCssClassProvider(new BootstrapFieldCssClassProvider())
        return base.OnInitializedAsync();
    }
}
</code></pre>
<p class="normal">But with the new <code class="inlineCode">CustomCssClassProvider</code> component, we can write the same thing like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;EditForm Model="personmodel"&gt;
&lt;CustomCssClassProvider ProviderType="BootstrapFieldCssClassProvider" /&gt;
&lt;/EditForm&gt;
</code></pre>
<p class="normal">If we are doing <a id="_idIndexMarker295"/>something with <code class="inlineCode">EditContext</code>, we can always create a component like this since it is a <code class="inlineCode">cascading</code> parameter.</p>
<p class="normal">Now, we have a component that will make our form controls look like Bootstrap controls and instead of adding specific code to every component, we can now add the <code class="inlineCode">CustomCssClassProvider</code> component. Next, it’s time to put that into practice and create a couple of forms by building our admin interface.</p>
<h1 class="heading-1" id="_idParaDest-139">Looking at bindings</h1>
<p class="normal">In this chapter, we are using bindings to bind data to our form controls. We briefly discussed bindings in <em class="chapterRef">Chapter 5</em>, <em class="italic">Creating Advanced Blazor Components</em>, but it’s time to dig deeper into bindings.</p>
<h2 class="heading-2" id="_idParaDest-140">Binding to HTML elements</h2>
<p class="normal">With <a id="_idIndexMarker296"/>HTML elements, we can use <code class="inlineCode">@bind</code> to bind variables to the element. </p>
<p class="normal">So, if we are binding to a textbox, we would do it like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="Variable"/&gt;
</code></pre>
<p class="normal"><code class="inlineCode">@bind</code> and <code class="inlineCode">@bind-value</code> both work and do the same thing. Note the lower <code class="inlineCode">v</code> in value. The input element is an HTML element that will render as a normal HTML element with no extra features (except binding). Compare this to <code class="inlineCode">InputText</code>, which will work in a similar way but also give you additional features like validation and styles.</p>
<p class="normal">By default, the value in the variable will change when we leave the textbox. But we can change that behavior by adding a <code class="inlineCode">@bind:event</code> attribute like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="Variable" @bind:event="oninput"/&gt;
</code></pre>
<p class="normal">We can even take full control over what is happening by using the <code class="inlineCode">@bind:get</code> and <code class="inlineCode">@bind:set</code> attributes like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind:get="SomeText" @bind:set="SetAsync" /&gt;
</code></pre>
<p class="normal">These are doing the same thing as <code class="inlineCode">@bind</code>, so we can’t use them together with <code class="inlineCode">@bind</code>. The <code class="inlineCode">@bind:set</code> attribute has another nice feature. We can run asynchronous methods when we set a value.</p>
<p class="normal">There is also a way for us to run a method after the value is set by using <code class="inlineCode">@bind:after</code> like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="SomeText" @bind:after="AfterAsync" /&gt;
</code></pre>
<p class="normal">This gives us great flexibility when it comes to binding to HTML elements.</p>
<p class="normal">On top of that, we can also set the culture using <code class="inlineCode">@bind:culture</code>. Both date and number fields use invariant culture and will use the appropriate browser formatting, but if we use a text field, we can change the behavior like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="SomeNumber" @bind:culture="GBCulture" /&gt;
</code></pre>
<p class="normal">Where <code class="inlineCode">GBCulture</code>, in this <a id="_idIndexMarker297"/>case, is a <code class="inlineCode">CultureInfo</code> object. Lastly, we can set the format using <code class="inlineCode">@bind:format</code>. This is only implemented for <code class="inlineCode">DateTime</code> at this point:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" @bind="SomeDate" @bind:format="MM/dd/yyyy" /&gt;
&lt;input type="text" @bind="SomeDate" @bind:format="yyyy-MM-dd" /&gt;
</code></pre>
<p class="normal">We now know how we can bind to HTML elements. Next, we will take a look at binding to components.</p>
<h2 class="heading-2" id="_idParaDest-141">Binding to components</h2>
<p class="normal">When binding <a id="_idIndexMarker298"/>to components, <code class="inlineCode">Get</code>, <code class="inlineCode">Set</code>, and <code class="inlineCode">After</code> will also work. <code class="inlineCode">Culture</code>, <code class="inlineCode">Event</code>, and <code class="inlineCode">Format</code> will work on some components.</p>
<p class="normal">When binding to a component, we use <code class="inlineCode">@bind-{ParameterName}</code>, so for the parameter <code class="inlineCode">Value</code>, it would look like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;InputText @bind-Value="text" /&gt;
</code></pre>
<p class="normal">In the background, <code class="inlineCode">@bind-Value</code> will affect two other parameters, <code class="inlineCode">ValueExpression</code> and <code class="inlineCode">ValueChanged</code>. This means you will not be able to set them manually if you use <code class="inlineCode">@bind-Value</code>. When we change the value, <code class="inlineCode">ValueChanged</code> will get triggered, and we can listen to the event and make things happen when it changes.</p>
<p class="normal">We can also use <code class="inlineCode">Get</code> and <code class="inlineCode">Set</code> like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;InputText @bind-Value:get="text" @bind-Value:set="(value) =&gt; {text=value; }" /&gt;
&lt;InputText @bind-Value:get="text" @bind-Value:set="Set" /&gt;
&lt;InputText @bind-Value:get="text" @bind-Value:set="SetAsync" /&gt;
</code></pre>
<p class="normal">We must always supply both <code class="inlineCode">Get</code> and <code class="inlineCode">Set</code> and they cannot be combined with <code class="inlineCode">@bind-Value</code>. These samples use <code class="inlineCode">InputText</code>, a built-in Blazor component, but this concept works with any parameter on any component. The same thing goes for <code class="inlineCode">After</code>. It can be used with any component, like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;InputText @bind-Value="text" @bind-Value:after="() =&gt; { }" /&gt;
&lt;InputText @bind-Value="text" @bind-Value:after="After" /&gt;
&lt;InputText @bind-Value="text" @bind-Value:after="AfterAsync" /&gt;
</code></pre>
<p class="normal">We have <a id="_idIndexMarker299"/>access to some nice binding features, and they work when binding to components as well as HTML elements.</p>
<p class="normal">Next, we will build an admin interface using bindings.</p>
<h1 class="heading-1" id="_idParaDest-142">Building an admin interface</h1>
<p class="normal">Now, it’s time to build a simple<a id="_idIndexMarker300"/> admin interface for our blog.</p>
<p class="normal">We need to be able to do the following:</p>
<ul>
<li class="bulletList">List categories</li>
<li class="bulletList">Edit categories</li>
<li class="bulletList">List tags</li>
<li class="bulletList">Edit tags</li>
<li class="bulletList">List blog posts</li>
<li class="bulletList">Edit blog posts</li>
</ul>
<p class="normal">If we look at the preceding list, we might notice that some of the things seem similar – perhaps we can build shared components for those. Categories and tags are very similar; they have names, and the name is the only thing we should be able to edit.</p>
<p class="normal">Let’s make a<a id="_idIndexMarker301"/> component for that. The component is going to be responsible for listing, adding, deleting, and updating the object.</p>
<p class="normal">Since the object we are working with is either <code class="inlineCode">Category</code> or <code class="inlineCode">Tag</code>, we need to be able to call different APIs depending on the object, so our component needs to be generic:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the root of the project, add a new Razor component and call it <code class="inlineCode">ItemList.razor</code>.</li>
<li class="numberedList">Open the newly created file and at the top of the file, add:
        <pre class="programlisting code"><code class="hljs-code">@typeparam ItemType
</code></pre>
<p class="normal"><code class="inlineCode">@typeparam</code> is to make the component generic, and the variable holding the generic type is called <code class="inlineCode">ItemType</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Add a <code class="inlineCode">code</code> section (if you don’t have one already), and add the following lines of code:
        <pre class="programlisting code"><code class="hljs-code">@code{
[Parameter]
public List&lt;ItemType&gt; Items { get; set; } = new();
[Parameter, EditorRequired]
    public required RenderFragment&lt;ItemType&gt; ItemTemplate { get; set; }
}
</code></pre>
</li>
<li class="numberedList">We need two parameters: a list where we can add all the items and an <code class="inlineCode">ItemTemplate</code> instance that we can use to change how we want the items to be shown. The <code class="inlineCode">EditorRequired</code> attribute makes sure that we need to set this value when using the component. Otherwise, Visual Studio will show hostile error messages until we fix it.
    <p class="normal">In this case, we are using <code class="inlineCode">RenderFragment&lt;T&gt;</code>, which will give us access to the item inside the template (things will become clearer as soon as we implement it).</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">We also need a couple of events; add the following code to the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">[Parameter]
public EventCallback&lt;ItemType&gt; DeleteEvent { get; set; }
[Parameter]
public EventCallback&lt;ItemType&gt; SelectEvent { get; set; }
</code></pre>
<p class="normal">We added two events; the first is when we delete a tag or a category. We will send an event to the parent component where we can add the code needed to delete the item.</p>
<p class="normal">The second one is when we select an item so that we can edit the item.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Now, it’s time<a id="_idIndexMarker302"/> to add the UI; replace the top of the file below the <code class="inlineCode">@typeparam</code> to the code tag with:
        <pre class="programlisting code"><code class="hljs-code">@using System.Collections.Generic
&lt;h3&gt;List&lt;/h3&gt;
&lt;table&gt;
&lt;Virtualize Items="@Items" Context="item"&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;button class="btn btn-primary" @onclick="@(()=&gt; {SelectEvent.InvokeAsync(item); })"&gt; Select&lt;/button&gt;
&lt;/td&gt;
&lt;td&gt;@ItemTemplate(item)&lt;/td&gt;
&lt;td&gt;
&lt;button class="btn btn-danger" @onclick="@(()=&gt; {DeleteEvent.InvokeAsync(item);})"&gt; Delete&lt;/button&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/Virtualize&gt;
&lt;/table&gt;
</code></pre>
</li>
</ol>
<p class="normal">If we look back to <em class="italic">Step 3</em>, we’ll notice that we used the variable for the lists and <code class="inlineCode">RenderFragment</code>.</p>
<p class="normal">Then, we use the new <code class="inlineCode">Virtualize</code> component to list our items; to be fair, we might not have that many categories or tags, but why not use it when we can? We set the <code class="inlineCode">Items</code> property to <code class="inlineCode">"Items"</code> (which is the name of our list) and the <code class="inlineCode">Context</code> parameter to <code class="inlineCode">"item"</code>.</p>
<p class="normal">We can give it whatever name we want; we’re only going to use it inside of the <code class="inlineCode">Virtualize</code> render template.</p>
<p class="normal">We added two buttons that simply invoke the <code class="inlineCode">EventCallback</code> instance we added in <em class="italic">Step 4</em>. Between those buttons, we added <code class="inlineCode">@ItemTemplate(item)</code>; we want Blazor to render the template, but<a id="_idIndexMarker303"/> we also send the current item in the loop.</p>
<p class="normal">That means we have access to the item’s value inside our template.</p>
<h2 class="heading-2" id="_idParaDest-143">Listing and editing categories</h2>
<p class="normal">With our new <a id="_idIndexMarker304"/>component, it’s now time to create a component for listing and editing our categories:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">_Imports.razor</code>. Make sure the following namespaces are included: <code class="inlineCode">@using SharedComponents</code> and <code class="inlineCode">@using Microsoft.AspNetCore.Components.Forms</code>.</li>
<li class="numberedList">Right-click on the <code class="inlineCode">Pages</code> folder, select <strong class="screenText">Add</strong> | <strong class="screenText">New folder</strong>, and name the folder <code class="inlineCode">Admin</code>.</li>
<li class="numberedList">In the <code class="inlineCode">Pages/Admin</code> folder, add a new Razor component and name it <code class="inlineCode">CategoryList.razor</code>.</li>
<li class="numberedList">At the top of the component, replace <code class="inlineCode">&lt;h3&gt;CategoryList&lt;/h3&gt;</code> with the following code:
        <pre class="programlisting code"><code class="hljs-code">@page "/admin/categories"
@rendermode InteractiveServer @using SharedComponents.ReusableComponents @inject IBlogApi _api &lt;h3&gt;Categories&lt;/h3&gt;
</code></pre>
<p class="normal">We started with the <code class="inlineCode">@page</code> directive, telling Blazor that if we navigate to the <code class="inlineCode">"</code><code class="inlineCode">admin/categories"</code> URL, we will get to the <code class="inlineCode">CategoryList.Razor</code> component. This component has some interactivity, so we need to set what interactivity mode we wish to use. In this case, we are using <code class="inlineCode">InteractiveServer</code>. If we want to use <code class="inlineCode">InteractiveAuto</code> or <code class="inlineCode">InteractiveWebAssembly</code>, we need to put the component in the <code class="inlineCode">BlazorWebApp.Client</code> project. We will add a <code class="inlineCode">using</code> statement and then inject our API.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">The next step is to add a form to edit the categories. Add the following code under the code from the previous step:
        <pre class="programlisting code"><code class="hljs-code">&lt;EditForm OnValidSubmit="Save" Model="Item"&gt;
&lt;DataAnnotationsValidator /&gt;
&lt;CustomCssClassProvider ProviderType="BootstrapFieldCssClassProvider" /&gt;
&lt;InputText @bind-Value="@Item.Name" /&gt;
&lt;ValidationMessage For="@(()=&gt;Item.Name)" /&gt;
    &lt;button class="btn btn-success" type="submit"&gt;Save&lt;/button&gt;
&lt;/EditForm&gt;
</code></pre>
<p class="normal">We added <code class="inlineCode">EditForm</code>, which will execute the <code class="inlineCode">Save</code> method if the form validates OK. For validation, we added <code class="inlineCode">DataAnnotationsValidator</code>, which will validate the supplied data against the annotations we added to the <code class="inlineCode">Tag</code> and <code class="inlineCode">Category</code> classes.</p>
<p class="normal">Since we are using Bootstrap, we want our form controls to look the same, so we added <code class="inlineCode">CustomCssClassProvider</code>, which we created earlier in this chapter.</p>
<p class="normal">We added <code class="inlineCode">InputText</code> and connected it to a <code class="inlineCode">Category</code> object called <code class="inlineCode">Item</code> (which we will add in just a second).</p>
<p class="normal">Below that, we added <code class="inlineCode">ValidationMessage</code>, which will show any errors for the <code class="inlineCode">name</code> property, and then a <strong class="screenText">Submit</strong> button.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Now, it’s time <a id="_idIndexMarker305"/>to add our <code class="inlineCode">ItemList</code> component; under the code we added in the previous step, add this code:
        <pre class="programlisting code"><code class="hljs-code">&lt;ItemList Items="Items" DeleteEvent="@Delete" SelectEvent="@Select" ItemType="Category"&gt;
&lt;ItemTemplate&gt;
        @{
            var item = context as Category;
            if (item != null)
            {
                @item.Name
            }
        }
    &lt;/ItemTemplate&gt;
&lt;/ItemList&gt;
</code></pre>
<p class="normal">We add our component and we bind the <code class="inlineCode">Items</code> property to a list of items (we will create that list in the next step).</p>
<p class="normal">We bind the <code class="inlineCode">Select</code> and <code class="inlineCode">Delete</code> events to methods and we specify the type of the list in the <code class="inlineCode">ItemType</code> property. Then, we have <code class="inlineCode">ItemTemplate</code>. Since we are using <code class="inlineCode">RenderFragment&lt;T&gt;</code>, we now have access to a variable called <code class="inlineCode">context</code>.</p>
<p class="normal">We convert that variable to a category and print out the name of the category. This is the template for each item that will be shown on the list.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">Finally, we add<a id="_idIndexMarker306"/> the following code to replace the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">@code {
    private List&lt;Category&gt; Items { get; set; } = new();
    public Category Item { get; set; } = new();
    protected async override Task OnInitializedAsync()
    {
        Items = (await _api.GetCategoriesAsync()) ?? new();
        await base.OnInitializedAsync();
    }
    private async Task Delete(Category category)
    {
        try
        {
            await _api.DeleteCategoryAsync(category.Id!);
            Items.Remove(category);
        }
        catch { }
    }
    private async Task Save()
    {
        try
        {
            await _api.SaveCategoryAsync(Item);
            if (!Items.Contains(Item))
            {
                Items.Add(Item);
            }
            Item = new Category();
        }
        catch { }
    }
    private Task Select(Category category)
    {
        try
        {
            Item = category;
        }
        catch { }
        return Task.CompletedTask;
    }
}
</code></pre>
<p class="normal">We added a list to hold all our categories and a variable that holds one item (the item currently being edited). We use <code class="inlineCode">OnInitializedAsync</code> to load all the categories from the API.</p>
<p class="normal">The <code class="inlineCode">Delete</code> and <code class="inlineCode">Save</code> methods call the API’s corresponding method, and the <code class="inlineCode">Select</code> method takes the provided item and puts it into the item variable (ready to be edited).</p>
<p class="normal">We check whether we already have the item in the list before we add it to the list. Run the project and navigate to <code class="inlineCode">/admin/categories</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">Try to add, edit, or delete <a id="_idIndexMarker307"/>a category, as shown in <em class="italic">Figure 6.1</em>:</li>
</ol>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" src="img/B21849_06_01.png"/></figure>
<p class="packt_figref">Figure 6.1: The Edit category view</p>
<p class="normal">Now, we need a component for listing and editing tags as well – it is pretty much the same thing, but we need to use <code class="inlineCode">Tag</code> instead of <code class="inlineCode">Category</code>.</p>
<h2 class="heading-2" id="_idParaDest-144">Listing and editing tags</h2>
<p class="normal">We just created a <a id="_idIndexMarker308"/>component for listing and editing categories; now, we need to create a component to list and edit tags:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp.Client</code> project, in the <code class="inlineCode">Pages</code><strong class="keyWord"> </strong>folder, add a new folder called<strong class="keyWord"> </strong><code class="inlineCode">Admin</code>.</li>
<li class="numberedList">Add a new Razor component called <code class="inlineCode">TagList.razor</code>.</li>
<li class="numberedList">At the top of the component, replace <code class="inlineCode">&lt;h3&gt;TagList&lt;/h3&gt;</code> with the following code:
        <pre class="programlisting code"><code class="hljs-code">@page "/admin/tags"
@rendermode InteractiveServer
@using Data.Models
@using Data.Models.Interfaces
@using SharedComponents
@using SharedComponents.ReusableComponents
@inject IBlogApi _api &lt;h3&gt;Tags&lt;/h3&gt;
</code></pre>
<p class="normal">We started with the <code class="inlineCode">@page</code> directive telling Blazor that if we navigate to the <code class="inlineCode">"admin/tags"</code> URL, we will get to the <code class="inlineCode">TagList.Razor</code> component. We also specify the render mode as <code class="inlineCode">InteractiveServer</code>. We add a <code class="inlineCode">using</code> statement and then inject our API.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">The next step is to add a form to edit the tags. Add the following code under the code from the previous step:
        <pre class="programlisting code"><code class="hljs-code">&lt;EditForm OnValidSubmit="Save" Model="Item"&gt;
&lt;DataAnnotationsValidator /&gt;
&lt;CustomCssClassProvider
 ProviderType="BootstrapFieldCssClassProvider" /&gt;
&lt;InputText @bind-Value="@Item.Name" /&gt;
&lt;ValidationMessage For="@(()=&gt;Item.Name)" /&gt;
&lt;button class="btn btn-success" type="submit"&gt;Save&lt;/button&gt;
&lt;/EditForm&gt;
</code></pre>
<p class="normal">We added <code class="inlineCode">EditForm</code>, which will execute the <code class="inlineCode">Save</code> method if the form validates without a problem. For validation, we added <code class="inlineCode">DataAnnotationsValidator</code>, which will validate the supplied data against the annotations we added to the <code class="inlineCode">Tag</code> and <code class="inlineCode">Category</code> classes.</p>
<p class="normal">Since we are using Bootstrap, we want our form controls to look the same, so we added <code class="inlineCode">CustomCssClassProvider</code>, which we created earlier in this chapter.</p>
<p class="normal">We added <code class="inlineCode">InputText</code> and connected it to a <code class="inlineCode">Tag</code> object called <code class="inlineCode">Item</code> (which we will add in a moment).</p>
<p class="normal">Below it, we add a <code class="inlineCode">ValidationMessage</code> instance that will show any errors for the <code class="inlineCode">name</code> property and then a <strong class="screenText">Submit</strong> button.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Now, it’s<a id="_idIndexMarker309"/> time to add our <code class="inlineCode">ItemList</code> component. Under the code we added in the previous step, add this code:
        <pre class="programlisting code"><code class="hljs-code">&lt;ItemList Items="Items" DeleteEvent="@Delete" SelectEvent="@Select" ItemType="Tag"&gt;
&lt;ItemTemplate&gt;
        @{
            var item = context as Tag;
            if (item != null)
            {
                @item.Name
            }
        }
    &lt;/ItemTemplate&gt;
&lt;/ItemList&gt;
</code></pre>
<p class="normal">We added our component and bound the <code class="inlineCode">Items</code> property to a list of items (we will create that list in the next step). We bind the <code class="inlineCode">Select</code> and <code class="inlineCode">Delete</code> events to methods and specify the <code class="inlineCode">List</code> type in the <code class="inlineCode">ItemType</code> property.</p>
<p class="normal">Then we have <code class="inlineCode">ItemTemplate</code>; since we are using <code class="inlineCode">RenderFragment&lt;T&gt;</code>, we now have access to a variable called <code class="inlineCode">context</code>. We convert that variable to a tag and print out the tag’s name.</p>
<p class="normal">This is the template for each item shown in the list.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Finally, we replace the code section with the following code:
        <pre class="programlisting code"><code class="hljs-code">@code {
    private List&lt;Tag&gt; Items { get; set; } = new List&lt;Tag&gt;();
    public Tag Item { get; set; } = new Tag();
    protected async override Task OnInitializedAsync()
    {
        Items = (await _api.GetTagsAsync())??new();
        await base.OnInitializedAsync();
    }
    private async Task Delete(Tag tag)
    {
        try
        {
            await _api.DeleteTagAsync(tag.Id!);
            Items.Remove(tag);
        }
        catch { }
    }
    private async Task Save()
    {
        try
        {
            await _api.SaveTagAsync(Item);
            if (!Items.Contains(Item))
            {
                Items.Add(Item);
            }
            Item = new Tag();
        }
        catch { }
    }
    private Task Select(Tag tag)
    {
        try
        {
            Item = tag;
        }
        catch { }
        return Task.CompletedTask;
    }
}
</code></pre>
<p class="normal">We added a<a id="_idIndexMarker310"/> list to hold all our tags and a variable that holds one item (the item currently being edited). We use <code class="inlineCode">OnInitializedAsync</code> to load all the tags from the API.</p>
<p class="normal">The <code class="inlineCode">Delete</code> and <code class="inlineCode">Save</code> methods call the API’s corresponding method and the <code class="inlineCode">Select</code> method takes the provided item and puts it into the <code class="inlineCode">Item</code> variable (ready to be edited).</p>
<p class="normal">We check whether we already have the item in the list before we add it to the list.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">Run the <a id="_idIndexMarker311"/>project and navigate to <code class="inlineCode">/admin/tags</code>.</li>
<li class="numberedList">Try to add, edit, and delete a tag, as shown in <em class="italic">Figure 6.2</em>:</li>
</ol>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" src="img/B21849_06_02.png"/></figure>
<p class="packt_figref">Figure 6.2: The Edit tag view</p>
<p class="normal">Now, we need ways to list and edit blog posts.</p>
<h2 class="heading-2" id="_idParaDest-145">Listing and editing blog posts</h2>
<p class="normal">Let’s start with<a id="_idIndexMarker312"/> listing and editing blog posts:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">Pages/Admin</code> folder, add a new Razor component <a id="_idIndexMarker313"/>called <code class="inlineCode">BlogPostList.razor</code>.</li>
<li class="numberedList">At the top of the <code class="inlineCode">BlogPostList.razor</code> file, replace <code class="inlineCode">&lt;h3&gt;BlogPostList&lt;/h3&gt;</code> with the following code:
        <pre class="programlisting code"><code class="hljs-code">@page "/admin/blogposts"
@attribute [StreamRendering(true)]
@inject IBlogApi _api
&lt;a href="/admin/blogposts/new"&gt;New blog post&lt;/a&gt;
@if (posts?.Count == 0)
{
    &lt;p&gt;No blog posts found&lt;/p&gt;
}
else if (posts == null)
{
    &lt;p&gt;Loading...&lt;/p&gt;
}
else
{
    &lt;ul&gt;
        @foreach (var p in posts)
        {
            &lt;li&gt;
                @p.PublishDate
                &lt;a href="/admin/blogposts/@p.Id"&gt;@p.Title&lt;/a&gt;
&lt;/li&gt;
        }
    &lt;/ul&gt;
}
</code></pre>
<p class="normal">We added a <code class="inlineCode">page</code> directive, injected our API, and listed the blog posts using a <code class="inlineCode">foreach</code> loop. We also enabled <code class="inlineCode">StreamingRendering</code>, because this page doesn’t have any interactivity, so there is no need to add that. This also means we can’t use the <code class="inlineCode">Virtualize</code> component since it is interactive.</p>
<p class="normal">We also linked the posts to a URL with the <code class="inlineCode">Id</code> instance of the blog.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Add the following code in the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">private List&lt;BlogPost&gt;? posts = null;
protected override async Task OnInitializedAsync()
{
    await Task.Delay(1000);
    var numberofposts = await _api.GetBlogPostCountAsync();
    posts = await _api.GetBlogPostsAsync(numberofposts, 0);
    await base.OnInitializedAsync();
}
</code></pre>
<p class="normal">We added the functionality to load posts from the database and a small delay so that we can see <strong class="screenText">Loading…</strong> for just a brief moment. Now, there is only one thing left in the section: adding a page where we can edit the blog post.</p>
<p class="normal">A very popular <a id="_idIndexMarker314"/>way of writing blog posts is using Markdown; our blog engine will support that. Since Blazor supports any .NET standard <strong class="keyWord">dynamic link library</strong> (<strong class="keyWord">DLL</strong>), we will add an existing library called <code class="inlineCode">Markdig</code>.</p>
<p class="normal">This is the same engine that Microsoft uses for their <code class="inlineCode">docs</code> site.</p>
<p class="normal">We can extend <code class="inlineCode">Markdig</code> with different extensions (as Microsoft has done), but let’s keep this simple and only add support for Markdown without all the fancy extensions.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Under the <code class="inlineCode">SharedComponents</code> project, right-click on the <strong class="screenText">Dependencies</strong> node in Solution Explorer and select <strong class="screenText">Manage NuGet Packages</strong>.</li>
<li class="numberedList">Search for <code class="inlineCode">Markdig</code> and click <strong class="screenText">Install</strong>.</li>
<li class="numberedList">Add a new class in the root of the project called <code class="inlineCode">InputTextAreaOnInput.cs</code>.</li>
<li class="numberedList">Open the new file and replace its contents with the following code:
        <pre class="programlisting code"><code class="hljs-code">using System.Diagnostics.CodeAnalysis;
using Microsoft.AspNetCore.Components.Rendering;
namespace Microsoft.AspNetCore.Components.Forms;
    public class InputTextAreaOnInput :
     InputBase&lt;string?&gt;
    {
        protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            builder.OpenElement(0, "textarea");
            builder.AddMultipleAttributes(1, AdditionalAttributes);
            builder.AddAttribute(2, "class", CssClass);
            builder.AddAttribute(3, "value", BindConverter.FormatValue(CurrentValue));
            builder.AddAttribute(4, "oninput", EventCallback.Factory.CreateBinder &lt;string?&gt;(this, __value =&gt; CurrentValueAsString = __value, CurrentValueAsString));
            builder.CloseElement();
        }
        protected override bool TryParseValueFromString(string? value, out string? result, [NotNullWhen(false)] out string? validationErrorMessage)
        {
            result = value;
            validationErrorMessage = null;
            return true;
        }
    }
</code></pre>
<p class="normal">The preceding code is taken from Microsoft’s GitHub repository; it is how they implement the <code class="inlineCode">InputTextArea</code> component.</p>
<p class="normal">In their build system, they can’t handle <code class="inlineCode">.razor</code> files, so that’s why they implement the code this way. I made one change in Microsoft’s code, and that is <code class="inlineCode">oninput</code>, which used to say <code class="inlineCode">OnChange</code>.</p>
<p class="normal">For most cases, <code class="inlineCode">OnChange</code> will be just fine, which means when I leave the textbox, the value will be updated (and trigger validations). But in our case, we want the preview of the HTML to be updated in real time, which is why we had to implement our own.</p>
<p class="normal">One option<a id="_idIndexMarker315"/> could have been not to use the <code class="inlineCode">InputTextArea</code> component and instead use the <code class="inlineCode">TextArea</code> tag, but we would lose the validation highlighting. This is the way to go if we ever need to customize the behavior on an input control.</p>
<p class="normal">I recommend using <code class="inlineCode">.razor</code> files over <code class="inlineCode">.cs</code> files if you make many changes to the implementation.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">In the <code class="inlineCode">Pages/Admin</code> folder, add a new Razor component called <code class="inlineCode">BlogPostEdit.razor</code>.</li>
<li class="numberedList">At the top of the <code class="inlineCode">BlogPostEdit.razor</code> file, replace <code class="inlineCode">&lt;h3&gt;BlogPostEdit&lt;/h3&gt;</code> with the following code:
        <pre class="programlisting code"><code class="hljs-code">@page "/admin/blogposts/new"
@page "/admin/blogposts/{Id}"
@rendermode InteractiveServer
@inject IBlogApi _api
@inject NavigationManager _manager
@using Markdig; @using Microsoft.AspNetCore.Components.Forms
</code></pre>
<p class="normal">We add two different <code class="inlineCode">page</code> directives because we want to be able to create a new blog post as well as supply an ID to edit an already existing one. If we do not supply an ID, the <code class="inlineCode">Id</code> parameter will be null (or the default).</p>
<p class="normal">We inject our API and <code class="inlineCode">NavigationManager</code> as well as adding <code class="inlineCode">using</code> statements.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">We also need<a id="_idIndexMarker316"/> some variables. Add the following code in the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">[Parameter]
public string? Id { get; set; }
BlogPost Post { get; set; } = new();
List&lt;Category&gt; Categories { get; set; }=new();
List&lt;Tag&gt; Tags { get; set; }= new();
string? selectedCategory = null;
string? markDownAsHTML { get; set; }
</code></pre>
<p class="normal">We added a parameter for the blog post ID (if we want to edit one), a variable to hold the post we are editing, one to hold all the categories, and one to hold all the tags. We also added a variable to hold the currently selected category and one to hold the Markdown converted to HTML.</p>
<p class="normal">Now, we need to add the form; add the following code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;EditForm Model="Post" OnValidSubmit="SavePost"&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;CustomCssClassProvider ProviderType="BootstrapFieldCssClassProvider" /&gt;
    &lt;InputText @bind-Value="Post.Title"/&gt;
    &lt;ValidationMessage For="()=&gt;Post.Title"/&gt;
    &lt;InputDate @bind-Value="Post.PublishDate"/&gt;
    &lt;ValidationMessage For="()=&gt;Post.PublishDate"/&gt;
    &lt;InputSelect @bind-Value="selectedCategory"&gt;
        &lt;option value="0" disabled&gt;None selected&lt;/option&gt;
        @foreach (var category in Categories)
        {
            &lt;option value="@category.Id"&gt;@category.Name &lt;/option&gt;
        }
    &lt;/InputSelect&gt;
    &lt;ul&gt;
        @foreach (var tag in Tags)
        {
        &lt;li&gt;
            @tag.Name
            @if (Post.Tags.Any(t =&gt; t.Id == tag.Id))
            {
                &lt;button type="button" @onclick="@(() =&gt; {Post.Tags.Remove(Post.Tags.Single(t=&gt;t.Id==tag.Id)); })"&gt;Remove&lt;/button&gt;
            }
            else
            {
                &lt;button type="button" @onclick="@(()=&gt; { Post.Tags.Add(tag); })"&gt;Add&lt;/button&gt;
            }
        &lt;/li&gt;
        }
    &lt;/ul&gt;
        &lt;InputTextAreaOnInput @bind-Value="Post.Text" @onkeyup="UpdateHTML"/&gt;
        &lt;ValidationMessage For="()=&gt;Post.Text"/&gt;
        &lt;button type="submit" class="btn btn-success"&gt;Save&lt;/button&gt;
    &lt;/EditForm&gt;
</code></pre>
<p class="normal">We add <a id="_idIndexMarker317"/>an <code class="inlineCode">EditForm</code>, and when we submit the form (if it is valid), we execute the <code class="inlineCode">SavePost</code> method. We add <code class="inlineCode">DataAnnotationValidator</code>, which will validate our model against the data annotations in the class.</p>
<p class="normal">We add <code class="inlineCode">CustomCssClassProvider</code> so that we get the correct Bootstrap class names. Then, we add components for the title, publish date, category, tags, and, last but not least, the text (the blog post’s content).</p>
<p class="normal">Finally, we add the text using the component we created in <em class="italic">Step 4</em> (the component that updates for each keystroke).</p>
<p class="normal">We also hook up the <code class="inlineCode">@onkeyup</code> event to update the preview for each keystroke.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="11">We also need to add our <code class="inlineCode">SavePost</code> method. Add the following code in the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">public async Task SavePost()
{
    if (!string.IsNullOrEmpty(selectedCategory) &amp;&amp; Categories != null)
    {
        var category = Categories.FirstOrDefault(c =&gt;c.Id == selectedCategory);
        if (category != null)
        {
            Post.Category = category;
        }
    }
    await _api.SaveBlogPostAsync(Post);
    _manager.NavigateTo("/admin/blogposts");
}
</code></pre>
</li>
<li class="numberedList">Now, it’s time<a id="_idIndexMarker318"/> to show the preview. Add the following code just below the <code class="inlineCode">EditForm</code> close tag:
        <pre class="programlisting code"><code class="hljs-code">@((MarkupString)markDownAsHTML)
</code></pre>
<p class="normal">We use <code class="inlineCode">MarkupString</code> to make sure Blazor outputs the HTML code without escaping the characters. You might remember that from <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="13">Now, it is time to set up <code class="inlineCode">Markdig</code>. Add the following code somewhere in the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">MarkdownPipeline pipeline = default!;
protected override Task OnInitializedAsync()
{
    pipeline = new MarkdownPipelineBuilder()
             .UseEmojiAndSmiley()
             .Build();
    return base.OnInitializedAsync();
}
</code></pre>
<p class="normal">To configure <code class="inlineCode">Markdig</code>, we need to create a pipeline. As I mentioned earlier in the chapter, this is the engine Microsoft uses for their documentation site. It has many extensions available, including source code highlighting and emoticons.</p>
<p class="normal">We also added emoticons to the pipeline to make it a little more fun.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="14">We must also <a id="_idIndexMarker319"/>add code to load the data (<code class="inlineCode">blog</code> <code class="inlineCode">posts</code>, <code class="inlineCode">categories</code>, and <code class="inlineCode">tags</code>). Add the following methods in the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">protected void UpdateHTML()
{
    markDownAsHTML = Markdig.Markdown.ToHtml(Post.Text, pipeline);
}
 protected override async Task OnParametersSetAsync()
    {
        if (Id != null)
        {
            var p = await _api.GetBlogPostAsync(Id);
            if (p != null)
            {
                Post = p;
                if (Post.Category != null)
                {
                    selectedCategory = Post.Category.Id;
                }
                UpdateHTML();
            }
        }
        Categories = (await _api.GetCategoriesAsync());
        Tags = (await _api.GetTagsAsync());
        base.OnParametersSet();
    }
</code></pre>
<p class="normal">Now, run the site, navigate to <code class="inlineCode">/admin/blogposts</code>, click on a blog post to edit it, and test the new Markdown support. <em class="italic">Figure 6.3</em> shows the <strong class="screenText">Edit</strong> page with Markdown support:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" src="img/B21849_06_03.png"/></figure>
<p class="packt_figref">Figure 6.3: The Edit page with Markdown support</p>
<p class="normal">We still have <a id="_idIndexMarker320"/>one more thing to do: we need to ensure that the blog post page shows a converted HTML version of the Markdown.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="15">Open <code class="inlineCode">/Pages/Post.razor</code> and add the following <code class="inlineCode">using</code> statement at the top of the file:
        <pre class="programlisting code"><code class="hljs-code">@using Markdig;
</code></pre>
</li>
<li class="numberedList">Add the following code to the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">MarkdownPipeline pipeline;
protected override Task OnInitializedAsync()
{
    pipeline = new MarkdownPipelineBuilder()
             .UseEmojiAndSmiley()
             .Build();
    return base.OnInitializedAsync();
}
</code></pre>
</li>
<li class="numberedList">Replace the following row:
        <pre class="programlisting code"><code class="hljs-code">@((MarkupString)BlogPost.Text)
</code></pre>
<p class="normal">Replace the preceding row with this:</p>
<pre class="programlisting code"><code class="hljs-code">@((MarkupString)Markdig.Markdown.ToHtml(BlogPost.Text, pipeline))
</code></pre>
</li>
</ol>
<p class="normal">Great job! Now, we have <a id="_idIndexMarker321"/>an admin interface up and running so that we can start writing blog posts.</p>
<p class="normal">Looking at the code we wrote, no textbox has a label; what we can do is add a label in all the places we are using a textbox. Some component vendors have a label built into their components. I prefer doing that myself. Add an abstraction layer on top of any built-in components or third-party components. </p>
<h2 class="heading-2" id="_idParaDest-146">Adding an abstraction layer</h2>
<p class="normal">This has saved us more times than I can count. Adding an abstraction layer does take some time and effort, but I promise you, you will get that time back. So, why should we do this? Well, for several reasons: if we are using Bootstrap, for example, and we want to upgrade Bootstrap to the latest version, there might be classes that have changed. By using components, it’s easy to only change those components. It also makes it easier to change component vendors in the future if you have your own components encapsulating the third-party components. But the real reason is that if we add a layer, we can set the team’s programming style/language. </p>
<p class="normal">Everything we build will have the same default values, the same access to properties, and the same UX. We can add functionality, but in most cases, it is more important to limit the functionality.</p>
<p class="normal">A third-party component has a lot of functionality; it should cater to many different use cases. But they also mean that your team now has access to many different functionalities that can make the UX different for each developer that implements the functionality.</p>
<p class="normal">Let’s add a couple of shared components to the project.</p>
<p class="normal">The first one is a textbox with a label and validation message built in.</p>
<p class="normal">If we take a look at our <code class="inlineCode">CategoryList</code> component, the code looks like this:</p>
<pre class="programlisting code"><code class="hljs-code"> &lt;InputText @bind-Value="@Item.Name" /&gt;
&lt;ValidationMessage For="@(()=&gt;Item.Name)" /&gt;
</code></pre>
<p class="normal">A label using Bootstrap looks something like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;label for="validationCustomCategoryName" class="form-label"&gt;Category name&lt;/label&gt;
&lt;div class="input-group has-validation"&gt;
&lt;input type="text" class="form-control" id="validationCustomCategoryName"&gt;
&lt;div class="invalid-feedback"&gt;
        Please choose a category name.
      &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">Let’s see if we can combine these; some features are already built in. Since we only add a layer, we don’t have to handle as much functionality. We rather need to send the parent component values to the encapsulated component. Let’s look at some code to see what’s <a id="_idIndexMarker322"/>going on:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponent</code> project, in the <code class="inlineCode">ResusableComponents</code> folder, add a new Razor component and call it <code class="inlineCode">BlogInputText.razor</code>.</li>
<li class="numberedList">In the <code class="inlineCode">code</code> section, add the following code:
        <pre class="programlisting code"><code class="hljs-code">  [Parameter]
  public string Id { get; set; } = Guid.NewGuid().ToString();
  [Parameter]
  public string? Label { get; set; }
  [CascadingParameter]
  public required EditContext CurrentEditContext { get; set; }
  [Parameter]
  public required string Value { get; set; }
  [Parameter]
  public EventCallback&lt;string&gt; ValueChanged { get; set; }
  [Parameter]
  public required Expression&lt;Func&lt;string&gt;&gt; ValueExpression { get; set; }
</code></pre>
</li>
<li class="numberedList">Let’s take a look at what is going on. First, we add a parameter so that we have an ID that we can use for the <code class="inlineCode">label</code> tag in the next step. We add a string that can contain text for our label, id we do have some text, we render the label. If it is <code class="inlineCode">null</code>, we don’t render the label. I prefer not to have a “<code class="inlineCode">ShowLabel</code>" property. If there is a text, it should show the label. We also have the current edit context, which we will use to send to the next level of components.</li>
<li class="numberedList">In our form we have an <code class="inlineCode">EditForm</code>; the <code class="inlineCode">EditForm</code> will send the <code class="inlineCode">EditContext</code> to all the child components and will keep track of the state of the form. We want to grab that edit context and send that to all the components inside of this component as well.</li>
<li class="numberedList">Then, we have the trio of value parameters, <code class="inlineCode">Value</code>, <code class="inlineCode">ValueChanged</code>, and <code class="inlineCode">ValueExpression</code>.</li>
<li class="numberedList">In the non-code<a id="_idIndexMarker323"/> part of the page, add the following (replacing the three tags):
        <pre class="programlisting code"><code class="hljs-code">@using System.Linq.Expressions
&lt;CascadingValue Value="CurrentEditContext"&gt;
    @if(Label!=null)
    {
        &lt;label for="@Id" class="form-label"&gt;@Label&lt;/label&gt;
    }
    &lt;InputText id="@Id" Value="@Value" ValueChanged="ValueChanged" ValueExpression="ValueExpression" /&gt;
&lt;ValidationMessage For="@ValueExpression" /&gt;
&lt;/CascadingValue&gt;
</code></pre>
</li>
<li class="numberedList">First, we grab the <code class="inlineCode">CurrentEditContext</code> and send that to a child component; this way, all the children will have the same edit context as the parent <code class="inlineCode">EditForm</code>. If we have any text in the <code class="inlineCode">Label</code> parameter, we should show the label. Then we add the <code class="inlineCode">InputText</code>, the built-in component. If we would like to do this with a third-party library, we would do it in a similar way. Next is where things get a bit more complicated; we could have simply said <code class="inlineCode">@bind-Value</code>, which would notify Blazor that a change has happened, but it would notify the <code class="inlineCode">EditContext</code> that the <code class="inlineCode">Value</code> parameter of our component has been changed, not the model. 
    <p class="numberedList">So, instead of doing that, we set the <code class="inlineCode">Value</code> parameter and the <code class="inlineCode">ValueChanged</code> parameter to the parameters that we send to the component. This way, the notification of the value changed will directly notify that the model has been changed. The <code class="inlineCode">ValueExpression</code> will make sure that the <code class="inlineCode">EditContext</code> gets notified of the change and will show the corresponding validation message. To be honest, in this example, it doesn’t really matter, but if we were using a third-party component with validation built in, it might not work (depending on how they build the component). So, using this method should always work.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">Then, we have the <code class="inlineCode">ValidationMessage</code>, which shows any error in the model, and we are using the same <code class="inlineCode">ValueExpression</code> here.</li>
<li class="numberedList">Now, we need to use this component. Let’s change the <code class="inlineCode">Taglist</code> first. In the <code class="inlineCode">BlazorWebApp.Client</code> project, in the <code class="inlineCode">Pages/Admin</code> folder, open <code class="inlineCode">Taglist.razor</code>.</li>
<li class="numberedList">Right now, we have the following code:
        <pre class="programlisting code"><code class="hljs-code">&lt;InputText @bind-Value="@Item.Name" /&gt;
&lt;ValidationMessage For="@(()=&gt;Item.Name)" /&gt;
</code></pre>
<p class="normal">Replace this code with the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;BlogInputText @bind-Value="@Item.Name" Label="Name" /&gt;
</code></pre>
<p class="normal">Now, isn’t that kind of elegant?</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="11">Let’s do the same with the <code class="inlineCode">CategoryList</code>. In the <code class="inlineCode">SharedComponent</code> project, in the <code class="inlineCode">Pages/Admin</code> folder, open <code class="inlineCode">CategoryList.razor</code>.</li>
<li class="numberedList">Replace the following code:
        <pre class="programlisting code"><code class="hljs-code">&lt;InputText @bind-Value="@Item.Name" /&gt;
&lt;ValidationMessage For="@(()=&gt;Item.Name)" /&gt;
</code></pre>
<p class="normal">Replace the preceding code with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;BlogInputText @bind-Value="@Item.Name" Label="Name" /&gt;
</code></pre>
</li>
</ol>
<p class="normal">This kind of<a id="_idIndexMarker324"/> change makes me genuinely happy – it simplifies usage, makes the UI easier to understand, and removes the need for duplicated code. Even though we know how to do this now, I want to add one more example that perhaps showcases the really nice benefits of working this way. Let’s create a button component as well. This component will be a bit more to take in:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">ReusableComponents</code> folder, add a new component and name it <code class="inlineCode">BlogButton.razor</code>.</li>
<li class="numberedList">Replace the content with this code:
        <pre class="programlisting code"><code class="hljs-code">@using Microsoft.AspNetCore.Components.Forms
&lt;button type="@InternalButtonType" disabled="@Disabled" class="@InternalCssClass" title="@Title" @onclick="OnButtonClick"&gt;@ChildContent&lt;/button&gt;
</code></pre>
</li>
<li class="numberedList">We are adding a normal HTML button, nothing fancy. We add functionality to change the type (<code class="inlineCode">button</code> or <code class="inlineCode">submit</code>), whether it is disabled or not, what CSS class it should have, a method to run, and the title.</li>
<li class="numberedList">Add the following code to the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">[CascadingParameter]
 public EditContext? EditContext { get; set; }
 [Parameter]
 public RenderFragment? ChildContent { get; set; }
</code></pre>
</li>
<li class="numberedList">Here, we are doing the same thing as with the <code class="inlineCode">BlogTextbox</code>, and we bring in the <code class="inlineCode">EditContext</code>, which we will use in just a bit.</li>
<li class="numberedList">We also have a <code class="inlineCode">RenderFragment</code> for the content of the button.</li>
<li class="numberedList">Next, add<a id="_idIndexMarker325"/> the following code:
        <pre class="programlisting code"><code class="hljs-code">`private bool? _disabled = null;
 private string? _disabledHelpText = "";
 private string formerrors = "";
    [Parameter]
    public bool Disabled
    {
        get
        {
            if (_disabled != null &amp;&amp; (_disabled == null || _disabled.Value))
            {
                return _disabled!.Value;
            }
            if (EditContext == null)
            {
                return false;
            }
            formerrors = "";
            if (!TryGetValidationMessages(out var validationmessages))
            {
                return true;
            }
            foreach (var m in validationmessages)
            {
                formerrors += m + (MarkupString)" \r\n";
            }
            return !EditContext.IsModified() || validationmessages.Any();
        }
        set =&gt; _disabled = value;
    }
</code></pre>
</li>
<li class="numberedList">First, we add a<a id="_idIndexMarker326"/> couple of <code class="inlineCode">private</code> fields that we will use in the component, then we add a property for whether the button is disabled or not. It will use <code class="inlineCode">EditContext</code> to check whether there are any errors in the form, save those errors in a variable, and if the form is OK, enable the button, and if it is not, disable the button. There is a downside to this implementation; for the validation to trigger, we need to click somewhere else on the page to trigger the change in the field. So, now, the button will be disabled if the form is not OK.</li>
<li class="numberedList">Add the following code:
        <pre class="programlisting code"><code class="hljs-code">private string? Title =&gt; Disabled &amp;&amp; !string.IsNullOrWhiteSpace(DisabledHelpText) ? DisabledHelpText : HelpText;
[Parameter]
public string? DisabledHelpText { get { return _disabledHelpText + (MarkupString)"\r\n" + formerrors; } set { _disabledHelpText = value; } }
[Parameter]
public string? HelpText { get; set; }
</code></pre>
</li>
<li class="numberedList">This code will get a <code class="inlineCode">Title</code> for the button and it will be shown when hovering your mouse over the button. We can also set a <code class="inlineCode">HelpText</code> or a disabled help text. If the function is disabled for any reason, it might not have anything to do with the for we will show a text that explains why the button is disabled. It will also add any form errors to the button so it is easy to understand what form element is the problem without having to scroll to the element.</li>
<li class="numberedList">Sometimes, we might want to use the button, but without a form, simply executing a method. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">    [Parameter] public EventCallback OnClick { get; set; }
    private string InternalButtonType =&gt; OnClick.HasDelegate ? "button" : "submit";
    private async Task OnButtonClick(EventArgs args)
    {
        if (OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(args);
        }
    }
</code></pre>
</li>
<li class="numberedList">If we have a delegate for <code class="inlineCode">OnClick</code>, we want the button to simply be a button. If we don’t have a delegate, we assume the button is used inside of an <code class="inlineCode">EditForm</code>. When the button is clicked, the <code class="inlineCode">OnButtonClick</code> method will run.</li>
<li class="numberedList">Now, we get<a id="_idIndexMarker327"/> to the really juicy part. Let’s add an <code class="inlineCode">enum</code>; we can add it in the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">public enum ButtonType
{
    Save,
    Cancel,
    Delete,
    Remove,
    Select
}
</code></pre>
</li>
<li class="numberedList">Notice that we are not using vocabulary like primary or danger – that’s Bootstrap lingo. What we want to know is what the button is used for. When we add a button, what is the most likely scenario in which the button will be used? </li>
<li class="numberedList">Then, we add a parameter for <code class="inlineCode">ButtonType</code> like this:
        <pre class="programlisting code"><code class="hljs-code">[Parameter] public ButtonType Type { get; set; }
private string InternalCssClass
{
    get
    {
        return Type switch
        {
            ButtonType.Save =&gt; "btn btn-success",
            ButtonType.Cancel =&gt; "btn btn-danger",
            ButtonType.Delete =&gt; "btn btn-danger",
            ButtonType.Remove =&gt; "btn btn-danger",
            ButtonType.Select =&gt; "btn btn-primary",
            _ =&gt; "btn btn-primary"
        };
    }
}
</code></pre>
<p class="normal">We add a parameter for <code class="inlineCode">ButtonType</code> and an internal property that translates the “Save” use case, for example, to a Bootstrap CSS class.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="16">Our team doesn’t have to bother remembering which Bootstrap class they should use; they know it’s a button, and they know what the button is used for. The component takes care of the rest.
    <p class="normal">Let’s test it out!</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="17">In the <code class="inlineCode">BlazorWebApp</code> project, in<a id="_idIndexMarker328"/> the <code class="inlineCode">Pages/Admin</code> folder, open <code class="inlineCode">TagList.razor.</code></li>
<li class="numberedList">Replace the following line:
        <pre class="programlisting code"><code class="hljs-code">&lt;button class="btn btn-success" type="submit"&gt;Save&lt;/button&gt;
</code></pre>
<p class="normal">Replace the preceding line with the following line:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;BlogButton Type="BlogButton.ButtonType.Save"&gt;Save&lt;/BlogButton&gt;
</code></pre>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="19">If you run the project now, you will see that the button is disabled if we haven’t made any changes to the form, and will become enabled if we add something to the textbox. </li>
<li class="numberedList">Let’s do the same for the <code class="inlineCode">CategoryList</code>. In the <code class="inlineCode">SharedComponents</code> project, in the folder <code class="inlineCode">Pages/Admin</code>, open <code class="inlineCode">CategoryList.razor</code>.</li>
<li class="numberedList">Replace the following line:
        <pre class="programlisting code"><code class="hljs-code">&lt;button class="btn btn-success" type="submit"&gt;Save&lt;/button&gt;
</code></pre>
<p class="normal">Replace the preceding line with the following line:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;BlogButton Type="BlogButton.ButtonType.Save"&gt;Save&lt;/BlogButton&gt;
</code></pre>
</li>
</ol>
<p class="normal">There are<a id="_idIndexMarker329"/> more places we can modify and add this button to, but let’s not spend time on that for now. If you want, you can return to this and make sure we are using the new button and <code class="inlineCode">InputText</code> everywhere.</p>
<p class="normal">We have one more component to build.</p>
<h2 class="heading-2" id="_idParaDest-147">Locking the navigation</h2>
<p class="normal">In .NET 7, we got a<a id="_idIndexMarker330"/> new component called <code class="inlineCode">NavigationLock</code>. Right<a id="_idIndexMarker331"/> now, if we write a blog post and click somewhere in the menu, our changes will be lost. The same thing happens if we change the URL and press <em class="keystroke">Enter</em>. With <code class="inlineCode">NavigationLock</code>, we can prevent that from happening.</p>
<p class="normal"><code class="inlineCode">NavigationLock</code> can prevent us from leaving the page and navigating to another page in our site. In that case, we can show a custom message using JavaScript. If we navigate to another site, it can trigger a warning, but we don’t have control over the message shown. This functionality is built into the browser.</p>
<p class="normal">We will implement this in the same way we did with <code class="inlineCode">FieldCssClassProvider</code>, as a reusable component. We want to check whether our <code class="inlineCode">EditContext</code> has any changes made so we can trigger the navigation lock:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">ReusableComponents</code> folder, add a new Razor component and name it <code class="inlineCode">BlogNavigationLock.razor</code>.</li>
<li class="numberedList">At the top of the component, add the following code:
        <pre class="programlisting code"><code class="hljs-code">@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.JSInterop @inject IJSRuntime JSRuntime
@implements IDisposable
</code></pre>
<p class="normal">We inject an <code class="inlineCode">IJSRuntime</code> to make JavaScript calls. We will return to JavaScript interop in <em class="chapterRef">Chapter 10</em>, <em class="italic">JavaScript Interop</em>.</p>
<p class="normal">We also implement the <code class="inlineCode">IDisposable</code> interface.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">In the <code class="inlineCode">code</code> section, add the following code:
        <pre class="programlisting code"><code class="hljs-code">[CascadingParameter]
public required EditContext CurrentEditContext { get; set; }
public string InternalNavigationMessage { get; set; } = "You are about to loose changes, are you sure you want to navigate away?"; public bool CheckNavigation { get; set; } = true;
</code></pre>
<p class="normal">We have a <code class="inlineCode">CascadingParameter</code>, which gets the current <code class="inlineCode">EditContext</code>, just as we did with <code class="inlineCode">FieldCssClassProvider</code>.</p>
<p class="normal">We also added a string that is the message shown when we try to navigate from the page.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">When a change<a id="_idIndexMarker332"/> happens in the <code class="inlineCode">EditContext</code>, we need to update the component and make sure it locks the navigation. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">protected override Task OnInitializedAsync()
{
    CurrentEditContext.OnFieldChanged += OnFieldChangedAsync;
    return base.OnInitializedAsync();
}
private async void OnFieldChangedAsync(object? Sender,FieldChangedEventArgs args)
    {
        await InvokeAsync(StateHasChanged);
    }
void Idisposable.Dispose()
{
        CurrentEditContext.OnFieldChanged -= OnFieldChangedAsync;
    }
</code></pre>
<p class="normal">We start to listen for field changes, and if a field changes, we call the <code class="inlineCode">StateHasChanged</code> method to update the component.</p>
<p class="normal"><code class="inlineCode">InvokeAsync</code> is needed since the call comes from another thread.</p>
<p class="normal">We also override the <code class="inlineCode">Dispose</code> method and remove the event listener.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In the <code class="inlineCode">code</code> section, add the following code:
        <pre class="programlisting code"><code class="hljs-code">private async Task OnBeforeInternalNavigation (LocationChangingContext context)
{
    if (CurrentEditContext.IsModified() &amp;&amp; CheckNavigation)
    {
        var isConfirmed = await JSRuntime.InvokeAsync&lt;bool&gt;("confirm",
            InternalNavigationMessage);
        if (!isConfirmed)
        {
            context.PreventNavigation();
        }
    }
}
</code></pre>
<p class="normal">This method will make a JavaScript call if there are changes in the <code class="inlineCode">EditContext</code> (or model), showing a confirm dialog and the message we added. If we do not confirm, the navigation will be prevented.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Now, we can <a id="_idIndexMarker333"/>add the <code class="inlineCode">NavigationLock</code> component. Just under the directives, add the following code:
        <pre class="programlisting code"><code class="hljs-code">&lt;NavigationLock ConfirmExternalNavigation="@(CurrentEditContext.IsModified() &amp;&amp; CheckNavigation)" OnBeforeInternalNavigation="OnBeforeInternalNavigation" /&gt;
</code></pre>
<p class="normal">This <code class="inlineCode">NavigationLock</code> component will prevent external navigation (navigating to another site) and internal navigation (navigating to another page in our blog). It checks whether the <code class="inlineCode">EditContext</code> (model) has any changes and prevents external navigation. On internal navigation, it will execute the <code class="inlineCode">OnBeforeInternalNavigation</code> method, which checks whether the <code class="inlineCode">EditContext</code> has been changed.</p>
<p class="normal">Now, we only have one more thing to do.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">In <code class="inlineCode">Pages/Admin/BlogPostEdit.razor</code>, add the new Razor component we created just below the <code class="inlineCode">CustomCssClassProvider</code>:
        <pre class="programlisting code"><code class="hljs-code">&lt;BlogNavigationLock @ref="NavigationLock"/&gt;
</code></pre>
<p class="normal">This will get the <code class="inlineCode">EditContext</code> from the cascading value, and execute the code we just wrote.</p>
<p class="normal">Add the following:</p>
<pre class="programlisting code"><code class="hljs-code">@using SharedComponents.ReusableComponents
</code></pre>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">In the <code class="inlineCode">code</code> section, add the following:
        <pre class="programlisting code"><code class="hljs-code">BlogNavigationLock? NavigationLock { get; set; }
</code></pre>
</li>
<li class="numberedList">In the <code class="inlineCode">SavePostAsync</code> method, just before navigating to <code class="inlineCode">admin/blogposts</code>, add the following:
        <pre class="programlisting code"><code class="hljs-code">NavigationLock?.CurrentEditContext.MarkAsUnmodified();
</code></pre>
<p class="normal">When saving the object, the <code class="inlineCode">EditContext</code> doesn’t know that, so we are telling the <code class="inlineCode">EditContext</code> that the model is now unmodified, so the navigation should not be stopped.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">Run the site, navigate to <code class="inlineCode">Admin/BlogPosts</code>, and click a blog post.</li>
<li class="numberedList">Try to navigate to another site (it should work).</li>
<li class="numberedList">Try to navigate to another page (it should work).</li>
<li class="numberedList">Change the blog post.</li>
<li class="numberedList">Try navigating to another site (it should show a message box).</li>
<li class="numberedList">Try <a id="_idIndexMarker334"/>navigating to another page. You might notice that, in our case, it doesn’t show a message box when we navigate to another page. What is up with that? It seems to be a limitation in how this component works. If we were running <code class="inlineCode">InteractiveServer</code> or <code class="inlineCode">InteractiveWebAssembly</code>, it would work. Navigation using static server rendering (which is what happens when we navigate) won’t trigger the navigation change. If we want to test this, we can change our project to run as Blazor Server.</li>
<li class="numberedList">In the <code class="inlineCode">BlazorWebApp</code> project, in the <code class="inlineCode">Components</code> folder, open the <code class="inlineCode">App.razor</code> file.
    <p class="normal">Replace the following line:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Routes  /&gt;
</code></pre>
<p class="normal">Replace the preceding line with the following line:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Routes @rendermode="RenderMode.InteractiveServer" /&gt;
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="17">Now we can try it again:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
<li class="alphabeticList" value="1">Run the site, navigate to <code class="inlineCode">Admin/BlogPosts</code>, and click a blog post.</li>
<li class="alphabeticList">Try to navigate to another site (it should work).</li>
<li class="alphabeticList">Try to navigate to another page (it should work).</li>
<li class="alphabeticList">Change the blog post.</li>
<li class="alphabeticList">Try navigating to another site (it should show a message box).</li>
<li class="alphabeticList">Try navigating to another page (it should show a message box).</li>
</ol>
<p class="normal">Now, change it<a id="_idIndexMarker335"/> back to <code class="inlineCode">&lt;Routes /&gt;</code>.</p>
</li>
</ol>
<p class="normal">The point of this is to show that, in some cases, the built-in components will act differently depending on the render mode. I honestly think that this is a bug rather than a feature, but there are discussions about this.</p>
<p class="normal">Awesome! We have implemented another reusable component. Next, let’s take a look at how we can use a form with a static server-side rendered component using enhanced form navigation.</p>
<h1 class="heading-1" id="_idParaDest-148">Enhanced Form Navigation</h1>
<p class="normal">In .NET 8, we got server-side <a id="_idIndexMarker336"/>rendering. Adding interactivity to a component is simple, as we have seen. But sometimes we just want a form and a submit button. Do we really have to enable WebAssembly or a SignalR connection for this? I’m glad you asked! The answer is, no, we don’t.</p>
<p class="normal">Let’s add a component to showcase that our blog posts need comments:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">Pages</code> folder, add a new Razor component called <code class="inlineCode">Comments.razor</code>. This component should do two things: list comments and create a new comment.</li>
<li class="numberedList">In the <code class="inlineCode">comments</code> file, replace the content with the following:
        <pre class="programlisting code"><code class="hljs-code">@using SharedComponents.ReusableComponents
@using Microsoft.AspNetCore.Components.Forms
@inject IBlogApi _api
&lt;h3&gt;Comments&lt;/h3&gt;
@foreach (var c in comments)
{
    &lt;div class="media mb-4"&gt;
&lt;div class="media-body"&gt;
&lt;h5 class="mt-0"&gt;@c.Name&lt;/h5&gt;
&lt;p&gt;@c.Text&lt;/p&gt;
&lt;small class="text-muted"&gt;@c.Date&lt;/small&gt;
&lt;/div&gt;
&lt;/div&gt;
}
</code></pre>
<p class="normal">This is a list of comments and some bootstrap classes to make it look better.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Continue by adding the form:
        <pre class="programlisting code"><code class="hljs-code">@if (Model != null)
{
    &lt;EditForm method="post" Model="@Model" OnValidSubmit="@ValidSubmitAsync" FormName="CommentForm"&gt;
&lt;DataAnnotationsValidator /&gt;
&lt;CustomCssClassProvider ProviderType="BootstrapFieldCssClassProvider" /&gt;
&lt;BlogInputText @bind-Value="Model.Name" Label="Name" /&gt;
&lt;BlogInputText @bind-Value="Model.Text" Label="Comment" /&gt;
&lt;button type="submit"&gt;Add Comment&lt;/button&gt;
&lt;/EditForm&gt;
}
</code></pre>
</li>
<li class="numberedList">We are still <a id="_idIndexMarker337"/>using an <code class="inlineCode">EditForm</code> just as before and an <code class="inlineCode">OnValidSubmit</code> property. There are some things that are new here, though. We are specifying the method we are using to post the form – in this case, a post method. We are also naming the form with the <code class="inlineCode">FormName</code> parameter. These two properties must be there. We are using the <code class="inlineCode">DataAnnotationValidator</code> and the <code class="inlineCode">CustomCssClassProvider</code> we created earlier. We are even using the <code class="inlineCode">BlogInputText</code>. But since this component isn’t interactive, our button will not work as it is disabled by default, and if we remove the interactivity, it will stay disabled. So, in this case, we have to add a button the old-fashioned way. We can make sure that there is a non-interactive button for cases like this as well.
    <p class="normal">Now it is time for the code part of the form:</p>
<pre class="programlisting code"><code class="hljs-code">@code {
    [Parameter,EditorRequired]
    public required string BlogPostId { get; set; }
    [SupplyParameterFromForm]
    public Comment? Model { get; set; } = new();
    List&lt;Comment&gt; comments = new();
    protected override async Task OnInitializedAsync()
    {
        comments = await _api.GetCommentsAsync(BlogPostId);
    }
    public async Task ValidSubmitAsync()
    {
        Model.Id = Guid.NewGuid().ToString();
        Model.Date = DateTime.Now;
        Model.BlogPostId = BlogPostId;
        await _api.SaveCommentAsync(Model);
        comments = await _api.GetCommentsAsync(BlogPostId);
    }
}
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Here, we are <a id="_idIndexMarker338"/>using a parameter so that our component knows what blog post to show comments for. It has <code class="inlineCode">EditorRequired</code>, so Visual Studio will warn you if it is missing. The <code class="inlineCode">Model</code> parameter has the <code class="inlineCode">SupplyParameterFromForm</code> attribute, which is required. This is so Blazor knows what property to fill with data when the form is posted. The rest of the code is the same as the code we have used previously. </li>
<li class="numberedList">Open <code class="inlineCode">Post.cs</code> and add the following code just beneath the line @((MarkupString)Markdig.Markdown.ToHtml(BlogPost.Text, pipeline)):
        <pre class="programlisting code"><code class="hljs-code">&lt;Comments BlogPostId="@BlogPostId" /&gt;
</code></pre>
<p class="normal">So, what is happening?</p>
<p class="normal">When we submit our form, the component will be rerendered, creating a new instance of the component and filling the (in our case) <code class="inlineCode">Model</code> parameter with the data from the post. With interactive components, <code class="inlineCode">OnInitialized</code> and <code class="inlineCode">OnInitializedAsync</code> will only run once (unless we are running prerendering). With these static components, it will reload the component. But we also get a “problem” because the scrolling positions get lost when the page reloads. We will now find ourselves at the top of the page, which is not a great user experience. Luckily, there is a solution; this is where the <code class="inlineCode">Enhance</code> part comes in. By adding <code class="inlineCode">Enhance</code> to our form, it will now keep its scroll position after posting the page. Pretty neat, right? We can also use a normal form instead of an <code class="inlineCode">EditForm</code>. </p>
<p class="normal">It would then look something like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;form method="post" @onsubmit="…" @formname="name" data-enhance&gt;
</code></pre>
<p class="normal">Instead of <code class="inlineCode">Enhance</code>, we add <code class="inlineCode">data-enhance</code>. Personally, I prefer to use an <code class="inlineCode">EditForm</code> where I can, but it might be good to know that there are options.</p>
<p class="normal">We can also use <code class="inlineCode">data-permanent</code> to keep the information in the form fields for a search parameter, for example. This way, the enhanced navigation will not update that data when the response is returned. How many times have we used a search field, misspelled something, and then the search field is empty and we need<a id="_idIndexMarker339"/> to retype everything? This is where <code class="inlineCode">data-permanent</code> saves us.</p>
</li>
</ol>
<p class="normal">Amazing!</p>
<p class="normal">This has been a heavy chapter, but wow, we have done so much – a whole bunch of new and reusable components and a complete admin interface.</p>
<h1 class="heading-1" id="_idParaDest-149">Summary</h1>
<p class="normal">This chapter taught us how to create forms and make API calls to get and save data.</p>
<p class="normal">We built custom input controls and got Bootstrap styling on our controls. Most business apps use forms; we can add logic close to the data by annotating data.</p>
<p class="normal">We also created multiple reusable components and used many of the things we discussed in previous chapters. We even touched on JavaScript interop, which we will go into more detail about in <em class="chapterRef">Chapter 10</em>, <em class="italic">JavaScript Interop</em>.</p>
<p class="normal">The functionality that Blazor offers when it comes to validation and input controls will help us build amazing applications and give our users a great experience. You may notice that, right now, the admin pages are wide open. We need to secure our blog with a login, but we will come to that in <em class="chapterRef">Chapter 8</em>, <em class="italic">Authentication and Authorization</em>.</p>
<p class="normal">In the next chapter, we will create a web API to get data when we are running components such as <code class="inlineCode">InteractiveAuto</code> or <code class="inlineCode">InteractiveWebAssembly</code>.</p>
</div>
</body></html>