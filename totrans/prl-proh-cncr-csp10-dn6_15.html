<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer091">
<h1 id="_idParaDest-187"><em class="italic"><a id="_idTextAnchor186"/>Chapter 12</em>: Unit Testing Async, Concurrent, and Parallel Code</h1>
<p>Unit testing asynchronous, concurrent, and parallel code can be a challenge for .NET developers. Fortunately, there are some steps you can take to help ease the difficulty. This chapter will provide some concrete advice and useful examples of how developers can unit test code that leverages multi-threaded constructs. These examples will illustrate how unit tests can still be reliable while covering code that performs multithreaded operations. In addition, we will explore a third-party tool that facilitates the creation of automated unit tests that monitor your code for potential memory leaks.</p>
<p>Creating unit tests for your .NET projects is important to maintain the health of your code base as it grows and evolves. When developers make changes to code that has unit test coverage, they can run the existing tests to feel confident that no existing functionality has been broken by the code changes. Visual Studio makes it simple to create, run, and maintain unit test projects throughout the life cycle of your code. </p>
<p>The<span class="superscript"> </span><strong class="bold">Test Explorer</strong> window in Visual Studio can detect and run unit tests created with Microsoft’s MSTest framework, as well as third-party frameworks such as NUnit and xUnit.net. Whether you are developing applications for Windows, mobile devices, or the cloud, you should always plan to develop a suite of unit tests for your projects and define goals for test coverage.</p>
<p class="callout-heading">Note</p>
<p class="callout">This chapter assumes that you have some familiarity with unit testing and good unit testing practices. For a good primer on unit testing projects with xUnit.net, you can review Microsoft’s documentation at <a href="https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test">https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test</a> and at <a href="https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing">https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing</a>.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Unit testing asynchronous code</li>
<li>Unit testing concurrent code</li>
<li>Unit testing parallel code</li>
<li>Checking for memory leaks with unit tests</li>
</ul>
<p>By the end of this chapter, you will be armed with tools and advice to help you confidently write modern multithreaded code with unit test coverage.</p>
<p class="callout-heading">Note</p>
<p class="callout">The unit tests in this chapter are created with<a id="_idIndexMarker617"/> the <strong class="bold">xUnit.net</strong> unit testing framework. You<a id="_idIndexMarker618"/> can achieve the same results with your unit testing framework of choice, including <strong class="bold">MSTest</strong> and <strong class="bold">NUnit</strong>. The<a id="_idIndexMarker619"/> memory unit testing framework we will be demonstrating later in this chapter uses xUnit.net, but it also supports MSTest and NUnit.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.2 or later</li>
<li>.NET 6</li>
<li>A JetBrains dotMemory Unit standalone console runner</li>
</ul>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12</a>.</p>
<p>Let’s get started by examining how to write unit tests that cover <strong class="source-inline">async</strong> C# methods.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Unit testing asynchronous code</h1>
<p>Unit testing<a id="_idIndexMarker620"/> asynchronous code requires the same<a id="_idIndexMarker621"/> approach as writing good asynchronous C# code. If you need a refresher on how to work with <strong class="source-inline">async</strong> methods, you can review <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<p>When writing <a id="_idIndexMarker622"/>a unit test for an <strong class="source-inline">async</strong> method, you will use the <strong class="source-inline">await</strong> keyword to wait for the method to complete. This requires that your unit test method is <strong class="source-inline">async</strong> and returns <strong class="source-inline">Task</strong>. Just like other C# code, creating <strong class="source-inline">async void</strong> methods <a id="_idIndexMarker623"/>is not permitted. Let’s look at a very simple test method:</p>
<pre class="source-code">[Fact]</pre>
<pre class="source-code">private async Task GetBookAsync_Returns_A_Book()</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    // Arrange</pre>
<pre class="source-code">    BookService bookService = new();</pre>
<pre class="source-code">    var bookId = 123;</pre>
<pre class="source-code">    // Act</pre>
<pre class="source-code">    var book = await bookService.GetBookAsync(bookId);</pre>
<pre class="source-code">    // Assert</pre>
<pre class="source-code">    Assert.NotNull(book);</pre>
<pre class="source-code">    Assert.Equal(bookId, book.Id);</pre>
<pre class="source-code">}</pre>
<p>This probably looks like most tests you have written for synchronous code. There are only a couple of differences: </p>
<ul>
<li>First, the test method is <strong class="source-inline">async</strong> and returns <strong class="source-inline">Task</strong>.</li>
<li>Second, the call to <strong class="source-inline">GetBookAsync</strong> uses the <strong class="source-inline">await</strong> keyword to wait for the result. Otherwise, this test follows the<a id="_idIndexMarker624"/> typical <strong class="bold">Arrange–Act–Assert</strong> pattern and tests the result as you typically would. </li>
</ul>
<p>Let’s create a simple project to try this in Visual Studio and see the results:</p>
<ol>
<li>Start by creating a new <strong class="bold">Class Library</strong> project in Visual Studio named <strong class="source-inline">AsyncUnitTesting</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 12.1 – Creating a new Class Library project " height="1066" src="image/Figure_12.1_B18552.jpg" width="1628"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Creating a new Class Library project</p>
<ol>
<li value="2">Next, we<a id="_idIndexMarker625"/> are<a id="_idIndexMarker626"/> going to add a test project to the <strong class="bold">AsyncUnitTesting</strong> solution. Right-click on the solution file in <strong class="bold">Solution Explorer</strong> and click on <strong class="bold">Add</strong> | <strong class="bold">New project</strong>. Select the <strong class="bold">xUnit Test Project</strong> template and name the project <strong class="source-inline">AsyncUnitTesting.Tests</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 12.2 – Adding an xUnit Test project to the solution " height="1075" src="image/Figure_12.2_B18552.jpg" width="1644"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Adding an xUnit Test project to the solution</p>
<ol>
<li value="3">In<a id="_idIndexMarker627"/> the <strong class="bold">AsyncUnitTesting</strong> project, rename<a id="_idIndexMarker628"/> the <strong class="bold">Class1.cs</strong> file <strong class="source-inline">BookOrderService.cs</strong>. When Visual Studio asks whether you want to rename all uses of <strong class="source-inline">Class1</strong>, select <strong class="bold">Yes</strong>.</li>
<li>Open the <strong class="source-inline">BookOrderService</strong> class and add an <strong class="source-inline">async</strong> method named <strong class="source-inline">GetCustomerOrdersAsync</strong>:<p class="source-code">public async Task&lt;List&lt;string&gt;&gt; </p><p class="source-code">    GetCustomerOrdersAsync(int customerId)</p><p class="source-code">{</p><p class="source-code">    if (customerId &lt; 1)</p><p class="source-code">    {</p><p class="source-code">        throw new ArgumentException("Customer ID must </p><p class="source-code">            be greater than zero.", nameof</p><p class="source-code">                (customerId));</p><p class="source-code">    }</p><p class="source-code">    var orders = new List&lt;string&gt;</p><p class="source-code">    {</p><p class="source-code">        customerId + "1",</p><p class="source-code">        customerId + "2",</p><p class="source-code">        customerId + "3",</p><p class="source-code">        customerId + "4",</p><p class="source-code">        customerId + "5",</p><p class="source-code">        customerId + "6"</p><p class="source-code">    };</p><p class="source-code">    // Simulate time to fetch orders</p><p class="source-code">    await Task.Delay(1500);</p><p class="source-code">    return orders;</p><p class="source-code">}</p></li>
</ol>
<p>This<a id="_idIndexMarker629"/> method takes <strong class="source-inline">customerId</strong> as a parameter <a id="_idIndexMarker630"/>and returns <strong class="source-inline">List&lt;string&gt;</strong> containing the order numbers. If <strong class="source-inline">customerId</strong> provided is less than <strong class="source-inline">1</strong>, <strong class="source-inline">ArgumentException</strong> is thrown. Otherwise, a list of six order numbers is created, with <strong class="source-inline">customerId</strong> as the prefix. After injecting <strong class="source-inline">Task.Delay</strong> of <strong class="source-inline">1500</strong> milliseconds, <strong class="source-inline">orders</strong> is returned to the calling method.</p>
<ol>
<li value="5">Next, right-click the <strong class="bold">AsyncUnitTesting.Tests</strong> project and click on <strong class="bold">Add</strong> |<strong class="bold"> Project Reference</strong>. In the <strong class="bold">Reference Manager</strong> dialog, check the box for the <strong class="bold">AsyncUnitTesting</strong> project and click <strong class="bold">OK</strong>.</li>
<li>Now, rename the <strong class="source-inline">UnitTest1</strong> class <strong class="source-inline">BookOrderServiceTests</strong> and open the file in the Visual Studio editor.</li>
<li>It’s time to<a id="_idIndexMarker631"/> start adding tests. Let’s start by testing the <a id="_idIndexMarker632"/>happy path. Add a test method named <strong class="source-inline">GetCustomerOrdersAsync_Returns_Orders_For_Valid_CustomerId</strong>:<p class="source-code">[Fact]</p><p class="source-code">public async Task GetCustomerOrdersAsync_Returns_</p><p class="source-code">    Orders_For_Valid_CustomerId()</p><p class="source-code">{</p><p class="source-code">    var service = new BookOrderService();</p><p class="source-code">    int customerId = 3;</p><p class="source-code">    var orders = await service.GetCustomerOrdersAsync</p><p class="source-code">        (customerId);</p><p class="source-code">    Assert.NotNull(orders);</p><p class="source-code">    Assert.True(orders.Any());</p><p class="source-code">    Assert.StartsWith(customerId.ToString(), </p><p class="source-code">        orders[0]);</p><p class="source-code">}</p></li>
</ol>
<p>After calling <strong class="source-inline">GetCustomerOrdersAsync</strong> with <strong class="source-inline">customerId</strong> of <strong class="source-inline">3</strong>, our code has three assertions: </p>
<ul>
<li>First, we’re checking that the list of orders is not <strong class="source-inline">null</strong>. </li>
<li>Second, we’re checking that the list contains some items.</li>
<li>Finally, we check that the first order starts with <strong class="source-inline">customerId</strong>.</li>
</ul>
<ol>
<li value="8">Click on <strong class="bold">Test</strong> | <strong class="bold">Run All Tests</strong> to ensure that this test passes.</li>
<li>Let’s write that same test with a new <strong class="source-inline">customerId</strong> but without <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. Assume <a id="_idIndexMarker633"/>that you have some legacy test code that just cannot be refactored, and <a id="_idIndexMarker634"/>you have to test the <strong class="source-inline">GetCustomerOrdersAsync</strong> method. That code would look like this:<p class="source-code">[Fact]</p><p class="source-code">public void GetCustomerOrdersAsync_Returns_Orders</p><p class="source-code">    _For_Valid_CustomerId_Sync()</p><p class="source-code">{</p><p class="source-code">    var service = new BookOrderService();</p><p class="source-code">    int customerId = 5;</p><p class="source-code">    List&lt;string&gt; orders = service.GetCustomer</p><p class="source-code">        OrdersAsync(customerId).GetAwaiter()</p><p class="source-code">            .GetResult();</p><p class="source-code">    Assert.NotNull(orders);</p><p class="source-code">    Assert.True(orders.Any());</p><p class="source-code">    Assert.StartsWith(customerId.ToString(), </p><p class="source-code">        orders[0]);</p><p class="source-code">}</p></li>
</ol>
<p>The test method is not <strong class="source-inline">async</strong> and returns <strong class="source-inline">void</strong>. Instead of using <strong class="source-inline">await</strong> to allow <strong class="source-inline">GetCustomerOrdersAsync</strong> to run to completion, we are calling <strong class="source-inline">GetAwaiter().GetResult()</strong>. The setup and assertion sections of the code remain the same.</p>
<ol>
<li value="10">Click on <strong class="bold">Test</strong> | <strong class="bold">Run All Tests</strong> to make sure both of our tests are <em class="italic">green</em> (passing).</li>
<li>Finally, we are going to test the exception case. Create another test but pass a negative <strong class="source-inline">customerId</strong> to the method under test. The entire call to <strong class="source-inline">GetCustomerOrdersAsync</strong> will be wrapped in an <strong class="source-inline">Assert.ThrowsAsync&lt;ArgumentException&gt;</strong> invocation:<p class="source-code">[Fact]</p><p class="source-code">public async Task GetCustomerOrdersAsync_</p><p class="source-code">    Throws_Exception_For_Invalid_CustomerId()</p><p class="source-code">{</p><p class="source-code">    var service = new BookOrderService();</p><p class="source-code">    await Assert.ThrowsAsync&lt;ArgumentException&gt;(async </p><p class="source-code">        () =&gt; await service.GetCustomerOrdersAsync</p><p class="source-code">            (-2));</p><p class="source-code">}</p></li>
<li>Execute <strong class="bold">Run All Tests</strong> one<a id="_idIndexMarker635"/> last time and ensure that they are all passing:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer086">
<img alt="Figure 12.3 – Viewing three passing tests in Test Explorer " height="451" src="image/Figure_12.3_B18552.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Viewing three passing tests in Test Explorer</p>
<p>We now<a id="_idIndexMarker636"/> have three passing unit tests for the <strong class="source-inline">GetCustomerOrdersAsync</strong> method. The first two are essentially testing the same thing, but they are demonstrating two different ways of writing the test. You will be using the <strong class="source-inline">async</strong> method in most cases. The final test provides test coverage of the code that throws <strong class="source-inline">ArgumentException</strong>. If you are using Visual Studio Enterprise edition or a third-party tool such as dotCover, you can use their visualization tools to view which parts of your code are covered by unit tests and which are not.</p>
<p>Now that we have some familiarity with testing <strong class="source-inline">async</strong> methods, let’s move on to working with concurrent data structures in a system under test.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Unit testing concurrent code</h1>
<p>In this<a id="_idIndexMarker637"/> section, we will adapt a sample from <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, to add unit test coverage. When your code uses <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>, adding reliable test coverage is very simple. At the end of the example, we will examine an alternative method of waiting to perform your <a id="_idIndexMarker638"/>assertions by using the <strong class="source-inline">SpinLock</strong> struct.</p>
<p>Let’s create an xUnit.net unit test project for the <strong class="source-inline">ConcurrentOrderQueue</strong> project and add several tests:</p>
<ol>
<li value="1">Start by copying the <strong class="bold">ConcurrentOrderQueue</strong> project from <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>. You can get the source code from the GitHub repository if you do not already have a copy of it: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue</a>.</li>
<li>Open the <strong class="bold">ConcurrentOrderQueue</strong> solution in Visual Studio.</li>
<li>Right-click the solution file in <strong class="bold">Solution Explorer</strong> and click on <strong class="bold">Add</strong> | <strong class="bold">New Project</strong>. Add an <strong class="bold">xUnit Unit Test</strong> project named <strong class="source-inline">ConcurrentOrderQueue.Tests</strong>. Make sure to add the new project inside the <strong class="bold">ConcurrentOrderQueue</strong> folder.</li>
<li>If your new test project also appears as a folder under the <strong class="bold">ConcurrentOrderQueue</strong> project, right-click on the <strong class="bold">ConcurrentOrderQueue.Tests</strong> folder and select <strong class="bold">Exclude from Project</strong>.</li>
<li>Add <strong class="bold">Project Reference</strong> from the new project to the <strong class="bold">ConcurrentOrderQueue</strong> project and rename the <strong class="source-inline">UnitTest1</strong> class <strong class="source-inline">OrderServiceTests</strong>.</li>
<li>In order to control which <strong class="source-inline">CustomerId</strong> values are used to generate the list of orders, we are going to create a new overload for the public <strong class="source-inline">EnqueueOrders</strong> method in the <strong class="source-inline">OrderService</strong> class:<p class="source-code">public async Task EnqueueOrders(List&lt;int&gt; customerIds)</p><p class="source-code">{</p><p class="source-code">    var tasks = new List&lt;Task&gt;();</p><p class="source-code">    foreach (int id in customerIds)</p><p class="source-code">    {</p><p class="source-code">        tasks.Add(EnqueueOrders(id));</p><p class="source-code">    }</p><p class="source-code">    await Task.WhenAll(tasks);</p><p class="source-code">}</p></li>
</ol>
<p>This method takes a list of <strong class="source-inline">customerId</strong> and calls the private <strong class="source-inline">EnqueueOrders</strong> method for each of them, adding <strong class="source-inline">Task</strong> from each call to <strong class="source-inline">List&lt;Task&gt;</strong> to be <a id="_idIndexMarker639"/>awaited before exiting the method.</p>
<ol>
<li value="7">We <a id="_idIndexMarker640"/>can now optimize the parameterless version of <strong class="source-inline">EnqueueOrders</strong> by having it call this new overload:<p class="source-code">public async Task EnqueueOrders()</p><p class="source-code">{</p><p class="source-code">    await EnqueueOrders(new List&lt;int&gt; { 1, 2 });</p><p class="source-code">}</p></li>
<li>Create a new unit test method in the <strong class="source-inline">OrderServiceTests</strong> class to test <strong class="source-inline">EnqueueOrders</strong>:<p class="source-code">[Fact]</p><p class="source-code">public async Task EnqueueOrders_Creates_Orders_For_</p><p class="source-code">    All_Customers()</p><p class="source-code">{</p><p class="source-code">    var orderService = new OrderService();</p><p class="source-code">    var orderNumbers = new List&lt;int&gt; { 2, 5, 9 };</p><p class="source-code">    await orderService.EnqueueOrders(orderNumbers);</p><p class="source-code">    var orders = orderService.DequeueOrders();</p><p class="source-code">    Assert.NotNull(orders);</p><p class="source-code">    Assert.True(orders.Any());</p><p class="source-code">    Assert.Contains(orders, o =&gt; o.CustomerId == 2);</p><p class="source-code">    Assert.Contains(orders, o =&gt; o.CustomerId == 5);</p><p class="source-code">    Assert.Contains(orders, o =&gt; o.CustomerId == 9);</p><p class="source-code">}</p></li>
</ol>
<p>The test will call <strong class="source-inline">EnqueueOrders</strong> with three customer IDs. After <strong class="source-inline">EnqueueOrders</strong> and <strong class="source-inline">DequeueOrders</strong> are complete, we assert that the <strong class="source-inline">orders</strong> collection is not <strong class="source-inline">null</strong>, contains some orders, and contains orders with all three of our customer IDs.</p>
<ol>
<li value="9">Run the new test and ensure that it passes.</li>
</ol>
<p>This<a id="_idIndexMarker641"/> covers <a id="_idIndexMarker642"/>the basics of working with a system under test that uses <strong class="source-inline">ConcurrentQueue</strong>. Let’s consider another scenario where we are working with code but cannot use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in our tests. Perhaps the method under test is not <strong class="source-inline">async</strong>. One of the tools at our disposal is the <strong class="source-inline">SpinWait</strong> struct. This struct contains some methods that provide non-locking mechanisms for waiting in our code. We will use <strong class="source-inline">SpinWait.WaitUntil()</strong> to wait until all orders have been enqueued.</p>
<p>The following steps will demonstrate how to reliably test the result of a method when you cannot explicitly wait for it to complete:</p>
<ol>
<li value="1">Start by adding a new public variable to the <strong class="source-inline">OrderService</strong> class to expose the number of customers whose orders have been enqueued:<p class="source-code">public int EnqueueCount = 0;</p></li>
<li>Next, increment <strong class="source-inline">EnqueueCount</strong> at the end of the private <strong class="source-inline">EnqueueOrders</strong> method:<p class="source-code">private async Task EnqueueOrders(int customerId)</p><p class="source-code">{</p><p class="source-code">    for (int i = 1; i &lt; 6; i++)</p><p class="source-code">    {</p><p class="source-code">        ...</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">EnqueueCount++;</strong></p><p class="source-code">}</p></li>
<li>Now, create an <strong class="source-inline">EnqueueOrdersSync</strong> public method to be called from our new test. It <a id="_idIndexMarker643"/>will be similar to the public <strong class="source-inline">EnqueueOrders</strong> method. The differences between the previous example and this one are <a id="_idIndexMarker644"/>that it is not <strong class="source-inline">async</strong>, it resets <strong class="source-inline">EnqueueCount</strong> to <strong class="source-inline">0</strong>, and it does not wait for the tasks to be completed:<p class="source-code">public void EnqueueOrdersSync(List&lt;int&gt; customerIds)</p><p class="source-code">{</p><p class="source-code">    EnqueueCount = 0;</p><p class="source-code">    var tasks = new List&lt;Task&gt;();</p><p class="source-code">    foreach (int id in customerIds)</p><p class="source-code">    {</p><p class="source-code">        tasks.Add(EnqueueOrders(id));</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Next, we <a id="_idIndexMarker645"/>will create a new synchronous test method to<a id="_idIndexMarker646"/> test <strong class="source-inline">EnqueueOrdersSync</strong>:<p class="source-code">[Fact]</p><p class="source-code">public <strong class="bold">void</strong> EnqueueOrders_Creates_Orders_For_All</p><p class="source-code">    _Customers_SpinWait()</p><p class="source-code">{</p><p class="source-code">    var orderService = new OrderService();</p><p class="source-code">    var orderNumbers = new List&lt;int&gt; { 2, 5, 9 };</p><p class="source-code"><strong class="bold">    orderService.EnqueueOrdersSync(orderNumbers);</strong></p><p class="source-code"><strong class="bold">    SpinWait.SpinUntil(() =&gt; orderService.EnqueueCount </strong></p><p class="source-code"><strong class="bold">        == orderNumbers.Count);</strong></p><p class="source-code">    var orders = orderService.DequeueOrders();</p><p class="source-code">    Assert.NotNull(orders);</p><p class="source-code">    Assert.True(orders.Any());</p><p class="source-code">    Assert.Contains(orders, o =&gt; o.CustomerId == 2);</p><p class="source-code">    Assert.Contains(orders, o =&gt; o.CustomerId == 5);</p><p class="source-code">    Assert.Contains(orders, o =&gt; o.CustomerId == 9);</p><p class="source-code">}</p></li>
</ol>
<p>The differences are highlighted in the preceding code snippet. <strong class="source-inline">SpinWait.SpinUntil</strong> will wait without locking until the <strong class="source-inline">orderService.EnqueueCount</strong> value matches the <strong class="source-inline">orderNumbers.Count</strong>. If you want to ensure it doesn’t spin forever, there are overloads for providing a timeout period as either <strong class="source-inline">TimeSpan</strong> or in milliseconds.</p>
<ol>
<li value="5">Run the tests again and make sure that they both pass. We now have unit test methods that are testing the two methods available to enqueue orders in the <strong class="source-inline">OrderService</strong> class. In your own projects, you would add more scenarios to increase the test coverage of the class. You should always test things, such as how your code handles invalid input.</li>
</ol>
<p>It is important<a id="_idIndexMarker647"/> to <a id="_idIndexMarker648"/>remember when unit testing multithreaded code that if you are not using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> or some other synchronization method, your tests are going to be unreliable. Having unreliable tests is as bad as having no tests at all. Be sure to design and develop your unit tests with care. It is best to use <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> wherever possible for maximum reliability.</p>
<p>In the next section, we will build some unit tests for code that use the <strong class="source-inline">Parallel.ForEach</strong> and <strong class="source-inline">Parallel.ForEachAsync</strong> methods.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Unit testing parallel code</h1>
<p>Creating <a id="_idIndexMarker649"/>unit tests <a id="_idIndexMarker650"/>for code that use <strong class="source-inline">Parallel.Invoke</strong>, <strong class="source-inline">Parallel.For</strong>, <strong class="source-inline">Parallel.ForEach</strong>, and <strong class="source-inline">Parallel.ForEachAsync</strong> is relatively straightforward. While they can run processes in parallel when conditions are suitable, they run synchronously relative to the invoking code. Unless you wrap <strong class="source-inline">Parallel.ForEach</strong> in a <strong class="source-inline">Task.Run</strong> statement, the flow of code will not continue until all iterations of the loop have been completed.</p>
<p>The one caveat to consider when testing code that uses parallel loops is the type of exceptions to expect. If an exception is thrown within the body of one of these constructs, the surrounding code must catch <strong class="source-inline">AggregateException</strong>. The exception to this <strong class="source-inline">Exception</strong> rule is <strong class="source-inline">Parallel.ForEachAsync</strong>. Because it is called with <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>, you must handle <strong class="source-inline">Exception</strong> instead of <strong class="source-inline">AggregateException</strong>. Let’s create an example to illustrate these scenarios:</p>
<ol>
<li value="1">Create a new <strong class="bold">Class Library</strong> project in Visual Studio named <strong class="source-inline">ParallelExample</strong>.</li>
<li>Rename <strong class="source-inline">Class1</strong> <strong class="source-inline">TextService</strong> and create a method named <strong class="source-inline">ProcessText</strong> in this class:<p class="source-code">public List&lt;string&gt; ProcessText(List&lt;string&gt; </p><p class="source-code">    textValues)</p><p class="source-code">{</p><p class="source-code">    List&lt;string&gt; result = new();</p><p class="source-code">    Parallel.ForEach(textValues, (txt) =&gt; </p><p class="source-code">    {</p><p class="source-code">        if (string.IsNullOrEmpty(txt))</p><p class="source-code">        {</p><p class="source-code">            throw new Exception("Strings cannot be </p><p class="source-code">                empty");</p><p class="source-code">        }</p><p class="source-code">        result.Add(string.Concat(txt, </p><p class="source-code">            Environment.TickCount));</p><p class="source-code">    });</p><p class="source-code">    return result;</p><p class="source-code">}</p></li>
</ol>
<p>This <a id="_idIndexMarker651"/>method accepts a list of strings and appends <strong class="source-inline">Environment.TickCount</strong> to each value inside a <strong class="source-inline">Parallel.ForEach</strong> loop. If <a id="_idIndexMarker652"/>any of the strings are <strong class="source-inline">null</strong> or empty, <strong class="source-inline">Exception</strong> will be thrown.</p>
<ol>
<li value="3">Next, create the <strong class="source-inline">async</strong> version of <strong class="source-inline">ProcessText</strong> and name it <strong class="source-inline">ProcessTextAsync</strong>. The <strong class="source-inline">async</strong> version uses <strong class="source-inline">Parallel.ForEachAsync</strong> to perform the same operation:<p class="source-code">public <strong class="bold">async Task&lt;List&lt;string&gt;&gt;</strong> </p><p class="source-code">    ProcessTextAsync(List&lt;string&gt; textValues)</p><p class="source-code">{</p><p class="source-code">    List&lt;string&gt; result = new();</p><p class="source-code">    <strong class="bold">await Parallel.ForEachAsync(textValues, async </strong></p><p class="source-code"><strong class="bold">        (txt, _) =&gt;</strong></p><p class="source-code">    {</p><p class="source-code">        if (string.IsNullOrEmpty(txt))</p><p class="source-code">        {</p><p class="source-code">            throw new Exception("Strings cannot </p><p class="source-code">                be empty");</p><p class="source-code">        }</p><p class="source-code">        result.Add(string.Concat(txt, </p><p class="source-code">            Environment.TickCount));</p><p class="source-code">        <strong class="bold">await Task.Delay(100);</strong></p><p class="source-code">    });</p><p class="source-code">    return result;</p><p class="source-code">}</p></li>
<li>Add a <a id="_idIndexMarker653"/>new <strong class="bold">xUnit Test</strong> project<a id="_idIndexMarker654"/> to the solution and name it <strong class="source-inline">ParallelExample.Tests</strong>.</li>
<li>Rename the <strong class="source-inline">UnitTest1</strong> class <strong class="source-inline">TextServiceTests</strong> and add a <strong class="bold">Project </strong>reference to the <strong class="bold">ParallelExample</strong> project.</li>
<li>Next, we will add two unit tests to test the <strong class="source-inline">ProcessText</strong> method:<p class="source-code">[Fact]</p><p class="source-code">public void ProcessText_Returns_Expected_Strings()</p><p class="source-code">{</p><p class="source-code">    var service = new TextService();</p><p class="source-code">    var fruits = new List&lt;string&gt; { "apple", "orange", </p><p class="source-code">        "banana", "peach", "cherry" };</p><p class="source-code">    var results = service.ProcessText(fruits);</p><p class="source-code">    Assert.Equal(fruits.Count, results.Count);</p><p class="source-code">}</p><p class="source-code">[Fact]</p><p class="source-code">public void ProcessText_Throws_Exception_For</p><p class="source-code">    _Empty_String()</p><p class="source-code">{</p><p class="source-code">    var service = new TextService();</p><p class="source-code">    var fruits = new List&lt;string&gt; { "apple", "orange", </p><p class="source-code">        "banana", "peach", "" };</p><p class="source-code">    Assert.Throws&lt;AggregateException&gt;(() =&gt; </p><p class="source-code">        service.ProcessText(fruits));</p><p class="source-code">}</p></li>
</ol>
<p>The<a id="_idIndexMarker655"/> first test calls <strong class="source-inline">ProcessText</strong> with a list of five-string values<a id="_idIndexMarker656"/> containing fruit names. The assertion checks that <strong class="source-inline">results.Count</strong> matches <strong class="source-inline">fruits.Count</strong>. </p>
<p>The second test makes the same call, but one of the <strong class="source-inline">fruits</strong> string values is empty. This test will ensure that <strong class="source-inline">AggregateException</strong> is thrown by the <strong class="source-inline">Parallel.ForEach</strong> loop in the method under test.</p>
<ol>
<li value="7">Add two more tests. These two tests will run the same assertions on the <strong class="source-inline">ProcessTextAsync</strong> method. The difference here is that <strong class="source-inline">Assert.ThrowsAsync</strong> must check for <strong class="source-inline">Exception</strong> instead of <strong class="source-inline">AggregateExceptoin</strong> because we are using <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>:<p class="source-code">[Fact]</p><p class="source-code">public async Task ProcessTextAsync_Returns_Expected</p><p class="source-code">    _Strings()</p><p class="source-code">{</p><p class="source-code">    var service = new TextService();</p><p class="source-code">    var fruits = new List&lt;string&gt; { "apple", "orange", </p><p class="source-code">        "banana", "peach", "cherry" };</p><p class="source-code">    var results = await service.ProcessTextAsync</p><p class="source-code">         (fruits);</p><p class="source-code">    Assert.Equal(fruits.Count, results.Count);</p><p class="source-code">}</p><p class="source-code">[Fact]</p><p class="source-code">public async Task ProcessTextAsync_Throws_Exception</p><p class="source-code">    _For_Empty_String()</p><p class="source-code">{</p><p class="source-code">    var service = new TextService();</p><p class="source-code">    var fruits = new List&lt;string&gt; { "apple", "orange", </p><p class="source-code">        "banana", "peach", "" };</p><p class="source-code">    await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; </p><p class="source-code">        await service.ProcessTextAsync(fruits));</p><p class="source-code">}</p></li>
<li>Run all <a id="_idIndexMarker657"/>four tests with the <strong class="bold">Run All Tests in View</strong> button<a id="_idIndexMarker658"/> in the <strong class="bold">Text Explorer</strong> window. If the window is not visible in Visual Studio, you can open it from <strong class="bold">View</strong> | <strong class="bold">Test Explorer</strong>. All tests should pass:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer087">
<img alt="Figure 12.4 – Four tests passing in the TextServiceTests class " height="538" src="image/Figure_12.4_B18552.jpg" width="1265"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Four tests passing in the TextServiceTests class</p>
<p>You now have two tests for each of the methods for processing text in the <strong class="source-inline">TextService</strong> class. They<a id="_idIndexMarker659"/> are testing valid and invalid input data successfully. Spend some time on your <a id="_idIndexMarker660"/>own to examine how the test coverage could be expanded. What other types of input could be used?</p>
<p>In the final section of this chapter, we will examine how you can build memory leak detection into your automated unit test suite.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Checking for memory leaks with unit tests</h1>
<p>Memory leaks <a id="_idIndexMarker661"/>are by no means unique to multithreaded <a id="_idIndexMarker662"/>code, but they certainly can happen. The more code that is executing in your application, the more likely it is that some objects <a id="_idIndexMarker663"/>are going to leak. The company that makes the popular .NET tools, <strong class="bold">ReSharper</strong> and <strong class="bold">Rider</strong>, also <a id="_idIndexMarker664"/>makes a tool called <strong class="bold">dotMemory</strong> for <a id="_idIndexMarker665"/>analyzing memory leaks. While these tools are not free, JetBrains does <a id="_idIndexMarker666"/>offer its memory unit testing tool for free. It’s called <strong class="bold">dotMemory Unit</strong>.</p>
<p>In this section, we will create a dotMemory Unit test to check whether we are leaking one of our objects. You can run these dotMemory Unit tests for free with .NET on the command line by downloading the standalone test runner here: https://www.jetbrains.com/dotmemory/unit/.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about <a id="_idIndexMarker667"/>using the free tooling, you can read about it here: <a href="https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml">https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml</a>. JetBrains also has integration for dotMemory Unit in its ReSharper and Rider tools. If you have licenses for either of these tools, it greatly simplifies the process of running these tests.</p>
<p>Let’s create an <a id="_idIndexMarker668"/>example demonstrating how to create<a id="_idIndexMarker669"/> a unit test that determines whether objects are being leaked in memory by the code under test:</p>
<ol>
<li value="1">Start by creating a new <strong class="bold">Class Library</strong> project named <strong class="source-inline">MemoryExample</strong>.</li>
<li>Rename <strong class="source-inline">Class1</strong> <strong class="source-inline">WorkService</strong> and add another class named <strong class="source-inline">Worker</strong>. Add the following code to the <strong class="source-inline">Worker</strong> class. The <strong class="source-inline">DoWork</strong> method in this class will handle a <strong class="source-inline">TimerElapsed</strong> event in <strong class="source-inline">WorkService</strong>:<p class="source-code">public class Worker : IDisposable</p><p class="source-code">{</p><p class="source-code">    public void Dispose()</p><p class="source-code">    {</p><p class="source-code">        // dispose objects here</p><p class="source-code">    }</p><p class="source-code">    public void DoWork(object? sender, </p><p class="source-code">        System.Timers.ElapsedEventArgs e)</p><p class="source-code">    {</p><p class="source-code">        Parallel.For(0, 5, (x) =&gt;</p><p class="source-code">        {</p><p class="source-code">            Thread.Sleep(100);</p><p class="source-code">        });</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>This class implements <strong class="source-inline">IDisposable</strong>, so we can use it with a <strong class="source-inline">using</strong> statement <a id="_idIndexMarker670"/>elsewhere.</p>
<ol>
<li value="3">Add a <strong class="source-inline">WorkWithTimer</strong> method<a id="_idIndexMarker671"/> to the <strong class="source-inline">WorkService</strong> class:<p class="source-code">public void WorkWithTimer()</p><p class="source-code">{</p><p class="source-code">    using var worker = new Worker();</p><p class="source-code">    var timer = new System.Timers.Timer(1000);</p><p class="source-code">    timer.Elapsed += worker.DoWork;</p><p class="source-code">    timer.Start();</p><p class="source-code">    Thread.Sleep(5000);</p><p class="source-code">}</p></li>
</ol>
<p>This code has some problems that will prevent the <strong class="source-inline">worker</strong> object from being released from memory. The <strong class="source-inline">timer</strong> object is not stopped or disposed of, and the <strong class="source-inline">Elapsed</strong> event is never unhooked. When we check for leaks, we should find some.</p>
<ol>
<li value="4">Add a new <strong class="bold">xUnit Test</strong> project to the solution named <strong class="source-inline">MemoryExample.Tests</strong>.</li>
<li>Add a project reference to <strong class="bold">MemoryExample</strong> and<a id="_idIndexMarker672"/> add a <strong class="bold">NuGet package reference</strong> to <strong class="bold">JetBrains.dotMemoryUnit</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="Figure 12.5 – Referencing the dotMemoryUnit NuGet package " height="102" src="image/Figure_12.5_B18552.jpg" width="1350"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Referencing the dotMemoryUnit NuGet package</p>
<ol>
<li value="6">Rename the <strong class="source-inline">UnitTest1</strong> class in <strong class="bold">MemoryExample.Tests</strong> <strong class="source-inline">WorkServiceMemoryTests</strong> and <a id="_idIndexMarker673"/>add the<a id="_idIndexMarker674"/> following code:<p class="source-code">using JetBrains.dotMemoryUnit;</p><p class="source-code"><strong class="bold">[assembly: SuppressXUnitOutputExceptionAttribute]</strong></p><p class="source-code">namespace MemoryExample.Tests</p><p class="source-code">{</p><p class="source-code">    public class WorkServiceMemoryTests</p><p class="source-code">    {</p><p class="source-code">        [Fact]</p><p class="source-code">        public void WorkWithSquares_Releases_Memory_</p><p class="source-code">            From_Bitmaps()</p><p class="source-code">        {</p><p class="source-code">            var service = new WorkService();</p><p class="source-code">            service.WorkWithTimer();</p><p class="source-code">            <strong class="bold">GC.Collect();</strong></p><p class="source-code">            // Make sure there are no Worker </p><p class="source-code">                objects in memory</p><p class="source-code">            <strong class="bold">dotMemory.Check(m =&gt; Assert.Equal(0, </strong></p><p class="source-code"><strong class="bold">                m.GetObjects(o =&gt;</strong></p><p class="source-code"><strong class="bold">                    o.Type.Is&lt;Worker&gt;())</strong></p><p class="source-code"><strong class="bold">                        .ObjectsCount));</strong></p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>A few lines are highlighted in the previous snippet. An <strong class="source-inline">assembly</strong> attribute must be added to suppress an error in the console runner when using xUnit.net with dotMemory Unit. After calling the method under test, <strong class="source-inline">WorkWithTimer</strong>, we are <a id="_idIndexMarker675"/>calling <strong class="source-inline">GC.Collect</strong> to attempt to clean all unused managed objects from memory. Finally, <strong class="source-inline">dotMemory.Check</strong> is called to determine whether there are any objects of the <strong class="source-inline">Worker</strong> type remaining in memory.</p>
<ol>
<li value="7">Run the <a id="_idIndexMarker676"/>following command either<a id="_idIndexMarker677"/> in <strong class="bold">PowerShell</strong> or the <strong class="bold">Windows command line</strong> from the folder where you<a id="_idIndexMarker678"/> downloaded and extracted the dotMemory Unit command-line tool. If you use PowerShell, the <strong class="source-inline">.\</strong> characters are required:<p class="source-code">.\dotMemoryUnit.exe "c:\Program Files\dotnet\dotnet.exe" – test "c:\dev\net6.0\MemoryExample.Tests.dll"</p></li>
</ol>
<p>The path to .NET should be the same on your system. You will need to replace the path to <strong class="source-inline">MemoryExample.Tests.dll</strong> with your own output path where this DLL resides. The test should fail, with one <strong class="source-inline">Worker</strong> object remaining in memory, and your output will look something like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<img alt="Figure 12.6 – Reviewing the failed dotMemoryUnit test run " height="690" src="image/Figure_12.6_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Reviewing the failed dotMemoryUnit test run</p>
<ol>
<li value="8">In order<a id="_idIndexMarker679"/> to fix the problem, make the following <a id="_idIndexMarker680"/>changes to your <strong class="source-inline">WorkService.WorkWithTimer</strong> method:<p class="source-code">public void WorkWithTimer()</p><p class="source-code">{</p><p class="source-code">    using var worker = new Worker();</p><p class="source-code">    <strong class="bold">using var timer = new System.Timers.Timer(1000);</strong></p><p class="source-code">    timer.Elapsed += worker.DoWork;</p><p class="source-code">    timer.Start();</p><p class="source-code">    Thread.Sleep(5000);</p><p class="source-code"><strong class="bold">    timer.Stop();</strong></p><p class="source-code"><strong class="bold">    timer.Elapsed -= worker.DoWork;</strong></p><p class="source-code">}</p></li>
</ol>
<p>To make sure the <strong class="source-inline">worker</strong> object instance is released, we’re initializing <strong class="source-inline">timer</strong> in a <strong class="source-inline">using</strong> statement, stopping <strong class="source-inline">timer</strong> when it’s finished, and unhooking the <strong class="source-inline">timer.Elapsed</strong> event handler.</p>
<ol>
<li value="9">Now, execute<a id="_idIndexMarker681"/> the <strong class="source-inline">dotMemory</strong> Unit command again. The test should succeed now:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 12.7 – The dotMemoryUnit test runs successfully " height="692" src="image/Figure_12.7_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – The dotMemoryUnit test runs successfully</p>
<p>That <a id="_idIndexMarker682"/>concludes this example and the section on memory unit tests. If you would like to read more about dotMemory Unit, you can find its documentation here: <a href="https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml">https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml</a>. The command-line tool can also be deployed to a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) build <a id="_idIndexMarker683"/>server to execute these tests as part of a CI build process.</p>
<p>Let’s finish up by reviewing what we have learned in the final chapter of this book.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Summary</h1>
<p>In this chapter, we learned about some tools and techniques to unit test .NET projects that contain different multithreaded constructs. We started by discussing the best methods for testing C# code that employs <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>. This will be common in modern applications, and it is important to have a suite of automated unit tests covering your <strong class="source-inline">async</strong> code. </p>
<p>We also walked through some examples of unit tests that test methods that leverage parallel constructs and concurrent data structures. In the last section of the chapter, we learned about dotMemory Unit from JetBrains. This free unit testing tool adds the ability to detect objects leaked by methods under test. It is a powerful automation tool for synchronous and asynchronous .NET code.</p>
<p>This is the final chapter. Thanks for following along on this multithreading journey. Hopefully, you didn’t encounter any deadlocks or race conditions along the way. This book provided guidance for your path through the modern, multithreaded world of .NET and C#. You should now have an understanding of the asynchronous, concurrent, and parallel methods and structures to build fast and reliable .NET applications. If you want to learn more about these topics, I suggest reading the <em class="italic">.NET Parallel Programming</em> blog (<a href="https://devblogs.microsoft.com/pfxteam/">https://devblogs.microsoft.com/pfxteam/</a>) and relying on the .NET documentation (<a href="https://docs.microsoft.com/dotnet/">https://docs.microsoft.com/dotnet/</a>). You can search for documentation on any of the topics in this book to learn more.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Questions</h1>
<ol>
<li value="1">What is the keyword used in .NET attributes that decorate an <strong class="source-inline">xUnit.net</strong> test method?</li>
<li>What method can you use to add <strong class="source-inline">await</strong> to your code without locks?</li>
<li>What type of exception should you expect in unit test assertions when the method under test contains a <strong class="source-inline">Parallel.ForEach</strong> loop?</li>
<li>What type of exception should you expect in unit test assertions when the method under test contains a <strong class="source-inline">Parallel.ForEachAsync</strong> loop?</li>
<li>How can you check that an object isn’t <strong class="source-inline">null</strong> in an xUnit.net assertion?</li>
<li>What is the name of the window in Visual Studio where unit tests can be managed and run?</li>
<li>What are the three most popular unit test frameworks for .NET?</li>
<li>Which JetBrains products provide tooling to run dotMemory Unit tests?</li>
</ol>
</div>
</div>
</body></html>