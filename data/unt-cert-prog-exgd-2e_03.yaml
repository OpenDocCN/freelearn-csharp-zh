- en: '*Chapter 3*: Managing Scripts and Taking a Mock Test'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：管理脚本和进行模拟测试'
- en: In this chapter, we are going to continue structuring our game by applying a
    Singleton design pattern to our `GameManager` script. This will allow our game
    to move on to another scene while keeping the script managers functioning and
    preventing them from being wiped (thereby preserving our data). We will then make
    a start on other details of our script and observe how information (such as the
    player's lives) travels through the game's frameworks. If and when the player
    dies, a life is deducted. If and when the player loses all of their lives, the
    game over scene will be triggered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过将Singleton设计模式应用到我们的`GameManager`脚本中来继续构建我们的游戏。这将允许我们的游戏在保持脚本管理器功能的同时进入另一个场景，并防止它们被清除（从而保留我们的数据）。然后我们将开始处理脚本的其他细节，并观察信息（如玩家的生命值）是如何通过游戏框架传递的。如果玩家死亡，生命值将减少。如果玩家失去所有生命值，将触发游戏结束场景。
- en: We will be extending our original code and introducing enemy points so that
    when we hit our enemies with bullets, the enemy will disappear as usual, but will
    also generate points. This scoring mechanism will be handled by a new score manager
    that we will be creating.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的原始代码，并引入敌人得分点，这样当我们用子弹击中敌人时，敌人将像往常一样消失，同时也会生成得分。这种得分机制将由我们创建的新得分管理器来处理。
- en: We'll also be adding sound to the player's bullets, which is a straightforward
    task. This will introduce us to extending and tweaking our audio sources, which
    we'll proceed with in a later chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为玩家的子弹添加声音，这是一个简单的任务。这将使我们了解扩展和调整音频源，我们将在后面的章节中继续这一过程。
- en: Finally, we will be quizzing ourselves with a couple of questions that suit
    the theme of this book, preparing you for the exam. The questions will cover what
    we have already learned, and if you have been following along with this book,
    you'll have a strong chance of passing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过几个适合本书主题的问题来测试自己，为考试做准备。这些问题将涵盖我们已经学到的内容，如果你一直跟随本书学习，你将有很大机会通过考试。
- en: By the end of this chapter, we will have extended our game's framework, added
    more features to our game, and tested our knowledge with some Unity exam questions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将扩展我们的游戏框架，为我们的游戏添加更多功能，并通过一些Unity考试问题来测试我们的知识。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding a **Singleton** design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加**Singleton**设计模式
- en: Setting up our `ScenesManager` script
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的`ScenesManager`脚本
- en: Creating lives for the player
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家创建生命值
- en: Scoring enemy hits
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录敌人击中得分
- en: Creating sounds for the player's bullets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家的子弹创建声音
- en: Mock test
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟测试
- en: The next section will introduce the core exam skills that are covered in this
    chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍本章涵盖的核心考试技巧。
- en: The core exam skills covered in this chapter
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技巧
- en: '*Programming core interactions*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互*：'
- en: Implementing and configuring game object behavior and physics
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象行为和物理
- en: '*Programming for scene and environment design*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程场景和环境设计*：'
- en: Determining scripts for implementing audio assets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实现音频资源的脚本
- en: Identifying methods for implementing game object instantiation, destruction,
    and management
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别实现游戏对象实例化、销毁和管理的方法
- en: '*Working in professional software development teams*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*在专业软件开发团队中工作*：'
- en: Recognizing techniques for structuring scripts for modularity, readability,
    and reusability
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到结构脚本以实现模块化、可读性和可重用性的技术
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可以在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_03)找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载每个章节的项目文件的全部内容，请访问[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All content for this chapter is held in the chapter's `unitypackage` file, including
    a `Complete` folder that holds all of the work we'll be carrying out in the chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都保存在章节的`unitypackage`文件中，包括一个包含我们在本章中将要执行的所有工作的`Complete`文件夹。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3xW4Zte](https://bit.ly/3xW4Zte).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码执行情况*：[https://bit.ly/3xW4Zte](https://bit.ly/3xW4Zte)。
- en: Adding a Singleton design pattern
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加单例设计模式
- en: As you will recall, back in *Chapter 1, Setting Up and Structuring Our Project*,
    we spoke about design patterns and how useful they are for maintaining our code.
    One of the design patterns we briefly covered was the Singleton pattern. Without
    repeating ourselves, the Singleton pattern gives us global access to code that
    can then be obtained at a point in our game. So, where can we see the benefits
    of using the Singleton design pattern? Well, we could use it so that Unity always
    keeps certain scripts accessible, no matter what scene we are in. We have already
    added a lot of structuring to our game framework and we still have a couple of
    manager scripts to add, such as `ScoreManager` and `ScenesManager`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，在*第一章，设置和构建我们的项目*中，我们讨论了设计模式及其对我们代码维护的有用性。我们简要介绍的设计模式之一是单例模式。我们不重复自己，单例模式为我们提供了全局访问代码的能力，然后我们可以在游戏中的某个点获取这些代码。那么，我们可以在哪里看到使用单例设计模式的益处呢？嗯，我们可以用它来确保Unity始终保持某些脚本的可访问性，无论我们处于哪个场景。我们已经为我们的游戏框架添加了很多结构，我们仍然需要添加几个管理脚本，例如`ScoreManager`和`ScenesManager`。
- en: Now is a good time to give all of the manager scripts global access to all other
    scripts in the game. Managers give a general overview of what is going on and
    steer which way the game needs to go without getting caught up in the details
    of the other scripts that are running during gameplay.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是给所有管理脚本提供对游戏中所有其他脚本的全局访问权限的好时机。管理脚本提供了对正在发生的事情的概述，并指导游戏需要走向何方，而不会陷入游戏过程中运行的脚本细节。
- en: In our current setup, when we run the `testLevel` scene, our `GameManager` object
    is in the `GameManager` script, which sets up our scene's camera and lights, is
    no longer present.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的当前设置中，当我们运行`testLevel`场景时，我们的`GameManager`对象位于`GameManager`脚本中，它设置了场景的相机和灯光，现在不再存在。
- en: To stop our `GameManager` game object and script from being wiped, we are going
    to add a Singleton design pattern so that our `GameManager` script will always
    be in the scene. This design pattern will also make it so that there is only one
    `GameManager` script (which is where this design pattern gets its name from).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的`GameManager`游戏对象和脚本被清除，我们将添加一个单例设计模式，这样我们的`GameManager`脚本将始终存在于场景中。这种设计模式还将确保只有一个`GameManager`脚本（这也是这种设计模式得名的原因）。
- en: 'In the following instructions, we will extend our original `GameManager` code
    to work as a Singleton script. Double-click on the `GameManager` script and let''s
    make a start:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下说明中，我们将扩展我们的原始`GameManager`代码，使其作为一个单例脚本工作。双击`GameManager`脚本，让我们开始吧：
- en: 'At the beginning of the class, we need to add a `static` variable and a `public
    static` property, both referring to our `GameManager` script:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在课程开始时，我们需要添加一个`static`变量和一个`public static`属性，它们都指向我们的`GameManager`脚本：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The reason we do this is that `static` means there is only one type of game
    manager. This is what we want; we don't want to have multiple instances of the
    same manager.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因是`static`意味着只有一个类型的游戏管理器。这正是我们想要的；我们不希望有相同管理器的多个实例。
- en: Next, we need to check and assign our `instance` variable with the `GameManager`
    class when the script begins with the `Awake` function.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在脚本开始时的`Awake`函数中检查并分配我们的`instance`变量到`GameManager`类。
- en: The `Awake` function ends with a Unity function called `DontDestroyOnLoad`.
    This will make sure the game object holding our `GameManager` class will not be
    destroyed if the scene changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake`函数以Unity函数`DontDestroyOnLoad`结束。这将确保包含我们的`GameManager`类的游戏对象在场景改变时不会被销毁。'
- en: Tip
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the player dies and loses all their lives, we can move from the level scene
    we are on to the `gameOver` scene, but we won't wipe the `GameManager` game object
    from the scene as this holds the main core methods to run the game.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家死亡并失去所有生命，我们可以从当前所在的关卡场景移动到`gameOver`场景，但不会从场景中清除`GameManager`游戏对象，因为这个对象包含了运行游戏的主要核心方法。
- en: 'Add an `else` loop to prevent any possible duplicate `GameManager` game objects.
    We can see these two steps in the following code block:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`else`循环以防止出现任何可能的重复`GameManager`游戏对象。我们可以在以下代码块中看到这两个步骤：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make our code easier to identify, wrap the code we just typed out in the
    `Awake` function and put it in a method called `CheckGameManagerIsInTheScene`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的代码更容易识别，我们将刚刚输入的代码包裹在`Awake`函数中，并将其放入一个名为`CheckGameManagerIsInTheScene`的方法中。
- en: Call the method from the `Awake` function.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Awake`函数中调用该方法。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: 'A similar method to `DontDestroyOnLoad` is `MoveGameObjectToScene`, which can
    be used to carry a single game object over to another scene. This could be useful
    for moving a player from one scene to another: [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html).'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`DontDestroyOnLoad`类似的方法是`MoveGameObjectToScene`，它可以用来将单个游戏对象携带到另一个场景。这可以用于将玩家从一个场景移动到另一个场景：[https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.MoveGameObjectToScene.html)。
- en: 'That''s it, our Singleton design pattern is done! The following screenshot
    shows a snippet of what our `GameManager` script should look like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的单例设计模式就完成了！以下截图显示了我们的`GameManager`脚本应该看起来像什么：
- en: '![Figure 3.1 – Singleton code pattern in our GameManager script'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 在我们的GameManager脚本中的单例代码模式]'
- en: '](img/Figure_3.01_B18381.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.01_B18381.jpg)'
- en: Figure 3.1 – Singleton code pattern in our GameManager script
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 在我们的GameManager脚本中的单例代码模式
- en: Finally, save the `GameManager` script.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存`GameManager`脚本。
- en: We have created a Singleton design pattern that will not be wiped away when
    we alternate through the scenes in our game, giving us global control of our game
    no matter which scene we are in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个单例设计模式，它不会在我们游戏中的场景之间切换时被清除，无论我们在哪个场景中，都能给我们提供全局控制游戏的能力。
- en: Now, we can jump into adding the `ScenesManager` script and attaching it to
    the same game object as `GameManager` (in its **Inspector** window).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加`ScenesManager`脚本并将其附加到与`GameManager`相同的游戏对象（在其**检查器**窗口中）。
- en: Setting up our ScenesManager script
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们的场景管理器脚本
- en: 'We will take some responsibility away from the `GameManager` script by making
    another manager script to be more consistent with the data and methods it holds.
    `ScenesManager` will take and send information to and from `GameManager`. The
    following diagram shows how close to `GameManager` our `ScenesManager` script
    is within the framework when only communicating with `GameManager`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建另一个管理脚本，我们将从`GameManager`脚本中分担一些责任，使其与它持有的数据和方法的保持一致性。`ScenesManager`将接收和发送信息到`GameManager`。以下图表显示了当只与`GameManager`通信时，我们的`ScenesManager`脚本在框架中与`GameManager`的接近程度：
- en: '![Figure 3.2 – ScenesManager location in the Killer Wave UML'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – ScenesManager在Killer Wave UML中的位置]'
- en: '](img/Figure_3.02_B18381.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.02_B18381.jpg)'
- en: Figure 3.2 – ScenesManager location in the Killer Wave UML
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – ScenesManager在Killer Wave UML中的位置
- en: The purpose of `ScenesManager`, apart from taking the workload off `GameManager`,
    is to deal with anything related to creating or changing a scene. This doesn't
    mean we only focus on adding and removing game levels; a scene can also consist
    of a start up logo, a title screen, a menu, and a game over screen, all of which
    are part of the `ScenesManager` script's responsibility.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScenesManager`的目的，除了减轻`GameManager`的工作负担外，还包括处理与创建或更改场景相关的任何内容。这并不意味着我们只关注添加和删除游戏关卡；一个场景还可以包括启动标志、标题屏幕、菜单和游戏结束屏幕，所有这些都是`ScenesManager`脚本责任的一部分。'
- en: In this section, we will be setting up a scene template and two methods. The
    first method will be responsible for resetting the level if the player dies (`ResetScene()`);
    the second will be the game over screen (`GameOver()`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置一个场景模板和两个方法。第一个方法将负责在玩家死亡时重置关卡（`ResetScene()`）；第二个方法将是游戏结束屏幕（`GameOver()`）。
- en: 'Let''s make a start by creating a new script in the same way that we did in
    [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,* *Adding and Manipulating
    Objects*. Follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以与[*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048)*,* *添加和操作对象*相同的方式开始，创建一个新的脚本。按照以下步骤操作：
- en: Name the script `ScenesManager`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为`ScenesManager`。
- en: Add the script to the `GameManager` game object. If you need further details
    on adding a script to a game object, check out the *Adding our script to a game
    object* section of the previous chapter.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本添加到`GameManager`游戏对象中。如果您需要有关将脚本添加到游戏对象的更多详细信息，请查看上一章的*将我们的脚本添加到游戏对象*部分。
- en: 'With our `GameManager` game object selected from the `GameManager` and `ScenesManager`
    scripts attached, as shown in the following screenshot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GameManager`和`ScenesManager`脚本中选择`GameManager`游戏对象，如图下所示：
- en: '![Figure 3.3 – GameManager game object holding two scripts (GameManager and
    ScenesManager)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 包含两个脚本（GameManager和ScenesManager）的游戏管理器游戏对象](img/Figure_3.3_B18381.jpg)'
- en: '](img/Figure_3.03_B18381.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.03_B18381.jpg](img/Figure_3.03_B18381.jpg)'
- en: Figure 3.3 – GameManager game object holding two scripts (GameManager and ScenesManager)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 包含两个脚本（GameManager和ScenesManager）的游戏管理器游戏对象](img/Figure_3.3_B18381.jpg)'
- en: 'Let''s open the `ScenesManager` script and start coding:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`ScenesManager`脚本并开始编码：
- en: 'Because we are obviously going to be closing and loading scenes, we are going
    to need to import an extra library into our `ScenesManager` script that supports
    these operations:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们显然将要关闭和加载场景，所以我们需要在我们的`ScenesManager`脚本中导入一个额外的库来支持这些操作：
- en: '[PRE2]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will have a public class in our script name, followed by the usual `MonoBehaviour`
    being inherited:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们将有一个公共类，后面跟着通常继承的`MonoBehaviour`：
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we need to create a list of references for our scenes, as mentioned earlier.
    I currently have the following scenes labeled:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个场景引用列表，正如之前提到的。我目前有以下场景标记：
- en: '`bootUp`: Credits to game'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootUp`：游戏信用'
- en: '`title`: Name of the game with an instruction to start'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：游戏名称，带有开始指令'
- en: '`shop`: Buy upgrades before starting the game'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shop`：在开始游戏前购买升级'
- en: '`level1`: First level'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1`：第一级'
- en: '`level2`: Second level'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2`：第二级'
- en: '`level3`: Final level'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level3`：最终级'
- en: '`gameOver`: Game over—delays until going back to the title scene'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameOver`：游戏结束—延迟直到返回标题场景'
- en: We will be labeling these scenes as enumerations (which are denoted as `enum`
    in the C# language). These values stay consistent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些场景标记为枚举（在C#语言中用`enum`表示）。这些值保持一致。
- en: Tip
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you would like to know more about enumeration, check out [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于枚举的信息，请查看[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)。
- en: 'Enter the following code into the `ScenesManager` script:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到`ScenesManager`脚本中：
- en: '[PRE4]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be making and adding these scenes in their respective order in the Unity
    Editor later on in the book. Before we do so, let's add two methods, starting
    with the `ResetScene()` method, which is typically used when the player dies and
    the current level is reloaded. The other method, `GameOver()`, is typically called
    when the player loses all of their lives or when the game is complete.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书后面的Unity编辑器中按顺序创建并添加这些场景。在我们这样做之前，让我们添加两个方法，从`ResetScene()`方法开始，这通常用于玩家死亡并且当前关卡重新加载时。另一个方法`GameOver()`通常在玩家失去所有生命或游戏完成时调用。
- en: Adding the ResetScene() method
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`ResetScene()`方法
- en: The `ResetScene()` method will be called when the player loses a life but still
    has another remaining. In this short method, we will set its accessibility to
    `public` and it returns nothing (`void`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家失去一条生命但仍有剩余时，将会调用`ResetScene()`方法。在这个简短的方法中，我们将将其可访问性设置为`public`，并且它不返回任何内容（`void`）。
- en: Within this method, we will refer to Unity's `SceneManager` script (not to be
    confused with our `ScenesManager` class), followed by Unity's `LoadScene` method.
    We now need to provide a parameter to tell `LoadScene` which scene we are going
    to load.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将引用Unity的`SceneManager`脚本（不要与我们的`ScenesManager`类混淆），然后是Unity的`LoadScene`方法。我们现在需要提供一个参数来告诉`LoadScene`我们将加载哪个场景。
- en: 'We use Unity''s `SceneManager` script again, but this time we use `GetActiveScene().buildIndex`,
    which basically means getting the value number of the scene. We send this scene
    number to `SceneManager` to load the scene again (`LoadScene`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用Unity的`SceneManager`脚本，但这次我们使用`GetActiveScene().buildIndex`，这基本上意味着获取场景的值编号。我们将这个场景编号发送到`SceneManager`以重新加载场景（`LoadScene`）：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A small but effective method, this can be called whenever we need the scene
    to reset. Let's now move on to the `GameOver()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小巧但有效的方法，可以在我们需要场景重置时随时调用。现在，让我们继续到`GameOver()`方法。
- en: Adding the GameOver() method
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`GameOver()`方法
- en: This method, as you may expect, is called when the player has lost all of their
    lives and the game ends, which means we need to move the player on to another
    scene.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，这个方法在玩家失去所有生命并且游戏结束时被调用，这意味着我们需要将玩家移动到另一个场景。
- en: 'In this method, we continue adding to the `ScenesManager` script:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们继续向`ScenesManager`脚本中添加内容：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the previous method, we refer to this method as `public` with `void
    return`. Within the method, we call the same Unity function, `SceneManager.LoadScene`,
    but this time, we call the `SceneManager` Unity function, followed by the name
    of the scene we want to load by name (in this case, `gameOver`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法类似，我们将此方法称为 `public` 并具有 `void return` 返回类型。在方法内部，我们调用相同的 Unity 函数 `SceneManager.LoadScene`，但这次我们调用
    `SceneManager` Unity 函数，然后通过名称调用我们想要加载的场景（在这种情况下，`gameOver`）。
- en: More Information
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: '`SceneManager.LoadScene` also offers a `LoadSceneMode` function, which gives
    us the option of using one of two properties. By default, the first property is
    `Single`, which closes all the scenes and loads the scene we want. The second
    property is `Additive`, which adds the next scene alongside the current one. This
    could be useful when swapping out scenes, such as a loading screen, or keeping
    the previous scene''s settings. For more information about `LoadScene`, check
    out [https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html](https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneManager.LoadScene` 还提供了一个 `LoadSceneMode` 函数，它为我们提供了使用两个属性之一的选择。默认情况下，第一个属性是
    `Single`，它关闭所有场景并加载我们想要的场景。第二个属性是 `Additive`，它将下一个场景添加到当前场景旁边。这在交换场景时可能很有用，例如加载屏幕，或者保持前一个场景的设置。有关
    `LoadScene` 的更多信息，请参阅 [https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html](https://docs.unity3d.com/ScriptReference/SceneManagement.LoadSceneMode.html)。'
- en: That's our `GameOver()` method made, and when used in the same way as our `ResetScene()`
    method, it can be called globally. `GameOver()` can be called not only when the
    player loses all their lives but also when the user completes the game. It can
    also be used if, somehow, the game crashes, and as a default reset, we proceed
    to the `gameOver` scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GameOver()` 方法已经制作完成，并且当以与我们的 `ResetScene()` 方法相同的方式使用时，它可以全局调用。`GameOver()`
    不仅可以在玩家失去所有生命时调用，也可以在用户完成游戏时调用。如果游戏意外崩溃，它也可以用作默认的重置，我们将进入 `gameOver` 场景。
- en: The next method to bring into our `ScenesManager` script is `BeginGame()`. This
    method is called when we need to start playing our game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要添加到 `ScenesManager` 脚本中的方法是 `BeginGame()`。当我们需要开始玩游戏时，将调用此方法。
- en: Adding the BeginGame() method
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `BeginGame()` 方法
- en: In this short section, we will add the `BeginGame()` method to our `ScenesManager`
    script as this will be called to start playing our game after visiting the `shop`
    scene, which we will cover in [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107)*,*
    *Creating a Shop Scene for Our Game*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向 `ScenesManager` 脚本添加 `BeginGame()` 方法，因为这将在我们访问 `shop` 场景后调用，我们将在
    [*第五章*](B18381_05_Epub.xhtml#_idTextAnchor107)*，* *为我们的游戏创建商店场景* 中介绍。
- en: 'With the `ScenesManager` script still open from the previous section, add the
    following method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中仍然打开的 `ScenesManager` 脚本中，添加以下方法：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code that we have just entered makes a direct call to run the `testLevel`
    scene, which we play our game in already. However, as our game begins to grow,
    we will use more than one scene.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚输入的代码直接调用以运行 `testLevel` 场景，这是我们玩游戏的地方。然而，随着我们的游戏开始增长，我们将使用多个场景。
- en: The next thing to do is to create our scenes and add them to the Unity build
    menu, so let's do that next. Remember to save the `ScenesManager` script before
    returning to the Unity Editor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的场景并将它们添加到 Unity 构建菜单中，所以让我们继续这样做。记得在返回 Unity 编辑器之前保存 `ScenesManager`
    脚本。
- en: Adding scenes to our Build Settings window
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景添加到我们的构建设置窗口
- en: 'Our game will consist of multiple scenes through which the player will need
    to navigate before they can fly their spaceship through the levels. This will
    result in them either dying or completing each level and the game, and then being
    taken back to the `title` scene. This is also known as a game loop. Let''s start
    by going back to Unity and, in the Project window, creating and adding our new
    scenes. Follow these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将包含多个场景，玩家需要在这些场景中导航，然后才能通过关卡飞行他们的宇宙飞船。这将导致他们死亡或完成每个关卡和游戏，然后被带回到 `title`
    场景。这也被称为游戏循环。让我们回到 Unity，在项目窗口中创建和添加我们的新场景。按照以下步骤操作：
- en: Go to the `Assets/Scene` folder that we created at the beginning of the previous
    chapter.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们在上一章开头创建的 `Assets/Scene` 文件夹。
- en: 'Inside the **Scene** folder, in the open space, right-click so that the dropdown
    appears, and then click **Create**, followed by **Scene**, as shown in the following
    screenshot:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Scene** 文件夹内部，在空白区域右键单击，以便出现下拉菜单，然后点击 **Create**，接着点击 **Scene**，如以下截图所示：
- en: '![Figure 3.4 – Creating an empty scene in the Unity Editor'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 在Unity编辑器中创建一个空场景'
- en: '](img/Figure_3.04_B18381.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B18381.jpg)'
- en: Figure 3.4 – Creating an empty scene in the Unity Editor
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 在Unity编辑器中创建一个空场景
- en: A scene file will appear. Rename it `bootUp`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个场景文件。将其重命名为`bootUp`。
- en: Repeat this process for the `shop`, `level1`, `level2`, `level3`, `gameOver`,
    and `title` scene files.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`shop`、`level1`、`level2`、`level3`、`gameOver`和`title`场景文件重复此过程。
- en: 'Once we have made all of our scenes, we need to let Unity know that we want
    these scenes to be recognized and applied to the project build order. This is
    a similar process to what we did in the last chapter when adding `testLevel` to
    the **Build Settings** window. To apply the other scenes to the list, do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们制作了所有场景，我们需要让Unity知道我们希望这些场景被识别并应用于项目构建顺序。这与我们在上一章中向**构建设置**窗口添加`testLevel`时的过程类似。要将其他场景应用到列表中，请执行以下操作：
- en: From the top of the Unity Editor, click on **File** | **Build Settings**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity编辑器的顶部，点击**文件** | **构建设置**。
- en: The `testLevel` in the list already. If you don't, fear not as we will be adding
    all our scenes to the **Scenes In Build** list.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表中已经有`testLevel`。如果没有，请不要担心，我们将在**场景在构建**列表中添加所有我们的场景。
- en: From the **Project** window, click and drag each scene into the **Build Settings
    | Scenes** **in** **Build** open space.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口，点击并拖动每个场景到**构建设置 | 场景** **在** **构建**开放空间中。
- en: 'Once we have added all the scenes, order them as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了所有场景，按照以下顺序排列它们：
- en: '`bootUp`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootUp`'
- en: '`title`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`'
- en: '`shop`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shop`'
- en: '`testLevel`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testLevel`'
- en: '`level1`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1`'
- en: '`level2`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2`'
- en: '`level3`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level3`'
- en: '`gameOver`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameOver`'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Note that each scene automatically has a camera and a light by default in its
    **Hierarchy** window. This is fine and we will customize them later on in this
    book.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，每个场景默认在其**层次**窗口中都有一个相机和一盏灯。这很好，我们将在本书的后面部分对其进行自定义。
- en: 'The **Build Settings** window should now look as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建设置**窗口现在应该如下所示：'
- en: '![Figure 3.5 – Build Settings current Scenes In Build list order'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 构建设置当前场景在构建列表中的顺序'
- en: '](img/Figure_3.05_B18381.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B18381.jpg)'
- en: Figure 3.5 – Build Settings current Scenes In Build list order
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 构建设置当前场景在构建列表中的顺序
- en: The reason why we are putting our scenes in this order is so that there is a
    logical progression in the levels. As you can see at the far right of each scene
    in the previous screenshot, the scenes are counted in increments. So, the first
    level to load will be the `bootUp` scene.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将场景按此顺序放置的原因是为了使层级之间有一个逻辑上的递进。如图3.4中所示，您可以看到每个场景的右侧，场景是按增量计算的。因此，第一个要加载的场景将是`bootUp`场景。
- en: Now that we have added multiple scenes to our game, we can consider the fact
    that we may not want our camera and light setup methods in our `GameManager` method
    to run in every scene of our game. Let's briefly return to our `GameManager` script
    and update our `LightSetup` and `CameraSetup` methods, as well as a few other
    things.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为游戏添加了多个场景，我们可以考虑这样一个事实：我们可能不希望我们的`GameManager`方法中的相机和灯光设置方法在游戏的每个场景中运行。让我们简要回顾一下我们的`GameManager`脚本，并更新我们的`LightSetup`和`CameraSetup`方法，以及一些其他内容。
- en: Updating our GameManager script
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新我们的`GameManager`脚本
- en: In this section, we are going to return to the `GameManager` script and make
    it so that the `CameraSetup` and `LightSetup` methods are called when we are controlling
    our spaceship only.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回到`GameManager`脚本，并使其在控制我们的宇宙飞船时调用`CameraSetup`和`LightSetup`方法。
- en: 'To update our `GameManager` script to support various scenes for our lights
    and camera, we need to do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新我们的`GameManager`脚本以支持各种场景的灯光和相机，我们需要执行以下操作：
- en: In the Unity Editor, navigate to `Assets/Script` from the **Project** window.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，从**项目**窗口导航到`Assets/Script`。
- en: In the `GameManager` script, scroll down to the `Start` function and remove
    the `LightSetup();` and `CameraSetup();` methods.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameManager`脚本中，向下滚动到`Start`函数，并移除`LightSetup();`和`CameraSetup();`方法。
- en: 'Next, we will enter two static global variables at the top of the `GameManager`
    script with the rest of the global variables:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`GameManager`脚本的顶部输入两个静态全局变量，与其它全局变量一起：
- en: '[PRE8]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`currentScene` is an integer that will keep the number of the current scene
    we are on, which we will use in the following method. The second variable, `gameLevelScene`,
    will hold the first level we play, which we will use later on in this chapter.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentScene`是一个整数，它将保持当前场景的编号，我们将在以下方法中使用它。第二个变量`gameLevelScene`将保存我们玩的第一级，我们将在本章后面使用它。'
- en: 'Still in the `GameManager` script, create an `Awake` function and enter the
    following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `GameManager` 脚本中，创建一个 `Awake` 函数并输入以下代码：
- en: '[PRE9]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the code we just entered, we store the `buildIndex` number (the numbers we
    have to the right of each scene in our Build Settings window from the previous
    section) in the `currentScene` variable. We then send the `currentScene` value
    to our new `LightandCameraSetup` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚输入的代码中，我们将 `buildIndex` 数字（上一节中从我们的 Build Settings 窗口中每个场景右侧的数字）存储在 `currentScene`
    变量中。然后我们将 `currentScene` 的值发送到我们新的 `LightandCameraSetup` 方法。
- en: 'The last piece of code to add to our `GameManager` script is the `LightandCameraSetup`
    method, which takes an integer parameter:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加到 `GameManager` 脚本中的最后一部分代码是 `LightandCameraSetup` 方法，它接受一个整型参数：
- en: '[PRE10]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code we just wrote, we ran a `switch` statement to check the value of
    the `sceneNumber` variable, and if it falls into the `3`, `4`, `5`, or `6` values,
    we run `LightSetup` and `CameraSetup`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚编写的代码中，我们运行了一个 `switch` 语句来检查 `sceneNumber` 变量的值，如果它落入 `3`、`4`、`5` 或 `6`
    的值，我们将运行 `LightSetup` 和 `CameraSetup`。
- en: Save the `GameManager` script.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `GameManager` 脚本。
- en: To reflect on this section, we have created a structure of empty scenes that
    will each serve a purpose in our game. We have also created a `ScenesManager`
    script that will either reset a scene when the player wins or dies and/or move
    to the game over scene.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 反思这一部分，我们创建了一个空场景的结构，每个场景都将在我们游戏中发挥其作用。我们还创建了一个 `ScenesManager` 脚本，当玩家获胜或死亡时，它将重置场景，或者移动到游戏结束场景。
- en: Now that we have our scenes in place and the start of the `ScenesManager` script
    has been built, we can focus on the player's life system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了场景并构建了 `ScenesManager` 脚本的开始，我们可以专注于玩家的生命系统。
- en: Creating lives for the player
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为玩家创建生命
- en: In this section, we are going to make it so that the player has a set number
    of lives. If and when the player collides with an enemy, the player will die,
    the scene will reset, and a life will be deducted from the player. When all the
    lives are gone, we will introduce the game over scene.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使玩家拥有一定数量的生命。如果玩家与敌人碰撞，玩家将死亡，场景将重置，并从玩家那里扣除一条生命。当所有生命都耗尽时，我们将引入游戏结束场景。
- en: 'We will be working with the following scripts in this section:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下脚本：
- en: '`GameManager`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameManager`'
- en: '`SceneManager`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SceneManager`'
- en: '`Player`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`'
- en: 'Let''s start by revisiting the `GameManager` script and setting up the ability
    to give and take the player''s lives:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下 `GameManager` 脚本，并设置给予和扣除玩家生命的功能：
- en: 'Open the `GameManager` script and enter the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameManager` 脚本并输入以下代码：
- en: '[PRE11]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the top of the script, just after entering the class and inheritance, enter
    a `static` (meaning only one) integer type labeled `playerLives`, along with the
    value `3`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部，在输入类和继承之后，输入一个 `static`（意味着只有一个）整型变量 `playerLives`，并赋予其值 `3`。
- en: Next, we need to create a new method for our `GameManager` script that will
    ensure the player loses a life. After we make this new method, the `Player` script
    will call it when it makes contact with an enemy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为 `GameManager` 脚本创建一个新的方法，以确保玩家失去一条生命。在我们创建这个新方法之后，`Player` 脚本将在与敌人接触时调用它。
- en: Let's continue with our `GameManager` script.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的 `GameManager` 脚本。
- en: 'To create the `LifeLost` method, enter the following code in our `GameManager`
    class:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 `LifeLost` 方法，在我们的 `GameManager` 类中输入以下代码：
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need this to be a `public` method so that it can be accessed from outside
    of the script. It's set to `void`, meaning nothing is returned from the method,
    and it's followed by the name of the method with empty brackets as it isn't taking
    any arguments.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个方法是一个 `public` 方法，以便可以从脚本外部访问。它被设置为 `void`，意味着该方法不返回任何内容，并且后面跟着方法名，括号内为空，因为它不接受任何参数。
- en: 'So, within the `LifeLost()` method, we will check the player''s lives with
    an `if` statement with the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在 `LifeLost()` 方法中，我们将使用以下代码的 `if` 语句检查玩家的生命值：
- en: '[PRE13]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After reviewing the `if` statement code we have entered, we will make a start
    by adding a comment to let ourselves or other developers know what this condition
    is doing (`//lose life`). We will then add the `if` statement condition, checking
    whether the player has more than or equal to one life left. If the player does
    have one or more lives left, we will deduct the player's lives by 1 with the `--`
    operator, which is just a quicker way of saying `playerLives = playerLives - 1;`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了我们输入的`if`语句代码后，我们将通过添加注释来开始，以便让我们或其他开发者知道这个条件正在做什么（`//lose life`）。然后我们将添加`if`语句条件，检查玩家是否剩下至少一条生命。如果玩家确实还有一条或多条生命，我们将使用`--`运算符从玩家的生命值中减去1，这仅仅是一种更快地说`playerLives
    = playerLives - 1;`的方式。
- en: 'The line of code following on from the deduction of the player''s lives isn''t
    required, but it will notify us, in the Unity Editor **Console** window, with
    an information box telling us how many lives the player has left (for debugging
    purposes), as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在扣除玩家生命值之后的代码行是不必要的，但它将在Unity编辑器的**控制台**窗口中通知我们，通过一个信息框告诉我们玩家剩余多少生命（用于调试目的），如下面的截图所示：
- en: '![Figure 3.6 – Console window displaying how many lives the player has left'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 控制台窗口显示玩家剩余的生命数'
- en: '](img/Figure_3.06_B18381.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B18381.jpg)'
- en: Figure 3.6 – Console window displaying how many lives the player has left
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 控制台窗口显示玩家剩余的生命数
- en: Following on from displaying how many lives the player has left in the `ScenesManager`
    script, which is attached to the `GameManager` game object. We can use `GetComponent`
    to access the `ScenesManager` script's `ResetScene` method, which will reset our
    scene.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScenesManager`脚本中显示玩家剩余生命数之后，该脚本附加到`GameManager`游戏对象。我们可以使用`GetComponent`来访问`ScenesManager`脚本的`ResetScene`方法，这将重置我们的场景。
- en: 'We will now enter the `else` condition, which indicates that the player has
    died:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将进入`else`条件，这表示玩家已经死亡：
- en: '[PRE14]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If our player doesn't have any more lives left, that means the `if` statement
    condition isn't met, so we can then offer an `else` condition. Within the scope
    of our `else` statement, we reset our player's lives back to `3`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的玩家没有剩余生命，这意味着`if`语句条件没有满足，因此我们可以提供一个`else`条件。在我们的`else`语句范围内，我们将玩家的生命值重置为`3`。
- en: We then access the `GameOver()` method from the `ScenesManager` class, which
    will take us from the scene we are on over to the `gameOver` scene.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后从`ScenesManager`类中访问`GameOver()`方法，这将带我们从当前场景跳转到`gameOver`场景。
- en: 'Lastly, all that we need to do now is to make our `Player` script call the
    `LifeLost` method when the player has collided with the enemy or the enemy''s
    bullets:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在需要做的是让我们的`Player`脚本在玩家与敌人或敌人的子弹碰撞时调用`LifeLost`方法：
- en: Save the `GameManager` script.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`GameManager`脚本。
- en: From the `Player` script (`Assets/Script`).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Player`脚本（`Assets/Script`）开始。
- en: Scroll down to its `Die` method.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到其`Die`方法。
- en: 'Starting from above the destroy line (`Destroy(this.gameObject);`), enter the
    following code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Destroy(this.gameObject);`这一行开始，输入以下代码：
- en: '[PRE15]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we can call the `GameManager` script directly without finding the
    game object in the scene by using code such as `GetComponent` to acquire a script.
    This is the power of using the Singleton design pattern, calling directly to the
    `LifeLost` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以直接通过使用`GetComponent`等代码调用`GameManager`脚本，而无需在场景中找到游戏对象来获取脚本。这是使用Singleton设计模式的强大之处，可以直接调用`LifeLost`方法。
- en: Save the `Player` script.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`Player`脚本。
- en: Press **Play** in the Unity Editor and collide with an enemy.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中按**Play**键并碰撞敌人。
- en: The level should reset with a message in the `testLevel` to `gameOver`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testLevel`中将等级重置为`gameOver`的消息。
- en: 'The following screenshot shows the `testLevel` to the `gameOver` scene:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从`testLevel`到`gameOver`场景的转换：
- en: '![Figure 3.7 – Players lives being depleted and the gameOver scene being loaded'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 玩家生命值减少和加载游戏结束场景'
- en: '](img/Figure_3.07_B18381.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B18381.jpg)'
- en: Figure 3.7 – Players lives being depleted and the gameOver scene being loaded
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 玩家生命值减少和加载游戏结束场景
- en: With minimal code, we have now made it so that our player has a number of lives.
    We have introduced a `ScenesManager` script into our game framework that talks
    directly to `GameManager`, regardless of restarting and changing scenes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最少的代码，我们现在让我们的玩家拥有一定数量的生命。我们向游戏框架中引入了一个`ScenesManager`脚本，该脚本直接与`GameManager`通信，无论重启和更改场景。
- en: As a side note, you might have noticed that when we changed to the `gameOver`
    scene, our `GameManager` game object was carried over into the `gameOver` scene.
    If you recall the *Adding a Singleton design pattern* section, we set up the `CheckGameManagerIsInTheScene`
    method, which is called in the `Awake` function. This means that just because
    we are in a different scene, it doesn't mean the `Awake` function is called again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，您可能已经注意到，当我们切换到`gameOver`场景时，我们的`GameManager`游戏对象被带到了`gameOver`场景中。如果您还记得*添加
    Singleton 设计模式*部分，我们设置了`CheckGameManagerIsInTheScene`方法，该方法在`Awake`函数中被调用。这意味着仅仅因为我们处于不同的场景，并不意味着`Awake`函数会被再次调用。
- en: Information
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Remember, the `Awake` function will only run when the script is active and will
    only run once, even if the script is attached to a game object and is carried
    through scenes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Awake`函数只有在脚本激活时才会运行，并且只会运行一次，即使脚本附加到游戏对象并通过场景传递。
- en: This is because our `gameOver` scene only carried the `GameManager` game object
    over to the `gameOver` scene. It wasn't activated, which means the `Awake` function
    wasn't called.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的`gameOver`场景只把`GameManager`游戏对象带到了`gameOver`场景中。它没有被激活，这意味着`Awake`函数没有被调用。
- en: We have our basic lives and scene structure, and we have also used the **Console**
    window to help us acknowledge the changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们基本的生命和场景结构，并且我们也使用了**控制台**窗口来帮助我们确认变化。
- en: 'Before we move on, you may notice that when the player dies, the lights get
    darker in the scene. The following screenshot shows what I mean:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，您可能会注意到，当玩家死亡时，场景中的灯光会变暗。以下截图展示了我的意思：
- en: '![Figure 3.8 – Lights have darkened in our game'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 游戏中的灯光变暗'
- en: '](img/Figure_3.08_B18381.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.08_B18381.jpg)'
- en: Figure 3.8 – Lights have darkened in our game
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 游戏中的灯光变暗
- en: As you can see in the previous screenshot, on the left is the scene we start
    with, and on the right is the scene when the player has died. To fix this, we
    just need to make it so that we generate our lighting manually instead of it being
    autogenerated by Unity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，左边是我们开始时的场景，右边是玩家死亡时的场景。为了解决这个问题，我们只需要手动生成我们的灯光，而不是让 Unity 自动生成。
- en: 'To prevent our lighting from going dark between scenes, we need to do the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的灯光在场景之间变暗，我们需要做以下事情：
- en: At the top of the Unity Editor, click on **Window** | **Lighting** | **Settings**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的顶部，点击**窗口** | **灯光** | **设置**。
- en: 'The **Lighting Settings** window will appear. At the bottom of the window,
    uncheck **Auto Generate** and click on the button next to it, **Generate Lighting**.
    Use the following screenshot for reference:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**灯光设置**窗口将出现。在窗口底部，取消选中**自动生成**，然后点击旁边的按钮，**生成灯光**。以下截图供您参考：'
- en: '![Figure 3.9 – Unchecked Auto Generate box and the Generate Lighting button'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 未选中的自动生成框和生成灯光按钮'
- en: '](img/Figure_3.09_B18381.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.09_B18381.jpg)'
- en: Figure 3.9 – Unchecked Auto Generate box and the Generate Lighting button
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 未选中的自动生成框和生成灯光按钮
- en: This will take a minute as Unity will be setting up the new light settings.
    Once this is done, save the Unity project and that should fix it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将需要一点时间，因为 Unity 将设置新的灯光设置。一旦完成，保存 Unity 项目，应该就能解决这个问题。
- en: Note that we will likely need to set the lighting manually for other scenes,
    such as the other levels and the `shop` scene, later on in this book.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可能需要在本书后面的其他场景中手动设置灯光，例如其他关卡和`shop`场景。
- en: Let's now turn our focus to the enemy and add some functionality so that when
    it is destroyed by the player, we can add a score to `ScoreManager`, which is
    a new script that we will be making next.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将注意力转向敌人，并添加一些功能，以便当它被玩家摧毁时，我们可以将分数添加到`ScoreManager`中，这是一个我们将要制作的新的脚本。
- en: Scoring enemy hits
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记分敌人击中
- en: 'As with most games, we need a scoring system to show how well the player has
    done at the end of the game. Typically, with side-scrolling shooter games, the
    player is rewarded for each kill they make. If we turn to our game framework diagram,
    we can see that `ScoreManager` is hooked up to `GameManager` like `ScenesManager`
    was:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数游戏一样，我们需要一个计分系统来显示玩家在游戏结束时的表现。通常，在侧滚动射击游戏中，玩家每击杀一次都会得到奖励。如果我们转向我们的游戏框架图，我们可以看到`ScoreManager`与`GameManager`连接，就像`ScenesManager`一样：
- en: '![Figure 3.10 – Killer Wave UML'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 杀手波 UML'
- en: '](img/Figure_3.10_B18381.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B18381.jpg)'
- en: Figure 3.10 – Killer Wave UML
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 杀手波 UML
- en: Our code for adding a scoring system will once again be minimal. We also want
    flexibility so that different enemies are worth different points. We also want
    it so that when we add another enemy to our game with a different scoring point,
    we can avoid altering our code each time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加评分系统的代码将再次是最小的。我们还想保持灵活性，以便不同的敌人有不同的得分。我们还希望，当我们向游戏中添加具有不同得分点的另一个敌人时，我们可以避免每次都更改我们的代码。
- en: 'We will be working with the following scripts in this section:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下脚本：
- en: '`EnemyWave`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemyWave`'
- en: '`ScoreManager`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScoreManager`'
- en: '`ScenesManager`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScenesManager`'
- en: '`SOActorModel`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOActorModel`'
- en: Since the scoring system is an integral factor in our game, it would make sense
    to add a simple integer to `SOActorModel` that injects common values into our
    game objects. This trend will then follow on to other scripts. Let's start adding
    some code to our already-made scripts before we introduce `ScoreManager`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于评分系统是我们游戏的一个关键因素，因此向 `SOActorModel` 添加一个简单的整数，将其常用值注入到我们的游戏对象中是有意义的。这种趋势将继续应用到其他脚本中。在我们引入
    `ScoreManager` 之前，让我们先在我们的已制作脚本中添加一些代码。
- en: Preparing the code for the ScoreManager script
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 `ScoreManager` 脚本的代码
- en: 'If you recall [*Chapter 1*](B18381_01_Epub.xhtml#_idTextAnchor016), *Setting
    Up and Structuring Our Project*, we spoke about the SOLID principles and how important
    it is to add to our code rather than change it, or we risk errors and our code
    may start mutating and eventually become unfit for purpose. In order to prepare,
    we will add code to the scripts that we have already made to fit our `ScoreManager`
    script into place. Let''s start with `SOActorModel` first. Follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得 [*第1章*](B18381_01_Epub.xhtml#_idTextAnchor016)，*设置和构建我们的项目*，我们讨论了 SOLID
    原则以及将代码添加而不是更改的重要性，否则我们可能会出错，我们的代码可能会开始变异，最终变得不再适合使用。为了准备，我们将向已经制作的脚本中添加代码，以便将
    `ScoreManager` 脚本放置到位。让我们首先从 `SOActorModel` 开始。按照以下步骤操作：
- en: Open the `SOActorModel` script from the **Project** window.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目** 窗口中打开 `SOActorModel` 脚本。
- en: 'Anywhere within our list of variables in the `SOActorModel` script, add the
    following code, which will be used to contain the enemy''s score:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SOActorModel` 脚本中的变量列表中的任何位置，添加以下代码，该代码将用于包含敌人的分数：
- en: '[PRE16]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the `SOActorModel` script.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `SOActorModel` 脚本。
- en: Before we add more code to the other scripts to fit `ScoreManager` into our
    game, we need to acknowledge that we have made a change to our `ScriptableObject`
    template.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向其他脚本添加更多代码以将 `ScoreManager` 放入游戏之前，我们需要承认我们已经更改了我们的 `ScriptableObject` 模板。
- en: 'Let''s check our `BasicWave Enemy` scriptable object in the Unity Editor. Follow
    these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Unity 编辑器中检查我们的 `BasicWave Enemy` 可脚本对象。按照以下步骤操作：
- en: From the `Assets/ScriptableObject` folder.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Assets/ScriptableObject` 文件夹。
- en: Click once on **BasicWave Enemy** and you will see that the **Inspector** window
    has a **Score** input field.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **BasicWave Enemy** 上单击一次，你将看到 **检查器** 窗口有一个 **Score** 输入字段。
- en: 'Give the `BasicWave Enemy` a value of your choice. I''m giving it a value of
    `200`. It really doesn''t matter what value you give it as long as it''s more
    than `0`. The following screenshot shows the **BasicWave Enemy** section with
    its updated **Score** value:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给 `BasicWave Enemy` 赋予你选择的值。我给它赋值为 `200`。只要它大于 `0`，你赋予什么值都无关紧要。以下截图显示了带有更新后的
    **Score** 值的 **BasicWave Enemy** 部分：
- en: '![Figure 3.11 – enemy_wave score property and value added'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 添加了敌人波分的属性和值'
- en: '](img/Figure_3.11_B18381.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B18381.jpg)'
- en: Figure 3.11 – enemy_wave score property and value added
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 添加了敌人波分的属性和值
- en: We have updated the `BasicWave Enemy` scriptable object. We now need to focus
    on the `EnemyWave` script to create and receive this new variable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了 `BasicWave Enemy` 可脚本对象。现在我们需要关注 `EnemyWave` 脚本来创建和接收这个新变量。
- en: Open the `EnemyWave` script.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `EnemyWave` 脚本。
- en: 'At the top of the script, where we have our `health`, `travelSpeed`, and other
    global variables, add an extra variable to the list:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部，我们有 `health`、`travelSpeed` 和其他全局变量，向列表中添加一个额外的变量：
- en: '[PRE17]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now need to update the `score` variable from the `ScriptableObject` value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要更新 `score` 变量，从 `ScriptableObject` 值中获取。
- en: 'In the `EnemyWave` script, scroll down until you find the `ActorStats` method,
    then add the following extra line of code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `EnemyWave` 脚本中，向下滚动直到找到 `ActorStats` 方法，然后添加以下额外的代码行：
- en: '[PRE18]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `EnemyWave` script now has a `score` variable that is set from the value
    given to it by `SOActorModel`. The last thing we need to do is send the score
    value to `ScoreManager` when the enemy dies due to the actions of the player.
    Before we do that, let's create and code our `ScoreManager` script.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnemyWave` 脚本现在有一个 `score` 变量，其值由 `SOActorModel` 给定。我们需要做的最后一件事是在敌人因玩家的行动而死亡时将分数值发送到
    `ScoreManager`。在我们这样做之前，让我们创建并编写我们的 `ScoreManager` 脚本。'
- en: Setting up our ScoreManager script
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的 ScoreManager 脚本
- en: The purpose of the `ScoreManager` script is to total up the score of the player
    during their game, concluding when they arrive at the `gameOver` scene. We could
    also give the `ScoreManager` script other score-related functionality, such as
    the ability to store our score data on the device that we are playing the game
    on or to send the score data to a server for an online scoreboard. For now, we
    will keep things simple and just collect the player's score.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreManager` 脚本的目的是在玩家游戏过程中累计分数，直到他们到达 `gameOver` 场景。我们也可以给 `ScoreManager`
    脚本添加其他与分数相关的功能，例如将我们的分数数据存储在玩游戏设备上，或者将分数数据发送到服务器以创建在线排行榜。现在，我们将保持简单，只收集玩家的分数。'
- en: 'We can create and add our `ScoreManager` script to the game framework, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建并添加我们的 `ScoreManager` 脚本到游戏框架中，如下所示：
- en: Create and attach a script called `ScoreManager` to the `GameManager` game object,
    similar to how we did with `ScenesManager`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并附加一个名为 `ScoreManager` 的脚本到 `GameManager` 游戏对象，类似于我们之前对 `ScenesManager` 所做的那样。
- en: 'If you can''t remember how to do this, then check out the *Setting up our ScenesManager
    script* section of this chapter. The following screenshot shows `ScoreManager`
    attached to the `GameManager` game object in the **Inspector** window:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不记得如何做这个，那么请查看本章的 *设置我们的 ScenesManager 脚本* 部分。以下截图显示了 `ScoreManager` 在 **检查器**
    窗口中附加到 `GameManager` 游戏对象：
- en: '![Figure 3.12 – ScoreManager script added to the GameManager game object'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12 – 将 ScoreManager 脚本添加到 GameManager 游戏对象]'
- en: '](img/Figure_3.12_B18381.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.12_B18381.jpg]'
- en: Figure 3.12 – ScoreManager script added to the GameManager game object
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.12 – 将 ScoreManager 脚本添加到 GameManager 游戏对象
- en: 'Next, we are going to open the `ScoreManager` script and add code that will
    hold and send score data. Open the `ScoreManager` script and enter the following
    code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打开 `ScoreManager` 脚本并添加代码来保存和发送分数数据。打开 `ScoreManager` 脚本并输入以下代码：
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, we require the `UnityEngine` library, as previously mentioned.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，默认情况下，我们需要 `UnityEngine` 库。
- en: 'Continue by checking and entering the name of the class:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过检查并输入班级名称：
- en: '[PRE20]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a public class, with `ScoreManager` inheriting `MonoBehaviour` to increase
    the functionality of the script.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个公开的类，`ScoreManager` 继承自 `MonoBehaviour` 以增加脚本的函数性。
- en: Next, we add our variables and properties to our script. The only value we are
    concerned about is `playerScore`, which is private to the script (because we don't
    want other classes to have access). This variable is also set to `static`, meaning
    we don't need duplicate references for this variable.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在脚本中添加我们的变量和属性。我们唯一关心的值是 `playerScore`，它是脚本私有的（因为我们不希望其他类访问它）。这个变量也被设置为
    `static`，这意味着我们不需要对这个变量的重复引用。
- en: 'Following on from this is our `public` property, which gives outside classes
    access to the `playerScore` variable. As you''ll notice, the `PlayerScore` property
    returns an integer. Within this property, we use the `get` accessor to return
    our private `playerScore` integer. It is a good habit to keep our variables private,
    or you risk exposing your code to other classes, which can result in errors. The
    following code shows you how to complete this step:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们添加我们的 `public` 属性，它允许外部类访问 `playerScore` 变量。正如你将注意到的，`PlayerScore` 属性返回一个整数。在这个属性中，我们使用
    `get` 访问器返回我们的私有 `playerScore` 整数。保持我们的变量私有是一个好习惯，否则你可能会将你的代码暴露给其他类，这可能导致错误。以下代码显示了如何完成此步骤：
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Accessors
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器
- en: To find out more about accessors, check out [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于访问器的信息，请查看[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get)。
- en: 'We will now move on to the `SetScore` method; it is public and doesn''t return
    a value (`void`), with the `SetScore` name taking in an integer parameter named
    `incomingScore`. Within this method, we use `incomingScore` to add to the `playerScore`
    script (as its total score):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将转到`SetScore`方法；它是一个公共方法，不返回任何值（`void`），`SetScore`名称接受一个名为`incomingScore`的整数参数。在此方法中，我们使用`incomingScore`将`playerScore`脚本（作为其总分）相加：
- en: '[PRE22]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last method to add is the `ResetScore` method. Enter the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要添加的方法是`ResetScore`方法。输入以下代码：
- en: '[PRE23]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can call this method at the beginning or end of a game to stop the score
    from carrying on into the next game.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏开始或结束时调用此方法，以防止分数延续到下一场游戏。
- en: Save the script.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'As mentioned earlier, we can now return to the `EnemyWave` script to send the
    value of the enemy''s score points to the `ScoreManagers` method, `SetScore`,
    thereby adding them to the player''s total score:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在可以回到`EnemyWave`脚本，将敌人的分数点值发送到`ScoreManagers`方法的`SetScore`，从而将其添加到玩家的总分数中：
- en: Open the `EnemyWave` script from the `OnTriggerEnter` Unity function.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity函数`OnTriggerEnter`打开`EnemyWave`脚本。
- en: 'Within the scope of the `if` statement labeled `if (health <= 0)`, enter the
    following line of code at the top of its scope:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标记为`if (health <= 0)`的`if`语句的作用域内，在其作用域顶部输入以下代码行：
- en: '[PRE24]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When this particular enemy dies as a result of the player, this line of code
    will send the enemy's `score` value directly to the `playerScore` variable and
    increment it toward its total until the player loses all of their lives.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个特定的敌人因玩家而死时，此代码行将直接将敌人的`score`值发送到`playerScore`变量，并增加其总分数，直到玩家失去所有生命。
- en: Finally, to confirm the score has totaled correctly, let's do what we did before
    with the `playerLives` integer in the `LifeLost` method of the `GameManager` script
    and add a `Debug.Log` message to the **Console** window.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确认分数是否正确累加，让我们像之前在`GameManager`脚本的`LifeLost`方法中对`playerLives`整数所做的那样操作，并在**控制台**窗口中添加一个`Debug.Log`消息。
- en: 'In the `ScenesManager` script under the `GameOver()` method, add the following
    line of code at the top within its scope:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScenesManager`脚本下的`GameOver()`方法中，在其作用域顶部添加以下代码行：
- en: '[PRE25]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code will tell us how much the player has scored because it directly accesses
    `ScoreManager` and grabs the `PlayerScore` property when the game is over. The
    following screenshot shows an example of a totaled score:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将告诉我们玩家得分多少，因为它直接访问`ScoreManager`并在游戏结束时获取`PlayerScore`属性。以下截图显示了总分的一个示例：
- en: '![Figure 3.13 – Game over score value displayed in the Console window'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.13 – Game over score value displayed in the Console window]'
- en: '](img/Figure_3.13_B18381.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.13_B18381.jpg]'
- en: Figure 3.13 – Game over score value displayed in the Console window
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 在控制台窗口中显示的游戏结束分数值
- en: Finally, save all the scripts.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存所有脚本。
- en: In this section, we introduced the `ScoreManager` script with its basic working
    structure of totaling up our end score and displaying the final count in the **Console**
    window. We have also added more code to a selection of scripts without deleting
    and changing any of their content. Next, we will be doing something different
    that doesn't involve any coding but gets us more familiar with Unity's sound components.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了`ScoreManager`脚本及其基本工作结构，用于汇总我们的最终分数并在**控制台**窗口中显示最终计数。我们还向一些脚本添加了更多代码，而没有删除或更改它们的内容。接下来，我们将做一些不同的事情，这不需要任何编码，但会使我们更熟悉Unity的声音组件。
- en: Creating sounds for the player's bullets
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为玩家的子弹创建声音
- en: Up until now, our game has been silent, but sound is an important factor in
    any game. In this section, we will be introducing our first sound component. We
    will make a start by creating sound effects for when our player fires a bullet.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的游戏一直是静音的，但声音是任何游戏中的重要因素。在本节中，我们将介绍我们的第一个声音组件。我们将从为玩家开火时创建声音效果开始。
- en: 'Feel free to add your own type of bullet sound if you wish. You can add sound
    to your player''s standard bullets as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以添加您自己的子弹声音类型。您可以通过以下方式为玩家的标准子弹添加声音：
- en: In the Unity Editor, navigate to the `Resources` folder. Name the new folder
    `Sound`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，导航到`Resources`文件夹。将新文件夹命名为`Sound`。
- en: Drag and drop the `Player_Bullet` prefab from the **Project** panel into the
    **Hierarchy** panel.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**项目**面板中的`Player_Bullet`预制体拖放到**层次**面板中。
- en: With `Player_Bullet` still selected, click on the **Add Component** button in
    the **Inspector** panel.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`Player_Bullet`的情况下，点击**添加组件**按钮在**检查器**面板中。
- en: In its dropdown, start typing (and select) `Audio Source`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中开始键入（并选择）`音频源`。
- en: 'Drag and drop the `PlayerLaser.mp3` file into the `Player_Bullet` selected.
    The audio file at the bottom left needs to be dragged into the **Audio Source**
    component at the right:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlayerLaser.mp3`文件拖放到选中的`Player_Bullet`中。左下角的音频文件需要拖放到右侧的**音频源**组件中：
- en: '![Figure 3.14 – Adding sound file to the Player_Bullet''s Audio Source game
    object in the'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 在检查器窗口中将音频文件添加到Player_Bullet的音频源游戏对象]'
- en: Inspector window
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器窗口
- en: '](img/Figure_3.14_B18381.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.14_B18381.jpg)'
- en: Figure 3.14 – Adding sound file to the Player_Bullet's Audio Source game object
    in the Inspector window
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 在检查器窗口中将音频文件添加到Player_Bullet的音频源游戏对象
- en: '`Player_Bullet` is instantiated, the sound will play.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Player_Bullet`被实例化时，声音将播放。
- en: If the volume is too high, simply lower it in the **Audio Source** component
    of the **Inspector** window.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果音量太高，只需在**检查器**窗口的**音频源**组件中将其降低。
- en: Information
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: As well as the **Volume** option in the **Audio Source** component, there is
    **Pitch** to change the sound of our bullet and **Stereo Pan** to make the sound
    more dominant in the left or right speaker. Finally, because this is a two-dimensional
    game, we don't want the sound to be affected by how close our camera is to the
    bullet. So, we slide the **Spatial Blend** toggle all the way to the left to make
    sure it is not affected by its distance.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了**音频源**组件中的**音量**选项外，还有**音调**来改变子弹的声音，以及**立体声平衡**来使声音在左或右扬声器中更加突出。最后，因为这是一个二维游戏，我们不希望声音受到我们的摄像头与子弹距离的影响。因此，我们将**空间混合**切换滑到最左边，以确保它不会受到其距离的影响。
- en: Finally, click on `Player_Bullet` prefab and remove the bullet from the **Hierarchy**
    window.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击`Player_Bullet`预制体，并在**层次结构**窗口中移除子弹。
- en: Play the scene and start firing. You will hear laser noises, and, in the scene
    view, you will see speaker symbols now attached to the player's bullets.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景并开始射击。你会听到激光声，在场景视图中，你会看到现在附加到玩家子弹的扬声器符号。
- en: That brings us to the end of this short section on audio, but we will cover
    more on audio throughout this book. Don't forget that if you get stuck at any
    point, check the `Complete` folder for this chapter and compare the scenes and
    code to make sure nothing is missing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于音频的简短部分，但在这本书中我们还会更多地涉及音频。别忘了，如果你在任何地方遇到困难，请检查本章的`Complete`文件夹，比较场景和代码，以确保没有遗漏。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have extended our game framework structure by implementing
    and reinforcing the `GameManager` script by extending its code. This means that
    it will never be deleted, regardless of scene changes. We have also introduced
    the score and scenes managers, which were originally planned in our game framework.
    These two additional managers take responsibility away from the game manager and
    add additional features to your game. We ensured these scripts don't mutilate
    our original code (removing, overflowing, or compensating for our game manager).
    Your game now has a working scoring system, as well as multiple scenes that can
    be restarted and changed with very little code. We also introduced sound, which
    we'll implement in more detail in later chapters.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过扩展`GameManager`脚本来扩展和加强我们的游戏框架结构，通过扩展其代码。这意味着无论场景如何变化，它都不会被删除。我们还引入了得分和场景管理器，这些最初都计划在我们的游戏框架中。这两个额外的管理器从游戏管理器那里接管了责任，并为你的游戏添加了额外的功能。我们确保这些脚本不会破坏我们的原始代码（删除、溢出或补偿我们的游戏管理器）。现在你的游戏有一个工作得分系统，以及多个可以重新启动和更改的场景，而且代码非常少。我们还引入了声音，我们将在后面的章节中更详细地实现。
- en: In the next chapter, we'll focus less on code-heavy content and instead concern
    ourselves with the art of the game. Even though we are programmers, we need to
    understand how to manipulate assets and how to animate with Unity's API. With
    just a little bit of coding, this will allow us to understand the connection between
    the Editor and our script. We'll also touch on some particle effects.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将减少对代码密集型内容的关注，而是关注游戏的艺术。尽管我们是程序员，但我们需要了解如何使用Unity的API操作资源以及如何进行动画。只需一点点的编码，这将使我们能够理解编辑器和我们的脚本之间的联系。我们还将涉及一些粒子效果。
- en: Well done—you've done and covered a lot. Before we move on, have a go at the
    following questions. They resemble what you will encounter in your programmer
    exam.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好——你已经做了很多。在我们继续之前，尝试以下问题。这些问题类似于你将在程序员考试中遇到的问题。
- en: Mock test
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟测试
- en: This is your first mini mock test. These tests represent sections of your final
    Unity exam. This first mini mock test consists of just five questions. Later on
    in this book, we'll introduce more mini mock tests with more questions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的第一次迷你模拟测试。这些测试代表了您的最终Unity考试的各个部分。这次迷你模拟测试只包含五个问题。稍后在这本书中，我们将介绍包含更多问题的更多迷你模拟测试。
- en: 'Fortunately, you will only be tested on what we have covered so far:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您将只会被测试到我们迄今为止所覆盖的内容：
- en: 'You have been asked to develop a horror survival game where your player relies
    on a pocket torch. Here is what you''ve coded so far:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您被要求开发一款恐怖生存游戏，其中玩家依赖口袋手电筒。以下是您迄今为止编写的代码：
- en: '[PRE26]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You notice, however, that the player's torch isn't casting any light or shadows.
    What should you change for this code to work as desired?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，玩家的手电筒没有投射任何光线或阴影。您应该更改哪些代码才能使其按预期工作？
- en: Set `playersTorch.lightBakeType` to `LightmapBakeType.Realtime`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`playersTorch.lightBakeType`设置为`LightmapBakeType.Realtime`。
- en: Set `playersTorch.range` to `10`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`playersTorch.range`设置为`10`。
- en: Set `playersTorch.shadows` to `LightShadows.Hard`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`playersTorch.shadows`设置为`LightShadows.Hard`。
- en: Set `playersTorch.type` to `LightType.Point`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`playersTorch.type`设置为`LightType.Point`。
- en: You have started creating your first indie game, Super Moped Racer 64\. You
    have coded your input controls to work with a joystick and started testing your
    moped around corners. You've noticed that after taking the moped around the first
    corner, the moped continues turning even after you've let go of the joystick.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经开始创建您的第一款独立游戏，超级摩托车赛车64。您已经编写了代码以使操纵杆工作，并开始测试您的摩托车在弯道上的表现。您已经注意到，在绕过第一个弯道后，即使您已经松开了操纵杆，摩托车仍然继续转弯。
- en: You've checked your code and the joystick and both seem to be working fine,
    suggesting the issue is with the input manager.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您检查了您的代码和操纵杆，它们似乎都运行良好，这表明问题出在输入管理器上。
- en: What change should you make within the input manager?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在输入管理器中做出什么更改？
- en: Increase the gravity.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加重力。
- en: Set `Snap` to `true`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Snap`设置为`true`。
- en: Increase `Deadzone`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加`Deadzone`。
- en: Decrease `Sensitivity`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少`Sensitivity`。
- en: You have started to template a game framework with pen and paper. You have drawn
    up several manager scripts that will all lead to the creation of a single `GameManager`
    script. You only require one `GameManager` script, which will always be in your
    scene.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经开始使用纸笔制作游戏框架的模板。您已经绘制了几个将导致创建单个`GameManager`脚本的经理脚本。您只需要一个`GameManager`脚本，它将始终存在于您的场景中。
- en: Which design pattern suits having a `GameManager` script in a persistent instance
    role?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种设计模式适合在持久实例角色中使用`GameManager`脚本？
- en: Prototype
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原型
- en: Abstract Factory
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Singleton
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例
- en: Builder
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建者
- en: You have been requested to create a prototype for a side-scrolling game where
    your player throws rocks at their enemies. The game works well and the camera
    moves from left to right until the level is over. To throw a rock, your code instantiates
    a prefab of a rock, which is then given a force (`Rigidbody.AddForce`) to launch
    the rock to give the illusion of the rock being thrown.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已被要求创建一个侧滚动游戏的原型，其中玩家向敌人投掷石头。游戏运行良好，摄像头从左向右移动，直到关卡结束。要投掷石头，您的代码实例化一个石头的预制体，然后给予一个力（`Rigidbody.AddForce`）以使石头飞出，从而产生石头被投掷的错觉。
- en: Your lead developer says that your method is costing too much in-memory performance
    and wants you to store a maximum of 10 rocks from within an array of rocks using
    a design pattern. Once a rock is used, instead of being destroyed, it should return
    to the array.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主开发人员表示，您的方法在内存性能上花费太多，并希望您使用设计模式在石头数组中存储最多10块石头。一旦石头被使用，而不是被销毁，它应该返回到数组中。
- en: What design pattern is the developer referring to?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员指的是哪种设计模式？
- en: Abstract Factory
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Object Pool
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象池
- en: Dependency Injection
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Builder
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建者
- en: That's the end of your first mini mock test. To check your answers, refer to
    the [*Appendix*](B18381_Appendix_Epub.xhtml#_idTextAnchor245) section at the back
    of this book. How did you do? To review any incorrect answers, I suggest flicking
    back through the last couple of chapters to the relevant section and refreshing
    your memory where needed. Sadly, exams can be a bit of a memory game. Everyone's
    memory is different, and the majority of people that pass these exams have failed
    on certain sections before passing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的第一次迷你模拟测试的结束。要检查你的答案，请参考本书后面的[*附录*](B18381_Appendix_Epub.xhtml#_idTextAnchor245)部分。你做得怎么样？为了复习任何错误的答案，我建议你翻回到最后几章的相关部分，并在需要的地方刷新你的记忆。遗憾的是，考试可能有点像记忆力游戏。每个人的记忆力都不同，而且大多数通过这些考试的人在通过之前都曾在某些部分失败过。
- en: Either way, the more you complete these tests, the stronger you will become
    at them. Just stay focused and you'll get through it!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你完成这些测试越多，你在这些测试上的能力就会越强。只需保持专注，你就能顺利通过！
