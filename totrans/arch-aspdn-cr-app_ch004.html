<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>3 Architectural Principles</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="4">3 Architectural Principles</h1>

<h2 data-number="4.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file11.png" style="width:10em"/></p>
<p>This chapter delves into fundamental architectural principles: pillars of contemporary software development practices. These principles help us create flexible, resilient, testable, and maintainable code.We can use these principles to stimulate critical thinking, fostering our ability to evaluate trade-offs, anticipate potential issues, and create solutions that stand the test of time by influencing our decision-making process and helping our design choices.As we embark on this journey, we constantly refer to those principles throughout the book, particularly the SOLID principles, which improve our ability to build flexible and robust software systems.In this chapter, we cover the following topics:</p>
<ul>
<li>The separation of concerns (SoC) principle</li>
<li>The <strong>DRY</strong> principle</li>
<li>The <strong>KISS</strong> principle</li>
<li>The <strong>SOLID</strong> principles</li>
</ul>
<p>We also revise the following notions:</p>
<ul>
<li>Covariance</li>
<li>Contravariance</li>
<li>Interfaces</li>
</ul>


<h2 data-number="4.2">Separation of concerns (SoC)</h2>
<p>As its name implies, the idea is to separate our software into logical blocks, each representing a concern. A “concern” refers to a specific aspect of a program. It’s a particular interest or focus within a system that serves a distinct purpose. Concerns could be as broad as data management, as specific as user authentication, or even more specific, like copying an object into another. The Separation of Concerns principle suggests that each concern should be isolated and managed separately to improve the system’s maintainability, modularity, and understandability.</p>
<blockquote>
<p>The Separation of Concerns principle applies to all programming paradigms. In a nutshell, this principle means factoring a program into the correct pieces. For example, modules, subsystems, and microservices are macro-pieces, while classes and methods are smaller pieces.</p>
</blockquote>
<p>By correctly separating concerns, we can prevent changes in one area from affecting others, allow for more efficient code reuse, and make it easier to understand and manage different parts of a system independently.Here are a few examples:</p>
<ul>
<li>Security and logging are cross-cutting concerns.</li>
<li>Rendering a user interface is a concern.</li>
<li>Handling an HTTP request is a concern.</li>
<li>Copying an object into another is a concern.</li>
<li>Orchestrating a distributed workflow is a concern.</li>
</ul>
<p>Before moving to the DRY principle, it is imperative to consider concerns when dividing software into pieces to create cohesive units. A good separation of concerns helps create modular designs and face design dilemmas more effectively, leading to a maintainable application.</p>


<h2 data-number="4.3">Don’t repeat yourself (DRY)</h2>
<p>The DRY principle advocates the separation of concerns principle and aims to eliminate redundancy in code as well. It promotes the idea that each piece of knowledge or logic should have a single, unambiguous representation within a system.So, when you have duplicated logic in your system, encapsulate it and reuse that new encapsulation in multiple places instead. If you find yourself writing the same or similar code in multiple places, refactor that code into a reusable component instead. Leverage functions, classes, modules, or other abstractions to refactor the code.Adhering to the DRY principle makes your code more maintainable, less error-prone, and easier to modify because a change in logic or bug fix needs to be made in only one place, reducing the likelihood of introducing errors or inconsistencies.However, it is imperative to regroup duplicated logic by concern, not only by the similarities of the code itself. Let’s look at those two classes:</p>
<div><pre><code>public class AdminApp
{
    public async Task DisplayListAsync(
        IBookService bookService,
        IBookPresenter presenter)
    {
        var books = await bookService.FindAllAsync();
        foreach (var book in books)
        {
            await presenter.DisplayAsync(book);
        }
    }
}
public class PublicApp
{
    public async Task DisplayListAsync(
        IBookService bookService,
        IBookPresenter presenter)
    {
        var books = await bookService.FindAllAsync();
        foreach (var book in books)
        {
            await presenter.DisplayAsync(book);
        }
    }
}</code></pre>
</div>
<p>The code is very similar, but encapsulating a single class or method could very well be a mistake. Why? Keeping two separate classes is more logical because the admin program can have different reasons for modification compared to the public program.However, encapsulating the list logic into the <code>IBookPresenter</code> interface could make sense. It would allow us to react differently to both types of users if needed, like filtering the admin panel list but doing something different in the public section. One way to do this is by replacing the <code>foreach</code> loop with a <code>presenter</code> <code>DisplayListAsync(books)</code> call, like the following highlighted code:</p>
<div><pre><code>public class AdminApp
{
    public async Task DisplayListAsync(
        IBookService bookService,
        IBookPresenter presenter)
    {
        var books = await bookService.FindAllAsync();
        // We could filter the list here
        await presenter.DisplayListAsync(books);
    }
}
public class PublicApp
{
    public async Task DisplayListAsync(
        IBookService bookService,
        IBookPresenter presenter)
    {
        var books = await bookService.FindAllAsync();
        await presenter.DisplayListAsync(books);
    }
}</code></pre>
</div>
<p>There is more to those simple implementations to discuss, like the possibility of supporting multiple implementations of the interfaces for added flexibility, but let’s keep some subjects for further down the book.</p>
<blockquote>
<p>When you don’t know how to name a class or a method, you may have identified a problem with your separation of concerns. This is a good indicator that you should go back to the drawing board. Nevertheless, naming is hard, so sometimes, that’s just it.</p>
</blockquote>
<p>Keeping our code DRY while following the separation of concerns principles is imperative. Otherwise, what may seem like a good move could become a nightmare.</p>


<h2 data-number="4.4">Keep it simple, stupid (KISS)</h2>
<p>This is another straightforward principle, yet one of the most important. Like in the real world, the more moving pieces, the more chances something breaks. This principle is a design philosophy that advocates for simplicity in design. It emphasizes the idea that systems work best when they are kept simple rather than made complex.Striving for simplicity might involve writing shorter methods or functions, minimizing the number of parameters, avoiding over-architecting, and choosing the simplest solution to solve a problem.Adding interfaces, abstraction layers, and complex object hierarchy adds complexity, but are the added benefits better than the underlying complexity? If so, they are worth it; otherwise, they are not.</p>
<blockquote>
<p>As a guiding principle, when you can write the same program with less complexity, do it. This is also why predicting future requirements can often prove detrimental, as it may inadvertently inject unnecessary complexity into your codebase for features that might never materialize.</p>
</blockquote>
<p>We study design patterns in the book and design systems using them. We learn how to apply a high degree of engineering to our code, which can lead to over-engineering if done in the wrong context. Towards the end of the book, we circle back on the KISS principle when exploring the vertical slice architecture and request-endpoint-response (REPR) patterns.Next, we delve into the SOLID principles, which are the key to flexible software design.</p>


<h2 data-number="4.5">The SOLID principles</h2>
<p>SOLID is an acronym representing five principles that extend the basic OOP concepts of <strong>Abstraction</strong>, <strong>Encapsulation</strong>, <strong>Inheritance</strong>, and <strong>Polymorphism</strong>. They add more details about what to do and how to do it, guiding developers toward more robust and flexible designs.It is crucial to remember that these are just guiding principles, not rules that you must follow, no matter what. Think about what makes sense for your specific project. If you’re building a small tool, it might be acceptable not to follow these principles as strictly as you would for a crucial business application. In the case of business-critical applications, it might be a good idea to stick to them more closely. Still, it’s usually a smart move to follow them, no matter the size of your app. That’s why we’re discussing them before diving into design patterns.The SOLID acronym represents the following:</p>
<ul>
<li><strong>S</strong>ingle responsibility principle</li>
<li><strong>O</strong>pen/Closed principle</li>
<li><strong>L</strong>iskov substitution principle</li>
<li><strong>I</strong>nterface segregation principle</li>
<li><strong>D</strong>ependency inversion principle</li>
</ul>
<p>By following these principles, your systems should become easier to test and maintain.</p>

<h3 data-number="4.5.1">Single responsibility principle (SRP)</h3>
<p>Essentially, the SRP means that a single class should hold one, and only one, responsibility, leading me to the following quote:</p>
<blockquote>
<em>“There should never be more than one reason for a class to change.”— Robert C. Martin, originator of the single responsibility principle</em>
</blockquote>
<p>OK, but why? Before answering, take a moment to remember a project you’ve worked on where someone changed one or more requirements along the way. I recall several projects that would have benefited from this principle. Now, imagine how much simpler it would have been if each part of your system had just one job: one reason to change.</p>
<blockquote>
<p>Software maintainability problems can be due to both tech and non-tech people. Nothing is purely black or white—most things are a shade of gray. The same applies to software design: always do your best, learn from your mistakes, and stay humble (a.k.a. continuous improvement).</p>
</blockquote>
<p>By understanding that applications are born to change, you will feel better when that happens, while the SRP helps mitigate the impact of changes. For example, it helps make our classes more readable and reusable and to create more flexible and maintainable systems. Moreover, when a class does only one thing, it’s easier to see how changes will affect the system, which is more challenging with complex classes since one change might break other parts. Furthermore, fewer responsibilities mean less code. Less code is easier to understand, helping you grasp that part of the software more quickly.Let’s try this out in action.</p>

<h4 data-number="4.5.1.1">Project – Single Responsibility</h4>
<p>First, we look at the <code>Product</code> class used in both code samples. That class represents a simple fictive product:</p>
<div><pre><code>public record class Product(int Id, string Name);</code></pre>
</div>
<blockquote>
<p>The code sample has no implementation because it is irrelevant to understanding the SRP. We focus on the class API instead. Please assume we implemented the data-access logic using your favorite database.</p>
</blockquote>
<p>The following class breaks the SRP:</p>
<div><pre><code>namespace BeforeSRP;
public class ProductRepository
{
    public ValueTask&lt;Product&gt; GetOnePublicProductAsync(int productId)
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;Product&gt; GetOnePrivateProductAsync(int productId)
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllPublicProductsAsync()
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllPrivateProductsAsync()
        =&gt; throw new NotImplementedException();
    public ValueTask CreateAsync(Product product)
        =&gt; throw new NotImplementedException();
    public ValueTask UpdateAsync(Product product)
        =&gt; throw new NotImplementedException();
    public ValueTask DeleteAsync(Product product)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>What does not conform to the SRP in the preceding class? By reading the name of the methods, we can extract two responsibilities:</p>
<ul>
<li>Handling public products (highlighted code).</li>
<li>Handling private products.</li>
</ul>
<p>The <code>ProductRepository</code> class mixes public and private product logic. From that API alone, there are many possibilities where an error could lead to leaking restricted data to public users. That is also true because the class exposes the private logic to the public-facing consumers; someone else could make a mistake.We are ready to rethink the class now that we identified the responsibilities. We know it has two responsibilities, so breaking the class into two sounds like an excellent first step. Let’s start with extracting a public API:</p>
<div><pre><code>namespace AfterSRP;
public class PublicProductReader
{
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;Product&gt; GetOneAsync(int productId)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>The <code>PublicProductReader</code> class now contains only two methods: <code>GetAllAsync</code> and <code>GetOneAsync</code>. When reading the name of the class and its methods, it is clear that the class handles only public product data. By lowering the complexity of the class, we made it easier to understandNext, let’s do the same for the private products:</p>
<div><pre><code>namespace AfterSRP;
public class PrivateProductRepository
{
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;Product&gt; GetOneAsync(int productId)
        =&gt; throw new NotImplementedException();
    public ValueTask CreateAsync(Product product)
        =&gt; throw new NotImplementedException();
    public ValueTask DeleteAsync(Product product)
        =&gt; throw new NotImplementedException();
    public ValueTask UpdateAsync(Product product)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>The <code>PrivateProductRepository</code> class follows the same pattern. It includes the read methods, named the same as the <code>PublicProductReader</code> class, and the mutation methods only users with private access can use.We improved our code’s readability, flexibility, and security by splitting the initial class into two. However, one thing to be careful about with the SRP is not to over-separate classes. The more classes in a system, the more complex assembling the system can become, and the harder it can be to debug and follow the execution paths. On the other hand, many well-separated responsibilities should lead to a better, more testable system.It is tough to define one hard rule that defines “one reason” or “a single responsibility”. However, as a rule of thumb, aim at packing a cohesive set of functionalities in a single class that revolves around its responsibility. You should strip out any excess logic and add missing pieces.A good indicator of the SRP violation is when you don’t know how to name an element, which points towards the fact that the element should not reside there, that you should extract it, or that you should split it into multiple smaller pieces.</p>
<blockquote>
<p>Using precise names for variables, methods, classes, and other elements is very important and should not be overlooked.</p>
</blockquote>
<p>Another good indicator is when a method becomes too big, maybe containing many <code>if</code> statements or loops. In that case, you can split that method into multiple smaller methods, classes, or any other construct that suits your requirements. That should make the code easier to read and make the initial method’s body cleaner. It often also helps you get rid of useless comments and improve testability. Next, we explore how to change behaviors without modifying code, but before that, let’s look at interfaces.</p>



<h3 data-number="4.5.2">Open/Closed principle (OCP)</h3>
<p>Let’s start this section with a quote from Bertrand Meyer, the person who first wrote the term open/closed principle in 1988:</p>
<blockquote>
<em>“Software entities (classes, modules, functions, and so on) should be open for extension but closed for modification.”</em>
</blockquote>
<p>OK, but what does that mean? It means you should be able to change the class behaviors from the outside without altering the code.As a bit of history, the first appearance of the OCP in 1988 referred to inheritance, and OOP has evolved a lot since then. Inheritance is still useful, but you should be careful as it is easily misused. Inheritance creates direct coupling between classes. You should, most of the time, opt for composition over inheritance.</p>
<blockquote>
<p>“Composition over inheritance” is a principle that suggests it’s better to build objects by combining simple, flexible parts (composition) rather than by inheriting properties from a larger, more complex object (inheritance).</p>
<blockquote>
<p>Think of it like building with LEGO® blocks. It’s easier to build and adjust your creation if you put together small blocks (composition) rather than trying to alter a big, single block that already has a fixed shape (inheritance).</p>
</blockquote>
</blockquote>
<p>Meanwhile, we explore three versions of a business process to illustrate the OCP.</p>

<h4 data-number="4.5.2.1">Project – Open Close</h4>
<p>First, we look at the <code>Entity</code> and <code>EntityRepository</code> classes used in the code samples:</p>
<div><pre><code>public record class Entity();
public class EntityRepository
{
    public virtual Task CreateAsync(Entity entity)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>The <code>Entity</code> class represents a simple fictive entity with no properties; consider it anything you’d like. The <code>EntityRepository</code> class has a single <code>CreateAsync</code> method that inserts an instance of an <code>Entity</code> in a database (if it was implemented).</p>
<blockquote>
<p>The code sample has few implementation details because it is irrelevant to understanding the OCP. Please assume we implemented the <code>CreateAsync</code> logic using your favorite database.</p>
</blockquote>
<p>For the rest of the sample, we refactor the <code>EntityService</code> class, beginning with a version that inherits the <code>EntityRepository</code> class, breaking the OCP:</p>
<div><pre><code>namespace OCP.NoComposability;
public class EntityService : EntityRepository
{
    public async Task ComplexBusinessProcessAsync(Entity entity)
    {
        // Do some complex things here
        await CreateAsync(entity);
        // Do more complex things here
    }
}</code></pre>
</div>
<p>As the namespace implies, the preceding <code>EntityService</code> class offers no composability. Moreover, we tightly coupled it with the <code>EntityRepository </code>class. Since we just covered the <em>composition over inheritance</em> principle, we can quickly isolate the problem: <strong>inheritance</strong>.As the next step to fix this mess, let’s extract a private <code>_repository</code> field to hold an <code>EntityRepository</code> instance instead:</p>
<div><pre><code>namespace OCP.Composability;
public class EntityService
{
    private readonly EntityRepository _repository
        = new EntityRepository();
    public async Task ComplexBusinessProcessAsync(Entity entity)
    {
        // Do some complex things here
        await _repository.CreateAsync(entity);
        // Do more complex things here
    }
}</code></pre>
</div>
<p>Now the <code>EntityService</code> is composed of an <code>EntityRepository</code> instance, and there is no more inheritance. However, we still tightly coupled both classes, and it is impossible to change the behavior of the <code>EntityService</code> this way without changing its code.To fix our last issues, we can inject an <code>EntityRepository</code> instance into the class constructor where we set our private field like this:</p>
<div><pre><code>namespace OCP.DependencyInjection;
public class EntityService
{
    private readonly EntityRepository _repository;
    public EntityService(EntityRepository repository)
    {
        _repository = repository;
    }
    public async Task ComplexBusinessProcessAsync(Entity entity)
    {
        // Do some complex things here
        await _repository.CreateAsync(entity);
        // Do more complex things here
    }
}</code></pre>
</div>
<p>With the preceding change, we broke the tight coupling between the <code>EntityService</code> and the <code>EntityRepository</code> classes. We can also control the behavior of the <code>EntityService</code> class from the outside by deciding what instance of the <code>EntityRepository</code> class we inject into the <code>EntityService</code> constructor. We could even go further by leveraging an abstraction instead of a concrete class and explore this subsequently while covering the DIP.As we just explored, the OCP is a super powerful principle, yet simple, that allows controlling an object from the outside. For example, we could create two instances of the <code>EntityService</code> class with different <code>EntityRepository</code> instances that connect to different databases. Here’s a rough example:</p>
<div><pre><code>using OCP;
using OCP.DependencyInjection;
// Create the entity in database 1
var repository1 = new EntityRepository(/* connection string 1 */);
var service1 = new EntityService(repository1);
// Create the entity in database 2
var repository2 = new EntityRepository(/* connection string 2 */);
var service2 = new EntityService(repository2);
// Save an entity in two different databases
var entity = new Entity();
await service1.ComplexBusinessProcessAsync(entity);
await service2.ComplexBusinessProcessAsync(entity);</code></pre>
</div>
<p>In the preceding code, assuming we implemented the <code>EntityRepository</code> class and configured <code>repository1</code> and <code>repository2</code> differently, the result of executing the <code>ComplexBusinessProcessAsync</code> method on <code>service1</code> and <code>service2</code> would create the entity in two different databases. The behavior change between the two instances happened without changing the code of the <code>EntityService</code> class; composition: 1, inheritance: 0.</p>
<blockquote>
<p>We explore the <strong>Strategy pattern</strong>—the best way of implementing the OCP—in <em>Chapter 5</em>, <em>Strategy, Abstract Factory, and Singleton</em>. We revisit that pattern and also learn to assemble our program’s well-designed pieces and sew them together using dependency injection in <em>Chapter 6</em>, <em>Dependency Injection</em>.</p>
</blockquote>
<p>Next, we explore the principle we can perceive as the most complex of the five, yet the one we will use the less.</p>



<h3 data-number="4.5.3">Liskov substitution principle (LSP)</h3>
<p>The Liskov Substitution Principle (LSP) states that in a program, if we replace an instance of a superclass (supertype) with an instance of a subclass (subtype), the program should not break or behave unexpectedly.Imagine we have a base class called <code>Bird</code> with a function called <code>Fly</code>, and we add the <code>Eagle</code> and <code>Penguin</code> subclasses. Since a penguin can’t fly, replacing an instance of the <code>Bird</code> class with an instance of the <code>Penguin</code> subclass might cause problems because the program expects all birds to be able to fly.So, according to the LSP, our subclasses should behave so the program can still work correctly, even if it doesn’t know which subclass it’s using, preserving system stability.Before moving on with the LSP, let’s look at covariance and contravariance.</p>

<h4 data-number="4.5.3.1">Covariance and contravariance</h4>
<p>We won’t go too deep into this, so we don’t move too far away from the LSP, but since the formal definition mentions them, we must understand these at least a minimum.Covariance and contravariance represent specific polymorphic scenarios. They allow reference types to be converted into other types implicitly. They apply to generic type arguments, delegates, and array types. Chances are, you will never need to remember this, as most of it is implicit, yet, here’s an overview:</p>
<ul>
<li><strong>Covariance (</strong><code>out</code><strong>)</strong> enables us to use a more derived type (a subtype) instead of the supertype. Covariance is usually applicable to method return types. For instance, if a base class method returns an instance of a class, the equivalent method of a derived class can return an instance of a subclass.</li>
<li><strong>Contravariance (</strong><code>in</code><strong>)</strong> is the reverse situation. It allows a less derived type (a supertype) to be used instead of the subtype. Contravariance is usually applicable to method argument types. If a method of a base class accepts a parameter of a particular class, the equivalent method of a derived class can accept a parameter of a superclass.</li>
</ul>
<p>Let’s use some code to understand this more, starting with the model we are using:</p>
<div><pre><code>public record class Weapon { }
public record class Sword : Weapon { }
public record class TwoHandedSword : Sword { }</code></pre>
</div>
<p>Simple class hierarchy, we have a <code>TwoHandedSword</code> class that inherits from the <code>Sword</code> class and the <code>Sword</code> class that inherits from the <code>Weapon</code> class.</p>

<h5 data-number="4.5.3.1.1">Covariance</h5>
<p>To demo covariance, we leverage the following generic interface:</p>
<div><pre><code>public interface ICovariant&lt;out T&gt;
{
    T Get();
}</code></pre>
</div>
<p>In C#, the <code>out</code> modifier, the highlighted code, explicitly specifies that the generic parameter <code>T</code> is covariant. Covariance applies to return types, hence the <code>Get</code> method that returns the generic type <code>T</code>.Before testing this out, we need an implementation. Here’s a barebone one:</p>
<div><pre><code>public class SwordGetter : ICovariant&lt;Sword&gt;
{
    private static readonly Sword _instance = new();
    public Sword Get() =&gt; _instance;
}</code></pre>
</div>
<p>The highlighted code, which represents the <code>T</code> parameter, is of type <code>Sword</code>, a subclass of <code>Weapon</code>. Since covariance means you can <strong>return (output) the instance of a subtype as its supertype</strong>, using the <code>Sword</code> subtype allows exploring this with the <code>Weapon</code> supertype. Here’s the xUnit fact that demonstrates covariance:</p>
<div><pre><code>[Fact]
public void Generic_Covariance_tests()
{
    ICovariant&lt;Sword&gt; swordGetter = new SwordGetter();
    ICovariant&lt;Weapon&gt; weaponGetter = swordGetter;
    Assert.Same(swordGetter, weaponGetter);
    Sword sword = swordGetter.Get();
    Weapon weapon = weaponGetter.Get();
    var isSwordASword = Assert.IsType&lt;Sword&gt;(sword);
    var isWeaponASword = Assert.IsType&lt;Sword&gt;(weapon);
    Assert.NotNull(isSwordASword);
    Assert.NotNull(isWeaponASword);
}</code></pre>
</div>
<p>The highlighted line represents covariance, showing that we can implicitly convert the <code>ICovariant&lt;Sword&gt;</code> subtype to the <code>ICovariant&lt;Weapon&gt;</code> supertype.The code after that showcases what happens with that polymorphic change. For example, the <code>Get</code> method of the <code>weaponGetter</code> object returns a <code>Weapon</code> type, not a <code>Sword</code>, even if the underlying instance is a <code>SwordGetter</code> object. However, that <code>Weapon</code> is, in fact, a <code>Sword</code>, as the assertions demonstrate.Next, let’s explore contravariance.</p>


<h5 data-number="4.5.3.1.2"><strong>Contravariance</strong></h5>
<p>To demo covariance, we leverage the following generic interface:</p>
<div><pre><code>public interface IContravariant&lt;in T&gt;
{
    void Set(T value);
}</code></pre>
</div>
<p>In C#, the <code>in</code> modifier, the highlighted code, explicitly specifies that the generic parameter <code>T</code> is contravariant. Contravariance applies to input types, hence the <code>Set</code> method that takes the generic type <code>T</code> as a parameter.Before testing this out, we need an implementation. Here’s a barebone one:</p>
<div><pre><code>public class WeaponSetter : IContravariant&lt;Weapon&gt;
{
    private Weapon? _weapon;
    public void Set(Weapon value)
        =&gt; _weapon = value;
}</code></pre>
</div>
<p>The highlighted code, which represents the <code>T</code> parameter, is of type <code>Weapon</code>, the topmost class in our model; other classes derive from it. Since contravariance means you can <strong>input the instance of a subtype as its supertype</strong>, using the <code>Weapon</code> supertype allows exploring this with the <code>Sword</code> and <code>TwoHandedSword</code> subtypes. Here’s the xUnit fact that demonstrates contravariance:</p>
<div><pre><code>[Fact]
public void Generic_Contravariance_tests()
{
    IContravariant&lt;Weapon&gt; weaponSetter = new WeaponSetter();
    IContravariant&lt;Sword&gt; swordSetter = weaponSetter;
    Assert.Same(swordSetter, weaponSetter);
    // Contravariance: Weapon &gt; Sword &gt; TwoHandedSword
    weaponSetter.Set(new Weapon());
    weaponSetter.Set(new Sword());
    weaponSetter.Set(new TwoHandedSword());
    // Contravariance: Sword &gt; TwoHandedSword
    swordSetter.Set(new Sword());
    swordSetter.Set(new TwoHandedSword());
}</code></pre>
</div>
<p>The highlighted line represents contravariance. We can implicitly convert the <code>IContravariant&lt;Weapon&gt;</code> supertype to the <code>IContravariant&lt;Sword&gt;</code> subtype.The code after that showcases what happens with that polymorphic change. For example, the <code>Set</code> method of the <code>weaponSetter </code>object can take a <code>Weapon</code>, a <strong>Sword</strong> , or a <code>TwoHandedSword</code> instance because they are all subtypes of the <code>Weapon</code> type (or is the <code>Weapon</code> type itself).The same happens with the <code>swordSetter</code> instance, but it only takes a <code>Sword</code> or a <code>TwoHandedSword</code> instance, starting at the <code>Sword</code> type in the inheritance hierarchy because the compiler considers the <code>swordSetter</code> instance to be an <code>IContravariant&lt;Sword&gt;</code>, even if the underlying implementation is of the <code>WeaponSetter</code> type.Writing the following yields a compiler error:</p>
<div><pre><code>swordSetter.Set(new Weapon());</code></pre>
</div>
<p>The error is:</p>
<div><pre><code>Cannot convert from Variance.Weapon to Variance.Sword.</code></pre>
</div>
<p>That means that for the compiler, <code>swordSetter</code> is of type <code>IContravariant&lt;Sword&gt;</code>, not <code>IContravariant&lt;Weapon&gt;</code>.</p>
<blockquote>
<p><strong>Note</strong></p>
<blockquote>
<p>I left a link in the <em>Further reading</em> section that explains covariance and contravariance if you want to know more since we just covered the basics here.</p>
</blockquote>
</blockquote>
<p>Now that we grazed covariance and contravariance, we are ready to explore the formal version of the LSP.</p>



<h4 data-number="4.5.3.2">The LSP explained</h4>
<p>The LSP came from Barbara Liskov at the end of the ‘80s and was revisited during the ‘90s by both Liskov and Jeannette Wing to create the principle that we know and use today. It is also similar to <em>Design by contract</em>, by Bertrand Meyer.Next, let’s look at the formal subtype requirement definition:</p>
<blockquote>
<em>Let <img src="img/file12.png" alt="img"/> be a property provable about objects x of type T. Then, <img src="img/file13.png" alt="img"/> should be true for objects y of type S, where S is a subtype of T.</em>
</blockquote>
<p>In simpler words, if <code>S</code> is a subtype of <code>T</code>, we can replace objects of type <code>T</code> with objects of type <code>S</code> without changing any of the expected behaviors of the program (correctness).The LSP adds the following signature requirements:</p>
<ul>
<li>The parameters of methods in subtypes must be contravariant.</li>
<li>The return type of methods in subtypes must be covariant.</li>
<li>You can’t throw a new type of exception in subtypes.</li>
</ul>
<blockquote>
<p>The first two rules are tough to violate without effort in C#.</p>
<blockquote>
<p>Throwing a new type of exception in subtypes is also considered changing behaviors. You can, however, throw subtyped exceptions in subtypes because the existing consumers can handle them.</p>
</blockquote>
</blockquote>
<p>The LSP also adds the following behavioral conditions:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Conditions</strong></td>
<td><strong>Examples</strong></td>
</tr>
<tr class="even">
<td>Any precondition implemented in a supertype should yield the same outcome in its subtypes, but subtypes can be less strict about it, never more.</td>
<td>If a supertype validates that an argument cannot be <code>null</code> , the subtype could remove that validation but not add stricter validation rules.</td>
</tr>
<tr class="odd">
<td>Any postcondition implemented in a supertype should yield the same outcome in its subtypes, but subtypes can be more strict about it, never less.</td>
<td><p>If the supertype never returns <code>null</code>, the subtype should not return <code>null</code> either or risk breaking the consumers of the object that are not testing for <code>null</code>.</p>
<p>If the supertype does not guarantee the returned value cannot be <code>null</code>, then a subtype could decide never to return <code>null</code>, making both instances interchangeable.</p></td>
</tr>
<tr class="even">
<td>Subtypes must preserve the invariance of the supertype.</td>
<td>A subtype must pass all the tests written for the supertype, so there is no variance between them (they don’t vary/they react the same).</td>
</tr>
<tr class="odd">
<td>The history constraint dictates that what happens in the supertype must still occur in the subtype, and you can’t change this.</td>
<td><p>A subtype can add new properties (state) and methods (behaviors).</p>
<p>A subtype must not modify the supertype state in any new way.</p></td>
</tr>
</tbody>
</table>
Table 3.1: LSP behavioral conditions
<p>OK, at this point, you are right to feel that this is rather complex. Yet, rest assured that this is the less important of those principles because we are moving as far as we can from inheritance, so the LSP should not apply often.</p>
<blockquote>
<p>We can summarize the LSP to:</p>
<blockquote>
<p><em>In your subtypes, add new behaviors and states; don’t change existing ones.</em></p>
</blockquote>
</blockquote>
<p>In a nutshell, applying the LSP allows us to swap an instance of a class for one of its subclasses without breaking anything.To make a LEGO® analogy: LSP is like swapping a 4x2 block with a 4x2 block with a sticker on it: neither the structure's structural integrity nor the block's role changed; the new block only has a new sticker state.</p>
<blockquote>
<p><strong>Tip</strong></p>
<blockquote>
<p>An excellent way of enforcing those behavioral constraints is automated testing. You can write a test suite and run it against all subclasses of a specific supertype to enforce the preservation of behaviors.</p>
</blockquote>
</blockquote>
<p>Let’s jump into some code to visualize that in practice.</p>


<h4 data-number="4.5.3.3">Project – Liskov Substitution</h4>
<p>To demonstrate the LSP, we will explore some scenarios. Each scenario is a test class that follows the same structure:</p>
<div><pre><code>namespace LiskovSubstitution;
public class TestClassName
{
    public static TheoryData&lt;SuperClass&gt; InstancesThatThrowsSuperExceptions = new TheoryData&lt;SuperClass&gt;()
    {
        new SuperClass(),
        new SubClassOk(),
        new SubClassBreak(),
    };
    [Theory]
    [MemberData(nameof(InstancesThatThrowsSuperExceptions))]
    public void Test_method_name(SuperClass sut)
    {
        // Scenario
    }
    // Other classes, like SuperClass, SubClassOk, 
    // and SubClassBreak
}</code></pre>
</div>
<p>In the preceding code structure, the highlighted code changes for every test. The setup is simple; I use the test method to simulate code that a program could execute, and just by running the same code three times on different classes, each theory fails once:</p>
<ul>
<li>The initial test passes</li>
<li>The test of a subtype respecting the LSP passes</li>
<li>The test of a subtype violating the LSP fails.</li>
</ul>
<blockquote>
<p>The parameter <code>sut</code> is the subject under test, a well-known acronym.</p>
</blockquote>
<p>Of course, we can’t explore all scenarios, so I picked three; let’s check the first one.</p>

<h5 data-number="4.5.3.3.1">Scenario 1: ExceptionTest</h5>
<p>This scenario explores what can happen when a subtype throws a new exception type.The following code is the consumer of the subject under test:</p>
<div><pre><code>try
{
    sut.Do();
}
catch (SuperException ex)
{
    // Some code
}</code></pre>
</div>
<p>The preceding code is very standard. We wrapped the execution of some code (the <code>Do</code> method) in a try-catch block to handle a specific exception.The initial subject under test (the <code>SuperClass</code>) simulates that at some point during the execution of the <code>Do</code> method, it throws an exception of type <code>SuperException</code>. When we execute the code, the try-catch block catches the <code>SuperException</code>, and everything goes as planned. Here’s the code:</p>
<div><pre><code>public class SuperClass
{
    public virtual void Do()
        =&gt; throw new SuperException();
}
public class SuperException : Exception { }</code></pre>
</div>
<p>Next, the <code>SubClassOk</code> class simulates that the execution changed, and it throws a <code>SubException</code> that inherits the <code>SuperException</code> class. When we execute the code, the try-catch block catches the <code>SubException</code>, because it’s a subtype of <code>SuperException</code>, and everything goes as planned. Here’s the code:</p>
<div><pre><code>public class SubClassOk : SuperClass
{
    public override void Do()
        =&gt; throw new SubException();
}
public class SubException : SuperException { }</code></pre>
</div>
<p>Finally, the <code>SubClassBreak</code> class simulates that it is throwing <code>AnotherException</code>, a new type of exception. When we execute the code, the program stops unexpectedly because we did not design the try-catch block for that. Here’s the code:</p>
<div><pre><code>public class SubClassBreak : SuperClass
{
    public override void Do()
        =&gt; throw new AnotherException();
}
public class AnotherException : Exception { }</code></pre>
</div>
<p>So as trivial as it may sound, throwing that exception breaks the program and go against the LSP.</p>


<h5 data-number="4.5.3.3.2">Scenario 2: PreconditionTest</h5>
<p>This scenario explores that <em>any precondition implemented in a supertype should yield the same outcome in its subtypes, but subtypes can be less strict about it, never more</em>.The following code is the consumer of the subject under test:</p>
<div><pre><code>var value = 5;
var result = sut.IsValid(value);
Console.WriteLine($"Do something with {result}");</code></pre>
</div>
<p>The preceding code is very standard. We have the <code>value</code> variable that could come from anywhere. Then we pass it to the <code>IsValid</code> method. Finally, we do something with the <code>result</code>; in this case, we write a line to the console.The initial subject under test (the <code>SuperClass</code>) simulates that a precondition exists that enforces that the value must be positive. Here’s the code:</p>
<div><pre><code>public class SuperClass
{
    public virtual bool IsValid(int value)
    {
        if (value &lt; 0)
        {
            throw new ArgumentException(
                "Value must be positive.", 
                nameof(value)
            );
        }
        return true;
    }
}</code></pre>
</div>
<p>Next, the <code>SubClassOk</code> class simulates that the execution changed and tolerates negative values up to -10. Everything is fine when executing the code because the precondition is less strict. Here’s the code:</p>
<div><pre><code>public class SubClassOk : SuperClass
{
    public override bool IsValid(int value)
    {
        if (value &lt; -10)
        {
            throw new ArgumentException(
                "Value must be greater or equal to -10.", 
                nameof(value)
            );
        }
        return true;
    }
}</code></pre>
</div>
<p>Finally, the <code>SubClassBreak</code> class simulates that the execution changed and restricts using values under 10. When executing the code, it breaks because we were not expecting that error; the precondition was more strict than the <code>SuperClass</code>. Here’s the code:</p>
<div><pre><code>public class SubClassBreak : SuperClass
{
    public override bool IsValid(int value)
    {
        if (value &lt; 10) // Break LSP
        {
            throw new ArgumentException(
                "Value must be greater than 10.", 
                nameof(value)
            );
        }
        return true;
    }
}</code></pre>
</div>
<p>Yet another example of how a simple change can break its consumers and the LSP. Of course, this is an overly simplified example focusing only on the precondition, but the same applies to more complex scenarios. Coding is like playing with blocks.</p>


<h5 data-number="4.5.3.3.3">Scenario 3: PostconditionTest</h5>
<p>This scenario explores that <em>postconditions implemented in a supertype should yield the same outcome in its subtypes, but subtypes can be more strict about it, never less</em>.The following code is the consumer of the subject under test:</p>
<div><pre><code>var value = 5;
var result = sut.Do(value);
Console.WriteLine($"Do something with {result.Value}");</code></pre>
</div>
<p>The preceding code is very standard and very similar to the second scenario. We have the <code>value</code> variable that could come from anywhere. Then we pass it to the <code>Do</code> method. Finally, we do something with the <code>result</code>; in this case, we write a line to the console. The <code>Do</code> method returns an instance of a <code>Model</code> class, which has only a <code>Value</code> property. Here’s the code:</p>
<div><pre><code>public record class Model(int Value);</code></pre>
</div>
<p>The initial subject under test (the <code>SuperClass</code>) simulates that at some point during the execution, it returns a <code>Model</code> instance and sets the value of the <code>Value</code> property to the value of the <code>value</code> parameter. Here’s the code:</p>
<div><pre><code>public class SuperClass
{
    public virtual Model Do(int value)
    {
        return new(value);
    }
}</code></pre>
</div>
<p>Next, the <code>SubClassOk</code> class simulates that the execution changed and returns a <code>SubModel</code> instance instead. The <code>SubModel</code> class inherits the <code>Model</code> class and adds a <code>DoCount</code> property. When executing the code, everything is fine because the output is invariant (a <code>SubModel</code> is a <code>Model</code> and behaves the same). Here’s the code:</p>
<div><pre><code>public class SubClassOk : SuperClass
{
    private int _doCount = 0;
    public override Model Do(int value)
    {
        var baseModel = base.Do(value);
        return new SubModel(baseModel.Value, ++_doCount);
    }
}
public record class SubModel(int Value, int DoCount) : Model(Value);</code></pre>
</div>
<p>Finally, the <code>SubClassBreak</code> class simulates that the execution changed and returns <code>null</code> when the value of the <code>value</code> parameter is 5. When executing the code, it breaks at runtime with a <code>NullReferenceException</code> when accessing the <code>Value</code> property during the interpolation that happens in the <code>Console.WriteLine</code> call. Here’s the code:</p>
<div><pre><code>public class SubClassBreak : SuperClass
{
    public override Model Do(int value)
    {
        if (value == 5)
        {
            return null;
        }
        return base.Do(value);
    }
}</code></pre>
</div>
<p>This last scenario shows once again how a simple change can break our program. Of course, this is also an overly simplified example focusing only on the postcondition and history constraint, but the same applies to more complex scenarios.What about the history constraint? We added a new state element to the <code>SubClassOk</code> class by creating the <code>_doCount</code> field. Moreover, by adding the <code>SubModel</code> class, we added the <code>DoCount</code> property to the return type. That field and property were nonexistent in the supertype, and they did not alter its behaviors: LSP followed!</p>



<h4 data-number="4.5.3.4">Conclusion</h4>
<p>The key idea of the LSP is that the consumer of a supertype should remain unaware of whether it's interacting with an instance of a supertype or an instance of a subtype.We could also name this principle the backward-compatibility principle because everything that worked in a way before must still work at least the same after the substitution, which is why this principle is essential.Once again, this is only a principle, not a law. You can also see a violation of the LSP as a <em>code smell</em>. From there, analyze whether you have a design problem and its impact. Use your analytical skills on a case-by-case basis and conclude whether or not it would be acceptable to break the LSP in that specific case. Sometimes you want to change the program's behavior and break the LSP, but beware that you might break certain execution paths you did not account for and introduce defects.The more we progress, the more we move away from inheritance, and the less we need to worry about this principle. However, if you use inheritance and want to ensure your subtypes don’t break the program: apply the LSP, and you will be rewarded by improving your chances of producing defect-free, backward-compatible changes.Let’s look at the ISP next.</p>



<h3 data-number="4.5.4">Interface segregation principle (ISP)</h3>
<p>Let’s start with another famous quote by Robert C. Martin:</p>
<blockquote>
<em>“Many client-specific interfaces are better than one general-purpose interface.”</em>
</blockquote>
<p>What does that mean? It means the following:</p>
<ul>
<li>You should create interfaces.</li>
<li>You should value small interfaces more.</li>
<li>You should not create multipurpose interfaces.</li>
</ul>
<blockquote>
<p>You can see a multipurpose interface as “an interface to rule them all” or a God class, introduced in <em>Chapter 1</em>, <em>Introduction</em>.</p>
</blockquote>
<p>An interface could refer to a class interface (the public members of a class) or a C# interface. We focus on C# interfaces in the book, as we use them extensively. Moreover, C# interfaces are very powerful.Speaking of interfaces, let’s quickly look at them before digging into some code.</p>

<h4 data-number="4.5.4.1">What is an interface?</h4>
<p>Interfaces are among the most valuable tools in the C# toolbox for creating flexible and maintainable software. It can be tough to understand and grasp the power of interfaces at first, especially from an explanation, so don’t worry if you don’t; you will see plenty in action throughout the book.</p>
<blockquote>
<p>You can see an interface as allowing a class to impersonate different things (APIs), bringing polymorphism to the next level.</p>
</blockquote>
<p>Next are some more details that overview interfaces:</p>
<ul>
<li>The role of an interface is to define a cohesive contract (public methods, properties, and events). In its theoretical form, an interface contains no code; it is only a contract. In practice, since C# 8, we can create default implementation in interfaces, which could be helpful to limit breaking changes in a library (such as adding a method to an interface without breaking any class implementing that interface).</li>
<li>An interface should be small (ISP), and its members should align toward a common goal (cohesion) and share a single responsibility (SRP).</li>
<li>In C#, a class can implement multiple interfaces, exposing multiples of those public contracts or, more accurately, be any and all of them. By leveraging polymorphism, we can consume a class as if it was any of the interfaces it implements or its supertype if it inherits another class.</li>
</ul>
<blockquote>
<p>A class does not inherit from an interface; it implements an interface. However, an interface can inherit from another interface.</p>
</blockquote>
<p>Let’s explore the ISP example now that we refreshed our memory.</p>


<h4 data-number="4.5.4.2">Project – Interface Segregation</h4>
<p>In this project, we start with the same class as the SRP example but extract an interface from the <code>ProductRepository</code> class. Let’s start by looking at the <code>Product</code> class as a reminder, which represents a simple fictive product:</p>
<div><pre><code>public record class Product(int Id, string Name);</code></pre>
</div>
<blockquote>
<p>The code sample has no implementation because it is irrelevant to understanding the ISP. We focus on the interfaces instead. Please assume we implemented the data-access logic using your favorite database.</p>
</blockquote>
<p>Now, let’s look at the interface extracted from the <code>ProductRepository</code> class:</p>
<div><pre><code>namespace InterfaceSegregation.Before;
public interface IProductRepository
{
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllPublicProductAsync();
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllPrivateProductAsync();
    public ValueTask&lt;Product&gt; GetOnePublicProductAsync(int productId);
    public ValueTask&lt;Product&gt; GetOnePrivateProductAsync(int productId);
    public ValueTask CreateAsync(Product product);
    public ValueTask UpdateAsync(Product product);
    public ValueTask DeleteAsync(Product product);
}</code></pre>
</div>
<p>At this point, the <code>IProductRepository</code> interface breaks the SRP and the ISP the same way the <code>ProductRepository</code> class did before. We already identified the SRP issues earlier but did not reach the point of extracting interfaces.</p>
<blockquote>
<p>The <code>ProductRepository</code> class implements the <code>IProductRepository</code> interface and is the same as the SRP example (all methods <code>throw new NotImplementedException()</code>).</p>
</blockquote>
<p>In the SRP example, we identified the following responsibilities:</p>
<ul>
<li>Handling public products.</li>
<li>Handling private products.</li>
</ul>
<p>Based on our previous analysis, we have two functional requirements (public and private access). By digging deeper, we can also identify five different database operations. Here’s the result in a grid:</p>
<table>
<tbody>
<tr class="odd">
<td/>
<td><strong>Public</strong></td>
<td><strong>Private</strong></td>
</tr>
<tr class="even">
<td>Read one product</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Read all products</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Create a product</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Update a product</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Delete a product</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
Table 3.3: a grid that shows what the software needs to do (functional requirements) and what needs to happen in the database (database operation requirements).
<p>We can extract the following families of database operations from Table 3.3:</p>
<ul>
<li>Read products (read one, read all).</li>
<li>Write or alter products (create, update, delete).</li>
</ul>
<p>Based on that more thorough analysis, we can extract the <code>IProductReader</code> and <code>IProductWriter</code> interfaces representing the database operation. Then we can create the <code>PublicProductReader</code> and <code>PrivateProductRepository</code> classes to implement our functional requirements.Let’s start with the <code>IProductReader</code> interface:</p>
<div><pre><code>namespace InterfaceSegregation.After;
public interface IProductReader
{
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync();
    public ValueTask&lt;Product&gt; GetOneAsync(int productId);
}</code></pre>
</div>
<p>With this interface, we cover the <em>read one product</em> and <em>read all products</em> use cases. Next, the <code>IProductWriter</code> interface covers the other three database operations:</p>
<div><pre><code>namespace InterfaceSegregation.After;
public interface IProductWriter
{
    public ValueTask CreateAsync(Product product);
    public ValueTask UpdateAsync(Product product);
    public ValueTask DeleteAsync(Product product);
}</code></pre>
</div>
<p>We can cover all the database use cases with the preceding interfaces. Next, let’s create the <code>PublicProductReader</code> class:</p>
<div><pre><code>namespace InterfaceSegregation.After;
public class PublicProductReader : IProductReader
{
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;Product&gt; GetOneAsync(int productId)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>In the preceding code, the <code>PublicProductReader</code> only implements the <code>IProductReader</code> interface, covering the identified scenarios. We do the <code>PrivateProductRepository</code> class next before exploring the advantages of the ISP:</p>
<div><pre><code>namespace InterfaceSegregation.After;
public class PrivateProductRepository : IProductReader, IProductWriter
{
    public ValueTask&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
        =&gt; throw new NotImplementedException();
    public ValueTask&lt;Product&gt; GetOneAsync(int productId)
        =&gt; throw new NotImplementedException();
    public ValueTask CreateAsync(Product product)
        =&gt; throw new NotImplementedException();
    public ValueTask DeleteAsync(Product product)
        =&gt; throw new NotImplementedException();
    public ValueTask UpdateAsync(Product product)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>In the preceding code, the <code>PrivateProductRepository</code> class implements the <code>IProductReader</code> and <code>IProductWriter</code> interfaces, covering all the database needs. Now that we have covered the building blocks, let’s explore what this can do. Here’s the <code>Program.cs</code> file:</p>
<div><pre><code>using InterfaceSegregation.After;
var publicProductReader = new PublicProductReader();
var privateProductRepository = new PrivateProductRepository();
ReadProducts(publicProductReader);
ReadProducts(privateProductRepository);
// Error: Cannot convert from PublicProductReader to IProductWriter
// ModifyProducts(publicProductReader); // Invalid
WriteProducts(privateProductRepository);
ReadAndWriteProducts(privateProductRepository, privateProductRepository);
ReadAndWriteProducts(publicProductReader, privateProductRepository);
void ReadProducts(IProductReader productReader)
{
    Console.WriteLine(
        "Reading from {0}.",
        productReader.GetType().Name
    );
}
void WriteProducts(IProductWriter productWriter)
{
    Console.WriteLine(
        "Writing to {0}.",
        productWriter.GetType().Name
    );
}
void ReadAndWriteProducts(IProductReader productReader, IProductWriter productWriter)
{
    Console.WriteLine(
        "Reading from {0} and writing to {1}.",
        productReader.GetType().Name,
        productWriter.GetType().Name
    );
}</code></pre>
</div>
<p>From the preceding code, the <code>ReadProducts</code>, <code>ModifyProducts</code>, and <code>ReadAndUpdateProducts</code> methods write messages in the console to demonstrate the advantages of applying the ISP.The <code>publicProductReader</code> (instance of <code>PublicProductReader</code>) and <code>privateProductRepository</code> (instance of <code>PrivateProductRepository</code>) variables are passed to the methods to show what we can and cannot do with the current design.Before getting into the weed, when we execute the program, we obtain the following output:</p>
<div><pre><code>Reading from PublicProductReader.
Reading from PrivateProductRepository.
Writing to PrivateProductRepository.
Reading from PrivateProductRepository and writing to PrivateProductRepository.
Reading from PublicProductReader and writing to PrivateProductRepository.</code></pre>
</div>

<h5 data-number="4.5.4.2.1">First operation</h5>
<p>The following code represents the first operation:</p>
<div><pre><code>ReadProducts(publicProductReader);
ReadProducts(privateProductRepository);</code></pre>
</div>
<p>Since the <code>PublicProductReader</code> and <code>PrivateProductRepository</code> classes implement the <code>IProductReader</code> interface, the <code>ReadProducts</code> method accepts them, leading to the following output:</p>
<div><pre><code>Reading from PublicProductReader.
Reading from PrivateProductRepository.</code></pre>
</div>
<p>That means we can centralize some code that reads from both implementations without changing them.</p>


<h5 data-number="4.5.4.2.2">Second operation</h5>
<p>The following code represents the second operation:</p>
<div><pre><code>WriteProducts(privateProductRepository);</code></pre>
</div>
<p>Since only the <code>PrivateProductRepository</code> class implements the <code>IProductWriter</code> interface, the <code>WriteProducts</code> method accepts only the <code>privateProductRepository</code> variable and outputs the following:</p>
<div><pre><code>Writing to PrivateProductRepository.</code></pre>
</div>
<p>This is one advantage of well-segregated interfaces and responsibilities; if we try to execute the following line, the compiler yields the error saying that we “cannot convert from PublicProductReader to IProductWriter”:</p>
<div><pre><code>ModifyProducts(publicProductReader);</code></pre>
</div>
<p>That error makes sense because PublicProductReader does not implement the <code>IProductWriter</code> interface.</p>


<h5 data-number="4.5.4.2.3">Third operation</h5>
<p>The following code represents the third operation:</p>
<div><pre><code>ReadAndWriteProducts(
    privateProductRepository, 
    privateProductRepository
);
ReadAndWriteProducts(
    publicProductReader, 
    privateProductRepository
);</code></pre>
</div>
<p>Let’s analyze the two calls to the <code>ReadAndWriteProducts</code> method individually, but before that, let’s look at the console output:</p>
<div><pre><code>Reading from PrivateProductRepository and writing to PrivateProductRepository.
Reading from PublicProductReader and writing to PrivateProductRepository.</code></pre>
</div>
<p>The first execution reads and writes to the <code>PrivateProductRepository</code> instance, which is possible because it implements both the <code>IProductReader</code> and <code>IProductWriter</code> interfaces.The second call, however, reads from the public reader but writes using the private writer. The last example shows the power of the ISP, especially when mixed with the SRP, and how easy it is to swap one piece for another when segregating our interfaces correctly and designing our code for the program’s use cases.</p>
<blockquote>
<p>You should not divide all your repositories into readers and writers; this sample only demonstrates some possibilities. Always design your programs for the specifications that you have.</p>
</blockquote>



<h4 data-number="4.5.4.3">Conclusion</h4>
<p>To summarize the idea behind the ISP, if you have multiple smaller interfaces, it is easier to reuse them and expose only the features you need instead of exposing APIs that part of your program doesn’t need. Furthermore, it is easier to compose bigger pieces using multiple specialized interfaces by implementing them as needed than remove methods from a big interface if we don’t need them in one of its implementations.</p>
<blockquote>
<p>The main takeaway is to <strong>only depend on the interfaces that you consume</strong>.</p>
</blockquote>
<p>If you don’t see all of the benefits yet, don’t worry. All the pieces should come together as we move on to the last SOLID principle, to dependency injection, the rest of the book, and as you practice applying the SOLID principles.</p>
<blockquote>
<p>Like the SRP, be careful not to overuse the ISP mindlessly. Think about cohesion and what you are trying to achieve, not how granular an interface can become. The finer-grained your interfaces, the more flexible your system will be but remember that flexibility has a cost, which can become very high very quickly. For example, your highly-flexible system may be very hard to navigate and understand, increasing the cognitive load required to work on the project.</p>
</blockquote>
<p>Next, we explore the last of the SOLID principles.</p>



<h3 data-number="4.5.5">Dependency inversion principle (DIP)</h3>
<p>The DIP provides flexibility, testability, and modularity, by reducing tight coupling between classes or modules.Let’s continue with another quote from Robert C. Martin (including the implied context from Wikipedia):</p>
<blockquote>
<em>One should “depend upon abstractions, [not] concretions.”</em>
</blockquote>
<p>In the previous section, we explored interfaces (abstractions), one of the pivotal elements of our SOLID arsenal, and using interfaces is the best way to approach the DIP.</p>
<blockquote>
<p>Are you wondering why not use abstract classes? While helpful at providing default behaviors over inheritance, they’re not fully abstract. If one is, it’s better to use an interface instead.</p>
<blockquote>
<p>Interfaces are more flexible and powerful, acting as contracts between parts of a system. They also allow a class to implement multiple interfaces, boosting flexibility. However, don’t discard abstract classes mindlessly. Actually, don’t discard anything mindlessly.</p>
</blockquote>
</blockquote>
<p>Exposing interfaces can save countless hours of struggling to find complex workaround when writing unit tests. That is even more true when building a framework or library that others use. In that case, please pay even more attention to providing your consumers with interfaces to mock if necessary.All that talk about interfaces again is great, but how can we invert the flow of dependencies? Spoiler alert: interfaces!Let’s compare a direct dependency and an inverted dependency first.</p>

<h4 data-number="4.5.5.1">Direct dependency</h4>
<p>A direct dependency occurs when a particular piece of code (like a class or a module) relies directly on another. For example, if Class A uses a method from Class B, then Class A directly depends on Class B, which is a typical scenario in traditional programming.Say we have a <code>SomeService</code> class that uses the <code>SqlDataPersistence</code> class for production but the <code>LocalDataPersistence</code> class during development and testing. Without inverting the dependency flow, we end up with the following UML dependency graph:</p>
<figure>
<img alt="Figure 3.2: Direct dependency graph schema" src="img/file14.png"/><figcaption aria-hidden="true">Figure 3.2: Direct dependency graph schema</figcaption>
</figure>
<p>With the preceding system, we could not change the <code>SqlDataPersistence</code> or <code>LocalDataPersistence</code> classes by the <code>CosmosDbDataPersistence</code> class (not in the diagram) without impacting the <code>SomeService</code> class.We call direct dependencies like these <strong>tight coupling</strong>.</p>


<h4 data-number="4.5.5.2">Inverted dependency</h4>
<p>An inverted dependency occurs when high-level modules (which provide complex logic) are independent of low-level modules (which provide basic, foundational operations). We can achieve this by introducing an abstraction (like an interface) between the modules. This means that instead of Class A depending directly on Class B, Class A would rely on an abstraction that Class B implements.Here is the updated schema that improves the direct dependency example:</p>
<figure>
<img alt="Figure 3.3: Indirect dependency graph schema" src="img/file15.png"/><figcaption aria-hidden="true">Figure 3.3: Indirect dependency graph schema</figcaption>
</figure>
<p>In the preceding diagram, we successfully inverted the dependency flow by ensuring the <code>SomeService</code> class depends only on an <code>IDataPersistance</code> interface (abstraction) that the <code>SqlDataPersistence</code> and <code>LocalDataPersistence</code> classes implement. We could then use the <code>CosmosDbDataPersistence</code> class (not in the diagram) without impacting the <code>SomeService</code> class.We call inverted dependencies like these <strong>loose coupling</strong>.Now that we covered how to invert the dependency flow of classes, we look at inverting subsystems.</p>


<h4 data-number="4.5.5.3">Direct subsystems dependency</h4>
<p>The preceding direct dependency example divided into packages, which have the same issue, would look like the following:</p>
<figure>
<img alt="Figure 3.3: direct dependency graph divided into packages" src="img/file16.png"/><figcaption aria-hidden="true">Figure 3.3: direct dependency graph divided into packages</figcaption>
</figure>
<p>The <code>Core</code> package depends on the <code>SQL</code> and <code>Local</code> packages leading to tight coupling.</p>
<blockquote>
<p>Packages usually represent assemblies or namespaces. However, dividing responsibilities around assemblies allows loading only the implementations that the program need. For example, one program could load the <code>Local</code> assembly, another could load the <code>SQL</code> assembly, and a third could load both.</p>
</blockquote>
<p>Enough said; let’s invert the dependency flow of those subsystems.</p>


<h4 data-number="4.5.5.4">Inverted subsystems dependency</h4>
<p>We discussed modules and packages, yet the example diagram of inverted dependency illustrated classes. Using a similar approach, we can reduce dependencies between subsystems and create more flexible programs by arranging our code in separate assemblies. This way, we can achieve loose coupling and improved modularity in our software. To continue the inverted dependency example, we can do the following:</p>
<ol>
<li>Create an abstraction assembly containing only interfaces.</li>
<li>Create other assemblies that contain the implementation of the contracts from that first assembly.</li>
<li>Create assemblies that consume the code through the abstraction assembly.</li>
</ol>
<blockquote>
<p>There are multiple examples of this in .NET, such as the <code>Microsoft.Extensions.DependencyInjection.Abstractions</code> and <code>Microsoft.Extensions.DependencyInjection</code> assemblies. We explore this concept further in <em>Chapter 12</em>, <em>Layering and Clean Architecture</em>.</p>
</blockquote>
<p>Then, if we divide the inverted dependency examples into multiple packages, it would look like the following:</p>
<figure>
<img alt="Figure 3.4: inverted dependency examples divided into multiple packages" src="img/file17.png"/><figcaption aria-hidden="true">Figure 3.4: inverted dependency examples divided into multiple packages</figcaption>
</figure>
<p>In the diagram, the <code>Core</code> package directly depends on the <code>Abstractions</code> package, while two implementations are available: <code>Local</code> and <code>Sql</code>. Since we only rely on abstractions, we can swap one implementation for the other without impacting <code>Core</code>, and the program will run just fine unless something is wrong with the implementation itself (but that has nothing to do with the DIP).We could also create a new <code>CosmosDb</code> package and a <code>CosmosDbDataPersistence</code> class that implements the <code>IDataPersistence</code> interface, then use it in the <code>Core</code> without breaking anything. Why? Because we are only directly depending on abstractions, leading to a loosely coupled system.Next, we dig into some code.</p>


<h4 data-number="4.5.5.5">Project – Dependency inversion</h4>
<p>In this section, we translate the preceding iteration of the inverted dependency example in code. We create the following assemblies to align with the preceding diagram:</p>
<ul>
<li><code>App</code> is a console application that references all projects to showcase different use cases.</li>
<li><code>Core</code> is a class library that depends on the <code>Abstractions</code> package.</li>
<li><code>Abstractions</code> is a class library that contains the <code>IDataPersistence</code> interface.</li>
<li><code>Sql</code> and <code>Local</code> are class libraries that reference the <code>Abstractions</code> project and implement the <code>IDataPersistence</code> interface.</li>
</ul>
<blockquote>
<p>The code sample has few implementation details because it is irrelevant to understanding the DIP. Please assume we implemented the <code>Persist</code> methods logic using your favorite in-memory and SQL databases.</p>
</blockquote>
<p>Visually, the relationships between the packages look like the following:</p>
<figure>
<img alt="Figure 3.5: the visual representation of the packages and their relationships" src="img/file18.png"/><figcaption aria-hidden="true">Figure 3.5: the visual representation of the packages and their relationships</figcaption>
</figure>
<p>Code-wise, our abstraction contains a <code>Persist</code> method that we use to showcase the DIP:</p>
<div><pre><code>namespace Abstractions;
public interface IDataPersistence
{
    void Persist();
}</code></pre>
</div>
<p>Next, the <code>LocalDataPersistence</code> class depends on the <code>Abstractions</code> package and outputs a line to the console, allowing us to trace what happens in the system:</p>
<div><pre><code>using Abstractions;
namespace Local;
public class LocalDataPersistence : IDataPersistence
{
    public void Persist()
    {
        Console.WriteLine("Data persisted by LocalDataPersistence.");
    }
}</code></pre>
</div>
<p>Next, the <code>SqlDataPersistence</code> class is very similar to the <code>LocalDataPersistence</code> class; it depends on the <code>Abstractions</code> package and outputs a line in the console, allowing us to trace what happens in the system:</p>
<div><pre><code>using Abstractions;
namespace Sql;
public class SqlDataPersistence : IDataPersistence
{
    public void Persist()
    {
        Console.WriteLine("Data persisted by SqlDataPersistence.");
    }
}</code></pre>
</div>
<p>Before we get to the program flow, we still have the <code>SomeService</code> class to look at, which depends on the <code>Abstractions</code> package:</p>
<div><pre><code>using Abstractions;
namespace App;
public class SomeService
{
    public void Operation(IDataPersistence someDataPersistence)
    {
        Console.WriteLine("Beginning SomeService.Operation.");
        someDataPersistence.Persist();
        Console.WriteLine("SomeService.Operation has ended.");
    }
}</code></pre>
</div>
<p>The highlighted code shows that the <code>SomeService</code> class calls the <code>Persist</code> method of the provided <code>IDataPersistence</code> interface implementation. The <code>SomeService</code> class is not aware of where the data go. In the case of full implementation, the <code>someDataPersistence</code> instance is responsible for where the data would be persisted. Other than that, the <code>Operation</code> method writes lines to the console so we can trace what happens. Now from the <code>App</code> package, the <code>Program.cs</code> file contains the following code:</p>
<div><pre><code>using Core;
using Local;
using Sql;
var sqlDataPersistence = new SqlDataPersistence();
var localDataPersistence = new LocalDataPersistence();
var service = new SomeService();
service.Operation(localDataPersistence);
service.Operation(sqlDataPersistence);</code></pre>
</div>
<p>In the preceding code, we create a <code>SqlDataPersistence</code> and a <code>LocalDataPersistence</code> instance. Doing that forced us to depend on both packages, but we could have chosen otherwise.Then we create an instance of the <code>SomeService</code> class. We then pass both <code>IDataPersistence</code> implementations to the <code>Operation</code> method one after the other.When we execute the program we get the following output:</p>
<div><pre><code>Beginning SomeService.Operation.
Data persisted by LocalDataPersistence.
SomeService.Operation has ended.
Beginning SomeService.Operation.
Data persisted by SqlDataPersistence.
SomeService.Operation has ended.</code></pre>
</div>
<p>The first half of the preceding terminal output represents the first call to the <code>Operation</code> method, where we passed the <code>LocalDataPersistence</code> instance. The second half represents the second call, where we passed the <code>SqlDataPersistence</code> instance.The highlighted lines show that depending on an interface allowed us to change this behavior (OCP). Moreover, we could create a <code>CosmosDb</code> package, reference it from the <code>App</code> package, then pass an instance of a <code>CosmosDbDataPersistence</code> class to the <code>Operation</code> method, and the <code>Core</code> package would not know about it. Why? Because we inverted the dependency flow, creating a loosely coupled system. We even did some <em>dependency injection</em>.</p>
<blockquote>
<p><strong>Dependency injection</strong>, or <strong>Inversion of Control</strong> (<strong>IoC</strong>), is a design principle that is a first-class citizen of ASP.NET Core. It allows us to map abstractions to implementations, and when we need a new type, the whole object tree gets created automatically based on our configuration. We start that journey in <em>Chapter 7</em>, <em>Dependency Injection</em>.</p>
</blockquote>


<h4 data-number="4.5.5.6">Conclusion</h4>
<p>The core idea is to depend on abstractions. Interfaces are pure contracts, which makes them more flexible than abstract classes. Abstract classes are still helpful, and we explore ways to leverage them in the book.Depending on implementations (classes) creates tight coupling between classes, which leads to a system that can be harder to maintain. The cohesion between your dependencies is essential in whether the coupling will help or hurt you in the long run. Don’t discard concrete types everywhere mindlessly.</p>




<h2 data-number="4.6">Summary</h2>
<p>In this chapter, we covered many architectural principles. We began by exploring DRY, KISS, and separation of concerns principles before learning about the SOLID principles and their importance in modern software engineering. By following those principles, you should be able to build better, more maintainable software.As we also covered, principles are only principles, not laws. You must always be careful not to abuse them so they remain helpful instead of harmful. The context is always essential; internal tools and critical business applications require different levels of tinkering. The key takeaways from this chapter are:</p>
<ul>
<li>Don’t over-engineer your solutions (KISS). </li>
<li>Encapsulate and reuse business logic (DRY). </li>
<li>Organize elements around concerns and responsibilities (SoC/SRP).</li>
<li>Aim at composability (OCP).</li>
<li>Support backward compatibility (LSP).</li>
<li>Write granular interfaces/contracts (ISP).</li>
<li>Depend on abstractions and invert the dependency flow (DIP).</li>
</ul>
<p>With all those principles in our toolbox, we are ready to jump into design patterns and get our design level one step further, with the next chapter covering the MVC pattern in the context of ASP.NET Core REST APIs.Afterward, in the following few chapters, we explore how to implement some of the most frequently used Gang of Four (GoF) patterns and then how to apply them at another level using dependency injection.</p>


<h2 data-number="4.7">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>How many principles are represented by the SOLID acronym?</li>
<li>Is it true that when following the SOLID principles, the idea is to create bigger components that can each manage more elements of a program by creating God-sized classes?</li>
<li>By following the DRY principle, you want to remove all code duplication from everywhere, irrespective of the source, and encapsulate that code into a reusable component. Is this affirmation correct?</li>
<li>Is it true that the ISP tells us that creating multiple smaller interfaces is better than creating one large one?</li>
<li>What principle tells us that creating multiple smaller classes that handle a single responsibility is better than one class handling multiple responsibilities?</li>
</ol>


<h2 data-number="4.8">Further reading</h2>
<ul>
<li>Covariance and contravariance (C#): <a href="https://adpg.link/BxBG">https://adpg.link/BxBG</a></li>
</ul>


</body>
</html>
