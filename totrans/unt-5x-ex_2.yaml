- en: Chapter 2. Project A – the Collection Game Continued
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter continues from the previous one by building a collection game with
    Unity. In this game, the player wanders an environment in first-person mode, searching
    for and collecting all coins in a scene before a global timer expires. If all
    coins are collected before timer expiry, the game is won. However, if the timer
    expires before all coins are collected, the game is lost. The project created
    so far features a complete environment, with a floor, props, and water, and it
    also features a first-person controller along with a basic coin object, which
    looks correct in shape and form but still cannot be collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter completes the project by creating a coin object to collect and
    adding a timer system to determine whether the total game time has elapsed. In
    essence, this chapter is about defining a system of logic and rules governing
    the game. To achieve this, we''ll need to code in C# and so this chapter requires
    a basic understanding of programming. This book is about Unity and developing
    games with that engine. The basics of programming as a subject is, however, beyond
    the scope of this book. So I''ll assume that you already have a working knowledge
    of coding generally but have simply not coded in Unity before. Overall, this chapter
    will demonstrate the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Material creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing script files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and compiling games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a coin material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter closed by creating a basic coin object from a non-uniformly
    scaled cylinder primitive. This object was created by selecting **GameObject**
    | **3D Object** | **Cylinder** from the application menu. See *Figure 2.1*. The
    coin object, as a concept, represents a basic or fundamental unit in our game
    logic because the player character should be actively searching the level looking
    for coins to collect before a timer runs out. This means that the coin is more
    than mere *appearance*; its purpose in the game is not simply eye candy, but is
    functional. It makes an immense difference to the game outcome whether the coin
    is collected by the player or not. Therefore, the coin object, as it stands, is
    lacking in two important respects. Firstly, it looks dull and grey—it doesn't
    really stand out and grab the player's attention. Secondly, the coin cannot actually
    be collected yet. Certainly, the player can walk into the coin, but nothing appropriate
    happens in response.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The coin object so far'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The completed `CollectionGame` project, as discussed in this chapter and the
    next, can be found in the book companion files in the `Chapter02/CollectionGame`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll focus on improving the coin appearance using a **material**.
    A material defines an algorithm (or instruction set) specifying how the coin should
    be rendered. A material doesn't just say what the coin should look like in terms
    of color; it defines how shiny or smooth a surface is, as opposed to rough and
    diffuse. This is important to recognize and is why a texture and material refer
    to different things. A texture is simply an image file loaded in memory, which
    can be wrapped around a 3D object via its UV mapping. In contrast, a material
    defines how one or more textures can be combined together and applied to an object
    to shape its appearance. To create a new material asset in Unity, right-click
    on an empty area in the **Project** panel, and from the context menu, choose **Create**
    | **Material**. See *Figure 2.2*. You can also choose **Assets** | **Create**
    | **Material** from the application menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Creating a material'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A material is sometimes called a **Shader**. If needed, you can create custom
    materials using a **Shader Language** or you can use a Unity add-on, such as **Shader
    Forge**.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new material, assign it an appropriate name from the Project
    panel. As I''m aiming for a gold look, I''ll name the material `mat_GoldCoin`.
    Prefixing the asset name with `mat` helps me know, just from the asset name, that
    it''s a material asset. Simply type a new name in the text edit field to name
    the material. You can also click on the material name twice to edit the name at
    any time later. See *Figure 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Naming a material asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select the material asset in the **Project** panel, if it''s not already
    selected, and its properties display immediately in the **Object Inspector**.
    There are lots of properties listed! In addition, a material preview displays
    at the bottom of the **Object Inspector**, showing you how the material would
    look, based on its current settings, if it were applied to a 3D object, such as
    a sphere. As you change material settings from the **Inspector**, the preview
    panel updates automatically to reflect your changes, offering instant feedback
    on how the material would look. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Material properties are changed from the Object Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a gold material for the coin. When creating any material,
    the first setting to choose is the **Shader** type because this setting affects
    all other parameters available to you. The **Shader** type determines which algorithm
    will be used to shade your object. There are many different choices, but most
    material types can be approximated using either **Standard** or **Standard (Specular
    setup)**. For the gold coin, we can leave the **Shader** as **Standard**. See
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Setting the material Shader type'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the preview panel displays the material as a dull grey, which is
    far from what we need. To define a gold color, we must specify the **Albedo**.
    To do this, click on the **Albedo** color slot to display a **Color** picker,
    and from the **Color** picker dialog, select a gold color. The material preview
    updates in response to reflect the changes. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Selecting a gold color for the Albedo channel'
  prefs: []
  type: TYPE_NORMAL
- en: 'The coin material is looking better than it did, but it''s still supposed to
    represent a metallic surface, which tends to be shiny and reflective. To add this
    quality to our material, click and drag the **Metallic** slider in the **Object
    Inspector** to the right-hand side, setting its value to `1`. This indicates that
    the material represents a fully metal surface as opposed to a diffuse surface
    such as cloth or hair. Again, the preview panel will update to reflect the change.
    See *Figure 2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Creating a metallic material'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a gold material created, and it''s looking good in the preview
    panel. If needed, you can change the kind of object used for a preview. By default,
    Unity assigns the created material to a sphere, but other primitive objects are
    allowed, including cubes, cylinders, and torus. This helps you preview materials
    under different conditions. You can change objects by clicking on the geometry
    button directly above the preview panel to cycle through them. See *Figure 2.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Previewing a material on an object'
  prefs: []
  type: TYPE_NORMAL
- en: 'When your material is ready, you can assign it directly to meshes in your scene
    just by dragging and dropping. Let''s assign the coin material to the coin. Click
    and drag the material from the **Project** panel to the coin object in the scene.
    On dropping the material, the coin will change appearance. See *Figure 2.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Assigning the material to the coin'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm that material assignment occurred successfully and can even
    identify which material was assigned by selecting the `Coin` object in the **Scene**
    and viewing its **Mesh Renderer** component from the **Object Inspector**. The
    **Mesh Renderer** component is responsible for making sure that a mesh object
    is actually visible in the scene when the camera is looking. The **Mesh Renderer**
    component contains a **Materials** field. This lists all materials currently assigned
    to the object. By clicking on the material name from the **Materials** field,
    Unity automatically selects the material in the **Project** panel, making it quick
    and simple to locate materials. See *Figure 2.10*, The **Mesh Renderer** component
    lists all materials assigned to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a coin material](img/figure_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: The Mesh Renderer component lists all materials assigned to an
    object'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mesh objects may have multiple materials with different materials assigned to
    different faces. For the best in-game performance, use as few unique materials
    on an object as necessary. Make the extra effort to share materials across multiple
    objects, if possible. Doing so can significantly enhance the performance of your
    game. For more information on optimizing rendering performance, see the online
    documentation at [http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html).
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You now have a complete and functional gold material for the collectible
    coin. It's looking good. However, we're still not finished with the coin. The
    coin looks right, but it doesn't behave right. Specifically, it doesn't disappear
    when touched, and we don't yet keep track of how many coins the player has collected
    overall. To address this, then, we'll need to script.
  prefs: []
  type: TYPE_NORMAL
- en: C# scripting in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining game logic, rules, and behavior often requires scripting. Specifically,
    to transform a static and lifeless scene with objects into an environment that
    does something, a developer needs to code behaviors. It requires someone to define
    how things should act and react under specific conditions. The coin collection
    game is no exception to this. In particular, it requires three main features:'
  prefs: []
  type: TYPE_NORMAL
- en: To know when the player collects a coin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep track of how many coins are collected during gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine whether a timer has expired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s no default out-of-the-box functionality included with Unity to handle
    this scenario. So we must write some code to achieve it. Unity supports two languages,
    namely, UnityScript (sometimes called JavaScript) and C#. Both are capable and
    useful languages, but this book uses C# because, going forward, support for JavaScript
    will eventually be dropped. Let''s start coding these three features in sequence.
    To create a new script file, right-click on an empty area in the **Project** panel,
    and from the context menu, choose **Create** | **C# Script**. Alternatively, you
    can navigate to **Assets** | **Create** | **C# Script** from the application menu.
    See *Figure 2.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C# scripting in Unity](img/figure_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Creating a new C# script'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the file is created, you''ll need to assign a descriptive name to it.
    I''ll call it `Coin.cs`. In Unity, each script file represents a single, discrete
    class of matching names. Hence, the `Coin.cs` file encodes the `Coin` class. The
    `Coin` class will encapsulate the behavior of a `Coin` object and will, eventually,
    be attached to the `Coin` object in the scene. See *Figure 2.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C# scripting in Unity](img/figure_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Naming a script file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the `Coin.cs` file from the **Object Inspector** to open it
    to edit in **MonoDevelop**, a third-party IDE application that ships with Unity.
    This program lets you edit and write code for your games. Once opened in MonoDevelop,
    the source file will appear, as shown in *Code Sample 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register to our website using your e-mail address and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Code Downloads & Errata**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the name of the book in the **Search** box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the book for which you're looking to download the code files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose from the drop-down menu where you purchased this book from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Code Download**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR / 7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg / iZip / UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip / PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, all newly created classes derive from `MonoBehavior`, which defines
    a common set of functionality shared by all components. The `Coin` class features
    two autogenerated functions, namely `Start` and `Update`. These functions are
    events invoked automatically by Unity. `Start` is called once as soon as the `GameObject`
    (to which the script is attached) is created in the **Scene**. `Update` is called
    once per frame on the object to which the script is attached. `Start` is useful
    for initialization code and `Update` is useful to create behaviors over time,
    such as motion and change. Now, before moving any further, let''s attach the newly
    created script file to the `Coin` object in the **Scene**. To do this, drag and
    drop the `Coin.cs` script file from the **Project** panel on the `Coin` object.
    When you do this, a new **Coin** component is added to the object. This means
    that the script is instantiated and lives on the object. See *Figure 2.13*, attaching
    a script file to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C# scripting in Unity](img/figure_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Attaching a script file to an object'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a script is attached to an object, it exists on the object as a component.
    A script file can normally be added to multiple objects and even to the same object
    multiple times. Each component represents a separate and unique instantiation
    of the class. When a script is attached in this way, Unity automatically invokes
    its events, such as `Start` and `Update`. You can confirm that your script is
    working normally by including a `Debug.Log` statement in the `Start` function.
    This prints a debug message to the **Console** window when the `GameObject` is
    created in the **Scene**. Consider *Code Sample 2.2*, which achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you press play (*Ctrl* + *P*) on the toolbar to run your game with the preceding
    script attached to an object, you will see the message, **Object Created**, printed
    to the **Console** window—once for each instantiation of the class. See *Figure
    2.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C# scripting in Unity](img/figure_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Printing messages to the Console window'
  prefs: []
  type: TYPE_NORMAL
- en: Good work! We've now created a basic script for the `Coin` class and attached
    it to the coin. Next, let's define its functionality to keep track of coins as
    they are collected.
  prefs: []
  type: TYPE_NORMAL
- en: Counting coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The coin collection game wouldn''t really be much of a game if there were only
    one coin. The central idea is that a level should feature many coins, all of which
    the player should collect before a timer expires. Now, to know whether all coins
    have been collected, we''ll need to know how many coins there are in total in
    the scene. After all, if we don''t know how many coins there are, then we can''t
    know if we''ve collected them all. So, our first task in scripting is to configure
    the `Coin` class so that we can know the total number of coins in the scene at
    any moment easily. Consider *Code Sample 2.3*, which adapts the `Coin` class to
    achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 2.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Coin` class maintains a static member variable, `CoinCount`, which, being
    static, is shared across all instances of the class. This variable keeps count
    of the total number of coins in the scene and each instance has access to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Start` function is called once per `Coin` instance when the object is created
    in the **Scene**. For coins that are present when the scene begins, the `Start`
    event is called at scene startup. This function increments the `CoinCount` variable
    by one per instance, thus keeping count of all coins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnDestroy` function is called once per instance when the object is destroyed.
    This decrements the `CoinCount` variable, reducing the count for each coin destroyed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altogether, *Code Sample 2.3* maintains a `CoinCount` variable. In short, this
    variable allows us to always keep track of the total coin count. We can query
    it easily to determine how many coins remain. This is good, but is only the first
    step towards completing the coin collection functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we developed a coin counting variable telling us how many coins
    are in the scene. However, regardless of the count, the player still can't collect
    the coins during gameplay. Let's fix this now. To start, we need to think about
    collisions. Thinking carefully, we know that a coin is considered collected whenever
    the player walks into it, that is, a coin is collected when the player and the
    coin intersect or collide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine when a collision happens like that, we must approximate the volume
    of both the player and coin in order to determine when the two volumes overlap
    in space. This is achieved in Unity through colliders. Colliders are special physics
    objects attached to meshes. They tell us when two meshes intersect. The `FPSController`
    object (First-person controller) already has a collider on it, through its **Character
    Controller** component. This approximates the physical body of a generic person.
    This can be confirmed by selecting `FPSController` in the **Scene** and examining
    the green wireframe cage surrounding the main camera. It is capsule-shaped. See
    *Figure 2.15*, the **Character Controller** features a Collider to approximate
    the player body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: The Character Controller features a collider to approximate the
    player body'
  prefs: []
  type: TYPE_NORMAL
- en: '`FPSController` features a **Character Controller** component attached, which
    is configured by default with **Radius**, **Height**, and **Center** settings,
    defining the physical extents of the character in the scene. See *Figure 2.16*,
    `FPSController` features **Character Controller**. These settings can be left
    unchanged for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: FPSController features a Character Controller'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Coin` object, in contrast, features only a **Capsule Collider** component,
    which was added automatically when we created the **Cylinder** primitive earlier
    to resemble a coin. This approximates the coin''s physical volume in the scene
    without adding any additional features specific to characters and motion as found
    in the **Character Controller** component. This is fine, because the coin is a
    **Static** object as opposed to a moving and dynamic object like the `FPSController`.
    See *Figure 2.17*, **Cylinder** primitives feature a **Capsule Collider** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Cylinder primitives feature a Capsule Collider component'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, I''ll stick to using a **Capsule Collider** component for
    the `Coin` object. However, if you want to change the attached collider to a different
    shape instead, such as a box or sphere, you can do this by first removing any
    existing collider components on the coin—click on the cog icon of the component
    in the **Object Inspector** and then select **Remove Component** from the context
    menu. See *Figure 2.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Removing a component from an object'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then add a new collider component to the selected object by choosing
    **Component** | **Physics** from the application menu and then choosing a suitably
    shaped collider. See *Figure 2.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Adding a component to the selected object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the collider type used, there''s a minor problem. If you play
    the game now and try to run through the coin, it''ll block your path. The coin
    acts as a solid, physical object through which `FPSController` cannot pass. However,
    for our purposes, this isn''t how the coin should behave. It''s supposed to be
    a collectible object. The idea is that when we walk through it, the coin is collected
    and disappears. We can fix this easily by selecting the `Coin` object and enabling
    the **Is Trigger** checkbox in the **Capsule Collider** component, in the **Object
    Inspector**. The **Is Trigger** setting appears for almost all collider types.
    It lets us detect collisions and intersections with other colliders while allowing
    them to pass through. See *Figure 2.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: The Is Trigger setting allows objects to pass through colliders'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play the game now, `FPSController` will easily walk through all coin
    objects in the scene. This is a good start. However, the coins don''t actually
    disappear when touched; they still don''t get collected. To achieve this, we''ll
    need to add more script to the `Coin.cs` file. Specifically, we''ll add an `OnTriggerEnter`
    function. This function is called automatically when an object, like the player,
    enters a collider. For now, we''ll add a `Debug.Log` statement to print a debug
    message when the player enters the collider, just for test purposes. See *Code
    Sample 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information on the `OnTriggerEnter` function can be found at the online
    Unity documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the *Code Sample 2.4* by pressing play on the toolbar. When you run into
    a coin, the `OnTriggerEnter` function will be executed and the message displayed.
    However, the question remains as to what object initiated this function in the
    first place. It''s true that something collided with the coin, but what exactly?
    Was it the player, an enemy, a falling brick, or something else? To check this,
    we''ll use **Tag**. The **Tag** feature lets you mark specific objects in the
    scene with specific tags or labels, allowing these objects to be easily identified
    in code so that we can check quickly that the player, rather than other objects,
    are colliding with the coins. After all, it should only be the player that can
    collect coins. So, firstly, we''ll tag the player object with a tag called **Player**.
    To do this, select the `FPSController` object in the scene and then click on the
    **Tag** drop-down box in the **Object Inspector**. From here, select the **Player**
    tag. This marks `FPSController` as the `Player` object. See *Figure 2.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting coins](img/figure_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: Tagging FPSController as Player'
  prefs: []
  type: TYPE_NORMAL
- en: With `FPSController` now tagged as **Player**, we can refine the `Coin.cs` file,
    as shown in *Code Sample 2.5*. This handles coin collection, making the coin disappear
    on touch and decreasing the coin count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 2.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter` is called once automatically by Unity each time `FPSController`
    intersects the `Coin` collider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `OnTriggerEnter` is called, the `Col` argument contains information about
    the object that entered the collider on this occasion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CompareTag` function is used to determine if the colliding object is the
    `Player` as opposed to a different object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Destroy` function is called to destroy the `Coin` object itself, represented
    internally by the inherited member variable, `gameObject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `Destroy` function is called, the `OnDestroy` event is invoked automatically,
    which decrements the `Coin` count
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Excellent work! You've just created your first working coin. The player can
    now run into the coin, collect it, and remove it from the scene. This is a great
    beginning, but the scene should contain more than one coin. We could solve this
    by duplicating the existing coin many times and repositioning each duplicate to
    a different place. However, there's a better way, as we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Coins and prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic coin functionality is now created, but the scene needs more than one
    coin. The problem with simply duplicating a coin and scattering the duplicates
    is that if we make a change later to one coin and need to propagate that change
    to all other coins, we'd need to delete the former duplicates and manually replace
    those with newer and amended duplicates. To avoid this tedious repetition, we
    can use prefabs. Prefabs let you convert an object in the scene to `Assets` in
    the **Project** panel. This can be instantiated in the scene as frequently as
    needed, as though it were a mesh asset. The advantage is that changes made to
    the asset are automatically applied to all instances automatically, even across
    multiple scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it easier to work with custom assets, so let''s prefab the coin
    right now. To do this, select the `Coin` object in the scene and then drag and
    drop it in the **Project** panel. When this happens, a new `prefab` is created.
    The object in the scene is automatically updated to be an instance of `prefab`.
    This means that if the asset is deleted from the `Project` panel, the instance
    will become invalidated. See *Figure 2.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coins and prefabs](img/figure_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: Creating a coin prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'After `prefab` is created, you can add more instances of the coin easily to
    the level by dragging and dropping `prefab` from the **Project** panel to the
    **Scene**. Each instance is linked to the original `prefab` asset, which means
    that all changes made to the asset will immediately be made to all instances.
    With this in mind, go ahead now and add as many `Coin` prefabs to the level as
    suitable for your coin collection game. Refer to the following figure for my arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coins and prefabs](img/figure_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: Adding coin prefabs to the level'
  prefs: []
  type: TYPE_NORMAL
- en: 'One question that naturally arises is how you can transform prefab back into
    an independent `GameObject` that is no longer connected to the `prefab` asset.
    This is useful to do if you want some objects to be based on `prefab` but deviate
    from it slightly. To achieve this, select a `prefab` instance in the **Scene**,
    and then navigate to **GameObject** | **Break Prefab Instance** from the application
    menu. See *Figure 2.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coins and prefabs](img/figure_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.24: Breaking the prefab instance'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you add a `prefab` instance to **Scene** and make changes to it that you
    like and want to distribute upstream back to the `prefab` asset, then select the
    object and choose **GameObject** | **Apply Changes to Prefab**.
  prefs: []
  type: TYPE_NORMAL
- en: Timers and countdowns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now have a level complete with geometry and coin objects. Thanks
    to our newly added `Coin.cs` script, the coins are both countable and collectible.
    Even so, the level still poses little or no challenge to the player because there''s
    no way the level can be won or lost. Specifically, there''s nothing for the player
    to achieve. This is why a time limit is important for the game: it defines a win
    and loss condition. Namely, collecting all coins before the timer expires results
    in a win condition and failing to achieve this results in a loss condition. Let''s
    get started at creating a timer countdown for the level. To do this, create a
    new and empty game object by selecting **GameObject** | **Create Empty** and rename
    this to `LevelTimer`. See *Figure 2.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers and countdowns](img/figure_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.25: Renaming the timer object'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that empty game objects cannot be seen by the player because they have
    no mesh renderer component. They are especially useful to create functionality
    and behaviors that don't correspond directly to physical and visible entities,
    such as timers, managers, and game logic controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new script file named `Timer.cs` and add it to the `LevelTimer`
    object in **Scene**. By doing this, the timer functionality will exist in the
    scene. Make sure, however, that the timer script is added to one object, and no
    more than one. Otherwise, there will effectively be multiple, competing timers
    in the same scene. You can always search a scene to find all components of a specified
    type by using the **Hierarchy** panel. To do this, click in the **Hierarchy**
    search box and type `t:Timer`. Then press *Enter* on the keyboard to confirm the
    search. This searches the scene for all objects with a component attached of the
    timer type, and the results are displayed in the **Hierarchy** panel. Specifically,
    the **Hierarchy** panel is filtered to show only the matching objects. The `t`
    prefix in the search string indicates a search by type operation. See *Figure
    2.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers and countdowns](img/figure_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.26: Searching for objects with a component of matching type'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily cancel a search and return the **Hierarchy** panel back to its
    original state by clicking on the small cross icon aligned to the right-hand side
    of the search field. This button can be tricky to spot. See *Figure 2.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timers and countdowns](img/figure_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.27: Canceling a type search'
  prefs: []
  type: TYPE_NORMAL
- en: The timer script itself must be coded if it's to be useful. The full source
    code for the `Timer.cs` file is given in the following *Code Sample 2.6*. This
    source code is highly important if you've never scripted in Unity before. It demonstrates
    so many critical features. See the comments for a fuller explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 2.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, class variables declared as `public` (such as `public float MaxTime`)
    are displayed as editable fields in the **Object Inspector** of the editor. However,
    this applies to a range of supported data types only, but it's a highly useful
    feature. It means that developers can monitor and set `public` variables for classes
    directly from the **Inspector** as opposed to changing and recompiling code every
    time a change is needed. The `private` variables, in contrast, are hidden from
    the **Inspector** by default. However, you can force them to be visible, if needed,
    using the `SerializeField` attribute. The `private` variables prefixed with this
    attribute, such as the `CountDown` variable, will be displayed in the **Object
    Inspector** just like a `public` variable, even though the variable's scope still
    remains `private`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Update` function is a Unity native event supported for all classes derived
    from `MonoBehaviour`. `Update` is invoked automatically once per frame for all
    active `GameObjects` in the scene. This means that all active game objects are
    notified about frame change events. In short, `Update` is therefore called many
    times per second; the game FPS is a general indicator as to how many times each
    second. The actual number of calls will vary in practice from second to second.
    In any case, `Update` is especially useful to animate, update, and change objects
    over time. In the case of a `CountDown` class, it'll be useful to keep track of
    time as it passes, second by second. More information on the `Update` function
    can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the `Update` function called on each frame, Unity also supports
    two other related functions, namely, `FixedUpdate` and `LateUpdate`. `FixedUpdate`
    is used when coding with **Physics**, as we'll see later, and is called a fixed
    number of times per frame. `LateUpdate` is called once per frame for each active
    object, but the `LateUpdate` call will always happen after every object has received
    an `Update` event. Thus, it happens after the `Update` cycle, making it a late
    update. There are reasons for this late update and we'll see them later in the
    book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More information on `FixedUpdate` can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html).
    More information on the `LateUpdate` function can be found in the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When scripting, the static `Time.deltaTime` variable is constantly available
    and updated automatically by Unity. It always describes the amount of time (in
    seconds) that has passed since the previous frame ended. For example, if your
    game has a frame rate of 2 FPS (a very low frame rate!) then `deltaTime` will
    be `0.5`. This is because, in each second, there would be two frames, and thus
    each frame would be half a second. The `deltaTime` is useful because, if added
    over time, it tells you how much time in total has elapsed or passed since the
    game began. For this reason, `deltaTime` floating point variable is used heavily
    in the `Update` function for the timer to subtract the elapsed time from the countdown
    total. More information can be found on `deltaTime` at the online documentation
    at [http://docs.unity3d.com/ScriptReference/Time-deltaTime.html](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static `Application.LoadLevel` function can be called anywhere in code to
    change the active scene at runtime. Thus, this function is useful to move the
    gamer from one level to another. It causes Unity to terminate the active scene,
    destroying all its contents, and load a new scene. It can also be used to restart
    the active scene, simply by loading the active level again. `Application.LoadLevel`
    is most appropriate for games with clearly defined levels that are separate from
    each other and have clearly defined beginnings and endings. It is not, however,
    suitable for large open-world games in which large sprawling environments stretch
    on, seemingly without any breakage or disconnection. More information on `Application.LoadLevel`
    can be found in the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html](http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the timer script is created, select the `LevelTimer` object in the scene.
    From the **Object Inspector**, you can set the maximum time (in seconds) that
    the player is allowed in order to complete the level. See *Figure 2.28*. I've
    set the total time to `60` seconds. This means that all coins must be completed
    within `60` seconds from the level start. If the timer expires, the level is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 2.6](img/figure_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.28: Setting the level total time'
  prefs: []
  type: TYPE_NORMAL
- en: Great work! You should now have a completed level with a countdown that works.
    You can collect coins and the timer can expire. Overall, the game is taking shape.
    There is a further problem, however, which we'll address next.
  prefs: []
  type: TYPE_NORMAL
- en: Celebrations and fireworks!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coin collection game is nearly finished. Coins can be collected and a timer
    expires, but the win condition itself is not truly handled. That is, when all
    coins are collected before time expiry, nothing actually happens to show the player
    that they've won. The countdown still proceeds and even restarts the level as
    though the win condition hadn't been satisfied at all. Let's fix this now. Specifically,
    when the win scenario happens, we should delete the timer object to prevent further
    countdown and show visual feedback to signify that the level has been completed.
    In this case, I'll add some fireworks! So, let's start by creating the fireworks.
    You can add these easily from the Unity 5 **Particle System** packages. Navigate
    to the `Standard Assets` | `ParticleSystems` | `Prefabs` folder. Then, drag and
    drop the `Fireworks` particle system in **Scene**. Add a second or even a third
    one if you want.
  prefs: []
  type: TYPE_NORMAL
- en: '![Celebrations and fireworks!](img/figure_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.29: Adding two Fireworks prefabs'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all firework particle systems will play when the level begins.
    You can test this by pressing play on the toolbar. This is not the behavior that
    we want. We only want the fireworks to play when the win condition has been satisfied.
    To disable playback on level startup, select the **Particle System** object in
    the **Scene** and, from the **Object Inspector**, disable the **Play On Awake**
    checkbox, which can be found in the **Particle System** component. See *Figure
    2.30*, Disabling **Play On Awake**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Celebrations and fireworks!](img/figure_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.30: Disabling Play On Awake'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disabling **Play On Awake** prevents particle systems playing automatically
    at level startup. This is fine, but if they are ever to play at all, something
    must manually start them at the right time. We can achieve this through code.
    Before resorting to a coding solution, however, we''ll first mark all firework
    objects with an appropriate tag. The reason for this is that, in code, we''ll
    want to search for all firework objects in the scene and trigger them to play
    when needed. To isolate the firework objects from all other objects, we''ll use
    tags. So, let''s create a new **Fireworks** tag and assign them to the firework
    objects only in the **Scene**. Tags were created earlier in this chapter when
    configuring the player character for coin collisions. See *Figure 2.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Celebrations and fireworks!](img/figure_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.31: Tagging firework objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the firework objects now tagged, we can refine the `Coin.cs` script class
    to handle a win condition for the scene, as shown in *Code Sample 2.7*. Comments
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 2.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnDestroy` function is critical. It occurs when a coin is collected and
    features an `if` statement to determine when all coins are collected (the win
    scenario).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a win scenario happens, the `GameObject.Find` function is called to search
    the complete scene hierarchy for any active object named `LevelTimer`. If found,
    the object is deleted. This happens to delete the timer and prevent any further
    countdown when the level is won. If the scene contains multiple objects of a matching
    name, then only the first object is returned. This is one reason why the scene
    should contain one and only one timer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using the `GameObject.Find` function wherever possible. It's slow for
    performance. Instead, use `FindGameObjectsWithTag`. It's been used here only to
    demonstrate its existence and purpose. Sometimes, you'll need to use it to find
    a single, miscellaneous object that has no specific tag.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition to deleting the `LevelTimer` object, the `OnDestroy` function finds
    all firework objects in the scene and initiates them. It finds all objects of
    a matching tag using the `GameObject.FindGameObjectsWithTag` function. This function
    returns an array of all objects with the **Fireworks** tag and the `ParticleSystem`
    is initiated for each object by calling the `Play` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, each `GameObject` in Unity is really made from a collection of
    attached and related components. An object is the sum of its components. For example,
    a standard cube (created using **GameObject** | **3D Object** | **Cube**) is made
    from a **Transform** component, **Mesh Filter** component, **Mesh Renderer** component,
    and **Box Collider** component. These components together make the cube what it
    is and behave how it does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `GetComponent` function can be called in script to retrieve a reference
    to any specified component, giving you direct access to its public properties.
    The `OnDestroy` function in the preceding code uses `GetComponent` to retrieve
    a reference to the `ParticleSystem` component attached to the object. `GetComponent`
    is a highly useful and important function. More information on `GetComponent`
    can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html](http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Play testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve now completed your first game in Unity! It''s time to take it for a
    test run and then finally build it. Testing in Unity firstly consists of pressing
    play on the toolbar and simply playing your game to see that it works as intended
    from the perspective of a gamer. In addition to playing, you can also enable debugging
    mode from the **Object Inspector** to keep a watchful eye on all `public` and
    `private` variables during runtime, making sure that no variable is assigned an
    unexpected value. To activate the **Debug** mode, click on the menu icon at the
    top right corner of the **Object Inspector** and, from the context menu that appears,
    select the **Debug** option. See *Figure 2.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play testing](img/figure_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.32: Activating Debug mode from the Object Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'After activating the **Debug** mode, the appearance of some variables and components
    in the **Object Inspector** may change. Typically, you''ll get a more detailed
    and accurate view of your variables, and you''ll also be able to see most `private`
    variables. See *Figure 2.33* for the **Transform** component in **Debug** mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play testing](img/figure_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.33: Viewing the Transform component in Debug mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful debugging tool at runtime is the **Stats** panel. This can be
    accessed from the **Game** tab by clicking on the **Stats** button from the toolbar.
    See *Figure 2.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play testing](img/figure_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.34: Accessing the Stats panel from the Game tab'
  prefs: []
  type: TYPE_NORMAL
- en: The **Stats** panel is only useful during the play mode. In this mode, it details
    the critical performance statistics for your game, such as Frame Rate (FPS) and
    memory usage. This lets you diagnose or determine whether any problems may be
    affecting your game. The FPS represents the total number of frames (ticks or cycles)
    per second that your game can sustain on average. There is no right, wrong, or
    magical FPS, but higher values are better than lower ones. Higher values represent
    better performance because it means that your game can sustain more cycles in
    one second. If your FPS falls below 20 or 15, it's likely that your game will
    appear choppy or laggy as the performance weight of each cycle means it takes
    longer to process. Many variables can affect FPS, some internal and some external
    to your game. Internal factors include the number of lights in a scene, vertex
    density of meshes, number of instructions, and complexity of code. Some external
    factors include the quality of your computer's hardware, number of other applications
    and processes running at the same time, amount of hard drive space, among others.
  prefs: []
  type: TYPE_NORMAL
- en: In short, if your FPS is low, then it indicates a problem that needs attention.
    The solution to that problem varies depending on the context and you'll need to
    use judgement, for example, are your meshes too complex? Do they have too many
    vertices? Are your textures too large? Are there too many sounds playing? See
    *Figure 2.35* for the coin collection game up and running. The completed game
    can be found in the book companion files in the `Chapter02/End` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Play testing](img/figure_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.35: Testing the coin collection game'
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now it's time to build the game! That is, to compile and package the game
    into a standalone and self-executing form, which the gamer can run and play without
    needing to use the Unity Editor. Typically, when developing games, you'll reach
    a decision about your target platform (such as Windows, iOS, Android, and others)
    during the design phase and not at the end of development. It's often said that
    Unity is a 'develop once, deploy everywhere tool. This slogan can conjure up the
    unfortunate image that, after a game is made, it'll work just as effortlessly
    on every platform supported by Unity as it does on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, things are not so simple; games that work well on desktop systems
    don''t necessarily perform equally well on mobiles and vice versa. This is largely
    due to the great differences in target hardware and industry standards that hold
    between them. Due to these differences, I''ll focus our attention here to the
    Windows and Mac desktop platforms, ignoring mobiles and consoles and other platforms.
    To create a Build for desktop platform, select **File** | **Build Settings** from
    the **File** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.36: Accessing the Build Settings for the project'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Build Settings** dialog is displayed and its interface consists of three
    main areas. The **Scenes In Build** list is a complete list of all scenes to be
    included in the build, regardless of whether the gamer will actually visit them
    in the game. It represents the totality of all scenes that could ever be visited
    in the game. In short, if you want or need a scene in your game, then it needs
    to be in this list. Initially, the list is empty. See *Figure 2.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.37: The Build Settings dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily add scenes to the list by simply dragging and dropping the scene
    asset from the **Project** panel to the **Scenes In Build** list. For the coin
    collection game, I''ll drag and drop the `Level_01` scene to the list. As scenes
    are added, Unity automatically assigns them a number, depending on their order
    in the list. **0** represents the topmost item, 1 the next item, and so on. This
    number is important insofar as the **0** item is concerned. The topmost scene
    (scene 0) will always be the starting scene. That is, when the build runs, Unity
    automatically begins execution from scene 0\. Thus, scene 0 will typically be
    your splash or intro scene. See *Figure 2.38*, Adding a level to the **Build Settings**
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.38: Adding a level to the Build Settings dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, be sure to select your target platform from the **Platform** list at
    the bottom left-hand side of the **Build Settings** dialog. For desktop platforms,
    choose **PC, Mac & Linux Standalone**, which should be selected by default. Then,
    from the options, set the **Target Platform** drop-down list to either **Windows**,
    **Linux**, or **Mac OS X**, depending on your system. See *Figure 2.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.39: Choosing a target build platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve previously been testing your game for multiple platforms or trying
    out other platforms such as **Android** and **iOS**, the **Switch Platform** button
    (at the bottom left of the **Build Settings** dialog) might become active when
    you select the **Standalone** option. If it does, click on the **Switch** **Platform**
    button to confirm to Unity that you intend building for the selected platform.
    On clicking this, Unity may spend a few minutes configuring your assets for the
    selected platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.40: Switching platforms'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before building for the first time, you''ll probably want to view the **Player
    Settings** options to fine-tune important build parameters, such as game resolution,
    quality settings, executable icon, and information, among other settings. To access
    the **Player Settings**, you can simply click on the **Player Settings** button
    from the **Build** dialog. This displays the **Player Settings** in the **Object
    Inspector**. The same settings can also be accessed via the application menu by
    navigating to **Edit** | **Project Settings** | **Player**. See *Figure 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.41: Accessing the Player Settings options'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Player Settings** options, set **Company Name** and **Product Name**
    as this information is baked and stored within the built executable. You can also
    specify an icon image for the executable as well as a default mouse cursor, if
    one is required. For the collection game, however, these latter two settings will
    be left empty. See *Figure 2.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.42: Setting a publisher name and product name'
  prefs: []
  type: TYPE_NORMAL
- en: The **Resolution and Presentation** tab is especially important as it specifies
    the game screen size and whether a default splash screen (**Resolution** dialog)
    should appear at the application startup. From this tab, ensure that the **Default
    Is Full Screen** option is enabled, meaning that the game will run at the complete
    size of the system's screen as opposed to a smaller and movable window. In addition,
    enable the **Display Resolution Dialog** drop-down list. See *Figure 2.43*. When
    this is enabled, your application will display an options screen at startup, allowing
    the user to select a target resolution and screen size and customize controls.
    For a final build, you'll probably want to disable this option, presenting the
    same settings through your own customized options screen in-game instead. However,
    for test builds, the **Resolution** dialog can be a great help. It lets you test
    your build easily at different sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.43: Enabling the Resolution dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you''re ready to make your first compiled build. So, click on the **Build**
    button from the **Build Settings** dialog or else, choose **File** | **Build &
    Run** from the application menu. When you do this, Unity presents you with a **Save**
    dialog, asking you to specify a target location on your computer where the build
    should be made. Select a location and choose **Save**, and the build process will
    be completed. Occasionally, this process can generate errors, which are printed
    in red in the **Console** window. This can happen, for example, when you save
    to a read-only drive, have insufficient hard drive space, or don''t have the necessary
    administration privileges on your computer. However, generally, the build process
    succeeds if your game runs properly in the editor. See *Figure 2.44*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.44: Building and running a game'
  prefs: []
  type: TYPE_NORMAL
- en: After the **Build** is completed, Unity generates new files at your destination
    location. For Windows, it generates an executable file and data folder. See *Figure
    2.45*. Both are essential and interdependent. That is, if you want to distribute
    your game and have other people play it without needing to install Unity, then
    you'll need to send users both the executable file and associated data folder
    and all its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.45: Unity builds several files'
  prefs: []
  type: TYPE_NORMAL
- en: 'On running your game, the **Resolution** dialog will show, assuming that you
    **Enabled** the **Display Resolution** **Dialog** option from the **Player Settings**.
    From here, users can select the game resolution, quality, and output monitor and
    configure player controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.46: Preparing to run your game from the Resolution dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'On clicking the play button, your game will run by default in fullscreen mode.
    Congratulations! Your game is now completed and built and you can send it to your
    friends and family for play testing! See *Figure 2.47*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/figure_02_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.47: Running the coin collection game in fullscreen mode'
  prefs: []
  type: TYPE_NORMAL
- en: But wait! How do you exit your game when you're finished playing? There's no
    quit button or main menu option in the game. For Windows, you just need to press
    *Alt* + *F4* on the keyboard. For Mac, you press *cmd* + *Q* and for Ubuntu, it's
    *Ctrl* + *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excellent work! On reaching this point, you've completed the coin collection
    game as well as your first game in Unity. On achieving this, you've seen a wide
    range of Unity features including level editing and design, prefabs, particle
    systems, meshes, components, script files, and build settings. That's a lot! Of
    course, there's a lot more to be said and explored for all these areas, but nevertheless,
    we've pulled them together to make a game. Next, we'll get stuck in with a different
    game altogether and, in doing this, we'll see a creative reuse of the same features
    as well as the introduction of completely new features. In short, we're going
    to move from the world of beginner-level Unity development to intermediate.
  prefs: []
  type: TYPE_NORMAL
