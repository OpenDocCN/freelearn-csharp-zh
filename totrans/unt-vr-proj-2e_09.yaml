- en: Exploring Interactive Spaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索交互式空间
- en: In this chapter, we'll dig a bit more into level design, modeling, rendering,
    teleporting, and animation; implementing an interactive space you can experience
    in VR. The scene is a photo gallery, where you design a simple floor plan and
    use a Blender to extrude it vertically into the walls. Use your own photos.  You
    can move around the space via teleport or an animated ride through.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨关卡设计、建模、渲染、传送和动画；实现一个可以在VR中体验的交互式空间。场景是一个照片画廊，你设计一个简单的平面图，并使用Blender将其垂直拉伸成墙壁。使用你自己的照片。你可以通过传送或动画乘坐来在空间中移动。
- en: 'In this chapter, we are going to discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Using Blender and Unity to build a simplistic art gallery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blender和Unity构建简单的艺术画廊
- en: Interacting with objects and metadata
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象和元数据交互
- en: Data structures, lists, and scriptable objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构、列表和可脚本化对象
- en: Using teleportation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传送
- en: Creating an animated walkthrough
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画导览
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decide to skip any of it or not save
    your work, that's OK.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的项目是独立的，并不直接依赖于本书其他章节的项目。如果你决定跳过其中任何部分或未保存你的工作，那都是可以的。
- en: Level design with Blender
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Blender进行关卡设计
- en: For this project, we're going to design an art gallery layout. We just need
    something simple, a small art gallery exhibit room about 24 by 36 feet. The room
    is so simple, in fact, it could easily be built within Unity using 3D cube primitives,
    but we'll take this opportunity to use Blender a little more since we introduced
    it in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects,
    and Scale,* keeping it minimal and instructive. If you prefer, you can skip this
    section and build the floor and walls using Unity cubes. Or, use the `Gallery.blend`
    file provided in the files for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将设计一个艺术画廊布局。我们只需要一个简单的布局，一个大约24英尺乘以36英尺的小型艺术画廊展览室。这个房间非常简单，实际上，它很容易在Unity中使用3D立方体原语构建，但我们将利用这个机会更多地使用Blender，因为我们已经在[第2章](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml)，*内容、对象和比例*中介绍了它，保持其最小化和指导性。如果你愿意，你可以跳过这一部分，使用Unity立方体构建地板和墙壁。或者，使用本章提供的`Gallery.blend`文件。
- en: Defining the walls
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义墙壁
- en: 'To start, draw a simple floor plan on a piece of paper or use a drawing app.
    Mine is just an open space with two entrances and interior walls to display artwork
    (`Gallery-floorplan.jpg`), which looks like the following image:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在一张纸上绘制一个简单的平面图或使用绘图应用程序。我的只是一个开阔的空间，有两个入口和内部墙壁来展示艺术品（`Gallery-floorplan.jpg`），如下面的图像所示：
- en: '![](img/842f96cf-0055-4ab1-aa1b-3b03570ee2c7.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/842f96cf-0055-4ab1-aa1b-3b03570ee2c7.jpg)'
- en: 'Now, open Blender. We''ll use a common technique of starting with a simple
    object (plane) and then extruding it to make each of the wall segments. To accomplish
    this, perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开Blender。我们将使用从简单对象（平面）开始，然后拉伸它以制作每个墙壁段落的常用技术。为了完成这个任务，请执行以下步骤：
- en: Start with an empty scene, press the A key to select all, and then press the
    X key to delete.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空场景开始，按A键选择所有对象，然后按X键删除。
- en: Add the floor plan image for reference by pressing the N key to open the properties
    panel. In the Background Images pane, select Add Image, click on Open and select
    your image (`Gallery-floorplan.jpg`).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按N键打开属性面板来添加平面图图像作为参考。在背景图像面板中，选择添加图像，点击打开并选择你的图像（`Gallery-floorplan.jpg`）。
- en: Depending on the size and scale of your floor plan reference image, you'll want
    to choose a scale factor so that it's correct in the Blender world coordinate
    space. A scale of `6.25` works for me. Actually, the most important thing is the
    relative scale of the features in the diagram, since we can always adjust the
    scale in Unity in the Import settings, or even in the Scene view itself.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你的平面图参考图像的大小和比例，你需要选择一个比例因子，以确保它在Blender世界坐标空间中是正确的。对我来说，`6.25`的比例是合适的。实际上，最重要的是图上特征的相对比例，因为我们总可以在Unity的导入设置中调整比例，甚至在场景视图中直接调整。
- en: In the Background Images pane, set Size to `6.25`. This pane, with the Size
    field highlighted, is shown in the following screenshot:![](img/c1c87579-278c-49b6-a0d3-912a89ca2761.png)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在背景图像面板中，将大小设置为`6.25`。这个面板中大小字段被高亮显示，如下面的截图所示：![截图](img/c1c87579-278c-49b6-a0d3-912a89ca2761.png)
- en: Go to a top-down orthographic view by pressing 7 on the numpad (or navigating
    to View | Top) and the orthographic view by pressing 5 (or navigating to View
    | Persp/Ortho). Note that the background image only gets drawn when it's in the
    top-ortho view.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按数字键盘上的7（或导航到视图|顶部）进入从上到下的正交视图，并通过按5（或导航到视图|透视/正交）进入正交视图。请注意，只有当它在顶部正交视图中时，背景图像才会被绘制。
- en: 'Now, we''ll make a tiny square in one corner of the room that will be extruded
    into a wall. Add a pane by pressing *Shift* + *A* and select Plane. Then, press
    *Tab* to go into the Edit mode. Press *Z* to toggle from the solid to the wireframe
    view. Press *G* to drag it into a corner, click *Enter* to confirm. Press *S*
    to scale it to fit the width of the corner of the wall, as shown in the following
    screenshot (you may recall that you can use the mouse scroll wheel to zoom and
    *Shift* and click on the middle mouse button to pan):'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在房间的角落处制作一个小正方形，将其拉伸成墙壁。按*Shift* + *A*添加一个面板，并选择平面。然后，按*Tab*进入编辑模式。按*Z*在实体视图和线框视图之间切换。按*G*将其拖入角落，点击*Enter*确认。按*S*将其缩放到适合墙角的宽度，如图所示（你可能还记得，你可以使用鼠标滚轮来缩放，*Shift*和点击中间鼠标按钮来平移）：
- en: '![](img/cc3a4220-f622-4200-ae61-977a9a0cc372.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc3a4220-f622-4200-ae61-977a9a0cc372.png)'
- en: 'Extrude the corner to make the outer walls. Go into the Edge Select mode (via
    the icon shown in the following screenshot), press *A* to unselect all, and then
    right-click on the edge that you want to extrude. Press *E* to begin extruding,
    press X or Y to constrain it to that axis, and then press *Enter* to complete
    the extrusion where you want it:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角落拉伸以形成外墙。进入边缘选择模式（通过以下截图中的图标），按*A*取消选择所有内容，然后右键单击要拉伸的边缘。按*E*开始拉伸，按X或Y将其约束到该轴，然后按*Enter*完成拉伸到所需位置：
- en: '![](img/9b66a724-1280-4a89-bafd-c6a401decb8f.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b66a724-1280-4a89-bafd-c6a401decb8f.png)'
- en: Repeat the previous steps for each outer wall. Create a small square at the
    corners so that you can extrude in the perpendicular direction. Leave gaps for
    the doorways. (You may recall that if you need to modify the existing edges, select
    it with a right-click, *Shift* and right-click to select multiple, and move with
    *G*. You can also duplicate the selected items.) Also, you can use *Shift* + *D* to
    duplicate in Object mode.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每面外墙重复之前的步骤。在角落处创建一个小正方形，以便可以沿垂直方向拉伸。为门留出空隙。（你可能还记得，如果你需要修改现有的边缘，右键单击选择它，使用*Shift*和右键单击来选择多个，然后使用*G*移动。你也可以复制选定的项目。）此外，你还可以使用*Shift*
    + *D*在对象模式下进行复制。
- en: '![](img/cec1e6a0-d972-4b5b-9319-0e7d72626f5d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cec1e6a0-d972-4b5b-9319-0e7d72626f5d.png)'
- en: 'To extrude out a face from the middle, we need to add an *edge loop*. With
    the mouse over the face, press *Ctrl* + *R* and left-click to create the cut.
    Slide the mouse to position it and left-click again to confirm. Repeat these steps
    for the width of the wall (making a square cut in the outer wall). Select the
    edge segment and press E to extrude it into the room:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从中间拉伸出一个面，我们需要添加一个*边缘环*。将鼠标移到面上，按*Ctrl* + *R*并左键单击创建切割。滑动鼠标定位它，然后再次左键单击确认。重复这些步骤以墙宽为宽度（在外墙上做一个正方形切割）。选择边缘段并按*E*将其拉伸到房间内：
- en: '![](img/e588ee45-e0e7-4579-a900-68e74e209443.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e588ee45-e0e7-4579-a900-68e74e209443.png)'
- en: Once the floor plan is done, we can extrude it along the *z* axis to create
    the walls. Change the view from Ortho to Persp by pressing *5*. Tilt it back using
    the middle mouse click and move. Select all by pressing *A*. Extrude with *E*.
    Begin to extrude with the mouse, press *Z* to constrain, and left-click to confirm.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成平面图，我们就可以沿*z*轴拉伸以创建墙壁。按*5*从正交视图切换到透视视图。使用中间鼠标点击并倾斜。按*A*选择所有内容。使用*E*拉伸。开始使用鼠标拉伸，按*Z*约束，然后左键单击确认。
- en: 'Save the model to a file named `gallery.blend`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型保存为名为`gallery.blend`的文件：
- en: '![](img/5018ca90-7f4a-4287-b178-2b01dde03155.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5018ca90-7f4a-4287-b178-2b01dde03155.png)'
- en: Adding a ceiling
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加天花板
- en: 'Now, add a ceiling with two skylights. The ceiling will just be a flat slab
    build from a single cube. Let''s see the steps to add a ceiling:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个带有两个天窗的天花板。天花板将只是一个由单个立方体构建的平板。让我们看看添加天花板的步骤：
- en: Return to Object mode using *Tab*
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Tab*返回对象模式
- en: Add a cube using *Shift* + *A* and select Cube
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Shift* + *A*添加一个立方体，并选择立方体
- en: Position it at the center using *G* and the mouse (*Alt* + *G* resets all its
    transforms)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*G*和鼠标（*Alt* + *G*重置所有变换）将其定位在中心
- en: Scale it along *x* and *y* so that it's size is the same as that of the room
    using *S* + *X* and *S* + *Y*)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿*x*和*y*轴缩放，使其大小与房间相同，使用*S* + *X*和*S* + *Y*）
- en: Switch to Front view using *1*, scale it so that it is flattened using *S* +
    *Z*, and move it to the top of the walls using *G* + *Z*)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*1*切换到前视图，使用*S* + *Z*将其缩放以使其变平，并使用*G* + *Z*将其移动到墙的顶部）
- en: 'The skylights will be holes cut out of the ceiling using another cube as a
    modifier, as show in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 天窗将通过使用另一个立方体作为修饰符从天花板上切割出孔，如图所示![截图](img/0a12959d-bd0f-4560-836a-076088c634ec.png)
- en: '![](img/0a12959d-bd0f-4560-836a-076088c634ec.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0a12959d-bd0f-4560-836a-076088c634ec.png)'
- en: Add a cube, using *Shift* + *A*, scale it to size, and move it to the position
    where you want the skylight.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Shift* + *A*添加一个立方体，将其缩放到所需的大小，并将其移动到你想放置天窗的位置。
- en: Position the cube's *z* axis so that it cuts through the ceiling slab.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体的*z*轴定位，使其穿过天花板板。
- en: Duplicate the cube by pressing *Shift* + *D* and move it to the other skylight's
    position, as shown in the following screenshot:![](img/c86f1c67-6db6-44f4-9bea-a2052b1d7e38.png)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Shift* + *D*来复制立方体，并将其移动到另一个天窗的位置，如图所示![截图](img/c86f1c67-6db6-44f4-9bea-a2052b1d7e38.png)
- en: Select the ceiling slab with a right-click.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击以选择天花板板。
- en: In the far right Properties Editor panel, select the wrench-icon.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最右侧的属性编辑器面板中，选择扳手图标。
- en: 'Then, navigate to Add Modifier | Boolean and for the Operation option, select
    Difference. For the Object option, select the first cube (`Cube.001`):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到“添加修饰符”|“布尔”并对于操作选项，选择“差集”。对于对象选项，选择第一个立方体（`Cube.001`）：
- en: '![](img/da46e8ba-2867-40c2-8caf-c903c0684602.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/da46e8ba-2867-40c2-8caf-c903c0684602.png)'
- en: Click on Apply to make the operation permanent. Then, delete the cube (select
    it and press X).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用以使操作永久。然后，删除立方体（选择它并按X）。
- en: Repeat the process, adding another Boolean modifier for the second cube.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，为第二个立方体添加另一个布尔修饰符。
- en: 'If you get stuck, I''ve included a copy of the finished model with the files
    for this book. This model is simple enough. You can build it using Unity cubes
    alone. So much more can, of course, be done to make this a more realistic architectural
    model, but we''re going to move ahead as is:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到困难，我已经包括了这个书的完成模型的副本。这个模型很简单。你可以仅使用Unity立方体来构建它。当然，还可以做更多的事情来使这个模型更加逼真的建筑模型，但我们将继续前进：
- en: '![](img/f8f05377-e64a-451f-aded-bf1001b0f2e5.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f8f05377-e64a-451f-aded-bf1001b0f2e5.png)'
- en: Assembling the scene in Unity
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中组装场景
- en: Now, we can use the gallery room model in Unity and add a floor and a ceiling
    with skylights. We will apply textures to the walls and add lighting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在Unity中使用画廊房间模型，并添加带有天窗的地板和天花板。我们将给墙壁应用纹理并添加照明。
- en: 'We can start a new Unity scene, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式启动一个新的Unity场景：
- en: Create a new scene by navigating to File | New Scene. Then, Save Scene As and
    name it `Gallery`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到“文件”|“新建场景”来创建一个新的场景。然后，选择“另存为场景”并将其命名为`Gallery`。
- en: Drag a copy of your `MeMyselfEye` prefab into the Hierarchy.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MeMyselfEye`预制体的副本拖动到层次结构中。
- en: Delete the default Main Camera from Hierarchy.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中删除默认的主摄像机。
- en: The gallery room level
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画廊房间级别
- en: 'First, we''ll build the art gallery''s room structure by performing the following
    steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过以下步骤构建艺术画廊的房间结构：
- en: Create a floor plane by navigating to GameObject | 3D Object | Plane. Reset
    its Transform option and rename it to `Floor`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到“游戏对象”|“3D对象”|“平面”创建一个地板平面。重置其变换选项并将其重命名为`Floor`。
- en: Create the material for the floor and color it brown. Create | Material, rename
    it, set its Albedo (`70`, `25`, `5`), and drag the material onto the `Floor`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为地板创建材质并将其染成棕色。创建 | 材质，重命名它，设置其Albedo（`70`, `25`, `5`），并将材质拖到`Floor`上。
- en: Our room is sized 24 by 36 feet, which in meters is roughly 7.3 by 11\. A Unity
    plane is 10 units square. So, Scale it to (`0.73`, `2`, `1.1`).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的房间大小为24英尺乘以36英尺，换算成米大约是7.3乘以11。Unity平面是10单位平方。因此，将其缩放为(`0.73`, `2`, `1.1`)。
- en: Import the gallery model (for instance, `Gallery.blend`). Drag a copy from Project
    Assets into the Scene. Reset its Transform option.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入画廊模型（例如，`Gallery.blend`）。从项目资产中拖动一个副本到场景中。重置其变换选项。
- en: Manually rotate and/or scale it to fit the floor, as needed (mine fits, but
    its Rotate Y value needed to be set to `90`). It may help if you first change
    the Scene view to Top Iso.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要手动旋转和/或缩放它以适应地板，例如（我的适合，但它的旋转Y值需要设置为`90`）。如果首先将场景视图更改为顶等距视图，可能会有所帮助。
- en: It is a good idea to add a collider to the walls so that a character doesn't
    just walk through them. To accomplish this, navigate to Add Component | Physics
    | Mesh Collider.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在墙上添加一个碰撞器是个好主意，这样角色就不会直接穿过了。为了实现这一点，导航到“添加组件”|“物理”|“网格碰撞器”。
- en: Note that when imported, as we defined in Blender, the Gallery has separate
    objects for the walls from the ceiling. A material is created (perhaps named `unnamed`)
    that has a neutral gray Albedo (`204`, `204`, `204`). I like this color for the
    walls, but I made a new material, all White (`255`, `255`, `255`) for the ceiling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们从Blender导入时，正如我们定义的那样，画廊中的墙壁和天花板是分开的对象。创建了一个材质（可能命名为“未命名”），它有一个中性的灰色Albedo（`204`，`204`，`204`）。我喜欢这种颜色用于墙壁，但我为天花板制作了一个新的材质，全部为白色（`255`，`255`，`255`）。
- en: For a good default skybox, we recommend **Wispy Skybox**, a free package on
    the Asset Store ([https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737](https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737)).
    Go ahead and download and import it into your project now if you want to use it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个好的默认Skybox，我们推荐**Wispy Skybox**，这是资源商店上的一个免费包（[https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737](https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737)）。如果您想使用它，请现在就下载并导入到您的项目中。
- en: 'Next, add some sky and sunlight, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一些天空和阳光，如下所示：
- en: If a Lighting tab is not visible in your Unity Editor, navigate to Window |
    Lighting | Settings
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在你的Unity编辑器中看不到“照明”选项卡，请导航到窗口 | 照明 | 设置
- en: In the Lighting pane, select the Scene tab
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在照明面板中，选择场景选项卡
- en: For sunlight, in the Lighting Scene pane, at the Sun input, select the (default)
    Directional Light from the Hierarchy and drag it onto the Sun Source slot
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于阳光，在照明场景面板中，在太阳输入处，从层次结构中选择（默认）方向光并将其拖放到太阳光源槽中
- en: For the sky, if you imported Wispy Skybox (see previously), then in the Lighting
    Scene tab, select the doughnut icon on the Skybox Material slot and select the
    material named `WispySkyboxMat`
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于天空，如果您导入了Wispy Skybox（见前文），则在照明场景选项卡中，选择Skybox材质槽上的甜甜圈图标并选择名为`WispySkyboxMat`的材质
- en: Since we selected the `Directional Light` for the sun source, you can play with
    the angle by selecting the Directional Light and modifying its Rotation, with
    the gizmo in the Scene window or directly in the Inspector, perhaps one that is
    consistent with the Skybox you chose (such as Rotation `60`, `175`, `0`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择了“方向光”作为光源，你可以通过选择方向光并修改其旋转来调整角度，在场景窗口中的gizmo或直接在检查器中，可能是一个与您选择的Skybox一致的旋转（例如旋转`60`，`175`，`0`）。
- en: You may consider textured materials for the floor and other surfaces. For example,  search
    the Asset Store for "Floor Materials." There are many free packages as well as
    paid ones.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑为地板和其他表面使用纹理材质。例如，在资源商店中搜索“地板材质”。这里有免费的包和付费的包。
- en: The artwork rig
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 艺术品装置
- en: 'Now, we can plan the art exhibition. We''ll create a  reusable artwork rig
    prefab with a picture frame, lighting, positioning, artist info, and a teleportation
    viewing position. Then, we''ll hang the art on the walls of the gallery. Later,
    we''ll apply the actual images. The artwork rig will consist of a picture frame
    (cube), a photo plane (quad), and a spotlight, all relative to the artwork''s
    placement on the wall. We will create the first one inside our Scene, save it
    as a `Prefab`, and then place duplicates on the walls throughout the gallery.
    I suggest doing this in the Scene view. Let''s get started:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以规划艺术展览。我们将创建一个带有画框、照明、定位、艺术家信息和传送观看位置的重复使用艺术品装置预制件。然后，我们将艺术挂在画廊的墙上。稍后，我们将应用实际图像。艺术品装置将包括一个画框（立方体）、一个照片平面（四边形）和一盏聚光灯，所有这些都相对于艺术品在墙上的放置。我们将在场景内创建第一个，将其保存为`Prefab`，然后在画廊的墙上放置副本。我建议在场景视图中这样做。让我们开始吧：
- en: Create a container object by navigating to GameObject | Create Empty. Name it`ArtworkRig`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到GameObject | 创建空对象来创建一个容器对象。将其命名为`ArtworkRig`。
- en: Create the frame. With `ArtworkRig` selected, right-click and navigate to GameObject
    | 3D Object | Cube. Name it `ArtFrame`. In Inspector, set its Scale Z to `0.05`.
    Also, let's assume a `3:4` aspect ratio. So, set its Scale Y value to `0.75`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建框架。选择`ArtworkRig`后，右键单击并导航到GameObject | 3D Object | Cube。将其命名为`ArtFrame`。在检查器中，将其Scale
    Z设置为`0.05`。假设一个`3:4`的宽高比。因此，将其Scale Y值设置为`0.75`。
- en: Position the rig on a wall (the one facing the entrance at the upper right of
    the original floor plan). It may help to hide the ceiling child of the `Gallery`
    object (uncheck its Enable checkbox option). Then, change the Scene view to Top
    and Iso using Scene View Gizmo on the upper right of the Scene panel. Click on
    the green Y icon for the Top view and the middle square icon for the Iso view.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将支架定位在墙上（原始楼层平面右上角面向入口的那面墙）。隐藏`Gallery`对象的子对象天花板（取消勾选其启用复选框选项）可能会有所帮助。然后，使用场景面板右上角的场景视图工具将场景视图更改为顶视图和等轴视图。点击绿色Y图标进行顶视图，点击中间的方块图标进行等轴视图。
- en: Select `ArtworkRig`, ensure that the Translate gizmo is active (the second icon
    in the top left icon toolbar), and use the *x* and *z* axis arrows to position
    it. Be sure to select and move the `ArtworkRig`. Leave the frame position at (`0`,`0`,`0`).
    Set the height at eye level (`Y=1.4`). The Transform Position value that works
    for me is (`2`, `1.4`, `-1.82`) and no Rotation at (`0`,`0`,`0`), as shown in
    the screenshot that follows.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`ArtworkRig`，确保翻译工具是激活的（位于左上角图标工具栏中的第二个图标），并使用*x*和*z*轴箭头定位它。务必选择并移动`ArtworkRig`。将框架位置保持在(`0`,`0`,`0`)。将高度设置为眼睛水平(`Y=1.4`)。对我有效的是变换位置值(`2`,
    `1.4`, `-1.82`)，并且没有旋转(`0`,`0`,`0`)，如图所示。
- en: Make the frame black. Navigate to Assets | Create | Material, name it `FrameMaterial`,
    and set its Albedo color to black. Then in Hierarchy, select the Frame option
    and drag the `FrameMaterial` material onto `ArtFrame`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将框架设置为黑色。导航到资产 | 创建 | 材质，将其命名为`FrameMaterial`，并将其Albedo颜色设置为黑色。然后在层次结构中选择框架选项，并将`FrameMaterial`材质拖放到`ArtFrame`上。
- en: Make the image placeholder. With `ArtFrame` selected in Hierarchy, right-click
    and navigate to 3D Object | Quad. Name it to `Image`. Position it just in front
    of the frame so that it's visible; set Position to (`0`, `0`, `-0.8`) and scale
    it so that it's slightly smaller than the frame by setting Scale to (`0.9`, `0.9`,
    `1`).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图像占位符。在层次结构中选择`ArtFrame`，右键单击并导航到3D对象 | 四边形。将其命名为`Image`。将其定位在框架前方，使其可见；将位置设置为(`0`,
    `0`, `-0.8`)，并调整缩放使其略小于框架，将缩放设置为(`0.9`, `0.9`, `1`)。
- en: To better appreciate the current scale and eye level, try inserting a copy of
    Ethan into the scene:![](img/df7623ae-a44b-4cac-b4af-6737c555d1f0.png)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地欣赏当前的缩放和眼睛水平，尝试在场景中插入Ethan的一个副本：![](img/df7623ae-a44b-4cac-b4af-6737c555d1f0.png)
- en: 'Next, we''ll add a spotlight to the rig, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向支架添加一个聚光灯，如下所示：
- en: First, put the ceiling back in by checking off the Enable checkbox option for
    the child object of Gallery.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过勾选画廊子对象的启用复选框选项来将天花板放回。
- en: With `ArtworkRig` selected in Hierarchy, right-click, navigate to Light | Spotlight,
    and position it one and half meters away from the wall (Z=`-1.5`) and up near
    the ceiling. The exact height doesn't matter much since we don't actually have
    a light fixture. We just have a Vector3 location for the source. I set Position
    to (`0`, `1.5`, `-1`).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`ArtworkRig`，右键单击，导航到光 | 聚光灯，并将其定位在离墙1.5米远（Z=`-1.5`）且靠近天花板的位置。确切的高度并不重要，因为我们实际上没有灯具。我们只有一个Vector3位置作为光源。我将位置设置为(`0`,
    `1.5`, `-1`)。
- en: Now, adjust the `Spotlight` value so that it appropriately illuminates the artwork.
    I set Rotation X to `2`, and adjust the light parameters to your liking, such
    as Range to `5`, Spot Angle to `45`, and Intensity to `3`. The results are shown
    in the following screenshot:![](img/71a054e2-240f-41e7-bd6b-169a3bc06f23.png)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调整`Spotlight`值，使其适当地照亮艺术品。我将旋转X设置为`2`，并根据您的喜好调整光参数，例如将范围设置为`5`，聚光灯角度设置为`45`，强度设置为`3`。结果如图所示：![](img/71a054e2-240f-41e7-bd6b-169a3bc06f23.png)
- en: 'Notice the spotlight is passing through the wall, illuminating the floor on
    the other side. We don''t want that. Select the Spotlight and enable shadows via
    Shadow Type: Soft Shadows.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意聚光灯正在穿过墙壁，照亮另一侧的地面。我们不想这样。选择聚光灯，通过阴影类型：软阴影启用阴影。
- en: To preserve the rig as a prefab, select `ArtworkRig` in Hierarchy and drag it
    into your Project Assets Prefabs folder.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将支架作为预制件保存，请在层次结构中选择`ArtworkRig`，并将其拖动到您的项目资产预制件文件夹中。
- en: Getting to know your Lighting settings can be important. If you see holes in
    your objects or shadows, for example, try sliding the Directional Light's Normal
    Bias to `0` and Bias to a low value like `0.1`. For more information on shadows
    and the bias property, see [https://docs.unity3d.com/Manual/ShadowOverview.html](https://docs.unity3d.com/Manual/ShadowOverview.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 了解您的照明设置可能很重要。例如，如果您看到物体中的孔或阴影，尝试将方向光的法线偏差滑到`0`并将偏差设置为低值，如`0.1`。有关阴影和偏差属性的更多信息，请参阅[https://docs.unity3d.com/Manual/ShadowOverview.html](https://docs.unity3d.com/Manual/ShadowOverview.html)。
- en: The exhibition plan
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展览计划
- en: 'The next step is to duplicate `ArtworkRig` on each wall where we want to display
    the images. Position it and rotate as needed. If you follow the plan shown in
    the following diagram, your exhibition will display ten images, indicated by the
    stars:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们想要显示图像的每面墙上复制`ArtworkRig`。根据需要定位和旋转。如果您遵循以下图中所示的计划，您的展览将显示十个图像，用星号表示：
- en: '![](img/edfc5fd9-cb20-4655-bdc2-494ea912734c.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edfc5fd9-cb20-4655-bdc2-494ea912734c.png)'
- en: 'The following are the steps to duplicate `ArtworkRig` on each wall:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在每面墙上复制`ArtworkRig`的步骤：
- en: As before, it may be easier to hide the ceiling and change the Scene View panel
    to Top and Iso.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，隐藏天花板并更改场景视图面板到顶视图和等距视图可能更容易。
- en: On the top left of the Scene View panel, change the Transform Gizmo toggles
    so that the tool handle is placed at the Pivot point rather than Center.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景视图面板的左上角，更改`Transform Gizmo`切换，以便工具句柄放置在轴点而不是中心。
- en: Create a new Empty game object, Reset its transform, and name it `Artworks`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空游戏对象，重置其变换，并将其命名为`Artworks`。
- en: Move the existing `ArtworkRig` so it's a child of `Artworks`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的`ArtworkRig`移动，使其成为`Artworks`的子对象。
- en: 'For each location, place an artwork in the gallery, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个位置，按照以下方式在画廊中放置一件艺术品：
- en: Select an existing `ArtworkRig` in the Hierarchy
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择现有的`ArtworkRig`
- en: Duplicate `Artworkrig` with right-click on Duplicate, or press *Ctrl* + *D*
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击复制或按*Ctrl* + *D*来复制`Artworkrig`。
- en: Rotate the rig so that it faces the correct direction by setting Rotation Y
    to `0`, `90`, `180`, or `-90`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将旋转Y设置为`0`、`90`、`180`或`-90`来旋转装置，使其朝向正确的方向。
- en: Position the rig on the wall
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将装置放置在墙上
- en: 'The settings that work for my gallery are provided in the following table (and
    assume your Artworks transform is reset to the origin):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了适用于我的画廊的设置（并假设您的`Artworks`变换已重置到原点）：
- en: '|  | Position X | Position Z | Rotation Y |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  | 位置 X | 位置 Z | 旋转 Y |'
- en: '| --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 2 | -1.8 | 0 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2 | -1.8 | 0 |'
- en: '| 1 | -1.25 | -5.28 | -180 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 1 | -1.25 | -5.28 | -180 |'
- en: '| 2 | -3.45 | -3.5 | -90 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 2 | -3.45 | -3.5 | -90 |'
- en: '| 3 | -3.45 | -0.7 | -90 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 3 | -3.45 | -0.7 | -90 |'
- en: '| 4 | -2 | 1.6 | 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -2 | 1.6 | 0 |'
- en: '| 5 | 2 | -1.7 | 180 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 | -1.7 | 180 |'
- en: '| 6 | 3.5 | 0 | 90 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3.5 | 0 | 90 |'
- en: '| 7 | 3.5 | 3.5 | 90 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 3.5 | 3.5 | 90 |'
- en: '| 8 | 1.25 | 5.15 | 0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1.25 | 5.15 | 0 |'
- en: '| 9 | -2 | 1.7 | 180 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 9 | -2 | 1.7 | 180 |'
- en: Note that the objects are listed in the same order that we'll use in the animated
    ride-through of the scene. Place them, as children of `Artworks`, in this order
    in Hierarchy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对象列表的顺序与我们将在场景动画中穿过的顺序相同。将它们作为`Artworks`的子对象，按照此顺序在层次结构中放置。
- en: Adding pictures to the gallery
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向画廊添加图片
- en: 'Please find 10 of your favorite photos from your photo library to use and add
    them to a new Project Assets folder named `Photos`. We are going to write a script
    that, given the list of images, will add them to each of the ArtworkRigs in the
    scene:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请从您的照片库中找到10张您最喜欢的照片以供使用，并将它们添加到名为`Photos`的新项目资产文件夹中。我们将编写一个脚本，该脚本将根据图像列表将它们添加到场景中的每个`ArtworkRigs`：
- en: To create the photos folder, navigate to Assets | Create | Folder and name it
    `Photos`
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建照片文件夹，导航到资产 | 创建 | 文件夹，并将其命名为`Photos`。
- en: Import 10 photos by dragging and dropping them from your File Explorer into
    the `Photos` folder that you just created (or navigate to Assets | ImportNew Asset...)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从文件资源管理器拖放10张照片到您刚刚创建的`Photos`文件夹（或导航到资产 | 导入新资产...）来导入10张照片。
- en: 'Now, we''ll write a script to populate Artworks Images:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个脚本来填充`Artworks Images`：
- en: In Hierarchy, select `Artworks`. Then, in Inspector, navigate to Add Component
    | New Script and name it `PopulateArtFrames`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择`Artworks`。然后在检查器中，导航到添加组件 | 新脚本，并将其命名为`PopulateArtFrames`。
- en: Open the new script for editing.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新脚本进行编辑。
- en: 'Write the code for `PopulateArtFrames.cs`, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编写`PopulateArtFrames.cs`的代码：
- en: '[PRE0]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is going on here? First, we declare a public array of `Textures` named
    `images`. You will see, this will appear in Inspector so we can specify what photos
    to include in the scene.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？首先，我们声明一个名为`images`的公共`Textures`数组。您将看到，这将出现在检查器中，我们可以指定要包含在场景中的哪些照片。
- en: 'This script is attached to the Artworks container object, which contains as
    children the ArtworkRigs. When the app starts, in `Start()`, we loop through all
    `theArtworkRigs`, find the Image object. For each image, we get its Renderer component''s
    Material, and assign a new Texture, that being the next image in the list. We
    use an `imageIndex` variable to increment through the list, and stop when we''ve
    run out of images or run out of ArtworkRigs:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本附加到Artworks容器对象上，该对象作为子对象包含ArtworkRigs。当应用启动时，在`Start()`中，我们遍历所有`theArtworkRigs`，找到图像对象。对于每个图像，我们获取其渲染器组件的材质，并分配一个新的纹理，即列表中的下一张图像。我们使用`imageIndex`变量遍历列表，并在用完图像或ArtworkRigs时停止：
- en: '![](img/d312e822-26ad-413d-848f-ca8e4773e8b3.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d312e822-26ad-413d-848f-ca8e4773e8b3.png)'
- en: The astute reader may wonder since all the ArtworkRigs use the same Material,
    and the Default-Material at that, why wouldn't changing the material on any ArtworkRig
    Image change them all? In fact, Unity takes care of that by cloning the material
    into a new unique one when you modify its texture (or other attributes) at runtime.
    So each ArtworkRig's Image gets its own Material with its own Texture, and thus,
    each picture in our gallery is different.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能会想，既然所有的ArtworkRigs都使用相同的材质，即默认材质，那么为什么改变任何ArtworkRig图像上的材质不会改变所有图像呢？实际上，当你在运行时修改其纹理（或其他属性）时，Unity会通过克隆材质到一个新的唯一材质来处理这个问题。因此，每个ArtworkRig的图像都获得自己的材质和自己的纹理，因此，我们画廊中的每幅画都是不同的。
- en: 'To finish this up, let''s perform the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，让我们执行以下步骤：
- en: Save the script and return to the Unity editor
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity编辑器
- en: With `Artworks` selected in Hierarchy, unfold the Populate Art Frames script
    component in Inspector and unfold the Images parameter
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`Artworks`，在检查器中展开 Populate Art Frames 脚本组件，并展开 Images 参数
- en: Set the Images Size value to `10`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像大小值设置为`10`
- en: Find the images you imported in the `Photos` folder under Project Assets and
    drag them, one at a time, into the Images slots as Element 0 through Element 9
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源下的`Photos`文件夹中找到您导入的图像，并将它们逐个拖放到图像槽中，作为元素0到元素9
- en: 'When you click on Play mode, the artwork in the scene will get populated with
    the images in the order that you specified:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击播放模式时，场景中的艺术作品将按照您指定的顺序填充图像：
- en: '![](img/9f0c2a10-0ebb-4cd5-be55-5b137716d123.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f0c2a10-0ebb-4cd5-be55-5b137716d123.png)'
- en: 'To view the scene in VR, we can position the MeMyselfEye in front of the first
    ArtworkRig:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在VR中查看场景，我们可以将MeMyselfEye定位在第一个ArtworkRig的前面：
- en: Select the `MeMyselfEye` camera rig in Hierarchy
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`MeMyselfEye`相机装置
- en: Set its Position to (`2`, `0`, `-2.82`)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为(`2`, `0`, `-2.82`)
- en: That's pretty nice!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太好了！
- en: Managing art info data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理艺术信息数据
- en: We could end here, but suppose we want to track more data than just the images
    for each artwork, such as artist, title, description, and so on. First, we'll
    consider several software design patterns to manage the data, including separate
    lists, data structures, and scriptable objects. Later, we'll update our ArtworkRig
    to display the info with each framed artwork.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以到此为止，但假设我们想要跟踪比每个艺术作品图像更多的数据，例如艺术家、标题、描述等。首先，我们将考虑几种软件设计模式来管理数据，包括单独的列表、数据结构和可脚本化的对象。稍后，我们将更新我们的ArtworkRig以显示每个框架艺术作品的信息。
- en: The first two scenarios are for explanation only. We will actually implement
    the `ScriptableObjects` one last.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个场景仅用于说明。我们将最后实现`ScriptableObjects`。
- en: Using lists
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'One approach could be to add more lists to the `PopulateArtFrames` script for
    each of the data fields. For example, if the script had the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在`PopulateArtFrames`脚本中为每个数据字段添加更多的列表。例如，如果脚本有如下所示：
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Inspector would show the following (I limited the list to four items for
    brevity):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器将显示以下内容（为了简洁，我限制了列表为四项）：
- en: '![](img/7b69f475-f8c3-42b8-adf5-4f06ed3e3eb7.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b69f475-f8c3-42b8-adf5-4f06ed3e3eb7.png)'
- en: As you can imagine, this could get very unwieldy. To change Element 3, for example,
    you'd have to go to all the lists, which is easily prone to mistakes; things could
    fatally get very out of sync.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这可能会变得非常难以管理。例如，要更改元素3，您必须访问所有列表，这很容易出错；事情可能会致命地失去同步。
- en: Using data structures
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据结构
- en: 'A better approach could be to write a C# `struct` (or `class`) as a data structure
    that contains each of the fields we want and then make the list in `PopulateArtFrames`
    as this type. For example, the script may read as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法可能是编写一个 C# `struct`（或 `class`），作为包含我们想要的每个字段的 数据结构，然后在 `PopulateArtFrames`
    中的列表为此类型。例如，脚本可能如下所示：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/98c40591-62a0-470d-a882-63341bd8d4c2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98c40591-62a0-470d-a882-63341bd8d4c2.png)'
- en: Now we have a list of `ArtInfo` elements that we can fill in, and the data for
    each element is grouped together.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以填充的 `ArtInfo` 元素列表，每个元素的数据都分组在一起。
- en: Another benefit of this structure is it could be more easily populated from
    an external data source, such as cloud-based JSON data or a CSV (comma separated
    values) data file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的另一个好处是它可以从外部数据源更容易地填充，例如基于云的 JSON 数据或 CSV（逗号分隔值）数据文件。
- en: If you are interested in loading data from a database there are a number of
    approaches, outside the scope of this chapter. But briefly, if you do find a source
    of CSV data, this handy CSV parser ([https://github.com/frozax/fgCSVReader](https://github.com/frozax/fgCSVReader)) 
    is basic but gets the job done. If you are in need of a JSON parser, from a web-based
    REST API for example, consider the JSON .NET For Unity package ([https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347](https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347))
    or another similar one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣从数据库加载数据，这里有一些方法，但超出了本章的范围。但简要来说，如果你确实找到了 CSV 数据的来源，这个方便的 CSV 解析器 ([https://github.com/frozax/fgCSVReader](https://github.com/frozax/fgCSVReader))
    基本上但能完成任务。如果你需要 JSON 解析器，例如从基于 Web 的 REST API，可以考虑 JSON .NET For Unity 包 ([https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347](https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347))
    或其他类似的包。
- en: Using scriptable objects
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可脚本化对象
- en: In the previous examples, the art info data is maintained on a `GameObject`
    in the Scene Hierarchy. As a software design, this is not really where the data
    belongs. Data objects are not game objects and should be managed separately.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，艺术信息数据是在场景层次结构中的 `GameObject` 上维护的。从软件设计的角度来看，这并不是数据真正所属的地方。数据对象不是游戏对象，应该单独管理。
- en: 'In the Scene hierarchy, we define the level design and game behaviors. ArtworkRigs
    have spatial coordinates (Transform) and renderers (and other potentially necessary
    runtime components such as colliders and RigidBodies for physics). But other data,
    still a project asset, can live outside the scene hierarchy. For this, Unity offers
    *ScriptableObjects*. We first introduced ScriptableObjects in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables*, as a way of sharing input data across game objects. We
    will use them again here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景层次结构中，我们定义了关卡设计和游戏行为。ArtworkRigs 有空间坐标（Transform）和渲染器（以及可能需要的其他运行时组件，如碰撞器和刚体用于物理）。但其他数据，尽管是项目资产，可以存在于场景层次结构之外。为此，Unity
    提供了 *ScriptableObjects*。我们首次在 [第 5 章](21722631-9544-4b1e-a888-877d34b0fff7.xhtml)，*实用交互对象*
    中介绍了 ScriptableObjects，作为在游戏对象之间共享输入数据的一种方式。我们在这里再次使用它们：
- en: In the Project window, create a new folder under *Assets* named `ScriptableObjects`
    if not already present
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 窗口中，如果尚未存在，则在 *Assets* 下创建一个名为 `ScriptableObjects` 的新文件夹
- en: In the new folder, right-click and select Create | C# Script
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，右键单击并选择 **创建** | **C# 脚本**
- en: Name the script `ArtInfo`
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为 `ArtInfo`
- en: Then, open the `ArtInfo.cs` script for editing
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `ArtInfo.cs` 脚本进行编辑
- en: 'Create the `ArtInfo.cs` script as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式创建 `ArtInfo.cs` 脚本：
- en: '[PRE3]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Rather than inheriting from `MonoBehaviour`, we define the class as a `ScriptableObject`.
    We added a `Multiline` attribute for description so the input field in Inspector
    will be a text area.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是从 `MonoBehaviour` 继承，而是将类定义为 `ScriptableObject`。我们添加了一个 `Multiline` 属性用于描述，这样在检查器中的输入字段就会是一个文本区域。
- en: If you are importing JSON data into your project and want to generate ScriptableObject
    classes that match the JSON object properties, take a look at this tool: [https://app.quicktype.io/#r=json2csharp](https://app.quicktype.io/#r=json2csharp).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在将 JSON 数据导入到你的项目中，并希望生成与 JSON 对象属性匹配的 ScriptableObject 类，请查看这个工具：[https://app.quicktype.io/#r=json2csharp](https://app.quicktype.io/#r=json2csharp)。
- en: 'At the top, we provide a `CreateAssetMenu` attribute, which generates a menu
    item in the Unity Editor for our object. Since scriptable objects are not added
    to the scene Hierarchy, we need a way to create them in the project. Using this
    attribute makes it easy, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们提供了一个`CreateAssetMenu`属性，它会在Unity编辑器中为我们的对象生成一个菜单项。由于可脚本化对象不会被添加到场景层次结构中，我们需要一种在项目中创建它们的方法。使用此属性会使操作变得简单，如下所示：
- en: Save the script and return to Unity.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity。
- en: In the Project window, select your Photos folder where you imported your image
    textures. We'll create the Art Info objects in the same folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，选择您导入图像纹理的相册文件夹。我们将在同一文件夹中创建艺术信息对象。
- en: In the Unity editor main menu, navigate to Assets | Create.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器主菜单中，导航到“资产”|“创建”。
- en: You will see a new item My Objects with a submenu with an item Art Info, as
    directed in the CreateAssetsMenu property attribute in our script.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个名为“我的对象”的新项，其中包含一个子菜单，其中有一个名为“艺术信息”的项，正如我们在脚本中的`CreateAssetsMenu`属性所指示的那样。
- en: Choose Art Info to create an instance. By default, it will be created in the
    same folder as the defining script (this can be changed in the property attribute
    options).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“艺术信息”以创建一个实例。默认情况下，它将在定义脚本所在的同一文件夹中创建（这可以在属性属性选项中更改）。
- en: It maybe be helpful to rename the object similar to your images. For example,
    if you have PictureA, name it `PictureA Info`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能会有助于将对象重命名为与您的图像类似。例如，如果您有PictureA，将其命名为`PictureA Info`。
- en: Drag the image texture onto the scriptable object's Image slot.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像纹理拖放到脚本化对象的图像槽中。
- en: Add information for the Title, Artist, and Description too.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为标题、艺术家和描述添加信息。
- en: 'Here is a screenshot of an ArtInfo object with data filled in:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个已填写数据的`ArtInfo`对象的截图：
- en: '![](img/6433e606-c9dd-49d9-9849-21be5d159a94.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6433e606-c9dd-49d9-9849-21be5d159a94.png)'
- en: Repeat these steps for all your pictures.  When you're done, your art data will
    be Project assets.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有图片重复这些步骤。完成时，您的艺术数据将成为项目资产。
- en: 'To use the scriptable object assets in the project, we could modify the PopulateArtFrames
    much like we would have for the `struct` version of the code. We''ll do a little
    bit of refactoring, creating a new component on the ArtworkRig to populate itself
    with an ArtInfo object, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中使用脚本化对象资产，我们可以修改`PopulateArtFrames`，就像我们之前对`struct`版本的代码所做的那样。我们将进行一些重构，在`ArtworkRig`上创建一个新的组件，以使用ArtInfo对象填充它，如下所示：
- en: Select one of the ArtworkRigs in the Hierarchy
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择一个`ArtworkRig`。
- en: Add Component | New Script, name it `ArtworkController`
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件|新建脚本，命名为`ArtworkController`
- en: 'Open it for editing and write it as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开它进行编辑，并按照以下内容编写：
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save the script and back in Unity, on the `ArtworkRig` where we just added
    this component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity，在刚刚添加此组件的`ArtworkRig`上：
- en: Drag the image child onto the image slot
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像子项拖放到图像槽中。
- en: Press Apply to save the `ArtworkRig` prefab
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用”以保存`ArtworkRig`预制体
- en: 'Now, update the `PopulateArtFrames` to iterate the list of `ArtInfo` and send
    the object to the `ArtworkRig`, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`PopulateArtFrames`以迭代`ArtInfo`列表并将对象发送到`ArtworkRig`，如下所示：
- en: '[PRE5]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the Inspector interface is much cleaner and workable. The Artworks'' Populate
    Art Frames component maintains a list of Art Info objects, as shown next. We just
    need to populate the list and use it. The data the list references are maintained
    separately as `ScriptableObjects`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查器界面更加整洁且易于操作。艺术作品的`PopulateArtFrames`组件维护一个艺术信息对象的列表，如下所示。我们只需要填充列表并使用它。列表引用的数据作为`ScriptableObjects`单独维护：
- en: '![](img/94eb8e15-f62a-4837-9fe8-35e6d34aeb68.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94eb8e15-f62a-4837-9fe8-35e6d34aeb68.png)'
- en: Press Play. The artwork images should get loaded during Start, just like before
    although we've greatly improved the underlying implementation and can now extend
    our app to include more info about each art picture.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。艺术图像应该在启动时加载，就像之前一样，尽管我们已经大大改进了底层实现，现在可以扩展我们的应用程序以包含有关每幅艺术图片的更多信息。
- en: Another advantage of using ScriptableObject in situations like this is once
    you have a distributable app, you can package these assets into an AssetBundle.
    This would allow, for example, changing out the gallery pictures, along with all
    the art info, in the live version.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况中使用ScriptableObject的另一个优点是，一旦您有一个可分发的应用程序，您可以将这些资产打包到AssetBundle中。这将允许，例如，在实时版本中更换画廊图片以及所有艺术信息。
- en: Displaying the art info
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示艺术信息
- en: Now that we have more information on each art piece, we can incorporate that
    into our project. We will add a UI canvas to the ArtworkRig. First, we'll include
    an info plaque with each picture. Then we'll make it interactive. If you'd like
    a reminder introduction to Unity's canvas and UI elements, please look at [Chapter
    6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml), *World Space UI*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对每件艺术品都有更多信息，我们可以将其纳入我们的项目。我们将在`ArtworkRig`中添加一个UI画布。首先，我们将包括每张图片的信息牌匾。然后我们将使其交互式。如果你想要Unity的画布和UI元素的提醒介绍，请查看[第6章](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml)，*世界空间UI*。
- en: Creating the title plaque
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标题牌匾
- en: 'The title plaque will be a small canvas next to each picture, with a title
    text UI element:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 标题牌匾将是一个位于每张图片旁边的小画布，包含标题文本UI元素：
- en: Select one of the ArtworkRig objects in Hierarchy.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择一个`ArtworkRig`对象。
- en: Add a child canvas, Create UI | Canvas, named InfoPlaque.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个子画布，创建UI | 画布，命名为InfoPlaque。
- en: Set its Render Mode to World Space.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其渲染模式设置为世界空间。
- en: Initially reset its position Pos to (`0`, `0`, `0`).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始重置其位置位置为（`0`，`0`，`0`）。
- en: 'Set the canvas Width: `640`, Height: `480`.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置画布宽度：`640`，高度：`480`。
- en: If you recall, the canvas scaled in world space will be 640 meters wide! Set
    the Scale to `0.0006.`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你记得，在世界上缩放的画布将是640米宽！将缩放设置为`0.0006`。
- en: 'Now you can visually adjust the position using the move gizmo, we found this
    works: Pos (`0.8`, `-0.1`, `-0.01`).'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以使用移动捕捉工具直观地调整位置，我们发现以下值有效：位置（`0.8`，`-0.1`，`-0.01`）。
- en: Next, create a child pane, Create UI | Panel.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个子面板，创建UI | 面板。
- en: And a sub-child of the panel, create a child text element, Create UI | Text,
    rename it Title.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在面板的子面板中，创建一个子文本元素，创建UI | 文本，将其重命名为Title。
- en: Set some default text, like Title title title title.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一些默认文本，如Title title title title。
- en: For Anchor Presets (the fancy icon in the top-left of the Transform panel),
    select Stretch / Stretch, click and also Alt-click it. This will let the text
    fill the panel area.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于锚点预设（变换面板左上角的复杂图标），选择拉伸/拉伸，点击并也Alt点击它。这将使文本填充面板区域。
- en: 'Font Size: `80`.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字体大小：`80`。
- en: 'Alignment: Middle, Center.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对齐：中间，中心。
- en: 'Set its Horizontal Overflow: `Wrap`, and Vertical Overflow: `Truncate`.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其水平溢出：`Wrap`，垂直溢出：`Truncate`。
- en: 'Now, we can modify `ArtworkController` script to add a new `public Text title`
    variable and set its `text` property to the `info.title`, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改`ArtworkController`脚本以添加一个新的`public Text title`变量，并将其`text`属性设置为`info.title`，如下所示：
- en: '[PRE6]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That was easy. Save the script, and then:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那很简单。保存脚本，然后：
- en: Drag the Title element onto the Text slot
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Title元素拖放到文本槽中
- en: To save the prefab, make sure the `ArtworkRig` itself is selected in the Hierarchy,
    then press Apply
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存预制体，请确保在层次结构中选择`ArtworkRig`本身，然后按应用。
- en: 'Now when you press Play, the picture images and title text will get initialized
    on `Start` for each of the artwork rigs. Here''s one of my photos with a title
    plaque:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你按播放时，图片图像和标题文本将在每个艺术品rig的`Start`时初始化。这是我的一张带有标题牌匾的照片：
- en: '![](img/801eadda-a63e-4509-a2a3-c248557fe71f.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/801eadda-a63e-4509-a2a3-c248557fe71f.png)'
- en: Interactive info details
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式信息详情
- en: 'We have more information on each picture that fits on the plaque, so we''ll
    allow the player to click an input controller button to open the detail infobox.
    Let''s create that canvas first, with text for artist and description:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每张适合在牌匾上放置的图片都有更多信息，因此我们将允许玩家点击输入控制器按钮以打开详细信息信息框。让我们首先创建那个画布，包括艺术家和描述的文本：
- en: As a shortcut, duplicate the InfoPlaque and name it `DetailsCanvas`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为快捷方式，复制InfoPlaque并将其命名为`DetailsCanvas`。
- en: 'Scale and position it, perhaps out front and a slight angle. The following
    values work for me: Pos (`0.7`, `0`, `-0.2`), Width Height (`1200`, `900`), Rotation
    (`0`, `15`, `0`).'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放并定位它，可能在前方并稍微倾斜。以下值对我有效：位置（`0.7`，`0`，`-0.2`），宽高（`1200`，`900`），旋转（`0`，`15`，`0`）。
- en: Rename the Title text element to `Description`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标题文本元素重命名为`Description`。
- en: Duplicate Description, rename it `Artist`, set to Top Alignment.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Description，重命名为`Artist`，设置为顶部对齐。
- en: Press Apply to save the prefab.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用以保存预制体。
- en: 'The `ArtworkController`  can now populate the details fields too:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtworkController`现在也可以填充详细信息字段：'
- en: '[PRE7]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And in the `SetArtInfo` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SetArtInfo`函数中：
- en: '[PRE8]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we'll add an `Update` handler to check for user input and display (or
    hide) the details canvas. And ensure the canvas starts out disabled in `Start`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个`Update`处理程序来检查用户输入并显示（或隐藏）细节画布。并确保在`Start`时画布处于禁用状态。
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For Daydream on Android, you would call `GvrControllerInput.ClickButtonDown`
    and `ClickButtonUp`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android上的Daydream，你会调用`GvrControllerInput.ClickButtonDown`和`ClickButtonUp`。
- en: Save the script.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Drag the Artist and Description elements onto the corresponding slots
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将艺术家和描述元素拖动到相应的槽中
- en: Drag the InfoDetails canvas onto the Details Canvas slot
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将InfoDetails画布拖动到细节画布槽中
- en: Press Apply on the ArtworkRig to save the prefab changes
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ArtworkRig上按下“应用”以保存预制体更改
- en: 'Now, when you Play and press the Fire1 button on your input controller, the
    details canvas will show, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您播放并按下输入控制器上的Fire1按钮时，细节画布将显示如下：
- en: '![](img/039697ed-984c-4227-9332-bfec3c59ad5c.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/039697ed-984c-4227-9332-bfec3c59ad5c.png)'
- en: If you would like to implement a different button, such as the finger trigger,
    or are using a device without a Fire1 mapping (Daydream), please refer to [Chapter
    5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy Interactables,* for implementation
    options and handling input events.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想实现不同的按钮，例如手指触发器，或者使用没有Fire1映射（Daydream）的设备，请参考[第5章](21722631-9544-4b1e-a888-877d34b0fff7.xhtml)，*实用交互项*，以获取实现选项和处理输入事件。
- en: As implemented, all the details canvases will appear when you press the button.
    If you want to control one canvas at a time, you could add a UI button to the
    InfoPlaque, for example, and then use click events on that to trigger the canvas
    visibility, using gaze-based look and click, or laser pointer & click interactions. Reference
    [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml), *World Space UI*, for
    implementation ideas.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如此实现，当您按下按钮时，所有细节画布都会出现。如果您想一次控制一个画布，可以在InfoPlaque上添加一个UI按钮，例如，然后使用该按钮的点击事件来触发画布的可见性，使用基于注视的查看和点击，或激光指针和点击交互。参考[第6章](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml)，*世界空间UI*，以获取实现想法。
- en: Adjusting for image aspect ratio
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整图像的宽高比
- en: You probably noticed that some of your pictures appear squished since our framed
    image is shown at a fixed size and aspect ratio. What we really would like is
    for the frame and image to adjust themselves depending on the dimensions of the
    image.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，由于我们的框架图像以固定大小和宽高比显示，一些图片看起来被压扁了。我们真正希望的是框架和图像根据图像的尺寸进行调整。
- en: 'When Unity imports a texture, it prepares it (by default) for GPU rendering
    as an object material texture, which includes resizing it to a square power of
    two (for example, 1024 x 1024, 2048 x 2048, and so on). If you adapt your project
    to read images at runtime, for example, from the Resources directory, the device''s
    photo stream, or over the web, then you will have access to the image file''s
    metadata header that includes its pixel width and height. In lieu of that, since
    we''re using imported textures, we can change the Advanced import settings for
    the images we''re using:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity导入纹理时，它将其（默认情况下）准备为GPU渲染的对象材质纹理，这包括将其调整到平方的2的幂（例如，1024 x 1024，2048 x 2048等）。如果您将项目调整为在运行时读取图像，例如从Resources目录、设备的照片流或通过网络，那么您将能够访问图像文件的元数据标题，其中包含其像素宽度和高度。由于我们使用的是导入的纹理，我们可以更改我们使用的图像的高级导入设置：
- en: From your Assets Photos folder, select an image texture
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的“资产照片”文件夹中选择一个图像纹理
- en: In Inspector, under Advanced, change Non Power of 2 to None
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，在“高级”选项下，将“非2的幂”更改为“无”
- en: Press Apply
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下“应用”
- en: Repeat this for each image in the project. Note that this also decompresses
    the image, so what might start out as a 400k `.jpg` file becomes a 3 MB, 24-bit
    image in the project, so be cautious of the width and height of the source images
    you choose to use.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对项目中的每个图像重复此操作。请注意，这也将解压缩图像，因此原本可能是一个400k的`.jpg`文件，在项目中变成了3MB，24位的图像，所以请谨慎选择要使用的源图像的宽度和高度。
- en: Not scaling textures to a power of two is really bad for performance. If you
    have more than a few images, you should avoid this. One approach would be to add
    the image aspect ratio as another field of the ArtInfo, and manually set the value
    in the corresponding scripted objects. Then, change ArtworkController to use this
    value instead of calculating it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不将纹理缩放到2的幂次方对性能非常不利。如果您有超过几个图像，您应该避免这样做。一种方法是将图像宽高比作为ArtInfo的另一个字段，并在相应的脚本对象中手动设置该值。然后，将ArtworkController更改为使用此值而不是计算它。
- en: In `ArtworkController.cs`, add the following helper function, which returns
    a normalized scale of a texture. The larger dimension will be 1.0 and the smaller
    one will be a fraction. For example, an image that is 1024w x 768h will get a
    scale of (1.0, 0.75). It also maintains the current relative scale of the picture
    using the Z scale value, since that's not changed by our aspect ratio calculation,
    but will be changed by the Scale tool!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ArtworkController.cs` 中添加以下辅助函数，该函数返回纹理的归一化缩放。较大的一边将是 1.0，较小的一边将是分数。例如，一个
    1024w x 768h 的图像将获得缩放 (1.0, 0.75)。它还使用 Z 缩放值保持图片的当前相对缩放，因为 Z 缩放值不会因我们的宽高比计算而改变，但会被缩放工具改变！
- en: 'Modify `ArtworkController` first by adding a private function `TextureToScale`
    which normalizes the image scale to 1.0 for the larger of width or height, and
    sets the other dimension to the aspect ratio, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先修改 `ArtworkController`，添加一个私有函数 `TextureToScale`，该函数将图像缩放归一化到宽度或高度较大的 1.0，并将另一维设置为宽高比，如下所示：
- en: '[PRE10]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The function also preserves the frame depth in the returned scale vector. Now,
    we can use this in `SetArtInfo` function. Add a new public variable for the `frame`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还保留了返回的缩放向量中的帧深度。现在，我们可以在 `SetArtInfo` 函数中使用它。为 `frame` 添加一个新的公共变量：
- en: '[PRE11]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And then, add this line to set the frame''s scale:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下行以设置帧的缩放：
- en: '[PRE12]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save the updates script. Then, in Unity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更新脚本。然后，在 Unity 中：
- en: Drag the ArtFrame onto the Frame slot in the component
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ArtFrame 拖动到组件中的 Frame 槽
- en: Press Apply to save the prefab
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 Apply 以保存预制体
- en: 'Now when you play, the framed images are scaled with the correct aspect ratio,
    like the one shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你玩游戏时，框定的图像会以正确的宽高比缩放，就像这里显示的：
- en: '![](img/7e4c8ce6-432d-473f-9e4b-75afef550bd3.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e4c8ce6-432d-473f-9e4b-75afef550bd3.png)'
- en: Moving around the gallery
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画廊中移动
- en: We've done so much, and yet have not discussed moving about the gallery level.
    In [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion and Comfort*,
    we examined various ways of implementing locomotion and teleportation. Let's now
    consider setting up specific teleportation spawn points that provide an optimal
    viewing pose for each artwork picture in the gallery.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了很多，但还没有讨论在画廊级别移动。在第 7 章 [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml)，*Locomotion
    and Comfort*（移动和舒适度）中，我们探讨了实现移动和传送的多种方法。现在，让我们考虑设置特定的传送出生点，为画廊中每幅艺术作品的图片提供最佳的观看姿势。
- en: Teleporting between pictures
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图片之间传送
- en: 'I suppose a good viewing position is about one meter back from the picture.
    We can add a ViewPose object at that location, within the ArtworkRig. We''ll place
    its origin on the floor. Let''s add that now:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一个良好的观看位置大约在图片后一米处。我们可以在 ArtworkRig 中添加一个 ViewPose 对象，并将其原点放在地板上。现在让我们添加它：
- en: Select a ArtworkRig in Hierarchy
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中选择 ArtworkRig
- en: Create a child Empty game object, name it `ViewPose`
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的子游戏对象，命名为 `ViewPose`
- en: Reset the ViewPose transform
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置 ViewPose 变换
- en: Set its Position to (`0`, `-1.4`, `-1.5`)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为 (`0`, `-1.4`, `-1.5`)
- en: In [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion and
    Comfort*, we examined various ways of implementing locomotion and teleportation,
    including our own home-grown scripts as well as higher-level toolkits. Here, we'll
    use teleportation toolkits for SteamVR and Daydream. For a more general introduction
    to these toolkits, or alternative solutions, please refer back to that chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章 [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml)，*Locomotion and
    Comfort*（移动和舒适度）中，我们探讨了实现移动和传送的多种方法，包括我们自己的脚本以及更高级的工具包。在这里，我们将使用 SteamVR 和 Daydream
    的传送工具包。有关这些工具包的更一般介绍或替代解决方案，请参阅该章节。
- en: Teleporting with SteamVR Interaction System
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SteamVR 交互系统传送
- en: 'To use the SteamVR Interaction System, we start with their Player prefab and
    add the components we want to use:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SteamVR 交互系统，我们首先从他们的 Player 预制体开始，并添加我们想要使用的组件：
- en: Locate the Player prefab in `SteamVR/InteractionSystem/Core/Prefabs`
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SteamVR/InteractionSystem/Core/Prefabs` 中定位 Player 预制体
- en: Drag it as a child of `MeMyselfEye` in your scene Hierarchy
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的场景 Hierarchy 中将其作为 `MeMyselfEye` 的子对象拖动
- en: Delete or disable the `[CameraRig]` object
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或禁用 `[CameraRig]` 对象
- en: Drag a copy of Teleporting prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` as
    a child of MeMyselfEye (this controller can actually go anywhere in the scene)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目 `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` 中拖动 Teleporting 预制体的一个副本作为
    MeMyselfEye（此控制器实际上可以在场景中的任何地方移动）的子对象
- en: Select the Player in Hierarchy, and drag its parent `MeMyselfEye` onto its Tracking
    Origin Transform slot
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中选择 Player，并将其父对象 `MeMyselfEye` 拖动到其 Tracking Origin Transform 槽
- en: Select the ViewPose object in the ArtworkRig
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“ArtworkRig”中选择“ViewPose”对象
- en: Drag a copy of the TeleportPoint prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` into
    the Hierarchy as a child of ViewPose
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目“Assets/SteamVR/InteractionSystem/Teleport/Prefabs”中将“TeleportPoint”预制件的副本拖放到层次结构中作为“ViewPose”的子对象
- en: Select the ArtworkRig and Apply to save the prefab changes
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“ArtworkRig”并应用以保存预制件更改
- en: 'That''s it! Press Play. The teleport points do not show until you press the
    button on your controller, then they glow, a dashed laser arc lets you choose
    one, and you go there. Here is a screenshot of the Scene view while the teleport
    points are activated:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！按播放。传送点不会显示，直到你按下控制器上的按钮，然后它们会发光，一个虚线激光弧让你选择一个，然后你就能到达那里。以下是激活传送点时的场景视图截图：
- en: '![](img/6726e430-2dbe-454c-9a7c-5c0911c66d96.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6726e430-2dbe-454c-9a7c-5c0911c66d96.png)'
- en: Teleporting with Daydream Elements
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“Daydream Elements”传送
- en: The Daydream Elements toolkit is more granular so it takes a little more to
    get this working. By default, the TeleportController lets you teleport to any
    horizontal surface on the scene (provided it has a collider). To limit it to our
    teleport stations we'll restrict the search to a specific layer, named `Teleport`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: “Daydream Elements”工具包更细致，因此需要更多时间才能使其工作。默认情况下，“TeleportController”允许你传送到场景中任何水平表面（前提是有碰撞器）。为了限制它只传送到我们的传送站，我们将搜索限制在特定层，命名为“Teleport”。
- en: In an ArtworkRig in Hierarchy, select its ViewPose object and create a child
    cylinder (Create | 3D Object | Cylinder) and name it `TeleportPod`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中的“ArtworkRig”中，选择其“ViewPose”对象，并创建一个子圆柱体（创建 | 3D 对象 | 圆柱体），并将其命名为“TeleportPod”。
- en: Set its Scale to (`0.5`, `0.5`, `0.01`). You may choose to decorate its material,
    for example, with transparency.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为（`0.5`，`0.5`，`0.01`）。你可以选择装饰其材质，例如，使用透明度。
- en: Put it on Layer `"Teleport"` (If there is no layer named Teleport, from the
    Layers select list choose Add Layer... first).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放在层“`Teleport`”上（如果没有名为“Teleport”的层，首先从层选择列表中选择添加层...）。
- en: Select the parent ArtworkRig and Apply to save the prefab changes.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择父级“ArtworkRig”并应用以保存预制件更改。
- en: 'Now, we add the Daydream Elements teleport controller:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加“Daydream Elements”的传送控制器：
- en: Drag the TeleportController prefab into your Hierarchy as child of Player (for
    us, `MeMyselfEye / GVRCameraRig / Player`)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“TeleportController”预制件拖放到你的层次结构中作为“Player”的子对象（对我们来说，“MeMyselfEye / GVRCameraRig
    / Player”）
- en: Reset its Transform, if necessary
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，重置其变换
- en: Drag the `MeMyselfEye` object onto the `TeleportController` component's Player transform
    slot
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“MeMyselfEye”对象拖放到“TeleportController”组件的“Player”变换槽中
- en: Drag GvrControllerPointer (or whichever controller game object you're using)
    onto the Controller transform slot
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“GvrControllerPointer”（或你正在使用的任何控制器游戏对象）拖放到“Controller”变换槽中
- en: On the TeleportController's Valid Teleport Layers, select Teleport (so both
    Default, Teleport are selected)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“TeleportController”的“Valid Teleport Layers”中，选择“Teleport”（这样“Default”和“Teleport”都被选中）
- en: 'On Raycast Mask, we want only Teleport, so select Nothing (to deselect all),
    then select Teleport. The layer settings are shown in the screen capture here:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Raycast Mask”中，我们只想选择“Teleport”，因此选择“Nothing”（取消选择所有选项），然后选择“Teleport”。层设置在此处的屏幕截图中显示：
- en: '![](img/8d3fb548-93bd-43ed-bc0f-a196d0221075.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d3fb548-93bd-43ed-bc0f-a196d0221075.png)'
- en: Press Play. When the controller pointer's arc touches a teleport pod, it will
    glow highlight. If you click, you will be teleported to that spot.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按播放。当控制器指针的弧线接触到传送舱时，它会发光高亮。如果你点击，你将被传送到那个位置。
- en: Room-scale considerations
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 房间规模考虑事项
- en: The gallery level layout we have designed works best in seated, standing, or
    non-positionally tracked VR. Our use of the zig-zag partitions, for example, is
    not a good idea in room scale VR unless you take care to not allow the player's
    play space (chaperone boundaries) to cross these walls. This can be done, but
    you would need to make the overall space larger, perhaps adaptive to the actual
    play space size, and add conditions to the teleportation feature that we implement
    later in the chapter, complicating our examples. See [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion
    and Comfort* for more about room-scale considerations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的画廊级别布局在坐着、站着或非位置跟踪VR中效果最好。例如，我们使用的之字形隔断在房间规模VR中不是一个好主意，除非你小心不要让玩家的游戏空间（守护者边界）穿过这些墙壁。这是可以做到的，但你可能需要使整体空间更大，可能适应实际的播放空间大小，并添加条件到我们在本章后面实现的传送功能中，这会使我们的示例复杂化。有关房间规模考虑事项的更多信息，请参阅[第7章](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml)，*移动和舒适*。
- en: The following image is a depiction of an initial position for MeMyselfEye for
    a room scale OpenVR camera rig, showing the guardian boundaries fit neatly within
    the gallery viewing space for the first ArtworkRig. It may not fit so easily at
    the other viewing situations, so you'd need to make adjustments to discourage
    the player from walking through walls (or through Ethan!). Also, whereas this
    is the default length and width, the player's actual space will vary to their
    configuration requirements. To fully accommodate these possibilities, it may be
    necessary to go to a procedurally generated level layout, where the position and
    scale of the walls are determined at runtime based on the player settings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了MeMyselfEye在房间规模OpenVR相机装置中的初始位置，显示守护边界完美地适合第一个ArtworkRig的画廊观看空间。在其他观看情况下可能不太容易适应，因此你可能需要调整以阻止玩家穿过墙壁（或穿过Ethan！）。此外，虽然这是默认的长度和宽度，但玩家的实际空间将根据其配置要求而变化。为了完全适应这些可能性，可能需要前往一个程序生成的关卡布局，其中墙壁的位置和缩放在运行时根据玩家设置确定。
- en: '![](img/5187058a-dc58-40e1-acbc-a2e30e316ff0.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5187058a-dc58-40e1-acbc-a2e30e316ff0.png)'
- en: Animating a ride-through
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化浏览体验
- en: If you can be certain the player will be seated or at least standing in one
    place, they might enjoy a ride-through guided tour of the gallery.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够确定玩家将坐着或至少站在一个地方，他们可能会喜欢画廊的浏览体验导览。
- en: In conventional games, first-person animation is often used for a cut-scene,
    that is, a canned fly-through animation as a transition from one level to another.
    In VR, it's somewhat different. Walkthroughs can really be the VR experience itself.
    Head tracking is still active. So, it's not simply a prerecorded video. You can
    look around and experience it, and it is more like an amusement park ride. This
    is often called an on-the-rails VR experience.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统游戏中，通常使用第一人称动画来制作过场动画，即从一个关卡到另一个关卡的预录飞行动画。在VR中，情况有所不同。浏览体验可以真正成为VR体验本身。头部跟踪仍然处于活动状态。因此，这不仅仅是一个预录制的视频。你可以四处张望并体验它，这更像是游乐园的游乐设施。这通常被称为轨道式VR体验。
- en: Be cautious using ride-through animations in your VR apps. It can cause motion
    sickness. If you do, give your players as much control as possible. For example,
    we're animating the `MeMyselfEye` rig, allowing users to continue to look around.
    Placing the user in a cockpit or vehicle with stationary surfaces in the foreground
    can also reduce the tendency for sickness. On the other hand, if you're a thrill
    seeker, techniques similar to those here can be used for making roller-coaster
    rides on a track that moves in three dimensions!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的VR应用中使用浏览动画时要小心。它可能会引起晕动症。如果你这样做，尽可能给玩家提供更多控制权。例如，我们正在动画化`MeMyselfEye`装置，允许用户继续四处张望。将用户置于一个有固定表面的驾驶舱或车辆中，也可以减少晕动症的倾向。另一方面，如果你是寻求刺激的人，可以使用这里类似的技术在三维移动轨道上制作过山车之旅！
- en: In this topic, we are scripting the animations ourselves. In a later chapter,
    we will dive more deeply into other Unity animation and cinematic tools. We create
    a `RidethroughController` that animates the first-person character (`MeMyselfEye`)
    Transform position, and rotation over time. It works by defining the key-frame
    transforms, using the Unity `AnimationCurve` class ([https://docs.unity3d.com/ScriptReference/AnimationCurve.html](https://docs.unity3d.com/ScriptReference/AnimationCurve.html)).
    As the name suggests, for key-frame animation, we define the player's location
    at specific key times in the ride. The in-between frames are calculated automatically.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们正在自己编写动画脚本。在后面的章节中，我们将更深入地探讨其他Unity动画和电影工具。我们创建了一个`RidethroughController`控制器，用于动画化第一人称角色（`MeMyselfEye`）的变换位置和随时间旋转。它通过定义关键帧变换，使用Unity的`AnimationCurve`类（[https://docs.unity3d.com/ScriptReference/AnimationCurve.html](https://docs.unity3d.com/ScriptReference/AnimationCurve.html)）来实现。正如其名所示，对于关键帧动画，我们在骑行中定义玩家在特定关键时间点的位置。中间帧会自动计算。
- en: At the root of Hierarchy, create a new Empty game object and name it `RidethroughController`
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构的根目录下创建一个新的空游戏对象，并将其命名为`RidethroughController`
- en: Add a new C# script component and name it `RidethroughController`
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的C#脚本组件，并将其命名为`RidethroughController`
- en: Open the script for editing
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本进行编辑
- en: 'First, we''ll define some variables we will need:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一些我们将需要的变量：
- en: '[PRE13]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`playerRoot` is the player transform we will animate (`MeMyselfEye`). `artWorks`
    is the container of the ArtworkRigs. We''ve included an option to specify an initial
    delay and the transition time between pictures. The setup function will generate
    three curves, for position (*x *and *z*) and rotation (about the *y *axis).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerRoot`是我们将要动画化的玩家变换（`MeMyselfEye`）。`artWorks`是艺术品装置的容器。我们包括了一个指定初始延迟和图片之间过渡时间的选项。设置函数将生成三个曲线，用于位置（*x*和*z*）和旋转（关于*y*轴）。'
- en: 'Next, we write a `SetupCurves` function that generates the animation curves,
    using each of ArtworkRig''s ViewPose as nodes in the curve. We do this concurrently
    for the *x*, z, and rotation curves as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写一个`SetupCurves`函数，生成动画曲线，使用每个ArtworkRig的ViewPose作为曲线中的节点。我们同时为*x*、z和旋转曲线这样做如下：
- en: '[PRE14]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will define the `RidethroughController` to start animating when the game
    object is enabled:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`RidethroughController`，当游戏对象被启用时开始动画：
- en: '[PRE15]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On each Update, we evaluate the X and Z curves to set the player''s current
    position. And, we evaluate the rotation curve to set the player''s current rotation.
    We use the native `Quaternion` representation of rotations since we''re interpolating
    between two angles we do not want use Euler coordinates:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次更新中，我们评估X和Z曲线来设置玩家的当前位置。同时，我们评估旋转曲线来设置玩家的当前旋转。我们使用原生的`Quaternion`表示旋转，因为我们正在在两个我们不想使用欧拉坐标的角度之间进行插值：
- en: '[PRE16]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lastly, we check whether we've completed the animation by comparing the current
    time with the time of the last node in the curve. If so, we disable the game object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过比较当前时间与曲线中最后一个节点的时时间来检查我们是否完成了动画。如果是这样，我们将禁用游戏对象。
- en: In this script, I used the `transform.rotation` Quaternion y value directly.
    It's usually not recommended to manipulate Quaternion's value directly, but since
    we're consistently changing only a single axis, it is safe. For more information
    on Quaternion versus Euler angles, see [https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html](https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我直接使用了`transform.rotation`的Quaternion y值。通常不建议直接操作Quaternion的值，但由于我们一致地只改变一个轴，这是安全的。有关Quaternion与欧拉角度的更多信息，请参阅[https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html](https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html)。
- en: As written, if/when the RidethroughController game object is enabled, the animation
    will play. You can save your scene with it enabled, and it will play when the
    app begins. We'll leave it up to you to modify it to be trigged by a player's
    option such as a *Start Ride* button within the app!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如所写，如果/当RidethroughController游戏对象被启用时，动画将播放。你可以保存启用它的场景，当应用开始时它将播放。我们将把它留给你来修改，使其可以通过玩家选项触发，例如应用内的*开始骑行*按钮！
- en: 'Save the script and then perform the following steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后执行以下步骤：
- en: From Hierarchy, drag `MeMyselfEye` onto the Player Root slot
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中，将`MeMyselfEye`拖放到玩家根槽中
- en: Drag the `Artworks` (which contains all `ArtworkRigs`) onto the Artworks slot
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Artworks`（包含所有`ArtworkRigs`）拖放到Artworks槽中
- en: When you Play the scene, you get a nice easy ride through the art gallery, with
    a slight pause to view each photo. That's real nice! Hopefully, you picked images
    that can be shown by you to all your friends and family!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放场景时，你将获得一次轻松愉快的艺术画廊之旅，每张照片会有短暂的暂停来观看。这真的很棒！希望你能挑选出可以展示给你的所有朋友和家人的图片！
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built an art gallery scene from scratch, starting with a
    2D plan drawing and going into Blender to construct a 3D architectural structure.
    We imported the model into Unity and added some environmental lighting. Then,
    we built an artwork rig consisting of an image, a picture frame, and a spotlight,
    and placed instances of the rig on various walls throughout the gallery. Next,
    we imported a bunch of personal photos and wrote a script that populates the art
    frames at runtime. Adding more detailed data about each artwork, we explored several
    ways of managing lists of non-graphical data. Finally, we added the ability to
    move around within the art gallery level, via teleportation and an automated first-person
    walkthrough of the scene.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始构建了一个艺术画廊场景，首先从一张2D平面图开始，然后在Blender中构建一个3D建筑结构。我们将模型导入Unity，并添加了一些环境照明。接着，我们构建了一个由图像、画框和聚光灯组成的艺术品装置，并在画廊的各个墙上放置了装置的实例。然后，我们导入了一大批个人照片，并编写了一个在运行时填充艺术画框的脚本。添加了关于每件艺术品的更详细数据后，我们探索了管理非图形数据列表的几种方法。最后，我们添加了在艺术画廊级别内移动的能力，通过传送和自动的第一人称场景浏览来实现。
- en: In the next chapter, we will take a look at a different kind of VR experience
    using pre-recorded 360-degree media. You will build and learn about photospheres,
    equirectangular projections, and infographics.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种使用预先录制的360度媒体的不同类型的VR体验。你将构建并了解球形照片、等经纬投影和图表信息。
