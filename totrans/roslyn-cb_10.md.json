["```cs\n// Class with no accessibility modifier\nclass C1\n{\n  void M() {}\n}\n\n// Public class with no documentation comments\npublic class C2\n{\n  void M() {}\n}\n\n// Empty class with no members\npublic class C3\n{\n}\n\n```", "```cs\npublic static void Main(string[] args)\n{\n  // Parse arguments to get source file.\n  var filePath = ParseArguments(args);\n  if (filePath == null)\n  {\n    return;\n  }\n\n  // Parse text into SyntaxTree.\n  var tree = Parse(filePath);\n  var root = (CompilationUnitSyntax)tree.GetRoot();\n\n  // Transform syntax tree to edit/add/remove syntax.\n  root = EditClassDeclarations(root);\n  root = AddDocCommentsToClassDeclarations(root);\n  root = RemoveEmptyClassDeclarations(root);\n\n  Console.WriteLine(\"Transformed source:\" + Environment.NewLine);\n  Console.WriteLine(root.ToFullString());\n}\n\n```", "```cs\nprivate static string ParseArguments(string[] args)\n{\n  if (args.Length != 1)\n  {\n    Console.WriteLine(@\"Usage: ConsoleApp.exe <%file_path%>\");\n    return null;\n  }\n\n  if (!File.Exists(args[0]))\n  {\n    Console.WriteLine($\"File '{args[0]}' does not exist\");\n    return null;\n  }\n\n  return args[0];\n}\n\n```", "```cs\nprivate static SyntaxTree Parse(string filePath)\n{\n var text = File.ReadAllText(filePath);\n return CSharpSyntaxTree.ParseText(text);\n}\n\n```", "```cs\nprivate static CompilationUnitSyntax EditClassDeclarations(CompilationUnitSyntax root)\n{\n  // Get class declarations with no accessibility modifier.\n  var classDeclarations = root.DescendantNodes()\n    .OfType<ClassDeclarationSyntax>()\n    .Where(c => !c.Modifiers.Any(m => SyntaxFacts.IsAccessibilityModifier(m.Kind())));\n\n  // Add modifier to these class declarations and replace in the original tree.\n  return root.ReplaceNodes(classDeclarations,\n  computeReplacementNode: (o, n) => AddModifier(n));\n}\n\n```", "```cs\nprivate static ClassDeclarationSyntax AddModifier(ClassDeclarationSyntax classDeclaration)\n{\n  var internalModifier = SyntaxFactory.Token(SyntaxKind.InternalKeyword)\n    .WithTrailingTrivia(SyntaxFactory.Whitespace(\" \"));\n  if (classDeclaration.HasLeadingTrivia)\n  {\n    // Move leading trivia for the class declaration to the new modifier.\n    internalModifier = internalModifier.WithLeadingTrivia(classDeclaration.GetLeadingTrivia());\n    classDeclaration = classDeclaration.WithLeadingTrivia();\n  }\n\n  var newModifiers = classDeclaration.Modifiers.Insert(0, internalModifier);\n  return classDeclaration.WithModifiers(newModifiers);\n}\n\n```", "```cs\nprivate static CompilationUnitSyntax AddDocCommentsToClassDeclarations(CompilationUnitSyntax root)\n{\n  // Get public class declarations with no documentation comments.\n  var classDeclarations = root.DescendantNodes()\n    .OfType<ClassDeclarationSyntax>()\n    .Where(c => c.Modifiers.Any(m => m.Kind() == SyntaxKind.PublicKeyword) &&\n   !c.GetFirstToken().LeadingTrivia.Any(IsDocumentationComment));\n\n  // Add stub documentation comment to these class declarations and replace in the original tree.\n  return root.ReplaceNodes(classDeclarations,\n  computeReplacementNode: (o, n) => AddDocumentationComment(n));\n}\n\n```", "```cs\nprivate static ClassDeclarationSyntax *AddDocumentationComment*(ClassDeclarationSyntax classDeclaration)\n{\n var summaryElement = SyntaxFactory.XmlSummaryElement(SyntaxFactory.XmlText(\"TODO: Add doc comments\"));\n var documentationComment = SyntaxFactory.DocumentationComment(summaryElement);\n var newLeadingTrivia = classDeclaration.GetLeadingTrivia()\n  .Add(SyntaxFactory.Trivia(documentationComment))\n  .Add(SyntaxFactory.EndOfLine(Environment.NewLine));\n  return classDeclaration.WithLeadingTrivia(newLeadingTrivia);\n}\n\n```", "```cs\nprivate static CompilationUnitSyntax RemoveEmptyClassDeclarations(CompilationUnitSyntax root)\n{\n // Get class declarations with no members.\n var classDeclarations = root.DescendantNodes()\n  .OfType<ClassDeclarationSyntax>()\n  .Where(c => c.Members.Count == 0);\n\n // Remove these class declarations from the original tree.\n return root.RemoveNodes(classDeclarations, SyntaxRemoveOptions.KeepNoTrivia);\n}\n\n```", "```cs\nclass C1\n{\n void F()\n {\n  M1();\n  M2(0);\n  M2(null);\n }\n\n void M1()\n {\n }\n\n void M2()\n {\n }\n\n void M2(int x)\n {\n }\n}\n\n```", "```cs\npublic static void Main(string[] args)\n{\n // Parse arguments to get source file.\n var filePath = ParseArguments(args);\n if (filePath == null)\n {\n  return;\n }\n\n // Parse text and create a compilation.\n var compilation = CreateCompilation(filePath);\n\n // Display diagnostics in the compilation.\n DisplayDiagnostics(compilation);\n\n // Display semantic information about invocations in the file.\n DisplayInvocations(compilation);\n}\n\n```", "```cs\nprivate static Compilation CreateCompilation(string filePath)\n{\n var text = File.ReadAllText(filePath);\n var tree = CSharpSyntaxTree.ParseText(text);\n var systemAssembly = MetadataReference.CreateFromFile(typeof(object).Assembly.Location);\n var options = new CSharpCompilationOptions(outputKind: OutputKind.DynamicallyLinkedLibrary);\n return CSharpCompilation.Create(\"TestAssembly\",\n  syntaxTrees: new[] { tree },\n  references: new[] { systemAssembly },\n  options: options);\n}\n\n```", "```cs\nprivate static void DisplayDiagnostics(Compilation compilation)\n{\n var diagnostics = compilation.GetDiagnostics();\n Console.WriteLine($\"Number of diagnostics: {diagnostics.Length}\");\n foreach (var diagnostic in diagnostics)\n {\n  Console.WriteLine(diagnostic.ToString());\n }\n\n Console.WriteLine();\n}\n\n```", "```cs\nprivate static void DisplayInvocations(Compilation compilation)\n{\n var tree = compilation.SyntaxTrees.Single();\n var semanticModel = compilation.GetSemanticModel(tree);\n var invocations = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>();\n foreach (var invocation in invocations)\n {\n  Console.WriteLine($\"Invocation: '{invocation.ToString()}'\");\n  var symbolInfo = semanticModel.GetSymbolInfo(invocation);\n\n  var overloadResolutionResult = symbolInfo.CandidateReason == CandidateReason.None ? \"Succeeded\" : symbolInfo.CandidateReason.ToString();\n  Console.WriteLine($\" Overload resolution result: {overloadResolutionResult}\");\n\n  if (symbolInfo.Symbol != null)\n  {\n   Console.WriteLine($\" Method Symbol: {symbolInfo.Symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}\");\n  }\n  else if (!symbolInfo.CandidateSymbols.IsDefaultOrEmpty)\n  {\n   Console.WriteLine($\" {symbolInfo.CandidateSymbols.Length} candidate symbols:\");\n   foreach (var candidate in symbolInfo.CandidateSymbols)\n   {\n    Console.WriteLine($\" Candidate Symbol: {candidate.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}\");\n   }\n  }\n\n  Console.WriteLine();\n }\n}\n\n```", "```cs\nclass ClassWithLowerCase\n{\n}\n\nclass OuterClassWithLowerCase\n{\n class NestedClassWithLowerCase\n {\n }\n}\n\nclass CLASS_WITH_UPPER_CASE\n{\n}\n\n```", "```cs\nNumber of diagnostics: 3\n(1,7): warning CSharpAnalyzers: Type name 'ClassWithLowerCase' contains lowercase letters\n(5,7): warning CSharpAnalyzers: Type name 'OuterClassWithLowerCase' contains lowercase letters\n(7,9): warning CSharpAnalyzers: Type name 'NestedClassWithLowerCase' contains lowercase letters\n\n```", "```cs\npublic static void Main(string[] args)\n{\n // Parse arguments to get analyzer assembly file and source file.\n var files = ParseArguments(args);\n if (files.analyzerFile == null || files.sourceFile == null)\n {\n  return;\n }\n\n // Parse source file and create a compilation.\n var compilation = CreateCompilation(files.sourceFile);\n\n // Create compilation with analyzers.\n var compilationWithAnalyzers = CreateCompilationWithAnalyzers(files.analyzerFile, compilation);\n\n // Display analyzer diagnostics in the compilation.\n DisplayAnalyzerDiagnostics(compilationWithAnalyzers);\n}\n\n```", "```cs\nprivate static CompilationWithAnalyzers CreateCompilationWithAnalyzers(string analyzerFilePath, Compilation compilation)\n{\n var analyzerFileReference = new AnalyzerFileReference(analyzerFilePath, new AnalyzerAssemblyLoader());\n var analyzers = analyzerFileReference.GetAnalyzers(LanguageNames.CSharp);\n var options = new CompilationWithAnalyzersOptions(\n  new AnalyzerOptions(ImmutableArray<AdditionalText>.Empty),\n  onAnalyzerException: (exception, analyzer, diagnostic) => throw exception,\n  concurrentAnalysis: false,\n  logAnalyzerExecutionTime: false);\n return new CompilationWithAnalyzers(compilation, analyzers, options);\n }\n\n```", "```cs\nprivate class AnalyzerAssemblyLoader : IAnalyzerAssemblyLoader\n{\n  void IAnalyzerAssemblyLoader.AddDependencyLocation(string fullPath)\n  {\n  }\n\n  Assembly IAnalyzerAssemblyLoader.LoadFromPath(string fullPath)\n  {\n    return Assembly.LoadFrom(fullPath);\n  }\n}\n\n```", "```cs\nprivate static void DisplayAnalyzerDiagnostics(CompilationWithAnalyzers compilationWithAnalyzers)\n{\n var diagnostics = compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync(CancellationToken.None).Result;\n Console.WriteLine($\"Number of diagnostics: {diagnostics.Length}\");\n foreach (var diagnostic in diagnostics)\n {\n  Console.WriteLine(diagnostic.ToString());\n }\n\n Console.WriteLine();\n }\n\n return newSolution;\n}\n\n```", "```cs\nLoading solution '<%test_sln_path%>'...\nFormatting solution...\nSimplifying solution...\nSolution updated.\n\n```", "```cs\npublic static void Main(string[] args)\n{\n // Parse arguments to get solution.\n var slnPath = ParseArguments(args);\n if (slnPath == null)\n {\n  return;\n }\n\n // Create workspace.\n MSBuildWorkspace workspace = MSBuildWorkspace.Create();\n\n // Open solution within the workspace.\n Console.WriteLine($\"Loading solution '{slnPath}'...\");\n Solution solution = workspace.OpenSolutionAsync(slnPath).Result;\n\n // Format the solution.\n solution = FormatSolution(solution, workspace.Options);\n\n // Simplify the solution.\n solution = SimplifySolution(solution, workspace.Options);\n\n // Apply changes.\n ApplyChanges(workspace, solution);\n}\n\n```", "```cs\nprivate static Solution FormatSolution(Solution originalSolution, OptionSet options)\n{\n Console.WriteLine(\"Formatting solution...\");\n\n // Prefer whitespaces over tabs, with an indentation size of 2.\n options = options\n  .WithChangedOption(FormattingOptions.UseTabs, LanguageNames.CSharp, false)\n  .WithChangedOption(FormattingOptions.IndentationSize, LanguageNames.CSharp, 2);\n\n Solution newSolution = originalSolution;\n foreach (var documentId in originalSolution.Projects.SelectMany(p => p.DocumentIds))\n {\n  Document document = newSolution.GetDocument(documentId);\n\n  // Format the document.\n  Document newDocument = Formatter.FormatAsync(document, options).Result;\n\n  // Update the current solution.\n  newSolution = newDocument.Project.Solution;\n }\n\n return newSolution;\n}\n\n```", "```cs\nprivate static Solution SimplifySolution(Solution originalSolution, OptionSet options)\n{\n Console.WriteLine(\"Simplifying solution...\");\n\n // Prefer 'var' over explicit type specification.\n options = options.WithChangedOption(SimplificationOptions.PreferImplicitTypeInLocalDeclaration, true);\n\n Solution newSolution = originalSolution;\n foreach (var documentId in originalSolution.Projects.SelectMany(p => p.DocumentIds))\n {\n  Document document = newSolution.GetDocument(documentId);\n\n  // Add simplification annotation to the root.\n  var newRoot = document.GetSyntaxRootAsync().Result.WithAdditionalAnnotations(Simplifier.Annotation);\n\n  // Simplify the document.\n  Document newDocument = Simplifier.ReduceAsync(document.WithSyntaxRoot(newRoot), options).Result;\n\n  // Update the current solution.\n  newSolution = newDocument.Project.Solution;\n }\n\n return newSolution;\n}\n\n```", "```cs\nprivate static void ApplyChanges(Workspace workspace, Solution solution)\n{\n // Apply solution changes to the workspace.\n // This persists the in-memory changes into the disk.\n if (workspace.TryApplyChanges(solution))\n {\n  Console.WriteLine(\"Solution updated.\");\n }\n else\n {\n  Console.WriteLine(\"Update failed!\");\n }\n}\n\n```", "```cs\npublic static void Main(string[] args)\n{\n // Parse arguments to get solution.\n string slnPath = ParseArguments(args);\n if (slnPath == null)\n {\n  return;\n }\n\n // Create workspace.\n MSBuildWorkspace workspace = MSBuildWorkspace.Create();\n\n // Open solution within the workspace.\n Console.WriteLine($\"Loading solution '{slnPath}'...\");\n Solution solution = workspace.OpenSolutionAsync(slnPath).Result;\n\n // Display project properties.\n DisplayProjectProperties(solution);\n\n // Add project AddedClassLibrary.\n WaitForKeyPress();\n solution = AddProject(solution, \"AddedClassLibrary\");\n\n // Remove project ClassLibrary.\n solution = RemoveProject(solution, \"ClassLibrary\");\n\n // Add project reference from AddedClassLibrary to TestSolution.\n solution = AddProjectReference(solution, referenceFrom: \"AddedClassLibrary\", referenceTo: \"TestSolution\");\n\n // Display project properties.\n WaitForKeyPress();\n DisplayProjectProperties(solution);\n}\n\n```", "```cs\nprivate static void DisplayProjectProperties(Solution solution)\n{\n Console.WriteLine($\"Project count: {solution.Projects.Count()}\");\n\n foreach (var project in solution.Projects)\n {\n  Console.WriteLine($\" Project: {project.Name}\");\n  Console.WriteLine($\" Assembly name: {project.AssemblyName}\");\n  Console.WriteLine($\" Language: {project.Language}\");\n  Console.WriteLine($\" Project file: {project.FilePath}\");\n  Console.WriteLine($\" Output file: {project.OutputFilePath}\");\n  Console.WriteLine($\" Documents: {project.Documents.Count()}\");\n  Console.WriteLine($\" Metadata references: {project.MetadataReferences.Count()}\");\n  Console.WriteLine($\" Project references: {project.ProjectReferences.Count()}\");\n  Console.WriteLine();\n }\n\n Console.WriteLine();\n}\n\n```", "```cs\nprivate static Solution AddProject(Solution originalSolution, string projectName)\n{\n Console.WriteLine($\"Adding project '{projectName}'...\");\n var projectInfo = ProjectInfo.Create(\n  id: ProjectId.CreateNewId(),\n  version: new VersionStamp(),\n  name: projectName,\n  assemblyName: \"AddedProjectAssembly\",\n  language: LanguageNames.CSharp);\n return originalSolution.AddProject(projectInfo);\n}\n\n```", "```cs\nprivate static Solution RemoveProject(Solution originalSolution, string projectName)\n{\n Console.WriteLine($\"Removing project '{projectName}'...\");\n var project = originalSolution.Projects.SingleOrDefault(p => p.Name == projectName);\n return originalSolution.RemoveProject(project.Id);\n}\n\n```", "```cs\nprivate static Solution AddProjectReference(Solution originalSolution, string referenceFrom, string referenceTo)\n{\n Console.WriteLine($\"Adding project reference from '{referenceFrom}' to '{referenceTo}'...\");\n var projectReferenceFrom = originalSolution.Projects.SingleOrDefault(p => p.Name == referenceFrom);\n var projectReference = new ProjectReference(projectReferenceFrom.Id);\n var projectReferenceTo = originalSolution.Projects.SingleOrDefault(p => p.Name == referenceTo);\n return originalSolution.AddProjectReference(projectReferenceTo.Id, projectReference);\n}\n\n```"]