- en: Chapter 10. Parallel LINQ – PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about declarative data parallelism using **Parallel
    Language Integrated Query** (**PLINQ**). In [Chapter 7](ch07.html "Chapter 7. Data
    Parallelism"), *Data Parallelism*, we discussed data parallelism using the `Parallel`
    library and the `Parallel.For` and `Parallel.ForEach` loops. PLINQ is a parallel
    version of LINQ to Objects. **LINQ to Objects** allows for LINQ queries on in-memory
    data collections such as `List` and `DataTable` that implement the `IEnumerable`
    or `IEnumerable<T>` interface. Unlike a sequential LINQ, PLINQ tries to use all
    of the processors in the computer it is running on by dividing the data collections
    into segments and creating a task to process each segment of the data collection.
    PLINQ and the **Common Language Runtime** (**CLR**) are smart enough to evaluate
    the query and determine if it will benefit from a multithreaded execution. If
    not, then it will run sequentially like a normal LINQ. It is the best of both
    worlds. .NET figures out whether it can gain performance improvements by operating
    concurrently or not and makes the decision for you.
  prefs: []
  type: TYPE_NORMAL
- en: The parallel extension methods were added to the `System.Linq` namespace in
    .NET 4.5\. It includes extension methods for all standard LINQ operators as well
    as some extra ones for parallel operators. Almost all of the PLINQ methods are
    implemented in the `System.Linq.ParallelEnumerable` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing a PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding performance improvements in PLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's take a look at a basic PLINQ and syntax. We will use three different
    methods to perform the PLINQ and then examine the results. The first will use
    the `ForAll` method of the `ParallelQuery` class. The next one will use the `AsParallel`
    method of the LINQ library on the `Enumerable` collection. The final way will
    use the standard LINQ method syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We will then display the results of the three queries in three listboxes and
    also display the time it took to execute each query.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by opening up Visual Studio and creating a new WPF application
    project named `WpfPLINQQuery`. Once this project is open, let''s perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainWindow.xaml` file in design mode add three button controls and name
    them `btnMethod1`, `btnMethod2`, and `btnMethod3`. Set the `Content` property
    of each to `Execute Method 1`, `Execute Method 2`, and `Execute Method 3,` respectively.
    Next, create a click event handler for each in the `MainWindow.xaml.cs` file and
    name these three methods `btnMethod1_Click`, `btnMethod2_Click`, and `btnMethod3_Click,`
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `btnMethod1_Click` event handler method, place the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `btnMethod2_Click` event handler method, place the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `btnMethod3_Click` event handler method, place the following code. Also,
    let's add three listboxes and name them `lb1`, `lb2`, and `lb3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then add three textboxes and name them `tbTime1`, `tbTime2`, and `tbTime3`.
    Also, clear their `Text` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainWindow.xaml.cs` file, we will need to add a `using` statement so
    that the `Stopwatch` class is available to us. So, add the following statement
    at the top of the file with the rest of the `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to add an empty method to serve as our delegate for the lambda
    expression. We will call it `DoWork`. Add it to the bottom of the `MainWindow`
    class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is all the code we need to add to our `MainWindow.xaml.cs` file. Our `MainWindow.xaml`
    file should now contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now our project is completed. Let''s build and run the project. The program
    should look like this when it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s click on the **Execute Method 1** button. We should see results
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s click on the next two buttons, **Execute Method 2** and **Execute
    Method 3** and see what the program looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we executed the PLINQ parallel query using three different methods
    and the results are different each time. The first thing you'll notice if you
    scroll through the results is that the numbers in the listbox are not ordered.
    The next thing you will notice is that the runtime of each is not exactly the
    same. Granted, the first one will take longer to display because we divide by
    5 instead of 10, so there are more results. But the query itself should take roughly
    the same time. You can play with this by moving the command to stop the `Stopwatch`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's examine how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we performed a PLINQ parallel query using three different
    methods. In the first one, we defined a `ParallelQuery` object using this line
    of code, but didn''t execute it yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `AsParallel` method to the `IEnumerable` collection with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This tells .NET to try and execute this query concurrently if it determines
    that it will improve performance. We can force .NET to operate this query concurrently
    using the parallel extension method `WithExecutionMode(ParallelExecutionMode.ForceParallelism)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we actually ran the query using the `ForAll` method of the `ParallelQuery`
    class. We did this using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To use this command, we need to pass it a lambda expression. We are just using
    a lambda expression that passes a delegate to a method that does nothing. We do
    not need to do work in the delegate method because we are doing all of the work
    in the parallel query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second method, we create a parallel query that executes when the command
    is processed and returns an array. This command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that here we have added the `ToArray()` method to the results of the
    query. By implementing the parallel query this way we ensure that the query is
    executing during this command. In the first method, we create the query but do
    not execute it until the `ForAll` command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final method, we use the LINQ method syntax. Here is the statement that
    performs the query using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we return a `ParallelQuery` object instead of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that in all three methods the results are not returned in order.
    We will see later in the chapter how to ensure the order of the results if that
    is necessary. For now, we are just trying to run a parallel query. We will let
    .NET determine how to run the query (concurrently or sequentially), and in whatever
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering in PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, what if the order of our results matters? In a lot of cases, we will want
    the results to come back in a certain order. Let's examine how we can accomplish
    this.
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods contained in the parallel extension methods of the
    `IEnumerable` interface. The two we use the most are `AsOrdered()` and `AsOrderedBy()`.
    These two methods guarantee order preservation in the results of the parallel
    query. This does add some cost and overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take our project from the last section and update it to return the ordered
    results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open up our `PLINQQuery` project and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the parallel query statement in the `btnMethod1_Click` method to look
    like the following by adding the `AsOrdered` method to the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, make a similar change to the statement in the `btnMethod2_Click` method.
    Make its parallel query statement look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s make a similar change to the `btn3Method_Click` method and
    its query statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is all of the changes; seems simple enough. Now, let''s build and run
    our application. You should get a program that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s click on each of the three buttons to run all the three queries.
    Your program should now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the results are now ordered. This is a simple example; however,
    in a more complex example, you will also see that the runtimes are longer. As
    you would expect, ordering the results will slow down the query processing.
  prefs: []
  type: TYPE_NORMAL
- en: Also, did you notice that if you execute the queries in the application in a
    different order you will see that typically the first one takes longer than the
    last one? There are two explanations for why the last one to run is usually faster.
    .NET has run the query, so it has also taken time to determine the best execution
    method. Also, if it chooses to run the query concurrently, it has already taken
    the overhead of creating the tasks in the threadpool.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The change from the first project to this one is a simple one. We just added
    the `AsOrdered()` method to the parallel extension method, `AsParallel()`, that
    we execute against the `IEnumerable` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This forces .NET to order the results. We can also order the results with the
    `OrderBy` query syntax. It should be noted that `OrderBy` is done sequentially,
    not in parallel. The following screenshot explains items in the query itself that
    will order the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Referenced from http://msdn.microsoft.com/en-us/library/dd460677(v=vs.110).aspx
  prefs: []
  type: TYPE_NORMAL
- en: Merging in PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to perform a parallel query and how to order the results.
    Now, let's examine merging with our parallel queries.
  prefs: []
  type: TYPE_NORMAL
- en: When a parallel query is performed, the .NET CLR partitions the source collection
    so that several tasks can work sections of the collection concurrently. Once this
    is completed, the results need to be merged into a result collection for processing.
    Depending on the query operators used, the results can be merged in different
    ways. Query operators that dictate a new order on the result collection will buffer
    all items from the separate threads before merging them together again. Other
    query operators are partially buffered, while the query operator, `ForAll<TSource>`,
    is not buffered. It produces all items from all tasks as soon as they are processed.
  prefs: []
  type: TYPE_NORMAL
- en: The `WithMergeOptions<TSource>` method can tell PLINQ how to perform the merging
    process of a concurrent query.
  prefs: []
  type: TYPE_NORMAL
- en: If a query cannot perform the merge option specified, .NET will ignore it. So,
    you can see that .NET treats merge options as suggestions and will not throw an
    error if the merge option is not compatible; it will just ignore it. Likewise,
    if you do not specify a merge option, .NET will select one for you. So, you can
    use a merge option if you have determined that a specific merge is best for your
    performance or just let .NET decide for you. This is one of the beautiful things
    of the TPL. It handles a lot of the thinking for you when it comes to common concurrent
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different options with which the parallel merge can be set up are listed
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging in PLINQ](img/8321EN_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Referenced from http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the parallel query operators that support merging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging in PLINQ](img/8321EN_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Referenced from http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's go back to our project and try changing our program to use the `NotBuffered`,
    `AutoBuffered`, and `FullyBuffered` merging options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s open our `PLINQQuery` project and change the parallel query
    statement in the `btnMethod1_Click` method to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build and run the program and click on the **Execute Method 1**
    button. You should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to use the `AutoBuffered` method. To do this, in the `btnMethod1_Click`
    method, change the parallel query statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and run the program again. Click on the **Execute Method 1** button
    and you should get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s make one final change to the parallel query in this method to use
    the `AutoBuffered` option. Change the `btnMethod1_click` method to have the following
    parallel query statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build and run this application one final time and click on the
    **Execute Method 1** button. The results should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, to dictate to .NET on how to merge the results of a buffered
    query is as easy as calling the `WithMergeOptions()` parallel extension method;
    just like ordering the results is as easy as calling the `AsOrdered()` parallel
    extension method.
  prefs: []
  type: TYPE_NORMAL
- en: But you will also notice that the best results come from using the `AutoBuffered`
    or no-merge option. Even though PLINQ gives you these options to dictate how the
    parallel query is merged, if we let .NET determine how to do it, the results are
    often far better.
  prefs: []
  type: TYPE_NORMAL
- en: For complex examples, it might be beneficial to tell .NET how to merge the results,
    but often it is best to let the CLR determine this itself. This is one of the
    benefits of using PLINQ and the TPL—a lot of the complex work and thinking are
    handled for you. You can concentrate your coding time on the functionality and
    not the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Canceling a parallel query is very similar to canceling a task using TPL. First,
    we create a cancellation token and then we issue a cancel request to the cancellation
    token. This will create an operation cancellation exception. Then when we execute
    our parallel query, add the parallel extension method `WithCancellation()`, and
    pass it the cancellation token. Then, finally, we catch the operation cancellation
    request and process it.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET framework does not pass a single `OperationCanceledException` into
    a `System.AggregateException`; the `OperationCanceledException` must be processed
    in a separate `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s open our `PLINQQuery` project again and this time we will add a
    Cancel button and work with the `btnMethod2_Click` event handler method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add a new button control to our `MainWindow.xaml.cs` file and set its
    `Content` property to `Cancel` and name the control `btnCancel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add a `using` statement for the `Threading` namespace so we
    can create a cancellation token object. Add the following `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create a cancellation token at the top of our `MainWindow` class
    with the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add a `btnCancel_Click` click event handler method for our **Cancel**
    button. It should have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, let''s change our `IEnumerable` collection to have 500,000 items, so
    it will run longer and give us a chance to cancel the operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s change the `btnMethod2_Click` event handler to have the following
    code for the parallel query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s build and run our program. Click on the **Execute Method 2** button
    and immediately click on the **Cancel** button. You should see the following output
    in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we have canceled the parallel query before its completion.
    Now, let's now take a look at how it was performed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We performed this very simply. First, we created a cancellation token to use
    with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we created a **Cancel** button. and when it is pressed, we execute the
    `Cancel()` method of the cancellation token object. This is done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our parallel query, we add the `WithCancellation()` method and
    pass it the cancellation token. Then we add a `catch` block and catch any `OperationCanceledException`
    exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That is all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding performance improvements in PLINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can implement PLINQ queries and specify ordering, merging,
    and parallel execution options. We have also seen how to execute a PLINQ with
    the `ForAll()` method and as a `foreach` loop. All of these factor into the performance
    of the query. It is also important to examine how .NET decides to partition a
    source data collection when it decides to execute a PLINQ in parallel. Remember,
    a PLINQ executed in parallel is just a LINQ where a data collection is partitioned
    into groups and a task is created to process the `Where` action of the query on
    each partition of data. The following diagrams depict the differences between
    LINQ processing and PLINQ processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the process of the LINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the process of PLINQ. Notice how the data is partitioned
    and the `Where` clause is executed concurrently on each partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also, when we perform a query using a `ForAll` versus a `foreach` loop, the
    processing is different. We can determine which of these are the best methods,
    usually by finding out whether or not the order of the results matter. If the
    order of the results is important, then `foreach` is the better processing method
    because the results are merged after the loop processes. Using the `ForAll` loop,
    the whole query is processed on each data partition individually so that there
    is no merging of the results in the correct order. You can place the `AsOrdered`
    method on the `IEnumerable` collection for the query, but it then basically buffers
    all results to merge them so you lose the performance gains the `ForAll` loop
    gives you. The following diagrams depict the differences in the way each of these
    is processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll have a look at the `ForAll` processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Second, let''s look at the process of the `foreach` processing. Notice in the
    following diagram that the merge happens before the `foreach` loop processing,
    so the `foreach` processing is done sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s take a look at the algorithms PLINQ (or more aptly the .NET CLR)
    uses to partition a data collection into groups for parallel processing. .NET
    uses four different algorithms to partition data based on the collection and the
    query. The following screenshot details the first two algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Referenced from http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx
  prefs: []
  type: TYPE_NORMAL
- en: 'The details of the other two algorithms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding performance improvements in PLINQ](img/8321EN_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Referenced from http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the previous screenshot, PLINQ partitions the source data
    collection based on the type of data and the type of query. This is all part of
    the logic that .NET performs so we do not have to. Just like determining if a
    query should be run concurrently or sequentially, it also determines if concurrent
    is the best way to partition the data.
  prefs: []
  type: TYPE_NORMAL
- en: As we also saw, based on whether or not you need the results ordered either
    a `ForAll` or a `foreach` statement can yield better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to change an ordinary LINQ to Objects query
    into a concurrent PLINQ. You also learned how to order results, merge results,
    and cancel queries. PLINQ makes it very easy to concurrently process queries on
    any memory data collection that supports `IEnumerable`.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to remember that PLINQ only supports LINQ to Objects and
    not the other forms of LINQ such as LINQ to SQL or LINQ to XML.
  prefs: []
  type: TYPE_NORMAL
- en: PLINQ is as easy to implement as adding a parallel extension method to a source
    data collection in a LINQ query—it is really that simple. Then .NET can determine
    if the query will have better performance running concurrently by partitioning
    the data collection into pieces, and if so, how to partition it. You as the programmer
    do not have to worry about any of this through your source code. PLINQ is really
    a no-brainer when performing a LINQ query because if .NET cannot improve performance
    making the query concurrent, it will just run the query sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the new `async` and `await` keywords and
    how to easily implement asynchronous methods.
  prefs: []
  type: TYPE_NORMAL
