- en: User Registration and Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built the foundation of the app in the last chapter, where we also explored
    the HTTP verbs in detail while creating a controller inside the ASP.NET Core Web
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are gradually moving toward an important aspect of the API, called **authentication**.
    Authentication is definitely a required component because of the ease of accessibility
    of the API. Limiting the requests and putting a restriction on them would prevent
    malicious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Users of your application, or customers, in our case, need a registration form/interface
    where their details can be grabbed by the system. We will see how to register
    users with the API.
  prefs: []
  type: TYPE_NORMAL
- en: After you register and have all the details of the customers, such as *email*
    and *password*, it will be easy for you to identify the requests coming from a
    client. Wait, that is easy, but there are principles we need to follow in order
    to authenticate the user to access our resources. That is where *Basic Authentication*
    and *OAuth Authentication* will come into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why authentication and limiting requests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EF Core for bootstrapping our REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding basic authentication to our REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Oauth 2.0 authentication to our service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the client-based API consumption architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why authentication and limiting requests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I told you that there is a Web API exposed from a particular country's government
    that you can use to get all the details of its citizens, then the first thing
    you would ask me is whether you can extract data from the API or not. That is
    exactly what we will be discussing.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you take the previous example, the data that comes back from that API
    would have the citizens' sensitive data, such as *name*, *address*, *phone number*,
    *country, and social security number*. The government should never allow everyone
    to access this data. Only authenticated sources are allowed, generally. What that
    means is when you call one API, you need to send your identity and ask to it to
    allow you to operate on the data. If the identity is wrong or not in the list
    of allowed sources, it will be rejected by the API. Imagine terrorists trying
    to access the API, you would definitely deny access by detecting their identity.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine another scenario, where a university has an API that sends out results
    of a particular semester of a certain course. Many other websites would show the
    results on their site by calling this university API. A hacker comes in and uses
    a code block to call the API in a loop. If the time interval is too small, then
    don't be surprised if you get a Server Busy/Server Unreachable message. That is
    because, with a huge number of requests in a short span of time, the server becomes
    overloaded and runs out of resources.
  prefs: []
  type: TYPE_NORMAL
- en: That is where imposing limitations on the API not to allow more requests from
    the same source in a particular time interval comes into the picture. For example,
    if any consumer accesses our API, we will not allow the request if the consumer
    has already requested it before in the last 10 seconds or so.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's design the database for our app before exploring other concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Database design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will definitely have a *Customers* table. We will store customer information
    in that table and use the primary key of this table as a reference in other tables,
    such as *Orders* and *Cart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Customers table can be designed as follows. You can find the database script,
    named `FlixOneStore.sql`, with this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13d529d2-2429-4ed7-9d63-2bd5da584ac6.png)'
  prefs: []
  type: TYPE_IMG
- en: CRUD operations will be performed on these tables from the API. Let's start
    by doing some operations on this table from the API. More precisely, we are talking
    about the customer registration and login process.
  prefs: []
  type: TYPE_NORMAL
- en: User registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get the models into the API first so that we can create an object and
    save data in the database. We will use **Entity Framework Core** (**EF Core**)
    version 2.0.2 for this.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up EF with the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use EF Core, the following package is required, which can be downloaded
    and installed from NuGet Package Manager inside Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d8b9441-f7c0-4226-867d-0abc0b97fc64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, we need another package named Microsoft.EntityFrameworkCore.Tools.
    This will help us with creating model classes from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7be0ab79-59d9-415f-8011-7c78d69294ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we arrive at the point where we need model classes according to the database
    tables. The following powershell command can be executed inside the package manager
    console to create the model class for the *Customers* table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have provided the connection string in the command so that it connects to
    our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are two important parts of the command we just explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-OutputDir Models`: This defines the folder in which the model class will
    be placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Tables Customers`: This defines the table that will be extracted as the model
    class. We will be dealing with *Customers* for now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After execution, you will see two files, `Customers.cs` and `FixOneStoreContext.cs`,
    inside the `Models` folder. The `Customers.cs` file will be something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Configuring DbContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `context` class can be found in the same folder that has the `OnConfiguring`
    and `OnModelCreating` methods with a property for *Customers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows the `FlixOneStoreContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice that I have commented the `OnConfiguring` method and added a
    constructor so that we can inject dependencies from startup to initialize the
    context with a connection string? Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, inside the `ConfigureServices` startup, we will add the context to the
    services collection using the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Generating the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to add the controller. To do so, refer to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `Controller` folder, then click on Add, followed by Controller.
    You will end up on a modal where you will see options to create different types
    of controllers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d624fe8b-4518-4322-b5b3-519aa20bad1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select API Controller with actions, using Entity Framework and click on the
    Add button. The following screenshot shows what happens next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dea4c3e2-3769-40b1-8ac8-c9c3224528b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Add. *Voila!* It did all that hard work and created a fully fledged
    controller using EF Core with actions using all major HTTP verbs. The following
    code block is a small snapshot of the controller with the `GET` methods only.
    I have removed other methods to save space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Some points to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how `FlixOneStoreContext` is initialized here by injecting it into the
    constructor. Further more, it will be used for database-related operations inside
    all actions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next thing to focus on is the methods used to return the results from the
    actions. See how `BadRequest()`, `NotFound()`, `Ok()`, and `NoContent()` are used
    to return proper HTTP response codes that can be easily understood by clients.
    We will see what codes they return in a while when we call these actions to perform
    real tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the API from a page to register the customer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify things, I have designed a simple HTML page with controls for a
    customer record, as follows. We will input data and try to call the API in order
    to save the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I have used bootstrap and *jQuery* with my code. You can refer to the whole
    code in the attached files with the book or refer to [https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the important part of the code, where we will call the API to store
    the customer record. Refer to the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `http://localhost:57571/api/Customers` URL and `POST` HTTP method.
    This eventually calls the `Post` method present in the API named `PostCustomers`.
    We will definitely have some uniqueness in the table, and in our case, I am taking
    email as unique for each record. That''s why I need to modify the `action` method
    a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I am returning `BadRequest()` by adding an error message for the model property
    email. We will see how this is shown on the browser shortly!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image captured from the browser shows you a successful *customer*
    creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdfb7a93-b70c-4ab5-9bc7-dcfaea41c97b.png)'
  prefs: []
  type: TYPE_IMG
- en: A successful registration of a *customer* would look something like the preceding
    image, which shows us the success message in the alert as we have that inside
    the `success` method of the ajax call.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform anything you want with the data received from the `action`
    method upon completion, as it returns the whole `customer` object. If you don''t
    believe me, refer to the following screenshot from the source window of the debugger
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f43ff98-4614-4c25-9636-e1bb5afc27d5.png)'
  prefs: []
  type: TYPE_IMG
- en: The response to the POST request with the new Customer created inside the jQuery
    Ajax success method
  prefs: []
  type: TYPE_NORMAL
- en: 'So, who did this? Simple, the following return statement, which is inside the
    `POST` method, does all the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular line does a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sends Status Code: 201 Created as the `POST` action successfully created the
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets a Location header with the actual URL for the resource. If you remember
    RESTful characteristics, after the `POST` action, the server should send the URL
    of the resource. That is what it does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let me show you the network tab of developer tools to prove my point. You can
    also use *Postman* and analyze it. The following screenshot shows you the response
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e5ced39-c692-4874-9748-3678ffcec256.png)'
  prefs: []
  type: TYPE_IMG
- en: The response received by a POST success request with Status Code and Location
    Header
  prefs: []
  type: TYPE_NORMAL
- en: '`Guid` is actually the `Customer ID` as we have defined it in the column type
    in database, and I am assigning the value to it inside the `Customer` model class
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you copy this URL and open it in your browser or Postman, you will
    get the details of the customer, as the following screenshot shows you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0361fdff-75a5-40c2-9b8e-831b0a2b1c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see a `BadRequest()` example with a mail ID that already exists. As
    the `taditdash@gmail.com` customer already exists, sending another request with
    the same email ID should send us an error message as a response. Let''s have a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b705c323-5591-45a6-955c-0faf6bf710b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember, we added a line to check the email ID existence and added a `ModelState`
    error. That is in action now.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity of the demo in this book, I am just saving a plain text password.
    You should not do that in the actual project. Implementing proper encryption for
    a password is a must.
  prefs: []
  type: TYPE_NORMAL
- en: With this, I would end the registration process. However, there is scope to
    implement validation at the client side as well as at the server side. You can
    add attributes to the `Model` class properties to make it solid so that you don't
    get bad data from clients. Send a `BadRequest()` response when `ModelState` validation
    fails. Required email-format and password-comparison attributes can be added to
    the `Model` class.
  prefs: []
  type: TYPE_NORMAL
- en: CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you see the following error when you call the API action, then you need
    to enable **Cross Origin Resource Sharing** (**CORS**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable CORS for all origins, follow the steps shown ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `Microsoft.AspNetCore.Cors` NuGet package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22cabbf2-3499-49f6-a794-536a0950a562.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside `Startup ConfigureServices`, add the following code to implement a policy
    for CORS that would allow all origins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Configure` method, add the following line before `app.UseMvc();`
    (it''s important):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, it should work as expected. If you want to explore CORS more, visit [https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1](https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1).
  prefs: []
  type: TYPE_NORMAL
- en: Adding basic authentication to our REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we registered the *customer*, we can move towards the authentication
    process. Authentication is to verify whether a *customer* is a valid user of our
    site or not. We already have their credentials with us since they registered using
    our registration form. When they try to access any resource from our site using
    those credentials, we will verify first and then allow.
  prefs: []
  type: TYPE_NORMAL
- en: Registration will be allowed for everyone and won't be authenticated. However,
    when a *customer* wants to *read their profile details* or *delete their account,*
    and so on, then we need authentication in place so that the data is returned to
    users who are actual trusted users of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *basic authentication*:'
  prefs: []
  type: TYPE_NORMAL
- en: We will get the *username*, which will be the *email ID* and *password* from
    the client while they request a resource. This will be sent with HTTP headers.
    We will see it when we design the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, that data will be verified from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If found, the operation will be allowed, otherwise a `401 Unauthorized` response
    will be sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 1 – Adding the (authorize) attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's restrict the action method that is returning the *customer* profile details,
    the `GET` method of `CustomersController` named `GetCustomers([FromRoute] Guid
    id)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will verify the following two things when a *customer* is trying to access
    the profile:'
  prefs: []
  type: TYPE_NORMAL
- en: The request is coming from a trusted user of the application. Meaning, the request
    is coming from a *customer* having a valid *email* and *password*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customer can only access their profile. To check this, we will verify the
    *customer's* credentials (present in the request) with the requested *customer's*
    ID on the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get started. Remember that our goal is to achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For now, we will focus our attention on this action method to understand the
    concept. You can see the `Authorize` attribute with an `AuthenticationScheme`
    defined as `Basic` here. That means we have to tell the runtime what the *basic
    authentication* is so that it will execute that first before going into the action
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If the authentication succeeds, the action method will be executed, otherwise
    a 401 Unauthorized response will be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Designing BasicAuthenticationOptions and BasicAuthenticationHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need a class that would derive the `AuthenticationSchemeOptions`
    class present in `Microsoft.AspNetCore.Authentication`, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is left blank for simplicity but can be loaded with different properties.
    We will not go into that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a handler for *basic authentication*, where we will have our
    actual logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have its constructor-like following with an extra `DbContext` param
    as we will validate the *customer* details from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthenticationHandler<T>` is an abstract class having properties and methods
    related to authentication especially. We will be overriding two methods, for now,
    `HandleAuthenticateAsync` and `HandleChallengeAsync`. `HandleAuthenticateAsync`
    will have actual logic to authenticate the customer and `HandleChallengeAsync`
    is used to deal with 401 challenge concerns, meaning whenever you decide that
    *customer* is not valid, codes can be written in this method to deal with that
    situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are assuming that we will receive the email and password in the HTTP header
    called `Authorization` separated by a delimiter colon (`:`). The following is
    the code to extract the data from the header and validate whether it is correct
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code is very easy to understand. I have added the steps over code blocks.
    Basically, we are trying to validate the header and then process it to see whether
    they are correct. If correct, then create the `ClaimsIdentity` object, which can
    be further used in the application. We will do that in the next section. At each
    step, if validation fails, we send `AuthenticateResult.NoResult()` or `AuthenticateResult.Fail()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on attaching this authentication to our action method, using something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – Registering basic authentication at startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looks like everything is set up, however, we have missed one step of registering
    this basic authentication in the startup. Otherwise, how could the `BasicAuthenticationHandler`
    handler be called? Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the API, you can design an HTML page to show the profile of the user
    by getting details from the API using the `Id`. You can use the *jQuery Ajax*
    call to the API and operate on the result received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the header part where we have the `Authorization` header mentioned with
    `email` and `password` separated by a colon (`:`) and passed to the `btoa` method,
    which is responsible for Base64 encryption. After you get the result, you can
    do *n* number of things. The following screenshot shows it on the page using some
    bootstrap designing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c735c15-2fd7-4ca7-b798-4622722d9f87.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, there is an important code block that should be included with the previous
    handler code. That is another `HandleChallengeAsync` method that should be overridden.
    The purpose of this method is to handle the situation when the authentication
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will just send one header with the response, named `WWW-Authenticate`, whose
    value can be set with a `realm`. Have a look at the code first and then I will
    explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If a client tries to access a restricted resource or a resource that requires
    authentication, it's the server's responsibility to inform the client about the
    authentication type and related information. The `WWW-Authenticate` HTTP response
    header is set by the server that defines the authentication method that should
    be used to gain access to the restricted resource requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it''s obvious that the `WWW-Authenticate` header is sent along with a 401
    Unauthorized response. The string contains three things: *Authentication Type*,
    *Realm*, and *Charset*. The realm is the domain or area where the authentication
    will be valid.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the scheme is `Basic`, Realm is `http://localhost:57571`, and Charset
    is `UTF-8`. Therefore, if the client provides the basic authentication params
    as `Username` and `Password`, those will be valid in the `localhost:57571` domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is what it signifies. So, just remove the header assigning a code or comment
    it out to test this. The following is the screenshot from the Network tab of the
    developer tool in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51293f33-d7e5-4bb1-8877-8d78738f0569.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Have a look at the following screenshot of an alert message, which we have
    inside the error method of the Ajax call. This happens when the API action is
    called without any credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/066f2093-32e1-4cb7-a809-90ec7d3b7324.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding OAuth 2.0 authentication to our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth is an open standard used by APIs to control access to the resources by
    clients, such as websites, desktop applications, or even other APIs. However,
    the API implementing OAuth can provide user information without sharing the password
    with third-party apps.
  prefs: []
  type: TYPE_NORMAL
- en: You must have seen websites where they allow logins using different services,
    such as Facebook, Twitter, or Google, saying something such as (for Facebook)
    Login with Facebook. That means Facebook has an OAuth server that would validate
    your app by a certain identity that you have provided to Facebook earlier, and
    give you an access token that would have some validity. Using that token, you
    can read the required user's profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some basic OAuth2.0 terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource:** We have already defined this in previous chapters. Resources
    are the things that we need to protect. That may be any information related to
    our system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server:** This is the server that would protect the resource, mostly
    the API that we have designed to access our eCommerce database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource owner:** The person who would grant us access to a particular resource.
    Mostly the users are the owners, and as you have seen when you click on Login
    with Facebook, it will ask for your login and consent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client:** The app that wants our resource access. In our case, it is the
    browser that is trying to access the resources when *jQuery* codes are executed
    on the HTML pages we designed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access token:** This is actually the pillar of this architecture. The OAuth
    server that we will design should provide a token using the credentials of the
    user for subsequent access to our resources, as we know OAuth standard tells us
    not provide passwords to clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bearer token:** This is a particular type of access token that allows anyone
    to use the token easily, meaning, in order to use the token for resource access,
    a client doesn''t need a cryptographic key or other secret keys. As this is less
    secure than other types of tokens, bearer tokens should only be used over HTTPs
    and should expire in a short amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server:** This is the server providing the access token to
    the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start adding OAuth to our Web API. We are going to use IdentityServer4,
    which is a free, open source OpenID Connect and OAuth 2.0 framework for ASP.NET
    Core. The project can be found here: [https://github.com/IdentityServer](https://github.com/IdentityServer).'
  prefs: []
  type: TYPE_NORMAL
- en: 'IdentityServer ([http://identityserver.io/](http://identityserver.io/)) is
    based on OWIN/Katana, but to our knowledge, it is distributed and available as
    a NuGet package. In order to start on IdentityServer, install the following two
    NuGet Packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c04f874-1ab5-4675-a2d3-4c06a25d577a.png)'
  prefs: []
  type: TYPE_IMG
- en: The *authorization server* in a production scenario is ideally isolated from
    the main web API. But for this book, we will directly put that in the same Web
    API project for simplicity. We are not using the default ASP.NET Core Identity.
    We will be using our own set of tables. For instance, we will use our *customer*
    table details for verification.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Designing the Config class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Config` class holds important details of the authorization server, such
    as *Resources*, *Clients*, and *Users*. These details are used while generating
    the token. Let''s design it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`ApiResource` is used to declare different scopes and claims for the API. For
    a simple case, an API might have one simple resource structure where it would
    give access to all clients. However, in a typical scenario, clients can be restricted
    to access different parts of the API. While declaring the clients, we will use
    these resources in order to configure their scope and access rights. `ReadAccess`
    and `FullAccess` are two different resource types that can be used with clients
    to give read and full access, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the methods that we are designing now will be called on `Startup`.
    Here, `GetApiResources` is actually creating two types of resource with different
    settings. The first one is what we will be dealing with for the moment. We have
    named it `FlixOneStore.ReadAccess`. You can see a list of strings with `Id`, `Name`,
    and so on, these are the details of the customer that will be generated with the
    token and passed to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add details for a client from where we will consume the authorization
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can add a number of clients as per your needs. You can set *client id*,
    *client secret,* and *grant types* according to OAuth standards in this method.
    Notice the secret password is set as `secretpassword`. You can set any string
    here; it can be a `Guid`. Here, `GrantType.ResourceOwnerPassword` defines the
    way we will validate the incoming request to generate tokens.
  prefs: []
  type: TYPE_NORMAL
- en: It says to the *Authorization Server*, "Hey look for `username` and `password`
    inside the request body." There are other types of Grant available. You can explore
    more on the official documentation link.
  prefs: []
  type: TYPE_NORMAL
- en: You might have a question now! What are we going to do with `username` and `password`?
    Of course, we will validate them, but with what? The answer is the `Email` and
    `Password` fields from the `Customers` table. We have not done anything related
    to connecting *Authorization Server* with the *Customers* table. That is what
    we will do next. But before that, let's register these settings at `Startup`.
  prefs: []
  type: TYPE_NORMAL
- en: Just to make sure we are on the same page, we landed at the point where we are
    trying to generate a token from the Authorization Server in order to access our
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Registering Config at startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For registration, the following is what we have to do inside the `ConfigureServices`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are loading all those config settings here, such as *Resources* and *Clients*,
    by calling the methods we designed. `AddDeveloperSigningCredential` adds a temporary
    key at the startup time, used only on the development environment when we don't
    have any certificate to apply for Authorization. You would add proper certificate
    details for actual use.
  prefs: []
  type: TYPE_NORMAL
- en: Mark `ProfileService` here. This is what I was talking about in the previous
    section, which will be used to validate the user credentials against the database.
    We will look at it in a little while. First, let's test our API, assuming that
    the Authorization Server is ready with `ProfileService` set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now coming to the API, we need to add `AuthenticationScheme` at the start of
    the API to declare what Authentication we will be using. For that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`JwtBearerDefaults.AuthenticationScheme` is actually a string constant with
    the **Bearer** value. **Bearer authentication** is also known as **token authentication**.
    That means our clients need to send a token in order to access the API''s resources.
    And to get the token, they need to call our *authorization server*, available
    at `/connect/token`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice we have `Audience` set as `FlixOneStore.ReadAccess`, which we have specified
    for the clients inside config. Simply put, we are setting up the bearer type of
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Adding the [Authorize] attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing is to add the `[Authorize]` attribute to the API controller
    action. Let''s test this with the `GetCustomers(id)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling it from the *Postman* yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2baca5b-b2bc-411e-8929-a8c66cf2101b.png)'
  prefs: []
  type: TYPE_IMG
- en: So, our request is not authorized anymore. We got a reply that we need to send
    a token in order to access the resource. Let's get the token, then.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Getting the token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get the token, we need to call the authorization server sitting
    at `/connect/token`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screen captured from *Postman* where a `POST` request is
    performed on the `http://localhost:57571/connect/token` URL with a body containing
    all the required parameters in order to authenticate the client. These are the
    details that we registered inside the `GetClients()` method in *Step 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38096c2e-0803-4c37-a14f-963cb390af21.png)'
  prefs: []
  type: TYPE_IMG
- en: Oops! It's a bad request. That is because we passed the wrong secret password
    for the client. If you remember, we set it as `secretpassword`, but passed it
    as `secret`. That's why it got rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important things to note here. To get the token:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to send a `POST` request to the `/connect/token` URL. As we have implemented
    the server in the same app, the domain is the same here as the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to have a `Content-Type` header set as `application/x-www-form-urlencoded`
    (which is actually in a different tab on the screenshot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the body of the request, we added all the required parameters of OAuth according
    to standards and they match exactly what we had in the configuration class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we send everything as required correctly, we will receive a token, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2981f005-71a2-4b96-8ef9-247082327d9c.png)'
  prefs: []
  type: TYPE_IMG
- en: We received the bearer token response according to OAuth specifications. They
    are `access_token`, `expires_in`, and `token_type`. The `expires_in` param is
    set to 3,600 by default for the access token, which is in seconds, meaning 1 hour.
    After 1 hour, this token won't work anymore. Therefore, before this token expires,
    let's quickly call our API with it and see whether that works.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – Calling the API with the access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have a look at the following picture, which shows you the call to the API using
    the token we just received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4afb75d0-4098-4983-ba63-2e71e983633c.png)'
  prefs: []
  type: TYPE_IMG
- en: Calling the API endpoint with the token in the authorization header
  prefs: []
  type: TYPE_NORMAL
- en: Voila! That worked. I just copied the token I got and added in the `Bearer [Access
    Token]` format to the authorization header and sent the request. Everything is
    perfect now.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – Adding the ProfileService class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we explored all this, I left out one part that I want to explain now.
    If you see the body of the request while we fetch the access token, it is something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Focus on the `username` and `password` parameters. They are here for a reason.
    While generating the token, these are getting validated and yes, we are validating
    with the database directly. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: '`IdentityServer4` provides two interfaces for this purpose, named `IProfileService`
    and `IResourceOwnerPasswordValidator`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `ResourceOwnerPasswordValidator` class implementing the
    interface. Remember, we set `AllowedGrantTypes = GrantTypes.ResourceOwnerPassword`
    inside the config for the client. That''s why we are doing this to validate the
    user''s credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Mark the bold lines on the preceding code. `ValidateAsync` is the method that
    is giving us the details from the request, and then it is verified with the database
    value. If matched, we create a `GrantValidationResult` object with `subject`,
    `authenticationMethod`, and `claims`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetUserClaims` helps us build all the claims. We will see the actual use of
    these claims in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: We added a number of claims inside config with a list of `ApiResources`, such
    as `Id`, `Name`, `Email`, `GivenName`, and `FamilyName`. That means the server
    can return these details about the *customer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump to `ProfileService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ProfileDataRequestContext` object is populated with all the claims we added
    in `ApiResource`. Refer to the following screenshot of the list of claims requested
    while debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06d0514e-22cd-44d7-9392-f6c45c63eed5.png)'
  prefs: []
  type: TYPE_IMG
- en: That means we need to fill all these details from the *customer* record that
    we did and add that to `IssuedClaims`.
  prefs: []
  type: TYPE_NORMAL
- en: Hold on a second! Why are we doing this? Because our config told us to provide
    this information. But do we need to fill in all that requested information? No.
    Not necessarily. We can issue as many, or as few, claims as we wish to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question now! Where do we find this information? We know that after
    all these authorization setups, we get an encrypted token string. Did you guess?
    Yes, all that information actually resides inside the token itself. Don''t trust
    me, trust the following screenshot. As the token is a JWT token, you can use [https://jwt.io/](https://jwt.io/)
    to decode it and see what is inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1e5db9b-fc37-4fe5-9f32-13cecc86ce8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Client-based API-consumption architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed *RESTful Services, Web APIs*, as well as how to register,
    authenticate, and authorize a user. Moreover, we did focus a little on the consumption
    aspect of the service. Services are designed not only to test on *Postman* but
    actually for consumption by different types of application (desktop, web, mobile,
    smart watches, and IoT apps).
  prefs: []
  type: TYPE_NORMAL
- en: While most modern apps are based on MVC-based architecture, there is a certain
    need to consume web services inside the controllers of those apps. Basically,
    I need to find a way to call the services from my controller without any hassle.
  prefs: []
  type: TYPE_NORMAL
- en: For that to happen, I can't call *Postman* or any other third-party tool. What
    I need is a client or component that can interact with the *RESTful Web API* for
    me. I just need to tell that client that I need the *Customer* details by passing
    the `id` or some identifier and the rest is taken care of by the client, from
    calling the API, passing the value to it, and getting the response. The response
    eventually comes back to the controller, which I can then operate on.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how to build a REST client with simple, quick, and easy steps
    in [Chapter 10](9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml), *Building a Web Client
    (Consuming Web Services)*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registration is a very common, yet very important part of an application. We
    handled the registration of *Customers* through the API. Before that, we learned
    to bootstrap the API controller actions and model classes with EF Core. While
    we were doing all this, we landed on CORS and learned how to handle that, too.
  prefs: []
  type: TYPE_NORMAL
- en: Gradually, we moved to the authentication part, where we discussed *Basic Authentication*
    in detail. It is a mechanism to validate the client by the *Customer* (who are
    users of our API) credentials (`username` and `password`), which are passed in
    with the requests.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bearer* or *Token-based* Authentication was the next topic we explored, and
    we implemented the OAuth paradigm using *IdentityServer4*. In this case, the client
    can''t access a resource directly by `username` and `password` as it was in the
    case of basic. What it needs is a token first, which is generated by one Authorization
    Server upon request by the client with client details such as *client id* and
    *client secret*. The token, then, can be sent to the API for subsequent requests
    for restricted resource access.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take all this knowledge to build other components
    of our API, such as *Cart*, *Shipment*, *Order Items*, and *Checkout*.
  prefs: []
  type: TYPE_NORMAL
