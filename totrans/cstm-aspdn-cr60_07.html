<html><head></head><body>
		<div><h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor111"/>Chapter 7</em>: Using IHostedService and BackgroundService</h1>
			<p>This seventh chapter isn't really about customization; it's more about a feature you can use to create background services to run tasks asynchronously inside your application. I use this feature to regularly fetch data from a remote service in a small ASP.NET Core application. </p>
			<p>We'll examine the following topics:</p>
			<ul>
				<li>Introducing <code>IHostedService</code></li>
				<li>Introducing <code>BackgroundService</code></li>
				<li>Implementing the new Worker Service projects</li>
			</ul>
			<p>The topics of this chapter refer to the Host layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_7.1_B17996.jpg" alt="Figure 7.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor112"/>Technical requirements</h1>
			<p>T<a id="_idTextAnchor113"/>o follow the descriptions in this chapter, you will need to create an ASP.NET Core application. Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new MVC application:</p>
			<pre>dotnet new mvc -n HostedServiceSample -o HostedServiceSample</pre>
			<p>Now open the project in Visual Studio by double-clicking the project file or in VS Code by changing the folder to the project and typing the following command in the already open console:</p>
			<pre>cd HostedServiceSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the GitHub repo for this book: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-65">I<a id="_idTextAnchor114"/><a id="_idTextAnchor115"/>ntroducing IHostedService</h1>
			<p>Hosted services have been a thing since ASP.NET Core 2.0 and can be used to run tasks asynchronously in <a id="_idIndexMarker092"/>the background of your application. They can be used to fetch data periodically, do some calculations in the background, or do some cleanup. You can also use them to send preconfigured emails – or whatever you need to do in the background.</p>
			<p>Hosted services are basically simple classes that implement the <code>IHostedService</code> interface. You call them with the following code:</p>
			<pre>public class SampleHostedService : IHostedService
{
    public Task StartAsync(CancellationToken 
      cancellationToken)
    {
    }
    public Task StopAsync(CancellationToken 
     cancellationToken)
    {
    }
}</pre>
			<p><code>IHostedService</code> needs to implement a <code>StartAsync()</code> method and a <code>StopAsync()</code> method. The <code>StartAsync()</code> method is the place where you implement the logic to execute. This method gets executed once, immediately after the application starts. The <code>StopAsync()</code> method, on the other hand, gets executed just before the application <a id="_idIndexMarker093"/>stops. This also means that to start a scheduled service, you will need to implement it on your own. You will need to implement a loop that executes the code regularly.</p>
			<p>To execute a <code>IHostedService</code>, you will need to register it in the ASP.NET Core dependency injection container as a singleton instance:</p>
			<pre>builder.Services.AddSingleton&lt;IHostedService, SampleHostedService&gt;();</pre>
			<p>The next sample shows you how hosted services work. It writes a log message to the console on start, on stop, and every 2 seconds:</p>
			<ol>
				<li>First, write the class skeleton that retrieves <code>ILogger</code> via <code>DependencyInjection</code>:<pre>namespace HostedServiceSample;
public class SampleHostedService : IHostedService
{
    private readonly ILogger&lt;SampleHostedService&gt; 
      logger;
    // inject a logger
    public 
      SampleHostedService(ILogger&lt;SampleHostedService&gt; 
        logger)
    {
        this.logger = logger;
    }
    public Task StartAsync(CancellationToken 
      cancellationToken)
    {
    }
    public Task StopAsync(CancellationToken 
      cancellationToken)
    {
    }
}</pre></li>
				<li>The next step is to <a id="_idIndexMarker094"/>implement the <code>StopAsync</code> method. This method is used to clean up in case you need to close connections, streams, and so on:<pre>public Task StopAsync(CancellationToken 
  cancellationToken)
{
    logger.LogInformation("Hosted service stopping");
    return Task.CompletedTask;
}</pre></li>
				<li>The actual <a id="_idIndexMarker095"/>work will be done in the <code>StartAsync</code> method:<pre>public Task StartAsync(CancellationToken 
  cancellationToken)
{
    logger.LogInformation("Hosted service starting");
    return Task.Factory.StartNew(async () =&gt;
    {
        // loop until a cancelation is requested
        while 
         (!cancellationToken.IsCancellationRequested)
        {
            logger.LogInformation($"Hosted service 
              executing - {DateTime.Now}");
            try
            {
                // wait for 2 seconds
                await 
                 Task.Delay(TimeSpan.FromSeconds(2), 
                   cancellationToken);
            }
            catch (OperationCanceledException) { }
        }
    }, cancellationToken);
}</pre></li>
				<li>To test this, start the application by calling the following command in the console:<pre><strong class="bold">dotnet run</strong></pre><p>Or press <em class="italic">F5</em> in Visual <a id="_idIndexMarker096"/>Studio or VS Code. This results in the following console output:</p></li>
			</ol>
			<div><div><img src="img/Figure_7.2_B17996.jpg" alt="Figure 7.2 – A screenshot of the dotnet run output"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – A screenshot of the dotnet run output</p>
			<p>As you can see, the log output is written to the console every 2 seconds. </p>
			<p>In the next section, we will look at <code>BackgroundServic<a id="_idTextAnchor116"/><a id="_idTextAnchor117"/>e</code>.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor118"/>Introducing BackgroundService</h1>
			<p>The <code>BackgroundService</code> class was introduced in ASP.NET Core 3.0 and is basically an abstract class that <a id="_idIndexMarker097"/>implements the <code>IHostedService</code> interface. It also provides an abstract method, called <code>ExecuteAsync()</code>, which returns a <code>Task</code>.</p>
			<p>If you want to reuse the hosted service from the last section, the code will need to be rewritten. Follow these steps to learn how:</p>
			<ol>
				<li value="1">First, write the class skeleton that retrieves <code>ILogger</code> via <code>DependencyInjection</code>:<pre>namespace HostedServiceSample;
public class SampleBackgroundService : 
  BackgroundService
{
    private readonly ILogger&lt;SampleHostedService&gt; 
      logger;
    // inject a logger
    public SampleBackgroundService(
        ILogger&lt;SampleHostedService&gt; logger)
    {
        this.logger = logger;
    }
}</pre></li>
				<li>The next step would be to override the <code>StopAsync</code> method:<pre>public override async Task StopAsync(CancellationToken 
  cancellationToken)
{
    logger.LogInformation("Background service 
      stopping");
    await Task.CompletedTask;
}</pre></li>
				<li>In the final step, we will <a id="_idIndexMarker098"/>override the <code>ExecuteAsync</code> method that does all the work:<pre>protected override async Task 
  ExecuteAsync(CancellationToken cancellationToken)
{
    logger.LogInformation("Background service 
      starting");
    await Task.Factory.StartNew(async () =&gt;
    {
        while 
          (!cancellationToken.IsCancellationRequested)
        {
            logger.LogInformation($"Background service 
              executing - {DateTime.Now}");
            try
            {
                await 
                  Task.Delay(TimeSpan.FromSeconds(2), 
                    cancellationToken);
            }
            catch (OperationCanceledException) {}
        }
    }, cancellationToken);
}</pre><p>Even the registration is new.</p></li>
			</ol>
			<p>Additionally, in ASP.NET Core 3.0 and later, the <code>ServiceCollection</code> has a new extension method <a id="_idIndexMarker099"/>to register hosted services or a background worker:</p>
			<pre>builder.Services.AddHostedService&lt;SampleBackgroundService&gt;();</pre>
			<p>To test this, start the application by calling the following command in the console:</p>
			<pre><strong class="bold">dotnet run</strong></pre>
			<p>Or press <em class="italic">F5</em> in Visual Studio or VS Code. It should show almost the same output as the <code>SampleHostedService</code> you created in the previous section.</p>
			<p>Next, let's take a look at Worker Service proj<a id="_idTextAnchor119"/><a id="_idTextAnchor120"/>ects.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor121"/>Implementing the new Worker Service projects</h1>
			<p>The <strong class="bold">worker services</strong> and the generic hosting in ASP.NET Core 3.0 and later make it pretty easy to create <a id="_idIndexMarker100"/>simple service-like applications that can do some stuff without the full-blown ASP.NET stack – and without a web server.</p>
			<p>You can create this project with the following command:</p>
			<pre>dotnet new worker -n BackgroundServiceSample -o BackgroundServiceSample</pre>
			<p>Basically, this creates a console application with a <code>Program.cs</code> and a <code>Worker.cs</code> file in it. The <code>Worker.cs</code> file contains the <code>Worker</code> class that inherits from the <code>BackgroundService</code> class. In ASP.NET 5.0 and earlier, the <code>Program.cs</code> file looks pretty familiar <a id="_idIndexMarker101"/>to what we saw in the previous versions of ASP.NET Core but without a <code>WebHostBuilder</code>:</p>
			<pre>public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }
    public static IHostBuilder CreateHostBuilder(string[] 
      args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =&gt;
            {
                services.AddHostedService&lt;Worker&gt;();
            });
}</pre>
			<p>In ASP.NET Core 6.0, <code>Program.cs</code> is pretty simplified in the same way as the minimal APIs. It looks like this:</p>
			<pre>using BackgroundServiceSample;
IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =&gt;
    {
        services.AddHostedService&lt;Worker&gt;();
    })
    .Build();
await host.RunAsync();</pre>
			<p>This creates an <code>IHost</code> with dependency injection enabled. This means we can use dependency <a id="_idIndexMarker102"/>injection in any kind of .NET Core application, and not only in ASP.NET Core applications.</p>
			<p>Then the worker is added to the service collection.</p>
			<p>Where is this useful? You can run this app as a Windows service or as a background application in a Docker container, which doesn't need an HTTP e<a id="_idTextAnchor122"/>ndpoint.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor123"/>Summary</h1>
			<p>You can now start to do some more complex things with an <code>IHostedService</code> and the <code>BackgroundService</code>. Be careful with background services because they all run in the same application; if you use too much CPU or memory, this could slow down your application.</p>
			<p>For bigger applications, I would suggest running such tasks in a separate application that is specialized for executing background tasks: a separate Docker container, a <code>BackgroundWorker</code> on Azure, Azure Functions, or something like that. However, it should be separate from the main application in that case.</p>
			<p>In the next chapter, we will learn about middleware, and how you can use them to implement special logic on the request pipeline or serve specific logic on different paths.</p>
		</div>
	</body></html>