<html><head></head><body>
<div id="_idContainer052">
<h1 class="chapter-number" id="_idParaDest-197"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-198"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.2.1">Creating Better Web APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Web APIs are the essence of the internet. </span><span class="koboSpan" id="kobo.3.2">They give developers the openness of the web and the ability to access any data on the internet. </span><span class="koboSpan" id="kobo.3.3">However, there are some best practices specific to APIs. </span><span class="koboSpan" id="kobo.3.4">The ability to select the right HTTP verb, how to document APIs, and testing APIs are just some of the topics </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">we’ll cover.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">With that said, the techniques covered in this chapter are vast and dense. </span><span class="koboSpan" id="kobo.5.2">We’ll try to pack as much information as possible to help build quality APIs. </span><span class="koboSpan" id="kobo.5.3">We’ll also provide relevant links for </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">further research.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">APIs quickly</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Designing APIs</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Testing </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Web APIs</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Standardized Web </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">API techniques</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">In this chapter, we’ll learn how to design, create, test, and document APIs and how to perform full end-to-end tests of our APIs through a </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">CI/CD pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">We’ll finish this chapter by reviewing some of the more common techniques for writing APIs, such as using the correct HTTP verbs and status codes, how to avoid large dependent resources, how to implement pagination into APIs, versioning an API, using DTOs instead of entities, and the best way to call other APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">from .NET.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">In .NET 8, Web APIs take a front seat. </span><span class="koboSpan" id="kobo.21.2">Visual Studio has added new features to make Web APIs easier to build and test. </span><span class="koboSpan" id="kobo.21.3">For this chapter, we recommend using Visual Studio 2022, but the only requirement to view the GitHub repository is a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">text editor.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">The code for </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 09</span></em></span><span class="koboSpan" id="kobo.25.1"> is located in Packt Publishing’s GitHub repository, found </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.29.1">Creating APIs quickly</span></h1>
<p><span class="koboSpan" id="kobo.30.1">With .NET 8, APIs</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.31.1"> are integrated into the framework, making it easier to create, test, and document. </span><span class="koboSpan" id="kobo.31.2">In this section, we’ll learn a quick and easy way to create a minimal API using Visual Studio 2022 and walk through the code it generates. </span><span class="koboSpan" id="kobo.31.3">We’ll also learn why minimal APIs are the best approach to building </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">REST-based services.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.33.1">Using Visual Studio</span></h2>
<p><span class="koboSpan" id="kobo.34.1">One of the </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.35.1">features of .NET 8 is the ability to create minimal </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.36.1">REST APIs extremely fast. </span><span class="koboSpan" id="kobo.36.2">One way is to use the dotnet command-line tool and the other way is to use Visual Studio. </span><span class="koboSpan" id="kobo.36.3">To do so, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.38.1">Open Visual Studio 2022 and create an </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">ASP.NET Core Web </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.40.1">API</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.41.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">After selecting the directory for the project, </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.44.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Under the project options, make the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">following changes:</span></span><ul><li><span class="koboSpan" id="kobo.48.1">Uncheck the </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">Use Controllers</span></strong><span class="koboSpan" id="kobo.50.1"> option to use </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">minimal APIs</span></span></li><li><span class="koboSpan" id="kobo.52.1">Check </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Enable OpenAPI support</span></strong><span class="koboSpan" id="kobo.54.1"> to include support for API documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">using Swagger:</span></span></li></ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.56.1"><img alt="Figure 9.1 – Options for a web minimal API project" src="image/B19493_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.57.1">Figure 9.1 – Options for a web minimal API project</span></p>
<ol>
<li value="4"><span class="No-Break"><span class="koboSpan" id="kobo.58.1">Click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.59.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.61.1">That’s it – we have a simple API! </span><span class="koboSpan" id="kobo.61.2">It may not be much of one, but it’s still a complete API </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.62.1">with Swagger documentation. </span><span class="koboSpan" id="kobo.62.2">Swagger</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.63.1"> is a tool for creating documentation for APIs and implementing the OpenAPI specification, whereas Swashbuckle is a NuGet package that uses Swagger for implementing Microsoft APIs. </span><span class="koboSpan" id="kobo.63.2">If we look at the project, there’s a single file </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.67.1">Opening </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Program.cs</span></strong><span class="koboSpan" id="kobo.69.1"> will show the entire application. </span><span class="koboSpan" id="kobo.69.2">This is one of the strong points of .NET – the ability to create a scaffolded REST API </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">relatively quickly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.71.1">
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
</span><span class="koboSpan" id="kobo.71.2">// Learn more about configuring Swagger/OpenAPI at
   https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
// Configure the HTTP request pipeline.
</span><span class="koboSpan" id="kobo.71.3">if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
var summaries = new[]
{
    "Freezing", "Bracing", "Chilly", "Cool", "Mild",
    "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
};
app.MapGet("/weatherforecast", () =&gt;
{
    var forecast = Enumerable.Range(1, 5).Select(index
    =&gt;
        new WeatherForecast
        (
            DateOnly.FromDateTime(DateTime.Now.AddDays
                (index)),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(
                summaries.Length)]
        ))
        .ToArray();
    return forecast;
})
.WithName("GetWeatherForecast")
.WithOpenApi();
app.Run();
internal record WeatherForecast(DateOnly Date,
int TemperatureC, string? </span><span class="koboSpan" id="kobo.71.4">Summary)
{
    public int TemperatureF =&gt; 32 +
        (int)(TemperatureC / 0.5556);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.72.1">In the </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.73.1">preceding </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.74.1">code, we created our “application” through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">.CreateBuilder()</span></strong><span class="koboSpan" id="kobo.76.1"> method. </span><span class="koboSpan" id="kobo.76.2">We also added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">EndpointsAPIExplorer</span></strong><span class="koboSpan" id="kobo.78.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">SwaggerGen</span></strong><span class="koboSpan" id="kobo.80.1"> services. </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">EndpointsAPIExplorer</span></strong><span class="koboSpan" id="kobo.82.1"> enables the developer to view all endpoints in Visual Studio, which we’ll cover later. </span><span class="koboSpan" id="kobo.82.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">SwaggerGen</span></strong><span class="koboSpan" id="kobo.84.1"> service, on the other hand, creates the documentation for the API when accessed through the browser. </span><span class="koboSpan" id="kobo.84.2">The next line creates our application instance using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">Build()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1"> method.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.88.1">Once we have our app instance and we are in development mode, we can add Swagger and the Swagger UI. </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">.UseHttpsRedirection()</span></strong><span class="koboSpan" id="kobo.90.1"> is meant to redirect to HTTPS when the protocol of a web page is HTTP to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">API secure.</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">The next line creates our GET </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">weatherforecast</span></strong><span class="koboSpan" id="kobo.94.1"> route using </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">.MapGet()</span></strong><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">We added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">.WithName()</span></strong><span class="koboSpan" id="kobo.98.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">.WithOpenApi()</span></strong><span class="koboSpan" id="kobo.100.1"> methods to identify the primary method to call and let .NET know it uses the OpenAPI standard, respectively. </span><span class="koboSpan" id="kobo.100.2">Finally, we </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">app.Run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">If we run the </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.105.1">application, we will see the documented </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.106.1">API on how to use our API and what’s available. </span><span class="koboSpan" id="kobo.106.2">Running the application produces the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">following output:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.108.1"><img alt="Figure 9.2 – Screenshot of our documented Web API" src="image/B19493_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.109.1">Figure 9.2 – Screenshot of our documented Web API</span></p>
<p><span class="koboSpan" id="kobo.110.1">If we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">/weatherforecast</span></strong><span class="koboSpan" id="kobo.112.1"> API, we see that we receive JSON back with a 200 </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">HTTP status.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 9.3 – Results of our /weatherforecast API" src="image/B19493_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 9.3 – Results of our /weatherforecast API</span></p>
<p><span class="koboSpan" id="kobo.116.1">Think of this small </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.117.1">API as middleware with API controllers </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.118.1">combined into one compact </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">file (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">).</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.122.1">Why minimal APIs?</span></h2>
<p><span class="koboSpan" id="kobo.123.1">I consider</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.124.1"> minimal APIs to be a feature in .NET 8, even though it’s a </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.125.1">language concept. </span><span class="koboSpan" id="kobo.125.2">If the application is extremely large, adding minimal APIs should be an appealing feature in </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">four ways:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.127.1">Self-contained</span></strong><span class="koboSpan" id="kobo.128.1">: Simple API</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.129.1"> functionality inside one file is easy to follow for </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">other developers</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Performance</span></strong><span class="koboSpan" id="kobo.132.1">: Since we aren’t using controllers, the MVC overhead isn’t necessary when using </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">these APIs</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.134.1">Cross-platform</span></strong><span class="koboSpan" id="kobo.135.1">: With .NET, APIs can now be deployed on </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">any platform</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Self-documenting</span></strong><span class="koboSpan" id="kobo.138.1">: While we can add Swashbuckle to other APIs, it also builds the documentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">minimal APIs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.140.1">Moving forward, we’ll take these minimal APIs and start looking at Visual Studio’s </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">testing capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">In this section, we created and reviewed a minimal API project in Visual Studio and why minimal APIs are important to </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">our projects.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">In the next section, we’ll look at designing APIs to help eliminate long resource (URL) names and standardized </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">API naming.</span></span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.146.1">Designing APIs</span></h1>
<p><span class="koboSpan" id="kobo.147.1">In this section, we’ll </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.148.1">cover the best approach for delivering intuitive and clear APIs to our users. </span><span class="koboSpan" id="kobo.148.2">The design of an API should be well thought-out and make sense when a user wishes to make </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">a request.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">To create a truly REST-based API, we must use a different mindset. </span><span class="koboSpan" id="kobo.150.2">We have to think of ourselves as a user and not a developer. </span><span class="koboSpan" id="kobo.150.3">When writing APIs, the users of the API </span><em class="italic"><span class="koboSpan" id="kobo.151.1">are</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.152.1">fellow developers.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.153.1">Disconnecting from existing schemas</span></h2>
<p><span class="koboSpan" id="kobo.154.1">When designing </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.155.1">APIs, we need a user’s perspective as opposed to basing an API on a class hierarchy or database schema. </span><span class="koboSpan" id="kobo.155.2">While developers may consider creating an API based on a class hierarchy or database schema as a shortcut, it could create more complexity as to which resource to use when retrieving data. </span><span class="koboSpan" id="kobo.155.3">One example is using an Order resource to find a contact. </span><span class="koboSpan" id="kobo.155.4">While an Order entity in Entity Framework Core could contain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Company</span></strong><span class="koboSpan" id="kobo.157.1"> property and we need the contact of the company, we wouldn’t write </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">https://www.myfakesite.com/Order/15/Company/Contact</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">Basing a URL structure on an existing hierarchy or schema should </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">be avoided.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">It’s crucial to disregard existing schemas when designing a sensible API. </span><span class="koboSpan" id="kobo.161.2">Look at the API with new eyes to get the best design. </span><span class="koboSpan" id="kobo.161.3">The most popular APIs are the cleanest and most intuitive as they use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">collection/item/collection</span></strong><span class="koboSpan" id="kobo.163.1"> syntax. </span><span class="koboSpan" id="kobo.163.2">A good example of this would </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">/orders/15/companys</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.167.1">Identifying the resources</span></h2>
<p><span class="koboSpan" id="kobo.168.1">In a system, look</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.169.1"> at how the user interacts with the website and extract the nouns from specific scenarios. </span><span class="koboSpan" id="kobo.169.2">These will become the resources for </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">For example, a user can perform the following actions in a shopping </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">cart system:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.173.1">View a list </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">of products</span></span></li>
<li><span class="koboSpan" id="kobo.175.1">View </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">a product</span></span></li>
<li><span class="koboSpan" id="kobo.177.1">Add a product to </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the cart</span></span></li>
<li><span class="koboSpan" id="kobo.179.1">Remove a product from </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">the cart</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.181.1">Check out</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.182.1">From these scenarios, we can extract the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">following resources:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.184.1">Products</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.185.1">Product</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.186.1">Cart</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.187.1">We’re starting </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.188.1">to identify and logically partition our APIs based on resources used throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">From here, we can apply an HTTP verb to each resource based on </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">each scenario.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.192.1">Relating HTTP verbs to resources</span></h2>
<p><span class="koboSpan" id="kobo.193.1">Once we have</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.194.1"> the primary resources, we can apply </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.195.1">an HTTP verb to each resource based on the specific scenario we defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">previous section.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">When creating an API, it may be tempting to use the noun/verb syntax – for example, </span><a href="https://www.myurl.com/products/get"><span class="koboSpan" id="kobo.198.1">https://www.myurl.com/products/get</span></a><span class="koboSpan" id="kobo.199.1"> or </span><a href="https://www.myurl.com/getproducts"><span class="koboSpan" id="kobo.200.1">https://www.myurl.com/getproducts</span></a><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">This approach is counterproductive since web standards already exist for this </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">exact purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">While this does work, it violates some of the REST principles (which we’ll get into when we looked at standardized web API techniques in the following sections). </span><span class="koboSpan" id="kobo.203.2">For now, let’s take it step by step and create a simple shopping </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">cart API.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Each HTTP verb has a default operation based on </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">its context:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">GET</span></strong><span class="koboSpan" id="kobo.208.1">: Returns </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">a resource</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">POST</span></strong><span class="koboSpan" id="kobo.211.1">: Creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">new resource</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">PUT</span></strong><span class="koboSpan" id="kobo.214.1">: Replaces an entire resource based on </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">an identifier</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">PATCH</span></strong><span class="koboSpan" id="kobo.217.1">: Updates specific items in a resource based on </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">an identifier</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">DELETE</span></strong><span class="koboSpan" id="kobo.220.1">: Deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">a resource</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.222.1">For example, our scenarios in the previous section can begin to take shape based on the resources and </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">their verbs:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">GET /api/products</span></strong><span class="koboSpan" id="kobo.225.1">: View a list </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">of products</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">GET /api/product/{id}</span></strong><span class="koboSpan" id="kobo.228.1">: View </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">a product</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">POST /api/cart/{cartId}</span></strong><span class="koboSpan" id="kobo.231.1">: Add a product to the cart with </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">POST</span></strong><span class="koboSpan" id="kobo.233.1"> data (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">new { ProductId = {productId}, Qty = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">1 }</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">PATCH /api/cart/{cartId}</span></strong><span class="koboSpan" id="kobo.238.1">: Remove a product from the cart with </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">POST</span></strong><span class="koboSpan" id="kobo.240.1"> data (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">new { ProductId = {</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">productId} }</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">GET /api/cart/{cartId}</span></strong><span class="koboSpan" id="kobo.245.1">: Retrieve a cart with all the products in </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the cart</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">POST /api/cart/{cartId}/checkout</span></strong><span class="koboSpan" id="kobo.248.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">Check out</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.250.1">Once we have </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.251.1">matched the resources to</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.252.1"> the scenarios that have been defined, we can move forward with returning status codes to </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">the caller.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.254.1">Returning HTTP status codes</span></h2>
<p><span class="koboSpan" id="kobo.255.1">With the resources </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.256.1">defined, we need to know whether </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.257.1">the request was successful or not. </span><span class="koboSpan" id="kobo.257.2">This is where we return HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">status codes.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">These status codes are broken into the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">following categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.261.1">1xx</span></strong><span class="koboSpan" id="kobo.262.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">Information codes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.264.1">2xx</span></strong><span class="koboSpan" id="kobo.265.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">Success codes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.267.1">3xx</span></strong><span class="koboSpan" id="kobo.268.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">Redirection codes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.270.1">4xx</span></strong><span class="koboSpan" id="kobo.271.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">Client-side codes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.273.1">5xx</span></strong><span class="koboSpan" id="kobo.274.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">Server errors</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.276.1">Similar to unit tests, we look at a “happy” path and a broken path. </span><span class="koboSpan" id="kobo.276.2">But with APIs, we need to add an unrecoverable path in case an unrecoverable </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">error occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Let’s look at two of the URLs and what status codes they </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">should return.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">GET /api/products</span></strong><span class="koboSpan" id="kobo.281.1"> will return the following </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">status codes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.283.1">200 Success</span></strong><span class="koboSpan" id="kobo.284.1">: Products were </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">successfully returned</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.286.1">500 Internal Server Error</span></strong><span class="koboSpan" id="kobo.287.1">: Optional if something caused </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">a problem</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.289.1">If the API was successful, it will return a list of the products with a 200 status code. </span><span class="koboSpan" id="kobo.289.2">If there are issues, it will return a 500 status code. </span><span class="koboSpan" id="kobo.289.3">The API could also return additional status codes. </span><span class="koboSpan" id="kobo.289.4">For example, if an API call is made for specific users, the API could return a 401, which is an Unauthorized </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">status code.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">POST /api/cart/{cartId}</span></strong><span class="koboSpan" id="kobo.292.1"> with a post body of (</span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">new { ProductId = {productId}, Qty = 1 }</span></strong><span class="koboSpan" id="kobo.294.1">) will return the following </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">status codes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">201 Created</span></strong><span class="koboSpan" id="kobo.297.1">: The item was created and added to </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the cart</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.299.1">202 Accepted</span></strong><span class="koboSpan" id="kobo.300.1">: The item was added to </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">the cart</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.302.1">404 Not Found</span></strong><span class="koboSpan" id="kobo.303.1">: The cart or product </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">wasn’t found</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">500 Internal Server Error</span></strong><span class="koboSpan" id="kobo.306.1">: An unrecoverable </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">error occurred</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.308.1">With this API, we can return either a 201 Created or a 202 Accepted status code. </span><span class="koboSpan" id="kobo.308.2">If we couldn’t find the</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.309.1"> cart or product to add to the cart, return</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.310.1"> a 404 status code. </span><span class="koboSpan" id="kobo.310.2">Otherwise, return a 500 </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">status code.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">While these two examples are not set in stone, they should provide a template for the team to discuss what business rules dictate the status codes that are returned to the user. </span><span class="koboSpan" id="kobo.312.2">Whatever status codes are returned, they should provide enough context as to the request made through </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Some APIs seen in the wild use an all-or-nothing approach; they either return a 200 or a 500. </span><span class="koboSpan" id="kobo.314.2">It depends on how much information we want to send back to the client. </span><span class="koboSpan" id="kobo.314.3">These types of APIs feel like they’re missing more functionality, such as Unauthorized (401) or Not Found (404) status codes. </span><span class="koboSpan" id="kobo.314.4">It’s a best practice to include as much information as we can to the caller of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the API.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.316.1">HTTP status codes</span></p>
<p class="callout"><span class="koboSpan" id="kobo.317.1">HTTP status codes are standard in web </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.318.1">development and are presented through the RFC </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">Request for Comments</span></strong><span class="koboSpan" id="kobo.320.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">RFC</span></strong><span class="koboSpan" id="kobo.322.1">) 9110 proposal located at </span><a href="https://www.rfc-editor.org/rfc/rfc9110#status.codes"><span class="koboSpan" id="kobo.323.1">https://www.rfc-editor.org/rfc/rfc9110#status.codes</span></a><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">Luckily, we don’t need to memorize them all since .NET provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">HttpStatusCodeEnum</span></strong><span class="koboSpan" id="kobo.326.1"> class with every status code at </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode"><span class="koboSpan" id="kobo.327.1">https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode</span></a><span class="koboSpan" id="kobo.328.1">, along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">IActionResults</span></strong><span class="koboSpan" id="kobo.330.1"> such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Ok(object)</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Specific status codes can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode"><span class="No-Break"><span class="koboSpan" id="kobo.334.1">https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">In this section, we learned how to design APIs and broke down each step – that is, disconnecting from the technology, identifying the resources, knowing the right verbs to apply to</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.337.1"> resources, and providing the correct response</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.338.1"> codes to </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">our API.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">In the next section, we will look at two ways to test our APIs: one in Visual Studio with the new Endpoints Explorer and the other by creating a complete </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">integration test.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.342.1">Testing Web APIs</span></h1>
<p><span class="koboSpan" id="kobo.343.1">Once we have</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.344.1"> our APIs designed and created, we need a way to test them in our IDE and our integration tests. </span><span class="koboSpan" id="kobo.344.2">Luckily, Visual Studio has added the new </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">Endpoints Explorer.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">In this section, we’ll learn two ways to test our APIs. </span><span class="koboSpan" id="kobo.346.2">One way is through our development environment using Visual Studio. </span><span class="koboSpan" id="kobo.346.3">The second way we’ll test our API is through integration tests. </span><span class="koboSpan" id="kobo.346.4">If we have a CI/CD pipeline (which we should from </span><a href="B19493_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.347.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.348.1">), these will automatically run to confirm our APIs work </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">as expected.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.350.1">Visual Studio Endpoints Explorer</span></h2>
<p><span class="koboSpan" id="kobo.351.1">Historically, developers</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.352.1"> using Visual Studio had to </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.353.1">run a separate tool to test their APIs, but with the latest version of .NET 8, the Visual Studio team added a new panel called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.354.1">Endpoints Explorer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.356.1"><img alt="Figure 9.4 – Endpoints Explorer" src="image/B19493_09_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.357.1">Figure 9.4 – Endpoints Explorer</span></p>
<p><span class="koboSpan" id="kobo.358.1">If we have</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.359.1"> a</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.360.1"> collection of APIs defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">Program.cs</span></strong><span class="koboSpan" id="kobo.362.1"> file, our collection will appear </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.364.1"><img alt="Figure 9.5 – Collection of APIs in Endpoints Explorer" src="image/B19493_09_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.365.1">Figure 9.5 – Collection of APIs in Endpoints Explorer</span></p>
<p><span class="koboSpan" id="kobo.366.1">Right-clicking on an API will generate a request in a new HTTP Editor. </span><span class="koboSpan" id="kobo.366.2">The HTTP Editor allows</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.367.1"> custom-defined variables for the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">APIs</span></span><span class="No-Break"><a id="_idIndexMarker516"/></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1"> listed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.370.1"><img alt="Figure 9.6 – Sample API collection in the HTTP Editor" src="image/B19493_09_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.371.1">Figure 9.6 – Sample API collection in the HTTP Editor</span></p>
<p><span class="koboSpan" id="kobo.372.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.373.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.374.1">.6</span></em><span class="koboSpan" id="kobo.375.1">, the HTTP Editor uses the following commands to issue </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">HTTP requests:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">@</span></strong><span class="koboSpan" id="kobo.378.1">: Creates a variable for the file (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">@variable</span></strong><span class="koboSpan" id="kobo.380.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">//</span></strong><span class="koboSpan" id="kobo.384.1">: This </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">specifies comments</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">###</span></strong><span class="koboSpan" id="kobo.387.1">: This specifies the end of an </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">HTTP request</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">&lt;HTTP Verb&gt;</span></strong><span class="koboSpan" id="kobo.390.1">: Creates a REST-based request, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">DELETE</span></strong><span class="koboSpan" id="kobo.392.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">GET</span></strong><span class="koboSpan" id="kobo.394.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">HEAD</span></strong><span class="koboSpan" id="kobo.396.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">OPTIONS</span></strong><span class="koboSpan" id="kobo.398.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">PATCH</span></strong><span class="koboSpan" id="kobo.400.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">POST</span></strong><span class="koboSpan" id="kobo.402.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">PUT</span></strong><span class="koboSpan" id="kobo.404.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">TRACE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1"> requests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">&lt;Headers&gt;</span></strong><span class="koboSpan" id="kobo.408.1">: Adds headers directly after defining the URL so that they’re included in </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the request</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.410.1">Once we have defined the APIs, there are green arrows in the left gutter. </span><span class="koboSpan" id="kobo.410.2">Run the application to test the API locally. </span><span class="koboSpan" id="kobo.410.3">Pressing the arrow in the far left gutter </span><em class="italic"><span class="koboSpan" id="kobo.411.1">while the API is running</span></em><span class="koboSpan" id="kobo.412.1"> will </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.413.1">produce </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.414.1">results in the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">right-hand pane:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.416.1"><img alt="Figure 9.7 – Results of the /attractions request" src="image/B19493_09_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.417.1">Figure 9.7 – Results of the /attractions request</span></p>
<p><span class="koboSpan" id="kobo.418.1">In this </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.419.1">example, we tested the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">/attractions</span></strong><span class="koboSpan" id="kobo.421.1"> request, received</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.422.1"> the data, and displayed it on </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">the right.</span></span></p>
<h3><span class="koboSpan" id="kobo.424.1">Why is this important?</span></h3>
<p><span class="koboSpan" id="kobo.425.1">By using this</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.426.1"> new Visual Studio feature, we gain the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">following advantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.428.1">Centralized APIs</span></strong><span class="koboSpan" id="kobo.429.1">: We have a</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.430.1"> catalog of all of our APIs in </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">one place</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.432.1">Self-documented</span></strong><span class="koboSpan" id="kobo.433.1">: Developers new to the project can find this </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">.http</span></strong><span class="koboSpan" id="kobo.435.1"> file, execute sample requests, and understand what each API does in </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">the system</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.437.1">IDE-integrated</span></strong><span class="koboSpan" id="kobo.438.1">: Additional tools aren’t necessary for testing </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">our APIs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.440.1">This new feature is extremely helpful to developers looking to test existing APIs locally and also complements new minimal APIs introduced into </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">the system.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.442.1">Additional Endpoints Explorer material</span></p>
<p class="callout"><span class="koboSpan" id="kobo.443.1">For additional material on Endpoints Explorer, Sayed Ibrahim Hashimi has provided a great write-up about everything it can do </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">at </span></span><a href="https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer"><span class="No-Break"><span class="koboSpan" id="kobo.445.1">https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.446.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">In this section, we learned about Endpoints Explorer, how we can use it to help test APIs locally, and why it’s</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.448.1"> important. </span><span class="koboSpan" id="kobo.448.2">In the next section, we’ll take our APIs and learn how to use integration tests to produce </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">quick results.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.450.1">Integration testing APIs</span></h2>
<p><span class="koboSpan" id="kobo.451.1">In the previous</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.452.1"> section, we learned about how to use Endpoints Explorer to test our APIs. </span><span class="koboSpan" id="kobo.452.2">However, we shouldn’t have to install Visual Studio on a server to test </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">our APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">In this section, we will look at applying an integration server for our APIs to achieve a complete </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">end-to-end test.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">When we created unit tests back in </span><a href="B19493_08.xhtml#_idTextAnchor189"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.457.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.458.1">, we created an in-memory representation of a database. </span><span class="koboSpan" id="kobo.458.2">We can create a similar environment where we can spin up and tear down the entire environment for </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">API tests.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">In our CI/CD pipelines, we can build a disposable server for our integration tests to provide a full end-to-end test with APIs and services and a </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">disposable database.</span></span></p>
<h3><span class="koboSpan" id="kobo.462.1">Building the integration server</span></h3>
<p><span class="koboSpan" id="kobo.463.1">Since .NET provides</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.464.1"> us with a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Program.cs</span></strong><span class="koboSpan" id="kobo.466.1"> file for our applications, we can wrap the entire application and replace the services we want to mimic with a web and </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">database server.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">We can set up the environment using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">WebApplicationFactory</span></strong><span class="koboSpan" id="kobo.470.1"> class. </span><span class="koboSpan" id="kobo.470.2">We include the minimal API project as a dependency in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">Api.Tests</span></strong><span class="koboSpan" id="kobo.472.1"> project. </span><span class="koboSpan" id="kobo.472.2">Once we have our dependency in the program, we can create our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">WebApplicationFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
using System.Data.Common;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using ThemePark.Data.DataContext;
namespace ThemePark.Api.Tests;
public class TestThemeParkApiApplication :
WebApplicationFactory&lt;Program&gt;
{
    protected override IHost CreateHost(
    IHostBuilder builder)
    {
        var root = new InMemoryDatabaseRoot();
        builder.ConfigureServices(services =&gt;
        {
            services.RemoveAll(typeof(
                DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;
                ));
            services.AddScoped(sp =&gt; new
            DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;()
                .UseInMemoryDatabase("TestApi", root)
                .UseApplicationServiceProvider(sp)
                .Options);
            services.AddDbContext&lt;ThemeParkDbContext&gt;(
            (container, options) =&gt;
            {
                var connection = container
                    .GetRequiredService&lt;DbConnection&gt;();
                options.UseSqlite(connection);
            });
            services.AddTransient&lt;IThemeParkDbContext,
                ThemeParkDbContext&gt;();
        });
        return base.CreateHost(builder);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.476.1">In the preceding code example, we inherited from </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">WebApplicationFactory&lt;Program&gt;</span></strong><span class="koboSpan" id="kobo.478.1">. </span><span class="koboSpan" id="kobo.478.2">The generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">&lt;Program&gt;</span></strong><span class="koboSpan" id="kobo.480.1"> comes from the included dependency we referenced. </span><span class="koboSpan" id="kobo.480.2">Then, we created a root for our in-memory database and proceeded to configure our services by removing all instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;</span></strong><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">Once we’ve removed these, we can create a new scoped reference to the same type with our updated settings for </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Next, we added our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.486.1"> with our updated connection using a SQLite database. </span><span class="koboSpan" id="kobo.486.2">Remember, Entity Framework Core will automatically create the structure of our entire database with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">.EnsureCreated()</span></strong><span class="koboSpan" id="kobo.488.1"> method. </span><span class="koboSpan" id="kobo.488.2">Finally, we added a dependency injection registration for </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">IThemeParkDbContext</span></strong><span class="koboSpan" id="kobo.490.1"> for the services in </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">That’s it for our integration server. </span><span class="koboSpan" id="kobo.492.2">Now, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">TestThemeParkApiApplication</span></strong><span class="koboSpan" id="kobo.494.1"> in our integration test. </span><span class="koboSpan" id="kobo.494.2">For example, if we want to create a test for</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.495.1"> our </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">/attractions</span></strong><span class="koboSpan" id="kobo.497.1"> API, our integration test will look </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
using Microsoft.Extensions.DependencyInjection;
using ThemePark.Data.DataContext;
namespace ThemePark.Api.Tests;
[TestClass]
public class ApiTests
{
    private TestThemeParkApiApplication _app;
    [TestInitialize]
    public void Setup()
    {
        _app = new TestThemeParkApiApplication();
        using (var scoped = _app.Services.CreateScope())
        {
            var context = scoped.ServiceProvider
                .GetService&lt;IThemeParkDbContext&gt;();
            context?.Database.EnsureCreated();
        }
    }
    [TestMethod]
    [TestCategory("Integration")]
    public async Task GetAllAttractions()
    {
        // Arrange
        var client = _app.CreateClient();
        var expected = TestData.ExpectedAttractionData;
        // Act
        var response = await
            client.GetAsync("/attractions");
        var actual = await response.Content
            .ReadAsStringAsync();
        // Assert
        Assert.AreEqual(expected, actual);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.500.1">In the preceding code snippet, we initialized </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">TestThemeParkApiApplication</span></strong><span class="koboSpan" id="kobo.502.1"> on setup so that every instance is new through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">.EnsureCreated()</span></strong><span class="koboSpan" id="kobo.504.1"> method. </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">_app.CreateClient</span></strong><span class="koboSpan" id="kobo.506.1"> gives us </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">HttpClient</span></strong><span class="koboSpan" id="kobo.508.1"> to make a call to a URL. </span><span class="koboSpan" id="kobo.508.2">We make a call to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">/attractions</span></strong><span class="koboSpan" id="kobo.510.1"> API and compare it with a resource string we created instead of cluttering our test methods with large JSON strings. </span><span class="koboSpan" id="kobo.510.2">Finally, our test compares the JSON results with what’s returned from </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">an API.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">The ability to create entire front-to-back integration tests proving the APIs, Entity Framework queries, and database code work as expected while running through a CI/CD pipeline with successful tests should instill confidence about </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">In this section, we learned how to take APIs and test them in Visual Studio’s Endpoints Explorer. </span><span class="koboSpan" id="kobo.514.2">We also </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.515.1">learned how to take those APIs and make them testable in a CI/CD pipeline by wrapping our API project </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">WebApplicationFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">In the next section, we’ll cover some of the common practices used in the industry when </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">building APIs.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.521.1">Standardized Web API techniques</span></h1>
<p><span class="koboSpan" id="kobo.522.1">In this section, we’ll learn</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.523.1"> how to use HTTP verbs and status codes properly, how to avoid large dependent resources, how to create paginations for APIs, how to version an API, using DTOs instead of entities, and the best way to make API calls </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">from .NET.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.525.1">Using the right HTTP verbs and status codes</span></h2>
<p><span class="koboSpan" id="kobo.526.1">So far, we’ve</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.527.1"> looked at how to use HTTP verbs </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.528.1">and how to </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.529.1">return</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.530.1"> status codes. </span><span class="koboSpan" id="kobo.530.2">While this may seem like a trivial thing, some systems ignore these standards and use POSTs all the time, regardless of </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">Swagger provides a great template for documenting APIs and with Visual Studio’s new Endpoints Explorer, Visual Studio brings this fundamental documentation down to the developer’s IDE, making the API easier to read and implement in other projects, showing developers what verbs to use and what status codes </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">are expected.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">In our example of a shopping cart API earlier in this chapter, users were going to add products to a cart and proceed to check out. </span><span class="koboSpan" id="kobo.534.2">They were going to use a cart to begin this process. </span><span class="koboSpan" id="kobo.534.3">The function of checking out led us to use the cart API with a method of checkout (</span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">/cart/checkout</span></strong><span class="koboSpan" id="kobo.536.1">), which makes perfect sense. </span><span class="koboSpan" id="kobo.536.2">We should take the user’s actions</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.537.1"> and</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.538.1"> match </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.539.1">them to</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.540.1"> actions in </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">the APIs.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.542.1">Beware dependent resources</span></h2>
<p><span class="koboSpan" id="kobo.543.1">But how far do I take my </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.544.1">API based on resources? </span><span class="koboSpan" id="kobo.544.2">What if one resource belongs to another resource and that’s dependent on another resource, and </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">so on?</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">Here’s an </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">example: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">/users/{userId}/projects/{projectId}/tasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">We want to get a user’s tasks for a project, but this URL seems a bit long, doesn’t it? </span><span class="koboSpan" id="kobo.550.2">How do we break this down into something a bit more manageable? </span><span class="koboSpan" id="kobo.550.3">Anything more than three levels deep is simply asking </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">for trouble.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">This URL requires a more granular approach – that is, breaking out each resource. </span><span class="koboSpan" id="kobo.552.2">Instead of the preceding URL, a better approach would be to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">/users/{userId}/projects</span></strong><span class="koboSpan" id="kobo.554.1"> to retrieve a list of projects a user is working on at a time. </span><span class="koboSpan" id="kobo.554.2">The next URL would provide the tasks based on the selected project and look </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">like </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">/projects/{projectId}/tasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">As developers, we all know everything is a compromise. </span><span class="koboSpan" id="kobo.558.2">In this case, we are providing a simpler API but requiring two calls instead </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">of one.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">These are discussions to be had with team members, but essentially, the smaller the URL, the easier it is to implement. </span><span class="koboSpan" id="kobo.560.2">The longer the URL, the more resource lookups are necessary to fulfill </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">the request.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.562.1">Pagination in API results</span></h2>
<p><span class="koboSpan" id="kobo.563.1">For most API calls, results</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.564.1"> are returned in</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.565.1"> a raw, </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.567.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.568.1">JSON</span></strong><span class="koboSpan" id="kobo.569.1">) format, usually as a collection or a single item. </span><span class="koboSpan" id="kobo.569.2">What if the client side needs paginated results and they only want one page of data </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">for now?</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">To assist client-side developers, a JSON result could contain </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.573.1">
{
    "total": 7,
    "pageSize": 7,
    "currentPage": 1,
    "next": false,
    "previous": false,
    "results": [
        {
            "id": 1,
            "name": "Twirly Ride",
            "locationId": 2,
            "locationName": "Fantasy"
        },
        {
            "id": 2,
            "name": "Mine car Coaster",
            "locationId": 5,
.
</span><span class="koboSpan" id="kobo.573.2">.</span></pre> <p><span class="koboSpan" id="kobo.574.1">While returning</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.575.1"> results as a collection is usually required, some fields to return in the header are </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">Total</span></strong><span class="koboSpan" id="kobo.578.1">: Total number </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">of records</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">PageSize</span></strong><span class="koboSpan" id="kobo.581.1">: How many records are returned in </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">this response</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">TotalPages</span></strong><span class="koboSpan" id="kobo.584.1">: Specifies the total number of pages based </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">PageSize</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">CurrentPage</span></strong><span class="koboSpan" id="kobo.588.1">: Specifies what page we are </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">currently on</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Next</span></strong><span class="koboSpan" id="kobo.591.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Previous</span></strong><span class="koboSpan" id="kobo.593.1">: Are there enough records to move back </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">and forward?</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Sort</span></strong><span class="koboSpan" id="kobo.596.1">: Specifies how the results </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">are sorted</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Filter</span></strong><span class="koboSpan" id="kobo.599.1">: Specifies what filter was applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">the results</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.601.1">The header is meant to help our fellow client-side developer make the most of the response. </span><span class="koboSpan" id="kobo.601.2">While this isn’t a comprehensive list of fields to include, it should be implemented with consistency across every single response when displaying a subset of records on</span><a id="_idIndexMarker541"/> <span class="No-Break"><span class="koboSpan" id="kobo.602.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">A “status code” field or “success” field in the header should be avoided since HTTP status codes are considered the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">expected response.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.605.1">Versioning APIs</span></h2>
<p><span class="koboSpan" id="kobo.606.1">When creating</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.607.1"> APIs, by default, they’ll more than likely be in a raw state with no versioning in place. </span><span class="koboSpan" id="kobo.607.2">There are four types </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">of versioning:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.609.1">No versioning</span></strong><span class="koboSpan" id="kobo.610.1">: When we create our </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">first API</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.612.1">URI versioning</span></strong><span class="koboSpan" id="kobo.613.1">: Placing another segment into the URL is extremely common and </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">recommended (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">/v1/users</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.617.1">Query string</span></strong><span class="koboSpan" id="kobo.618.1">: This involves appending a query string to the end of the </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">URL (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">/users/?version=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.622.1">Header versioning</span></strong><span class="koboSpan" id="kobo.623.1">: This involves using </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">custom-header</span></strong><span class="koboSpan" id="kobo.625.1"> to place the version into </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">the header:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.627.1">
GET /users
Custom-Header: api-version=1</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.628.1">The most common versioning technique that’s used is URI versioning. </span><span class="koboSpan" id="kobo.628.2">While everyone’s mileage may vary, this technique is appealing because it’s immediately obvious which version </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">we’re using.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.630.1">Use DTOs, not entities!</span></h2>
<p><span class="koboSpan" id="kobo.631.1">While testing</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.632.1"> our API, we </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.633.1">weren’t returning entities (</span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Attraction</span></strong><span class="koboSpan" id="kobo.635.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">Location</span></strong><span class="koboSpan" id="kobo.637.1">). </span><span class="koboSpan" id="kobo.637.2">Instead, we were returning </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">data transfer objects</span></strong><span class="koboSpan" id="kobo.639.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.640.1">DTOs</span></strong><span class="koboSpan" id="kobo.641.1">), which are a subset </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">of properties.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Our security chapter (</span><a href="B19493_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.644.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.645.1">) mentioned not to expose too much when it comes to primary keys or sensitive information. </span><span class="koboSpan" id="kobo.645.2">DTOs give the developer a chance to pick and choose which properties should be exposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">For example, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">Attraction</span></strong><span class="koboSpan" id="kobo.649.1"> DTO is meant to provide a minimal amount of information; we’ll discuss this after we look at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">code example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
public static class AttractionExtensions
{
    public static AttractionDto ToDto(
    this Attraction attraction)
    {
        return new AttractionDto
        {
            Id = attraction.Id,
            Name = attraction.Name,
            LocationId = attraction.LocationId,
            LocationName = attraction.Location == null
                ? </span><span class="koboSpan" id="kobo.651.2">string.Empty
                : attraction.Location.Name
        };
    }
}</span></pre> <p><span class="koboSpan" id="kobo.652.1">Here, we have a simplified </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">AttractionDto</span></strong><span class="koboSpan" id="kobo.654.1"> class containing simple properties. </span><span class="koboSpan" id="kobo.654.2">We also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">LocationName</span></strong><span class="koboSpan" id="kobo.656.1"> property based on our dependent </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">While we have this as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">.ToDto()</span></strong><span class="koboSpan" id="kobo.661.1"> method, we could create other DTO extension methods to return different data in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">.ToDifferentDto()</span></strong><span class="koboSpan" id="kobo.663.1"> method or whatever we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">call it.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">Another reason to use DTOs instead of Entity Framework entities is the potentially recursive nature of navigational properties. </span><span class="koboSpan" id="kobo.665.2">When an entity is returned from an API, it’s turned into a JSON object. </span><span class="koboSpan" id="kobo.665.3">If we have a nested entity, it’ll follow it down the chain. </span><span class="koboSpan" id="kobo.665.4">It’s better to isolate and distill an entity’s properties down to their native types for basic consumption on</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.666.1"> the client</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.667.1"> side when they’re returned from </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">the API.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.669.1">Avoid new instances of HttpClient</span></h2>
<p><span class="koboSpan" id="kobo.670.1">While the majority</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.671.1"> of this </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.672.1">chapter discussed creating and testing APIs, I feel we need to mention how to consume them in a .NET application </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">There are various ways to consume a web API, such as using </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">WebRequest</span></strong><span class="koboSpan" id="kobo.676.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">WebClient</span></strong><span class="koboSpan" id="kobo.678.1">, but for most purposes, the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">HttpClient</span></strong><span class="koboSpan" id="kobo.680.1"> class is recommended because of its flexibility and modernization. </span><span class="koboSpan" id="kobo.680.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">WebRequest</span></strong><span class="koboSpan" id="kobo.682.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">WebClient</span></strong><span class="koboSpan" id="kobo.684.1"> classes were included for the transition of legacy applications. </span><span class="koboSpan" id="kobo.684.2">With that said, it’s easy to create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">HttpClient</span></strong><span class="koboSpan" id="kobo.686.1">, but it’s not the </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">best approach.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">Microsoft states that </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">HttpClient</span></strong><span class="koboSpan" id="kobo.690.1"> should only be used once per the lifetime of an application. </span><span class="koboSpan" id="kobo.690.2">If we create instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">HttpClient</span></strong><span class="koboSpan" id="kobo.692.1"> in multiple locations in our application, we are hindering the performance and scalability opportunities. </span><span class="koboSpan" id="kobo.692.2">It causes an issue called TCP port exhaustion if the rate of requests is too high, so it’s best to avoid code such as </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">
// Bad use of HttpClient
var client = new HttpClient();</span></pre> <p><span class="koboSpan" id="kobo.695.1">Some developers may take this a step further and decide the following code snippet is better by wrapping a </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">using</span></strong><span class="koboSpan" id="kobo.697.1"> statement to dispose of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">HttpClient</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.699.1">class properly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
// Still not good
using (var client = new HttpClient())
{
    .
</span><span class="koboSpan" id="kobo.700.2">    .
</span><span class="koboSpan" id="kobo.700.3">}</span></pre> <p><span class="koboSpan" id="kobo.701.1">The problem with this code is that we’re still creating another instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">HttpClient</span></strong><span class="koboSpan" id="kobo.703.1">, still causing port exhaustion, and still disposing of it when we’ll more than likely need </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">it later.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">In .NET Core 2.1, Microsoft created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">IHttpClientFactory</span></strong><span class="koboSpan" id="kobo.707.1"> class to deliver a single instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">HttpClient</span></strong><span class="koboSpan" id="kobo.709.1">. </span><span class="koboSpan" id="kobo.709.2">We can simply ask it for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">HttpClient</span></strong><span class="koboSpan" id="kobo.711.1"> instance and we’ll receive one. </span><span class="koboSpan" id="kobo.711.2">The best news is it can be </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">dependency injected.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">The code becomes easier to work with once we’ve injected the class through constructors, as </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.714.1">shown in</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.715.1"> the following </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
public class IndexModel : PageModel
{
    private readonly ILogger&lt;IndexModel&gt; _logger;
    private readonly IHttpClientFactory _factory;
    public IndexModel(
        ILogger&lt;IndexModel&gt; logger,
        IHttpClientFactory factory)
    {
        _logger = logger;
        _factory = factory;
    }
    public async Task OnGet()
    {
        // Bad use of HttpClient
        // var client = new HttpClient();
        // Still not good
        //using (var client = new HttpClient())
        //{
        //    .
</span><span class="koboSpan" id="kobo.717.2">        //    .
</span><span class="koboSpan" id="kobo.717.3">        //}
        // Best way to use HttpClient
        var client = _factory.CreateClient();
        // use client.GetAsync("https://www.google.com") to
           grab HTML
    }
}</span></pre> <p><span class="koboSpan" id="kobo.718.1">When we </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.719.1">ask </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">HttpClientFactory</span></strong><span class="koboSpan" id="kobo.721.1"> for a </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.722.1">client using </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">.CreateClient()</span></strong><span class="koboSpan" id="kobo.724.1">, it won’t create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">HttpClient</span></strong><span class="koboSpan" id="kobo.726.1"> unless it </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">has to.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">Think of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">.CreateClient()</span></strong><span class="koboSpan" id="kobo.730.1"> method as using a singleton design pattern behind the scenes, similar to the code </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
private static HttpClient _client { get; set; }
public HttpClient CreateClient()
{
    if (_client == null)
    {
        _client = new HttpClient();
    }
    return _client;
}</span></pre> <p><span class="koboSpan" id="kobo.733.1">As a side note, the preceding code is </span><em class="italic"><span class="koboSpan" id="kobo.734.1">not</span></em><span class="koboSpan" id="kobo.735.1"> thread-safe; it has been provided to show the concept of a </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.736.1">singleton </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">design </span></span><span class="No-Break"><a id="_idIndexMarker554"/></span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.739.1">We always get an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">HttpClient</span></strong><span class="koboSpan" id="kobo.741.1">, which is a better way to make server-side </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">API calls.</span></span></p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.743.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.744.1">In this chapter, we learned about several techniques, such as how to design an API by disconnecting from technology by becoming a user of the application, identifying the resources, and using the right HTTP verbs and correct status codes. </span><span class="koboSpan" id="kobo.744.2">We also learned how to create, test, and document APIs, along with why minimal APIs are important. </span><span class="koboSpan" id="kobo.744.3">After, we learned how to use the new Endpoints Explorer in Visual Studio 2022, as well as how to build an automated end-to-end test of our APIs in a </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">CI/CD pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">Once we understood the process of writing APIs, we examined what standards were used in the industry to create common and useful APIs, such as using the correct HTTP verbs and status codes, avoiding large URLs, how to use pagination with APIs, versioning our API, using DTOs instead of entities, and the optimal way to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">HttpClient</span></strong><span class="koboSpan" id="kobo.748.1"> when making API calls </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">from .NET.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">In the next chapter, we’ll look at how to improve performance across various topics we’ve covered in this book, and we’ll also provide some new </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">performance tips.</span></span></p>
</div>
</body></html>