- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Test-Driven Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Let’s continue our discussion of testing and ensuring the quality of our software
    processes by going in-depth with Test-Driven Development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过深入探讨测试驱动开发来继续我们的讨论，以确保我们软件过程的质量。
- en: While this is a book about refactoring and Test-Driven Development is primarily
    intended for future development and bug fixing, it has some key lessons to teach
    us in software quality and the same tools Visual Studio provides to support Test-Driven
    Development can help immensely in the refactoring process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一本关于重构和测试驱动开发的书籍，主要目的是为了未来的开发和修复bug，但它有一些关键的教训要教给我们关于软件质量，并且Visual Studio提供的支持测试驱动开发的工具在重构过程中也能极大地帮助。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is Test-Driven Development?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是测试驱动开发？
- en: Test-Driven Development with Visual Studio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Visual Studio进行测试驱动开发
- en: When to use Test-Driven Development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用测试驱动开发
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter07/Ch7BeginningCode` folder.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可以从GitHub的[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)在`Chapter07/Ch7BeginningCode`文件夹中获取。
- en: What is Test-Driven Development?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是测试驱动开发？
- en: '**Test-driven Development** (**TDD**) is the process of writing your tests
    *before* you write your code for a new feature or to implement a new fix.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是指在编写新功能或实施新修复的代码之前，先编写测试的过程。'
- en: Under TDD, you first write a test for the feature you’re trying to implement
    or a test to reproduce the bug you’re about to fix. You do this in the most ideal
    way possible, which may even involve classes or methods that don’t exist at the
    start of your test.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD下，你首先为你要实现的功能或为重现你即将修复的bug编写一个测试。你以最理想的方式做这件事，这甚至可能涉及到测试开始时还不存在的类或方法。
- en: Next, you do the minimum amount of work needed to make your code successfully
    compile. This isn’t to say that it runs perfectly or does the thing it is trying
    to do, in fact, you’re trying to start out with a red failing test that indicates
    your feature or fix doesn’t work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你进行最小的工作量，使你的代码能够成功编译。这并不是说它运行得完美或者完成了它试图做的事情，实际上，你试图从一个红色的失败测试开始，这表明你的功能或修复不起作用。
- en: This makes sense when you consider that at this point you haven’t implemented
    the new feature or made the fix to the code. So, the test *should* be a failing
    test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你还没有实现新功能或对代码进行修复。所以，测试*应该*是一个失败的测试。
- en: Next, you write the minimum amount of code required to make your test pass.
    In this step, you are doing what you need to do to meet the specific requirement
    you are trying to address. Once you are finished, your test should turn into a
    green passing test.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你编写最小的代码，使你的测试通过。在这个步骤中，你正在做你需要做的事情来满足你试图解决的具体要求。一旦完成，你的测试应该变成绿色的通过测试。
- en: After that, you refactor the code you added to implement your feature or fix
    and you refactor your test code as well; taking care to continue to run your unit
    tests to ensure you haven’t broken anything.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你重构你添加的代码以实现你的功能或修复，同时也要重构你的测试代码；注意继续运行你的单元测试，以确保你没有破坏任何东西。
- en: 'Once you’re satisfied with the state of your new code and your test, you look
    at the next requirement on the current work item you’re working on, write a test
    for that, and repeat the process until you have met all requirements. This process
    is illustrated in *Figure 7**.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对你的新代码和测试的状态感到满意，你就可以查看当前工作项上的下一个要求，为那个要求编写一个测试，然后重复这个过程，直到你满足了所有要求。这个过程在*图7.1*中得到了说明：
- en: '![Figure 7.1 – The Test-Driven Development Cycle](img/B21324_07_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 测试驱动开发周期](img/B21324_07_01.jpg)'
- en: Figure 7.1 – The Test-Driven Development Cycle
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 测试驱动开发周期
- en: Because you start with a failing red test, move on to a green passing test,
    and then refactor your code before starting again with a new requirement, TDD
    is sometimes referred to as **Red / Green /** **Refactor**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你是从一个失败的红色测试开始的，然后过渡到绿色的通过测试，然后在你开始新的要求之前重构你的代码，所以TDD有时被称为**红/绿/** **重构**。
- en: 'This process has a few key benefits:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程有几个关键的好处：
- en: You can be confident your code addresses the problem by starting with a test.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过从测试开始来确信你的代码解决了问题。
- en: Code written in this way is guaranteed to be covered by your tests.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式编写的代码保证会被你的测试覆盖。
- en: When you start with how your code should be called by others, it tends to lead
    to more intuitive class designs for others to use later.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你从其他人如何调用你的代码开始时，往往会引导出更直观的类设计，供其他人以后使用。
- en: This process, and its results, make a lot more sense with a practical example.
    So, let’s jump into some code and implement a new feature for Cloudy Skies Airlines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程及其结果，通过一个实际例子会更有意义。所以，让我们跳入一些代码，为 Cloudy Skies Airlines 实现一个新功能。
- en: Test-Driven Development with Visual Studio
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 进行测试驱动开发
- en: 'We’re starting this chapter with a nearly empty console project and a supporting
    xUnit test project that has already been linked to the main project as shown in
    [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133). The structure of this project
    can be seen in *Figure 7**.2*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个几乎空的控制台项目和已经链接到主项目的支持 xUnit 测试项目开始这一章，如图 [*第 6 章*](B21324_06.xhtml#_idTextAnchor133)
    所示。这个项目的结构可以在 *图 7**.2* 中看到：
- en: '![Figure 7.2 – Solution Explorer showing only a few files](img/B21324_07_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 显示仅几个文件的解决方案资源管理器](img/B21324_07_02.jpg)'
- en: Figure 7.2 – Solution Explorer showing only a few files
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 仅显示几个文件的解决方案资源管理器
- en: Over the course of the rest of this section, we’re going to add a new class
    to track frequent flier miles for Cloudy Skies Airlines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节剩余的部分，我们将为 Cloudy Skies Airlines 添加一个新的类来跟踪常旅客里程。
- en: 'The requirements we’ll be addressing (in order) are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的要求（按顺序）是：
- en: When a new Frequent Flier Account is created it should start with a starting
    balance of 100 miles.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建一个新的常旅客账户时，它应该从 100 英里起始余额开始。
- en: You should be able to add miles to the frequent flier account.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该能够向常旅客账户添加里程。
- en: You should be able to mark miles as redeemed as long as this wouldn’t result
    in a negative balance.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要这不会导致余额为负，你应该能够标记里程为已兑换。
- en: These are not complex requirements, but they should serve as a starting point
    for briefly exploring TDD.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求并不复杂，但它们应该作为简要探索 TDD 的起点。
- en: We’ll start with the starting balance requirement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从起始余额要求开始。
- en: Setting the starting balance
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置起始余额
- en: Our first requirement involves the account starting with 100 miles already registered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个要求涉及账户从已经注册的 100 英里开始。
- en: Under the guidance of TDD, we should start with a failing test. Thankfully,
    we already have a `MilesTrackerTests.cs` file, so that gives us a good place to
    start.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 的指导下，我们应该从一个失败的测试开始。幸运的是，我们已经有了一个 `MilesTrackerTests.cs` 文件，这为我们提供了一个良好的起点。
- en: However, we have no classes in the `Chapter7` project to represent the mileage
    tracker, which poses a problem for us in writing the arrange section of our first
    test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在 `Chapter7` 项目中没有类来表示里程追踪器，这在我们编写第一个测试的安排部分时给我们带来了问题。
- en: While there’s a temptation to “cheat” a bit by creating the class now, let’s
    follow a strictly TDD approach and write the test code in the way we’d prefer
    to interact with the class, knowing that the class doesn’t exist yet and this
    will cause some compiler errors for us in a moment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在创建类可能会有点“作弊”的诱惑，但让我们遵循严格的 TDD 方法，并按照我们希望与类交互的方式编写测试代码，知道这个类还不存在，这将在不久的将来给我们带来一些编译错误。
- en: 'Such a test might look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试可能看起来像这样：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This test sets an expected starting mileage variable, tries to instantiate a
    `MileageTracker`, and then asserts that the `Balance` property on this new tracker
    should be the expected amount.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试设置了一个预期的起始里程变量，尝试实例化一个 `MileageTracker`，然后断言这个新追踪器的 `Balance` 属性应该是预期的金额。
- en: 'This is a simple, concise, and readable test with a couple of tiny problems:
    `MileageTracker` and its `Balance` property don’t exist in our code yet, meaning
    our code won’t compile.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单、简洁且易于阅读的测试，但存在一些小问题：`MileageTracker` 和其 `Balance` 属性在我们的代码中尚不存在，这意味着我们的代码无法编译。
- en: Generating classes
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成类
- en: These compiler issues when creating new classes and new properties are normal
    and to be expected when coding under TDD. Thankfully Visual Studio has a Quick
    Actions refactoring available for us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 编码时创建新类和新属性时出现的编译问题是很正常的，也是可以预料的。幸运的是，Visual Studio 为我们提供了一个快速操作重构功能。
- en: 'Select the `MileageTracker` in your act section and open the Quick Actions
    menu. From there note the various options to generate this Type as shown in *Figure
    7**.2*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的操作部分选择 `MileageTracker` 并打开快速操作菜单。从那里注意各种选项来生成此类型，如图 *图 7**.2* 所示：
- en: '![Figure 7.3 – Quick Actions to generate a new Type](img/B21324_07_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 快速操作以生成新的类型](img/B21324_07_03.jpg)'
- en: Figure 7.3 – Quick Actions to generate a new Type
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 快速操作以生成新的类型
- en: These options, as shown here, are great, but most of them would create the new
    class inside the test project which is not what we want. Since we want to customize
    the new type being created, select **Generate** **new type…**
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项，如图所示，非常好，但其中大多数都会在测试项目中创建新的类，这不是我们想要的。由于我们想要自定义正在创建的新类型，请选择 **生成** **新类型…**
- en: 'This will open the **Generate Type** dialog allowing you to select the type,
    name, and location of the new type being generated. Change the **Project** to
    *Chapter7* and choose to create a new file as shown in *Figure 7**.4*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 **生成类型** 对话框，允许您选择新生成类型的类型、名称和位置。将 **项目** 更改为 *Chapter7* 并选择创建一个新文件，如图
    *图 7.4* 所示：
- en: '![Figure 7.4 – Generating a new class in the Chapter7 project](img/B21324_07_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 在 Chapter7 项目中生成新的类](img/B21324_07_04.jpg)'
- en: Figure 7.4 – Generating a new class in the Chapter7 project
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 在 Chapter7 项目中生成新的类
- en: Next, click `MileageTracker.cs` file to the main project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击 `MileageTracker.cs` 文件到主项目。
- en: This class is boring at present with nothing in it, but we’ll add to it in a
    moment as we work on the next compiler error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个类里面什么都没有，很无聊，但当我们处理下一个编译错误时，我们会很快添加内容。
- en: Generating members
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成成员
- en: 'Going back to our test, the *act* section now has no issues, but we still have
    a compiler error on the reference to `Balance` in the *Assert* section as shown
    in *Figure 7**.5*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试中，现在 *操作* 部分没有问题，但我们仍然在 *断言* 部分对 `Balance` 的引用上有编译错误，如图 *图 7.5* 所示：
- en: '![Figure 7.5 – The C# Compiler pointing out that MileageTracker has Balance
    property](img/B21324_07_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – C# 编译器指出 MileageTracker 有 Balance 属性](img/B21324_07_05.jpg)'
- en: Figure 7.5 – The C# Compiler pointing out that MileageTracker has Balance property
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – C# 编译器指出 MileageTracker 有 Balance 属性
- en: Thankfully, Visual Studio gives us tools to generate properties. Let’s do that
    now so our code will at least compile.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Visual Studio 给我们提供了生成属性的工具。现在让我们这样做，这样我们的代码至少可以编译。
- en: 'Select **Balance** and then open the **Quick Actions** menu and choose **Generate
    property ‘Balance’** as shown in *Figure 7**.6*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **Balance**，然后打开 **快速操作** 菜单，选择 **生成属性‘Balance’**，如图 *图 7.6* 所示：
- en: '![Figure 7.6 – Generating a new property](img/B21324_07_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 生成新的属性](img/B21324_07_06.jpg)'
- en: Figure 7.6 – Generating a new property
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 生成新的属性
- en: 'Doing so causes Balance to be defined. If you hold down *Ctrl* and click on
    `Balance`, it will navigate you to `MileageTracker.cs` and we’ll see how the class
    is defined:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会导致 Balance 被定义。如果您按住 *Ctrl* 并单击 `Balance`，它将带您导航到 `MileageTracker.cs`，我们将看到类是如何定义的：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, Visual Studio had to guess what property type `Balance` was and it guessed
    horribly wrong. Since this will otherwise cause compiler errors, change `Balance`
    to an `int`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Visual Studio 必须猜测 `Balance` 属性的类型，并且猜测得非常糟糕。由于这否则会导致编译错误，将 `Balance` 改为
    `int`：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that change, the code should now compile, but let’s make one more change
    before we run our tests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个更改，代码现在应该可以编译，但在我们运行测试之前，让我们再做一个更改。
- en: 'Remember that TDD requires us to write the minimum amount of code to do what
    we’re trying to do? Technically, Visual Studio has violated this principle by
    generating both a getter and a setter for our Balance property. In this test,
    we only need to get the `Balance` and not set it via this property. So, let’s
    protect that `Balance` by removing the setter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，TDD 要求我们编写最少的代码来完成我们想要做的事情吗？技术上讲，Visual Studio 通过为我们的 Balance 属性生成获取器和设置器违反了这一原则。在这个测试中，我们只需要获取
    `Balance`，而不需要通过这个属性来设置它。所以，让我们通过移除设置器来保护这个 `Balance`：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this bit of added encapsulation in hand and our code compiling, let’s
    run our test. When you do so, you should see the test fail stating that it expected
    `Balance` to be 100 but it actually was 0 as shown in *Figure 7**.7*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这段额外的封装并代码编译无误后，让我们运行我们的测试。当你这样做时，你应该会看到测试失败，指出它期望 `Balance` 为 100，但实际上是
    0，如图 *图 7.7* 所示：
- en: '![Figure 7.7 – Our first failing test](img/B21324_07_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 我们的第一个失败的测试](img/B21324_07_07.jpg)'
- en: Figure 7.7 – Our first failing test
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 我们的第一个失败的测试
- en: Under TDD, this is exactly what we’d want. We did the minimum amount of work
    to get an ideal test to compile, and that test failed because we hadn’t fully
    implemented the feature.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 下，这正是我们想要的。我们做了最少的努力来得到一个理想的测试编译，而这个测试失败了，因为我们还没有完全实现这个功能。
- en: Moving from red to green and onto refactoring
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从红色变为绿色，并进行重构
- en: Let’s implement the feature now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在实现这个功能。
- en: 'While we know that our `MileageTracker` will need some additional things later,
    let’s implement this feature by writing the minimum amount of code possible:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道我们的 `MileageTracker` 将需要一些额外的功能，但让我们通过编写尽可能少的代码来实现这个功能：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This now defaults new `MileageTracker` instances to have a starting balance
    of 100, which meets our needs and causes our test to turn green and pass when
    re-run.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在默认将新的 `MileageTracker` 实例的起始余额设置为 100，这符合我们的需求，并在重新运行测试时使测试变为绿色并通过。
- en: With a green test, we now look for opportunities to refactor. While our test
    code is minimal, the `MileageTracker` does have a **magic number** in it. Magic
    numbers are **code smells** that represent some sort of undocumented business
    or technical requirement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在绿色测试之后，我们现在寻找重构的机会。虽然我们的测试代码是最小的，但 `MileageTracker` 中确实有一个 **魔法数字**。魔法数字是代表某种未记录的业务或技术需求的
    **代码异味**。
- en: 'Let’s fix it by introducing a constant:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过引入一个常量来修复它：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is now easier for others to understand, removing the code smell.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在更容易被其他人理解，消除了代码异味。
- en: Naming
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 命名
- en: Naming things in software engineering is hard. It’s possible the name that occurred
    to you for this class or the `SignUpBonus` `const` I introduced was different
    than the names I picked. That’s fine. What’s most important about a name is that
    it *communicates intent* to other developers and is not confused with something
    else in the system. While the name `StartingBalance` would have been fine for
    my const, I chose `SignUpBonus` because I thought it more clearly documented the
    business case for the starting balance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中给事物命名是困难的。可能您对这个类或我引入的 `SignUpBonus` `const` 的名字与我选择的名称不同。这没关系。一个名字最重要的地方是它能向其他开发者传达意图，并且不会与系统中的其他事物混淆。虽然
    `StartingBalance` 这个名字对我这个常量来说已经足够好了，但我选择了 `SignUpBonus`，因为它更清楚地记录了起始余额的业务案例。
- en: Running the tests again results in a green passing test once more and there
    are no other obvious targets for refactoring, so we move on to the next requirement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试后，结果再次是一个绿色的通过测试，并且没有其他明显的重构目标，所以我们继续到下一个需求。
- en: Adding miles and generating methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加里程和生成方法
- en: Our next requirement is *You should be able to add miles to the frequent* *flier
    account*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个需求是 *您应该能够向常旅客账户添加里程*。
- en: 'Let’s go back to our tests and add a new test for this requirement. Here we’ll
    again choose the most intuitive syntax and then make the code compile and test
    pass later:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的测试中，为这个需求添加一个新的测试。这里我们再次选择最直观的语法，然后稍后使代码编译并通过测试：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test instantiates a `MileageTracker`, then tries to add 50 miles using
    a not-yet-created `AddMiles` method before verifying that the balance is 150 (100
    starting miles plus the 50 we just added).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试实例化了一个 `MileageTracker`，然后尝试使用尚未创建的 `AddMiles` 方法添加 50 英里，并在验证余额为 150（100
    英里起始里程加上我们刚刚添加的 50 英里）之前进行。
- en: 'Of course, there is no `AddMiles` method in `MileageTracker`. Let’s add one
    by selecting `AddMiles` and then choosing **Generate method ‘AddMiles’** from
    the **Quick Actions** menu as shown in *Figure 7**.8*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 `MileageTracker` 中没有 `AddMiles` 方法。让我们通过选择 `AddMiles` 并从 **快速操作** 菜单中选择
    **生成方法‘AddMiles’** 来添加一个，如图 *图 7.8* 所示：
- en: '![Figure 7.8 – Adding a new method](img/B21324_07_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 添加新方法](img/B21324_07_08.jpg)'
- en: Figure 7.8 – Adding a new method
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 添加新方法
- en: 'Adding this method causes it to be created with the following implementation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此方法会导致它以以下实现被创建：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Obviously, this is not what the method should do. However, let’s follow strict
    TDD and move through the motions one step at a time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是该方法应该做的事情。然而，让我们遵循严格的 TDD，一步一步地完成这些动作。
- en: Since our code now compiles, we can run the test and verify that it fails as
    expected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码现在可以编译，我们可以运行测试并验证它是否按预期失败。
- en: Once we’re confident we have a test that can detect failing code we write only
    the minimum amount of code required to get the test to pass. This ensures that
    our tests are sufficient for finding actual problems with the code later.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确信我们有一个可以检测到我们编写的失败代码的测试，我们就只编写使测试通过所需的最少代码。这确保了我们的测试足以在以后找到代码的实际问题。
- en: 'A passing implementation of `AddMiles` might look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMiles` 的一个通过实现可能看起来像这样：'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the code now compiles and results in green tests. This means
    we should move on to refactoring our code as needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码现在可以编译，并导致绿色测试。这意味着我们应该继续根据需要重构我们的代码。
- en: The test code is still clean and the only refactoring I can see to apply here
    might be to use the expression-bodied members that we covered in [*Chapter 4*](B21324_04.xhtml#_idTextAnchor072).
    However, I’m going to leave the code in its current form as the class is still
    very minimal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码仍然干净，我看到的唯一重构可能是使用我们在[*第4章*](B21324_04.xhtml#_idTextAnchor072)中介绍的表达式-bodied成员。然而，我将保留代码的当前形式，因为类仍然非常简单。
- en: With that requirement complete, let’s move on to our final requirement around
    redeeming miles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那个需求完成之后，让我们继续到最后一个关于兑换里程的需求。
- en: Redeeming miles and refactoring tests
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兑换里程和重构测试
- en: Our final requirement is *You should be able to mark miles as redeemed if this
    wouldn’t cause a negative balance*. This is a bit more complex than the last requirement
    as it has a condition attached to it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的需求是*你应该能够在不会导致负余额的情况下标记里程数为已兑换*。这个需求比上一个需求复杂一些，因为它附带了一个条件。
- en: 'As we did before, let’s start by writing a test:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前，让我们先编写一个测试用例：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test should look very similar to our `AddMiles` test earlier, except it
    calls out to a new `RedeemMiles` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试应该看起来非常类似于我们之前的`AddMiles`测试，除了它调用了一个新的`RedeemMiles`方法。
- en: Let’s use the *generate method* refactoring shown earlier to generate that empty
    `RedeemMiles` method and allow the code to compile.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面展示的*生成方法*重构来生成那个空的`RedeemMiles`方法，并允许代码编译。
- en: 'This should result in a red failing test as shown in *Figure 7**.9* due to
    the default `throw new NotImplementedException` line in that method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会导致如*图7.9*所示的红色失败测试，因为该方法中默认的`throw new NotImplementedException`行：
- en: '![Figure 7.9 – The remove mileage test failing due to an Exception being thrown](img/B21324_07_09.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 移除里程测试因抛出异常而失败](img/B21324_07_09.jpg)'
- en: Figure 7.9 – The remove mileage test failing due to an Exception being thrown
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 移除里程测试因抛出异常而失败
- en: 'However, moving from red to green is again trivial here by mirroring what we
    did for `AddMiles`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过镜像我们对`AddMiles`所做的操作，从红色变为绿色在这里又是微不足道的：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This gets our test to pass and so we move on to looking for refactoring options.
    This code isn’t bad, so we continue to look for the next requirement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的测试就通过了，因此我们继续寻找重构选项。这段代码并不差，所以我们继续寻找下一个需求。
- en: 'In this case, we haven’t fully met the requirement we were trying to solve
    because we don’t cover trying to redeem more miles than are in an account. Let’s
    write a new test for that scenario:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有完全满足我们试图解决的问题的需求，因为我们没有涵盖尝试提取比账户中更多的里程数的情况。让我们为那种情况编写一个新的测试用例：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This test creates an account and takes note of its starting balance. The test
    then attempts to withdraw more miles than accounts start with and verifies that
    the ending balance is equal to the starting balance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试创建一个账户并记录其初始余额。然后，测试尝试提取比账户初始余额更多的里程数，并验证最终余额是否等于初始余额。
- en: This doesn’t rely on any new methods in the tracker. As a result, our code compiles
    without changes. However, running this test results in a failure stating that
    balance was expected to be 100 but was -2400 instead.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这不依赖于跟踪器中的任何新方法。因此，我们的代码无需更改即可编译。然而，运行此测试会导致失败，指出预期余额为100，但实际为-2400。
- en: 'With a red test in hand, let’s modify the `RedeemMiles` method to make the
    test green:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着红色的测试用例，让我们修改`RedeemMiles`方法，使其测试变为绿色：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we check to make sure we have enough miles to fulfill the request and only
    reduce the mileage if that condition is met.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们检查是否有足够的里程来满足请求，并且只有在该条件满足的情况下才减少里程。
- en: 'Running the tests again results in a full set of passing tests as shown in
    *Figure 7**.10*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，结果是一组全部通过测试，如*图7.10*所示：
- en: '![Figure 7.10 – Four passing tests around mileage](img/B21324_07_10.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 四个关于里程的通过测试](img/B21324_07_10.jpg)'
- en: Figure 7.10 – Four passing tests around mileage
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 四个关于里程的通过测试
- en: With a passing test in hand, we now look at refactoring. Since the `MileageTracker`
    is succinct and clear, we’ll move on to looking at our tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着通过测试用例，我们现在来看重构。由于`MileageTracker`简洁明了，我们将继续查看我们的测试。
- en: What about exceptions?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常怎么办？
- en: Right now `RedeemMiles` will silently fail if you request more miles than desired,
    which might raise some alarm bells for you as a developer. In a real-world application,
    you’d probably want this method to either return a bool indicating if the redemption
    was successful or to throw an exception if the redemption was not possible. Both
    of these scenarios could be handled in TDD as additional requirements to implement,
    such as “If we try to redeem more miles than possible, an `InvalidOperationException`
    should be thrown”.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你请求比预期更多的里程，`RedeemMiles`将静默失败，这可能会让你作为开发者感到一些警觉。在现实世界的应用中，你可能希望这个方法要么返回一个布尔值来指示兑换是否成功，要么在兑换不可能时抛出一个异常。这两种情况都可以在TDD（测试驱动开发）中作为额外的实现要求来处理，例如，“如果我们尝试兑换比可能的更多的里程，应该抛出`InvalidOperationException`”。
- en: Looking at our tests, we do see that our `RemoveMileageShouldDecreaseBalance`
    and `RemoveMileageShouldPreventNegativeBalance` do similar things.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们的测试，我们可以看到`RemoveMileageShouldDecreaseBalance`和`RemoveMileageShouldPreventNegativeBalance`确实做了类似的事情。
- en: 'Due to the duplication between tests, we should combine these into a `Theory`
    with `InlineData` lines representing individual test cases. This would look something
    like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试之间的重复，我们应该将这些测试合并为一个`Theory`，其中`InlineData`行代表单个测试用例。这看起来可能如下所示：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This form allows many tests to add an initial amount to the balance, redeem
    some number of miles, and then verify the result matches the expected balance.
    This also lets us easily add new scenarios as we identify them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单允许许多测试向余额添加一个初始金额，兑换一定数量的里程，然后验证结果是否与预期余额相符。这也让我们能够轻松地添加新场景，一旦我们识别出它们。
- en: However, the name of the method is less meaningful than the more specific names
    we could use with individual `Fact` tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，方法的名称不如我们为单个`Fact`测试使用的更具体名称有意义。
- en: With passing tests and refactoring complete, we now move on to either the next
    requirement in this feature or the next work item in our queue. Let’s close the
    chapter by talking about TDD at a high level and when it’s right to use in your
    projects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试和重构完成，我们现在可以继续进行这个功能中的下一个需求，或者继续处理我们队列中的下一个工作项。让我们通过讨论在项目中的高级TDD（测试驱动开发）及其适用时机来结束这一章节。
- en: When to use Test-Driven Development
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用测试驱动开发
- en: TDD is not always a good match for every task. Some tasks, such as highly visual
    user interface design may not fit into the TDD workflow very well, while others
    such as fixing an error observed in production or adding a new special case to
    a calculation are almost ideal for TDD.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）并不总是适合每个任务。有些任务，如高度可视的用户界面设计可能不太适合TDD（测试驱动开发）的工作流程，而其他任务，如修复在生产中观察到的错误或向计算中添加新的特殊情况，几乎非常适合TDD（测试驱动开发）。
- en: Using TDD results in code that is generally easier to understand, has perfect
    or near-perfect code coverage on tests, and encourages refactoring along the way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD（测试驱动开发）的结果是代码通常更容易理解，测试覆盖率完美或接近完美，并且鼓励在开发过程中进行重构。
- en: Many developers follow TDD but don’t follow it as strictly as outlined in this
    chapter. For example, instead of just generating a method, they may go ahead and
    implement the method and write additional argument validation code not required
    by their specific test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者遵循TDD（测试驱动开发），但并不像本章所述那样严格。例如，他们可能不会仅仅生成一个方法，而是会继续实现该方法并编写额外的参数验证代码，而这些代码并不是他们特定测试所必需的。
- en: Such deviations from TDD are common and often acceptable, though they usually
    result in a few pieces of code being added that don’t have supporting tests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对TDD（测试驱动开发）的偏离很常见，通常也是可接受的，尽管这通常会导致添加一些没有支持测试的代码。
- en: Ultimately, it’s up to you and your team to determine what works best for you
    and the work that you do, but I can tell you that projects I work on where TDD
    is possible tend to rapidly reach better quality levels, encourage more refactoring,
    and have better long-term success.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这取决于你和你团队决定什么最适合你们的工作，但我可以告诉你，我在其中使用TDD（测试驱动开发）的项目往往能迅速达到更高的质量水平，鼓励更多的重构，并且有更好的长期成功。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered Test-Driven Development (TDD) and showed how its
    process involves writing only the minimum possible amount of code to get to a
    failing test – make that test pass with the minimum amount of code needed – then,
    refactor all code as needed before moving on to the next requirement or work item.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了测试驱动开发（TDD）并展示了其过程，即只编写最少的代码来达到一个失败的测试——用最少的代码使测试通过——然后，在继续下一个需求或工作项之前，根据需要重构所有代码。
- en: We also saw how Visual Studio has Quick Actions that allow you to generate types,
    properties, and methods and support your efforts in following TDD.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了 Visual Studio 中的快速操作功能，这些功能允许你生成类型、属性和方法，并支持你遵循 TDD 的努力。
- en: In the next chapter, we’ll talk about anti-patterns that can lead to unmaintainable
    code and SOLID principles that help your code be robust and maintainable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论可能导致代码难以维护的反模式和有助于使你的代码健壮且易于维护的 SOLID 原则。
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What areas of your code would be a good fit for using TDD?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你代码的哪些领域适合使用 TDD？
- en: What areas might be harder to apply TDD to?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些领域可能更难应用 TDD？
- en: Further reading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about materials discussed in this chapter at
    this URL:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址找到关于本章讨论的材料更多信息：
- en: '*Test-Driven Development* *Walkthrough:* [https://learn.microsoft.com/en-us/visualstudio/test/quick-start-test-driven-development-with-test-explorer](https://learn.microsoft.com/en-us/visualstudio/test/quick-start-test-driven-development-with-test-explorer)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试驱动开发（TDD）入门指南*：[https://learn.microsoft.com/en-us/visualstudio/test/quick-start-test-driven-development-with-test-explorer](https://learn.microsoft.com/en-us/visualstudio/test/quick-start-test-driven-development-with-test-explorer)'
- en: '*Is TDD* *Dead?*: [https://martinfowler.com/articles/is-tdd-dead/](https://martinfowler.com/articles/is-tdd-dead/)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TDD 是否已死？*：[https://martinfowler.com/articles/is-tdd-dead/](https://martinfowler.com/articles/is-tdd-dead/)'
