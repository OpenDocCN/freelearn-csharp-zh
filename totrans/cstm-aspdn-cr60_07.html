<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor111"/>Chapter 7</em>: Using IHostedService and BackgroundService</h1>
			<p>This seventh chapter isn't really about customization; it's more about a feature you can use to create background services to run tasks asynchronously inside your application. I use this feature to regularly fetch data from a remote service in a small ASP.NET Core application. </p>
			<p>We'll examine the following topics:</p>
			<ul>
				<li>Introducing <strong class="source-inline">IHostedService</strong></li>
				<li>Introducing <strong class="source-inline">BackgroundService</strong></li>
				<li>Implementing the new Worker Service projects</li>
			</ul>
			<p>The topics of this chapter refer to the Host layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_7.1_B17996.jpg" alt="Figure 7.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor112"/>Technical requirements</h1>
			<p>T<a id="_idTextAnchor113"/>o follow the descriptions in this chapter, you will need to create an ASP.NET Core application. Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new mvc -n HostedServiceSample -o HostedServiceSample</p>
			<p>Now open the project in Visual Studio by double-clicking the project file or in VS Code by changing the folder to the project and typing the following command in the already open console:</p>
			<p class="source-code">cd HostedServiceSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the GitHub repo for this book: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-65">I<a id="_idTextAnchor114"/><a id="_idTextAnchor115"/>ntroducing IHostedService</h1>
			<p>Hosted services have been a thing since ASP.NET Core 2.0 and can be used to run tasks asynchronously in <a id="_idIndexMarker092"/>the background of your application. They can be used to fetch data periodically, do some calculations in the background, or do some cleanup. You can also use them to send preconfigured emails – or whatever you need to do in the background.</p>
			<p>Hosted services are basically simple classes that implement the <strong class="source-inline">IHostedService</strong> interface. You call them with the following code:</p>
			<p class="source-code">public class SampleHostedService : IHostedService</p>
			<p class="source-code">{</p>
			<p class="source-code">    public Task StartAsync(CancellationToken </p>
			<p class="source-code">      cancellationToken)</p>
			<p class="source-code">    {</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public Task StopAsync(CancellationToken </p>
			<p class="source-code">     cancellationToken)</p>
			<p class="source-code">    {</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">IHostedService</strong> needs to implement a <strong class="source-inline">StartAsync()</strong> method and a <strong class="source-inline">StopAsync()</strong> method. The <strong class="source-inline">StartAsync()</strong> method is the place where you implement the logic to execute. This method gets executed once, immediately after the application starts. The <strong class="source-inline">StopAsync()</strong> method, on the other hand, gets executed just before the application <a id="_idIndexMarker093"/>stops. This also means that to start a scheduled service, you will need to implement it on your own. You will need to implement a loop that executes the code regularly.</p>
			<p>To execute a <strong class="source-inline">IHostedService</strong>, you will need to register it in the ASP.NET Core dependency injection container as a singleton instance:</p>
			<p class="source-code">builder.Services.AddSingleton&lt;IHostedService, SampleHostedService&gt;();</p>
			<p>The next sample shows you how hosted services work. It writes a log message to the console on start, on stop, and every 2 seconds:</p>
			<ol>
				<li>First, write the class skeleton that retrieves <strong class="source-inline">ILogger</strong> via <strong class="source-inline">DependencyInjection</strong>:<p class="source-code">namespace HostedServiceSample;</p><p class="source-code">public class SampleHostedService : IHostedService</p><p class="source-code">{</p><p class="source-code">    private readonly ILogger&lt;SampleHostedService&gt; </p><p class="source-code">      logger;</p><p class="source-code">    // inject a logger</p><p class="source-code">    public </p><p class="source-code">      SampleHostedService(ILogger&lt;SampleHostedService&gt; </p><p class="source-code">        logger)</p><p class="source-code">    {</p><p class="source-code">        this.logger = logger;</p><p class="source-code">    }</p><p class="source-code">    public Task StartAsync(CancellationToken </p><p class="source-code">      cancellationToken)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">    public Task StopAsync(CancellationToken </p><p class="source-code">      cancellationToken)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The next step is to <a id="_idIndexMarker094"/>implement the <strong class="source-inline">StopAsync</strong> method. This method is used to clean up in case you need to close connections, streams, and so on:<p class="source-code">public Task StopAsync(CancellationToken </p><p class="source-code">  cancellationToken)</p><p class="source-code">{</p><p class="source-code">    logger.LogInformation("Hosted service stopping");</p><p class="source-code">    return Task.CompletedTask;</p><p class="source-code">}</p></li>
				<li>The actual <a id="_idIndexMarker095"/>work will be done in the <strong class="source-inline">StartAsync</strong> method:<p class="source-code">public Task StartAsync(CancellationToken </p><p class="source-code">  cancellationToken)</p><p class="source-code">{</p><p class="source-code">    logger.LogInformation("Hosted service starting");</p><p class="source-code">    return Task.Factory.StartNew(async () =&gt;</p><p class="source-code">    {</p><p class="source-code">        // loop until a cancelation is requested</p><p class="source-code">        while </p><p class="source-code">         (!cancellationToken.IsCancellationRequested)</p><p class="source-code">        {</p><p class="source-code">            logger.LogInformation($"Hosted service </p><p class="source-code">              executing - {DateTime.Now}");</p><p class="source-code">            try</p><p class="source-code">            {</p><p class="source-code">                // wait for 2 seconds</p><p class="source-code">                await </p><p class="source-code">                 Task.Delay(TimeSpan.FromSeconds(2), </p><p class="source-code">                   cancellationToken);</p><p class="source-code">            }</p><p class="source-code">            catch (OperationCanceledException) { }</p><p class="source-code">        }</p><p class="source-code">    }, cancellationToken);</p><p class="source-code">}</p></li>
				<li>To test this, start the application by calling the following command in the console:<p class="source-code"><strong class="bold">dotnet run</strong></p><p>Or press <em class="italic">F5</em> in Visual <a id="_idIndexMarker096"/>Studio or VS Code. This results in the following console output:</p></li>
			</ol>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_7.2_B17996.jpg" alt="Figure 7.2 – A screenshot of the dotnet run output"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – A screenshot of the dotnet run output</p>
			<p>As you can see, the log output is written to the console every 2 seconds. </p>
			<p>In the next section, we will look at <strong class="source-inline">BackgroundServic<a id="_idTextAnchor116"/><a id="_idTextAnchor117"/>e</strong>.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor118"/>Introducing BackgroundService</h1>
			<p>The <strong class="source-inline">BackgroundService</strong> class was introduced in ASP.NET Core 3.0 and is basically an abstract class that <a id="_idIndexMarker097"/>implements the <strong class="source-inline">IHostedService</strong> interface. It also provides an abstract method, called <strong class="source-inline">ExecuteAsync()</strong>, which returns a <strong class="source-inline">Task</strong>.</p>
			<p>If you want to reuse the hosted service from the last section, the code will need to be rewritten. Follow these steps to learn how:</p>
			<ol>
				<li value="1">First, write the class skeleton that retrieves <strong class="source-inline">ILogger</strong> via <strong class="source-inline">DependencyInjection</strong>:<p class="source-code">namespace HostedServiceSample;</p><p class="source-code">public class SampleBackgroundService : </p><p class="source-code">  BackgroundService</p><p class="source-code">{</p><p class="source-code">    private readonly ILogger&lt;SampleHostedService&gt; </p><p class="source-code">      logger;</p><p class="source-code">    // inject a logger</p><p class="source-code">    public SampleBackgroundService(</p><p class="source-code">        ILogger&lt;SampleHostedService&gt; logger)</p><p class="source-code">    {</p><p class="source-code">        this.logger = logger;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The next step would be to override the <strong class="source-inline">StopAsync</strong> method:<p class="source-code">public override async Task StopAsync(CancellationToken </p><p class="source-code">  cancellationToken)</p><p class="source-code">{</p><p class="source-code">    logger.LogInformation("Background service </p><p class="source-code">      stopping");</p><p class="source-code">    await Task.CompletedTask;</p><p class="source-code">}</p></li>
				<li>In the final step, we will <a id="_idIndexMarker098"/>override the <strong class="source-inline">ExecuteAsync</strong> method that does all the work:<p class="source-code">protected override async Task </p><p class="source-code">  ExecuteAsync(CancellationToken cancellationToken)</p><p class="source-code">{</p><p class="source-code">    logger.LogInformation("Background service </p><p class="source-code">      starting");</p><p class="source-code">    await Task.Factory.StartNew(async () =&gt;</p><p class="source-code">    {</p><p class="source-code">        while </p><p class="source-code">          (!cancellationToken.IsCancellationRequested)</p><p class="source-code">        {</p><p class="source-code">            logger.LogInformation($"Background service </p><p class="source-code">              executing - {DateTime.Now}");</p><p class="source-code">            try</p><p class="source-code">            {</p><p class="source-code">                await </p><p class="source-code">                  Task.Delay(TimeSpan.FromSeconds(2), </p><p class="source-code">                    cancellationToken);</p><p class="source-code">            }</p><p class="source-code">            catch (OperationCanceledException) {}</p><p class="source-code">        }</p><p class="source-code">    }, cancellationToken);</p><p class="source-code">}</p><p>Even the registration is new.</p></li>
			</ol>
			<p>Additionally, in ASP.NET Core 3.0 and later, the <strong class="source-inline">ServiceCollection</strong> has a new extension method <a id="_idIndexMarker099"/>to register hosted services or a background worker:</p>
			<p class="source-code">builder.Services.AddHostedService&lt;SampleBackgroundService&gt;();</p>
			<p>To test this, start the application by calling the following command in the console:</p>
			<p class="source-code"><strong class="bold">dotnet run</strong></p>
			<p>Or press <em class="italic">F5</em> in Visual Studio or VS Code. It should show almost the same output as the <strong class="source-inline">SampleHostedService</strong> you created in the previous section.</p>
			<p>Next, let's take a look at Worker Service proj<a id="_idTextAnchor119"/><a id="_idTextAnchor120"/>ects.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor121"/>Implementing the new Worker Service projects</h1>
			<p>The <strong class="bold">worker services</strong> and the generic hosting in ASP.NET Core 3.0 and later make it pretty easy to create <a id="_idIndexMarker100"/>simple service-like applications that can do some stuff without the full-blown ASP.NET stack – and without a web server.</p>
			<p>You can create this project with the following command:</p>
			<p class="source-code">dotnet new worker -n BackgroundServiceSample -o BackgroundServiceSample</p>
			<p>Basically, this creates a console application with a <strong class="source-inline">Program.cs</strong> and a <strong class="source-inline">Worker.cs</strong> file in it. The <strong class="source-inline">Worker.cs</strong> file contains the <strong class="source-inline">Worker</strong> class that inherits from the <strong class="source-inline">BackgroundService</strong> class. In ASP.NET 5.0 and earlier, the <strong class="source-inline">Program.cs</strong> file looks pretty familiar <a id="_idIndexMarker101"/>to what we saw in the previous versions of ASP.NET Core but without a <strong class="source-inline">WebHostBuilder</strong>:</p>
			<p class="source-code">public class Program</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static void Main(string[] args)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        CreateHostBuilder(args).Build().Run();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static IHostBuilder CreateHostBuilder(string[] </p>
			<p class="source-code">      args) =&gt;</p>
			<p class="source-code">        Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">            .ConfigureServices((hostContext, services) =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                services.AddHostedService&lt;Worker&gt;();</p>
			<p class="source-code">            });</p>
			<p class="source-code">}</p>
			<p>In ASP.NET Core 6.0, <strong class="source-inline">Program.cs</strong> is pretty simplified in the same way as the minimal APIs. It looks like this:</p>
			<p class="source-code">using BackgroundServiceSample;</p>
			<p class="source-code">IHost host = Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">    .ConfigureServices(services =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        services.AddHostedService&lt;Worker&gt;();</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .Build();</p>
			<p class="source-code">await host.RunAsync();</p>
			<p>This creates an <strong class="source-inline">IHost</strong> with dependency injection enabled. This means we can use dependency <a id="_idIndexMarker102"/>injection in any kind of .NET Core application, and not only in ASP.NET Core applications.</p>
			<p>Then the worker is added to the service collection.</p>
			<p>Where is this useful? You can run this app as a Windows service or as a background application in a Docker container, which doesn't need an HTTP e<a id="_idTextAnchor122"/>ndpoint.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor123"/>Summary</h1>
			<p>You can now start to do some more complex things with an <strong class="source-inline">IHostedService</strong> and the <strong class="source-inline">BackgroundService</strong>. Be careful with background services because they all run in the same application; if you use too much CPU or memory, this could slow down your application.</p>
			<p>For bigger applications, I would suggest running such tasks in a separate application that is specialized for executing background tasks: a separate Docker container, a <strong class="source-inline">BackgroundWorker</strong> on Azure, Azure Functions, or something like that. However, it should be separate from the main application in that case.</p>
			<p>In the next chapter, we will learn about middleware, and how you can use them to implement special logic on the request pipeline or serve specific logic on different paths.</p>
		</div>
	</body></html>