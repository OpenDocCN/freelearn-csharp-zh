<html><head></head><body>
<div id="_idContainer134">
<h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor379"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.2.1">Conclusion</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As you saw while reading the book, there are many data structures with many configuration variants. </span><span class="koboSpan" id="kobo.3.2">Thus, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">choosing a proper data structure is not an easy task</span></strong><span class="koboSpan" id="kobo.5.1">, which could have a significant impact on the performance of the developed solution. </span><span class="koboSpan" id="kobo.5.2">Even the topics mentioned in this book form quite a long list of described data structures. </span><span class="koboSpan" id="kobo.5.3">For this reason, it is a good idea to classify them in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">some way.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Within this chapter, the described data structures are grouped into linear and non-linear categories. </span><span class="koboSpan" id="kobo.7.2">Each element in a </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">linear data structure</span></strong><span class="koboSpan" id="kobo.9.1"> can be logically adjacent to the following or the previous element. </span><span class="koboSpan" id="kobo.9.2">In the case of a </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">nonlinear data structure</span></strong><span class="koboSpan" id="kobo.11.1">, a single element can be logically adjacent to numerous others, not necessarily only one </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">or two.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">As it is the last chapter of the book, we will also summarize all of the gathered knowledge. </span><span class="koboSpan" id="kobo.13.2">Each data structure will be presented with a brief description, and some of them will be also shown with illustrations to help you remember </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this information.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, the following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">be covered:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Classification</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Arrays</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Lists</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Stacks</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Queues</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Dictionaries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Sets</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Trees</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Graphs</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">last word</span></span></li>
</ul>
<h1 id="_idParaDest-181"><a id="_idTextAnchor381"/><span class="koboSpan" id="kobo.28.1">Classification</span></h1>
<p><span class="koboSpan" id="kobo.29.1">I will start with a classification </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.30.1">of the data structures shown already in the book. </span><span class="koboSpan" id="kobo.30.2">The classification divides all structures into linear and </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">non-linear ones.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">linear data structure</span></strong><span class="koboSpan" id="kobo.34.1"> means</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.35.1"> that </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">each element can be logically adjacent to the following or the previous element</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">There are several data structures that follow this rule, such as arrays, lists, stacks, and queues. </span><span class="koboSpan" id="kobo.37.3">Of course, you should also take care of various subtypes of the mentioned </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.38.1">data structures, such as four variants of a linked list, which is a subtype of </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">a list.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">non-linear data structure</span></strong><span class="koboSpan" id="kobo.42.1"> indicates that </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">a single element can be logically adjacent to numerous others, not necessarily only one or two</span></strong><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">They can be freely distributed</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.45.1"> throughout the memory. </span><span class="koboSpan" id="kobo.45.2">Of course, graph-based data structures, including</span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.46.1"> trees, are included in this group. </span><span class="koboSpan" id="kobo.46.2">Trees include binary trees, tries, and heaps, while a binary search tree is a subtype of a binary tree. </span><span class="koboSpan" id="kobo.46.3">In a similar way, you can describe the relationships of other data structures presented and explained in </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">The mentioned classification is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.50.1"><img alt="Figure 10.1 – Classification of data structures into linear and non-linear ones" src="image/B18069_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.51.1">Figure 10.1 – Classification of data structures into linear and non-linear ones</span></p>
<p><span class="koboSpan" id="kobo.52.1">Do you remember all of the data structures shown in the book? </span><span class="koboSpan" id="kobo.52.2">Due to the high number of described topics, it is a good idea to take a look at the following data structures once again. </span><span class="koboSpan" id="kobo.52.3">The associated</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.53.1"> algorithms will be mentioned, as well. </span><span class="koboSpan" id="kobo.53.2">The remaining part of this chapter is a brief summary with information about some </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">real-world applicat</span><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.55.1">i</span><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.56.1">ons.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.57.1">Arrays</span></h1>
<p><span class="koboSpan" id="kobo.58.1">Let’s start with an </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">array</span></strong><span class="koboSpan" id="kobo.60.1">, which was the main topic of </span><a href="B18069_03.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.62.1">, </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Arrays and Sorting</span></em><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">You can use this data structure to </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">store many data of the same type</span></strong><span class="koboSpan" id="kobo.66.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">int</span></strong><span class="koboSpan" id="kobo.68.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">string</span></strong><span class="koboSpan" id="kobo.70.1">, or a user-defined </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.71.1">class. </span><span class="koboSpan" id="kobo.71.2">The important assumption is that the number of elements in an array cannot be changed after initialization. </span><span class="koboSpan" id="kobo.71.3">Moreover, arrays belong to </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">random access data structures</span></strong><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">This means that you can use indices to get access to the first, the middle, the </span><em class="italic"><span class="koboSpan" id="kobo.74.1">n</span></em><span class="koboSpan" id="kobo.75.1">-th, or the last element from </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the array.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">You can benefit from a few variants of </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.78.1">arrays – namely, </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">single-dimensional</span></strong><span class="koboSpan" id="kobo.80.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">multi-dimensional</span></strong><span class="koboSpan" id="kobo.82.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">jagged arrays</span></strong><span class="koboSpan" id="kobo.84.1">, also referred to as an </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">array of arrays</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">All of these variants are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">following illustration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<span class="koboSpan" id="kobo.88.1"><img alt="Figure 10.2 – Variants of arrays" src="image/B18069_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.89.1">Figure 10.2 – Variants of arrays</span></p>
<p><span class="koboSpan" id="kobo.90.1">There are a lot of applications for arrays and, as a developer, you have probably already used this data structure many times. </span><span class="koboSpan" id="kobo.90.2">In this book, you saw how you can use it to store various data, such as the </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">names of months</span></strong><span class="koboSpan" id="kobo.92.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">multiplication table</span></strong><span class="koboSpan" id="kobo.94.1">, or even a </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">map of a game</span></strong><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">In the last case, you created a two-dimensional array with the same size as a map, where each element specified a certain type of terrain, such </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">as grass.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">There are many algorithms that perform operations on arrays. </span><span class="koboSpan" id="kobo.98.2">However, one of the most common tasks is sorting an array to arrange its elements in the correct order, either ascending or descending. </span><span class="koboSpan" id="kobo.98.3">This book focuses on seven algorithms, namely </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">selection sort</span></strong><span class="koboSpan" id="kobo.100.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">insertion sort</span></strong><span class="koboSpan" id="kobo.102.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">bubble sort</span></strong><span class="koboSpan" id="kobo.104.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">merge sort</span></strong><span class="koboSpan" id="kobo.106.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Shell sort</span></strong><span class="koboSpan" id="kobo.108.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">quicksort</span></strong><span class="koboSpan" id="kobo.110.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">heap sort</span></strong><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">Each of them </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.113.1">was described and presented in the illustration, as well as written in the C# code, together with a </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">detailed explan</span><a id="_idTextAnchor385"/><span class="koboSpan" id="kobo.115.1">ation.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.116.1">Lists</span></h1>
<p><span class="koboSpan" id="kobo.117.1">The next group of data structures are </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">lists</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">They were described in </span><a href="B18069_04.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.120.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.121.1">, </span><em class="italic"><span class="koboSpan" id="kobo.122.1">Variants of Lists</span></em><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Lists are </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.124.1">similar to arrays but make it possible to </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">dynamically increase the size of the collection</span></strong><span class="koboSpan" id="kobo.126.1">, if necessary. </span><span class="koboSpan" id="kobo.126.2">It is worth mentioning that the built-in implementation is available for the array list (</span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">ArrayList</span></strong><span class="koboSpan" id="kobo.128.1">), as well as its generic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">List</span></strong><span class="koboSpan" id="kobo.130.1">) and sorted (</span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">SortedList</span></strong><span class="koboSpan" id="kobo.132.1">) variants. </span><span class="koboSpan" id="kobo.132.2">The latter can be understood as a collection of key-value pairs, always sorted </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">by keys.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">There are a few other variants of lists, including a </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">singly linked list</span></strong><span class="koboSpan" id="kobo.136.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">doubly linked list</span></strong><span class="koboSpan" id="kobo.138.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">circular singly linked list</span></strong><span class="koboSpan" id="kobo.140.1">, and a </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">circular doubly linked list</span></strong><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">The first variant makes it possible to easily navigate from one element to the next one. </span><span class="koboSpan" id="kobo.142.3">However, it can be further expanded by allowing navigating in forward and backward directions, forming the doubly linked list. </span><span class="koboSpan" id="kobo.142.4">In the circular doubly linked list, the first node navigates to the last one in the case of backward direction, while the last node navigates to the first in the forward direction. </span><span class="koboSpan" id="kobo.142.5">It is worth noting that there is a built-in implementation of the doubly linked list (</span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">LinkedList</span></strong><span class="koboSpan" id="kobo.144.1">). </span><span class="koboSpan" id="kobo.144.2">You can quite easily extend it to behave as any circular linked list, either as a circular singly or circular doubly </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">linked list.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Various variants of lists are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">following illustration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer124">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 10.3 – Variants of lists" src="image/B18069_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 10.3 – Variants of lists</span></p>
<p><span class="koboSpan" id="kobo.150.1">There are a lot of applications for the lists to solve diverse problems in various kinds of applications. </span><span class="koboSpan" id="kobo.150.2">In this book, you saw how to utilize the list to store some floating-point values and calculate the average value, how to use this data structure to create a simple </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">database of people</span></strong><span class="koboSpan" id="kobo.152.1">, and </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.153.1">how to develop an automatically sorted </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">address book</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">Moreover, you prepared an exemplary application that allows a user to </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">read the book</span></strong><span class="koboSpan" id="kobo.157.1"> by changing the pages, as well as a game, in which the user </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">spins the wheel</span></strong><span class="koboSpan" id="kobo.159.1"> with random power. </span><span class="koboSpan" id="kobo.159.2">The wheel rotates slower and slower until it stops. </span><span class="koboSpan" id="kobo.159.3">Then, the user can spin it again, from the previous stop position, which illustrates a circular </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">link</span><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.161.1">e</span><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.162.1">d list.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.163.1">Stacks</span></h1>
<p><a href="B18069_05.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.165.1">, </span><em class="italic"><span class="koboSpan" id="kobo.166.1">Stacks and Queues</span></em><span class="koboSpan" id="kobo.167.1">, focused on stacks and queues. </span><span class="koboSpan" id="kobo.167.2">Now, let’s recap a </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">stack</span></strong><span class="koboSpan" id="kobo.169.1">, which is representative of </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">limited access data structures</span></strong><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">This name means that you cannot access every</span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.172.1"> element from the structure. </span><span class="koboSpan" id="kobo.172.2">So, the way of getting elements is strictly specified. </span><span class="koboSpan" id="kobo.172.3">In the case of a stack, you can only add a new element at the top (the </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">push</span></strong><span class="koboSpan" id="kobo.174.1"> operation) and get an element by removing it from the top (the </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">pop</span></strong><span class="koboSpan" id="kobo.176.1"> operation). </span><span class="koboSpan" id="kobo.176.2">For this reason, a stack is consistent with the </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">LIFO</span></strong><span class="koboSpan" id="kobo.178.1"> principle, which means </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">Last-In First-Out</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">The built-in implementation as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Stack</span></strong><span class="koboSpan" id="kobo.182.1"> class is available, </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The illustration of a stack is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.186.1"><img alt="Figure 10.4 – Illustration of a stack" src="image/B18069_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.187.1">Figure 10.4 – Illustration of a stack</span></p>
<p><span class="koboSpan" id="kobo.188.1">A stack has many real-world applications. </span><span class="koboSpan" id="kobo.188.2">One of the mentioned examples is related to a </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">pile of many plates</span></strong><span class="koboSpan" id="kobo.190.1">, each placed on top of the other. </span><span class="koboSpan" id="kobo.190.2">You can only add a new plate at the top of the pile, and you can only get a plate from the top of the pile. </span><span class="koboSpan" id="kobo.190.3">You cannot remove the seventh plate without taking the previous six from the top, and you cannot add a plate to the middle of the pile. </span><span class="koboSpan" id="kobo.190.4">You also saw how to use a stack to </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">reverse a word</span></strong><span class="koboSpan" id="kobo.192.1"> and how to apply it to solve the mathematical game </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">Tower o</span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.194.1">f Hanoi</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">That’s not all, because applications of stacks are much broader, such as for calculating mathematical expressions provided in the </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">reverse </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.197.1">Polish no</span><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.198.1">tation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor392"/><span class="koboSpan" id="kobo.200.1">Queues</span></h1>
<p><span class="koboSpan" id="kobo.201.1">Another leading subject of </span><a href="B18069_05.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.203.1">, </span><em class="italic"><span class="koboSpan" id="kobo.204.1">Stacks and Queues</span></em><span class="koboSpan" id="kobo.205.1">, was a </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">queue</span></strong><span class="koboSpan" id="kobo.207.1">. </span><span class="koboSpan" id="kobo.207.2">This is also a representative of limited access data structures. </span><span class="koboSpan" id="kobo.207.3">While using a queue, you can only add new elements at the end (the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">enqueue</span></strong><span class="koboSpan" id="kobo.209.1"> operation) and remove the element from the queue only from the </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.210.1">beginning of the queue (the </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">dequeue</span></strong><span class="koboSpan" id="kobo.212.1"> operation). </span><span class="koboSpan" id="kobo.212.2">For this reason, this data structure is consistent with the </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">FIFO</span></strong><span class="koboSpan" id="kobo.214.1"> principle, which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">First-In First-Out</span></strong><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">The built-in implementation as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">Queue</span></strong><span class="koboSpan" id="kobo.218.1"> class is available for you, </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">The illustration of a queue is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.222.1"><img alt="Figure 10.5 – Illustration of a queue" src="image/B18069_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.223.1">Figure 10.5 – Illustration of a queue</span></p>
<p><span class="koboSpan" id="kobo.224.1">It is also possible to use a </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">priority queue</span></strong><span class="koboSpan" id="kobo.226.1">, which extends the concept of a queue by setting the priority for each element. </span><span class="koboSpan" id="kobo.226.2">Thus, the dequeue operation returns the element with the highest priority, which was added earliest to the queue. </span><span class="koboSpan" id="kobo.226.3">When all elements with the highest priority are dequeued, the priority queue handles elements with the next highest priority and dequeues such elements from those </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">added earliest.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Another variant of a</span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.229.1"> queue is a </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">circular queue</span></strong><span class="koboSpan" id="kobo.231.1">, also called a </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">ring buffer</span></strong><span class="koboSpan" id="kobo.233.1">, which was also presented and explained in the book. </span><span class="koboSpan" id="kobo.233.2">Here, a queue forms a circle, internally uses an array, and the maximum number of elements that can be placed inside the queue is limited. </span><span class="koboSpan" id="kobo.233.3">You specify indices for front and rear elements in </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">this case.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">There are many real-world applications of a queue. </span><span class="koboSpan" id="kobo.235.2">For example, a queue can be used to represent a </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">line of people</span></strong><span class="koboSpan" id="kobo.237.1"> waiting in a shop at a checkout. </span><span class="koboSpan" id="kobo.237.2">New people stand at the end of the line, and the next person is taken to the checkout from the beginning of the line. </span><span class="koboSpan" id="kobo.237.3">You are not allowed to</span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.238.1"> choose a person from the middle and serve them. </span><span class="koboSpan" id="kobo.238.2">Moreover, you saw a few examples of the solution of a </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">call center</span></strong><span class="koboSpan" id="kobo.240.1">, where there are many clients and one consultant, many clients and many consultants, or many clients (with different plans, either standard or priority support) and only one consultant, who answers the wait</span><a id="_idTextAnchor393"/><span class="koboSpan" id="kobo.241.1">ing calls. </span><span class="koboSpan" id="kobo.241.2">Another group of queue applications was shown while presenting </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">graph-based algorithms</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">A queue was used in the </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">breadth-first search</span></strong><span class="koboSpan" id="kobo.245.1"> algorithm for traversing a graph or for searching for a given value in a graph. </span><span class="koboSpan" id="kobo.245.2">A priority queue was applied in </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Dijkstra’s algorithm</span></strong><span class="koboSpan" id="kobo.247.1"> for searching the shortest path in</span><a id="_idTextAnchor394"/> <span class="No-Break"><span class="koboSpan" id="kobo.248.1">a graph.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.249.1">Dictionaries</span></h1>
<p><span class="koboSpan" id="kobo.250.1">The topic of </span><a href="B18069_06.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.251.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.252.1">, </span><em class="italic"><span class="koboSpan" id="kobo.253.1">Dictionaries and Sets</span></em><span class="koboSpan" id="kobo.254.1">, was related to dictionaries and sets. </span><span class="koboSpan" id="kobo.254.2">First, let’s recap a </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">dictionary</span></strong><span class="koboSpan" id="kobo.256.1">, which allows </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">mapping keys to values and performing fast lookups</span></strong><span class="koboSpan" id="kobo.258.1">. </span><span class="koboSpan" id="kobo.258.2">A dictionary uses a hash function and can be understood as a collection of pairs, each consisting </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.259.1">of a key and </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">a value.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">There are two built-in versions of a dictionary – non-generic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Hashtable</span></strong><span class="koboSpan" id="kobo.263.1">) and generic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Dictionary</span></strong><span class="koboSpan" id="kobo.265.1">). </span><span class="koboSpan" id="kobo.265.2">The sorted variant of a dictionary (</span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.267.1">) is available, as well. </span><span class="koboSpan" id="kobo.267.2">All of them were described </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">in detail.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">The mechanism of a hash table is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">following illustration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<span class="koboSpan" id="kobo.271.1"><img alt="Figure 10.6 – Illustration of mapping keys to particular values" src="image/B18069_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.272.1">Figure 10.6 – Illustration of mapping keys to particular values</span></p>
<p><span class="koboSpan" id="kobo.273.1">Due to the great performance of the hash table, such a data structure is frequently used in many real-world applications, such as for </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">associative arrays</span></strong><span class="koboSpan" id="kobo.275.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">database indices</span></strong><span class="koboSpan" id="kobo.277.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">cache systems</span></strong><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">Within this book, you saw how to create a </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">phone book</span></strong><span class="koboSpan" id="kobo.281.1"> to store entries where a person’s name is a key and a phone number is a value. </span><span class="koboSpan" id="kobo.281.2">Among other examples, you developed an application that helps employees of shops </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">find the location</span></strong><span class="koboSpan" id="kobo.283.1"> of where a </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.284.1">product should be placed, and you applied the sorted dictionary to create a simple </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">encyclopedia</span></strong><span class="koboSpan" id="kobo.286.1">, where a user can </span><a id="_idTextAnchor396"/><span class="No-Break"><span class="koboSpan" id="kobo.287.1">ad</span><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.288.1">d entries.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor398"/><span class="koboSpan" id="kobo.289.1">Sets</span></h1>
<p><span class="koboSpan" id="kobo.290.1">Another data structure from </span><a href="B18069_06.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.291.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.292.1">, </span><em class="italic"><span class="koboSpan" id="kobo.293.1">Dictionaries and Sets</span></em><span class="koboSpan" id="kobo.294.1">, is a </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">set</span></strong><span class="koboSpan" id="kobo.296.1">, which is a </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">collection of distinct objects without duplicated elements and without any particular order</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">Therefore, you can only get to know whether a given element is in the set or not. </span><span class="koboSpan" id="kobo.298.3">The sets are strictly connected with </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.299.1">mathematical models and operations, such as </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">union</span></strong><span class="koboSpan" id="kobo.301.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">intersection</span></strong><span class="koboSpan" id="kobo.303.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">subtraction</span></strong><span class="koboSpan" id="kobo.305.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.306.1">symmetric difference</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">The exemplary sets, storing data of various types, are shown </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.310.1"><img alt="Figure 10.7 – Illustration of sets with integer and string values" src="image/B18069_10_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.311.1">Figure 10.7 – Illustration of sets with integer and string values</span></p>
<p><span class="koboSpan" id="kobo.312.1">While developing applications in the C# language, you can benefit from high-performance set-related operations provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">HashSet</span></strong><span class="koboSpan" id="kobo.314.1"> class. </span><span class="koboSpan" id="kobo.314.2">As an example, you saw how to create a system that handles </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">one-time promotional coupons</span></strong><span class="koboSpan" id="kobo.316.1"> and allows you to check whether the scanned one was already used. </span><span class="koboSpan" id="kobo.316.2">Another example was the </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">reporting service</span></strong><span class="koboSpan" id="kobo.318.1"> for </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.319.1">the system of a SPA center with four swimming pools. </span><span class="koboSpan" id="kobo.319.2">By using sets, you calculated statistics, such as the number of visitors to a pool, the most popular pool, and the number of people who visited at lea</span><a id="_idTextAnchor399"/><span class="koboSpan" id="kobo.320.1">s</span><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.321.1">t </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">one pool.</span></span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.323.1">Trees</span></h1>
<p><span class="koboSpan" id="kobo.324.1">The next topic is about </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">trees</span></strong><span class="koboSpan" id="kobo.326.1">, which were </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.327.1">the subject of </span><a href="B18069_07.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.328.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.329.1">, </span><em class="italic"><span class="koboSpan" id="kobo.330.1">Variants of Trees</span></em><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">A tree consists of </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">nodes</span></strong><span class="koboSpan" id="kobo.333.1"> with one </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">root</span></strong><span class="koboSpan" id="kobo.335.1">. </span><span class="koboSpan" id="kobo.335.2">The root contains no </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">parent</span></strong><span class="koboSpan" id="kobo.337.1"> node, while all other nodes do. </span><span class="koboSpan" id="kobo.337.2">Moreover, each node can have any number of </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">child nodes</span></strong><span class="koboSpan" id="kobo.339.1">. </span><span class="koboSpan" id="kobo.339.2">The child </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.340.1">nodes of the same parent can be called </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">siblings</span></strong><span class="koboSpan" id="kobo.342.1">, while a node without children is called a </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">leaf</span></strong><span class="koboSpan" id="kobo.344.1">. </span></p>
<p><span class="koboSpan" id="kobo.345.1">An exemplary tree is </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.347.1"><img alt="Figure 10.8 – Illustration of a tree" src="image/B18069_10_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.348.1">Figure 10.8 – Illustration of a tree</span></p>
<p><span class="koboSpan" id="kobo.349.1">A tree is a data structure that is great for the representation of various data, such as the </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">structure of a company</span></strong><span class="koboSpan" id="kobo.351.1">, divided into a few departments, where each has its own structure. </span><span class="koboSpan" id="kobo.351.2">You also saw an example where a tree was used to arrange a </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">simple quiz</span></strong><span class="koboSpan" id="kobo.353.1"> consisting of a few questions and answers, which are shown depending on the previously </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">ta</span><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.355.1">ken decisions.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Generally speaking, each node</span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.357.1"> in a tree can contain any number of children. </span><span class="koboSpan" id="kobo.357.2">However, in the case of </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">binary trees</span></strong><span class="koboSpan" id="kobo.359.1">, a node cannot contain more than two children – that is, it can contain no child nodes, or only one or two. </span><span class="koboSpan" id="kobo.359.2">However, there are no rules about relationships between the nodes. </span><span class="koboSpan" id="kobo.359.3">The exemplary binary trees are </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.361.1"><img alt="Figure 10.9 – Illustration of a binary tree and a binary search tree" src="image/B18069_10_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.362.1">Figure 10.9 – Illustration of a binary tree and a binary search tree</span></p>
<p><span class="koboSpan" id="kobo.363.1">If you want to use a </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">binary search tree</span></strong><span class="koboSpan" id="kobo.365.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.366.1">BST</span></strong><span class="koboSpan" id="kobo.367.1">), the next</span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.368.1"> rule is introduced. </span><span class="koboSpan" id="kobo.368.2">It states that, for any node, the values of all nodes in its left subtree must be smaller than its value, and that the values </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.369.1">of all nodes in its right subtree must be greater than its value. </span><span class="koboSpan" id="kobo.369.2">The exemplary BST is presented on the right-hand side of the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">preceding illustration.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Another group of trees is called </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">self-balancing trees</span></strong><span class="koboSpan" id="kobo.373.1">, which </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.374.1">keep a tree balanced all the time while adding and removing nodes. </span><span class="koboSpan" id="kobo.374.2">Their application is very important because it allows you to form the correctly arranged tree, which has a positive impact on performance. </span><span class="koboSpan" id="kobo.374.3">There are several variants of self-balancing trees, but </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">AVL trees</span></strong><span class="koboSpan" id="kobo.376.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">red-black trees</span></strong><span class="koboSpan" id="kobo.378.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.379.1">RBTs</span></strong><span class="koboSpan" id="kobo.380.1">) are some of the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">most popular.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">One of the tree applications is related to processing strings, such as for </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">auto-complete</span></strong><span class="koboSpan" id="kobo.384.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">spell-checker</span></strong><span class="koboSpan" id="kobo.386.1"> features. </span><span class="koboSpan" id="kobo.386.2">Here, you can benefit from another tree-based data structure – namely, a </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">trie</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">It is used to store strings and to perform prefix-based searching. </span><span class="koboSpan" id="kobo.388.3">A trie is a tree with one root node, where each node represents a string and each edge indicates a character. </span><span class="koboSpan" id="kobo.388.4">A trie node contains references to the next nodes – for example, as an array with 26 elements, representing the 26 characters from the alphabet (from </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">a</span></strong><span class="koboSpan" id="kobo.390.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">z</span></strong><span class="koboSpan" id="kobo.392.1">). </span><span class="koboSpan" id="kobo.392.2">When you go from the root to each node, you receive a string, which is either a saved word or its substring, as presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">following illustration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.394.1"><img alt="Figure 10.10 – Illustration of a trie" src="image/B18069_10_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.395.1">Figure 10.10 – Illustration of a trie</span></p>
<p><span class="koboSpan" id="kobo.396.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">heap</span></strong><span class="koboSpan" id="kobo.398.1"> is another subtype of a tree and exists in many variants, including a </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">binary heap</span></strong><span class="koboSpan" id="kobo.400.1">. </span><span class="koboSpan" id="kobo.400.2">It contains two versions – namely, </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">min-heap</span></strong><span class="koboSpan" id="kobo.402.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">max-heap</span></strong><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">For each of them, the additional property must be satisfied. </span><span class="koboSpan" id="kobo.404.3">For the min-heap, the value of each node must be greater than or equal to the value of its parent node. </span><span class="koboSpan" id="kobo.404.4">Thus, the root node contains the smallest </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.405.1">value. </span><span class="koboSpan" id="kobo.405.2">For the max-heap, the value of each node must be less than or equal to the value of its parent node. </span><span class="koboSpan" id="kobo.405.3">Therefore, the root node always contains the largest value. </span><span class="koboSpan" id="kobo.405.4">The exemplary binary heaps are shown </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.407.1"><img alt="Figure 10.11 – Illustration of a min-heap and max-heap" src="image/B18069_10_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.408.1">Figure 10.11 – Illustration of a min-heap and max-heap</span></p>
<p><span class="koboSpan" id="kobo.409.1">A heap is a convenient data structure for implementing a </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">priority queue</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">Another interesting application is </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.412.1">the sorting algorithm</span><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.413.1">, named </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">heap sort</span></strong><span class="koboSpan" id="kobo.415.1">, which was presented and explained in the chapter regarding arra</span><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.416.1">ys </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">and sorting.</span></span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.418.1">Graphs</span></h1>
<p><a href="B18069_08.xhtml#_idTextAnchor296"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.419.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.420.1">, </span><em class="italic"><span class="koboSpan" id="kobo.421.1">Exploring Graphs</span></em><span class="koboSpan" id="kobo.422.1">, was related to </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">graphs</span></strong><span class="koboSpan" id="kobo.424.1"> – a very popular data structure with a broad range of applications. </span><span class="koboSpan" id="kobo.424.2">As a reminder, a graph is a data structure that consists of </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">nodes</span></strong><span class="koboSpan" id="kobo.426.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">edges</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">Each edge connects two nodes. </span><span class="koboSpan" id="kobo.428.3">There are a few variants of edges in a graph, such as</span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.429.1"> undirected and directed, as well as unweighted and weighted. </span><span class="koboSpan" id="kobo.429.2">A graph can be represented as an adjacency list or as an </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">adjacency matrix.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">All of these topics were described in the book, together with the problem of graph</span><strong class="bold"><span class="koboSpan" id="kobo.432.1"> traversal</span></strong><span class="koboSpan" id="kobo.433.1"> with breadth-first search and depth-first search algorithms, finding the </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">minimum spanning tree</span></strong><span class="koboSpan" id="kobo.435.1"> with Kruskal’s and Prim’s algorithms, </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">node coloring</span></strong><span class="koboSpan" id="kobo.437.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">finding the shortest path</span></strong><span class="koboSpan" id="kobo.439.1"> in a graph with </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">Dijkstra’s algorithm.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">The exemplary graphs are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">following illustration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.443.1"><img alt="Figure 10.12 – Illustration of graphs" src="image/B18069_10_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.444.1">Figure 10.12 – Illustration of graphs</span></p>
<p><span class="koboSpan" id="kobo.445.1">A graph data structure is commonly used in various applications. </span><span class="koboSpan" id="kobo.445.2">It is also a great way to represent diverse data, such as the </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">structure of friends</span></strong><span class="koboSpan" id="kobo.447.1"> available on a social media site. </span><span class="koboSpan" id="kobo.447.2">Here, the nodes can represent contacts, while edges represent relationships between people. </span><span class="koboSpan" id="kobo.447.3">Thus, you</span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.448.1"> can easily check whether two contacts know each other or how many people should be involved to arrange a meeting between two </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">particular people.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">Another common application of graphs involves the problem of </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">finding a path</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">As an example, you can use a graph to find a path between two points in the city, taking into account the distance or time necessary for driving. </span><span class="koboSpan" id="kobo.452.3">You can use a graph to represent a map of a city, where nodes are intersections and edges represent roads. </span><span class="koboSpan" id="kobo.452.4">You can assign weights to edges to indicate the necessary distance or time for driving a </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">given road.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">There are many other applications related to graphs. </span><span class="koboSpan" id="kobo.454.2">For instance, the minimum spanning tree can be used to create a </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">plan of connections between buildings</span></strong><span class="koboSpan" id="kobo.456.1"> to supply all of them with a telecommunication cable at the smallest cost. </span><span class="koboSpan" id="kobo.456.2">The node coloring problem was used in the book for </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">coloring voivodeships</span></strong><span class="koboSpan" id="kobo.458.1"> on a map of Poland according to the rule that two voivodeships that have common borders cannot have the same color. </span><span class="koboSpan" id="kobo.458.2">Another shown example involves Dijkstra’s algorithm for finding </span><strong class="bold"><span class="koboSpan" id="kobo.459.1">the shortest path in a game map</span></strong><span class="koboSpan" id="kobo.460.1">, taking into account </span><a id="_idTextAnchor406"/><span class="No-Break"><span class="koboSpan" id="kobo.461.1">v</span><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.462.1">arious obstacles.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.463.1">The last word</span></h1>
<p><span class="koboSpan" id="kobo.464.1">You just reached the end of the last chapter of the book. </span><span class="koboSpan" id="kobo.464.2">First, the classification of data structures was presented, taking into account linear and non-linear data structures. </span><span class="koboSpan" id="kobo.464.3">In the first group, you can find arrays, lists, stacks, and queues, while the second group involves graphs and their subtypes, including trees and heaps. </span><span class="koboSpan" id="kobo.464.4">In the following part of this chapter, the diversity of applications of various data structures was taken into account. </span><span class="koboSpan" id="kobo.464.5">You saw a short summary of each described data structure, as well as information about some problems that can be solved with the use of a particular data structure, such as a queue or a graph. </span><span class="koboSpan" id="kobo.464.6">To make the content easier to understand, as well as to remind you of the various topics from the previous chapters, the summary was equipped with brief descriptions and illustrations of </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">data structures.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">In the introduction to this book, I invited you to start your adventure with data structures and algorithms. </span><span class="koboSpan" id="kobo.466.2">While reading the following chapters, writing hundreds of lines of code, and debugging, you had a chance to familiarize yourself with various data structures, starting with arrays and lists, through stacks, queues, dictionaries, and sets, and ending with trees and graphs. </span><span class="koboSpan" id="kobo.466.3">I hope that this book is only the first step in your long, challenging, and successful adventure with data structures </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">and algorithms.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">I would like to thank you for reading this book. </span><span class="koboSpan" id="kobo.468.2">If you have any questions or problems regarding the described content, please do not hesitate to contact me directly using the contact information shown at </span><a href="https://marcin.com"><span class="koboSpan" id="kobo.469.1">https://marcin.com</span></a><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">While visiting my website, you can also find answers to many questions that you can ask during your development career. </span><span class="koboSpan" id="kobo.470.3">Please also tell me what topics are missing from this book that you want to learn about for the next edition of this book or from another of my books. </span><span class="koboSpan" id="kobo.470.4">I really hope that you will benefit from the presented content. </span><span class="koboSpan" id="kobo.470.5">I would like to wish you all the best in your career as a software developer, and I hope that you have many successful projects! </span><span class="koboSpan" id="kobo.470.6">I will be very happy if you let me know about your great projects, especially if they are inspired by the content of this book. </span><span class="koboSpan" id="kobo.470.7">Good luck and keep </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">in touch!</span></span></p>
</div>
</body></html>