- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing CLI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an important phase of any software development project. The purpose
    of testing is to ensure that the application we put into the hands of our users
    behaves as expected and doesn’t cause any harm to users (by leaking their personal
    information or by allowing malicious actors to take advantage of a security issue
    to harm users).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss why testing is so important and explore different
    testing techniques and tools that will help us achieve this goal. More specifically,
    we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why testing is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to test, how to do it, and when to run these tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to mock external dependencies when writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Why is testing so important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, testing has proven to be very valuable when it comes to providing
    great software and digital experiences to users. Any developer, team, or organization
    that is serious about their software development project and truly cares about
    their users and the experience they have when using their applications will invest
    in software testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing allows us to ensure that the applications we put into the hands of our
    users are of great quality, reliable, performant, and secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key benefits you can expect from testing your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ensuring your application’s quality, usability, and reliability**: Testing
    ensures that the application behaves as expected, meets stakeholders’ needs, adheres
    to business requirements and technical specifications, and provides value to users.
    This helps increase user (and customer) satisfaction and prevents a poorly designed
    or developed application from having a negative impact on the organization’s reputation.
    This can, for example, be achieved by validating API responses and verifying the
    output formatting of the CLI application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensuring your application’s security and compliance**: Testing plays a crucial
    role in validating the security of the application. It helps identify potential
    vulnerabilities and weaknesses that could be exploited by malicious actors. It
    also ensures that the application complies with industry standards, regulations,
    and other critical requirements that an organization (or an industry) might be
    subject to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acting as your application’s documentation**: If you have ever worked on
    IT projects, you know how hard it is to maintain accurate and up-to-date documentation.
    A by-product of software testing is that it also acts as live documentation for
    your application: you can run it at any time to understand the behavior of the
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplify the application’s evolution**: If you have ever worked on IT projects,
    you know how scary it is when you have to modify the code of an application that
    works fine. We even have a saying for that: “If it’s not broken, don’t fix it!”.
    However, by having an efficient suite of tests, modifying that code is way less
    scary because we know that we can rely on that test suite to ensure that we didn’t
    introduce any bug in the existing code and functionalities (we call these *regressions*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Achieving cost savings and efficiency**: It is well-known that the cost of
    finding and fixing a bug in production might be 100 times more expensive than
    finding it and fixing it during the development or testing phase. This cost also
    includes the cost of loss of efficiency as the team has to stop working on new
    features and concentrate on fixing that bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a book about testing!
  prefs: []
  type: TYPE_NORMAL
- en: During my career, I have coached and trained development teams, both for the
    organizations I worked for and for our customers, on testing and raising awareness
    about its importance. That’s why I couldn’t write a book about development without
    covering this topic.
  prefs: []
  type: TYPE_NORMAL
- en: However, although we will provide very valuable information and guidance throughout
    this chapter, keep in mind that this is not a book about software testing. Hence,
    concepts such as test-driven development, behavior-driven development, and code
    coverage, will not be covered.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, I provide many references in [*Chapter 14*](B22400_14.xhtml#_idTextAnchor236)
    if you want to dig into this fascinating topic.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are various types of tests. Let’s highlight them!
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a wide variety of test types. They can be classified into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional tests**: This category of tests verifies that the application
    performs its intended function, according to its specifications. In other words,
    it ensures that the application does what it is supposed to do (what it has been
    designed for).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional tests**: This category of tests verifies that the application
    does what is intended to do in a way that meets user expectations and quality
    standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these categories is composed of various types of tests. This figure
    illustrates this relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Categories and types of software tests](img/B22400_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Categories and types of software tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s briefly describe each of these types of test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: Here, we focus on testing methods in isolation (i.e., without
    relying on their dependencies such as databases or external services. To achieve
    this, we use *mocking* techniques (more on that later) to avoid relying on these
    dependencies. These tests are usually fast and provide immediate feedback. They
    therefore help ensure that a very specific portion of the code (a method) is doing
    exactly what it is intended to do. In the event that a bug is discovered, this
    type of test proves very useful as it narrows the issue down to the line of code
    that causes it! It is however important not to overuse mocks as it can lead to
    tests that do not represent reality, making them worthless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: This type of test verifies the interactions between
    different components of the application, ensuring that the integrated parts work
    together as expected. It also helps ensure that the flow of data and communication
    between these components is correct and can surface integration issues, usually
    due to interface defects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tests**: This type of test verifies that the complete application
    meets the specified requirements. This covers end-to-end functionality and behavior
    and relies on external dependencies. These tests are performed in an environment
    that is similar to the production environment (usually the staging or pre-production
    environment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance tests**: This type of test validates that the application meets
    the users’ needs and business requirements. The main difference is that acceptance
    tests are usually performed by users or stakeholders and serve as a final approval
    before going to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We just described the types of functional tests. Let’s now describe the types
    of non-functional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security tests**: This type of test is intended to reveal vulnerabilities
    and security breaches in the application and aims to protect users against data
    breaches, unauthorized access, and cyber-attacks in general.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance tests**: This type of test is intended to identify performance
    issues and bottlenecks by measuring response times and resource usage and identifying
    scalability or capacity limits under various workloads.. This provides valuable
    insights into what parts of the application require special attention, such as
    redesigning or refactoring, in order to meet the performance requirements and
    users’ expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability tests**: This type of test focuses on assessing the user-friendliness
    and ease of use of the application. This involves asking real users to test the
    application by completing tasks, gathering feedback and metrics along the way
    (such as the user experience in general, how easy it is to navigate the application,
    how long it takes to complete a task, and the user’s appreciation in general).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interactive` command, which means that the terminal it is running in is compliant
    with the requirements. We should then ensure that it works as expected when these
    requirements are met and gracefully degrades (e.g., converts to text-based output)
    when they are not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About usability tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have guessed, usability tests are intended to be performed manually.
    While it may not always be possible to gather real users together to perform these
    tests, one way to achieve this goal in the context of a CLI application is by
    implementing a command in the CLI application that allows users to provide feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is, as an example, how the Azure CLI team does it: they provide a `survey`
    command that directs the user to an online form where they can provide feedback.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Allowing users to provide feedback](img/B22400_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Allowing users to provide feedback
  prefs: []
  type: TYPE_NORMAL
- en: The pyramid of (software) testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of you may not be familiar with the concepts of functional and non-functional
    tests, but you may be familiar with the pyramid of testing. It is worth mentioning
    that this pyramid includes many of the functional and non-functional types of
    test that we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the pyramid of testing looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The pyramid of (software) testing](img/B22400_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The pyramid of (software) testing
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is presented as a pyramid is to illustrate the quantity of tests
    to be expected at each step. The larger the step, the more tests it is expected
    to contain. As an example, a project is likely to have more unit tests than system
    tests and more system tests than UAT tests. This is due to the cost of creating
    and maintaining such tests.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep in mind that what separates these various types of tests
    is their scope and their intent, not the frameworks or libraries used to implement
    them.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to keep in mind that you can create your own types of tests
    if you need to. Let me give you some examples.
  prefs: []
  type: TYPE_NORMAL
- en: About custom types of tests
  prefs: []
  type: TYPE_NORMAL
- en: In my career, I have worked with organizations that had their own custom types
    of tests that suited their needs and policies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some organizations may have *architectural tests*, which are tests
    written to ensure that an application (and its components) are developed following
    their architectural standards, such as what components can reference what components,
    ensure that every service class exposes an interface, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of test I have seen can be referred to as *naming conventions tests*.
    These tests are meant to ensure that every component (such as classes, services
    or libraries) is named according to the organization’s naming conventions and
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: These two types of tests are intended to simplify the code review process and
    can be automated as part of validating a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a better understanding of the various types of tests. The next
    logical question (the one that I get every time I discuss software testing with
    clients) is: *“What should we test?”* Let’s discuss this now.'
  prefs: []
  type: TYPE_NORMAL
- en: What should we test?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a great question!
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to say that you should test every possible scenario in your application.
    However, we need to consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you define “every scenario”?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you really test “every scenario”? How many tests does that mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a nutshell, your suite of tests should cover both of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The happy path**: This means testing the situation in which the required
    input for your application is provided and is in the expected format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The unhappy path**: Here, we test the behavior of the application under unexpected
    circumstances, such as input in the wrong format, user errors, network issues
    (when relying on external dependencies), the user canceling a task, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, this is not a book about software testing, but I would like to
    give you some guidance on what to test in different situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input parameters** | Test both valid and invalid values.As an example,
    if a method takes only one integer parameter, and the range of valid values is
    between 1 and 100, we should also test it with values outside of this range, such
    as `-1`, `0`, and `2000` (we usually call these `"bonjour"` or `1.23`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Lists** | When dealing with lists, we should ensure that the list only
    contains the expected elements, no more, no less. It is not sufficient to check
    the number of elements in the list because if a bug in the code inserts an element
    more than once or inserts inappropriate elements, the count could meet the expected
    value, but the list might not contain the appropriate elements. |'
  prefs: []
  type: TYPE_TB
- en: '| **Exceptions** | If the application throws exceptions, this should be tested
    too to ensure that the right type of exception is thrown and with the expected
    details. |'
  prefs: []
  type: TYPE_TB
- en: '| **Methods/services** **returned values** | It is easy to verify that a numerical
    or string value matches the expected value, but if the return value is an object
    (or a list of objects), we should verify that the values of all meaningful properties
    match the expected ones. |'
  prefs: []
  type: TYPE_TB
- en: '| **Methods/services** **behavior** | While most developers verify the returned
    values of their methods or services when implementing tests, they fail at verifying
    that these methods or services behave as expected.Verifying the behavior of a
    method or service means that we need to ensure that:'
  prefs: []
  type: TYPE_NORMAL
- en: The correct subsequent methods are called with the expected parameters. These
    could be logging or caching methods or calls to external dependencies such as
    database or external APIs for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state changes within the object, the class, or the service are accurate
    and expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects, such as database updates or changes to files, are accurate and
    expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idempotency occurs when appropriate, which means that if the same method is
    called more than once, it maintains the coherence of the system. Think of a method
    that performs a call to a payment gateway or to a reservation system. We certainly
    don’t want the customer to be charged twice for the same purchase, nor for multiple
    reservations to be made for the same appointment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – What to test
  prefs: []
  type: TYPE_NORMAL
- en: It is just as important to know what to test as it is to know what *not* to
    test.
  prefs: []
  type: TYPE_NORMAL
- en: What not to test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should not test external frameworks and libraries because this is the responsibility
    of their creators and maintainers. It is very likely that they have already been
    tested before you had a chance to use them. So, don’t do this, please!
  prefs: []
  type: TYPE_NORMAL
- en: Other code artifacts that do not need to be tested are model classes and **Data
    Transfer Objects** (**DTOs**) as they are supposed to only contain properties,
    not methods, since they do not perform any processing of any kind, only move data
    around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you may have heard that it is not recommended to test private methods.
    There is a heated debate about whether we should test private methods. My personal
    opinion is that you should not, for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A private method is intended to be invoked by at least one public method**:
    Hence, when testing that public method, you are also testing the private one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object` to pass parameters to it. It is hence very easy to break these tests
    at runtime (they will compile, though) since the name of the method is usually
    passed as a string, and since every data type inherits from the `Object` class,
    if we change the data type or structure for a given parameter, it will still inherit
    from that same base class even though it is not expected by the private method
    anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is a safety net
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I tell my customers and students, a test suite is like a safety net:'
  prefs: []
  type: TYPE_NORMAL
- en: The more test cases you cover, the wider the safety net. If you fall from 30
    feet and your safety net is 2 inches by 2 inches, the chances are that it won’t
    help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, if you have a safety net that is 50 feet by 50 feet but its
    meshes are 3 feet by 3 feet large, it won’t help either. What I mean here is that
    if you have an extensive test suite in terms of a number of tests, but these tests
    do not cover meaningful situations, your test suite is of no use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we are now aware of the different types of tests, and we know what to test.
    But when should we run these tests? Let’s discuss this.
  prefs: []
  type: TYPE_NORMAL
- en: When should we run tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The various types of tests we discussed are intended to be run at different
    points during the development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'An organization (or even a developer or a team) may have policies and preferences
    but, in general, the following recommendations are adopted by the industry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These tests are intended to be run during development. In other
    words, the developer should run them as they write the code. There are some IDEs
    (such as Visual Studio Enterprise) that even allow you to configure unit tests
    to be run in the background as you type your code! This has to be configured and
    used carefully as it might quickly become cumbersome. You have to, however, run
    them before committing your changes, and before creating or updating a pull request.
    Unit tests are also usually run as part of a CI/CD pipeline. For these reasons,
    unit tests should always be automated and are actually very easy to automate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: These tests are to be run after unit tests have passed
    (that is, run successfully).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke tests**: These tests should be run after a new build has been deployed
    and before QA testers engage in more extensive testing. For this reason, these
    tests are usually triggered by the CI/CD pipeline, right after the deployment
    operation is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System tests**: These tests are run on a staging or pre-production environment,
    right before releasing the application to production. These tests are to be triggered
    after integration tests have passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression tests**: These tests should be run at least before committing
    your changes. They should also be part of the CI/CD pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance tests**: These should be run when new features (especially the
    ones dealing with external dependencies) or any significant code changes have
    been made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UAT tests**: These special tests are performed by users (or their representatives,
    such as stakeholders) and are intended to obtain final approval before releasing
    the application to production. Hence, these tests are usually manual.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed, we haven’t covered all the possible types of tests.
    We have only focused on the ones that are part of the pyramid of software testing.
  prefs: []
  type: TYPE_NORMAL
- en: Okay. Now that we understand the importance of software testing, and we know
    what to test, let’s implement testing into our CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test project to Bookmarkr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to add a test project for our CLI application, I needed to make a slight
    change to the project structure, which was to extract the solution file (`.sln`)
    from the project directory and edit it to update the path to the `.csproj` file.
    This allows us to create a test project and add it to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s type the following command to create the test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new directory, named `bookmarkr.UnitTests`, in which the
    content of the test project will reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, this directory only contains two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bookmarkr.UnitTests.csproj`, which describes the project, its configuration,
    and its dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnitTest1.cs`, which acts as a sample test class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting to note that the `.csproj` file already references some testing
    libraries and frameworks, particularly the **MS Test** testing framework, which
    is the one we will be using throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: About testing frameworks
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are many testing frameworks, the most common ones being **NUnit**,
    **xUnit**, and **MS Test**, we decided to use the latter for many reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '- MS Test is Microsoft’s testing framework and is widely known and used'
  prefs: []
  type: TYPE_NORMAL
- en: '- MS Test has evolved over the years and has a rich feature set, such as built-in
    support for testing parallel code, data-driven testing, and test grouping capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: That being said, no matter what your preferred testing framework is, the concepts
    are similar and the one covered in this chapter will apply as well. The main difference
    will be in the keywords provided by each testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to note that the test project is defined as *non-packable*.
    This means that this project will not be packaged and distributed as part of the
    application, which makes perfect sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we go any further, let’s add the test project to the solution using
    this command (which has to be run at the same location as the `.``sln` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we open the solution in Visual Studio, it will contain both the code
    and the test projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to make our test project reference the actual project. This
    is required so that we can test the actual code. So, let’s navigate to the test
    project’s directory and type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is one last step we need to take before we start implementing unit tests,
    which is to define a structure for our test project.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the test project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each developer, team, or organization will have preferences when it comes to
    structuring their test projects. In this section, I will introduce you to my way
    of structuring test projects, which I implemented during my career and found valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if your application is composed of multiple components and each component
    has its own Visual Studio project, you will want to create a separate unit tests
    project for each component while having a single integration tests project. This
    structure may be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Structure of test projects](img/B22400_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Structure of test projects
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will only focus on unit tests, but the same principles apply
    to integration tests. This is the reason why we only have a `bookmarkr.UnitTests`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you create multiple test projects within the solution, remember
    to always use the same version of the testing framework across all projects to
    prevent side effects due to compatibility issues.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s structure our unit tests project. Here, again, there are unlimited
    possibilities depending on personal choices and teams’/organizations’ policies.
    My approach is to have one test class for each code class. The test class will
    have the same name as the code class completed with the `Tests` suffix. I also
    like to replicate, in the test project, the same folder structure as in the code
    project as I find it easier to navigate in the test project because of the structure
    parity between the two projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'After applying these principles, the structure of our test project looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Test project’s structure](img/B22400_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Test project’s structure
  prefs: []
  type: TYPE_NORMAL
- en: Now that the structure of our test project is set up, we can start implementing
    our unit tests. But wait! Are there any code artifacts that should not be tested?
    Yes, indeed!
  prefs: []
  type: TYPE_NORMAL
- en: Code artifacts that should not be tested
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following artifacts do not need to be tested since they do not perform
    any processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bookmark.cs` and `BookmarkConflictModel.cs` since they are only model classes
    and hence only serve the purpose of moving data around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program.cs`: The purpose of this class is to configure the CLI application,
    configure logging, identify which command is the root command and build the command
    hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Helper.cs`: This helper class’s methods are used to format the text outputs
    using different colors and formatting. Hence, this class is more suitable for
    UI testing rather than unit testing. For this reason, it is excluded from unit
    testing. However, it could be tested as part of manual tests or end-to-end tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that even though we decided not to test these code artifacts for
    valid reasons, MS Test will tell us, as part of the test results, that these artifacts
    were not tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inform MS Test that we have chosen not to test these artifacts using
    the `[ExcludeFromCodeCoverage]` attribute. This attribute is very flexible: it
    can be applied to the property, method, class, or even assembly level. This attribute
    also allows us to pass a string to justify our decision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, this is how we will apply it to the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are finally ready to start implementing some tests. Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Writing effective tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn how to implement tests by writing tests for the `link` and the
    `import` commands.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is to add a test class for each command. We already
    have the folder structure in place, so let’s add the test classes. As I mentioned
    earlier, I find it useful to name my test classes after the actual classes with
    an added suffix of `Tests`. So, our test classes will be named `LinkCommandTests`
    and `ImportCommandTests`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let me introduce you to the best practices of structuring a test class
    and its test methods (yes, we will talk about structure once again! 😊):'
  prefs: []
  type: TYPE_NORMAL
- en: Using MS Test, a test class is decorated with the `[TestClass]` attribute. If
    you don’t provide this attribute, the class will not be considered a test class
    and the test methods it contains will not be run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test class usually consists of multiple test methods. The name of a test method
    should convey its intent. This is important since the test report will only present
    the names of the methods along with an icon indicating the result of this test
    method (pass, fail, skipped, and so on). The usual approach is that the name of
    test a method is composed of its name, its input parameters’ values, and the expected
    result. Examples of such names are `GetEmployeeById_ValidId_ReturnsTheExpectedEmployeeObject`
    and `GetEmployeeById_InvalidId_ThrowsEmployeeNotFoundException.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MS Test, a test method is decorated with the `[TestMethod]` attribute.
    If you don’t provide this attribute, the class will not be considered as a test
    method and will not be run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test method should test one and only one outcome (whether this is a result
    or a behavior). This is important since we need to be able to know that, if a
    test method fails, it is because it didn’t achieve the expected outcome (a result
    or a behavior). To achieve this, however, a test method may contain more than
    one assertion as long as these multiple assertions serve the purpose of validating
    that one outcome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To maximize clarity and readability, it is advised that a test method’s body
    be chunked into three parts (also known as the 3As):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrange**: where all the objects required to perform the test are instantiated
    and initialized.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: where the code artifact to be tested is invoked and the result is
    gathered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: where the obtained result (usually referred to as the “actual”
    result) is compared to the expected result. If both match, the test is considered
    to be a success. However, the test is considered to be a failure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with this new knowledge, we have everything we need to write our first
    test. Let’s start by writing tests for the `link` command.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code of the `LinkCommand` class, we notice that it does not have
    any methods. However, we see that its constructor calls the `AddCommand` method
    to set the `LinkAddCommand` as a sub-command of `Linkcommand` (that is why `add`
    appears as a child of the `link` command).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, our test method will not be verifying a result but rather a behavior.
    In this case, we want to verify that `LinkAddCommand` is actually a sub-command
    of `LinkCommand`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code is self-explanatory and easy to understand, I wanted to
    point out a couple of key points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the naming convention applied to the name of the test method. It clearly
    indicates its intent: we are testing the `LinkCommand` class, and our test consists
    of calling the class constructor and ensuring that `LinkAddCommand` is its only
    sub-command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we applied the 3A principle to structure the body of the test method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we performed three assertions to verify the expected behavior. Also,
    note the usage of `CollectionAssert`, which helps with asserting collections and
    their items. It is way more convenient than using `Assert` when dealing with lists
    and collections of elements. This is my little secret for you, as many developers
    are not aware of it or don’t naturally tend to use it 😉.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now ready to run our tests. Let’s see how we do this.
  prefs: []
  type: TYPE_NORMAL
- en: Running our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .NET CLI provides a command for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will compile the code and the test project, discover the test classes
    and test methods, execute the tests, and return the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code also provides a **graphical user interface** (**GUI**) for
    listing and executing the tests. This pane can be displayed by clicking on the
    appropriate icon, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Running tests](img/B22400_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Running tests
  prefs: []
  type: TYPE_NORMAL
- en: This GUI also provides a visual identification of the states of the test methods.
    In the preceding screenshot, we can see that our test method has been completed
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: From this GUI, we can also debug tests! This is a fantastic capability that
    helps us understand why a test is failing by strategically applying breakpoints
    and re-executing it in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We can implement more tests.
  prefs: []
  type: TYPE_NORMAL
- en: But wait!
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that we passed a `null` instance of the `BookmarkrService`
    as a parameter? This is fine since we are not relying on that parameter in the
    test we are conducting. But if we did (as we will when testing the `import` command),
    we would like to provide an instance for it.
  prefs: []
  type: TYPE_NORMAL
- en: We obviously don’t want to use an actual instance of that service as it is a
    dependency of the command and it may also rely on an external dependency, such
    as a database where the bookmarks are stored.
  prefs: []
  type: TYPE_NORMAL
- en: We will then need to provide a fake representation of it. This is where **mocks**
    come into play!
  prefs: []
  type: TYPE_NORMAL
- en: Mocking external dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking is useful for simulating the behavior of dependencies without actually
    relying on them. This is powerful because it allows us to test our application
    in isolation from its environment. The reason we want to do this is to have tests
    that ensure that the application’s code works correctly, irrespective of the state
    of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The role of mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let me clarify this with an example. Let’s say you have a method that stores
    a bookmark in the database. You write a test method to verify that, and it fails.
    You run it again, and it passes. Can you tell, without investigating, whether
    this was due to a transient database connectivity problem or due to a bug in the
    code? You can’t! But if you remove the dependency (that is, the database) from
    the equation and the same behavior occurred, you can tell (with a high level of
    confidence) that this was due to a bug in the code.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that we usually write tests that take external dependencies
    out of the equation (namely, unit tests) and tests that take these external dependencies
    into account (such as integration or system tests). So, when facing such an issue,
    we can look at unit and integration or system tests to figure out if the problem
    is due to the dependency (such as a communication problem) or due to the code
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to mock an external dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we can write our own fake implementation of a dependency
    that simulates the behavior of the real dependency, but the major drawback of
    this approach is that we have to maintain (and possibly rewrite) these implementations
    if the behavior of the real dependency changes.
  prefs: []
  type: TYPE_NORMAL
- en: It is wiser to rely on a mocking framework that will perform this task for us.
    What we need to do is to provide an interface for that dependency and the mocking
    framework will create a fake representation of it at runtime. We can also pass
    instructions to the mocking framework to configure the behavior of the fake dependency
    in a certain way, depending on the test we need to perform. For example, we can
    instruct the mocking framework to simulate a certain error or exception when invoking
    a dependency with some parameter values to verify the behavior of our application
    under these circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: About mocking frameworks
  prefs: []
  type: TYPE_NORMAL
- en: Just as there are many testing frameworks, there are also many mocking frameworks
    for you to choose from. One of the most commonly used ones, and my personal favorite,
    is **NSubstitute**. I like it because it is both powerful and easy to learn and
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about NSubstitute by visiting its website: [https://nsubstitute.github.io/help/getting-started/](https://nsubstitute.github.io/help/getting-started/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s mock the `BookmarkService` service using NSubstitute.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the BookmarkService service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to add NSubstitute to the test project. We
    can achieve this by navigating to the directory of the test project and typing
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s update the `LinkCommandTests` test class by mocking the `BookmarkService`
    service. The updated code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we haven’t done much here. We merely added a `using` statement
    for `NSubstitute` and instead of initializing the service to a `null` value, we
    asked `NSubstitute` to provide a simulation of it based on its interface (which
    is referred to as a *mock*). The result is a temporary, in-memory object built
    based on the structure of the `IBookmarkService` interface for which we can configure
    the behavior depending on the test we are performing.
  prefs: []
  type: TYPE_NORMAL
- en: If we now execute the test again, it still passes. Since we are not calling
    the service during our test, we do not need to configure its behavior. But we
    will need to do that for the upcoming test methods we are going to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mock version of the BookmarkService service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a test class for the `import` command. We first create
    the `ImportCommandTests.cs` file in the `Commands\Import` directory. This file
    will contain all the test methods related to the `import` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we lay out the base structure of the test class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command has no subcommands, so we do not need to test that, or we can write
    a test that verifies this fact. If you want to do this, you can follow the same
    procedure as in the `LinkCommandTests` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start implementing tests, we need to identify the test cases we want
    to perform. In invite you to reflect on that, but in the meantime, here is a non-exhaustive
    list of test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnImportCommand` handler method will call the `Import` method of `BookmarkService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case #2**: If the file name is invalid, an error message should be returned
    (for example, indicating that there is an forbidden character in the filename).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case #3**: If the file is not found, an error message, indicating that
    the file does not exist, should be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case #4**: When importing bookmarks, if no conflict is detected, the
    imported bookmarks are found in the local collection of bookmarks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log` method is also called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of this chapter, we will only implement test cases 1 and 5\.
    The remaining test cases are left for you as a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we can implement these test cases, some changes to the application’s
    code have to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the code must be made!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the idea: sometimes, changes to your code will have to be made so that
    the code can be testable. This is okay because some classes of the .NET framework
    aren’t testable by nature.'
  prefs: []
  type: TYPE_NORMAL
- en: In our situation, this is the case with the `FileInfo` class, which is a sealed
    class and exposes no interface, hence it cannot be overridden nor mocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a library that allows us to work around this limitation.
    We will then need to add the following NuGet package to both the application and
    the test projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the test project, we will also need to add this NuGet package, which will
    help with testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to make the following changes to the `ImportCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: We will add a private property of type `IFileSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will initialize this property to an instance of the `FileSystem` class in
    the default constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will add a second constructor that will only be used for testing. This constructor
    will take an extra parameter, of type `IFileSystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will add an overload of the `OnImportCommand` handler method that
    takes an `IFileInfo` parameter and whose only purpose is to call the original
    version of the `OnImportCommand` method, passing an instance of `FileInfo` based
    on the `IFileInfo` object it received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoking the `import` command once again, we find out that it still works as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement those test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to implementing the test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with test case 1\. Here is the associated test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code deserves an explanation, so here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a mock of the `BookmarkService`, as we did in the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a string representation of the JSON content for three bookmarks
    that will be needed for our test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, and this is the reason why we performed the changes to the code that we
    described above, we create a mock of the filesystem and simulate the existence
    of a file named `bookmarks.json` that contains the JSON representation we created
    in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we create an instance of the `ImportCommand` class using the new
    constructor we have added, which allows us to pass the mock filesystem as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to invoke the `OnImportCommand` by relying on the mock filesystem
    and passing the name of the `bookmarks.json` file we simulated earlier. It is
    important to note here that if we pass the name of a file that was not part of
    the simulation, the test will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now ready to verify whether our assertions are correct. Pay careful
    attention to how we did it: we first ensured that calling the `OnImportCommand`
    method triggered three calls to the `Import` method of `BookmarkService` (here,
    these calls are in fact made to the mock version of the service since we do not
    want the service to be activated but rather, we only want to validate that it
    was invoked as expected). This is, however, not sufficient to validate that the
    test is successful as these three calls could include unexpected calls. To make
    sure that these calls are legitimate, we verify them, one by one, ensuring that
    each of their meaningful properties matches what is expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that’s it for test case #1\. Let’s now move on to test case #5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this test case is very similar to the code for test case #1, with
    two noticeable differences:'
  prefs: []
  type: TYPE_NORMAL
- en: We are calling the real implementation of `BookmarkService`, not a mock. The
    reason is that we want to ensure that the bookmarks have been imported correctly
    and that the conflicting one has been renamed accordingly. If that service was
    relying on a database, we could have mocked that database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last assertion, although not necessary, ensures that the original, conflicting
    bookmark does not exist anymore since it has been updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, if you have been coding along with me, you have certainly noticed that
    this code does not work. In fact, it does not even compile! Don’t worry, this
    was intentional 😊. The intention is to teach you how to control visibility to
    test artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Internals visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `ImportCommand` class, we added a second constructor (which takes a parameter
    of type `IFileSystem`) and an overload for the `OnImportCommand` handler method.
    These two methods have been marked as `internal`, which simply means that they
    are visible to all parts of the code within the current project but aren’t visible
    outside of that project unless we specify otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: This is the recommended approach when you add artifacts specifically for testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `internal` accessor is very interesting. It allows us to control its visibility.
    In this case, we only want the test project to see these internal code artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we will need to update the `bookmarkr.csproj` file (the one where
    these code artifacts marked as `internal` are located) to indicate that we only
    want the test project to be able to access them. We can achieve this by adding
    this entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that code artifacts that are marked as `internal` in the `bookmarkr`
    project can only be “seen” by the `bookmarkr.UniTests` project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will notice that the code compiles and executes as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the test methods of the `ImportCommandTests` class, you have
    certainly noticed that in both test methods, we instantiated and initialized `MockFileSystem`
    and the string representation of the JSON structure of the bookmarks in the same
    way. Hence, this code is redundant and, if it changes over time, we need to update
    this code in both places. This will get even worse as the number of test methods
    increases.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, MS Test provides a way to centralize this initialization. Let’s
    see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing test initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MS Test provides a `[TestInitialize]` attribute that can be used to decorate
    a method where any common instantiation, initialization, or configuration can
    be centralized.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is then automatically invoked by the MS Test framework before calling
    every test method. This has another benefit: every test method gets fresh instances
    of the objects instantiated in the initialization method, preventing the execution
    of a test method to have an impact and an influence on the execution of the next
    test method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the test initialization method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! Now we know everything we need to know to implement meaningful and
    efficient tests for our CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: But before closing this chapter, there is one last thing I want to discuss with
    you. I want to tell you how you can use these tests that you are implementing
    to identify and eliminate a bug.
  prefs: []
  type: TYPE_NORMAL
- en: How to hunt a bug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests play a key role in hunting down a bug and ensuring it doesn’t come up
    again. To do that, you should follow a process.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a bug is discovered (by you or your team) or reported (by the user),
    you should write tests that reproduce it. These tests can be of different types.
    These are to ensure that the bug doesn’t come up again.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run your tests and you should notice that tests are failing. Tests that
    cover wider ranges (such as system or integration tests) will tell you in what
    component of the application the bug is happening. Then, more granular tests (such
    as unit tests) will tell you in what class and ultimately in what method the bug
    is hiding.
  prefs: []
  type: TYPE_NORMAL
- en: By using a smart combination of both wide-range and granular tests, you will
    be able to hunt down the bug. Keep in mind that breakpoints will be great allies.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We are now armed with everything we need to enhance the quality
    of our application by leveraging software testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned why testing is an important step in the process
    of developing any application, including CLI applications. I like to call tests
    your safety nets: they ensure not only that your new features behave as expected
    but also that you don’t accidentally introduce bugs in existing functionalities
    (we call these **regressions**). I highly encourage you to write effective tests
    and run them often.'
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the categories and roles of tests, and we learned techniques
    for testing applications and applied them to **Bookmarkr**, our CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Our application now has the required functionalities, and we ensured, through
    testing, that these functionalities behave as expected. It is now time to deliver
    the application to its users!
  prefs: []
  type: TYPE_NORMAL
- en: This is why, in the next chapter, we will explore different techniques that
    will allow us to package, distribute, and deploy our application.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 – Write the required unit tests for the remaining functionalities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we wrote tests only for the `link` and `import` commands. You
    are hence challenged to write tests for the other commands. You will have to figure
    out what test cases are to be considered and implement them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 – Write integration tests for the sync command'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sync` command deals with a database. For the purpose of unit testing, you
    can mock the database using NSubstitute. However, when implementing an integration
    test, you need a real database. You are then challenged to write integration tests
    for the `sync` command. You will have to provide a test database and use the appropriate
    connection string depending on whether the application is running in production
    or in testing mode.
  prefs: []
  type: TYPE_NORMAL
