- en: '*Chapter 8*: Adding Custom Fonts and UI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：添加自定义字体和UI'
- en: In this chapter, we are going to take the scenes that we created for our game
    loop in the previous chapter and move our focus on to text, imagery, and animation
    through various customizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把上一章为我们的游戏循环创建的场景拿来进行各种定制，重点关注文本、图像和动画。
- en: A requirement of the Unity Programmer Exam is not only to be confident with
    your C# programming skills but also to be familiar with what the Unity Editor
    offers in terms of its components and tools. Therefore, in this chapter, we will
    do no programming and, instead, focus on our **User Interface** (**UI**), which
    consists of **Image** and **Text** components. It's also worth mentioning that
    we will make our UI expand and contract with the screen's ratio size, which isn't
    possible with 3D assets alone (please refer to the previous chapter for more details).
    We will also import and apply our own custom font while we learn about our **Text**
    component. Finally, we will animate the UI with **Animator** and make use of the
    **Animator Controller**, which involves creating our own states.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unity程序员考试的要求不仅是要对自己的C#编程技能有信心，还要熟悉Unity编辑器在组件和工具方面提供的功能。因此，在本章中，我们将不进行编程，而是专注于我们的**用户界面**（**UI**），它由**图像**和**文本**组件组成。还值得一提的是，我们将使我们的UI根据屏幕的比率大小进行扩展和收缩，这是仅使用3D资产无法实现的（请参阅上一章以获取更多详细信息）。在学习我们的**文本**组件的同时，我们还将导入并应用我们自己的自定义字体。最后，我们将使用**动画器**对UI进行动画处理，并利用**动画控制器**，这涉及到创建我们自己的状态。
- en: 'The following screenshot shows what our title screen should look like by the
    end of the chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本章结束时我们的标题屏幕应该看起来像什么：
- en: '![Figure 8.1 – Killer Wave title screen'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – Killer Wave标题屏幕'
- en: '](img/Figure_8.01_B18381.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B18381.jpg)'
- en: Figure 8.1 – Killer Wave title screen
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – Killer Wave标题屏幕
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing the Canvas and UI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Canvas和UI
- en: Applying text and images to our scenes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本和图像应用到我们的场景中
- en: By the end of this chapter, you will feel more confident about combining **Text**
    and **Image** components together, along with animating the UI.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更有信心地将**文本**和**图像**组件结合起来，并对UI进行动画处理。
- en: Core exam skills being covered in this chapter
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技能
- en: '*Programming core interactions:*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互*：'
- en: Implement and configure game object behavior and physics.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象的行为和物理。
- en: '*Working in the art pipeline:*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*在艺术管道中工作*：'
- en: Understand materials, textures, and shaders, and write scripts that interact
    with Unity's rendering API.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材质、纹理和着色器，并编写与Unity渲染API交互的脚本。
- en: Understand 2D and 3D animation, and write scripts that interact with Unity's
    animation API.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解2D和3D动画，并编写与Unity动画API交互的脚本。
- en: '*Developing application systems:*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发应用程序系统*：'
- en: Interpret scripts for application interface flow such as menu systems, UI navigation,
    and application settings.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释应用界面流程的脚本，例如菜单系统、UI导航和应用设置。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_08](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_08).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_08](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_08)找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)下载每个章节的项目文件。
- en: All content for this chapter is held in the chapter's `unitypackage` file, including
    a `Complete` folder that contains all of the work that we'll carry out in this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都包含在章节的`unitypackage`文件中，包括一个包含本章我们将执行的所有工作的`Complete`文件夹。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3kqIi8k](https://bit.ly/3kqIi8k).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码的实际应用*：[https://bit.ly/3kqIi8k](https://bit.ly/3kqIi8k)。
- en: Introducing the Canvas and UI
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Canvas和UI
- en: The purpose of the Canvas is to typically hold images and text in a 2D world.
    Its primary purpose is to allow the user to interact with things, such as clicking
    on buttons, pushing volume sliders, and turning knobs, which is more commonly
    known as the UI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的目的通常是持有图像和文本的 2D 世界。其主要目的是允许用户与事物交互，例如点击按钮、推动音量滑块和旋转旋钮，这通常被称为 UI。
- en: Unity (quite confusingly) makes it such that the 2D Canvas also shares the same
    space as it's a 3D world. Therefore, in our scene, we will typically have a large
    canvas area with the UI; then, further down in the bottom left of the screen,
    we will have our 3D world.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unity（相当令人困惑地）使得 2D 画布也共享与 3D 世界相同的空间。因此，在我们的场景中，我们通常会有一个大的画布区域，包含 UI；然后，在屏幕的左下角，我们将有我们的
    3D 世界。
- en: 'The following screenshot shows an example of a Unity scene with an implemented
    **Canvas** component, along with a cube and a UI button:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了具有实现 **Canvas** 组件的 Unity 场景示例，以及一个立方体和一个 UI 按钮：
- en: '![Figure 8.2 – Our Button''s visibility differs from 2D Canvas Space and 3D
    World Space'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 我们的按钮的可见性不同于 2D 画布空间和 3D 世界空间'
- en: '](img/Figure_8.02_B18381.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B18381.jpg)'
- en: Figure 8.2 – Our Button's visibility differs from 2D Canvas Space and 3D World
    Space
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 我们的按钮的可见性不同于 2D 画布空间和 3D 世界空间
- en: As you can see in the preceding screenshot, on the right-hand side, we have
    the **Game** view showing a 3D cube and UI **Button**. On the left-hand side,
    we have the **Scene** view showing the same cube but with the **Button** missing.
    This is because, in the **Scene** window, the Canvas that holds the UI button
    is located in its own 2D space. To resolve this issue, we need to zoom out of
    the **Scene** view, and we will see where the UI button is located. Additionally,
    we will see the outline of a large white rectangle that represents the screen
    ratio.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，在右侧，我们有 **Game** 视图显示一个 3D 立方体和 UI **按钮**。在左侧，我们有 **Scene** 视图显示相同的立方体，但缺少
    **按钮**。这是因为，在 **Scene** 窗口中，包含 UI 按钮的画布位于其自己的 2D 空间中。为了解决这个问题，我们需要从 **Scene**
    视图中缩放出来，我们将看到 UI 按钮的位置。此外，我们还将看到代表屏幕比率的白色大矩形轮廓。
- en: 'Note that because we have zoomed out so much, the 3D cube is really small.
    In the following screenshot, we can''t even see the cube, on the left-hand side
    marked with a circle outline. It''s a little complicated to understand at first,
    but consider it like two projects sharing the same space:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们放大了很多，3D 立方体实际上非常小。在下面的屏幕截图中，我们甚至看不到立方体，左侧用圆形轮廓标记。一开始理解起来有点复杂，但可以将其视为两个项目共享同一空间：
- en: '![Figure 8.3 – Canvas on the left containing our Button, the right shows its
    position in the Game window'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 左侧的画布包含我们的按钮，右侧显示其在游戏窗口中的位置'
- en: '](img/Figure_8.03_B18381.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B18381.jpg)'
- en: Figure 8.3 – Canvas on the left containing our Button, the right shows its position
    in the Game window
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 左侧的画布包含我们的按钮，右侧显示其在游戏窗口中的位置
- en: With that brief example of how the Canvas shares space with the 3D space, let's
    move on to the next section, where we'll start using the Canvas and add some text
    and images.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的例子，我们可以看到画布如何与 3D 空间共享空间，接下来让我们进入下一节，我们将开始使用画布并添加一些文本和图像。
- en: Applying text and images to our scenes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文本和图像应用到我们的场景中
- en: 'In this section, we are going to change the following scenes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更改以下场景：
- en: The gray background
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰色的背景
- en: The white **TextMesh** (3D text, which doesn't require the Canvas)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白色的 **TextMesh**（3D 文本，不需要画布）
- en: 'We''ll replace those scenes with the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下场景替换那些场景：
- en: A black background
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑色的背景
- en: Custom red **Text** (2D text, which requires a Canvas)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义红色 **Text**（2D 文本，需要画布）
- en: As mentioned in the introduction, the benefit of doing this is that the text
    will remain the same size, no matter the ratio or resolution of the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，这样做的好处是文本的大小将保持不变，无论屏幕的比率或分辨率如何。
- en: 'The following screenshot shows the current `BootUp` scene on the left and what
    it should look like after making the changes on the right:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了左侧的当前 `BootUp` 场景和右侧在做出更改后应该看起来像什么：
- en: '![Figure 8.4 – We will be improving our BootUp scene''s visuals'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 我们将改进 BootUp 场景的视觉效果'
- en: '](img/Figure_8.04_B18381.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B18381.jpg)'
- en: Figure 8.4 – We will be improving our BootUp scene's visuals
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 我们将改进 BootUp 场景的视觉效果
- en: If you haven't already opened the scene in the Unity Editor, go to the `bootUp`
    scene from `Assets/Scene`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在 Unity 编辑器中打开场景，请从 `Assets/Scene` 跳转到 `bootUp` 场景。
- en: 'Let''s start by changing the background color from gray to black. If you have
    forgotten how to do this, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将背景颜色从灰色更改为黑色开始。如果您忘记了如何操作，请按照以下步骤进行：
- en: Select **Main Camera** in the **Hierarchy** window.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中选择 **Main Camera**。
- en: 'With `0,0,0,255`, as shown in the following screenshot:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `0,0,0,255`，如下截图所示：
- en: '![Figure 8.5 – Changing our bootUp scene''s background to black'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 将我们的 bootUp 场景背景更改为黑色'
- en: '](img/Figure_8.05_B18381.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.05_B18381.jpg)'
- en: Figure 8.5 – Changing our bootUp scene's background to black
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 将我们的 bootUp 场景背景更改为黑色
- en: The `BootUp` text and replace it with our new 2D text.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `BootUp` 文本替换为我们的新 2D 文本。
- en: Select `BootUpText` from the **Hierarchy** window and delete it.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 窗口中选择 `BootUpText` 并删除它。
- en: We are now going to add the Canvas and 2D text to the scene.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将向场景中添加 Canvas 和 2D 文本。
- en: 'In the open space of the **Hierarchy** window, right-click and select **UI**
    | **Text**, as shown in the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口的空白区域右键单击，选择 **UI** | **Text**，如下截图所示：
- en: '![Figure 8.6 – Creating 2D Text in the Unity Editor'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 在 Unity 编辑器中创建 2D 文本'
- en: '](img/Figure_8.06_B18381.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.06_B18381.jpg)'
- en: Figure 8.6 – Creating 2D Text in the Unity Editor
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 在 Unity 编辑器中创建 2D 文本
- en: 'Because we have added 2D text, Unity helps us out by automatically adding the
    Canvas and EventSystem to the scene. The following screenshot shows the `bootUp`
    `Text` game object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了 2D 文本，Unity 会自动将 Canvas 和 EventSystem 添加到场景中。以下截图显示了 `bootUp` `Text`
    游戏对象：
- en: '![Figure 8.7 – Our Hierarchy displaying Canvas, Text, and EventSystem'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 我们显示 Canvas、Text 和 EventSystem 的层次结构'
- en: '](img/Figure_8.07_B18381.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B18381.jpg)'
- en: Figure 8.7 – Our Hierarchy displaying Canvas, Text, and EventSystem
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 我们显示 Canvas、Text 和 EventSystem 的层次结构
- en: Right-click on the `Text` game object and rename it to `presented`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Text` 游戏对象并将其重命名为 `presented`。
- en: With `presented` still selected in the **Hierarchy** window, pay attention to
    the **Inspector** window because we need to update its **Text** component.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中仍然选择 `presented`，注意 **Inspector** 窗口，因为我们需要更新其 **Text** 组件。
- en: In the **Text** field, change the default input from **New Text** to **presented
    by**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Text** 字段中，将默认输入从 **New Text** 更改为 **presented by**。
- en: Let's continue modifying the `presented` game object's **Text** component settings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续修改 `presented` 游戏对象的 **Text** 组件设置。
- en: We will change the font from the typical `Assets/Font/ethnocentric rg it`. We
    can select this font from our `presented` game object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改字体，从典型的 `Assets/Font/ethnocentric rg it`。我们可以从我们的 `presented` 游戏对象中选择此字体。
- en: Click on the small circle that appears to the right of the `ethnocentric rg
    it` from the drop-down list.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下拉列表中 `ethnocentric rg it` 右侧出现的圆形小圈。
- en: Change the `0`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改 `0`。
- en: At this point, our font will have disappeared from the **Scene** window. This
    is because the **Rect Tool** isn't big enough and we need to resize it. We will
    do this next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的字体已从 **Scene** 窗口中消失。这是因为 **矩形工具** 不够大，我们需要调整其大小。我们将在下一步进行此操作。
- en: Information Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 信息提示
- en: The Rect Tool is an area for the images or text to sit in. Consider it as a
    similar tool to the Transform component, where we enter the Vector3 values for
    the Position, Rotation, and Scale of our game's objects, which we have been altering
    from [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048), *Adding and Manipulating
    Objects*, onward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形工具是图像或文本放置的区域。将其视为与变换组件类似的一个工具，我们在此输入游戏对象的 Position、Rotation 和 Scale 的 Vector3
    值，这是我们自 [*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048)，*添加和操作对象* 以来一直在更改的。
- en: 'In the `presented` game object still selected, make sure that the **Rect Tool**
    is selected, as shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选中的 `presented` 游戏对象中，确保选择 **矩形工具**，如下截图所示：
- en: '![Figure 8.8 – Rect Tool button location'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8 – 矩形工具按钮位置'
- en: '](img/Figure_8.08_B18381.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.08_B18381.jpg)'
- en: Figure 8.8 – Rect Tool button location
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 矩形工具按钮位置
- en: 'Make sure we are in 2D mode (and **Gizmos** is turned on to the right of the
    bar), as we don''t need to be concerned about the 3D space while adjusting the
    2D text. Either press *2* on the keyboard or click on the following button:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们处于 2D 模式（并且 **Gizmos** 在条形上已开启），因为我们调整 2D 文本时不需要关心 3D 空间。可以在键盘上按 *2* 或点击以下按钮：
- en: '![Figure 8.9 – 2D button location'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B18381.jpg)'
- en: '](img/Figure_8.09_B18381.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B18381.jpg)'
- en: Figure 8.9 – 2D button location
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 2D 按钮位置
- en: 'Additionally, check whether the **Game** window ratio is set to **1080 (1920x1080)**
    (this is the screen ratio that we set in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*). You can do this using the drop-down list below
    the **Game** tab, as shown in the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，检查**游戏**窗口的比例是否设置为**1080 (1920x1080)**（这是我们[*第 2 章*](B18381_02_Epub.xhtml#_idTextAnchor048)，*添加和操作对象*中设置的屏幕比例）。您可以使用**游戏**标签下面的下拉列表来完成此操作，如下面的截图所示：
- en: '![Figure 8.10 – Changing our Game window aspect to 1080'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10 – 将我们的游戏窗口宽高比更改为 1080]'
- en: '](img/Figure_8.10_B18381.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.10_B18381.jpg)'
- en: Figure 8.10 – Changing our Game window aspect to 1080
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 将我们的游戏窗口宽高比更改为 1080
- en: 'Click and drag the outer edge of the **Rect Tool** to the far left until it
    clips to the outer edge, as indicated in the following screenshot:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动**矩形工具**的外边缘到最左侧，直到它剪切到外边缘，如下面的截图所示：
- en: '![Figure 8.11 – Click and drag the edge (where the arrow is) of our Rect Tool
    to the far-left outer edge (* symbol)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – 点击并拖动我们的矩形工具边缘（箭头所在位置）到最左边的外边缘（*符号）]'
- en: '](img/Figure_8.11_B18381.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.11_B18381.jpg)'
- en: Figure 8.11 – Click and drag the edge (where the arrow is) of our Rect Tool
    to the far-left outer edge (* symbol)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 点击并拖动我们的矩形工具边缘（箭头所在位置）到最左边的外边缘（*符号）
- en: Once done, drag the right edge of the **Rect Tool** to the right side of the
    outer edge.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将**矩形工具**的右边缘拖到外边缘的右侧。
- en: 'Now, widen the top and the bottom of the **Rect Tool** edges. This is so that
    the height is approximately a quarter of the white outer rectangle. We should
    now see our text reappear, and our **Rect Tool** proportions should be similar
    to those in the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将**矩形工具**的顶部和底部边缘加宽。这样，高度大约是白色外矩形四分之一。我们现在应该能看到文本重新出现，我们的**矩形工具**比例应该与以下截图中的类似：
- en: '![Figure 8.12 – Click and drag the top and the bottom of the Rect Tool edges
    similar to here'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – 按照此处类似的方式，点击并拖动矩形工具的顶部和底部边缘]'
- en: '](img/Figure_8.12_B18381.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.12_B18381.jpg)'
- en: Figure 8.12 – Click and drag the top and the bottom of the Rect Tool edges similar
    to here
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 按照此处类似的方式，点击并拖动矩形工具的顶部和底部边缘
- en: Now that we have the **Rect Tool** spacing set up, we need to set the **Anchors**
    so that the text remains the correct size no matter what the screen ratio or resolution
    is.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了**矩形工具**的间距，我们需要设置**锚点**，以确保文本无论屏幕比例或分辨率如何都能保持正确的尺寸。
- en: In the center of the Canvas screen, we should be able to see four arrows pointing
    toward each other (the left-hand side of the following screenshot has these four
    arrows circled in red).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布屏幕的中心，我们应该能看到四个指向彼此的箭头（以下截图的左侧用红色圈出了这四个箭头）。
- en: 'To set the **Anchors** in the same location as the four blue circles, perform
    the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要将**锚点**设置在四个蓝色圆圈相同的位置，请执行以下步骤：
- en: 'One at a time, click and drag each white arrow to where each blue circle is:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个点击并拖动每个白色箭头到每个蓝色圆圈的位置：
- en: '![Figure 8.13 – Click and drag each white outline arrow out to its far-corner
    blue circles'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13 – 点击并拖动每个白色轮廓箭头到其远角的蓝色圆圈]'
- en: '](img/Figure_8.13_B18381.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.13_B18381.jpg)'
- en: Figure 8.13 – Click and drag each white outline arrow out to its far-corner
    blue circles
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 点击并拖动每个白色轮廓箭头到其远角的蓝色圆圈
- en: Now that our **Anchors** are roughly sitting on top of the **Rect Tool**, which
    is denoted by blue circles, we can make it so that the **Position** and **Anchors**
    are both aligned.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的**锚点**大致位于**矩形工具**上方，该工具由蓝色圆圈表示，我们可以确保**位置**和**锚点**都对齐。
- en: 'To set the **Rect Transform** into place, enter a value of 0 in the **Left**,
    **Top**, **Pos Z**, **Right**, and **Bottom** positions. The following screenshot
    (on the left) shows our highlighted values. It''s likely that yours won''t be
    the same since we positioned the **Rect Tool** manually earlier on:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将**矩形变换**设置到位，请在**左**、**顶**、**Pos Z**、**右**和**底**位置输入值为 0。以下截图（左侧）显示了我们的突出显示值。您的可能不会相同，因为我们之前手动定位了**矩形工具**：
- en: '![Figure 8.14 – Reset all highlighted Rect Transform values to 0'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – 将所有突出显示的矩形变换值重置为 0]'
- en: '](img/Figure_8.14_B18381.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.14_B18381.jpg)'
- en: Figure 8.14 – Reset all highlighted Rect Transform values to 0
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 将所有突出显示的矩形变换值重置为 0
- en: Now, we can continue with the **Text** component in the **Inspector** window
    in order to set the color and position of the text.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续在**检查器**窗口中的**文本**组件中设置文本的颜色和位置。
- en: 'To center the `presented by` text in the **Text** component, select the two
    middle buttons in the **Alignment** section, as shown in the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在**文本**组件中居中**由**文本，选择**对齐**部分中的两个中间按钮，如下一个截图所示：
- en: '![Figure 8.15 – Update each of the Text component property values'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 – 更新每个文本组件属性值'
- en: '](img/Figure_8.15_B18381.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.15_B18381.jpg)'
- en: Figure 8.15 – Update each of the Text component property values
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 更新每个文本组件属性值
- en: Tick the **Best Fit** box. This will ensure that our text scales to support
    the screen's ratio dynamically.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**最佳拟合**框。这将确保我们的文本可以动态地缩放以支持屏幕的比率。
- en: With the `0` and `80`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`0`和`80`。
- en: Change the color by clicking on the **Color** field and choosing red, as shown
    in the preceding screenshot.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**颜色**字段并选择红色来更改颜色，如前一个截图所示。
- en: We have now had a full run with the `bootUp` **TextMesh** that we had before.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完全运行了我们之前拥有的`bootUp`**TextMesh**。
- en: 'The following screenshot shows our custom text, color, size, and alignment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的自定义文本、颜色、大小和对齐方式：
- en: '![Figure 8.16 – Our font is now centered and stylized'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 – 我们的新字体现在居中并具有风格'
- en: '](img/Figure_8.16_B18381.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.16_B18381.jpg)'
- en: Figure 8.16 – Our font is now centered and stylized
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 我们的新字体现在居中并具有风格
- en: As you can imagine, we haven't quite finished yet because we need to have the
    name or company's name appear underneath the **PRESENTED BY** text. Thankfully,
    we only need to repeat about a quarter of the work we've just done. And, as you've
    probably guessed – yes – we can copy and paste this text.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，我们还没有完全完成，因为我们还需要在**由**文本下面显示名字或公司名称。幸运的是，我们只需要重复我们刚刚完成的工作的四分之一左右。而且，正如你可能猜到的——是的——我们可以复制并粘贴这段文本。
- en: 'To set our own name or company name underneath **PRESENTED BY**, perform the
    following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置自己的名字或公司名字在**由**下面，请执行以下步骤：
- en: Select the `presented` game object from the **Hierarchy** window.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择`presented`游戏对象。
- en: Press *Ctrl* (*command* on the Mac) and *D* to duplicate the game object.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*（在Mac上为*command*）和*D*键复制游戏对象。
- en: 'Press *T* to switch to the **Move Tool**:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*T*键切换到**移动工具**：
- en: '![Figure 8.17 – Duplicate a second line of text'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 – 复制文本的第二行'
- en: '](img/Figure_8.17_B18381.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.17_B18381.jpg)'
- en: Figure 8.17 – Duplicate a second line of text
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 复制文本的第二行
- en: Now click and drag the green *y-axis* arrow downward (as shown in the preceding
    screenshot) to roughly sit on the white line where the original **PRESENTED BY**
    text's **Rect Tool** lies.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击并拖动绿色*y轴*箭头向下（如前一个截图所示），大致位于原始**由**文本的**矩形工具**所在的白色线上。
- en: 'All we need to do next is to click and drag each of the four white arrow outlines
    of the **Anchors** downward to fit in our newly created game object, as shown
    in the following screenshot:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的就是点击并拖动**锚点**的四个白色箭头轮廓向下，以适应我们新创建的游戏对象，如下一个截图所示：
- en: '![Figure 8.18 – Tidy up the Rect Transform boundaries of our duplicated text'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 – 整理我们复制的文本的Rect Transform边界'
- en: '](img/Figure_8.18_B18381.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.18_B18381.jpg)'
- en: Figure 8.18 – Tidy up the Rect Transform boundaries of our duplicated text
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 整理我们复制的文本的Rect Transform边界
- en: If you have moved the `0`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经移动了`0`。
- en: So, our new text is in place. All we need to do now is to change what has been
    typed in.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的新文本已经到位。我们现在需要做的就是更改输入的内容。
- en: 'We know how to do this: just scroll down to the **Text** component and enter
    your name, company name, pet''s name, or any name – it doesn''t matter for the
    purpose of this tutorial.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道如何做到这一点：只需滚动到**文本**组件并输入你的名字、公司名字、宠物的名字或任何名字——对于本教程的目的来说，这都不重要。
- en: Once you have entered your name, don't forget to name the `presented(1)` game
    object to something such as `yourName`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你输入了你的名字，不要忘记将`presented(1)`游戏对象重命名为`yourName`。
- en: 'Click on the **Game** tab window to see how it looks. This is what ours looks
    like:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**游戏**选项卡窗口查看其外观。这就是我们的样子：
- en: '![Figure 8.19 – Our bootup text is complete'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 我们的启动文本已完成'
- en: '](img/Figure_8.19_B18381.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.19_B18381.jpg)'
- en: Figure 8.19 – Our bootup text is complete
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 我们的启动文本已完成
- en: Save the scene.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: We have covered the fundamentals of a **Canvas** component and how to apply
    2D text. Next, we will be repeating a similar procedure and using the **Image**
    component. This is equivalent to the **Sprite Renderer** that we used for our
    shop scene buttons in [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107), *Creating
    a Shop Scene for Our Game*. However, here, the **Image** component is for a 2D
    space.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了**Canvas**组件的基本知识以及如何应用2D文本。接下来，我们将重复类似的程序并使用**图像**组件。这相当于我们在[*第5章*](B18381_05_Epub.xhtml#_idTextAnchor107)中用于商店场景按钮的**Sprite
    Renderer**，即*为我们的游戏创建商店场景*。然而，在这里，**图像**组件用于2D空间。
- en: 'From this point to the end of the chapter, we will go through a series of subsections
    in order to polish and animate our scenes. We will cover the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点到本章的结尾，我们将按顺序浏览一系列子章节，以便润色和生动化我们的场景。我们将涵盖以下内容：
- en: Starting with our title scene, we will improve its visuals by creating and applying
    **Text** and **Image** components.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的标题场景开始，我们将通过创建和应用**文本**和**图像**组件来改进其视觉效果。
- en: We will use a custom font because we can, and it'll make our game look better
    than the standard fonts that come with Unity. From there, we will be able to further
    customize the `title` scene look more suitable for our game.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用自定义字体，因为我们能这样做，这将使我们的游戏看起来比Unity附带的标准字体更好。从那里，我们将能够进一步自定义`title`场景的外观，使其更适合我们的游戏。
- en: We will then take what we have applied to the `title` scene and copy and paste
    it into the other scenes. From there, we will change the content of the text and
    its position slightly.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将把应用到`title`场景中的内容复制并粘贴到其他场景中。从那里，我们将稍微更改文本内容和位置。
- en: Finally, we will set up our **Animator** and **Animator Controller** states
    and animate our UI to introduce each game level.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将设置我们的**动画器**和**动画控制器**状态，并动画化我们的UI以介绍每个游戏级别。
- en: Let's continue with polishing our `title` scene.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续润色我们的`title`场景。
- en: Improving our title scene
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改善我们的标题场景
- en: In this section, we will repeat the procedure that we already learned in the
    previous section without going into too much depth, as we already know how to
    create a Canvas, add custom text, and perform duplicating. In this section, we
    will also make use of Unity's **Image** component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重复我们在上一节中学到的程序，但不会深入探讨，因为我们已经知道如何创建Canvas、添加自定义文本和执行复制。在本节中，我们还将利用Unity的**图像**组件。
- en: 'The following screenshot shows the transformation we will be undergoing, starting
    with our current title scene on the left and using the same techniques we applied
    in the previous section, along with adding **Image** components, to create the
    red stripe on the right:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将要经历的转换，从左侧的当前标题场景开始，使用我们在上一节中应用的技术，以及添加**图像**组件，以创建右侧的红色条纹：
- en: '![Figure 8.20 – Old Title screen on the left; what we will be replacing it
    with on the right'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 – 左侧的旧标题屏幕；我们将用右侧的内容替换它'
- en: '](img/Figure_8.20_B18381.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B18381.jpg)'
- en: Figure 8.20 – Old Title screen on the left; what we will be replacing it with
    on the right
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 左侧的旧标题屏幕；我们将用右侧的内容替换它
- en: 'As mentioned earlier, we won''t be going into all of the details; however,
    if you do struggle at any point, then please refer back to the previous section
    to guide you through what you should already know. Let''s get started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会深入所有细节；然而，如果你在任何时候遇到困难，请参考上一节以指导你了解你应该知道的内容。让我们开始吧：
- en: Let's begin by loading up our `title` scene from the `Assets/Scene`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从从`Assets/Scene`加载我们的`title`场景开始。
- en: Change the `255`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`255`更改为。
- en: Delete the `TitleText` game object from the **Hierarchy** window.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中删除`TitleText`游戏对象。
- en: 'Create just a `Canvas` game object in the **Hierarchy** window. Use the following
    screenshot as a reference:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中仅创建一个`Canvas`游戏对象。以下截图作为参考：
- en: '![Figure 8.21 – Creating a Canvas'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 创建Canvas'
- en: '](img/Figure_8.21_B18381.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.21_B18381.jpg)'
- en: Figure 8.21 – Creating a Canvas
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 创建Canvas
- en: 'We are now going to create an empty game object. Inside this game object, we
    are going to store our **Text** and **Image** components:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个空的游戏对象。在这个游戏对象内部，我们将存储我们的**文本**和**图像**组件：
- en: Create an empty game object by right-clicking in the lower open space of the
    **Hierarchy** window, and then select **Create Empty** from the drop-down list.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**窗口的底部空白区域右键单击，然后从下拉列表中选择**创建空对象**来创建一个空的游戏对象。
- en: The new empty game object will default to the name of `GameObject`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的空游戏对象将默认命名为`GameObject`。
- en: Right-click on this game object and select `Title`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击此游戏对象并选择`标题`。
- en: Move the `Title` game object into the `Canvas` game object so that the former
    becomes a child.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`标题`游戏对象移动到`画布`游戏对象中，使其成为子对象。
- en: Typically, when a new game object is created, it will automatically be given
    a **Transform** component that holds the game object's **Position**, **Rotation**,
    and **Scale** for a 3D space. In this section, our focus is on 2D space, so we
    need to change this game object from a **Transform** component into a **Rect Transform**
    component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当创建一个新的游戏对象时，它将自动获得一个**变换**组件，该组件包含游戏对象在3D空间中的**位置**、**旋转**和**缩放**。在本节中，我们的重点是2D空间，因此我们需要将此游戏对象从**变换**组件更改为**矩形变换**组件。
- en: 'To change the `Title` game object from **Transform** to **Rect Transform**,
    follow these steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`标题`游戏对象从**变换**更改为**矩形变换**，请按照以下步骤操作：
- en: With the `Title` game object selected in the **Hierarchy** window, click on
    the **Add Component** button in the **Inspector** window.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`标题`游戏对象后，在**检查器**窗口中单击**添加组件**按钮。
- en: 'A drop-down list will appear. Type `rect transform` into the drop-down list
    search bar until it is possible to select it from the list, as shown in the following
    screenshot:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个下拉列表。在搜索栏中输入`rect transform`，直到可以从列表中选择它，如下面的屏幕截图所示：
- en: '![Figure 8.22 – Select the Rect Transform from the dropdown'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – 从下拉菜单选择矩形变换'
- en: '](img/Figure_8.22_B18381.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.22_B18381.jpg)'
- en: Figure 8.22 – Select the Rect Transform from the dropdown
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 从下拉菜单选择矩形变换
- en: We are now going to set our `Title` game object's `Title` game object's **Anchors**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`标题`游戏对象的`标题`游戏对象的**锚点**。
- en: 'I have set my `Title` game object''s **Rect Transform** component to the following
    settings:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将我的`标题`游戏对象的**矩形变换**组件设置为以下设置：
- en: '![Figure 8.23 – Update the Anchors Min and Max values'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – 更新锚点最小和最大值'
- en: '](img/Figure_8.23_B18381.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.23_B18381.jpg)'
- en: Figure 8.23 – Update the Anchors Min and Max values
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 更新锚点最小和最大值
- en: As you can see, in the previous screenshot, the `Title` game object are centered
    in the canvas's white box outline. Also, note that the **Rect Transform** component's
    **Left**, **Top**, **Pos Z**, **Right**, and **Bottom** positions are all set
    to the value of 0.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在前面的屏幕截图中，`标题`游戏对象位于画布的白色框轮廓中央。此外，请注意，**矩形变换**组件的**左**、**上**、**Z位置**、**右**和**下**位置都设置为0的值。
- en: 'The next step will be to add a red transparent stripe within the `Title` game
    object. To add an **Image** component, follow these instructions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将在`标题`游戏对象内添加一个红色透明条带。要添加**图像**组件，请按照以下说明操作：
- en: Create a new game object in the **Hierarchy** window.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中创建一个新的游戏对象。
- en: Name the game object `mainCol`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象命名为`mainCol`。
- en: 'Drag the `mainCol` game object on top of the `Title` game object to make `mainCol`
    a child of `Title`. Refer to the following screenshot for reference:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mainCol`游戏对象拖放到`标题`游戏对象上方，使`mainCol`成为`标题`的子对象。请参考以下屏幕截图以获取参考：
- en: '![Figure 8.24 – Canvas child objects order from the Hierarchy window'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24 – 从层次结构窗口查看画布子对象顺序'
- en: '](img/Figure_8.24_B18381.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.24_B18381.jpg)'
- en: Figure 8.24 – Canvas child objects order from the Hierarchy window
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 从层次结构窗口查看画布子对象顺序
- en: 'With our `mainCol` game object still selected, we want its `Title` game object
    as it is the parent of our `mainCol` game object. The following screenshot is
    a reference to our `mainCol` **Rect Transform** properties:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`mainCol`游戏对象的情况下，我们希望其`标题`游戏对象保持原样，因为它是我们的`mainCol`游戏对象的父对象。以下屏幕截图是关于我们的`mainCol`
    **矩形变换**属性的参考：
- en: '![Figure 8.25 – mainCol Anchors set to full size'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – mainCol锚点设置为全尺寸'
- en: '](img/Figure_8.25_B18381.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.25_B18381.jpg)'
- en: Figure 8.25 – mainCol Anchors set to full size
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 将mainCol锚点设置为全尺寸
- en: 'With the `mainCol` game object still selected, select the `Image` into the
    drop-down list until it appears. When it does appear, select it. Use the following
    screenshot as a reference:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`mainCol`游戏对象的情况下，将`图像`选择到下拉列表中，直到它出现。当它出现时，选择它。请参考以下屏幕截图：
- en: '![Figure 8.26 – Add the Image component from the dropdown'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26 – 从下拉菜单添加图像组件'
- en: '](img/Figure_8.26_B18381.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.26_B18381.jpg)'
- en: Figure 8.26 – Add the Image component from the dropdown
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 – 从下拉菜单添加图像组件
- en: We have now added an `mainCol` image.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已添加了`mainCol`图像。
- en: 'Next, we will adjust the `mainCol` image react to the color change (denoted
    by **3**):'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将调整`mainCol`图像反应的颜色变化（表示为**3**）：
- en: '![Figure 8.27 – Update the Image component''s Color setting to the displayed
    values'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27 – 更新图像组件的颜色设置为显示的值'
- en: '](img/Figure_8.27_B18381.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.27_B18381.jpg)'
- en: Figure 8.27 – Update the Image component's Color setting to the displayed values
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 – 更新图像组件的颜色设置为显示的值
- en: Further Information
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: With the **Image** component, if we added a sprite to the parameter instead
    of just changing the color alone, we would also have the ability to alter its
    **Image Type**. One of the types that can be used is called **Filled**. This can
    give you the impression that the sprite is filling up, which would be useful for
    a loading bar or a time limit that is counting down.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在参数中添加了精灵而不是仅仅改变颜色，使用**图像**组件，我们还将有改变其**图像类型**的能力。可以使用的一种类型称为**填充**。这可以给你一种精灵正在填充的印象，这对于加载条或倒计时的时间限制将很有用。
- en: If you would like to know more about the **Image** component and its other uses,
    view the documentation at [https://docs.unity3d.com/2017.3/Documentation/Manual/script-Image.html](https://docs.unity3d.com/2017.3/Documentation/Manual/script-Image.html).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于**图像**组件及其其他用途的信息，请查看[https://docs.unity3d.com/2017.3/Documentation/Manual/script-Image.html](https://docs.unity3d.com/2017.3/Documentation/Manual/script-Image.html)的文档。
- en: 'Next, we will add a strip to the top of the image we''ve just made with another
    game object containing an **Image** component. To do that, we will repeat our
    earlier methodology but with a tighter, thinner strip. Follow these steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用包含**图像**组件的另一个游戏对象添加一个条带到我们刚刚制作好的图像顶部。为此，我们将重复我们之前的方法，但使用更紧、更薄的条带。按照以下步骤操作：
- en: With `mainCol` still selected, press *Ctrl* (*command* on the Mac) and *D* on
    our keyboard to duplicate the game object.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mainCol`仍然被选中时，按键盘上的*Ctrl* (*Mac上的*command*) 和 *D* 来复制游戏对象。
- en: Rename the new game object `trim00`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新游戏对象`trim00`重命名。
- en: 'Change the `trim00` game object''s `trim00` game object at the top:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`trim00`游戏对象的`trim00`游戏对象在顶部：
- en: '![Figure 8.28 – trim00 Anchors Min and Max values'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28 – trim00 锚点最小和最大值'
- en: '](img/Figure_8.28_B18381.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.28_B18381.jpg)'
- en: Figure 8.28 – trim00 Anchors Min and Max values
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28 – trim00 锚点最小和最大值
- en: For our trim set, we don't need to change the color as it duplicates from the
    `mainCol` game object. We now need to repeat this process for the bottom part
    of the `mainCol` image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的trim集，我们不需要改变颜色，因为它从`mainCol`游戏对象中复制而来。我们现在需要重复这个过程来处理`mainCol`图像的底部部分。
- en: 'Here are the steps that we need to accomplish to copy another trim game object:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成以下步骤来复制另一个trim游戏对象：
- en: Duplicate the `trim00` game object and rename it to `trim01`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`trim00`游戏对象，并将其重命名为`trim01`。
- en: 'Set the `trim01` game object''s **Rect Transform** settings to the same settings
    shown in the following screenshot:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`trim01`游戏对象的**矩形变换**设置设置为以下截图所示的相同设置：
- en: '![Figure 8.29 – trim01 Anchors Min and Max values'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29 – trim01 锚点最小和最大值'
- en: '](img/Figure_8.29_B18381.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.29_B18381.jpg)'
- en: Figure 8.29 – trim01 Anchors Min and Max values
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29 – trim01 锚点最小和最大值
- en: 'Now it''s time to enter our main title text, `KILLER WAVE`, by following these
    instructions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候按照以下说明输入我们的主标题文本`KILLER WAVE`了：
- en: Create another empty game object in the **Hierarchy** window.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中创建另一个空的游戏对象。
- en: Give the new empty game object the name `TitleText`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新的空游戏对象命名为`TitleText`。
- en: In the `TitleText` game object inside the `Title` game object. This is so that
    `TitleText` becomes a child of `Title`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TitleText`游戏对象内部的`Title`游戏对象中。这样`TitleText`就变成了`Title`的子对象。
- en: With `TitleText` still selected, click on **Add Component** in the **Inspector**
    window and select **Rect Transform** from the drop-down list as before.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TitleText`仍然被选中时，在**检查器**窗口中点击**添加组件**，然后从下拉列表中选择**矩形变换**，就像之前一样。
- en: 'Set the `TitleText` **Rect Transform** settings to the following values:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TitleText` **矩形变换**设置设置为以下值：
- en: '![Figure 8.30 – TitleText Anchors Min and Max values'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.30 – TitleText 锚点最小和最大值'
- en: '](img/Figure_8.30_B18381.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.30_B18381.jpg)'
- en: Figure 8.30 – TitleText Anchors Min and Max values
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30 – TitleText 锚点最小和最大值
- en: This will fill our `TitleText` `Title`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将填充我们的`TitleText` `Title`）。
- en: 'The final steps for our `TitleText` game object are to give it a **Text** component
    and set its values in the **Inspector** window:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`TitleText`游戏对象的最后几步是给它添加一个**文本**组件，并在**检查器**窗口中设置其值：
- en: With the `TitleText` game object still selected in the `text` if it isn't there)
    from the drop-down list as before.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`text`中选择`TitleText`游戏对象（如果它不在那里），然后从下拉列表中选择，就像之前一样。
- en: In the `killer wave`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`killer wave`中。
- en: Click on the small circle to the right of the `bootUp` scene (`ethnocentric
    rg it`).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`bootUp`场景右侧的小圆圈（`ethnocentric rg it`）。
- en: Set the **Alignment** buttons to center and middle.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**对齐**按钮为中心和中间。
- en: Tick **Best Fit**. This will leave it up to Unity to try and fit the text depending
    on the ratio it is in.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**最佳拟合**。这将让Unity根据其比例尝试调整文本。
- en: Set `140`. This will give us a fairly large title.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`140`。这将给我们一个相当大的标题。
- en: Select a bright red color in the **Color** field.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**颜色**字段中选择鲜艳的红色。
- en: Our title is set. The last thing we need to do in this scene is to set a message
    at the bottom of the screen to prompt the player to start the game.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了标题。在这个场景中，我们最后需要做的是在屏幕底部设置一条消息，提示玩家开始游戏。
- en: Similar to what we did in the `bootUp` scene, we can duplicate our `TitleText`
    game object. However, this time, we are going to move the duplicated game object
    outside of the **Rect Transform** restrictions of its parent. The final text we
    will display will be a message to prompt the player to tap on the screen or shoot
    to begin playing the game.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在`bootUp`场景中所做的一样，我们可以复制我们的`TitleText`游戏对象。然而，这次，我们将把复制的游戏对象移动到其父**矩形变换**的限制之外。我们将显示的最后文本将是一条提示玩家点击屏幕或射击以开始游戏的短信。
- en: 'To enter the `SHOOT TO START` text, follow these instructions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要输入`SHOOT TO START`文本，请按照以下说明操作：
- en: Select the `TitleText` game object in the **Hierarchy** window.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`TitleText`游戏对象。
- en: Press *Ctrl* (*command* on the Mac) and *D* to duplicate it.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*（在Mac上为*command*）和*D*来复制它。
- en: Rename the duplicated game object `shootToStart`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的游戏对象重命名为`shootToStart`。
- en: With `shootToStart` still selected, change its `SHOOT TO START` in the **Inspector**
    window.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`shootToStart`仍然被选中的情况下，在**检查器**窗口中更改其`SHOOT TO START`。
- en: Set `50`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`50`。
- en: As mentioned earlier, we are going to move the **Text** selection from its current
    area to outside its parent.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将把**文本**选择从其当前区域移动到其父对象之外。
- en: 'Hold *Ctrl* (*command* on the Mac) and click on any of its white arrows. Then,
    pull the **Rect Tool** downward so that it is completely outside its parent **Rect
    Tool**, as highlighted in the following screenshot:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*（在Mac上为*command*）并点击其上的任意一个白色箭头。然后，将**矩形工具**向下拉，使其完全位于其父**矩形变换**之外，如以下截图所示：
- en: '![Figure 8.31 – Move the shootToStart Anchors into the highlighted positions'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.31 – 将shootToStart锚点移动到高亮位置'
- en: '](img/Figure_8.31_B18381.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.31_B18381.jpg)'
- en: Figure 8.31 – Move the shootToStart Anchors into the highlighted positions
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 – 将shootToStart锚点移动到高亮位置
- en: 'Zero out the `SHOOT TO START` text down and into the location where the white
    arrows are. The following screenshot shows the placement of the text along with
    its **Rect Transform** property values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将`SHOOT TO START`文本移至白色箭头所在的位置。以下截图显示了文本的放置以及其**矩形变换**属性值：
- en: '![Figure 8.32 – shootToStart Anchors Min and Max values'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32 – shootToStart锚点的最小和最大值'
- en: '](img/Figure_8.32_B18381.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.32_B18381.jpg)'
- en: Figure 8.32 – shootToStart Anchors Min and Max values
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32 – shootToStart锚点的最小和最大值
- en: We don't need to change any of the functionality of the scene as we have already
    set this up.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要更改场景的任何功能，因为我们已经设置了这一点。
- en: Save the scene.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'The following screenshot shows what our `title` scene now looks like:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的`title`场景现在的样子：
- en: '![Figure 8.33 – Killer Wave title screen'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33 – 杀手浪标题屏幕'
- en: '](img/Figure_8.33_B18381.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.33_B18381.jpg)'
- en: Figure 8.33 – Killer Wave title screen
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33 – 杀手浪标题屏幕
- en: So far, we have gone further with our text by duplicating it, altering it, and
    moving it outside of its parent **Rect Tool** game object. We have also introduced
    images and used them in a similar way to our 2D text.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过复制、修改和将其移动到其父**矩形工具**游戏对象之外来进一步处理我们的文本。我们还引入了图像，并以类似的方式使用它们来处理2D文本。
- en: 'We will now continue and work on the next scene: `gameOver`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续并开始下一个场景：`gameOver`。
- en: Duplicating our game objects
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制我们的游戏对象
- en: In this section, we will improve the `gameOver` scene from its gray background
    and blocky white text and replace it with the same images and text from the `title`
    scene. However, this time, we won't be repeating the same steps from the previous
    sections to recreate the same outcome.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将改进`gameOver`场景，从其灰色背景和块状白色文本，替换为与`title`场景相同的图像和文本。然而，这次，我们不会重复之前章节中的相同步骤来重现相同的结果。
- en: We will copy, paste, and tweak the game objects to save time and effort rather
    than repeat what we have already achieved with the title scene.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制、粘贴并调整游戏对象以节省时间和精力，而不是重复我们在标题场景中已经实现的内容。
- en: 'As an overview, here is what our `gameOver` UI game objects will contain and
    do:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概述，以下是我们`gameOver` UI游戏对象将包含的内容和功能：
- en: '`Canvas`: This is the parent of all of the UI game objects.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Canvas`：这是所有UI游戏对象的父对象。'
- en: '`GameOverTitle`: This holds all of the individual game objects relating to
    the **Text** and **Image** components.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameOverTitle`：这包含与**文本**和**图像**组件相关的所有单个游戏对象。'
- en: '`mainCol`: The main red stripe in the center (holds the **Image** component).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mainCol`：中心的主要红色条纹（包含**图像**组件）。'
- en: '`trim00`: The red line at the top (holds the **Image** component).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim00`：顶部的红线（包含**图像**组件）。'
- en: '`trim01`: The red line at the bottom (holds the **Image** component).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim01`：底部的红线（包含**图像**组件）。'
- en: '`GameOverText`: The main **GAME OVER** text (holds the **Text** component).'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameOverText`：主要的**GAME OVER**文本（包含**文本**组件）。'
- en: 'Thankfully, we don''t really need to worry too much about what their roles
    are because we have already established this in the previous section. To duplicate
    our game objects and move them from the `title` scene to `gameOver`, perform these
    steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们实际上不必太担心它们的角色是什么，因为我们已经在上一节中建立了这一点。要复制我们的游戏对象并将它们从`title`场景移动到`gameOver`，请执行以下步骤：
- en: While still in our `title` scene, hold *Ctrl* (*command* on the Mac) on the
    keyboard and select **Main Camera** and **Canvas**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们仍然处于`title`场景时，按住键盘上的*Ctrl*（在Mac上为*command*）并选择**主相机**和**Canvas**。
- en: Both our objects will be highlighted. Right-click on either one of them and
    select **Copy** from the drop-down list.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的两个对象都将被突出显示。右键单击其中的任何一个，然后从下拉列表中选择**复制**。
- en: Open the `gameOver` scene.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`gameOver`场景。
- en: In the `GameOverText`. We will replace these with our copied game objects.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameOverText`中。我们将用我们复制的游戏对象替换这些内容。
- en: Right-click in an open space of the **Hierarchy** window and select **Paste**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口的空白区域右键单击并选择**粘贴**。
- en: Click on the arrow next to the `Canvas` game object in the `Title` game object
    and then click on **Rename** from the drop-down list.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Title`游戏对象旁边的`Canvas`游戏对象旁边点击箭头，然后从下拉列表中选择**重命名**。
- en: Rename the game object to `GameOverTitle`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象重命名为`GameOverTitle`。
- en: Click on the arrow next to `GameOverTitle` and rename the `TitleText` game object
    to `GameOverText`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`GameOverTitle`旁边的箭头，将`TitleText`游戏对象重命名为`GameOverText`。
- en: Select the `shootToStart` game object and press *Delete* on your keyboard.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`shootToStart`游戏对象，然后在键盘上按*Delete*键。
- en: 'To confirm what we have done so far, the following screenshot shows the `gameOver`
    scene:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们到目前为止所做的工作，以下截图显示了`gameOver`场景：
- en: '![Figure 8.34 – The Hierarchy window with its ordered game objects'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34 – 带有序列游戏对象的层次结构窗口'
- en: '](img/Figure_8.34_B18381.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.34_B18381.jpg]'
- en: Figure 8.34 – The Hierarchy window with its ordered game objects
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34 – 带有序列游戏对象的层次结构窗口
- en: With `GameOverText` still selected, change its `killer wave` to `game over`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameOverText`仍然被选择的情况下，将其`killer wave`更改为`game over`。
- en: Save the scene.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'This is what our `gameOver` scene should look like:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`gameOver`场景应该看起来像的：
- en: '![Figure 8.35 – The Game Over screen'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.35 – 游戏结束屏幕'
- en: '](img/Figure_8.35_B18381.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.35_B18381.jpg]'
- en: Figure 8.35 – The Game Over screen
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35 – 游戏结束屏幕
- en: In this section, we discovered that we can simply copy and paste game objects
    from one scene to another as long as we work within the same Unity project. This
    saves time and effort and keeps our game looking uniform in accordance with the
    rest of the scenes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们发现我们可以在同一个Unity项目中简单地复制和粘贴游戏对象，只要我们在同一个场景中工作。这节省了时间和精力，并使我们的游戏看起来与场景的其他部分保持一致。
- en: In the next section, we will learn how to animate our UI game objects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何对UI游戏对象进行动画处理。
- en: Preparing to animate UI game objects
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备对UI游戏对象进行动画处理
- en: In this section, we will use a number of techniques that we have already covered,
    so we won't be going into the same level of detail. Once we have duplicated and
    changed the game objects, we will also be adding animation elements to make our
    2D visuals less static.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们已经介绍过的多种技术，因此不会深入到相同的程度。一旦我们复制并更改了游戏对象，我们还将添加动画元素，使我们的2D视觉效果不那么静态。
- en: We will be using a similar methodology to the `gameOver` scene by copying our
    previous scene's `Canvas` with its child game objects (not the `gameOver` scene
    as it has the basic elements we need. This only requires a couple of amendments
    before moving on to the animation phase.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与`gameOver`场景类似的方法，通过复制我们之前场景的`Canvas`及其子游戏对象（不是`gameOver`场景，因为它包含我们需要的元素。这只需要在进入动画阶段之前进行一些修改）。
- en: 'To set up the `level1` scene, perform the following steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`level1`场景，执行以下步骤：
- en: Make sure our `gameOver` scene is still open in the Unity Editor. This is because
    we are going to copy some game objects over into the `level1` scene.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们的`gameOver`场景仍在Unity编辑器中打开。这是因为我们将要复制一些游戏对象到`level1`场景中。
- en: In the `Canvas` game object and click on **Copy** from the drop-down list.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas`游戏对象中，从下拉列表中选择**复制**。
- en: Open the `level1` scene from the **Project** window.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口打开`level1`场景。
- en: Right-click in the `Canvas` in our `level1` scene.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`level1`场景中的`Canvas`上右键单击。
- en: Next, we will rename two game objects to suit our `level1` scene.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将重命名两个游戏对象以适应我们的`level1`场景。
- en: Expand the `Canvas` game object in the `GameOverTitle` game object. Right-click
    on it and select **Rename** from the drop-down list.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameOverTitle`游戏对象中扩展`Canvas`游戏对象。右键单击它，从下拉列表中选择**重命名**。
- en: Rename the game object to `LevelTitle`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏对象重命名为`LevelTitle`。
- en: Expand the `LevelTitle` game object in the **Hierarchy** window.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中展开`LevelTitle`游戏对象。
- en: Select `GameOverText` in the `Level`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Level`中选择`GameOverText`。
- en: That's all that we need to do to our `Canvas` game object in the `LEVEL 1`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要在`LEVEL 1`的`Canvas`游戏对象上做的所有事情。
- en: 'With the `Level` game object still selected, remove `LEVEL 1`, as shown in
    the following screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择`Level`游戏对象的同时，移除`LEVEL 1`，如下面的屏幕截图所示：
- en: '![Figure 8.36 – Level 1 text typed out'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.36 – Level 1 text typed out]'
- en: '](img/Figure_8.36_B18381.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.36_B18381.jpg]'
- en: Figure 8.36 – Level 1 text typed out
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36 – Level 1 text typed out
- en: We are now ready to start animating the UI 2D text and its image. All the game
    objects that we will be animating sit within the `LevelTitle` game object.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始对UI 2D文本及其图像进行动画处理了。我们将要动画化的所有游戏对象都位于`LevelTitle`游戏对象内。
- en: 'To set up our animation, we need to do the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的动画，我们需要执行以下操作：
- en: While you are still in the `level1` scene, select `LevelTitle` under the **Canvas**
    game object in the **Hierarchy** window.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你仍然在`level1`场景中时，在**层次结构**窗口中，选择**Canvas**游戏对象下的`LevelTitle`。
- en: In the `LevelTitle`, click on the **Add Component** button at the bottom.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LevelTitle`中，点击底部的**添加组件**按钮。
- en: Type in `Animator` until you see the word **Animator** appear, and then select
    it.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Animator`直到你看到单词**Animator**出现，然后选择它。
- en: 'Our `LevelTitle` game object now has an `LevelTitle` game object. To do that,
    follow these steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`LevelTitle`游戏对象现在有一个`LevelTitle`游戏对象。要这样做，请遵循以下步骤：
- en: In the `Assets/Animator`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Animator`。
- en: Right-click in an open space of the **Project** window and select **Create**
    from the drop-down list, followed by **Animator Controller**.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口的空白区域右键单击，然后从下拉列表中选择**创建**，接着选择**Animator Controller**。
- en: Change the name of the new `LevelTitle`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改新的`LevelTitle`的名称。
- en: We now need to attach the new `LevelTitle` **Animator Controller** to our **Animator**
    component.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将新的`LevelTitle` **Animator Controller**附加到我们的**Animator**组件上。
- en: Back in the `LevelTitle` game object, and click on the small round circle (which
    is referred to as a remote, denoted by an arrow in the following screenshot) next
    to the `LevelTitle` game object from the drop-down list.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LevelTitle`游戏对象中，点击旁边的小圆形圆圈（在以下屏幕截图中被标记为远程，用箭头表示）从下拉列表中选择。
- en: 'The following screenshot shows the `LevelTitle` game object with the `LevelTitle`
    controller selected:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了已选择`LevelTitle`控制器的`LevelTitle`游戏对象：
- en: '![Figure 8.37 – LevelTitle game object with an Animator component and a LevelTitle
    Animator Controller'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.37 – LevelTitle game object with an Animator component and a LevelTitle
    Animator Controller]'
- en: '](img/Figure_8.37_B18381.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.37_B18381.jpg]'
- en: Figure 8.37 – LevelTitle game object with an Animator component and a LevelTitle
    Animator Controller
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37 – 带有Animator组件和LevelTitle Animator控制器的LevelTitle游戏对象
- en: 'Next, we need to create an animation so that we can add it to the **Animator
    Controller**:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个动画，以便我们可以将其添加到**Animator Controller**：
- en: In the `Assets/Animator` location, right-click in an open space. Select **Create**
    | **Animation**.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Animator`位置，在空白区域右键单击。选择**创建** | **动画**。
- en: Rename the `levelTitle_A`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`levelTitle_A`重命名。
- en: Let's now open the `levelTitle_A` clip to it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开`levelTitle_A`片段。
- en: At the top of the Unity Editor, click on **Window** followed by **Animator**.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，点击**窗口**然后选择**动画器**。
- en: This will open the **Animator** window.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开**动画器**窗口。
- en: Select the `LevelTitle` game object in the **Hierarchy** window. The content
    for the **Animator** will appear with its three states (**Any State**, **Entry**,
    and **Exit**).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`LevelTitle`游戏对象。**动画器**的内容将出现，包括其三个状态（**任何状态**、**进入**和**退出**）。
- en: 'The following screenshot shows the **Animator** window with its three default
    states and also a reference to the location of the **Animator Controller** that
    is selected:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**动画器**窗口及其三个默认状态，以及所选**动画控制器**的位置引用：
- en: '![Figure 8.38 – Animator window with the name of the location of the Animator
    Controller file'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.38 – 包含动画控制器文件位置名称的动画器窗口'
- en: '](img/Figure_8.38_B18381.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.38_B18381.jpg)'
- en: Figure 8.38 – Animator window with the name of the location of the Animator
    Controller file
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38 – 包含动画控制器文件位置名称的动画器窗口
- en: Before we drop the animation clip in, it will benefit us to have a small time
    delay before the clip is played; otherwise, the animation might play too soon.
    In order to fix this, we can make an empty state that has a time limit. We can
    set this `levelTitle_A`).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将动画片段拖入之前，在片段播放前有一个小的时间延迟对我们是有益的；否则，动画可能会播放得太早。为了解决这个问题，我们可以创建一个有时间限制的空状态。我们可以设置这个`levelTitle_A`）。
- en: 'To create an **idle** state and hook it up to the intended animation clip,
    follow these steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**空闲**状态并将其连接到目标动画片段，请按照以下步骤操作：
- en: 'Right-click in an empty part of the **Animator** window and select **Create
    State** | **Empty**. The following screenshot shows the drop-down list we should
    expect:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**窗口的空白部分右键单击，并选择**创建状态** | **空**。以下截图显示了我们应该期望的下拉列表：
- en: '![Figure 8.39 – Creating an empty state'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.39 – 创建一个空状态'
- en: '](img/Figure_8.39_B18381.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.39_B18381.jpg)'
- en: Figure 8.39 – Creating an empty state
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39 – 创建一个空状态
- en: Select **New State** and, in the **Inspector** window, change the **New State**
    name to **Idle**. Then, press *Enter* on your keyboard.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新状态**，然后在**检查器**窗口中，将**新状态**名称更改为**空闲**。然后，按键盘上的*Enter*键。
- en: Now we can drag `levelTitle_A` from the **Project** window to the **Animator**
    window.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将`levelTitle_A`从**项目**窗口拖动到**动画器**窗口。
- en: We now need to join the transition from our `Idle` game state to the `levelTitle_A`
    state.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要将我们的`Idle`游戏状态与`levelTitle_A`状态之间的转换连接起来。
- en: Right-click on the **Idle** state and select **Make Transition** from the drop-down
    list.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**空闲**状态上右键单击，并从下拉列表中选择**创建转换**。
- en: Select **levelTitle_A** to make a connection between the two states.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**levelTitle_A**以在两个状态之间建立连接。
- en: 'The following screenshot indicates what our states should look like now:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的状态现在应该看起来是什么样子：
- en: '![Figure 8.40 – Our animation states transitioning from Entry > Idle > levelTitle_A'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.40 – 我们的动画状态从Entry > Idle > levelTitle_A转换'
- en: '](img/Figure_8.40_B18381.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.40_B18381.jpg)'
- en: Figure 8.40 – Our animation states transitioning from Entry > Idle > levelTitle_A
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.40 – 我们的动画状态从Entry > Idle > levelTitle_A转换
- en: 'It will not be necessary to use the **Animator** window after the animation
    is complete, and we may need to tweak the delay. However, for this, we will need
    to use the **Animation** window, so it''s ideal to have this at the bottom of
    the screen. To do that, perform these steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 动画完成后，可能不需要使用**动画器**窗口，我们可能需要调整延迟。然而，为此，我们需要使用**动画**窗口，因此最好将其放在屏幕底部。为此，请执行以下步骤：
- en: In the **Project** window, click on the **Add Tab** button from the drop-down
    list.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，从下拉列表中点击**添加标签**按钮。
- en: Click on **Animation**.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**动画**。
- en: 'The following screenshot is in accordance with the preceding numbered bullets:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图与前面的编号项目一致：
- en: '![Figure 8.41 – Displaying the Animation window'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.41 – 显示动画窗口'
- en: '](img/Figure_8.41_B18381.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.41_B18381.jpg)'
- en: Figure 8.41 – Displaying the Animation window
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.41 – 显示动画窗口
- en: In this section, we have brought in the **GAME OVER** UI art and replaced the
    text from its **Text** component; we also brought over its sprites (banner and
    trim) and **Image** component to give us a representation of which level we are
    on. We then prepared the game objects to be animated with the **Animator Controller**
    and its states, followed by creating a blank **Animation** clip.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们引入了 **GAME OVER** UI 艺术并将其文本从其 **Text** 组件中替换；我们还带来了其精灵（横幅和修剪）和 **Image**
    组件，以给出我们当前所在级别的表示。然后我们使用 **Animator Controller** 和其状态准备游戏对象进行动画，随后创建了一个空的 **动画**
    片段。
- en: We can now start animating the entrance and exit for our **LEVEL 1** UI art
    in the next section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始动画化下一节中我们的 **LEVEL 1** UI 艺术的进入和退出。
- en: Animating our UI level title
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画我们的 UI 级别标题
- en: 'We are going to animate two game objects: the level title and the main strip
    bar in the `level1` scene. In the previous section, we set up the **Animation**
    window at the bottom of the Unity Editor. The following screenshot shows our current
    setup for the placement of the windows, which may be helpful for reference purposes:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要动画化两个游戏对象：`level1` 场景中的级别标题和主要条形栏。在前一节中，我们在 Unity 编辑器底部设置了 **动画** 窗口。以下截图显示了我们的当前窗口布局设置，可能有助于参考：
- en: '![Figure 8.42 – Recommended Unity Editor window layouts'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.42 – 推荐的 Unity 编辑器窗口布局'
- en: '](img/Figure_8.42_B18381.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.42_B18381.jpg)'
- en: Figure 8.42 – Recommended Unity Editor window layouts
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.42 – 推荐的 Unity 编辑器窗口布局
- en: 'With regard to the animation itself, we will be animating the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动画本身，我们将动画化以下内容：
- en: The level text that moves on to the screen.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动到屏幕上的级别文本。
- en: The main center strip will glow red.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要中心条将变红。
- en: The text that will exit the screen.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将退出屏幕的文本。
- en: 'The following screenshots show this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这一点：
- en: '![Figure 8.43 – UI animation sequence for level 1'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.43 – 第 1 级的 UI 动画序列'
- en: '](img/Figure_8.43_B18381.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.43_B18381.jpg)'
- en: Figure 8.43 – UI animation sequence for level 1
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.43 – 第 1 级的 UI 动画序列
- en: So, the four main elements to animate are the `Level` game object, which contains
    the 2D `mainCol`, `trim00`, and `trim01` game objects that contain the `Level`
    game object first.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要动画化的四个主要元素是包含 Level 游戏对象的 `Level` 游戏对象，它首先包含 2D `mainCol`、`trim00` 和 `trim01`
    游戏对象。
- en: Animating the 2D text component
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画 2D 文本组件
- en: 'In this section, we are going to animate the text from the left to the center.
    It will pause so the player has a chance to read it. Then, it will move out of
    the screen:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从左到右动画化文本，它将暂停以便玩家有时间阅读，然后它将移出屏幕：
- en: In the `Canvas` game object to expand its content if it isn't expanded already.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Canvas` 游戏对象中展开其内容，如果尚未展开的话。
- en: Click on the arrow next to the `LevelTitle` to do the same.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `LevelTitle` 旁边的箭头执行相同的操作。
- en: Select the `Level` game object.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Level` 游戏对象。
- en: 'In the **Animation** window, click on the record button, as shown in the following
    screenshot:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **动画** 窗口中，点击记录按钮，如下截图所示：
- en: '![Figure 8.44 – Record button for animation'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.44 – 动画记录按钮'
- en: '](img/Figure_8.44_B18381.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.44_B18381.jpg)'
- en: Figure 8.44 – Record button for animation
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.44 – 动画记录按钮
- en: With our animation track line scrubbed (note that scrub is an animation term
    for dragging our timeline indicator) all the way back to `Level` game object from
    the center of the Canvas to the left in the **Scene** view by doing the following.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下操作，我们将动画轨迹线刮擦（注意刮擦是动画术语，用于拖动我们的时间轴指示器）到 `Level` 游戏对象，从 Canvas 的中心到 **场景**
    视图中的左侧。
- en: 'With the `Level` game object still selected in the `-2000` and `2000`) property
    fields to move our 2D `LEVEL 1` text out of the **Canvas** view, as shown in the
    following screenshot:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `-2000` 和 `2000` 属性字段中选择并拖动 `Level` 游戏对象，以将我们的 2D `LEVEL 1` 文本从 **Canvas**
    视图中移出，如下截图所示：
- en: '![Figure 8.45 – Position the Level game object Rect Transform property values'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.45 – 定位 Level 游戏对象 Rect Transform 属性值'
- en: '](img/Figure_8.45_B18381.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.45_B18381.jpg)'
- en: Figure 8.45 – Position the Level game object Rect Transform property values
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.45 – 定位 Level 游戏对象 Rect Transform 属性值
- en: Now that our `LEVEL 1` 2D text is pushed out of the way, we can scrub the animation
    line forward.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `LEVEL 1` 2D 文本已经被推到一边，我们可以将动画线向前刮擦。
- en: 'Click and drag within the timeline digits, as shown in the following screenshot:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间轴数字内点击并拖动，如下截图所示：
- en: '![Figure 8.46 – Adjusting the display of the timeline'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.46 – 调整时间轴的显示'
- en: '](img/Figure_8.46_B18381.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.46_B18381.jpg)'
- en: Figure 8.46 – Adjusting the display of the timeline
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.46 – 调整时间轴的显示
- en: In the **Animation** window, drag the white vertical line from **0:00** to **0:34**.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，将白色垂直线从**0:00**拖动到**0:34**。
- en: In the `Level` game object's **Rect Transform** **Left** and **Right** properties
    to 0.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Level`游戏对象的**Rect Transform** **Left**和**Right**属性设置为0。
- en: The fields will turn red to show the change has been recorded. The animation
    timeline in the **Animation** window will gain keyframes from the movement of
    the 2D text.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 字段将变为红色以显示更改已被记录。动画窗口中的动画时间轴将从2D文本的运动中获得关键帧。
- en: 'The following screenshot shows the changes made to the timeline:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了时间轴上的更改：
- en: '![Figure 8.47 – Animation timeline with its recorded area'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.47 – Animation timeline with its recorded area'
- en: '](img/Figure_8.47_B18381.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.47_B18381.jpg](img/Figure_8.47_B18381.jpg)'
- en: Figure 8.47 – Animation timeline with its recorded area
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.47 – 带有记录区域的动画时间轴
- en: 'We obviously want the `LEVEL 1` text to stay where it is for a few seconds
    before it leaves the screen again. To make the text pause in the center before
    moving, follow these steps:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然希望`LEVEL 1`文本在再次离开屏幕之前停留在原地几秒钟。为了使文本在移动前暂停在中心，请按照以下步骤操作：
- en: In the **Animation** window, move the white line from **0:34** to **1:25**.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，将白色线条从**0:34**移动到**1:25**。
- en: Click on the **Add keyframe** button.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加关键帧**按钮。
- en: 'The following screenshot shows the timeline is at **1:25**, with new keyframes
    added while the record button is clicked on:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了时间轴在**1:25**，在点击记录按钮时添加了新的关键帧：
- en: '![Figure 8.48 – Adding a keyframe button'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.48 – Adding a keyframe button'
- en: '](img/Figure_8.48_B18381.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.48_B18381.jpg](img/Figure_8.48_B18381.jpg)'
- en: Figure 8.48 – Adding a keyframe button
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.48 – 添加关键帧按钮
- en: For our next keyframe point, drag the white line to **1:50**.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的下一个关键帧点，将白色线条拖动到**1:50**。
- en: Now we have come to the stage where we want to move the UI text from its center
    position to out of view of the camera.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了想要将UI文本从其中心位置移动到摄像机视图中不可见的位置的阶段。
- en: Select the `Level` game object.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Level`游戏对象。
- en: In the `2000`
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`2000`
- en: '`-2000`'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-2000`'
- en: 'This will push the `LEVEL 1` text out of the camera view, as shown in the following
    screenshot:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使`LEVEL 1`文本从摄像机视图中移出，如下面的截图所示：
- en: '![Figure 8.49 – Level game object Rect Transform recorded property values'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.49 – Level game object Rect Transform recorded property values'
- en: '](img/Figure_8.49_B18381.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.49_B18381.jpg](img/Figure_8.49_B18381.jpg)'
- en: Figure 8.49 – Level game object Rect Transform recorded property values
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.49 – 级别游戏对象Rect Transform记录的属性值
- en: Move your mouse cursor down to the timeline **Animation** window. Then, click
    and press *F* on your keyboard. This will show all of the keyframes for the total
    animation we have just done.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标光标向下移动到时间轴**动画**窗口。然后，点击并按键盘上的*F*键。这将显示我们刚刚完成的总动画的所有关键帧。
- en: Click on the **record** button in the **Animation** window timeline to stop
    recording, and scrub backward and forward to see our 2D text animate in, pause,
    and then move out of the screen.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口的时间轴上点击**记录**按钮以停止记录，并前后滚动以查看我们的2D文本动画进入、暂停然后移出屏幕。
- en: We have made a start by animating the `Level 1` text within the `Canvas` with
    Unity's **Animation** system.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用Unity的**动画**系统，在`Canvas`中动画化了`Level 1`文本，开始了我们的尝试。
- en: Our UI text starts on the far left (out of view of the camera), animates into
    the center, pauses, and then animates out of view.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的UI文本从最左边开始（在摄像机视图中不可见），动画进入中心，暂停，然后动画移出视图。
- en: Now we can continue to animate the UI and move our focus from positioning to
    changing our UI's color (R, G, B, A) to a glowing red in the next section. This
    will show that our animation isn't just applied to one component but is shared
    through a series of components. We will animate the **Image** component next.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续动画化UI，并将我们的重点从定位转移到在下一节中更改UI的颜色（R、G、B、A）到发光的红色。这将表明我们的动画不仅应用于一个组件，而是通过一系列组件共享。我们将接下来动画化**图像**组件。
- en: Animating the Image component's center strip
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画图像组件的中心条
- en: The second part of the animation phase is to have the center strip for the level
    title glow red and then disappear. To do this, all animation for the `mainCol`,
    `trim00`, and `trim01` game objects will be manipulated in the **Inspector** window
    through their **Image** component's **Color** settings.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 动画阶段的第二部分是使级别标题的中心条发光红色然后消失。为此，将使用**检查器**窗口中的`mainCol`、`trim00`和`trim01`游戏对象的**图像**组件的**颜色**设置来操作所有动画。
- en: 'Let''s start animating the **Image** components for all three game objects:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始动画化所有三个游戏对象的**图像**组件：
- en: In the `mainCol`, `trim00`, and `trim01`. These are the game objects we will
    be animating.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mainCol`、`trim00`和`trim01`中。这些是我们将要动画化的游戏对象。
- en: In the **Animation** window, move the line bar all the way back to **0:00**.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，将线条条完全移回**0:00**。
- en: Click on the **record** button in the **Animation** window.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中点击**记录**按钮。
- en: 'With all three game objects still selected, click on the `255`, `0`, `0`, and
    `0`. Refer to the following screenshot:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有三个游戏对象仍然被选中的情况下，点击`255`、`0`、`0`和`0`。参见图示：
- en: '![Figure 8.50 – Update the Image component Color values while recording'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.50 – 在录制时更新图像组件颜色值](img/Figure_8.50_B18381.jpg)'
- en: '](img/Figure_8.50_B18381.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.50 – B18381.jpg](img/Figure_8.50_B18381.jpg)'
- en: Figure 8.50 – Update the Image component Color values while recording
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.50 – 在录制时更新图像组件颜色值](img/Figure_8.50_B18381.jpg)'
- en: 'Our `mainCol`, `trim00`, and `trim01` **Image** component''s alpha color properties
    (note that alpha is the **A** from **R**, **G**, **B**, and **A**). The **Alpha**
    setting will alter the transparency of the image:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`mainCol`、`trim00`和`trim01`**图像**组件的透明度颜色属性（注意，透明度是**R**、**G**、**B**和**A**中的**A**）。**透明度**设置将改变图像的透明度：
- en: '![Figure 8.51 – Image component keyframes in the Animation window'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.51 – 动画窗口中的图像组件关键帧](img/Figure_8.51_B18381.jpg)'
- en: '](img/Figure_8.51_B18381.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.51_B18381.jpg](img/Figure_8.51_B18381.jpg)'
- en: Figure 8.51 – Image component keyframes in the Animation window
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.51 – 动画窗口中的图像组件关键帧
- en: 'In basic terms, the three game objects are invisible at the start of the animation
    in the **Scene** window. Next, we need to make the images come out of the transparency
    phase and glow red. To do that, we now need to move our timeline indicator over
    to **0:55** and perform the following steps:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本术语来说，三个游戏对象在**场景**窗口的动画开始时是不可见的。接下来，我们需要让图像从透明阶段出来并变红。为此，我们现在需要将时间轴指示器移动到**0:55**并执行以下步骤：
- en: 'With the three game objects still selected, change the `255`, `0`, `0`, and
    `120`, as shown in the following screenshot:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择三个游戏对象的情况下，将`255`、`0`、`0`和`120`更改为如下截图所示：
- en: '![Figure 8.52 – Update the Image component color values for our three selected
    game objects'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.52 – 更新我们选择的三个游戏对象的图像组件颜色值](img/Figure_8.52_B18381.jpg)'
- en: '](img/Figure_8.52_B18381.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.52 – B18381.jpg](img/Figure_8.52_B18381.jpg)'
- en: Figure 8.52 – Update the Image component color values for our three selected
    game objects
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.52 – 更新我们选择的三个游戏对象的图像组件颜色值](img/Figure_8.52_B18381.jpg)'
- en: 'Our three game objects have now become visible again in the **Scene** view.
    The final part of the animation is to make the three game objects turn invisible
    again. Instead of going back into the **Color** value settings, we can simply
    copy and paste the keys we created in the timeline at **0:00**. To copy our keyframes,
    do the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们三个游戏对象现在在**场景**视图中再次可见。动画的最后一部分是让三个游戏对象再次变为不可见。我们不需要回到**颜色**值设置中，我们可以简单地复制并粘贴我们在时间轴上**0:00**处创建的键。要复制我们的关键帧，请执行以下操作：
- en: With our three game objects and the record button still selected in the **Animation**
    window, move the timeline indicator back to **0:00**.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，仍然选择三个游戏对象和记录按钮，将时间轴指示器移回**0:00**。
- en: 'Select all three `Image.Color.a` changes in the **Animation** window, as shown
    in the following screenshot:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，选择所有三个`Image.Color.a`更改，如图示：
- en: '![Figure 8.53 – Select the three keyframes in the Animation window'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.53 – 在动画窗口中选择三个关键帧](img/Figure_8.53_B18381.jpg)'
- en: '](img/Figure_8.53_B18381.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.53 – B18381.jpg](img/Figure_8.53_B18381.jpg)'
- en: Figure 8.53 – Select the three keyframes in the Animation window
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.53 – 在动画窗口中选择三个关键帧](img/Figure_8.53_B18381.jpg)'
- en: Press *Ctrl* (*Command* on the Mac) and *C* on your keyboard to copy the keyframes.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*（在Mac上为*Command*）和*C*复制关键帧。
- en: Click on the record button in the **Animation** window to stop recording the
    animation.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中点击记录按钮以停止录制动画。
- en: Scrub to **1:50** and press *Ctrl* (*Command* on the Mac) and *V* on your keyboard
    to paste.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**1:50**并按键盘上的*Ctrl*（在Mac上为*Command*）和*V*粘贴。
- en: Move your mouse cursor to the **Animation** window. Click and press *F* on the
    keyboard to get a full view of the timeline. Move the cursor back and forth to
    see the level text animating into the scene and the center strip glowing red.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标光标移至**动画**窗口。点击并按键盘上的*F*键以获得时间轴的全视图。移动光标来回查看级别文本如何动画进入场景以及中心条变红。
- en: 'When our Level 1 scene starts, we will see the title and the red bar before
    the animation, which we don''t want. Therefore, we need to set the Level 1 text
    and red bar to the same values as the first frame of our animation:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的第1级场景开始时，我们会看到动画前的标题和红色条，这是我们不想看到的。因此，我们需要将第1级文本和红色条设置为与我们的动画第一帧相同的值：
- en: Select the `mainCol` game object and set the `0`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`mainCol`游戏对象并设置`0`。
- en: Set the `trim00` `0`.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`trim00`为`0`。
- en: Set the `trim01` `0`.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`trim01`为`0`。
- en: Set the `-2000` and the `2000`.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`-2000`和`2000`。
- en: 'The following screenshot shows the default position and alpha settings of the
    previous steps:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了之前步骤的默认位置和alpha设置：
- en: '![Figure 8.54 – Default position and color of our level title UI'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.54 – 我们关卡标题UI的默认位置和颜色]'
- en: '](img/Figure_8.54_B18381.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.54 – B18381.jpg](img/Figure_8.54_B18381.jpg)'
- en: Figure 8.54 – Default position and color of our level title UI
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.54 – 我们关卡标题UI的默认位置和颜色
- en: Save the scene.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: Let's remind ourselves briefly of what we have covered so far before we move
    on to the final section. We took our `mainCol`, `trim00`, and `trim01` game objects
    and changed their **Image** component's **Color** alpha values over a series of
    keyframes using the animation timeline.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到最后一个部分之前，让我们简要回顾一下我们已经覆盖的内容。我们取出了`mainCol`、`trim00`和`trim01`游戏对象，并使用动画时间线在一系列关键帧上更改了它们的**图像**组件的**颜色**alpha值。
- en: Let's now move on to the next section where we will copy our art, text, and,
    in some cases, animation into other scenes. From there, we will tailor the components
    to each scene.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入下一节，我们将复制我们的艺术作品、文本，在某些情况下，还将复制动画到其他场景中。从那里，我们将调整组件以适应每个场景。
- en: Copying and pasting art, text, and animation into other scenes
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将艺术作品、文本和动画复制粘贴到其他场景中
- en: 'Finally, we can copy all of the hard work of our `level1` scene (including
    its animation) and paste it into the `level2` and `level3` scenes and amend each
    level number. To do that, follow these steps:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以复制`level1`场景（包括其动画）的所有辛勤工作，并将其粘贴到`level2`和`level3`场景中，并修改每个关卡编号。为此，请按照以下步骤操作：
- en: In the **Hierarchy** window, select **Canvas** and press *Ctrl* (*Command* on
    the Mac) and *C* on your keyboard.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**Canvas**，然后按键盘上的*Ctrl* (*Mac上的*Command*) 和 *C*。
- en: In the `level2` in `Assets/Scene`.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scene`中的`level2`。
- en: Click in an open space of the `level1` scene's `Canvas` game object and all
    of its content.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`level1`场景的`Canvas`游戏对象的一个开放空间中点击，并选择所有内容。
- en: Select the `Level` game object in the `Canvas` and `LevelTitle`).
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas`和`LevelTitle`中选择`Level`游戏对象。
- en: Change the `Level 1` to `Level 2`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Level 1`改为`Level 2`。
- en: Save the scene.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: Repeat the process for the `level3` scene.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`level3`场景重复此过程。
- en: '![Figure 8.55 – Duplicate and edit the level title number'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.55 – 复制并编辑关卡标题编号]'
- en: '](img/Figure_8.55_B18381.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.55 – B18381.jpg](img/Figure_8.55_B18381.jpg)'
- en: Figure 8.55 – Duplicate and edit the level title number
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.55 – 复制并编辑关卡标题编号
- en: Well done! Another big chapter has been conquered. We have started to make our
    game shine with some sweet art that we made ourselves. Let's recap what we have
    achieved.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！另一个大章节已经被征服。我们已经开始用我们自己制作的精美艺术作品让我们的游戏发光。让我们回顾一下我们已经取得的成就。
- en: 'We took some plain gray scenes and made them more presentable and fit with
    our sci-fi game. This was all thanks to the Unity Editor, as we were able to achieve
    this with no scripting. The main components we covered were as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一些普通的灰色场景变得更有吸引力，并与我们的科幻游戏更匹配。这一切都归功于Unity编辑器，因为我们能够不使用脚本就实现这一点。我们涵盖的主要组件如下：
- en: '**Text**: We imported a custom font and tweaked it within the component itself.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**: 我们导入了一个自定义字体，并在组件内部调整了它。'
- en: '**Image**: With any sprites, we set our colors to create a series of red stripes
    with transparency.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**: 对于任何精灵，我们设置颜色以创建一系列带有透明度的红色条纹。'
- en: '**Animator Controller**: Held states for when the **Image** and **Text** components
    were to be animated.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画控制器**: 当**图像**和**文本**组件需要动画时的保持状态。'
- en: '**Animation**: Each keyframe for a mixture of components was set in a single
    timeline animation.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**: 每个组件混合的关键帧都在单个时间线动画中设置。'
- en: Finally, we didn't need to repeat the process followed for the UI we created
    at the beginning of the chapter by adding the UI's text, images, animation all
    over again. We took the majority of these game objects and components from one
    scene (killer wave title screen) and pasted the game objects to the existing scenes
    (level title and game over) to act as a template for the game's theme. Once these
    components were in place, we simply modified the text field (changing the text
    from killer wave to level 1 and so on).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不需要通过再次添加UI的文本、图像和动画来重复本章开头创建的UI过程。我们主要从场景（杀手波浪标题屏幕）中提取了这些游戏对象和组件，并将游戏对象粘贴到现有场景（关卡标题和游戏结束）中，作为游戏主题的模板。一旦这些组件就位，我们只需修改文本字段（将文本从杀手波浪改为关卡1等）。
- en: This makes working with Unity fast and user-friendly. We didn't need to start
    over again each time for a new UI scene from scratch. With our UI visually improved,
    you should hopefully start to feel like our project is turning more into a polished-looking
    prototype.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用 Unity 变得快速且用户友好。我们不需要每次从头开始为新 UI 场景工作。随着我们的 UI 视觉上得到改善，你可能会希望开始觉得我们的项目正变得更加精致。
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about taking our game project and polishing its current content
    with regard to the existing UI. It is also required for your Unity Programmer
    Exam to understand what tools and components we have to help us create our game
    with regard to the *Working in the art pipeline* core exam skill.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于对我们的游戏项目进行润色，使其现有内容与现有 UI 保持一致。这也要求你在 Unity 程序员考试中理解我们有哪些工具和组件可以帮助我们根据“在艺术管道中工作”的核心考试技能来创建游戏。
- en: We also took our **Text** and **Image** components and created one piece of
    animation from multiple game objects. These animations were called from the **Animator
    Controller** state machine.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还取用了 **文本** 和 **图像** 组件，并从多个游戏对象中创建了一个动画。这些动画是通过 **动画控制器** 状态机调用的。
- en: In your future projects, you will have the option to keep your UI presentable
    while putting your game loop together.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的未来项目中，你将有机会在构建游戏循环的同时保持你的 UI 令人印象深刻。
- en: In the next chapter, we will extend our current UI skills by making our `shop`
    scene more flexible with a range of screen ratios. Additionally, we will create
    a UI to sit at the bottom of our in-game levels.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使我们的 `商店` 场景具有多种屏幕比例来扩展我们当前的 UI 技能。此外，我们还将创建一个位于游戏关卡底部的 UI。
