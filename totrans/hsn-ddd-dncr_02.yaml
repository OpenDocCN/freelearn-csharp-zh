- en: Language and Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the importance of language briefly. In
    the software industry, we developed this naïve perception that the only languages
    that matter are programming languages. That's why we often speak complete gibberish
    and our colleagues from other departments, or our customers, have a hard time
    understanding what we're trying to say. This issue is mutual because many lines
    of business have developed their jargon, which other people might not completely
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to go deeper into the importance of language and
    go through several examples of mockups and code. We'll also get into the concept
    of language in a context and introduce the Ubiquitous Language, one of the most
    critical aspects of **Domain-Driven Design** (**DDD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll go deeper into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous Language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why language is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making implicit explicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language in context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubiquitous Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It isn't a coincidence that the website of Eric Evans, the author of the original
    DDD book, is located at [http://domainlanguage.com](http://domainlanguage.com).
    Fundamental concepts of DDD, such as Ubiquitous Language and Bounded Context,
    are both based on the idea of language. It might sound strange to those who haven't
    spent many years developing software because, for less experienced developers,
    the only language that's important is a programming language. We learn to program
    usually by studying some concepts and applying them to practice using one of the
    programming languages. We think that we can translate a human language into a
    programming language, and this is the essence of our work. There's some degree
    of truth there indeed. However, this is by far not the essential part of the developer's
    daily routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two people can understand each other only if they can speak the same language.
    It doesn''t necessarily need to be verbal; it might very well be sign language
    or the language of music. But both interlocutors need to share the same understanding
    of this universal language. Otherwise, there will be trouble. Not only do they
    need to speak the same language, but this language must be in one context. There''s
    a whole book called *American and British English: Divided by a Common Language?*
    by Paul Baker, which describes how different the same language became after being
    split by the ocean for a long enough time.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look deeper into the importance of language and the context
    in which these concepts are crucial for successful software projects.
  prefs: []
  type: TYPE_NORMAL
- en: Domain language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every industry has developed a particular language that only people from
    that industry fully understand. Some of those words spread out to the world, like
    the automotive world, which enriched our language with terms such as gearbox,
    ignition, combustion engine, and even body shop. The last term is ambiguous when
    being looked at outside of the domain. But as soon as the domain is specified,
    it becomes clear that we don't mean a beauty product boutique, nor a software
    outsourcing company, but a place where car bodies are being repaired after accidents.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the automotive industry isn't unique in this sense. Other industries
    have developed their terms, and their language might be much less known and more
    cryptic for outsiders.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the examples of such an industry is, of course, the software industry.
    When two programmers discuss implementation details of some reasonably complex
    systems, non-programmers around them don''t understand much of this conversation
    and usually get bored. Lack of understanding always results in a lack of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5486bbce-882b-4615-b491-8138cd1743d5.png)'
  prefs: []
  type: TYPE_IMG
- en: The world, as seen by a programmer (based on the original work by Manu Cornet)
  prefs: []
  type: TYPE_NORMAL
- en: The software industry is, in a sense, unique because it tends to serve a variety
    of business problems within any other industry. Almost everything today requires
    or wishes for some degree of automation, and this means software. This also means
    that people from the business will come to their developers or external software
    companies and try to express their problems using their language. When this language
    isn't understood correctly, issues arise.
  prefs: []
  type: TYPE_NORMAL
- en: Functional requirements, written by dedicated professionals who are neither
    business people nor software developers, have been seen as the holy grail of successful
    software. Each time we reach an undesired outcome after the software is delivered
    to an unhappy customer, we blame requirements. We say—next time, we'll write better
    requirements and more detailed specifications and explain what developers need
    to do down to every single small detail. It can quickly become a blame game when
    everyone is pointing fingers to each other and no one is willing to be responsible
    for anything.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the points we were discussing in [Chapter 1](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml),
    *Why Domain-Driven Design? *(in the *What went wrong with requirements?* section),
    one additional aspect is worth mentioning here. It's the language. Requirements
    not only focus on the solution and hide problems, but requirements also tend to
    **translate** business language to more technical language, which is seen as **developer-friendly**.
    In reality, this works more like a broken telephone. The more levels of translation
    that are being added to the transmission line, the less relevant information reaches
    the receiver without being disturbed beyond recognition.
  prefs: []
  type: TYPE_NORMAL
- en: One more aspect of such a *translation* is that it slows down communication.
    If developers require more information from the business but are unable to understand
    what the business means when they speak, the involvement of translators becomes
    unavoidable. Usually, these are the same people that write requirements, but not
    always. I've heard enough examples when only people such as enterprise architects
    are allowed to talk to customers; then, they translate their understanding to
    business analysis, who then throw requirements over the wall to poor developers,
    which are then literally lost in translation.
  prefs: []
  type: TYPE_NORMAL
- en: That's why understanding the business is significant for people who are working
    to create a good solution for real business problems. Being able to understand
    the business and communicate without a need for translations and translators not
    only shortens the communication time but also substantially improves the quality
    of such communication.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we all know that business people, who usually play the customer
    role for the systems we create, are overall much less available as we would like
    them to be. You might end up having just a few session with people who actually
    possess the crucial information that you must obtain in order to make the system
    do what it should do. Sometimes they are even unwilling to take discussions with
    developers. It might be related to some personal issues, negative experience from
    the past or unconscious fear of looking silly in front of the bund of nerds.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, having a dedicated person, which is trusted by the business and
    speaks their language really helps. Our aim would be to ensure that this person
    is also trusted by the development team. You can call this role as a business
    analyst or a product owner, it doesn't really matter. The best people I know in
    this role are able to speak to everyone in their language, like the high-degree
    translators that work with world leaders behind their backs, being able to translate
    from one language to another without losing the meaning of things. At the same
    time, the best approach is still to avoid such a translation altogether.
  prefs: []
  type: TYPE_NORMAL
- en: For example, London City bankers are notorious for hiring developers who have
    already been exposed to banking and have ideally worked in the City before. They
    value their time and want to shorten the time spent on communication and discussions.
    Therefore, someone who has exposure to their language and shows a decent level
    of understanding of their business and their language is valued higher than someone
    else who might be a better developer but needs to be trained and get to know the
    language before really starting to work on real-life tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jargon terms are usually hard to grasp for outsiders since words that are being
    used are often everyday use words, but have an entirely different meaning. Some
    examples from the aforementioned financial domain are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Call**: Short for a **call** option*,* this is a demand for payment of lent
    or unpaid capital'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: To attest the credit, the right to property, or the ownership
    of stocks or bonds that are related to tradable derivatives, this certificate
    is used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swap**: Among two borrowers, if each of them gain access to the required
    funds or a fixed interest is changed to floating, it''s considered as swap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the domain language is crucial to establish effective communication
    between domain experts and developers.
  prefs: []
  type: TYPE_NORMAL
- en: Sample application domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we'll be developing a sample application to practice our
    gained knowledge and skills. In this section, you'll get an introduction to the
    business domain, and more details will be added later throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: The domain that we're going to be working on is selling stuff online for private
    individuals. We'll be building an application to publish classified ads and something
    that might be necessary to support this type of activity.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't familiar with the terminology, think about a bunch of stuff you
    have in your storage room or in the basement, which you would be delighted to
    remove. You can publish a small ad online, and other people might buy things that
    you no longer need. You can also give stuff away for free. Examples of such services
    are websites such as eBay, Craigslist, Gumtree, Marktplaats (the Netherlands),
    and FINN.no (Norway).
  prefs: []
  type: TYPE_NORMAL
- en: Making implicit explicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we start working on a new system, we need to learn a lot. We discussed
    the paradox of ignorance in [Chapter 1](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml), *Why
    Domain-Driven Design?*, and you might remember that the highest level of ignorance
    and thereby the lowest level of knowledge is when we make a lot of decisions about
    the future system.
  prefs: []
  type: TYPE_NORMAL
- en: We not only suffer a lack of knowledge about the business domain we're trying
    to solve problems for—we're also forced to work in an environment with a high
    level of ambiguity. Before we learn about the domain language, we use our understanding,
    which is often based on assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where you come to a meeting with domain experts at the beginning
    of the project. They try to explain their problem, and you slowly begin to study
    their language and, at some point, you think you got the idea and more or less
    know what to do. Here, it's important to remember what we were going through in
    the previous chapter when we discussed cognitive biases and their influence on
    decision making. The first and the most obvious risk is that **what you see is
    all there is** (**WYSIATI**), or availability heuristics. You apply your limited
    knowledge to past experiences and then get the feeling of understanding. At this
    point, we're usually asked to make estimates and logically we fail, since biases
    play a trick on our minds and give the illusion of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: At such meetings, we often agree on something. Then, everyone leaves the room
    to meet again and maybe discuss some specifications or even prototypes after a
    couple of weeks. Time passes by, we're still in the same room, and no one is pleased
    since, to our mutual dissatisfaction, we find out that we agreed on completely
    different things. Everyone had a picture in mind, and all those pictures were
    different.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da7b2f76-711c-4ca2-a43d-6e035e46b02e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We agree on different things if we don't visualize
  prefs: []
  type: TYPE_NORMAL
- en: People spend hours arguing about things they thought are different but are the
    same. People also agree on something that they don't share a common understanding
    about, and this never goes well.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to remove assumptions. We need to make *implicit* things
    *explicit*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this sample form from a real-life HR management system. Here, an employee
    can request sick leave:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ab13797-43ea-4757-af5b-b75123d1362b.png)'
  prefs: []
  type: TYPE_IMG
- en: Sick leave registration form
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see a typical structure, which is created by a programmer. We could
    even imagine a SQL table where the data that's entered into this form gets stored.
    It most probably has the `StartDate`, `EndDate`, and `HalfDay` columns and the
    employee `id`. Notice that there's a Save button here too, which is very common
    to find in forms like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'But despite the fact that this form might look okay, let''s think a little
    bit more about what we see here. After spending a bit of time analyzing this form,
    we could see the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The Start date is ambiguous. It might be the date when sick leave is registered,
    or it might also be the date when the employee didn't come to work because they
    got sick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The End date is even more ambiguous because it might represent the last day
    of the sick leave, or the day when the employee came back to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Half day might apply to both of those fields, but there's no clear indication
    of what it means.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the Save button gives us no clue about what will happen next. There
    might be just a record in a table, and we need to tell someone to look at it,
    or there might be an approval process that gets started automatically. Does the
    employee need to call or send an email to the line manager after filling out this
    form?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, even in such a small form with two fields, one checkbox, and
    two buttons, many things are implicit. If we imagine the code behind this form,
    all those implicit and ambiguous concepts could be found there as well. I already
    mentioned a table that has columns that represent those fields in the form. All
    properties in the domain model classes, data model objects, and other code artifacts
    are equally implicit. Everything there demands an explanation, such as *this date
    means the day when an employee came back to work*, and without such an explanation.
    Things like reports could be just plain wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare it with another example, also taken from a real-life HR management
    system, which was made by a competitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dfa5910-680a-4721-a05f-101c827b3ffa.png)'
  prefs: []
  type: TYPE_IMG
- en: The sick leave registration form that makes sense
  prefs: []
  type: TYPE_NORMAL
- en: 'In this form, the fields make much more sense for regular people who don''t
    need to solve puzzles or read the help to understand what to enter in these fields.
    Things that were made *implicit* in the first sample are *explicit* here. Everything,
    from naming individual fields to calls for actions, has a better meaning. We could
    also imagine that, behind this form, we can find code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code expresses the same meaning and terminology as the user interface.
    So, not only will the end user have an easy time filling out this form, but also
    a fellow developer would be happy reading this code, where the intent is clearly
    expressed and all the concepts are explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of making implicit explicit is to create domain concepts that
    are visible in the code. In the preceding code, the `SendSickLeaveForApproval`
    command exhibits a precise domain concept in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Domain language for classified ads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our developers were discussing the flow of publishing classified ads. They went
    through the creation process and got to the point where the user clicks the Publish
    button. Together, with the domain expert, they discovered that ads couldn't be
    published immediately since an ad could contain malicious content. They decided
    to put in some approval process, which should take place after the user clicks Publish
    and the ad becomes visible on the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers quickly decided to create a property for their `ClassifiedAd` domain
    class, called `Status`. It should be an enum, which indicates different stages
    of the review and publication process. It could also be reused later for statuses
    that aren''t yet known. Since they want to have behavior in their domain model,
    they added the `UpdateStatus` method to the class, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that the method also publishes a domain event, other parts of the system
    can subscribe to this event and do some other vital actions.
  prefs: []
  type: TYPE_NORMAL
- en: We will spend more time with domain events and commands later in this book.
    For now, the sample code uses domain events in the code to closely resemble events
    and commands we were using in the EventStorming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after the user clicks Publish, the following would happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the review is complete, the ad would be activated, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It might seem acceptable. Our `ClassifiedAd` class is a state machine, where
    instances of this class move from one status to another through the life cycle
    of the ad. However, we already miss the intent. Our language becomes weird—instead
    of saying that we want to *publish* the announcement, we *update the status*.
    Instead of *activating* the ad, we *update the status* again!
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if it all seems to work after some more behavior is added to the system,
    code like this will start to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That isn''t the code we expect to see in such a simple method. It takes too
    much responsibility, and the logical blocks in this method barely relate to each
    other. But things get worse when it gets to the domain event handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The number of flow control operators is growing, and most of the behavior is
    now being driven by status updates, something that, in the beginning, was considered
    to be a small and concise operation on a single property of the domain object.
    The intent of this update operation is dissolved, and each call needs to be carefully
    controlled for side effects. The risk of damaging an existing behavior when adding
    new features is now genuine.
  prefs: []
  type: TYPE_NORMAL
- en: Discussions with domain experts also lost some meaning. Instead of using phrases
    such as *if the malicious content is detected, we hide the ad and inform our moderation
    group*, it becomes *and then we query all ads with the status equals* `MaliciousContentDetected`
    *and use the notification service to deliver a message to all users that have
    moderation rights*. The meaning of the language gets lost behind technical gibberish,
    mixed with generalized words such as **status** and **message**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The team decides to refactor the code and use proper domain language instead.
    So, this is what they came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also refactor the domain event handling to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to handle cases with malicious content, we can write the new event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our small example also shows that the domain language can't be built by making
    a glossary with nouns. A misconception about collecting a lot of nouns in an extensive
    list and calling it a domain language definitely exists. But this isn't a happy
    path, and usually, it leads to something called an anemic model, which is considered
    an anti-pattern. Classes in anemic models only have properties, and properties
    are always named by nouns. But a no less important part of every domain is the
    behavior. Nouns express what the domain operates with, but verbs describe what's
    being done. Without verbs, our domain tends to be a set of magic actions when
    properties change values without any particular reason. But our preceding code
    clearly expresses the domain behavior by introducing verbs as part of the domain
    language. These verbs are precise, show the intent, and describe actions. They're
    used both in imperative style for activities and in the past tense when describing
    the history when we publish domain events from our code.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we not only improve our code and brought a better
    understanding of what it does and what concepts are being present there, but we
    also discovered some new terms and concepts that our domain model would benefit
    from. We can start using this terminology when talking to domain experts and see
    whether they understand it. Sometimes, they might give developers strange looks,
    trying to understand their excitement because they knew this *new* concept already—its
    part of *their language*, and it was just never expressed in conversations between
    business and development people. Such breakthroughs not only make the code better
    and closer to the actual business model but also improve communication between
    developers and domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: By making implicit things explicit, not only do we discover missing concepts
    in our code, but we also put them into our domain model. This part is essential
    because the language is used across the whole range of models—business and mental
    models, conceptual and visual models, and domain models in diagrams and code.
    This pattern of using the same concept and, in general, the same language across
    multiple levels of models in the system is called **Ubiquitous Language**.
  prefs: []
  type: TYPE_NORMAL
- en: Language and context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction of this chapter, we already touched on the topic of linguistic
    differences in the same language. If one language is divided by some boundary,
    be it a geographical, national, or professional area, it starts to split. We used
    British and American English as an example before, but of course, there are more
    examples like this. Dutch language spoken in Belgium is often even referred to
    as a separate language, Flemish because it sounds different, but mainly because,
    for everyday objects and actions, different words are being used. The same can
    be observed for languages that evolve within professional groups where people
    develop jargon, and we've looked at some examples of this too.
  prefs: []
  type: TYPE_NORMAL
- en: These examples were presented here to demonstrate how important it is to define
    the precise meaning of words. Avoiding confusion is indeed one of the goals in
    order to find and identify Ubiquitous Language.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to realize that Ubiquitous Language is only valid within a context.
    A different context is defined by a different language. There's a misconception
    that Ubiquitous Language is called *ubiquitous* because it's the single language
    for the whole business, organization, or domain. That isn't the case. It's ubiquitous
    not horizontally, but vertically. Each context might have its own language, but
    all layers in this context share one Ubiquitous Language—meetings with the business,
    models, code, tests, UI concepts, data structures, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the classic example of the term **Product** being used
    in different contexts of the e-commerce domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5a1c911-2b91-4b71-803c-17884a3d0a61.png)'
  prefs: []
  type: TYPE_IMG
- en: Product in different contexts
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we''re operating in the same domain, clearly the term **Product**
    has a somewhat different meaning in each of the identified contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sales**: For the salespeople, product means the sales price and maybe the
    margin. It''s where the company earns money, and other properties of the product
    aren''t that important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Purchasing**: If we buy a product to resell, we''re mostly interested in
    the purchase price, how many items of a given product the supplier has in stock,
    and how fast they can be delivered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**: We''re mainly interested in how many items we have in stock.
    If a specific item is out of stock, this context can keep the estimated date when
    it will be back in stock. Here, we probably also define some internal properties
    of the product, such as the item number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warehouse**: It needs to manage the space that''s required to store products,
    so people in this context need to know when product batches arrive when shipments
    to customers take place, how products are packaged, and where they are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, although we have a popular term, such as **Product**, different
    departments in the same domain or organization really have very little shared
    interest and have more in-depth knowledge in their subset of properties of something
    that otherwise could be considered the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Another good example would be the term **policy** in the insurance domain. It's
    a bit less well-known for people that don't work in insurance but, in general,
    we understand that people that sell insurance to us are mostly interested in money
    and in getting new customers. So, for them, the policy means new sales and money. When
    it comes to approvals, if we take vehicle insurance as an example, policy implies
    risk. Even after a policy is sold, there's a chance that the risk assessment department
    could request additional documentation and, after some internal checks, reject
    the policy. And finally, when it comes to the point of handling a claim on the
    existing policy, for the claim handling department, it's a cost since the insurance
    company loses money.
  prefs: []
  type: TYPE_NORMAL
- en: Both examples demonstrate that, even for the same domain, there's a different
    context where language changes and sometimes changes significantly. What happens
    if we keep using the same meaning of words across contexts? Well, things become
    much less explicit. The degree of ambiguity increases with each new context that
    we fail to identify and separate. It leads to unclear models and, as a result,
    to obscure code, where we need to clarify what we mean exactly when we use this
    and that word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixing different contexts in one working environment also leads to something
    called **context switching**. In *Quality Software Management: Systems Thinking*, Gerald
    Weinberg suggested that an increasing number of projects that one individual works
    on leads to significant productivity loss due to context switching:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd0a33da-1a7f-4740-8a6f-308456ec8392.png)'
  prefs: []
  type: TYPE_IMG
- en: Productivity loss due to context switching
  prefs: []
  type: TYPE_NORMAL
- en: Adding one more project to current tasks means 20% productivity loss. Hence,
    when the number of contexts reaches five, the amount of time spent on the actual
    work becomes tremendously low. Most of the time is then spent figuring out in
    which context the current task belongs.
  prefs: []
  type: TYPE_NORMAL
- en: It's not only valid for the project. You might know from experience that, for
    larger projects where generalization prevails over precision and unambiguity,
    the phenomena of context switching effects the performance just as much. In our
    **product** example, if we were to put all of the properties of different logical
    views of the product in one place, working with such an object would involve some
    additional effort of trying to understand which part of the product we're working
    on at the moment. So, despite this still being one thing, the hidden context switching
    and productivity will suffer.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that centralization and generalization are good things, many software
    systems create so-called God classes, such as `Customer` or `Product`, which contain
    all possible properties for all possible views of a physical object. In addition
    to context switching, there are more downsides to such an approach.
  prefs: []
  type: TYPE_NORMAL
- en: One is obviously that not all properties need to have value during a specific
    life cycle of such an object in the system. For example, the phased-out product
    has no features that are related to sales whatsoever. But since we have one class
    for everything, we must assign empty values to all of these properties. Such an
    approach leads to a high degree of confusion since we hardly understand why these
    properties are vacant—either there's a mistake in the system, or this is just
    a typical situation due to the object's state.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that, inevitably, such classes attract a lot of dependencies.
    You've probably seen data models, which sometimes mimic **domain models**, where
    the whole complex system has one large SQL database where tables have many cross-references.
    We could imagine that things such as `Product` can be referenced by `Order`*,*
    `ShoppingCart`*,* `Catalogue`*,* `Invoice`*,* `PurchaseInvoice`*,* `Return`, `CreditNote`,
    and so on. The model becomes tangled and very hard to maintain. Sometimes, it
    gets worse because referential dependencies are sometimes plain wrong. For example,
    it isn't correct to show an updated product description on some order from the
    past. The order should contain a snapshot of the purchased product as it was at
    the moment of purchase.
  prefs: []
  type: TYPE_NORMAL
- en: We've identified enough reasons for us to be cautious when it comes to forgetting
    about context when seeking language. Ubiquitous Language is always unambiguous,
    explicit, and context-specific. As soon as you sense or observe that the meanings
    of words start to change between different parts of the system, this should trigger
    an alarm in your head that you are probably crossing context boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Context emerges when discussing users**. Developers love to think of people
    as users. This term is so ambiguous that it''s almost guaranteed that we switch
    between different contexts when talking about users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to our sample domain, the team developers discussed how their
    users would rate their deals. They thought that it could be useful if people could
    give a rating to each other, helping to build trust in the community. During the
    conversation, some of them noticed that they use the words *user*, *those who
    sell*, *seller*, *those who buy*, and *buyer* interchangeably. When the generic
    term *user* was used, it almost always required clarification: what role this
    user plays at that particular moment. At the same time, when they named their
    users as *buyers* and *sellers*, there was no ambiguity, and no further clarification
    was required.'
  prefs: []
  type: TYPE_NORMAL
- en: After noticing this, the group decided that they discovered new elements of
    Ubiquitous Language and started to use these terms. It was a good insight that
    saved them a lot of time when they discussed models and removed ambiguity in code.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, splitting people into *sellers* and *buyers* in the authorization
    part of the system made no sense at all. These were just *users*, and they can
    log in to the system and do some operations, such as update their profile, without
    any clear distinction of whether they're going to sell or buy on the site. It was
    another context when the word *user* wasn't ambiguous and was explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Later, they discovered another distinction for users when they modeled the back
    office system. There, users started to take roles, and again ambiguity was there
    until they identified these roles and began to use terms such as *administrator*, *support
    assistant*, and *reviewer*. A new context was discovered, and a new model emerged
    for that context, which was separated from other contexts by the meanings of words.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the importance of language in system design and
    how precise and unambiguous terminology brings clarity. We also have a shared
    understanding of the domain for business people and developers. We also looked
    at how different industries use the same words to express different concepts and
    what consequences this has on domain modeling.
  prefs: []
  type: TYPE_NORMAL
- en: The code sample in this chapter showed how unclear language could make the implementation
    more complicated and less understandable. By introducing better language to the
    code, we made it much clearer and shorter and more concise. We made some implicit
    concepts more explicit, and it helped to get a better understanding of the business
    and improved the code quality. We also discovered many verbs that became part
    of the language, which is an essential addition to a glossary of nouns that are
    often seen as the only important part of the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced the term *Ubiquitous Language*, which was coined by
    Eric Evans. We emphasize the fact that the ubiquity of the language isn't in its
    wideness but in its precision, and the fact that it's being used for all artifacts
    of the software development process—from initial discussions, through modeling
    and design, to code and tests.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how words change their meaning between different contexts and how
    context switching can negatively impact productivity. Using our sample domain,
    we went through a couple of examples of how contexts are being discovered during
    the modeling process and in conversations between developers and domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore one of the most popular techniques for domain
    modeling and go through some practical tips on how to organize useful workshops
    between domain experts and developers.
  prefs: []
  type: TYPE_NORMAL
