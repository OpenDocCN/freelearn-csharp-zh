- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Advanced Scripting Techniques in Unity – Async, Cloud Integration, Events, and
    Optimizing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的高级脚本技术 – 异步、云集成、事件和优化
- en: In this chapter, we will elevate your C# scripting expertise within Unity to
    new heights, delving into some of the most advanced programming concepts essential
    for crafting professional-level games. We’ll start with exploring the power of
    non-blocking code execution through coroutines, enabling you to maintain smooth
    and responsive gameplay. Then, you’ll learn to manage and manipulate complex data
    structures effectively, enhancing your capacity to handle intricate game logic.
    Then, we’ll explore how to create custom event systems using techniques for designing
    and implementing robust event systems that add depth and interactivity to your
    game elements. Lastly, we’ll focus on critical strategies for enhancing script
    performance, ensuring that your games operate fluidly across a variety of platforms.
    From implementing a sophisticated save/load system to creating a tailored event
    system, this chapter is designed to refine your programming skills and help you
    push the boundaries of game development in Unity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提升您在Unity中的C#脚本编程技能至新的高度，深入探讨一些对于制作专业级游戏至关重要的高级编程概念。我们将从通过协程探索非阻塞代码执行的力量开始，使您能够保持流畅和响应性的游戏体验。然后，您将学习如何有效地管理和操作复杂的数据结构，增强您处理复杂游戏逻辑的能力。接着，我们将探讨如何使用设计实现稳健的事件系统的技术来创建自定义事件系统，为您的游戏元素增添深度和交互性。最后，我们将关注提升脚本性能的关键策略，确保您的游戏在各种平台上流畅运行。从实现复杂的保存/加载系统到创建定制的事件系统，本章旨在提升您的编程技能，并帮助您在Unity游戏开发中突破界限。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Utilizing coroutines for non-blocking code execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用协程进行非阻塞代码执行
- en: Implementing coroutines in Unity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中实现协程
- en: Managing and manipulating complex data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和操作复杂的数据结构
- en: Designing and implementing custom event systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现自定义事件系统
- en: Optimizing scripts for performance and efficiency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化脚本以提升性能和效率
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter09](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter09)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到与本章节相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter09](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter09)
- en: Asynchronous programming and coroutines
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程和协程
- en: Let’s delve into the essentials of asynchronous programming and coroutines in
    Unity, key techniques for achieving non-blocking code execution that enhances
    the smoothness and responsiveness of gameplay. We begin with the basics of asynchronous
    operations, their importance in game development, and how Unity’s coroutine system
    simplifies these tasks without the complexity of traditional threading. The discussion
    progresses to practical examples that demonstrate coroutines in action, helping
    you visualize their impact through real-world applications. We wrap up by highlighting
    common pitfalls and best practices to ensure your coroutine-based code is clean,
    efficient, and maintainable. Through this exploration, you’ll gain the skills
    needed to effectively leverage these powerful programming concepts in your Unity
    projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨Unity中异步编程和协程的基本知识，这些是实现非阻塞代码执行的关键技术，有助于提升游戏操作的流畅性和响应性。我们从异步操作的基础开始，探讨其在游戏开发中的重要性，以及Unity的协程系统如何简化这些任务，而不需要传统线程的复杂性。讨论将逐步过渡到实际示例，展示协程的实际应用，并通过现实世界的应用帮助您可视化其影响。最后，我们将强调常见的陷阱和最佳实践，以确保您的基于协程的代码干净、高效且易于维护。通过这次探索，您将获得在Unity项目中有效利用这些强大编程概念所需的技能。
- en: Introduction to asynchronous programming
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程简介
- en: '**Asynchronous programming** is a fundamental technique that enables game developers
    to maintain high responsiveness and smooth gameplay, even while running complex
    and resource-intensive operations. This section introduces the concept of **non-blocking
    code execution**, a cornerstone of modern game development that ensures games
    remain responsive and interactive, regardless of the background processing. By
    exploring asynchronous programming, you’ll understand how it can transform the
    architectural approach to building games in Unity, providing a more dynamic and
    engaging player experience. Asynchronous programming in Unity allows developers
    to enhance gameplay smoothness by managing time-consuming operations without halting
    the game’s execution. This advanced approach is vital for maintaining an engaging
    player experience, especially crucial when dealing with resource-intensive tasks.
    This overview sets the stage for a deeper dive into how these principles are directly
    applied in Unity through coroutines, enabling you to harness their full potential
    in game development scenarios.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程**是一种基本技术，它使游戏开发者能够在运行复杂和资源密集型操作的同时保持高响应性和流畅的游戏体验。本节介绍了**非阻塞代码执行**的概念，这是现代游戏开发的一个基石，确保游戏无论在后台处理中如何，都保持响应性和交互性。通过探索异步编程，你将了解它如何改变在Unity中构建游戏的结构方法，提供更动态和吸引人的玩家体验。Unity中的异步编程允许开发者通过管理耗时操作而不中断游戏执行来增强游戏流畅性。这种高级方法对于保持吸引人的玩家体验至关重要，尤其是在处理资源密集型任务时。本概述为更深入地探讨这些原则如何通过协程直接应用于Unity奠定了基础，使你能够在游戏开发场景中充分利用它们的潜力。'
- en: In Unity, **coroutines** provide a robust framework for implementing asynchronous
    behavior. Building on what we’ve covered in previous chapters, let’s dive deeper
    into how you can leverage coroutines for complex asynchronous operations, focusing
    on a specific example of asset loading.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，**协程**提供了一个强大的框架来实现异步行为。基于我们在前几章中讨论的内容，让我们更深入地探讨如何利用协程进行复杂的异步操作，重点关注资源加载的特定示例。
- en: Leveraging coroutines for complex asynchronous operations
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用协程进行复杂的异步操作
- en: 'Consider using the `LoadAssetAsync` coroutine to efficiently load large assets
    during gameplay in Unity; it asynchronously loads a GameObject and yields control
    each frame until the load completes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在Unity游戏过程中使用`LoadAssetAsync`协程来高效地加载大型资源；它异步加载一个GameObject，并在每一帧中暂停控制，直到加载完成：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the `LoadAssetAsync` coroutine begins by initiating
    the asynchronous loading of a GameObject. The `Resources.LoadAsync` method is
    non-blocking and immediately returns a `ResourceRequest` object that tracks the
    progress of this `LoadAsync` operation. By utilizing a `while` loop that continues
    until `load.isDone` returns `true`, the coroutine will loop each frame—using `yield
    return null`—until the asset is fully loaded. This pattern prevents the game’s
    main thread from being from pausing or freezing, thereby keeping the gameplay
    fluid and responsive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`LoadAssetAsync`协程首先启动GameObject的异步加载。`Resources.LoadAsync`方法是非阻塞的，并立即返回一个`ResourceRequest`对象，该对象跟踪此`LoadAsync`操作的进度。通过使用一个`while`循环，该循环持续到`load.isDone`返回`true`，协程将在每一帧循环——使用`yield
    return null`——直到资源完全加载。这种模式防止游戏的主线程暂停或冻结，从而保持游戏流畅和响应。
- en: 'Once the asset is completely loaded, as indicated by `load.asset`, you can
    proceed with any necessary operations to integrate this asset into your game,
    such as instantiating it or modifying its properties. This focused use of coroutines
    in asynchronous programming serves multiple purposes: it minimizes performance
    hits during heavy operations, maintains high frame rates, and ensures that the
    game remains interactive. This example underscores the importance of managing
    and orchestrating asynchronous tasks effectively to enhance overall game performance.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦资源完全加载，如`load.asset`所示，你可以进行任何必要的操作来将此资源集成到你的游戏中，例如实例化它或修改其属性。这种在异步编程中对协程的专注使用具有多重目的：它最小化了重操作期间的性能损失，保持了高帧率，并确保游戏保持交互性。这个例子强调了有效管理和编排异步任务以提升整体游戏性能的重要性。
- en: In summary, asynchronous programming is crucial in game development for maintaining
    the responsiveness and smoothness of gameplay amidst complex and resource-intensive
    operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在游戏开发中，异步编程对于保持游戏在复杂和资源密集型操作中的响应性和流畅性至关重要。
- en: Having laid the groundwork for understanding non-blocking code execution and
    its pivotal role in creating dynamic and interactive game environments, we are
    now poised to explore how Unity implements this concept through coroutines. In
    the next section, we will delve deeper into how coroutines offer a streamlined
    alternative to traditional multithreading. We will explore key concepts such as
    `IEnumerator`, `yield return`, and the mechanics of Unity’s coroutine scheduler,
    setting the stage for their effective application in game development scenarios.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了非阻塞代码执行及其在创建动态和交互式游戏环境中的关键作用后，我们现在准备探索Unity如何通过协程实现这一概念。在下一节中，我们将深入探讨协程如何提供传统多线程的简化替代方案。我们将探讨关键概念，如`IEnumerator`、`yield
    return`以及Unity协程调度器的机制，为在游戏开发场景中有效应用它们奠定基础。
- en: Understanding coroutines in Unity
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Unity中的协程
- en: In this section, we will delve into Unity’s coroutines—a powerful feature that
    offers an alternative to traditional multithreading and is essential for asynchronous
    programming within Unity’s ecosystem. **Coroutines** allow developers to manage
    time-consuming tasks without halting game execution, enhancing gameplay interactivity
    and smoothness.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究Unity的协程——这是一个强大的功能，提供了传统多线程的替代方案，对于Unity生态系统中的异步编程至关重要。**协程**允许开发者在不中断游戏执行的情况下管理耗时任务，增强游戏交互性和流畅性。
- en: A coroutine is a powerful construct that allows you to perform tasks over time,
    ensuring that the game continues to run smoothly while the coroutine is operating.
    This is achieved using the `IEnumeratoror` interface, which coroutines implement
    to yield control back to Unity while waiting for the next frame or until a specified
    condition is met. When a coroutine is started with `StartCoroutine()`, Unity begins
    executing the coroutine’s code until it hits a `yield` statement. At this point,
    the coroutine suspends, allowing other game processes to continue. The coroutine
    then automatically resumes from the point it yielded, either on the next frame,
    after a delay, or when a specific condition is satisfied. This makes coroutines
    ideal for managing time-based tasks, animations, or sequences that need to unfold
    across several frames, without blocking the rest of your game logic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种强大的结构，允许你在一段时间内执行任务，确保协程运行时游戏继续平稳运行。这是通过实现`IEnumerator`接口来实现的，协程在等待下一帧或满足指定条件时将控制权交还给Unity。当使用`StartCoroutine()`启动协程时，Unity开始执行协程的代码，直到遇到`yield`语句。此时，协程暂停，允许其他游戏进程继续。然后协程自动从它yield的位置恢复，无论是在下一帧、延迟后或满足特定条件时。这使得协程非常适合管理基于时间的任务、动画或需要在多个帧上展开的序列，而不会阻塞你的游戏逻辑的其他部分。
- en: Practical examples of coroutines in Unity
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中协程的实际示例
- en: 'Here are a few key examples that demonstrate the versatility and effectiveness
    of coroutines in Unity, from smoothly animating game objects to managing complex
    game states asynchronously without disrupting gameplay:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关键示例，展示了协程在Unity中的多功能性和有效性，从平滑地动画化游戏对象到异步管理复杂游戏状态而不中断游戏：
- en: '**Animating game objects**: Using coroutines to smoothly transition game objects
    between states or locations over time, without the stutter or halt in gameplay
    that might occur with frame-by-frame calculations.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画游戏对象**：使用协程在时间上平滑地过渡游戏对象的状态或位置，避免在逐帧计算中可能出现的游戏卡顿或中断。'
- en: '**Sequencing events**: Orchestrating a sequence of events that trigger in response
    to game actions or after certain delays, ensuring gameplay flows logically and
    engagingly.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件序列**：编排一系列事件，这些事件在游戏动作触发或经过一定延迟后发生，确保游戏流程逻辑性和吸引力。'
- en: '**Asynchronous asset loading**: Loading resources in the background while keeping
    the game responsive, a crucial technique in larger games to prevent loading screens
    from freezing the game experience.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步资源加载**：在后台加载资源的同时保持游戏响应，这是大型游戏中防止加载界面冻结游戏体验的关键技术。'
- en: Building upon our understanding of coroutines in Unity, we will now dive into
    practical examples that illustrate how these flexible tools can be effectively
    employed in real-world game development scenarios. We will explore how coroutines
    enable smooth movement of game objects, implement wait times without halting gameplay,
    and manage complex game states asynchronously—all essential for creating a seamless
    player experience. Each example will include detailed code snippets and explanations,
    providing a clear demonstration of best practices in action. By seeing coroutines
    applied in various contexts, you’ll gain insights into their power and versatility,
    enhancing your ability to incorporate these techniques into your own game development
    projects effectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中对协程的理解基础上，我们将现在深入实际示例，说明这些灵活的工具如何在现实世界的游戏开发场景中有效应用。我们将探讨协程如何使游戏对象平滑移动，实现等待时间而不中断游戏，以及异步管理复杂游戏状态——所有这些都是创建无缝玩家体验所必需的。每个示例都将包括详细的代码片段和解释，清楚地展示最佳实践的实际应用。通过看到协程在各种上下文中的应用，你将深入了解它们的强大和多功能性，增强你将此技术有效融入自己的游戏开发项目的能力。
- en: Smoothly moving game objects
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平滑移动游戏对象
- en: 'One common use of coroutines in Unity is to animate game objects smoothly over
    time. The following example demonstrates how to move an object from one position
    to another smoothly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，协程的一个常见用途是使游戏对象随时间平滑地动画化。以下示例演示了如何平滑地将一个对象从一个位置移动到另一个位置：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, the coroutine, `MoveObject`, takes three parameters:
    the starting position (start), the ending position (end), and the duration over
    which the move should occur (duration). It uses a `while` loop to interpolate
    the position of the GameObject from start to end using `Vector3.Lerp`, which linearly
    interpolates between two points. `elapsedTime` tracks the time elapsed since the
    coroutine started, and `Time.deltaTime` is used to update `elapsedTime` each frame,
    ensuring the movement is smooth and time-based. The `yield return null` statement
    causes the coroutine to pause until the next frame, allowing other game operations
    to continue. Once the movement is complete, the object’s position is explicitly
    set to the end point to ensure it arrives precisely at the target location.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，协程`MoveObject`接受三个参数：起始位置（start）、结束位置（end）以及移动应发生的持续时间（duration）。它使用`while`循环通过`Vector3.Lerp`来插值GameObject的位置，从起始位置到结束位置进行线性插值。`elapsedTime`跟踪协程开始以来经过的时间，`Time.deltaTime`用于每帧更新`elapsedTime`，确保运动平滑且基于时间。`yield
    return null`语句使协程暂停，直到下一帧，允许其他游戏操作继续。一旦移动完成，对象的位置将显式设置为终点，以确保它精确地到达目标位置。
- en: Implementing wait times
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现等待时间
- en: 'The following script defines the `StartDelay` coroutine in Unity, which utilizes
    the `IEnumerator` interface to implement a timed delay. The coroutine pauses execution
    for a specified duration using `yield return new WaitForSeconds(delay)`, then
    proceeds with the actions scheduled post-delay. This example logs a message to
    the console indicating the completion of the delay, demonstrating a basic yet
    practical use of coroutines to control flow in your game:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本在Unity中定义了`StartDelay`协程，该协程利用`IEnumerator`接口实现定时延迟。协程暂停执行指定的时间，然后继续执行延迟后的操作。此示例在控制台记录一条消息，指示延迟完成，展示了协程在控制游戏流程中的基本但实用的应用：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `StartDelay` coroutine, the new `WaitForSeconds` is used to create a
    delay specified by the delay parameter. This function does not freeze the game
    but simply pauses the coroutine, allowing other tasks to continue. After the delay,
    the execution resumes, and the `Debug.Log` statement is executed, indicating that
    the delay has completed. This method is particularly useful for timing game events
    without impacting gameplay fluidity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartDelay`协程中，使用新的`WaitForSeconds`创建由延迟参数指定的延迟。此函数不会冻结游戏，而只是暂停协程，允许其他任务继续。延迟后，执行继续，并执行`Debug.Log`语句，指示延迟已完成。此方法特别适用于定时游戏事件而不影响游戏流畅性。
- en: Managing complex game states asynchronously
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步管理复杂游戏状态
- en: 'Managing game states asynchronously is another powerful application of coroutines,
    allowing for complex state management without compromising game performance. Here
    is an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 异步管理游戏状态是协程的另一个强大应用，允许在不影响游戏性能的情况下进行复杂的状态管理。以下是一个示例：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, the `CheckGameState` coroutine runs indefinitely,
    checking the game’s state in each frame and performing actions based on the current
    state (`currentState`). It uses a switch statement to handle different game states
    such as Starting, Playing, and Ending. The `yield return null` statement at the
    end of the loop ensures that the coroutine only uses up processing power when
    necessary, by pausing its execution until the next frame. This approach allows
    the game to handle state transitions smoothly, asynchronously managing different
    phases of the game without stalling other processes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`CheckGameState` 协程无限运行，在每一帧检查游戏状态并根据当前状态（`currentState`）执行操作。它使用 switch
    语句来处理不同的游戏状态，如开始、进行中和结束。循环末尾的 `yield return null` 语句确保协程仅在必要时使用处理能力，通过暂停执行直到下一帧来减少资源消耗。这种方法允许游戏平滑地处理状态转换，异步管理游戏的不同阶段，而不会阻塞其他进程。
- en: In this section, we’ve explored practical examples of coroutines in Unity, showcasing
    their versatility in smoothly moving game objects, implementing wait times without
    blocking code execution, and managing complex game states asynchronously. Each
    example provided insight into how coroutines can be leveraged to enhance gameplay
    mechanics, improve performance, and manage game complexity effectively. By understanding
    these real-world applications and accompanying best practices, developers can
    wield coroutines with confidence, ensuring clean, efficient, and maintainable
    code in their Unity projects. Moving forward, we will delve into common pitfalls
    and best practices associated with asynchronous programming and coroutines in
    Unity, equipping you with the knowledge to avoid mistakes and write robust coroutine-based
    code that aligns seamlessly with game logic and timing requirements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Unity 中协程的实际应用示例，展示了它们在平滑移动游戏对象、实现非阻塞代码执行的时间等待以及异步管理复杂游戏状态方面的多功能性。每个示例都提供了关于如何利用协程来增强游戏机制、提高性能和有效管理游戏复杂性的见解。通过理解这些实际应用和相应的最佳实践，开发者可以自信地使用协程，确保在
    Unity 项目中编写干净、高效且易于维护的代码。展望未来，我们将深入研究与 Unity 中异步编程和协程相关的常见陷阱和最佳实践，为您提供避免错误并编写与游戏逻辑和时序要求无缝对齐的健壮协程代码的知识。
- en: Common pitfalls and best practices in implementing coroutines
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现协程时的常见陷阱和最佳实践
- en: While coroutines are a powerful tool in Unity for implementing asynchronous
    programming, they come with their own set of challenges and common mistakes that
    can lead to inefficient and error-prone code. This section aims to highlight these
    frequent pitfalls, providing practical advice on how to navigate them effectively.
    We will explore essential best practices for managing coroutine life cycles, avoiding
    memory leaks, and ensuring that coroutine execution is properly synchronized with
    game logic and timing requirements. By understanding these guidelines, you can
    write cleaner, more efficient, and maintainable coroutine-based code, thereby
    enhancing the overall stability and performance of your Unity projects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然协程是 Unity 中实现异步编程的有力工具，但它们也带来了一组挑战和常见错误，可能导致代码效率低下且易于出错。本节旨在突出这些常见的陷阱，并提供如何有效应对这些陷阱的实际建议。我们将探讨管理协程生命周期、避免内存泄漏以及确保协程执行与游戏逻辑和时序要求正确同步的基本最佳实践。通过理解这些指南，您可以编写更干净、更高效且易于维护的基于协程的代码，从而提高您
    Unity 项目的整体稳定性和性能。
- en: Proper handling of coroutine life cycles
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确处理协程生命周期
- en: One common mistake with coroutines is improper handling of their life cycles.
    Developers often start coroutines without plans for their termination, which can
    lead to coroutines running longer than needed or not completing when the game
    state changes. This oversight can cause unexpected behavior or performance issues.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的一个常见错误是未能正确处理其生命周期。开发者经常在没有终止计划的情况下启动协程，这可能导致协程运行时间过长或在游戏状态改变时无法完成。这种疏忽可能导致意外的行为或性能问题。
- en: 'The best practice is to always ensure that coroutines are stopped appropriately
    when they are no longer needed. You can manage this by keeping a reference to
    the coroutine and using `StopCoroutine` when you need to explicitly stop it, especially
    before starting the same coroutine again or when the object it affects is destroyed.
    Here’s how you can handle it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是始终确保在协程不再需要时适当地停止它们。你可以通过保留协程的引用，并在需要显式停止它时使用 `StopCoroutine` 来管理这一点，尤其是在再次启动相同的协程之前或当它影响的对象被销毁时。以下是处理方法：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `myCoroutine` variable serves as a reference to the currently active
    coroutine. The `StartMyCoroutine()` method initiates a coroutine, first verifying
    whether one is already running to prevent concurrent execution. If an existing
    coroutine is found, it halts its execution with `StopCoroutine()`. Thereafter,
    it commences a new coroutine by invoking `StartCoroutine()` with the designated
    `MyCoroutineMethod()` method for execution. Conversely, the `StopMyCoroutine()`
    method ceases the coroutine if it’s ongoing by checking whether `myCoroutine`
    is not null, and subsequently calling `StopCoroutine()` to terminate its execution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`myCoroutine` 变量作为当前活动协程的引用。`StartMyCoroutine()` 方法启动一个协程，首先验证是否已经有一个正在运行，以防止并发执行。如果发现现有的协程，它将使用
    `StopCoroutine()` 停止其执行。之后，它通过调用 `StartCoroutine()` 并指定 `MyCoroutineMethod()`
    方法来执行，开始一个新的协程。相反，`StopMyCoroutine()` 方法通过检查 `myCoroutine` 是否不为空来停止正在进行的协程，并随后调用
    `StopCoroutine()` 来终止其执行。
- en: Avoiding memory leaks
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: Coroutines can cause memory leaks if not handled carefully. This usually happens
    when the coroutine keeps references to objects that should otherwise be garbage
    collected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理不当，协程可能会导致内存泄漏。这种情况通常发生在协程持续引用那些本应被垃圾回收的对象时。
- en: The best practice is to be cautious with what your coroutine references. Make
    sure to nullify references to objects that are no longer needed and be mindful
    of closures capturing large objects or entire classes inadvertently. Also, consider
    using `WeakReference` when referencing objects that might lead to memory leaks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是对协程引用的内容保持谨慎。确保取消对不再需要的对象的引用，并注意闭包意外捕获大对象或整个类。此外，在引用可能导致内存泄漏的对象时，考虑使用 `WeakReference`。
- en: Ensuring coroutine execution aligns with game logic and timing requirements
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保协程执行与游戏逻辑和时序要求相一致
- en: Coroutines are often used to handle operations that depend on timing and game
    logic, but misalignment in their execution can lead to issues such as animations
    being out of sync or game events triggering at the wrong time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 协程通常用于处理依赖于时序和游戏逻辑的操作，但它们执行中的不匹配可能导致动画不同步或游戏事件在错误的时间触发等问题。
- en: 'The best practice is to ensure that coroutines align perfectly with other game
    processes, use precise timing controls, and synchronize them with the game’s update
    cycles. Utilize `WaitForEndOfFrame` or `WaitForFixedUpdate` to control exactly
    when in the frame your coroutine’s code should run, depending on whether it needs
    to be in sync with physics calculations or just general game logic updates. For
    example, see the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是确保协程与其它游戏过程完美对齐，使用精确的时序控制，并将它们与游戏的更新周期同步。利用 `WaitForEndOfFrame` 或 `WaitForFixedUpdate`
    来控制协程代码在帧中的确切运行时间，这取决于它是否需要与物理计算同步或只是进行一般的游戏逻辑更新。例如，请参阅以下代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To effectively harness the power of coroutines in Unity, it’s crucial to grasp
    their life cycle, manage memory diligently, and synchronize them precisely with
    the game’s timing and logic. This understanding ensures optimal game performance
    and a superb user experience. The `WaitForThenAct` coroutine, illustrated in the
    preceding code, exemplifies these best practices. It employs `yield return new
    WaitForFixedUpdate()` to pause its execution until after all physics calculations
    are completed for the frame, making it ideal for physics-related updates. This
    setup demonstrates how carefully managed coroutines can integrate seamlessly with
    Unity’s physics engine and game logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用 Unity 中协程的力量，掌握它们的生命周期、勤勉地管理内存以及精确地与游戏的时序和逻辑同步至关重要。这种理解确保了最佳的游戏性能和卓越的用户体验。前述代码中展示的
    `WaitForThenAct` 协程，就是这些最佳实践的例证。它使用 `yield return new WaitForFixedUpdate()` 暂停其执行，直到该帧的所有物理计算完成后，这使得它非常适合与物理相关的更新。这种设置展示了如何通过精心管理的协程与
    Unity 的物理引擎和游戏逻辑无缝集成。
- en: The foundational *Asynchronous programming and coroutines* section has thoroughly
    explored the vital role of non-blocking code execution in creating smooth and
    responsive gameplay within Unity. Starting with an introduction to asynchronous
    programming, we’ve built a comprehensive understanding of how these practices
    prevent gameplay disruptions and enhance interactivity. Delving into the specifics
    of coroutines, we examined their advantages over traditional multithreading, their
    operation within Unity’s unique environment, and practical applications that showcase
    their effectiveness in game development. Additionally, we addressed common pitfalls
    and outlined best practices to help developers write clean, efficient, and maintainable
    coroutine-based code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基础的*异步编程和协程*部分已经彻底探讨了非阻塞代码执行在Unity中创建流畅和响应式游戏体验中的关键作用。从异步编程的介绍开始，我们已经建立了对这些实践如何防止游戏中断和增强交互性的全面理解。深入到协程的具体细节，我们研究了它们相对于传统多线程的优势，它们在Unity独特环境中的操作，以及展示其在游戏开发中有效性的实际应用。此外，我们还讨论了常见的陷阱，并概述了最佳实践，以帮助开发者编写干净、高效且易于维护的基于协程的代码。
- en: Having equipped you with the knowledge to implement advanced scripting techniques,
    we now turn to the equally critical realm of advanced data management. The next
    section will expand on managing and manipulating complex data structures essential
    for handling sophisticated game logic and optimizing game performance through
    efficient data management practices, serialization, and deserialization.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在为您提供了实现高级脚本技术所需的知识后，我们现在转向同样关键的领域——高级数据管理。下一节将扩展到管理和操作复杂数据结构，这对于处理复杂的游戏逻辑和通过高效的数据管理实践、序列化和反序列化来优化游戏性能至关重要。
- en: Advanced data management
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据管理
- en: In this section, we will delve into the intricate handling of complex data structures
    crucial for managing sophisticated game logic. As game development involves complex
    scenarios and the need for efficient performance, understanding and utilizing
    advanced data structures becomes essential. This section will delve into their
    strategic implementation in Unity, illustrating how they can significantly influence
    game performance. We will discuss the roles these data structures play in game
    development, from facilitating fast lookups and managing hierarchical data to
    representing complex networks. Additionally, we will cover essential processes
    such as serialization and deserialization for game saves and loads, providing
    practical examples and best practices to optimize data management for enhanced
    game performance and reliability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨管理和操作复杂数据结构的微妙之处，这对于管理复杂的游戏逻辑至关重要。由于游戏开发涉及复杂场景和高效性能的需求，理解和利用高级数据结构变得至关重要。本节将深入探讨它们在Unity中的战略实施，说明它们如何显著影响游戏性能。我们将讨论这些数据结构在游戏开发中的作用，从促进快速查找和管理层次数据到表示复杂网络。此外，我们还将涵盖游戏保存和加载的序列化和反序列化等基本过程，提供实际示例和最佳实践，以优化数据管理，提高游戏性能和可靠性。
- en: Overview of data structures in game development
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏开发中数据结构的概述
- en: This overview explores the pivotal role of data structures in game development,
    highlighting the necessity of advanced data structures beyond the basic arrays
    and lists. It emphasizes the importance of selecting appropriate data structures
    based on performance, memory usage, and ease of manipulation to tailor solutions
    to specific game development challenges. This segment will equip developers with
    the knowledge to optimize their applications for better efficiency and effectiveness
    in handling complex game dynamics.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本概述探讨了数据结构在游戏开发中的关键作用，强调了在基本数组列表之外使用高级数据结构的必要性。它强调了根据性能、内存使用和易用性选择适当的数据结构的重要性，以针对特定的游戏开发挑战定制解决方案。本部分将为开发者提供优化其应用程序以更好地处理复杂游戏动态的效率和效果所需的知识。
- en: In the realm of game development, **data structures** play a fundamental role
    in organizing and managing information, directly impacting a game’s performance
    and player experience. Advanced data structures, such as **dictionaries** for
    rapid data retrieval, **trees** for managing hierarchical relationships, and **graphs**
    for depicting complex networks, provide sophisticated solutions that go beyond
    the capabilities of simple arrays and lists. Choosing the correct data structure
    is critical, as it affects not only the performance and memory efficiency of the
    game but also the ease with which developers can manipulate game data. Careful
    selection tailored to specific needs can lead to more robust and scalable game
    architectures, enabling smoother gameplay and more complex game logic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发领域，**数据结构**在组织和管理工作信息方面起着基本作用，直接影响游戏性能和玩家体验。高级数据结构，如用于快速数据检索的**字典**、用于管理层次关系的**树**和用于表示复杂网络的**图**，提供了超越简单数组和列表功能的复杂解决方案。选择正确的数据结构至关重要，因为它不仅影响游戏性能和内存效率，还影响开发者操作游戏数据的能力。根据特定需求进行仔细选择可以导致更健壮和可扩展的游戏架构，从而实现更流畅的游戏体验和更复杂的游戏逻辑。
- en: Implementing advanced data structures in Unity
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity中实现高级数据结构
- en: This section dives into the implementation of advanced data structures in Unity,
    essential for enhancing game development with efficient data handling capabilities.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了在Unity中实现高级数据结构，这对于通过高效的数据处理能力增强游戏开发至关重要。
- en: In Unity, dictionaries are essential for managing data that requires efficient
    and fast retrieval, ideal for scenarios where performance is critical. They provide
    a way to organize data such that elements can be quickly accessed using unique
    keys, vastly speeding up data retrieval compared to linear searches in lists.
    For example, dictionaries are perfect for storing player statistics in a sports
    simulation game, where accessing player stats quickly and frequently is crucial
    to the gameplay experience. A practical example involves using the `Dictionary<TKey,TValue>`
    class in Unity, which could be demonstrated through code snippets showing how
    to store and retrieve item properties in an inventory system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，字典对于管理需要高效和快速检索的数据至关重要，对于性能至关重要的场景来说非常理想。它们提供了一种组织数据的方法，使得可以使用唯一的键快速访问元素，与列表中的线性搜索相比，大大加快了数据检索速度。例如，字典非常适合在体育模拟游戏中存储玩家统计数据，快速频繁地访问玩家统计数据对于游戏体验至关重要。一个实际例子是使用Unity中的`Dictionary<TKey,TValue>`类，这可以通过代码片段展示如何在库存系统中存储和检索物品属性。
- en: 'In Unity, a dictionary is used to store and access elements with a key-value
    pair structure, which allows for rapid data retrieval. The following example demonstrates
    how to implement a dictionary to manage a simple inventory system where game items
    are stored with their item ID as the key and the item name as the value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，字典用于存储和访问具有键值对结构的元素，这允许快速数据检索。以下示例演示了如何实现一个字典来管理一个简单的库存系统，其中游戏物品以它们的物品ID作为键，以物品名称作为值存储：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the provided code snippet, a dictionary named `inventory` is declared to
    store integers (item IDs) and strings (item names). Items are added to the dictionary
    using the `Add` method, which pairs each item ID with a corresponding item name.
    For example, the `ID 1` item is associated with the `"Sword"` name. This setup
    allows for quick retrieval of item names based on their IDs, as demonstrated by
    the `Debug.Log` statement, which outputs the name of the item with `ID 1`. This
    efficient data structure is particularly useful in games for managing various
    types of data where quick access is necessary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码片段中，声明了一个名为`inventory`的字典来存储整数（物品ID）和字符串（物品名称）。使用`Add`方法将物品添加到字典中，该方法将每个物品ID与其对应的物品名称配对。例如，`ID
    1`物品与`"Sword"`名称相关联。这种设置允许根据其ID快速检索物品名称，如`Debug.Log`语句所示，该语句输出了具有`ID 1`的物品名称。这种高效的数据结构在游戏中特别有用，用于管理需要快速访问的各种类型的数据。
- en: While this section focuses on dictionaries due to their widespread utility in
    game development, it’s also worth noting the importance of other advanced data
    structures such as trees and graphs. Trees are valuable for creating hierarchical
    systems such as organizational charts or decision trees, and graphs are instrumental
    in representing complex networks, such as traffic systems or social relationships.
    Although detailed discussions on trees and graphs exceed the scope of this section,
    they remain integral components of advanced data management in games, offering
    structured ways to handle complex data beyond simple linear data structures.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节侧重于字典，因为它们在游戏开发中具有广泛的应用，但值得注意的是其他高级数据结构（如树和图）的重要性。树对于创建层次结构系统（如组织图表或决策树）非常有价值，而图在表示复杂网络（如交通系统或社会关系）方面至关重要。尽管对树和图的详细讨论超出了本节的范围，但它们仍然是游戏高级数据管理的重要组成部分，提供了处理复杂数据（超出简单线性数据结构）的结构化方法。
- en: Moving forward, we will explore the vital processes of serialization and deserialization,
    focusing on how complex data structures are handled during game saves and loads.
    We will discuss Unity’s built-in tools and third-party solutions that improve
    flexibility and performance, emphasizing best practices for data integrity (ensuring
    data is accurate and consistent) and compatibility across various game versions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将探讨序列化和反序列化的关键过程，重点关注在游戏保存和加载过程中如何处理复杂的数据结构。我们将讨论Unity内置的工具和第三方解决方案，这些解决方案可以提高灵活性和性能，强调数据完整性（确保数据准确和一致）以及在不同游戏版本之间的兼容性的最佳实践。
- en: Serialization and deserialization for game saves
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏保存的序列化和反序列化
- en: This section examines the critical processes of serialization and deserialization
    in Unity, essential for converting complex data structures into formats suitable
    for saving and restoring game states. We will explore both Unity’s built-in serialization
    tools and third-party solutions that may offer improved flexibility and performance.
    Additionally, this discussion will highlight best practices for ensuring data
    integrity and maintaining compatibility across different game versions, providing
    developers with the insights needed to manage game data effectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了Unity中序列化和反序列化的关键过程，这对于将复杂的数据结构转换为适合保存和恢复游戏状态的格式至关重要。我们将探讨Unity内置的序列化工具和可能提供改进灵活性和性能的第三方解决方案。此外，本讨论还将强调确保数据完整性和在不同游戏版本之间保持兼容性的最佳实践，为开发者提供有效管理游戏数据所需的见解。
- en: In Unity, `JsonUtility`, offer a straightforward method to serialize and deserialize
    simple data types and some complex structures but may struggle with polymorphism
    or more complex nested types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，`JsonUtility`提供了一个简单的方法来序列化和反序列化简单的数据类型和一些复杂结构，但可能难以处理多态性或更复杂的嵌套类型。
- en: When these native tools do not suffice, developers can opt for third-party solutions
    that provide greater flexibility and improved performance. Such tools typically
    support a broader range of data types and allow more control over the serialization
    process, including how objects reference each other or the serialization of private
    fields. Libraries such as `Newtonsoft.Json` or **Full Serializer** are excellent
    examples, offering robust features for managing complex serialization scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些原生工具不足以满足需求时，开发者可以选择使用提供更大灵活性和改进性能的第三方解决方案。此类工具通常支持更广泛的数据类型，并允许在序列化过程中有更多的控制，包括对象如何相互引用或私有字段的序列化。例如，`Newtonsoft.Json`或**Full
    Serializer**等库提供了强大的功能，用于管理复杂的序列化场景。
- en: To maintain data integrity and ensure compatibility across different game versions,
    implementing version control within your serialization logic is vital. This includes
    assigning a version number to each saved game state and developing conditional
    serialization and deserialization logic that adjusts based on the version number.
    Such practices help prevent problems when game data structures change in new versions,
    ensuring older saves remain valid and functional. Moreover, consistently testing
    save-load cycles across various game versions is critical for identifying and
    fixing potential incompatibilities, thus preserving a seamless user experience.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持数据完整性和确保不同游戏版本之间的兼容性，在序列化逻辑中实现版本控制至关重要。这包括为每个保存的游戏状态分配一个版本号，并开发基于版本号的条件序列化和反序列化逻辑。这些做法有助于防止在新版本中游戏数据结构发生变化时出现问题，确保旧保存仍然有效且可用。此外，跨各种游戏版本持续测试保存-加载周期对于识别和修复潜在的不兼容性至关重要，从而保持无缝的用户体验。
- en: 'Here’s an example demonstrating how `JsonUtility` can be used to manage player
    preferences in a game:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了如何使用`JsonUtility`在游戏中管理玩家偏好：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, a `PlayerPreferences` class is defined with three fields:
    `audioVolume`, `brightness`, and `subtitlesEnabled`, each representing a setting
    that can be customized by the player. This class is marked with the `[System.Serializable]`
    attribute, which makes it eligible for JSON serialization.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，定义了一个`PlayerPreferences`类，包含三个字段：`audioVolume`、`brightness`和`subtitlesEnabled`，每个字段代表玩家可以自定义的设置。此类被标记为`[System.Serializable]`属性，使其有资格进行JSON序列化。
- en: Within the `PreferencesManager` class, a new instance of `PlayerPreferences`
    is created and initialized with default values. The `ToJson` method of `JsonUtility`
    is then used to serialize this instance into a JSON string, which could be saved
    to a file or sent to a server. The serialized JSON string is logged to the Unity
    console for demonstration purposes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PreferencesManager`类中，创建了一个新的`PlayerPreferences`实例，并使用默认值进行初始化。然后使用`JsonUtility`的`ToJson`方法将此实例序列化为JSON字符串，该字符串可以保存到文件或发送到服务器。为了演示目的，序列化的JSON字符串被记录到Unity控制台。
- en: Following serialization, the `FromJson` method is employed to deserialize the
    JSON string back into a new `PlayerPreferences` object. This demonstrates how
    game settings could be loaded back into the game, for instance, at the start or
    from a saved preferences file. The loaded preferences are also logged, showing
    the values that were initially set, thus verifying that the serialization and
    deserialization processes were successful. This example is a practical illustration
    of how `JsonUtility` can be effectively used in game development for managing
    player settings and preferences.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化之后，使用`FromJson`方法将JSON字符串反序列化为新的`PlayerPreferences`对象。这展示了如何将游戏设置重新加载到游戏中，例如在开始时或从保存的偏好文件中。加载的偏好设置也被记录下来，显示了最初设置的值，从而验证了序列化和反序列化过程的成功。这个示例是`JsonUtility`在游戏开发中有效管理玩家设置和偏好的实际应用。
- en: In this section, we delved into the essential roles of serialization and deserialization
    in Unity, exploring how developers can adeptly convert complex data structures
    for game state saving and restoration. We covered the use of Unity’s built-in
    tools such as `JsonUtility` and discussed third-party solutions that enhance flexibility
    and performance. Emphasizing best practices, we highlighted the need for maintaining
    data integrity and ensuring version compatibility to provide a seamless player
    experience.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了序列化和反序列化在Unity中的基本作用，探讨了开发者如何熟练地将复杂的数据结构转换为游戏状态的保存和恢复。我们介绍了Unity的内置工具，如`JsonUtility`，并讨论了增强灵活性和性能的第三方解决方案。强调最佳实践，我们强调了保持数据完整性和确保版本兼容性的必要性，以提供无缝的玩家体验。
- en: Moving forward, we will shift our focus to optimizing data management for performance
    in Unity, profiling and identifying bottlenecks, and providing strategies for
    effective data structure usage, including advice on value versus reference types,
    reducing garbage collection, and optimizing data access to boost game performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，我们将把重点转向Unity中优化数据管理以提升性能，分析并识别瓶颈，并提供有效数据结构使用的策略，包括关于值类型与引用类型的建议、减少垃圾回收以及优化数据访问以提升游戏性能。
- en: Optimizing data management for performance
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化数据管理以提升性能
- en: 'This section focuses on optimizing data management for performance in Unity,
    addressing the performance implications of using advanced data structures. We
    will provide practical guidance on profiling and identifying bottlenecks in data
    management, along with strategies to enhance the efficiency of data structure
    usage. This includes crucial tips on deciding between value and reference types,
    minimizing garbage collection, and implementing techniques for efficient data
    access and manipulation to ensure optimal performance in your game development
    projects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍Unity中数据管理的性能优化，讨论使用高级数据结构的性能影响。我们将提供实际指导，包括如何进行性能分析以识别数据管理中的瓶颈，以及提高数据结构使用效率的策略。这包括关于在值类型和引用类型之间做出选择的宝贵提示，最小化垃圾回收，以及实现高效数据访问和操作的技术，以确保在游戏开发项目中获得最佳性能：
- en: '**Profiling for managing data efficiently**: In the realm of Unity game development,
    managing data efficiently is critical to maintaining high performance and smooth
    gameplay. One significant aspect of this management involves profiling to detect
    bottlenecks in your game’s data-handling processes. Profiling tools within Unity,
    such as the Unity Profiler, allow developers to analyze memory usage and the performance
    impact of different data structures in real time. This analysis can pinpoint inefficiencies
    that, once addressed, can lead to substantial performance gains.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行性能分析以高效管理数据**：在Unity游戏开发领域，高效地管理数据对于保持高性能和流畅的游戏体验至关重要。这一管理的一个重要方面涉及性能分析，以检测游戏中数据处理过程中的瓶颈。Unity中的性能分析工具，如Unity
    Profiler，允许开发者实时分析内存使用情况以及不同数据结构对性能的影响。这种分析可以确定不效率之处，一旦解决，可以带来显著的性能提升。'
- en: '**Strategically using value and reference types**: Another vital area of optimization
    is the strategic use of value and reference types. Value types, stored directly
    on the stack, typically offer faster access times and can reduce overhead when
    they are small and immutable. However, misuse can lead to excessive copying, especially
    in large structures. Conversely, reference types are stored on the heap and can
    be more efficient for large data structures or when data needs to be shared across
    multiple components. Developers must carefully choose between these types based
    on their specific needs to optimize performance.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略性地使用值类型和引用类型**：另一个重要的优化领域是策略性地使用值类型和引用类型。值类型直接存储在栈上，通常提供更快的访问时间，并且在它们小且不可变时可以减少开销。然而，不当使用可能导致过度复制，尤其是在大型结构中。相反，引用类型存储在堆上，对于大型数据结构或需要跨多个组件共享数据的情况可能更有效率。开发者必须根据具体需求谨慎选择这些类型，以优化性能。'
- en: '**Minimizing garbage collection**: Minimizing garbage collection is essential
    for game performance. Frequent garbage collections can cause frame rate hitches
    and reduce the smoothness of gameplay. To mitigate this, developers should avoid
    frequent allocations and deallocations of objects during gameplay. Instead, techniques
    such as object pooling or using immutable data structures can be employed to maintain
    a steady performance. By understanding and applying these strategies, developers
    can significantly enhance the responsiveness and stability of their Unity games.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化垃圾回收**：最小化垃圾回收对于游戏性能至关重要。频繁的垃圾回收可能导致帧率波动并降低游戏流畅度。为了减轻这一问题，开发者在游戏过程中应避免频繁分配和释放对象。相反，可以采用对象池或使用不可变数据结构等技术来保持稳定的性能。通过理解和应用这些策略，开发者可以显著提升他们Unity游戏的响应性和稳定性。'
- en: This comprehensive section on advanced data management has explored the critical
    role of complex data structures in game development, underscoring their necessity
    for sophisticated game logic. We began by discussing the importance of choosing
    appropriate data structures, such as dictionaries for rapid lookups and trees
    for hierarchical systems, and their implementation in Unity. Practical examples
    illustrated their integration into the Unity environment, emphasizing the benefits
    and performance considerations. We delved into serialization and deserialization
    processes essential for game saves, detailing both Unity’s built-in tools and
    more flexible third-party solutions. Lastly, we offered strategies to optimize
    data management for performance, including tips on profiling, choosing between
    value and reference types, and minimizing garbage collection to enhance game performance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本节全面探讨了高级数据管理，探讨了复杂数据结构在游戏开发中的关键作用，强调了它们对于复杂游戏逻辑的必要性。我们首先讨论了选择适当数据结构的重要性，例如使用字典进行快速查找和使用树进行分层系统，以及它们在
    Unity 中的实现。实际示例说明了它们在 Unity 环境中的集成，强调了其优势和性能考虑。我们深入探讨了序列化和反序列化过程，这对于游戏保存至关重要，详细介绍了
    Unity 的内置工具和更灵活的第三方解决方案。最后，我们提供了优化数据管理以提高性能的策略，包括关于分析、在值类型和引用类型之间选择以及最小化垃圾回收以增强游戏性能的建议。
- en: As we move forward, our focus will shift to creating custom event systems, where
    we will explore the implementation of events and delegates in C#. This next section
    will provide a foundation for understanding event-driven programming, essential
    for crafting dynamic and interactive game elements, and discuss how custom event
    systems can make your game code more modular and maintainable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们的重点将转向创建自定义事件系统，我们将探讨 C# 中事件和委托的实现。下一节将为理解事件驱动编程提供基础，这对于制作动态和交互式游戏元素至关重要，并讨论自定义事件系统如何使您的游戏代码更加模块化和易于维护。
- en: Creating custom event systems
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义事件系统
- en: This section delves into the creation of custom event systems in Unity, a fundamental
    technique for enhancing interactivity and dynamics in game elements. We will start
    by exploring the core concepts of events and delegates in C#, detailing their
    crucial role in event-driven programming and how they enable methods to act as
    type-safe (ensuring only the correct data type is used) pointers. The focus will
    then shift to designing and implementing a custom event system within the Unity
    framework, highlighting how to construct event managers, define event types, and
    register listeners. This discussion will include practical use cases and examples
    to demonstrate how event systems can decouple game components, thereby making
    the code more modular and maintainable. Additionally, we will cover best practices
    and address common pitfalls to ensure effective and efficient implementation of
    event systems in your game development projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了在 Unity 中创建自定义事件系统，这是增强游戏元素交互性和动态性的基本技术。我们将从探索 C# 中事件和委托的核心概念开始，详细说明它们在事件驱动编程中的关键作用以及它们如何使方法作为类型安全（确保只使用正确的数据类型）的指针。然后，重点将转向在
    Unity 框架内设计和实现自定义事件系统，突出如何构建事件管理器、定义事件类型和注册监听器。这次讨论将包括实际用例和示例，以展示事件系统如何解耦游戏组件，从而使代码更加模块化和易于维护。此外，我们还将介绍最佳实践和解决常见问题，以确保在您的游戏开发项目中有效地和高效地实现事件系统。
- en: Introduction to events and delegates in C#
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 事件和委托简介
- en: This introductory section provides a foundational overview of events and delegates
    in C#, crucial components in event-driven programming. We will explore how delegates
    function as type-safe method pointers, allowing methods to be passed as arguments,
    and how events leverage these delegates to establish a subscription model for
    managing notifications. Understanding these concepts is essential, as they form
    the basic building blocks of event systems, setting the stage for more complex
    interactions within game development. This discussion will clarify the role of
    these programming constructs and prepare you to effectively utilize them in creating
    dynamic and responsive game environments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 C# 中的事件和委托的基础概述，这是事件驱动编程中的关键组件。我们将探讨委托如何作为类型安全的方法指针工作，允许方法作为参数传递，以及事件如何利用这些委托来建立用于管理通知的订阅模型。理解这些概念是至关重要的，因为它们构成了事件系统的基本构建块，为游戏开发中更复杂的交互奠定了基础。这次讨论将阐明这些编程结构的作用，并为您在创建动态和响应式游戏环境时有效地利用它们做好准备。
- en: In C#, **delegates** are essentially type-safe function pointers that encapsulate
    a method with a specific signature, allowing methods to be passed around and invoked
    as arguments. This capability is instrumental in event-driven programming where
    responses to changes or user actions need to be dynamically handled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，**代表**本质上是一种类型安全的函数指针，它封装了一个具有特定签名的函数，允许方法被传递并作为参数调用。这种能力在事件驱动编程中至关重要，因为需要对变化或用户操作进行动态处理。
- en: '**Events**, built on top of delegates, further facilitate communication between
    objects. They allow one object to publish an event to be received by multiple
    subscribers, thereby implementing a subscription model. This model is crucial
    for decoupling components in software architecture, allowing systems to interact
    through notifications without direct dependency. Understanding how delegates and
    events function provides developers with powerful tools to design responsive and
    modular systems, which are especially valuable in game development where user
    interaction and real-time updates are paramount.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**建立在代表之上，进一步促进了对象之间的通信。它们允许一个对象发布一个事件，被多个订阅者接收，从而实现订阅模型。这种模型对于软件架构中组件解耦至关重要，允许系统通过通知进行交互，而不存在直接依赖。了解代表和事件的工作原理为开发者提供了强大的工具来设计响应性和模块化系统，这在游戏开发中尤其有价值，因为用户交互和实时更新至关重要。'
- en: 'In *Figure 9**.1*, we see Game Manager as the central hub and the various other
    scripts message and listen for the Game Manager:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 9*.1 中，我们看到游戏管理器作为中心枢纽，其他各种脚本向游戏管理器发送消息并监听：
- en: '![Figure 9.1 – Delegates and events act as a communication system between scripts](img/B22128_09_1.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 代表和事件作为脚本之间的通信系统](img/B22128_09_1.jpg)'
- en: Figure 9.1 – Delegates and events act as a communication system between scripts
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 代表和事件作为脚本之间的通信系统
- en: This section has introduced the fundamentals of events and delegates in C#,
    which are crucial for event-driven programming. By explaining how delegates allow
    methods to be passed as arguments and how events use these delegates for handling
    notifications, we’ve set the stage for deeper exploration. Next, we will delve
    into designing and implementing a custom event system in Unity, focusing on its
    architecture, the creation of event managers, and the registration of listeners
    to enhance modularity and maintainability in game development.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 C# 中事件和代表的基本概念，这对于事件驱动编程至关重要。通过解释代表如何允许方法作为参数传递以及事件如何使用这些代表来处理通知，我们为更深入的探索奠定了基础。接下来，我们将深入探讨在
    Unity 中设计和实现自定义事件系统，重点关注其架构、事件管理器的创建以及监听器的注册，以增强游戏开发中的模块化和可维护性。
- en: Designing a custom event system in Unity
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Unity 中设计自定义事件系统
- en: 'In this section, we’ll explore practical applications of custom event systems
    in game development through detailed examples. We will see how events can be strategically
    employed to manage player inputs, UI interactions, and dynamic changes in game
    state such as triggering dialogues, cutscenes, or environmental transformations.
    These scenarios will be supported by code snippets and explanations that demonstrate
    how a well-designed event system can decouple game components. This approach not
    only simplifies the development process but also results in a cleaner, more flexible
    code architecture, allowing for easier updates and maintenance. Here are some
    key applications of custom event systems:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过详细的示例探讨自定义事件系统在游戏开发中的实际应用。我们将看到如何战略性地使用事件来管理玩家输入、UI 交互以及游戏状态中的动态变化，如触发对话、剪辑或环境转换。这些场景将由代码片段和解释支持，展示一个精心设计的事件系统如何解耦游戏组件。这种方法不仅简化了开发过程，而且结果是一个更干净、更灵活的代码架构，便于更新和维护。以下是自定义事件系统的关键应用：
- en: '**Managing player inputs**: One key application of custom event systems in
    game development is managing player inputs. Consider a scenario where different
    game objects need to react differently to the same input. By using an event system,
    a central input manager can broadcast an event whenever a key is pressed. Individual
    game objects subscribe to this event and execute their unique reactions only when
    triggered, thus decoupling the input handling from the objects’ behaviors. For
    example, pressing a button might cause one character to jump, while causing another
    to crouch, depending on their current state or position in the game.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理玩家输入**：自定义事件系统在游戏开发中的一个关键应用是管理玩家输入。考虑一个场景，其中不同的游戏对象需要对相同的输入做出不同的反应。通过使用事件系统，中央输入管理器可以在按键按下时广播事件。单个游戏对象订阅此事件，并在触发时执行其独特的反应，从而将输入处理与对象的动作解耦。例如，按下一个按钮可能使一个角色跳跃，而使另一个角色蹲下，这取决于它们当前的状态或游戏中的位置。'
- en: '`OnVolumeChange` or `OnResolutionChange`. Separate systems or components that
    handle audio settings and display settings can listen for these events and react
    appropriately without needing direct communication links with the UI components
    themselves. This decouples the UI from the systems that implement the changes,
    facilitating easier maintenance and scalability of the code.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnVolumeChange` 或 `OnResolutionChange`。处理音频设置和显示设置的独立系统或组件可以监听这些事件，并相应地做出反应，而无需与UI组件直接通信链接。这种解耦使得UI与实现更改的系统分离，便于代码的维护和扩展。'
- en: '`OnEnterTriggerArea`, which the cutscene manager listens to. Upon receiving
    this event, the cutscene manager can initiate the appropriate cinematic sequence
    without being directly called by the game area’s script. This separation ensures
    that the triggering logic and the cinematic control logic do not intertwine unnecessarily,
    promoting a modular and maintainable code base.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEnterTriggerArea`，这是场景管理器所监听的事件。在接收到此事件后，场景管理器可以启动适当的电影序列，而无需直接被游戏区域的脚本调用。这种分离确保了触发逻辑和电影控制逻辑不会不必要地交织在一起，从而促进模块化和可维护的代码库。'
- en: These examples illustrate how custom event systems facilitate communication
    between different game components while maintaining a clean architecture by ensuring
    that these components remain loosely coupled, enhancing modularity and flexibility.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例说明了自定义事件系统如何促进不同游戏组件之间的通信，同时通过确保这些组件保持松散耦合，保持清晰的架构，增强模块化和灵活性。
- en: In this section, we have explored the design and implementation of a custom
    event system within the Unity framework, detailing the creation of event managers,
    the definition of event types, and the registration of listeners. This architecture
    plays a crucial role in enhancing communication across various game components,
    significantly improving modularity and maintainability. Such a system ensures
    that components can interact seamlessly without being tightly coupled, paving
    the way for more scalable and manageable code bases.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Unity框架内自定义事件系统的设计和实现，详细介绍了事件管理器的创建、事件类型的定义和监听器的注册。这种架构在增强各种游戏组件之间的通信中发挥着关键作用，显著提高了模块化和可维护性。这样的系统确保组件可以无缝交互，而无需紧密耦合，为更可扩展和可管理的代码库铺平道路。
- en: Next, we will examine practical use cases and examples to demonstrate how these
    custom event systems are applied in real game development scenarios, such as managing
    player inputs, UI interactions, and game state changes, further illustrating the
    benefits of a decoupled and flexible code architecture.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨实际用例和示例，以展示这些自定义事件系统如何在真实游戏开发场景中应用，例如管理玩家输入、UI交互和游戏状态变化，进一步说明解耦和灵活的代码架构的好处。
- en: Practical use cases and examples of custom event systems in game development
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏开发中自定义事件系统的实际用例和示例
- en: This section will delve into practical use cases and examples to illustrate
    the effective application of custom event systems in game development. We will
    explore how events can skillfully manage player inputs, UI interactions, and significant
    changes in game state—such as triggering dialogues, cutscenes, or environmental
    modifications. Each example will include code snippets and detailed explanations
    of how these event systems facilitate the decoupling of game components, resulting
    in a cleaner, more flexible code architecture that enhances maintainability and
    scalability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将深入探讨实际用例和示例，以说明自定义事件系统在游戏开发中的有效应用。我们将探讨事件如何巧妙地管理玩家输入、UI交互以及游戏状态的重大变化——例如触发对话、剪辑场景或环境修改。每个示例都将包括代码片段和详细说明，这些事件系统如何促进游戏组件的解耦，从而实现更干净、更灵活的代码架构，提高可维护性和可扩展性。
- en: Streamlining the interaction between different components and improving code
    organization
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化不同组件之间的交互和改进代码组织
- en: 'Custom event systems in game development streamline the interaction between
    different components and improve the organization of the code. For instance, consider
    the management of player inputs. Typically, multiple game systems need to respond
    to the same user input, and setting this up without an event system can lead to
    tightly coupled code that is hard to maintain:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发中的自定义事件系统简化了不同组件之间的交互，并提高了代码的组织性。例如，考虑玩家输入的管理。通常，多个游戏系统需要响应相同的用户输入，如果没有事件系统，设置这些系统可能会导致代码紧密耦合，难以维护：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, `OnInputReceived` is an event that fires when a specific
    key is pressed. Separate game systems subscribe to this event and react only if
    the event is relevant, such as handling a jump when the spacebar is pressed. This
    decouples the input handling from the actions performed, allowing for easier changes
    to input mappings or game logic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`OnInputReceived` 是一个在按下特定键时触发的事件。不同的游戏系统订阅此事件，并且只有在事件相关时才做出反应，例如在按下空格键时处理跳跃。这种方法将输入处理与执行的动作解耦，使得对输入映射或游戏逻辑的更改更加容易。
- en: Managing UI interactions
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理UI交互
- en: 'Another significant application of event systems is in managing UI interactions.
    For example, suppose a player adjusts a setting in the **Options** menu that needs
    to trigger updates in various parts of the game, such as changing the audio volume:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 事件系统在管理UI交互方面也有另一个重要的应用。例如，假设玩家在 **选项** 菜单中调整了一个设置，需要触发游戏中各个部分的更新，比如改变音量：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding example shows a UI slider controlling the game’s volume. The `OnVolumeChanged`
    event is triggered whenever the slider’s value changes, which the audio manager
    listens to. This pattern ensures that the UI does not directly manipulate the
    audio settings, adhering to the principle of separation of concerns (keeping different
    parts of a program distinct and independent).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了如何使用 UI 滑块来控制游戏音量。每当滑块的值发生变化时，都会触发 `OnVolumeChanged` 事件，音频管理器会监听这个事件。这种模式确保了
    UI 不直接操作音频设置，遵循了关注点分离的原则（保持程序不同部分独立且互不干扰）。
- en: Managing changes in game state
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理游戏状态的变化
- en: 'Lastly, event systems are crucial for managing changes in the game’s state,
    such as triggering a dialogue or cutscenes based on player location or actions.
    Let’s look at the following code block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，事件系统对于管理游戏状态的变化至关重要，例如根据玩家位置或动作触发对话或剪辑场景。让我们看一下以下代码块：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this scenario, an event is raised when the player enters a specific zone,
    which triggers a corresponding dialogue system. This method ensures that the environmental
    triggers are cleanly separated from the narrative components, promoting modular
    design and easy adjustments to game mechanics or story elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，当玩家进入特定区域时，会引发一个事件，触发相应的对话系统。这种方法确保了环境触发器与叙事组件干净地分离，促进了模块化设计和游戏机制或故事元素调整的便捷性。
- en: In this section, we have explored several practical use cases demonstrating
    the effectiveness of custom event systems in game development. Through detailed
    examples, we have shown how events can adeptly manage player inputs, UI interactions,
    and significant game state changes, such as triggering dialogue and cutscenes.
    Each scenario, supported by code snippets, illustrated the power of event systems
    to decouple game components, thereby enhancing code cleanliness and flexibility.
    This approach not only simplifies development and maintenance but also scales
    more effectively as game complexity grows.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了几个实际用例，展示了自定义事件系统在游戏开发中的有效性。通过详细的示例，我们展示了事件如何巧妙地管理玩家输入、UI交互以及重要的游戏状态变化，例如触发对话和场景。每个场景都通过代码片段说明了事件系统解耦游戏组件的能力，从而增强了代码的整洁性和灵活性。这种方法不仅简化了开发和维护，而且在游戏复杂性增加时也更具可扩展性。
- en: As we move into the next section, we will discuss best practices and common
    pitfalls in designing and using event systems in Unity. This will include crucial
    strategies such as ensuring proper event de-registration to prevent memory leaks
    and managing the complexity of event-driven code to avoid creating spaghetti code.
    Understanding these practices will equip developers with the knowledge to implement
    efficient and effective event systems, ensuring their game projects are both robust
    and maintainable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一节，我们将讨论在Unity中设计和使用事件系统的最佳实践和常见陷阱。这包括确保适当注销事件以防止内存泄漏和管理工作驱动复杂性的关键策略。了解这些实践将使开发者具备实施高效且有效的事件系统的知识，确保他们的游戏项目既稳健又易于维护。
- en: Best practices and common pitfalls in designing and using event systems in Unity
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity中设计和使用事件系统的最佳实践和常见陷阱
- en: This section outlines the best practices and common pitfalls in designing and
    using event systems in Unity. We’ll cover essential strategies such as ensuring
    proper event de-registration to prevent memory leaks and techniques for managing
    event-driven complexity to avoid creating unmanageable spaghetti code. By highlighting
    these key points along with how to circumvent typical errors, this guide aims
    to equip developers with the necessary insights to build efficient and effective
    event systems that enhance the maintainability and robustness of their game projects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了在Unity中设计和使用事件系统的最佳实践和常见陷阱。我们将涵盖确保适当注销事件以防止内存泄漏和管理工作驱动复杂性的技术，以避免创建难以管理的乱麻代码。通过突出这些关键点以及如何规避典型错误，本指南旨在为开发者提供必要的见解，以构建高效且有效的事件系统，从而提高游戏项目的可维护性和稳健性。
- en: Diligent management of event registrations and de-registrations
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勤奋管理事件注册和注销
- en: 'One of the fundamental best practices in using event systems in Unity involves
    diligent management of event registrations and de-registrations. It’s crucial
    to unregister events when they are no longer needed, typically in the `OnDisable`
    method of `MonoBehaviour`. This prevents memory leaks that can occur if an object
    holding a subscription is destroyed, yet the event handler remains active, causing
    the object to linger in memory indefinitely:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中使用事件系统时，一项基本最佳实践是勤奋地管理事件注册和注销。在 `MonoBehaviour` 的 `OnDisable` 方法中注销事件至关重要，这可以防止在持有订阅的对象被销毁时发生内存泄漏，而事件处理程序仍然处于活动状态，导致对象在内存中无限期地停留：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, `CustomEventHandler` is registered with the event
    in the `OnEnable` method and importantly, de-registered in the `OnDisable` method.
    This pattern ensures that handlers are only active when the object is in use,
    thereby conserving memory and processing resources.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`CustomEventHandler` 在 `OnEnable` 方法中注册了事件，并且重要的是，在 `OnDisable` 方法中进行了注销。这种模式确保了处理程序仅在对象使用时才处于活动状态，从而节省内存和处理资源。
- en: Managing the complexity of event-driven code
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理事件驱动代码的复杂性
- en: Another crucial practice is to manage the complexity of event-driven code to
    prevent it from devolving into spaghetti code. This involves keeping the event
    logic simple and not allowing event handlers to become overly intertwined. For
    example, it’s advisable to limit the actions performed directly in an event handler
    and instead call other methods where appropriate. This keeps the event handling
    clean and modular, making the code easier to maintain and debug.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键实践是管理事件驱动代码的复杂性，以防止其演变成意大利面条代码。这涉及到保持事件逻辑简单，并防止事件处理程序过于交织。例如，建议限制在事件处理程序中直接执行的操作，并在适当的地方调用其他方法。这保持了事件处理的清晰和模块化，使代码更容易维护和调试。
- en: 'Here is the before (how *not* to do it):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是之前（如何不这样做）：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the after (how to do it):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是之后（如何这样做）：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `CustomEventHandler` calls other methods rather than directly implementing
    all logic within the handler. This separation helps maintain clarity and separation
    of concerns within the code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CustomEventHandler`调用其他方法，而不是在处理程序中直接实现所有逻辑。这种分离有助于在代码中保持清晰性和关注点的分离。
- en: Using event systems judiciously
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明智地使用事件系统
- en: Lastly, it is beneficial to use event systems judiciously and understand when
    they are the best solution versus other patterns such as direct method calls or
    using Unity’s built-in messaging system. Event systems are excellent for scenarios
    where multiple unrelated components need to respond to changes in state or other
    signals. However, they might be overkill for simpler interactions, leading to
    unnecessary complexity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，明智地使用事件系统并理解在什么情况下它们是最佳解决方案，相对于直接方法调用或使用Unity内置的消息系统，是非常有益的。事件系统在多个无关组件需要响应状态变化或其他信号的场景中表现得非常出色。然而，对于更简单的交互，它们可能过于复杂，导致不必要的复杂性。
- en: By adhering to these best practices and being mindful of common pitfalls, developers
    can ensure that their use of event systems in Unity contributes positively to
    both the performance and maintainability of their game projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践并注意常见的陷阱，开发者可以确保他们在Unity中使用事件系统对游戏项目的性能和可维护性产生积极贡献。
- en: In this section, we learned in detail the integration and utility of custom
    event systems in Unity, starting with an introduction to the core concepts of
    events and delegates in C#. This foundational knowledge underscores the significance
    of event-driven programming and sets the stage for constructing sophisticated,
    modular game systems. We discussed the design of these systems within Unity, from
    creating event managers to defining event types and registering listeners, demonstrating
    how they foster improved communication and modularity across various game components.
    Practical examples showed how custom event systems effectively manage player inputs,
    UI interactions, and significant game changes such as dialogues and cutscenes,
    leading to more maintainable and flexible code architectures. The section concluded
    with best practices and common pitfalls, equipping developers with the knowledge
    to prevent issues such as memory leaks and overly complex code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们详细学习了Unity中自定义事件系统的集成和实用性，从介绍C#中的事件和委托的核心概念开始。这些基础知识强调了事件驱动编程的重要性，并为构建复杂、模块化的游戏系统奠定了基础。我们讨论了在Unity中这些系统的设计，从创建事件管理器到定义事件类型和注册监听器，展示了它们如何促进各种游戏组件之间的改进通信和模块化。实际示例展示了自定义事件系统如何有效地管理玩家输入、UI交互以及重要的游戏变化，如对话和场景剪辑，从而实现更可维护和灵活的代码架构。本节以最佳实践和常见陷阱结束，为开发者提供了预防内存泄漏和过于复杂代码等问题的知识。
- en: Next, we transition into script optimization techniques, where we’ll dive into
    profiling tools in Unity, identify performance bottlenecks, and explore advanced
    techniques for optimizing Unity scripts to enhance game performance further.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将过渡到脚本优化技术，我们将深入研究Unity中的分析工具，识别性能瓶颈，并探索优化Unity脚本的高级技术，以进一步提高游戏性能。
- en: Script optimization techniques
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本优化技术
- en: In the realm of game development, where milliseconds matter and smooth gameplay
    is essential, mastering script optimization is crucial. This section delves into
    techniques to elevate Unity projects’ performance and efficiency. We explore tools
    for identifying bottlenecks, dissect common pitfalls, and implement memory management
    strategies. Get ready to unlock the secrets of script optimization prowess for
    unparalleled gaming experiences.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发领域，毫秒至关重要，流畅的游戏体验是必不可少的，掌握脚本优化至关重要。本节深入探讨了提升Unity项目性能和效率的技术。我们探讨了识别瓶颈的工具、剖析常见陷阱，并实施内存管理策略。准备好揭示脚本优化技巧的秘密，以获得无与伦比的游戏体验。
- en: Profiling and identifying bottlenecks
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析和识别瓶颈
- en: In the fast-paced world of game development, optimizing performance is crucial
    for creating captivating experiences. This section delves into Unity’s profiling
    tools, such as the **Unity Profiler** and **Frame Debugger**, essential for pinpointing
    performance bottlenecks. By deciphering data on CPU usage, memory allocations,
    and rendering efficiency, we equip you with the skills to elevate your game’s
    performance. Join us as we unravel the mysteries behind smooth gameplay, one frame
    at a time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发这个快节奏的世界里，优化性能对于创造引人入胜的体验至关重要。本节深入探讨了Unity的分析工具，如**Unity Profiler**和**帧调试器**，这些工具对于定位性能瓶颈至关重要。通过解码CPU使用率、内存分配和渲染效率的数据，我们为您提供了提升游戏性能的技能。加入我们，一起揭示流畅游戏背后的奥秘，一次一帧。
- en: Unity provides developers with a robust set of profiling tools, including the
    Unity Profiler and Frame Debugger, which serve as invaluable assets in the pursuit
    of optimization. The Unity Profiler offers a comprehensive overview of your game’s
    performance metrics, allowing you to monitor CPU usage, GPU rendering, memory
    allocation, and more in real time. By analyzing these metrics, developers can
    identify areas of concern that may be impeding performance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为开发者提供了一套强大的分析工具，包括Unity Profiler和帧调试器，这些工具在追求优化的过程中是宝贵的资产。Unity Profiler提供了您游戏性能指标的全面概述，允许您实时监控CPU使用率、GPU渲染、内存分配等。通过分析这些指标，开发者可以识别可能阻碍性能的担忧区域。
- en: One of the primary advantages of the Unity Profiler is its ability to pinpoint
    high CPU usage, a common bottleneck in game development. By monitoring CPU spikes
    and identifying the corresponding code segments responsible, developers can optimize
    performance by optimizing or refactoring these sections. Additionally, excessive
    memory allocations can lead to performance degradation, causing frequent garbage
    collection pauses. Through the Unity Profiler, developers can track memory usage
    and identify areas where memory allocations can be minimized, such as by implementing
    object pooling or optimizing data structures.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Profiler的一个主要优势在于其能够精确地定位高CPU使用率，这是游戏开发中常见的瓶颈。通过监控CPU峰值并识别相应的代码段，开发者可以通过优化或重构这些部分来优化性能。此外，过多的内存分配可能导致性能下降，造成频繁的垃圾回收暂停。通过Unity
    Profiler，开发者可以跟踪内存使用情况，并识别可以最小化内存分配的区域，例如通过实现对象池或优化数据结构。
- en: Moreover, the Frame Debugger is instrumental in identifying rendering inefficiencies
    that may impact performance. By analyzing each frame rendered by the game, developers
    can detect rendering bottlenecks such as overdraw, excessive draw calls, or inefficient
    shader usage. Armed with this knowledge, developers can optimize rendering performance
    by reducing the complexity of shaders, batching draw calls, or implementing occlusion
    culling techniques.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，帧调试器在识别可能影响性能的渲染效率方面起着至关重要的作用。通过分析游戏渲染的每一帧，开发者可以检测到渲染瓶颈，例如过度绘制、过多的绘制调用或效率低下的着色器使用。有了这些知识，开发者可以通过减少着色器的复杂性、批处理绘制调用或实施遮挡剔除技术来优化渲染性能。
- en: In essence, mastering the art of profiling and identifying bottlenecks empowers
    developers to optimize their games for maximum performance and efficiency. By
    leveraging Unity’s profiling tools, developers can conduct thorough performance
    analyses, interpret the data, and implement targeted optimizations to ensure smooth
    and responsive gameplay experiences.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，掌握分析技术和识别瓶颈的艺术，使开发者能够为最大性能和效率优化他们的游戏。通过利用Unity的分析工具，开发者可以进行彻底的性能分析，解读数据，并实施有针对性的优化，以确保流畅和响应迅速的游戏体验。
- en: In this section, we explored how Unity’s profiling tools such as the Unity Profiler
    and Frame Debugger are essential for pinpointing bottlenecks and optimizing game
    performance. By analyzing data on CPU usage, memory allocations, and rendering
    efficiency, developers gain valuable insights into areas ripe for optimization.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Unity的剖析工具，如Unity Profiler和Frame Debugger，对于定位瓶颈和优化游戏性能的重要性。通过分析CPU使用、内存分配和渲染效率的数据，开发者可以获取到优化潜力的宝贵见解。
- en: Transitioning to optimizing game scripts next, we will delve deeper into common
    performance issues in Unity scripts and strategies for addressing them. From optimizing
    loops to minimizing object instantiations, we provide specific examples illustrating
    the tangible impact of optimization techniques on gameplay performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨优化游戏脚本，分析Unity脚本中常见的性能问题及其解决策略。从优化循环到最小化对象实例化，我们提供了具体的示例，展示了优化技术对游戏性能的直接影响。
- en: Optimizing game scripts
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化游戏脚本
- en: In the intricate tapestry of game development, script optimization emerges as
    the cornerstone of crafting immersive and responsive gameplay experiences. In
    this section, we embark on a journey into the realm of optimizing game scripts,
    where we unravel the complexities of common performance issues found in Unity
    scripts and arm you with the tools to address them effectively. From mastering
    the art of efficient loop usage to navigating the nuances of garbage collection,
    we delve into the depths of script optimization techniques that elevate your creations
    to new heights of performance and efficiency. Join us as we explore the impact
    of minimizing object instantiations and the judicious use of `Invoke`, `SendMessage`,
    and coroutines, accompanied by specific examples illustrating the transformative
    power of optimization. Through *before and after* scenarios, we showcase how strategic
    optimization techniques can breathe life into your code base, ensuring that every
    line of script contributes to the seamless orchestration of gaming brilliance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的复杂织锦中，脚本优化成为打造沉浸式和响应式游戏体验的基石。在本节中，我们将踏上优化游戏脚本之旅，揭示Unity脚本中常见性能问题的复杂性，并为你提供有效解决这些问题的工具。从掌握高效循环使用技巧到探索垃圾回收的微妙之处，我们深入脚本优化技术的深处，这些技术将你的创作提升到性能和效率的新高度。加入我们，一起探索最小化对象实例化和谨慎使用`Invoke`、`SendMessage`和协程的影响，以及具体示例展示了优化带来的变革力量。通过*前后*场景，我们展示了战略优化技术如何为你的代码库注入活力，确保每一行脚本都对游戏卓越的流畅编排做出贡献。
- en: Efficiently using loops
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高效使用循环
- en: 'The efficient use of loops is fundamental to script optimization in Unity.
    Loops are often used for iterating through collections of data or performing repetitive
    tasks. However, inefficient loop structures can introduce unnecessary overhead
    and impact performance. For example, nested loops can exponentially increase the
    number of iterations, leading to significant processing time. By refactoring nested
    loops into single loops or employing techniques such as loop unrollin g (a method
    where the loop’s iterations are expanded to reduce the loop’s overhead), developers
    can streamline their code and improve performance dramatically. Consider the following
    example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本优化中，高效使用循环是基础。循环通常用于遍历数据集合或执行重复任务。然而，不高效的循环结构可能会引入不必要的开销并影响性能。例如，嵌套循环可以指数级增加迭代次数，导致显著的处理时间。通过将嵌套循环重构为单循环或采用如循环展开（一种将循环迭代展开以减少循环开销的方法）等技术，开发者可以简化代码并显著提高性能。以下是一个示例：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The *before* code utilizes nested loops to iterate through a 2D array, while
    the second code optimizes the process by using a single loop and calculating the
    corresponding indices for the 2D array elements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始*代码使用嵌套循环遍历二维数组，而第二段代码通过使用单个循环并计算二维数组元素的相应索引来优化这个过程。'
- en: Minimizing object instantiations
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化对象实例化
- en: 'Minimizing object instantiations is another crucial aspect of script optimization.
    Creating and destroying objects frequently can lead to memory fragmentation and
    increased garbage collection overhead. Object pooling is a popular technique for
    mitigating this issue by reusing objects instead of instantiating and destroying
    them repeatedly. By maintaining a pool of pre-allocated objects and recycling
    them as needed, developers can significantly reduce memory churn and improve performance.
    Here’s a simplified example of object pooling:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化对象实例化是脚本优化的另一个关键方面。频繁地创建和销毁对象可能导致内存碎片化和垃圾收集开销增加。对象池是一种常用的技术，通过重用对象而不是反复实例化和销毁它们来减轻这一问题。通过维护一个预分配的对象池并在需要时回收它们，开发者可以显著减少内存波动并提高性能。以下是一个简化的对象池示例：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before optimization, objects are instantiated and destroyed as needed. After
    optimization, object pooling is utilized, where objects are retrieved from a pool
    and activated with updated position and rotation parameters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化之前，对象根据需要被实例化和销毁。在优化之后，使用对象池技术，即从池中检索对象，并使用更新的位置和旋转参数激活它们。
- en: Understanding garbage collection behavior
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解垃圾回收行为
- en: 'Understanding garbage collection behavior is critical for optimizing memory
    usage in Unity scripts. Garbage collection pauses can disrupt gameplay and lead
    to stuttering performance, particularly in real-time applications. By minimizing
    the frequency and duration of garbage collection cycles, developers can ensure
    smoother gameplay experiences. Strategies for reducing garbage collection overhead
    include minimizing the use of dynamic memory allocation, utilizing object pooling,
    and managing references efficiently. Additionally, understanding the impact of
    using `Invoke`, `SendMessage`, and coroutines on garbage collection can help developers
    make informed decisions when implementing these features in their scripts. Let’s
    look at the following example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理解垃圾回收行为对于优化Unity脚本中的内存使用至关重要。垃圾回收暂停可能会干扰游戏玩法并导致性能卡顿，尤其是在实时应用中。通过最小化垃圾回收周期的频率和持续时间，开发者可以确保更平滑的游戏体验。减少垃圾收集开销的策略包括最小化动态内存分配的使用、利用对象池以及有效地管理引用。此外，了解使用`Invoke`、`SendMessage`和协程对垃圾回收的影响，可以帮助开发者在其脚本中实现这些功能时做出明智的决定。让我们看看以下示例：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code shows some examples of functions and their impact on garbage
    collection. Let’s take an in-depth look at them:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了函数及其对垃圾回收的影响的一些示例。让我们深入了解一下：
- en: '`Invoke`: `Invoke` is used here to call `DelayedAction` after a delay of two
    seconds. While easy to use, `Invoke` can generate small amounts of garbage due
    to the internal handling of delayed method calls, especially if used frequently
    in a game loop.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke`: 在这里使用`Invoke`在延迟两秒后调用`DelayedAction`。虽然使用简单，但`Invoke`由于内部处理延迟方法调用，可能会生成少量垃圾，尤其是在游戏循环中频繁使用时。'
- en: '`SendMessage`: `SendMessage` is called when the space bar is pressed to execute
    the `PerformAction` method. `SendMessage` is versatile but inefficient in terms
    of performance and memory usage because it relies on reflection, which can lead
    to additional garbage generation.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendMessage`: 当按下空格键时调用`SendMessage`以执行`PerformAction`方法。`SendMessage`功能多样，但在性能和内存使用方面效率低下，因为它依赖于反射，这可能导致额外的垃圾生成。'
- en: '`Coroutines`: The `WaitAndPerformAction` coroutine is started in `Start()`
    and performs an action after a three-second delay. Coroutines are generally more
    efficient than `Invoke` in terms of garbage generation, but they still create
    a small amount of garbage every time you yield `WaitForSeconds`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`协程`: 在`Start()`方法中启动了`WaitAndPerformAction`协程，该协程在延迟三秒后执行一个动作。在垃圾生成方面，协程通常比`Invoke`方法更高效，但每次调用`WaitForSeconds`时仍然会创建少量垃圾。'
- en: 'Let’s look at some optimization tips for this code block here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个代码块的一些优化技巧：
- en: Avoid using `Invoke` and `SendMessage` where possible or replace them with direct
    method calls or event-driven approaches to reduce overhead and garbage production.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下避免使用`Invoke`和`SendMessage`，或者用直接方法调用或事件驱动方法替换它们，以减少开销和垃圾生成。
- en: '`Update()` method to minimize garbage. For example, replacing `WaitForSeconds`
    with manual delay handling using time comparison in `Update()` can eliminate garbage
    from coroutine delays.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Update()`方法来最小化垃圾。例如，将`WaitForSeconds`替换为在`Update()`中使用时间比较的手动延迟处理，可以消除协程延迟产生的垃圾。
- en: In this section, we’ve explored key strategies for optimizing game scripts in
    Unity, targeting common performance issues to ensure smooth gameplay. From efficient
    loop usage to minimizing object instantiations, understanding garbage collection,
    and managing the impact of `Invoke`, `SendMessage`, and coroutines, we’ve provided
    practical examples illustrating performance improvements achieved through optimization
    techniques.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了优化Unity中游戏脚本的关键策略，针对常见的性能问题以确保流畅的游戏体验。从高效循环使用到最小化对象实例化，理解垃圾回收以及管理`Invoke`、`SendMessage`和协程的影响，我们提供了通过优化技术实现的性能改进的实用示例。
- en: Transitioning to memory management and minimization, we’ll next tackle the importance
    of efficient memory usage in Unity. We’ll discuss strategies such as object pooling,
    optimizing data structures, and the impact of value versus reference types on
    memory usage. Through concise examples, we’ll showcase how these strategies can
    significantly enhance game smoothness and responsiveness.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 转向内存管理和优化，我们将接下来探讨在Unity中高效内存使用的重要性。我们将讨论诸如对象池、优化数据结构和值类型与引用类型对内存使用影响等策略。通过简洁的示例，我们将展示这些策略如何显著提高游戏的流畅性和响应性。
- en: Memory management and minimization
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理和优化
- en: In the realm of Unity game development, efficient memory management is crucial
    for smooth and responsive gameplay. This section explores strategies such as object
    pooling and efficient data structure usage to minimize memory allocations and
    mitigate the impact of garbage collection pauses.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏开发领域，高效的内存管理对于实现流畅和响应的游戏体验至关重要。本节探讨了诸如对象池和高效数据结构使用等策略，以最小化内存分配并减轻垃圾回收暂停的影响。
- en: Implementing object pooling
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现对象池
- en: 'Object pooling, for instance, allows for the reuse of pre-allocated objects,
    enhancing performance. Here is a simplified example of a finite-sized object pool:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对象池允许重用预先分配的对象，从而提高性能。以下是一个有限大小的对象池的简化示例：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code defines an `ObjectPool` class that manages a pool of GameObjects.
    During initialization, it instantiates a specified number of GameObjects and adds
    them to a list of pooled objects. The `GetPooledObject` method retrieves an inactive
    GameObject from the pool, activates it, and returns it for use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个`ObjectPool`类，用于管理一组`GameObject`对象池。在初始化期间，它实例化指定数量的`GameObject`并将它们添加到已池化对象列表中。`GetPooledObject`方法从池中检索一个非活动`GameObject`，激活它，并将其返回以供使用。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unity provides an object pooling feature.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了对象池功能。
- en: Efficiently using data structures
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高效使用数据结构
- en: 'Efficient use of data structures is another key aspect of memory optimization.
    Choosing the right data structure can reduce memory overhead and improve performance.
    For example, using arrays instead of lists can be more memory efficient due to
    their fixed size and absence of dynamic resizing overhead. The following is a
    simple example demonstrating the use of arrays for storing game data:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构的有效使用是内存优化的另一个关键方面。选择合适的数据结构可以减少内存开销并提高性能。例如，使用数组而不是列表可能更节省内存，因为它们具有固定大小且没有动态调整大小的开销。以下是一个简单示例，展示了使用数组存储游戏数据的使用方法：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code initializes an array called `enemyPositions` to store the
    positions of enemies. It then populates the array with `Vector3` positions, incrementing
    the x-coordinate by 2 for each enemy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码初始化了一个名为`enemyPositions`的数组来存储敌人的位置。然后，它使用`Vector3`位置填充数组，并为每个敌人将x坐标增加2。
- en: Understanding the differences between value and reference types
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解值类型和引用类型之间的区别
- en: 'Understanding the differences between value and reference types is crucial
    for effective memory management. Value types, such as integers and floats, are
    stored directly in memory, while reference types, such as objects and arrays,
    are stored as references to memory locations. Using value types instead of reference
    types can reduce memory overhead and improve performance. The following is a simple
    example illustrating the usage of value types:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 理解值类型和引用类型之间的区别对于有效的内存管理至关重要。值类型，如整数和浮点数，直接存储在内存中，而引用类型，如对象和数组，存储为对内存位置的引用。使用值类型而不是引用类型可以减少内存开销并提高性能。以下是一个简单示例，说明了值类型的用法：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code demonstrates the declaration and initialization of variables:
    `score` as an integer with a value of `100`, and `''player''` as a reference to
    a GameObject instantiated from a Prefab.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了变量的声明和初始化：`score`是一个整数值为`100`，`'player'`是一个从Prefab实例化的GameObject的引用。
- en: In conclusion, by implementing strategies such as object pooling, efficient
    data structure usage, and understanding value versus reference types, developers
    can optimize memory usage and minimize garbage collection pauses, thereby enhancing
    game smoothness and responsiveness.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，通过实施对象池、高效的数据结构使用和理解值类型与引用类型之间的区别等策略，开发者可以优化内存使用并最小化垃圾回收暂停，从而提高游戏的流畅性和响应性。
- en: Transitioning to the final section on best practices for script optimization,
    we’ll conclude with a summary of key principles for writing and maintaining optimized
    Unity scripts. These include continuous profiling throughout development, adherence
    to coding standards prioritizing performance, and optimizing scripts with scalability
    in mind for future projects. We’ll highlight the importance of balancing readability,
    maintainability, and performance in optimized code, ensuring that developers can
    create robust and efficient Unity projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 转到关于脚本优化的最佳实践的最后一部分，我们将以总结编写和维护优化Unity脚本的关键原则来结束。这些包括开发过程中的持续性能分析，遵守优先考虑性能的编码标准，以及考虑到未来项目的可扩展性来优化脚本。我们将强调在优化代码中平衡可读性、可维护性和性能的重要性，确保开发者能够创建健壮且高效的Unity项目。
- en: Best practices for script optimization
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本优化的最佳实践
- en: 'As the curtains draw closed on our exploration of script optimization in Unity,
    it’s essential to reflect on the overarching principles that guide the craft of
    writing and maintaining optimized Unity scripts. In this section, we will delve
    into the realm of best practices for script optimization, where we distill key
    insights garnered from our journey thus far. From the imperative of continuous
    profiling throughout development to the adherence to coding standards prioritizing
    performance, we navigate the delicate balance between enhancing game performance
    and ensuring code maintainability. Moreover, we will underscore the invaluable
    lesson of optimizing scripts not merely for the present game but with scalability
    in mind for future projects. Join us as we unravel the intricacies of achieving
    the elusive harmony between readability, maintainability, and performance in the
    realm of optimized code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索Unity脚本优化的旅程即将结束，反思指导编写和维护优化Unity脚本的根本原则至关重要。在本节中，我们将深入研究脚本优化的最佳实践领域，总结迄今为止获得的关键见解。从开发过程中的持续性能分析到遵守优先考虑性能的编码标准，我们将在提高游戏性能和确保代码可维护性之间寻找微妙的平衡。此外，我们将强调优化脚本不仅是为了当前游戏，还要考虑到未来项目的可扩展性这一宝贵教训。加入我们，我们将揭示在优化代码领域实现可读性、可维护性和性能之间难以捉摸的和谐之处的复杂性：
- en: '**Continuous profiling**: Continuous profiling throughout the development cycle
    is paramount for achieving optimized Unity scripts. By regularly analyzing performance
    metrics using Unity’s profiling tools, developers can identify and address performance
    bottlenecks early in the development process, ensuring a smoother and more responsive
    gameplay experience. For example, developers can utilize the Unity Profiler to
    monitor CPU usage, memory allocations, and rendering efficiency, allowing them
    to pinpoint areas of code that require optimization.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续性能分析**：在整个开发周期中进行持续性能分析对于实现优化的Unity脚本至关重要。通过定期使用Unity的性能分析工具分析性能指标，开发者可以在开发早期阶段识别并解决性能瓶颈，确保游戏体验更加流畅和响应。例如，开发者可以利用Unity
    Profiler来监控CPU使用情况、内存分配和渲染效率，从而确定需要优化的代码区域。'
- en: '**Adhering to coding standards**: Adhering to coding standards that prioritize
    performance is another crucial aspect of script optimization. By following established
    coding conventions and best practices, developers can write cleaner, more efficient
    code that is easier to maintain and optimize, significantly improving script performance.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵守编码标准**：遵守优先考虑性能的编码标准是脚本优化的另一个关键方面。通过遵循既定的编码约定和最佳实践，开发者可以编写更干净、更高效的代码，这些代码更容易维护和优化，从而显著提高脚本性能。'
- en: '**Optimizing resource-intensive operations**: Additionally, optimizing resource-intensive
    operations, such as physics calculations or **artificial intelligence** (**AI**)
    pathfinding, can have a substantial impact on overall game performance.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源密集型操作**：此外，优化资源密集型操作，如物理计算或**人工智能**（**AI**）路径查找，对整体游戏性能有显著影响。'
- en: 'Here is an example of optimizing a resource-intensive operation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个优化资源密集型操作的示例：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code showcases an optimization process in a loop iterating over
    a collection of enemies. In the initial inefficient version (before optimization),
    each enemy’s activity status is checked within the loop, potentially leading to
    resource-intensive operations being performed on inactive enemies. In the optimized
    version, inactive enemies are efficiently skipped using a conditional statement
    (`if (!enemy.activeSelf)`), reducing unnecessary computation and improving overall
    performance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了在一个循环中遍历敌人集合的优化过程。在初始的低效版本（优化前），循环中会检查每个敌人的活动状态，这可能导致对非活动敌人执行资源密集型操作。在优化版本中，通过条件语句（`if
    (!enemy.activeSelf)`）高效地跳过非活动敌人，减少了不必要的计算并提高了整体性能。
- en: Furthermore, optimizing scripts, not only for the current game but also with
    scalability in mind for future projects, is essential for long-term success. By
    designing scripts with modularity and extensibility in mind, developers can facilitate
    easier maintenance and updates as the project evolves. For example, creating reusable
    components and scripts that can be easily integrated into future projects can
    save time and effort in the long run. Additionally, documenting code effectively
    and providing clear comments can aid in understanding and modifying scripts in
    the future. Striking a balance between readability, maintainability, and performance
    is crucial in optimized code, ensuring that scripts remain comprehensible and
    adaptable while still delivering optimal performance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，优化脚本，不仅针对当前游戏，还要考虑未来项目的可扩展性，对于长期成功至关重要。通过考虑模块化和可扩展性来设计脚本，开发者可以简化项目的维护和更新。例如，创建可重用组件和脚本，这些组件和脚本可以轻松集成到未来的项目中，从而在长期节省时间和精力。此外，有效地记录代码并提供清晰的注释有助于未来理解和修改脚本。在优化代码中，在可读性、可维护性和性能之间取得平衡至关重要，确保脚本保持可理解性和适应性，同时仍然提供最佳性能。
- en: Achieving optimized Unity scripts requires a holistic approach encompassing
    continuous profiling, adherence to coding standards, and consideration for scalability.
    By integrating these practices and ensuring scripts are readable, maintainable,
    and performant, developers create robust projects that deliver seamless gameplay.
    Continuous profiling identifies and rectifies bottlenecks while coding standards
    prioritize efficiency. Optimizing for scalability ensures success in future projects.
    This balance ensures each line serves both the current and future games. By embracing
    these practices, developers craft responsive experiences that captivate players
    and endure over time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实现优化的Unity脚本需要一种全面的方法，包括持续的性能分析、遵守编码标准和考虑可扩展性。通过整合这些实践并确保脚本可读、可维护和高效，开发者可以创建出稳健的项目，提供无缝的游戏体验。持续的性能分析可以识别并纠正瓶颈，而编码标准则优先考虑效率。针对可扩展性进行优化确保了未来项目的成功。这种平衡确保每一行代码都服务于当前和未来的游戏。通过采纳这些实践，开发者能够创造出吸引玩家并持久存在的互动体验。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude our exploration, it’s crucial to summarize the best practices
    for writing and maintaining optimized Unity scripts. Continuous profiling is key,
    enabling developers to identify and rectify performance bottlenecks iteratively.
    Adhering to performance-oriented coding standards and optimizing scripts with
    scalability in mind ensures long-term success. Achieving an effective combination
    of readability, maintainability, and performance is key to efficient development
    practices and delivering a seamless gameplay experience across Unity projects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对编写和维护优化Unity脚本的最佳实践的探索时，总结这些实践至关重要。持续的性能分析是关键，它使开发者能够迭代地识别和纠正性能瓶颈。遵守以性能为导向的编码标准，并考虑可扩展性来优化脚本，确保了长期的成功。实现可读性、可维护性和性能的有效结合是高效开发实践和在整个Unity项目中提供无缝游戏体验的关键。
- en: Transitioning from the exploration of script optimization techniques, we now
    venture into the captivating realm of AI in Unity. The next chapter serves as
    a gateway to understanding AI’s fundamental principles in the context of game
    development, exploring pathfinding algorithms and AI logic for decision-making
    processes. By delving into the intricacies of implementing AI in Unity, we unlock
    the potential to create intelligent character movements, dynamic NPC reactions,
    and immersive gameplay scenarios.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本优化技术的探索过渡，我们现在进入了一个引人入胜的领域——Unity中的AI。下一章将作为理解游戏开发背景下AI基本原理的入门，探讨路径查找算法和AI逻辑在决策过程中的应用。通过深入研究在Unity中实现AI的复杂性，我们解锁了创建智能角色动作、动态NPC反应和沉浸式游戏场景的潜力。
