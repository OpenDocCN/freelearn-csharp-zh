- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello Blazor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for picking up your copy of *Web Development with Blazor*. This book
    intends to get you started as quickly and smoothly as possible, chapter by chapter,
    without you having to read this book from cover to cover before getting your Blazor
    on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This book will start by guiding you through the most common scenarios you’ll
    come across when you begin your journey with Blazor and will also dive into a
    few more advanced scenarios later on. This book aims to show you what Blazor is
    – Blazor Server, Blazor WebAssembly, Blazor Hybrid, and on top of that, the new
    **Server-Side Rendering** (**SSR**) – and how it all works practically to help
    you avoid traps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This is the book’s third edition; much has happened since the first edition.
    .NET 6 and .NET 7 were released, and for the second edition, I updated the content
    to reflect the changes and the new functionality we got.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This edition has been updated to include all the new things in .NET 8, and let
    me tell you, that is a lot.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: I do Blazor presentations all over the world, and there are common questions
    that I get asked a lot. Without going into too much detail, they are often related
    to download size or time when it comes to Blazor WebAssembly and continuous connection
    to Blazor Server. In .NET 8, we can leverage a new mode, SSR, that solves all
    of these problems in one swift blow. Okay, maybe not all problems, but we are
    well on our way to solving them. A common belief is that Blazor is WebAssembly,
    but WebAssembly is just one way of running Blazor. Many books, workshops, and
    blog posts on Blazor focus heavily on WebAssembly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This book will cover Blazor WebAssembly, Blazor Server, Blazor Hybrid, and SSR.
    There are a few differences between the different ways of running Blazor; I will
    point them out as we go along.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This first chapter will explore where Blazor came from, what technologies made
    Blazor possible, and the different ways of running Blazor. We will also touch
    on which type (Blazor WebAssembly, Blazor Server, or Blazor Hybrid) is best for
    you.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Why Blazor?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preceding Blazor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing WebAssembly
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing .NET 8
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Blazor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that you have some knowledge of .NET before you start, as
    this book is aimed at .NET developers who want to utilize their skills to make
    interactive web applications. However, it’s more than possible that you will pick
    up a few .NET tricks if you are new to the world of .NET.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Why Blazor?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not that long ago, I got asked by a random person on Facebook if I work with
    Blazor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: I said, “Yes, yes I do”.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: He then continued with a long remark telling me Blazor would never beat Angular,
    React, or Vue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: I see these kinds of remarks quite often, and it’s essential to understand that
    beating other **Single-Page Application** (**SPA**) frameworks has never been
    the goal. This is not *Highlander*, and there can be more than one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Learning web development has previously been pretty tough. Not only do we need
    to know ASP.NET for the server but we also need to learn an SPA framework like
    React, Angular, or Vue.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: But it doesn’t end there. We also need to learn npm, Bower, and Parcel, as well
    as JavaScript or TypeScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We need to understand transpiling and build that into our development pipeline.
    This is, of course, just the tip of the iceberg; depending on the technology,
    we need to explore other rabbit holes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is an excellent choice for .NET developers to write interactive web applications
    without needing to learn (or keep up with) everything we just mentioned. We can
    leverage our existing C# knowledge and the packages we use and share code between
    the server and client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: I usually say, “Blazor removes all the things I hate about web development.”
    I guess the saying should be, “Blazor *can* remove all the things I hate about
    web development.” With Blazor, it is still possible to do JavaScript interop and
    use JavaScript frameworks or other SPA frameworks from within Blazor, but we don’t
    have to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Blazor has opened a door where I can feel productive and confident I am creating
    a great user experience for my users, with my existing C# knowledge.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Preceding Blazor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably didn’t get this book to read about **JavaScript**, but it helps
    to remember that we came from a pre-Blazor time. I recall that time – the dark
    times. Many of the concepts used in Blazor are not that far from those used in
    many JavaScript frameworks, so I will start with a brief overview of where we
    came from.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'As developers, we have many different platforms we can develop for, including
    desktop, mobile, games, the cloud (or server side), AI, and even IoT. All these
    platforms have a lot of different languages to choose from, but there is, of course,
    one more platform: the apps that run inside the browser.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: I have been a web developer for a long time, and I’ve seen code move from the
    server to run within the browser. It has changed the way we develop our apps.
    Frameworks such as Angular, React, Aurelia, and Vue have changed the web from
    reloading the whole page to updating small parts on the fly. This *new* on-the-fly
    update method has enabled pages to load quicker, as the perceived load time has
    been lowered (not necessarily the whole page load).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: But for many developers, this is an entirely new skill set – that is, switching
    between a server (most likely C#, if you are reading this book) to a frontend
    developed in JavaScript. Data objects are written in C# in the backend and then
    serialized into JSON, sent via an API, and then deserialized into another object
    written in JavaScript in the frontend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript used to work differently in different browsers, which jQuery tried
    to solve by having a common API that was translated into something the web browser
    could understand. Now, the differences between different web browsers are much
    more minor, which has rendered jQuery obsolete in many cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript differs slightly from other languages since it is not object-oriented
    or typed, for example. In 2010, Anders Hejlsberg (known for being C#, Delphi,
    and Turbo Pascal’s original language designer) started working on **TypeScript**.
    This object-oriented language can be compiled/transpiled into JavaScript.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You can use Typescript with Angular, React, Aurelia, and Vue, but in the end,
    it is JavaScript that will run the actual code. Simply put, to create interactive
    web applications today using JavaScript/TypeScript, you need to switch between
    languages and choose and keep up with different frameworks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will look at this in another way. Even though we will talk
    about JavaScript, our primary focus will be on developing interactive web applications
    mainly using C#.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know a bit about the history of JavaScript. JavaScript is no longer
    the only language that can run within a browser, thanks to WebAssembly, which
    we will cover in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WebAssembly
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how **WebAssembly** works. One way of running
    Blazor is by using WebAssembly, but for now, let’s focus on what WebAssembly is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is a binary instruction format that is compiled and, therefore,
    smaller. It is designed for native speeds, which means that when it comes to speed,
    it is closer to C++ than it is to JavaScript. When loading JavaScript, the JavaScript
    files (or inline JavaScript) are downloaded, parsed, optimized, and JIT-compiled;
    most of those steps are not needed for WebAssembly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly has a very strict security model that protects users from buggy
    or malicious code. It runs within a sandbox and cannot escape that sandbox without
    going through the appropriate APIs. Suppose you want to communicate outside WebAssembly,
    for example, by changing the **Document Object Model** (**DOM**) or downloading
    a file from the web. In that case, you will need to do that with JavaScript interop
    (more on that later; don’t worry – Blazor will solve this for us).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some code to get a bit more familiar with WebAssembly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create an app that sums two numbers and returns the
    result, written in C (to be honest, this is about the level of C I’m comfortable
    with).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compile C into WebAssembly but it requires the installation of some
    tooling so we will not do this all the way. The point here is just to give us
    a feeling of how WebAssembly works under the hood. Consider this code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The result of this will be the number `3`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is a stack machine language, which means that it uses a stack to
    perform its operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most compilers will optimize the code and return `3`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s assume that all the instructions should be executed. This is the
    way WebAssembly would do things:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'It will start by pushing `1` onto the stack (`instruction: i32.const 1`), followed
    by pushing `2` onto the stack (`instruction: i32.const 2`). At this point, the
    stack contains `1` and `2`.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we must execute the add instruction (`i32.add`), which will pop (`get`)
    the two top values (`1` and `2`) from the stack, add them up, and push the new
    value onto the stack (`3`).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This demo shows that we can build WebAssembly from C code. Even though we never
    need to go to this level to understand WebAssembly (Blazor handles all of that
    for us), we will use C code and other libraries compiled into WebAssembly later
    in the book (*Chapter 16*, *Going Deeper into WebAssembly*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: OTHER LANGUAGES
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, it is only low-level languages that can be compiled into WebAssembly
    (such as C or Rust). However, there are a plethora of languages that can run on
    top of WebAssembly. Here is a great collection of some of these languages: [https://github.com/appcypher/awesome-wasm-langs](https://github.com/appcypher/awesome-wasm-langs).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is super performant (near-native speeds) – so performant that game
    engines have already adopted this technology for that very reason. Unity, as well
    as Unreal Engine, can be compiled into WebAssembly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of examples of games running on top of WebAssembly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Angry Bots (Unity)**: [https://beta.unity3d.com/jonas/AngryBots/](https://beta.unity3d.com/jonas/AngryBots/)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doom**: [https://wasm.continuation-labs.com/d3demo/](https://wasm.continuation-labs.com/d3demo/)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a great list of different WebAssembly projects: [https://github.com/mbasso/awesome-wasm](https://github.com/mbasso/awesome-wasm).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This section touched the surface of how WebAssembly works; in most cases, you
    won’t need to know much more. We will dive into how Blazor uses this technology
    later in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: To write Blazor apps, we can leverage the power of .NET 8, which we’ll look
    at next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Introducing .NET 8
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET is a platform developed by Microsoft for building different types of applications,
    including web, mobile, and desktop applications. The .NET team has been working
    hard on tightening everything up for us developers for years. They have been making
    everything simpler, smaller, cross-platform, and open source – not to mention
    easier to utilize your existing knowledge of .NET development.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core was a step toward a more unified .NET. It allowed Microsoft to re-envision
    the whole .NET platform, build it in a completely new way, and make it run on
    even more platforms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'There were three different types of .NET runtimes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework (full .NET)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono/Xamarin
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different runtimes had different capabilities and performances. This also meant
    that creating a .NET Core app (for example) had different tooling and frameworks
    that needed to be installed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: .NET 5 was the start of our journey toward one single .NET. With this unified
    toolchain, the experience of creating, running, and so on became the same across
    all the different project types. “Framework” and “Core” were dropped from the
    name. .NET 5 is still modular in a similar way to what we are used to, so we do
    not have to worry that merging all the different .NET versions is going to result
    in a bloated .NET.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the .NET platform, you will be able to reach all the platforms we
    talked about at the beginning of this chapter (web, desktop, mobile, games, the
    cloud (or server side), AI, and even IoT) using only C# and with the same tooling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Blazor has been around for a while now. In .NET Core 3, the first version of
    Blazor Server was released, and at Microsoft Build in 2020, Microsoft released
    Blazor WebAssembly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 5, we got a lot of new components for Blazor – pre-rendering and CSS
    isolation to name a couple of things. Don’t worry; we will go through all these
    things throughout the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 6, we got even more functionality, like Hot Reload, co-located JavaScript,
    new components, and much more, all of which we will explore throughout the book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 7, we got even more enhancements for Blazor developers. We got performance
    improvements and get/set/after modifiers, among other things.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In November 2023, Microsoft released .NET 8, and with that, everything changed.
    During development, this new way of developing Blazor apps was called “Blazor
    United,” which is a name they now have updated to simply Blazor. This is the new
    way of creating Blazor applications and it is an awesome way. But let’s save something
    for later chapters as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: .NET 8 brought us performance improvements, native Define, better source generators,
    and so much more. It is also an LTS (Long-Term Support) version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the enhancements and number of features, I can only conclude that
    Microsoft believes in Blazor, and so do I.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know about some of the surrounding technologies, in the next section,
    it’s time to introduce the main character of this book: Blazor.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Blazor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Blazor** is an open-source web UI framework. That’s a lot of buzzwords in
    the same sentence, but simply put, it means that you can create interactive web
    applications using HTML, CSS, and C# with full support for bindings, events, forms
    and validation, dependency injection, debugging, and much more, with Blazor. We
    will take a look at these in this book.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, Steve Sanderson (well-known for creating the Knockout JavaScript framework
    and who works for the ASP.NET team at Microsoft) was about to do a session called
    *Web Apps can’t really do *that*, can they?* at the developer conference NDC Oslo.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: But Steve wanted to show a cool demo, so he thought, *Would it be possible to
    run C# in WebAssembly?* He found an old inactive project on GitHub called *Dot
    Net Anywhere*, which was written in C and used tools (similar to what we just
    did) to compile the C code into WebAssembly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: He got a simple console app running in the browser. This would have been a fantastic
    demo for most people, but Steve wanted to take it further. He thought, *Is it
    possible to create a simple web framework on top of this?*, and went on to see
    if he could also get the tooling working.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: When it was time for his session, he had a working sample to create a new project,
    create a to-do list with great tooling support, and run the project in the browser.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Damian Edwards (the .NET team) and David Fowler (the .NET team) were also at
    the NDC conference. Steve showed them what he was about to demo, and they described
    the event as their heads exploded and their jaws dropped.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: And that’s how the prototype of Blazor came into existence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The name Blazor comes from a combination of **Browser** and **Razor** (which
    is the technology used to combine code and HTML). Adding an *L* made the name
    sound better, but other than that, it has no real meaning or acronym.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different flavors of Blazor, including Blazor Server, Blazor
    WebAssembly, Blazor Hybrid (using .NET MAUI), and Server-Side Rendering.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The different versions have some pros and cons, all of which I will cover in
    the upcoming sections and chapters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blazor Server uses SignalR to communicate between the client and the server,
    as shown in the following diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21849_01_01.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Overview of Blazor Server'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**SignalR** is an open-source, real-time communication library that will create
    a connection between the client and the server. SignalR can use many different
    means of transporting data and automatically selects the best transport protocol
    based on your server and client capabilities. SignalR will always try to use WebSockets,
    which is a transport protocol built into HTML5\. If WebSockets is not enabled,
    it will gracefully fall back to another protocol.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is built with reusable UI elements called **components** (more on components
    in *Chapter 4*, *Understanding Basic Blazor Components*). Each component contains
    C# code and markup. A component can include other components. You can use Razor
    syntax to mix markup and C# code or do everything in C# if you wish. The components
    can be updated by user interaction (pressing a button) or triggers (such as a
    timer).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The components are rendered into a render tree, a binary representation of the
    DOM containing object states and any properties or values. The render tree will
    keep track of any changes compared to the previous render tree, and then send
    only the things that changed over SignalR using a binary format to update the
    DOM.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript will receive the changes on the client side and update the page accordingly.
    If we compare this to traditional ASP.NET, we only render the component itself,
    not the entire page, and we only send over the actual changes to the DOM, not
    the whole page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'There are advantages to Blazor Server:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: It contains just enough code to establish that the connection is downloaded
    to the client, so the site has a small footprint, which makes the site startup
    really fast.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since everything is rendered on the server, Blazor Server is more SEO-friendly.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are running on the server, the app can fully utilize the server’s capabilities.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The site will work on older web browsers that don’t support WebAssembly.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code runs on the server and stays on the server; there is no way to decompile
    the code.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the code is executed on your server (or in the cloud), you can make direct
    calls to services and databases within your organization.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, of course, some disadvantages to Blazor Server as well:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: You need to always be connected to the server since the rendering is done on
    the server. If you have a bad internet connection, the site might not work. The
    big difference compared to a non-Blazor Server site is that a non-Blazor Server
    site can deliver a page and then disconnect until it requests another page. With
    Blazor, that connection (SignalR) must always be connected (minor disconnections
    are okay).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no offline/**PWA** (**Progressive Web App**) mode since it needs to
    be connected.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every click or page update must do a round trip to the server, which might result
    in higher latency. It is important to remember that Blazor Server will only send
    the changed data. I have not experienced any slow response times personally.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we have to have a connection to the server, the load on that server increases
    and makes scaling difficult. To solve this problem, you can use the Azure SignalR
    hub to handle the constant connections and let your server concentrate on delivering
    content.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each connection stores the information in the server’s memory, increasing memory
    use and making load balancing more difficult.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to run Blazor Server, you have to host it on an ASP.NET Core-enabled
    server.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At my workplace, we already had a large site, so we decided to use Blazor Server
    for our projects. We had a customer portal and an internal CRM tool, and our approach
    was to take one component at a time and convert it into a Blazor component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We quickly realized that, in most cases, it was faster to remake the component
    in Blazor rather than continue to use ASP.NET MVC and add functionality. The **User
    Experience** (**UX**) for the end-user became even better as we converted.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The pages loaded faster. We could reload parts of the page as we needed instead
    of the whole page, and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We found that Blazor introduced a new problem: the pages became *too* fast.
    Our users didn’t understand whether data had been saved because *nothing happened*;
    things *did* happen, but too fast for the users to notice. Suddenly, we had to
    think more about UX and how to inform the user that something had changed. This
    is, of course, a very positive side effect of Blazor.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server is not the only way to run Blazor – you can also run it on the
    client (in the web browser) using WebAssembly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another option: instead of running Blazor on a server, you can run
    it inside your web browser using WebAssembly.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The Mono runtime is a tool that lets you run programs made with C# and other
    .NET languages on various operating systems, not just Windows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has taken the Mono runtime (which is written in C) and compiled that
    into WebAssembly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The WebAssembly version of Blazor works very similarly to the server version,
    as shown in the following diagram. We have moved everything off the server, and
    it is now running within our web browser:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21849_01_02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Overview of Blazor WebAssembly'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: A render tree is still created, and instead of running the Razor pages on the
    server, they are now running inside our web browser. Instead of SignalR, since
    WebAssembly doesn’t have direct DOM access, Blazor updates the DOM with direct
    JavaScript interop.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The Mono runtime that’s compiled into WebAssembly is called **dotnet.wasm**.
    The page contains a small piece of JavaScript that will make sure to load `dotnet.wasm`.
    Then, it will download `blazor.boot.json`, a JSON file containing all the files
    the application needs to run, as well as the application’s entry point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the default sample site that is created when we start a new Blazor
    project in Visual Studio, the `Blazor.boot.json` file contains 63 dependencies
    that need to be downloaded. All the dependencies get downloaded and the app boots
    up.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, `dotnet.wasm` is the mono runtime that’s compiled
    into WebAssembly. It runs .NET DLLs – the ones you have written and the ones from
    .NET Framework (which is needed to run your app) – in your browser.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When I first heard of this, I got a bit of a bad taste. It’s running the whole
    .NET runtime in my browser?! But then, after a while, I realized how amazing that
    is. You can run any .NET Standard DLLs in your web browser.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at exactly what happens and in what order
    code gets executed when a WebAssembly app boots up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, of course, some advantages of Blazor WebAssembly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Since the code runs in the browser, creating a **PWA** is easy.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not require a connection to the server. Blazor WebAssembly will work
    offline.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we’re not running anything on the server, we can use any backend server
    or file share (no need for a .NET-compatible server in the backend).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No round trips mean that you can update the screen faster (that is why there
    are game engines that use WebAssembly).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some disadvantages to Blazor WebAssembly as well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Even if we compare it to other large sites, the footprint of Blazor WebAssembly
    is large and there are a large number of files to download.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access any on-site resources, you will need to create a Web API to access
    them. You cannot access the database directly.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code runs in the browser, meaning it can be decompiled. All app developers
    are used to this, but it is perhaps not as common for web developers.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I wanted to put WebAssembly to the test! When I was seven years old, I got
    my first computer, a Sinclair ZX Spectrum. I remember that I sat down and wrote
    the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That was *my* code; I made the computer write my name on the screen over and
    over!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: That was when I decided that I wanted to become a developer to make computers
    do stuff.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: After becoming a developer, I wanted to revisit my childhood and decided I wanted
    to build a ZX Spectrum emulator. In many ways, the emulator has become my test
    project instead of a simple *Hello World* when I encounter new technology. I’ve
    had it running on a Gadgeteer, Xbox One, and even a HoloLens (to name a few platforms/devices).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: But is it possible to run my emulator in Blazor?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'It took me only a couple of hours to get the emulator working with Blazor WebAssembly
    by leveraging my already built .NET Standard DLL; I only had to write the code
    specific to this implementation, such as the keyboard and graphics. This is one
    of the reasons Blazor (both Server and WebAssembly) is so powerful: it can run
    libraries that have already been made. Not only can you leverage your knowledge
    of C# but you can also take advantage of the large ecosystem and .NET community.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the emulator here: [http://zxbox.com](http://zxbox.com). This
    is one of my favorite projects to work on, as I keep finding ways to optimize
    and improve the emulator.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Building interactive web applications used to only be possible with JavaScript.
    Now, we know we can use Blazor WebAssembly and Blazor Server, but which one of
    these new options is the best?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly versus Blazor Server
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which one should we choose? The answer is, as always, it depends. You have seen
    the advantages and disadvantages of both.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If you have a current site that you want to port over to Blazor, I recommend
    going for the server side; once you have ported it, you can make a new decision
    as to whether you want to go for WebAssembly as well. This way, it is easy to
    port parts of the site, and the debugging experience is better with Blazor Server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Suppose your site runs on a mobile browser or another unreliable internet connection.
    In that case, you might consider going for an offline-capable (PWA) scenario with
    Blazor WebAssembly since Blazor Server needs a constant connection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The startup time for WebAssembly is a bit slow, but there are ways to combine
    the two hosting models to have the best of both worlds. We will cover this in
    *Chapter 16*, *Going Deeper into WebAssembly*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: There is no silver bullet when it comes to this question, but read up on the
    advantages and disadvantages and see how they affect your project and use cases.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 8, we have more opportunities to mix and match the different technologies,
    so the question becomes less relevant since we can choose to have one specific
    component running Blazor Server and another running Blazor WebAssembly (more on
    that later in this chapter).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We can run Blazor server-side and on the client, but what about desktop and
    mobile apps?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Hybrid/.NET MAUI
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET MAUI is a cross-platform application framework. The name comes from **.NET
    Multi-platform App UI** and is the next version of Xamarin. We can use traditional
    XAML code to create our cross-platform application just as with Xamarin. However,
    .NET MAUI also targets desktop operating systems that will enable running our
    Blazor app on Windows and even macOS.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI has its own template that enables us to run Blazor inside of a .NET
    MAUI application using a Blazor WebView. This is called Blazor Hybrid. Blazor
    Hybrid works in a similar way to the other hosting models (Blazor Server and Blazor
    WebAssembly). It has a render tree and updates the Blazor WebView, which is a
    browser component in .NET MAUI. This is a bit oversimplified perhaps but we have
    a whole chapter on Blazor Hybrid (*Chapter 18*, *Visiting .NET MAUI*). Using Blazor
    Hybrid, we also get access to native APIs (not only Web APIs), making it possible
    to take our application to another level.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at .NET MAUI in *Chapter 18*, *Visiting .NET MAUI*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we don’t need interactive components, we just need to render some
    content and be done. In .NET 8, we have a new way of doing that.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side Rendering (SSR)
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Server-side rendering is the new kid on the Blazor block. It makes it possible
    to use the Razor syntax to build web pages that are rendered server-side just
    like MVC or Razor Pages. This is called Static Server-side Rendering. It has some
    additional features that will keep scrolling in the previous position even though
    the whole page is reloaded, which is called enhanced form navigation. This will
    only render static pages, with no interactivity (with a few exceptions). There
    is also something called streaming rendering that will load the page even faster.
    This mode is called streaming server-side rendering. During long-running tasks,
    streaming rendering will first send the HTML it has and then update the DOM once
    the long-running task is complete, giving it a more interactive feeling.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes we want interactivity, and choosing between Blazor Server or Blazor
    WebAssembly can be a bit hard. But what if I told you we don’t have to choose
    anymore? We can mix it up.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The feature formerly known as Blazor United
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This next feature was called “Blazor United” when Microsoft first spoke of it
    but is now simply part of Blazor, not an extra feature. I still want to mention
    the name because the community still uses it, and chances are you might have heard
    it and are wondering why I am not mentioning it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a really cool feature: we can pick and choose what components will run
    using SSR and what components will use Blazor Server, Blazor WebAssembly, or (hope
    you are sitting down for this) a mix of the two. Previously, we had to choose
    one of the two (Blazor Server or Blazor WebAssembly), but now we can combine the
    technologies to get the best of both worlds. We can now tell each component how
    we want it to render and we can mix and match throughout the site. The new “auto”
    feature means the first time our users visit the site, they will run Blazor Server.
    This is to get a quick connection and get data to the user as quickly as possible.
    In the background, the WebAssembly version is downloaded and cached so the next
    time they visit the site, it will use the cached Blazor WebAssembly version. If
    the WebAssembly version can be downloaded and started within 100 milliseconds,
    it will load only the WebAssembly version. If it takes longer, it will start up
    Blazor Server and download in the background. This is one of the ways we can speed
    up the download speed of our Blazor site. We can combine all of these technologies,
    pre-render the content on the server using Static Server-side Rendering, make
    the site interactive using Blazor Server (using SignalR), and then switch over
    to Blazor WebAssembly without the “long” download time.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how Blazor was created and its underlying technologies,
    such as SignalR and WebAssembly. You also learned about the render tree and how
    the DOM gets updated to give you an understanding of how Blazor works under the
    hood.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We got an overview of the different technologies you can use with Blazor, such
    as server-side (Blazor Server), client-side (WebAssembly), desktop, and mobile
    (Blazor Hybrid). This overview should have helped you decide what technology to
    choose for your next project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We talked about why Blazor is a good choice for .NET developers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We looked at SSR and (according to me) the most exciting feature in .NET 8 for
    Blazor, what was known as Blazor United.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, I will walk you through various scenarios to equip
    you with the knowledge to handle everything from upgrading an old/existing site
    and creating a new server-side site to creating a new WebAssembly site.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll get our hands dirty by configuring our development
    environment and creating and examining our first Blazor app.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a .NET developer, you might be interested in Uno Platform ([https://platform.uno/](https://platform.uno/)),
    which makes it possible to create a UI in XAML and deploy it to many different
    platforms, including WebAssembly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see how the ZX Spectrum emulator is built, you can download
    the source code here: [https://github.com/EngstromJimmy/ZXSpectrum](https://github.com/EngstromJimmy/ZXSpectrum).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解 ZX Spectrum 模拟器的构建过程，可以在此处下载源代码：[https://github.com/EngstromJimmy/ZXSpectrum](https://github.com/EngstromJimmy/ZXSpectrum).
- en: Join our community on Discord
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
- en: '![](img/QR_Code2668029180838459906.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2668029180838459906.png)'
