- en: '*Chapter 4*: Creating Animations with the Unity Animation System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether for 2D games or 3D games, if you want a game to be lively and interesting,
    good animation is essential. As a very popular game engine, Unity provides easy-to-use
    and powerful animation development tools. In this chapter, we will explore the
    animation system in Unity, sometimes referred to as **Mecanim**, to make Scenes
    and characters in your game not static, but dynamic. Then, we will demonstrate
    how to implement 3D and 2D animation in Unity with two examples. Finally, we'll
    cover how to improve the performance of the animation system in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Unity animation system's concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing 3D animation in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing 2D animation in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the performance of Unity's animation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create 3D and 2D animations
    in Unity, as well as knowing how to control animations through C# code and how
    to optimize animation performance.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting, I recommend you first download **Unity-Chan! Model** from
    Unity Asset Store: [https://assetstore.unity.com/packages/3d/characters/unity-chan-model-18705](https://assetstore.unity.com/packages/3d/characters/unity-chan-model-18705).'
  prefs: []
  type: TYPE_NORMAL
- en: This cute 3D girl model asset is produced by Unity Technologies Japan, and it's
    available for all developers to download and make games with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following content is included in this asset:'
  prefs: []
  type: TYPE_NORMAL
- en: 3D models with beautiful textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Unity-Chan!" original shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31 animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31 still poses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 emotions made from blend shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample locomotion scene and other sample Scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Unity animation system's concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animation is an important aspect of game development. In this section, we will
    first learn the basic concepts of the Unity animation system. Specifically, we
    will introduce the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: What Animation Clips are and how to create an Animation Clip in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an Animator Controller to manage a set of animations for characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Avatar system to work with animation rigging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the Animator component is and how to use it to assign animation to a GameObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move on!
  prefs: []
  type: TYPE_NORMAL
- en: Animation Clips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animation in Unity can range from simple cube rotation to complex character
    movement and actions, and they are all based on **Animation Clips**, which are
    used to store keyframe-based animations in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We can manually create an Animation Clip file in the Unity Editor to implement
    some simple traditional keyframe animation effects via the **Animation** window,
    such as simple movement, rotation, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show how to animate a GameObject in a Scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window (on the right-hand side) and select
    **3D Object | Cube** from the pop-up menu to create a new **Cube** object in the
    Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.01_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Create a new Cube object in the Scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Cube** object in the Scene view. Then navigate to **Window | Animation
    | Animation** to open the **Animation** window. In addition to opening this window
    from the menu, we can also use the *Ctrl + 6* shortcut to open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.02_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Open the Animation window
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Create** button in the **Animation** window to create a new
    Animation Clip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.03_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The Animation window
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Add Property** button to display a list of available properties
    that can be animated. As shown in *Figure 4.4*, we can not only modify **Position**
    and **Rotation** but also modify the properties of other components. Here we can
    add **Scale** as the property that will be animated by clicking the **+** button
    next to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.04_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Add Property
  prefs: []
  type: TYPE_NORMAL
- en: 'When a property is added, two keyframes are created by default: the first keyframe
    and the second keyframe are at *0:00* and *1:00* on the timeline respectively.
    So, we need to create a third keyframe to change the `0.5`, as shown in *Figure
    4.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.05_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Add keyframes
  prefs: []
  type: TYPE_NORMAL
- en: In order to preview the animation, click on the **Play** button to play the
    Animation Clip. You will see that the volume of the Cube shrinks rapidly and then
    slowly enlarges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.06_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Play the Animation Clip
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use **recording mode** to create an Animation Clip in Unity, as
    demonstrated in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to create a new GameObject and open the **Animation** window are
    the same as before. So, let''s start directly with how to use recording mode to
    create an Animation Clip for a Sphere object in the Scene. We can click the record
    button to enable keyframe recording mode, as shown in *Figure 4.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.07_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Enable keyframe recording mode
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the record button, it will enter recording mode. Now, we can
    modify the point in time that we want it to be at by dragging on the timeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.08_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Drag on the timeline
  prefs: []
  type: TYPE_NORMAL
- en: 'In recording mode, whether you move, rotate, or scale the target GameObject
    in the Scene, Unity will automatically add the keyframe of the current time point
    to the Animation Clip. Here we can move the GameObject from its original position
    (0, 0, 0) to a new position, let''s say, (1, 0, 0). And you can see in the following
    figure that Unity created keyframes for the Sphere object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.09_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Unity creates keyframes
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, click on the record button again to exit recording mode and click
    the **Play** button to play the Animation Clip we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.10_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Play the Animation Clip
  prefs: []
  type: TYPE_NORMAL
- en: In addition, importing external animation assets into the Unity Editor can also
    automatically create Animation Clip files.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.11_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Animation Clips created automatically after importing animation
    assets
  prefs: []
  type: TYPE_NORMAL
- en: Animation files such as generic **FBX** files, **Autodesk® 3ds Max® (.max)**
    files, native **Autodesk® Maya® (.mb or .ma)** files, and **Blender™ (.blend)**
    files need to be imported into our Unity project first before they can be used
    by Unity. After animation files are imported, Unity will generate Animation Clip
    files. We can open the **Animation** window to view an Animation Clip by double-clicking
    the Animation Clip file in the Unity Editor, as shown in *Figure 4.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand what an Animation Clip is and how to create a new one
    in Unity, let''s move on to the next concept: the Animator Controller.'
  prefs: []
  type: TYPE_NORMAL
- en: Animator Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that our game character has multiple animations. For example, say a
    character can both run and attack – it is very important to manage both of these
    animations for the character. In a Unity project, we use the **Animator Controller**
    asset to arrange and maintain a set of animations for characters or other animated
    GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: An **Animator Controller** will reference the Animation Clips it uses and use
    a so-called **state machine** to manage various animation states and transitions
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: We can import the **Unity-Chan! Model** asset that we downloaded earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.12_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Unity-Chan! Model ActionCheck Scene
  prefs: []
  type: TYPE_NORMAL
- en: This asset provides multiple demo Scenes; we chose to open the `Assets/unity-chan!/Unity-chan!
    Model/Scenes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.13_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Unity-Chan! Model
  prefs: []
  type: TYPE_NORMAL
- en: As *Figure 4.13* shows, the Unity-Chan! model has been set up in the Scene.
    If we open the Animator Controller file used by this model, we can see all the
    Animation Clips used by this model and the transitions between Animation Clips
    in the state machine displayed in the **Animator** window, as shown in *Figure
    4.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.14_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Animator Controller
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also follow these steps to manually create an **Animator Controller**
    asset in the Unity Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Project** view and right-click to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Create | Animator Controller** to create a new **Animator Controller**
    asset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.15_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Create a new Animator Controller
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the **Animator Controller** asset we just created to open the **Animator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, drag the **POSE01** Animation Clip into the **Animator** window directly
    to create a new state. In the state machine, a state is represented by a box because
    the **POSE01** Animation Clip is the first animation we dragged, so we can see
    this animation is connected to the entry point of the Animator Controller, indicating
    that this animation will be the default animation.![](img/Figure_4.16_B17146.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.16 – Create a new state
  prefs: []
  type: TYPE_NORMAL
- en: Create the second state by dragging the **POSE02** Animation Clip into the **Animator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **POSE01** state and right-click to open a menu, then select **Make
    Transition** to make a transition between **POSE01** and **POSE02**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.17_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Make Transition
  prefs: []
  type: TYPE_NORMAL
- en: Now, we've created an Animator Controller asset and added some Animation Clips
    to the state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Avatar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the animation we created for Unity's built-in Cube model earlier, the
    model imported from the external tools into the Unity Editor may be more complicated.
    For example, the Unity-Chan! model is a human-like model. A model in Unity is
    represented by a mesh of **triangles**, and a triangle is composed of **vertices**.
    When the model is animated, the position of the vertices will be modified. Obviously,
    when many vertices make up a model, moving each vertex individually is an inefficient
    operation. Therefore, a common technique in computer animation is not to move
    each triangle individually during the animation but to skin the model before it
    is animated. This technique is called **skeletal animation** or **rigging.**
  prefs: []
  type: TYPE_NORMAL
- en: Unity uses a system called **Avatar** to identify whether the animation model
    is a humanoid layout and which parts of the model correspond to the head, body,
    arms, legs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.18_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Import Settings
  prefs: []
  type: TYPE_NORMAL
- en: We can open the **Import Settings** window for Unity-Chan! by clicking the model
    in the Unity Editor. As *Figure 4.18* shows, we can specify the kind of rig it
    is in the **Rig** tab of the window, and in this case, **Animation Type** for
    this model is **Humanoid**. The animation system will try to match the model's
    existing bone structure with the **Avatar** bone structure. If the bone structure
    can be successfully mapped, then an **Avatar** asset will be created automatically
    as shown in *Figure 4.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.19_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – unitychanAvatar
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Bones** are a hierarchical set of interconnected parts of **skeletal animation**.
    **Skinning** makes each vertex of the triangle depend on the bone.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the animation system cannot automatically match the model's
    existing bone structure with the **Avatar** bone structure, we need to configure
    the **Avatar** manually. In addition, even if the bone structure can be successfully
    mapped, sometimes we want to manually adjust things to achieve better results.
    At this time, we can also modify it by configuring the **Avatar** asset.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.20_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Configure Avatar
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the model to open the **Import Settings** window for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Configure** button in the **Rig** tab of the window to open the
    **Avatar Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the bones in the **Avatar Inspector** window as shown in *Figure 4.20*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avatar Mask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we create a mapping between the bones of the model and the bone structure
    of Unity's Avatar system, we can play the animation of this character. However,
    sometimes we may not want to animate all the bones of the character. A common
    example is that the walking animation may involve a character swinging their arms,
    but if they pick up a phone to make a call, their arms should hold the phone instead
    of swinging as they walk. In this case, we want to restrict an animation to specific
    body parts, and the **Avatar Mask** asset provided by Unity can help us achieve
    this goal.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new **Avatar Mask** asset by selecting **Assets | Create | Avatar
    Mask** as shown in *Figure 4.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.21_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Create an Avatar Mask
  prefs: []
  type: TYPE_NORMAL
- en: After creating a new **Avatar Mask** asset, we can configure it to define which
    parts of the animation should be masked. As *Figure 4.22* shows, the **Avatar
    Mask** **Inspector** window allows us to click on a diagram of a humanoid body
    to select or deselect certain parts to mask. Here we mask an arm of Unity-Chan!,
    which means some animation will not affect this arm at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.22_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Avatar Mask
  prefs: []
  type: TYPE_NORMAL
- en: In order for this Avatar Mask asset to take effect, we need to apply it to an
    Animator Controller.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.23_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Apply the Avatar Mask asset
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will apply this Avatar Mask asset to the Animator Controller
    we created earlier as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the **New Animator Controller** file to open the **Animator** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the gear icon of the **Base Layer** item to open the **Layer settings**
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click the radio button next to the **Mask** field and select the New **Avatar
    Mask** asset to apply from the **Select AvatarMask** window that pops up, as shown
    in *Figure 4.23*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this way, we can limit the animation to specific body parts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore another important concept in Unity's Animation development
    solution, namely the **Animator** component. By using Animator, we can use this
    Animator Controller asset in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Animator component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we explored Animation Clips, Animator Controllers,
    and Avatar in Unity. However, just creating Animation Clips, Animator Controllers,
    and Avatar assets is not enough to animate the characters in a game Scene. We
    still need the Animator component to assign animation to the GameObject in the
    Scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Animator Controllers and Animator components have similar names but different
    functions. An Animator component uses an associated Animator Controller to apply
    animations to a GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: If you see an Animator component on a GameObject, you will find that it will
    bring together all the various assets we discussed before. It is the root of the
    binding system in Unity's animation solution, so it is very important.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.24_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Animator component
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we can drag the Unity-Chan! model into the Scene to create a new character
    GameObject, and add an Animator component to the GameObject, as *Figure 4.24*
    shows. This is how the Animator component was configured:'
  prefs: []
  type: TYPE_NORMAL
- en: The Animator component needs to reference an Animator Controller, which defines
    the Animation Clips to be used. We can assign the Animator Controller that we
    created in the *Animator Controller* section to it, with the name **New Animator
    Controller**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the Unity-Chan! model is a humanoid model, provide the corresponding Avatar
    asset to this Animator component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Apply Root Motion** setting of the Animator component determines whether
    or not any change to the position or rotation of the root node will be applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Update Mode** setting of the Animator component determines the update
    mode of the Animator component. There are three different options, namely **Normal**,
    **Animate Physics**, and **Unscaled Time**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.25_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – The Update Mode setting
  prefs: []
  type: TYPE_NORMAL
- en: The last setting is **Culling** **Mode**, which determines whether the animations
    of the Animator component should play off-screen. There are three different options,
    namely **Always Animate**, **Cull Update Transforms**, and **Cull Completely**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.26_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – The Culling Mode setting
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, we have an understanding of the concepts of Unity's
    animation system. We will use this system to create 3D animations in the next
    section!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing 3D animation in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered some important concepts, such as **Animation Clips**, **Animator
    Controllers**, **Avatar**, and **Animator components**, in the Unity animation
    system in the previous sections. In this section, you will learn how to implement
    animation for 3D models with these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Importing animation assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to know how to import animation assets into Unity from `/Assets/unity-chan!/Unity-chan!
    Model/Art/Animations` folder as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.27_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 – The Animations folder
  prefs: []
  type: TYPE_NORMAL
- en: Here we can select one animation asset in the **Project** window to open its
    **Import Settings** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.28_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Import settings for animations
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 4.28*, click **Animation** in the **Inspector** window to
    switch to the **Animation** tab, and you can see all the Animation Clips contained
    in the animation asset.
  prefs: []
  type: TYPE_NORMAL
- en: Animation compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition, in the **Animation** tab, we can also find animation-related import
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.29_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – The Anim. Compression setting
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 4.29*, there is a setting called **Anim. Compression**,
    whose value is **Off** by default, which means that Unity doesn't reduce the keyframe
    count on import. In this case, Unity will keep the highest precision animation,
    but at the expense of a large animation size. If reducing the size of the animation,
    whether on our hard disk or in memory, is important, we can consider the two other
    **Anim. Compression** options, which are **Keyframe Reduction** and **Optimal**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.30_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 – Optimal
  prefs: []
  type: TYPE_NORMAL
- en: If the `0.5`; the smaller the value, the higher the precision.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Optimal** option is selected, Unity will decide how to compress the
    Animation Clip.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also modify the properties of a single Animation Clip. After selecting
    an Animation Clip in the list, we can scroll down to see the settings for this
    particular Animation Clip.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.31_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 – Settings for the Animation Clip
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding figure shows, there is an option for the Animation Clip to
    add an Animation Event, which allows us to call functions in a script at a specified
    point in the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new Animation Event, first, we need to position the point
    in the timeline where we want to add the event, then click the **Add Event** button
    in the upper-left corner. A small white marker on the timeline will be created,
    which indicates the new event.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new event, we also need to configure it by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 4.32*, there are multiple fields to fill in, and we
    entered the name `PrintStringFromAnimationEvent` in the `PrintStringFromAnimationEvent`
    function in a script attached to the GameObject. Several other fields can pass
    in different types of parameters for this function, such as `Float`, `Int`, and
    `String`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.32_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 – Add an Animation Event
  prefs: []
  type: TYPE_NORMAL
- en: After setting the event, remember to click the **Apply** button to make the
    configuration of the event take effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the same time, we need to implement a function whose name must exactly match
    the name already filled in the function field, namely `PrintStringFromAnimationEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will accept a string type parameter; once this Animation Event
    is triggered, this function will be called, and the string value will be printed
    in the **Console** window, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.33_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.33 – Print the string value in the Console window
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about importing animation assets into Unity and how to
    set up Animation Events, let's turn our attention to setting up the Animator Controller!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Animator Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After importing animation assets, we need to set up an Animator Controller to
    reference these Animation Clips that will be used in our game. In fact, we created
    an Animator Controller when we introduced it earlier and referenced two Animation
    Clips that will be used. However, we did not configure this Animator Controller;
    for instance, we did not configure how to switch between the two animations. In
    this section, we will explore how to configure an Animator Controller and use
    C# code to switch between different animations.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the animation speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can view the settings of a specific state in the Animator Controller by selecting
    the state in the **Animator** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.34_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.34 – Settings of an animation's state
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple settings, such as `1`. If the `0.5`, the play speed of `2`
    will make the play speed of **Motion Time** twice the normal speed and halve the
    play time.
  prefs: []
  type: TYPE_NORMAL
- en: Animator parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we can see in *Figure 4.35*, there are other settings that require parameters
    to be used. These parameters are called **animation parameters** and they are
    variables defined in the Animator Controller that can be accessed and assigned
    values from a C# script. Therefore, they are an important part of using C# code
    to control animation. In order to add new parameters and edit existing parameters,
    we should switch to the **Parameters** section of the **Animator** window by clicking
    the **Parameters** button in the top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.35_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.35 – The Parameters section
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding figure, the parameters can be one of the following
    four types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Float**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bool**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a demonstration, we can add a new parameter called **SpeedMultiplier**. Then,
    we open the settings of the **POSE01** animation state again and check the **Parameter**
    checkbox after the **Multiplier** setting, and you can see that the newly created
    **SpeedMultiplier** parameter appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.36_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.36 – The SpeedMultiplier parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, these parameters can be accessed and assigned values
    using C# code. Therefore, we can create a new script to access and set a value
    of the `SpeedMultiplier` parameter as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new C# script named `AnimationParametersTest` and obtain a
    reference to the Animator component, then we set the value of the parameter by
    calling the **SetFloat** method of the Animator component, because the type of
    this parameter is float. Similarly, the Animator component also has, **SetInteger**,
    **SetBool**, and **SetTrigger** methods, which are used to set values for different
    types of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animation parameters can also be used to implement animation switching. We can
    use animation transitions to connect two animation states and switch between them.
    However, by default, animation transitions will automatically switch between two
    connected animation states, but we obviously prefer to be able to control the
    switching of animations when developing games.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.37_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.37 – Animation transitions
  prefs: []
  type: TYPE_NORMAL
- en: We can set a transition to occur only when certain conditions are true, and
    animation parameters can be used to determine whether these conditions are met,
    so we can use them here to control the switching of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to add a new parameter, set up a condition,
    and control the switching of different animations from C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `bool` variable parameter called **Run**; its default value is
    **false**, as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.38_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.38 – A new parameter
  prefs: []
  type: TYPE_NORMAL
- en: Select the transition we want to apply the condition to; here we choose the
    transition from **POSE01** to **POSE02**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Go To Run` to this transition, as shown in *Figure 4.39*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.39_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.39 – Name the transition
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the same window, all the conditions for this transition are
    listed. By clicking the **+** button, add a new condition for this **Go To Run**
    transition, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.40_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.40 – Add a new condition
  prefs: []
  type: TYPE_NORMAL
- en: After adding a new condition, we also need to select a parameter, the value
    of which is considered as the condition. The parameter here is **Run**. When the
    value of the **Run** parameter is **true**, it can be considered that the condition
    is met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.41_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 – Select a parameter as the condition
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the default value of the **Run** parameter is **false**. Therefore,
    in order to switch from **POSE1** to **POSE2**, create a C# script to set the
    value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.42_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.42 – C# code snippets
  prefs: []
  type: TYPE_NORMAL
- en: The `Input.GetKey` method will return `true` when the user holds down the key
    identified by `KeyCode`; otherwise, it will return `false`, and then we use this
    value to set the value of the **Run** parameter. Therefore, we can control the
    switching of the animation by pressing the key.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, we have learned how to implement animation for 3D
    models and how to control animation through C# code in Unity. Next, we will discuss
    how to implement animation for 2D assets.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing 2D animation in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the tools we explored earlier to implement 2D animation
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of 2D animation is different from the implementation of 3D
    animation. A common implementation technique for 2D animation is to use **Sprite
    Animations**, which are Animation Clips that are created for 2D assets.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to create Sprite Animations; we can create them directly
    in the **Animation** window of the Unity Editor or create them in external tools,
    such as Aseprite, a popular animation sprite editor, and Piskel, a free online
    sprite editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the sprite animation created by an external tool. You can download
    this asset from Unity Asset Store here: [https://assetstore.unity.com/packages/2d/characters/free-pixel-mob-113577](https://assetstore.unity.com/packages/2d/characters/free-pixel-mob-113577).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.43_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.43 – A Sprite Sheet
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the assets, we can find that this image contains many different
    Sprites, as shown in *Figure 4.43*. We call this a **Sprite Sheet**, which is
    an image containing sequential Sprites commonly used for animation for 2D assets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If an image contains a set of non-sequential Sprite images, we call it a **Sprite
    Atlas**, which is often used to implement UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we should import this image file into the Unity Editor by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 4.44*, since this image contains a series of Sprite images,
    we set **Sprite Mode** to **Multiple** in the **Import Settings** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.44_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.44 – Import Settings of the Sprite Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Sprite Editor** button to open **Sprite Editor** in Unity. **Sprite
    Editor** provides tools that allow us to modify Sprite Sheets, such as slicing
    Sprite Sheets into individual Sprites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.45_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.45 – Sprite Editor in Unity
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking the `16`, change the value of `1`, and then click the **Slice**
    button at the bottom of the drop-down menu and close **Sprite Editor**, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.46_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.46 – Grid By Cell Count
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can select this **Sprite Sheet** asset in the **Project** window to
    expand it, and you can see all the individual Sprites in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.47_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.47 – Sprites in the Sprite Sheet
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have imported the assets and created these sprites. The next
    question is, how do we use these Sprites to create Animation Clips in Unity? The
    answer is not complicated. We only need to select the Sprites that make up the
    Animation Clip we want to create and drag them into the scene. The Unity Editor
    will automatically create the Animation Clip and ask us to select the folder where
    the Animation Clip file will be stored, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.48_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.48 – Create an Animation Clip file
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we select the first eight Sprites from the Sprite Sheet and drag
    them to the Scene view of the Unity Editor. Then, we rename the Animation Clip
    file to `walk` and save it.
  prefs: []
  type: TYPE_NORMAL
- en: Unity will create the Animation Clip file, as I mentioned earlier, and a new
    Animator Controller asset as well. A new GameObject with an Animator component
    attached will also be created in the Scene, which references the Animator Controller,
    as shown in *Figure 4.49*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.49_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.49 – New GameObject in the Scene
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run the game to play the animation by clicking the **Play** button
    in the Unity Editor, and we can see the **walk** animation is playing!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.50_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.50 – Play the walk animation
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, you have learned how to implement animation for
    2D assets; next, we will share some tips to improve animation performance.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the performance of Unity's animation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, the implementation of animation may cause excessive memory usage and
    CPU overhead. In this section, we will talk about how to avoid performance problems
    caused by animation. Specifically, we'll first introduce the **Unity Profiler**
    tool and how to use it to view animation-related performance metrics, and then
    we'll look at how to reduce the CPU overhead and memory footprint of animations.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we should learn how to use tools to view and locate performance bottlenecks
    rather than relying on subjective guesses and experience. Of course, it's not
    that experience is not important, but using tools will help you locate problems
    more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Editor provides developers with a Profiler tool, which we can use
    to view the detailed memory usage of the game and real-time CPU overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to view performance data about the CPU overhead of animation, we should
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Window | Analysis | Profiler** to open the **Profiler** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **CPU Usage** module area in the **Profiler** window to view the performance
    data on the CPU overhead, such as the CPU time consumed by **Animator.Update**,
    as shown in *Figure 4.51*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.51_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.51 – The Unity Profiler
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Profiler also allows us to switch from the **Hierarchy** view to the
    **Timeline** view, which is more intuitive in some cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.52_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.52 – The Timeline view in the Profiler window
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the **CPU Usage** module, we can also view the detailed memory
    consumption of the game in the **Memory** module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Memory** module area in the **Profiler** window to view the
    performance data of memory consumption. The default display mode is **Simple**
    mode, and the memory consumption is counted by types in the **Profiler** window.
    For example, the memory usage of **Textures** is about 106.3 MB, and the memory
    usage of **Meshes** is about 4.5 MB, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.53_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.53 – Memory data in the Profiler window
  prefs: []
  type: TYPE_NORMAL
- en: Compared with **Simple** mode, **Detailed** mode is more powerful. We can switch
    from **Simple** mode to **Detailed** mode by selecting **Detailed** from the drop-down
    menu in the upper-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_4.54_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.54 – Switch to Detailed mode
  prefs: []
  type: TYPE_NORMAL
- en: '**Detailed** mode does not display memory consumption data in real time like
    **Simple** mode. Instead, we need to manually click the **Take Sample****Playmode**
    button to sample the game memory at the current time.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.55_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.55 – Take a memory sample
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the number of objects created in the game or how much memory is
    consumed, the sampling time will be different. But once the sampling is complete,
    we will see the detailed memory overhead; for example, in the following screenshot,
    there are 82 Animation Clips taking up 50.1 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.56_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.56 – Detailed memory data in the Profiler window
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding introduction, we can see that the optimization of animation
    should mainly focus on CPU overhead and memory consumption. Therefore, the following
    two best practices need to be considered when using Unity's animation system to
    implement animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animator's Culling Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to reduce the CPU overhead of animation, we should set the **Animator**
    window's **Culling Mode** property to **Cull Update Transforms** or **Cull Completely**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.57_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.57 – Animator's Culling Mode
  prefs: []
  type: TYPE_NORMAL
- en: By setting it to **Cull Update Transforms**, Unity will disable some features
    of the animation system such as Retarget, Inverse Kinematics (IK) Transforms when
    the Animator is not visible on screen. If it is set to **Cull Completely**, Unity
    will completely disable the animation when the Animator is not visible. Therefore,
    the goal of reducing CPU overhead can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Anim. Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another best practice is to set **Anim. Compression** in the animation import
    settings window to save memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.58_B17146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.58 – Anim. Compression
  prefs: []
  type: TYPE_NORMAL
- en: By setting it to **Keyframe Reduction**, Unity will reduce keyframes on import
    and compress keyframes when storing animations in files. If it is set to **Optimal**,
    Unity will decide how to compress, either by reducing keyframes or by using a
    dense format.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by introducing some of the most important concepts
    of the Unity animation system, such as Animation Clips, Animator Controllers,
    Avatar, and the Animator component. Then, we demonstrated how to implement 3D
    animation in Unity, including how to import animation assets into the Unity Editor,
    how to create an Animation Event on an Animation Clip, how to set up animation
    parameters to control an animation via C# code, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to implement 2D animation in Unity. The implementation
    of 2D animation is different from the implementation of 3D animation. A common
    implementation technique for 2D animation is to use Sprite Animations, which are
    Animation Clips that are created for 2D assets.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored some best practices for implementing animation in Unity
    to optimize the performance problems caused by the animation system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the Physics system in Unity, and at
    the same time, we will also introduce how to optimize Physics performance in Unity.
  prefs: []
  type: TYPE_NORMAL
