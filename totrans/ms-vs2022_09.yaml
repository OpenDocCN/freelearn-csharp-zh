- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Handling Advanced Git Workflows
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理高级Git工作流程
- en: In this chapter, we will dive deep into the world of Git integration within
    Visual Studio, focusing on practical skills that will enhance our software development
    workflows. We will focus on advanced features provided by Visual Studio 2022.
    This chapter is designed to equip you with the tools and techniques needed to
    manage repositories efficiently, resolve conflicts effectively, and leverage the
    power of interactive staging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Visual Studio中Git集成的世界，重点关注将增强我们的软件开发工作流程的实用技能。我们将专注于Visual Studio
    2022提供的高级功能。本章旨在为您提供管理仓库、有效解决冲突和利用交互式暂存能力的工具和技术。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Managing a repository through Visual Studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Visual Studio管理仓库
- en: Resolving conflicts through Visual Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Visual Studio解决冲突
- en: Exploring interactive staging in Visual Studio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Visual Studio中的交互式暂存
- en: In order to streamline our process for collaborative development experiences,
    we will explore mastering the management of branches, resolving conflicts, and
    implementing interactive staging.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的协作开发流程，我们将探讨掌握分支管理、解决冲突和实施交互式暂存。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'While writing this chapter, I used the following versions of Visual Studio:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我使用了以下版本的Visual Studio：
- en: Visual Studio Enterprise 2022 version 17.12.0
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise 2022版本17.12.0
- en: Preview 1.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览1.0
- en: Managing a repository through Visual Studio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Visual Studio管理仓库
- en: If you’re familiar with development, you’ll have likely already used tools such
    as **GitKraken** or **Sourcetree** , among others. For now, all our daily usage
    of Git and repository management can be handled entirely within Visual Studio.
    In this section, we’ll explore how we can leverage Visual Studio to manage our
    repositories without having to exit our favorite IDE.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉开发，你可能已经使用过**GitKraken**或**Sourcetree**等工具，以及其他工具。目前，我们所有的Git和仓库管理都可以在Visual
    Studio中完全处理。在本节中，我们将探讨如何利用Visual Studio来管理我们的仓库，而无需退出我们最喜欢的IDE。
- en: Exploring the Manage Branches window
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索管理分支窗口
- en: 'Visual Studio 2022 introduced a window named **Manage Branches** . To open
    it, we have several options. The first option is using the top **Git** | **Manage
    Branches** menu option:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022引入了一个名为**管理分支**的窗口。要打开它，我们有几种选择。第一种选择是使用顶部的**Git** | **管理分支**菜单选项：
- en: '![Figure 9.1 – Manage Branches top-bar menu option](img/B22218_09_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 管理分支顶部菜单选项](img/B22218_09_1.jpg)'
- en: Figure 9.1 – Manage Branches top-bar menu option
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 管理分支顶部菜单选项
- en: 'The second option is going to **Git Changes** windows, then using the three
    dots in the top-right corner of the window and selecting **Manage Branches** :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是进入**Git更改**窗口，然后在窗口右上角的三点菜单中选择**管理分支**：
- en: '![Figure 9.2 – Manage Branches Git Changes menu](img/B22218_09_2.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 管理分支Git更改菜单](img/B22218_09_2.jpg)'
- en: Figure 9.2 – Manage Branches Git Changes menu
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 管理分支Git更改菜单
- en: Furthermore, in the **Git Changes** window, if we have pending outgoing or incoming
    commits, we can directly click on the **View Commits** link below the **Branches**
    **Combo** box.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在**Git更改**窗口中，如果我们有挂起的出站或入站提交，我们可以直接点击**分支****组合框**下方的**查看提交**链接。
- en: Notice that we can search for this feature by using the **Feature Search** box
    with the *Ctrl* + *Q* shortcut.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用带有*Ctrl* + *Q*快捷键的**功能搜索**框来搜索这个功能。
- en: 'This action will open the **Git** **Repository** window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将打开**Git** **仓库**窗口：
- en: '![Figure 9.3 – Git Repository window](img/B22218_09_3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – Git仓库窗口](img/B22218_09_3.jpg)'
- en: Figure 9.3 – Git Repository window
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Git仓库窗口
- en: 'In this window, we can find all the branches of our repository. When we click
    on a branch, we can see details about its state, in the right part of the window,
    which is organized into three sections:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口中，我们可以找到我们仓库的所有分支。当我们点击一个分支时，我们可以在窗口的右侧看到其状态详情，这些详情被组织成三个部分：
- en: '**Incoming** : This section shows changes from other branches that have not
    yet been merged into the currently selected branch. These changes could come from
    any remote branch that has updates compared to our local branch.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入站**：此部分显示尚未合并到当前选定分支的其他分支的更改。这些更改可能来自任何与我们本地分支相比有更新的远程分支。'
- en: '**Outgoing** : This section displays changes that have been made locally but
    have not yet been pushed to the remote repository. This includes commits that
    we’ve made since our last synchronization with the remote branch.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：此部分显示在本地已做更改但尚未推送到远程仓库的更改。这包括自我们上次与远程分支同步以来所做的提交。'
- en: '**Local History** : This section offers a detailed view of the commit history
    for the currently selected branch. Unlike the **Incoming** and **Outgoing** sections,
    which focus on changes relative to other branches, the **Local History** section
    focuses on the chronological progression of commits within the selected branch.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地历史**：此部分提供了当前选中分支的提交历史的详细视图。与专注于与其他分支相对更改的**输入**和**输出**部分不同，**本地历史**部分专注于选中分支内提交的按时间顺序进展。'
- en: 'Through this window, we can organize our view using the features offered by
    the toolbox menu:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此窗口，我们可以使用工具箱菜单提供的功能来组织我们的视图：
- en: '![Figure 9.4 – Manage Branches toolbox](img/B22218_09_4.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 管理分支工具箱](img/B22218_09_4.jpg)'
- en: Figure 9.4 – Manage Branches toolbox
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 管理分支工具箱
- en: 'This toolbox offers us the following options:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具箱为我们提供了以下选项：
- en: '**Refresh** : Updates the list of branches, tags, and other repository objects
    displayed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刷新**：更新显示的分支、标签和其他仓库对象的列表。'
- en: '**Go to Child** : Navigates directly to a child branch of the currently selected
    branch. A child branch is typically created from another branch (the parent) as
    a result of operations such as branching or merging.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转到子分支**：直接导航到当前选中分支的子分支。子分支通常是通过分支或合并等操作从一个分支（父分支）创建的。'
- en: '**Go to Parent** : Enables navigation to the parent branch of the currently
    selected branch. The parent branch is the branch from which the current branch
    was originally created.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转到父分支**：启用导航到当前选中分支的父分支。父分支是从中创建当前分支的分支。'
- en: '**Show first Parent Only** : Filters the view to display only the immediate
    parent branch of the current selection.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅显示第一个父分支**：过滤视图以仅显示当前选择的直接父分支。'
- en: '**Show Local Branches** : Hides any remote branches from the view, allowing
    you to concentrate on branches that exist only on our local machine.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示本地分支**：隐藏任何远程分支，以便您专注于仅存在于本地机器上的分支。'
- en: '**Show Remote Branches** : Filters the view to display only the branches that
    exist on the remote repository.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示远程分支**：过滤视图以仅显示存在于远程仓库中的分支。'
- en: '**Show Tags** : Makes Git tags visible in the **Git Repository** window alongside
    branches. Git tags are references to specific points in our repository’s history,
    often used to mark release versions.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示标签**：使 Git 标签在**Git 仓库**窗口中与分支一起可见。Git 标签是对我们仓库历史中特定点的引用，通常用于标记发布版本。'
- en: '**Clear Toggled Branches in History** : Provides a way to clean up branches’
    histories by removing the toggles next to branches in the history panel. This
    can make it easier to see the commit history of the currently selected branch
    without being distracted by toggles indicating the presence of other branches
    in the history.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除历史中的切换分支**：通过移除历史面板中分支旁边的切换来清理分支的历史记录。这可以使查看当前选中分支的提交历史记录更加容易，而不会被表示其他分支存在于历史中的切换所分散注意力。'
- en: With this toolbox, we can interact with different branches and perform various
    Git operations. To access these options, we open the context menu by right-clicking
    on the desired branch or commit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具箱，我们可以与不同的分支交互并执行各种 Git 操作。要访问这些选项，我们通过在所需的分支或提交上右键单击来打开上下文菜单。
- en: '![Figure 9.5 – Git command menu](img/B22218_09_5.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – Git 命令菜单](img/B22218_09_5.jpg)'
- en: Figure 9.5 – Git command menu
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – Git 命令菜单
- en: From this menu, we can process classic Git commands, such as creating new branches
    and tags, viewing commit details, reverting commits, and even deleting changes.
    Some of the options may be disabled depending on the state of the commit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从此菜单中，我们可以处理经典的 Git 命令，如创建新分支和标签、查看提交详情、撤销提交，甚至删除更改。某些选项可能根据提交的状态而禁用。
- en: One of the handy options provided is **Checkout(--detach)** .
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的一个方便的选项是**检出（--detach）**。
- en: Looking at Checkout(-- detach)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看检出（--detach）
- en: In the Git command menu ( *Figure 9* *.5* ), we can find the **Checkout (--detach)**
    option, which allows us to revert to an earlier state of our repository, which
    is particularly useful for testing or running code as it existed at a particular
    moment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 命令菜单（*图 9.5*）中，我们可以找到**检出 (--detach**)选项，它允许我们恢复到仓库的早期状态，这对于测试或运行特定时刻存在的代码特别有用。
- en: 'In some cases, we might want to check out the latest commit of a remote branch
    to quickly review a pull request and evaluate the most recent updates. To do this,
    we first need to ensure that we have fetched and updated our local copy of the
    branch. Then, we can right-click on the remote branch of interest and select **Checkout
    Tip** **Commit (--detach)** :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能想检出远程分支的最新提交，以便快速审查拉取请求并评估最新的更新。为此，我们首先需要确保我们已经获取并更新了本地分支的副本。然后，我们可以右键单击感兴趣的远程分支并选择**检出提示**
    **提交 (--detach**)：
- en: "![Figure 9.6 – \uFEFFCheckout Tip Commit (--detach)](img/B22218_09_6.jpg)"
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 检出提示提交 (--detach)](img/B22218_09_6.jpg)'
- en: Figure 9.6 – Checkout Tip Commit (--detach)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 检出提示提交 (--detach)
- en: It’s crucial to note that any commits made while in a **detached HEAD** state
    aren’t linked to a specific branch. As a result, Git might remove these commits
    once you switch to another branch, as they become vulnerable to being deleted.
    Therefore, to safeguard our work, it’s advisable to start a new branch before
    moving away from a detached HEAD state if we want to keep potential changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意，在**分离头**状态下做出的任何提交都没有链接到特定的分支。因此，当你切换到另一个分支时，Git 可能会删除这些提交，因为它们变得容易删除。因此，为了保护我们的工作，如果我们想保留潜在的变化，建议在从分离头状态移开之前开始一个新的分支。
- en: Handling multiple repositories
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个仓库
- en: For greater convenience, or depending on our team’s organization, we might come
    across solutions built across several repositories. This could be a nightmare
    to deal with. Visual Studio introduces multi-repo branching, which streamlines
    this use case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更方便，或者根据我们团队的组织结构，我们可能会遇到跨越多个仓库构建的解决方案。这可能是一个噩梦。Visual Studio 引入了多仓库分支，这简化了这种情况。
- en: Both the status bar and the **Git Changes** tool window in Visual Studio now
    include enhanced branch selection features that support working with multiple
    repositories. These tools allow for easy switching between branches and facilitate
    branch management across all our currently active repos. To swiftly change branches
    within any active repository, simply expand the repository tree in the branch
    picker and select the branch you wish to switch to.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中的状态栏和**Git 变更**工具窗口现在都包括增强的分支选择功能，支持与多个仓库一起工作。这些工具允许我们轻松地在分支之间切换，并促进我们对所有当前活动仓库的分支管理。要快速在任何活动仓库中更改分支，只需在分支选择器中展开仓库树，然后选择要切换到的分支。
- en: '![Figure 9.7 – Select repository](img/B22218_09_7.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 选择仓库](img/B22218_09_7.jpg)'
- en: Figure 9.7 – Select repository
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 选择仓库
- en: For better efficiency, Visual Studio offers us the capability to work with multiple
    repositories as if they were one. Indeed, we can create a new branch across our
    multiple repositories by using the top **Git** | **New branch…** menu option.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，Visual Studio 提供了将多个仓库作为单个仓库一起工作的能力。确实，我们可以通过使用顶部**Git** | **新建分支…**菜单选项在多个仓库中创建一个新的分支。
- en: "![Figure 9.8 –Creating \uFEFFa new branch in multi-repositories](img/B22218_09_8.jpg)"
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 在多仓库中创建新分支](img/B22218_09_8.jpg)'
- en: Figure 9.8 –Creating a new branch in multi-repositories
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 在多仓库中创建新分支
- en: Here, we can choose which repository(s) to include when creating the new branch
    using the checkboxes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过复选框选择在创建新分支时要包含哪些仓库。
- en: Finally, we can access and manage all repositories and branches through the
    **Manage Branches** feature, allowing us to interact with them seamlessly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过**管理分支**功能访问和管理所有仓库和分支，使我们能够无缝地与之交互。
- en: 'Now that we have learned how to leverage Visual Studio 2022 to manage branches,
    using the **Manage Branches** and multi-repository features, in the next section,
    we will explore an important part of a shared code base: resolving conflicts.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何利用 Visual Studio 2022 来管理分支，使用**管理分支**和多个仓库功能，在下一节中，我们将探讨共享代码库的一个重要部分：解决冲突。
- en: Resolving conflicts through Visual Studio
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Visual Studio 解决冲突
- en: Resolving conflicts involves identifying and merging changes made by multiple
    contributors to the same lines of code. This process ensures that everyone’s contributions
    are integrated smoothly, maintaining the integrity and consistency of the shared
    code base. By understanding and effectively managing these conflicts, teams can
    ensure that their software development process remains efficient and productive,
    fostering a collaborative environment where contributions from all team members
    are valued and integrated seamlessly. In this section, we will see how Visual
    Studio 2022 allows us to handle this process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决冲突涉及识别和合并多个贡献者对同一行代码所做的更改。这个过程确保了每个人的贡献都能顺利集成，保持共享代码库的完整性和一致性。通过理解和有效管理这些冲突，团队可以确保他们的软件开发过程保持高效和高效，营造一个所有团队成员的贡献都受到重视并无缝集成的协作环境。在本节中，我们将了解Visual
    Studio 2022如何让我们处理这个过程。
- en: Git excels at seamlessly integrating file modifications under normal conditions,
    provided that the content of the files doesn’t undergo significant alterations
    between updates. When our branch lags significantly behind the primary branch,
    it’s advisable to rebase our branches prior to initiating a pull request. This
    process ensures that our branch can be smoothly incorporated into the main branch
    without encountering conflict issues.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，Git擅长无缝集成文件修改，前提是文件内容在更新之间没有发生重大更改。当我们的分支与主分支落后很多时，在发起拉取请求之前重新设置我们的分支是明智的。这个过程确保我们的分支可以顺利地合并到主分支中，而不会遇到冲突问题。
- en: Despite its proficiency in resolving changes using the history in our repository,
    merge changes are sometimes not clear, and Git stops the merge and informs us
    about file conflicts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Git在利用仓库历史记录解决更改方面非常熟练，但合并更改有时并不清晰，Git会停止合并并通知我们文件冲突。
- en: So, in that case, when we pull the remote branch to our local repository, Visual
    Studio will warn us in the **Git Changes** window with a message and list the
    files that expriencing conflicts with the merge.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，当我们从远程分支将代码拉到本地仓库时，Visual Studio 将在 **Git 变更** 窗口中通过消息和列出发生冲突的文件来警告我们。
- en: '![Figure 9.9 – Merge conflicts arising](img/B22218_09_9.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 合并冲突出现](img/B22218_09_9.jpg)'
- en: Figure 9.9 – Merge conflicts arising
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 合并冲突出现
- en: In this example, the **Car.cs** file was modified on both the remote and local
    branches. In such a case, we must complete the merging process by ourselves. To
    do that, we will double-click on the concerned file, which will open the file
    in resolve conflict mode.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**Car.cs** 文件在远程和本地分支上都进行了修改。在这种情况下，我们必须自己完成合并过程。为此，我们将双击相关的文件，这将以解决冲突模式打开该文件。
- en: '![Figure 9.10 – Resolve conflict mode](img/B22218_09_10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 解决冲突模式](img/B22218_09_10.jpg)'
- en: Figure 9.10 – Resolve conflict mode
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 解决冲突模式
- en: 'In this mode, we can see three sections:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，我们可以看到三个部分：
- en: '**Incoming** : These are the modifications made in the branch we are trying
    to merge with our current branch.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传入**：这些是我们尝试与当前分支合并的分支所做的修改。'
- en: '**Current** : These changes refer to the modifications we have made in our
    current branch.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前**：这些更改指的是我们在当前分支中进行的修改。'
- en: '**Result** : This section consolidates the result of the merging. Notice that
    we can manually edit this part at our convenience.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：本节总结了合并的结果。请注意，我们可以根据自己的方便手动编辑这部分内容。'
- en: We may have unique preferences for how conflict windows are displayed. To adjust
    these settings according to personal convenience, simply click on the gear icon
    located in the upper-right corner of the interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能对冲突窗口的显示方式有独特的偏好。为了根据个人方便调整这些设置，只需单击界面右上角的位置图标。
- en: '![Figure 9.11 – Change the resolve conflict view](img/B22218_09_11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 更改解决冲突视图](img/B22218_09_11.jpg)'
- en: Figure 9.11 – Change the resolve conflict view
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 更改解决冲突视图
- en: 'This way, we can switch between three modes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以在三种模式之间切换：
- en: '**Vertical View** : The **Result** section is placed between the **Incoming**
    and **Outgoing** sections'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直视图**：**结果**部分位于**传入**和**传出**部分之间'
- en: '**Horizontal View** : The **Result** section is placed below the **Incoming**
    and **Outgoing** sections'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平视图**：**结果**部分位于**传入**和**传出**部分下方'
- en: '**Mixed View** : Here, the **Incoming** and **Outgoing** sections are side
    by side and the **Result** section is below them'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合视图**：在这里，**传入**和**传出**部分并排，**结果**部分位于它们下方'
- en: The resolve conflict mode also provides a toolbox to enable us to easily resolve
    conflicts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解决冲突模式还提供了一个工具箱，使我们能够轻松解决冲突。
- en: '![Figure 9.12 – Resolve conflict toolbox](img/B22218_09_12.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 解决冲突工具箱](img/B22218_09_12.jpg)'
- en: Figure 9.12 – Resolve conflict toolbox
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 解决冲突工具箱
- en: This toolbox allows us to use the **Take Incoming** button (or press *F10* )
    to automatically accept all changes coming from the other branch. Alternatively,
    we can click the **Take Current** button (or press *F11* ) to retain our current
    version of all conflicting changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具箱允许我们使用**Take Incoming**按钮（或按*F10*）自动接受来自另一个分支的所有更改。或者，我们可以点击**Take Current**按钮（或按*F11*）以保留所有冲突更改的当前版本。
- en: In the left corner, the arrows enable us to navigate through the differences
    and conflicts across the file. This way, we can resolve conflicts line by line.
    To combine both modifications, we can use the checkboxes on the left side of each
    section. We can see them in *Figure 9* *.10* .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在左上角，箭头使我们能够浏览文件中的差异和冲突。这样，我们可以逐行解决冲突。要合并两种修改，我们可以在每个部分的左侧使用复选框。它们在*图9.10*中可见。
- en: After successfully resolving all conflicts, a notification indicating **0 Remaining**
    will appear near the arrows in the top-left corner of the screen. This signifies
    that there are no unresolved conflicts. To finalize the merge operation, click
    on the **Accept** **Merge** button.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功解决所有冲突后，一个指示**0 Remaining**的通知将出现在屏幕左上角箭头附近。这表示没有未解决的冲突。要完成合并操作，请点击**Accept
    Merge**按钮。
- en: Finally, after we accept the merge and repeat the process in all conflict files,
    we use the **Git Changes** window to create a merge commit and resolve the conflict.
    In our daily use cases, we sometimes write code that we don’t want to commit immediately
    or at all. Git offers us fine-grained control over which changes are committed,
    a feature known as staging. In the next section, let’s explore how Visual Studio
    streamlines this process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们接受合并并在所有冲突文件中重复此过程后，我们使用**Git Changes**窗口创建合并提交并解决冲突。在我们的日常使用案例中，我们有时会编写我们不希望立即或根本提交的代码。Git为我们提供了对要提交的更改的精细控制，这一功能被称为暂存。在下一节中，我们将探讨Visual
    Studio如何简化此过程。
- en: Exploring interactive staging in Visual Studio
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Visual Studio中的交互式暂存
- en: The staging area is where Git stores information about what will go in our next
    commit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存区域是Git存储有关我们将要提交的信息的地方。
- en: Staging allows us to select which changes we want to include in the next commit.
    It is a crucial Git feature. The main reason is that it provides a level of granularity
    and control over what gets committed. By staging only the necessary changes, we
    make the project history cleaner and easier to understand.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存允许我们选择我们想要包含在下一个提交中的更改。这是Git的一个关键功能。主要原因是我们提供了对要提交内容的粒度和控制。通过仅暂存必要的更改，我们使项目历史更加清晰易懂。
- en: For instance, imagine we work on a feature that involves several changes in
    two functions. We might have finished making changes for one function but are
    still working on the other. With staging, we can commit the first function without
    including the second. This way, our commit reflects the state of the feature at
    that point in time, and our teammates can integrate the stable part without getting
    distracted by incomplete tasks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在处理一个涉及两个函数中几个更改的功能。我们可能已经完成了一个函数的更改，但仍在处理另一个。通过暂存，我们可以提交第一个函数而不包括第二个。这样，我们的提交反映了该功能在那一刻的状态，我们的队友可以集成稳定部分，而不会被不完整的任务所分散。
- en: Since version 17.6, Visual Studio 2022 has integrated interactive staging features.
    In this section, we will explore how.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自17.6版本以来，Visual Studio 2022已集成交互式暂存功能。在本节中，我们将探讨如何实现。
- en: When we make modifications to the files, these modifications will appear above
    the **Changes** section in the **Git** **Changes** window.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对文件进行修改时，这些修改将出现在**Git Changes**窗口的**Changes**部分上方。
- en: '![Figure 9.13 – Changes section](img/B22218_09_13.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – Changes部分](img/B22218_09_13.jpg)'
- en: Figure 9.13 – Changes section
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – **Changes**部分
- en: 'In this example, we made changes to three files. By default, Visual Studio
    displays the **Commit All** button, which **stage all** changes in the files and
    then commits them using the message entered in the text box. As if we executed
    directly those command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们对三个文件进行了更改。默认情况下，Visual Studio显示**Commit All**按钮，该按钮**暂存**文件中的所有更改，然后使用文本框中输入的消息提交它们。就像我们直接执行了以下命令：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we want to stage only the **Car.cs** file, we can right-click on it and
    select **Stage** ; alternatively, we can use the **+** button that appears on
    the right when the file is selected:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想暂存**Car.cs**文件，我们可以右键单击它并选择**暂存**；或者，当文件被选中时，我们可以使用右侧出现的**+**按钮：
- en: '![Figure 9.14 – Staging a file](img/B22218_09_14.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 暂存文件](img/B22218_09_14.jpg)'
- en: Figure 9.14 – Staging a file
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 暂存文件
- en: 'With this, the **Staged Changes** section will appear, and we can find the
    **Car.cs** file listed under it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，**暂存更改**部分就会出现，我们可以在其中找到列出的**Car.cs**文件：
- en: '![Figure 9.15 – Staged Changes section](img/B22218_09_15.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 暂存更改部分](img/B22218_09_15.jpg)'
- en: Figure 9.15 – Staged Changes section
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 暂存更改部分
- en: 'You might notice that now the **Git Changes** window will display a **Commit
    Staged** button instead of the **Commit All** one. Under the hood, Visual Studio
    will execute the following **git** command to stage our specified file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，现在**Git更改**窗口将显示一个**暂存提交**按钮而不是**提交所有**按钮。在底层，Visual Studio将执行以下**git**命令来暂存我们指定的文件：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we go back to our initial example, both features can be in the same file.
    For instance, we finish implementing the **UpdateModel()** function and leave
    **DeleteCar()** in a standby state. Here, we will take advantage of the interactive
    staging feature, by selecting the change we want to stage line by line, following
    these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的初始示例，这两个功能可以位于同一个文件中。例如，我们完成了**UpdateModel()**函数的实现，并将**DeleteCar()**置于待机状态。在这里，我们将利用交互式暂存功能，通过逐行选择我们想要暂存的更改，按照以下步骤进行：
- en: In the **Git Changes** window, we double-click on the **Car.cs** file to open
    the **Diff** window. This will show us the difference between the remote repository
    and our local repository.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Git更改**窗口中，我们双击**Car.cs**文件以打开**差异**窗口。这将显示远程仓库和我们的本地仓库之间的差异。
- en: '![Figure 9.16 – Diff window](img/B22218_09_16.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 差异窗口](img/B22218_09_16.jpg)'
- en: Figure 9.16 – Diff window
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 差异窗口
- en: 'Once you have identified the lines you want to stage, select them and click
    on the **+ Stage Lines** pop-up button to add them:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你确定了想要暂存的行，选中它们并点击**+ 暂存行**弹出按钮来添加它们：
- en: '![Figure 9.17 – Stage Lines](img/B22218_09_17.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 暂存行](img/B22218_09_17.jpg)'
- en: Figure 9.17 – Stage Lines
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 暂存行
- en: 'Now, in the **Git Changes** window, we can find two versions of our **Car.cs**
    file: one with the lines we picked to stage in the **Staged Changes** section
    and another with our complete pending changes in the **Changes** section.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**Git更改**窗口中，我们可以找到我们的**Car.cs**文件的两个版本：一个是在**暂存更改**部分中选择的行，另一个是在**更改**部分中的完整挂起更改。
- en: '![Figure 9.18 – Staged by line file](img/B22218_09_18.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 按行暂存的文件](img/B22218_09_18.jpg)'
- en: Figure 9.18 – Staged by line file
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 按行暂存的文件
- en: After staging our changes, we can commit them using the standard commit workflow
    with the **Commit Staged** button. This ensures that our commits are clean and
    logically organized, reflecting the changes we intended to share.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂存我们的更改后，我们可以使用带有**暂存提交**按钮的标准提交工作流程来提交它们。这确保了我们的提交是干净的并且逻辑上组织良好，反映了我们打算分享的更改。
- en: In this section, we explored how we can properly stage commits by selectively
    choosing specific lines of changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何通过选择性地选择特定的更改行来正确地暂存提交。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter delved into essential aspects of managing software development
    projects using Visual Studio, focusing on repository management, resolving conflicts,
    and leveraging the interactive staging feature. These lessons are crucial as they
    equip us with the tools and techniques necessary to maintain clean, efficient
    code bases and ensure smooth collaboration among team members.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了使用Visual Studio管理软件开发项目的关键方面，重点关注仓库管理、解决冲突以及利用交互式暂存功能。这些课程至关重要，因为它们为我们提供了维护干净、高效的代码库并确保团队成员之间协作顺畅所需的工具和技术。
- en: We started by diving deep into the capabilities of Visual Studio for managing
    repositories, underscoring its critical role in simplifying version control processes.
    Following this, we delved into the art of resolving conflicts within Visual Studio,
    offering valuable insights into navigating the challenges of the merge conflicts
    that commonly surface during teamwork. Our journey concluded with an examination
    of the interactive staging feature, which provides a more user-friendly method
    for preparing commits.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从深入研究 Visual Studio 管理仓库的功能开始，强调了其在简化版本控制流程中的关键作用。随后，我们探讨了在 Visual Studio
    中解决冲突的艺术，提供了关于如何应对团队合作中常见的合并冲突挑战的宝贵见解。我们的旅程以对交互式暂存功能的考察结束，该功能提供了一种更用户友好的方法来准备提交。
- en: As we move forward to the next chapter, we will build upon the foundational
    knowledge acquired in this chapter. The upcoming discussion will focus on automating
    the integration process, further enhancing project efficiency and reliability.
    This transition marks the next logical step in our journey toward mastering modern
    software development practices through Visual Studio 2022, where continuous integration
    plays a pivotal role in delivering high-quality software consistently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们迈向下一章节，我们将基于本章所获得的基础知识进行构建。接下来的讨论将聚焦于自动化集成过程，进一步优化项目效率和可靠性。这一过渡标志着我们在通过
    Visual Studio 2022 掌握现代软件开发实践旅程中的下一个逻辑步骤，其中持续集成在持续交付高质量软件中扮演着关键角色。
