- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Interactions and Mechanics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互和机制
- en: Now that we have a character with basic locomotion and an environment to work
    with, let’s take a look at how this character should interact with this environment.
    Unity allows us to use C# to build logic around GameObjects that the player can
    interact with. This is the basis of game design and helps tell the story or experience
    through actual interaction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个具有基本移动能力和可以与之交互的环境的角色，让我们看看这个角色应该如何与这个环境交互。Unity允许我们使用C#围绕玩家可以与之交互的GameObject构建逻辑。这是游戏设计的基础，并有助于通过实际交互讲述故事或体验。
- en: 'You’ll learn more about the specific interactions and mechanics that can be
    implemented with Unity in this chapter. We will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解更多关于可以使用Unity实现的具体交互和机制。我们将涵盖：
- en: Game loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏循环
- en: Mechanics toolbox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机制工具箱
- en: Interactions within our project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目内的交互
- en: Stairs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 楼梯
- en: Rings puzzles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环形谜题
- en: Tight spaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 狭小空间
- en: Interactive volumes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互体积
- en: Design and implementation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计与实现
- en: Game loops
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: 'Video games have a unique concept called a **game loop**. As you might be able
    to guess, it’s a loop of mechanics that are performed throughout the experience.
    The game loop itself could be very short, such as Call of Duty’s multiplayer team
    deathmatch. The loop looks something like this, where the goal is to kill more
    enemies than the number of times you die:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏有一个独特的概念，称为**游戏循环**。正如你可能猜到的，它是在整个体验过程中执行的一系列机制循环。游戏循环本身可能非常短，例如《使命召唤》的多玩家团队死亡匹配。循环看起来可能像这样，目标是杀死比死亡次数更多的敌人：
- en: Kill enemies
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 杀死敌人
- en: Die and respawn
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死亡并重生
- en: 'There’s more to it than that, and if you are a professional Call of Duty player,
    you may think this is an over-generalization of the gameplay. Ultimately, however,
    it really is the case 90% of the time. Now let’s look at Minecraft’s game loop:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是那样，如果你是一个职业的《使命召唤》玩家，你可能认为这是对游戏玩法的一种过度概括。然而，最终，这真的是90%的情况。现在让我们看看Minecraft的游戏循环：
- en: Gather resources in the day
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 白天收集资源
- en: Build in the day
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 白天建造
- en: Survive at night
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 夜间生存
- en: 'We are going to simplify this: there are specific circumstances that fall outside
    this loop, such as creepers in the day and rainfall, which reduces light levels
    such that it essentially becomes night. Let’s assume those two factors aren’t
    part of this study. This is interesting, as this loop is particularly complex.
    By this, I mean that surviving doesn’t always happen in this loop. The majority
    of the game is 1, then 2\. Only at night does 3, **Survive at night**, become
    a large portion of the gameplay, visually represented in *Figure 6.1*. The core
    game loop needs to be as concise as it can possibly be.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简化这一点：有一些特定的情况不在这个循环中，例如白天的爬行者以及降雨，这降低了光照水平，使得实际上变成了夜晚。让我们假设这两个因素不包含在这个研究中。这很有趣，因为这个循环尤其复杂。我的意思是，生存并不总是在这个循环中发生。游戏的大部分时间是1，然后是2。只有在夜晚，3，**夜间生存**，才成为游戏玩法的重要组成部分，这在*图6.1*中有视觉表示。核心游戏循环需要尽可能简洁。
- en: '![](img/B17304_06_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_06_01.png)'
- en: 'Figure 6.1: Minecraft game loop'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Minecraft游戏循环
- en: 'Take a look at your favorite games and break down their main game loops. You
    may find that there are layers of game loops. Sometimes this is called **meta-progression**.
    In the game Hades, the game loops are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你最喜欢的游戏，并分析它们的主要游戏循环。你可能会发现存在游戏循环的层级。有时这被称为**元进度**。在游戏《Hades》中，游戏循环如下：
- en: (Optional) Talk to NPCs
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）与NPC交谈
- en: (In lobby) Choose skills to upgrade
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （在大厅中）选择升级的技能
- en: (In lobby) Choose weapon for the next run
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （大厅中）为下一次运行选择武器
- en: (In game) Fight
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （在游戏中）战斗
- en: (In game) Earn currency for in-lobby upgrades
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （在游戏中）为大厅升级赚取货币
- en: (In game) Upgrades to strengthen this playthrough
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （游戏中）升级以增强这次游玩
- en: Die and respawn in lobby
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大厅中死亡并重生
- en: The meta-progression takes place at step 2\. Base health and damage upgrades
    make it slightly easier to progress further. This is a common factor in rogue-like
    genres where the game’s experiences are focused on skill mastery and game progression
    through death.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 元进度发生在步骤2。基础生命值和伤害升级使进一步进步变得稍微容易一些。这在以技能掌握和通过死亡进行游戏进度的roguelike流派中是一个常见因素。
- en: You’ll notice that in the Call of Duty loop we didn’t mention meta-progression,
    even though there is heavy meta-progression in that game. This is because meta-progression
    is essentially **cosmetic**. You do not have to change anything between matches
    in Call of Duty. Any equipment that is gained in Call of Duty will be the same
    as another player’s equipment with the same mods. If you put a player that has
    played 1000 hours against a player with the same exact loadout, it would only
    come down to skill. In Hades, however, you have to spend points on upgrades to
    actually complete the game.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在《使命召唤》循环中，我们没有提到元进度，尽管这款游戏中存在大量的元进度。这是因为元进度本质上**只是装饰性的**。在《使命召唤》中，你不需要在比赛之间做任何改变。在《使命召唤》中获得的任何装备都将与拥有相同模组的其他玩家的装备相同。如果你让一个玩了1000小时的玩家与一个装备完全相同的玩家对战，那结果将只取决于技能。然而，在《冥界神殿》中，你必须花费点数来升级，才能真正完成游戏。
- en: These loops are interesting, but we should take some time to go deeper into
    the interactions that make up these loops. In the next section, we will cover
    a broad set of game mechanics individually.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环很有趣，但我们应该花些时间深入研究构成这些循环的交互。在下一节中，我们将单独介绍一系列游戏机制。
- en: Mechanics toolbox
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机制工具箱
- en: An interaction is an action taken using a mechanic. For example, the mechanic
    of `Use Item` could be used to pull a lever, push a button, or use a phone. Those
    three examples are interactions; the mechanic allows the player to interact with
    the items through a button press. If we only had the ability to interact with
    something in this way, we would have very few genres to play with. Luckily for
    us, there is a broad world of mechanics available for us to use to make interactions.
    Using interactions, we can design amazing experiences!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 交互是通过机制采取的行动。例如，`使用物品`的机制可以用来拉动杠杆、按按钮或使用电话。这三个例子都是交互；机制允许玩家通过按钮点击与物品交互。如果我们只能以这种方式与某物交互，我们将只有很少的游戏类型可以玩。幸运的是，我们有广阔的机制世界可供我们使用来创造交互。通过使用交互，我们可以设计出惊人的体验！
- en: To begin this chapter, we thought it would be a good idea to provide a list
    of mechanics and some interactions that come from those mechanics. We will not
    be able to go through every mechanic, but we will be going over some primary concepts
    to get a good feel for the mechanics landscape.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这一章，我们认为提供一个来自这些机制的机制列表和一些交互列表是个好主意。我们无法涵盖每一个机制，但我们将探讨一些主要概念，以获得对机制景观的良好感觉。
- en: 'What we will be providing here is an understanding of mechanics and how they
    can be viewed. If this interests you, take some time to read through several different
    authors on the subject, as their views on the mechanics may differ from our explanations.
    Our way of seeing mechanics is that they are layers of experiential movement.
    There are core concepts that can be layered on top of each other to form an interaction.
    These include:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提供的是对机制及其如何被看待的理解。如果你对此感兴趣，花些时间阅读几位不同作者关于这个主题的作品，因为他们对机制的看法可能与我们解释的不同。我们看待机制的方式是它们是体验运动的层次。有一些核心概念可以叠加在一起形成交互。这些包括：
- en: Resource management
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理
- en: Risk versus reward
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险与回报
- en: Spatial awareness
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间意识
- en: Collection
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集
- en: Research
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究
- en: Limitations
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局限性
- en: Read on to get an understanding of these modular core concepts of game design.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读，以了解这些游戏设计的模块化核心概念。
- en: Resource management
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源管理
- en: You may know of this as a primary mechanic of **real-time strategy** games,
    or **RTSs**. Starcraft, Age of Empires, and Total Annihilation are examples of
    popular resource management-focused games. The concept here is that there are
    finite resources that you need to gather and spend on something that can help
    you win. This could be soldiers for an army or experiments to make your soldiers
    stronger. A non-combat-related scenario is a city builder. You need to monitor
    the people of your city and build things to make them happy, and you manage the
    money coming in from them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道这是**实时策略**游戏的主要机制，或者称为**RTS**。例如，《星际争霸》、《帝国时代》和《全面战争》都是流行的以资源管理为重点的游戏。这里的理念是，你需要收集和花费有限的资源在能帮助你赢得比赛的东西上。这可能是一支军队的士兵或使你的士兵变得更强大的实验。一个非战斗相关的场景是城市建设者。你需要监控你城市的人民，并为他们建造东西以使他们快乐，同时管理从他们那里流入的钱。
- en: Risk versus reward
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风险与回报
- en: This mechanic is used in many combat-oriented games. It’s usually given in the
    form of cooldowns. Do you want to use your ultimate right now, to take an example
    from the popular title League of Legends? It could take out an enemy and give
    you a major advantage. However, it could also potentially put you at a disadvantage
    if you miss, because the enemy will know you have one less power to use. This
    is the risk vs. reward concept. The simplest form of this is in Super Mario Bros.
    Should you try for those coins that are hard to reach? You want those points for
    an extra life, but at the same time, there is a pit that you might fall into if
    you don’t jump just right.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制在许多以战斗为导向的游戏中被使用。它通常以冷却时间的形式出现。以流行的游戏《英雄联盟》为例，你想现在就使用你的终极技能吗？这可能会消灭一个敌人并给你带来重大优势。然而，如果你失误，这也可能让你处于劣势，因为敌人会知道你少了一个可以使用的力量。这是风险与回报的概念。这种概念最简单的形式体现在《超级马里奥兄弟》中。你应该尝试那些难以触及的硬币吗？你想要这些分数来获得额外生命，但与此同时，如果你不正确跳跃，你可能会掉进坑里。
- en: Spatial awareness
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间意识
- en: It is common to find this in first-person shooters. Call of Duty and Overwatch
    utilize this in several ways. First, you have spatial awareness of the enemy on
    the screen. You need to be able to place your cursor where they are on the screen
    to shoot at them. Secondly, there is spatial awareness of the entire map. If you
    are not spatially aware of the map, you can easily get caught unawares. This is
    the core of platforming games as well. Understanding your position in space in
    2D and being able to maneuver deftly is the name of the game in any action platformer.
    Celeste takes full advantage of this by giving the player tight control schemes
    that move as you expect every time. The movement is so well put together that
    when you make a mistake, you feel as though it’s your fault.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称射击游戏中，这种情况很常见。使命召唤和守望先锋以几种方式利用这一点。首先，你需要对屏幕上的敌人有空间意识。你需要能够将光标放置在屏幕上他们的位置来射击他们。其次，你需要对整个地图有空间意识。如果你对地图没有空间意识，你很容易被突然袭击。这也是平台游戏的核心。在2D空间中理解你的位置并能够灵活操作是任何动作平台游戏中的游戏名称。Celeste通过提供玩家每次都按预期移动的紧密控制方案充分利用了这一点。动作编排得如此之好，以至于当你犯错时，你会觉得自己是错的。
- en: 'This is interesting: if you have loose controls in a game that needs tight
    controls, the player can feel cheated by the game and may stop playing. This is
    undesirable!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣：如果你在一个需要紧密控制的游戏中拥有松散的控制，玩家可能会感到被游戏欺骗，并可能停止游戏。这是不可取的！
- en: Collection
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集
- en: 'Any CCG gamers out there? It’s in the name! Collectable Card Game. Magic: The
    Gathering, Hearthstone, Yu-Gi-Oh!, and Pokémon are just a few examples. Although
    this mechanic is not flashy, the concept of collection is used in all sorts of
    games.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有玩过任何CCG（可收集卡牌游戏）的玩家？这个名字就说明了这一点！可收集卡牌游戏。万智牌、炉石传说、游戏王和宝可梦只是几个例子。尽管这种机制并不显眼，但收集的概念被用于各种游戏中。
- en: Skills can be collected, as well as weapons, codex entries, armor, and the list
    can go on forever. Humans enjoy collecting stuff. It could be that you want every
    card in the season to unlock an achievement. This is double collecting, as you
    want the cards, but you also want to collect those achievements. It could be that
    you want to collect all the codices in a game, such as in Mass Effect, where the
    lore of the game comes from interacting with as many unique things as possible
    and your journal updates a codex, which holds information on unique items, characters,
    races, history, etc.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 技能可以收集，同样还有武器、法典条目、盔甲，清单可以一直列下去。人类喜欢收集东西。可能你想要收集该季节中的每一张卡牌以解锁成就。这是双重收集，因为你不仅想要这些卡牌，还想要收集那些成就。可能你想要收集游戏中所有的法典，例如在《质量效应》中，游戏的背景知识来自于尽可能多地与独特事物互动，你的日志更新法典，其中包含关于独特物品、角色、种族、历史等信息。
- en: Research
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 研究
- en: Research is the ability to engage in investigation to establish facts and rules
    to your surroundings. We can use the concept of research in a few unique ways.
    One thought is that the player should be the one doing the research, rather than
    the character. Meaning the player sees the environment for the character. Because
    of this, the player can learn about subjects and things that may be outside of
    the character’s knowledge. We as designers can utilize this knowledge and relay
    information easier to the player by outlining interactable objects or by making
    climbable ledges a specific color.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 研究是进行调查以建立事实和规则的能力。我们可以以几种独特的方式使用研究的概念。一个想法是玩家应该是进行研究的那个，而不是角色。这意味着玩家看到的是角色的环境。正因为如此，玩家可以了解角色可能不知道的主题和事物。我们作为设计师可以利用这些知识，并通过概述可交互对象或使可攀爬的边缘具有特定颜色来更容易地向玩家传达信息。
- en: On the other hand, the concept of research could refer to the character themselves.
    The character in-game researches and concludes something new to them in their
    world and becomes stronger while expanding their awareness both physically and
    mentally. This may seem similar to collection and resource management; however,
    if it involves knowledge transfer from the character to the player or things being
    inherently learned from play, it should be considered research.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，研究的概念可能指的是角色本身。游戏中的角色通过研究，在自己的世界中得出新的结论，并在身体和精神上变得更强大，同时扩展他们的意识。这看起来可能类似于收集和资源管理；然而，如果它涉及到从角色到玩家的知识转移，或者事物本质上是通过游戏学到的，那么它应该被视为研究。
- en: Limitations
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: Pressure makes diamonds. Rather than being a mechanic in and of itself, limitations
    can be seen as modifiers of other/all mechanics, but we like to break it out as
    its own mechanic, as not every interaction requires there to be heavy limitations.
    There can be overarching limitations that affect the overall gameplay. For example,
    adding a timer to the game as a whole is a limitation. Another is giving the player
    only 3 lives before ending the play session. In a CCG, you may see there is a
    hard cap to the decks. This limits the number of turns that can be taken.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 压力使钻石。与其被视为一种独立的机制，限制可以被视为其他/所有机制的修饰符，但我们喜欢将其作为一个独立的机制单独列出，因为并非每个交互都需要有严格的限制。可以有影响整体游戏的整体限制。例如，给整个游戏添加计时器就是一个限制。另一个例子是玩家只有3次生命，游戏会结束。在一个卡牌游戏中，你可能看到对牌库有硬性上限。这限制了可以进行的回合数。
- en: When you take the time to figure out how these mechanics fit together to build
    interactions and make and experience, you’ve designed a complete mechanic. How
    all these pieces fit together is the crux of mechanics and interaction design.
    Let’s take some time to go over some of the nuances involved.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花时间去弄清楚这些机制如何组合在一起以构建交互和体验时，你就已经设计了一个完整的机制。所有这些部件如何组合在一起是机制和交互设计的核心。让我们花点时间来探讨一些细微差别。
- en: Design and implementation
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计与实现
- en: In good design fashion, we need to break down the reasons for the mechanics
    and interactions that we are going to use. In general, you want to minimize the
    number of mechanics in a game while spreading their use to many unique interactions.
    Mega Man is a great example of minimal mechanics with elegant use for slight variations.
    Locomotion, jumping, and shooting are the only things you have to worry about.
    After defeating the enemies, you gain different shooting abilities or skills,
    but you will still use the same button to engage the shooting mechanic. This mechanic
    is kept to a single button press all the way up until Mega Man 4; when the character
    is able to charge up his weapon and the button designation changes to adapt to
    the skill change.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好的设计风格中，我们需要分解我们将要使用的力学和交互的原因。一般来说，你希望在游戏中尽量减少力学数量，同时将它们的应用扩展到许多独特的交互中。Mega
    Man 是一个很好的例子，展示了如何以优雅的方式使用最少的力学来实现细微的变化。移动、跳跃和射击是你唯一需要担心的事情。在击败敌人后，你将获得不同的射击能力或技能，但你仍然会使用相同的按钮来激活射击机制。这个机制一直保持为单个按钮按下，直到
    Mega Man 4；当角色能够充电他的武器并且按钮分配改变以适应技能变化时。
- en: 'This is an interesting thought: the gameplay involves a very limited number
    of changes to the mechanics, instead just changing graphics and narrative. When
    you begin designing this portion of your game, think about the smallest action
    your player should take to progress and break it down to its smallest components.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的想法：游戏玩法只涉及对机制非常有限的变化，只是改变图形和叙事。当你开始设计游戏这部分时，考虑玩家应该采取的最小行动以推进游戏，并将其分解为其最小的组成部分。
- en: 'If you’re thinking about designing a game that is heavily combat-driven, you
    need to ask yourself some questions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑设计一个以战斗为主的游戏，你需要问自己一些问题：
- en: What type of combat style is it?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是哪种类型的战斗风格？
- en: Does the combat style match the historical theme of the surrounding environment?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战斗风格是否与周围环境的主题历史相符？
- en: Does the combat style align with the character or contrast their morals?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战斗风格是否与角色相符或与其道德观形成对比？
- en: How do the answers to all of the above questions align with the emotional experience
    you are asking the player to feel? These questions aren’t exhaustive by any means.
    Each of the questions should lead to a further clarification of the game mechanics
    and shape the experience you want for your players.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述问题的答案如何与你要让玩家感受到的情感体验相一致？这些问题绝不是详尽的。每个问题都应该进一步阐明游戏机制，并塑造你希望为玩家提供的体验。
- en: It is all too easy to look at the game you are making and fall into the trap
    of comfort, just falling into line with other games from the genre that you’re
    developing for. If you find yourself designing something and thinking to yourself,
    “This is how it’s always been done,” you need to evaluate that interaction. **First-person
    shooters** (**FPSs**) are a great example of this because of the restrictions
    of the first-person viewpoint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易在制作的游戏中陷入舒适区的陷阱，只是沿着你正在开发的类型的其他游戏走。如果你发现自己正在设计某物，并想，“这就是一直以来的做法”，你需要评估这种交互。**第一人称射击游戏**（**FPS**）是这一点的绝佳例子，因为第一人称视角的限制。
- en: 'There is one major unique outlier that did very well in the FPS space: Half
    Life. Valve created an FPS with physics-based puzzle mechanics and a heavy emphasis
    on narrative. This was highly unique compared to the run-and-gun hyper-destruction
    that was the focus of previous FPS games.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在FPS领域有一个非常独特的例外，那就是《半条命》。Valve创造了一个基于物理谜题机制的FPS游戏，并高度重视叙事。与之前FPS游戏以跑酷和超破坏为主的特点相比，这非常独特。
- en: Since we are talking about interactions and mechanics through the design lens,
    we need to talk about the game Undertale. Undertale is a game that begins as a
    low-graphical-fidelity role-playing game. The gameplay narrative feels normal
    at first; then combat happens! You quickly learn the combative mechanics you need
    to win and combat gameplay feels great. However, hurting things isn’t always what
    you want to focus on. There is a subversion of the players’ expectations, where
    the game sees you asking the character to hurt people that the character may have
    an emotional tie to in the game. That emotional difference is being brought into
    view to show the use of what is standard in a way that turns the players’ expectations
    on their head. This is only available if you, the designer, study and know game
    design intimately.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在从设计角度讨论交互和机制，我们需要谈谈《Undertale》这款游戏。《Undertale》是一款以低图形保真度的角色扮演游戏开始的。游戏玩法叙事一开始感觉正常；然后战斗发生了！你很快就会学会你需要赢得战斗的战斗机制，战斗游戏感觉很好。然而，伤害事物并不总是你想要关注的。游戏颠覆了玩家的期望，其中游戏看到你要求角色伤害角色可能在游戏中与角色有情感联系的人。这种情感差异被引入视野，以展示标准的使用方式，从而颠覆了玩家的期望。这只有在设计师你研究了并深入了解游戏设计的情况下才可行。
- en: This entire chapter could easily be spent talking about the design of other
    games’ mechanics and interactions. Instead of breaking down loads of games, let’s
    work through our own project and investigate some simple examples of mechanics
    and interactions to use within them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节可以很容易地用来讨论其他游戏机制和交互的设计。与其分析大量游戏，不如让我们处理我们自己的项目，并调查一些简单的机制和交互的例子，这些例子可以用于其中。
- en: Throughout the sections, we will also be looking at the implementation of various
    game designs. Metaphorically speaking, our hope here is that we will break down
    the puzzle pieces from top to bottom in interaction, to show you that developing
    a game is all about breaking down each piece while keeping the whole picture in
    mind.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在各个部分中，我们还将探讨各种游戏设计的实现。从比喻的角度来说，我们在这里的希望是，我们将从上到下分解交互中的谜题块，以展示开发游戏就是关于在保持整体图景的同时分解每一块。
- en: One piece of advice while reading through these sections is that the implementations
    of these game interactions are not set in stone, nor are they the only way to
    use these interactions. They are just examples of our approach. Try to imagine
    how you might change the design of each piece.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这些部分时的一些建议是，这些游戏交互的实现并非一成不变，也不是使用这些交互的唯一方式。它们只是我们方法的一个例子。试着想象你可能会如何改变每一块的设计。
- en: Our project
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的项目
- en: 'We are building a 3D puzzle adventure game. Our initial mechanics will be using
    research as the primary component. Later in the book, in *Chapter 7*, *Rigid Bodies
    and Physics Interaction*, regarding our design of telekinesis, we will layer spatial
    awareness on top of this. With this understanding, we will build out our game
    loop. To make an experience worth playing, we can define the game loop as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个3D解谜冒险游戏。我们的初始机制将使用研究作为主要组成部分。在本书的后面，在第7章“刚体与物理交互”中，关于我们对心灵感应的设计，我们将在其基础上叠加空间感知。有了这个理解，我们将构建我们的游戏循环。为了使体验值得一玩，我们可以将游戏循环定义为以下内容：
- en: Search environment for clues
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在环境中寻找线索
- en: Solve puzzles from clues
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从线索中解决谜题
- en: With the game loop defined and the understanding that we are focusing on research
    as a primary mechanic, we now need to build interactions to make an experience.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了游戏循环并理解我们专注于研究作为主要机制之后，我们现在需要构建交互来创造体验。
- en: To get started on our interactions, we are going to work through a couple of
    simple non-physics-focused actions. The character, Myvari, needs to be able to
    interact with the environment to complete puzzles and enter areas to get to her
    destination. Thematically the environments are ruins from her race’s past. Through
    our demonstrative vertical slice, Myvari will encounter multiple environmental
    puzzles where she will need to take in her surroundings and overcome obstacles.
    The player of this game, leading Myvari with their controller, is to pay attention
    to the detail of the environment and learn how to work through the environmental
    puzzles. The first interaction the character will face is the stairs. Let’s dive
    into the design of that to get a real sense of what the rest of the interactions
    will need in terms of definition.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '为了开始我们的交互，我们将通过几个简单的非物理聚焦的动作进行工作。角色Myvari需要能够与环境交互以完成谜题并进入区域以到达她的目的地。从主题上讲，环境是她种族过去的废墟。通过我们的演示垂直切片，Myvari将遇到多个环境谜题，她需要观察周围环境并克服障碍。这款游戏的玩家，通过控制器引导Myvari，需要关注环境的细节并学习如何解决环境谜题。角色将面临的第一交互是楼梯。让我们深入设计这个楼梯，以真正了解其他交互在定义方面需要什么。 '
- en: The stairs
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 楼梯
- en: In this demonstrative level, there exists a set of stairs woven within the environment
    for the character to traverse. Understanding what these stairs convey to the player
    helps to establish a foundational sense of early interaction affordance, meaning
    that your environment will be the primary guiding factor for players navigating
    the level. Let’s work through designing this initial interaction, as it is the
    first experience the player truly gets to be part of.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示级别中，环境中存在一组供角色穿越的楼梯。理解这些楼梯向玩家传达的信息有助于建立早期交互能力的基础感，这意味着你的环境将成为玩家导航级别的首要指导因素。让我们一起来设计这个初始交互，因为这是玩家真正能够参与的第一体验。
- en: Design
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: When the player enters the game, Myvari will enter from the woods into a cave
    that seems normal. Moving into the cave brings you into a small hallway that leads
    to an opening with a steep slope that’s too steep to walk up. There are two pools,
    one on each side of this slope. There are levers on each side. All that needs
    to happen is that each level needs to be interacted with. *Figure 6.2* shows the
    blockout of how this will flow.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入游戏时，Myvari将从树林中进入一个看似正常的洞穴。进入洞穴后，你会进入一个通往一个陡峭斜坡的小走廊，这个斜坡太陡峭以至于无法爬上去。在这个斜坡的两侧各有一个池塘。每侧都有一个杠杆。所有需要发生的事情就是每个层级都需要进行交互。*图6.2*显示了这种流程的预览。
- en: '![](img/B17304_06_02.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_06_02.png)'
- en: 'Figure 6.2: Overview of initial interaction, the stairs'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：初始交互，楼梯概述
- en: In the first open space encounter, you can get a sense of wonderment. Here is
    a cave with manmade features. In the distance, there is a semblance of a door
    and a path leading to it. Making your way toward the door, you will notice the
    path ahead becoming very steep. Walking around, you research the area and find
    levers. These levers bring stairs to the path so you can climb to the door surrounded
    by what looks to be ruins.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次开阔空间遭遇中，你可以感受到一种惊奇。这里有一个有手工特征的洞穴。在远处，有一个门和通往它的路径的轮廓。当你朝着门走去时，你会注意到前面的路径变得非常陡峭。四处走动，你研究这个区域，并找到杠杆。这些杠杆将楼梯带到路径上，这样你就可以爬到被看起来像是废墟所包围的门那里。
- en: Simple environment design needs to be in place here with “light pooling.” This
    is when you add lighting to an area to draw the attention of the player. We tend
    to go to areas with more light. Therefore we need the players to interact with
    particular models within the scene. To make it noticable to the player, you add
    player affordances to these designated models. For example when you get close
    enough to the levers, they will become highlighted slightly. Suddenly, a tooltip
    will be displayed to show you which button to press to interact with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要有一个简单的环境设计，包括“灯光聚集”。这是当你向一个区域添加灯光以吸引玩家注意的时候。我们倾向于走向光线更充足的地方。因此，我们需要玩家与场景中的特定模型进行交互。为了使玩家注意到这些指定的模型，你需要在这些模型上添加玩家可及性。例如，当你足够接近杠杆时，它们会略微突出。突然，一个工具提示会显示出来，告诉你需要按哪个按钮来与之交互。
- en: Interacting with both levers creates a clicking noise. Moving away from your
    current camera, a small cinematic will play showing the stairs rising and moving
    into place. From this point, you may move up the stairs onto the Rings area. The
    Rings will be the initial puzzle with environmental research at play. We have
    a sense of how this should be played out, but implementation always throws us
    a few kinks. We need to put things into practice to see if the design works. Let’s
    get into Unity and see how it feels!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与两个杠杆交互会产生点击声。从你的当前摄像机移动开，会播放一个小型电影，展示楼梯升起并就位。从这一点开始，你可以沿着楼梯移动到Rings区域。Rings将是初始的谜题，其中包含环境研究。我们有一种感觉，知道应该如何进行，但实施总是给我们带来一些问题。我们需要将事物付诸实践，看看设计是否可行。让我们进入Unity看看感觉如何！
- en: Implementation
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: First things first, we need something that we can interact with. Let’s break
    this down just a little bit. There are 3 points to this implementation. We need
    an interaction block, a stair blocker, and a manager to work with these two elements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些可以与之交互的东西。让我们稍微分析一下。这个实现有三个要点。我们需要一个交互块，一个楼梯阻挡器，以及一个管理这两个元素的管理器。
- en: Interaction block
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交互块
- en: We know we have two interaction points that both need to be interacted with
    to satisfy the success of the stairs. This means we should build a trigger that
    we can use more than once. This cube needs to have a box collider on it, as we
    will be using collision to help with setting the states.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们有两个交互点，这两个点都需要交互以满足楼梯的成功。这意味着我们应该构建一个可以多次使用的触发器。这个立方体需要有一个盒子碰撞器，因为我们将会使用碰撞来帮助设置状态。
- en: We’re now going to look at some code. As with *Chapter 4*, *Characters*, we
    won’t be going over each and every line of code – we’ll only look closer at code
    if we haven’t gone over it before or if, for some reason, we make a change to
    previously explained code. We are going over `InteractionTrigger.cs`, which can
    be found in the *Assets/Scripts* folder of the project’s GitHub. If you haven’t
    set up GitHub yet, please refer to the start of this book for instructions on
    how to do so. When implementing something for the first time, there may be some
    key areas that you couldn’t design for, so it’s a good idea to work through some
    visual debugging code to make it easier for you. We want to implement a simple
    cube that, when you enter it, you can interact with. unclear wording and noticing
    when we interact with it. The way we do this is by using some colors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一些代码。与**第4章**，**角色**一样，我们不会逐行检查每一行代码——只有在我们之前没有检查过或者由于某种原因对之前解释过的代码进行了更改时，我们才会仔细查看代码。我们正在查看`InteractionTrigger.cs`，它可以在项目的*Assets/Scripts*文件夹中找到。如果您还没有设置GitHub，请参阅本书的开头部分，了解如何设置GitHub的说明。在第一次实现某事时，可能有一些关键区域您无法设计，因此通过一些视觉调试代码来工作是一个好主意，这样可以使您更容易实现。我们想要实现一个简单的立方体，当您进入它时，您可以与之交互。通过使用一些颜色来识别不清的措辞和注意到我们与之交互的方式。
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We define these in the beginning so we can reference them when we define the
    states a bit later. We are using the input action `interact` from the input system
    we defined in *Chapter 4*, *Characters*. In this case, we need to pay attention
    to that input, so we put it on `Update`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开头定义这些，以便稍后定义状态时可以引用它们。我们使用来自我们在**第4章**，**角色**中定义的输入系统的输入动作`interact`。在这种情况下，我们需要注意这个输入，所以我们将其放在`Update`上。
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The input here is either 0 or 1, but we want to use it as a bool. This allows
    us to make simple `if` checks when we want to change the state. To do this, we
    ask if the value is above 0\. If the assigned interaction button is being pressed,
    the value is 1, which sets `interactPressed` to `true`; otherwise, it’s set to
    `false`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输入是0或1，但我们要将其用作布尔值。这允许我们在想要改变状态时进行简单的`if`检查。为此，我们检查值是否大于0。如果分配的交互按钮正在按下，则值为1，这将`interactPressed`设置为`true`；否则，它被设置为`false`。
- en: In the next sections, we are going to use some `MonoBehaviour` methods that
    we haven’t gone over yet. These are `OnTriggerEnter`, `OnTriggerStay`, and `OnTriggerLeave`.
    As the names suggest, these methods are useful for dealing with collision states
    for when something enters, stays, or leaves a collision box.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将使用一些我们还没有讨论过的`MonoBehaviour`方法。这些是`OnTriggerEnter`、`OnTriggerStay`和`OnTriggerLeave`。正如名称所暗示的，这些方法在处理进入、停留或离开碰撞盒的碰撞状态时非常有用。
- en: We will start with `OnTriggerEnter`. We are only using this to set the color
    of the box so that we can see that we have entered it. This isn’t mechanically
    useful, but it is visually helpful. Maybe later on during the polishing stage,
    we may want to spawn some particles or change some lights to show the player that
    they are in an area that can be interacted with. For now, let’s just change the
    color of the cube’s material for the visual debugging.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`OnTriggerEnter`开始。我们只使用这个来设置盒子的颜色，这样我们就可以看到我们已经进入了它。这从机械上讲没有用处，但从视觉上是有帮助的。也许在后续的抛光阶段，我们可能想要生成一些粒子或改变一些灯光，以向玩家显示他们处于可以交互的区域。现在，让我们只改变立方体材质的颜色来进行视觉调试。
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What’s happening here is that when the player collides with the box’s collision
    box, we are looking to see if the other component that made the collision has
    `MyvariThirdPersonMovement` script. Since no other item that can collide should
    have that component, this is a good check. We assign that to the `player` variable
    and then do a small check asking if the `player` value isn’t `null`, then change
    the color to the occupied color. Now we need to work through `OnTriggerStay`,
    which will be where we allow the player to interact with this previously collided-with
    object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，当玩家与盒子的碰撞盒发生碰撞时，我们正在查看是否碰撞的另一个组件具有`MyvariThirdPersonMovement`脚本。由于没有其他可以碰撞的项目应该具有该组件，这是一个很好的检查。我们将它分配给`player`变量，然后进行一个小检查，询问`player`值是否不是`null`，然后将颜色更改为占用颜色。现在我们需要处理`OnTriggerStay`，这将是我们允许玩家与之前碰撞过的对象交互的地方。
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should all look similar to the enter trigger until we get to the `if`
    block that is waiting for the interact button to be pressed. When the interact
    button is pressed, we do a few things:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达等待交互按钮被按下的`if`块之前，所有这些都应该看起来与进入触发器相似。当按下交互按钮时，我们会做几件事：
- en: Set the color to an interact color
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将颜色设置为交互颜色
- en: Invoke an action
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个动作
- en: Log it out for another debug check
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登出以进行另一个调试检查
- en: Disable it so we can’t interact with it again
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用它，这样我们就不可以再次与之交互
- en: We’ve already set a color previously, so this should seem familiar. We are using
    the interact color instead here, which also makes sense!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经设置了一种颜色，所以这里应该看起来很熟悉。我们在这里使用的是交互颜色，这也很有道理！
- en: The next portion is invoking an action. This has a bit of a two-part explanation.
    Our manager will be listening for the action to be invoked. When we get to our
    manager, we will go over how this works fully. For now, understand that another
    item will be waiting for a signal to enact the action fully.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是调用一个动作。这有两个部分的解释。我们的管理器将监听动作被调用的信号。当我们到达管理器时，我们将全面介绍这是如何工作的。现在，理解另一个项目将等待一个信号来完全执行动作。
- en: We set debugging to the console so we can see what is happening in the logic.
    When we remove the debugging color, the console debug will be our guide if there
    is a bug in the future.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调试设置为控制台，这样我们就可以看到逻辑中发生了什么。当我们移除调试颜色时，控制台调试将成为我们未来遇到bug时的指南。
- en: The last part is to disable it so we can’t interact with it again. We need to
    disable both the object and the collider. We’re doing this as this interaction
    only needs to be pressed once per side.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是禁用它，这样我们就不可以再次与之交互。我们需要禁用对象和碰撞器。我们这样做是因为这种交互只需要在每一侧按一次。
- en: That’s it! We now need to go over the stair blocker before we get into the manager.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在我们进入管理器之前，我们需要检查楼梯阻挡器。
- en: Stair blocker
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 楼梯阻挡器
- en: We know that there will be an effect to blocking the stairs beyond, but we have
    finished up the look of this blocking mechanism. For now, it is a debugging red
    block with a collider. This isn’t a problem, as we know how we want the experience
    to play out, so we need to make a blocker that just doesn’t allow the player through
    to the stairs yet. We will add the visual portion of that later in *Chapter 12*,
    *Final Touches*. This could be in the form of the stairs being flat so that the
    player can’t walk up to them, and we make it look slippery, or maybe there can
    be a rock obstructing the stairs that disappears after the right interaction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这将阻止楼梯的进一步效果，但我们已经完成了这种阻挡机制的外观。目前，它是一个带有碰撞器的调试红色方块。这不是问题，因为我们知道我们想要体验如何进行，所以我们需要制作一个阻挡器，它不允许玩家通过到达楼梯。我们将在*第12章，最终润色*中添加这个视觉部分。这可能表现为楼梯是平的，玩家无法走上它们，我们使其看起来很滑，或者可能有一个岩石阻挡楼梯，在正确交互后会消失。
- en: There isn’t any scripting to be done here. We will be offloading any logic for
    this onto the manager. One of the reasons why we need to have this manager is
    that we cannot have a script on the stairs themselves to turn themselves on or
    off. If you have a GameObject that is disabled, the scripts won’t be able to be
    activated without some outside object with its reference to the disabled GameObject
    enabling it. So we need to do this with the manager. Let’s do that now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要编写脚本。我们将把任何逻辑都卸载到管理器上。我们需要这个管理器的一个原因是，我们不能在楼梯本身上放置脚本来自动开启或关闭。如果你有一个禁用的GameObject，脚本将无法在没有一些外部对象（该对象具有对禁用GameObject的引用）启用它的前提下被激活。所以我们需要通过管理器来做这件事。现在让我们来做吧。
- en: Interaction manager
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交互管理器
- en: Stitching together scripts is much easier if you have a parent object for interactive
    items in a manager of sorts. In the editor, this is often done by creating a prefab
    that the parent prefab houses a script to hold the state of the interaction. What
    we are doing here is making sure that the stairs cannot be turned on without both
    buttons being pressed. It would be difficult for this to be done without a GameObject
    knowing the state of each item. Getting into the code, we define our public variables
    and class variables to set up as we normally do, and then we get into the second
    part of the events we talked about in the *Interaction block* section. In the
    `Awake` and `OnDestroy` sections, we need to handle the events listening.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在某种管理器中为交互项有一个父对象，那么将脚本拼接在一起会容易得多。在编辑器中，这通常是通过创建一个父预制体来完成的，该预制体包含一个脚本以保持交互的状态。我们在这里所做的确保楼梯在没有两个按钮都按下时不能被打开。如果没有
    GameObject 知道每个项目的状态，这将很难完成。进入代码，我们定义我们的公共变量和类变量，就像我们通常做的那样设置，然后我们进入我们之前在 *交互块*
    部分讨论的事件的第二部分。在 `Awake` 和 `OnDestroy` 部分中，我们需要处理事件监听。
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We defined each of our triggers publically and they both have their own events.
    On `Awake`, we listen to the `OnInteract` event, and if it’s invoked, we will
    then run the function that is the argument of the listener. In this case, it’s
    `OnLeftTriggerInteract` for the left side. The one for the right side is similarly
    named. We’re only going to look in detail at the left side as the right side is
    very similar.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公开定义了每个触发器，并且它们都有自己的事件。在 `Awake` 中，我们监听 `OnInteract` 事件，如果它被调用，我们将运行作为监听器参数的函数。在这种情况下，对于左侧是
    `OnLeftTriggerInteract`。右侧的类似命名。我们只将详细查看左侧，因为右侧非常相似。
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the left side gets triggered, we immediately set `leftTriggerFired` to `true`.
    That checks if the right side has been triggered already. If it hasn’t been, then
    nothing happens. If it has, then we will set `stairsRaised` to `true`, invoke
    another action, set the stair blocker GameObject to not active, and log out a
    string to help with later debugging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧被触发，我们立即将 `leftTriggerFired` 设置为 `true`。这会检查右侧是否已经被触发。如果没有，则不会发生任何事情。如果已经触发，那么我们将
    `stairsRaised` 设置为 `true`，调用另一个动作，将楼梯阻隔的 GameObject 设置为非活动状态，并记录一个字符串以帮助后续调试。
- en: The `OnStairsRaised` `UnityAction` will fire, but there isn’t anything attached
    to this yet. After we finish up this area and finalize what exactly we need, we
    will add more to this action.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStairsRaised` `UnityAction` 将会被触发，但目前还没有任何东西附加到这个动作上。在我们完成这个区域并确定确切需要什么之后，我们将添加更多到这个动作中。'
- en: Interestingly, this setup allows the player to start from the left or the right
    without problems. It also sets us up for future development. We don’t need to
    have everything laid out, but we do need to have an understanding of what the
    general idea is so we can write the architecture accordingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个设置允许玩家从左侧或右侧开始而不会出现问题。它也为我们未来的开发奠定了基础。我们不需要把所有东西都安排好，但我们确实需要理解总体想法，这样我们才能相应地编写架构。
- en: This completes the current implementation of the stairs puzzle. Now that Myvari
    is up the stairs, we need to work through our first main puzzle, the rings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了当前楼梯谜题的实现。现在 Myvari 已经上了楼梯，我们需要解决我们的第一个主要谜题，即环状谜题。
- en: The rings
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环状物
- en: Passing through the stairs, we’re now faced with a door and rings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过楼梯，我们现在面对一扇门和环状物。
- en: The door signifies the first narrative-driven answer to the puzzle versus lighting
    drawing them to an area. The puzzle will only be able to be figured out if you
    pay attention to the image on the door and correlate it to the puzzle rings. Let’s
    break down the design of the Rings puzzle.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这扇门象征着对谜题的第一个以叙事驱动的答案，而不是通过灯光引导它们到一个区域。只有当你注意门上的图像并将其与谜题环相关联时，才能解开这个谜题。让我们分析一下环状谜题的设计。
- en: Design
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: The first puzzle the player will need to work through is the rings. When you
    get onto the platform of the puzzle, your necklace will animate in front of you
    and both the necklace and the middle pillar will glow a soft blue before fading.
    On the door, there will be a time-worn inscription of what the pillars should
    look like if manipulated properly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要解决的第一个谜题是环状谜题。当你进入谜题的平台时，你的项链会在你面前动画化，项链和中间的柱子会先发出柔和的蓝色光芒，然后逐渐消失。在门上，将有一个时间久远的铭文，描述如果正确操作，柱子应该是什么样子。
- en: What the player needs to do is push the pillars in the rings to match an image
    of the celestial bodies found on the door. This allows for multiple levels of
    research and interaction within a small scene. The player already knows that there
    is interaction within the environment from the hints given previously, and a small
    outline will indicate the button to press to interact with the pillars. The new
    information gathering would be the shape of the imagery in the door to fit the
    shape of the ground. *Figure 6.3* shows a concept of the area. The big blank area
    at the back is the door. The pillars are within the circles outside the middle
    pillar. There are three rings in all.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要做的是推动环中的柱子，以匹配门上找到的星体图像。这允许在小场景中进行多层次的科研和互动。玩家已经从之前给出的提示中知道环境中存在互动，一个小轮廓将指示按下按钮与柱子互动。新的信息收集将是门上图像的形状以适应地面的形状。*图6.3*展示了该区域的概念。后面的一个大空白区域是门。柱子位于中间柱子外的圆圈中。总共有三个环。
- en: '![](img/B17304_06_03.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17304_06_03.png)'
- en: 'Figure 6.3: The Rings and environmental research puzzle'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：环与环境研究谜题
- en: Working through this puzzle will open the door, but time has not been kind to
    this door or the area surrounding the ruins in general. When it tries to open,
    there is debris that collapses within the hallways leading further into the cave.
    We will take this opportunity to work through another simple interaction, which
    is navigating tight spaces.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个谜题将打开门，但时间对这个门或周围废墟区域并不友好。当尝试打开时，走廊中有碎片会倒塌，进一步通向洞穴。我们将利用这个机会解决另一个简单的互动，即穿越狭窄的空间。
- en: Implementation
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: We thought a lot about how we would put this one together. Two pillars on either
    side of each ring. Three rings in total. We needed a certain configuration to
    end with that would fit our design ideas of a constellation as well. Another problem
    with this is how to deal with Myvari moving these things. At first, we thought
    of pushing and pulling, but to make things simpler, we went with pushing only.
    This allowed us to only worry about rotating in one direction as well as cutting
    out an animation. Myvari isn’t a large character and pulling might not make much
    sense. We need to come up with two scripts. The first script will look similar
    to the one for visual volumes we worked with previously. We will use this to tell
    which side of a pillar Myvari is on. This tells us which way to rotate it. After
    we have it rotated to the correct position, we need to have a puzzle manager to
    know where to initially place the pillars, what the victory rotation value looks
    like, and how to deal with the ending of the puzzle. Let’s run through the easy
    one first and look at the puzzle trigger volumes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们思考了很多如何组合这个项目。每个环两侧各有一个柱子。总共有三个环。我们需要一个特定的配置来结束，这将符合我们的星座设计理念。这个问题还有一个是如何处理Myvari移动这些物体。起初，我们考虑了推和拉，但为了简化，我们选择了只推。这允许我们只关注一个方向的旋转以及切割动画。Myvari不是一个大角色，拉可能没有太多意义。我们需要想出两个脚本。第一个脚本将类似于我们之前一起工作的视觉体积脚本。我们将使用这个来告诉Myvari在柱子的哪一侧。这告诉我们旋转的方向。在我们将其旋转到正确的位置后，我们需要有一个谜题管理器来知道最初放置柱子的位置，胜利旋转值看起来像什么，以及如何处理谜题的结束。让我们先看看简单的那个，并查看谜题触发体积。
- en: Puzzle triggers
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 谜题触发器
- en: This item is simple. We need a box that we will change colors for debugging,
    just as previously had for the stairs, and then we need to have a few choices
    that are properties in the inspector that we get to choose before the game starts.
    These choices (outer, middle, and inner) will be which ring they are located on
    and which direction they should move. The direction is counterclockwise or clockwise.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目很简单。我们需要一个盒子，我们将为调试而改变它的颜色，就像之前为楼梯所做的那样，然后我们需要在游戏开始前有一些选择，这些选择是检查器中的属性。这些选择（外圈、中圈和内圈）将是它们所在的环以及它们应该移动的方向。方向是逆时针或顺时针。
- en: Even though we’ve seen it before, in this implementation of color changing,
    we did something a little bit different that involves the puzzle accessing a method
    of this class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前已经见过，但在这种颜色变化实现中，我们做了一些不同的事情，涉及到谜题访问这个类的方法。
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Something to notice here is the public access modifier. It takes in a color.
    Remember this when we go over the manager of the puzzle script right after this.
    Next, there are two defined enums. We will put them both below: `FirstPuzzleTriggerType`
    and `FirstPuzzleTriggerDirection`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个细节是公共访问修饰符。它接受一个颜色。记住这一点，当我们接下来讨论谜题脚本的管理器时。接下来，定义了两个枚举。我们将它们都放在下面：`FirstPuzzleTriggerType`和`FirstPuzzleTriggerDirection`。
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve made public enums in the top portion of this class and here we are defining
    them. These definitions will allow us to choose the ring and direction for each
    trigger. Look below at *Figure 6.4* to see an example of what the enum looks like
    in the inspector.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类的顶部部分公开了枚举，并且在这里定义了它们。这些定义将允许我们为每个触发器选择环和方向。请看下面的*图6.4*，以了解枚举在检查器中的样子。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_06_04.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B17304_06_04.png)'
- en: 'Figure 6.4: Display of a public enum in the inspector'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：检查器中公共枚举的显示
- en: If you were to select either of these, they would display the options that are
    seen in the code above. One more small detail in the code is the first value in
    the enum, which we are assigning as 0\. This will happen by default; however,
    making it explicit may be a good habit to get into. When someone looks at this
    code, they know for sure that the enum value will start at 0.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择其中任何一个，它们都会显示上面代码中看到的选择项。代码中的一个额外细节是枚举中的第一个值，我们将其赋值为0。这将是默认行为；然而，明确地这样做可能是一个好习惯。当有人查看这段代码时，他们可以确信枚举值将从0开始。
- en: The Puzzle pieces
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 谜题碎片
- en: Open the `FirstPuzzle.cs` file that is in the `scripts` folder and attached
    to the `FirstPuzzle` GameObject in the hierarchy. We start as we always do by
    defining the variables we want to use. For this puzzle manager, it needs to have
    a reference to each transform of the pillar sections, the center pillar, which
    takes care of finalizing the puzzle, and the properties of the puzzle’s timing.
    Directly after the public variables that we will assign in the inspector, we have
    quite a few variables that are not public but are assigned and used within the
    class’ logic. Take a few moments to read over the comments on them. We will be
    referencing those class variables throughout the rest of this section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`scripts`文件夹中并附加到层次结构中`FirstPuzzle`游戏对象的`FirstPuzzle.cs`文件。我们像往常一样开始，定义我们想要使用的变量。对于这个谜题管理器，它需要有一个对支柱部分每个变换的引用，中心支柱，它负责完成谜题，以及谜题的时间属性。在我们在检查器中分配的公共变量之后，我们有一些不是公共的变量，但它们在类的逻辑中被分配和使用。花几分钟时间阅读它们的注释。我们将在本节的其余部分引用这些类变量。
- en: Though we’ve seen this a few times, this is a larger piece of the definition
    than we’ve seen previously. We will pull in the whole initialization and go over
    each piece.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经见过几次，但这比我们之前看到的定义更大。我们将引入整个初始化过程，并逐一讲解。
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Regarding the `MonoBehaviour` class we’re inheriting from, we are using the
    `Start` method to initialize the cache references and starting positions of the
    pillars when the game starts. First off, we need to cache the references to each
    trigger volume. We are using a `UnityEngine.Component` method that we have available
    due to us having a `using` `UnityEngine;` directive at the top of this file. This
    is `GetComponentsInChildren<FirstPuzzleTrigger>();`. The type that is used in
    this is called a generic type. You could place any type in the place of `FirstPuzzleTrigger`,
    in the code above. This could be `Image` or `Transform`. In this case, we only
    want to grab each trigger. We will clarify why we need them in this manner shortly.
    Just know that they are all in a bucket waiting to be called.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们继承的`MonoBehaviour`类，我们在游戏开始时使用`Start`方法初始化支柱的缓存引用和起始位置。首先，我们需要缓存每个触发器体积的引用。我们使用一个`UnityEngine.Component`方法，这是由于我们在文件顶部有`using
    UnityEngine;`指令。这个方法是`GetComponentsInChildren<FirstPuzzleTrigger>();`。在这个方法中使用的是一种称为泛型类型。你可以在代码中将任何类型放在`FirstPuzzleTrigger`的位置。在上面的代码中，这可以是`Image`或`Transform`。在这种情况下，我们只想获取每个触发器。我们将在稍后解释为什么我们需要以这种方式获取它们。只需知道它们都在一个桶里，等待被调用。
- en: Next, we need to use `FindObjectOfType`, which is another `UnityEngine` method,
    but it’s on the `Object` class. It’s part of the `UnityEngine` library and we’re
    already requesting access to its methods. It’s going to find the character controller
    and return it to the `playerController` variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`FindObjectOfType`，这是另一个`UnityEngine`方法，但它位于`Object`类上。它是`UnityEngine`库的一部分，我们已经在请求访问其方法。它将找到角色控制器并将其返回到`playerController`变量。
- en: The next three lines are for setting the rotation of the rings. We wanted them
    to be unique, so if someone played the game more than once, it would be a little
    bit different each time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行用于设置环的旋转。我们希望它们是独特的，所以如果有人玩过游戏多次，每次都会有一点不同。
- en: Finally, we have the position of the puzzle being set. We are using this line
    to set the height of the center spire. After the puzzle is completed, the center
    spire will raise up to be interacted with. This will move you on to the next section.
    We wanted this to be animated as you completed the puzzle to reveal the way forward.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置了拼图的位置。我们使用这一行来设置中心尖塔的高度。拼图完成后，中心尖塔将升起以便交互。这将带你进入下一个部分。我们希望它在完成拼图时动画化，以揭示前进的道路。
- en: We’re going to now move on to the `Update` method. This is again from `MonoBehaviour`.
    The interesting thing about this puzzle is that there are a lot of points where
    we don’t do much. We mostly just need to wait until the character moves the pillars
    into the right positions. The way that we are running the update section is like
    a lock system in a waterway. You must finish the first step to get to the next
    step. We have a very simplified logic flow for this system. You can see it in
    *Figure 6.5*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续到`Update`方法。这同样来自`MonoBehaviour`。这个拼图的有趣之处在于有很多地方我们并没有做什么。我们主要只需要等待角色将支柱移动到正确的位置。我们运行更新部分的方式就像水道中的锁系统。你必须完成第一步才能进入下一步。我们为这个系统有一个非常简化的逻辑流程。你可以在*图6.5*中看到它。
- en: '![Diagram  Description automatically generated](img/B17304_06_05.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17304_06_05.png)'
- en: 'Figure 6.5: Basic lock flow for the puzzle manager'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：拼图管理器的基本锁流程
- en: Let’s keep *Figure 6.5* in mind while we finish up the puzzle manager. The first
    step here is to check for victory. Let’s dig into that process block. Victory
    is dependent on all three pillars being closely enough aligned to the desired
    rotation values.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成拼图管理器时，让我们记住*图6.5*。这里的第一个步骤是检查胜利。让我们深入到这个流程块。胜利依赖于三个支柱足够紧密地与期望的旋转值对齐。
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’re checking every frame for the right alignment. Because we are checking
    the alignment for three separate items, we shouldn’t write the code on all three
    rings. Let’s write it once and then ask it to refer to a method for each pillar
    instead. This is called refactoring. Digging in even further, we should break
    down how it checks for alignment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每帧都在检查正确的对齐。因为我们正在检查三个独立项目的对齐，所以我们不应该在所有三个环上写代码。让我们写一次，然后让它为每个支柱调用一个方法。这被称为重构。进一步挖掘，我们应该分解它是如何检查对齐的。
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we need it to return a bool. This is very helpful when you want to run
    a conditional against the response. We’re asking for the current pillar and the
    correct rotation value. We look at the absolute value of the current rotation
    in the *y* value minus the correct rotation. We take that value and check if it’s
    less than the threshold we’re allowing for “closeness.” If it is, then `outerAligned`
    will return `true`. If all three pillars are returning `true`, then `CheckForVictory`
    will return `true`, which allows us to move on to the next block in our lock.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要它返回一个布尔值。当你想要对响应运行条件时，这非常有帮助。我们要求当前的支柱和正确的旋转值。我们查看当前旋转在*y*值上的绝对值减去正确的旋转值。我们取这个值并检查它是否小于我们允许的“接近”阈值。如果是，那么`outerAligned`将返回`true`。如果所有三个支柱都返回`true`，那么`CheckForVictory`将返回`true`，这允许我们进入锁的下一个块。
- en: The next block is displaying victory. This seems like an innocent block that
    is just a display for debug; however, there is one small bit of logic in here
    that helps us with the end block.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个块是显示胜利。这似乎是一个无辜的块，只是用于调试的显示；然而，这里有一小段逻辑帮助我们处理结束块。
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These four values being set are important. We need to have set the values before
    we move on to the next block. We could potentially have this done in the final
    block; however, sometimes it’s a good idea to set up each bit of logic in a lock
    so that you can debug easily and know exactly where you are and what the data
    is that you need at that exact point in the logic. To finish the last block, we
    know that we need to record what the pillars’ current information is. We have
    tolerance as to where we need to place the pillars, so this doesn’t mean the puzzle’s
    solution is always the same. Now that we’ve stored values of the pillars and displayed
    our victory in the console for debug, we can move on to the final block.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个设置的值很重要。在继续到下一个块之前，我们需要设置这些值。我们可能已经在最后一个块中完成了这个操作；然而，有时在锁中设置每一点逻辑是一个好主意，这样你可以轻松调试，并确切地知道你在逻辑中的位置以及在那个确切点你需要的数据。为了完成最后一个块，我们知道我们需要记录柱子的当前信息。我们对柱子的放置位置有一定的容忍度，所以这并不意味着谜题的解决方案总是相同的。现在我们已经存储了柱子的值并在控制台显示胜利信息以供调试，我们可以继续到最后一个块。
- en: The final block is in the `PerformVictoryLerp` method. Take your time looking
    over the whole method. We will break down a single Lerp below. Interestingly,
    this method is mostly just animating some environmental items for a final piece
    and allowing us to finish the block, so we don’t check for rotations in this puzzle
    anymore.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的块位于 `PerformVictoryLerp` 方法中。花点时间仔细查看整个方法。我们下面会分解一个单独的 Lerp。有趣的是，这个方法主要只是为最终作品动画化一些环境物品，并允许我们完成这个块，所以我们在这个谜题中不再检查旋转。
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve seen something similar in the character with using the Slerp method. That
    one was better for spherical needs. The Lerp is a linear interpolation. You’re
    transforming a value to another value of the same type over a period. In this
    case, it’s the rotational values of the pillars to the predetermined end victory
    rotational values we need to get the pillars to, because there is a small amount
    of leeway we give to each section. It may feel daunting to work through this method.
    If you are feeling overwhelmed, just look at a single line and slowly work through
    it. Each line has a task and it’s providing context for the Lerp time, or it’s
    lerping itself to another value over that time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在具有使用 Slerp 方法的角色中看到过类似的情况。那个更适合球面需求。Lerp 是线性插值。你在一个时间段内将一个值转换到另一个相同类型的值。在这种情况下，它是柱子的旋转值到预定的最终胜利旋转值，因为我们对每个部分都给予了一小部分余量。处理这个方法可能会让你感到有些困难。如果你感到不知所措，只需查看一行，并慢慢地处理它。每一行都有一个任务，它提供了
    Lerp 时间或在该时间段内将自身插值到另一个值的上下文。
- en: We also have at the end a `PrintDebug` method outside of our lock system. This
    allows us to check for what’s going on in the puzzle at any given moment. Take
    some time to go over this method and surmise what it might show you, and then
    run the game to see if your assumptions are correct. Did something print in the
    console you didn’t expect? See if you can find it in the code by following the
    game’s logic and identifying when you saw the console message arrive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后，我们还有一个位于锁系统之外的 `PrintDebug` 方法。这允许我们在任何给定时刻检查谜题中正在发生的事情。花点时间研究这个方法，并推测它可能会显示什么，然后运行游戏以查看你的假设是否正确。控制台是否打印出了你意料之外的内容？尝试通过跟随游戏的逻辑并识别你看到控制台消息到达的时刻，在代码中找到它。
- en: The next questions that might come to mind are, “That’s a great way to do it,
    but how do we *actually* control it? Also, why didn’t we cover the `RotatePillar`
    method?” These are great questions! Let’s explore them in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现的下一个问题是，“这是一个很好的方法，但我们如何*实际上*控制它？还有，为什么我们没有涵盖 `RotatePillar` 方法？”这些问题都很棒！让我们在下一节中探讨它们。
- en: Puzzle control
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 谜题控制
- en: Should we have put the control on the puzzle trigger volume? Our thinking is
    that all control mechanisms should be on the object that’s containing the control.
    We made another script called `FirstPuzzleControl.cs` in the `scripts` folder,
    which will be attached to the `Character` GameObjects. This script is responsible
    for setting up the color of the trigger volume as well as calling the rotate from
    the `FirstPuzzle` class. We wrote it in this manner as we wanted to ensure the
    manager of the puzzle would oversee the rotation of each ring. Even if the character
    is the object initiating the `RotatePillar` method with input, the puzzle manager
    needs to rotate whichever pillar section the player is interacting with, as it
    owns those GameObjects. Thinking about it this way is a little unique. Try to
    imagine a manager owning the GameObjects and telling them what to do. We have
    them already being referenced in this script; we should keep them in this script.
    The other option would be to also reference them in the control script that is
    on the character, and then you have multiple references, and could potentially
    cause a bug that you may not see. Attempt to centralize your GameObjects in a
    single script that manages them as much as possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该将控制权放在谜题触发体积上？我们的想法是所有控制机制都应该放在包含控制的对象上。我们在 `scripts` 文件夹中创建了一个名为 `FirstPuzzleControl.cs`
    的另一个脚本，它将被附加到 `Character` GameObjects 上。这个脚本负责设置触发体积的颜色以及从 `FirstPuzzle` 类中调用旋转。我们以这种方式编写它，因为我们想确保谜题的管理员会监督每个环的旋转。即使角色是使用输入启动
    `RotatePillar` 方法的对象，谜题管理员也需要旋转玩家正在交互的任何柱子部分，因为它拥有那些 GameObjects。这样思考有点独特。试着想象一个拥有
    GameObjects 并告诉它们做什么的管理员。我们已经在脚本中引用了它们；我们应该将它们保留在这个脚本中。另一种选择是将它们也引用到角色上的控制脚本中，然后你就有多个引用，可能会引起你无法看到的错误。尽量将
    GameObjects 集中在单个脚本中，尽可能多地管理它们。
- en: The `RotatePillar` method is slightly tricky. In this method, we need to not
    only rotate the rings, but also need to push the character along with it as well.
    How are we doing this? Let’s look into it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotatePillar` 方法稍微有些棘手。在这个方法中，我们不仅需要旋转环，还需要将角色与其一起推动。我们是如何做到这一点的呢？让我们来看看。'
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first need to know how far we’re going to rotate the pillar GameObjects.
    We’re going to assign the rotation angle to a variable in the method’s scope.
    We will use ternary to tell if it’s clockwise or counterclockwise and multiply
    by `deltatime` to deal with framerate changes. Then we will rotate the item using
    `parent.parent.Rotate` along its `up` vector. The rotation angle and direction
    are decided on the line above, defined as `rot`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要知道我们将旋转柱子 GameObjects 多远。我们将在方法的范围内将旋转角度分配给一个变量。我们将使用三元运算符来判断是顺时针还是逆时针旋转，并将其乘以
    `deltatime` 来处理帧率变化。然后我们将使用 `parent.parent.Rotate` 沿其 `up` 向量旋转项目。旋转角度和方向在上面的行中定义，称为
    `rot`。
- en: One problem is that the character needs to move along with the pillar they are
    interacting with. The second problem is that the pillar rotates, so we need to
    face the character toward the pillar she’s pushing. To do this, we will turn off
    the player’s ability to move and then directly manipulate the character to the
    trigger’s location and then keep her there while the interact button is held down.
    We will also point the character toward the pillar using the trigger volume’s
    `forward vector`. In the end, we will transfer control back to the player. This
    makes it so that the character doesn’t get stuck pushing the pillar forever.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是角色需要与它们交互的柱子一起移动。第二个问题是柱子会旋转，因此我们需要将角色面向她推动的柱子。为此，我们将关闭玩家的移动能力，然后直接将角色移动到触发器的位置，并在按下交互按钮时保持她在那里。我们还将使用触发体积的
    `forward vector` 将角色指向柱子。最后，我们将控制权交还给玩家。这使得角色不会永远卡在推动柱子。
- en: That is it! We just made our first puzzle. What happens next after solving this
    puzzle is that the door tries to open, but it breaks a bit and only has a small
    space to move through. Let’s take some time to break down why this might be useful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们制作了第一个谜题。解决这个谜题之后会发生什么？门试图打开，但稍微断裂，只有一个小空间可以移动。让我们花点时间分析一下这可能会很有用。
- en: Tight spaces
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 狭窄的空间
- en: There are times when your game needs to load the next scene, but you may not
    want the loading screen to pull your player out of the immersion, or you may just
    want to add some environmental tension. Possibly you want to achieve both! Tight
    spaces is a common tool to use to achieve either of these situations. Let’s go
    through how we’re using tight spaces in our work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你的游戏需要加载下一个场景，但你可能不希望加载屏幕将你的玩家从沉浸感中拉出来，或者你可能只是想增加一些环境紧张感。可能你想要两者兼得！狭窄的空间是达到这些情况的一个常用工具。让我们来看看我们如何在我们的工作中使用狭窄空间。
- en: Design
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: The concept of tight spaces is an interesting design use. We are using it in
    two ways. The first way is to add some tension to the exploration and movement.
    You have a character who must get through a space that is very narrow that she
    just watched collapse into place.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 狭窄空间的概念是一个有趣的设计用途。我们以两种方式使用它。第一种方式是增加探索和移动的紧张感。你有一个角色必须穿过一个非常狭窄的空间，她刚刚看到它塌陷到位。
- en: The second point is that this is a common design used for transitioning. Since
    we are only using this design concept on a small vertical of the game and we do
    not need to load multiple parts of the map, it isn’t needed for that reason, but
    it is a good teaching point to you, the aspiring designer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，这是一个常用的设计，用于过渡。由于我们只在这个游戏的小垂直部分上使用这个设计概念，而且我们不需要加载地图的多个部分，因此从这个原因来看，它不是必需的，但它对你这个有抱负的设计师来说是一个很好的教学点。
- en: This helps with setting expectations for the player, letting them know that
    there will be slow-moving sections with tight animation and the camera close to
    the player to push up the intensity. While this longer animation and movement
    is happening, it will give time for the system to load into memory the next area
    without a loading screen. This trick is great as it doesn’t hurt the immersion
    while allowing for detail to be retained. Nothing breaks the suspension of disbelief
    more than watching objects load into existence in front of you. After you finish
    working your way through the closed-off space, the rocks will fall naturally and
    close off the hallway. Not only does this stop any backward movement, but this
    also gives a feeling of necessity to move forward.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于为玩家设定期望，让他们知道将会有缓慢移动的部分，动画紧密，摄像机靠近玩家以增加紧张感。当这种较长的动画和动作发生时，系统将有时间将下一个区域加载到内存中，而无需加载屏幕。这个技巧很棒，因为它不会破坏沉浸感，同时允许保留细节。没有什么比在你面前看到物体加载成实体更能打破你的信念了。在你完成穿越封闭空间的工作后，岩石会自然落下，封闭通道。这不仅阻止了任何后退动作，还给人一种向前移动的必要性。
- en: Implementation
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: 'The initial implementation of this is simple. We will make a Cinemachine camera
    move through the spaces to get the sense of timing needed for the cinematic while
    not allowing the player any inputs. We do this starting implementation through
    code as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的初始版本很简单。我们将让Cinemachine摄像机穿过空间，以获得电影所需的时机感，同时不允许玩家有任何输入。我们通过以下代码进行这种初始实现：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to find the virtual cameras in the children and enable them while also
    disabling the player character. In *Chapter 12*, *Final Touches*, we will call
    this code when we trigger the cinematic. But instead of the virtual cameras that
    are in the children, we will call the camera made for the cinematic.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在子对象中找到虚拟摄像机，并在启用它们的同时禁用玩家角色。在*第12章*，*最终润色*中，当我们触发电影时，我们将调用此代码。但我们将调用为电影制作的摄像机，而不是子对象中的虚拟摄像机。
- en: This implementation works very well for setting up the logic, without worrying
    about the nuance of each cinematic, which is very time- and animation-intensive.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现非常适合设置逻辑，无需担心每个电影的细微差别，这非常耗时和动画密集。
- en: Interactive volumes
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式体积
- en: This is the Swiss Army knife of mechanics. There are so many uses of interactive
    volumes that we can’t cover them all in this book. This would also not make much
    sense as defining this takes away from the creativity that could be designed.
    This is not a tool that should be detailed in high granularity. Instead, let’s
    go over how we will use it as well as some thoughts on it in general.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是机械领域的瑞士军刀。交互式体积的用途如此之多，我们无法在这本书中全部涵盖。这也并不合理，因为定义它会削弱可能设计的创造力。这不是一个应该在高粒度上详细说明的工具。相反，让我们来看看我们将如何使用它，以及一些关于它的总体想法。
- en: Design
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'As this is an adventure puzzle game, there will be points at which we need
    volumes where, when the character enters them, something happens. This definition
    is purposely broad. We are also using Cinemachine for our character’s main camera.
    This allows us to link up virtual cameras in certain places when you trigger your
    volumes. Here are some examples of what we can perform with interactive volumes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个冒险解谜游戏，会有一些需要体积的地方，当角色进入时，会发生某些事情。这个定义是故意很宽泛的。我们也在使用Cinemachine作为我们角色的主摄像机。这允许我们在触发体积时在某些地方连接虚拟摄像机。以下是一些我们可以使用交互式体积执行的示例：
- en: Moving the camera over a cliff to give a sense of heightened anxiety
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将摄像机移过悬崖，以产生更高的焦虑感
- en: Triggering rocks to fall
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发岩石坠落
- en: Changing the walking animation to be slower when you walk through water
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你穿过水时，改变行走动画以变得更慢
- en: Changing the lighting in an environment
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变环境中的照明
- en: Spawning GameObjects
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 GameObjects
- en: This list is not exhaustive by any means, as volumes are a creative tool to
    allow for interaction. We’re using them in only a few ways, but the possibilities
    are endless. Let your imagination run wild while designing with interactive volumes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表绝不是详尽的，因为体积是一种创意工具，允许进行交互。我们只以几种方式使用它们，但可能性是无限的。在设计时，让您的想象力自由驰骋，使用交互式体积。
- en: This is powerful for many games to have, especially for us, with our environment-driven,
    research-focused mechanics. Our interactions require the environment to explain
    to the player what is going on and how to move forward. In the scripting section
    below, we will go through each interactive volume for this chapter. You can expect
    to see more volumes being used in future chapters, especially in the polishing
    phase as we can enhance the experience with many small interactions. This will
    help to make the environment and gameplay immersive.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多游戏来说，这很强大，尤其是对于我们来说，因为我们有以环境驱动、研究为重点的机制。我们的交互需要环境向玩家解释正在发生的事情以及如何前进。在下面的脚本部分，我们将逐一介绍本章的每个交互式体积。你可以期待在未来的章节中看到更多体积的使用，尤其是在抛光阶段，因为我们可以通过许多小的交互来增强体验。这将有助于使环境和游戏玩法更具沉浸感。
- en: Implementation
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: Luckily for us, you’ve seen two versions of interactive volumes. Look back up
    in the implementations of what we looked at earlier and pay close attention to
    the volumes. They are unique in their uses and can teach you some valuable lessons
    about developing in an environment without all the art assets being completed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你已经看到了交互式体积的两个版本。回顾一下我们之前查看的实现，并仔细注意体积。它们在用途上独特，可以教你一些关于在没有所有艺术资源完成的情况下开发环境的宝贵经验。
- en: It may be a good idea to also think about some other ways we could’ve used interactive
    volumes so far. Were there any volumes you may have wanted to add?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们到目前为止可能使用交互式体积的其他一些方法可能是个好主意。你有没有想要添加的体积？
- en: Why don’t we go over a bit of a summary of where we’re using them in our game?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不简要回顾一下我们在游戏中使用它们的地方？
- en: We’re using interactive volumes in any place where we can use an input action.
    An example of this might be the stairs buttons for accessing the stairs.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在可以使用输入动作的任何地方使用交互式体积。一个例子可能是用于访问楼梯的楼梯按钮。
- en: We’ve added a volume to know the player is in the zone of the first puzzle.
    This allows the camera to move to a more advantageous position to understand the
    puzzle visually.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个体积，以便知道玩家位于第一个拼图的区域内。这允许摄像机移动到一个更有利的位置，以便从视觉上理解拼图。
- en: Triggers on the puzzle pieces let you know you are close enough to interact
    with them.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拼图块上的触发器会让你知道你足够接近可以与之交互。
- en: There is a volume for you to be able to tell you’ve entered the trigger point
    for entry into the tight spaces.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个体积可以告诉你已经进入了进入狭窄空间的触发点。
- en: Crossing the bridge, there is a small volume to change camera angles for a more
    cinematic shot.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过桥时，有一个小体积可以改变摄像机角度，以获得更电影化的镜头。
- en: At the end of the bridge, there is a volume to trigger another tight space cinematic.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在桥的尽头，有一个体积可以触发另一个狭窄空间的 cinematics。
- en: While on a ledge, there is a trigger that unleashes a boulder to fall on you,
    whereupon you lift your arm up in defense. This will trigger you to discover a
    new power, which is a new mechanic.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在悬崖上时，有一个触发器会释放一块巨石落在你身上，这时你会举起手臂进行防御。这将触发你发现一种新的力量，这是一种新的机制。
- en: More triggers are used to open another door.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多触发器用于打开另一扇门。
- en: There are triggers on items that you can interact with using your telekinetic
    powers.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你可以使用心灵感应能力与之交互的物品上设置了触发器。
- en: There are triggers on the final puzzle pieces.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最终谜题碎片上设置了触发器。
- en: This is a summary of all the triggers that are part of our core gameplay. There
    are a few others that deal with ambient flora and fauna, but they are simple collision
    triggers responsible for small changes or the simple movement of birds or deer.
    They are in random locations for cosmetic purposes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们核心游戏玩法中所有触发器的总结。还有一些其他触发器与周围环境和生物有关，但它们只是简单的碰撞触发器，负责引起小的变化或鸟类或鹿的简单移动。它们位于随机位置，用于美观目的。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over the design and implementation of interactions
    and mechanics. Even though the player’s experiences and interactions seemed quite
    simple, the depth of design of player afforadances allowed the player to know
    their limits and navigate the gameplay. We spent a good amount of time talking
    about interactions and mechanics. We defined the game loops and broke down parts
    of the mechanics toolbox. This was a very quick and short lesson into various
    game experiences. Finally, we broke down a bit of our game.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了交互和机制的设计与实现。尽管玩家的体验和交互看起来相当简单，但玩家便利性的设计深度使得玩家能够了解自己的限制并导航游戏玩法。我们花了大量时间讨论交互和机制。我们定义了游戏循环并分解了机制工具箱的部分。这是一次非常快速而简短的关于各种游戏体验的介绍。最后，我们分解了我们的一些游戏。
- en: We broke down the stairs interaction and how that would be managed. We also
    went over why the stairs problem exists and where the solutions need to happen.
    Then, after that was completed, we went over the design of the first puzzle. After
    that was fully explained, we broke down our version of the implementation. Once
    this puzzle is completed, it’s followed by a tight space segment, which could
    be used for loading the rest of the level, if we were on a larger scale project.
    Finally, there was a small section on how to use interactive volumes. As we used
    two different types of interactive volumes in our previous implementation, we
    went over them as well.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了楼梯交互及其管理方式。我们还讨论了楼梯问题存在的原因以及解决方案需要发生的地方。然后，在完成这些工作之后，我们讨论了第一个谜题的设计。在详细解释之后，我们分解了我们的实现版本。一旦这个谜题完成，接下来是一个紧凑的空间段，如果我们是一个更大规模的项目，可以用来加载剩余的关卡。最后，有一小节介绍了如何使用交互体积。由于我们在之前的实现中使用了两种不同的交互体积，我们也对它们进行了讨论。
- en: Overall, this chapter was very dense in information. Take some time to pause
    here and digest what you have just learned. Even if you feel like you could move
    on, let’s just relax and let your brain process it all. In the next chapter, we
    will go over physics mechanics and interactions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这一章信息量很大。请在这里稍作停顿，消化一下你刚刚学到的内容。即使你觉得可以继续前进，也让我们放松一下，让大脑处理所有信息。在下一章中，我们将讨论物理力学和交互。
