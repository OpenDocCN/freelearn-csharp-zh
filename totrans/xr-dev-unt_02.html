<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-23"><a id="_idTextAnchor002"/>2</h1>
<h1 id="_idParaDest-24">The Unity Editor and Scene Creation</h1>
<p>In this chapter, we’ll lay the groundwork for your Unity journey. You’ll familiarize yourself with the Unity Editor, create a basic scene, and explore essential lighting aspects. We’ll cover installing Unity, navigating the Editor, working with <strong class="bold">GameObjects</strong>, importing assets, and experimenting with various lighting settings. By the end, you’ll have a solid foundation to delve deeper into Unity and create increasingly complex and captivating scenes.</p>
<p>We’ll cover the following topics as we proceed:</p>
<ul>
<li>Setting up the Unity development environment</li>
<li>Getting to know the Unity Editor and its interface</li>
<li>Understanding GameObjects and components</li>
<li>Creating a basic scene in Unity and adding objects</li>
</ul>
<h1 id="_idParaDest-25">Technical requirements</h1>
<p>Before diving into the Unity Editor, it is important to ensure that your system meets the minimum requirements to run Unity. To successfully complete the exercises in this chapter, you will require a personal computer that has <em class="italic">Unity 2021.3</em> LTS or a more recent version installed. To ensure your hardware meets the requirements, you can cross-check it on the Unity website (<a href="https://docs.unity3d.com/Manual/system-requirements.html">https://docs.unity3d.com/Manual/system-requirements.html</a>).</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor003"/>Setting up the Unity development environment</h1>
<p>First<a id="_idIndexMarker043"/> things first, let’s get Unity up and running on your development machine. Throughout this book, we’ll be harnessing the power of the Unity 3D game engine to create inspiring projects. Unity is an incredibly potent, cross-platform 3D development environment, complete with an intuitive and visually appealing editor.</p>
<p>If you<a id="_idIndexMarker044"/> have not yet installed Unity on your computer, we will guide you through the process. Following the installation, we’ll proceed to create our initial scene. Let’s begin the setup and exploration of Unity.</p>
<h2 id="_idParaDest-27">Installing the Unity Hub</h2>
<p>Over the <a id="_idIndexMarker045"/>course of this book, the <strong class="bold">Unity Hub</strong> will become your trusty command center for managing different Unity projects, Unity Editor versions, and modules. To initiate the installation process of the Unity Hub, follow these steps:</p>
<ol>
<li>Head over to the official Unity website (<a href="https://unity3d.com/get-unity/download">https://unity3d.com/get-unity/download</a>) and navigate to the latest version of the Unity Hub.</li>
<li>Follow the onscreen instructions to install Unity Hub.</li>
<li>With the Unity Hub installed, open it up and sign in using your Unity account. If you’re new to Unity, create an account to join the ranks of fellow creators.</li>
</ol>
<p>Without having the Unity Editor installed, the Unity Hub is just as powerful as a CD player without a CD. The next section covers how you can install the Unity Editor within the Unity Hub.</p>
<h2 id="_idParaDest-28">Installing the Unity Editor</h2>
<p>The <strong class="bold">Unity Editor</strong> is<a id="_idIndexMarker046"/> where the magic happens—a workspace for designing, building, and testing your game projects. To install it, follow these steps:</p>
<ol>
<li>Within the Unity Hub, navigate to the <strong class="bold">Installs</strong> tab and hit the <strong class="bold">Add</strong> button to add a new Unity Editor version.</li>
<li>Opt for the latest LTS version of the Unity Editor and click <strong class="bold">Next</strong> to kick off the installation process.</li>
<li>During installation, don’t forget to include the necessary platforms and modules tailored to your specific needs. Add the <em class="italic">Windows/Mac/Linux Build Support</em>, depending on the operating system of your PC. Likewise, select the <em class="italic">Android</em> or <em class="italic">iOS Build Support</em>, depending on the nature of your smartphone, so that you can follow along with the AR tutorials in this book. Lastly, if you are using a VR headset<a id="_idIndexMarker047"/> that runs on Android, such as the <em class="italic">Quest 2</em> or <em class="italic">Quest Pro</em>, be sure to add the <em class="italic">Android Build Support</em> module along with its sub-modules: <em class="italic">OpenJDK</em> and <em class="italic">Android SDK &amp; </em><em class="italic">NDK Tools</em>.</li>
</ol>
<p>As we have the Unity Editor installed, it is time to create a project.</p>
<h2 id="_idParaDest-29">Loading a sample scene as a new Unity project</h2>
<p>After<a id="_idIndexMarker048"/> installing the Unity Hub and the Unity Editor, it’s time to create a new Unity project. For the sake of simplicity, we will first use a sample scene. A sample scene in Unity is a pre-built scene created by Unity to show developers how various functions and techniques can be implemented. Unity offers a variety of sample scenes, ranging from simple 2D games to complex 3D environments, that can be used as a starting point for your own projects. The sample scenes can be downloaded via the Asset Store or directly from the Unity Hub. Here’s how to do that directly from the Unity Hub.</p>
<p><em class="italic">Figure 2</em><em class="italic">.1</em> shows a project’s creation within the Unity Hub.</p>
<div><div><img alt="Figure 2.1 – ﻿How to create a project with a sample scene in the Unity Hub" src="img/B20869_02_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – How to create a project with a sample scene in the Unity Hub</p>
<p>To load a <a id="_idIndexMarker049"/>sample scene as a new project, just go through the following steps:</p>
<ol>
<li>Open the Unity Hub and go to the <strong class="bold">Projects</strong> tab.</li>
<li>Click on the <strong class="bold">New</strong> button to create a new project.</li>
<li>Choose <strong class="bold">3D Sample Scene (URP)</strong>, give your project a name, and select a location to save it. For this project, we’ve opted for <strong class="bold">3D Sample Scene (URP)</strong> as it provides a preconfigured environment showcasing the capabilities of the <strong class="bold">Universal Render Pipeline</strong> (<strong class="bold">URP</strong>), ideal <a id="_idIndexMarker050"/>for those new to Unity or seeking a reference. While the standard <strong class="bold">3D (URP)</strong> template is typically favored by developers for its clean slate, allowing for a customized setup, they often enhance these projects by importing additional packages or assets via the Package Manager or Unity Asset Store.</li>
<li>Click on the <strong class="bold">Create</strong> button to create the project.</li>
</ol>
<p>Now that we’ve got that out of the way, let’s look at how to choose the right render pipeline.</p>
<h2 id="_idParaDest-30">Choosing the right render pipeline</h2>
<p>Upon<a id="_idIndexMarker051"/> examining the sample scene options, you might have noticed the choice between the URP and the <strong class="bold">High Definition Render Pipeline</strong> (<strong class="bold">HDRP</strong>). But <a id="_idIndexMarker052"/>which one is better, and what exactly is a render pipeline? In essence, a render pipeline is a <a id="_idIndexMarker053"/>sequence of steps and processes that dictate how the engine renders graphics. It transforms 3D assets, lighting, and other scene components into the final 2D image gracing your screen. While URP and HDRP share some low-level tasks, each pipeline is tailored to specific project needs and target platforms.</p>
<p><em class="italic">Table 2.1</em> shows how URP and HDRP stack up against one another:</p>
<div><div><img alt="Table 2.1 – A comparison between URP and HDRP" src="img/B20869_Table_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – A comparison between URP and HDRP</p>
<p>A comfortable VR experience demands high frame rates, typically exceeding 90 FPS. URP emphasizes performance, ensuring smooth frame rates across various VR devices, including standalone VR headsets, PC-based VR, and mobile VR. As the market sees a growing number of standalone VR headsets, URP proves invaluable for its adaptability and ease of project optimization.</p>
<p>While URP may not boast the visual prowess of HDRP, it strikes a balance between graphic quality and performance, making it suitable for the majority of VR projects where performance is crucial.</p>
<p>Unity’s versatility <a id="_idIndexMarker054"/>extends beyond HDRP and URP pipelines, allowing the creation of custom <strong class="bold">Scriptable Render Pipeline</strong> (<strong class="bold">SRP</strong>) pipelines <a id="_idIndexMarker055"/>for experienced graphics programmers. However, developing a custom SRP pipeline requires deep knowledge of 3D graphics<a id="_idIndexMarker056"/> programming, rendering pipelines, and C# language proficiency. For those lacking these skills, HDRP and URP offer an optimal balance between flexibility and ease of use.</p>
<p>Given its many advantages, URP emerges as the go-to choice for most VR endeavors. Throughout this book, we’ll focus exclusively on URP. However, HDRP remains a worthy contender for those pursuing high-end PC VR experiences.</p>
<p>With Unity installed, the render pipeline selected, and your project at your fingertips, it’s time to acquaint ourselves with the Un<a id="_idTextAnchor004"/>ity Editor.</p>
<h1 id="_idParaDest-31">Getting to know the Unity Editor and its interface</h1>
<p>If you’re new <a id="_idIndexMarker057"/>to Unity, the editor’s interface can be a bit overwhelming at first. But don’t worry—we’ll guide you through the Unity Editor and show you how to navigate its various menus and panels. Experienced users can also benefit from staying current with the latest best practices and techniques, as designing for VR presents unique challenges that may require a different approach than traditional game development.</p>
<h2 id="_idParaDest-32">Exploring the Unity interface</h2>
<p>Upon<a id="_idIndexMarker058"/> launching a new Unity project, you’ll be greeted by the Unity Editor. This multifaceted workspace is composed of several distinct windows known as panels.</p>
<p><em class="italic">Figure 2</em><em class="italic">.2</em> shows the window layout for the sample scene project we just created.</p>
<div><div><img alt="Figure 2.2 – ﻿The window layout for the sample scene project" src="img/B20869_02_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The window layout for the sample scene project</p>
<p><em class="italic">Figure 2</em><em class="italic">.2</em> showcases a number of panels, namely: (<em class="italic">1</em>) <strong class="bold">Scene</strong> view, (<em class="italic">2</em>) <strong class="bold">Game</strong> view, (<em class="italic">3</em>) <strong class="bold">Hierarchy</strong>, (<em class="italic">4</em>) <strong class="bold">Inspector</strong>, (<em class="italic">5</em>) <strong class="bold">Project</strong>, and (<em class="italic">6</em>) <strong class="bold">Console</strong>.</p>
<p>Let’s <a id="_idIndexMarker059"/>explore these essential panels that make up Unity’s interface.</p>
<p>Imagine<a id="_idIndexMarker060"/> the <strong class="bold">Scene view</strong> (<em class="italic">1</em>) as your canvas, where you’ll bring your game world to life, creating mesmerizing landscapes and placing your characters in fantastic environments. This panel is the heart of the game, where every object is placed and arranged to tell a compelling story. For example, you can select the <strong class="bold">Safety Hat</strong> GameObject within our sample scene and move, rotate, scale, or remove it.</p>
<p>The <strong class="bold">Game view</strong> (<em class="italic">2</em>) is the <a id="_idIndexMarker061"/>place where you can experience your game from your player’s perspective. It provides a real-time preview of the gameplay, including the visual rendering and user interface elements you’ve implemented.</p>
<p>The <strong class="bold">Hierarchy panel</strong> (<em class="italic">3</em>) or <strong class="bold">Scene Hierarchy window</strong> is your game’s blueprint, showcasing<a id="_idIndexMarker062"/> the organized list of every GameObject that makes up your <a id="_idIndexMarker063"/>game world. It’s like an architectural plan that helps you navigate, manage, and visualize the relationships between game elements, ensuring a coherent and structured experience. Our sample scene demonstrates what a well-structured hierarchy looks like. All added GameObjects are subordinate to the <strong class="bold">Example Assets</strong> parent object. This includes the <strong class="bold">Props</strong> GameObject, which itself serves as a parent object for any GameObjector asset that decorates a scene and adds details and context to the game world—for example, Jigsaw, Hammer, Workbench, and so on. So, keep in mind that grouping related objects together<a id="_idIndexMarker064"/> under a parent GameObject makes it easier to manage and manipulate them as a single entity. Additionally, naming conventions can be used to make the hierarchy more readable and easier to understand.</p>
<p>The <strong class="bold">Inspector panel</strong> (<em class="italic">4</em>) or <strong class="bold">Inspector window</strong> is the control center for fine-tuning your<a id="_idIndexMarker065"/> game<a id="_idIndexMarker066"/> elements. It’s where you can adjust every tiny detail of your GameObjects or assets, making sure your game world is precisely how you envisioned it. From position and scale to adding components and modifying scripts, the <strong class="bold">Inspector</strong> panel is your ticket to perfection. Let’s select the <strong class="bold">Safety Hat</strong> object in the <strong class="bold">Scene Hierarchy</strong> window by navigating to <strong class="bold">Example Asset</strong> | <strong class="bold">Props</strong> | <strong class="bold">Safety Hat</strong>. The <strong class="bold">Inspector</strong> window shows all the defined components of the <strong class="bold">Safety Hat</strong> object. The <strong class="bold">Transform</strong> component is responsible for positioning, rotating, and scaling the object. You will find a gizmo representation of it in the Scene View, which allows us to transform objects directly there. Two other components that can be seen in the <strong class="bold">Inspector</strong> window are the <strong class="bold">Mesh Filter</strong> and <strong class="bold">Mesh Renderer</strong> components. The <strong class="bold">Mesh Filter</strong> and <strong class="bold">Mesh Renderer</strong> components provide a way to create and display 3D models in a scene. The <strong class="bold">Mesh Filter</strong> component defines the model’s geometry, while the <strong class="bold">Mesh Renderer</strong> component applies visual properties such as materials and textures. Without these components, you wouldn’t see the object in the Scene View.</p>
<p>The <strong class="bold">Project</strong> panel (<em class="italic">5</em>) holds<a id="_idIndexMarker067"/> all the building blocks of your game, from <strong class="bold">textures</strong> and models to sounds and scripts. It’s like a library of resources, where every imported or created asset is at your fingertips, waiting to be used in your XR project.</p>
<p>Finally, the <strong class="bold">Console</strong> panel (<em class="italic">6</em>) is an<a id="_idIndexMarker068"/> essential tool, assisting in the identification and resolution of issues during development. It provides detailed logs, warnings, and error messages, allowing for efficient troubleshooting and ensuring the integrity of the game’s performance.</p>
<p>You are now familiar with the default panels in Unity. Next, we will get to know the Unity Grid and Snap system, which is a game changer when building scenes.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can keep the default layout, or customize your panels using the dropdown at the top right of the Unity Editor under <strong class="bold">Layout</strong>. We usually prefer the 2x3 layout, but for simplicity, we will use the default layout in this book.</p>
<h2 id="_idParaDest-33">Using the Grid and Snap system</h2>
<p>The <strong class="bold">Unity Grid and Snap system</strong> helps align and place objects in a more organized manner in<a id="_idIndexMarker069"/> the game environment. It allows you to snap objects to a grid and also to other objects for easier placement and arrangement.</p>
<p><em class="italic">Figure 2</em><em class="italic">.3</em> shows you where to find the system.</p>
<div><div><img alt="Figure 2.3 – ﻿How to use the Grid and Snap system" src="img/B20869_02_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – How to use the Grid and Snap system</p>
<p>To make use of this system, you will need to turn on the <strong class="bold">Grid Snapping</strong> button, which is represented by an icon with a grid and magnet (<em class="italic">1</em>). Furthermore, make sure to activate the <strong class="bold">Global</strong> handles by selecting the <strong class="bold">Global</strong> icon (<em class="italic">2</em>) positioned adjacent to the <strong class="bold">Grid </strong><strong class="bold">Snapping</strong> field.</p>
<p>The <code>1</code> for all three axes (<strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong>), meaning each grid square has a width, height, and depth of one unit. This setting can be adjusted as needed to match the scale of the objects in your scene. The <strong class="bold">Grid Size</strong> field determines the increment at which objects will snap to the grid, so a larger grid size will<a id="_idIndexMarker070"/> result in coarser snapping, while a smaller grid size will result in finer snapping.</p>
<p class="callout-heading">Your turn</p>
<p class="callout">1. Select the same stud as in <em class="italic">Figure 2</em><em class="italic">.3</em> and move it two units towards the <strong class="bold">Y</strong> direction. Activate <strong class="bold">Grid Snapping</strong>, and try different grid sizes to place the stud<a id="_idTextAnchor005"/> back on the workbench.</p>
<p class="callout">2. Try to become familiar with the navigation in the <strong class="bold">Scene</strong> view by moving, orbiting, and zooming through the scene. This documentation may help you: <a href="https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html">https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html</a>).</p>
<p class="callout">3. Pick another two GameObjectsand move, scale, and r<a id="_idTextAnchor006"/>otate them as you like.</p>
<h1 id="_idParaDest-34">Understanding GameObjects and components</h1>
<p>GameObjects <a id="_idIndexMarker071"/>and <strong class="bold">components</strong> are essential building blocks of Unity projects, allowing developers to create interactive and dynamic content. Now, we’ll provide a <a id="_idIndexMarker072"/>comprehensive overview of GameObjects and components and how they work together.</p>
<h2 id="_idParaDest-35">Understanding the default new scene</h2>
<p>Unity empowers <a id="_idIndexMarker073"/>developers with the ability to create multiple scenes within the editor. This feature aids in managing complexity, enhancing performance, and fostering more modular and reusable game projects. To create a new default scene alongside our sample scene, access the menu at the uppermost section of the editor and choose <code>Scenes</code> folder with a name of your choosing. After following these steps, you will be presented with a new Unity scene containing a <strong class="bold">Main Camera</strong> GameObject and a <strong class="bold">Directional Light</strong> GameObject. Both GameObjects are located in the <strong class="bold">Scene Hierarchy</strong> window and displayed in the <strong class="bold">Scene</strong> window, which features an infinite reference ground plane grid. In Unity, GameObjects serve as the foundational building blocks of a game scene. They represent visible or interactive elements such as characters, props, light sources, or cameras. Each GameObject possesses a <strong class="bold">Transform</strong> component that defines its position, rotation, and <a id="_idIndexMarker074"/>scale and can be augmented with additional <a id="_idIndexMarker075"/>components <a id="_idIndexMarker076"/>for <strong class="bold">physics</strong>, <strong class="bold">collision detection</strong>, or <strong class="bold">game logic</strong>.</p>
<p>Let’s create <a id="_idIndexMarker077"/>our first GameObject. Keep in mind that while Unity is primarily a game engine, it does offer some basic modeling capabilities. You can create simple 3D models using Unity’s built-in 3D object <strong class="bold">primitives</strong> or import more intricate models fashioned in other 3D modeling software. Third-party plugins are also available to further bolster Unity’s modeling prowess. However, it’s important to remember that Unity is no match for dedicated 3D modeling software such as <em class="italic">Blender</em>, <em class="italic">3ds Max</em>, or <em class="italic">Maya</em>, and it’s better suited for creating and manipulating models for use in game development.</p>
<p>We’ll start by creating a plane primitive to act as our floor. To do so, right-click in the <code>0</code>,<code>0</code>,<code>0</code>) but rather at a different location. By default, newly created objects are parented to the active object in the <code>Ground</code>.</p>
<p>In the <code>Ground</code> object’s <strong class="bold">Inspector</strong> window, you’ll notice that besides the <strong class="bold">Mesh Filter</strong> and <strong class="bold">Mesh Renderer</strong> components responsible for the GameObject’s visual appearance, there’s also a <strong class="bold">Mesh Collider</strong> component. Up next, you’ll learn more about this and other types of colliders.</p>
<h2 id="_idParaDest-36">Adding a collider</h2>
<p><strong class="bold">Colliders</strong> are <a id="_idIndexMarker078"/>components that define the shape of an object <a id="_idIndexMarker079"/>and <a id="_idIndexMarker080"/>are used to determine physical interactions with other objects in the scene. There are several types of colliders available in Unity, each with its own specific use case, as follows:</p>
<ul>
<li><strong class="bold">Box collider</strong>: This<a id="_idIndexMarker081"/> type of collider defines a rectangular shape, perfect for objects with a box-like shape.</li>
<li><strong class="bold">Sphere collider</strong>: This<a id="_idIndexMarker082"/> type of collider defines a spherical shape, great for objects with a round shape, such as a ball.</li>
<li><strong class="bold">Capsule collider</strong>: This <a id="_idIndexMarker083"/>type of collider is a combination of a cylinder and two spheres, useful for objects that are shaped like a capsule, such as a character.</li>
<li><strong class="bold">Mesh collider</strong>: This<a id="_idIndexMarker084"/> type of collider defines the shape of an object based on its mesh, allowing precise collision detection.</li>
<li><strong class="bold">Wheel collider</strong>: This <a id="_idIndexMarker085"/>type of collider is specifically designed for wheel-based objects, such as vehicles. It allows realistic wheel behavior and suspension.</li>
</ul>
<p>By <a id="_idIndexMarker086"/>incorporating a collider component, you can define an object’s interactions with other scene colliders, such as bouncing, stopping, or passing through. Additionally, colliders can trigger events, such as activating sound effects upon collision. Applying <a id="_idIndexMarker087"/>a collider to the ground is sensible, as it establishes environmental boundaries and enables lifelike interactions with other scene objects, preventing characters from falling through the ground, for instance.</p>
<p>Components are <a id="_idIndexMarker088"/>versatile tools that can be assigned to GameObjects, shaping their behavior, appearance, and functionality. Consider <strong class="bold">Main Camera</strong>, which is equipped with components such as <strong class="bold">Transform</strong> (defining position, rotation, and scale) and <strong class="bold">Camera</strong> (specifying settings such as <strong class="bold">field of view</strong> (<strong class="bold">FOV</strong>) and clipping planes). Similarly, the <strong class="bold">Directional Light</strong> GameObject features components such as <strong class="bold">Transform</strong> and <strong class="bold">Light</strong>, which determine the light’s type, color, and intensity, among other properties.</p>
<p>Other examples of components include <strong class="bold">Rigidbody</strong> for incorporating physics-based behavior, <strong class="bold">AudioSource</strong> for playing sounds, and <strong class="bold">Particle System</strong> for crafting visual effects such as fire, smoke, or magical spells. Each component fulfills a unique function and significantly influences your game world and its interactions.</p>
<p>As we progress through this book, we will explore and utilize an array of essential components, starting with the next section, where we b<a id="_idTextAnchor007"/>reathe life into our initial basic scene.</p>
<h1 id="_idParaDest-37">Creating a basic scene in Unity and adding objects</h1>
<p>In this section, we will walk you through<a id="_idIndexMarker089"/> constructing the scene depicted in <em class="italic">Figure 2</em><em class="italic">.4</em>, which integrates elements such as primitives, materials, prefabs, lighting, and imported assets.</p>
<div><div><img alt="Figure 2.4 – ﻿The basic scene we are going to create" src="img/B20869_02_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – The basic scene we are going to create</p>
<p>By engaging with this step-by-step tutorial, you will develop a strong knowledge of these core concepts while assembling an aesthetically striking scene. Our initial task involves crafting a table using primitive shapes.</p>
<h2 id="_idParaDest-38">Building a table with primitives</h2>
<p>Primitives, as <a id="_idIndexMarker090"/>the name suggests, are simple geometric shapes that form the building blocks for more complex models in our scene. Imagine a chair taking shape as a cube forms the seat, two cylinders become the sturdy legs, and two more cylinders morph into supportive back legs. The backrest is crafted from a plane, its size and placement perfectly complementing the seat and legs.</p>
<p>A table<a id="_idIndexMarker091"/> for our scene can be crafted in a similar fashion—a cube takes center stage as the tabletop, while four cylinders rise up to serve as legs. Textures are applied, giving the tabletop and legs a lifelike appearance. The size and positioning of each primitive are adjusted, resulting in a table that looks like it was plucked from the real world.</p>
<p>To create the table, we recommend following the sequence illustrated in <em class="italic">Figure 2</em><em class="italic">.5</em>.</p>
<div><div><img alt="Figure 2.5 – ﻿How to use the Grid and Snap system" src="img/B20869_02_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – How to use the Grid and Snap system</p>
<p>To build your table, go through the following steps:</p>
<ol>
<li>Create a single table leg by introducing a cylinder to the scene. This can be achieved by right-clicking into the <code>0.05</code>, <code>0.2</code>, <code>0.05</code>) and position at (<code>0</code>, <code>0.2</code>, <code>0</code>).</li>
<li>The table requires four identical legs. To achieve this, reproduce the original leg by copying (right-click on the object in the <strong class="bold">Scene Hierarchy</strong> window and click <strong class="bold">Copy</strong>) and pasting it three times. Fine-tune the positions of the duplicated legs based on the preceding reference image.</li>
<li>Next, add a <strong class="bold">Cube</strong> primitive to the scene that will serve as the tabletop. Rescale and <a id="_idIndexMarker092"/>position the cube so that it rests on the table legs. To achieve the scaling and positioning more simply, shift to <strong class="bold">Wireframe</strong> mode, as shown in <em class="italic">Figure 2</em><em class="italic">.6</em>.</li>
</ol>
<div><div><img alt="Figure 2.6 – ﻿How to use Wireframe mode" src="img/B20869_02_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – How to use Wireframe mode</p>
<p class="callout-heading">Tip</p>
<p class="callout">Our advice here is to initially scale just the <strong class="bold">Y</strong> value and place the cube on top of the legs using the Grid and Snap system. Subsequently, you can shift your view from the scene to the top and modify the <strong class="bold">Shading</strong> mode from <strong class="bold">Shaded</strong> to <strong class="bold">Wireframe</strong>. This change reveals the cylinders and the cube, simplifying the task of scaling the <strong class="bold">X</strong> and <strong class="bold">Z</strong> values and positioning the <strong class="bold">Cube</strong> object.</p>
<ol>
<li value="4">To organize the table components, create a nested parent-child object hierarchy. First, assign appropriate names to the objects by renaming the <code>Table top</code> and the cylinders as their respective table legs. Subsequently, select all the legs (<em class="italic">cmd</em>/<em class="italic">Ctrl</em> + left-click). Click and drag them onto the <code>Table top</code> object in the <code>Table top</code> object, establishing a parent-child relationship.</li>
<li>To further refine the table structure, create an empty GameObject by selecting <code>Table</code>. Make the <code>Table top</code> object a child of the <code>Table</code> object. This results in a harmoniously structured table consisting of five interconnected primitives. With this arrangement, the table <a id="_idIndexMarker093"/>can be easily scaled and relocated without the need to individually select each GameObject.</li>
</ol>
<p>To complete the scene, place a sphere primitive named <code>Table</code> object. You can use the Grid and Snap techniques discussed earlier for this. For a more refined look, feel free to scale the sphere to your liking. In the following section, we will enhance the appearance of both the <code>Table</code> and <strong class="bold">Sphere</strong> objects using materials.</p>
<h2 id="_idParaDest-39">Changing the appearance of the ground, table, and sphere</h2>
<p>Up to this point, the <a id="_idIndexMarker094"/>scene consists of a <a id="_idIndexMarker095"/>ground and a table with a sphere placed on it, all displaying the standard gray color. Let’s<a id="_idIndexMarker096"/> enhance this by creating a new red material for the sphere through the following steps:</p>
<ol>
<li>Navigate to the <code>Materials</code> folder in the <code>Assets</code> | <code>Materials</code>).</li>
<li>Click on the <code>Red Material</code>.</li>
<li>Select the white square adjacent to the <strong class="bold">Base Map</strong> field in the <strong class="bold">Inspector</strong> window. This action will launch the <strong class="bold">Color</strong> window. Select the <strong class="bold">#FF0000</strong> hex code.</li>
<li>Now, you can apply the <code>Red Material</code> material by dragging and dropping it on top of the <strong class="bold">Sphere</strong> object.</li>
</ol>
<p>Now, the sphere should appear in red. So far, we have used the simplest form of a material to apply a simple red color to a sphere geometry.</p>
<p>When creating materials for objects in a 3D game or application, it’s often necessary to add additional details and depth to the surface of the object beyond what can be achieved with <a id="_idIndexMarker097"/>just a single texture. This is where maps such as base maps, metallic maps normal maps, height maps, and occlusion maps come in.</p>
<p>Let us get to know each of these maps, as follows:</p>
<ul>
<li><code>Red Material</code> material) or we can assign a texture (such as a picture of a brick wall) that defines the color and pattern of an object’s surface.</li>
<li><strong class="bold">Metallic Map</strong>: A<a id="_idIndexMarker100"/> Metallic Map<a id="_idIndexMarker101"/> defines the extent to which an object’s surface should appear to be metallic, with areas of the map that are white appearing highly metallic, and areas that are black appearing non-metallic.</li>
<li><strong class="bold">Normal Map</strong>: A <a id="_idIndexMarker102"/>Normal Map<a id="_idIndexMarker103"/> is a type of texture that defines the surface normal vectors of an object, giving the illusion of additional depth and detail on the surface. Normal Maps are often used to create the appearance of bumps, dents, and other small details on an object’s surface, without adding extra geometry.</li>
<li><strong class="bold">Height Map</strong>: A<a id="_idIndexMarker104"/> Height Map is <a id="_idIndexMarker105"/>a black-and-white image that defines the height of an object’s surface. Height Maps are used to create the appearance of depth and relief on a surface, such as mountains and valleys on a terrain or the ridges and valleys of a fingerprint.</li>
<li><strong class="bold">Occlusion Map</strong>: An <a id="_idIndexMarker106"/>Occlusion Map<a id="_idIndexMarker107"/> is a texture that defines which parts of an object are occluded, or hidden, from view. Occlusion Maps are used to create the appearance of shadows and ambient occlusion, giving objects a more grounded, realistic look by making them appear to cast shadows and have depth.</li>
</ul>
<p>To visualize these maps, imagine <a id="_idIndexMarker108"/>a piece of paper with a picture of a wall painted on it. The <strong class="bold">Base Map</strong> would be the paint on the wall, the <strong class="bold">Normal Map</strong> would add the appearance of bumps and dents to the surface, the <strong class="bold">Height Map</strong> would create the appearance of depth and relief, and the <strong class="bold">Occlusion Map</strong> would add the appearance of shadows. When these maps are combined, they can create a much more detailed and believable representation of a wall. You may have noticed that <a id="_idIndexMarker109"/>this example did not cover the <strong class="bold">Metallic Map</strong>. You do not have to use all of the maps for a material. The choice of which maps to use depends on the desired appearance of the material and the level of detail you want to achieve. For example, a simple material for a flat, single-colored object may only require a <strong class="bold">Base Map</strong> (or albedo color) to define its appearance. A more complex material, such as a metal object with intricate details, might require a <strong class="bold">Base Map</strong>, <strong class="bold">Normal Map</strong>, <strong class="bold">Height Map</strong>, and <strong class="bold">Metallic Map</strong> to achieve the desired look.</p>
<p>Creating maps <a id="_idIndexMarker110"/>can be a complex<a id="_idIndexMarker111"/> and time-consuming task, especially <a id="_idIndexMarker112"/>for intricate objects. To save time and effort, it’s often best to utilize pre-made materials or models from marketplaces<a id="_idIndexMarker113"/> such as <a id="_idIndexMarker114"/>the <strong class="bold">Unity Asset Store</strong>, <strong class="bold">ArtStation</strong>, and <strong class="bold">Sketchfab</strong>. These<a id="_idIndexMarker115"/> sites offer a wealth of free content to choose from.</p>
<p>In our sample scene, we have a variety of pre-made materials available. Let’s use a wooden material for the tabletop. Here’s what you need to do:</p>
<ol>
<li>Open the <code>Materials</code> folder (<code>Assets</code> | <code>ExampleAssets</code> | <code>Materials</code>).</li>
<li>Search for the <strong class="bold">OBS_Mat</strong> material and drag it onto the top of the table.</li>
</ol>
<p>Now, the tabletop should exhibit a wooden texture, as illustrated in <em class="italic">Figure 2</em><em class="italic">.7</em>.</p>
<div><div><img alt="Figure 2.7 – ﻿The table top with its wooden texture" src="img/B20869_02_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The table top with its wooden texture</p>
<p>Upon<a id="_idIndexMarker116"/> examining<a id="_idIndexMarker117"/> the surface inputs in the <strong class="bold">Inspector</strong> window, the <a id="_idIndexMarker118"/>wooden material consists of a base map, metallic map, normal map, and occlusion map. To preview each map, <em class="italic">cmd</em>/<em class="italic">Ctrl</em> + left-click the corresponding squares next to the maps.</p>
<p>Let’s also choose an appropriate material for the ground. In the <code>Materials</code> folder (<code>Assets</code> | <code>ExampleAssets</code> | <code>Materials</code>) and search for the <strong class="bold">Ground_Mat</strong> material. Drag it onto the ground, and the surface should now appear more realistic.</p>
<p>Next, you will learn how to create a brick wall material in the scene.</p>
<h2 id="_idParaDest-40">Creating a brick wall material</h2>
<p>In the previous<a id="_idIndexMarker119"/> sections, we explored the application of a red albedo color to a sphere and utilized more advanced materials for the ground and table. It’s worth noting that materials play a crucial role in determining how a surface is rendered, encompassing not only the textures of an object’s surface but also its interaction with light sources.</p>
<p>A texture is an image that is applied to a 3D model or a 2D surface to add detail or color. It can be thought of as skin that covers the surface of an object to give it a specific look or feel. Textures can be created within Unity or imported from external image files and then assigned to materials that are applied to GameObjects in a scene. This technique enhances the level of detail and realism in the rendered object.</p>
<p>In this section, we <a id="_idIndexMarker120"/>will delve into the process of creating and applying a more sophisticated material by developing a brick wall material and applying it to a wall constructed from a transformed cube. Follow these steps to get started:</p>
<ol>
<li>Let’s start by creating a wall by inserting a new cube into the scene, renaming it <code>Wall</code>, scaling it to (<code>2</code>, <code>1</code>, <code>0.1</code>), and positioning it at (<code>0.2</code>, <code>0.5</code>, <code>1.8</code>) behind the table.</li>
<li>Navigate to the <code>Assets</code> folder in the <code>Textures</code>.</li>
<li>To give the <code>Wall</code> cube a brick-like appearance, download and utilize the <code>BrickWall.jpg</code> texture file that is provided in this book’s GitHub repository, or find a suitable brick wall texture through an online search. Import the image into the newly created <code>Textures</code> folder. This can be accomplished by simply dragging the image from your local filesystem and dropping it into the corresponding Unity folder.</li>
<li>Staying in the <code>Materials</code> folder. Here, generate a new material and rename it <code>Brick_Mat</code>. You can create the material by right-clicking within the folder, selecting <strong class="bold">Create</strong>, and then choosing <strong class="bold">Material</strong>.</li>
<li>With th<a id="_idTextAnchor008"/>e <code>Brick_Mat</code> material selected, navigate to the <strong class="bold">Inspector</strong> window. Look for the small <em class="italic">torus symbol</em> situated adjacent to the <strong class="bold">Base Map</strong> field and select it. Proceed to search for and select the imported <strong class="bold">BrickWall</strong> image.</li>
<li>The final step involves moving the <code>Brick_Mat</code> material from the <code>Wall</code> cube present in the <strong class="bold">Scene</strong> window. This can be achieved via a simple drag and drop maneuver.</li>
</ol>
<p>With these steps, your scene should now look similar to the one shown in <em class="italic">Figure 2</em><em class="italic">.8</em>.</p>
<div><div><img alt="Figure 2.8 – ﻿The brick wall in the scene" src="img/B20869_02_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – The brick wall in the scene</p>
<p>You have now <a id="_idIndexMarker121"/>witnessed the prowess of materials in transforming a scene’s realism. In the next section, we will learn about another important component of any Unity scene in more detail: prefabs.</p>
<h2 id="_idParaDest-41">Unpacking a prefab</h2>
<p>In this<a id="_idIndexMarker122"/> section, we will learn how to convert a prefab from the sample scene into a regular GameObject in Unity. Prefabs are reusable, prefabricated objects that can be utilized multiple times within a scene, acting like building blocks for your environment. They are master copies of objects saved in separate files, allowing you to create multiple instances and streamline scene management.</p>
<p>To import a prefab, navigate to the <code>Assets</code> | <code>ExampleAssets</code> | <code>Prefabs</code>. Drag and drop the <strong class="bold">ConstructionLight_Low</strong> object from the <strong class="bold">Scene Hierarchy</strong> window into the scene. In the <strong class="bold">Scene Hierarchy</strong> window, you’ll notice a blue cube icon, indicating it is a prefab instance.</p>
<p>We’ll now unpack the <strong class="bold">ConstructionLight_Low</strong> object to turn it into a regular GameObject. Right-click in the <strong class="bold">Scene Hierarchy</strong> window and select <strong class="bold">Prefab</strong> | <strong class="bold">Unpack</strong>. This way, modifications to the prefab won’t affect the unpacked instance. Go ahead and position it in front of the brick wall.</p>
<p>It’s important to <a id="_idIndexMarker123"/>remember that using prefabs in<a id="_idIndexMarker124"/> Unity is advantageous in various scenarios, such as the following:</p>
<ul>
<li><strong class="bold">Repeating GameObjects</strong>: Save time and effort by creating an object once, converting it into a prefab, and duplicating it as needed</li>
<li><strong class="bold">Customizing GameObjects</strong>: Manage customizations more efficiently with a prefab containing all possible modifications, adjusting instances as required</li>
<li><strong class="bold">Modular game design</strong>: Facilitate a modular design by creating prefabs for individual-level components and assembling them into a complete level</li>
</ul>
<p>Using prefabs in Unity helps save time, manage complex GameObjects, and support an adaptable, modular game design. Next, we’ll discuss how to import assets from the Unity Asset Store.</p>
<h2 id="_idParaDest-42">Importing from the Unity Asset Store</h2>
<p>Let’s learn <a id="_idIndexMarker125"/>how to import and use models available on the Asset Store. The Unity Asset Store is a marketplace where users can find, purchase, and download a variety of assets, including 3D models, animations, audio, visual effects, and more, to use in their Unity projects.</p>
<p>Here’s how to import a spotlight model from the Asset Store:</p>
<ol>
<li>Open your preferred web browser and navigate to the Unity Asset Store at <a href="https://assetstore.unity.com/">https://assetstore.unity.com/</a>. Here, input <code>Spotlight and Structure</code> in the search bar. Alternatively, you can directly access the package page via <a href="https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453">https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453</a>.</li>
<li>Once you have added the package to your assets, look for the <strong class="bold">Open in Unity</strong> button and click on it.</li>
<li>The Unity application should open with a prompt to import the package. Proceed with the <strong class="bold">Import</strong> operation.</li>
<li>Upon successful import, navigate to the package’s directory in the <code>Assets</code> | <code>SpaceZeta_Spotlight</code> | <code>Assets</code>.</li>
<li>Drag the <code>Spotlight.fbx</code> and <code>SpotlightStructure1.fbx</code> files into the scene and unpack them (right-click, then select <strong class="bold">Prefab</strong> | <strong class="bold">Unpack</strong>).</li>
</ol>
<p>If the objects<a id="_idIndexMarker126"/> appear magenta, this typically signifies that the associated materials are either absent or incompatible with the render pipeline currently in use. To fix this, select <strong class="bold">Spotlight</strong> and change the shader to <strong class="bold">Universal Render Pipeline</strong> | <strong class="bold">Lit</strong> in the <strong class="bold">Inspector</strong> window.</p>
<p>If your <code>Spotlight_basecolor.png</code>, <code>Spotlight_roughness.png</code>, <code>Spotlight_normal.png</code>, and <code>Spotlight_emission.png</code> files.</p>
<p>Now, your <code>BrickWallLight</code> and <code>BrickWallLightStructure</code> and transform them according to what is shown in <em class="italic">Figure 2</em><em class="italic">.9</em>.</p>
<div><div><img alt="Figure 2.9 – ﻿The imported BrickWallLight model and its BrickWallLightStructure model" src="img/B20869_02_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – The imported BrickWallLight model and its BrickWallLightStructure model</p>
<p>You can<a id="_idIndexMarker127"/> use the same procedure to find and import other 3D models, animations, audio, and visual effects that you need for your scene. In line with the <code>BrickWallLight</code> model that was imported just now, the next section deals with the most crucial aspects of lighting.</p>
<h2 id="_idParaDest-43">Understanding Unity’s lighting pipeline</h2>
<p>A crucial aspect to <a id="_idIndexMarker128"/>consider before implementing your project is planning the lighting. Here, we present a proven approach that has<a id="_idIndexMarker129"/> consistently delivered exceptional lighting in a wide array of XR projects over the years, closely aligning with Unity’s best practice lighting pipeline (<a href="https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html">https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html</a>). This process consists of three primary steps, as shown in <em class="italic">Figure 2</em><em class="italic">.10</em>.</p>
<div><div><img alt="Figure 2.10 – ﻿Unity’s best practice lighting pipeline" src="img/B20869_02_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Unity’s best practice lighting pipeline</p>
<p>The selection <a id="_idIndexMarker130"/>of an appropriate render pipeline for your project is your initial step of the overall lighting pipeline process. As noted in <em class="italic">Table 2.1</em>, we recommend using URP for XR projects, which establishes the groundwork for effective lighting.</p>
<p>The second step of the lighting pipeline is to determine how <strong class="bold">indirect lighting</strong> should be generated<a id="_idIndexMarker131"/> by selecting <a id="_idIndexMarker132"/>a suitable <strong class="bold">Global Illumination (GI) system</strong> and <a id="_idIndexMarker133"/>corresponding <strong class="bold">lighting mode</strong>.</p>
<p>Think <a id="_idIndexMarker134"/>about a room with a single window on a sunny day. The direct light is like the bright sunlight that’s coming straight into the room through the window—it’s the light you would feel directly on your skin if you stood in the path of the window. That’s similar to what we mean by direct lighting in Unity.</p>
<p>Now, look at the corners of the room or the parts not directly in front of the window. They aren’t in complete darkness, right? They’re lit up, but not as brightly. That’s because the sunlight coming in hits different surfaces—the floor, walls, or furniture—and bounces off to these parts. This is what we refer to as indirect lighting.</p>
<p>The GI system in Unity mimics the rules of how light bounces around in the room. It’s the system that calculates how much light gets to the darker parts of the room based on how much it reflects off the surfaces it hits.</p>
<p>Lastly, the lighting mode in Unity is akin to choosing what kind of surfaces you have in the room. Is it a shiny, reflective marble floor or a dark, matte wood floor? Depending on what you choose, the light would bounce off differently and light up the room in a unique way. This is what the lighting mode controls—it determines how the light interacts with different surfaces to create the overall lighting effect in your game scene.</p>
<p>With the GI settings tailored to your project’s requirements, it’s time to unleash your artistic vision. The last step of the lighting pipeline is to integrate lights, emissive surfaces, reflection probes, and light probes to harmoniously weave your scene’s illumination. By following this approach, you will construct a cohesive and detailed lighting environment, enhancing the realism and engagement of your virtual space and ensuring a high-quality user experience.</p>
<p>Now, it is time to implement the steps of the lighting pipeline into our scene. With URP already chosen for your project, let’s proceed to the second phase of the lighting pipeline. Here, we’ll focus on understanding and selecting the appropriate lighting settings for your scene. This crucial step ensures your virtual world is lit effectively.</p>
<h2 id="_idParaDest-44">Choosing the right lighting settings</h2>
<p>As you’ve<a id="_idIndexMarker135"/> selected URP for your XR project, the next task is configuring indirect lighting. This process entails choosing a suitable GI system and lighting mode. <strong class="bold">GI</strong> imitates indirect light in 3D environments, leading to soft shadows and a natural appearance as light bounces between objects and surfaces. Unity’s lighting mode options present a variety of settings, each balancing visual quality and performance differently.</p>
<p>For simple mobile XR scenes, the most performant option is <strong class="bold">Subtractive</strong> mode, which relies on pre-calculated lightmaps to minimize <strong class="bold">GPU</strong> load and boost performance. <strong class="bold">Shadowmask</strong> mode follows closely, offering <strong class="bold">real-time lighting</strong> and baked shadows for static objects, striking a <a id="_idIndexMarker136"/>balance between visual quality and performance by reducing GPU load with pre-calculated shadows. Alternatively, <strong class="bold">Baked Indirect Lighting</strong> mode provides an ideal mix of real-time lighting, shadowing, and baked indirect lighting for high-quality XR visuals.</p>
<p>To set up indirect lighting, navigate to <code>Assets</code> folder, where it can be renamed. We suggest choosing <strong class="bold">Mixed Lighting</strong> by default, enabling the <strong class="bold">Baked Global Illumination</strong> option in the <strong class="bold">Lighting</strong> settings window. For the lighting mode, <strong class="bold">Shadowmask</strong> is the optimal choice for its balance between quality and performance.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Though <strong class="bold">Baked Global Illumination</strong> permits automatic lightmap generation, we advise against it. Instead, manually generate lightmaps before testing the scene or after implementing changes as it provides the flexibility to test different lighting scenarios and iterate on your design without the overhead of constant automatic updates.</p>
<p>With that settled, you can proceed to place light objects within your scene.</p>
<h2 id="_idParaDest-45">Adding lights and a skybox</h2>
<p><strong class="bold">Light objects</strong> in <a id="_idIndexMarker137"/>Unity are<a id="_idIndexMarker138"/> an essential part of creating an immersive and believable environment. There are several different light objects to choose from, including Point Lights, Spot Lights, Directional Lights, and Area Lights. They can be categorized under <strong class="bold">direct lighting</strong>, which refers<a id="_idIndexMarker139"/> to the light that is emitted directly from a light source. Let’s take a closer look at each light object.</p>
<p><strong class="bold">Point Lights</strong> emit<a id="_idIndexMarker140"/> light uniformly from a single point, ideal for <a id="_idIndexMarker141"/>localized sources such as lamps and candles. <strong class="bold">Spot Lights</strong> project<a id="_idIndexMarker142"/> light<a id="_idIndexMarker143"/> in a conical shape, perfect for directional sources such as flashlights and headlights. <strong class="bold">Directional Lights</strong> cast <a id="_idIndexMarker144"/>light in a <a id="_idIndexMarker145"/>single direction, resembling the sun or moon, while <strong class="bold">Area Lights</strong> disperse <a id="_idIndexMarker146"/>light <a id="_idIndexMarker147"/>from a specific area, akin to ceiling light panels.</p>
<p>Each light type has unique properties, and when combined, they can produce diverse lighting effects. Comprehending these light types is key to achieving effective lighting in Unity.</p>
<p>Let's start by selecting the <strong class="bold">Directional Light</strong> GameObject in the <strong class="bold">Scene Hierarchy</strong> window and unchecking the checkbox at the top of its <strong class="bold">Inspector</strong> window. You’ll observe its substantial influence on the scene’s illuminance. However, you might be curious why the scene remains brighter than<a id="_idIndexMarker148"/> anticipated—the reason lies in the active <strong class="bold">skybox</strong>.</p>
<p>In Unity, a <a id="_idIndexMarker149"/>skybox serves as a backdrop that surrounds the scene, imparting a sense of environment and depth, similar to the sky and surrounding landscape in real life. A skybox is created using a specific material applied to a large cube that encloses the scene, consistently appearing behind all other elements. This cube generates the illusion of a sky and environment extending beyond the scene’s actual boundaries.</p>
<p>Skyboxes play a crucial role in indirect lighting, as they impact the scene’s overall lighting ambiance. For instance, a bright sky with a blazing sun casts warm light over the scene, fostering a welcoming and inviting atmosphere. Conversely, a dark sky featuring a full moon casts cool, blue light over the scene, cultivating a more eerie and mysterious mood. Other examples of indirect lighting in Unity encompass GI, ambient light, and lightmaps, which all contribute to the final visual experience.</p>
<p>Let's create<a id="_idIndexMarker150"/> and <a id="_idIndexMarker151"/>apply a totally dark skybox, following these steps:</p>
<ol>
<li>To create a new material, navigate to the <code>Materials</code> folder within the <strong class="bold">Project</strong> window. Right-click and choose <strong class="bold">Create</strong> | <strong class="bold">Material</strong>.</li>
<li>Name the new material <code>DarkSkybox_Mat</code> and select it to see its properties in the <strong class="bold">Inspector</strong> window.</li>
<li>Choose the shader type by going to <strong class="bold">Skybox</strong> | <strong class="bold">Procedural</strong> and keep the default settings.</li>
<li>Drag the new <strong class="bold">Skybox</strong> material to the sky.</li>
</ol>
<p>Your scene<a id="_idIndexMarker152"/> should now resemble the one shown in <em class="italic">Figure 2</em><em class="italic">.11</em>.</p>
<div><div><img alt="Figure 2.11 – ﻿The skybox applied to the scene" src="img/B20869_02_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – The skybox applied to the scene</p>
<p>Now, you <a id="_idIndexMarker153"/>can see that the elements in the scene are only visible because of the activated spotlight emanating from the <strong class="bold">ConstructionLightLow</strong> object. Since the influences of indirect lighting conditions have been eliminated, it is time to experiment with the remaining different light types.</p>
<p>First, select the <strong class="bold">Spot Light</strong> child object of the <strong class="bold">ConstructionLightLow</strong> object and then go to the <strong class="bold">Inspector</strong> window. Here, change the light type to <strong class="bold">Point</strong>, which, while not entirely suitable for the construction light, will serve to illustrate the shift in behavior. A Point Light, you see, radiates its luminance in all directions, unlike the focused beam of a Spot Light.</p>
<p>Now, let us breathe life into the imported <code>BrickWallLight</code> object. To do so, add an empty child object to its existing child object. Rename it <code>Light</code> and proceed by selecting <code>Light</code>. With <strong class="bold">Spot</strong> as the chosen type, you are free to adjust <strong class="bold">Position</strong>, <strong class="bold">Color</strong>, <strong class="bold">Intensity</strong>, and other parameters to your heart’s content. To witness the full extent of your creation’s influence, momentarily disable the <strong class="bold">ConstructionLightLow</strong> object.</p>
<p>Finally, we have arrived at the last uncharted territory of light types—the Area Light. <em class="italic">Figure 2</em><em class="italic">.12</em> demonstrates the incorporation of an Area Light into our scene, elevating it to new heights of brilliance.</p>
<div><div><img alt="Figure 2.12 – ﻿An Area Light illuminating the scene" src="img/B20869_02_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – An Area Light illuminating the scene</p>
<p>To incorporate<a id="_idIndexMarker154"/> an Area Light in your scene, go through the following steps:</p>
<ol>
<li>Add a <code>1.3</code>, <code>0.75</code>, <code>0.1</code> ), and change its <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> parameters so that it is approximately aligned with the white cube light shown in <em class="italic">Figure 2</em><em class="italic">.12</em>.</li>
<li>Name the object <code>Cube Light</code>.</li>
<li>Create an empty child object. Right-click and select <code>Area Light</code>.</li>
<li>In the <code>Light</code>. Now, you will find the option to change the light type to <strong class="bold">Area (baked only)</strong>. Temporarily extinguish all other sources of light within your scene by unchecking their respective checkboxes in the <strong class="bold">Inspector</strong> window. You may observe that the scene plunges into darkness, with the Area Light seemingly unable to fulfill its illuminating duties.</li>
</ol>
<p>Unity offers a duo of lighting systems: <strong class="bold">real-time lighting</strong> and <strong class="bold">precomputed lighting</strong>. Real-time lighting<a id="_idIndexMarker155"/> illuminates the scene<a id="_idIndexMarker156"/> dynamically, shifting<a id="_idIndexMarker157"/> with the player’s movements through the environment. In contrast, precomputed lighting<a id="_idIndexMarker158"/> calculates the scene’s luminance before the game commences, delivering a stable and optimized lighting experience. A third, hybrid mode known as<a id="_idIndexMarker159"/> mixed lighting combines the best of both worlds, allowing flexibility in determining which parts of the scene utilize real-time and precomputed lighting.</p>
<p>Area Lights <a id="_idIndexMarker160"/>only allow precomputed lighting, requiring us to first bake a lightmap and assign its <strong class="bold">emissive surface</strong> to the<a id="_idIndexMarker161"/> GameObjects illuminated by the light. Baking a lightmap involves pre-calculating lighting data and storing it in a texture, optimizing the scene’s lighting during runtime. Baking is a one-time process that’s repeated only when lighting conditions change.</p>
<p>To start, identify the GameObjects affected by the <code>Area Light</code>, such as the <code>Wall</code> object and <code>Cube Light</code> object itself, and activate their <strong class="bold">Static</strong> checkboxes in the <strong class="bold">Inspector</strong> window. Next, bake the lightmap by navigating to <strong class="bold">Window</strong> | <strong class="bold">Rendering</strong> | <strong class="bold">Lighting</strong>, and switching to the <strong class="bold">Baked Lightmaps</strong> tab. Click on <strong class="bold">Generate Lighting</strong> to see the transformation.</p>
<p>Notice that only the <code>Wall</code> object appears to shine, while the <code>Cube Light</code> object doesn’t. This occurs because there’s no object to reflect its light, as with the <code>Ground</code> object below.</p>
<p>To enhance the scene, focus on the <code>Ground</code>, <code>BrickWallLight</code>, <code>BrickWallLightStructure</code> objects and their respective children. Enable their <strong class="bold">Static</strong> checkboxes and bake the lightmap once more. Observe the transformation of your scene.</p>
<p><em class="italic">Figure 2</em><em class="italic">.13</em> highlights the difference when using emissive surfaces with Area Lights.</p>
<div><div><img alt="Figure 2.13 – ﻿The influence of emissive surfaces of an Area Light" src="img/B20869_02_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – The influence of emissive surfaces of an Area Light</p>
<p>The<a id="_idIndexMarker162"/> left image of <em class="italic">Figure 2</em><em class="italic">.13</em> features only the wall and Area Light as emissive surfaces, while the right image includes multiple GameObjects, resulting in a more dynamic, visually engaging experience.</p>
<p>Let's reactivate the lights of the <code>BrickWallLight</code> and the <strong class="bold">ConstructionLightLow</strong> objects. By doing so, we embrace the principle of mixed lighting, merging the strengths of both real-time and precomputed lighting. As a result, the objects within our scene become illuminated in a harmonious blend.</p>
<p>As an XR developer, the choice of lighting is a reflection of your artistic vision and the demands of your scene. Real-time lighting captivates with its dynamism, precomputed lighting entrances with its stability, and mixed lighting enchants with its versatility. In the last section of this chapter, we’ll introduce light and reflection probes.</p>
<h2 id="_idParaDest-46">Exploring light and reflection probes</h2>
<p>Finally, let’s delve into <strong class="bold">reflection probes</strong> and <strong class="bold">light probes</strong> by revisiting our <strong class="bold">SampleScene</strong> object. To access it, navigate to <strong class="bold">Assets</strong> | <strong class="bold">Scenes</strong> in the <strong class="bold">Project </strong>window and double-click on the <strong class="bold">SampleScene</strong> object.</p>
<p>In Unity, reflection <a id="_idIndexMarker163"/>probes and light probes<a id="_idIndexMarker164"/> contribute to the creation of realistic lighting and reflections within a scene. Reflection probes capture<a id="_idIndexMarker165"/> reflection data from the surrounding environment and apply it to the scene’s objects. By capturing a 360-degree view of the environment and storing it as a cube map, reflection probes enable accurate reflections on reflective surfaces in the scene. For instance, if you want a shiny car in a game to reflect nearby trees and the sky, place a reflection probe near the car to gather environmental data and apply it to the car’s reflections.</p>
<p>Light probes, conversely, capture lighting data from the surrounding environment and apply it to the <a id="_idIndexMarker166"/>scene’s objects. By placing probes at various points in the scene, they gather lighting information and store it as a texture. This texture is then utilized to provide realistic lighting to objects in the scene. For example, if a character is standing in a forest, you could place light probes around the character to capture lighting information from the trees and apply it to the character’s skin.</p>
<p>Examining the <strong class="bold">SampleScene</strong> object in the <strong class="bold">Scene Hierarchy</strong> window, we can see it contains three reflection probes and a light probe group with numerous light probes. The images in <em class="italic">Figure 2</em><em class="italic">.14</em> showcase the appearance of selected reflection probes (left side) and light probes (right side).</p>
<div><div><img alt="Figure 2.14 – ﻿Reflection and light probes in the sample scene" src="img/B20869_02_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Reflection and light probes in the sample scene</p>
<p>Essentially, not <a id="_idIndexMarker167"/>using reflection probes and light <a id="_idIndexMarker168"/>probes in a scene may result in less realistic lighting and reflections. However, if your scene doesn’t feature highly reflective objects or if the lighting is mostly uniform, removing the probes might not create a noticeable difference in the final result. In the case of this <strong class="bold">SampleScene</strong> object, this could very well be true.</p>
<p>As demonstrated, reflection and light probes are potent tools for significantly enhancing a scene’s realism in Unity. Nevertheless, their use is not always required or discernible in simpler scenes, as Unity’s built-in lightmapping technology is adept at approximating lighting and reflections without resorting to probes.</p>
<p>With a grasp of these principles, you’re equipped to create immersive and visually captivating XR experiences.</p>
<h1 id="_idParaDest-47">Summary</h1>
<p>In this chapter, you constructed a fundamental scene, familiarized yourself with the Unity Editor, started learning how to import assets to your own project, and were introduced to the essential aspects of lighting.</p>
<p>You embarked on this journey by installing Unity through the Unity Hub and establishing a new project with a sample scene using URP. You then explored the Unity Editor’s basics, such as navigating its numerous windows and utilizing the scene editing options, including Grid and Snap. Moreover, you delved into GameObjects and their components, such as colliders.</p>
<p>Subsequently, you crafted your very own rudimentary scene, complete with a ground plane, a brick wall, and a table supporting a sphere. Along the way, you discovered the potency of materials, applied some, and designed your own advanced brick wall material using an imported image as a texture. You also examined the usefulness of prefabs and learned how to transform them into regular GameObjects.</p>
<p>Furthermore, you grasped the importance of importing assets by searching for and importing a spotlight from the Asset Store, addressing potential issues that may arise due to render pipeline incompatibilities. Finally, you delved into the expansive subject of lighting, understanding, and implementing Unity’s best practices lighting pipeline within your basic scene. In doing so, you identified the ideal render pipeline, selected the right lighting settings, and experimented with various lights, including Point Lights, Spot Lights, Directional Lights, and Area Lights. You also employed skyboxes and became acquainted with light and reflection probes.</p>
<p>Building upon this solid foundation, you are now prepared to delve deeper into Unity and create increasingly complex and captivating scenes. In the next chapter, we will construct our first VR scene, deploy it, and test it on various VR headsets or simulators, further expanding your understanding and mastery of Unity.</p>
</div>


<div><h1 id="_idParaDest-48" lang="en-US" xml:lang="en-US">Part 2 – Interactive XR Applications with Custom Logic, Animations, Physics, Sound, and Visual Effects</h1>
<p>After delving into the Unity Engine intricacies and exploring various XR technologies in the first part of this book, this part covers all the essentials of XR development, taking you from a beginner to an intermediate level. In this part, you’ll master the creation of your first VR and AR experiences, including deployment to different devices and testing without specific VR headsets or smartphones, using simulators. Once you have a solid understanding of creating and deploying basic XR scenes, you’ll progress to developing more advanced XR applications.</p>
<p>You’ll add interactivity to your XR applications, utilizing no-code options such as button clicks, and delve into more complex logic by scripting in C#. While this part contains numerous coding segments, don’t worry – we’ll explain C# in a beginner-friendly manner. Additionally, you’ll discover how to enhance the realism of your XR scenes by incorporating sounds and particle effects, while ensuring these physical phenomena adhere to real-world physics laws.</p>
<p>This part contains the following chapters:</p>
<ul>
<li><a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>, <em class="italic">VR Development in Unity</em></li>
<li><a href="B20869_04.xhtml#_idTextAnchor011"><em class="italic">Chapter 4</em></a>, <em class="italic">AR Development in Unity</em></li>
<li><a href="B20869_05.xhtml#_idTextAnchor016"><em class="italic">Chapter 5</em></a>, <em class="italic">Building Interactive VR Experiences</em></li>
<li><a href="B20869_06.xhtml#_idTextAnchor020"><em class="italic">Chapter 6</em></a>, <em class="italic">Building Interactive AR Experiences</em></li>
<li><a href="B20869_07.xhtml#_idTextAnchor024"><em class="italic">Chapter 7</em></a>, <em class="italic">Adding Sound and Visual Effects</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>