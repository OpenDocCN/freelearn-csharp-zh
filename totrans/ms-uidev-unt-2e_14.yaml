- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: UI Images and Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 图像和效果
- en: We’ve worked with UI Images in the previous chapters, but now we’ll learn more
    about the component’s specific properties, as well as how to access the component
    via code. We’ll also look at some of the UI effect components that we can apply
    to our UI objects for visual appeal. While we will look at the components thoroughly,
    the majority of this chapter focuses on specific worked-out examples of UI functionality
    that you will find in video games, particularly mobile video games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经使用过 UI 图像，但现在我们将学习更多关于组件的特定属性，以及如何通过代码访问组件。我们还将查看一些可以应用于我们的 UI 对象以增强视觉吸引力的
    UI 效果组件。虽然我们将彻底研究这些组件，但本章的大部分内容将专注于您在视频游戏中（尤其是移动视频游戏中）会发现的具体的 UI 功能示例。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating UI Images and setting their properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI 图像并设置其属性
- en: Using the various UI effects components to further customize our graphical UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种 UI 效果组件进一步自定义我们的图形 UI
- en: Implementing horizontal and circular progress bars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现水平和圆形进度条
- en: How to create Buttons that swap sprites without using the built-in transitions,
    like a mute/unmute Button
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建不使用内置过渡效果的按钮，例如静音/取消静音按钮
- en: Adding a press-and-hold/long-press functionality
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加按住/长按功能
- en: Creating an onscreen four-directional virtual D-Pad
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建屏幕上的四方向虚拟 D-Pad
- en: Creating a floating eight-directional virtual analog stick
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个浮动的八方向虚拟摇杆
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the examples shown in the sections before the *Examples* section can be
    found within the Unity project provided in the code bundle. They can be found
    within the scene labeled **Chapter11**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在“示例”部分之前展示的所有示例都可以在代码包中提供的 Unity 项目中找到。它们位于标记为**第11章**的场景中。
- en: Each example figure has a caption stating the example name within the scene.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例图都有一个标题，说明场景中的示例名称。
- en: In the scene, each example is on its own Canvas, and some of the Canvases are
    deactivated. To view an example on a deactivated Canvas, simply select the checkbox
    next to the Canvas’ name in the Inspector. Each Canvas is also given its own Event
    System. This will cause errors if you have more than one Canvas activated at a
    time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中，每个示例都在自己的 Canvas 上，其中一些 Canvas 被禁用。要查看禁用 Canvas 上的示例，只需在检查器中选择 Canvas 名称旁边的复选框。每个
    Canvas 也都有自己的事件系统。如果您同时激活多个 Canvas，这将导致错误。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011)
- en: UI Image component properties
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 图像组件属性
- en: We’ve created a UI Image before, but let’s look at its properties and components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了一个 UI 图像，但现在让我们看看它的属性和组件。
- en: You can create a new UI Image object using **+** | **UI** | **Image**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **+** | **UI** | **Image** 创建一个新的 UI 图像对象。
- en: The UI `Image` object contains the **Rect Transform** and **Canvas Renderer**
    components as well as the **Image** component. We’ve looked at the **Rect Transform**
    and **Canvas Renderer** components extensively; now, let’s look at the **Image**
    component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UI `Image` 对象包含 **Rect Transform** 和 **Canvas Renderer** 组件以及 **Image** 组件。我们已经详细地研究了
    **Rect Transform** 和 **Canvas Renderer** 组件；现在，让我们看看 **Image** 组件。
- en: The first setting on the **Image** component is the **Source Image** property,
    which represents the sprite that will be rendered. The **Color** property represents
    the base color of the sprite being rendered. Leaving the color at white will make
    the Image appear exactly as the sprite, but changing the color will add a tinted
    color overlay to the Image. You can also change the transparency of the Image
    by reducing the alpha value. The **Material** property allows you to add a material
    to the Image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像**组件的第一个设置是**源图像**属性，它表示将要渲染的精灵。**颜色**属性表示正在渲染的精灵的基本颜色。将颜色设置为白色会使图像看起来与精灵完全一样，但更改颜色将为图像添加带有色调的颜色叠加。您还可以通过降低alpha值来更改图像的不透明度。**材质**属性允许您向图像添加材质。'
- en: The **Raycast Target** and **Raycast Padding** properties work the same way
    they do on the **Text** component, by specifying whether the Image will block
    clicks on UI objects behind it or not and if there is any padding to the block.
    The **Maskable** property determines if the Image can be affected by masks or
    not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**射线投射目标**和**射线投射填充**属性与**文本**组件上的工作方式相同，通过指定图像是否会阻止其后面的UI对象的点击以及是否有任何填充来阻止。**可遮罩**属性确定图像是否可以被遮罩影响。'
- en: 'When a sprite is assigned to the **Source Image** slot, new options appear
    in the **Image** component under **Image Type**, as shown in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当精灵被分配到**源图像**槽位时，在**图像**组件下的**图像类型**中会出现新的选项，如图下所示：
- en: '![Figure 11.1: The UI Image component and all its properties](img/B18327_11_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：UI图像组件及其所有属性](img/B18327_11_01.jpg)'
- en: 'Figure 11.1: The UI Image component and all its properties'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：UI图像组件及其所有属性
- en: Let’s look at the various options for **Image Type** and how they affect a sprite.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看**图像类型**的各种选项以及它们如何影响精灵。
- en: Image Type
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像类型
- en: 'The **Image Type** property determines how the sprite specified by **Source
    Image** will appear. There are four options: **Simple**, **Sliced**, **Tiled**,
    and **Filled**. Let’s take a look at them.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像类型**属性确定由**源图像**指定的精灵将如何显示。有四种选项：**简单**、**切片**、**平铺**和**填充**。让我们来看看它们。'
- en: Simple
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单
- en: An Image with its **Image Type** property set to **Simple** scales evenly across
    the sprite. This is the default type. When **Simple** is selected as the **Image
    Type**, a toggle labeled **Use Sprite Mesh**, a toggle labeled **Preserve Aspect**,
    and a button labeled **Set Native Size** become available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像的**图像类型**属性设置为**简单**时，图像在精灵上均匀缩放。这是默认类型。当选择**简单**作为**图像类型**时，会出现一个标签为**使用精灵网格**的切换按钮，一个标签为**保持纵横比**的切换按钮，以及一个标签为**设置原始大小**的按钮。
- en: Selecting the **Use Sprite Mesh** toggle will have the Image use the sprite
    mesh created by the **TextureImporter**. By default, this property is deselected,
    and the sprite’s mesh is a quad. You will select this property if you don’t want
    the Image represented by a rectangle, but instead want it to have a mesh that
    fits tightly around the visible area of the Image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**使用精灵网格**切换按钮将使图像使用由**TextureImporter**创建的精灵网格。默认情况下，此属性未选中，精灵的网格是一个四边形。如果你不希望图像以矩形表示，而是希望它有一个紧密围绕图像可见区域的网格，则将选择此属性。
- en: When the **Preserve Aspect** property is checked, the sprite will display with
    its portions preserved and may not appear to fill the entire area of the Rect
    Transform. Selecting this property ensures that your sprites look as originally
    intended and are not stretched out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当**保持纵横比**属性被勾选时，精灵将以保留其部分的方式显示，可能不会看起来填充整个Rect Transform区域。选择此属性确保你的精灵看起来与最初意图一致，并且不会被拉伸。
- en: Selecting the **Set Native Size** button sets the dimensions of the Image to
    the pixel dimensions of the sprite.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**设置原始大小**按钮将图像的尺寸设置为精灵的像素尺寸。
- en: Sliced
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片
- en: '**Sliced** Images are split into nine areas. When a **Sliced** Image is scaled,
    all areas of the Image are scaled, except the corners. This allows you to scale
    an Image without distorting its corners. This works particularly well with sprites
    that have rounded corners that you want to be able to stretch into rounded rectangles.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片**图像被分成九个区域。当**切片**图像被缩放时，图像的所有区域都会缩放，除了角落。这允许你在不扭曲角落的情况下缩放图像。这对于你想要拉伸成圆角矩形的具有圆角精灵特别有效。'
- en: When an image is set to **Sliced**, the **Fill Center** and **Pixels Per Unit
    Multiplier** properties appear. The following figure shows a rounded rectangle
    with five alternate versions of it being stretched. You can see how selecting
    **Sliced** allows the rounded rectangle to stretch in a way that maintains the
    rounded rectangle shape while leaving the **Image Type** at **Simple** causes
    a distortion in the edges of the Image when it is scaled.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像设置为**切片**时，会出现**填充中心**和**每单位像素乘数**属性。下图显示了一个圆角矩形及其五个变体被拉伸的情况。你可以看到选择**切片**如何允许圆角矩形以保持圆角矩形形状的方式拉伸，而将**图像类型**保持在**简单**则会在缩放图像时导致边缘扭曲。
- en: '![Figure 11.2: Sliced Image Type Example in the Chapter11 scene](img/B18327_11_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：第11章场景中的切片图像类型示例](img/B18327_11_02.jpg)'
- en: 'Figure 11.2: Sliced Image Type Example in the Chapter11 scene'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：第11章场景中的切片图像类型示例
- en: You must specify where the nine areas will be, within the **Sprite Editor**
    of the sprite or sprite sheet. If you have not specified the regions, a message
    will appear within the **Image** component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在精灵或精灵图的**精灵编辑器**中指定九个区域的位置。如果您没有指定区域，**图像组件**中将会显示一条消息。
- en: 'To specify the area in the **Sprite Editor**, you need to drag the green boxes
    on the edges of the sprite to the desired position. As you can see from the following
    screenshot, you want to drag the green lines so that they stop surrounding the
    curves of the edges:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**精灵编辑器**中指定区域，您需要将精灵边缘的绿色框拖动到所需位置。从以下屏幕截图可以看出，您想要拖动绿色线条，使它们停止围绕边缘的曲线：
- en: '![Figure 11.3: Specifying the nine areas of a sprite in the Sprite Editor](img/B18327_11_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：在精灵编辑器中指定精灵的九个区域](img/B18327_11_03.jpg)'
- en: 'Figure 11.3: Specifying the nine areas of a sprite in the Sprite Editor'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：在精灵编辑器中指定精灵的九个区域
- en: Next, let’s talk about the **Tiled** option under the **Image Type**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈**图像类型**下的**平铺**选项。
- en: Tiled
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平铺
- en: 'Selecting **Tiled** for **Image Type** will cause the Image to repeat to fill
    the stretched area. The following figure demonstrates how selecting **Simple**
    and **Tiled** for **Image Type** affects the scaled Images:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**平铺**作为**图像类型**将导致图像重复以填充拉伸区域。以下图示演示了选择**简单**和**平铺**作为**图像类型**如何影响缩放后的图像：
- en: '![Figure 11.4: Tiled Image Type Example in the Chapter11 scene](img/B18327_11_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：第11章场景中的平铺图像类型示例](img/B18327_11_04.jpg)'
- en: 'Figure 11.4: Tiled Image Type Example in the Chapter11 scene'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：第11章场景中的平铺图像类型示例
- en: Next, let’s talk about the **Filled** option under the **Image Type**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈**图像类型**下的**填充**选项。
- en: Filled
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充
- en: 'Images with **Filled** selected for their **Image Type** will fill in a percentage
    of the sprite, starting at an origin in a specified direction. Any part of the
    sprite past the designated percentage will not be rendered. When **Filled** is
    selected, new properties are displayed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**图像类型**选择**填充**的图像，将从指定方向的原点填充精灵的一部分，超过指定百分比的任何精灵部分将不会渲染。当选择**填充**时，将显示新的属性：
- en: '![Figure 11.5: Properties for a Filled Image](img/B18327_11_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5：填充图像的属性](img/B18327_11_05.jpg)'
- en: 'Figure 11.5: Properties for a Filled Image'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：填充图像的属性
- en: 'The `0.75` or 75 percent:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.75`或75%：'
- en: '![Figure 11.6: Filled Image Type Example in the Chapter11 scene](img/B18327_11_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：第11章场景中的填充图像类型示例](img/B18327_11_06.jpg)'
- en: 'Figure 11.6: Filled Image Type Example in the Chapter11 scene'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：第11章场景中的填充图像类型示例
- en: The **Horizontal** and **Vertical** **Fill Method** options are somewhat self-explanatory
    when you see them in action, but it’s a little more difficult to determine exactly
    how the three radial methods work just from looking at them. **Radial 90** places
    the center of the radial at one of the corners, **Radial 180** places the center
    of the radial at one of the edges, and **Radial 360** places the center of the
    radial in the center of the sprite.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到**水平**和**垂直****填充方法**选项在动作中的表现时，它们是相当直观的，但仅从外观上确定三种径向方法的确切工作方式可能有点困难。**径向90**将径向的中心放置在角落之一，**径向180**将径向的中心放置在边缘之一，而**径向360**将径向的中心放置在精灵的中心。
- en: The **Filled** **Image Type** option also has the **Set Native** **Size** property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**填充** **图像类型**选项也有**设置原始大小**属性。'
- en: Now that we’ve explored the UI Image component, we can look at some UI effect
    components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了UI图像组件，我们可以看看一些UI效果组件。
- en: UI effect components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI效果组件
- en: 'Three effects components allow you to add special effects to your Text and
    Image objects: **Shadow**, **Outline**, and **Position as UV1**. They can all
    be found under **Add Component** | **UI** | **Effects**. Let’s look at each one
    individually, starting with the Shadow component.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 三个效果组件允许您为文本和图像对象添加特殊效果：**阴影**、**轮廓**和**作为UV1定位**。它们都可以在**添加组件** | **UI** |
    **效果**下找到。让我们逐一查看每个组件，从阴影组件开始。
- en: Shadow
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影
- en: The **Shadow** component adds a simple shadow to your Text or Image object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**阴影**组件为您的文本或图像对象添加简单的阴影。'
- en: '![Figure 11.7: The Shadow component](img/B18327_11_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：阴影组件](img/B18327_11_07.jpg)'
- en: 'Figure 11.7: The Shadow component'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：阴影组件
- en: You can change the color and transparency of the shadow with the `0`, rendering
    it invisible, the shadow would remain visible based on the alpha specified on
    the **Effect** **Color** property.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`0`更改阴影的颜色和透明度，使其不可见，但基于**效果** **颜色**属性上指定的透明度，阴影仍然可见。
- en: 'The following figure shows a few examples of the **Shadow** component in action:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了**阴影**组件的一些示例：
- en: '![Figure 11.8: Shadow Component Example in the Chapter11 scene](img/B18327_11_08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：第11章场景中的阴影组件示例](img/B18327_11_08.jpg)'
- en: 'Figure 11.8: Shadow Component Example in the Chapter11 scene'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：第11章场景中的阴影组件示例
- en: All four bananas have the same alpha value set on their `0`, but since **Use
    Graphic Alpha** is not selected on the **Shadow** component, the shadow did not
    dim with the banana and remains at its designated alpha value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个香蕉都设置了相同的`0`透明度值，但由于**阴影**组件上未选择**使用图形透明度**，阴影没有随着香蕉变暗，并保持在指定的透明度值。
- en: Outline
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮廓
- en: The **Outline** component simulates an outline around the graphic by creating
    four shadows around it at specified distances.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮廓**组件通过在其周围指定距离处创建四个阴影来模拟图形的轮廓。'
- en: '![Figure 11.9: The Outline component](img/B18327_11_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9：轮廓组件](img/B18327_11_09.jpg)'
- en: 'Figure 11.9: The Outline component'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：轮廓组件
- en: The **Outline** component will create two shadows to the left and right of the
    original graphic based on **Effect Distance X** and two shadows to the top and
    bottom of the original graphic based on **Effect Distance Y**. Unlike the **Shadow**
    component, there is no difference in a negative or positive value for these two
    distances because the two shadows created for each axis are mirrored.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮廓**组件将根据**效果距离X**在原始图形的左侧和右侧创建两个阴影，根据**效果距离Y**在原始图形的顶部和底部创建两个阴影。与**阴影**组件不同，这两个距离的正负值没有区别，因为每个轴上创建的两个阴影是镜像的。'
- en: 'Setting the `-3` essentially just switches the positions of the two horizontal
    shadows, but the effect looks the same, as shown in the following figure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`-3`实际上只是交换了两个水平阴影的位置，但效果看起来相同，如下图所示：
- en: '![Figure 11.10: Outline Component Example 1 in the Chapter11 scene](img/B18327_11_10.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10：第11章场景中的轮廓组件示例1](img/B18327_11_10.jpg)'
- en: 'Figure 11.10: Outline Component Example 1 in the Chapter11 scene'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：第11章场景中的轮廓组件示例1
- en: 'The **Use Graphic Alpha** property works identically on this component as it
    does on the **Shadow** component, as shown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用图形透明度**属性在这个组件上的作用与在**阴影**组件上相同，如下所示：'
- en: '![Figure 11.11: Outline Component Example 2 in the Chapter11 scene](img/B18327_11_11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11：第11章场景中的轮廓组件示例2](img/B18327_11_11.jpg)'
- en: 'Figure 11.11: Outline Component Example 2 in the Chapter11 scene'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：第11章场景中的轮廓组件示例2
- en: Next, let’s look at the **Position As** **UV1** component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看**位置作为UV1**组件。
- en: Position As UV1
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置作为UV1
- en: The **Position As UV1** component allows you to change the UV channel that the
    Canvas renders on. This is used if you want to create custom shaders that utilize
    baked light maps.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置作为UV1**组件允许您更改Canvas渲染的UV通道。如果您想创建使用烘焙光照图的自定义着色器，则使用此功能。'
- en: '![Figure 11.12: The Position As UV1 component](img/B18327_11_12.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12：第11章场景中的位置作为UV1组件](img/B18327_11_12.jpg)'
- en: 'Figure 11.12: The Position As UV1 component'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：位置作为UV1组件
- en: Sadly, custom shaders are a pretty heavy topic and go past the scope of this
    text, so I won’t go any further into the usage of this component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，自定义着色器是一个相当复杂的话题，超出了本文的范围，所以我就不再深入探讨这个组件的用法了。
- en: Now that we’ve reviewed the UI Image component and some UI effect components,
    let’s look at some examples of ways we can use these components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了UI图像组件和一些UI效果组件，让我们看看我们可以如何使用这些组件的示例。
- en: Examples
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: In this chapter, we’ll expand on the scene we’ve been building further by adding
    some new UI elements. We’ll also look at some mobile/touchscreen UI and interactions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过添加一些新的UI元素来进一步扩展我们一直在构建的场景。我们还将探讨一些移动/触摸屏UI和交互。
- en: Some of these examples may seem better suited for the chapter on Buttons, but
    since they include access to the Image component’s properties, I placed them here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的一些可能更适合按钮章节，但既然它们包括了访问图像组件属性的权限，我就把它们放在这里。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have created two scenes that load into the scene we’ve been building upon:
    a start screen and an intro scene. Since I’ve been duplicating our main scene
    to make progress from each chapter easy to track, our intro sScene will not navigate
    to the updates we make in this and future chapters unless we keep updating the
    **Next Scene** variable on our **Dialogue Boxes** component in the intro sScene
    and including the new scene in our **Build Settings**.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了两个场景，它们将加载到我们一直在构建的场景中：一个开始屏幕和一个简介场景。由于我一直复制我们的主场景以使每个章节的进度跟踪变得容易，因此我们的简介场景将不会导航到我们在本章和未来章节中进行的更新，除非我们继续更新简介场景中**对话框**组件的**下一场景**变量，并将新场景包含在我们的**构建设置**中。
- en: I will not be including this update in the steps since scene navigation is no
    longer a focus of these examples. However, it will be included in the packages
    I include in each chapter’s completed scenes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在步骤中包含这个更新，因为场景导航不再是这些示例的重点。然而，它将包含在每个章节完成场景中我包含的包中。
- en: Horizontal and circular health/progress meters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水平和圆形生命值/进度条
- en: Let’s get back to our main scene. Duplicate the `Chapter10-Examples` scene to
    create a `Chapter11-Examples` scene.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的主场景。复制`Chapter10-Examples`场景以创建一个`Chapter11-Examples`场景。
- en: 'In this section, we’ll cover how to create two types of progress meters, a
    horizontal one and a circular one, as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何创建两种类型的进度条，一个是水平的一个是圆形的，如下面的截图所示：
- en: '![Figure 11.13: Example of horizontal and vertical progress bars](img/B18327_11_13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13：水平和垂直进度条的示例](img/B18327_11_13.jpg)'
- en: 'Figure 11.13: Example of horizontal and vertical progress bars'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：水平和垂直进度条的示例
- en: We’ll hook up the circular and horizontal progress meters so that they both
    display the progress of the same variable, and we can watch them both change at
    the same time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接圆形和水平进度条，使它们都显示相同变量的进度，并且我们可以同时观察它们的变化。
- en: The circular progress meter doesn’t really fit in the main scene that we’ve
    been building, and we’ll hide it after this chapter, but circular progress bars
    are common game elements, so I thought it was important to include an example
    of how to do them in this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形进度条实际上并不适合我们一直在构建的主场景，我们将在本章之后将其隐藏，但圆形进度条是常见的游戏元素，因此我认为在本章中包含一个如何实现它们的示例很重要。
- en: Horizontal health bar
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平生命值条
- en: There are a few different ways that a horizontal health bar can be created,
    but the quickest and easiest way is to scale a single axis based on percentage.
    When setting up a horizontal health bar in this way, it is important to ensure
    that the anchor is set at a position that represents a completely depleted bar.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建水平生命值条有几种不同的方法，但最快、最简单的方法是根据百分比缩放单个轴。以这种方式设置水平生命值条时，确保锚点设置在表示完全耗尽的条的位置非常重要。
- en: Remember that back in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), we set
    the anchor of the health bar to the left, so we have already set the anchor correctly.
    We also scaled the health bar in the *x* direction to show what the bar would
    look like as it depleted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[*第6章*](B18327_06.xhtml#_idTextAnchor085)中，我们设置了生命值条的锚点为左侧，因此我们已经正确设置了锚点。我们还沿*x*方向缩放了生命值条，以显示条在耗尽时的样子。
- en: '![](img/B18327_11_14.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18327_11_14.jpg)'
- en: 'Figure 11.14: The Health Bar’s Rect Transform component'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：生命值条的矩形变换组件
- en: Now, all we need to do is tie the percentage to the **X Scale** value of the
    health bar.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将百分比与生命值条的**X缩放**值关联起来。
- en: 'To tie the fill of the health bar to an actual value, complete the following
    steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将生命值条的填充与实际值关联，请完成以下步骤：
- en: Create a new C# script in your `Scripts` folder and name it `ProgressMeters.cs`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Scripts`文件夹中创建一个新的C#脚本，并将其命名为`ProgressMeters.cs`。
- en: 'In the `ProgressMeters` script, initialize the following four variables:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProgressMeters`脚本中，初始化以下四个变量：
- en: '[PRE0]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `health` variable represents the current health of the player, and the `totalHealth`
    variable represents the total health the player can obtain. As it doesn’t make
    sense for these values to be negative, they have been initialized at the `uint`
    type or a positive integer. I have made the `health` variable `public` so that
    it can be accessed via other scripts and seen within the Inspector. I made `totalHealth`
    a private `SerializeField` so that it cannot be accessed via other scripts but
    still be seen and assigned via the Inspector.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`health` 变量表示玩家的当前生命值，而 `totalHealth` 变量表示玩家可以获得的总生命值。由于这些值不应该是负数，它们已经被初始化为
    `uint` 类型或正整数。我将 `health` 变量设置为 `public`，以便可以通过其他脚本访问并在检查器中查看。我将 `totalHealth`
    设置为私有的 `SerializeField`，这样它就不能通过其他脚本访问，但仍然可以通过检查器查看和分配。'
- en: The `percentHealth` variable will be calculated based on the quotient of the
    `health` and `totalHealth` variables. I made this value private and serialized,
    not so that we can edit it in the Inspector but so that we can easily see its
    value change in the Inspector.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`percentHealth` 变量将基于 `health` 和 `totalHealth` 变量的商来计算。我将此值设置为私有并序列化，不是为了在检查器中编辑它，而是为了可以轻松地在检查器中看到其值的变化。'
- en: The `healthBar` variable stores the `RectTransform` component of the `Health
    Bar` UI Image within our scene.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`healthBar` 变量存储了我们场景中 `Health Bar` UI Image 的 `RectTransform` 组件。'
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since **RectTransform** inherits from **Transform**, we could have declared
    **healthBar** as a **Transform** and the following code would still work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **RectTransform** 继承自 **Transform**，我们本可以将 **healthBar** 声明为 **Transform**，并且下面的代码仍然可以工作。
- en: 'Return to the Unity Editor and drag the `ProgessMeters` script onto `HUD Canvas`
    > `Top Left Panel`. Assign the value `500` to both the `Health Bar` UI Image into
    the **Health Bar** slot. Any value you try to type into the **Percent Health**
    slot will be overridden by the code we write in the next step. Your component
    should look as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 编辑器，将 `ProgessMeters` 脚本拖放到 `HUD Canvas` > `Top Left Panel`。将值 `500`
    分配给 **Health Bar** 槽中的 `Health Bar` UI Image。你尝试输入到 **Percent Health** 槽中的任何值都将被我们在下一步中编写的代码覆盖。你的组件应该如下所示：
- en: '![Figure 11.15: The Progress Meters component](img/B18327_11_15.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15：进度条组件](img/B18327_11_15.jpg)'
- en: 'Figure 11.15: The Progress Meters component'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15：进度条组件
- en: 'We want any changes made to our `health` value to automatically update the
    `percentHealth` value and the scale of our `healthBar`. To do that, we can put
    the following code in the `Update()` function:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望对 `health` 值的任何更改都能自动更新 `percentHealth` 值和 `healthBar` 的比例。为此，我们可以在 `Update()`
    函数中放置以下代码：
- en: '[PRE1]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Declaring our `health` and `totalHealth` variables with the `uint` type stopped
    them from becoming negative, but we still need to put an upper cap on our `health`
    variable. It doesn’t make sense for it to exceed the `totalHealth` variable.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `uint` 类型声明我们的 `health` 和 `totalHealth` 变量阻止了它们变成负数，但我们仍然需要给 `health` 变量设置一个上限。它不应该超过
    `totalHealth` 变量。
- en: While `percentHealth` is a `float` variable, performing a division between two
    `uint` variables will result in a `uint` type, so adding `(float)` at the beginning
    of the integer division provides a `float` result from the division.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然 `percentHealth` 是一个 `float` 类型的变量，但两个 `uint` 类型的变量之间进行除法运算将得到一个 `uint` 类型的结果，因此在整数除法前添加
    `(float)` 可以得到一个浮点数结果。
- en: The last part of the code sets the `localScale` value of the `healthBar`. When
    you scale a UI object, you have to use `localScale`. This scales the object locally,
    meaning relative to its parent object.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的最后部分设置了 `healthBar` 的 `localScale` 值。当你缩放 UI 对象时，你必须使用 `localScale`。这意味着相对于其父对象进行缩放。
- en: 'Now, we can test the code easily in the Editor. Play the game and hover your
    mouse over the word **Health** in the **Progress Meters** component until the
    mouse displays two arrows around it, as shown in the following figure:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在编辑器中轻松测试代码。玩游戏并将鼠标悬停在 **Progress Meters** 组件中的 **Health** 字样上，直到鼠标显示围绕它的两个箭头，如图所示：
- en: '![Figure 11.16: The Progress Meters component’s effect on the meter](img/B18327_11_16.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16：进度条组件对仪表的影响](img/B18327_11_16.jpg)'
- en: 'Figure 11.16: The Progress Meters component’s effect on the meter'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：进度条组件对仪表的影响
- en: When these arrows appear, clicking and dragging will manipulate the values of
    the variable based on your mouse position. You’ll see, as you do this, that as
    the `Health Bar` in the scene changes size. You’ll note that you cannot set the
    value of `0` or above `500`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些箭头出现时，点击并拖动将根据您的鼠标位置操纵变量的值。您会看到，当您这样做时，场景中的“生命值条”大小会变化。您会注意到您不能设置 `0` 或以上
    `500` 的值。
- en: As you can see, setting up a horizontal health bar isn’t terribly difficult.
    Duplicating this process in a game where the health reduces by Events won’t require
    a lot of steps to achieve. Just ensure that you set the anchor of the health bar
    correctly. This process will work similarly for a vertical health bar.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，设置水平生命值条并不特别困难。在游戏中通过事件减少生命值时重复此过程不需要很多步骤即可实现。只需确保正确设置生命值条的锚点。这个过程对于垂直生命值条也类似有效。
- en: Circular progress meter
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 圆形进度条
- en: Horizontal health bars didn’t take a lot of work to set up. The work to make
    a circular progress meter is just about as easy and can be completed with only
    two more lines of code. Since we don’t already have a circular progress bar in
    our scene, we will have to start with a bit of setup first.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 水平生命值条设置起来并不需要太多工作。制作圆形进度条的工作几乎一样简单，只需再添加两行代码即可完成。由于我们场景中还没有圆形进度条，我们首先需要做一些设置。
- en: 'To create a circular progress bar, complete the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建圆形进度条，请完成以下步骤：
- en: From the code bundle, drag the `circularMeter.png` sprite into the `Sprites`
    folder of your project.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码包中，将 `circularMeter.png` 精灵拖入项目中的 `Sprites` 文件夹。
- en: Set the `circularMeter.png` sprite to **Multiple** and automatically slice it
    in the **Sprite Editor**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `circularMeter.png` 精灵设置为 **多重** 并在 **精灵编辑器** 中自动切片。
- en: Select the `Top Left Panel` within the Hierarchy and give it a new UI Image
    child. Name the Image `Progress Holder`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择“左上角面板”，并为其添加一个新的 UI Image 子项。将 Image 命名为 `Progress Holder`。
- en: Similar to how we set up the health bar, there will be a holder and a fill.
    Drag the `circularMeter_0` sub-sprite into the `Progress Holder`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们设置生命值条的方式类似，将会有一个持有者和一个填充。将 `circularMeter_0` 子精灵拖入 `Progress Holder`。
- en: It’s important that we get the right proportions for our holder and fill Images.
    So, to ensure that the Image is correctly proportioned, hit the **Set Native Size**
    button on the **Image** component.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的持有者和填充图像获取正确的比例非常重要。因此，为了确保图像比例正确，点击 **设置原始大小** 按钮在 **图像** 组件上。
- en: Now, add a child UI Image to `Progress Holder` called `Progress Meter`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `Progress Holder` 添加一个名为 `Progress Meter` 的子 UI Image。
- en: Set the anchor preset of `Progress Meter` to middle center. Do not stretch it.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“进度条”的锚点预设设置为居中。不要拉伸它。
- en: Add `circularMeter_1` to the `Progress Meter`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `circularMeter_1` 添加到 `Progress Meter`。
- en: 'Hit the `Progress Meter` **Image** component as well. After completing this
    step, you should see the following:![Figure 11.17: The progress on the Progress
    Meter](img/B18327_11_17.jpg)'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时点击“进度条”的“图像”组件。完成此步骤后，您应该看到以下内容：![图 11.17：进度条上的进度](img/B18327_11_17.jpg)
- en: 'Figure 11.17: The progress on the Progress Meter'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.17：进度条上的进度
- en: If the pink fill is not perfectly nestled inside the blue holder, you may have
    forgotten to hit the `Progress Meter` does not have its anchor preset set to middle
    center.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果粉红色填充没有完美地嵌入蓝色持有者中，您可能忘记点击“进度条”的锚点预设没有设置为居中。
- en: Let’s move this meter and scale it a bit. Select `Progress Holder` and move
    it so that it is positioned in the scene below `Character Holder`. Set the `Progress
    Holder` to `0.8` to make it a little smaller.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们移动这个仪表并稍微缩放一下。选择 `Progress Holder` 并将其移动到场景中位于 `Character Holder` 下方。将 `Progress
    Holder` 设置为 `0.8` 以使其稍微小一些。
- en: '![Figure 11.18: Repositioning the circular progress meter](img/B18327_11_18.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18：重新定位圆形进度条](img/B18327_11_18.jpg)'
- en: 'Figure 11.18: Repositioning the circular progress meter'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18：重新定位圆形进度条
- en: 'The last thing to do to the code is to change the `Progress Meter`. Change
    the **Image Type** to **Filled** with a **Radial 360 Fill Method**. Change the
    **Fill Origin** to **Top**. Adjust the scroll bar on the **Fill Amount** to preview
    the meter filling:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码的最后一件事情是更改 `Progress Meter`。将 **图像类型** 更改为 **填充** 并使用 **径向 360 填充方法**。将 **填充起源**
    更改为 **顶部**。调整 **填充量** 上的滚动条以预览仪表填充：
- en: '![Figure 11.19: Adjusting the fill amount on the circular progress meter](img/B18327_11_19.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19：调整圆形进度条上的填充量](img/B18327_11_19.jpg)'
- en: 'Figure 11.19: Adjusting the fill amount on the circular progress meter'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19：调整圆形进度条上的填充量
- en: 'Now, we’re ready to write some code. As you have probably guessed from adjusting
    the `fillAmount` value to the `percentHealth` variable in our code. First, we
    need to create a variable with which we can access the Image component of our
    `Progress Meter`. Declare the following variable at the top of your code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好编写一些代码。正如您可能从调整代码中 `fillAmount` 值到 `percentHealth` 变量中猜到的。首先，我们需要创建一个变量，我们可以通过它访问
    `Progress Meter` 的图像组件。在代码顶部声明以下变量：
- en: '[PRE2]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, add the following at the end of the `Update()` function:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Update()` 函数的末尾添加以下内容：
- en: '[PRE3]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last thing we need to do is hook the `Progress Meter` UI Image to the `progressMeter`
    variable. Drag the `Progress Meter` into the **Progress** **Meter** slot.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的是将 `Progress Meter` UI 图像连接到 `progressMeter` 变量。将 `Progress Meter` 拖动到
    **进度** **条** 槽中。
- en: '![Figure 11.20: The Progress Meter component’s updates](img/B18327_11_20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20：进度条组件的更新](img/B18327_11_20.jpg)'
- en: 'Figure 11.20: The Progress Meter component’s updates'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20：进度条组件的更新
- en: Play the game and adjust the **Health** value in the Inspector as you did earlier,
    and watch the two meters move in unison.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播玩游戏，并在检查器中调整 **健康** 值，就像您之前做的那样，并观察两个仪表同时移动。
- en: '![Figure 11.21: Result of the Progress Meter](img/B18327_11_21.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.21：进度条的最终结果](img/B18327_11_21.jpg)'
- en: 'Figure 11.21: Result of the Progress Meter'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21：进度条的最终结果
- en: As you can see, making a circular progress meter is really not more difficult
    than making a horizontal one!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，制作圆形进度条实际上并不比制作水平进度条更困难！
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the same way we used the fill amount for the circular progress bar, we could
    have used the fill amount for the horizontal health bar. Setting the **Image Type**
    property to **Filled** and **Horizontal** and then affecting the **Fill Amount**
    value rather than the scale would have had a similar effect.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前使用的圆形进度条的填充量相同，我们也可以使用水平生命条上的填充量。将**图像类型**属性设置为**填充**和**水平**，然后影响**填充量**值而不是缩放，会产生类似的效果。
- en: Because this circular progress meter wasn’t part of the original UI plan and
    was only placed in the scene for demonstration purposes, I am going to disable
    it in all future figures and screenshots.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个圆形进度条不是原始 UI 计划的一部分，只是为了演示目的而放置在场景中，我将在所有未来的图表和屏幕截图中禁用它。
- en: Mute Buttons with sprite swap
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有精灵交换的静音按钮
- en: Now, let’s look at an example where we swap the sprite of a Button based on
    a pre-defined state. This is different than a sprite swap transition, which we
    discussed in [*Chapter 9*](B18327_09.xhtml#_idTextAnchor213), because it won’t
    use the states of highlighted, pressed, selected, or disabled. It’s included in
    this chapter rather than the Buttons chapter since it involves affecting the Image
    component, not the Button component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个基于预定义状态交换按钮精灵的例子。这与我们在[*第 9 章*](B18327_09.xhtml#_idTextAnchor213)中讨论的精灵交换过渡不同，因为它不会使用高亮、按下、选中或禁用状态。它包含在本章而不是按钮章节中，因为它涉及影响图像组件，而不是按钮组件。
- en: 'In the scene, we have a `Pause Panel` that pops up when the *P* key is hit
    on the keyboard. On this Panel, we will place two mute Buttons, one for music
    and one for sound, which will toggle between muted and unmuted states. The Panel
    will appear as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中，我们有一个在按下键盘上的 *P* 键时弹出的 `Pause Panel`。在这个面板上，我们将放置两个静音按钮，一个用于音乐，一个用于声音，它们将在静音和取消静音状态之间切换。面板将如以下屏幕截图所示：
- en: '![Figure 11.22: The Pause Panel with new mute Buttons](img/B18327_11_22.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22：带有新静音按钮的暂停面板](img/B18327_11_22.jpg)'
- en: 'Figure 11.22: The Pause Panel with new mute Buttons'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22：带有新静音按钮的暂停面板
- en: 'To add the music and sound Buttons shown in the preceding screenshot, complete
    the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加前面屏幕截图所示的音效和声音按钮，请完成以下步骤：
- en: 'First, we need to bring in a new art asset. The Button sprites on the sprite
    sheet we imported previously are a bit too small and don’t contain a muted version.
    So, I edited them a bit and provided a new sprite for you. In the book’s source
    files, you should find an `.png` file named `muteUnmute.png`:![Figure 11.23: The
    muteUnmute.png sprite](img/B18327_11_23.jpg)'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要引入一个新的艺术资产。我们之前导入的精灵表中的按钮精灵有点太小，并且不包含静音版本。因此，我稍作编辑，并为您提供了一个新的精灵。在本书的源文件中，您应该找到一个名为
    `muteUnmute.png` 的 `.png` 文件：![图 11.23：muteUnmute.png 精灵](img/B18327_11_23.jpg)
- en: 'Figure 11.23: The muteUnmute.png sprite'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.23：muteUnmute.png 精灵
- en: Import this `.png` file into your project’s `Assets/Sprites` folder.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此 `.png` 文件导入到项目文件夹 `Assets/Sprites` 中。
- en: 'Slice the sprite into multiple sub-sprites by changing its **Sprite Mode**
    to **Multiple**, opening its **Sprite Editor**, and applying the automatic slice
    type. Multiple sprites should appear as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 **Sprite Mode** 改为 **Multiple**，打开其 **Sprite Editor** 并应用自动切片类型，将精灵切割成多个子精灵。多个精灵应如下所示：
- en: '![Figure 11.24: The muteUnmute.png sprite sliced](img/B18327_11_24.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24：muteUnmute.png 精灵切片](img/B18327_11_24.jpg)'
- en: 'Figure 11.24: The muteUnmute.png sprite sliced'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24：muteUnmute.png 精灵切片
- en: Create two new Buttons as children of the `Pause Panel` and name them `Music
    Button` and `Sound Button`. Delete their text children because we do not need
    them.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个新的按钮作为 `Pause Panel` 的子项，并分别命名为 `Music Button` 和 `Sound Button`。删除它们的文本子项，因为我们不需要它们。
- en: '![Figure 11.25: The current view of the Hierarchy](img/B18327_11_25.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.25：当前层次结构视图](img/B18327_11_25.jpg)'
- en: 'Figure 11.25: The current view of the Hierarchy'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25：当前层次结构视图
- en: 'Give the two new Buttons the following **Rect Transform** and **Image** properties:![Figure
    11.26: The Rect Transform of the two Buttons](img/B18327_11_26.jpg)'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给这两个新的按钮以下 **Rect Transform** 和 **Image** 属性：![图 11.26：两个按钮的 Rect Transform](img/B18327_11_26.jpg)
- en: 'Figure 11.26: The Rect Transform of the two Buttons'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.26：两个按钮的 Rect Transform
- en: 'Your Panel should now look just like the one at the beginning of this example:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的面板现在应该看起来就像本例开头的那样：
- en: '![Figure 11.27: The Pause Panel](img/B18327_11_27.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.27：暂停面板](img/B18327_11_27.jpg)'
- en: 'Figure 11.27: The Pause Panel'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.27：暂停面板
- en: Now, let’s write some code to make these Buttons swap sprites that will represent
    the sound and music toggling on and off. Create a new script called `MuteUnmute.cs`
    in your `Assets/Scripts` folder.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些代码来使这些按钮交换代表声音和音乐开关的精灵。在您的 `Assets/Scripts` 文件夹中创建一个新的脚本，命名为 `MuteUnmute.cs`。
- en: 'Replace the code of `MuteUnmute` with the following:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `MuteUnmute` 的代码替换为以下内容：
- en: '[PRE4]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, this code contains two main functions: `ToggleMusic()` and
    `ToggleSound()`. These two function identically by simply swapping the sprite
    on the specified Button based on the `musicOn` and `soundOn` Boolean values.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码包含两个主要函数：`ToggleMusic()` 和 `ToggleSound()`。这两个函数通过根据 `musicOn` 和 `soundOn`
    布尔值在指定的按钮上交换精灵而完全相同。
- en: To swap the sprite, the script first finds the Image component on the two Buttons
    specified as `musicButton` and `soundButton`, within the `Awake()` function. These
    Buttons will be assigned in the Inspector. It then swaps the sprite of the Image
    component to the correct sprite from an array of sprites. The sprites for the
    mute and unmute states will be assigned in the Inspector in a future step.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要交换精灵，脚本首先在 `Awake()` 函数中找到指定为 `musicButton` 和 `soundButton` 的两个按钮上的 Image 组件，这些按钮将在检查器中分配。然后，脚本将
    Image 组件的精灵交换到精灵数组中的正确精灵。静音和取消静音状态的精灵将在未来的步骤中在检查器中分配。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sadly, this book does not cover adding sound and music to a Unity project.
    The code provided here doesn’t actually mute and unmute audio; it simply swaps
    sprites. You will simply need to include two audio sources: one for playing music
    and one for playing sounds that have the **Music** and **Sound** tags, respectively.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这本书没有涵盖向 Unity 项目添加声音和音乐。这里提供的代码实际上并没有静音和取消静音音频；它只是交换精灵。您只需包含两个音频源：一个用于播放音乐，一个用于播放带有
    **Music** 和 **Sound** 标签的声音。
- en: 'Go back to the Unity Editor and attach the `MuteUnmute.cs` script to the `Pause
    Panel` by dragging it into its **Inspector**:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 编辑器，通过将其拖动到其 **Inspector** 中将 `MuteUnmute.cs` 脚本附加到 `Pause Panel`：
- en: '![Figure 11.28: The Mute Unmute component](img/B18327_11_28.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.28：静音/取消静音组件](img/B18327_11_28.jpg)'
- en: 'Figure 11.28: The Mute Unmute component'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.28：静音/取消静音组件
- en: Now, we want to assign the appropriate Buttons and sprites to the slots. Drag
    the `Music Button` and `Sound Button` into their designated slots from the Hierarchy.
    Drag and drop the audio Button sprites from the project view to their appropriate
    slots, making sure to put the muted sprite in the 0 element of the array.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要将适当的按钮和精灵分配到槽位。从层次结构中将 `Music Button` 和 `Sound Button` 拖动到它们的指定槽位。从项目视图中拖放音频按钮精灵到它们的适当槽位，确保将静音精灵放在数组的
    0 元素中。
- en: '![Figure 11.29: The updated Mute Unmute component](img/B18327_11_29.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.29：更新的静音/取消静音组件](img/B18327_11_29.jpg)'
- en: 'Figure 11.29: The updated Mute Unmute component'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.29：更新的静音/取消静音组件
- en: Now, we just need to hook up the Buttons to call the appropriate functions.
    Select the `Music Button`. Select the `OnClick()` Event list of the `MuteUnmute.cs`,
    is on the `Pause Panel`, so drag the `Pause Panel` into the object slot. Now,
    from the function dropdown menu, select **MuteUnmute** | **ToggleMusic**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要将按钮连接到调用适当的函数。选择`Music Button`。选择`MuteUnmute.cs`的`OnClick()`事件列表，位于`Pause
    Panel`上，因此将`Pause Panel`拖入对象槽中。现在，从函数下拉菜单中选择**MuteUnmute** | **ToggleMusic**。
- en: Perform the same actions as you did in the previous step for the `Sound Button`,
    but this time select **MuteUnmute** | **ToggleSound** from the function dropdown
    list.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Sound Button`执行与之前步骤相同的操作，但这次从函数下拉列表中选择**MuteUnmute** | **ToggleSound**。
- en: Now, play the game, press *P* to bring up the `Pause Panel`, and you will see
    the Buttons toggle back and forth between their two different sprites.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩游戏，按下*P*键调出`Pause Panel`，你会看到按钮在两个不同的精灵之间切换。
- en: Now that we’ve looked at how to implement progress meters and sprite swap Buttons,
    let’s look at how to implement a few different mobile-specific interactions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何实现进度条和精灵交换按钮，让我们看看如何实现一些不同的移动特定交互。
- en: Adding press-and-hold/long-press functionality
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加按下并保持/长按功能
- en: Press-and-hold is utilized frequently in mobile games. Many games that use right-click
    on a PC or the web use press-and-hold when they are converted to the mobile platform.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动游戏中，按下并保持（Press-and-hold）操作被频繁使用。许多在PC或网页上使用右键点击的游戏，在转换为移动平台时使用按下并保持操作。
- en: 'To demonstrate how to implement press-and-hold functionality, we will create
    a Button that has a growing ring that represents hold time. Once a specified amount
    of time has passed, a function will fire:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何实现按下并保持功能，我们将创建一个具有表示保持时间的增长环的按钮。一旦经过指定的时间，就会触发一个函数：
- en: '![Figure 11.30: Press-and-hold Button example](img/B18327_11_30.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图11.30：按下并保持按钮示例](img/B18327_11_30.jpg)'
- en: 'Figure 11.30: Press-and-hold Button example'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30：按下并保持按钮示例
- en: When working on this example, it is important to remember that even though the
    code is referencing a pointer, this functionality does not work exclusively with
    a mouse. Placing a finger on a touchscreen functions in the same way as a pointer
    down, and picking up the finger works the same as a pointer up.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这个示例时，重要的是要记住，尽管代码引用了指针，但这种功能并不仅限于鼠标。在触摸屏上放置手指与指针按下功能相同，抬起手指与指针抬起功能相同。
- en: 'To create a Button with a growing ring that represents hold time, complete
    the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个表示保持时间的增长环的按钮，请按照以下步骤操作：
- en: Create a new scene named `Chapter11-Examples-Buttons1` in the `Assets/Scenes`
    folder and open the new scene.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scenes`文件夹中创建一个名为`Chapter11-Examples-Buttons1`的新场景并打开该场景。
- en: Select **+** | **UI** | **Button** to create a new Button in the scene.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**+** | **UI** | **Button**在场景中创建一个新的按钮。
- en: Set the Button’s **Transition** type on the **Button** component to **None**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮组件的**过渡**类型设置为**无**。
- en: Change the text on the Button to say `Press` `and Hold`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮上的文本更改为`Press` `and Hold`。
- en: Right-click the `Button` in the Hierarchy and select `Image` child to the `Button`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中右键单击`Button`，然后选择`Button`的`Image`子项。
- en: Change the `Image`’s `50`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Image`的`50`。
- en: Assign the `circularMeter_1` sprite to the **Source Image** property of the
    **Image** component.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`circularMeter_1`精灵分配给**Image**组件的**源图像**属性。
- en: Change the `0`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0`更改为。
- en: To create press-and-hold functionality on the `Button`, we will utilize the
    `Button` object.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在`Button`上创建按下并保持功能，我们将使用`Button`对象。
- en: Select **Add New Event Type** and select **PointerDown**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加新事件类型**并选择**PointerDown**。
- en: Select **Add New Event Type** and select **PointerUp**.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加新事件类型**并选择**PointerUp**。
- en: Now, we need to actually write the functions that will be called by the Event
    Triggers we set up in the previous steps. Create a new script in the `Assets/Scripts`
    folder called `LongPressButton`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实际编写在之前步骤中设置的触发器事件将要调用的函数。在`Assets/Scripts`文件夹中创建一个新的脚本，命名为`LongPressButton`。
- en: Before opening the script, go ahead and attach it as a component to `Button`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开脚本之前，先将它作为组件附加到`Button`上。
- en: 'Add the `UnityEngine.UI` namespace to the top of the script with the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部添加`UnityEngine.UI`命名空间，如下所示：
- en: '[PRE5]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To check how long the Button is being pressed, we will use a Boolean variable
    that checks to see if the Button is being held and a few different variables related
    to time. Add the following variable declaration to your script:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查按钮被按下的持续时间，我们将使用一个布尔变量来检查按钮是否被按下，以及一些与时间相关的不同变量。将以下变量声明添加到您的脚本中：
- en: '[PRE6]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `buttonPressed` variable will be set to `true` with the `startTime` variable
    will be set to the current time when the `holdTime` variable will determine how
    much time has passed since `startTime`. The `longHoldTime` variable is the amount
    of time the Button must be held down before the long press is complete. It is
    serialized so that it can be easily customized.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`holdTime`变量确定自`startTime`以来经过的时间时，`buttonPressed`变量将被设置为`true`，而`startTime`变量将被设置为当前时间。`longHoldTime`变量是按钮必须按下直到长按完成所需的时间量。它是序列化的，以便可以轻松自定义。
- en: 'The last variable we need will represent the radial filling Image. Add the
    following variable declaration to your code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的最后一个变量将表示径向填充图像。将以下变量声明添加到您的代码中：
- en: '[PRE7]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we need to write a function that will be called by both the **Pointer
    Down** and **Pointer** **Up** Events:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编写一个函数，该函数将由**指针按下**和**指针抬起**事件调用：
- en: '[PRE8]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function accepts a Boolean variable from the Event Trigger. It then sets
    the value of `buttonPressed` to the passed value.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数接受来自事件触发器的布尔变量。然后，它将`buttonPressed`的值设置为传递的值。
- en: When the Button is released, a value of `false` will be passed to the function.
    If the value passed is `false`, the amount of time that has passed, `holdTime`,
    is reset to `0`, and the `radialFillImage` Image is reset to have a `fillAmount`
    value of `0`.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当按钮被释放时，将向函数传递一个值为`false`的值。如果传递的值是`false`，则经过的时间`holdTime`将被重置为`0`，`radialFillImage`图像将被重置为`fillAmount`值为`0`。
- en: When the Button is pressed, the `startTime` value will be set to the current
    time.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当按钮被按下时，`startTime`值将被设置为当前时间。
- en: 'Create a function that will be called once the full amount of time needed for
    the long press, specified by `longHoldTime`, has completed:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，当指定的`longHoldTime`所需的时间完成时将被调用：
- en: '[PRE9]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function doesn’t really do anything but reset the filling Image and print
    out a `Debug.Log`. However, you can later reuse this code and replace the `Debug.Log`
    line with more interesting and meaningful actions.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数实际上并没有做任何事情，只是重置填充图像并打印出`Debug.Log`。然而，您可以在以后重用此代码，并将`Debug.Log`行替换为更有趣和更有意义的操作。
- en: 'The `Update()` function can be used to make the timer count upward. Adjust
    the `Update()` function as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`Update()`函数来使计时器向上计数。按如下方式调整`Update()`函数：
- en: '[PRE10]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code makes the value of `holdTime` tick upward if the `buttonPressed` value
    is set to `true`. Remember—`buttonPressed` will be set to `true` with a `false`
    with a `holdTime` value reaches the value specified by `longHoldTime`, the timer
    will stop ticking up, because `buttonPressed` will be reset to `false`. Additionally,
    the `LongPressCompleted()` function is called. If `longHoldTime` has not yet been
    reached, the Image’s radial fill will update to represent the percentage of total
    required time that has transpired.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`buttonPressed`的值设置为`true`，则此代码将使`holdTime`的值向上递增。记住——当`holdTime`的值达到`longHoldTime`指定的值时，`buttonPressed`将被重置为`false`，计时器将停止递增。此外，将调用`LongPressCompleted()`函数。如果尚未达到`longHoldTime`，图像的径向填充将更新以表示已发生所需总时间的百分比。
- en: Now that the script is completed, we can hook up the `PressAndRelease()` function
    with the Event Triggers on the Button. Add the `PressAndRelease` function from
    the static list to both the `PressAndRelease()` function accepts a Boolean variable,
    there is a checkbox representing the Boolean value that should be passed. Select
    the checkbox for the `true`) but not for the `false`).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在脚本已完成，我们可以将`PressAndRelease()`函数连接到按钮上的事件触发器。将静态列表中的`PressAndRelease`函数添加到两个事件触发器上。`PressAndRelease`函数接受一个布尔变量，有一个复选框表示应该传递的布尔值。选择`true`的复选框（但不要选择`false`）。
- en: '![Figure 11.31: The Event Trigger component](img/B18327_11_31.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图11.31：事件触发器组件](img/B18327_11_31.jpg)'
- en: 'Figure 11.31: The Event Trigger component'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31：事件触发器组件
- en: Now, we need to assign the `Image` to the **Radial Fill Image** slot on the
    **Long** **Press** component.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`Image`分配到**长按**组件上的**径向填充图像**槽位。
- en: '![Figure 11.32: The Long Press component](img/B18327_11_32.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图11.32：长按组件](img/B18327_11_32.jpg)'
- en: 'Figure 11.32: The Long Press component'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32：长按组件
- en: Playing the game now will demonstrate the Image radially filling when you hold
    the Button and printing `Do something after long press` in the console. If you
    release the Button before the fill has completed, it will go away and reset for
    when you start clicking again.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏将演示当你按住按钮时图像径向填充，并在控制台打印`Do something after long press`。
- en: Press-and-hold is a pretty common functionality, and while it isn’t a pre-installed
    Event in the Unity Event library, luckily it isn’t too difficult to hook up. I
    recommend holding on to that script so that you can reuse it in the future.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 按住并保持是一个相当常见的功能，虽然它不是Unity事件库中预安装的事件，但幸运的是，它并不太难连接。我建议保留这个脚本，以便将来可以重用它。
- en: Creating a static four-directional virtual D-Pad
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个静态的四方向虚拟D-Pad
- en: A D-Pad is simply four Buttons on a directional pad. To create a D-Pad for a
    mobile game, you just need to create a graphic that contains four Buttons on the
    directions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: D-Pad简单来说就是方向板上四个按钮。要为移动游戏创建一个D-Pad，你只需要创建一个包含四个按钮的图形。
- en: The art used in this example was obtained from [https://opengameart.org/content/onscreen-controls-8-styles](https://opengameart.org/content/onscreen-controls-8-styles).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的艺术作品来自[https://opengameart.org/content/onscreen-controls-8-styles](https://opengameart.org/content/onscreen-controls-8-styles)。
- en: 'To create a virtual D-Pad, complete the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个虚拟D-Pad，请完成以下步骤：
- en: Create a new scene named `Chapter11-Examples-Buttons2` in the `Assets/Scenes`
    folder and open the new scene.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scenes`文件夹中创建一个名为`Chapter11-Examples-Buttons2`的新场景并打开新场景。
- en: Import the `dPadButtons.png` sprite sheet into the `Assets/Sprites` folder.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dPadButtons.png`精灵图集导入到`Assets/Sprites`文件夹。
- en: Change the newly imported sprite’s **Sprite Mode** to **Multiple** and automatically
    slice it.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新导入的精灵的**Sprite Mode**更改为**Multiple**并自动切割。
- en: Create a new Canvas with `D-Pad Canvas`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Canvas，并命名为`D-Pad Canvas`。
- en: The size of a D-Pad is incredibly important on mobile devices. Even if the screen
    gets smaller, you’ll probably want the D-Pad to be about the same size. If it
    gets too small, the game can be unplayable or uncomfortable. Therefore, set the
    **Canvas Scaler** component’s **UI Scale Mode** value to **Constant** **Physical
    Size**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移动设备上，D-Pad的大小非常重要。即使屏幕变得更小，你可能也希望D-Pad的大小保持不变。如果它太小，游戏可能无法玩或感觉不舒服。因此，将**Canvas
    Scaler**组件的**UI Scale Mode**值设置为**Constant** **Physical Size**。
- en: Add a new Image as a child of `D-Pad Canvas` with `D-Pad Background`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的Image作为`D-Pad Canvas`的子对象添加，并命名为`D-Pad Background`。
- en: Set the `dPadButtons_4`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`dPadButtons_4`。
- en: Set its anchor and pivot to the lower-left corner of the screen, and set its
    `30`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其锚点和枢轴设置为屏幕的左下角，并设置其`30`。
- en: 'Set its `200`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`200`：
- en: '![Figure 11.33: The D-Pad positioned correctly](img/B18327_11_33.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图11.33：正确定位的D-Pad](img/B18327_11_33.jpg)'
- en: 'Figure 11.33: The D-Pad positioned correctly'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33：正确定位的D-Pad
- en: Right-click on `D-Pad Background` and add a new Button as a child with `Up`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`D-Pad Background`并添加一个新的按钮作为子对象，并命名为`Up`。
- en: Remove its child `Text` object.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除其子`Text`对象。
- en: Set the `Up` Button to `0`, `65`, `60`, and `60`, respectively. This will create
    a square over just the up position of the D-Pad Image.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Up`按钮的值分别设置为`0`、`65`、`60`和`60`。这将创建一个覆盖D-Pad Image向上位置的方块。
- en: '![Figure 11.34: The D-Pad with an Up Button](img/B18327_11_34.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图11.34：带有向上按钮的D-Pad](img/B18327_11_34.jpg)'
- en: 'Figure 11.34: The D-Pad with an Up Button'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34：带有向上按钮的D-Pad
- en: Duplicate the `Up` Button three times and rename the duplicates `Right`, `Left`,
    and `Down`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Up`按钮复制三次，并将副本重命名为`Right`、`Left`和`Down`。
- en: Set the `Right` Button’s `65` and `0`, respectively.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Right`按钮的`65`和`0`分别设置。
- en: Set the `Left` Button’s `-65` and `0`, respectively.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Left`按钮的`-65`和`0`分别设置。
- en: 'Set the `Down` Button’s `0` and `-65`, respectively. You should now have four
    Buttons positioned as follows:![Figure 11.35: The D-Pad with all of its Buttons](img/B18327_11_35.jpg)'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Down`按钮的`0`和`-65`分别设置。现在你应该有四个按钮，位置如下：![图11.35：带有所有按钮的D-Pad](img/B18327_11_35.jpg)
- en: 'Figure 11.35: The D-Pad with all of its Buttons'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.35：带有所有按钮的D-Pad
- en: These four Buttons cover the entire area of the arms of the directional pad.
    They will act as the hit area for the directions.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这四个按钮覆盖了方向板臂的整个区域。它们将作为方向的击中区域。
- en: We only really want these four Buttons for their hit area and don’t want to
    actually have them visible in the UI. Select all four of the Buttons in the Hierarchy
    and set the alpha value on the `0`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只真正需要这四个按钮的点击区域，并不希望在UI中实际显示它们。在层次结构中选择所有四个按钮，并将`alpha`值设置为`0`。
- en: Since the directional pad Image is static and not split into four separate Buttons,
    any transitions applied to it would cover the whole Image. However, we can make
    the individual directions look as if they are being pressed and have some sort
    of color transition by adding sub-Images for the arrows on the directions. Right-click
    the `Up` Button and add an Image as a child with `Arrow`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于方向盘图像是静态的，并且没有分成四个单独的按钮，因此应用在其上的任何过渡都会覆盖整个图像。然而，我们可以通过为方向上的箭头添加子图像，使单个方向看起来像被按下，并有一种颜色过渡。右键单击`上`按钮，并添加一个带有`Arrow`的图像作为子项。
- en: Assign the `dPadButtons_5` sprite to the **Source Image** on its **Image** component
    and select **Preserve Aspect**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dPadButtons_5`精灵分配给其`Image`组件上的**源图像**，并选择**保持纵横比**。
- en: 'Scale and move the Image so that it is appropriately lined up with the arrow
    displayed on the D-Pad background Image:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放并移动图像，使其与D-Pad背景图像上显示的箭头适当地对齐：
- en: '![Figure 11.36: The Up Arrow of the D-Pad](img/B18327_11_36.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图11.36：D-Pad的上箭头](img/B18327_11_36.jpg)'
- en: 'Figure 11.36: The Up Arrow of the D-Pad'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.36：D-Pad的上箭头
- en: Select the `Arrow` Image component and use the eye dropper tool to grab the
    color of the arrows from the `D-Pad Background` Image. This will make it a light
    gray instead of white.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`箭头`图像组件，并使用吸管工具从`D-Pad背景`图像中抓取箭头的颜色。这将使其变为浅灰色而不是白色。
- en: 'Create `Arrow` children for each of the other three Buttons, and size, position,
    and color them appropriately. Make sure to also use the correct sub-Image of the
    `dPadButtons` sprite sheet. Once completed, your D-Pad and Hierarchy should appear
    as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其他三个按钮创建`箭头`子项，并适当地调整大小、位置和颜色。确保也使用`dPadButtons`精灵图的正确子图像。完成后，你的D-Pad和层次结构应该如下所示：
- en: '![Figure 11.37: All Arrows on the D-Pad](img/B18327_11_37.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图11.37：D-Pad上的所有箭头](img/B18327_11_37.jpg)'
- en: 'Figure 11.37: All Arrows on the D-Pad'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.37：D-Pad上的所有箭头
- en: Now, so that the D-Pad will react visually when the four directions are pressed,
    we will set the four `Arrow` children to have color tint Button `Arrow` child
    into the **Target Graphic** slot on its **Button** component. Now, when you press
    the individual Buttons, you will see a slight change in the color of the arrows,
    indicating which direction is pressed. You may wish to change the pressed color
    to something a bit more drastic than the default gray if you are having difficulty
    telling that a change is occurring.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了让D-Pad在按下四个方向时在视觉上做出反应，我们将设置四个`箭头`子项，使其具有颜色渐变的按钮`箭头`子项到其**目标图形**槽在其**按钮**组件上。现在，当你按下单个按钮时，你会看到箭头颜色的轻微变化，指示哪个方向被按下。如果你发现难以判断是否发生了变化，你可能希望将按下颜色改为比默认灰色更明显一些的颜色。
- en: Add the script named `DPad.cs` from the book’s code bundle to the `Assets/Scripts`
    folder. This is an incredibly simple script that contains four functions that
    only write to the console. Hooking up these four functions to the individual directional
    Buttons won’t do anything fun, but it will allow us to see logs in the console
    that let us know the Buttons are performing as they should.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将书中代码包中的名为`DPad.cs`的脚本添加到`Assets/Scripts`文件夹。这是一个非常简单的脚本，它包含四个只写入控制台的功能。将这些功能连接到单个方向按钮不会做任何有趣的事情，但它将允许我们在控制台中看到日志，让我们知道按钮正在按预期执行。
- en: Attach the script to the `D-Pad` `Background` object.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本附加到`D-Pad` `Background`对象。
- en: Select each of the four directional Buttons and, with all of them selected,
    add an **On Click ()** Event to the **Button** component.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个四个方向按钮，在它们全部被选中时，向`按钮`组件添加一个**On Click ()**事件。
- en: Now, drag the `D-Pad Background` object into the object slot of the **On Click
    ()** Event.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`D-Pad背景`对象拖动到**On Click ()**事件的对象槽中。
- en: Select each Button individually and assign the appropriate functions, `PressUp`,
    `PressDown`, `PressLeft`, and `PressRight`, to their **On Click ()** Events.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别选择每个按钮，并将适当的函数`PressUp`、`PressDown`、`PressLeft`和`PressRight`分配给它们的**On Click
    ()**事件。
- en: Playing the game and selecting the four directional Buttons should result in
    the appropriate message being displayed on the console.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中玩并选择四个方向按钮应该会在控制台显示适当的消息。
- en: 'Many D-Pads actually accept nine inputs: the four directs, the four diagonals
    (corners), and the center. If you want to accept diagonal inputs as well as a
    center-click for your D-Pad, I’d suggest using a grid layout group to evenly space
    your nine Buttons.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 许多D-Pad实际上接受九个输入：四个方向，四个对角线（角落），以及中心。如果您想接受对角线输入以及D-Pad的中心点击，我建议使用网格布局组来均匀地分配您的九个按钮。
- en: Since D-Pads tend to allow press-and-hold, you may want to combine the process
    used in this example with actions similar to those described in the previous example.
    Instead of using the `OnPointerDown` and `OnPointerUp` Events. These Events could
    then set a Boolean variable to `true` and `false`. For example, on the `Right`
    Button, you could have the `OnPointerDown` Event set a variable called `moveRight`
    to `true` and the `OnPointerUp` Event set `moveRight` to `false`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于D-Pad倾向于允许按住，您可能希望将此示例中使用的过程与之前示例中描述的动作结合起来。而不是使用 `OnPointerDown` 和 `OnPointerUp`
    事件。这些事件可以设置一个布尔变量为 `true` 和 `false`。例如，在 `Right` 按钮上，您可以将 `OnPointerDown` 事件设置一个名为
    `moveRight` 的变量为 `true`，并将 `OnPointerUp` 事件将 `moveRight` 设置为 `false`。
- en: Creating a floating eight-directional virtual analog stick
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个浮动的八向虚拟模拟摇杆
- en: 'In this example, we will create a floating eight-directional virtual analog
    stick. First, we will create an eight-directional D-Pad that simulates a control
    stick that moves in the direction the player drags:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将创建一个浮动的八向虚拟模拟摇杆。首先，我们将创建一个八向D-Pad，模拟一个玩家拖动方向移动的控制杆：
- en: '![Figure 11.38: The positions of the floating analog stick](img/B18327_11_38.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图11.38：浮动模拟摇杆的位置](img/B18327_11_38.jpg)'
- en: 'Figure 11.38: The positions of the floating analog stick'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38：浮动模拟摇杆的位置
- en: Then, we will expand the eight-directional D-Pad so that it is floating, which
    means it will not be visible in the scene until the player presses somewhere in
    the screen. Then, it will appear where the player’s thumb is located and perform
    the eight-direction movement based on the player’s thumb dragging.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将扩展八向D-Pad，使其浮动，这意味着它将在玩家在屏幕上按下某处之前在场景中不可见。然后，它将出现在玩家的拇指位置，并根据玩家的拇指拖动执行八个方向的运动。
- en: Setting up the eight-directional virtual analog stick
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 设置八向虚拟模拟摇杆
- en: 'To create an analog stick that moves in eight directions, as shown in the previous
    figure, complete the following steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个如图所示在八个方向上移动的模拟摇杆，请完成以下步骤：
- en: Create a new scene named `Chapter11-Examples-Buttons3` in the `Assets/Scenes`
    folder and open the new scene.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scenes` 文件夹中创建一个新的场景，命名为 `Chapter11-Examples-Buttons3` 并打开新场景。
- en: Create a new Image with `Stick Base`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Stick Base` 创建一个新的图像。
- en: Add the `dPadButtons_15` sprite to the **Source Image** slot of its **Image**
    component.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dPadButtons_15` 精灵添加到其 **Image** 组件的 **Source Image** 槽中。
- en: Resize it so that it has a `200` and give it a `0`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整大小，使其具有 `200` 并将其设置为 `0`。
- en: Right-click `Stick Base` in the Hierarchy and select `Image` child to the `Stick
    Base`. Name the child `Stick`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中右键单击 `Stick Base`，然后选择 `Stick Base` 的 `Image` 子项。将子项命名为 `Stick`。
- en: Resize the `Stick` Image to match the `Stick Base` by setting its **Rect Transform**
    stretch and anchor to stretch fully across both directions.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Stick` 图像调整到与 `Stick Base` 相匹配，通过设置其 **Rect Transform** 拉伸和锚点以在两个方向上完全拉伸。
- en: Add the `dPadButtons_0` sprite to the `Stick` Image component.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dPadButtons_0` 精灵添加到 `Stick` 图像组件中。
- en: Set the `10` to give some padding around the edges of the `Stick`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `10` 以在 `Stick` 的边缘周围提供一些填充。
- en: Now, set the pivot and position to `Stick` will not move around appropriately
    on the `Stick Base`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置枢轴和位置，使 `Stick` 在 `Stick Base` 上不会移动。
- en: '![Figure 11.39: The Rect Transform component of the Stick](img/B18327_11_39.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图11.39：摇杆的Rect Transform组件](img/B18327_11_39.jpg)'
- en: 'Figure 11.39: The Rect Transform component of the Stick'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39：摇杆的Rect Transform组件
- en: That’s all there is for the setup to get our virtual analog stick working. We’ll
    just leave it in the center of the screen for now. Now, we need to write some
    code. Create a new script in the `Assets/Script` folder and name it `FloatingAnalogStick`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是设置虚拟模拟摇杆工作的全部内容。我们现在将其留在屏幕中央。现在，我们需要编写一些代码。在 `Assets/Script` 文件夹中创建一个新的脚本，并将其命名为
    `FloatingAnalogStick`。
- en: 'Add the `UnityEngine.UI` namespace to the top of the script with the following:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到脚本顶部的 `UnityEngine.UI` 命名空间中：
- en: '[PRE11]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To make the stick wiggle around on top of the base, we need the following variables:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使摇杆在基座上方摇摆，我们需要以下变量：
- en: '[PRE12]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first three variables should be pretty self-explanatory. The `dragPadding`
    variable will be used to determine how far the player has to drag the stick before
    it actually registers as being moved.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前三个变量应该是相当直观的。`dragPadding`变量将用于确定玩家需要拖动摇杆多远，它才会实际注册为移动。
- en: 'Before we write the code that checks how far the player has dragged their finger,
    let’s add a few dummy functions that would allow this analog stick to actually
    control something in the future. Add the following functions to your script:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写检查玩家拖动手指距离的代码之前，让我们添加一些虚拟函数，这将允许这个模拟摇杆在未来实际上控制某些东西。将以下函数添加到您的脚本中：
- en: '[PRE13]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Stick` will move outward when the player moves their finger from their
    starting finger-down position. So, let’s create a function that will find the
    starting position when the player begins dragging their finger. Add the following
    function to your script:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家将手指从起始的按下位置移动时，`Stick`会向外移动。因此，让我们创建一个函数，当玩家开始拖动手指时，它会找到起始位置。将以下函数添加到您的脚本中：
- en: '[PRE14]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember—when working with a touchscreen, `Input.mousePosition` will give the
    value of the touch position.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住——当使用触摸屏时，`Input.mousePosition`将给出触摸位置的价值。
- en: 'Now, let’s create a function that checks how far the player has dragged their
    finger and moves the `Stick` based on that information. Add the following function
    to your script:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数，检查玩家拖动手指的距离，并根据该信息移动`Stick`。将以下函数添加到您的脚本中：
- en: '[PRE15]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last piece we need to add is something that will reset the stick to its
    original position once the player stops dragging or lifts up their finger. Add
    the following function to your script to do so:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的最后一件事情是，当玩家停止拖动或抬起手指时，将摇杆重置到原始位置的某种东西。将以下函数添加到您的脚本中，以实现这一点：
- en: '[PRE16]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we need to hook this script and these functions to the items within the
    scene. Add the `FloatingAnalogStick` script to the `Stick` `Base` Image.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将此脚本和这些函数连接到场景中的项目。将`FloatingAnalogStick`脚本添加到`Stick` `Base`图像。
- en: Add the `Stick` Image to the **Stick** property in the **Floating Analog** **Stick**
    component.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Stick`图像添加到**浮动模拟****摇杆**组件的**摇杆**属性中。
- en: Add an `Stick Base` object with **Add Component** | **Events** | **Event Trigger**.
    This will allow the user to use Event Types other than **On Click()**.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加组件** | **事件** | **事件触发**添加一个`Stick Base`对象。这将允许用户使用除**On Click()**之外的事件类型。
- en: Add the **Begin Drag**, **Drag**, and **End Drag** Event Types with the **Add
    New Event** **Type** button.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加新事件****类型**按钮添加**开始拖动**、**拖动**和**结束拖动**事件类型。
- en: 'Add the appropriate functions on the `FloatingAnalogStick` script attached
    to the `Stick Base` to the Events:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附加到`Stick Base`的`FloatingAnalogStick`脚本上添加适当的函数到事件中：
- en: '![Figure 11.40: The Event Trigger component](img/B18327_11_40.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图11.40：事件触发组件](img/B18327_11_40.jpg)'
- en: 'Figure 11.40: The Event Trigger component'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40：事件触发组件
- en: If you play the game now, you should see the eight-directional analog stick
    responding appropriately. Clicking on it and dragging in any direction will cause
    the stick to move in the direction of the drag.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在您玩游戏，您应该会看到八方向模拟摇杆适当地响应。点击它并在任何方向上拖动将导致摇杆移动到拖动方向。
- en: Making the eight-directional virtual analog stick float
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使八方向虚拟模拟摇杆浮动
- en: If all you want is an eight-directional analog stick, you’re good to go! But
    if you want the analog stick to float—appear where the players press on the screen
    and disappear when they lift their finger—you have to do a little bit more work.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只需要一个八方向模拟摇杆，那么您就可以开始了！但如果您想让模拟摇杆浮动——出现在玩家点击屏幕的位置，当玩家抬起手指时消失——您需要做更多的工作。
- en: 'To make the analog stick appear where the player clicks, complete the following
    steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要使模拟摇杆出现在玩家点击的位置，完成以下步骤：
- en: First, we need to create an area where the player will click to bring up the
    analog stick. Right-click `Canvas` in the Hierarchy and select `Button` child
    to the `Canvas`. Rename the `Button` child `Click Area`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个区域，玩家点击该区域将弹出模拟摇杆。在层级中右键点击`Canvas`，然后选择`Canvas`的`Button`子项。将`Button`子项重命名为`Click
    Area`。
- en: Remove the `Text` child object from the `Click Area`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Click Area`中移除`Text`子对象。
- en: Stretch the `Click Area` to fill the whole `Canvas`.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Click Area`拉伸以填充整个`Canvas`。
- en: Add some padding to the sides of `Click Area` by changing the `50`. I have added
    this padding so that the player cannot click on the very edge of the screen and
    have the analog stick appear mostly off-screen.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更改 `50` 为 `一些填充` 来给 `点击区域` 的两侧添加一些填充。我添加了这个填充，以便玩家不能点击屏幕的边缘，并且模拟杆大部分出现在屏幕外。
- en: 'In the Hierarchy, move `Click Area` so that it is above `Stick Base`. Now,
    `Click Area` will render behind the analog stick:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，将 `点击区域` 移动到 `杆基` 之上。现在，`点击区域` 将在模拟杆之后渲染：
- en: '![Figure 11.41: The Hierarchy showing Click Area and Stick Base](img/B18327_11_41.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.41：显示点击区域和杆基的层次结构](img/B18327_11_41.jpg)'
- en: 'Figure 11.41: The Hierarchy showing Click Area and Stick Base'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.41：显示点击区域和杆基的层次结构
- en: Open up your `FloatingAnalogStick` code so that we can add some functionality
    to it.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `FloatingAnalogStick` 代码，以便我们可以向其中添加一些功能。
- en: To make the position of our analog stick more easily hook to the position of
    the mouse on the screen, we should move our stick base so that it is centered
    at the lower-left corner of the `Canvas`. Set the anchor and position to the **bottom
    left** anchor preset.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的模拟杆的位置更容易与屏幕上鼠标的位置挂钩，我们应该将杆基移动到 `Canvas` 的左下角中心。将锚点和位置设置为 **底部左侧** 锚点预设。
- en: Now, set the `0.5`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `0.5` 设置为：
- en: 'Set the `0`. This should place the analog stick at the lower-left corner of
    the Canvas (or screen) with its pivot point set to its center:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `0`。这应该将模拟杆放置在画布（或屏幕）的左下角，其支点设置为中心：
- en: '![Figure 11.42: The Hierarchy showing Click Area and Stick Base](img/B18327_11_42.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.42：显示点击区域和杆基的层次结构](img/B18327_11_42.jpg)'
- en: 'Figure 11.42: The Hierarchy showing Click Area and Stick Base'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.42：显示点击区域和杆基的层次结构
- en: 'We need two more variables now to get the analog stick to appear where we want
    it to in the scene. Add the following variable to your script to assign the stick
    and track if it has been added:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要两个额外的变量，以便将模拟杆放置在场景中我们想要的位置。将以下变量添加到你的脚本中，以分配杆并跟踪它是否已被添加：
- en: '[PRE17]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, create the following function to add the stick to the scene:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建以下函数以将杆添加到场景中：
- en: '[PRE18]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following `Update()` function to determine when the stick will appear:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `Update()` 函数以确定杆何时出现：
- en: '[PRE19]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add `Stick Base` to the **The** **Base** slot:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `杆基` 添加到 **基础** 插槽：
- en: '![Figure 11.43: The Floating Analog Stick component](img/B18327_11_43.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.43：浮动模拟杆组件](img/B18327_11_43.jpg)'
- en: 'Figure 11.43: The Floating Analog Stick component'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.43：浮动模拟杆组件
- en: Add the `Click Area`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `点击区域`。
- en: 'Add the following `Click Area`:![Figure 11.44: The Event Trigger component](img/B18327_11_44.jpg)'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `点击区域`：![图 11.44：事件触发组件](img/B18327_11_44.jpg)
- en: 'Figure 11.44: The Event Trigger component'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.44：事件触发组件
- en: Playing the game now will have the analog stick appear where you click and move
    around with your dragging.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在玩游戏时，模拟杆将出现在你点击的位置，并随着你的拖动而移动。
- en: Now, let’s make it so that the analog stick is only visible when the player
    is touching the screen. Add a `Stick Base`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们让它这样，模拟杆仅在玩家触摸屏幕时可见。添加一个 `杆基`。
- en: Set `0`, `false`, and `false`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `0`、`false` 和 `false`。
- en: 'Add the following variable to your `FloatingAnalogStick` script to keep track
    of the `CanvasGroup`:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下变量添加到你的 `FloatingAnalogStick` 脚本中，以跟踪 `CanvasGroup`：
- en: '[PRE20]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following `Awake()` function to initialize the `theBaseVisibility`
    variable:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `Awake()` 函数以初始化 `theBaseVisibility` 变量：
- en: '[PRE21]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new function called `ToggleBaseCanvasGroup()` to toggle the `CanvasGroup`’s
    properties on and off:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ToggleBaseCanvasGroup()` 的新函数，用于切换 `CanvasGroup` 的属性开和关：
- en: '[PRE22]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following to the `AddTheStick()` function to turn on the `CanvasGroup`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AddTheStick()` 函数中添加以下内容以启用 `CanvasGroup`：
- en: '[PRE23]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following to the innermost `if` statement within the `Update()` function
    to turn off the `CanvasGroup`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Update()` 函数内部最内层的 `if` 语句中添加以下内容以关闭 `CanvasGroup`：
- en: '[PRE24]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, the analog stick will appear when the player presses down, move in the
    direction of their finger, and disappear when the player lifts their finger.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家按下时，模拟杆将出现，并朝手指的方向移动，当玩家抬起手指时消失。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: UI Images are one of the core components of the Unity UI system and manipulating
    them is essential to creating visually interactive user interfaces. This chapter
    culminated all the skills we have learned in the preceding chapters by letting
    us create interesting interfaces that utilized Events, Buttons, and Images.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: UI 图像是 Unity UI 系统的核心组件之一，操作它们对于创建视觉交互式用户界面至关重要。本章通过让我们创建利用事件、按钮和图像的有趣界面，总结了我们在前几章中学到的所有技能。
- en: In the next chapter, we’ll look at how to create masks and scroll views so that
    we can hold even more child objects within our Panel containers.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建遮罩和滚动视图，以便我们可以在我们的面板容器中容纳更多的子对象。
