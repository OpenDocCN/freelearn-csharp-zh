- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I was introduced to the **Dependency Injection** (**DI**) pattern when I was
    working as a web developer, and I've been using it for years. However, I have
    noticed that DI is not well-known in the gaming industry. I suspect this is because
    it's a pattern that was developed to resolve design issues in business-oriented
    applications, and not for high-performance software such as video games.
  prefs: []
  type: TYPE_NORMAL
- en: As its names implies, DI is about injecting dependencies; it might sound abstract
    at first, but it's a quite simple concept. Classes often need instances of other
    classes to complete specific functions. So instead of having a class initialize
    its own dependencies, we inject them through its constructor or a parameter in
    one of its functions. This approach decouples the explicit relationships between
    classes, and it makes it easier to test our code, because we can easily inject
    mock objects that execute unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in this book, DI has its limitations, and it is not necessarily
    compatible with Unity's programming environment. This will become especially clear
    when you start to introduce more advanced versions of DI, in the form of** Inversion
    of Control** (**IoC**) containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will review the fundamentals of the DI pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore the core concepts behind IoC containers and how they relate
    to DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will resolve a dependency issue prompted by the implementation of a feature
    that permits customizing the initial configurations of a superbike for a racing
    game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands-on; you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review them before moving
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files from this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Oww7WM](http://bit.ly/2Oww7WM)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its name implies, the DI pattern''s core purpose is to inject dependencies
    into the classes that need them. There are three ways to achieving this with DI,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor injection**: We inject dependencies through a class''s constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setter injection**: We inject dependencies through a class''s function parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface injection**: The dependency''s interface offers an injector method
    to pass a dependency to a client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will only review the constructor and setter techniques,
    because they are the most common.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are usually classes that offer a particular service that other
    classes can utilize to complete specific functions. A classic example is a manager
    class that is responsible for establishing a connection to a database to execute
    queries. To fulfill this responsibility, the database manager is dependent on
    vendor-specific classes that act as interfaces to certain types of databases.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having the database manager retrieve and initialize a specific dependency
    every time it needs to connect to a particular type of database, we could provide
    them by injecting them when needed. In other words, we are decoupling the relationship
    between the dependent and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A UML diagram is not the best tool to describe the purposes of a DI pattern,
    but let''s review a simplified diagram that outlines what we are going to implement
    as our use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8371126-f7a1-436c-a544-971e5cbe2c5a.png)'
  prefs: []
  type: TYPE_IMG
- en: The case presented in the preceding diagram is similar to the database manager
    example that we just examined. We have a class named `Bike` that needs an engine
    to run correctly. Instead of having the `Bike` class initialize a specific type
    of engine depending on a particular condition, we made it accept a parameter of
    the `IEngine` type in its constructor. With this approach, we can have `Bike`
    receive any concrete class that implements `IEngine`, like in this example, with `JetEngine`
    and `NitroEngine`.
  prefs: []
  type: TYPE_NORMAL
- en: This arrangement provides us with a lot of extensibility; we could write dozens
    of different types of engines, each with their particular features, and the `Bike`
    would be able to accept them without any modification to its current structure.
  prefs: []
  type: TYPE_NORMAL
- en: But of course, DI is not without its drawbacks, as you are going to see in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: DI follows the core principals of IoC, which is about inverting the flow control
    of a system. In the case of DI, it's about inverting the process of dependency
    management. Another pattern that follows IoC principals is the service locator,
    which you can review in [Chapter 16](56a2aeed-924d-4d95-b44b-b10ac7595d4a.xhtml),
    *Service Locator*.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the Singleton pattern, the DI pattern is somewhat controversial, and its
    actual benefits and drawbacks are often contested. I suspect this is because its
    design is straightforward and programmers tend to be cautious of anything that
    looks too simple, because it's usually too good to be true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loose coupling**: Having classes receive instances to dependencies instead
    of explicitly initializing them can reduce tight coupling in a code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testable code**: DI makes it easier to run tests by making it possible to
    inject mock objects that can run specific scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent development**: DI offers a way to decouple objects and enforce
    communication through interfaces. This approach makes it easier for a team of
    programmers to write classes that utilize each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The drawbacks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disputes**: DI is a type of pattern that causes a lot of debates in a team,
    because the best approach is not always clear, especially when a more advanced
    form of DI is considered, such as the use of IoC injection containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework dependency**: The basic form of DI is very limited; once a certain
    degree of complexity is achieved, it becomes necessary to implement a third-party
    IoC framework to manage the injection of dependencies in a configurable manner.
    As a consequence, the code base often becomes dependent on the framework and cannot
    be easily removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ravioli code**: Overzealous use of DI and related best practices can result
    in a code base that''s overly encapsulated and broken up into too many individual
    classes, making it difficult to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test a candidate's ability to debate technical subject matters, interviewers
    often ask a candidate to give an opinion on a controversial pattern, such as DI
    and Singleton. It's a good practice, as an interviewee, to showcase a balanced
    view on any issue by taking into account the benefits and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that we are working on a racing game set in the future, with
    superbikes. We have to implement a feature quickly, in which a player can customize
    their bike by choosing an engine and driver from a list of available options before
    starting a race. In other words, our bike object has two specific dependencies:
    an engine and a driver. Using the DI pattern, we are going to manage these dependencies
    without adding unnecessary complexity to our code base.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to look at the incorrect way to manage dependencies in a
    class so that you can understand the benefits of DI in contrast to the opposite
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: The wrong way, without DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going into the implementation phase of our use case, let''s first review
    an example of a class that uses an ill-considered way of initializing and managing
    its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this might seem like a reasonable approach, but let's imagine
    that we are working in a team of game programmers and each is implementing new
    types of engine behaviors. If we want our `Bike` class to support them, we will
    need to modify the `EngineType` enum and also update the `switch` case inside
    the body of the `SetEgnine()` method. This approach can become very bothersome
    over time if multiple programmers are working on the class at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: We are having the same issue with the `SetDriver()` function; with this arrangement,
    adding new types of drivers will become a choir and will probably be prone to
    errors. So let's implement the same class in a step-by-step approach by using
    DI as our foundation.
  prefs: []
  type: TYPE_NORMAL
- en: The right way with DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of DI is quite straightforward, and that''s probably its
    main benefit. So, this section should be painless:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing our `Bike` class; we could say that it''s the actual
    client in this DI pattern example, mainly because it''s the class that''s dependent
    on receiving dependencies during the injection process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `SetEngine()` and `SetDriver()` functions are not aware
    of what specific engine or driver they are receiving—only that they expect a generic
    type of them. In other words, the `Bike` class is no longer responsible for the
    initialization process of its dependencies. This approach is very flexible; we
    could write an infinite number of engine classes, each with their own specific
    behaviors, and if we stayed consistent with the implementation contract of the
    `IEngine` interface, we wouldn't need to modify the `Bike` class directly for
    it to be suitable to use new engines.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that this approach is likewise valid for the `driver` dependency.
    The `Bike` doesn't need to know who the driver is; it just needs to know that
    the entity that's taking control implemented the `IDriver` interface so that they
    could communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, this flexibility is helpful; we could easily inject mock
    `engine` or `driver` objects at runtime and run some automated unit tests on the
    `Bike` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the interfaces for our two primary types of dependencies:
    engines and drivers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `IEngine` interface is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IDriver` interface is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following step, we are going to write all of our concrete classes for
    each primary type of component that our bike needs to function correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `JetEngine` class is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NitroEngine` class is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that each engine encapsulates its internal mechanism
    while staying consistent with the implementation of the `IEngine` interface. It's
    this consistent approach that permits DI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HumanDriver` class is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AndroidDriver` class is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `HumanDriver` class is intended to give control of the `Bike` to a player,
    which we will do in the upcoming `Client` class. The `AndroidDriver` class is
    meant to support an AI entity that could drive the `Bike` and act as a rival to
    the player during a race.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our `Client` class, which we will use to test our system, is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Client` class is quite straightforward; in the `Awake()` function, we
    inject the dependencies into two instances of a `Bike` class: `m_PlayerBike` and
    `m_AndroidBike`. In the `Update()` function, we listen for a player''s input that
    permits them to control the `m_PlayerBike` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: This might look very straightforward and too simple to be true, but this pattern
    offers a lot of extensibility and flexibility, with little complexity, if used
    in moderation. In the next section, we are going to review a more advanced form
    of DI, which uses IoC containers.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we didn't use constructor injection in our code example;
    it's because we were working with a `MonoBehaviour` class, and we don't have access
    to its constructor. Some Unity developers do use the `Awake()` function to inject
    dependencies during the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: DI with IoC containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IoC containers usually come in the form of frameworks; their primary responsibilities
    are to automate the DI process and manage the life space of dependencies. Before
    we start, it's important to note that most IoC containers are not designed to
    be compatible with Unity's coding model, and I don't recommend using them. On
    the other hand, it's important to be aware that they exist.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, DI is a handy and straightforward
    pattern, but it has its limitations. In the code example that we just implemented,
    we managed the injection of two dependencies at once, but imagine if we had dozens
    of them spread out over multiple classes. In that type of context, DI can become
    a choke point in your architecture. That is when IoC containers become useful,
    because they can automate the process of managing all of those injections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quick summary of the functions that most IoC containers
    offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registration**: The container offers a way to register dependencies and map
    them to the dependents correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolving**: The container takes the responsibility of resolving the dependencies
    by initializing and injecting them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disposing**: The container will manage the lifespan of objects, including
    disposing them once they are not needed anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of this quick review of the IoC containers is not to debate whether
    they are necessary, but to become aware that the simple version of the DI pattern
    has its limitations. Once we have reached a certain degree of complexity and density
    with regard to the dependencies to inject, we need to consider implement or integrating
    an IoC container framework to manage the process.
  prefs: []
  type: TYPE_NORMAL
- en: Always be cautious about making your code base dependent on third-party frameworks;
    you might find yourself falling into the vendor lock-in anti-pattern, which I
    will describe in more detail in the final chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the DI pattern, a simple pattern that has grown
    in popularity over the years. Its fame is explainable by the fact that it resolves
    a common challenge that every programmer faces daily, which is the management
    of dependencies between classes. In other words, it's a powerful tool to have
    in your toolkit, as long as you don't abuse it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the object pool pattern, another handy
    tool that is very popular with mobile game programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Practical exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a practical exercise, I recommend writing an application in C# using a popular
    IoC container framework. Because most of them are incompatible with the Unity
    engine, I suggest going native and coding a simple Windows application in Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Further reading* section, I have added a list of popular IoC container
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some books that may be used as reference are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dependency Injection in .NET* by Mark Seemann: [https://www.manning.com/books/dependency-injection-in-dot-net](https://www.manning.com/books/dependency-injection-in-dot-net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dependency Injection Principles, Practices, and Patterns* by Steven van Deursen
    and Mark Seemann: [https://www.manning.com/books/dependency-injection-principles-practices-patterns](https://www.manning.com/books/dependency-injection-principles-practices-patterns)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some IoC frameworks to consider are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ninject:[http://www.ninject.org](http://www.ninject.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Castle Windsor:[https://github.com/castleproject/Windsor](https://github.com/castleproject/Windsor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
