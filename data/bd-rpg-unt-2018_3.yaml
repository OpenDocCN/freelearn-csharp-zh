- en: RPG Character Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPG角色设计
- en: We are now at an interesting point in our development. In this chapter, we will
    discuss the design of our RPG characters and look at some of the attributes and
    characteristics that we need to design and implement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于开发过程中的一个有趣阶段。在本章中，我们将讨论我们RPG角色的设计，并查看我们需要设计和实现的一些属性和特征。
- en: 'Here is a breakdown of the topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章涵盖的主题概述：
- en: Character definitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色定义
- en: Base character class attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础角色类属性
- en: Character states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色状态
- en: 'Character model:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色模型：
- en: Rigging your model
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的模型绑定
- en: Character motion
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色动作
- en: Animator controller
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画控制器
- en: Animation states
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画状态
- en: Character controller
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色控制器
- en: Modification to animations
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画修改
- en: Inverse kinematics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向动力学
- en: Character definitions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色定义
- en: 'To have a meaningful and interesting RPG, the game should usually have more
    than one character class. In [Chapter 1](part0021.html#K0RQ0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *What is an RPG?* We defined the following class types:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个有意义且有趣的RPG，游戏通常应该有多个角色类。在[第一章](part0021.html#K0RQ0-7a1ef7ae3ef249cdb149f8344d2e8e79)“什么是RPG？”中，我们定义了以下类类型：
- en: Barbarians
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 野蛮人
- en: Orcs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兽人
- en: Villagers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 村民
- en: We won't be able to implement all of the character types, due to time. The demonstration
    of the implementation of one or two character types should give you a good foundation
    to develop your own character classes. After all, that is the overall objective
    of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时间限制，我们无法实现所有角色类型。展示一两个角色类型的实现应该为你开发自己的角色类提供一个良好的基础。毕竟，这是本书的整体目标。
- en: One of the main characters is, of course, the **Player Character** (**PC**).
    Let's go ahead and concentrate on the implementation of the PC, and then we can
    start defining and designing the `Barbarian` class, the `Villager` class, and
    perhaps the `Orc` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，主要角色之一是**玩家角色**（**PC**）。让我们先集中精力实现PC，然后我们可以开始定义和设计`野蛮人`类、`村民`类，也许还有`兽人`类。
- en: My character models will be from the Asset Store. You may either download the
    same characters or design your own. You can also use different types of character
    models. The point is to implement the character based on the specifications, which
    will be defined in this chapter and beyond.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我的角色模型将从资源商店获取。你可以下载相同的角色，或者设计自己的角色。你也可以使用不同类型的角色模型。关键是要根据规格实现角色，这些规格将在本章及以后定义。
- en: Character assets
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色资源
- en: 'I will be using the following assets from the Asset Store for my character
    models:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下资源商店的资源来创建我的角色模型：
- en: Fantasy Horde Barbarians
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻想部落野蛮人
- en: Fantasy Horde - Villagers
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻想部落 - 村民
- en: Fantasy Horde - Orc
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻想部落 - 兽人
- en: Let's take a look at some of the attributes that our player will have in general.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看玩家通常将拥有的某些属性。
- en: Base character class attributes
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础角色类属性
- en: 'Let''s start laying down the foundation we will need for the implementation
    of our character classes. The following is a list of attributes that will be part
    of the Base Character class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始奠定我们将需要用于实现角色类的基石。以下是一个将作为基础角色类一部分的属性列表：
- en: Character class name
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色类名称
- en: Character class description
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色类描述
- en: 'List of attributes:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性列表：
- en: Strength
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力量
- en: Dexterity
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷性
- en: Endurance
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耐力
- en: Intelligence
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智力
- en: Social standing
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社会地位
- en: Agility
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷性
- en: Alertness
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警觉性
- en: Vitality
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命力
- en: Willpower
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意志力
- en: The attributes you define for your characters depend on the character type,
    but there will be some similarities between all character attributes. We would
    like to implement these similarities in a base class that will be shared with
    all character classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你为角色定义的属性取决于角色类型，但所有角色属性之间将存在一些相似之处。我们希望在所有角色类共享的一个基础类中实现这些相似之处。
- en: The list provided is just a sample, and you can add or subtract as you see fit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的列表只是一个示例，你可以根据自己的需要添加或删除。
- en: 'Let''s keep things simple. We will use only the five primary statistics for
    now, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持简单。现在我们将只使用以下五个主要统计数据，如下所示：
- en: '**Strength:** Strength is a measure of how physically solid a character is.
    Quality controls the most extreme weight the character can convey, skirmish assault
    as well as harm, and some of the time hit focuses. Protective layer and weapons
    may likewise have a strength prerequisite.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力量**：力量是衡量角色身体坚固程度的指标。质量控制角色可以传达的最极端重量，包括小规模攻击以及伤害，有时还有击中点数。防护层和武器也可能有力量要求。'
- en: '**Defense:** Defense is a measure of how flexible a character is. Protection
    more often than not diminishes harm taken by either a rate or a settled sum for
    each hit.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御**：防御是衡量角色灵活程度的指标。保护通常通过每次打击的速率或固定金额来减少所受伤害。'
- en: '**Dexterity:** Dexterity is a measure of how deft a character is. Skill controls
    assault, development speed, and precision, and also dodging an adversary''s assault.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性**：敏捷性是衡量角色灵巧程度的指标。技能控制攻击、发展速度和精度，以及躲避敌人的攻击。'
- en: '**Intelligence:** Intelligence is a measure of a character''s critical thinking
    capacity. Knowledge regularly controls a character''s capacity to understand remote
    dialects and their aptitude in enchantment. Now and again, insight controls what
    number of aptitude focuses the character gets at level up. In a few recreations,
    it controls the rate at which encounter focuses are earned, or the sum expected
    to level up. This is once in a while joined with shrewdness, and additionally
    self control.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智力**：智力是衡量角色批判性思维能力的指标。知识通常控制角色理解方言的能力和他们在魔法方面的才能。有时，洞察力控制角色在升级时获得的技能点数。在一些游戏中，它控制获得经验点的速率或升级所需的金额。这通常与智慧相结合，以及自律。'
- en: '**Health:** Health decides whether the character is alive or dead.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：健康决定角色是生是死。'
- en: 'The attributes listed are attributes that will be inherited by all character
    classes. Now let''s put this into code. Create a new C# script and name it `BaseCharacter.cs`.
    Open the script and place the following code in the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的属性是所有角色类将继承的属性。现在让我们将其放入代码中。创建一个新的 C# 脚本，命名为 `BaseCharacter.cs`。打开脚本并将以下代码放入文件中：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Character states
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色状态
- en: 'States are an important part of the character design. They will also drive
    the kind of actions and movement you will need to create for each state. For instance,
    at a minimum our character will need to have the following states implemented:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是角色设计的重要组成部分。它们还将驱动为每个状态创建的动作和移动类型。例如，我们的角色至少需要实现以下状态：
- en: Idle
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲
- en: Walking
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行走
- en: Running
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跑步
- en: Jumping
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃
- en: Attacking
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击
- en: Die
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死亡
- en: You character may have more states defined; this is something that you, as the
    designer of the game, will need to identify and eventually implement. Each one
    of the states identified will need to be implemented as an animation. The person
    creating the character models will usually also develop the animations for the
    character.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您的角色可能定义了更多状态；这是您作为游戏设计师需要识别并最终实现的事情。每个识别出的状态都需要实现为动画。创建角色模型的个人通常也会为角色开发动画。
- en: 'For instance, the Orc model has the following states/animations defined:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，兽人模型定义了以下状态/动画：
- en: '![](img/00052.gif)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.gif)'
- en: You may consider implementing all of the states or some of the states. The theory
    and practice are the same either way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑实现所有状态或部分状态。无论是理论还是实践，都是一样的。
- en: I can also use RawMocap data to animate the models, since the models I am using
    are Mecanim-ready, including Face Rigs. In fact, we will use some RawMocap data
    to animate the models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以使用 RawMocap 数据来为模型动画，因为我在使用的模型是 Mecanim 兼容的，包括面部绑定。实际上，我们将使用一些 RawMocap
    数据来为模型动画。
- en: With the release of Unity 5, the *Mecanim Animation System* was introduced,
    which is used to create easy workflow and setup of animations on humanoid characters,
    retargeting animation from one character to the next, previewing the animation
    clips, managing complex interactions between animations with a visual tool, and
    animating different body parts with different logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Unity 5 的发布，引入了 *Mecanim 动画系统*，该系统用于创建在类人角色上创建动画的简单工作流程和设置，将动画从一角色重定向到另一角色，预览动画剪辑，使用可视化工具管理动画之间的复杂交互，以及使用不同的逻辑为不同的身体部位进行动画处理。
- en: In fact, let's go ahead and download the asset from the Asset Store right now.
    Do a search on *Raw Mocap Data for Mecanim* in the Asset Store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们现在就下载 Asset Store 上的资产吧。在 Asset Store 中搜索 *Mecanim 的原始 mocap 数据*。
- en: '![](img/00053.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00053.jpeg)'
- en: The package contains several raw motion capture data files for your use. Be
    aware that you might have to make some adjustments on your own.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包含几个原始动作捕捉数据文件供您使用。请注意，您可能需要自行进行一些调整。
- en: When creating your character models, it is a good idea to follow the proper
    bone structure set up for your characters. This will help make controlling the
    states and the animations of your character easier, as well as re-using your Animation
    Controller on multiple characters. This is also true if you are going to use a
    character from the Asset Store.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的角色模型时，遵循为您的角色设置的适当骨骼结构是一个好主意。这将有助于使控制角色的状态和动画更容易，以及在不同的角色上重用您的动画控制器。如果您打算使用资产商店中的角色，这也同样适用。
- en: Character model
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色模型
- en: You should now consider how your player character is going to look. There are
    several approaches that can be taken. An easy way would be to have a predefined
    hero where the player does not have many options or much choice when it comes
    to customization of the character. The other way would be to provide the player
    the ability to change and modify their character to an extent or fully. This all
    really depends on your budget!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该考虑您的玩家角色将如何看起来。可以采取几种不同的方法。一种简单的方法是提供一个预定义的英雄，玩家在角色自定义方面没有太多选择或自由度。另一种方法是让玩家能够在一定程度上或完全改变和修改他们的角色。这完全取决于您的预算！
- en: Here, we are going to do something in-between, to get the benefit of both worlds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将采取介于两者之间的方法，以获得两个世界的优点。
- en: You may use the Asset Store to download predefined characters that can be used
    as placeholders for your game while you create your own. You can even use some
    of the characters that are freely available through the Asset Store and modify
    them for your needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用资产商店下载预定义的角色，这些角色可以在您创建自己的角色时作为占位符使用。您甚至可以使用资产商店中免费提供的某些角色，并根据您的需求进行修改。
- en: Once you have determined your character model, the next step is to configure
    it and customize it for your game. The character model I have can be visually
    modified to represent several unique characters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定了您的角色模型，下一步就是对其进行配置和自定义，以便在您的游戏中使用。我拥有的角色模型可以视觉上修改，以代表多个独特的角色。
- en: For instance, let's take a look at the default character models we will be working
    with, as detailed in the following sections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下我们将要使用的默认角色模型，以下章节将详细介绍。
- en: Default character models
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认角色模型
- en: Here is a set of character models that have been purchased from the Asset Store.
    I like this set of models as they are simple and straightforward to work with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一套从资产商店购买的字符模型。我喜欢这一套模型，因为它们简单且易于使用。
- en: Barbarian
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 野蛮人
- en: This model contains several body types—fat, regular, and skinny—which are set
    up by blendshapes on the body and cloth. It comes with 15 different body and accessories
    textures, one weapons texture, and two shield textures. This gives us a good range
    of unique character definitions and customization to enhance the range of different
    NPCs for the RPG.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型包含几种身体类型——肥胖、普通和瘦弱，这些类型是通过身体和布料上的混合形状设置的。它包含15种不同的身体和配件纹理，一种武器纹理和两种盾牌纹理。这为我们提供了一系列独特的角色定义和自定义选项，以增强RPG中不同NPC的范围。
- en: 'We will take a look at how to utilize them when doing character customization.
    See the following screenshot for an example of a barbarian:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何在角色自定义时利用它们。以下截图展示了野蛮人的一个示例：
- en: '![](img/00054.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: The Barbarian model
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 野蛮人模型
- en: Villager
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 村民
- en: 'The Villager models give us two groups of models: child and adult. In the adult
    group, we have the male, female, and monk types. There are 16 male, three monk,
    eight female, four child, and two equipment textures provided. For the female
    type, there are two types of texture: standard hair, used for loose hair, and
    hat, used with head accessories such as a hat.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 村民模型为我们提供了两组模型：儿童和成人。在成人组中，我们有男性、女性和僧侣类型。提供了16个男性、3个僧侣、8个女性、4个儿童和2个装备纹理。对于女性类型，有两种纹理类型：标准发型，用于散发的头发，和帽子，与帽子等头部配件一起使用。
- en: 'There are two different sets of animations: one for the `Adult` mesh type and
    one for the `Child` mesh type. The child type has fewer states compared to the
    adult. See the following screenshot, depicting a male, female, and child villager:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有两组不同的动画集：一组用于`成人`网格类型，另一组用于`儿童`网格类型。与成人相比，儿童类型的状态较少。以下截图展示了男性、女性和儿童村民：
- en: '![](img/00055.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: The Villager models
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 村民模型
- en: Orc
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵
- en: 'The Orc model will be a bit different in its structure. All body-type meshes
    will be part of the main structure; there are three main models: Fat, Average,
    and Athletic. There might also be some legacy animations, which we will need to
    take care of when we start the configuration and programming or the `Orc` class.
    See the following screenshot of an orc:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 兽人模型在其结构上可能略有不同。所有身体类型网格都将属于主要结构；有三个主要模型：肥胖、平均和健壮。也可能有一些遗留动画，我们在开始配置和编程或`Orc`类时需要处理。请参阅以下兽人的截图：
- en: '![](img/00056.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: The Orc model
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 兽人模型
- en: Let's get started
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始吧
- en: Drag and drop the Barbarian model from your project into the scene. You will
    need to study your character model carefully, and understand how it is built so
    that you can modify it during design time, as well as during runtime if necessary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的项目中的野蛮人模型拖放到场景中。您需要仔细研究您的角色模型，了解它是如何构建的，这样您就可以在设计时间以及必要时在运行时对其进行修改。
- en: 'This particular model has several visual elements attached for weapons, clothing,
    and so on. Your model may have been configured differently; if so, you will need
    to create your own attachment points and instantiate the weapons and/or other
    character related assets accordingly. See the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的模型有几个视觉元素附加在武器、服装等上。您的模型可能配置不同；如果是这样，您需要创建自己的附加点并相应地实例化武器和其他与角色相关的资产。请参阅以下截图：
- en: '![](img/00057.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: Model hierarchy
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模型层级
- en: 'Select your character model and investigate the structure of the model. You
    will notice that there is a certain pattern and naming convention to the model
    hierarchy, as shown in the preceding screenshot. Some models might have animations
    attached. To check them, you will need to select the model from the Project window
    and select the Animation tab in the Inspector window to get a list of the embedded
    animations for the model, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您的角色模型并研究模型的架构。您会注意到模型层级中存在一定的模式和命名约定，如前一张截图所示。某些模型可能附加了动画。要检查它们，您需要从项目窗口中选择模型，并在检查器窗口中选择动画选项卡，以获取模型的嵌入动画列表，如以下截图所示：
- en: '![](img/00058.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.jpeg)'
- en: 'In the Inspector window, select the Animations tab shown in the preceding screenshot,
    and notice the Clips section for all animations developed for your character model,
    as indicated in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器窗口中，选择前一张截图所示的动画选项卡，并注意所有为您的角色模型开发的动画的剪辑部分，如以下截图所示：
- en: '![](img/00059.gif)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.gif)'
- en: Notice that the animation clips have a start time and an end time. The actual
    character model is visually displayed at the bottom of the Inspector window.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到动画片段有开始时间和结束时间。实际的角色模型在检查器窗口的底部以视觉方式显示。
- en: Rigging your model
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的模型设置骨架
- en: 'There might be times that you will need to Rig your model to make it suitable
    for your game. This can be achieved by selecting your model source, and from the
    Inspector window selecting the Rig tab, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您可能需要为您的模型设置骨架以使其适合您的游戏。这可以通过选择模型源，并在检查器窗口中选择骨架选项卡来实现，如以下截图所示：
- en: '![](img/00060.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.jpeg)'
- en: 'In the Rig tab, there are several options that you can apply to your model.
    Assuming that your character is of Humanoid type, you will need to select the
    Humanoid Animation Type if not already selected. The Avatar Definition can also
    be either created from the model or assigned if you have an avatar defined. Finally,
    you can click on the Configure... button to see the configuration of the rigged
    model. See the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在骨架选项卡中，有一些选项您可以应用于您的模型。假设您的角色是类人型，如果您尚未选择，您需要选择类人动画类型。Avatar定义也可以从模型创建或分配，如果您已经定义了Avatar。最后，您可以点击“配置...”按钮以查看设置好的骨架模型的配置。请参阅以下截图：
- en: '![](img/00061.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00061.jpeg)'
- en: Humanoid bone structure
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类人骨骼结构
- en: Notice from the preceding screenshot that your model has a mapping defined for
    its skeleton. If your model is of Humanoid type, and if your model structure has
    been named properly, the system will automatically assign the correct bones and
    joints. If your naming is not per Unity specification, you can navigate your model
    structure and manually assign each point in the Body, Head, Left Hand, and Right
    Hand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从前面的截图可以看出，你的模型为其骨骼定义了映射。如果你的模型是 Humanoid 类型，并且如果你的模型结构已经被正确命名，系统将自动分配正确的骨骼和关节。如果你的命名不符合Unity规范，你可以导航你的模型结构并手动为身体、头部、左手和右手中的每个点分配。
- en: The Muscles and Settings tabs will enable you to define and restrict the movement
    of the joints for your model. These can be very useful and practical for creating
    more realistic movements for your characters. You can study these topics further
    on your own, as they would require a whole chapter or two to cover them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 肌肉和设置选项卡将允许你定义和限制模型关节的运动。这些对于创建更逼真的角色动作非常有用和实用。你可以自己进一步研究这些主题，因为它们可能需要一整章或两章来涵盖。
- en: Character motion
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色动作
- en: Traditionally, the motion and movement of the characters were done separately
    through code. With the introduction of *Mecanim*, you are now able to apply what
    is called *Root Motion*. This modifies the character's in-game transform based
    on the data in root motion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，角色的动作和运动是通过代码分别完成的。随着 *Mecanim* 的引入，你现在可以应用所谓的 *根运动*。这根据根运动中的数据修改了角色的游戏内变换。
- en: We are going to use root motion for our characters. Root motion works with the
    Animator Controller and the Animation State Machine. The Body Transform and Orientation
    are stored in the Animation Clip. This makes it easier to create a state machine
    that plays the appropriate animation clip through the Animator Controller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的角色使用根运动。根运动与Animator Controller和动画状态机一起工作。身体变换和方向存储在动画剪辑中。这使得创建一个通过Animator
    Controller播放适当动画剪辑的状态机变得更容易。
- en: Animator Controller
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画控制器
- en: In this section, we will use the new Animator Controller to create our character
    states and determine the criteria for a change of states. Let's make a new folder
    in the Project window and name it `Animator`. Select the newly created folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用新的Animator Controller来创建我们的角色状态并确定状态变化的准则。让我们在项目窗口中创建一个新的文件夹并命名为 `Animator`。选择新创建的文件夹。
- en: To create an Animator Controller, in the Project window, right-click and select
    *Create | Animator Controller*. Give it a name. I have called mine `BaseAnimatorController`.
    Double-click the controller to open the Animator window.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Animator Controller，在项目窗口中，右键单击并选择 *创建 | 动画控制器*。给它起一个名字。我称之为 `BaseAnimatorController`。双击控制器以打开Animator窗口。
- en: The Animator Controller is a very complex tool, and it will take you some time
    to study the different aspects and features that are available to you through
    it. The following screenshot is a snapshot of an empty controller. I have marked
    the main sections of the Animator window. There are two visible tabs, the Layers
    tab and the *Parameters* tab. In the *Layers*, tab you will be able to create
    different layers that hold your animation states and the relevant `Transitions`
    from one state to the next. The *Parameters* tab is where you define your parameters
    that will be accessed and modified by the Animator Controller, as well as through
    your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Animator Controller 是一个非常复杂的工具，你需要花一些时间来研究通过它可用的不同方面和功能。以下截图是空控制器的快照。我已经标记了Animator窗口的主要部分。有两个可见的选项卡，即层选项卡和
    *参数* 选项卡。在 *层* 选项卡中，你可以创建不同的层，这些层包含你的动画状态以及从一种状态到另一种状态的相关 `转换`。*参数* 选项卡是定义你的参数的地方，这些参数将由Animator
    Controller以及你的代码访问和修改。
- en: 'There is a wide range of topics that you will need to know to fully appreciate
    the Mecanim system. We won''t be going through all of the aspects in this book,
    but we will touch on some of the key aspects that are needed for our game. See
    the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解 Mecanim 系统，你需要了解一系列的主题。在这本书中，我们不会涵盖所有方面，但会涉及一些对我们游戏所需的关键方面进行探讨。请看以下截图：
- en: '![](img/00062.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00062.jpeg)'
- en: Animation states
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画状态
- en: 'To create a new state, you can simply drag and drop an animation from your
    Project window. This will name and assign the relevant animation to the state
    in the layer. You can also create an empty state by right-clicking in the layer
    and selecting *Create State* | *Empty*. When a state is created, you can click
    on the state and observe its properties in the Inspector window, as shown in the
    following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的状态，您只需从项目窗口拖放一个动画即可。这将命名并分配相关的动画到层的该状态。您也可以通过在层中右键单击并选择*创建状态* | *空状态*来创建一个空状态。当状态创建后，您可以通过点击状态并在以下屏幕截图中所示，在检查器窗口中观察其属性：
- en: '![](img/00063.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00063.jpeg)'
- en: Your model may or may not have animations attached to it. The whole idea of
    the Mecanim system is to enable character modelers to work on their models, while
    animators can use the skeleton of a humanoid avatar to animate the character.
    This in turn makes it easier and better to have a set of animations applied to
    different types of character models!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您的模型可能或可能没有附加动画。Mecanim系统的整个想法是使角色模型师能够在他们的模型上工作，同时动画师可以使用类人形角色的骨架来动画化角色。这反过来使得将一系列动画应用于不同类型的角色模型变得更加容易和更好！
- en: To identify the state, it is best to provide it with a unique name that can
    be easily recognized in the state diagram. You will need to assign a Motion to
    it; this is the animation clip that will be playing when the state is active.
    The next important property would be the *Transitions* property. A transition
    will determine the condition for which state will be moving to another state,
    if there is such a requirement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别状态，最好给它提供一个独特且易于在状态图中识别的名称。您需要给它分配一个动作；这是当状态激活时将播放的动画剪辑。下一个重要的属性将是*转换*属性。转换将确定状态将移动到另一个状态的条件，如果存在这样的要求。
- en: 'For instance, when the character is in an idle state, what condition is for
    the character to change its state to a walking state, to a running state and so
    forth, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当角色处于空闲状态时，什么条件会使角色将其状态更改为行走状态、跑步状态等等，如以下屏幕截图所示：
- en: '![](img/00064.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00064.jpeg)'
- en: 'In the preceding screenshot, you will see I have defined three different states:
    Idle, Walking, and Running. You will also notice that, in the *Parameters* tab,
    I have defined some parameters. These parameters are used to determine when to
    move from idle to walking, to running, and back. The parameters are there to help
    you create the conditions for your state machine.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您将看到我定义了三个不同的状态：空闲、行走和跑步。您还会注意到，在*参数*选项卡中，我定义了一些参数。这些参数用于确定何时从空闲状态移动到行走状态、跑步状态，以及返回。这些参数旨在帮助您为状态机创建条件。
- en: To create a Transition from one state to the next, right-click your state, and
    select *Make Transition*, then select the state it will transition to. This will
    create the visual arrow from the start state to the end state. Select the *Transition*
    arrow to get its properties, and set the conditions in the Inspector window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要从当前状态创建到下一个状态的转换，请右键单击您的状态，然后选择*创建转换*，然后选择它将转换到的状态。这将创建从起始状态到结束状态的视觉箭头。选择*转换*箭头以获取其属性，并在检查器窗口中设置条件。
- en: The Walking and Running states are actually a Blend Tree in this instance. A
    Blend Tree is used to make the transition from one animation state to the next
    more natural. In order for the blended motion to make sense, the motions that
    are blended must be of similar nature and timing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，行走和跑步状态实际上是一个混合树。混合树用于使从一个动画状态到下一个动画状态的过渡更加自然。为了使混合动作有意义，混合的动作必须是相似性质和时序的。
- en: Blend Trees are used to allow multiple animations to be blended smoothly by
    incorporating parts of them all to a varying degree. The amount that each of the
    motions contributes to the final effect is controlled using a blending parameter,
    which is just one of the numeric animation parameters associates with the Animator
    Controller.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 混合树用于通过将它们的所有部分以不同程度地结合在一起，允许多个动画平滑地混合。每个动作对最终效果贡献的程度是通过一个混合参数控制的，这个参数只是与Animator
    Controller关联的数字动画参数之一。
- en: 'For instance, the walking state could look something like the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，行走状态可能看起来像以下屏幕截图：
- en: '![](img/00065.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00065.jpeg)'
- en: Blend Tree example
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 混合树示例
- en: 'In our first *Blend Tree* node, we have five outputs: `HumanoidWalkLeftSharp`,
    `HumanoidWalkLeft`, `WalkFWD`, `HumanoidWalkRight`, and `HumanoidWalkRightSharp`.
    These are the animation clips that will be playing based on the value of the parameter
    called *Horizontal*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个*混合树*节点中，我们有五个输出：`HumanoidWalkLeftSharp`、`HumanoidWalkLeft`、`WalkFWD`、`HumanoidWalkRight`和`HumanoidWalkRightSharp`。这些是根据名为*水平*的参数值播放的动画剪辑。
- en: These animations are from *Raw Mocap Data for Mecanim.*
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动画来自*Mecanim的原始Mocap数据*。
- en: 'In the behavior region, you will notice a few thresholds that have been set
    up for the parameter; these thresholds are what determines the animation to be
    played. The value of the Horizontal parameter is set through our C# code by passing
    in the value of the Horizontal Axis, which is defined in the Input Manager. See
    the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为区域，你会注意到为参数设置了一些阈值；这些阈值决定了要播放的动画。水平参数的值通过我们的C#代码通过传递水平轴的值来设置，该值在输入管理器中定义。请看以下截图：
- en: '![](img/00066.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00066.jpeg)'
- en: When you select a *Blend Tree* node, your Inspector window will give you the
    ability to add or remove the different animation states, as well as the parameter
    and the threshold of the parameter that will determine which animation will be
    rendered.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个*混合树*节点时，你的检查器窗口将允许你添加或删除不同的动画状态，以及参数和参数的阈值，这将决定哪个动画将被渲染。
- en: The key to have a smooth looking blending in your animation is to pay attention
    to your animation data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画中实现平滑混合的关键是注意你的动画数据。
- en: 'Let''s take a look at our final state diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的最终状态图：
- en: '![](img/00067.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00067.jpeg)'
- en: State diagram
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 状态图
- en: At this stage, I have gone ahead and implemented the state diagram for *Idle*,
    *Walking*, *Running*, *Idle Jump*, *Running Jump, Attack1/2/3*, *Punch*, and *Die*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我已经提前实现了*空闲*、*行走*、*奔跑*、*空闲跳跃*、*奔跑跳跃、攻击1/2/3*、*拳头*和*死亡*的状态图。
- en: The parameter that defines the transition from the Idle state to the Walking
    and Running states is the Speed parameter. If the Speed value is greater than
    0.1, it will transition from Idle to Walking; if it is greater than 0.6, it will
    transition from Walking to Running. The opposite is true for going from Running
    to Walking, and from Walking to Running.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义从空闲状态到行走和奔跑状态的转换的参数是速度参数。如果速度值大于0.1，它将从空闲状态转换为行走状态；如果它大于0.6，它将从行走状态转换为奔跑状态。从奔跑状态到行走状态，以及从行走状态到奔跑状态的转换情况相反。
- en: Notice, however, that the character can only enter the Jump state from either
    the Idle state or from the Running state. The parameter that controls this transition
    is the `Jump` parameter, which is a Boolean value set by pressing the Space bar
    button on the keyboard.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，角色只能从空闲状态或奔跑状态进入跳跃状态。控制这种转换的参数是`Jump`参数，它是一个通过按键盘上的空格键设置的布尔值。
- en: There are also three attack states that can be triggered from the Any state,
    as well as a Die state that can be entered from the Any state. Well, this is because
    your character can die at any given time if you are not careful!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从任意状态可以触发三种攻击状态，以及可以从任意状态进入的死亡状态。嗯，这是因为如果你不小心，你的角色在任何时候都可能死亡！
- en: Let's take a look at how we can control these parameters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何控制这些参数。
- en: Character controller
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色控制器
- en: It is time to enable our character to move around the scene. This is generally
    handled by the character controller. The character controller will be used to
    handle most of the interactions the player will have with the character in the
    game.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让我们的角色在场景中移动了。这通常由角色控制器处理。角色控制器将被用来处理玩家在游戏中与角色的大部分交互。
- en: 'Create a new C# script and call it `BarbarianCharacterController.cs`. Enter
    the following code in the `BarbarianCharacterController` class. At the moment
    the code is very basic. Let''s get a listing of the code and we can start discussing
    the different parts of the code after the listing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，并将其命名为`BarbarianCharacterController.cs`。在`BarbarianCharacterController`类中输入以下代码。目前代码非常基础。让我们列出代码，然后我们可以开始讨论代码的不同部分：
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Start()` function, we will get a reference to the Animator Controller.
    We will be using the `FixedUpdate()` function to perform our updates for the character
    movement, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start()`函数中，我们将获取Animator Controller的引用。我们将使用`FixedUpdate()`函数来执行角色移动的更新，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is the difference between the `Update()` function and the `FixedUpdate()`?
    The `Update()` function is called every frame, and is used regularly to update
    the moving of non-physics objects, simple timers, and input processing. The update
    interval time varies for the `Update()` function. `FixedUpdate()` is called every
    physics step. The interval is consistent and used for adjusting physics on Rigidbody.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 函数和 `FixedUpdate()` 函数的区别是什么？`Update()` 函数在每一帧都会被调用，通常用于更新非物理对象的移动、简单的计时器和输入处理。`Update()`
    函数的更新间隔时间会有所不同。`FixedUpdate()` 函数在物理步骤中调用。间隔是固定的，用于调整 Rigidbody 上的物理。'
- en: In the `FixedUpdate()` function, we get the inputs for our Horizontal and Vertical
    axes, we calculate the *speed* value, and set the parameters defined in the Animator
    Controller using the `animator.SetFloat()` function. These parameters are then
    used by the animator controller to decide which state the character is at.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FixedUpdate()` 函数中，我们获取水平轴和垂直轴的输入，计算 *速度* 值，并使用 `animator.SetFloat()` 函数设置在动画控制器中定义的参数。然后，动画控制器使用这些参数来决定角色处于哪个状态。
- en: For instance, to go from an idle state to the walking state, the *speed* parameter
    needs to be greater than 0.1, and from walking to running, the *speed* parameter
    will need to be greater than 0.6, and the *run* parameter needs to be true. The
    opposite is true when you want to go back from the running state to the walking
    state and from the walking state to the idle state. The Horizontal and Vertical
    parameters control the movement for turning left or turning right. All these three
    parameters combined control what state and what animation the character is rendering.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从空闲状态过渡到行走状态，*速度* 参数需要大于 0.1，从行走状态过渡到跑步状态，*速度* 参数需要大于 0.6，并且 *run* 参数需要为
    true。当你想从跑步状态回到行走状态，以及从行走状态回到空闲状态时，情况相反。水平方向和垂直方向参数控制转向左或右的移动。这三个参数的组合控制角色渲染的状态和动画。
- en: The next step is for us to enable the *Jump*, Die and *Attack* states. The Jump
    state can be entered while the character is idle or running and the Jump Boolean
    variable is set to true. The jump condition is set in the `Update()` function
    when the space bar is pressed by the player. This sets the variable to true and
    passes the variable to the animator controller.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们启用 *跳跃*、*死亡* 和 *攻击* 状态。跳跃状态可以在角色空闲或跑步时进入，并且跳跃布尔变量设置为 true。跳跃条件在玩家按下空格键时设置在
    `Update()` 函数中。这会将变量设置为 true 并将其传递给动画控制器。
- en: 'The same mechanism is used for the attack and punch state. This is mapped to
    the following keys on the keyboard: *C* and *P*. Each one will set its Boolean
    value to true and pass it into the animator controller. The player can only enter
    these states from the Any state. We will leave it as is for now.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击和拳套状态使用相同的机制。这映射到键盘上的以下按键：*C* 和 *P*。每个按键都会将其布尔值设置为 true 并传递给动画控制器。玩家只能从 Any
    状态进入这些状态。我们现在就保持这个状态。
- en: Finally, the Die state is implemented, and for now we are using the keyboard
    input I to test it out. The main difference between the Die state and the other
    states so far is that the Die state can be entered from any state.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实现了死亡状态，目前我们使用键盘输入 I 来测试它。死亡状态与其他状态的主要区别在于，死亡状态可以从任何状态进入。
- en: We are not using Blend Trees for these states as there is only one type of animation
    for the state. You will also notice that the states can only be transitioned to
    from the Idle state. This is due to how the animations and model were set up initially.
    Yours could be different.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为这些状态使用 Blend Trees，因为这些状态只有一种动画。你也会注意到，状态只能从空闲状态过渡到。这是由于动画和模型最初设置的方式。你的可能不同。
- en: 'Take a look at the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00068.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: Animator parameters
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 动画参数
- en: The character can get into the Die and Attack states from any state. That is,
    your character player can die at any time in the game, whatever state he or she
    is in at the time. The jump states can be triggered from two states, idle and
    the running. You can improve these transitions and states based on the level of
    your animation complexity, but for now, this should do.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 角色可以从任何状态进入死亡和攻击状态。也就是说，你的角色玩家可以在游戏中的任何时间死亡，无论他或她当时处于什么状态。跳跃状态可以从两种状态触发，空闲和跑步。你可以根据你的动画复杂度级别改进这些过渡和状态，但就目前而言，这样应该足够了。
- en: 'Take a look at the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00069.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: These states are controlled through Boolean parameters defined in the animator.
    At this stage, you should be able to use your model to test the scene, as well
    as your character animations and states.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态是通过动画器中定义的布尔参数控制的。在这个阶段，你应该能够使用你的模型来测试场景，以及你的角色动画和状态。
- en: Modification to animations
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画修改
- en: There might be times that you will need to make some changes and/or modifications
    to the existing modification that will make it work properly with your game and
    the state machine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要做一些更改和/或修改现有的修改，以便它能够与你的游戏和状态机正常工作。
- en: 'The attack animations prepared for my character model need to be adjusted to
    make them loop while the character is still in that particular state. For instance,
    if I use the existing animation and the character state goes into attack mode,
    the animation will play only once. This is not what I intend to do; I am building
    the attack input to perform the attack while the attack key is pressed down. Changing
    the animation loop setting is easy. To do so, select the animation from your Project
    window and select the *Edit...* button from the Inspector window, as shown in
    the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为我的角色模型准备好的攻击动画需要调整，以便在角色仍然处于那个特定状态时循环播放。例如，如果我使用现有的动画，并且角色状态进入攻击模式，动画将只播放一次。这不是我想要的效果；我正在构建攻击输入，以便在攻击键按下时执行攻击。更改动画循环设置很简单。为此，从你的项目窗口中选择动画，然后从检查器窗口中选择*编辑...*按钮，如图下面的屏幕截图所示：
- en: '![](img/00070.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: You will now be in the Edit mode of the animation, as displayed in the following
    screenshot. I have placed the Inspector window next to it, to illustrate the Animation
    tab, selecting each animation we want to modify, one at a time, and setting the
    Loop Time property to True.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将进入动画的编辑模式，如图下面的屏幕截图所示。我把它放在旁边，以展示动画选项卡，选择我们想要修改的每个动画，一次一个，并将循环时间属性设置为True。
- en: 'In this particular screenshot, you will also notice several other important
    properties for the animation, such as *Root Transform Rotation*, *Mirror*, *Curves*,
    *Events*, *Mask*, and *Motion*. We will use the Curves property when we set out
    Inverse Kinematics for some of our animations regarding our character. This basically
    sets the values of predefined parameters that can be used to set or get them through
    *Mecanim*. Take a look at the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的屏幕截图中，你还会注意到动画的几个其他重要属性，例如*根变换旋转*、*镜像*、*曲线*、*事件*、*遮罩*和*运动*。当我们为我们的角色动画设置逆运动学时，我们会使用曲线属性。这基本上设置了预定义参数的值，这些值可以通过*Mecanim*来设置或获取。看看下面的屏幕截图：
- en: '![](img/00071.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: If your animations are attached to your model and your animations and models
    are older, you will most likely need to make some modifications to them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的动画附加到你的模型上，并且你的动画和模型较旧，你很可能需要对其进行一些修改。
- en: For instance, one of the main properties that you might have to set for a particular
    animation clip would be the *Loop Time* property, as shown in the preceding screenshot.
    This will make sure that the animation will loop as long as you are in the state
    which is running the animation. If looping is not enabled, the animation will
    run once and stop, even if you are still in the state representing the animation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能需要为特定动画剪辑设置的一个主要属性可能是*循环时间*属性，如图前面所示的屏幕截图。这将确保动画将在你处于运行动画的状态下循环播放。如果循环未启用，动画将只播放一次并停止，即使你仍然处于表示动画的状态。
- en: Make sure the *Loop Time* property is set for the idle, walking, running and
    attacking animations. At the same time, not all animation clips need to be looped,
    for instance, the jump and die animations just need to be played once. You will
    need to do your diligence and check all of these properties.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保空闲、行走、跑步和攻击动画的*循环时间*属性已设置。同时，并非所有动画剪辑都需要循环，例如，跳跃和死亡动画只需要播放一次。你需要做足功课，检查所有这些属性。
- en: 'Other animation will need to be modified to enable baking the transform into
    the model. For instance, the die and jump animations have the following properties
    checked: *Root Transform Rotation* and *Root Transform Position (Y)*; make sure
    that the *Bake Into Pose* property is checked. This is important, to make sure
    the animation and the skeletal movement of the character are harmonized at the
    root transform position.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其他动画需要修改以启用将变换烘焙到模型中。例如，投掷和跳跃动画具有以下属性被勾选：*根变换旋转*和*根变换位置（Y）*；确保*烘焙到姿态*属性被勾选。这很重要，以确保动画和角色的骨骼运动在根变换位置上和谐一致。
- en: Your animation might seem funky if these properties are not set properly. If
    there is something weird going on, make sure to double-check these properties.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些属性设置不正确，你的动画可能会显得很奇怪。如果有任何异常情况发生，请务必仔细检查这些属性。
- en: If you have not done so by now, you should attach your `BarbarianharacterController.cs`
    script to your player character.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，你应该将你的`BarbarianharacterController.cs`脚本附加到你的玩家角色上。
- en: Inverse Kinematics
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆运动学
- en: '**Inverse Kinematics** (**IK**) is important in game programming. It is typically
    used to make the character''s movement more realistic. One of the main uses of
    IK is the calculation of the player''s feet and how they relate to the ground
    they are standing on.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆运动学**（**IK**）在游戏编程中非常重要。它通常用于使角色的动作更加逼真。逆运动学的一个主要用途是计算玩家的脚以及它们与站立地面的关系。'
- en: In short, IK is used to determine the position and rotation of the joints of
    a character based on a given position in space. For instance, to make sure the
    foot of a player lands properly on the terrain it is walking on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，IK用于根据空间中的给定位置确定角色的关节位置和旋转。例如，确保玩家的脚在行走的地面上的着陆位置正确。
- en: Unity has a built-in IK system that can be used to do some basic calculations
    in this regard. Let's go ahead and implement the foot IK for our character. There
    are a few things that you will need to set up before we can enable IK for our
    humanoid character.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有一个内置的逆运动学系统，可以用来进行这方面的基本计算。让我们继续为我们的角色实现脚部逆运动学。在我们为我们的拟人角色启用逆运动学之前，有一些事情需要设置。
- en: 'The first thing to do is check your layer in the Animator Controller and use
    the Engine icon to enter the Settings window. Make sure that *IK Pass* is checked,
    as shown in the following screenshot. You will also need to provide a Mask if
    you have not done so already. The mask is used to dictate which parts of the skeleton
    are affected by the IK. Take a look at the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是检查你的动画控制器中的层级，并使用引擎图标进入设置窗口。确保已勾选*IK传递*，如图下所示。如果你还没有这样做，你还需要提供一个遮罩。遮罩用于指定哪些骨骼部分受到逆运动学的影响。请参考以下截图：
- en: '![](img/00072.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00072.jpeg)'
- en: Mask for Inverse Kinematics
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 逆运动学遮罩
- en: 'Once you have set this up, the fun begins. We need to create a C# script that
    will handle our IK. Create a C# script and call it `IKHandle.cs`. Type the following
    code into the script:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，乐趣就开始了。我们需要创建一个C#脚本来处理我们的IK。创建一个名为`IKHandle.cs`的C#脚本。将以下代码输入到脚本中：
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This script is a bit involved. In order for the Inverse Kinematic, that is,
    IK, to work properly, we need to identify a couple of important points in space.
    One of these points is the position of the target in space that we want our foot
    to move to, and the second point in space is the hint. These two points in space
    are used to control the movement and translations of the skeleton for a particular
    joint to be made, in order to successfully complete the IK for the target position.
    Take a look at the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有些复杂。为了使逆运动学，即IK，正常工作，我们需要在空间中识别几个重要的点。其中一个点是我们要让脚移动到的目标位置在空间中的位置，另一个点是提示。这两个空间点用于控制特定关节的骨骼运动和变换，以便成功完成目标位置的IK。请参考以下代码：
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `LeftFootPosition` and `RightFootPosition` variables are used to represent
    the target position for the left and right foot during runtime. `LeftFootRotation`
    and `RightFootRotation` are used to store the rotation of the left and right foot.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeftFootPosition`和`RightFootPosition`变量用于在运行时表示左右脚的目标位置。`LeftFootRotation`和`RightFootRotation`用于存储左右脚的旋转。'
- en: We also need two variables to actually reference our left and right foot in
    the model. This is done by the `LeftFoot` and `RightFoot` variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要两个变量来在模型中实际引用我们的左右脚。这是通过`LeftFoot`和`RightFoot`变量完成的。
- en: Some of these variables are initialized in the `Start()` function. Specifically,
    we get a reference to the left and right foot from the Animator Controller bone
    structure defined for humanoids.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些变量在`Start()`函数中初始化。具体来说，我们从为人类角色定义的Animator Controller骨骼结构中获取左右脚的引用。
- en: 'In the `Update()` function, we use `Physics.Raycast()` to perform some raycasting,
    to determine the position of our left and right foot. This data is then used and
    stored in the `LeftFootPosition` and `RightFootPosition` variables, with their
    equivalent rotation data in the `LeftFootRotation` and `RightFootRotation` variables.
    Take a look at the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`函数中，我们使用`Physics.Raycast()`执行一些射线投射，以确定左右脚的位置。然后，这些数据被使用并存储在`LeftFootPosition`和`RightFootPosition`变量中，以及它们在`LeftFootRotation`和`RightFootRotation`变量中的等效旋转数据。请看以下截图：
- en: '![](img/00073.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00073.jpeg)'
- en: Animation curves
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 动画曲线
- en: The actual IK animation is applied in the `OnAnimatorIK()` function. The `LeftFootWeight`
    and `RightFootWeight` variables are used to get the parameter values set for `MyLeftFoot`
    and `MyRightFoot` in the Animator Controller, through the animation clip `Curve`
    function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的IK动画是在`OnAnimatorIK()`函数中应用的。`LeftFootWeight`和`RightFootWeight`变量用于通过Animator
    Controller中的动画剪辑`Curve`函数获取为`MyLeftFoot`和`MyRightFoot`设置的参数值。
- en: The key here is to properly define the curve of the animation clip that will
    be used to drive the weight of the IK. The preceding screenshot only shows the
    curve of the idle state. Both feet are on the ground, therefore the value is set
    to 1\. For your walking and running clips, your curve will be different.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于正确定义将用于驱动IK权重的动画剪辑曲线。前面的截图只显示了空闲状态的曲线。两只脚都放在地面上，因此值设置为1。对于你的行走和跑步剪辑，你的曲线将不同。
- en: Finally, the `SetIKPositionWeight()` and `SetIKPosition()` functions are used
    to properly adjust the position and rotation of the feet relative to the ground!
    Notice that this is performed for each foot separately.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`SetIKPositionWeight()`和`SetIKPosition()`函数来正确调整脚相对于地面的位置和旋转！请注意，这是为每只脚分别执行的。
- en: Attach the `IKHandle.cs` script to your character and do a test run. Notice
    the difference in your character and the way it is interacting with the floor
    or the terrain you have set up.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将`IKHandle.cs`脚本附加到你的角色上并执行测试运行。注意你的角色以及它与地面或你设置的地面或地形交互的方式有何不同。
- en: Setting the animation curve
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置动画曲线
- en: 'This step is very important for the IK to work. I am going to use the Idle
    animation to demonstrate what needs to be configured, to make sure the parameters
    in the animator controller are set properly. Take a look at the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步对于IK的正常工作非常重要。我将使用空闲动画来演示需要配置的内容，以确保动画控制器中的参数设置正确。请看以下截图：
- en: '![](img/00074.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00074.jpeg)'
- en: Animation curve modification
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 动画曲线修改
- en: For the IK to work properly and look nice, you will need to set the curve for
    each animation that has to do with the motion of the feet. Since we have five
    sets of animations for walking and running, you will need to perform the same
    for each animation curve to properly set the weight value that will be passed
    to the IK script.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使IK正常工作并看起来不错，你需要为与脚部运动相关的每个动画设置曲线。由于我们有五套行走和跑步的动画，你需要为每个动画曲线执行相同的操作，以正确设置传递给IK脚本的权重值。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We covered a lot of content in this chapter. We discussed the different character
    definitions we will be using for our game, looked at the base character class
    attributes that will be shared by all of our characters, and created the `BaseCharacter`
    class to be used later in the game. We also discussed the primary states our character
    will have in the game, and how to implement them using the Animator Controller.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量内容。我们讨论了我们将在游戏中使用的不同角色定义，查看所有角色将共享的基础角色类属性，并创建了`BaseCharacter`类，以便在游戏后期使用。我们还讨论了角色在游戏中的主要状态，以及如何使用Animator
    Controller来实现它们。
- en: We looked at how to rig our character model to be prepared for the Mecanim system,
    as well as how to use the Mecanim system to create animation and state diagrams
    that will determine how the character behaves during game play. Then we implemented
    our initial character controller script that handles the state of our character.
    This gave us the opportunity to look at the Blend Trees and transition from one
    state to the next using parameters. We then looked at how to modify animation
    clips if there is a need for it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何为我们的角色模型绑定，使其为Mecanim系统做好准备，以及如何使用Mecanim系统创建动画和状态图，这些图将决定角色在游戏中的行为。然后我们实现了我们的初始角色控制器脚本，该脚本处理我们角色的状态。这给了我们机会查看混合树以及使用参数从一个状态过渡到下一个状态。然后我们探讨了如果需要的话如何修改动画剪辑。
- en: Finally, we learned about Inverse Kinematics, which will help our character
    to behave more realistically in the game environment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了逆运动学，这将帮助我们的角色在游戏环境中表现得更加真实。
- en: Having reached the end of the chapter, you should have a good grasp of all of
    the different components that work together to make your character look, behave,
    and move in the game environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 章节结束，你应该已经很好地掌握了所有共同作用使你的角色在游戏环境中看起来、表现和移动的不同组件。
- en: In the next chapter, we will be introducing non-character behaviors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍非角色行为。
