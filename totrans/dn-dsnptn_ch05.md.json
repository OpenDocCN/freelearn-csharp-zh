["```cs\n    using iTextSharp; \n    using iTextSharp.text; \n    using iTextSharp.text.pdf; \n    //------some code omitted \n    FileStream fs = new FileStream(@\"D:\\ab\\fund.pdf\",   \n    FileMode.Create); \n    Document document = new Document(PageSize.A4, 25, 25, 30, 30); \n    PdfWriter writer = PdfWriter.GetInstance(document, fs); \n    document.AddAuthor(\"Praseed Pai\"); \n    document.AddCreator(\"iTextSharp PDF Library\"); \n    document.AddTitle(\"PDF Demo\"); \n    document.Open(); \n    PdfPTable table = new PdfPTable(2); \n    PdfPCell cell = new PdfPCell(new Phrase(\"A Header which spans    \n    Columns\")); \n    cell.Colspan = 3; \n    cell.HorizontalAlignment = 1;  \n    table.AddCell(cell); \n    table.AddCell(\"Col 1 Row 1\"); \n    table.AddCell(\"Col 2 Row 1\"); \n    table.AddCell(\"Col 3 Row 1\"); \n    table.AddCell(\"Col 1 Row 2\"); \n    table.AddCell(\"Col 2 Row 2\"); \n    table.AddCell(\"Col 3 Row 2\"); \n    document.Add(table); \n    document.Close(); \n    writer.Close(); \n    fs.Close(); \n\n```", "```cs\n    public enum OPERATOR \n    { \n      //--- supports +,-,*/ \n      PLUS,MINUS,MUL,DIV \n    } \n    /// <summary> \n    /// Base class for all Expression \n    /// supports accept method to implement  \n    /// so called \"Double Dispatch\". Search for  \n    /// \"Double Dispatch\" and Visitor to understand more  \n    /// about this strategy \n    /// </summary> \n    public abstract class Expr \n    { \n      //------ Whenever we start traversal, we will start from  \n      //------ the topmost node of a hierarchy and  \n      //-------descends down the heirarchy \n      //------ The Visitor will call the accept method of a node \n      //------ and node will reflect it back to concrete class \n      //------ using Visit method. Thus Visitor dispatches the  \n      //------ call to a node and node dispatches it back to the \n      //-------visit method of the Visitor. This is called a \n      //------ a double dispatch \n      public abstract double accept(IExprVisitor expr_vis); \n    } \n\n```", "```cs\n    /// <summary> \n    ///  Our Visitor Interface. The Purpose of seperating Processing \n    ///  Of Nodes and Data Storage (heirarchy) is for various  \n    ///  transformations on the composites created. \n    /// </summary> \n    public interface IExprVisitor \n    { \n      double Visit(Number num); \n      double Visit(BinaryExpr bin); \n      double Visit(UnaryExpr un); \n    } \n\n```", "```cs\n    /// <summary> \n    ///  Class Number stores a IEEE 754 doouble precision \n    ///  floating point \n    /// </summary> \n    public class Number : Expr \n    { \n      public double NUM { get; set; } \n      public Number(double n) { this.NUM = n; } \n      public  override double accept(IExprVisitor expr_vis) \n      { \n        return expr_vis.Visit(this); \n      } \n    } \n\n```", "```cs\n    /// <summary> \n    ///  Class BinaryExpr models a binary expression of  \n    ///  the form <Operand> <OPER> <Operand> \n    /// </summary> \n    public class BinaryExpr : Expr \n    { \n      public Expr Left { get; set; } \n      public Expr Right { get; set; } \n      public OPERATOR OP { get; set; } \n      public BinaryExpr(Expr l,Expr r,OPERATOR op){ \n        Left = l; Right = r; OP = op; \n      } \n      public override double accept(IExprVisitor expr_vis) \n      { \n        //----- When this method gets invoked by a Concrete \n        //----- implementation of Visitor, the call is routed \n        //----- back to IExprVisitor.Visit(BinaryExpr ) \n        return expr_vis.Visit(this); \n      } \n    } \n\n```", "```cs\n    /// <summary> \n    /// Class UnaryExpr models a unary expression of the form \n    /// <OPER> <OPERAND>  \n    /// </summary>\n   public  class UnaryExpr  : Expr { \n     public Expr Right; \n     public OPERATOR OP; \n     public UnaryExpr (Expr r,OPERATOR op) { \n       Right = r; OP = op; \n     } \n     public override double accept(IExprVisitor expr_vis) \n     { \n       //----- When this method gets invoked by a Concrete \n       //----- implementation of a Visitor, the call is routed \n       //----- back to IExprVisitor.Visit(UnaryExpr ) \n       return expr_vis.Visit(this); \n     } \n   } \n\n```", "```cs\n    Expr first = new BinaryExpr( \n      new Number(1), \n      new Number(2), \n      OPERATOR.PLUS); \n\n```", "```cs\n    Expr r = new BinaryExpr(new Number(2), \n    new BinaryExpr( \n      new Number(3),  \n      new Number(4),  \n      OPERATOR.MUL), \n    OPERATOR.PLUS); \n\n```", "```cs\n    /// <summary> \n    ///  A Visitor implementation which converts Infix expression to  \n    ///  a Reverse Polish Notation ( RPN)  \n    /// </summary> \n    public class ReversePolishEvaluator : IExprVisitor \n    { \n      public double Visit(Number num) \n      { \n        //------ Spit the number to the console \n        Console.Write(num.NUM+ \" \"); \n        return 0; \n      } \n      public double Visit(BinaryExpr bin) \n      { \n        //------ Traverse the Left Sub Tree followed \n        //------ By Right Sub Tree. We follow a Depth \n        //------ First Traversal \n        bin.Left.accept(this); \n        bin.Right.accept(this); \n        //-----  After Nodes has been processed, spit out \n        //-----  the Operator \n        if (bin.OP == OPERATOR.PLUS) \n          Console.Write(\" + \"); \n        else if (bin.OP == OPERATOR.MUL) \n          Console.Write(\" * \"); \n        else if (bin.OP == OPERATOR.DIV) \n          Console.Write(\" / \"); \n        else if (bin.OP== OPERATOR.MINUS) \n          Console.Write(\" - \"); \n        return Double.NaN; \n      } \n      public double Visit(UnaryExpr un) \n      { \n        //-------- In a Unary Expression we have got  \n        //-------- only a sub tree, Traverse it \n        un.Right.accept(this); \n        //-------- Spit the operand to the Console. \n        if (un.OP == OPERATOR.PLUS) \n          Console.Write(\"  + \"); \n        else if (un.OP == OPERATOR.MINUS) \n          Console.Write(\"  - \"); \n        return Double.NaN; \n      } \n    } \n\n```", "```cs\n    Expr r = new BinaryExpr(new Number(2), \n      new BinaryExpr( \n        new Number(3),  \n        new Number(4),  \n        OPERATOR.MUL), \n      OPERATOR.PLUS); \n\n```", "```cs\n    IExprVisitor visitor =  \n      new ReversePolishEvaluator(); \n    second.accept(visitor); \n\n```", "```cs\n    /// <summary> \n    ///  A Visitor which evaluates the Infix expression using a Stack \n    ///  We will leverage stack implementation available with .NET  \n    ///  collections API \n    /// </summary> \n    public class StackEvaluator : IExprVisitor \n    { \n      //------- A stack to store double values \n      //------- .NET Framework has got a stack implementation! \n      private Stack<double> eval_stack = new Stack<double>(); \n      //---- return the computed value \n      //---- implementation does not do any error check \n      public double get_value() { return eval_stack.Pop(); } \n\n      public StackEvaluator() { eval_stack.Clear(); } \n      public double Visit(Number num) \n      { \n        //---- whenever we get an operand \n        //---- push it to the stack \n        eval_stack.Push(num.NUM); \n        return 0; \n      } \n      public double Visit(BinaryExpr bin) \n      { \n        bin.Left.accept(this); \n        bin.Right.accept(this); \n        //--- We have processed left and right sub tree \n        //--- Let us pop values, apply the operator \n        //--- and push it back \n        if (bin.OP == OPERATOR.PLUS) \n          eval_stack.Push(eval_stack.Pop() + eval_stack.Pop()); \n        else if (bin.OP == OPERATOR.MUL) \n          eval_stack.Push(eval_stack.Pop() * eval_stack.Pop()); \n        else if (bin.OP == OPERATOR.DIV) \n        { \n          double dval = eval_stack.Pop(); \n          if (dval == 0) \n          { \n            //--- handle division by zero error \n            //--- throw an exception \n          } \n          eval_stack.Push( eval_stack.Pop()/dval); \n        } \n        else if (bin.OP == OPERATOR.MINUS) \n          eval_stack.Push(eval_stack.Pop() - eval_stack.Pop()); \n        return Double.NaN; \n      } \n      public double Visit(UnaryExpr un) \n      { \n        un.Right.accept(this); \n        if (un.OP == OPERATOR.PLUS) \n          eval_stack.Push(eval_stack.Pop()); \n        else if (un.OP == OPERATOR.MINUS) \n          eval_stack.Push(-eval_stack.Pop()); \n        return Double.NaN; \n      } \n    } \n\n```", "```cs\n    Expr third = new BinaryExpr(new Number(2), \n      new BinaryExpr( \n      new Number(3),  \n      new Number(4),  \n      OPERATOR.MUL), \n    OPERATOR.PLUS); \n\n    StackEvaluator seval = new StackEvaluator();  \n    third.accept(seval);\n    Console.WriteLine(seval.get_value()); \n    Console.WriteLine(); \n\n```", "```cs\n    public abstract class TDocumentElement \n    { \n      public List<TDocumentElement> DocumentElements { get; set; } \n      //------ The method given below is for implementing Visitor     \n      Pattern \n      public abstract void accept(IDocumentVisitor doc_vis); \n      //--- Code Omitted \n      public TDocumentElement() \n      { \n        DocumentElements = new List<TDocumentElement>(5); \n        this.Align = alignment.LEFT; \n        this.BackgroundColor = \"0xFF000000L\"; \n      } \n      //---- Code Omitted \n      public void addObject(TDocumentElement value) \n      { \n        if (value != null) \n        DocumentElements.Add(value); \n      } \n      public Boolean removeObject(TDocumentElement value) \n      { \n        if (value != null) \n        { \n          DocumentElements.Remove(value); \n          return true; \n        } \n        return false; \n      } \n      //----- Code Omitted \n    } \n\n```", "```cs\n    public class TDocument : TDocumentElement \n    { \n      public string Title {get;set;} \n      public string BackGroundImage { get; set;} \n      public string TextColor { get; set;} \n      public string LinkColor {get;set;} \n      public string Vlink { get; set;} \n      public string Alink {get;set;} \n      public  int ColumnCount { get; set;} \n      public override void accept(IDocumentVisitor doc_vis) \n      { \n        doc_vis.visit(this); \n      } \n      public TDocument(int count=1) \n      { \n        this.ColumnCount = count; \n        this.Title = \"Default Title\"; \n      } \n    } \n\n```", "```cs\n    public class TDocumentTable : TDocumentElement \n    { \n      public string  Caption {get;set; } \n      public int Width { get;set; } \n      public int Border { get; set; } \n      public int CellSpacing { get;set;} \n      public int Cellpadding { get; set; } \n      public Boolean PercentageWidth { get;set; } \n      public String bgColor {get; set; } \n\n      public int RowCount \n      { \n        get \n        { \n          return this.DocumentElements.Count; \n        } \n      } \n\n      public override void accept(IDocumentVisitor doc_vis) \n      { \n        doc_vis.visit(this); \n      } \n\n      public TDocumentTable() \n      { \n      } \n    } \n\n```", "```cs\n    public class TDocumentTableRow : TDocumentElement \n    { \n      public TDocumentTableRow(){} \n      public override void accept(IDocumentVisitor doc_vis) \n      { \n        doc_vis.visit(this); \n      } \n    } \n\n```", "```cs\n    public class TDocumentTableCell : TDocumentElement \n    { \n      public int ColumnSpan { get; set; } \n      public alignment Horizontal { get; set; } \n      public alignment Vertical { get; set; } \n      public alignment Type { get; set; } \n      public TDocumentTableCell() \n      { \n        this.ColumnSpan = 1; \n        this.Horizontal = alignment.LEFT; \n        this.Vertical = alignment.MIDDLE; \n        this.Type = alignment.DATA; \n      } \n      public override void accept(IDocumentVisitor doc_vis) \n      { \n        doc_vis.visit(this); \n      } \n    } \n\n```", "```cs\n    public class TDocumentText : TDocumentElement \n    { \n      public string Text { set;get; } \n      public Boolean Bold {get;set;} \n      public Boolean Italic {get;set;} \n      public Boolean Underline { get; set; } \n      public Boolean Center {get;set;} \n      public Boolean Preformatted { get; set; } \n      public string Color { get; set; } \n      public Boolean Font  {get;set;} \n\n      public TDocumentText(string value = null) \n      { \n        this.Text = value; \n      } \n\n      public override void accept(IDocumentVisitor doc_vis) \n      { \n        doc_vis.visit(this); \n      } \n    } \n\n```", "```cs\n    public interface IDocumentVisitor \n    { \n      void visit(TDocument doc); \n      void visit(TDocumentTable table); \n      void visit(TDocumentTableRow row); \n      void visit(TDocumentTableCell cell); \n      void visit(TDocumentText txt); \n    } \n\n```", "```cs\n    public abstract class TDocumentElement \n    { \n      //--- code omitted \n      public abstract void accept(IDocumentVisitor doc_vis); \n      //--- code omitted \n    } \n\n```", "```cs\n    public class TDocument : TDocumentElement \n    { \n      //----- code omitted \n      public override void accept(IDocumentVisitor doc_vis) \n      { \n        doc_vis.visit(this); \n      } \n      //------ code omitted\n    } \n\n```", "```cs\n    string filename = @\"D:\\ab\\fund.pdf\"; \n    ds.accept(new PDFVisitor(filename)); \n\n```", "```cs\n    public class PDFVisitor : IDocumentVisitor \n    { \n      private string file_name = null; \n      private PdfWriter writer = null; \n      private Document document = null; \n      private PdfPTable table_temp = null; \n      private FileStream fs = null; \n      private int column_count; \n\n      public PDFVisitor(string filename) \n      { \n        file_name = filename; \n        fs = new FileStream(file_name, FileMode.Create); \n        document = new Document(PageSize.A4, 25, 25, 30, 30); \n        writer = PdfWriter.GetInstance(document, fs); \n      } \n\n```", "```cs\n    public void visit(TDocument doc) \n    { \n      document.AddAuthor(@\"Praseed Pai & Shine Xavier\"); \n      document.AddCreator(@\"iTextSharp Library\"); \n      document.AddKeywords(@\"Design Patterns Architecture\"); \n      document.AddSubject(@\"Book on .NET Design Patterns\"); \n      document.Open(); \n      column_count = doc.ColumnCount; \n      document.AddTitle(doc.Title); \n\n      for (int x = 0; x < doc.DocumentElements.Count; x++) \n      { \n        try \n        { \n          doc.DocumentElements[x].accept(this); \n        } \n        catch (Exception ex) \n        { \n          Console.Error.WriteLine(ex.Message); \n        } \n      } \n      document.Add(this.table_temp); \n      document.Close(); \n      writer.Close(); \n      fs.Close(); \n\n```", "```cs\n    public void visit(TDocumentTable table) \n    { \n      this.table_temp = new PdfPTable(column_count); \n      PdfPCell cell = new  \n      PdfPCell(new Phrase(\"Header spanning 3 columns\")); \n      cell.Colspan = column_count; \n      cell.HorizontalAlignment = 1;  \n      table_temp.AddCell(cell); \n      for (int x = 0; x < table.RowCount; x++) \n      { \n        try \n        { \n          table.DocumentElements[x].accept(this); \n        } \n        catch (Exception ex) \n        { \n          Console.Error.WriteLine(ex.Message); \n        } \n      } \n    } \n\n```", "```cs\n    public void visit(TDocumentTableRow row) \n    { \n      for (int I = 0; i < row.DocumentElements.Count; ++i) \n      { \n        row.DocumentElements[i].accept(this); \n      } \n    } \n\n```", "```cs\n    public void visit(TDocumentTableCell cell) \n    { \n      for (int i = 0; i < cell.DocumentElements.Count; ++i) \n      { \n        cell.DocumentElements[i].accept(this); \n      } \n    } \n\n```", "```cs\n    public void visit(TDocumentText txt) \n    { \n      table_temp.AddCell(txt.Text); \n    } \n  } \n\n```", "```cs\n    public class HTMLVisitor : IDocumentVisitor \n    { \n      private String file_name = null; \n      private StringBuilder document = null; \n      public HTMLVisitor(string filename) { \n        file_name = filename; \n      } \n      //--- Code omitted for all methods \n      public void visit(TDocument doc){} \n      public void visit(TDocumentTable table){} \n      public void visit(TDocumentTableRow row) {} \n      public void visit(TDocumentTableCell cell) {} \n      public void visit(TDocumentText txt) {} \n    }\n```", "```cs\n    string filename = @\"D:\\ab\\fund.html\"; \n    ds.accept(new HTMLVisitor(filename)); \n\n```", "```cs\n    static void DocumentRender() \n    { \n      TDocument ds = new TDocument(3); \n      ds.Title = \"Multiplication Table\"; \n      TDocumentTable table = new TDocumentTable(); \n      table.Border = 1; \n      table.Width = 100; \n      table.BackgroundColor = \"#EFEEEC\"; \n      TDocumentTableRow row = null; \n      row = new TDocumentTableRow(); \n\n      TDocumentText headtxt = new TDocumentText(\"Multiplicand\"); \n      headtxt.Font = true; \n      headtxt.Color = \"#800000\"; \n      TDocumentTableCell cell = null; \n      cell = new TDocumentTableCell(alignment.HEADING); \n      cell.addObject(headtxt); \n      row.addObject(cell); \n\n      headtxt = new TDocumentText(\"Multiplier\"); \n      headtxt.Color = \"#800000\"; \n      cell = new TDocumentTableCell(alignment.HEADING); \n      cell.addObject(headtxt); \n      row.addObject(cell); \n      headtxt = new TDocumentText(\"Result\"); \n      headtxt.Color = \"#800000\"; \n      cell = new TDocumentTableCell(alignment.HEADING); \n      cell.addObject(headtxt); \n      row.addObject(cell); \n      table.addObject(row); \n\n      int a = 16; \n      int j = 1; \n\n      while (j <= 12) \n      { \n        row = new TDocumentTableRow(); \n        cell = new TDocumentTableCell(alignment.DATA); \n        cell.addObject(new TDocumentText(a.ToString())); \n        row.addObject(cell); \n        cell = new TDocumentTableCell(alignment.DATA); \n\n        cell.addObject(new TDocumentText(j.ToString())); \n        row.addObject(cell); \n        cell = new TDocumentTableCell(alignment.DATA); \n        int result = a * j; \n        cell.addObject(new TDocumentText(result.ToString())); \n        row.addObject(cell); \n        table.addObject(row); \n        j++; \n      } \n      ds.addObject(table); \n\n      string filename = \n      @\"D:\\ab\\fund.pdf\"; \n      ds.accept(new PDFVisitor(filename)); \n\n      string filename2 = \n      @\"D:\\ab\\fund.html\"; \n      ds.accept(new HTMLVisitor(filename2)); \n    } \n\n```"]