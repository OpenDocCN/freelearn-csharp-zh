- en: Optimizing for Performance and Comfort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've mentioned throughout these chapters, the success of your VR app will
    be negatively impacted by any discomfort your users feel. It is a fact that VR
    can cause motion sickness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The symptoms of motion sickness are nausea, sweating, headaches, even vomiting.
    It can take hours, perhaps an overnight sleep, to recover. In real life, humans
    are susceptible to motion sickness: riding a roller coaster, a bumpy airplane,
    a rocking boat. It''s caused when one part of the balance-sensing system thinks
    your body is moving but other parts don''t.'
  prefs: []
  type: TYPE_NORMAL
- en: In VR, this could occur when the eyes see motion but your body doesn't sense
    it. We've considered ways you can design your VR apps to avoid this. With locomotion,
    always give the user control over their first person movement. Try to avoid riding-the-rails
    experiences and especially avoid free-falling. Include using a horizon line or
    dashboard in the foreground so at least the player feels they're grounded in a
    cockpit if not on solid ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite is also true: when you body feels motion but your eyes don''t
    see it.  Even very subtle discord can have a bad effect. In VR, a major culprit
    is latency. If you move your head but the view you see doesn''t keep up with the
    movement, that can cause nausea.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this chapter is at the end of this book, we do not mean to suggest
    that performance issues be left for the end of your project implementation. The
    old adage "first get it to work, then get it to work faster" doesn''t necessarily
    apply to VR development. You need to pay attention to performance and comfort
    throughout your development process, which we will address as the main topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your artwork and 3D models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing your scene and lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the rendering with shaders and settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key tools in analyzing and diagnosing performance issues are the built-in Unity
    Profiler and Stats windows. We will start with a quick introduction to these.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Unity Profiler and Stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing can be a lot of work, and there is a learning curve to get the hang
    of it. The good news is that it can be accomplished incrementally. Tackle the
    more obvious, bigger bang-for-the-buck things first. You can accomplish a lot
    with little or no visual degradation after a bit of experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity Editor includes two built-in tools to assess performance: the Stats window
    and the Profiler window.'
  prefs: []
  type: TYPE_NORMAL
- en: The Stats window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Stats window shows real-time rendering statistics when you press Play in
    the Unity Editor. Reviewing and understanding these statistics is your first line
    in evaluating and improving the performance of your app, and can help you decide
    which optimization strategies, including those covered in this chapter, to tackle
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Game window, enable Stats by pressing the Stats button. A screenshot
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8472ef1b-22cf-4eed-8592-8332d6ed18ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The actual statistics displayed will vary depending on your current build target (see [http://docs.unity3d.com/Manual/RenderingStatistics.html](http://docs.unity3d.com/Manual/RenderingStatistics.html)),
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Graphics FPS (frames per seconds) and time per frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU time per frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tris (triangles)/Verts (vertices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In VR, you want to pay close attention to the frames per second. The minimum
    acceptable rate varies depending on your target device, but generally for desktop
    devices you should keep it at or above 90 FPS, while 60 FPS (or 75 FPS) is considered
    an absolute minimum. The Sony PlayStation VR accepts 60 FPS but uses hardware
    to automatically double the rate to 120 FPS to compensate. Windows Mixed Reality
    HMD will throttle the frame rate between 90 and 60 depending on the graphics processor
    hardware on your computer, allowing laptops with slower mobile GPU to run VR.
    Phone-based mobile VR devices can target 60 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: When in Editor Play mode, the FPS is not necessarily the same as you'd experience
    running a built executable in your device, so it should be used as an indicator,
    not necessarily an actual value. But, thankfully, it does not include any editor-only
    processing such as drawing the Scene view.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the CPU time per frame and comparing that with the overall graphics
    time per frame will tell you whether your game is CPU bound or GPU bound. That
    is, which process is the bottleneck, slowing you down the most. The CPU is used
    for physics calculations, geometry culling, and other operations that prepare
    the data for rendering in the GPU. The GPU runs the shaders and actually generates
    the pixel values for display. Knowing if you're CPU or GPU bound can help dictate
    where to focus your optimization efforts to improve your game performance.
  prefs: []
  type: TYPE_NORMAL
- en: The Tris (triangles) and Verts (vertices) values show the size of your geometric
    models' meshes that are drawn. Only the visible faces of your meshes are counted,
    so your scene could include much more.  That is, the values in Stats are the geometry
    the camera is looking at, not including any vertices outside the view, and after
    any occluded surfaces have been removed. As you move the camera or as objects
    in the scene move, the numbers will change. As we'll see in the next topic, reducing
    the poly count of your models can lead to significant gains in performance.
  prefs: []
  type: TYPE_NORMAL
- en: The Batches value is an indicator of how hard your GPU is working. The more
    batches, the more rendering the GPU must perform each frame. The number of batches,
    not the size of a batch, is the bottleneck. You can reduce batches by reducing
    the geometry in your scene. Since it's faster to have fewer (albeit larger) batches
    than lots of small ones, you can tell Unity to optimize the graphics by combining
    more geometry into larger batches, and pump that through the GPU pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: When profiling and optimizing, write down (or take screenshots of) the stats
    and label them, perhaps in a spreadsheet, to log your progress and measure the
    effectiveness of each technique that you try.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unity Profiler is a performance instrumentation tool that reports how much
    processing time is spent in various areas of your game, including rendering and
    scripts. It records the statistics over time during gameplay and shows them in
    a timeline graph. Clicking lets you drill down into the details. See [http://docs.unity3d.com/Manual/Profiler.html](http://docs.unity3d.com/Manual/Profiler.html) and
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffb8bf9d-6826-42fa-8580-c642473f0db7.png)'
  prefs: []
  type: TYPE_IMG
- en: The Profiler compacts a lot of information into a small space, so you should
    recognize its various parts to understand better what you're seeing. Along the
    top of the window is the Profiler controls toolbar, which enables you to turn
    profiling on and off (Record) and navigate through profiled frames. The white
    vertical line in the profile Tracks is the playhead, indicating the current frame
    being examined.
  prefs: []
  type: TYPE_NORMAL
- en: The Deep Profile button lets you drill down into more detail, recording all
    function calls in your scripts. This can be useful to see exactly where time is
    spent in your game code. Note that deep profiling incurs a lot of overhead and
    causes your game to run very slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the toolbar are the profile tracks. Scroll down the Tracks pane to
    reveal more.  You can add and remove tracks using the Add Profiler select list.
  prefs: []
  type: TYPE_NORMAL
- en: Each track includes stats for many parameters pertaining to that category of
    processing. For example, CPU Usage includes Scripts and Physics; the Rendering
    one include Batches and Triangles. The visual graph allows you to readily detect
    anomalies. When troubleshooting, look for stretches and spikes where the data
    exceeds your expected thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: You can profile your game running in the Unity Editor, or remote profile your
    game running in a separate player, such as a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some decisions that impact performance the most are your intentionally creative
    ones. Maybe you want hyper-realistic graphics with high-fidelity sound because
    *its gotta be so awesome!* Realizing you must dial that down may constitute a
    difficult design compromise. However, it's also likely that with a little creative
    *outside-the-box* thinking and experimentation, you can achieve (nearly) identical
    visual results with much better performance. The one thing that you have most
    control over in your project is the content of your scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Quality is not only how it looks, but also how it feels. Optimizing for user
    experience is as fundamental a design decision as any.
  prefs: []
  type: TYPE_NORMAL
- en: In general, try to minimize the number of vertices and faces in your model's
    meshes. Avoid complex meshes. Remove faces that will never be seen, such as the
    ones inside of solid objects. Clean up duplicate vertices and remove doubles.
    This will most likely be done in the same 3D modeling application you used to
    create them in the first place. For example, Blender has the tools for this. Also,
    there are third-party tools that you can purchase to simplify model meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out Unity's Import Settings for your FBX models. There are
    option to compress and optimize your meshes, for example. See [https://docs.unity3d.com/Manual/FBXImporter-Model.html](https://docs.unity3d.com/Manual/FBXImporter-Model.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate what we mean. We are going to set up a scene with a high polygon
    count model, replicate that model 1000 times, examine it in the Profiler, and
    try some optimization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we'll need a high-poly model. We found one of a pair of sunglasses
    on Turbosquid with over 5,800 triangles, and which includes a transparent material
    for the lenses ([https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082](https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082)).
    Please download the FBX file now. A copy is also included with the files for this
    book, for convenience. We will refer to this as `Sunglasses-original.fbx` to distinguish
    it from other versions we'll modify along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go into Unity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene (File | New Scene), then save it (File | Save Scene As) and
    name it `Optimization`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the model into your Project `Assets Models` folder (Assets | Import New
    Asset)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a ground plane for reference (Create | 3D  Object | Plane), named `Ground
    Plane`, reset its Transform, and create or assign it a material with a neutral
    color (such as our `Ground Material` with Albedo `#908070FF`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cube (Create | 3D Object | Cube), Positioned at (`-1, 1, 1`), and give
    it a colored material (such as  our `Red Material` with Albedo `#E52A2AFF`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `Main Camera` to Position (`0, 0.5, -2`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add a copy of the sunglasses:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of the `Sunglasses-original` model into the scene
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position (`0, 1, 0`), Rotation (`90, 180, 15`), and Scale (`10, 10,
    10`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a baseline, let''s look at its Stats and Profile, and make a note of the
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Game window, press Stats
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, open the Profiler window (Window | Profile)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Game window has the following scene and Stats window, showing the graphics
    hovering around 420 FPS, CPU main 2.4ms, with 22.6k Tris:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/606e83c4-8de1-4c75-a9fd-a10524379c10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding Profiler window is shown next. You can see in the Rendering
    timeline where I moved the HMD around:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6c71367-764e-431f-9aa4-5bc42d401d5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This scene is too simple to gather much in the way of meaningful statistics.
    Let''s create 1000 copies of the sunglasses in the scene; follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object and name it `SunglassesReplicator`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script on it, named `SunglassesReplicator`, and write it as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The script takes a `prefab` object and instantiates it the `dup` number of times
    (`10`) in each of the X, Y, and Z axes, offsetting each by `delta` units (`2`),
    generating a total of 1000 instances of the prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script, then back in Unity, set up and assign the replicator parameters
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a prefab of your sunglasses. Drag the `Sunglasses-original` from Hierarchy
    into your Project `Assets prefabs` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `SunglassesReplicator` in Hierarchy again and drag the prefab from
    Project Assets onto its Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `SunglassesReplicator` Position to (`-10, 1, 0`) as the origin of our
    stack of sunglasses
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press Play and the generated sunglasses Borg is shown in the Scene window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66cdabb4-35c6-495c-97e5-4d3ea06b8099.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Stats now report over 36 million tris and a frame rate under 60 FPS. Ugh!
    The corresponding Profiler timeline is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6acd84f0-0c62-40a1-b67e-29b6dc19761d.png)'
  prefs: []
  type: TYPE_IMG
- en: OK, now that we have a poorly performing scene, let's see what we can do about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Decimating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing we can do is try to simplify the models that we imported into Unity.
    If you select the `SunGlasses-original` object in your Project Assets, you can
    see it consists of two meshes: the `Frame` with 4176 tris, and the `Lens` with
    1664 tris. We should reduce the number of faces on the mesh, or *decimate* the
    model. Presently, we will use the separate free and open source Blender application
    ([https://www.blender.org/](https://docs.unity3d.com/Manual/LevelOfDetail.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the original FBX file of this model downloaded from Turbosquid is
    in FBX 6 ASCII format, which is not compatible with Blender 2.7+. The version
    of the file provided with this book was converted using Autodesk FBX Converter
    2013 ([http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=22694909](http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=22694909)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to decimate the model in Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender, and delete all to clear the default scene (keyboard A | A again
    | X | Delete)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the source Sunglasses fbx file (File | Import | FBX)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the sunglasses' frame model mesh (right-click)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right, choose the Modify tool (wrench icon)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Modifier | Decimate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set Ratio to `0.1`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f409db7-ea4b-4662-9a5b-1f87f337d137.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, press Apply
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the sunglass' lens model mesh (right-click)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decimate it also to Ratio `0.1` and Apply
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the camera, light, and background objects (select with mouse, keyboard
    X to delete)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export as FBX (File | Export | FBX) and give it a new name, such as `SunGlasses-decimated.fbx`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now back in Unity, import the model and use it in our replicator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the new `SunGlasses-decimated.fbx` file (Assets | Import New Asset) into
    your `Models` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of this model, `SunGlasses-decimated`, into the scene
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy/paste the transform from the original (using Transform Copy Component from
    the original, and Paste Component Values on the decimated version)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this as a prefab (drag `SunGlasses-decimated` from Hierarchy into your
    Project `Assets Prefabs` folder)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set this one in the `SunglassesReplicator` (drag the prefab from Project Assets
    onto the replicator's Prefab slot)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play and as expected, we are now running about 3.4M tris, about 10% of 
    what we had before, and we've boosted the FPS some, consistently more than 60
    FPS. Better, but not good enough.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another killer of graphics processing and frame rate is the use of transparency
    and other rendering techniques that require each pixel to be rendered multiple
    times. For the sunglasses lens to appear transparent, Unity will render the solid
    objects behind it first, then render the semi-transparent lens pixels on top,
    effectively merging the pixel values. Possibly dozens of lenses stacked in front
    of one another causes a considerable amount of processing work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we replace the transparent lens material with
    an opaque one:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Project `Assets Materials` folder, create a new Material and name it
    `Lens_Opaque`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For its Albedo color, choose an opaque gray, such as `#333333FF`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of `Sunglasses-source` to Hierarchy and rename it `Sunglasses-opaque`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold it and select the `Lens` child object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Lens_Opaque` material onto the Lens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Sunglasses-opaque` and drag it into the `Prefabs` folder, creating
    a new prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `SunglassesReplicator` selected, drag the `Sunglasses-opaque` prefab onto
    its Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you press Play now, we have 1000 of the opaque sunglasses and we get a
    much better frame rate, about 80 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we combine these two techniques? Let''s use the opaque material
    on the decimated lenses. Like we just did, create another version of the prefab,
    named `Sunglasses-decimated-opaque`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of `Sunglasses-decimated` to Hierarchy and rename it `Sunglasses-decimated-opaque`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold it and select the `Lens` child object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Lens_Opaque` material onto the Lens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Sunglasses-decimated-opaque` and drag it into the `Prefabs` folder,
    creating a new prefab with the opaque lenses
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `SunglassesReplicator` selected, drag the `Sunglasses-decimated-opaque` prefab
    onto its Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pressing Play we consistently get about 100 FPS, as shown in the Profiler timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18ff4448-d9eb-44df-aa46-deebc8b5793c.png)'
  prefs: []
  type: TYPE_IMG
- en: Terrific! We have the frame rate we want. But... that's not the look we want
    either. We have opaque lenses, but we expect translucent ones. And, disappointingly,
    the low poly versions of the glasses look... low poly. That's just not acceptable.
    Perhaps there's a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Levels of detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reviewing our scene, we realize that the high-poly sunglasses are really only
    needed for the ones closest to you. As they recede further into the distance,
    the low-poly version is just fine. Likewise, the transparency on the lenses is
    really mostly needed on the ones near you. The sunglasses in the distance, and
    those occluded by other glasses, do not really need transparency. Unity understands
    this and provides a component to automatically manage levels of detail, called
    **LOD Group** (see [https://docs.unity3d.com/Manual/LevelOfDetail.html](https://docs.unity3d.com/Manual/LevelOfDetail.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this now. We''ll create a group of sunglasses, with each of our
    versions for levels of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create an Empty game object, name it `SunglassesLOD`, and reset
    its Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of the `Sunglasses-original` prefab as a child of `SunglassesLOD`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of the `Sunglasses-decimated` prefab as a child also
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And drag a copy of the `Sunglasses-decimated-opaque` too
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the parent `Sunglasses` object and Add Component | LOD Group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the LOD Group component in Inspector. Notice it has several ranges for
    when to use each model based on camera distance, labeled LOD0, LOD1, and LOD2\.
    The range is a percentage of the object's bounding box height relative to the
    screen height. When closest, the LOD0 objects are active. Further away, those
    will be deactivated and the LOD1 ones will be active, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assign the LOD groups now:'
  prefs: []
  type: TYPE_NORMAL
- en: Select LOD0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Sunglasses-original` game object from Hierarchy onto the Add button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select LOD1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Sunglasses-decimated` game object onto the Add button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select LOD2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Sunglasses-decimated-opaque` object onto Add also
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A screen capture of the Inspector is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebf71c76-3614-4e92-b3ad-8bd0d99824da.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice there is a little camera icon on the top edge of the LODn groups. You 
    can select and slide it across to preview the LOD activations based on camera
    distance. You can also configure the active range of each LOD (percentage) by
    sliding the edge of each area box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try it in our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `SunglassesLOD` object into your Project Prefabs folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `SunglassesReplicator` in Hierarchy and drag the `SunglassesLOD` prefab
    onto its Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press Play. The Profiler timeline is shown next. There''s essentially no difference
    from our most optimized version, but we get the high-poly models and transparent
    lenses when we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a31c6277-9e26-40bc-abc2-7265d7cd3979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next is a screen capture of the Game view using SunglassesLOD. Closest to us
    are the high-poly glasses. The middle are low-poly, but with transparent lenses.
    Further away are low-poly and opaque versions of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb109066-c9c6-4c71-9670-c56a3f07bde1.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a number LOD tools available in the Unity Asset Store to help manage
    levels of detail and even generate decimated meshes from your models. Unity itself
    is toying with such a tool, AutoLOD, available free on GitHub ([https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/](https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/)).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your scene with static objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to your art objects, the next step in optimization might be how
    your scene itself is organized. If we tell Unity that specific objects will not
    move in the scene, it can precompute a lot of the rendering in advance rather
    than at runtime. We do this by defining these game objects as *static*, and then
    *baking* them into specific contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We used static objects in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gazed-Based Control*, when we set up a `Navmesh` for Ethan to run through. His
    walkable *nav* area was defined by the flat ground plane minus any large static
    objects that might get in his way, baked into a *navmesh*.
  prefs: []
  type: TYPE_NORMAL
- en: Statics can also be used to help precompute the scene rendering. Baked lightmaps
    and shadowmaps precompute lighting and shadows. Baked occlusions divide the scene
    into static volumes that can be readily culled when out of view, saving processing
    by possibly eliminating many objects from consideration at once. Let's try some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate the use of static game objects, we cannot use the dynamically
    instantiated sunglasses by `SunglassesReplicator`. But given we have this script,
    we''ll use it to our advantage now:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `SunglassesReplicator` and drag the `Sunglasses-original`
    prefab from Project Assets onto its Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While playing, in the Hierarchy, select all the `Sunglasses-original(Clone)`
    objects (there's 1000 of them!). Right-click and select Copy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the play mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Hierarchy, create an Empty game object and name it `SunglassesBorg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the cloned sunglasses as children of `SunglassesBorg`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `SunglassesReplicator` object, as we no longer want to use it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you had the need to do this more than once, you could write an *Editor Script*.
    For example, maybe you need a BorgMaker menu option in the Editor''s main menubar.
    It could prompt you with a dialog box asking for the prefab object, duplication
    counts, and offset parameters, much like our `SunglassesReplicator`. Writing scripts
    that customize and extend the Unity Editor is common practice. If you''re interested,
    see the *Manual: Extending the Editor* ([https://docs.unity3d.com/Manual/ExtendingTheEditor.html](https://docs.unity3d.com/Manual/ExtendingTheEditor.html))
    and the *Editor Scripting Intro* tutorial ([https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro](https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro)).'
  prefs: []
  type: TYPE_NORMAL
- en: Lighting and baking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of lights in your scene affects frame rate. You have a great deal of
    control over the number of lights, types of lights, their placement, and settings. Read
    up on it in the Unity manual, which can be found at [http://docs.unity3d.com/Manual/LightPerformance.html](http://docs.unity3d.com/Manual/LightPerformance.html).
  prefs: []
  type: TYPE_NORMAL
- en: Use baked lightmaps whenever possible, which precalculates the lighting effects
    into a separate image rather than at runtime. Use real-time shadows sparingly.
    When an object casts shadows, a shadow map is generated, which will be used to
    render the other objects that might receive shadows. Shadows have a high rendering
    overhead and generally require high-end GPU hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the impact of using baked lightmaps on our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `SunglassesBorg` and click its Static checkbox in the upper right of Inspector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, answer Yes, change children
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you get an error, "Mesh doesn't have UVs suitable for lightmapping," select
    the imported fbx model in your Project window, choose Generate Lightmap UVs, and Apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your Lighting settings, the lightmaps may begin generating right
    away.  Review and modify the lightmap settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Lighting window (Window | Lighting)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Auto Generate checked, it will start generating lightmaps any time your
    scene changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Or, uncheck it and click Generate Lighting to build them manually
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a screen capture of the Game window running with 1000 high-poly Sunglasses
    with transparency. We''re getting 90 FPS now, and as I move the non-static red
    cube around, it still renders with transparency and shadows present:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75ce6640-0463-4187-b607-caa25432e429.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Lighting window, there are also settings for Realtime Lighting (enabled
    by default), Baked Global Illumination (enabled by default), Lightmapper subsystem
    (Enlighten by default), and Fog effects (disabled by default), all of which affect
    the quality and performance of your scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more tips when dealing with lighting:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid dynamic shadows, just use a "blurry blob" underneath moving things by
    using a Projector (see [https://docs.unity3d.com/Manual/class-Projector.html](https://docs.unity3d.com/Manual/class-Projector.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your project’s Quality Settings (Edit | Project Settings | Quality). Use
    fewer Pixel Lights (on mobile, limit to 1 or 2). Use High Resolution on Hard and
    Soft Shadows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have as many baked lights as you want. Baked lighting produces high
    quality results, whereas real-time shadows can appear blocky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When baking, you can improve lightmap quality by increasing the baked resolution
    (a 40-100 pixel resolution is reasonable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use light probes with baked lighting to illuminate dynamic objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use reflection probes for reflective surfaces. These can be static (baked) or
    dynamic (real-time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light probes (either real-time or baked) and the choice of shaders (and the
    shader options), can make your scene look really amazing. However, they can also
    have a significant effect on the performance. Balancing aesthetics and graphics
    performance is an art and a science.
  prefs: []
  type: TYPE_NORMAL
- en: Occlusion culling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, the more you try to reduce the number of objects that need to
    be rendered, the better. Whether or not you are using high- or low-poly models,
    Unity still needs to figure out which faces are in view. When there are a lot
    of objects, perhaps we could help Unity out by giving it some clues.
  prefs: []
  type: TYPE_NORMAL
- en: Occlusion culling disables the rendering of objects when they are not seen by
    the camera because they are obscured (occluded) by other objects. (See [http://docs.unity3d.com/Manual/OcclusionCulling.html](http://docs.unity3d.com/Manual/OcclusionCulling.html).)
    It examines your scene and, using the bounding boxes (extents) of each object,
    divides the world space into a hierarchy of cubes. When Unity needs to determine
    if an object is within view, it will throw away any objects who's culling box
    is obviously outside of the view, and continue through the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we''ll replicate a few copies of our `SunglassesBorg` and set
    up occlusion culling:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `SunglassesBorg`, right-click, then Duplicate three times
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first copy, set the Y-Rotation to `90`, then move it off to Position
    X = `20`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second copy, set Y-Rotation to `-90` and move it to Position X = `-20`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the third copy, set Y-Rotation to `180` and move it Position Z = `-20`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When I press Play, with so many objects, we are down to about a 50 FPS frame
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with the following changes, we can address our performance problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All four Borgs are already Static, but verify that the Static: Occluder and
    Occludee are checked (inspect the Static drop-down list)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Occlusion Culling window (Window | Occlusion Culling)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Bake
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we could have, but didn't, distinguish Occludees versus Occluders in
    our scene. Occludees are objects that get occluded. Ocluders are ones that may
    be in front, occluding the others. Translucent objects that do not occlude should
    be marked as Occludees, but not Occluders.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may take a while. Here is a top-down Scene view with the generated culling
    volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce571836-350e-4eeb-bb9a-0fc105b9c30c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now when I press Play, the performance is back up to 90 FPS again (more or less,
    depending on where you're looking, as a user in the scene).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to reduce the details in a scene is by using Global Fog, which is
    based on distance. Objects further away than the fog limits will not be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another area prone to performance problems and ripe for optimization is your
    script code. Throughout this book, we have used various coding best practices,
    without necessarily explaining why. (On the other hand, some examples in this
    book are not necessarily efficient, in favor of simplicity and explanation.) In
    [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml), *Playing with Physics
    and Fire*, for example, we implemented an object pool memory manager to avoid
    repeatedly instantiating and destroying game objects that causes memory **garbage
    collection** (**GC**) issues, which in turn slows down your app.
  prefs: []
  type: TYPE_NORMAL
- en: In general, try to avoid code that repeats a lot of computation over and over.
    Try to pre-compute as much work as you can and store the partial results in variables.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you may have to use a profiling tool to see how your code is
    performing under the hood. If the Profiler indicates that a large amount of time
    is spent in the scripts that you've written, you should consider another way to
    refactor the code so that it's more efficient. Often, this is related to memory
    management, but it could be math or physics. (See [http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html](http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html).)
  prefs: []
  type: TYPE_NORMAL
- en: Please follow coding best practices, but otherwise avoid going out of your way
    with premature optimization. One mistake people make is putting too much effort
    into optimizing areas of their code that don't need it, sacrificing readability
    and maintainability in the process. Use the Profiler to analyze where the performance
    bottlenecks are and focus your optimization efforts there first.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Unity life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like all video game engines, when your game runs, Unity is executing a giant
    loop, repeating over and over each frame update. Unity provides many *hooks* to
    tap into events at just about every step in the game loop. Depicted below is the
    life cycle flowchart, taken from the Unity Manual page Execution Order of Event
    Functions ([https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)).
    The two event functions you are most familiar with, `Start` and `Update`, are
    highlighted with the red arrows. The green dots highlight a number of other events
    we''ll reference in this conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebe8a3a5-399a-4859-8d10-8ea0792291e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting at the top of this chart, when your game starts, each GameObject's
    component, which is derived from the `MonoBehaviour` class, will be woke with
    a call to `Awake`. Unless you need to use `Awake` or `OnEnable`, we typically
    initialize objects in `Start`. Skipping down to the Game Logic section, `Update`
    is called on each frame iteration. Note the loop line/arrows. (The physics engine
    has its own loop timing, for dealing with RigidBodies, which may be more frequent
    than the frame updates. You hook into it with `FixedUpdate`.) The `OnDestroy`
    event is called to decommission the object.
  prefs: []
  type: TYPE_NORMAL
- en: For the current discussion, the important thing to notice is which events are
    within the game loop, and which are outside.
  prefs: []
  type: TYPE_NORMAL
- en: Writing efficient code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to keep all of the code within the game loop (such as`FixedUpdate`, `Update`,
    and `LateUpdate`) as lean as possible. Move any initialization into `Awake`, `OnEnable`,
    or `Start`. We also want to precompute and cache any computationally expensive
    work in the initialization functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a call to `GetComponent` is expensive. As we''ve seen in many
    scripts in this book, it is a best practice to get references to any components
    that Update will need, outside the game logic loop, in `Start`. The following
    code, used in [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), Lo*comotion
    and Comfort*, gets the `CharacterController` component in `Start`, caches it in
    a variable, and then references it in `Update`, rather than calling `GetComponent`
    every frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Any time you declare an `Update()` function in your script (or any other event
    function), Unity will call it, even if it's empty. Therefore, you should remove
    any unused `Updates` even though they're part of the default template when you
    create a new C# `MonoBehaviour` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if you have code in `Update` that does not need to be called every
    frame, turn off the calculations using a state variable (and an `if` statement)
    when they are not needed, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding expensive API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than moving expensive API calls out of Update into an initialization function,
    there are some APIs that should be avoided altogether if possible. Here are a
    few.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid `Object.Find()`. To obtain a reference to a game object in your scene,
    do not call `Find`. Not only is `Find` by name expensive, as it must search the
    Hierarchy tree, but it is brittle (might break) if you rename the object it is
    looking for. If you can, define a `public` variable to reference the object and
    associate it in the Editor Inspector. If you must find the object at runtime,
    use Tags or perhaps Layers to limit the search to a known fixed set of candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid `SendMessage()`. The legacy use of `SendMessage` is computationally expensive
    (because it makes use of runtime *reflection*). To trigger functions in another
    object, use Unity Events instead.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid fragmenting memory and garbage collection. Temporary allocations of data
    and objects may cause memory to fragment. Unity will periodically go through the
    memory heap to consolidate free blocks, but this is expensive and can cause frames
    to skip in your app.
  prefs: []
  type: TYPE_NORMAL
- en: For more suggestions and a deeper discussion, see the Unity best practices guide,
    *Understanding Optimization in Unity* ([https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Another area of optimization is Unity Physics. In previous chapters, we briefly
    mentioned using layers for ray casting, to limit the objects Unity needs to search,
    for example, for gaze-based selection in VR. Likewise, physics collision detection
    can be limited to objects on specific layers by defining a Layer Collision Matrix.
    See the manual page on Optimizing Physics Performance ([https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html](https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html))
    and the Physics Best Practices tutorial ([https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of important performance considerations that are specific
    to how Unity does its rendering. Some of these may be common for any graphics
    engine. Some recommendations may change as newer versions of Unity emerge, the
    technology advances, and algorithms get replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many articles offering recommendations for which setting to use to
    optimize your VR apps, and it''s not unusual for one''s advice to contradict another''s.
    Here are some good ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Forward Rendering path. This is the default in Graphics Settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `4X` MSAA (multi-sampling anti-aliasing). This is a low-cost anti-aliasing
    technique that helps remove jagged edges and shimmering effects in Quality Settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Single Pass Stereo Rendering. It performs efficient rendering of parallax
    perspective for each eye in a single pass in Player Settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable Static Batching and Dynamic Batching in Player Settings. These are discussed
    later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that some rendering settings are device- or platform-specific, and found
    in the Player Settings (Edit | Project Settings | Player). Others have been abstracted
    by Unity into project Quality Settings (Edit | Project Settings | Quality). Still
    others are in the Graphics Settings (Edit | Project Settings | Graphics).
  prefs: []
  type: TYPE_NORMAL
- en: The phrase *Player Settings* in Unity does not refer to the user (player) nor
    a first-person character (player rig). Rather it's referring to the platform executable
    that *plays* your app. More like a media player, such as a video player that plays
    mp4s, the Unity *player* runs your game after it has been compiled. The Player
    Settings configure the generated executable.
  prefs: []
  type: TYPE_NORMAL
- en: Life's a batch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps, the biggest bang for the buck is a feature in Unity that groups different
    meshes into a single batch, which is then shoveled into the graphics hardware
    all at once. This is much faster than sending the meshes separately. Meshes are
    actually first compiled into an OpenGL vertex buffer object, or VBO, but that's
    a low-level detail of the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Each batch takes one draw call. Reducing the number of draw calls in a scene
    is more significant than the actual number of vertices or triangles. For mobile
    VR, for example, stay around 50 (up to 100) draw calls.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of batching, **static batching** and **dynamic batching***,* enabled
    in Player Settings.
  prefs: []
  type: TYPE_NORMAL
- en: For static batching, simply mark the objects as static by checking off the Static checkbox
    in the Unity Inspector for each object in the scene. Marking an object static
    tells Unity that it will never move, animate, or scale. Unity will automatically
    batch together the meshes that share the same material into a single, large mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'The caveat here is meshes must share the same Material settings: the same texture,
    shader, shader parameters, and the material pointer object. How can this be? They''re
    different objects! This can be done by combining multiple textures into a single
    macro-texture file or TextureAtlas and then UV-mapping as many models as will
    fit. It''s a lot like a sprite image used for 2D and web graphics. There are third-party
    tools that help you build these.'
  prefs: []
  type: TYPE_NORMAL
- en: A useful analytic tool for checking resources in your scene, including active
    textures, materials and meshes, is the Unity Resource Checker, found here: [https://github.com/handcircus/Unity-Resource-Checker](https://github.com/handcircus/Unity-Resource-Checker).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic batching is similar to static batching. For objects that are not marked Static,
    Unity will still try to batch them, albeit it will be a slower process since it
    needs to think about it frame by frame (the CPU cost). The shared Material requirement
    still holds, as well as other restrictions such as vertex count (less than 300
    vertices) and uniform Transform Scale rules. (See [http://docs.unity3d.com/Manual/DrawCallBatching.html](http://docs.unity3d.com/Manual/DrawCallBatching.html).)
  prefs: []
  type: TYPE_NORMAL
- en: When managing textures in scripts, use `Renderer.sharedMaterial` rather than `Renderer.material` to
    avoid creating duplicate materials. Objects receiving a duplicate material will
    opt out of the batch.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, only Mesh Renderers and Particle Systems are batched. This means
    that skinned meshes, cloth, trail renderers, and other types of rendering components
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: Multipass pixel filling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another concern in the rendering pipeline is sometimes referred to as the pixel
    fill-rate. If you think about it, the ultimate goal of rendering is to fill each
    pixel on the display device with the correct color value. If it has to paint any
    pixels more than once, that's more costly. For example, watch out for transparent
    particle effects, such as smoke, that touch many pixels with mostly transparent
    quads.
  prefs: []
  type: TYPE_NORMAL
- en: For VR, Unity paints into a frame buffer memory that is larger than the physical
    display dimensions, which is then post-processed for ocular distortion correction
    (barrel effect) and chromatic aberration correction (color separation), before
    getting tossed onto the HMD display. In fact, there may be multiple overlay buffers
    that get composited before the post-processing.
  prefs: []
  type: TYPE_NORMAL
- en: This multipass pixel filling is how some advanced renderers work, including
    lighting and material effects such as multiple lights, dynamic shadows, and transparency
    (Transparent and Fade Render modes) - the Unity Standard Shader as well. Basically,
    all the good stuff!
  prefs: []
  type: TYPE_NORMAL
- en: VBO batches with materials that require multipass pixel filling get submitted
    multiple times, thus increasing the net number of draw calls. Depending on your
    project, you may choose to either optimize the heck out of it and avoid multipass
    pixel filling altogether, or carefully curate the scenes with an understanding
    of what should have a high performance and what should have a high fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Light Probes to inexpensively simulate dynamic lighting of your
    dynamic objects. Light probes are baked cubemaps that store information about
    direct, indirect, and even emissive light at various points in your scene. As
    a dynamic object moves, it interpolates samples of the nearby light probes to
    approximate the lighting at that specific position. This is a cheap way of simulating
    realistic lighting on dynamic objects without using expensive real-time lights.
    (See [http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html).)
  prefs: []
  type: TYPE_NORMAL
- en: Unity 2018 introduces a new Scriptable Render Pipeline, providing a way of configuring
    and controlling rendering from C# scripts. Unity 2018 includes alternative built-in
    pipelines for lightweight rendering (such as for mobile and VR apps), and high
    definition rendering (such as for high fidelity physically based renders), and
    there's an opportunity for the community to build and share more. Use of these
    pipelines may supersede information and recommendations made here.
  prefs: []
  type: TYPE_NORMAL
- en: VR-optimized shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shaders are small programs that are compiled to run in the GPU. They process
    your 3D vectors and polygons (triangles), prepared by the game engine on the CPU,
    along with lighting information, texture maps, and other parameters, to generate
    pixels on the display.
  prefs: []
  type: TYPE_NORMAL
- en: Unity comes with a rich set of shaders. The Default Surface Shader is a powerful
    and optimized one that supports textures, normal maps, height maps, occlusion
    maps, emission map, specular highlights, reflections, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Unity also includes a set of mobile optimized shaders that are popular for mobile
    (and desktop) VR development. While they may not provide as high-quality lighting
    and rendering support, they are designed to perform well on mobile devices and
    should be considered in any developer's toolbox, even on desktop VR apps.
  prefs: []
  type: TYPE_NORMAL
- en: VR device manufacturers and developers have released their own custom shaders
    that optimize graphics processing in ways they see fit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Daydream Renderer** ([https://developers.google.com/vr/develop/unity/renderer](https://developers.google.com/vr/develop/unity/renderer))
    is a Unity package designed for high-quality rendering optimized for the Daydream
    platform. It supports normal maps, specular highlights with up to eight dynamic
    lights, "hero shadows" with significant performance improvements over Unity''s
    standard shaders.'
  prefs: []
  type: TYPE_NORMAL
- en: Valve (Steam) released the VR shaders used in their impressive demo project,
    *The Lab*, as a Unity Package ([https://assetstore.unity.com/packages/tools/the-lab-renderer-63141](https://assetstore.unity.com/packages/tools/the-lab-renderer-63141)).
    It supports up to 18 dynamic shadowing lights in a single pass with MSAA.
  prefs: []
  type: TYPE_NORMAL
- en: The Oculus OVRPlugin, included with Unity, contains a number of Oculus-specific
    shaders, used by their prefabs and script components.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party developers also provide shaders with their tools and utilities. As
    mentioned in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content,
    Objects, and Scale*, the Google Poly Toolkit for Unity include shaders for models
    downloaded from Poly, including artwork created with TiltBrush.
  prefs: []
  type: TYPE_NORMAL
- en: And you can experiment and write your own shader. In [Chapter 10](df997d92-d63c-4701-9786-da7ba54082b6.xhtml),
    *Using All 360 Degrees,* we looked at the Unity **ShaderLab** language when we
    wrote our own inward shader. Unity 2018 introduces a new **Shader Graph** tool
    for visually building shaders instead of using code. It's intended to be "simple
    enough that new users can become involved in shader creation."
  prefs: []
  type: TYPE_NORMAL
- en: Runtime performance and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphics hardware architectures continue to evolve towards performance that
    benefits rendering pipelines of virtual reality (and augmented reality). VR introduces
    requirements that weren''t so important for traditional video gaming. Latency
    and dropped frames (where rendering a frame takes longer than the refresh rate)
    took a back seat to high-fidelity AAA rendering capabilities. VR needs to render
    each frame in time and do it twice: once for each eye. Driven by the requirements
    of this emerging industry, semiconductor and hardware manufacturers are building
    new and improved devices, which will inevitably impact how content developers
    think about optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: That said, most likely you should develop and optimize for the lower specs that
    you want to target. If such optimizations necessitate undesirable compromises,
    consider separate versions of the game for high- versus low-end platforms. VR
    device manufacturers have started publishing minimum/recommended hardware specifications,
    which take much of the guesswork out of it. Start with the recommended Unity settings
    of your target device and adjust as needed.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, for mobile VR, it is recommended that you tune for CPU-bound rather
    than GPU-bound usage. Some games will make the CPU work harder, others will impact
    the GPU. Normally, you should favor CPU over GPU. The Oculus Mobile SDK (GearVR)
    has an API that is used to throttle the CPU and GPU to control heat and battery
    drain.
  prefs: []
  type: TYPE_NORMAL
- en: Running in the editor is not the same as running on a mobile device. But, you
    can still use the Profiler while running in the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be useful to have a developer mode in your app that shows a heads up
    display (HUD) with current **frames per second** (**FPS**) and other vital statistics
    at runtime. To make your how FPS HUD display, add a UI Canvas to your scene with
    a child Text object. The following script updates the text string with the FPS
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Some VR devices also provide their own tools, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Daydream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Daydream developer options include the `GvrInstalPreviewMain` prefab that lets
    you use your Daydream device with the Unity Editor Play mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Daydream Performance HUD* ([https://developers.google.com/vr/develop/unity/perfhud](https://developers.google.com/vr/develop/unity/perfhud))
    is built into Android. To enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Daydream application on your phone
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the gear icon on the top right of the screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tab Build Version six times to make the Developer Options item appear
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Developer Options | Enable performance heads-up display
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, run a VR app and you will see the performance overlay.
  prefs: []
  type: TYPE_NORMAL
- en: Oculus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oculus offers a suite of performance analysis and optimization tools ([https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/)),
    which includes extensive documentation and a workflow guide for developers. Good
    stuff! It also includes an Oculus Debug Tool, Lost Frame Capture Tool, Performance
    Profiler, and a Performance Head-Up Display ([https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the Performance Head-Up Display, you run it from the Oculus Debug
    Tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Program Files\Oculus\Support\oculus-diagnostics\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click `OculusDebugTool.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They recommend you first turn off Asynchronous Spacewarp (ASW) to get a good
    sense of your app's performance without ASW. Find Asynchronous Spacewarp and choose
    Disabled from the select list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find Visible HUD and choose the type you''d like to see: Performance, Stereo
    Debug, Layer, or None.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Latency and low frames-per-second rates are not acceptable and can cause motion
    sickness in VR. We are bound by the capabilities and limitations of the hardware
    devices we run on and their SDKs. In this chapter, we dove into some of the more
    technical aspects of making great VR, considering four separate areas that affect
    performance: the artwork, the scene, the code, and the rendering pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We started the chapter by introducing the built-in Unity Profiler and Stats
    windows, our primary weapons in this battle. To illustrate the impacts of designing
    models and materials, we built a scene with 1000 high-poly Sunglasses with transparent
    lenses, examined the performance stats, and then tried several ways to improve
    the frame rate: decimating the models (making them low poly), removing transparency
    in the materials, and managing level of detail (LOD) in the scene. Then, we considered
    things we can do at the scene level, using static objects, baked lightmaps, and
    occlusion culling.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at basic practices for optimizing your C# scripts. A key to
    this is understanding the Unity life cycle, game loop, and expensive API functions,
    encouraging you to make the frame `Update` processing as lean as possible. Then,
    we looked at the rendering pipeline, gaining some insight into how it works and
    how to use recommended Quality, Graphics and Player settings, VR optimized shaders,
    and runtime tools to analyze and improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: It should be abundantly clear by now that developing for VR has many facets
    (pun intended). You work hard to create an awesome scene with beautiful models,
    textures, and lighting. You try to provide a thrilling interactive experience
    for your visitors. At the same time, you should also be thinking about the requirements
    of your target platform, rendering performance, frames per second, latency, and
    motion sickness. It's never too early to focus on performance. It's a mistake
    to start too late. Follow recommended best practices that are easy to implement,
    while keeping your code and object hierarchy clean and maintainable. However,
    take a thoughtful, scientific approach to troubleshooting and performance tuning,
    using the Profiler and other tools to analyze your project so you can zero in
    on the root causes rather than spend time on areas that may yield little net effect.
  prefs: []
  type: TYPE_NORMAL
- en: We developers rapidly become immune to all but the most obvious rendering errors,
    and as a result we are the worst people at testing our own code. It introduces
    a new and exciting variation of the coder's defense that "it works on my machine"
    - in this case, "it works for my brain." -Tom Forsyth, Oculus
  prefs: []
  type: TYPE_NORMAL
- en: Developing for VR is a moving target. The platform hardware, software SDKs,
    and the Unity 3D engine itself are all changing and improving rapidly. Books,
    blog posts, and YouTube videos can be readily superseded as products improve and
    new developer insights emerge. On the other hand, great strides have already been
    made to establish best practices, preferred Unity settings, and optimized device
    SDKs that address the needs of VR developers.
  prefs: []
  type: TYPE_NORMAL
- en: As VR goes mainstream, it is coming into its own as a new medium for expression,
    communication, education, problem solving, and storytelling. Your grandparents
    needed to learn to type and read. Your parents needed to learn PowerPoint and
    browse the web. Your children will build castles and teleport between virtual
    spaces. VR will not replace the real world and our humanity; it will enhance it.
  prefs: []
  type: TYPE_NORMAL
