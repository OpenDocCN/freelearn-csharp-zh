- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Minimal APIs – Creating REST Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小API – 创建REST服务
- en: Since .NET 6, minimal APIs are the new way to create REST APIs. With later .NET
    versions, more and more enhancements have been made available, which makes them
    the preferred way to create REST services with .NET.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET 6以来，最小API是创建REST API的新方法。随着.NET版本的更新，越来越多的增强功能被提供，这使得它们成为使用.NET创建REST服务的首选方式。
- en: In this chapter, you’ll learn how to create a data representation of the game
    with model types, use these types in a service to implement the game functionality,
    create a minimal API project to create games, update games by setting game moves,
    and return information about games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用模型类型创建游戏的数据表示，在服务中使用这些类型来实现游戏功能，创建一个最小API项目来创建游戏，通过设置游戏移动来更新游戏，并返回有关游戏的信息。
- en: You’ll implement functionality to offer an OpenAPI description for developers
    accessing the service to get information about the service, and an easy way to
    create a client application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将实现提供OpenAPI描述的功能，以便开发人员访问服务以获取有关服务的信息，并创建客户端应用程序的简单方法。
- en: 'In this chapter, you’ll be exploring these topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索以下主题：
- en: Creating models for the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏模型
- en: Implementing an in-memory game repository
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现内存游戏库
- en: Implementing the REST service of the game using minimal APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小API实现游戏的REST服务
- en: Using OpenAPI to describe the service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenAPI描述服务
- en: Testing the service using HTTP files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP文件测试服务
- en: Enabling .NET Aspire
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用.NET Aspire
- en: By the end of this chapter, you’ll have a running service implementing the Codebreaker
    Games API with an in-memory games store, accessible using HTTP requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个运行中的服务，该服务实现了Codebreaker游戏API，并具有内存游戏存储，可以通过HTTP请求访问。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).
    The `ch02` source code folder contains the code samples for this chapter. You’ll
    find the code for the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub存储库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure)。`ch02`源代码文件夹包含本章的代码示例。你将找到以下代码：
- en: '`Codebreaker.GamesAPIs` – The Web API project'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GamesAPIs` – Web API项目'
- en: '`Codebreaker.GamesAPIs.Models` – A library for the data models'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GamesAPIs.Models` – 数据模型库'
- en: '`Codebreaker.GameAPIs.Analyzers` – A library containing game move analyzers
    for the game'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs.Analyzers` – 包含游戏移动分析器的库'
- en: '`Codebreaker.GamesAPIs.Analyzers.Tests` – Unit tests for the game move analyzers'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GamesAPIs.Analyzers.Tests` – 游戏移动分析器的单元测试'
- en: '`Codebreaker.AppHost` – The host project for .NET Aspire'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost` – .NET Aspire的主项目'
- en: '`Codebreaker.ServiceDefaults` – A library used by the .NET Aspire configuration'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ServiceDefaults` – 由.NET Aspire配置使用的库'
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t implement the game move analyzers of the game in this chapter. The
    `Analyzers` project is just for reference purposes, but you can simply use a NuGet
    package for the analyzers (`CNinnovation.Codebreaker.Analyzers`) that has been
    made available for you to build the service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中不实现游戏移动分析器。`Analyzers`项目仅作参考，但你可以直接使用为你提供的分析器NuGet包（`CNinnovation.Codebreaker.Analyzers`）来构建服务。
- en: For the installation of Visual Studio, Visual Studio Code, and .NET Aspire,
    check the README file for this chapter in the repository.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Visual Studio、Visual Studio Code和.NET Aspire的安装，请检查存储库中本章的README文件。
- en: The game models
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏模型
- en: Before creating the REST API project, we start with a library that contains
    the models to represent the game along with a move of the game. This model will
    contain the main data part of the Codebreaker Game API service solution, which
    will be used to read and write to the database (in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063)),
    while the model also serves as an implementation of the main functionality of
    the game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建REST API项目之前，我们从一个包含游戏及其移动的模型的库开始。此模型将包含Codebreaker游戏API服务解决方案的主要数据部分，该部分将用于读取和写入数据库（在[*第3章*](B21217_03.xhtml#_idTextAnchor063)），同时该模型也作为游戏主要功能的实现。
- en: The major types in a simplified version are shown in *Figure 2**.1*. The `Game`
    class implements the `IGame` interface. The `IGame` interface is used by the `Analyzers`
    package. A game contains a list of moves. A single game move is represented by
    the `Move` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简化版本中的主要类型如图 *图 2.1* 所示。`Game` 类实现了 `IGame` 接口。`IGame` 接口由 `Analyzers` 包使用。一个游戏包含一系列移动。单个游戏移动由
    `Move` 类表示。
- en: '![Figure 2.1 – The game model](img/B21217_02_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 游戏模型](img/B21217_02_01.jpg)'
- en: Figure 2.1 – The game model
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 游戏模型
- en: Exploring the game analyzers library
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索游戏分析器库
- en: 'As the focus of this book is not implementing the game rules with .NET, you
    can use the existing project, `Codebreaker.GameAPIs.Analyzers`, or just reference
    the NuGet package that has been made available on the NuGet server. This library
    contains game move analyzers for these game types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点不是使用 .NET 实现游戏规则，您可以使用现有的项目 `Codebreaker.GameAPIs.Analyzers`，或者直接引用已发布在
    NuGet 服务器上的 NuGet 包。此库包含以下游戏类型的游戏移动分析器：
- en: '`Game6x4` – Six colors with four codes to guess'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game6x4` – 六种颜色和四种代码来猜测'
- en: '`Game8x5` – Eight colors with five codes'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game8x5` – 八种颜色和五种代码'
- en: '`Game6x4Mini` – Six colors with four codes with a *small* *children* mode'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game6x4Mini` – 六种颜色和四种代码，带有 *小型* *儿童* 模式'
- en: '`Game5x5x4` – Five colors and five shapes with four codes'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game5x5x4` – 五种颜色和五种形状，四种代码'
- en: The analyzers work using the generic `IGame` interface, which you need to implement
    with the game models library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器通过通用的 `IGame` 接口工作，您需要使用游戏模型库来实现它。
- en: 'The `IGame` interface specifies some common functionalities for the `Codebreaker`
    games, as you can see in the following code snippet. Check the repository for
    the complete interface definition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGame` 接口指定了 `Codebreaker` 游戏的一些常见功能，如下面的代码片段所示。请检查存储库以获取完整的接口定义：'
- en: Codebreaker.GameAPIs.Analyzers/Contracts/IGame.cs
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers/Contracts/IGame.cs
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `IGame` interface defines game members used by the analyzers, such as the
    number of codes that must be set and the maximum number of moves allowed, which
    are used by the analyzer to verify correct input data. The `FieldValues` property
    of the `IDictionary<string, IEnumerable<string>>` type defines the possible values
    to select from. With the color game types, this will be a list of colors. With
    the shape game type, this will be a list of colors and a list of shapes. The `Codes`
    property contains an array of strings. How the string looks is different based
    on the game type. The string array contains the correct solution for a game run.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGame` 接口定义了分析器使用的游戏成员，例如必须设置的代码数量和允许的最大移动次数，这些由分析器用于验证正确的输入数据。`IDictionary<string,
    IEnumerable<string>>` 类型的 `FieldValues` 属性定义了可从中选择的可能值。对于颜色游戏类型，这将是一个颜色列表。对于形状游戏类型，这将是一个颜色列表和一个形状列表。`Codes`
    属性包含一个字符串数组。字符串的样式取决于游戏类型。字符串数组包含游戏运行的正确解决方案。'
- en: The `analyzers` library also contains record types that are supported by the
    analyzers implementation that you can use for the generic parameters of your game
    types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`analyzers` 库还包含分析器实现支持的记录类型，您可以用作游戏类型的泛型参数。'
- en: 'One example of such a type used for the generic parameters is `ColorField`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于泛型参数的此类类型的示例 `ColorField`：
- en: Codebreaker.GameAPIs.Analyzers/Fields/ColorField.cs
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers/Fields/ColorField.cs
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ColorField` record class just contains a `color` string. This field type
    is used with all game types with the exception of the `Game5x5x4` game type, which
    uses the `ShapeAndColorField` record.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorField` 记录类仅包含一个 `color` 字符串。此字段类型与所有游戏类型一起使用，除了 `Game5x5x4` 游戏类型，它使用
    `ShapeAndColorField` 记录。'
- en: 'To specify the results of a game move, three different types are available:
    `ColorResult`, `SimpleColorResult`, and `ShapeAndColorResult`. `SimpleColorResult`
    adds information for small children (which position has a correct color), whereas
    the `ColorResult` record struct just contains information on the number of colors
    placed in a correct hole, and the number of colors placed in an incorrect hole.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定游戏移动的结果，有三种不同类型可供选择：`ColorResult`、`SimpleColorResult` 和 `ShapeAndColorResult`。`SimpleColorResult`
    为幼儿提供信息（哪个位置有正确的颜色），而 `ColorResult` 记录结构仅包含有关放置在正确孔中的颜色数量和放置在错误孔中的颜色数量的信息。
- en: 'The following code snippet shows the `ColorResult` record struct:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了 `ColorResult` 记录结构：
- en: Codebreaker.GameAPIs.Analyzers/Results/ColorResult.cs
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Analyzers/Results/ColorResult.cs
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This record is implemented partially, separating parts of the implementation
    to simplify the source code. The other parts are defined in other source files
    and implement the `IParsable` and `IFormattable` interfaces. The `const` member
    called `Separator` is used with the other parts of the `ColorResult` type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此记录部分实现，将实现的部分分离以简化源代码。其他部分定义在其他源文件中，并实现了`IParsable`和`IFormattable`接口。名为`Separator`的`const`成员与`ColorResult`类型的其他部分一起使用。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ColorField`, `ColorResult`, and the other classes representing a field and
    results are just used to analyze moves and return results. The `Game` and `Move`
    classes that you’ll implement in this chapter are just data holders and don’t
    contain any logic. The field guesses and results are all represented using strings,
    which makes them flexible for every game type available and easier to use with
    JSON serialization and database access. Converting the specific field and result
    types to and from strings is done using the `IParsable`, `ISpanParsable`, and
    `IFormattable` interfaces. The parsable interfaces are new since .NET 7 and are
    based on a C# 11 feature that allows static members with interfaces. These types
    are important in case you want to create your own game types and game analyzers.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorField`、`ColorResult`以及其他表示字段和结果的类仅用于分析移动并返回结果。您在本章中将要实现的`Game`和`Move`类只是数据持有者，不包含任何逻辑。字段猜测和结果都使用字符串表示，这使得它们适用于每种游戏类型，并且更容易与JSON序列化和数据库访问一起使用。将特定字段和结果类型转换为字符串以及从字符串转换的操作是通过使用`IParsable`、`ISpanParsable`和`IFormattable`接口完成的。可解析接口自.NET
    7以来是新的，并基于C# 11的一个功能，该功能允许具有接口的静态成员。如果您想创建自己的游戏类型和游戏分析器，这些类型很重要。'
- en: You can read the article at [https://csharp.christiannagel.com/2023/04/14/iparsable/](https://csharp.christiannagel.com/2023/04/14/iparsable/)
    for more information about parsable interfaces.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读[https://csharp.christiannagel.com/2023/04/14/iparsable/](https://csharp.christiannagel.com/2023/04/14/iparsable/)上的文章，了解更多关于可解析接口的信息。
- en: Exploring game analyzers
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索游戏分析器
- en: The implementation of the game analyzers is done within the `GameGuessAnalyzer`
    base class and the `ColorGameGuessAnalyzer`, `SimpleGameGuessAnalyzer`, and `ShapeGameGuessAnalyzer`
    derived classes. The implementation of these analyzers is disconnected from the
    game model types. All these analyzers implement the `GetResult` method specified
    with the `IGameGuessAnalyzer<Tresult>` interface. After creating an instance of
    the analyzer passing the game, the guesses, and the move number, just the `GetResult`
    method needs to be invoked to calculate the result of the move.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏分析器的实现是在`GameGuessAnalyzer`基类和`ColorGameGuessAnalyzer`、`SimpleGameGuessAnalyzer`和`ShapeGameGuessAnalyzer`派生类中完成的。这些分析器的实现与游戏模型类型无关。所有这些分析器都实现了由`IGameGuessAnalyzer<Tresult>`接口指定的`GetResult`方法。在创建分析器实例并传递游戏、猜测和移动编号后，只需调用`GetResult`方法即可计算移动的结果。
- en: If you are interested in checking the analyzers, dive into the `Codebreaker.GameAPIs.Analyzers`
    project within the book’s source code repository. Working through the following
    steps, instead of referencing this project, you can add the `CNinnovation.Codebreaker.Analyzers`
    NuGet package. Just make sure to use the latest 3.x version of this package, as
    4.x and newer versions might contain breaking changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对检查分析器感兴趣，请深入到书中源代码仓库中的`Codebreaker.GameAPIs.Analyzers`项目。通过以下步骤操作，而不是引用此项目，您可以添加`CNinnovation.Codebreaker.Analyzers`
    NuGet包。只需确保使用此包的最新3.x版本，因为4.x及更高版本可能包含破坏性更改。
- en: If you choose to, you can create an analyzer on your own and also add more game
    types. Make sure to read the information on the game rules in [*Chapter 1*](B21217_01.xhtml#_idTextAnchor014).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择这样做，您可以自己创建一个分析器，并添加更多游戏类型。请确保阅读关于游戏规则的[*第一章*](B21217_01.xhtml#_idTextAnchor014)中的信息。
- en: Creating a .NET library
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建.NET库
- en: The model types are added to the `Codebreaker.GameAPIs.Models` .NET library.
    Having a library allows the creation of different data access libraries (in [*Chapter
    3*](B21217_03.xhtml#_idTextAnchor063)) to offer a flexible data store choice for
    hosting the service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类型被添加到`.NET library Codebreaker.GameAPIs.Models`。拥有一个库允许创建不同的数据访问库（在[*第三章*](B21217_03.xhtml#_idTextAnchor063)中），为托管服务提供灵活的数据存储选择。
- en: 'You can use the .NET CLI as shown to create the class library, or use Visual
    Studio to create a class library:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用如上所示的.NET CLI创建类库，或者使用Visual Studio创建类库：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Implementing classes for the model types
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模型类型的类
- en: 'The `Game` class holding all the data needed by a game is shown here (check
    the GitHub repository for the complete implementation):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了包含游戏所需所有数据的 `Game` 类（完整的实现请查看 GitHub 仓库）：
- en: Codebreaker.GameAPIs.Models/Game.cs
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Models/Game.cs
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class implements the `IGame` interface to support the analyzer to check
    the correctness of a move and to set some game state. In addition to the members
    of the interface, the `Game` class also contains a collection of `Move` objects.
    Primary constructor syntax is used to reduce the number of needed code lines.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此类实现了 `IGame` 接口，以支持分析器检查走法的正确性并设置一些游戏状态。除了接口的成员外，`Game` 类还包含一个 `Move` 对象的集合。使用主要构造函数语法来减少所需的代码行数。
- en: Primary constructors
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数
- en: Several classes created in this book make use of primary constructors. Primary
    constructors have been in use with records since C# 9\. With C# 12, primary constructors
    can be used with normal classes and structs. However, while primary constructors
    with records create properties, with classes, these are just parameters. The parameters
    can be assigned to fields and properties, or just be used within members.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本书创建的几个类都使用了主要构造函数。自 C# 9 以来，主要构造函数一直用于记录。在 C# 12 中，主要构造函数可以用于普通类和结构体。然而，虽然记录中的主要构造函数创建属性，而在类中，这些只是参数。这些参数可以分配给字段和属性，或者仅用于成员内。
- en: 'The `Move` class is simpler as it just represents the move of a player within
    a game along with its result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move` 类比较简单，因为它只代表游戏中的玩家走法及其结果：'
- en: Codebreaker.GameAPIs.Models/Move.cs
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Models/Move.cs
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Move` class contains string arrays for the guesses (`GuessPegs`) and the
    results (`KeyPegs`). String arrays can be used for every game type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move` 类包含用于猜测（`GuessPegs`）和结果（`KeyPegs`）的字符串数组。字符串数组可以用于每种游戏类型。'
- en: Defining the game repository contract
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义游戏存储库合约
- en: 'To be independent of the data store, the `IGamesRepository` interface defines
    all the members needed from a data store when playing a game. The `AddGameAsync`
    method is invoked when a new game is started. Setting a move, the game needs to
    be updated invoking the `UpdateGameAsync` method. The `GetGameAsync` and `GetGamesAsync`
    methods are specified by the interface to retrieve games:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了独立于数据存储，`IGamesRepository` 接口定义了在玩游戏时从数据存储中需要的所有成员。当开始新游戏时，将调用 `AddGameAsync`
    方法。设置走法时，需要通过调用 `UpdateGameAsync` 方法来更新游戏。接口指定了 `GetGameAsync` 和 `GetGamesAsync`
    方法来检索游戏：
- en: Codebreaker.GameAPIs.Models/Data/IGamesRepository.cs
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Models/Data/IGamesRepository.cs
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This interface specifies asynchronous methods. This wouldn’t be required with
    the implementation in this chapter. The next chapter will add asynchronous implementations,
    thus the contract should be ready for this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口指定了异步方法。在本章的实现中不需要这些方法。下一章将添加异步实现，因此合约应该为此做好准备。
- en: Specifying asynchronous methods, it’s a good practice to allow passing a `CancellationToken`.
    This allows canceling long-running operations even across network boundaries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定异步方法时，允许传递 `CancellationToken` 是一种良好的做法。这允许在网络边界之外取消长时间运行的操作。
- en: The `IGamesRepository` interface is specified in the `Codebreaker.GameAPIs.Models`
    library. This makes it possible to reference this interface from all the data
    store libraries that will be implemented later on. In this chapter, just an in-memory
    collection will be implemented as part of the next step.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGamesRepository` 接口在 `Codebreaker.GameAPIs.Models` 库中定义。这使得可以从稍后将要实现的所有数据存储库中引用此接口。在本章中，将只实现一个内存中的集合作为下一步的一部分。'
- en: The minimal APIs project
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小 API 项目
- en: After having the models and the repository contract in place, we can move over
    to creating the project hosting the REST API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了模型和存储库合约之后，我们可以转向创建托管 REST API 的项目。
- en: 'Here, we’ll use ASP.NET Core with minimal APIs to create a REST API, and store
    games and moves in an in-memory repository. To create the running games API, we
    need to do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 ASP.NET Core 和最小 API 创建 REST API，并在内存存储库中存储游戏和走法。为了创建运行中的游戏 API，我们需要执行以下操作：
- en: Create a Web API project.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Web API 项目。
- en: Implement the games repository.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现游戏存储库。
- en: Create a games factory.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建游戏工厂。
- en: Create data transfer objects.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据传输对象。
- en: Create endpoints to run the game via HTTP requests.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建端点以通过 HTTP 请求运行游戏。
- en: Configure the JSON serializer.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 JSON 序列化器。
- en: Add endpoint filters.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加端点过滤器。
- en: To better understand how the different classes interact in creating the game
    and setting a move, the flow of the functionality we need to implement is shown
    in the next two figures.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解不同的类在创建游戏和设置移动时的交互，我们需要实现的功能流程在接下来的两个图中展示。
- en: '*Figure 2**.2* shows the sequence when a new game is created. On invoking the
    API call, `GamesService` is invoked to start the game. This service class uses
    `GamesFactory` to create a new game based on the parameters received and returns
    random code values. For persistence, `GameMemoryRepository` is invoked from `GamesService`
    to add the game before the game is returned.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.2* 展示了创建新游戏的序列。在调用 API 调用后，`GamesService` 被调用以启动游戏。这个服务类使用 `GamesFactory`
    根据接收到的参数创建一个新的游戏，并返回随机的代码值。为了持久化，`GamesService` 从 `GamesService` 调用 `GameMemoryRepository`
    在返回游戏之前添加游戏。'
- en: '![Figure 2.2 – Creating a game](img/B21217_02_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 创建游戏](img/B21217_02_02.jpg)'
- en: Figure 2.2 – Creating a game
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 创建游戏
- en: '*Figure 2**.3* shows the sequence when a game move is set. Because the client
    does not have the complete state of the game, `GamesService` retrieves the game
    from the repository. Then, `GamesFactory` is used again to select an analyzer
    based on the game type, and the analyzer is invoked to find the results of the
    game move. After the results are available with `GamesService`, the game is updated
    with the new move, and the results are returned to the game endpoint.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.3* 展示了设置游戏移动的序列。因为客户端没有游戏完整的状态，`GamesService` 从存储库中检索游戏。然后，`GamesFactory`
    再次使用以根据游戏类型选择分析器，并调用分析器以找到游戏移动的结果。在 `GamesService` 可用结果后，游戏使用新的移动进行更新，并将结果返回到游戏端点。'
- en: '![Figure 2.3 – Setting a game move](img/B21217_02_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 设置游戏移动](img/B21217_02_03.jpg)'
- en: Figure 2.3 – Setting a game move
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 设置游戏移动
- en: Let’s implement this functionality with the API.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 API 实现这个功能。
- en: Creating the Web API project
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Web API 项目
- en: 'To create the Web API project, you can use the .NET CLI as shown or use the
    Web API project template from Visual Studio:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Web API 项目，你可以使用如下的 .NET CLI 或使用 Visual Studio 中的 Web API 项目模板：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `--``use-minimal-apis` option is used to create minimal APIs instead of
    the traditional controllers. Because the API will be hosted behind an Ingress
    server, the Ingress server will offer HTTPS, while HTTP is okay in the backend.
    To allow but not require HTTPS remove the codeline `app.UseHttpsRedirection();`
    from the code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--use-minimal-apis` 选项创建最小 API 而不是传统的控制器。因为 API 将托管在 Ingress 服务器后面，Ingress
    服务器将提供 HTTPS，而后端可以使用 HTTP。为了允许但不要求 HTTPS，从代码中删除 `app.UseHttpsRedirection();` 这行代码。
- en: Exploring WebApplicationBuilder and WebApplication
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 WebApplicationBuilder 和 WebApplication
- en: With the created project, `Program.cs` is created and contains the configuration
    for the dependency injection container with the `WebApplicationBuilder` class
    and the configuration of middleware with the `WebApplication` class. The project
    template creates a random weather service. However, as weather information is
    not needed with the games service, some of the created code can be removed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用创建的项目，`Program.cs` 被创建并包含使用 `WebApplicationBuilder` 类配置依赖注入容器的配置，以及使用 `WebApplication`
    类配置中间件的配置。项目模板创建了一个随机天气服务。然而，由于游戏服务不需要天气信息，一些创建的代码可以被删除。
- en: 'The part of the code that remains is shown in the next code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一代码片段显示了剩余的代码部分：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`WebApplication.CreateBuilder` returns `WebApplicationBuilder` and configures
    the dependency injection container, the default configuration, and default logging.
    The `AddEndpointsApiExplorer` and `AddSwaggerGen` methods add services to the
    dependency injection container. The services registered by these two methods are
    needed for the `OpenAPI` description of the services.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplication.CreateBuilder` 返回 `WebApplicationBuilder` 并配置依赖注入容器、默认配置和默认日志。`AddEndpointsApiExplorer`
    和 `AddSwaggerGen` 方法向依赖注入容器添加服务。这两个方法注册的服务对于服务的 `OpenAPI` 描述是必需的。'
- en: Invoking the `Build` method returns a `WebApplication` instance. This instance
    is then used to configure the middleware. Middleware is invoked with every request
    to the service. The `UseSwagger` method registers the Swagger middleware to create
    an `OpenAPI` description of the service. The `UseSwaggerUI` method registers the
    `SwaggerUI` middleware to show a web page where the API is described and can be
    tested. As an API is not yet implemented, a description will not be generated
    yet.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Build`方法返回一个`WebApplication`实例。然后使用此实例来配置中间件。中间件在服务对每个请求进行调用时被调用。`UseSwagger`方法注册Swagger中间件以创建服务的`OpenAPI`描述。`UseSwaggerUI`方法注册`SwaggerUI`中间件以显示一个网页，其中描述了API并可对其进行测试。由于API尚未实现，因此尚不会生成描述。
- en: What is the relationship between Swagger and OpenAPI?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger和OpenAPI之间的关系是什么？
- en: The Swagger specification was created to describe HTTP APIs. In 2015, SmartBear
    Software acquired the Swagger API specification and started to form a new organization
    in 2016 together with Google, IBM, Microsoft, PayPal, and others under the sponsorship
    of the Linux Foundation – the **OpenAPI Initiative**. New versions of this specification
    are defined with OpenAPI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger规范是为了描述HTTP API而创建的。2015年，SmartBear Software收购了Swagger API规范，并在2016年与Google、IBM、Microsoft、PayPal和其他公司一起在Linux基金会的赞助下成立了新的组织——**OpenAPI倡议**。此规范的最新版本使用OpenAPI定义。
- en: The `SwaggerXX` method names originate from the original specification and haven’t
    been changed since. These methods are defined within the `Swashbuckle.AspNetCore`
    NuGet package that’s referenced with the Web API project template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwaggerXX`方法名称源自原始规范，并且自那时起没有更改。这些方法在`Swashbuckle.AspNetCore` NuGet包中定义，该包与Web
    API项目模板一起引用。'
- en: Implementing the repository
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现存储库
- en: 'In the earlier *Defining the game repository contract* section, we created
    the `IGamesRepository` interface to specify the methods that need to be implemented
    by every data store used with the Games API. We can implement this contract now.
    The `GamesMemoryRepository` class implements the `IGamesRepository` interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早的*定义游戏存储库合约*部分中，我们创建了`IGamesRepository`接口来指定需要由与游戏API一起使用的每个数据存储实现的方法。我们现在可以实施此合约。`GamesMemoryRepository`类实现了`IGamesRepository`接口：
- en: Codebreaker.GameAPIs/Data/GamesMemoryRepository.cs
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Data/GamesMemoryRepository.cs
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the implementation, the `ConcurrentDictionary` class is used for a thread-safe
    collection when multiple clients access the service concurrently. With the implemented
    `AddGameAsync`, `GetGameAsync`, and similar methods, games are added, updated,
    and removed from the dictionary. Here, all the games are just kept in memory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施过程中，当多个客户端并发访问服务时，使用`ConcurrentDictionary`类来创建线程安全的集合。通过实现的`AddGameAsync`、`GetGameAsync`和类似方法，游戏可以从字典中添加、更新和删除。在这里，所有游戏都仅保存在内存中。
- en: Persistent state and multiple server instances
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 持久状态和多个服务器实例
- en: This chapter’s implementation of the repository does not persist the state and
    also does not allow multiple server instances to run, as the state is only stored
    within the memory of the process. In the next chapter, other implementations of
    this interface will be used to store the games in a database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章实现的存储库不持久化状态，也不允许多个服务器实例运行，因为状态仅存储在进程的内存中。在下一章中，将使用此接口的其他实现来将游戏存储在数据库中。
- en: Creating game objects initialized with random values
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建使用随机值初始化的游戏对象
- en: 'The `GamesFactory` class creates games with random values. The following code
    snippet shows creating a game with six colors and four holes; you can extend this
    to other game types as well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesFactory`类使用随机值创建游戏。以下代码片段显示了创建一个具有六种颜色和四个孔的游戏；您可以将此扩展到其他游戏类型：'
- en: Codebreaker.GameAPIs/Services/GamesFactory.cs
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesFactory.cs
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the code, pattern matching is used. For every game type, a local function
    such as `Create6x4Game` is defined, which specifies the available colors or shapes,
    the random code, and the maximum number of moves.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，使用了模式匹配。对于每种游戏类型，定义了一个局部函数，例如`Create6x4Game`，它指定了可用的颜色或形状、随机代码和最大移动次数。
- en: Creating data transfer objects
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据传输对象
- en: '`BookData` class to write information to the database and a `BookDTO` class
    for communication, implementing the same properties. With such a design in place,
    a change to the book would result in changing `BookData` and `BookDTO`, as well
    as the implementation to transform these objects. Using the same `Book` class
    with every of these scenarios reduces the programming effort, and also reduces
    the memory and CPU usage during runtime.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookData`类用于将信息写入数据库，以及一个`BookDTO`类用于通信，实现相同的属性。采用这种设计，对书籍的更改会导致`BookData`和`BookDTO`以及转换这些对象的实现发生变化。在每个场景中使用相同的`Book`类可以减少编程工作量，并且在运行时也可以减少内存和CPU的使用。'
- en: A reason to use different types for data access and communication is the requirements
    for the data mapping to the database and the requirements of the serializer used
    with communication. Nowadays, both EF Core and the `System.Text.Json` serializer
    support constructors with parameters, which might fill the requirements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同类型进行数据访问和通信的原因是数据映射到数据库的要求以及与通信一起使用的序列化器的需求。如今，EF Core和`System.Text.Json`序列化器都支持带有参数的构造函数，这可能满足这些需求。
- en: If there are other requirements, DTOs can become important. With the games API,
    different data should be used with the communication than used internally with
    the service. In creating a game, not all the data for the game is coming from
    the client. Much of this data, such as the list of available fields as well as
    the code, is generated on the server. When sending a move from the client to the
    server, a game gets updated on the server, but there’s only a subset of a move
    needed that’s sent from the client to the server. When returning information from
    the server to the client, again, only a subset of data is required. This makes
    creating DTOs important.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有其他需求，DTOs变得很重要。在使用游戏API时，与内部服务相比，通信应使用不同的数据。在创建游戏时，并非所有游戏数据都来自客户端。其中大部分数据，如可用的字段列表以及代码，都是在服务器上生成的。当客户端向服务器发送移动时，服务器上的游戏会更新，但只需要发送从客户端到服务器的一个移动子集。当从服务器向客户端返回信息时，同样，只需要所需的数据子集。这使得创建DTOs变得重要。
- en: 'With the games API, to start a new game, we implement the `CreateGameRequest`
    and `CreateGameResponse` class record types:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游戏API，要开始新游戏，我们实现`CreateGameRequest`和`CreateGameResponse`类记录类型：
- en: Codebreaker.GameAPIs/Models/GameAPIModels.cs
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Models/GameAPIModels.cs
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In creating a game, the client just needs to send the game type and the player’s
    name. This is all that’s needed from the client. In the backend, just a string
    is used for the game type. Using a string allows for easy enhancements of other
    game types. The API using an `enum` type allows showing the available game types
    with the OpenAPI description, as you’ll see in the section about OpenAPI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建游戏时，客户端只需要发送游戏类型和玩家姓名。这就是客户端需要提供的一切。在后台，仅使用字符串表示游戏类型。使用字符串可以轻松地增强其他游戏类型。使用`enum`类型的API可以显示可用的游戏类型，正如您将在关于OpenAPI的部分中看到的那样。
- en: After the game is created, the client just needs to have the identifier of the
    game. For convenience, the game type and player name are also returned. The client
    should also know the possible fields that can be selected. This is specified by
    the `FieldValues` dictionary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏创建后，客户端只需要拥有游戏的标识符。为了方便，游戏类型和玩家姓名也会返回。客户端还应了解可以选定的可能字段。这由`FieldValues`字典指定。
- en: 'To set a game move, we implement the `UpdateGameRequest` and `UpdateGameResponse`
    class record types:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置游戏移动，我们实现`UpdateGameRequest`和`UpdateGameResponse`类记录类型：
- en: Codebreaker.GameAPIs/Models/GameAPIModels.cs
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Models/GameAPIModels.cs
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When sending a move, the client needs to send the list of guess pegs. With the
    API service, guess pegs and key pegs are represented with strings, such as the
    `GuessPegs` property. This makes it independent of any game type. With the analyzers,
    different types for every game type are implemented. The `IParsable` interface
    is used to convert string values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送移动时，客户端需要发送猜测珠子的列表。使用API服务，猜测珠子和关键珠子用字符串表示，例如`GuessPegs`属性。这使得它与任何游戏类型无关。在分析器中，为每种游戏类型实现不同的类型。使用`IParsable`接口将字符串值转换为其他类型。
- en: Implementing the games service
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现游戏服务
- en: 'To simplify the implementation of the endpoints, we create the `GamesService`
    class, which will be injected into the endpoints:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化端点的实现，我们创建`GamesService`类，该类将被注入到端点中：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`StartGameAsync` just invokes the `AddGameAsync` method with `IGamesRepository`.
    Such a simple implementation is the case with many other methods of `GamesService`.
    This will change in the next chapter when data will be cached in memory before
    accessing the database. When using the in-memory repository, this is not necessary.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartGameAsync`只是调用带有`IGamesRepository`的`AddGameAsync`方法。这种简单的实现是`GamesService`的许多其他方法的典型情况。在下一章中，当数据在访问数据库之前在内存中缓存时，这将发生变化。当使用内存存储库时，这并不是必需的。'
- en: 'Implementing `SetMoveAsync` is more complex, as here we have to decide to use
    one of the game analyzers to calculate the game. For the game type selection and
    the calculation, the `ApplyMove` method is defined as an extension method for
    the `Game` type within the `GamesFactory` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`SetMoveAsync`更为复杂，因为在这里我们必须决定使用其中一个游戏分析器来计算游戏。对于游戏类型选择和计算，`ApplyMove`方法在`GamesFactory`类内部被定义为`Game`类型的扩展方法：
- en: Codebreaker.GameAPIs/Services/GamesFactory.cs
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesFactory.cs
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The implementation of this method uses pattern matching with the `switch` expression
    to invoke the correct analyzer class to get the result of the game move.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法实现使用`switch`表达式进行模式匹配，以调用正确的分析器类来获取游戏移动的结果。
- en: 'Having this `Game` extension method in place let’s us switch back to the implementation
    of the `SetMoveAsync` method of the `GamesService` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个`Game`扩展方法，我们可以切换回`GamesService`类的`SetMoveAsync`方法的实现：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SetMoveAsync` method retrieves the game from the repository before invoking
    the `ApplyMove` method to do the calculation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMoveAsync`方法在调用`ApplyMove`方法进行计算之前，会从存储库中检索游戏。'
- en: Converting transfer objects to and from the object model
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在传输对象和对象模型之间进行转换
- en: 'In receiving a `CreateGameRequest` to create a new game, there’s no need for
    a conversion. The members of `CreateGameRequest` can directly be used when using
    `GamesService`. We need to create a conversion from a `Game` type to `CreateGameResponse`.
    This is done as an extension method for the `Game` type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收创建新游戏的`CreateGameRequest`请求时，无需进行转换。`CreateGameRequest`的成员可以直接在`GamesService`中使用。我们需要创建一个从`Game`类型到`CreateGameResponse`类型的转换。这作为`Game`类型的扩展方法来完成：
- en: Codebreaker.GameAPIs/Extensions/ApiModelExtensions.cs
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Extensions/ApiModelExtensions.cs
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the implementation, the needed data from the `Game` type is transferred
    to the `CreateGameResponse` type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现，从`Game`类型所需的数据被传输到`CreateGameResponse`类型。
- en: Creating endpoints for the Games API service
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为游戏API服务创建端点
- en: 'Before creating the endpoints, the services we created need to be registered
    with the dependency injection container to inject them within the endpoint:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建端点之前，我们创建的服务需要注册到依赖注入容器中，以便在端点中注入它们：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`GamesMemoryRepository` was created to store game objects in memory. This is
    registered as a singleton for creating a single instance that’s injected into
    the endpoints. Games should be kept as long as the server keeps running. `GamesMemoryRepository`
    implements `IGamesRepository`. In the next chapter, an EF Core context will be
    created to implement the same interface, which will allow changing the `GamesService`
    class implements the `IGamesService` interface. This service class is registered
    scoped; thus one instance is created with every HTTP request.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesMemoryRepository`被创建来在内存中存储游戏对象。这被注册为单例，以创建一个实例，该实例被注入到端点。游戏应该保持与服务器运行的时间一样长。`GamesMemoryRepository`实现了`IGamesRepository`接口。在下一章中，将创建一个EF
    Core上下文来实现相同的接口，这将允许更改`GamesService`类实现`IGamesService`接口。此服务类是注册作用域的；因此，每次HTTP请求都会创建一个实例。'
- en: 'With the middleware, we invoke one extension method that defines all the games
    API endpoints:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间件，我们调用一个定义所有游戏API端点的扩展方法：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `MapGameEndpoints` method is an extension method for the `IEndpointRouteBuilder`
    interface and is implemented next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapGameEndpoints`方法是`IEndpointRouteBuilder`接口的扩展方法，接下来将实现它。'
- en: 'In creating a REST API, different HTTP verbs are used to read and write resources:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建REST API时，使用不同的HTTP动词来读取和写入资源：
- en: '`GET` – With an HTTP `GET` request, resources are returned from the service'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` – 使用HTTP `GET`请求，资源从服务返回'
- en: '`POST` – The HTTP `POST` request creates a new resource'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` – HTTP `POST`请求创建一个新的资源'
- en: '`PUT` – `PUT` is usually used to update a complete resource'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` – 通常使用`PUT`来更新一个完整的资源'
- en: '`PATCH` – With `PATCH`, a partial resource can be sent for an update'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH` – 使用 `PATCH`，可以发送部分资源进行更新'
- en: '`DELETE` – The HTTP `DELETE` request deletes a resource'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` – HTTP的 `DELETE` 请求用于删除资源'
- en: Creating games with HTTP POST
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用HTTP POST创建游戏
- en: 'Let’s start with the endpoint to create a new game by mapping an HTTP `POST`
    request:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从映射HTTP `POST` 请求来创建新端点开始：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the source code repository, you will find the `GameEndpoints.cs` and `GameEndPoints1.cs`
    files. The current state of the endpoints is in the `GameEndpoints1.cs` file,
    but this will be changed later on when OpenAPI information is added. The file
    that gets compiled as defined in the project file is `GameEndpoints.cs`. If you
    want to compile the project from the repository with the current version, change
    the settings of the C# file in the project file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码仓库中，你可以找到 `GameEndpoints.cs` 和 `GameEndPoints1.cs` 文件。当前端点的状态在 `GameEndpoints1.cs`
    文件中，但稍后当添加OpenAPI信息时，这将被更改。根据项目文件定义的文件是 `GameEndpoints.cs`。如果你想要从仓库中编译具有当前版本的项目的项目，请更改项目文件中C#文件的设置。
- en: The `MapGameEndpoints` method is – as previously mentioned – an extension method
    for the `IEndpointRouteBuilder` interface. The first method invoked is `MapGroup`
    to define common functionality for the endpoints, which, in turn, uses the returned
    group variable (a `RouteGroupBuilder` object). With this code, the common functionality
    is the `/games` URI, which will be prefixed. You can use this for common authorization
    needs or common logging, which will be shown in later chapters of this book. Common
    functionality for OpenAPI will be shown later in this chapter in the section on
    OpenAPI.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`MapGameEndpoints` 方法是 `IEndpointRouteBuilder` 接口的一个扩展方法。首先调用的是 `MapGroup`
    方法来定义端点共有的功能，该方法反过来使用返回的组变量（一个 `RouteGroupBuilder` 对象）。使用这段代码，共有功能是 `/games` URI，它将被添加前缀。你可以用这个来满足共同的授权需求或共同记录，这将在本书的后续章节中展示。OpenAPI的共有功能将在本章的OpenAPI部分中展示。
- en: The created group is used with the `MapPost` method. The `MapPost` method will
    be invoked on an HTTP `POST` request. Similarly, `MapGet`, `MapPut`, and `MapDelete`
    are available as well. All these methods offer two overloads, where the overload
    with a pattern and the `Delegate` parameter are used. The `Delegate` parameter
    allows passing a lambda expression with any parameters and any return types –
    this is what minimal APIs take advantage of.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的组与 `MapPost` 方法一起使用。`MapPost` 方法将在HTTP `POST` 请求上被调用。同样，`MapGet`、`MapPut`
    和 `MapDelete` 也是可用的。所有这些方法都提供两种重载，其中包含模式和 `Delegate` 参数的重载被使用。`Delegate` 参数允许传递任何参数和任何返回类型的lambda表达式
    – 这正是最小API所利用的。
- en: 'The parameter types specified with the `MapPost` method are listed here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MapPost` 方法指定的参数类型在此列出：
- en: '`CreateGameRequest` – This comes from the HTTP body.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateGameRequest` – 这个请求来自HTTP体。'
- en: '`IGamesService` – The value is injected from the DI container.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGamesService` – 该值从DI容器中注入。'
- en: '`HttpContext` and `CancellationToken` – These are special types bound with
    minimal APIs. Another special one is `ClaimsPrincipal`, which is used with authentication.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpContext` 和 `CancellationToken` – 这些是与最小API绑定在一起的特殊类型。另一个特殊类型是 `ClaimsPrincipal`，它与身份验证一起使用。'
- en: Other binding sources that can be used are route values, query strings, headers,
    and HTML form values. You can also add custom binding to map a route, query, or
    header binding to custom types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的其他绑定来源包括路由值、查询字符串、头部和HTML表单值。你还可以添加自定义绑定来映射路由、查询或头部绑定到自定义类型。
- en: You can add attributes such as `FromBody`, `FromRoute`, `FromServices`, and
    others, which can help with readability and also resolve issues if there’s a conflict.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加如 `FromBody`、`FromRoute`、`FromServices` 等属性，这些属性有助于提高可读性，并在存在冲突时解决问题。
- en: With the implementation of the lambda expression with the `MapPost` method,
    the injected `gameService` variable is used to start a game. Starting the game
    successfully, a `Game`-derived object is returned, which is converted to `CreateGameResponse`
    with the `ToCreateGameResponse` extension method. The method returns either `HTTP
    201 Created` on success, or `HTTP 400 Bad Request` using the `Results` factory
    class. `Results` offers methods to return the different HTTP status codes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `MapPost` 方法实现lambda表达式，注入的 `gameService` 变量被用来启动游戏。成功启动游戏后，返回一个由 `Game`
    派生的对象，该对象通过 `ToCreateGameResponse` 扩展方法转换为 `CreateGameResponse`。该方法在成功时返回 `HTTP
    201 Created`，或者在失败时使用 `Results` 工厂类返回 `HTTP 400 Bad Request`。`Results` 提供了返回不同HTTP状态码的方法。
- en: Using `Results.Created`, a URI is assigned to the first parameter of the method,
    and the second parameter receives the created object. The `201 Created` status
    code is used to return the HTTP location header with a link that can be remembered
    by the client to retrieve the same resource at a later time. The link that’s returned
    here can be used with an HTTP `GET` request to retrieve the game at a later time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Results.Created`，将 URI 分配给方法的第一个参数，第二个参数接收创建的对象。使用 `201 Created` 状态码返回 HTTP
    位置头，包含客户端可以记住的链接，以便稍后检索相同的资源。这里返回的链接可以用作 HTTP `GET` 请求，稍后检索游戏。
- en: Defining an error object
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个错误对象
- en: In case of an error, the `MapPost` method returns `Results.BadRequest`. Here,
    we can define an object to return detailed error information to the client.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，`MapPost` 方法返回 `Results.BadRequest`。在这里，我们可以定义一个对象，向客户端返回详细的错误信息。
- en: 'The following code snippet shows the `GameError` class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 `GameError` 类：
- en: Codebreaker.GameAPIs/Errors/GameError.cs
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Errors/GameError.cs
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `GameError` class defines the `Code`, `Message`, `Target`, and `Details`
    properties. With the `MapPost` method, in the case of requesting an invalid game
    type, the valid game types are returned with the details.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameError` 类定义了 `Code`、`Message`、`Target` 和 `Details` 属性。使用 `MapPost` 方法时，如果请求无效的游戏类型，将返回有效的游戏类型及其详细信息。'
- en: Returning games with HTTP GET
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 HTTP GET 返回游戏
- en: 'To fulfill a request to a single game, we use the `MapGet` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要满足对单个游戏的请求，我们使用 `MapGet` 方法：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the lambda parameters, here, the `Guid` is received from the route parameter.
    Within curly braces, the same variable name is used that matches the variable
    of `Guid`. The implementation simply returns the game with the status code of
    `OK`, or `not found` if the game ID is not found within the repository.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 lambda 参数，从路由参数中接收 `Guid`。在大括号内，使用了与 `Guid` 变量匹配的相同变量名。实现简单，仅返回状态码为 `OK`
    的游戏，或者在仓库中找不到游戏 ID 时返回 `not found`。
- en: Updating games by setting a move with HTTP PATCH
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过设置移动更新游戏使用 HTTP PATCH
- en: 'To set a move, a game is updated with a move without sending the complete game.
    That’s a partial update, thus we use the HTTP `PATCH` verb to invoke the `MapPatch`
    method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置移动，游戏通过不发送完整游戏来更新移动。这是一个部分更新，因此我们使用 HTTP `PATCH` 动词来调用 `MapPatch` 方法：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete route for this request is `games/{id}` – prefixed with the pattern
    specified by the group. The `SetMoveAsync` method of `GamesService` does the main
    work. On success, the method returns `UpdateGameResponse`, which is created from
    the `Game` object and the result string.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求的完整路由为 `games/{id}` – 前缀由组指定的模式。`GamesService` 的 `SetMoveAsync` 方法执行主要工作。成功时，该方法返回
    `UpdateGameResponse`，它由 `Game` 对象和结果字符串创建。
- en: Configuring JSON serialization
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 JSON 序列化
- en: To successfully run the application, the JSON serialization needs to be configured.
    The .NET JSON serializer has many configuration options – including polymorphic
    serialization (returning a hierarchy of objects). But with all these features
    supported from serialization and with ASP.NET Core, you need to pay attention
    to the client technologies you use, if the same support is available there. With
    the data types we transfer here, there’s not a lot to do.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行应用程序，需要配置 JSON 序列化。.NET JSON 序列化器有许多配置选项 – 包括多态序列化（返回对象层次结构）。但是，由于 ASP.NET
    Core 支持所有这些序列化功能，您需要注意您使用的客户端技术，如果那里也有相同支持的话。在这里传输的数据类型，没有太多要做。
- en: 'Just to serialize the enumeration value of game types, we prefer to use strings
    instead of just numbers, which would be returned by default. To return string
    values, the JSON options are configured:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了序列化游戏类型的枚举值，我们更愿意使用字符串而不是默认返回的数字。要返回字符串值，需要配置 JSON 选项：
- en: Codebreaker.GameAPIs/Models/GameAPIModels.cs
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Models/GameAPIModels.cs
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The generic version of the `JsonStringEnumConverter` class is new since .NET
    8 to support Native AOT. The non-generic version of this type uses reflection,
    which is incompatible with Native AOT.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonStringEnumConverter` 类的泛型版本自 .NET 8 以来是新的，以支持原生 AOT。此类型的非泛型版本使用反射，这与原生
    AOT 不兼容。'
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of using the attribute with the type, you can also configure the JSON
    serialization behavior with the dependency injection container. The `ConfigureHttpJsonOptions`
    extension method with `JsonOptions` from the `Microsoft.AspNetCore.Http.Json`
    namespace can be used to configure the JSON serialization for minimal APIs. Be
    aware that the OpenAPI generation still uses the MVC serializer configuration,
    thus, here, you need to use the `Configure` method with `Microsoft.AspNetCore.Mvc.JsonOptions`
    as a generic parameter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用具有类型的属性外，你还可以使用依赖注入容器配置JSON序列化行为。可以使用来自`Microsoft.AspNetCore.Http.Json`命名空间的`ConfigureHttpJsonOptions`扩展方法和`JsonOptions`来配置最小API的JSON序列化。请注意，OpenAPI生成仍然使用MVC序列化配置，因此在这里，你需要使用带有`Microsoft.AspNetCore.Mvc.JsonOptions`作为泛型参数的`Configure`方法。
- en: Creating endpoint filters
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建端点过滤器
- en: To simplify the code for endpoints, as you’ve seen, endpoints don’t need to
    be specified within top-level statements. You can create multiple classes with
    extension methods to group endpoints together. Within one extension method, you
    can also group endpoints with common behaviors using the `MapGroup` method. We
    also used dependency injection to have the main functionality outside of the endpoint
    implementation in the `GameService` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化端点的代码，正如你所见，端点不需要在顶层语句中指定。你可以通过扩展方法创建多个类来将端点分组在一起。在一个扩展方法内部，你也可以使用`MapGroup`方法将具有共同行为的端点分组。我们还使用了依赖注入，将`GameService`类中的主要功能放在端点实现之外。
- en: 'There’s another way to simplify the implementation of the endpoints – by using
    custom endpoint filters. Endpoint filters offer similar functionality as ASP.NET
    Core middleware, just with a different scope. By adding an endpoint filter to
    an endpoint, the filter code is invoked every time the endpoint is accessed. Adding
    multiple endpoint filters, the order of adding these is important: one filter
    is invoked after the other. You can also add an endpoint filter to a group; thus
    the filter is invoked with every endpoint specified with this group.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种简化端点实现的方法——通过使用自定义端点过滤器。端点过滤器提供了类似于ASP.NET Core中间件的功能，只是作用域不同。通过将端点过滤器添加到端点，每次访问端点时都会调用过滤器代码。添加多个端点过滤器时，添加的顺序很重要：一个过滤器在另一个过滤器之后被调用。你还可以将端点过滤器添加到一组中；因此，该过滤器会与该组中指定的每个端点一起调用。
- en: 'With `ValidatePlayernameEndpointFilter`, we create a filter to validate the
    minimum length of the player’s name:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ValidatePlayernameEndpointFilter`，我们创建了一个过滤器来验证玩家名字的最小长度：
- en: Codebreaker.GameAPIs/Endpoints/ValidatePlayernameEndpointFilter.cs
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/ValidatePlayernameEndpointFilter.cs
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: An endpoint filter implements the `IEndpointFilter` interface. This interface
    defines the `InvokeAsync` method with `EndpointFilterInvocationContext` and `EndpointFilterDelegate`
    parameters. By using `EndpointFilterInvocationContext`, you can access `HttpContext`
    to access all the information about the request and also add responses, as well
    as the parameters passed to the endpoint. With the implementation of `ValidatePlayernameEndpointFilter`,
    the player’s name is validated by accessing the first parameter of the endpoints
    lambda expression, accessing the `CreateGameRequest` object, and accessing the
    `PlayerName` property. An HTTP status code of `400 Bad Request` is returned in
    the case that this does not succeed. To access the different parameters, the index
    of the parameter is needed. With a successful validation, the next endpoint is
    invoked using the `next` variable received with the second parameter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 端点过滤器实现了`IEndpointFilter`接口。该接口定义了带有`EndpointFilterInvocationContext`和`EndpointFilterDelegate`参数的`InvokeAsync`方法。通过使用`EndpointFilterInvocationContext`，你可以访问`HttpContext`以获取有关请求的所有信息，并添加响应以及传递给端点的参数。通过实现`ValidatePlayernameEndpointFilter`，通过访问端点lambda表达式的第一个参数、访问`CreateGameRequest`对象以及访问`PlayerName`属性来验证玩家的名字。如果这没有成功，将返回`400
    Bad Request`的HTTP状态码。要访问不同的参数，需要参数的索引。在验证成功后，使用从第二个参数接收的`next`变量调用下一个端点。
- en: 'Using an endpoint filter, you can also remove the exception handling code and
    create code with the filter that’s invoked before and after the next filter or
    the endpoint code is invoked. We implement this functionality with `CreateGameExceptionEndointFilter`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端点过滤器，你还可以删除异常处理代码，并创建在下一个过滤器或端点代码调用之前和之后调用的过滤器代码。我们通过`CreateGameExceptionEndointFilter`实现此功能：
- en: Codebreaker.GameAPIs/Endpoints/CreateGameExceptionEndpointFilter.cs
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/CreateGameExceptionEndpointFilter.cs
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `CreateGameExceptionEndpointFilter` endpoint filter defines a constructor
    to inject the `ILogger` interface. Everything registered with the dependency injection
    container can be injected with an endpoint filter. With this filter, the invocation
    of the next filter – or the endpoint itself, in this case – is surrounded by a
    `try`/`catch` block. Thus, `CodebreakerException` is caught with the endpoint
    invocation, logged, and a result returned. This way, the exception-handling code
    can be removed from the endpoint itself. The following code snippet shows the
    new code for the endpoint implementation with the configured filters:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGameExceptionEndpointFilter`端点过滤器定义了一个构造函数来注入`ILogger`接口。所有注册到依赖注入容器的都可以通过端点过滤器注入。使用此过滤器，下一个过滤器（或端点本身，在这种情况下）的调用被一个`try`/`catch`块包围。因此，`CodebreakerException`在端点调用时被捕获，记录，并返回结果。这样，异常处理代码就可以从端点本身中移除。以下代码片段显示了配置了过滤器的端点实现的新代码： '
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints2.cs
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints2.cs
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this implementation, the important main functionality of this endpoint
    is easily visible. Validation and error handling is moved outside of the endpoint
    implementation. Calculating all the code together, the code is not becoming smaller,
    just the main functionality of the endpoint is becoming easier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种实现，该端点的重要主要功能很容易看到。验证和错误处理被移出端点实现之外。将所有代码一起计算，代码并没有变得更小，只是端点的主要功能变得更简单。
- en: The real power of endpoint filters comes with shared functionality between different
    endpoints. In [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), *Logging and Monitoring*,
    we will create an endpoint filter that logs information for every endpoint that
    is configured with this filter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 端点过滤器真正的威力来自于不同端点之间的共享功能。在第[*11章*](B21217_11.xhtml#_idTextAnchor263) *日志和监控*中，我们将创建一个端点过滤器，为配置了此过滤器的每个端点记录信息。
- en: Running the service
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行服务
- en: 'With the endpoints implemented, you can run and test the application and see
    the Open API user interface, as shown in *Figure 2**.4*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了端点之后，你可以运行和测试应用程序，并查看Open API用户界面，如图*2.4*所示：
- en: '![Figure 2.4 – OpenAPI UI without extra configuration](img/B21217_02_04.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 无额外配置的OpenAPI UI](img/B21217_02_04.jpg)'
- en: Figure 2.4 – OpenAPI UI without extra configuration
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 无额外配置的OpenAPI UI
- en: You can now run the application sending a `POST` request from the Swagger page.
    After getting the game information returned, copy the unique ID from the game,
    and send a `PATCH` request to set a move.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以从Swagger页面发送一个`POST`请求来运行应用程序。在获取返回的游戏信息后，复制游戏的唯一ID，并发送一个`PATCH`请求来设置移动。
- en: While the application is running, OpenAPI now lacks some information. The returned
    HTTP results are not listed, more description details should be shown, and the
    schema for return types is not available. This is solved in the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，OpenAPI现在缺少一些信息。返回的HTTP结果未列出，应该显示更多描述细节，并且返回类型的模式不可用。这将在下一节中解决。
- en: OpenAPI information
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAPI信息
- en: Since there are many .NET versions, the Web API templates reference the `Swashbuckle.AspNetCore`
    NuGet package to create an OpenAPI description. Over the years, with later .NET
    versions, more and more functionality from OpenAPI has been added to ASP.NET Core
    itself, such as the `OpenApiInfo` class, which is now part of the `Microsoft.OpenApis.Models`
    namespace. Swashbuckle was changed to use the new classes and was also changed
    to be based on the `System.Text.Json` serializer instead of `Newtonsoft.Json`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在许多.NET版本，Web API模板引用了`Swashbuckle.AspNetCore` NuGet包来创建OpenAPI描述。多年来，随着.NET版本的更新，越来越多的OpenAPI功能被添加到ASP.NET
    Core本身中，例如`OpenApiInfo`类，现在它是`Microsoft.OpenApis.Models`命名空间的一部分。Swashbuckle被修改为使用新的类，并且也被修改为基于`System.Text.Json`序列化器而不是`Newtonsoft.Json`。
- en: Adding OpenAPI documentation
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加OpenAPI文档
- en: 'Next, let’s make use of classes from the `Microsoft.OpenApis.Models` namespace
    together with Swashbuckle to configure the OpenAPI documentation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`Microsoft.OpenApis.Models`命名空间中的类以及Swashbuckle来配置OpenAPI文档：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Codebreaker Games API is already in its third major version. With the Swagger
    configuration of the dependency injection container, the `AddSwaggerGen` method
    supports receiving configuration options. The `SwaggerDoc` method of the `SwaggerGenOptions`
    options parameter allows specifying different document values, such as the version
    number, title, description, terms of service, contact, and license information,
    as shown in the code snippet. The `OpenApiInfo`, `OpenApiContact`, and `OpenApiLicense`
    classes are part of the `Microsoft.OpenApi.Models` namespace. All this configured
    information will show up in the generated OpenAPI documentation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker 游戏API已经进入第三个主要版本。通过依赖注入容器的Swagger配置，`AddSwaggerGen`方法支持接收配置选项。`SwaggerGenOptions`选项参数的`SwaggerDoc`方法允许指定不同的文档值，例如版本号、标题、描述、服务条款、联系信息和许可信息，如代码片段所示。`OpenApiInfo`、`OpenApiContact`和`OpenApiLicense`类是`Microsoft.OpenApi.Models`命名空间的一部分。所有这些配置信息都将显示在生成的OpenAPI文档中。
- en: 'The middleware configuration needs to be updated as well:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件配置也需要更新：
- en: Codebreaker.GameAPIs/Program.cs
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Program.cs
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the version number is included with the OpenAPI endpoint invoking the
    `SwaggerEndpoint` method using the `SwaggerUIOptions` parameter. In case you prefer
    a different look for the generated document, you can create your own style sheet,
    and pass the style sheet file by invoking the `options.InjectStylesheet` method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，版本号包含在调用`SwaggerEndpoint`方法时使用的`SwaggerUIOptions`参数中。如果您更喜欢生成的文档的另一种外观，可以创建自己的样式表，并通过调用`options.InjectStylesheet`方法传递样式表文件。
- en: Documentation for the endpoints
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点的文档
- en: 'Several extension methods are available to add OpenAPI documentation to the
    endpoints, as we’ll do within the `MapGameEndpoints` implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个扩展方法可用于向端点添加OpenAPI文档，正如我们将在`MapGameEndpoints`实现中做的那样：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `WithTags` method could be added to every endpoint or, as shown here, to
    the endpoint group. `WithTags` adds a category name – or multiple names if the
    API should show up with multiple categories. With this, for the documentation
    for every tag name, a heading is used to show all the endpoints together that
    belong to the same category. If you don’t supply a tag name, the project name
    is used, and all the endpoints are listed in this category.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithTags`方法可以添加到每个端点，或者，如这里所示，添加到端点组。`WithTags`添加一个类别名称——如果API应该显示多个类别，则可以添加多个名称。有了这个，对于每个标签名称的文档，都会使用一个标题来显示属于同一类别的所有端点。如果您不提供标签名称，则使用项目名称，并将所有端点列在这个类别中。'
- en: 'Next, using `RouteHandlerBuilder` extension methods, documentation is added
    to every endpoint:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`RouteHandlerBuilder`扩展方法，将文档添加到每个端点：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the `WithName`, `WithSummary`, and `WithOpenApi` methods, a name and description
    of the API – including a description of every parameter – can be added.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WithName`、`WithSummary`和`WithOpenApi`方法，可以添加API的名称和描述——包括每个参数的描述。
- en: Adding return type information to OpenAPI
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向OpenAPI添加返回类型信息
- en: 'The `Produces` extension method could be used to define what types are returned
    from endpoints that need to be described. Since .NET 7, there’s a better option:
    using the `TypedResults` class instead of the `Results` class that was used earlier
    in implementing the endpoints. `TypedResults` adds the class specified to the
    OpenAPI documentation. However, if there is more than one type returned, we need
    to specify this with the return types of the endpoint lambda expression.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Produces`扩展方法可用于定义需要描述的端点返回的类型。从.NET 7开始，有一个更好的选项：使用`TypedResults`类而不是之前在实现端点时使用的`Results`类。`TypedResults`将指定的类添加到OpenAPI文档中。然而，如果有多个类型返回，我们需要通过端点lambda表达式的返回类型来指定这一点。'
- en: 'The first method to be changed to `TypedResults` is `MapDelete`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要更改为`TypedResults`的方法是`MapDelete`：
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The implementation of the lambda expression for the `MapDelete` method just
    returns the HTTP status code `204` and doesn’t require a return type for the lambda
    expression.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapDelete`方法的lambda表达式实现仅返回HTTP状态码`204`，并且lambda表达式不需要返回类型。'
- en: 'This is different with the `MapPatch` implementation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`MapPatch`实现不同：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The implementation of the lambda expression contains several invocations of
    the `TypedResults` factory class. The `BadRequest`, `NotFound`, and `Ok` methods
    are invoked. With `BadRequest`, an object of the `GameError` type is returned.
    This is just a simple record class with a `Message` and other properties to return
    useful information for the clients. The `Ok` method returns an object of the `UpdateGameResponse`
    class. With two or more typed results returned, the lambda expression needs a
    return type. To specify the return type with the lambda expression, .NET 7 added
    generic `Results` types – for example, the type with two generic parameters: `Results<TResult1,
    TResult2>`. The generic types specify the constraint to require the `IResult`
    interface. The `Microsoft.AspNetCore.Http.HttpResults` namespace contains generic
    `Results` types from two to six generic parameters. By using `Results<Ok<UpdateGameResponse>,
    NotFound, BadRequest<InvalidGameMoveError>>`, it’s defined that the method either
    returns an `Ok` result with a `SetMoveError` object, `NotFound`, or `BadRequest`
    with an `InvalidGameMoveError` object. Because the lambda expression makes use
    of the `async` keyword, the complete result is put into a task: `Task<Results<Ok<UpdateGameResponse>,`
    `NotFound, BadRequest<InvalidGameMoveError>>>`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的实现包含对 `TypedResults` 工厂类的多次调用。调用 `BadRequest`、`NotFound` 和 `Ok` 方法。使用
    `BadRequest` 返回 `GameError` 类型的对象。这是一个简单的记录类，包含 `Message` 和其他属性，以向客户端返回有用的信息。`Ok`
    方法返回 `UpdateGameResponse` 类型的对象。当返回两个或更多类型的结果时，lambda 表达式需要一个返回类型。为了使用 lambda
    表达式指定返回类型，.NET 7 添加了泛型 `Results` 类型 – 例如，具有两个泛型参数的类型：`Results<TResult1, TResult2>`。泛型类型指定了约束，要求实现
    `IResult` 接口。`Microsoft.AspNetCore.Http.HttpResults` 命名空间包含具有两个到六个泛型参数的泛型 `Results`
    类型。通过使用 `Results<Ok<UpdateGameResponse>, NotFound, BadRequest<InvalidGameMoveError>>`，定义了该方法要么返回一个包含
    `SetMoveError` 对象的 `Ok` 结果，要么返回 `NotFound` 或 `BadRequest`，并带有 `InvalidGameMoveError`
    对象。由于 lambda 表达式使用了 `async` 关键字，完整的结果被放入一个任务中：`Task<Results<Ok<UpdateGameResponse>,
    NotFound, BadRequest<InvalidGameMoveError>>>`。
- en: With all this OpenAPI configuration in place, we can start the service, generate
    the documentation to describe the API, and use it from a web interface, as shown
    in *Figure 2**.5*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些 OpenAPI 配置就绪后，我们可以启动服务，生成描述 API 的文档，并通过网页界面使用它，如图 *图 2.5* 所示。
- en: '![Figure 2.5 – OpenAPI documentation](img/B21217_02_05.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – OpenAPI 文档](img/B21217_02_05.jpg)'
- en: Figure 2.5 – OpenAPI documentation
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – OpenAPI 文档
- en: Opening an endpoint, you can see the different HTTP results returned and all
    the schemas created.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 打开端点，你可以看到返回的不同 HTTP 结果和创建的所有模式。
- en: Testing the service
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务
- en: 'To run the service, the OpenAPI test page can be used. However, there’s a better
    way without leaving Visual Studio or Visual Studio Code. Visual Studio offers
    the **Endpoints Explorer** window to show all the API endpoints in your solution,
    as shown in *Figure 2**.6*. Open this window using **View** | **Other Windows**
    | **Endpoints Explorer**:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行服务，可以使用 OpenAPI 测试页面。然而，有一种更好的方法，无需离开 Visual Studio 或 Visual Studio Code。Visual
    Studio 提供了 **端点探索器** 窗口，以显示解决方案中的所有 API 端点，如图 *图 2.6* 所示。使用 **视图** | **其他窗口**
    | **端点探索器** 打开此窗口：
- en: '![Figure 2.6 – Endpoints Explorer](img/B21217_02_06.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 端点探索器](img/B21217_02_06.jpg)'
- en: Figure 2.6 – Endpoints Explorer
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 端点探索器
- en: By selecting an endpoint and opening the context menu, you can generate a request.
    This creates an HTTP file that you can use to send HTTP requests, including the
    body, and see the returned results beside it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择一个端点并打开上下文菜单，你可以生成一个请求。这会创建一个 HTTP 文件，你可以使用它发送 HTTP 请求，包括正文，并查看旁边的返回结果。
- en: Using HTTP files with Visual Studio Code
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中使用 HTTP 文件
- en: If you use Visual Studio Code, install the `REST Client` extension from Huachao
    Mao.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio Code，请从华超毛那里安装 `REST 客户端` 扩展。
- en: 'First, we start a game by sending a `POST` request:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过发送 `POST` 请求开始游戏：
- en: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first two lines in the HTTP file specify variables that are referenced later
    surrounded by two curly braces. Every request specified needs to be separated
    by three hash characters, `###`. With this, using Visual Studio or the Visual
    Studio Code extension, you can see a green arrow that, when clicked, sends the
    request. To separate the HTTP header from the body, a blank line is required.
    The body to create a game contains the `gameType` and `playerName` JSON elements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP文件中的前两行指定了随后被两个大括号包围的变量。每个请求都需要用三个井号字符`###`分隔。使用这种方式，通过Visual Studio或Visual
    Studio Code扩展，您可以看到一个绿色箭头，点击它就会发送请求。为了将HTTP头与正文分开，需要一个空行。创建游戏的正文包含`gameType`和`playerName`
    JSON元素。
- en: 'After sending the request to create a game, you can set a move:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送请求创建游戏后，您可以设置一步操作：
- en: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before sending the move, get the ID that was returned on creation of the game,
    and paste it into the `id` variable used with the HTTP file. There’s no need to
    save this file; just clicking on the link will send the `PATCH` request. Remember
    to update the move number with every move.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送操作之前，获取在创建游戏时返回的ID，并将其粘贴到与HTTP文件一起使用的`id`变量中。无需保存此文件；只需点击链接就会发送`PATCH`请求。请记住，每次操作都要更新操作编号。
- en: 'To get information about the game, send a `GET` request:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关游戏的信息，请发送一个`GET`请求：
- en: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
- en: '[PRE35]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When sending the `GET` request, a body is not supplied. This request gives complete
    information about the game, including its moves, and the result code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送`GET`请求时，不提供正文。此请求提供了关于游戏的所有完整信息，包括其操作和结果代码。
- en: By using HTTP files, you can easily debug the APIs without leaving Visual Studio.
    In case you’re in a debug session, you might need to change the **Request timeout**
    setting in **Text Editor** | **Rest** | **Advanced settings**. The HTTP files
    also serve as good documentation as part of the project.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用HTTP文件，您可以在不离开Visual Studio的情况下轻松调试API。如果您正在进行调试会话，可能需要更改**文本编辑器** | **REST**
    | **高级设置**中的**请求超时**设置。HTTP文件还作为项目的一部分提供了良好的文档。
- en: Enabling .NET Aspire
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用.NET Aspire
- en: Let’s add .NET Aspire to this solution. Using Visual Studio, you can select
    the Games API project in **Solution explorer** and use the context menu to select
    **Add** | **.NET Aspire** **Orchestrator Support…**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将.NET Aspire添加到这个解决方案中。使用Visual Studio，您可以在**解决方案资源管理器**中选择游戏API项目，并使用上下文菜单选择**添加**
    | **.NET Aspire Orchestrator Support…**。
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instead of using Visual Studio, you can use the dotnet CLI to create a .NET
    Aspire project: `dotnet new aspire`. With the two projects created, you can connect
    the Games API project using the explanations from this section.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Visual Studio之外，您还可以使用dotnet CLI创建.NET Aspire项目：`dotnet new aspire`。创建这两个项目后，您可以使用本节中的说明连接游戏API项目。
- en: This creates two projects (`{solution}.AppHost` and `{solution}.ServiceDefaults`)
    and makes small changes to the Games API project. The `AppHost` project is a web
    application that runs a dashboard to monitor all the configured services. `ServiceDefaults`
    is a library to specify default configurations. This library is referenced by
    the Games API. Let’s look into the details next.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个项目（`{solution}.AppHost`和`{solution}.ServiceDefaults`），并对游戏API项目进行一些小的修改。`AppHost`项目是一个运行仪表板以监控所有配置服务的Web应用程序。`ServiceDefaults`是一个用于指定默认配置的库。此库由游戏API引用。接下来，让我们深入了解细节。
- en: Exploring the Aspire host
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Aspire主机
- en: 'The source code of the startup code of the Aspire host is shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了Aspire主机启动代码的源代码：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This Aspire host runs a web application that’s only used during development
    time. Here, the `DistributedApplication` class is used with the app builder pattern.
    The `CreateBuilder` method returns the `IDistributedApplicationBuilder` interface,
    which allows the configuration of all the services that should be orchestrated
    by the distributed application. Using this interface, similar to `WebApplicationBuilder`,
    the configuration and DI container can be configured. Contrary to `WebApplicationBuilder`,
    resources can be added that are orchestrated by the app host.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此Aspire主机运行一个仅在开发时间使用的Web应用程序。在这里，使用应用程序构建器模式使用了`DistributedApplication`类。`CreateBuilder`方法返回`IDistributedApplicationBuilder`接口，该接口允许配置所有应由分布式应用程序编排的服务。使用此接口，类似于`WebApplicationBuilder`，可以配置配置和DI容器。与`WebApplicationBuilder`相反，可以添加由应用程序主机编排的资源。
- en: A project resource is added to the resources of the builder by invoking the
    `AddProject` extension method. Adding a project reference to the `Codebreaker.GameAPIs`
    project creates the `Codebreaker_GameAPIs` class in the `Projects` namespace.
    The name passed with the parameter – `gameapis` – can be used when one service
    references another one. Currently, we only have one service in the `Codebreaker`
    solution, but this will change going forward with the chapters of this book.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `AddProject` 扩展方法将项目资源添加到构建器的资源中。将项目引用添加到 `Codebreaker.GameAPIs` 项目中将在
    `Projects` 命名空间中创建 `Codebreaker_GameAPIs` 类。传递给参数的名称 – `gameapis` – 可以在某个服务引用另一个服务时使用。目前，我们在
    `Codebreaker` 解决方案中只有一个服务，但随本书的章节推进，这将会改变。
- en: Exploring the ServiceDefaults library
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 ServiceDefaults 库
- en: The `Codebreaker.ServiceDefaults` project is here to be referenced by all service
    projects making use of .NET Aspire functionality. This project adds references
    to NuGet packages for HTTP resiliency, service discovery, and several OpenTelemetry
    packages used for logging, metrics, and distributed tracing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.ServiceDefaults` 项目是为了被所有使用 .NET Aspire 功能的服务项目引用。此项目添加了对 NuGet
    包的引用，用于 HTTP 弹性、服务发现以及用于日志记录、指标和分布式跟踪的几个 OpenTelemetry 包。'
- en: 'This is the configuration defined by the `Extensions` class:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Extensions` 类定义的配置：
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `AddServiceDefaults` method configures the DI container with OpenTelemetry
    for logging, default health checks, and service discovery, and configures the
    `HttpClient` class with resiliency.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddServiceDefaults` 方法使用 OpenTelemetry 配置 DI 容器以进行日志记录、默认健康检查和服务发现，并配置 `HttpClient`
    类以实现弹性。'
- en: This complete configuration can be used from the Codebreaker Games API by invoking
    the `AddServiceDefaults` method with the application builder. This invocation
    is added from the Visual Studio .NET Aspire integration when adding Aspire orchestration.
    If you created the .NET Aspire projects from the command line, you need to add
    the invocation to the `AddServiceDefaults` method when configuring the DI container.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此完整配置可以通过调用应用程序构建器的 `AddServiceDefaults` 方法从 Codebreaker Games API 使用。此调用是在添加
    Aspire 协调器时从 Visual Studio .NET Aspire 集成中添加的。如果你是从命令行创建的 .NET Aspire 项目，则在配置
    DI 容器时需要将调用添加到 `AddServiceDefaults` 方法中。
- en: 'Another extension method defined by the service defaults library is `MapDefaultEndpoints`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 服务默认库定义的另一个扩展方法是 `MapDefaultEndpoints`：
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE38]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is an extension method to configure the ASP.NET Core middleware with health
    checks. The `MapDefaultEndpoints` method needs to be invoked with the middleware
    configuration of the Games API.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个配置 ASP.NET Core 中间件的健康检查的扩展方法。需要使用 Games API 的中间件配置调用 `MapDefaultEndpoints`
    方法。
- en: All the functionality mentioned here will be discussed in detail in the following
    chapters. Now, you can already start the Aspire host project, which, in turn,
    starts up the Games API.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的所有功能将在以下章节中详细讨论。现在，你可以开始启动 Aspire 宿主项目，它反过来启动 Games API。
- en: Running the .NET Aspire host
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 .NET Aspire 宿主
- en: When running the .NET Aspire host, a dashboard is shown that shows the `codebreaker.gameapis`
    project with the resources where you can access endpoints, check environment variables,
    and open log information, as shown in *Figure 2**.7*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 .NET Aspire 宿主时，会显示一个仪表板，显示 `codebreaker.gameapis` 项目及其资源，你可以访问端点、检查环境变量和打开日志信息，如图
    *图 2**.7* 所示。
- en: '![Figure 2.7 – Resources in the .NET Aspire dashboard](img/B21217_02_07.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – .NET Aspire 仪表板中的资源](img/B21217_02_07.jpg)'
- en: Figure 2.7 – Resources in the .NET Aspire dashboard
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – .NET Aspire 仪表板中的资源
- en: While the Aspire host is running, you can play games using the HTTP files created
    earlier, and now monitor the logs, metrics information, and traces (shown in *Figure
    2**.8*).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Aspire 宿主运行时，你可以使用之前创建的 HTTP 文件玩游戏，并现在监控日志、指标信息和跟踪（如图 *图 2**.8* 所示）。
- en: '![Figure 2.8 – Traces in the .NET Aspire dashboard](img/B21217_02_08.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – .NET Aspire 仪表板中的跟踪](img/B21217_02_08.jpg)'
- en: Figure 2.8 – Traces in the .NET Aspire dashboard
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – .NET Aspire 仪表板中的跟踪
- en: Details on logging, metrics, tracing, and adding custom information are covered
    in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), *Logging* *and Monitoring*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志记录、指标、跟踪以及添加自定义信息的详细信息请参阅 [*第 11 章*](B21217_11.xhtml#_idTextAnchor263)，*日志记录*
    和 *监控*。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a Web API using ASP.NET Core minimal APIs. We covered
    creating services and an in-memory repository, configured them with the dependency
    injection container, created models, and used game analyzer classes to calculate
    moves.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 ASP.NET Core 最小 API 创建了一个 Web API。我们涵盖了创建服务和内存中仓库，使用依赖注入容器进行配置，创建了模型，并使用游戏分析类来计算移动。
- en: We created endpoints to create, read, and update games, specified information
    to show up with the OpenAPI documentation, tested the service using HTTP files,
    and finally, added .NET Aspire for hosting and a dashboard.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了用于创建、读取和更新游戏的端点，指定了与 OpenAPI 文档一起显示的信息，使用 HTTP 文件测试了服务，并最终添加了 .NET Aspire
    用于托管和仪表板。
- en: After working through this chapter, you deserve a break to play a game. Use
    the HTTP files to create a game and set moves until the answer returned shows
    that you won. Don’t cheat by making `GET` requests to the game before you find
    the answer!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，你应休息一下，玩玩游戏。使用 HTTP 文件创建一个游戏并设置移动，直到返回的答案显示你已经赢了。在你找到答案之前，不要通过向游戏发送
    `GET` 请求来作弊！
- en: In the next chapter, we’ll replace the repository by using Entity Framework
    Core with SQL Server and Azure Cosmos DB to have a persistent games store.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Entity Framework Core 和 SQL Server 以及 Azure Cosmos DB 来替换仓库，以拥有一个持久的游戏存储。
- en: Further reading
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下链接：
- en: '*Primary* *constructors*: [https://csharp.christiannagel.com/2023/03/28/primaryctors/](https://csharp.christiannagel.com/2023/03/28/primaryctors/)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要* 构造函数：[https://csharp.christiannagel.com/2023/03/28/primaryctors/](https://csharp.christiannagel.com/2023/03/28/primaryctors/)'
- en: '*Microsoft REST API* *Guidelines*: [https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Microsoft REST API* 指南：[https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)'
- en: '*The OpenAPI* *Initiative*: [https://www.openapis.org/](https://www.openapis.org/)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenAPI* 初始项目：[https://www.openapis.org/](https://www.openapis.org/)'
- en: '*Minimal APIs parameter* *binding*: https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/parameter-binding'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最小 API 参数* 绑定：[https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/parameter-binding](https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/parameter-binding)'
- en: '*JSON serialization* *customization*: [https://learn.microsoft.com/en-us/dotnet/standard/serialization/](https://learn.microsoft.com/en-us/dotnet/standard/serialization/)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON 序列化* 自定义：[https://learn.microsoft.com/en-us/dotnet/standard/serialization/](https://learn.microsoft.com/en-us/dotnet/standard/serialization/)'
- en: 'The `Swashbuckle.AspNetCore` GitHub repo: https://github.com/domaindrivendev/Swashbuckle.AspNetCore'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swashbuckle.AspNetCore` GitHub 仓库：[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
- en: '.NET Aspire documentation: [https://learn.microsoft.com/en-us/dotnet/aspire/](https://learn.microsoft.com/en-us/dotnet/aspire/)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Aspire 文档：[https://learn.microsoft.com/en-us/dotnet/aspire/](https://learn.microsoft.com/en-us/dotnet/aspire/)
