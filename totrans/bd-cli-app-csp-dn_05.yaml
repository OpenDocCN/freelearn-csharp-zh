- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input/Output and File Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we laid out the foundations of `System.CommandLine`
    library to infuse CLI capabilities into the application.
  prefs: []
  type: TYPE_NORMAL
- en: For now, our CLI application only contains one command (`link`), which allows
    for managing bookmarks by adding new ones or listing, updating, or removing existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this chapter, we are working toward two goals:'
  prefs: []
  type: TYPE_NORMAL
- en: To go a bit deeper with options to further control input values for our CLI
    applicationâ€™s command options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see how to handle input and output files in a CLI application. This might
    be handy for import and export operations, making it easier to back up and restore
    our applicationâ€™s data and share it with other applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specifically, weâ€™ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling input values for an option, determining when to use required versus
    non-required options, setting default values for options, controlling the set
    of allowed values for an option, and validating input values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files passed as parameters to the CLI application, both as input
    and output files, which will be useful for adding import and export capabilities
    to our CLI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Controlling input values for an option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters are at the heart of any application. They allow users to indicate
    what command they want to execute and provide values to the input parameters.
    This is why, in this section and its subsections, we will cover the subtleties
    of dealing with these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Required versus non-required options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its current state, adding a new bookmark requires both the name and the URL
    to be provided, which is, obviously, what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we call the `link add` command without passing one of these
    options or their values, we should get an error such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 â€“ The name and URL for a bookmark should be required](img/B22400_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 â€“ The name and URL for a bookmark should be required
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we run the program without passing these two options, we currently
    get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 â€“ The name and URL for the added bookmark are currently optional](img/B22400_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 â€“ The name and URL for the added bookmark are currently optional
  prefs: []
  type: TYPE_NORMAL
- en: Notice how a new bookmark with no name and no URL is added to the collection
    of bookmarks. This is clearly not what we want!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `Option` class provides a Boolean value to specify whether
    it should be required or optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the name and URL options required, letâ€™s set their respective `IsRequired`
    property to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the program without passing in an option or its value, we get
    an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 â€“ The name and URL for the added bookmark are now required](img/B22400_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 â€“ The name and URL for the added bookmark are now required
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the help menu clearly states that these two options are required.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have two required options. Letâ€™s add an optional one.
  prefs: []
  type: TYPE_NORMAL
- en: When an option is not required (i.e., optional), the application should not
    return an error if we donâ€™t pass that option or its value.
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s take an illustrative example.
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s say we want to classify our bookmarks by category. By doing so, we can
    imagine that we may want to list only the bookmarks that belong to a specific
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that matter, we will first add a `Category` property to the `Bookmark`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add an option for the category and pass it to the `add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the handler method and its association with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, do not forget to update `BookmarkService` so it handles the `Category`
    property accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we execute the application without passing the category, no error is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 â€“ The Category option is optional](img/B22400_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 â€“ The Category option is optional
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, if we pass a category, it works too. ðŸ˜Š
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 â€“ Assigning a category to the newly added bookmark](img/B22400_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 â€“ Assigning a category to the newly added bookmark
  prefs: []
  type: TYPE_NORMAL
- en: However, since the category is now optional, if we donâ€™t pass it, what would
    its value be?
  prefs: []
  type: TYPE_NORMAL
- en: Double or single dash?
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering when we should use double versus single dashes. Do we
    even have to use both?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no! You only use both if you want to provide both a long and a
    short form for passing in an option, but you can definitely opt for only one of
    these options.
  prefs: []
  type: TYPE_NORMAL
- en: For example, while `--set-max-concurrent-requests` might be more self-explanatory
    to someone new to your CLI, if they often use your CLI application, having to
    type this long form again and again may become frustrating. Thatâ€™s why a short
    form, such as `-m`, will be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, you will notice that users who are just starting to use your
    CLI application will rely on long-form options and gradually transition to short
    forms as they become more experienced with your CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, a junior user of Bookmarkr will prefer this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bookmarkr link add --name "Packt Publishing" --``url "https://packtpub.com"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'An experienced user, on the other hand, is likely to prefer this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bookmarkr link add -n "Packt Publishing" -``u "https://packtpub.com"`'
  prefs: []
  type: TYPE_NORMAL
- en: What about arguments?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ah! I can see that youâ€™ve learned about arguments. Arguments are instances of
    the `Argument` class, and they represent required parameters that are essential
    to the execution of a command.
  prefs: []
  type: TYPE_NORMAL
- en: But waitâ€¦ why not use arguments instead of options for required parameters?
  prefs: []
  type: TYPE_NORMAL
- en: You could, of course! But I donâ€™t like these because they are *positional* parameters
    and not *named* parameters. This means that only their position instructs the
    user about their purpose, which, to me, sacrifices the readability of the CLI
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate my point, here is what the call to the `link add` command would
    look like if it relied on arguments rather than parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See how this is way less readable than our previous request (which relies on
    options)?
  prefs: []
  type: TYPE_NORMAL
- en: Thatâ€™s why I donâ€™t like arguments and prefer to use options, specifying which
    ones are required and which ones are optional.
  prefs: []
  type: TYPE_NORMAL
- en: So, letâ€™s get back to exploring options.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a default value for an option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, as you may have guessed, the default value for an option will be (by default)
    the default value for its data type (are you still with me?).
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Category` option is of type `string`, its default value is `null`.
    However, the `Option` class allows us to define a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s set the default value for the `Category` option to `"Read later"`. This
    can be done by calling the `SetDefaultValue` method and passing in the default
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the program without providing a value for the `Category` option,
    we can see that its default value is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 â€“ Using the default value for the category option](img/B22400_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 â€“ Using the default value for the category option
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we do provide a value for the category, we can see that this value
    is actually used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 â€“ Using the provided value for the category option](img/B22400_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 â€“ Using the provided value for the category option
  prefs: []
  type: TYPE_NORMAL
- en: Should we provide default values for required options?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No, we should not! This is because if we do that, a required option will no
    longer behave as a required one but rather as an optional one.
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because if we do not provide a value for it, the default value will be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: This is why default values should only be used with optional options.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the previous example, the user can specify any string value for
    the `Category` option. But what if we wanted to control the set of allowed values?
    This is where the `FromAmong` method comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the allowed values for an option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Letâ€™s pretend for a moment that we only allow a set of categories in our application.
    Yes, in real life, we would allow users to create as many categories as they want,
    but this will serve our purpose of explaining how to only allow a specific set
    of values for an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letâ€™s say we allow the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Read later (which serves as the default one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tech books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cooking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will do this by passing these values to the `FromAmong` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the application by passing in an allowed category, everything works
    fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 â€“ Passing in an allowed value for the category](img/B22400_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 â€“ Passing in an allowed value for the category
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we do pass an unallocated category value, we will get an error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 â€“ Passing in an unallowed value for the category](img/B22400_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 â€“ Passing in an unallowed value for the category
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the error message indicates the allowed values. We can also see
    the allowed values from the help menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 â€“ Seeing the allowed values in the help menu](img/B22400_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 â€“ Seeing the allowed values in the help menu
  prefs: []
  type: TYPE_NORMAL
- en: Using `FromAmong` can be particularly useful for ensuring data integrity and
    guiding user input, especially in scenarios where options need to conform to a
    predefined set of valid values.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so letâ€™s recap. Our CLI application has required and optional parameters.
    It specifies a default value for its optional parameter, along with allowed values.
    However, we are missing something, something important. Can you guess what it
    is?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, exactly, the ability to ensure that the provided value for a specific parameter
    is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Validating input values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding a new bookmark, we need to pass a URL for it. But, until now, we
    havenâ€™t checked whether the provided value is indeed a valid URL. Letâ€™s fix this.
  prefs: []
  type: TYPE_NORMAL
- en: The `Option` class allows us to configure a validator function. We will then
    add a validator method for `urlOption` to ensure it only gets valid URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved by calling the `AddValidator` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `AddValidator` method uses an inline delegate
    to ensure that the value provided to `urlOption` is valid. In this case, it ensures
    that it is actually present (thatâ€™s what the `if` section is checking) and that
    it is a valid URL (thatâ€™s what the `else if` section is checking).
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, if we execute the program with both an invalid and a valid URL, we
    can see that it behaves as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 â€“ Validating the input value for the URL option](img/B22400_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 â€“ Validating the input value for the URL option
  prefs: []
  type: TYPE_NORMAL
- en: More advanced validation
  prefs: []
  type: TYPE_NORMAL
- en: Validation could be more advanced than that. Our application is intended to
    collect bookmarks from everywhere on the web. However, if you would like to restrict
    its usage to, letâ€™s say, your organization only, you may want to check (in your
    validation process) that the bookmarked URLs are only referring to your corporate
    domain and dismiss everything else.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! So now, Bookmarkr allows us to manage bookmarks, ensuring that only
    valid information can be passed to (and stored in) the CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: However, up to this point, we can still only add one bookmark at a time. Wouldnâ€™t
    it be nice if we could provide a set of names and URLs as part of the same request
    and have Bookmarkr add them in one go?
  prefs: []
  type: TYPE_NORMAL
- en: '`System.CommandLine` has a feature that allows us to do just that ðŸ˜‰.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple elements in one go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Letâ€™s try passing in multiple names and URLs to the same request, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we do this, we will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 â€“ Name and URL options expect only one value by default](img/B22400_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 â€“ Name and URL options expect only one value by default
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the arity of these options.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is an** **arity, anyway?**'
  prefs: []
  type: TYPE_NORMAL
- en: The arity of an option represents the number of values that can be passed if
    that option is specified. It is expressed with a minimum value and a maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: This is of great importance if your CLI application supports bulk operations
    through one or many of its commands. In our example, we want to perform a bulk
    operation for adding multiple bookmarks at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an option of type `string`, the minimum and maximum values are
    both set to `1`, which means that if we specify the option, we must provide a
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Boolean option will have a minimum value of `0` and a maximum value of `1`
    since we donâ€™t need to pass in a value as both these syntaxes are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, a list of elements has a minimum arity of 1 and a maximum of
    (by default) 100,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to specify the arity of an option, `System.CommandLine` provides an
    enumeration named `ArgumentArity`, which has these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Zero`, meaning no values are allowed. So, `--force` would be valid but not
    `--``force true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZeroOrOne`, meaning a minimum of zero and a maximum of one value is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZeroOrMore`, meaning either zero, one, or many values are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExactlyOne`, meaning a minimum of one and a maximum of one value is allowed.
    This is the case for our string options, name, and URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneOrMore`, meaning either one or multiple values are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set the arity of an option, we can then use one of the values provided by
    the `ArgumentArity` enumeration, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, we should be able to provide multiple values for a given option. Letâ€™s
    try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 â€“ Failing to provide multiple values for a given option](img/B22400_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 â€“ Failing to provide multiple values for a given option
  prefs: []
  type: TYPE_NORMAL
- en: Oops, this is not what we expected, right?
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that even though `nameOption` can accept more than one value,
    it is not clear to the program how to convert those values into a single string.
    This is why the error message is referring to a custom binder (so it is told how
    to perform such a conversion).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this problem, we need to tell the program to treat each of
    these inputs as a separate argument. This is done by setting the `AllowMultipleArgumentsPerToken`
    property to `true`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Also, letâ€™s get rid of the arity for a moment by commenting out the corresponding
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we run the program, we can see that the error is gone but we are still
    not getting the expected resultâ€¦
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 â€“ nameOption is now accepting multiple values](img/B22400_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 â€“ nameOption is now accepting multiple values
  prefs: []
  type: TYPE_NORMAL
- en: Notice how only the last pair of names and URLs were considered and added to
    the list of bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: What happened, in fact, is that `System.CommandLine` noticed that we have two
    occurrences of the name and URL, so the last ones have overridden the first ones
    and only those last ones were actually passed to the `Handler` method. This is
    why we only get one bookmark added with the information of the last pair of names
    and URL values.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we want to be able to pass a list of names and URLs and have the
    `Handler` method add as many bookmarks as the number of name and URL pairs?
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need two things. First, letâ€™s uncomment the lines of code that
    set the arities for `nameOption`, `urlOption`, and `categoryOption`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, letâ€™s change the declaration of the name, URL, and category options along
    with the validator and the signature of the `Handler` method so that they accept
    a list of strings rather than a single string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run the program, things work (finally) as expected! ðŸ˜Š
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 â€“ Bookmarkr accepts a list of bookmarks](img/B22400_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 â€“ Bookmarkr accepts a list of bookmarks
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each option accepts multiple values, letâ€™s take a look at whether we
    can simplify the following CLI request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Weâ€™ll simplify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we only need to specify `--name`, `--url`, and `--``category` once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since both CLI requests are equivalent, they lead to the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 â€“ Simplified CLI request](img/B22400_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 â€“ Simplified CLI request
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! This works just great!
  prefs: []
  type: TYPE_NORMAL
- en: Butâ€¦ typing a list of names, URLs, and categories might quickly become tedious
    as the list grows.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldnâ€™t it be nice if we could simply provide the path to a file as a parameter
    that contains all the names, URLs, and categories and let the application read
    that file and create the bookmarks accordingly?
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, wouldnâ€™t it be nice if we could specify the path to an output
    file to store all the bookmarks our CLI application is holding?
  prefs: []
  type: TYPE_NORMAL
- en: Working with files passed in as options values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files can be provided as options values to serve as input or output parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As an input parameter, a fileâ€™s content can be read to import data into the
    CLI application. In our case, we could import bookmarks from other browsers, such
    as Chrome or Firefox, into Bookmarkr.
  prefs: []
  type: TYPE_NORMAL
- en: As an output parameter, a file can be created to export the data that is held
    by Bookmarkr, which in turn can be imported into other browsers, such as Chrome
    or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Together, these two capabilities can enable backup and restore but also data
    sharing and exchange scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s build these features into Bookmarkr!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Browsers, such as Chrome or Firefox, have their own proprietary structure to
    import and export bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: We wonâ€™t be performing parsing or conversion to these formats for the sake of
    simplicity. Our goal is to focus on working with input and output files as part
    of a CLI application. We will, however, import and export bookmarks in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s begin with the `export` command.
  prefs: []
  type: TYPE_NORMAL
- en: This command is meant to take all bookmarks managed by Bookmarkr and save them
    in a JSON file whose path is specified as a value to the `--file` option. This
    option is, of course, required.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to create an option of type `FileInfo`, and it will be
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to create a new command and add it to the `root` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to set a `Handler` method for the `export` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Handler` method calls `BookmarkService` to get the list of all bookmarks,
    then converts them to JSON and saves that JSON content into the provided file.
    If the file already exists, it is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that youâ€™ll need to import this namespace for the code to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, letâ€™s try it and see whether it works as expected!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 â€“ Exporting all bookmarks](img/B22400_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 â€“ Exporting all bookmarks
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! This is exactly what we expected!
  prefs: []
  type: TYPE_NORMAL
- en: But how can we ensure that the provided file has a valid name?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could certainly create a validator method to check this, but `System.CommandLine`
    already provides an extension method for that matter (and I wanted to let you
    know ðŸ˜‰):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Letâ€™s try calling the `export` command with an invalid file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 â€“ Handling invalid files](img/B22400_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 â€“ Handling invalid files
  prefs: []
  type: TYPE_NORMAL
- en: See? That error has been raised because of the call to the `LegalFileNamesOnly`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Okay! Now letâ€™s move on to adding the `import` command!
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the syntax to import bookmark data from an existing file is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since many of the steps involved are very similar to the ones we followed to
    create the `export` command, letâ€™s just share the code here and discuss the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main difference is the call to the `ExistingOnly` method. This method ensures
    that `inputfileOption` will only accept values corresponding to existing files,
    otherwise an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other difference is how the `OnImportCommand` handler method operates:
    it reads the content of the file, converts it from JSON to a list of items of
    type `Bookmark`, and then passes it to `BookmarkService` to add these items to
    the list of bookmarks it manages (by calling its `Import` method).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, letâ€™s try this code!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 â€“ Importing bookmarks from a file](img/B22400_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 â€“ Importing bookmarks from a file
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the file doesnâ€™t exist?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 â€“ Handling a non-existent file](img/B22400_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 â€“ Handling a non-existent file
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we can see that we are getting the expected result! ðŸ˜Š
  prefs: []
  type: TYPE_NORMAL
- en: And thatâ€™s a wrap! You now know how to work with input and output files in your
    CLI applications. Congratulations! Letâ€™s now conclude this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved our CLI application, Bookmarkr, by adding better
    control for the input values for its commandâ€™s options (by explicitly indicating
    what options are required, setting default values where appropriate, designing
    validators to ensure the input values comply with the expected type, format, or
    range of values, and enabling auto-completion to make things simpler for the user).
  prefs: []
  type: TYPE_NORMAL
- en: We also added the ability to import and export application data from and to
    a file. This makes it easier to back up and restore data and even share it offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming chapter, we will see how to implement a very important feature
    in every application: logging and error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 â€“ validating the format and the ability to access the input file'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a reminder, the syntax to import bookmark data from an existing file is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the input file cannot be accessed, or if its data is not in the expected
    format, then the application should display a corresponding error message to the
    user. Otherwise, the application should import all the bookmarks from the input
    file and display a success message to the user indicating how many bookmarks have
    been imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 â€“ merging existing links from the input file'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When importing bookmarks from an existing file, it is possible that some of
    them already exist in the bookmarks held by the application.
  prefs: []
  type: TYPE_NORMAL
- en: In such a situation, it is a best practice for a CLI application to provide
    the user with an option to control whether they want to merge those existing links
    or simply discard them and not import them.
  prefs: []
  type: TYPE_NORMAL
- en: In this task, I challenge you to implement this best practice by adding an optional
    `--merge` option to the `import` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the syntax for the `import` command with the `--merge` option will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `--merge` option is specified, the expected behavior of the `import`
    command is that for each bookmark in the provided input file, the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: If its URL already exists in the list of bookmarks held by the application,
    the name of the existing bookmark should be updated with the name corresponding
    to this URL in the input file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the bookmark should simply be added to the list of bookmarks held
    by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
