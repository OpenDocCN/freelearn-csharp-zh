- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Externalization of Business Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the two preceding chapters detailing the Master Data Management and Business
    Process Management parts of a utopic information system, this chapter will end
    with the third and last part of such an ideal system, which is the **Business
    Rules Management System** (**BRMS**). We have already discussed briefly business
    rules in the previous chapters because the data referential may contain some validation
    rules that are associated with a given business entity, and the business process
    may also embed some business rules to orient the workflow and decide which branch
    of the process should be executed, depending on the context. But in the perfectly
    ideal system that we envision, a centralized system should be responsible for
    all the business rules, and that is the subject of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by explaining in more detail what a BRMS is and what implementing
    such a solution requires in terms of business rules management, deployment, and
    architecture of the stream of data in the system. Then, we will show the first
    example of business rules management using a standard called **DMN** (short for,
    **Decision Model and Notation**), inside a business process.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous two, we will end this chapter (and the series of three chapters
    on the different parts of an ideal information system) without providing application
    examples of our sample information system. The reason behind this is that authorization
    management is one of the best examples of business rules management, but the subject
    is so complex that it needs a complete chapter to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Business Rules Management Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Business Rules Management System** (we will abbreviate into **BRMS** from
    now on) is a piece of software that deals with computations and decisions that
    can be applied to data, in order to output results that have a higher business
    value. There are lots of concepts in that definition, and we are going to explain
    them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: How does a BRMS handle business rules?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A business rule can, for example, calculate the total price of an order line,
    using the tax-excluding price of an article, the number of articles, and the applicable
    tax rate. Another example of its application would be to decide whether a piece
    of document created in an invoicing process should be given an electronic signature
    or not. In this case, the business rules output a Boolean value, stating whether
    the result is true or false. Business rules can call each other. In the previous
    example, we may have to decide how the document will be presented to someone for
    signature, who will sign if the initial signee is considered absent after several
    notifications, how many such notifications will be sent and on which channels,
    and so on – all these are business rules.
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, a BRMS manages business rules. But what this entails is
    not so obvious. In one way, you could consider that a BRMS is the MDM of business
    rules – it can store them, together with their old versions. It can allow some
    people to read them, some to write them, or reject others that have no authorization
    whatsoever on certain business rules. It can group and categorize business rules
    in order to specify their research. All this is done by an MDM on its referenced
    business entity, but a BRMS has one more responsibility that an MDM does not have,
    which is the execution of the business rule. Indeed, a business rule takes input
    to calculate an output, and it is the main responsibility of a BRMS to do so.
  prefs: []
  type: TYPE_NORMAL
- en: However, responsibility does not mean the BRMS executes everything. Most of
    the time, it will delegate the enforcement of the rule, as it does not own the
    data that is addressed by a business rule or the service that executes a business
    action in a way defined by the output of the rule. That may sound counter-intuitive,
    but a BRMS can even delegate responsibility for the execution of the rule (which
    is to calculate the output of the rule from its input). This is the case, for
    example, where an MDM service validates its incoming data with a rule coming from
    the BRMS. Some local cache of the rules expressions is also possible since it
    does not introduce lots of coupling. Nonetheless, the responsibility of the validation
    rule remains in the BRMS, since if somebody changes the rule in the BRMS editor,
    then it will apply (maybe after a small delay, if the cache is not immediately
    invalidated for performance reasons) to all servers using this rule, among which
    is the MDM of our example.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the primary responsibilities of a BRMS are to store, expose, and
    execute business rules. It is responsible for the right execution of the rules
    and, thus, either executes them internally or trusts other applications to execute
    the rules that it provides them. This is often the case, as external applications
    are the ones that have access to the input data necessary to execute the rule.
    Also, they will be – most of the time – the ones that use the output of the rule
    to adjust their behavior accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Additional characteristics of a BRMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often talk about the “secondary responsibilities” of a service for features
    that are not absolutely necessary but still remain important. In the case of BRMS,
    there are several such responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, a BRMS should have high performance, both in execution time
    and in its capacity to withstand a high volume of requests. Indeed, rule execution
    is one of the few cases where a cache is difficult to apply. When retrieving an
    image from a URL, there is a great chance that it is not going to change from
    one call to another one a few seconds after; thus, it is really worth keeping
    a cache, as this will avoid a network roundtrip and server request handling and
    drastically improve performance. This is not the case for business rules, as their
    main function is to be calculated from varying input and provide an output that
    depends on them.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, the rule expression can be cached (and rules may not change that frequently),
    but when you do so, the caller has to be able to execute the rule from its textual
    expression itself, which may be overly complex and necessitate a rule-execution
    engine. If the rule is shared among many services, many instances of the engine
    will have to be kept in synchronization with the BRMS, so it is not efficient.
    So, we come back to the engine being in only one place, which is the BRMS server
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the engine’s moving parts may be cached, or at least kept in RAM,
    which will provide a quick execution. However, caching the results depending on
    the input is, most of the time, not efficient, as there are so many possible values.
    To use our preceding example, there is absolutely no need to cache the result
    of a calculation of an invoice line total price, as there is almost no chance
    that another call will come back quickly for the same article, with the same quantity
    and tax rate. If you add that some rules may be based on ever-changing data (such
    as stock market values), it can become absolutely impossible to arrange some way
    of caching. So, we basically fall back to the need for an engine that can output
    values as quickly as possible. This requirement should of course be supported
    in case of high volumes. As business data (as opposed to reporting data) tends
    to be volatile, business rules will be called very often.
  prefs: []
  type: TYPE_NORMAL
- en: The other “secondary” feature of a good BRMS is robustness. When they are used
    in the industry (which is not very often because they are complex applications),
    it is because they are a very important part of the business processes. For instance,
    a BRMS is used by insurance companies to calculate risk, or by mobile phone companies
    to calculate the price to be paid from data about the conversations (the duration,
    numbers called, time of the day, etc.) and the contract (a discount for certain
    numbers, prepaid amount per month, consumption in the month, etc.). Because of
    the cost of a BRMS, they are generally used for core business functions, where
    important decisions (in our examples, accepting a contract and sending the correct
    invoice to a customer) are made based on their output. The robustness of calculations
    is, thus, an important aspect because no one would work with a system that can
    miscalculate from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, traceability is generally an important feature of a BRMS.
    It can, of course, delegate this to calling services because a BRMS mostly works
    for other services. But even if the responsibility is shared, there should be
    logs that record whether a rule has been applied to certain context data, providing
    output that clarifies why a certain rule was made. Even if logs are better suited
    to the calling application, it is a good idea that the version of the BRMS set
    of rules is kept somewhere and that the rule engine versions are immutable. This
    allows you, if necessary, to go back in time, re-execute business rules calculation
    on the then-used version of the BRMS engine, and understand why an output value
    was wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as explained previously, a BRMS is often used in conjunction with other
    services and is useless by itself. Its low-level characteristics make its integration
    and good capacity for interoperation of paramount importance. An implementation
    should normally come with at least some APIs and, if possible, SDKs for as many
    languages as possible, making it easy to interact with all possible software applications.
  prefs: []
  type: TYPE_NORMAL
- en: Actual use of BRMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As was hinted previously, the actual use of BRMS in the field is very low. The
    cost of implementation is such that only a few very particular cases of business
    rule execution are actually worth deploying a dedicated server for. Also, as we
    saw, the externalization of a rule comes with a high toll on performance, as either
    the application that knows the data has to send it to the BRMS and wait for the
    output to follow its flow, or it has to dynamically execute a business rule expression
    sent by the BRMS, and maybe cached internally. In this case, the speed of execution
    is still lower than when the rule is compiled into an application. Sure, the coupling
    between the application and the rule is then maximal, there is no centralized
    sharing of the rule, and the many uses can diverge. However, the performance issue
    can be so significant that these reasons are not as important.
  prefs: []
  type: TYPE_NORMAL
- en: Also, let’s not underestimate habitual factors as well – since developers have
    spent most of their careers taking business rules from use cases and translating
    them into code put in an application, it is an effort to change this way of thinking,
    extract the business rule, and place it somewhere else. And with what results?
    A large performance drop and code that is more difficult to read and maintain.
    This means that the business rule should `CommonBusinessValues` class, in a `public
    static readonly` member, and everything will be fine and ready for an update.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, indeed, in 99.99% of the cases, business rules will be concretely
    implemented, like in the following C# example, by means of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, lots of other business rules will be scattered all over the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, it is better to use string values or even dedicated code structures
    instead of enumerations for this kind of value, as this eases evolution.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there are so many business rules everywhere in a code base that it
    is difficult to spot all of them. But this is not what is most important. The
    real challenge is for the architect/product owner/developer to know, when creating
    the application, which ones should be externalized, which ones should be centralized,
    and which should be simply left in the code, even in duplicates, because they
    will never change. Beware, though, that some things that are thought to never
    change sometimes evolve over time! For example, you could say that the rule about
    net price will always be stable; net price will always be the tax-free price multiplied
    by one plus the tax rate. Well, yes, until the government decides to apply multiple
    tax rates that apply differently to the sub-parts of a product. And if you have
    in your Product Information Management software some articles that are composed
    of a hardware part and an installation service, for example, you may end up with
    the first part taxed at 5.5% and the second part taxed at 20%. If the calculation
    has been written in a centralized function, this is not so bad. But if it has
    been duplicated in hundreds of places in the code (which can be the case with
    business rules that everyone assumes are constant and immutable), you will face
    some difficulty, not only because it will take ages for the change to be realized,
    but also because the one instance you forget will most likely be the one your
    most important customer uses.
  prefs: []
  type: TYPE_NORMAL
- en: In short, externalizing a business rule in a dedicated BRMS is 99.99% of the
    time overkill, and the cost is not justified. But you can go a very long way simply
    by putting the business rule in a function. And most of the time, the only difficulty
    there is simply realizing you are implementing one!
  prefs: []
  type: TYPE_NORMAL
- en: Examples of a BRMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say that you are indeed in this very particular 0.01% case where you actually
    could gain business value from implementing a dedicated BRMS. You would, thus,
    need a piece of software to do this for you, since, as you can imagine from the
    required secondary features, this kind of server is quite a complex piece of code.
    At the time of writing, there were only two serious contenders for BRMS servers
    – Drools (open source) and **Operational Decision** **Manager** (**ODM**).
  prefs: []
  type: TYPE_NORMAL
- en: The most used open source BRMS is Drools ([https://www.drools.org/](https://www.drools.org/)).
    It contains a core engine to calculate rules (including some functions such as
    rule chaining), which is sometimes called an inference engine, as it infers results
    from a data context and a set of rules. It also contains an application to create
    and manipulate rules (with a web editor). Drools is written in Java and can be
    interoperated with other platforms, but not natively.
  prefs: []
  type: TYPE_NORMAL
- en: ODM, from IBM, is a proprietary decision management system that was created
    to extract the important business rules from legacy COBOL code, in an effort to
    modernize the information systems on the z/OS platform. Although it can manipulate
    rules, it is mostly organized around the concepts of decisions on events.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the landscape is far from being as complicated as in other fields
    of IT – for example, Big Data, where a single book could not even describe all
    the software applications, platforms, and servers that are available, mostly all
    doing the same things while pretending to be radically different from their competitors.
    This has the merit of clarity – if you need to implement a BRMS in your information
    system and you want to reduce costs, Drools will be your first choice.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are some lesser-known alternatives. Lots of BPMN engines implement
    their own language for workflow decisions. Windows Workflow Foundation did so,
    but it is not supported anymore. PowerApps has some expression capability that
    can be used for business rule execution, but it can only be mutualized, so it
    is not a real BRMS system. Another solution, although it involves additional work,
    is to implement your own BRMS. If you do not need advanced features, you can build
    one quite quickly if you use an existing expression execution engine. Lots of
    scripting languages are available, and you can even use C# inside C# with expression
    trees, dynamic code generation, and other advanced, but still accessible, features.
  prefs: []
  type: TYPE_NORMAL
- en: In short, you have a choice of software, even if it is not as plethoric as in
    some other fields of IT. However, as you are certainly used to now, business/IT
    alignment is about reducing coupling, so the choice of software implementation
    is normally not such an important subject (in the sense it could harm the application
    evolution) as long as there is a standard norm, widely accepted specification,
    or even just an organization-wide pivotal format that can serve as a level of
    indirection between functional dependency and technical implementation. And the
    great news is that there is a standard for business rules, which is **Decision
    Modeling Notation** (**DMN**) 1.0\. This will be our topic of discussion in the
    next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The DMN standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DMN is a standard that defines decision trees and decision tables, which are
    the two main concepts concerning business rule implementation. In the upcoming
    sections, we will show how it works and how useful it can be.
  prefs: []
  type: TYPE_NORMAL
- en: The origin and principle of DMN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DMN standard is in version 1.0 and was published by the **OMG** (short for,
    **Object Management Group**) in September 2015\. At the time of writing, the latest
    validated version is numbered 1.3 and was published in February 2021\. Version
    1.5 has existed since June 2023, but it is considered a beta version currently.
    Thus, we will discuss only version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that OMG is also the consortium behind the BPMN 2.0 standard, which works
    in conjunction with the DMN standard. As expressed by OMG as soon as the first
    version was launched ([https://www.omg.org/spec/DMN/1.0/About-DMN](https://www.omg.org/spec/DMN/1.0/About-DMN)):
    “*DMN notation is designed to be useable alongside the standard BPMN business
    process notation.*” And there is a type of task that exists in BPMN that directly
    relates to business rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – A business rule task](img/B21293_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – A business rule task
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind this type of task is that there are complex business rules
    that decide how a BPMN business process should behave (mostly, which path in the
    gateways should be taken) and that a way to handle such a decision should be made
    possible. Indeed, imagine a (not so) complicated process like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2  – An example of a process with several rules](img/B21293_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – An example of a process with several rules
  prefs: []
  type: TYPE_NORMAL
- en: For now, it is not too bad because there are only three types of contracts.
    But this is typically the kind of scenario that has many chances to scale (never
    underestimate the creativity of salespersons and marketing people). What if there
    are ten types of contract in the future, maybe with a third criterion to take
    into account? The process will become more and more complex and, soon, illegible,
    which would be a big problem, since business processes should always remain a
    helpful tool for teams and, specifically, not something that makes it more complicated
    for them to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'DMN proposes a solution, which is to externalize the decision rules in a dedicated
    place, in order to free up the design of the process itself. In the previous example,
    we would externalize the decision table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – A decision table](img/B21293_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – A decision table
  prefs: []
  type: TYPE_NORMAL
- en: 'This would allow us to draw the process in a much simpler way, as follows (note
    the icon in the second task, which corresponds to the `Business` `rule` type):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – A simplified BPMN process](img/B21293_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – A simplified BPMN process
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, since there is no standardization of how data is collected in the different
    tasks of a BPMN process, there can be no standardized way either to call a DMN
    model. But it’s worth keeping informed about any updates to the norms at [https://www.omg.org/dmn/](https://www.omg.org/dmn/)
    since this is bound to change at some point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best part is that now that this logic has been decoupled from the business
    process itself, we could evolve to a much more complex definition of the type
    of contract, such as the following, without having to change anything on the process
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – An extended decision table](img/B21293_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – An extended decision table
  prefs: []
  type: TYPE_NORMAL
- en: This time, we also take into account the age of the author to issue some special
    contract that must be signed by the author’s parents. This is done by using a
    very simple expression here (`FEEL` expression language allows for much more sophisticated
    expressions (if you want to delve into more on this subject, [https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook](https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook)
    is a great starting point). You also may have spotted that the `AdditionalEdition`,
    since the result was common for any author as long as the book is a new edition
    of an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having these tables to externalize potentially complex rules is already a great
    advantage, but DMN also comes with a graphical way to represent the decision process
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – An example decision graph](img/B21293_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – An example decision graph
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the diagram is very simple, since we use only two inputs (author
    and book information) in order to create a decision (the type of contract), possibly
    using a “knowledge source,” which would be our referential of contracts, although
    we did not relate to any such use in the simple example previously. However, these
    diagrams could be much more advanced and show hierarchical decisions if necessary.
    We could imagine that the type of contract decided on is then itself used to decide
    the content of a customized contract, depending on the regions of diffusion of
    the work, and that sales statistics are used to decide on a proposed amount for
    the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – An extended decision graph](img/B21293_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – An extended decision graph
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an idea of the XML structure of a DML file, here is the (shortened)
    content corresponding to this first example above, where you will easily recognize
    the first part with the decision rules (starting at `<decision>`) and the second
    part corresponding to the diagram (starting at `<dmndi:DMNDI>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the graphs shown previously were designed using the great tool provided
    by Camunda at [https://demo.bpmn.io/dmn](https://demo.bpmn.io/dmn). Now that you
    have an introductory knowledge of what DMN is about, let’s see how we can put
    the standard to work.
  prefs: []
  type: TYPE_NORMAL
- en: Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Business Rules Execution System landscape is quite small. The go-to implementation
    of DMN has been and remains the Java open source project called Drools. Drools
    is a BRMS that supports its own rules language but also DMN, and since DMN is
    the standard, all servers using Drools are based on it. You can use Drools directly
    in your Java applications, or even with some bridges to other platforms. In particular,
    there has been a Drools .NET implementation, and some projects such as [https://github.com/adamecr/Common.DMN.Engine](https://github.com/adamecr/Common.DMN.Engine)
    can help with that, but the maintenance of such projects is questionable, and
    I’d rather show you another way that – in my opinion – is more suitable to what
    we are trying to achieve, which is an aligned and adaptable information system.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we will get closer to a service-oriented architecture by using a BRMS
    server that exposes the business rule runtime through REST APIs. Sure, the performance
    will not be as strong as with an embedded library but remember that, first, “premature
    optimization is the root of all evil” and, second, that most calls of the business
    rules are not executed with high frequency (and when they need to be, we will
    show at the end of the chapter how we can adapt). Kogito has already been cited
    in the previous chapter, but we did not show a complete example of BPMN with it
    because, as was explained, this would be overkill for most cases, especially our
    sample `DemoEditor` information system. What is interesting is that Kogito also
    supports DMN, and that is why we are going to use it here – or, rather, use JBPM,
    which is the product that Kogito is based on.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Kogito is the cloud-native derivative of JBPM, a product maintained
    under the JBoss umbrella. Since we are not going to deploy in the cloud, instead
    keeping a Docker-based deployment of our applications to satisfy either SaaS or
    on-premise conditions, we will simply use JBPM in the following example. Still,
    keep in mind for your needs that Kogito may be a better alternative, particularly
    since it offers some functions that could be compared to a light MDM, exposing
    entities directly by REST APIs generated dynamically. If you want to go in this
    direction and see how a fully integrated cloud-oriented approach suits you, you
    can start with Docker images of Kogito, available at [https://github.com/kiegroup/kogito-images](https://github.com/kiegroup/kogito-images).
  prefs: []
  type: TYPE_NORMAL
- en: The JBoss JBPM server that we are going to exploit is an all-in-one application,
    providing a frontend and a backend to design and operate BPMN workflows with DMN-based
    business rules. It works with Maven projects containing some Java code for the
    unit tests, and possibly for the exposition of the entities, but it can operate
    with simple standard files in DMN for our example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explain how to operate a sample business rule engine
    in JBPM 7.74, using the Drools engine and a DMN definition of two business decisions
    with several parameters. For more information about how this works precisely,
    head over to [https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/](https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/).
    The reason why we use a sample provided by JBoss is that designing from scratch
    an example on the subject of `DemoEditor` would take up a whole chapter. In addition,
    it would be a completely artificial exercise, since a DMN rule engine, just like
    a BPMN engine in the previous chapter, would simply be overkill for our functional
    needs. It is essential that I respect the principal rule I have been repeating
    over and over since the beginning of this book, which is that the technical aspects
    should be completely defined by the functional needs. Although I – like most of
    us who are passionate about technology – would love to integrate a full-blown
    Kogito server in our sample information system, the truth is that it would not
    be suitable for our needs. The implementation of the business workflows and most
    business rules will simply be in dedicated .NET services. Only a particular case
    of business rules would be treated with a dedicated external service that strongly
    resembles a BRMS, namely the authorization rules. But I am anticipating the last
    section of this chapter, and for now, we are going to show how we can take advantage
    of a DMN-based BRMS in a business/IT-aligned context, using JBPM.
  prefs: []
  type: TYPE_NORMAL
- en: An example of DMN use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple exercises such as the one that follows are really where Docker stands
    out because it will save us the hassle of installing Java and Maven, getting the
    right dependencies, updating versions, and so on. Provided you have Docker installed
    on your machine (and if this is not the case, you really should, as this tool
    is now part of your basic toolset, just like a web browser and a text editor),
    you can simply enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `latest` tag, at the time of writing, was the `7.74.1.Final` version.
    It is generally recommended to use the `latest` tag as much as possible, but if
    you ever encounter a functional problem replaying the example, give it a try using
    this precise version, even if it is not the latest anymore. The first Docker command
    will start a container based on the image containing everything that is needed
    to design, build, test, and deploy projects, including the BPMN and DMN assets.
    This is where we will manipulate the DMN model. If you want to get some more information
    about this image, the reference page is [https://quay.io/repository/kiegroup/business-central-workbench-showcase](https://quay.io/repository/kiegroup/business-central-workbench-showcase).
    The second Docker command runs a container onto which the project will be deployed
    and that will act as a separate business rule execution engine, or a simple runtime
    if you prefer to think of it that way. The reference page for this second image
    is [https://quay.io/repository/kiegroup/kie-server-showcase](https://quay.io/repository/kiegroup/kie-server-showcase).
  prefs: []
  type: TYPE_NORMAL
- en: Once everything has started (you should allow for some time – up to one minute
    – for the completion of the startup routine), you can access the console by navigating
    to `http://localhost:8080/business-central`, where you will be able to connect
    with the default credentials, `admin`/`admin` (the documentation cited previously
    provides other credentials for users with different authorization profiles, as
    well as how to set up production-ready authorization).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The JPBM login page](img/B21293_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The JPBM login page
  prefs: []
  type: TYPE_NORMAL
- en: Once connected, you will be presented with the welcome page interface, which
    you can return to at any time by clicking on **Business Central**, or the home
    icon in the top-left part of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The JPBM welcome page](img/B21293_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – The JPBM welcome page
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Design** section, click on **Projects**. This will bring you to an
    interface in which you can manage your JBPM projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – A list of JPBM spaces](img/B21293_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – A list of JPBM spaces
  prefs: []
  type: TYPE_NORMAL
- en: Spaces are used to organize work and separate groups of projects from one another.
    In this simple tryout of the technology, simply select the existing **MySpace**
    space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – A JPBM space without any project](img/B21293_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – A JPBM space without any project
  prefs: []
  type: TYPE_NORMAL
- en: 'The space just created is, of course, empty for now. We are going to use one
    of the embedded examples to illustrate how JBPMN works and what we are particularly
    interested in right now, namely the DMN rules engine. To do so, click on **Try
    Samples**, which will bring you to the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Choosing sample projects](img/B21293_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Choosing sample projects
  prefs: []
  type: TYPE_NORMAL
- en: 'There, select the **Traffic_Violation** sample project and click on **OK**.
    You should receive a message stating that the project has been correctly imported,
    and you will land on a page that shows the assets contained by the sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Assets of the traffic violation JBPM sample](img/B21293_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Assets of the traffic violation JBPM sample
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the asset that interests us most is the DMN model. Click on the
    **Traffic Violation** asset to analyze it, and you will be led to the following
    interface, which shows the main part of the DMN model, the decision graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – A sample DMN decision graph](img/B21293_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – A sample DMN decision graph
  prefs: []
  type: TYPE_NORMAL
- en: If you have a driver’s license, the understanding of this example should be
    self-explanatory – the violation of the speed limit provides data to calculate
    the associated fine. Then, depending on the fine and additional context on the
    driver, another decision is taken, regarding whether a suspension of the driver’s
    license should be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now click on the menu on the left, on the **Decision Table** entry of
    the **Fine** section, you will be shown the following table that describes the
    conditions of application of the decision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – A sample DMN decision table](img/B21293_12_141.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – A sample DMN decision table
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the project by using the breadcrumbs menu at the top, and then
    click **Deploy** in the top menu that appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – The JBPM build and deploy menu](img/B21293_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – The JBPM build and deploy menu
  prefs: []
  type: TYPE_NORMAL
- en: 'After a bit of time, you should see a message stating that the build is successful,
    and then a second one, like the one shown in the following figure, that explains
    that everything is now ready to exploit the decision engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – The JBPM deployment success notification](img/B21293_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – The JBPM deployment success notification
  prefs: []
  type: TYPE_NORMAL
- en: 'If you care to take a look at the deployment results, you can activate the
    **Menu**/**Execution Servers** command and watch how servers are configured and
    deployment units are organized on them. You can then start and stop execution
    servers from this console, or even remove deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – The JBPM servers management interface](img/B21293_12_18.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 – The JBPM servers management interface
  prefs: []
  type: TYPE_NORMAL
- en: Since everything is now set up and deployed, we are able to exploit the business
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the business rule runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking how effective the engine is, is simply a matter of calling a REST
    API that has been exposed dynamically for us to consume. In order to do so, and
    since the engine is (logically) exposed through a `POST` verb, we need a tool
    a bit more advanced than a simple web browser, such as Postman. To access the
    API, you will have to use the port number that was associated with the second
    Docker container we ran – in our example, `8180`. The rest of the URL is composed
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/kie-server` corresponds to the application server of the rules execution
    engine (or **BRE** for **Business** **Rules Execution**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/services/rest` indicates that we will be accessing the REST APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/server/containers` is linked to the fact that BRE servers are exposed through
    containers, each deployment unit being separate from the others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/traffic-violation_1.0.0-SNAPSHOT` is the identity of the project that we
    have chosen to deploy in this unit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dmn` corresponds to the resource we are interested in this project, namely
    the decision management system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The content of the body should be adjusted to `raw`/`json` and contain the
    following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`model-namespace` corresponds to the unique identifier of the project, and
    `dmn-context` indicates the values that should be fed to the rules engine for
    execution. The interface should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – A sample Postman call](img/B21293_12_19.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – A sample Postman call
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this to work, you need to go to the `kieserver` as the username
    and `kieserver1!` as the password (these are the default values that, of course,
    would change if working in production):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Postman authentication settings](img/B21293_12_20.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – Postman authentication settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after sending the message to the server, the complete response is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What interests us in particular is how `dmn-context` has been completed, with
    the results of the decision. In our case, the fine will be 3 points and 500 units
    of money, and the result of the driver’s license suspension decision will be negative.
    But change `Actual Speed` to `135` in the body of the request, send it again,
    and watch the impact on the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The engine is, thus, ready to be used in any information system that can handle
    REST APIs (which is any platform on earth, except for a few very exotic exceptions).
    Note there is also everything you need inside the JBPM platform to perform tests
    on the decisions that have been built. A test with Postman was preferred because
    it is closer to how the BRE would be exploited by another application, but if
    you click on the `Violation Scenarios` asset, you will be brought to this nice
    interface, where you can execute preliminary tests in order to make sure everything
    works fine before deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21 – A JBPM-integrated automatic test interface](img/B21293_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – A JBPM-integrated automatic test interface
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you want to understand better how to create your own project (which
    is outside of the scope of this book, where we focus only on how to use existing
    projects to correctly structure an information system), the best starting point
    is the code source of the example used previously, which can be found at [https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation](https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation).
    You can also follow the detailed instructions on how to build this project from
    the console, as explained at [https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services](https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will complete this example with a very simple (thanks to Docker)
    clean-out procedure (be aware that this will erase all data associated with the
    exercise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Everything should be reverted to the state the test machine was in before creating
    this example, which leaves us with the conclusion of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we showed what a Business Rules Management System does, how
    useful it can be in an information system, and how we can implement one, starting
    with a functional example and demonstrating afterward another example relating
    to authorizations, which are one of the most used sets of business rules in software
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Just like BPMN engines, BRMS engines are not used very often. In fact, business
    rules are – in the great majority of cases – implemented in code expressions or
    compiled into applications. This is absolutely normal because a BRMS represents
    an important investment, and implementing such complex applications really needs
    a strong business case, where business rules change very frequently, they are
    associated with high regulatory or marketing constraints (such as the necessity
    to trace all business rules and their changes), there is capacity to simulate
    the effects of new versions of sets of business rules, and so on. It is clear,
    then, that this approach is currently limited to very rare contexts. Things may,
    of course, change in the future, with the longed-for industrialization of information
    system designs, but currently, BPMNs and BRMSs are efforts that are almost always
    overkill.
  prefs: []
  type: TYPE_NORMAL
- en: And since two of the three parts of the ideal system are not worth using by
    most organizations, that means that this system remains utopic. Moreover, even
    a centralized MDM approach is complicated. The MDM practices per se are applicable
    to every business domain, so there is no problem with data referential – they
    are not very complicated to set up, as we will see in practice in [*Chapter 16*](B21293_16.xhtml#_idTextAnchor588)
    and the upcoming chapters and they bring lots of business value and advantages.
    However, the ideal system aims for a generic MDM, dynamically adjusting to every
    entity in the business context of an application. This additional sophistication
    is also out of context for now, although static code generation for data referential
    is becoming a viable option, as will be shown at the end of [*Chapter 19*](B21293_19.xhtml#_idTextAnchor634).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we have shown that the three responsibilities of an ideal information
    system are, ultimately, quite interrelated with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: MDM uses business rules in its validation of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BRMS needs data from MDM to apply business rules and decide their output value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BPMN serves mainly as a collector of data to feed MDM, while also consuming
    data from MDM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BPMN also uses business rules to know where to go in the different gateways
    (and sometimes to calculate some additional data during a given task)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this proves that, technically, this assembly of three generic servers for
    MDM, BPM, and BRMS is not so feasible, and neither achieves a perfect decoupling.
    So, why did we bother in [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164) and the
    last three chapters to discuss such an ideal system? Again, the answer lies in
    the business/IT alignment. The ideal system is not something that can be realized
    in practice in information systems today (and certainly for at least a few more
    decades), but it has the great advantage of forcing an architect to think in terms
    of three generic, always applicable, functional responsibilities. Even if you
    use a unique software application, knowing how to separate the data management,
    the business rules management, and the business process execution provides a great
    step toward decoupling your information system (which is not achieved at all with
    *n*-tier architecture, for example). As you will see in the upcoming chapters,
    constructing an information system with these principles in mind will help us
    achieve a very complex goal, which is to be able to modify important functional
    rules and behaviors very easily, in most cases without any significant impact
    on the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, as explained in the introduction, we will show a particular
    use case – yet very important application – of business rules management, which
    is using rules to determine and enforce authorization in a software application.
    Although we have shown a few examples in this chapter, the most complete description
    of how to use a BRMS will happen in the next chapter, by applying dedicated authorization
    management policies to our good old sample information system.
  prefs: []
  type: TYPE_NORMAL
