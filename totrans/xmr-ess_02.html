<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Demystifying Xamarin.iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Demystifying Xamarin.iOS</h1></div></div></div><p>Now that we have a little background on Mono and Xamarin, let's dive in and see how Xamarin.iOS works. This chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Xamarin.iOS and AOT compilation</li><li class="listitem" style="list-style-type: disc">Mono assemblies</li><li class="listitem" style="list-style-type: disc">Xamarin.iOS bindings</li><li class="listitem" style="list-style-type: disc">Memory management for Xamarin.iOS apps</li><li class="listitem" style="list-style-type: disc">XIB and storyboard code generation</li><li class="listitem" style="list-style-type: disc">Xamarin.iOS Designer</li></ul></div><div class="section" title="Xamarin.iOS and Ahead-of-Time compilation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Xamarin.iOS and Ahead-of-Time compilation</h1></div></div></div><p>Unlike <a class="indexterm" id="id75"/>most Mono or .NET apps, Xamarin.iOS apps are statically compiled, where compilation is accomplished through the Mono <span class="strong"><strong>Ahead-of-Time</strong></span> (<span class="strong"><strong>AOT</strong></span>) compilation facilities. AOT is used to comply with Apple's requirements, for example, the use of iOS apps to <a class="indexterm" id="id76"/>compile, refraining from Just-in-Time compilation facilities, or running on virtual machines.</p><p>Use of AOT compilation comes with some limitations regarding the C# language. These limitations will be easier to discuss after discussing the approach to binding iOS to C# and .NET. This is why we have pushed this topic to the <span class="emphasis"><em>Limitations of using the AOT compilation</em></span> section in the later part of this chapter.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Additional <a class="indexterm" id="id77"/>information about Mono AOT compilation can be found at the following link:</p><p>
<a class="ulink" href="http://www.mono-project.com/AOT#Full_AOT">http://www.mono-project.com/AOT#Full_AOT</a>
</p></div></div></div></div>
<div class="section" title="Understanding Mono assemblies"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Understanding Mono assemblies</h1></div></div></div><p>Xamarin.iOS <a class="indexterm" id="id78"/>ships with an extended subset of Silverlight and desktop .NET assemblies. These libraries provide the .NET runtime library support for developers, including namespaces such as <code class="literal">System.IO</code> and <code class="literal">System.Threading</code>.</p><p>Xamarin.iOS is not binary compatible with assemblies compiled for a different profile, meaning your <a class="indexterm" id="id79"/>code must be recompiled to generate assemblies that specifically target the Xamarin.iOS profile. This is essentially the same thing you have to do if you are targeting other profiles such as Silverlight or .NET 4.5.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>For a complete list of assemblies that ship with Xamarin.iOS, please refer to the following link:</p><p>
<a class="ulink" href="http://docs.xamarin.com/guides/ios/under_the_hood/assemblies">http://docs.xamarin.com/guides/ios/under_the_hood/assemblies</a>
</p></div></div></div>
<div class="section" title="Xamarin.iOS bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Xamarin.iOS bindings</h1></div></div></div><p>In this section, you will discover one of the main sources of power behind Xamarin.iOS. This ships with a <a class="indexterm" id="id80"/>set of binding libraries that provides support for iOS development. What will follow are some details into each of these bindings.</p><div class="section" title="The design principles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The design principles</h2></div></div></div><p>A number of <a class="indexterm" id="id81"/>goals or design principles guided the development of the binding libraries. These principles are critical to make C# developers productive in an iOS development. The following represents a summary of the design principles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Allow developers to subclass Objective-C classes in the same way as they subclass other .NET classes</li><li class="listitem" style="list-style-type: disc">Provide a way to call arbitrary Objective-C libraries</li><li class="listitem" style="list-style-type: disc">Transform the common Objective-C tasks into something much easier while making the difficult Objective-C tasks possible to complete</li><li class="listitem" style="list-style-type: disc">Expose Objective-C properties as C# properties as well as expose a strongly typed API</li><li class="listitem" style="list-style-type: disc">Use Native C# types in lieu of Objective-C types when possible</li><li class="listitem" style="list-style-type: disc">Support both C# events and Objective-C Delegation as well as expose C# delegates to Object-C APIs<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>This section has provided you with a general idea of the principles to bear in mind. If you are curious to find a complete discussion, you can refer to the official <a class="indexterm" id="id82"/>documentation available at the following link:</p><p>
<a class="ulink" href="http://docs.xamarin.com/guides/ios/under_the_hood/api_design/">http://docs.xamarin.com/guides/ios/under_the_hood/api_design/</a>
</p></div></div></li></ul></div></div><div class="section" title="C# types and type safety"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>C# types and type safety</h2></div></div></div><p>The Xamarin.iOS <a class="indexterm" id="id83"/>bindings are designed to use types familiar to C# developers and to increase type safety when possible.</p><p>For example, the <a class="indexterm" id="id84"/>API uses C# string instead of <code class="literal">NSString</code>, meaning the text property in <code class="literal">UILabel</code> is defined in the iOS SDK in the following manner:</p><div class="informalexample"><pre class="programlisting">@property(nonatomic, copy) NSString *text</pre></div><p>Also, this is exposed in Xamarin.iOS as follows:</p><div class="informalexample"><pre class="programlisting">public string Text { get; set; }</pre></div><p>Behind the scenes, the framework takes care of marshaling C# types to the appropriate type expected by the iOS SDK.</p><p>Another example is the treatment of <code class="literal">NSArray</code>. Rather than exposing weakly typed arrays, Xamarin.iOS exposes strongly typed arrays to the following Object-C property on <code class="literal">UIView</code>:</p><div class="informalexample"><pre class="programlisting">@property(nonatomic, readonly, copy) NSArray *subviews</pre></div><p>This is exposed as a C# property in the following manner:</p><div class="informalexample"><pre class="programlisting">UIView[] Subviews { get; }</pre></div></div><div class="section" title="Use of inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Use of inheritance</h2></div></div></div><p>Xamarin.iOS allows <a class="indexterm" id="id85"/>you to extend any Objective-C type <a class="indexterm" id="id86"/>in the same manner you will extend any C# type and features like calling "base" from overridden methods work as predicted.</p></div><div class="section" title="Mapping Objective-C delegates"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Mapping Objective-C delegates</h2></div></div></div><p>In Objective-C, the delegation design pattern is used extensively to allocate responsibility to various objects. Xamarin faced a few inherent challenges in mapping iOS delegates to C# and .NET.</p><p>In Objective-C, delegates <a class="indexterm" id="id87"/>in Objective-C are implemented as objects that respond to a set of methods. This set of methods is generally defined as a protocol, and although it resembles a C# interface, there is in fact a significant difference between a C# interface and an Objective-C protocol:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In C#, an object that <span class="emphasis"><em>implements</em></span> an interface is required to implement all the methods defined on the interface</li><li class="listitem" style="list-style-type: disc">On the other hand, objects in Objective-C that <span class="emphasis"><em>adopt</em></span> a protocol are not required to implement the methods of the protocol for the given circumstance</li></ul></div><p>Another challenge is that, in many ways, traditional .NET frameworks have relied more heavily on events to accomplish similar capabilities, and the event model is much more familiar to .NET developers.</p><p>With these differences in mind and hoping to make Xamarin.iOS as intuitive to C# developers as possible without compromising the iOS architecture, Xamarin.iOS provides four different ways to implement delegate functionality:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Via .NET events</li><li class="listitem" style="list-style-type: disc">Via .NET properties</li><li class="listitem" style="list-style-type: disc">Via strongly typed delegates</li><li class="listitem" style="list-style-type: disc">Via weakly typed delegates</li></ul></div><div class="section" title="Via .NET events"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Via .NET events</h3></div></div></div><p>For many types, Xamarin.iOS automatically creates an appropriate delegate and forwards delegate calls to <a class="indexterm" id="id88"/>corresponding .NET events. This makes the development experience very natural to C# and .NET developers.</p><p>
<code class="literal">UIWebView</code> is a good <a class="indexterm" id="id89"/>example of this. iOS defines <code class="literal">UIWebViewDelegate</code>, which contains a number of methods that a <code class="literal">UIWebView</code> will forward if a delegate is assigned that includes the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">webViewDidStartLoad</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">webViewDidFinishLoad</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">webView:didFailLoadWithError</code></li></ul></div><p>What we find in the <a class="indexterm" id="id90"/>Xamarin.iOS class <code class="literal">MonoTouch.UIKit.UIWebView</code> are <a class="indexterm" id="id91"/>three events that correspond to the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LoadStarted</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadFinished</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadError</code></li></ul></div></div><div class="section" title="Via .NET properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Via .NET properties</h3></div></div></div><p>Although events have <a class="indexterm" id="id92"/>the advantage of having multiple subscribers, they come with their own limitations. Specifically, this could be where <a class="indexterm" id="id93"/>events cannot have a return type. In situations where a delegate method must return a value, delegate properties are used. The following example shows you how to use a delegate property for <code class="literal">UITextField</code>. In this example, an anonymous method is assigned to the delegate property <code class="literal">ShouldReturn</code> on <code class="literal">UITextField</code>:</p><div class="informalexample"><pre class="programlisting">firstNameTextField.ShouldReturn = delegate (textfield)
{
      textfield.ResignFirstResponder ();
      return true;
}</pre></div></div><div class="section" title="Via strongly typed delegates"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Via strongly typed delegates</h3></div></div></div><p>If events or delegate <a class="indexterm" id="id94"/>properties have not been provided or if you would just rather work with a delegate, you will be pleased to hear that Xamarin.iOS provides a set of .NET classes that correspond to each iOS <a class="indexterm" id="id95"/>delegate. These classes contain a definition for each method defined on the corresponding protocol. Methods that require implementations are defined as abstract and methods that are optional are defined as virtual. To use one of these delegates, a developer simply creates a new class that inherits from the desired delegate and overrides the methods that need to be implemented.</p><p>For an example of using strongly typed delegate, we will turn to <code class="literal">UITableViewDataSource</code>. This is the protocol iOS defines to populate a <code class="literal">UITableView</code> instance. The following example demonstrates a data source that can be used to populate <code class="literal">UITableView</code> with phone numbers:</p><div class="informalexample"><pre class="programlisting">public class PhoneDataSource : UITableViewDataSource
{
    List&lt;string&gt;_phoneList;
    public PhoneDataSource (List&lt;string&gt; phoneList) {
    _phoneList = phoneList;
}
public override int RowsInSection(UITableView
tableView, int section)
{
  return _phoneList.Count;
}
public override UITableViewCell GetCell(UITableView
  tableView, NSIndexPath indexPath) {
      ... // create and populate UITableViewCell
      return cell;
}
}</pre></div><p>Now that we have created the delegate, we need to assign it to a <code class="literal">UITableView</code> instance. The property for the <code class="literal">UITableViewDataSource</code> delegate is named <code class="literal">Source</code> with the following code that <a class="indexterm" id="id96"/>shows you how to <a class="indexterm" id="id97"/>make the assignment:</p><div class="informalexample"><pre class="programlisting">phoneTableView.Source = new PhoneDataSource(phoneList);</pre></div></div><div class="section" title="Via weakly typed delegates"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Via weakly typed delegates</h3></div></div></div><p>Lastly, Xamarin.iOS provides you with a way to use weakly typed delegates. Unfortunately, this method requires a bit more work for the developer. </p><p>In <a class="indexterm" id="id98"/>Xamarin.iOS, weak delegates can be created using any class that inherits from <code class="literal">NSObject</code>. When creating a weak <a class="indexterm" id="id99"/>delegate, you are being handed the responsibility to properly decorate your class using the <code class="literal">Export</code> attribute, which effectively teaches iOS how the methods are mapped. The following example shows a weak delegate with the appropriate attribute specifications:</p><div class="informalexample"><pre class="programlisting">public class WeakPhoneDataSource : NSObject
{
...
[Export ("tableView:numberOfRowsInSection:")]
public override int RowsInSection(UITableView
      tableView, int section)
  {
    ...
  }
[Export ("tableView:cellForRowAtIndexPath:")]
  public override UITableViewCell GetCell(UITableView
      tableView, NSIndexPath indexPath) {
...
  }
}</pre></div><p>The last few steps assign the weak delegate to a <code class="literal">UITableView</code> instance. By Xamarin.iOS convention, weak delegate property names always begin with <code class="literal">Weak</code>. The following example shows you how to assign the weak data source delegate:</p><div class="informalexample"><pre class="programlisting">phoneTableView.WeakSource =
    new WeakPhoneDataSource(...);</pre></div><p>Once a <a class="indexterm" id="id100"/>weak delegate has been <a class="indexterm" id="id101"/>assigned, any assigned strong delegates will cease to receive calls. </p></div></div></div>
<div class="section" title="Creating binding libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Creating binding libraries</h1></div></div></div><p>There might be <a class="indexterm" id="id102"/>times when you are required to create your own binding library for an Objective-C library that is not delivered as part of Xamarin.iOS and can't be found in the Xamarin component store. Xamarin provides a great deal of guidance to create bindings as well as an automated tool to help with some of the drudgery work. The following links provide guidance to create custom bindings for Objective-C libraries:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type of information</p>
</th><th style="text-align: left" valign="bottom">
<p>URL to access it</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>General binding information</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/">http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Use of the Objective Sharpie automation tool</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/">http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Binding types reference</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/">http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/</a>
</p>
</td></tr></tbody></table></div></div>
<div class="section" title="Memory management"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Memory management</h1></div></div></div><p>When it <a class="indexterm" id="id103"/>comes to releasing resources, Xamarin.iOS has this covered for <a class="indexterm" id="id104"/>you through <span class="strong"><strong>garbage collector</strong></span> (<span class="strong"><strong>GC</strong></span>), which does this on your behalf. On top of this, all objects that are derived from <code class="literal">NSObject</code> utilize the <code class="literal">System.IDisposable</code> interface so that developers have some control over it when the memory is released.</p><p>
<code class="literal">NSObject</code> not only implements the <code class="literal">IDisposable</code> interface, but also follows the .NET dispose pattern. The <code class="literal">IDisposable</code> interface only requires a single method to be implemented, <code class="literal">Dispose()</code>. The dispose pattern requires an additional method to be implemented, <code class="literal">Dispose(bool disposing)</code>. The disposing parameter indicates whether the method is being called from the <code class="literal">Dispose()</code> method, in which case the value is <code class="literal">true</code>, or from the <code class="literal">Finalize</code> method, in which case the value is <code class="literal">false</code>.</p><p>The disposing parameter is intended to be used to determine if managed objects should be freed. If the value is <code class="literal">true</code>, the managed objects should be released. Unmanaged objects should be released regardless of the value. The following code demonstrates what should be present in the <code class="literal">Dispose()</code> method:</p><div class="informalexample"><pre class="programlisting">public void Dispose ()
{
  this.Dispose (true);
  GC.SuppressFinalize (this);
}</pre></div><p>Take note of the call to <code class="literal">Dispose(bool disposing)</code> with a value of <code class="literal">true</code>. Conveniently, the <code class="literal">Dispose()</code> method is implemented for you by the framework as a virtual method <a class="indexterm" id="id105"/>on <code class="literal">NSObject</code>. The following code demonstrates an implementation of the <code class="literal">Dispose(bool disposing)</code> method:</p><div class="informalexample"><pre class="programlisting">class MyViewController : UIViewController {

  UIImagemyImage;

  . . .   

  public override void Dispose (bool disposing)
  {
    if (disposing){
      if (myImage!= null) {
        myImage.Dispose ();
        myImage = null;
      }
    }

    // Free unmanaged objects regardless of value.

    base.Dispose (disposing)

  }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Again, notice the call to <code class="literal">base.Dispose(disposing)</code>. This call is very important as it deals with resources managed within the framework itself.</p></div></div><p>Why the fuss? Why not clean up everything in <code class="literal">Dispose()</code>? The answer lies in the garbage collector. The order in which the garbage collector destroys objects is not defined and thus is unpredictable and subject to change. The .NET dispose pattern helps prevent the finalizer from calling <code class="literal">Dispose()</code> on objects that have already been disposed of.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>You can read more about the .NET dispose pattern at the following link:</p><p>
<a class="ulink" href="http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx">http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</a>
</p></div></div><p>Disposing of a managed object renders it useless. Even though references to the object might still exist, you <a class="indexterm" id="id106"/>need to structure your software with the assumption that an object that has been disposed of is no longer valid. In some cases, an <code class="literal">ObjectDisposedException</code> will be thrown when accessing methods of a disposed object.</p><div class="section" title="Disposing of objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Disposing of objects</h2></div></div></div><p>Anytime you have an <a class="indexterm" id="id107"/>object that is holding substantial resources and is no longer required, call the <code class="literal">Dispose()</code> method. The GC is convenient and fairly sophisticated but might not have a complete picture as to the amount of resources a specific object has allocated, particularly if those resources are associated with unmanaged objects.</p></div><div class="section" title="Keeping objects around"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Keeping objects around</h2></div></div></div><p>To prevent an object <a class="indexterm" id="id108"/>from being destroyed, you simply need to be sure there is at least one reference to the object maintained. Once an object's reference count reaches <code class="literal">0</code>, the GC is all happy to call the <code class="literal">Dispose()</code> method on it and the object is no longer usable.</p></div></div>
<div class="section" title="Limitations of using the AOT compilation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Limitations of using the AOT compilation</h1></div></div></div><p>As we <a class="indexterm" id="id109"/>mentioned earlier in this chapter, some limitations come with the use of the AOT compilation. The following sections outline the limitations imposed by Xamarin.iOS due to the use of the AOT compilation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No generic subclasses of <code class="literal">NSObject</code> are allowed. The following will not be allowed since <code class="literal">UIViewController</code> is a subclass of <code class="literal">NSObject</code>:<div class="informalexample"><pre class="programlisting">class MainViewController&lt;T&gt; : UIViewController {
...
}</pre></div></li><li class="listitem" style="list-style-type: disc">P/Invoke is not supported in generic classes, so the following is not supported in Xamarin.iOS:<div class="informalexample"><pre class="programlisting">class MyGenericType&lt;T&gt; {
    [DllImport ("System")]
    public static extern int getpid ();
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Property.SetInfo()</code> on <code class="literal">a Nullable&lt;T&gt; Type</code> is not supported. Using Reflection's <code class="literal">Property.SetInfo()</code> to set the value on a <code class="literal">Nullable&lt;T&gt;</code> is not currently supported.</li><li class="listitem" style="list-style-type: disc">No dynamic code generation. The iOS kernel prevents an app from generating code dynamically and thus Xamarin.iOS imposes the following limitations:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Neither <code class="literal">System.Reflection.Emit</code> nor <code class="literal">System.Runtime.Remoting</code> is available</li><li class="listitem" style="list-style-type: disc">No support to create types dynamically</li><li class="listitem" style="list-style-type: disc">Reverse callbacks must be registered with the runtime at compile time</li></ul></div></li><li class="listitem" style="list-style-type: disc">There is a further limitation for reverse callbacks. In Mono, you can pass C# delegates to unmanaged code rather than passing a function pointer. Use of AOT imposes some <a class="indexterm" id="id110"/>limitations on this:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Callback methods must be flagged with the Mono attribute <code class="literal">MonoPInvokeCallbackAttribute</code></li><li class="listitem" style="list-style-type: disc">Callback methods must be static; there is no support for instance methods</li></ul></div></li></ul></div><div class="section" title="Runtime features disabled"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Runtime features disabled</h2></div></div></div><p>The following <a class="indexterm" id="id111"/>features are disabled in Xamarin.iOS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Profiler</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Reflection.Emit</code> functionality</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Reflection.Emit.Save</code> functionality</li><li class="listitem" style="list-style-type: disc">COM bindings</li><li class="listitem" style="list-style-type: disc">The JIT engine</li><li class="listitem" style="list-style-type: disc">The metadata verifier (since there is no JIT)</li></ul></div></div></div>
<div class="section" title="Generating code for XIB and storyboard files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Generating code for XIB and storyboard files</h1></div></div></div><p>The Apple <a class="indexterm" id="id112"/>Interface Builder is a designer built into Xcode that allows for visual design of a user interface. The use of the Interface Builder is optional; user interfaces can be completely built using iOS APIs. The definitions created by the <a class="indexterm" id="id113"/>Interface Builder are saved in either XIB or storyboard files with the difference being that the XIB files tend to contain a single view. Storyboards, on the other hand, contain a set of views along with the transitions or segues between the views.</p><p>Xamarin <a class="indexterm" id="id114"/>Studio works in conjunction with Xcode to support the UI <a class="indexterm" id="id115"/>design. When a storyboard or XIB file is double-clicked on within Xamarin Studio, Xcode is launched to facilitate the design of the UI. Once the changes are saved in Xcode and you switched back to Xamarin Studio, C# code is generated to support the UI design captured in Xcode. The following sections describe this process in more detail.</p><div class="section" title="Generated classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Generated classes</h2></div></div></div><p>Xamarin Studio <a class="indexterm" id="id116"/>generates two files for each custom class found in an XIB file or a storyboard file, a designer file, and a non-designer file. For instance, a view controller named <code class="literal">LoginViewController</code> will cause the following files to be generated:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LoginViewController.cs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LoginViewController.designer.cs</code></li></ul></div><p>These files are generated after the changes have been saved in Xcode, and Xamarin Studio gains focus.</p><div class="section" title="Designer files"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Designer files</h3></div></div></div><p>Designer files <a class="indexterm" id="id117"/>contain a partial class definition for custom classes found in the XIB or storyboard file with properties being created for outlets and partial methods for the actions that are found. The following example is for a view controller with <a class="indexterm" id="id118"/>two <code class="literal">UITextField</code> controls and a single <code class="literal">UIButton</code> control:</p><div class="informalexample"><pre class="programlisting">[Register ("LoginViewController")]
partial class LoginViewController
{
  [Outlet]
  MonoTouch.UIKit.UITextField textPassword { get; set; }
  [Outlet]
  MonoTouch.UIKit.UITextField textUserId { get; set; }
  [Action ("btnLoginClicked:")]
  partial void btnLoginClicked
         (MonoTouch.Foundation.NSObject sender);
void ReleaseDesignerOutlets ()
{
if (textUserId != null) {
      textUserId.Dispose ();
textUserId = null;
}
if (textPassword != null) {
textPassword.Dispose ();
textPassword = null;
}
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Designer files are automatically updated once an XIB or storyboard file has been altered. As a result, they should not be modified manually because any changes will be lost once Xamarin Studio updates them.</p></div></div></div><div class="section" title="Non-designer files"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Non-designer files</h3></div></div></div><p>Designer files are <a class="indexterm" id="id119"/>used alone but in conjunction with a non-designer file. The non-designer file contains a partial class specification, which completes the class <a class="indexterm" id="id120"/>defined in its corresponding designer file. The non-designer files identify the base class, defines constructors that are required to instantiate the class, and provides a place to implement functionality either by providing implementations for partial methods or by overriding virtual methods on the base class. The following example shows a non-designer file with an override and partial method implementation:</p><div class="informalexample"><pre class="programlisting">public partial class LoginViewController : UIViewController
{
  public LoginViewController (IntPtr handle) :
    base (handle)
{
}
  public override void ViewDidLoad ()
  {
    base.ViewDidLoad ();
    // logic to perform when view has loaded...
  }
partial void btnLoginClicked (NSObject sender)
{
// logic for login goes here...
}
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Note that the partial method implementation in this file is for a method generated in the designer file in response to find an action defined in the corresponding XIB or storyboard files.</p></div></div><p>Changes made to the non-designer file will not be lost as these files are only created the first time Xamarin Studio encounters the new custom class and are not subsequently updated.</p></div><div class="section" title="Outlets properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Outlets properties</h3></div></div></div><p>Designer classes <a class="indexterm" id="id121"/>contain private properties, which correspond to outlets defined on the custom class that can then be used from the <code class="literal">CodeBehind</code> class found in the non-designer file. If you need to make these properties public, all you need to do is add the accessor properties to the non-designer file similar to how you will for any given private field.</p></div><div class="section" title="Action properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Action properties</h3></div></div></div><p>Designer files have the <a class="indexterm" id="id122"/>property of containing partial methods that are associated to all of the actions defined on the custom class. You should note that these methods do not contain an implementation and they serve a dual purpose:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Their first purpose <a class="indexterm" id="id123"/>is that when you insert partial into the class body of the non-designer file, Xamarin Studio will offer to autocomplete the signatures of all non-implemented partial methods, which allows developers to implement logic for actions.</li><li class="listitem" style="list-style-type: disc">Their other purpose is that their signatures have an attribute applied to them, exposing them to the Objective-C world. Consequently, they can be invoked once the corresponding action is triggered in iOS.</li></ul></div></div></div></div>
<div class="section" title="Xamarin.iOS Designer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Xamarin.iOS Designer</h1></div></div></div><p>Xamarin <a class="indexterm" id="id124"/>provides an alternative to Apple's Interface Builder. Xamarin.iOS Designer is an add-in for the Xamarin Studio environment that adds full drag-and-drop user interface design for iOS storyboards all from within Xamarin Studio. Xamarin.iOS Designer provides the following key features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Compatible storyboard format</strong></span>: As you will expect, Xamarin.iOS Designer creates storyboards in the same format used by Xcode and the iOS SDK, so switching back to Xcode at some point is allowed</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Eliminates syncing with Xcode</strong></span>: Using Xamarin.iOS Designer eliminates the need to use Xcode in the development process along with the synchronization problems that can occur between Xamarin Studio and Xcode</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Easy properties</strong></span>: Xamarin.iOS Designer automatically creates properties that reference controls <a class="indexterm" id="id125"/>as they are dropped on a view</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Easy event handlers</strong></span>: Xamarin.iOS Designer provides a more intuitive means to create event handlers, which work in a very similar way as Visual Studio works on other UI frameworks such as Silverlight and WPF</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Custom controls</strong></span>: User can create their own custom UI controls that are accessible from <a class="indexterm" id="id126"/>within the toolbox panel</li></ul></div><p>Xamarin.iOS Designer can only be used to create storyboards. If you prefer or need to work with XIB files, you will need to continue to work with Xcode.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we presented the essentials of Xamarin.iOS architecture and tried to demystify the way Xamarin.iOS allows developers to create great native apps for iOS using C# and Mono. While we have obviously not covered the entire iOS SDK, we have described the approach and principles used to build Xamarin.iOS. With this knowledge in place, you should be in a good position to move forward with Xamarin.iOS development and resolve issues as they arise.</p><p>In the next chapter, we will try to accomplish the same goals for Xamarin.Android.</p></div></body></html>