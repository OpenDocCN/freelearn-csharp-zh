<html><head></head><body>
		<div><h1 id="_idParaDest-46"><em class="italic"><a id="_idTextAnchor077"/>Chapter 5</em>: Configuring WebHostBuilder</h1>
			<p>When reading <a href="B17996_04_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 4</em></a>, <em class="italic">Configuring and Customizing HTTPS with Kestrel</em>, you might have asked yourself a question:</p>
			<p><em class="italic">How can I use user secrets to pass the password to the HTTPS configuration?</em> </p>
			<p>You might even be wondering whether you can fetch the configuration from within <code>Program.cs</code>.</p>
			<p>In this chapter, we're going to answer these questions through the following topic:</p>
			<ul>
				<li>Re-examining <code>WebHostBuilderContext</code></li>
			</ul>
			<p>The topic in this chapter refers to the hosting layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_5.1_B17996.jpg" alt="Figure 5.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an <strong class="bold">ASP.NET</strong> <strong class="bold">Core</strong> application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new web application:</p>
			<pre>dotnet new web -n HostBuilderConfig -o HostBuilderConfig</pre>
			<p>Now open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<pre>cd HostBuilderConfig
code .</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The simple <code>web</code> project template changed in .NET 6.0. In version 6.0, Microsoft introduced <strong class="bold">minimal APIs</strong> and changed the project template to use the minimal API approach. I'm going to show you the differences between these templates within this chapter. </p>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-48">R<a id="_idTextAnchor079"/><a id="_idTextAnchor080"/>e-examining WebHostBuilderContext</h1>
			<p>R<a id="_idTextAnchor081"/>emember the <code>WebHostBuilder</code> Kestrel configuration in the <code>Program.cs</code> file that we looked at in <a href="B17996_04_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 4</em></a>, <em class="italic">Configuring and Customizing HTTPS with Kestrel</em>? In that chapter, we saw that<a id="_idIndexMarker056"/> you should use user secrets to configure the certificates password, as shown in the following code snippet:</p>
			<pre>public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }
    public static IHostBuilder CreateHostBuilder(
        string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder
                    .UseKestrel(options =&gt;
                    {
                        options.Listen(
                            IPAddress.Loopback, 
                            5000);
                        options.Listen(
                            IPAddress.Loopback, 
                            5001, 
                            listenOptions  =&gt;
                            {
                                listenOptions.UseHttps(
                                    "certificate.pfx", 
                                    "topsecret");
                            });
                    })
                    .UseStartup&lt;Startup&gt;();
            });
    }
}</pre>
			<p>This snippet is still valid<a id="_idIndexMarker057"/> for .NET 5.0 and prior versions, and it still is valid for almost all web projects in .NET 6.0. But it is not valid for the <code>web</code> project template we use in the technical requirements section. The <code>Program.cs</code> file for a minimal API looks like this:</p>
			<pre>var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();</pre>
			<p>This means the configuration we implemented in the last chapter would look like this within a minimal API:</p>
			<pre>using System.Net;
var builder = WebApplication.CreateBuilder(args);
builder.WebHost.UseKestrel(options =&gt;
{
    options.Listen(IPAddress.Loopback, 5000);
    options.Listen(IPAddress.Loopback, 5001,
        listenOptions =&gt;
        {
            listenOptions.UseHttps(
                "certificate.pfx",
                "topsecret");
        });
});</pre>
			<p>The following is valid for all project templates in .NET 6.0 and prior versions.</p>
			<p>Usually, you are not able to fetch the configuration inside this code. You need to know that the <code>UseKestrel()</code> method is overloaded, as you can see here:</p>
			<pre>.UseKestrel((host, options) =&gt;
{
    // ...
})</pre>
			<p>This first argument<a id="_idIndexMarker058"/> is a <code>WebHostBuilderContext</code> instance, which you can use to access the configuration. So, let's rewrite the lambda a little bit to use this context:</p>
			<pre>builder.WebHost.UseKestrel((host, options) =&gt;
{
    var filename = host.Configuration.GetValue(
        "AppSettings:certfilename", "");
    var password = host.Configuration.GetValue(
        "AppSettings:certpassword", "");
    options.Listen(IPAddress.Loopback, 5000);
    options.Listen(IPAddress.Loopback, 5001, 
        listenOptions =&gt;
        {
            listenOptions.UseHttps(filename, password);
        });
});</pre>
			<p>In this example, we write the keys using the colon divider, as this is the way in which you need to read nested configurations from <code>appsettings.json</code>:</p>
			<pre>{
    "AppSettings": {
        "certfilename": "certificate.pfx",
        "certpassword": "topsecret"
    },
    "Logging": {
        "LogLevel": {
            "Default": "Warning"
        }
    },
    "AllowedHosts": "*"
}</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This is just a sample of how to read<a id="_idIndexMarker059"/> configurations to configure <strong class="bold">Kestrel</strong>. Please never, <em class="italic">ever</em> store any credentials inside the code. Use the following concepts instead.</p>
			<p>You are also able to read from the user<a id="_idIndexMarker060"/> secrets store where the keys are set<a id="_idIndexMarker061"/> up with the following <strong class="bold">.NET</strong> <strong class="bold">CLI</strong> commands that you need to execute in the project folder:</p>
			<pre>dotnet user-secrets init
dotnet user-secrets set "AppSettings:certfilename" 
  "certificate.pfx"
dotnet user-secrets set "AppSettings:certpassword" 
  "topsecret"</pre>
			<p>This also applies to environment variables:</p>
			<pre>SET APPSETTINGS_CERTFILENAME=certificate.pfx
SET APPSETTINGS_CERTPASSWORD=topsecret</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Since the user secrets store is for local development only, you should pass credentials via environment variables to the application in production, or production-like applications. Also, the app<a id="_idIndexMarker062"/> settings configuration you will make in Azure will be passed as environment variables to your application.</p>
			<p>So, how does this all <a id="_idTextAnchor082"/><a id="_idTextAnchor083"/>work?</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor084"/>How does it work?</h2>
			<p>Do you remember the days back when you needed to set app configurations in the <code>Startup.cs</code> file in ASP.NET Core 1.0? They were configured in the constructor of the <code>StartUp</code> class and looked similar to this if you added user secrets:</p>
			<pre>var builder = new ConfigurationBuilder()
    .SetBasePath(env.ContentRootPath)
    .AddJsonFile("appsettings.json")
    .AddJsonFile($"appsettings.{env.EnvironmentName}.json",
      optional:  true);
if (env.IsDevelopment())
{
    builder.AddUserSecrets();
}
builder.AddEnvironmentVariables();
Configuration = builder.Build();</pre>
			<p>This code is now wrapped<a id="_idIndexMarker063"/> inside the <code>CreateDefaultBuilder</code> method (as you can see on GitHub – refer to the <em class="italic">Further reading</em> section for details) and looks like this:</p>
			<pre>builder.ConfigureAppConfiguration((hostingContext, config) 
  =&gt;
{
    var env = hostingContext.HostingEnvironment;
    config
        .AddJsonFile(
            "appsettings.json", 
            optional: true, 
            reloadOnChange: true)
        .AddJsonFile(
            $"appsettings.{env.EnvironmentName}.json", 
            optional:  true,
            reloadOnChange: true);
    if (env.IsDevelopment())
    {
        var appAssembly = Assembly.Load(
            new AssemblyName(env.ApplicationName));
        if (appAssembly != null)
        {
            config.AddUserSecrets(appAssembly, 
                optional: true);
        }
    }
    config.AddEnvironmentVariables();
    if (args != null)
    {
        config.AddCommandLine(args);
    }
});</pre>
			<p>This is almost the same code, and it is one of the first things that gets executed when building the <code>WebHost</code>.</p>
			<p>This needs to be one of the first<a id="_idIndexMarker064"/> things we set up because Kestrel is configurable via the app configuration. You can specify ports, URLs, and more by using environment variables or <code>appsettings.json</code>.</p>
			<p>You can find these lines in <code>WebHost.cs</code> on GitHub:</p>
			<pre>builder.UseKestrel((builderContext, options) =&gt;
  {
    options.Configure(
        builderContext.Configuration.GetSection("Kestrel"));
})</pre>
			<p>This means that you are able to add these lines to <code>appsettings.json</code> to configure Kestrel endpoints:</p>
			<pre>"Kestrel": {
    "EndPoints": {
        "Http": {
            "Url": "http://localhost:5555"
        }
    }
}</pre>
			<p>Alternatively, environment variables such as the following can be used to configure endpoints:</p>
			<pre>SET KESTREL_ENDPOINTS_HTTP_URL=http://localho<a id="_idTextAnchor085"/><a id="_idTextAnchor086"/>st:5555</pre>
			<p>Let's now recap everything<a id="_idIndexMarker065"/> we've covered in this <a id="_idTextAnchor087"/><a id="_idTextAnchor088"/><a id="_idTextAnchor089"/>chapter.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor090"/>Summary</h1>
			<p>Inside <code>Program.cs</code>, you are able to make app configurations inside the lambdas of the configuration methods, provided you have access to the <code>WebHostBuilderContext</code>. This way, you can use all the configurations you like to configure <code>WebHostBuilder</code>.</p>
			<p>In the next chapter, we are going to have a look at the hosting details. You will learn about different hosting models and how to host an ASP.NET Core application in different ways.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor091"/>Further reading</h1>
			<p>The <code>WebHost.cs</code> file in the ASP.NET GitHub repository: <a href="https://github.com/aspnet/MetaPackages/blob/d417aacd7c0eff202f7860fe1e686aa5beeedad7/src/Microsoft.AspNetCore/WebHost.cs">https://github.com/aspnet/MetaPackages/blob/d417aacd7c0eff202f7860fe1e686aa5beeedad7/src/Microsoft.AspNetCore/WebHost.cs</a>.</p>
		</div>
	</body></html>