<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Physically-Based Rendering</h1>
                
            
            <article>
                
<p class="calibre3">Introduced in Unity 5, PBR is a shading model that seeks to render graphics in a way that acts in a similar manner to how light works in the real world. Previous chapters have repeatedly mentioned it without revealing too much about it. If you want to understand not only how PBR works, but how to make the most out of it, this is the chapter you should read. In this chapter, you will learn the following recipes:</p>
<ul class="calibre11">
<li class="calibre12">Understanding the metallic setup</li>
<li class="calibre12">Adding transparency to PBR</li>
<li class="calibre12">Creating mirrors and reflective surfaces</li>
<li class="calibre12">Baking lights in your scene</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            <article>
                
<p class="calibre3">All the lighting models encountered in <a href="part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10"><span>Chapter 4</span></a>, <em class="calibre14">Understanding Lighting Models</em>, were very primitive descriptions of how light behaves. The most important aspect during their making was <em class="calibre14">efficiency</em>. Real-time shading is expensive, and techniques such as Lambertian or BlinnPhong are a compromise between computational cost and realism.</p>
<p class="calibre3">Having a more powerful GPU has allowed us to write progressively more sophisticated lighting models and rendering engines, with the aim of simulating how light actually behaves. This is, in a nutshell, the philosophy behind PBR. As the name suggests, it tries to get as close as possible to the physics behind the processes that give a unique look at each material. Despite this, the term PBR has been widely used in marketing campaigns and is more of a synonym for <strong class="calibre5">state-of-the-art rendering</strong> rather than a well-defined technique.</p>
<p class="calibre3">Unity implements PBR in two main ways:</p>
<ul class="calibre11">
<li class="calibre12">The first is a completely new lighting model (called Standard). Surface Shaders allow developers to specify the physical properties of a material, but they do not impose actual physical constraints on them. PBR fills this by gap using a lighting model that enforces principles of physics such as <strong class="calibre1">energy conservation</strong> (an object cannot reflect more light than the amount it receives), <strong class="calibre1">microsurface scattering</strong> (rough surfaces reflect light more erratically compared to smooth ones), <strong class="calibre1">Fresnel reflectance</strong> (specular reflections appear at grazing angles), and <strong class="calibre1">surface occlusion</strong> (the darkening of corners and other geometries that are hard to light). All these aspects, and many others, are used to calculate the standard lighting model.</li>
<li class="calibre12">The second aspect that makes PBR so realistic is called <strong class="calibre1">Global Illumination</strong> (<strong class="calibre1">GI</strong>) and is the simulation of physically-based light transport. It means that objects are not drawn in the scene as if they were separate entities. They all contribute to the final rendering as light can reflect on them before hitting something else. This aspect is not captured in the shaders themselves, but is an essential part of how the rendering engine works. Unfortunately, accurately simulating how light rays actually bounce over surfaces in real time is beyond the capabilities of modern GPUs. Unity makes some clever optimizations that allow us to retain visual fidelity without sacrificing performance. Some of the most advanced techniques (such as reflections), however, require user input.</li>
</ul>
<p class="calibre3">All of these aspects will be covered in this chapter. It is important to remember that PBR and GI do not automatically guarantee that your game will be photorealistic. Achieving photorealism is a very challenging task and, like every art, it requires great expertise and exceptional skills.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding the metallic setup</h1>
                
            
            <article>
                
<p class="calibre3">Unity provides three different types of PBR shaders; they are referred to in the drop-down menu of the material's <span class="calibre6">Inspector</span> tab as <span class="calibre6">Standard</span>, <span class="calibre6">Standard (Roughness Setup)</span>,<span class="calibre6"> </span>and <span class="calibre6">Standard (Specular setup)</span>. The main difference is that <span class="calibre6">Standard</span> and <span class="calibre6">Standard (Roughness Setup)</span> expose the <span class="calibre6">Metallic</span> property, but <span class="calibre6">Standard</span> contains a <span class="calibre6">Smoothness</span> property while the second replaces <span class="calibre6">Smoothness</span> with <span class="calibre6">Roughness</span><strong class="calibre5">.</strong> <span class="calibre6">Standard (Specular setup)</span> contains <span class="calibre6">Smoothness</span>, but replaces the <span class="calibre6">Metallic</span> property with <span class="calibre6">Specular</span>. <span class="calibre6">Smoothness</span> and <span class="calibre6">Roughness</span> are opposites of each other, so a <kbd class="calibre13">1</kbd> <span class="calibre6">Smoothness</span> means <kbd class="calibre13">0</kbd> <span class="calibre6">Roughness</span> and vice versa. You can generally get the same result no matter which shader you use, so it mostly comes down to personal preference.</p>
<p class="calibre3">These setups represent different ways in which you can initialize PBR materials. One of the concepts that has driven PBR is the ability to provide meaningful, physically-related properties that artists and developers can tweak and play with. The properties of some materials are easier to represent, indicating how <em class="calibre14">metallic</em> they are. For others, it is more important to specify how they reflect lights directly through its <strong class="calibre5">specularity</strong>. This recipe will show you how to use the <strong class="calibre5">metallic</strong> <strong class="calibre5">setup</strong> effectively. It's important to remember that the metallic workflow is not just for metallic materials; it is a way of defining how materials will look according to how metallic or non-metallic their surface is. Despite being presented as two different types of shaders, both <span class="calibre6">Metallic</span> and <span class="calibre6">Specular</span> setups are generally equally expressive. As shown in the Unity documentation at <span class="calibre6"><a href="http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html" class="calibre10">http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html</a> and mentioned earlier</span>, the same materials can usually be recreated with both setups (see the following screenshot):</p>
<div class="cdpaligncenter"><img src="../images/00115.jpeg" class="calibre107"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">This recipe will use the Standard Shader, so there is no need to create a new one. The steps to start the recipe are as follows:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new material (<kbd class="calibre13">MetallicMat</kbd>).</li>
<li value="2" class="calibre12">From its <span>Inspector</span>, make sure that <span>Standard</span> is selected from its <span>Shader </span>drop-down menu. </li>
<li class="calibre12" value="3">You will also need a textured 3D model. Our basic character we've been using previously will work perfectly. Drag and drop it into the scene. Afterward, drag and drop the <kbd class="calibre13">MetallicMat</kbd> material onto each of the parts of the character. <span>Also, assign the texture for the m<span><span>aterial</span></span> to the </span><span>Albedo</span><span> property:</span></li>
</ol>
<div class="cdpaligncenter"><img src="../images/00116.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">There are two main textures that need to be configured in the Standard Shader: <span class="calibre6">Albedo</span> and <span class="calibre6">Metallic</span>. To use the metallic workflow effectively, we need to initialize these maps correctly:</p>
<ol class="calibre15">
<li value="1" class="calibre12">The <span>Albedo</span> map should be initialized with the unlit texture of the 3D model.</li>
<li value="2" class="calibre12">To create the <span>Metallic</span> map, start by duplicating the file for your <span>Albedo</span> map. You can do this by selecting the map from the <span>Project</span> tab and pressing <em class="calibre2"><span>Ctrl </span>+ <span>D</span></em>.</li>
<li value="3" class="calibre12">Use white (<kbd class="calibre13">#ffffff</kbd>) to color the regions of the map that correspond to materials that are made of pure metal. Use black (<kbd class="calibre13">#000000</kbd>) for all the other colors. Shades of grey should be used for dusty, weathered, or worn-out metal surfaces, rust, scratched paint, and so on. As a matter of fact, Unity uses only the red channel to store the metallic value; the green and blue ones are ignored.</li>
<li value="4" class="calibre12">Use the alpha channel of the image to provide information about the <span>Smoothness</span> of the material:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00117.jpeg" class="calibre108"/></div>
<div class="mce-root"><span>An example of a Metallic map opened in Photoshop</span></div>
<p class="calibre26">For our simple character, the belt and the little ends of the hoodie are the only parts we need to be metallic. I've also made the opacity around 55% for the main character, with the belt having a higher opacity of 80%:</p>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Assign the <span>Metallic</span> map to the material. The <span>Metallic</span> slider will disappear as these two properties are now controlled by the map. You may use the <span>Smoothness</span> slider to provide a modifier on the map you've provided:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00118.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Metals are known for the conducting of electricity; light is in the form of electromagnetic waves, meaning that almost all metals behave in a similar way compared to non-conductors (often referred as <strong class="calibre5">insulators</strong>). Conductors tend to reflect most photons (70-100%), resulting in high reflectance. The remaining light is absorbed, rather than diffused, suggesting that conductors have a very dark diffuse component. Insulators, conversely, have a low reflectance (4%); the rest of the light is scattered on the surface, contributing to their diffused looks.</p>
<p class="calibre3">In the Standard Shader, purely metallic materials have dark diffuse components, and the color of their specular reflections is determined by the <span class="calibre6">Albedo</span> map. Conversely, the diffuse component of purely non-metallic materials is determined by the <span class="calibre6">Albedo</span> map; the color of their specular highlights is determined by the color of the incoming light. Following these principles allows the metallic workflow to combine the <span class="calibre6">Albedo</span> and specular into the <span class="calibre6">Albedo</span> map, enforcing physically-accurate behaviors. This also allows for saving more space, resulting in a significant speed increase at the expenses of reduced control over the look of your materials.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<p class="calibre3">For more information about the metallic setup, you can refer to these links:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Calibration chart</strong>: How to calibrate a metallic material (<span><a href="http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png" class="calibre10">http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png</a></span>)</li>
<li class="calibre12"><strong class="calibre1">Material chart</strong>: How to initialize the Standard Shader parameters for common materials (<span><a href="http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html" class="calibre10">http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html</a></span>)</li>
<li class="calibre12"><strong class="calibre1">Quixel MEGASCANS</strong>: A vast library of materials, including textures and PBR parameters (<a href="https://megascans.se/" class="calibre10"><span>https://megascans.se/</span></a>)</li>
<li class="calibre12"><strong class="calibre1">PBR Texture Conversion</strong>: How traditional shaders can be converted to PBR shaders (<span><a href="http://www.marmoset.co/toolbag/learn/pbr-conversion" class="calibre10">http://www.marmoset.co/toolbag/learn/pbr-conversion</a></span>)</li>
<li class="calibre12"><strong class="calibre1">Substance Designer</strong>: A node-based software to work with PBR (<span><a href="https://www.allegorithmic.com/products/substance-designer" class="calibre10">https://www.allegorithmic.com/products/substance-designer</a></span>)</li>
<li class="calibre12"><strong class="calibre1">The Theory of</strong> <strong class="calibre1">Physically-Based Rendering</strong>: A complete guide about PBR (<span><a href="https://www.allegorithmic.com/pbr-guide" class="calibre10">https://www.allegorithmic.com/pbr-guide</a></span>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding transparency to PBR</h1>
                
            
            <article>
                
<p class="calibre3">Transparency is such an important aspect in games that the Standard Shader supports three different ways of doing it. This recipe is useful if you need to have realistic materials with transparent or semi-transparent properties. Glasses, bottles, windows, and crystals are good candidates for PBR transparent shaders. This is because you can still have all the realism introduced by PBR with the addition of a transparent or translucent effect. If you need transparency for something different, such as UI elements or pixel art, there are more efficient alternatives that are explored in the <em class="calibre14">Creating a transparent material</em> recipe in <a href="part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10"><span>Chapter 3</span></a>, <em class="calibre14">Surface Shaders and Texture Mapping</em>.</p>
<div class="packt_infobox"><span class="calibre27">In order to have a transparent standard material, changing the alpha channel of its </span><span class="calibre27">Albedo</span><span class="calibre27"> color property is not enough. Unless you properly set its </span><span class="calibre27">Rendering Mode</span>, <span class="calibre27">your material will not appear transparent.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">This recipe will use the Standard Shader, so there is no need to create a new one:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new material (<kbd class="calibre13">TransparencyMat</kbd>).</li>
<li value="2" class="calibre12">Make sure that the <span>Shader</span> property is set to either <span>Standard</span> or <span>Standard (Specular setup)</span> from the material's <span>Inspector</span> tab.</li>
<li value="3" class="calibre12">Assign the newly created material to the 3D object that you want to be transparent:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00119.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">The Standard Shader provides three different types of transparencies. Despite being very similar, they have subtle differences and fit in different contexts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Semi-transparent materials</h1>
                
            
            <article>
                
<p class="calibre3">Some materials such as clear plastics, crystal, and glass are semi-transparent. This means that they both require all the realistic effects of PBR (such as specular highlights and Fresnel refraction and reflection), but allow the geometry behind an object with the material attached to be seen. If this is what you need, perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">From the material's <span>Inspector</span> tab, set <span>Rendering Mode</span> to <span>Transparent</span>.</li>
<li value="2" class="calibre12">The amount of transparency is determined by the alpha channel of the <span>Albedo</span> color or the <span>Albedo</span> map (if any). If you click on the box to the right of the <span>Albedo</span> section, you'll bring up a <span>Color</span> menu. Adjusting the <span>A</span> channel will make the item more visible or less visible:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00120.jpeg" class="calibre109"/></div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Setting the <span>A</span> channel to <kbd class="calibre13">44</kbd> provides the following effect:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00121.jpeg" class="calibre25"/></div>
<ol start="4" class="calibre15">
<li class="calibre12" value="4">The following screenshot shows the Unity calibration scene with four different highly polished plastic spheres. From left to right, their transparency is increasing. The last sphere is fully transparent, but retains all the added effects of PBR:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00122.jpeg" class="calibre110"/></div>
<div class="packt_tip">The Unity Calibration Scene can be downloaded for free from the Asset Store at <a href="https://www.assetstore.unity3d.com/en/#!/content/25422" class="calibre31">https://www.assetstore.unity3d.com/en/#!/content/25422</a>.</div>
<p class="calibre3">The <span class="calibre6">Transparent</span> rendering mode is perfect for windows, bottles, gems, and headsets.</p>
<div class="packt_infobox"><span class="calibre27">You should notice that many transparent materials don't usually project shadows. On top of this, the </span><span class="calibre27">Metallic</span><span class="calibre27"> and </span><span class="calibre27">Smoothness</span><span class="calibre27"> properties of a material can interfere with the transparency effect. A mirror-like surface can have the alpha set to zero, but if it reflects all the incoming light, it won't appear transparent.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fading objects</h1>
                
            
            <article>
                
<p class="calibre3">Sometimes, you want an object to fully disappear with a fading effect. In this case, specular reflections and Fresnel refraction and reflection should disappear as well. When a fading object is fully transparent, it should also be invisible. To do this, perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">From the material's <span>Inspector</span> tab, set <span>Rendering Mode</span> to <span>Fade</span>.</li>
<li value="2" class="calibre12">As before, use the alpha channel of the <span>Albedo</span> color or map to determine the final transparency:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00123.jpeg" class="calibre111"/></div>
<ol start="3" class="calibre15">
<li class="calibre12" value="3">The following screenshot shows four fading spheres. It is clear from the screenshot that the PBR effects fade with the sphere as well. As you can see in the following image, the last one on the right is almost invisible:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00124.jpeg" class="calibre112"/></div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">This rendering mode works best for non-realistic objects, such as holograms, laser rays, faux lights, ghosts, and particle effects.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Solid geometries with holes</h1>
                
            
            <article>
                
<p class="calibre3">Most of the materials encountered in a game are solid, meaning that they don't allow light to pass through them. At the same time, many objects have a very complex (yet flat) geometry. Modeling leaves and grass with 3D objects is often overkilled. A more efficient approach is to use a quad (rectangle) with a leaf texture. While the leaf itself is solid, the rest of the texture should be fully transparent. If this is what you want, then perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">From the material's <span>Inspector</span> tab, set <span>Rendering Mode</span> to <span>Cutout</span>.</li>
<li value="2" class="calibre12">Use the <span>Alpha Cutoff</span> slider to determine the cutoff threshold. All the pixels in the <span>Albedo</span> map with an alpha value equal to or less than <span>Alpha Cutoff</span> will be hidden.</li>
</ol>
<p class="calibre3">The following image, taken from the <em class="calibre14">Unity Official Tutorials</em> on PBR (<span class="calibre6"><a href="https://www.youtube.com/watch?v=fD_ho_ofY6A" class="calibre10">https://www.youtube.com/watch?v=fD_ho_ofY6A</a></span>), shows you how the effect of the <span class="calibre6">Cutout</span> rendering mode can be used to create a hole in the geometry:</p>
<div class="cdpaligncenter"><img src="../images/00125.jpeg" class="calibre113"/></div>
<p class="calibre3">It's worth noticing that <span class="calibre6">Cutout</span> does not allow the back of the geometry to be seen. In the previous example, you could not see the inner volume of the sphere. If you require such an effect, you need to create your own shader and make sure that the back geometry is not culled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<ul class="calibre11">
<li class="calibre12">As mentioned previously, some of the examples in this recipe have been created using the Unity <span>Shader Calibration Scene</span>, which is freely available in the Asset Store at <span><a href="https://www.assetstore.unity3d.com/en/#!/content/25422" class="calibre10">https://www.assetstore.unity3d.com/en/#!/content/25422</a></span>.</li>
<li class="calibre12">More information about <span>Albedo</span> and <span>Transparency</span> can be found at<br class="title-page-name"/>
<span><a href="http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html" class="calibre10">http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html</a></span>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating mirrors and reflective surfaces</h1>
                
            
            <article>
                
<p class="calibre3">Specular materials reflect lights when objects are viewed from certain angles. Unfortunately, even the Fresnel reflection, which is one of the most accurate models, does not correctly reflect lights from nearby objects. The lighting models examined in the previous chapters took into account only light sources, but ignored light that is reflected from other surfaces. With what you've learned about shaders so far, making a mirror is simply not possible.</p>
<p class="calibre3">Global illumination makes this possible by providing PBR shaders with information about their surroundings. This allows objects to have not just specular highlights, but also real reflections, which depend on the other objects around them. Real-time reflections are very costly and require manual setting up and tweaking in order to work. When done properly, they can be used to create mirror-like surfaces, as seen in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00126.jpeg" class="calibre114"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">This recipe will not feature any new shader. Quite the opposite; most of the work is done directly in the editor. Perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new scene.</li>
</ol>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Create a quad (<span>GameObject</span> | <span>3D Object</span> | <span>Quad</span>), which will serve as a mirror. I've rotated it to -65 in the Y axis to make it easy to see.</li>
<li value="3" class="calibre12">Create a new material (<kbd class="calibre13">MirrorMat</kbd>) and attach it to the mirror.</li>
<li value="4" class="calibre12">Place the quad in a scene with other objects.</li>
<li value="5" class="calibre12">Create a new reflection probe from <span>GameObject</span> | <span>Light</span> | <span>Reflection Probe</span> and place it in front of the quad:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00127.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">If the preceding steps have been followed correctly, you should have a quad in the middle of your scene, close to a reflection probe. In order to make it in a mirror, some changes need to be made:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Change the shader of the material to <span>Standard</span> and its <span>Rendering Mode</span> to <span>Opaque</span>.</li>
<li value="2" class="calibre12">Change its <span>Metallic</span> and <span>Smoothness</span> properties to one. You should see the material reflecting the sky more clearly.</li>
<li value="3" class="calibre12">Select the reflection probe and change its <span>Size</span> and <span>Probe Origin</span> until it is in front of the quad and it encloses all the objects that you want to reflect.</li>
</ol>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">To make the item more clear under the <span>Cubemap capture settings</span>, change the <span>Resolution</span> to <kbd class="calibre13">2048</kbd><span>.</span></li>
<li value="5" class="calibre12">Finally, change its <span>Type</span> to <span>Realtime</span> and the <span>Refresh Mode</span> to <span>Every frame</span>. Also, make sure that <span>Culling Mask</span> is set to <span>Everything</span>.</li>
<li class="calibre12" value="6">Your reflection probe should be configured, as shown in the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00128.jpeg" class="calibre115"/></div>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Using these settings, you should see something similar to this:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00129.jpeg" class="calibre25"/></div>
<p class="calibre3"><span class="calibre6">You may notice that the bunny seems larger in the reflection rather than what's beside it.</span> If your probe is used for a real mirror, you should check the <span class="calibre6">Box Projection</span> flag (in this example, setting the box size to <kbd class="calibre13">1</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">1</kbd> does a pretty good job of looking like a mirror). If it is used for other reflective surfaces, such as shiny pieces of metal or glass tables, you can uncheck it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">When a shader wants information about its surroundings, it is usually provided in a structure called <strong class="calibre5">cube</strong> <strong class="calibre5">maps</strong>. They have been briefly mentioned in <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10"><span>Chapter 2</span></a>, <em class="calibre14">Creating Your First Shader</em>, as one of the shader property types, among <kbd class="calibre13">Color</kbd>, <kbd class="calibre13">2D</kbd>, <kbd class="calibre13">Float</kbd>, and <kbd class="calibre13">Vector</kbd>. Loosely speaking, cube maps are the 3D equivalent of 2D textures; they represent a 360-degree view of the world, as seen from a center point.</p>
<p class="calibre3">Unity previews cube maps with a spherical projection, as seen in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00130.jpeg" class="calibre116"/></div>
<p class="calibre3">When cube maps are attached with a camera, they are referred to as <strong class="calibre5">skyboxes</strong>, as they are used to provide a way to reflect the sky. They can be used to reflect geometries that are not in the actual scene, such as nebulae, clouds, and stars.</p>
<p class="calibre3">The reason why they are called cube maps is because of the way they are created: a cube map is made up of six different textures, each one attached to the face of a cube. You can create a cube map manually or delegate it to a <strong class="calibre5">reflection probe</strong>. You can imagine a reflection probe as a collection of six cameras, creating a 360-degree mapping of the surrounding area. This also gives you an idea as to why probes are so expensive. By creating one in our scene, we allow Unity to know which objects are around the mirror. If you need more reflective surfaces, you can add multiple probes. You need no further action for the reflection probes to work. The Standard Shaders will use them automatically.</p>
<p class="calibre3">You should notice that when they are set to <span class="calibre6">Realtime</span>, they render their cube map at the beginning of every frame. There is a trick to make this faster; if you know that part of the geometry that you want to reflect does not move, you can bake the reflection. This means that Unity can calculate the reflection before starting the game, allowing more precise (and computationally expensive) calculations. In order to do this, your reflection probe must be set to <span class="calibre6">Baked</span> and will work only for objects that are flagged as <span class="calibre6">Static</span>. Static objects cannot move or change, which makes them perfect for terrain, buildings, and props. Every time a static object is moved, Unity will regenerate the cube maps for its baked reflection probes. This might take a few minutes to several hours.</p>
<p class="calibre3">You can mix <span class="calibre6">Realtime</span> and <span class="calibre6">Baked</span> probes to increase the realism of your game. Baked probes will provide very high-quality reflections, environmental reflections, while the real-time ones can be used to move objects such as cars or mirrors. The <em class="calibre14">Baking lights in your scene</em> section will explain in detail how light baking works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<p class="calibre3">If you are interested in learning more about reflection probes, you should check these links:</p>
<ul class="calibre11">
<li class="calibre12">Unity manual about the Reflection Probe: <span><a href="http://docs.unity3d.com/Manual/class-ReflectionProbe.html" class="calibre10">http://docs.unity3d.com/Manual/class-ReflectionProbe.html</a></span></li>
<li class="calibre12"><span>Box projection and other advanced Reflection Probe settings: </span><a href="https://docs.unity3d.com/Manual/AdvancedRefProbe.html" class="calibre10">https://docs.unity3d.com/Manual/AdvancedRefProbe.html</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Baking lights in your scene</h1>
                
            
            <article>
                
<p class="calibre3">Rendering lighting is a very expensive process. Even with state-of-the-art GPUs, accurately calculating the <strong class="calibre5">light transport</strong> (which is how light bounces between surfaces) can take hours. In order to make this process feasible for games, real-time rendering is essential. Modern engines compromise between realism and efficiency; most of the computation is done beforehand in a process called <strong class="calibre5">light baking</strong>. This recipe will explain how light baking works and how you can get the most out of it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">Light baking requires you to have a scene ready. It should have geometries and, obviously, lights. For this recipe, we will rely on Unity's standard features so there is no need to create additional shaders or materials. We will be reusing the map that we used previously in <a href="part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 1</a>,<span class="calibre6"> </span><em class="calibre14"><span class="calibre6"><span class="calibre6">Post Processing Stack</span></span></em>. For better control, you might want to access the <span class="calibre6">Lighting</span> window. If you don't see it, select <span class="calibre6">Window</span> | <span class="calibre6">Lighting | Settings</span> from the menu and dock it where it is more convenient for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">Light baking requires some manual configuration. There are three essential, yet independent, steps that you need to take.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the static geometry</h1>
                
            
            <article>
                
<p class="calibre3">These steps must be followed for the configuration:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Identify all the objects in your scene that do not change position, size, and material. Possible candidates are buildings, walls, terrain, props, trees, and others. In our case, it will be all of the objects aside from the <kbd class="calibre13">FPSController</kbd> and its children.</li>
<li value="2" class="calibre12">Select these objects and check the <span>Static</span> box from the <span>Inspector</span> tab, as shown in the following screenshot. If any of the selected objects have children, Unity will ask if you want them to be considered static as well. If they meet the requirements (fixed position, size, and material), select <span>Yes, change children</span> in the pop-up box:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00131.jpeg" class="calibre25"/></div>
<div class="packt_tip"><span class="calibre27">If a light qualifies as a static object but illuminates non-static geometry, make sure that its </span><span class="calibre27">Baking</span><span class="calibre27"> property is set to </span><span class="calibre27">Mixed</span><span class="calibre27">. If it will affect only static objects, set it to </span><span class="calibre27">Baked</span><span class="calibre27">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the light probes</h1>
                
            
            <article>
                
<p class="calibre3">There are objects in your game that will move, such as the main character, enemies, and the other <strong class="calibre5">non-playable characters</strong> (<strong class="calibre5">NPCs</strong>). If they enter a static region that is illuminated, you might want to surround it with light probes. To do this, follow the given steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">From the menu, navigate to <span>GameObject</span> | <span>Light</span> | <span>Light Probe Group</span>. A new object called <span>Light Probe Group</span> will appear in <span>Hierarchy</span>.</li>
<li value="2" class="calibre12">Once selected, eight interconnected spheres will appear. Click and move them around the scene so that they enclose the static region in which your characters can enter. The following screenshot shows an example of how light probes can be used to enclose the volume of a static office space:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00132.jpeg" class="calibre117"/></div>
<p class="calibre72">   For our example, it would just be the center area the player is able to enter:</p>
<div class="cdpaligncenter"><img src="../images/00133.jpeg" class="calibre25"/></div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Select the moving objects that will enter the light probe region. </li>
<li value="4" class="calibre12">From their <span>Inspector</span>, expand their <strong class="calibre1">renderer component</strong> (usually <span>Mesh Renderer</span>) and make sure that <span>Light Probes</span> is not set to <span>Off checked</span> (see the following screenshot):</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00134.jpeg" class="calibre118"/></div>
<p class="calibre3">Deciding where and when to use light probes is a critical problem; more information about this can be found in the <em class="calibre14">How it works... </em>section for this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Baking the lights</h1>
                
            
            <article>
                
<p class="calibre3">To bake the lights, follow the given steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">First, select the lights you'd like to bake. Confirm from the <span>Inspector</span> tab that the <span>Mode</span> is set to <span>Baked </span>in the<span><span> </span>Light<span> </span></span>component:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00135.jpeg" class="calibre25"/></div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">To finally bake the lights, open the <span>Lighting</span> window by going to <span>Window</span> | <span>Lighting</span> | <span>Settings</span>. Once there, select the <span>Global Maps</span> tab.</li>
<li value="3" class="calibre12">If the <span>Auto Generate</span> checkbox is enabled, Unity will automatically execute the baking process in the background. If not, click on <span>Generate Lighting</span>.</li>
</ol>
<div class="packt_infobox"><span class="calibre27">Light baking can take several hours even for a relatively small scene. If you are constantly moving static objects or lights, Unity will restart the process from scratch, causing a severe slowdown </span><span class="calibre27">in the editor. You can uncheck the </span><span class="calibre27">Auto</span><span class="calibre27"> checkbox from the </span><span class="calibre27">Lighting</span><span class="calibre27"> | </span><span class="calibre27">Lightmaps | Settings</span><span class="calibre27"> tab to prevent this so that you can decide when to start the process manually.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">The most complicated part of rendering is the light transport. During this phase, the GPU calculates how the rays of light bounce between objects. If an object and its lights don't move, this calculation can be done only once as it will never change during the game. Flagging an object as <span class="calibre6">Static</span> is how to tell Unity that such an optimization can be made.</p>
<p class="calibre3">Loosely speaking, light baking refers to the process of calculating the global illumination of a static object and saving it in what is called a <strong class="calibre5">lightmap</strong>. Once baking is completed, lightmaps can be seen in the <span class="calibre6">Global Maps</span> tab of the <span class="calibre6">Lighting</span> window:</p>
<div class="cdpaligncenter"><img src="../images/00136.jpeg" class="calibre25"/></div>
<p class="calibre3">Light baking comes at a great expense: memory. Every static surface is, in fact, retextured so that it already includes its lighting condition. Let's imagine that you have a forest of trees, all sharing the same texture. Once they are made static, each tree will have its very own texture. Light baking not only increases the size of your game, but can take a lot of texture memory if used indiscriminately.</p>
<p class="calibre3">The second aspect introduced in this recipe is <strong class="calibre5">light probing</strong>. Light baking produces extremely high-quality results for static geometries, but does not work on moving objects. If your character is entering a static region, it can look somehow <em class="calibre14">detached</em> from the environment. Its shading will not match the surroundings, resulting in an aesthetically unpleasant result. Other objects, such as <strong class="calibre5">skinned mesh renderers</strong>, will not receive global illumination even if made static. Baking lights in real-time is not possible, although light probes offer an effective alternative. Every light probe samples the global illumination at a specific point in space. A light probe group can sample several points in space, allowing the interpolation of global illumination within a specific volume. This allows us to cast a better light on moving objects, even despite the fact that global illumination has been calculated only for a few points. It is important to remember that light probes need to enclose a volume in order to work. It is best to place light probes in regions where there is a sudden change in light conditions. Similar to lightmaps, probes consume memory and should be placed wisely; remember that they exist only for non-static geometry. Since there are no visible objects in the demoscene, this was done purely for demonstration purposes.</p>
<p class="calibre3">Even while using light probes, there are a few aspects that Unity's global illumination cannot capture. Non-static objects, for instance, cannot reflect light on other objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<p class="calibre3">You can read more about light probes at <span class="calibre6"><a href="http://docs.unity3d.com/Manual/LightProbes.html" class="calibre10">http://docs.unity3d.com/Manual/LightProbes.html</a></span>.</p>
<p class="calibre3"> </p>


            </article>

            
        </section>
    </body></html>