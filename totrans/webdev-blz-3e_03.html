<html><head></head><body>
<div><h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-52">Managing State – Part 1</h1>
<p class="normal">In this chapter, we will start looking at managing state. There is also a continuation of this chapter in <em class="chapterRef">Chapter 11</em>, <em class="italic">Managing State – Part 2</em>.</p>
<p class="normal">There are many different ways of managing state or persisting data. As soon as we leave a component, the state is gone. If we click the counter button from the sample pages, see the counter count up and then navigate away, we don’t know how many times we’ll need to click the counter button and have to start over. You can’t imagine how many times I have clicked that counter button over the years. It is such a simple yet powerful demo of Blazor and was a part of Steve’s original demo back in 2017.</p>
<p class="normal">To get started quickly, I have split this chapter in two. In this chapter, we are focusing on data access, and we will come back to more state management in the second part. Since this book focuses on Blazor, we will not explore how to connect to databases but create simple JSON storage instead.</p>
<div><p class="normal">In the first edition, we used Entity Framework to connect to a database, but there were people who were not used to working with Entity Framework, and they got stuck pretty fast. Using Entity Framework is a book all in itself, so I have opted not to include that in this book to remove any added complexity.</p>
</div>
<p class="normal">In the repo on GitHub, you can find more examples of storing data in databases such as <code class="inlineCode">RavenDB</code> or <code class="inlineCode">MSSQL</code>.</p>
<p class="normal">We will use a common pattern <a id="_idIndexMarker101"/>called the <strong class="keyWord">repository pattern</strong>.</p>
<p class="normal">We will also create an API to access the data from the JSON repository.</p>
<p class="normal">By the end of this chapter, you will have learned how to create a JSON repository and an API.</p>
<p class="normal">We will cover the following main topics:</p>
<ul>
<li class="bulletList">Creating a data project</li>
<li class="bulletList">Adding the API to Blazor</li>
</ul>
<h1 class="heading-1" id="_idParaDest-53">Technical requirements</h1>
<p class="normal">Make sure you have followed the previous chapters or use the <code class="inlineCode">Chapter02</code> folder on GitHub as the starting point.</p>
<p class="normal">You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter03</a>.</p>
<h1 class="heading-1" id="_idParaDest-54">Creating a data project</h1>
<p class="normal">There are many ways <a id="_idIndexMarker102"/>of persisting data: document databases, relational databases, and files, to name a few. To avoid complexity in the book, we will use the simplest way of creating blog posts for our project by storing them as JSON in a folder.</p>
<p class="normal">To save our blog posts, we will use JSON files stored in a folder, and to do so, we need to create a new project.</p>
<h2 class="heading-2" id="_idParaDest-55">Creating a new project</h2>
<p class="normal">We can create a new project from within Visual Studio (to be honest, that’s how I would do it), but to get to know the .NET CLI, let’s do it from the command line instead.</p>
<p class="normal">To create a new project, follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open a PowerShell prompt.</li>
<li class="numberedList">Navigate to the <code class="inlineCode">MyBlog</code> folder.</li>
<li class="numberedList">Create a class library (<code class="inlineCode">classlib</code>) by typing the following command:
        <pre class="programlisting con"><code class="hljs-con">dotnet new classlib -o Data
</code></pre>
<p class="normal">The <code class="inlineCode">dotnet</code> tool should now have created a folder called <code class="inlineCode">Data</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">We also need to create a project where we can put our models:
        <pre class="programlisting con"><code class="hljs-con">dotnet new classlib -o Data.Models
</code></pre>
</li>
<li class="numberedList">Add the new projects to our solution by running the following command:
        <pre class="programlisting con"><code class="hljs-con">dotnet sln add Data
dotnet sln add Data.Models
</code></pre>
</li>
</ol>
<p class="normal">It will look for any solution in the current folder.</p>
<p class="normal">We call the projects <code class="inlineCode">Data</code> and <code class="inlineCode">Data.Models</code> so their purpose will be easy to understand and they will be easy to find.</p>
<p class="normal">The default project <a id="_idIndexMarker103"/>has a <code class="inlineCode">class1.cs</code> file – feel free to delete the file.</p>
<p class="normal">The next step is to create data classes to store our information.</p>
<h2 class="heading-2" id="_idParaDest-56">Creating data classes</h2>
<p class="normal">Now we need to create a class<a id="_idIndexMarker104"/> for our blog post. To do that, we will go back to Visual Studio:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open the <code class="inlineCode">MyBlog</code> solution in Visual Studio (if it is not already open).
    <p class="normal">We should now have a new project called <code class="inlineCode">Data</code> in our solution. We might get a popup asking if we want to reload the solution; click <strong class="screenText">Reload</strong> if so.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="2">Right-click on the <code class="inlineCode">Data.Models</code> project and select <strong class="screenText">Add</strong> | <strong class="screenText">Class</strong>. Name the class <code class="inlineCode">BlogPost.cs</code> and click <strong class="screenText">Add</strong>.</li>
<li class="numberedList">Right-click on the <code class="inlineCode">Data.Models</code> project and select <strong class="screenText">Add</strong> | <strong class="screenText">Class</strong>. Name the class <code class="inlineCode">Category.cs</code> and click <strong class="screenText">Add</strong>.</li>
<li class="numberedList">Right-click on the <code class="inlineCode">Data.Models</code> project and select <strong class="screenText">Add</strong> | <strong class="screenText">Class</strong>. Name the class <code class="inlineCode">Tag.cs</code> and click <strong class="screenText">Add</strong>.</li>
<li class="numberedList">Right-click on the <code class="inlineCode">Data.Models</code> project and select <strong class="screenText">Add</strong> | <strong class="screenText">Class</strong>. Name the class <code class="inlineCode">Comment.cs</code> and click <strong class="screenText">Add</strong>.</li>
<li class="numberedList">Open <code class="inlineCode">Category.cs</code> and replace the content with the following code:
        <pre class="programlisting code"><code class="hljs-code">namespace Data.Models;
public class Category
{
	public string? Id { get; set; }
	public string Name { get; set; } = string.Empty;
}
</code></pre>
<p class="normal">The <code class="inlineCode">Category</code> class contains <code class="inlineCode">Id</code> and <code class="inlineCode">Name</code>. It might seem strange that the <code class="inlineCode">Id</code> property is a string, but this is because we will support multiple data storage types, including MSSQL, RavenDB, and JSON. A string is a great datatype to support all of these. <code class="inlineCode">Id</code> is also nullable, so if we create a new category, we send in null as an <code class="inlineCode">Id</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">Open <code class="inlineCode">Tag.cs</code> and <a id="_idIndexMarker105"/>replace the content with the following code:
        <pre class="programlisting code"><code class="hljs-code">namespace Data.Models;
public class Tag
{
    public string? Id { get; set; }
    public string Name { get; set; } = string.Empty;
}
</code></pre>
<p class="normal">The <code class="inlineCode">Tag</code> class contains an <code class="inlineCode">Id</code> and <code class="inlineCode">Name</code>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">Open <code class="inlineCode">Comment.cs</code> and replace the content with the following code:
        <pre class="programlisting code"><code class="hljs-code">namespace Data.Models;
public class Comment
{
    public string? Id { get; set; }
    public required string BlogPostId { get; set; }
    public DateTime Date { get; set; }
    public string Text { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
}
</code></pre>
</li>
<li class="numberedList">The <code class="inlineCode">comment</code> class could be part of the <code class="inlineCode">Blogpost</code> class, but to use the same classes for different database types, we add comments as a separate entity referencing the blog post.</li>
<li class="numberedList">Open <code class="inlineCode">BlogPost.cs</code> and replace the content with the following code:
        <pre class="programlisting code"><code class="hljs-code">namespace Data.Models;
public class BlogPost
{
    public string? Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Text { get; set; } = string.Empty;
    public DateTime PublishDate { get; set; }
    public Category? Category { get; set; }
    public List&lt;Tag&gt; Tags { get; set; } = new();
}
</code></pre>
</li>
</ol>
<p class="normal">In this class, we define the content of our blog post. We need an <code class="inlineCode">Id</code> to identify the blog post, a title, some text (the article), and the publishing date. We also have a <code class="inlineCode">Category</code> property in the class, which is of<a id="_idIndexMarker106"/> the <code class="inlineCode">Category</code> type. In this case, a blog post can have only one category, and a blog post can contain zero or more tags. We define the <code class="inlineCode">Tag</code> property with <code class="inlineCode">List&lt;Tag&gt;</code>.</p>
<p class="normal">We have now created a couple of classes that we will use. I have kept the complexity of these classes to a minimum since we are here to learn about Blazor.</p>
<p class="normal">Next, we will create a way to store and retrieve the blog post information.</p>
<h2 class="heading-2" id="_idParaDest-57">Creating an interface</h2>
<p class="normal">In this section, we will create an API. </p>
<p class="normal">We will create <a id="_idIndexMarker107"/>one API that has direct database access and one that will retrieve data through a Web API.</p>
<p class="normal">In <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating an API</em>, we will get back to creating the Web API. Why are we creating two APIs?</p>
<p class="normal">We are not creating two APIs; we are creating a service with direct database access and a client that goes over the web and then uses direct database access. But we will use the same interface for both scenarios, making it possible to use one on the server and the other on the client.</p>
<p class="normal">In a real-world application, it would make more sense to access all the data in one way, not use both. But the point is to show that it is possible to mix and match and pick what is right for your scenario.</p>
<p class="normal">We will start with the API with direct database access:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Right-click on the <code class="inlineCode">Data.Models</code> project, select <strong class="screenText">Add</strong> | <strong class="screenText">New Folder</strong>, and name it <code class="inlineCode">Interfaces</code>.</li>
<li class="numberedList">Right-click on the <code class="inlineCode">Interfaces</code> folder and select <strong class="screenText">Add</strong> | <strong class="screenText">Class</strong>.</li>
<li class="numberedList">In the list of different templates, select <strong class="screenText">Interface</strong> and name it <code class="inlineCode">IBlogApi.cs</code>.</li>
<li class="numberedList">Open <code class="inlineCode">IBlogApi.cs</code> and replace its content with the following:
        <pre class="programlisting code"><code class="hljs-code">namespace Data.Models.Interfaces;
public interface IBlogApi
{
    Task&lt;int&gt; GetBlogPostCountAsync();
    Task&lt;List&lt;BlogPost&gt;&gt; GetBlogPostsAsync(int numberofposts, int startindex);
    Task&lt;List&lt;Category&gt;&gt; GetCategoriesAsync();
    Task&lt;List&lt;Tag&gt;&gt; GetTagsAsync();
    Task&lt;List&lt;Comment&gt;&gt; GetCommentsAsync(string blogPostId);
    Task&lt;BlogPost?&gt; GetBlogPostAsync(string id);
    Task&lt;Category?&gt; GetCategoryAsync(string id);
    Task&lt;Tag?&gt; GetTagAsync(string id);
    Task&lt;BlogPost?&gt; SaveBlogPostAsync(BlogPost item);
    Task&lt;Category?&gt; SaveCategoryAsync(Category item);
    Task&lt;Tag?&gt; SaveTagAsync(Tag item);
    Task&lt;Comment?&gt; SaveCommentAsync(Comment item);
    Task DeleteBlogPostAsync(string id);
    Task DeleteCategoryAsync(string id);
    Task DeleteTagAsync(string id);
    Task DeleteCommentAsync(string id);
}
</code></pre>
</li>
<li class="numberedList">Alright, so<a id="_idIndexMarker108"/> here’s the deal with this <code class="inlineCode">IBlogApi</code> thing. It’s basically our cheat sheet for handling all the blog stuff, like posts, comments, tags, and categories. Need to grab some posts or zap one out of existence? This interface is your go-to. It’s all about making our lives easier when we’re coding the blog, and keeping things tidy and straightforward.</li>
</ol>
<p class="normal">Now, we have an interface for the API with the methods we need to list blog posts, tags, and categories, as well as to save (create/update) and delete them. Next, let’s implement the interface.</p>
<h2 class="heading-2" id="_idParaDest-58">Implementing the interface</h2>
<p class="normal">The idea is to create a class <a id="_idIndexMarker109"/>that stores our blog posts, tags, comments, and categories as JSON files on our file system. We will start with implementing the direct access implementation. This is the one we can use when accessing information directly from the database and not through a Web API. We will use the direct access implementation when running our components on the server and accessing the database and our Web API will also use it to access the database, but we will come back to that in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating an API</em>.</p>
<p class="normal">To implement the interface <a id="_idIndexMarker110"/>for the direct database access implementation, follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">First, to be able to access our data models, we need to add a reference to our <code class="inlineCode">Data</code> models. Expand the <code class="inlineCode">Data</code> project and right-click on the <strong class="screenText">Dependencies</strong> node. Select <strong class="screenText">Add Project reference</strong> and check the <code class="inlineCode">Data.Models</code> project. Click <strong class="screenText">OK</strong>.</li>
<li class="numberedList">Right-click on the <strong class="screenText">Dependencies</strong> node once again, but select <strong class="screenText">Manage NuGet Packages</strong>. In the <strong class="screenText">Browse</strong> tab, search for <code class="inlineCode">Microsoft.Extensions.Options</code> and click <strong class="screenText">Install</strong>.</li>
<li class="numberedList">We need a class to hold our settings.
    <p class="normal">In the <code class="inlineCode">Data</code> project, add a new class called <code class="inlineCode">BlogApiJsonDirectAccessSetting.cs</code> and replace its content with:</p>
<pre class="programlisting code"><code class="hljs-code">namespace Data;
public class BlogApiJsonDirectAccessSetting
{
    public string BlogPostsFolder { get; set; } = string.Empty;
    public string CategoriesFolder { get; set; } = string.Empty;
    public string TagsFolder { get; set; } = string.Empty;
    public string CommentsFolder { get; set; } = string.Empty;
    public string DataPath { get; set; } = string.Empty;
}
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">This is the class where we hold our settings and the folders we will be using for storing our JSON files. <code class="inlineCode">IOptions</code> is configured in <code class="inlineCode">program</code> during the configuration of dependencies and is injected into all the classes that ask for a specific type.</li>
<li class="numberedList">Next, we need to create a class for our API. Right-click on the <code class="inlineCode">Data</code> project, select <strong class="screenText">Add</strong> | <strong class="screenText">Class</strong>, and name the class <code class="inlineCode">BlogApiJsonDirectAccess.cs</code>.</li>
<li class="numberedList">Open <code class="inlineCode">BlogApiJsonDirectAccess.cs</code> and replace the code with the following:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models.Interfaces;
using Microsoft.Extensions.Options;
using System.Text.Json;
using Data.Models;
namespace Data;
public class BlogApiJsonDirectAccess: IBlogApi
{
}
</code></pre>
<p class="normal">This is the start of our JSON direct access class. It references the <code class="inlineCode">IBlogAPI</code> and we will implement each method the interface wants.</p>
<p class="normal">The error list should contain many errors since we haven’t implemented the methods yet. We are inheriting from the <code class="inlineCode">IBlogApi</code>, so we know what methods to expose.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">To be able to read <a id="_idIndexMarker111"/>settings, we also add a way to inject <code class="inlineCode">IOptions</code>. By getting the settings this way, we don’t have to add any code – it can come from a database, a settings file, or even be hard coded. 
    <p class="numberedList">This is my favorite way to get settings because this part of the code itself doesn’t know how to do it – instead, we add all our configurations using dependency injection.</p>
<p class="normal">Add the following code to the <code class="inlineCode">BlogApiJsonDirectAccess</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">    BlogApiJsonDirectAccessSetting _settings;
    public BlogApiJsonDirectAccess( IOptions&lt;BlogApiJsonDirectAccessSetting&gt; option)
    {
        _settings = option.Value;
        ManageDataPaths();
    }
    private void ManageDataPaths()
    {
        CreateDirectoryIfNotExists(_settings.DataPath);
        CreateDirectoryIfNotExists($@"{_settings.DataPath}\{_settings.BlogPostsFolder}");
        CreateDirectoryIfNotExists($@"{_settings.DataPath}\{_settings.CategoriesFolder}");
        CreateDirectoryIfNotExists($@"{_settings.DataPath}\{_settings.TagsFolder}");
        CreateDirectoryIfNotExists($@"{_settings.DataPath}\{_settings.CommentsFolder}");
    }
    private static void CreateDirectoryIfNotExists(string path)
    {
        if (!Directory.Exists(path))
        {
            Directory.CreateDirectory(path);
        }
    }
</code></pre>
<p class="normal">We get the injected<a id="_idIndexMarker112"/> setting and ensure we have the correct folder structure for our data.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">Now, it’s time to implement the API, but first, we need a couple of helper methods that can load the data from our file system. To do this, we add the following code to our class:
        <pre class="programlisting code"><code class="hljs-code">private async Task&lt;List&lt;T&gt;&gt; LoadAsync&lt;T&gt;(string folder)
{
    var list = new List&lt;T&gt;();
    foreach (var f in Directory.GetFiles($@"{_settings.DataPath}\{folder}"))
    {
        var json = await File.ReadAllTextAsync(f);
        var blogPost = JsonSerializer.Deserialize&lt;T&gt;(json);
        if (blogPost is not null)
        {
            list.Add(blogPost);
        }
    }
    return list;
}
</code></pre>
</li>
<li class="numberedList">The <code class="inlineCode">LoadAsync</code> method is a generic method that allows us to load blog posts, tags, comments, and categories using the same method. It will load data from the file system whenever we ask for it. This would be a great place to put in some cache logic, but this is closer to what the implementation would look like if we used a database (we would always ask the database).</li>
<li class="numberedList">Next, we will add a couple of methods to help manipulate the data, namely <code class="inlineCode">SaveAsync</code> and <code class="inlineCode">Delete</code>. Add <a id="_idIndexMarker113"/>the following methods:
        <pre class="programlisting code"><code class="hljs-code">private async Task SaveAsync&lt;T&gt;(string folder, string filename, T item)
{
    var filepath = $@"{_settings.DataPath}\{folder}\{filename}.json";
    await File.WriteAllTextAsync(filepath, JsonSerializer.Serialize&lt;T&gt;(item));
}
private Task DeleteAsync(string folder, string filename)
 {
     var filepath = $@"{_settings.DataPath}\{folder}\{filename}.json";
     if (File.Exists(filepath))
     {
         File.Delete(filepath);
     }
     return Task.CompletedTask;
 }
</code></pre>
<p class="normal">These methods are<a id="_idIndexMarker114"/> also generic to share as much code as possible and avoid repeating the code for every type of class (<code class="inlineCode">BlogPost</code>, <code class="inlineCode">Category</code>, <code class="inlineCode">Comment,</code> and <code class="inlineCode">Tag</code>).</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="11">Next, it’s time to implement the API by adding the methods to get blog posts. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">public async Task&lt;int&gt; GetBlogPostCountAsync()
 {
     var list = await LoadAsync&lt;BlogPost&gt;(_settings.BlogPostsFolder);
     return list.Count;
 }
 public async Task&lt;List&lt;BlogPost&gt;&gt; GetBlogPostsAsync(int numberofposts, int startindex)
 {
     var list = await LoadAsync&lt;BlogPost&gt;(_settings.BlogPostsFolder);
     return list.Skip(startindex).Take(numberofposts).ToList();
 } 
public async Task&lt;BlogPost?&gt; GetBlogPostAsync(string id)
    {
        var list = await LoadAsync&lt;BlogPost&gt;(_settings.BlogPostsFolder);
        return list.FirstOrDefault(bp =&gt; bp.Id == id);
    }
</code></pre>
<p class="normal">The <code class="inlineCode">GetBlogPostsAsync</code> method takes a couple of parameters we will use later for paging. It will get the blog posts from our JSON storage and return the posts we are asking for, skipping and taking the right amount for our paging. </p>
<p class="normal">We also have a method that returns the current blog post count, which we will use for paging. Last but not least, we have <code class="inlineCode">GetBlogPostAsync</code> for getting a single blog post from our JSON storage.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="12">Now, we need to add<a id="_idIndexMarker115"/> the same methods for categories. To do this, add the following code:
        <pre class="programlisting code"><code class="hljs-code">    public async Task&lt;List&lt;Category&gt;&gt; GetCategoriesAsync()
    {
        return await LoadAsync&lt;Category&gt;(_settings.CategoriesFolder);
    }
    public async Task&lt;Category?&gt; GetCategoryAsync(string id)
    {
        var list = await LoadAsync&lt;Category&gt;(_settings.CategoriesFolder);
        return list.FirstOrDefault(c =&gt; c.Id == id);
    }
</code></pre>
</li>
<li class="numberedList">The <code class="inlineCode">Category</code> methods don’t have any support for paging. Otherwise, they should look familiar as they do almost the same as the blog post methods.</li>
<li class="numberedList">Now, it’s time to do the same thing for tags. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">    public async Task&lt;List&lt;Tag&gt;&gt; GetTagsAsync()
    {
        return await LoadAsync&lt;Tag&gt;(_settings.TagsFolder);
    }
    public async Task&lt;Tag?&gt; GetTagAsync(string id)
    {
        var list = await LoadAsync&lt;Tag&gt;(_settings.TagsFolder);
        return list.FirstOrDefault(t =&gt; t.Id == id);
    }
</code></pre>
<p class="normal">As we can see, the <code class="inlineCode">tag</code> code is basically a copy of the code for categories.</p>
<p class="normal">We also need a way to retrieve the comments for a blog post. We will not create a method to retrieve one <code class="inlineCode">comment</code>; we always get all the comments for a specific post. Add the following method:</p>
<pre class="programlisting code"><code class="hljs-code">    public async Task&lt;List&lt;Comment&gt;&gt; GetCommentsAsync(string blogPostId)
    {
        var list = await LoadAsync&lt;Comment&gt;(_settings.
CommentsFolder);
        return list.Where(t =&gt; t.BlogPostId == blogPostId).ToList();
    }
</code></pre>
<p class="normal">This method will get all the comments for a blog post.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="15">We also need a couple of methods for saving the data, so next up, we’ll add methods for saving <a id="_idIndexMarker116"/>blog posts, categories, comments, and tags.
    <p class="normal">Add the following code:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task&lt;BlogPost?&gt; SaveBlogPostAsync(BlogPost item)
{
    item.Id ??= Guid.NewGuid().ToString();
    await SaveAsync(_settings.BlogPostsFolder, item.Id, item);
    return item;
}
public async Task&lt;Category?&gt; SaveCategoryAsync(Category item)
{
    item.Id ??= Guid.NewGuid().ToString();
    await SaveAsync(_settings.CategoriesFolder, item.Id, item);
    return item;
}
public async Task&lt;Tag?&gt; SaveTagAsync(Tag item)
{
    item.Id ??= Guid.NewGuid().ToString();
    await SaveAsync(_settings.TagsFolder, item.Id, item);
    return item;
}
public async Task&lt;Comment?&gt; SaveCommentAsync(Comment item)
{
    item.Id ??= Guid.NewGuid().ToString();
    await SaveAsync(_settings.CommentsFolder, item.Id, item);
    return item;
}
</code></pre>
<p class="normal">The first thing we do is to check that the <code class="inlineCode">id</code> of the item is not null. If it is, we create a new <code class="inlineCode">Guid</code>. This is the <code class="inlineCode">id</code> of the new item. And this is also going to be the name of the JSON files stored on the file system.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="16">We now have a<a id="_idIndexMarker117"/> method for saving and getting items. But sometimes, things don’t go as planned, and we need a way to delete the items that we have created. Next up, we will add some delete methods. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">    public async Task DeleteBlogPostAsync(string id)
    {
        await DeleteAsync(_settings.BlogPostsFolder, id);
        
        var comments = await GetCommentsAsync(id);
        foreach (var comment in comments)
        {
            if (comment.Id != null)
            {
                await DeleteAsync(_settings.CommentsFolder, comment.Id);
            }
        }
    }
    public async Task DeleteCategoryAsync(string id)
    {
        await DeleteAsync(_settings.CategoriesFolder, id);
    }
    public async Task DeleteTagAsync(string id)
    {
        await DeleteAsync(_settings.TagsFolder, id);
    }
    public async Task DeleteCommentAsync(string id)
    {
        await DeleteAsync(_settings.CommentsFolder, id);
    }
</code></pre>
</li>
</ol>
<p class="normal">The code we just added calls the <code class="inlineCode">DeleteAsync</code> method, which deletes the blog post, tag, category, etc.</p>
<p class="normal">Our JSON storage is done!</p>
<p class="normal">In the end, there will be four<a id="_idIndexMarker118"/> folders stored on the file system, one for blog posts, one for categories, one for comments, and one for tags.</p>
<p class="normal">The next step is to add and configure the Blazor project to use our new storage.</p>
<h1 class="heading-1" id="_idParaDest-59">Adding the API to Blazor</h1>
<p class="normal">We now have a way to<a id="_idIndexMarker119"/> access JSON files stored on our file system. In the repo on GitHub, you can <a id="_idIndexMarker120"/>find more ways of storing our data with RavenDB or SQL Server, but be mindful to keep the focus on what is important (Blazor).</p>
<p class="normal">Now it’s time to add the API to our Blazor Server project:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp</code> project, <strong class="screenText">add a project reference</strong> to the <code class="inlineCode">Data</code> project. Open <code class="inlineCode">Program.cs</code> and add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">using Data;
using Data.Models.Interfaces;
</code></pre>
</li>
<li class="numberedList">Add the following code after .AddInteractiveWebAssemblyComponents();:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddOptions&lt;BlogApiJsonDirectAccessSetting&gt;().Configure(options =&gt;
{
    options.DataPath = @"..\..\..\Data\";
    options.BlogPostsFolder = "Blogposts";
    options.TagsFolder = "Tags";
    options.CategoriesFolder = "Categories";
    options.CommentsFolder = "Comments";
});
builder.Services.AddScoped&lt;IBlogApi, BlogApiJsonDirectAccess&gt;();
</code></pre>
</li>
</ol>
<pre>IOptions&lt;BlogApiJsonDirectAccessSetting&gt;</code>, the dependency injection will return an object populated with the<a id="_idIndexMarker121"/> information we have supplied above. This is an excellent place to load configuration from our .NET configuration, a key vault, or a database.</pre>
<p class="normal">We are also saying that<a id="_idIndexMarker122"/> when we ask for an <code class="inlineCode">IBlogAPI</code> we will get an instance of <code class="inlineCode">BlogApiJsonDirectAccess</code> back from our dependency injection. We will return to dependency injection in <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>.</p>
<p class="normal">Now, we can use our API to access the database in our Blazor project.</p>
<h1 class="heading-1" id="_idParaDest-60">Summary</h1>
<p class="normal">This chapter taught us how to create a simple JSON repository for our data. We also learned that other alternatives could be found in the GitHub repo if you want to look at other options.</p>
<p class="normal">We also created an interface to access the data, which we will use some more later in the book.</p>
<p class="normal">In the next chapter, we will learn about components, particularly the built-in components in Blazor templates. We will also create our first component using the API and repository we made in this chapter.</p>
</div>
</body></html>