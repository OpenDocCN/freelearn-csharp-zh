<html><head></head><body>
		<div><h1 id="_idParaDest-274"><em class="italic"><a id="_idTextAnchor280"/>Chapter 16</em>: Asynchronous Programming</h1>
			<p>In this chapter, you will learn about the <code>async</code>, <code>await</code>, and <code>WhenAll</code>. You will also learn about different return types and extract the required results. Plus, you will learn how to correctly cancel asynchronous operations and perform asynchronous file reading and writing.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li><strong class="bold">Understanding the TAP model</strong>: In this section, we provide a high-level overview of the TAP model.</li>
				<li><code>Task.Run</code>) and asynchronously.</li>
				<li><code>GetAwaiter.GetResult()</code>, <code>.Result</code>, and <code>.Wait</code> for both <code>Task</code> and <code>ValueTask</code>.</li>
				<li><strong class="bold">Canceling asynchronous operations</strong>: In this section, we write code that demonstrates asynchronous task cancellation.</li>
				<li><strong class="bold">Writing files asynchronously</strong>: In this section, we write text to a file asynchronously.</li>
				<li><strong class="bold">Reading files asynchronously</strong>: In this section, we read text from a file asynchronously.</li>
			</ul>
			<p>After completing this chapter, you will be skilled in the following areas:</p>
			<ul>
				<li>Understanding the TAP model</li>
				<li>Processing web resources asynchronously</li>
				<li>Writing files asynchronously</li>
				<li>Reading files asynchronously</li>
			</ul>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor281"/>Technical requirements</h1>
			<p>You'll need Visual Studio to work on the code presented in this chapter.</p>
			<p>All code from this chapter is placed on GitHub at <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16</a>.</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor282"/>Understanding the TAP model</h1>
			<p>Before we begin, it is<a id="_idIndexMarker1496"/> worth noting that there are three different models for dealing with asynchronous programming. These are as follows:</p>
			<ul>
				<li>The <strong class="bold">Asynchronous Programming Model</strong> (<strong class="bold">APM</strong>)</li>
				<li>The <strong class="bold">Event-Based Asynchronous Pattern</strong> (<strong class="bold">EAP</strong>) model</li>
				<li>The <strong class="bold">Task Parallelism Library</strong> (<strong class="bold">TPL</strong>)</li>
			</ul>
			<p>APM uses <code>BeginMethod</code> to start the asynchronous process and <code>EndMethod</code> to complete the asynchronous process. EAP uses <code>MethodAsync</code> to start an asynchronous process, <code>CancelAsync</code> to handle the cancellation of an asynchronous operation, and a completed event handler to handle the completed asynchronous operation. Both these ways of performing asynchronous operations were replaced by TPL in C# 4.5.</p>
			<p>TPL uses the <code>async</code> and <code>await</code> pattern. Asynchronous method names are suffixed with <code>async</code>. An asynchronous method usually returns an awaitable <code>Task</code> or <code>Task&lt;Result&gt;</code>. From .NET 4.5 onwards, you are advised to use TPL instead of using APM and EAP.</p>
			<p>TAP's foundation types are the <code>System.Thread.Tasks</code> namespace, and the <code>Task</code> and <code>Task&lt;Tresult&gt;</code> classes via asynchronous operations. Microsoft advises that you should use TAP when starting new projects.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor283"/>Naming, parameters, and return types</h2>
			<p>An asynchronous method <a id="_idIndexMarker1497"/>using the TAP model prefixes the method signature with <code>async Task</code> for void methods, or <code>async Task&lt;Tresult&gt;</code>, <code>async ValueTask</code>, or <code>async ValueTask&lt;Tresult&gt;</code> for methods that return a value. The name of an asynchronous method that does not return a value should begin with a verb such as <code>Begin</code> or <code>Process</code>.</p>
			<p>TAP method parameters should match <a id="_idIndexMarker1498"/>and be in the same order as the parameters of synchronous counterpart methods. You should avoid entirely using <code>out</code> and <code>ref</code> parameters that are exempt from this rule. If you need to return data, use <code>Tresult</code> returned by <code>Task&lt;Tresult&gt;</code>. Use data structures to accommodate multiple return<a id="_idIndexMarker1499"/> types. It is also worth considering adding cancellation tokens to TAP methods as parameters even if synchronous method counterparts don't have such tokens.</p>
			<p>Combinator methods that work with multiple tasks where the intent is clear do not have to follow this naming pattern. <code>WhenAll</code> and <code>WhenAny</code> are examples of combinator methods.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor284"/>Initiating asynchronous operations</h2>
			<p>You may wish to perform <a id="_idIndexMarker1500"/>some synchronous tasks, such as validation and preparing the asynchronous operation for execution, at the start of an asynchronous method. If so, you are advised to keep these tasks to the minimum, and the time they take should be minimal. The reason is that such methods may be invoked from <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) threads, and you don't want to cause your applications to hang or freeze momentarily.</p>
			<p>Another reason for keeping synchronous operations to the minimum and for spending minimal time within asynchronous operations is that when you run concurrent asynchronous methods, long-running synchronous operations can and do decrease the benefits of concurrency.</p>
			<p>Sometimes, it can take longer to prepare and launch an asynchronous operation than it can take to complete the same operation synchronously. In these situations, you can run the method synchronously and return a task.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor285"/>Exceptions</h2>
			<p>Usage errors, such as passing <code>null</code> arguments, are the only errors that should be raised in asynchronous methods. You can prevent asynchronous methods from raising usage errors by modifying the calling code to ensure that erroneous arguments are not passed into the asynchronous <a id="_idIndexMarker1501"/>methods. All other types of exceptions and errors should be assigned to the task being returned. Normally, one exception is returned by one task. But when there are multiple operations represented by a single task, multiple exceptions may be returned by a single task.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor286"/>Optional cancellation</h2>
			<p>Cancellation of asynchronous <a id="_idIndexMarker1502"/>method implementers and consumers is optional. An asynchronous method that can be canceled, exposes an overload method that accepts a <code>CancellationToken</code> that is named <code>cancellationToken</code> by convention.</p>
			<p>Cancellation requests are monitored by the asynchronous operation. When a cancellation request is received, it may be honored. If cancellation results in unfinished work, a task in the <code>Canceled</code> state is returned with no available result and no exceptions.</p>
			<p>The <code>Canceled</code> state is a completed task state, as are <code>RanToCompletion</code> and <code>Faulted</code>. When a task's state is either <code>Canceled</code>, <code>RanToCompletion</code>, or <code>Faulted</code>, the <code>IsCompleted</code> property returns <code>true</code>.</p>
			<p>Continuations will continue to be scheduled and executed when a task is canceled unless the <code>NotOnCancelled</code> continuation option is specified. If this option is specified, then continuations will not be scheduled or executed when a task is canceled.</p>
			<p>Asynchronous code waiting for canceled tasks via language features will continue to run but will receive an <code>OperationCanceledException</code> or one of its derivatives. And code that is blocked synchronously waiting on tasks through methods like <code>Wait</code> and <code>WaitAll</code> will continue to run with an exception.</p>
			<p>TAP methods should return a <code>Canceled</code> task when a cancellation token has requested cancellation before the TAP method that accepts the token has been called. During the execution of an asynchronous operation, cancellation requests can be ignored. When returning a task, you will normally return the task with one of three states:</p>
			<ul>
				<li><code>Canceled</code>: The operation has ended as a result of a cancellation request.</li>
				<li><code>RanToCompletion</code>: A cancellation was requested but the operation was completed and produced a result.</li>
				<li><code>Faulted</code>: A cancellation was requested that resulted in the generation of an exception.</li>
			</ul>
			<p>If you are coding an asynchronous method and want to enable the operation to be canceled first and foremost, then there is no need to produce an overload method devoid of a <code>CancellationToken</code>. If you are coding an asynchronous method that cannot be canceled, then you do not have to provide an overload method that accepts a <code>CancellationToken</code>. These<a id="_idIndexMarker1503"/> guidelines help the caller to know whether or not the target method can be canceled. When a method that accepts a <code>CancellationToken</code> is called by a consumer that has no desire to cancel the method call, <code>None</code> can be passed in for the <code>CancellationToken</code> argument, as this is functionally equivalent to the default <code>CancellationToken</code>.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor287"/>Optional Progress Reporting</h2>
			<p>When asynchronous operations are <a id="_idIndexMarker1504"/>running as part of a UI procedure, it can be beneficial to provide progress updates. This helps the end user to know that the program is still working.</p>
			<p>The <code>IProgress&lt;T&gt;</code> interface is used to handle progress and is passed into an asynchronous method as a parameter that is conventionally called <code>progress</code>. Passing this interface into an asynchronous method can help prevent race conditions that can occur when event handlers are incorrectly registered once the operation has started, which can lead to missed updates. Another reason for passing in an interface is that consuming code can support various progress implementations. Only provide an <code>IProgress&lt;T&gt;</code> interface when progress notifications are supported by the TAP implementation.</p>
			<p>An example that fits well with progress updates is the <code>FindFilesAsync</code> method, which returns a list of files meeting a particular search pattern. In this scenario, you could provide the percentage of work completed along with the current set of partial results. The information would be provided by some data type that is specific to your API. Such data types are conventionally suffixed with <code>ProgressInfo</code>.</p>
			<p>TAP methods that provide a progress parameter should allow no progress reporting by allowing the progress parameter to be <code>null</code>. Progress should be reported to the <code>Progress&lt;T&gt;</code> object that implements the <code>IProgress&lt;T&gt;</code> interface synchronously. This enables the asynchronous method to quickly provide progress. Consumers can then determine how and where they want to handle the information provided by the progress update.</p>
			<p>The <code>ProgressChanged</code> event is <a id="_idIndexMarker1505"/>exposed by instances of the <code>Progress&lt;T&gt;</code> class. This event is raised every time a progress update is reported by the asynchronous operation. When a <code>Progress&lt;T&gt;</code> object is instantiated, the <code>ProgressChanged</code> event is raised on the captured <code>SynchronizationContext</code> object. A default context that targets the thread pool is used when there is no synchronization context available.</p>
			<p>You can either register handlers for this event as you would any other event, and you can also provide the <code>Progress&lt;T&gt;</code> constructor with a single handler, for convenience. The single handler behaves the same as an event handler for the <code>ProgressChanged</code> event. During the execution of event handlers, delays to asynchronous operations are avoided by raising progress updates asynchronously.</p>
			<p>Now that we have a high-level understanding of the task-based asynchronous pattern, in the next section, we will look at <code>async</code>, <code>await</code>, and <code>Task</code>.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor288"/>async, await, and Task</h1>
			<p>In this section, we will be looking at the performance differences between running methods<a id="_idIndexMarker1506"/> synchronously, using <code>Task.Run</code>, and asynchronously. An asynchronous method is identified by the <code>async</code> keyword.</p>
			<p>The <code>await</code> keyword informs<a id="_idIndexMarker1507"/> the runtime to wait at the specified line until the current task has been completed. It can only be used with a method that is prefixed <a id="_idIndexMarker1508"/>with the <code>async</code> keyword.</p>
			<p>The <code>System.Threading.Tasks</code> namespace. A task encapsulates threading in order to maximize the use of multiple cores on computer hardware.</p>
			<p>Let's write a simple project to benchmark three different ways of calling a method. We will call the method synchronously using <code>Task.Run</code>, and asynchronously using <code>async/await</code>. We will be using <code>BenchmarkDotNet</code> to see how each method call type performs. We aim to show the performance advantage of using asynchronous calls over synchronous<a id="_idIndexMarker1510"/> and <code>Task.Run</code> calls.</p>
			<p>We perform the following <a id="_idIndexMarker1511"/>steps to write our little program:</p>
			<ol>
				<li>Start a new .NET 6.0 console application and call it <code>CH16_AsynchronousProgramming</code>.</li>
				<li>Add the <code>BenchmarkDotNet</code> NuGet package.</li>
				<li>Add a new class called <code>Benchmarks</code>, and in that class add the following method:<pre>public static void LengthyTask()
{
     int y = 0;
     for (int x = 0; x &lt; 10; x++)
          y++;
}</pre></li>
			</ol>
			<p>This method is our worker method. All it does is increment the <code>y</code> variable by one for ten iterations.</p>
			<ol>
				<li value="4">Add the <code>SynchronousMethod</code> to the class:<pre>[Benchmark]
public void SychronousMethod()
{
      LengthyTask();
}</pre></li>
			</ol>
			<p>This method calls the <code>LengthyTask</code> method synchronously and is a benchmark.</p>
			<ol>
				<li value="5">Add the <code>TaskMethod</code> to the class:<pre>[Benchmark]
public void TaskMethod()
{
     Task.Run(new Action(LengthyTask));
}</pre></li>
			</ol>
			<p>This method runs the <code>LengthyTask</code> method as a new <code>Action</code>, which is queued to run on the <code>ThreadPool</code>. A <code>Task</code> or <code>Task&lt;Tresult&gt;</code> handle is returned for<a id="_idIndexMarker1512"/> that method.</p>
			<ol>
				<li value="6">Add the <code>AsynchronousTaskMethod</code> to the class:<pre>[Benchmark]
public void AsynchronousTaskMethod()
{
     var data = async () =&gt; await Task.Run(new   
         Action(LengthyTask));
}</pre></li>
			</ol>
			<p>This method runs the <code>LengthyTask</code> method as an action using <code>Task.Run</code> asynchronously, and await the completion of the method before it continues.</p>
			<ol>
				<li value="7">Our <a id="_idIndexMarker1513"/>benchmark class is now complete. So, in the <code>Program.cs</code> file, replace the code with the following:<pre>using BenchmarkDotNet.Running;
using CH16_AsynchronousProgramming;
Console.WriteLine("CH16 - Asynchronous Programming");
var summary = BenchmarkRunner.Run&lt;Benchmarks&gt;();
Console.ReadLine();</pre></li>
			</ol>
			<p>This code will run our benchmarks and produce a report for us.</p>
			<ol>
				<li value="8">Make sure that the <a id="_idIndexMarker1514"/>project is set to <code>Release</code> build.</li>
				<li>Build the project.</li>
				<li>Open a command window and execute the compiled executable file called <code>CH16_AsynchronousProgramming.exe</code> in the <code>bin\Release\net6.0</code> folder.</li>
				<li>The benchmarks should start running, and once complete, you should see a report like the<a id="_idIndexMarker1515"/> one shown in <em class="italic">Figure 16.1</em>:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_16.1.jpg" alt="Figure 16.1 – The BenchmarkDotNet report for our CH16_AsynchronusProgramming Project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – The BenchmarkDotNet report for our CH16_AsynchronusProgramming Project</p>
			<p>As you can see in <em class="italic">Figure 16.1</em>, running the <code>LengthyTask</code> method synchronously took <code>7.3220 ns</code> to complete. Using <code>Task.Run</code> took the longest time to run at <code>112.4494 ns</code>. And the<a id="_idIndexMarker1516"/> fastest way to run the code was asynchronously, which only took <code>0.9982ns</code> to complete.</p>
			<p>We can clearly see from<a id="_idIndexMarker1517"/> those times that there is a clear performance benefit to running our code asynchronously, as it takes less overall time for our code to complete.</p>
			<p>In the next section, we will compare the performance of <code>await</code> with <code>GetAwaiter.GetResult()</code>, <code>.Result</code>, and <code>.Wait</code>. We will cover both <code>Task</code> and <code>ValueTask</code>.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor289"/>Benchmarking GetAwaiter.GetResult(), .Result, and .Wait for both Task and ValueTask</h1>
			<p>In this section, we will be<a id="_idIndexMarker1518"/> writing some code to benchmark the <code>GetAwaiter.GetResult()</code>, <code>.Result</code>, and <code>.Wait</code> methods to <a id="_idIndexMarker1519"/>see which method is best for <a id="_idIndexMarker1520"/>obtaining the return value for both a <code>Task</code> and a <code>ValueTask</code>.</p>
			<p>At <a href="https://github.com/dotnet/BenchmarkDotNet/issues/236">https://github.com/dotnet/BenchmarkDotNet/issues/236</a>, the <code>BenchmarkDotNet</code> maintainer called <em class="italic">adamsitnik</em> wrote in reply to <em class="italic">@i3arnon</em>:</p>
			<p><em class="italic">"@i3arnon Thanks for the hint! I have measured</em> <code>.Result</code><em class="italic"> vs </em><code>.Wait</code><em class="italic"> vs</em> <code>GetAwaiter.GetResult()</code> <em class="italic">and it seems that for</em> <code>Tasks</code> <em class="italic">the </em><code>GetAwaiter.GetResult()</code> <em class="italic">is also the fastest way to go. On the other hand, for </em><code>ValueTask</code><em class="italic"> it was much more slower so I stayed with</em> <code>.Result</code><em class="italic"> for VT</em>."</p>
			<p>And so, from the code that we will be writing, we should see that <code>.Result</code> should provide us with the best performance when working with a <code>ValueTask</code>. And <code>GetAwaiter.GetResult()</code> should give us the best performance when working with a <code>Task</code>.</p>
			<p>We will now start writing our code. Please complete the following tasks in the <code>CH16_AsynchronousProgramming</code> project that we started in the previous section:</p>
			<ol>
				<li value="1">Open the <code>CH16_AsynchronousProgramming</code> project.</li>
				<li>Open the <code>Benchmarks</code> class.</li>
				<li>Add the following<a id="_idIndexMarker1521"/> method that returns an <code>int</code>:<pre>public static int LengthyTaskReturnsInt()
{
     int y = 0;
     for (int x = 0; x &lt; 10; x++)
         y++;
      return y;
}</pre></li>
			</ol>
			<p>In this code, we<a id="_idIndexMarker1522"/> are incrementing the <code>y</code> variable and returning<a id="_idIndexMarker1523"/> the result.</p>
			<ol>
				<li value="4">Add the <code>GetAwaiterGetResult</code> method:<pre>[Benchmark]
public void GetAwaiterGetResult()
{
     int value = Task.Run(() =&gt; 
         LengthyTaskReturnsInt()).GetAwaiter()
           .GetResult();
}</pre></li>
			</ol>
			<p>This method benchmarks the time taken to return an <code>int</code> from a method using <code>GetAwaiter().GetResult()</code>.</p>
			<ol>
				<li value="5">Add the <code>Result</code> method:<pre>[Benchmark]
public async Task Result()
{
     int value = await Task.Run(() =&gt; 
       LengthyTaskReturnsInt()).ConfigureAwait(false);
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker1524"/>benchmarks the time taken<a id="_idIndexMarker1525"/> to await the return of <code>int</code> from a method.</p>
			<ol>
				<li value="6">Add the <code>Wait</code> method:<pre>[Benchmark]
public void Wait()
{
     Task.Run(() =&gt; LengthyTask()).Wait();
}</pre></li>
			</ol>
			<p>This method runs a lengthy <a id="_idIndexMarker1526"/>task and waits for it to finish before continuing.</p>
			<ol>
				<li value="7">Add the <code>GetAwaiter</code> method:<pre>[Benchmark]
public void GetAwaiter()
{
         Task.Run(() =&gt; LengthyTask()).GetAwaiter();
}</pre></li>
			</ol>
			<p>This method gets an awaiter used to await the task completion.</p>
			<ol>
				<li value="8">Build the project and<a id="_idIndexMarker1527"/> run the executable via the command line. You should see a summary report<a id="_idIndexMarker1528"/> like the one shown in <em class="italic">Figure 16.2</em>:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_16.2.jpg" alt="Figure 16.2 – The BenchmarkDotNet summary report for this section's methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2 – The BenchmarkDotNet summary report for this section's methods</p>
			<p>As we can see from these results, when<a id="_idIndexMarker1529"/> returning a value from a <code>Task</code>, the <code>GetAwaiterGetResult</code> method operates much faster than the <code>Result</code> method. And when executing a long-running <code>Task</code>, the <code>GetAwaiter</code> method operates much more quickly than the <code>Wait</code> method.</p>
			<p>In the next section, we will look at how we can speed up our code asynchronously when awaiting multiple tasks by using <code>WhenAll</code>.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor290"/>Using async, await, and WhenAll</h1>
			<p>In this section, we will write some<a id="_idIndexMarker1530"/> example code that demonstrates the use of <code>async</code>, <code>await</code>, and <code>WhenAll</code> and the effect on execution time. </p>
			<p>If you have multiple tasks that are being <a id="_idIndexMarker1531"/>executed in a method and you <code>await</code> each task, your code will work asynchronously, and the execution time will be expensive. You can circumvent this time expense with improved performance by using <code>WhenAll</code> to <code>await</code> all completed tasks before continuing. In the code we will be writing, you will see how <code>WhenAll</code> reduces<a id="_idIndexMarker1532"/> the time taken to execute two asynchronous methods within a function when compared to awaiting each task in turn.</p>
			<p>Let's work our way through the following tasks:</p>
			<ol>
				<li value="1">In the <code>Benchmarks</code> class still, add the following asynchronous method, which waits <code>300</code> milliseconds before returning an <code>int</code>:<pre>private async Task&lt;int&gt; TaskOne()
{
     await Task.Delay(300);
     return 100;
}</pre></li>
			</ol>
			<p>The <code>TaskOne</code> method is the first of our methods that will be run by our benchmarks.</p>
			<ol>
				<li value="2">Add the second of our asynchronous methods:<pre>private async Task&lt;string&gt; TaskTwo()
{
     await Task.Delay(300);
     return "TaskTwo";
}</pre></li>
			</ol>
			<p>The <code>TaskTwo</code> method waits for <code>300</code> milliseconds and then returns a <code>string</code>.</p>
			<ol>
				<li value="3">Firstly, we will benchmark running asynchronous tasks synchronously:<pre>[Benchmark]
public async Task SynchronousAwait()
{
     int intValue = await TaskOne();
     string stringValue = await TaskTwo(); 
} </pre></li>
			</ol>
			<p>Here, we have two<a id="_idIndexMarker1533"/> tasks and we <code>await</code> them both to complete before <a id="_idIndexMarker1534"/>continuing.</p>
			<ol>
				<li value="4">Now, we'll add our <a id="_idIndexMarker1535"/>method that will utilize <code>WhenAll</code>:<pre>[Benchmark]
public async Task AsynchynchronousWhenAll()
{
     var taskOne = TaskOne();
     var taskTwo = TaskTwo();
     await Task.WhenAll(taskOne, taskTwo);
}</pre></li>
			</ol>
			<p>In this method, we create our two tasks, then we pass them into the <code>WhenAll</code> method as parameters. We do not continue until all tasks are complete.</p>
			<ol>
				<li value="5">Build and run your executable via the command line. You should see something like <em class="italic">Figure 16.3</em>:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_16.3.jpg" alt="Figure 16.3 – The results of synchronous and asynchronous execution of multiple asynchronous calls&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.3 – The results of synchronous and asynchronous execution of multiple asynchronous calls</p>
			<p>As you can see from<a id="_idIndexMarker1536"/> the results of our benchmarking, using <code>WhenAll</code> executes<a id="_idIndexMarker1537"/> multiple asynchronous tasks <a id="_idIndexMarker1538"/>much faster than when you await them in turn. In the next section, we will look at canceling asynchronous tasks.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor291"/>Canceling asynchronous operations</h1>
			<p>In this section, we will look at how we <a id="_idIndexMarker1539"/>can cancel long-running asynchronous operations. Sometimes a task will take longer than it should do. A good example of this is fetching data from a website when it goes down. Asynchronous operations can take a long time before they are reset by the server due to something like <code>Error 404</code>, <code>Error 401</code>, or <code>Error 500</code> for example. And so, it pays to have the ability to cancel an asynchronous operation after a set period to prevent wasting an end user's time.</p>
			<p>The code we will write will return the text from a website URL. We will assign a very short timeout. This timeout will cancel the task that is responsible for returning the website text. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>CH16_AsynchronousProgramming</code> project, and add a new class called <code>TaskCancellation</code>.</li>
				<li>Add the <code>using System.Text;</code> statement.</li>
				<li>Add the following two member variables:<pre>private const string _website = 
    "https://docs.microsoft.com";
private static readonly CancellationTokenSource 
    _cancellationTokenSource = new();</pre></li>
			</ol>
			<p>The <code>_website</code> variable holds the URL of the website whose page text we will be returning. And the <code>CancellationTokenSource</code> will be used to signal to a <code>CancellationToken</code> that it should be cancelled.</p>
			<ol>
				<li value="4">Add the following<a id="_idIndexMarker1540"/> method:<pre>private static readonly HttpClient HttpClient = new()
{
     MaxResponseContentBufferSize = 1000000
};</pre></li>
			</ol>
			<p>Here, we declare a method that returns a <code>HttpClient</code> for our HTTP request. The <code>MaxResponseContentBufferSize</code> sets the number of bytes to buffer when reading the response content.</p>
			<ol>
				<li value="5">Now add the <code>ReturnWebsiteTextAsync</code> method:<pre>private static async Task&lt;string&gt; 
    ReturnWebsiteTextAsync()
{
     HttpResponseMessage response = await HttpClient
             .GetAsync(
             _website, 
             _cancellationTokenSource.Token)
           .ConfigureAwait(false);
     byte[] contentAsByteArray = await response
         .Content
         .ReadAsByteArrayAsync(
             _cancellationTokenSource.Token)
           .ConfigureAwait(false);
     return Encoding.ASCII.GetString(
         contentAsByteArray
     );
}</pre></li>
			</ol>
			<p>In this method, we declare <code>HttpResponseMessage</code>, which awaits an asynchronous task that returns the contents of a web page. The response is then read and<a id="_idIndexMarker1541"/> converted into a byte array. This byte array is then transformed into an ASCII string and returned.</p>
			<ol>
				<li value="6">Now add the <code>Start</code> method:<pre>public static async Task Start()
{
     Console.WriteLine("Task started.");
     try {
         _cancellationTokenSource.CancelAfter(3000);
           await ReturnWebsiteTextAsync()
             .ConfigureAwait(false);
     }
     catch (OperationCanceledException) {
       Console.WriteLine(
       "\nThe task has timed out and been cancelled.
         \n");
     }
     finally {
         _cancellationTokenSource.Dispose();
     }
     Console.WriteLine("Task completed.");
}</pre></li>
			</ol>
			<p>In the <code>Start</code> method, we write<a id="_idIndexMarker1542"/> a console message that states the task has started. We then set the cancellation time of <code>cancellationTokenSource</code> to 30 seconds, which is 3000 milliseconds. Then we <code>await</code> the call to the <code>ReturnWebsiteTextAsync</code>. If the process times out after the set timeout period, an <code>OperationCanceledException</code> is raised, which outputs a message to the console. Finally, <code>cancellationTokenSource</code> is disposed of and a console message is an output stating that the task is finished.</p>
			<ol>
				<li value="7">Comment out the benchmark running code in the <code>Program.cs</code> file, and add the following line:<pre>TaskCancellation.Start().GetAwaiter();</pre></li>
				<li>Run the project and try it several times with different timeout periods to test the code completing successfully and returning text, and to test the operation timing out and raising an exception.</li>
			</ol>
			<p>Running this code through a couple of times with timeouts of <code>3000</code> and <code>30000</code> will present an operation timeout exception and display the web page text, respectively. As you can see if you run the code yourself, it is very easy to write asynchronous tasks that are canceled after a set period.</p>
			<p>In the next section, we will be writing code that shows how to write files asynchronously.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor292"/>Writing files asynchronously</h1>
			<p>In this section, we will write<a id="_idIndexMarker1543"/> text to a file asynchronously. Scenarios where asynchronous file writing can be useful include writing large volumes of text and data to files that will not be read immediately.</p>
			<p>Use the following steps to write our code:</p>
			<ol>
				<li value="1">On your <code>C:\</code> drive, add a folder called <code>Temp</code> if one does not already exist.</li>
				<li>Open the <code>CH16_AsynchronousProgramming</code> project.</li>
				<li>Add a class called <code>FileReadWriteAsync</code>.</li>
				<li>Add the following method:<pre>public static async Task WriteTextAsync()
{
string filePath = @"C:\Temp\Greetings.txt";
string text = "Hello, World!";
byte[] encodedText = 
     Encoding.Unicode.GetBytes(text);
using (FileStream fileStream = new FileStream(
                    filePath,
                    FileMode.Append, 
                    FileAccess.Write, 
                    FileShare.None,
                    bufferSize: 4096, 
                    useAsync: true
                )
            )
{
         await fileStream.WriteAsync(
             encodedText, 0, encodedText.Length); 
};
}</pre></li>
			</ol>
			<p>In the <code>WriteTextAsync</code> method, we declare a file path for a text file and a variable that contains the text to be written to the file. The text to be written gets converted into a byte array. A writable asynchronous file stream is then opened in append mode. Then we write the text to the file stream and close it.</p>
			<p>In the next section, we continue<a id="_idIndexMarker1544"/> in this class as we add our asynchronous read method that shows how to read a file asynchronously.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor293"/>Reading files asynchronously</h1>
			<p>In this section, we will read<a id="_idIndexMarker1545"/> text from a file asynchronously. We will be building upon the code from the previous section that writes the text to a file asynchronously.</p>
			<p>The following steps will add our asynchronous read method and update the <code>Program.cs</code> file to run our asynchronous code:</p>
			<ol>
				<li value="1">In the <code>FileReadWriteAsync</code> class, add the following method:<pre>public static async Task&lt;string&gt; ReadTextAsync()
{
     string filePath = @"C:\Temp\Greetings.txt";
     using (FileStream fileStream = new FileStream(
             filePath,
               FileMode.Open, 
               FileAccess.Read, 
               FileShare.Read,
               bufferSize: 4096, 
               useAsync: true
         )
     )
     {
         StringBuilder sb = new StringBuilder();
         byte[] buffer = new byte[0x1000];
         int numRead;
         while (( numRead = await fileStream
           .ReadAsync(buffer, 0, buffer.Length)) != 0
         )
         {
             string text = Encoding.Unicode
                 .GetString(buffer, 0, numRead);
             sb.Append(text);
         }
         return sb.ToString();
     }
}</pre></li>
			</ol>
			<p>Here, we define the path <a id="_idIndexMarker1546"/>of the file that we need to read. Then we open a file stream in read mode with read access. Next, we define <code>StringBuilder</code> and byte array that will act as our buffer to store read data. We then read the stream until the read has been completed. During each iteration of the read, we read the text from the file, encode it into Unicode, and then append it to <code>StringBuilder</code>. Then, once the loop has finished and exits, we return the string from the method.</p>
			<ol>
				<li value="2">Open the <code>Program.cs</code> class.</li>
				<li>Comment out the following lines:<pre>//var summary = BenchmarkRunner.Run&lt;Benchmarks&gt;();
// TaskCancellation.Start().GetAwaiter();</pre></li>
			</ol>
			<p>We won't be needing these lines when we run our code.</p>
			<ol>
				<li value="4">Add the following lines of code:<pre>FileReadWriteAsync.WriteTextAsync().GetAwaiter();
string data = FileReadWriteAsync.ReadTextAsync()
    .GetAwaiter().GetResult();
Console.WriteLine(data);</pre></li>
			</ol>
			<p>In this code, we call our<a id="_idIndexMarker1547"/> methods that write text to a file asynchronously, read the text asynchronously into a variable, and then print the contents of the variable to the console.</p>
			<ol>
				<li value="5">Run the code, and you should see something like <em class="italic">Figure 16.3</em>:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_16.4.jpg" alt="Figure 16.4 – The result of our asynchronous write and read code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.4 – The result of our asynchronous write and read code</p>
			<p>As you can see from the screenshot, we have successfully written text asynchronously to a file, asynchronously read it from that file, and printed the contents to the console window.</p>
			<p>In the next section, we will summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor294"/>Summary</h1>
			<p>In this chapter, we began with a high-level overview of the task-based asynchronous pattern. Things we covered were naming, parameters, return types, initializing asynchronous operations, exceptions, and optionally providing ways to report progress updates and cancel operations. We saw that we can have asynchronous operations that allow cancellation, and those that don't allow cancellation. Plus, we learned that when a cancellation has been requested, the cancellation will either go ahead or be ignored. Completed tasks can have a completed state of <code>Canceled</code>, <code>RanToCompletion</code>, or <code>Faulted</code>.</p>
			<p>We then benchmarked three different ways of calling a method synchronously, using <code>Task.Run</code>, and asynchronously. Using <code>Task.Run</code> took the longest time, followed by running the method synchronously, and running the method asynchronously was by far the quickest way to run the method.</p>
			<p>Then we benchmarked <code>GetAwaiter.GetResult()</code>, <code>Result</code>, and <code>Wait</code> for both <code>Task</code> and <code>TaskValue</code>. We saw that when returning a value from a <code>Task</code>, the <code>GetAwaiterGetResult</code> method operates much faster than the <code>Result</code> method. And when executing a long-running <code>Task</code>, the <code>GetAwaiter</code> method operates much more quickly than the <code>Wait</code> method.</p>
			<p>Next, we looked at cancelling asynchronous operations. We coded an example that obtains the text from a website and outputs the text to the console. If the operation fails to complete within a set period of time, then it is cancelled.</p>
			<p>In the final two sections, we wrote some code to demonstrate the writing and reading of text and data asynchronously.</p>
			<p>To complete this chapter, there are some questions for you to answer to see how well you have retained what you have read and some further reading on asynchronous programming.</p>
			<p>Thank you for purchasing this book. I hope you have enjoyed reading it, and that you have learned plenty of ways to improve your own code. Happy coding!</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor295"/>Questions</h1>
			<ol>
				<li value="1">What does TAP stand for?</li>
				<li>What parameter type identifies that an asynchronous operation can be canceled?</li>
				<li>What parameter type is passed into an asynchronous task to provide progress updates?</li>
				<li>Explain <code>async</code>, <code>await</code>, and <code>Task</code>.</li>
				<li>How do you cancel an asynchronous operation?</li>
				<li>How do you report on an asynchronous operation's progress?</li>
			</ol>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor296"/>Further reading</h1>
			<ul>
				<li>Asynchronous programming; APM vs EAP: <a href="https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap">https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap</a></li>
				<li>Asynchronous programming: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/async">https://docs.microsoft.com/en-us/dotnet/csharp/async</a></li>
				<li>Introduction to async programming in C#: <a href="https://auth0.com/blog/introduction-to-async-programming-in-csharp/">https://auth0.com/blog/introduction-to-async-programming-in-csharp/</a></li>
				<li>The performance characteristics of async methods in C#: <a href="https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/">https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/</a></li>
				<li>Exception Handling (Task Parallel Library): <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library</a></li>
			</ul>
		</div>
	</body></html>