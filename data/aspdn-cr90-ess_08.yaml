- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Enhancing Applications with Middleware in ASP.NET Core 9
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中使用中间件增强应用程序
- en: ASP.NET Core 9 offers a robust and flexible framework designed to handle high-demand
    web applications. A key component of this framework is middleware, which allows
    developers to interact directly with the request and response pipeline. Understanding
    and leveraging middleware can significantly enhance your application’s capabilities.
    This chapter will dive deep into middleware, exploring its structure, implementation,
    and practical applications, such as global error handling, request limiting, and
    more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 提供了一个强大且灵活的框架，旨在处理高需求网络应用程序。该框架的关键组件是中间件，它允许开发者直接与请求和响应管道交互。理解和利用中间件可以显著增强应用程序的功能。本章将深入探讨中间件，包括其结构、实现和实际应用，如全局错误处理、请求限制等。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Knowing the middleware pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解中间件管道
- en: Implementing custom middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义中间件
- en: Working with factory-based middleware
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于工厂的中间件
- en: Adding capabilities to applications using middleware
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件为应用程序添加功能
- en: Creating an extension method for middleware registration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为中间件注册创建扩展方法
- en: In this chapter, we will explore essential best practices for developing applications
    with ASP.NET Core 9, covering the correct use of asynchronous mechanisms, HTTP
    requests, and application instrumentation through logs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用 ASP.NET Core 9 开发应用程序的基本最佳实践，包括正确使用异步机制、HTTP 请求以及通过日志进行应用程序仪表化。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持本章的学习，以下工具必须存在于您的开发环境中：
- en: '**Docker** : The Docker engine must be installed on your operating system and
    have an SQL Server container running. You can find more details about Docker and
    SQL Server containers in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：必须在您的操作系统上安装 Docker 引擎，并运行一个 SQL Server 容器。您可以在 [*第 5 章*](B21788_05.xhtml#_idTextAnchor078)
    中找到有关 Docker 和 SQL Server 容器的更多详细信息。'
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：此工具将用于执行对开发应用程序 API 的请求。'
- en: '**Redis Insight** : This tool is used to connect to a Redis Server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis Insight**：此工具用于连接到 Redis 服务器数据库（[https://redis.io/insight/](https://redis.io/insight/)）。'
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码示例可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08)
- en: Knowing the middleware pipeline
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解中间件管道
- en: During the previous chapters, we used several features of ASP.NET Core 9, including
    middleware.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了 ASP.NET Core 9 的几个功能，包括中间件。
- en: Middleware is a pipeline model used during the execution flow of an ASP.NET
    Core 9 web application to handle requests and responses, and the applications
    developed in this book already use some standard middleware from the .NET platform,
    such as **Authentication** , **Authorization** , **Cross-Origin Resource Sharing**
    ( **CORS** ), and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是在 ASP.NET Core 9 网络应用程序执行流程中用于处理请求和响应的管道模型，本书中开发的应用程序已经使用了一些来自 .NET 平台的标准中间件，例如
    **身份验证**、**授权**、**跨源资源共享**（**CORS**）等。
- en: 'The ASP.NET Core request pipeline consists of a sequence of request delegates,
    called one after the other. *Figure 8* *.1* demonstrates the concept:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 请求管道由一系列请求委托组成，一个接一个地调用。*图 8* *.1* 展示了这一概念：
- en: '![Figure 8.1 – ASP.NET Core 9 middleware pipeline](img/B21788_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – ASP.NET Core 9 中间件管道](img/B21788_08_01.jpg)'
- en: Figure 8.1 – ASP.NET Core 9 middleware pipeline
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – ASP.NET Core 9 中间件管道
- en: Request delegates are configured using the **Run** , **Map** , and **Use** extension
    methods typically configured in the **Program.cs** file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Run**、**Map** 和 **Use** 扩展方法配置请求委托，这些方法通常在 **Program.cs** 文件中配置。
- en: 'Each extension method has a template for registering a request delegate:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扩展方法都有一个用于注册请求委托的模板：
- en: '**Run** : The **app.Run** method is used to define an inline middleware that
    handles the request and completes the response, as in the following example code
    that implements an inline middleware:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：使用 **app.Run** 方法定义内联中间件，该中间件处理请求并完成响应，如下面的示例代码所示，它实现了内联中间件：'
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Map** : The **app.Map** method is used to create a branch in the middleware
    pipeline. In the following code, requests to **/SomeRoute** are handled by this
    middleware branch. The middleware in the branch writes a message to the response:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：使用 **app.Map** 方法在中间件管道中创建一个分支。在以下代码中，对 **/SomeRoute** 的请求由这个中间件分支处理。分支中的中间件将一条消息写入响应：'
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Use** : The **app.Use** method is used to add middleware to the pipeline.
    The following code uses a middleware to log the request method and path before
    calling the next middleware in the pipeline. After the next middleware completes,
    it logs the response status code:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**：使用 **app.Use** 方法将中间件添加到管道中。以下代码使用中间件在调用管道中的下一个中间件之前记录请求方法和路径。在下一个中间件完成后，它记录响应状态码：'
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The use of middleware brings constant benefits to applications; we will understand
    in greater detail the use of different approaches, such as the creation of middleware
    classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的使用为应用程序带来持续的好处；我们将更详细地了解不同方法的使用，例如创建中间件类。
- en: Now, let’s learn about how the middleware execution flow works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解中间件执行流程是如何工作的。
- en: Understanding middleware flow
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解中间件流程
- en: 'When the application receives a request, it goes through each middleware component
    in the order they are registered, and the following cases can be executed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序收到请求时，它会按照注册的顺序通过每个中间件组件，并可以执行以下操作：
- en: '**Process the request and pass it to the next piece of middleware** : It’s
    like a relay race where each runner passes the baton to the next. Each piece of
    middleware does its part and then calls the next one in line to continue processing
    the request.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理请求并将其传递给下一个中间件**：这就像接力赛跑，每个运动员将接力棒传给下一位。每个中间件完成其部分工作后，就调用下一个中间件以继续处理请求。'
- en: '**Process the request and break the chain, preventing other middleware from
    running** : Imagine a security checkpoint at an airport. If security finds a problem,
    they may stop you for additional checks, preventing you from proceeding. Likewise,
    the middleware may decide to handle the request completely and stop further processing.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理请求并中断链，防止其他中间件运行**：想象一下机场的安全检查站。如果安全人员发现问题，他们可能会让你停下来进行额外检查，阻止你继续前进。同样，中间件可能会决定完全处理请求并停止进一步的处理。'
- en: '**Process the response as it moves up the chain** : This is like sending a
    package through multiple stages of inspection. Once the package reaches the final
    stage, it is inspected again at each stage on the way back, ensuring that everything
    is in order before being delivered.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在链中向上移动时处理响应**：这就像将包裹通过多个检查阶段。一旦包裹到达最终阶段，它将在返回的每个阶段再次进行检查，确保在交付之前一切正常。'
- en: The layered approach allows for powerful and flexible handling of HTTP requests
    and responses. Middleware can be used for a variety of tasks, such as logging,
    authentication, error handling, and more.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分层方法允许强大且灵活地处理HTTP请求和响应。中间件可用于各种任务，例如日志记录、身份验证、错误处理等。
- en: 'Furthermore, the order in which you register middleware is crucial, as it defines
    the flow of the request and response pipeline. We can see a representation of
    the middleware execution flow in *Figure 8* *.2* :'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注册中间件的顺序至关重要，因为它定义了请求和响应管道的流程。我们可以在 *图8.2* 中看到中间件执行流程的表示：
- en: '![Figure 8.2 – Middleware execution flow](img/B21788_08_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 中间件执行流程](img/B21788_08_02.jpg)'
- en: Figure 8.2 – Middleware execution flow
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 中间件执行流程
- en: 'Let’s see how the flow works in detail:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看流程是如何工作的：
- en: '**Request arrival** : When a request arrives at the server, it enters the pipeline
    and reaches the first middleware component'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求到达**：当请求到达服务器时，它进入管道并到达第一个中间件组件'
- en: '**Middleware execution** : Each middleware can do the following:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件执行**：每个中间件可以执行以下操作：'
- en: '**Modify the request** : Middleware can change aspects of the request, such
    as adding headers or changing the request path'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改请求**：中间件可以更改请求的某些方面，例如添加头或更改请求路径'
- en: '**Move to next middleware** : After processing, the middleware can call the
    next middleware in the pipeline using **await next** , which we’ll discuss in
    the *Implementing custom* *middleware* section'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动到下一个中间件**：处理完毕后，中间件可以使用`await next`调用管道中的下一个中间件，我们将在*实现自定义* *中间件*部分进行讨论'
- en: '**Short-circuiting the pipeline** : The middleware may decide not to call the
    next middleware, effectively ending request processing early'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短路管道**：中间件可能决定不调用下一个中间件，从而有效地提前结束请求处理'
- en: '**Response handling** : When the request reaches the end of the pipeline, the
    response goes back through the middleware components in reverse order'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应处理**：当请求达到管道的末端时，响应将按相反的顺序通过中间件组件返回'
- en: '**Modifying the response** : The middleware can change the response, such as
    adding headers, changing the status code, or logging information'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改响应**：中间件可以更改响应，例如添加头信息，更改状态码或记录信息'
- en: Middleware order
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件顺序
- en: ASP.NET Core 9 has, by default, some middleware available to handle requests
    and responses. However, the order in which this middleware is inserted completely
    changes the application’s execution flow and, in some cases, can cause malfunctions.
    For example, it is important to add middleware authentication before middleware
    authorization; otherwise, how can you validate authorization without being authenticated?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9默认提供了一些中间件来处理请求和响应。然而，这些中间件的插入顺序完全改变了应用程序的执行流程，在某些情况下甚至可能导致故障。例如，在中间件授权之前添加中间件身份验证是很重要的；否则，未经认证如何验证授权？
- en: In any case, in addition to standard middleware, there is an order of execution
    for customized middleware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，除了标准中间件外，还有自定义中间件的执行顺序。
- en: 'To learn more about middleware order, see the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order)
    .'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于中间件顺序的信息，请参阅以下链接：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order)。
- en: By working on the middleware execution flow, we have the ability to add several
    powerful possibilities to our applications, and we will learn some more benefits
    in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对中间件执行流程的工作，我们能够为我们的应用程序添加几个强大的可能性，我们将在下一节中学习更多的好处。
- en: Benefits of middleware and best practices
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件的好处和最佳实践
- en: 'Middleware plays a key role in ASP.NET Core 9 applications, offering a number
    of benefits that contribute to the robustness, maintainability, and extensibility
    of your application. Understanding these benefits allows you to use this resource
    effectively, so let’s look at this in more detail:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件在ASP.NET Core 9应用程序中扮演着关键角色，提供了一系列有助于提高应用程序的健壮性、可维护性和可扩展性的好处。了解这些好处可以使您有效地利用这一资源，因此让我们更详细地看看这一点：
- en: '**Modularity** : Modularity means that middleware is an independent unit of
    functionality that can be easily added, removed, or replaced without affecting
    the rest of the application. This modularity allows developers to create reusable
    middleware components that can be shared between different projects or in different
    parts of the same project.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：模块化意味着中间件是一个独立的函数单元，可以轻松添加、删除或替换，而不会影响应用程序的其他部分。这种模块化允许开发者创建可重用的中间件组件，这些组件可以在不同的项目或同一项目的不同部分之间共享。'
- en: '**Composition** : Middleware can be composed in multiple orders to achieve
    different behaviors. This compositional nature allows you to tailor the request
    and response pipeline to the specific needs of your application.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：中间件可以以多种顺序组合，以实现不同的行为。这种组合特性允许您根据应用程序的具体需求定制请求和响应管道。'
- en: 'Let’s say you have three middleware components: one for logging, one for authentication,
    and one for handling errors. You can compose these middleware components in the
    desired order:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设您有三个中间件组件：一个用于日志记录，一个用于身份验证，一个用于处理错误。您可以按照所需的顺序组合这些中间件组件：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the preceding code, the **app.UseMiddleware** method adds
    middleware to handle errors, authentication, and logging in the application. The
    **app.Run** method just creates a standard request response, returning a **Hello**
    **World** message.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，`app.UseMiddleware`方法向应用程序添加了处理错误、身份验证和日志记录的中间件。`app.Run`方法仅创建一个标准的请求响应，返回一个**Hello
    World**消息。
- en: 'It is important to consider the following factors:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下因素很重要：
- en: If you want to rearrange the order of these middleware components, the way requests
    are processed and errors are handled will be different.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想重新排列这些中间件组件的顺序，请求的处理方式和错误处理将会不同。
- en: '**SoC (Separation of concerns)** : Middleware allows for a clear separation
    of different concerns, enabling the definition of a clear execution context in
    a pipeline and facilitating a clearer, extensible, and maintainable code base.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离（SoC）**：中间件允许不同关注点之间的清晰分离，使得在管道中定义清晰的执行上下文成为可能，并促进代码库的更清晰、可扩展和可维护。'
- en: '**Extensibility** : You can develop a custom middleware to extend the application’s
    functionality – for example, by adding validation capabilities to requests or
    modifying responses globally within the application.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：你可以开发自定义中间件来扩展应用程序的功能——例如，通过向请求添加验证功能或在应用程序中全局修改响应。'
- en: 'Suppose you need custom middleware to validate an API key in request headers.
    You can create this middleware as follows:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设你需要自定义中间件来验证请求头中的 API 密钥。你可以按照以下方式创建此中间件：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code aims to create a customized middleware that checks the existence
    of an API key that must be provided in the header of a request, where the header
    key is **X-API-KEY** and the expected value is, exactly, **XYZ123** .
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码旨在创建一个自定义中间件，该中间件检查必须包含在请求头中的 API 密钥的存在，其中头键是 **X-API-KEY**，期望的值正好是 **XYZ123**。
- en: When performing validation, if the header and value are not part of the request,
    then the user receives an **unauthorized** return message with HTTP status code
    **401** .
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在执行验证时，如果头和值不是请求的一部分，则用户会收到一个带有 HTTP 状态码 **401** 的**未授权**返回消息。
- en: In fact, middleware is a powerful feature that allows you to have greater control
    over the flow of requests and responses in an application developed in ASP.NET
    Core 9.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，中间件是一个强大的功能，它允许你更好地控制使用 ASP.NET Core 9 开发的应用程序中的请求和响应流程。
- en: Don’t worry about the details related to the preceding code examples. We will
    learn about the structure of a middleware class in the *Implementing custom* *middleware*
    section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心与前面代码示例相关的细节。我们将在 *实现自定义* *中间件* 部分学习中间件类的结构。
- en: Despite the great benefits of applications using middleware, it is important
    to be aware of good practices; otherwise, what could be a benefit could become
    a major problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用中间件的应用程序具有很大的好处，但了解良好的实践很重要；否则，可能成为好处的东西可能会变成一个主要问题。
- en: 'Let’s look at some best practices:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些最佳实践：
- en: '**Order matters** : The order in which middleware components are added is crucial
    as it affects how requests and responses are processed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序很重要**：中间件组件添加的顺序至关重要，因为它会影响请求和响应的处理方式。'
- en: '**Keep it simple** : Middleware should do one thing and do it well. Complex
    logic should be avoided in middleware.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持简单**：中间件应该只做一件事，并且做好。在中间件中应避免复杂的逻辑。'
- en: '**Error handling** : Make sure your middleware components handle exceptions
    and errors in the same way as other classes in your application.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：确保你的中间件组件以与其他应用程序中的类相同的方式处理异常和错误。'
- en: '**Performance** : Be aware of the impact of middleware on performance, especially
    in high-load scenarios. As it operates in request and response processes, avoid
    large amounts of processing during these stages to avoid causing problems for
    users and the application.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：注意中间件对性能的影响，尤其是在高负载场景中。由于它在请求和响应过程中操作，因此在这些阶段避免大量处理，以避免给用户和应用程序造成问题。'
- en: '**Reuse existing middleware** : Use built-in middleware whenever possible to
    reduce the need for custom implementations. As we have already learned, there
    is some middleware available in ASP.NET Core 9.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用现有中间件**：尽可能使用内置中间件以减少对自定义实现的依赖。正如我们已经学到的，ASP.NET Core 9 中有一些可用的中间件。'
- en: Now that we understand the principles, benefits, and best practices of middleware,
    let’s implement our first custom middleware and learn the details of this approach.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了中间件的原则、好处和最佳实践，让我们实现我们的第一个自定义中间件，并了解这种方法的具体细节。
- en: Implementing custom middleware
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义中间件
- en: Custom middleware allows you to encapsulate functionality and reuse it in different
    parts of your application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义中间件允许你封装功能并在应用程序的不同部分重用它。
- en: 'Creating custom middleware in ASP.NET Core 9 involves several steps, such as
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中创建自定义中间件涉及几个步骤，例如以下内容：
- en: Middleware class definition
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件类定义
- en: The implementation of the **Invoke** or **InvokeAsync** method
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Invoke**或**InvokeAsync**方法的实现'
- en: Middleware registration in the request pipeline
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求管道中的中间件注册
- en: 'Let’s analyze the following code, which represents a customized middleware:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下代码，它代表一个自定义中间件：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This custom middleware code aims to just write a string to the console at the
    beginning and in the response of the request.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段自定义中间件代码的目的是在请求的开始和响应中向控制台写入一个字符串。
- en: 'However, it is important to understand the structure of the preceding code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解前面代码的结构是很重要的：
- en: '**RequestDelegate** : This is a delegate that represents the next middleware
    in the pipeline. This delegate is stored in a field called **_next** for use in
    the context of the class.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RequestDelegate**：这是一个代表管道中下一个中间件的委托。这个委托存储在一个名为**_next**的字段中，用于类的作用域。'
- en: '**Constructor** : The class constructor receives an instance of the **RequestDelegate**
    class as a parameter, representing the next middleware in the execution flow.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：类构造函数接收一个**RequestDelegate**类的实例作为参数，代表执行流程中的下一个中间件。'
- en: '**Invoke** or **InvokeAsync** method: Contains the logic for processing HTTP
    requests. The difference between the methods is that one is executed asynchronously
    and the other is not. The **InvokeAsync** method receives an **HttpContext** object
    as a parameter. The **HttpContext** object allows you to access request and response
    information. It is a good practice to use the **InvokeAsync** method to improve
    performance and scalability.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Invoke**或**InvokeAsync**方法：包含处理HTTP请求的逻辑。这两种方法之间的区别在于一个是异步执行的，另一个不是。**InvokeAsync**方法接收一个**HttpContext**对象作为参数。**HttpContext**对象允许你访问请求和响应信息。使用**InvokeAsync**方法来提高性能和可伸缩性是一种良好的实践。'
- en: '**await _next(context)** : Execution of the **_next** delegate, which receives
    the **HttpContext** object as a parameter. In this example, we are just writing
    a string containing request information before propagating the execution of the
    next middleware, and then another string is written with response information
    after executing the middleware.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await _next(context)**：执行**_next**委托，该委托接收**HttpContext**对象作为参数。在这个例子中，我们只是在传播下一个中间件的执行之前，在请求信息中写入一个字符串，然后在执行中间件之后，再写入一个包含响应信息的字符串。'
- en: Dependency injection (DI) in middleware
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件中的依赖注入（DI）
- en: Custom middleware classes must use the **Explicit Dependencies Principle** (
    **EDP** ), as we have already learned in previous chapters, where the dependencies
    of a class are defined in the constructor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义中间件类必须使用**显式依赖原则**（**EDP**），正如我们在前面的章节中已经学到的，其中类的依赖关系在构造函数中定义。
- en: As middleware is built during application initialization, it is not possible
    to inject services added to a scoped lifetime as is done with each request in
    a **Controller** class, for example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中间件是在应用程序初始化期间构建的，因此无法像在**Controller**类中的每个请求那样注入添加到作用域生命周期的服务。
- en: So, if you want to use any services available in DI control in a middleware
    class, add these services to the signature of the **InvokeAsync** method, which
    can accept additional parameters resolved by DI.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想在中间件类中使用DI控制中可用的任何服务，请将这些服务添加到**InvokeAsync**方法的签名中，该方法可以接受由DI解析的附加参数。
- en: The previous code example, although simple, demonstrates the basic structure
    of a middleware, which requires a **RequestDelegated** field, a constructor that
    depends on an instance of **RequestDelegated** , and the implementation of the
    **Invoke** or **InvokeAsync** method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例，虽然简单，但展示了中间件的基本结构，需要包含一个**RequestDelegate**字段，一个依赖于**RequestDelegate**实例的构造函数，以及**Invoke**或**InvokeAsync**方法的实现。
- en: 'For the customized middleware to be used in the application, it is necessary
    to register it in the ASP.NET Core 9 execution pipeline through the **Program.cs**
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序中使用定制中间件，必须通过**Program.cs**文件将其注册到ASP.NET Core 9执行管道中：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code has been shortened to make it easier to read and learn. For
    the middleware to be registered, the **UseMiddleware** extension method is used,
    which is a generic method, where we define the previously executed custom middleware
    as the type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码已被缩短，以便更容易阅读和学习。为了注册中间件，使用**UseMiddleware**扩展方法，这是一个泛型方法，其中我们定义之前执行的定制中间件作为类型。
- en: During the application startup flow, all custom or non-customized middleware
    is created, forming part of the application lifecycle, and not by request, as
    is generally done in scoped services. This behavior prevents other dependencies
    from being added to the constructor of a custom middleware class but allows the
    addition of dependencies with parameters through the **Invoke** and **InvokeAsync**
    methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动流程中，所有自定义或非自定义中间件都被创建，形成应用程序生命周期的一部分，而不是像作用域服务那样按请求创建。这种行为防止将其他依赖项添加到自定义中间件类的构造函数中，但允许通过
    **Invoke** 和 **InvokeAsync** 方法添加带有参数的依赖项。
- en: Obtaining HTTP context objects in middleware
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件中获取 HTTP 上下文对象
- en: 'As an alternative to using DI in the **InvokeAsync** method, it is possible
    to use the **context.RequestService** property ( [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0)
    ), as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在 **InvokeAsync** 方法中使用 DI 的替代方案，可以使用 **context.RequestService** 属性（[https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0)），如下面的代码所示：
- en: '**public async Task** **InvokeAsync(HttpContext context)**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**public async Task** **InvokeAsync(HttpContext context)**'
- en: '**{**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**var logger =** **context.RequestServices**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**var logger =** **context.RequestServices**'
- en: '**.** **GetRequiredService<Ilogger**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**.** **GetRequiredService<Ilogger**'
- en: '**<** **BeforeAfterRequestMiddleware >>();**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**<** **BeforeAfterRequestMiddleware >>();**'
- en: '**logger.LogInformation($"Request:{context.Request.Method}**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**logger.LogInformation($"Request:{context.Request.Method}**'
- en: '**{** **context.Request.Path}");**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**{** **context.Request.Path}");**'
- en: '**await _next(context);**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**await _next(context);**'
- en: '**logger.LogInformation($"Response:**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**logger.LogInformation($"Response:**'
- en: '**{** **context.Response.StatusCode}");**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**{** **context.Response.StatusCode}");**'
- en: '**}**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: However, this somewhat decreases dependency visibility in code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这多少降低了代码中依赖项的可见性。
- en: However, ASP.NET Core 9 offers an approach to enabling the use of custom middleware
    on a per-request basis using factory-based middleware, which we will discuss in
    the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET Core 9 提供了一种方法，通过基于工厂的中间件在每次请求的基础上启用自定义中间件的用法，我们将在下一节中讨论。
- en: Working with factory-based middleware
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与基于工厂的中间件一起工作
- en: Another way to create custom middleware is by using the factory-based approach,
    which offers better performance and flexibility using DI.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义中间的另一种方式是使用基于工厂的方法，它通过 DI 提供了更好的性能和灵活性。
- en: This approach is particularly useful when the middleware requires scoped services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在中间件需要作用域服务时特别有用。
- en: Factory-based middleware uses the **IMiddleware** interface, which allows the
    middleware to be activated by the **DI** **container** ( **DIC** ).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于工厂的中间件使用 **IMiddleware** 接口，这使得中间件可以通过 **DI** **容器**（**DIC**）被激活。
- en: The **IMiddleware** interface has only one **InvokeAsync** method that must
    be implemented in the class. The structure of a customized middleware that uses
    the factory-based approach is very similar to the traditional approach learned
    in the previous section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**IMiddleware** 接口只有一个必须由类实现的 **InvokeAsync** 方法。使用基于工厂的方法的自定义中间件的结构与上一节中学到的传统方法非常相似。'
- en: 'Let’s look at a code example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The big difference with the factory-based approach is the definition of a dependency
    in the class constructor instead of declaring it as a parameter in the **InvokeAsync**
    method. In the preceding code example, the constructor has a dependency on an
    **ILogger** interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于工厂的方法相比，最大的不同在于在类构造函数中定义依赖项，而不是在 **InvokeAsync** 方法中声明它。在先前的代码示例中，构造函数依赖于一个
    **ILogger** 接口。
- en: The **InvokeAsync** method must only have two parameters, **HttpContext** and
    **RequestDelegate** .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**InvokeAsync** 方法必须只有两个参数，**HttpContext** 和 **RequestDelegate** 。'
- en: 'Now, let’s look at custom middleware registration, using the factory-based
    approach, by analyzing the **Program.cs** class code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过分析 **Program.cs** 类代码，看看如何使用基于工厂的方法进行自定义中间件注册：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Middleware registration is done using the **app.UseMiddleware** method, as we
    have already learned. However, note that the **RequestLimitingMiddleware** class
    is added to the scoped lifetime through the **builder.Services.AddScoped<RequestLimitingMiddleware>()**
    code with the lifecycle managed per request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件注册是通过我们已学过的**app.UseMiddleware**方法完成的。然而，请注意，**RequestLimitingMiddleware**类是通过**builder.Services.AddScoped<RequestLimitingMiddleware>()**代码添加到作用域生命周期的，生命周期由每个请求管理。
- en: Service lifetimes
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 服务生命周期
- en: ASP.NET Core 9 offers different types of service lifetimes; you can learn more
    at [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes)
    .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9提供了不同类型的服务生命周期；你可以在[https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes)了解更多信息。
- en: As we can see, the factory-based approach allows us to use DIC resources and
    manage the middleware lifecycle by request.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，基于工厂的方法允许我们使用DIC资源并通过请求来管理中间件的生命周期。
- en: Whether to use a factory-based or the traditional approach depends, of course,
    on the application requirements. However, both are powerful solutions that add
    precious features to our applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用基于工厂的方法或传统方法，当然取决于应用需求。然而，两者都是强大的解决方案，为我们的应用增添了宝贵的功能。
- en: In the next section, we will create and use some common middleware used in many
    applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建并使用许多应用中常用的中间件。
- en: Adding capabilities to applications using middleware
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件为应用添加功能
- en: Now that we have knowledge about the features and possibilities of middleware,
    we will work on some capabilities that will bring greater quality to our web applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了中间件的功能和可能性，我们将着手实现一些功能，这将使我们的Web应用质量得到提升。
- en: There is no strict standard directory structure or namespace for creating middleware
    classes. However, it is good practice to organize classes into well-defined namespaces.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建中间件类没有严格的目录结构或命名空间标准。然而，将类组织到定义良好的命名空间中是一种良好的实践。
- en: For this example, we will default to creating a folder called **Middlewares**
    in the root of your application project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将默认在应用项目的根目录下创建一个名为**Middlewares**的文件夹。
- en: 'In this section, we will focus on the following middleware:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注以下中间件：
- en: Global error handling
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局错误处理
- en: Adding request logging – logging request information
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加请求日志 - 记录请求信息
- en: Rate limiting – defining request limits in your application
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制 - 在你的应用中定义请求限制
- en: The project containing the classes mentioned in the preceding list is available
    in the book repository, the link to which can be found in the *Technical* *requirements*
    section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 包含前面提到的类的项目可在书籍仓库中找到，其链接可在*技术要求*部分找到。
- en: 'Let’s create a new application. Open the terminal, and in a folder of your
    choice, create a project with the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的应用。打开终端，在你的选择文件夹中，使用以下命令创建一个项目：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, in the root of the directory, create a folder called **Middlewares** .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在目录的根目录下创建一个名为**Middlewares**的文件夹。
- en: 'Now, we will start creating the first middleware: global error handling.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始创建第一个中间件：全局错误处理。
- en: Global error handling
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局错误处理
- en: During the execution flow of an application, errors or exceptions may arise
    that, if not handled correctly, may cause inconvenience to users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的执行流程中，可能会出现错误或异常，如果处理不当，可能会给用户带来不便。
- en: In this case, we must handle errors in our code to prevent exceptions from causing
    applications to malfunction.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须在代码中处理错误，以防止异常导致应用出现故障。
- en: To achieve this, a good practice is to use a global error-handling middleware
    that makes it possible to manage the application’s exception flow in a centralized
    manner, even allowing it to extend its functionality by adding logs in different
    monitoring tools, which is essential for error corrections.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，一种良好的实践是使用全局错误处理中间件，它使得能够以集中化的方式管理应用异常流，甚至可以通过在不同的监控工具中添加日志来扩展其功能，这对于错误修正至关重要。
- en: 'Create a file called **ErrorHandlingMiddleware.cs** in the **Middlewares**
    folder you created earlier and add the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在你之前创建的**Middlewares**文件夹中创建一个名为**ErrorHandlingMiddleware.cs**的文件，并添加以下代码：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see in the preceding code the common structure of a middleware. The great
    functionality of this global error-handling middleware is the use of the **try**
    / **catch** block, in the body of the **InvokeAsync** method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的代码中看到中间件的常见结构。这个全局错误处理中间件的功能强大之处在于它在 **InvokeAsync** 方法的主体中使用了 **try**
    / **catch** 块。
- en: The **await _next(context)** command is executed in a **try** block so that
    if there is an exception in the application, it will be handled globally. Exception
    handling is done through the **HandleExceptionAsync** method, called in the **catch**
    block.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**await _next(context)** 命令在 **try** 块中执行，因此如果应用程序中发生异常，它将被全局处理。异常处理是通过在 **catch**
    块中调用的 **HandleExceptionAsync** 方法完成的。'
- en: The **HandleExceptionAsync** method modifies the request response by changing
    the **StatusCode** property to Internal Server Error, **HTTP status code 500**
    , in addition to returning an object in the request body. This object is represented
    by the **ErrorDetails** class, which has the **StatusCode** and Message properties.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**HandleExceptionAsync** 方法通过将请求响应的 **StatusCode** 属性更改为内部服务器错误，即 **HTTP 状态码
    500**，并在请求体中返回一个对象来修改请求响应。此对象由 **ErrorDetails** 类表示，该类具有 **StatusCode** 和 **Message**
    属性。'
- en: Therefore, in addition to guaranteeing the handling of any exception in the
    application, there is a customized, but common, return that can be used appropriately
    for handling in a UI, allowing a better experience for the developers and also
    for the users of the application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了保证处理应用程序中的任何异常外，还有一个自定义但通用的返回值，可以适当用于 UI 处理，从而为开发者和应用程序用户提供更好的体验。
- en: Problems Details in ASP.NET Core 9
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 中的问题详情
- en: ASP.NET Core 9 provides built-in support for Problem Details, a standardized
    format for error responses based on RFC 7807 (https://datatracker.ietf.org/doc/html/rfc7807).
    By incorporating Trace ID into the response, developers can enhance debugging
    and error tracking.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 提供了对问题详情的内建支持，这是一个基于 RFC 7807（https://datatracker.ietf.org/doc/html/rfc7807）的标准化错误响应格式。通过将跟踪
    ID 包含在响应中，开发者可以增强调试和错误跟踪。
- en: 'A Problem Details response with a Trace ID looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 带有跟踪 ID 的问题详情响应看起来像这样：
- en: '**{**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**"** **type": "https://example.com/probs/server-error",**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**"** **type": "https://example.com/probs/server-error",**'
- en: '**"title": "An unexpected** **error occurred.",**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**"title": "An unexpected** **error occurred.",**'
- en: '**"** **status": 500,**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**"** **status": 500,**'
- en: '**"detail": "The system encountered** **an issue.",**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**"detail": "The system encountered** **an issue.",**'
- en: '**"** **instance": "/example-path",**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**"** **instance": "/example-path",**'
- en: '**"** **traceId": "00-abcdef1234567890abcdef1234567890-1234567890abcdef-01"**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**"** **traceId": "00-abcdef1234567890abcdef1234567890-1234567890abcdef-01"**'
- en: '**}**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: 'The **ProblemDetails** class can be used in conjunction with the Middleware
    following the following implementation example, changing the **HandleExceptionAsync**
    method of the **ErrorHandlingMiddleware** class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProblemDetails** 类可以与以下实现示例中的中间件一起使用，更改 **ErrorHandlingMiddleware** 类的 **HandleExceptionAsync**
    方法：'
- en: '**private static Task HandleExceptionAsync(HttpContext context,** **Exception
    exception)**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**private static Task HandleExceptionAsync(HttpContext context,** **Exception
    exception)**'
- en: '**{**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**var traceId = Activity.Current?.Id ??** **context.TraceIdentifier;**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**var traceId = Activity.Current?.Id ??** **context.TraceIdentifier;**'
- en: '**var problemDetails =** **new ProblemDetails**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**var problemDetails =** **new ProblemDetails**'
- en: '**{**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**Type = "** **server-error",**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Type = "** **server-error",**'
- en: '**Title = "An unexpected** **error occurred.",**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Title = "An unexpected** **error occurred.",**'
- en: '**Status =** **StatusCodes.Status500InternalServerError,**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**Status =** **StatusCodes.Status500InternalServerError,**'
- en: '**Detail = “Internal Server Error from the** **custom middleware.”,**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Detail = “来自自定义中间件的内部服务器错误。”,**'
- en: '**Instance =** **context.Request.Path**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Instance =** **context.Request.Path**'
- en: '**};**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**};**'
- en: '**// Include the Trace ID in the** **Problem Details.**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 在问题详情中包含跟踪 ID。**'
- en: '**problemDetails.Extensions["traceId"] =** **traceId;**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**problemDetails.Extensions["traceId"] =** **traceId;**'
- en: '**context.Response.ContentType = "** **application/problem+json";**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**context.Response.ContentType = "** **application/problem+json";**'
- en: '**context.Response.StatusCode =** **StatusCodes.Status500InternalServerError;**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**context.Response.StatusCode =** **StatusCodes.Status500InternalServerError;**'
- en: '**return context.Response.WriteAsJsonAsync(problemDetails);**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**return context.Response.WriteAsJsonAsync(problemDetails);**'
- en: '**}**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: 'The preceding code is a customization of the Global Error Handler implemented
    through Middleware. In addition to using the **ProblemDetails** class, code is
    added to obtain the trace id value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是通过中间件实现的全球错误处理器的自定义。除了使用 **ProblemDetails** 类外，还添加了代码以获取跟踪 ID 值：
- en: '**var traceId = Activity.Current?.Id ??** **context.TraceIdentifier;**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**var traceId = Activity.Current?.Id ?? context.TraceIdentifier;**'
- en: 'Then, the trace ID is added to the extensions of the object ProblemdDetails>:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，跟踪ID被添加到 `ProblemDetails` 对象的扩展中：
- en: '**problemDetails.Extensions["traceId"] =** **traceId;**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**problemDetails.Extensions["traceId"] = traceId;**'
- en: The trace ID is excellent information that should be part of the application
    Log, facilitating the correlation between error responses to resolve issues.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪ID是极好的信息，应该成为应用程序日志的一部分，便于关联错误响应以解决问题。
- en: 'ASP.NET Core 9 also has alternatives for error handling that you can learn
    more about at the following URL: [https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0)
    .'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 还提供了错误处理的替代方案，您可以在以下网址了解更多信息：[https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0)。
- en: Using global error handling brings an excellent benefit to applications, and,
    in addition, some log writing strategies could be used in cloud monitoring tools,
    in the terminal, or even in files, facilitating problem resolution.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局错误处理为应用程序带来了极大的好处，此外，一些日志记录策略可以在云监控工具、终端或甚至文件中使用，从而便于问题解决。
- en: The log functionality can be used for other purposes, not just to handle errors.
    Let’s analyze another middleware approach for logging requests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 日志功能可用于其他目的，而不仅仅是处理错误。让我们分析另一种用于记录请求的中间件方法。
- en: Adding request logging
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加请求日志
- en: Every web application has a constant flow of communication and processing of
    requests that generate different types of information, as well as exceptions that
    must be handled, and we took care of this scenario when creating global error-handling
    middleware in the previous section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用程序都有持续的通信和请求处理流程，这些流程生成不同类型的信息，以及必须处理的异常。我们在上一节创建全局错误处理中间件时已经考虑了这种情况。
- en: 'In addition to handling errors and exceptions, we must log this information
    to be able to carry out effective troubleshooting. However, in many cases, it
    is necessary to log information processed during the request and response flow
    of an application. This approach offers several benefits:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理错误和异常之外，我们还必须记录这些信息，以便能够进行有效的故障排除。然而，在许多情况下，记录应用程序请求和响应流程中处理的信息是必要的。这种方法提供了以下好处：
- en: '**Centralized logging** : Centralize logging logic, ensuring all requests are
    logged consistently in a single location in the pipeline'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式日志记录**：集中日志记录逻辑，确保所有请求在管道中的单个位置一致地记录。'
- en: '**Request tracking** : The ability to trace all requests is useful for monitoring
    application performance, debugging issues, and understanding user behavior'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求跟踪**：能够跟踪所有请求对于监控应用程序性能、调试问题和理解用户行为非常有用。'
- en: '**Security and auditing** : By logging requests, you can maintain an audit
    trail of access to your application, which is essential for security compliance'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和审计**：通过记录请求，您可以维护对应用程序访问的审计跟踪，这对于符合安全规范至关重要。'
- en: '**Error diagnosis** : When problems arise, logs can help you diagnose and troubleshoot
    problems by providing a detailed history of the request activity that led to an
    error'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误诊断**：当出现问题时，日志可以帮助您通过提供导致错误的请求活动的详细历史记录来诊断和排除问题。'
- en: '**Performance monitoring** : Logging the time it takes to process requests
    can help identify performance bottlenecks and optimize application performance'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能监控**：记录处理请求所需的时间可以帮助识别性能瓶颈并优化应用程序性能。'
- en: '**Flexibility** : The middleware can be configured to log only certain types
    of requests or responses, providing flexibility in how logging is implemented'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：中间件可以被配置为仅记录特定类型的请求或响应，从而在日志记录的实现方式上提供灵活性。'
- en: 'Let’s look at an example of middleware responsible for logging request data
    into the application. To do this, create a class called **PerformanceLoggingMiddleware.cs**
    in the **Middlewares** folder and add the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个负责将请求数据记录到应用程序中的中间件的示例。为此，在 **Middlewares** 文件夹中创建一个名为 **PerformanceLoggingMiddleware.cs**
    的类，并添加以下代码：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code aims to record the execution time of a request. This is an
    interesting approach to measuring the limits of your application and allowing
    you to improve the performance of your implementation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码旨在记录请求的执行时间。这是一种有趣的测量应用程序限制并允许您改进实现性能的方法。
- en: 'When analyzing the code, we have the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码时，我们有以下内容：
- en: '**DI** : The **InvokeAsync** method accepts an **ILogger<PerformanceLoggingMiddleware>**
    parameter, which is provided by DI'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入（DI）**：`InvokeAsync` 方法接受一个 `ILogger<PerformanceLoggingMiddleware>` 参数，该参数由依赖注入提供'
- en: '**Log request metrics** : The **InvokeAsync** method uses the **ILogger** instance
    to log the HTTP method, request path, and time taken to process the request'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志请求指标**：`InvokeAsync` 方法使用 `ILogger` 实例来记录 HTTP 方法、请求路径以及处理请求所需的时间'
- en: '**Collecting the request execution time** : Before executing the request, use
    the **GetTimestamp()** static method of the **Stopwatch** object to get the initial
    timestamp'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集请求执行时间**：在执行请求之前，使用 `Stopwatch` 对象的 `GetTimestamp()` 静态方法获取初始时间戳'
- en: After executing the request through the **_await _next(context)** request delegation,
    the **Stop** method of the **Stopwatch** object is used to end the timer.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在通过 `_await _next(context)` 请求委派执行请求之后，使用 `Stopwatch` 对象的 `Stop` 方法来结束计时器。
- en: A log is then created containing information about the request, such as the
    method, path, and execution time in milliseconds, obtained from the **Stopwatch**
    class throughout the **GetElapsedTime(timestamp).TotalMilliseconds** method.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后创建一个包含有关请求的信息的日志，例如方法、路径和从 `Stopwatch` 类的 `GetElapsedTime(timestamp).TotalMilliseconds`
    方法中获取的以毫秒为单位的执行时间。
- en: The Stopwatch class
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 类'
- en: 'The **Stopwatch** class in .NET is a high-resolution timer provided by the
    **System.Diagnostics** namespace. It is used to measure elapsed time with great
    precision, making it ideal for performance measurement and benchmarking tasks.
    Get more information about the features available in **Stopwatch** through the
    documentation: [https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0)
    .'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中的 `Stopwatch` 类是由 **System.Diagnostics** 命名空间提供的具有高分辨率的计时器。它用于以极高的精度测量经过的时间，非常适合性能测量和基准测试任务。有关
    `Stopwatch` 可用功能的更多信息，请参阅文档：[https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0)。
- en: As we can see when implementing customized logs such as **PerformanceLoggingMiddleware**
    , creating customized middleware enhances the functionalities of our applications,
    helping both the experience of users who consume quality applications and supporting
    teams in maintenance processes, diagnostics, and also application evolution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现如 **PerformanceLoggingMiddleware** 这样的自定义日志时，创建自定义中间件增强了我们应用程序的功能，既帮助了使用优质应用程序的用户体验，也支持了在维护过程、诊断以及应用程序演进方面的团队。
- en: However, ASP.NET Core 9 provides some middleware capable of dealing with several
    other important aspects of an application’s execution flow, such as rate limiting,
    which we will understand in the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET Core 9 提供了一些中间件，能够处理应用程序执行流程的几个其他重要方面，例如速率限制，我们将在下一节中了解这些内容。
- en: Rate limiting
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率限制
- en: The rate-limiting middleware in ASP.NET Core 9 is a powerful feature that is
    essential for protecting applications from abuse and improving overall performance
    and reliability. This middleware controls the number of requests a client can
    make to a server within a specified period of time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 中的速率限制中间件是一个强大的功能，对于保护应用程序免受滥用、提高整体性能和可靠性至关重要。此中间件控制客户端在指定时间段内可以向服务器发送的请求数量。
- en: 'Using the rate-limiting middleware in ASP.NET Core 9 is done by adding the
    configuration in the **Program.cs** file. The following is a step-by-step guide:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中使用速率限制中间件是通过在 `Program.cs` 文件中添加配置来完成的。以下是一个逐步指南：
- en: Add the required NuGet packages.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的 NuGet 包。
- en: Register the middleware in the HTTP request pipeline.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTTP 请求管道中注册中间件。
- en: Add rate-limiting middleware to the pipeline. Rate-limiting middleware is included
    in **Microsoft.AspNetCore.RateLimiting** .
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将速率限制中间件添加到管道中。速率限制中间件包含在 **Microsoft.AspNetCore.RateLimiting** 中。
- en: 'Let’s see an example of implementation in a Razor Pages-type application using
    the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码查看在 Razor Pages 类型应用程序中的实现示例：
- en: '[PRE12]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s analyze the important aspects of the preceding code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析前面代码的重要方面：
- en: '**builder.Services.AddRateLimiter** : Required to define the rate limit policies
    that will be used in this application. Each policy uses a unique client identifier,
    adding the **X-Forwarded-For** HTTP header, to enforce limits per client IP address.
    In the previous code, we configured three policies – namely, the following:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Services.AddRateLimiter**：用于定义在此应用程序中将使用的速率限制策略。每个策略使用一个唯一的客户端标识符，添加**X-Forwarded-For**
    HTTP头，以对每个客户端IP地址实施限制。在之前的代码中，我们配置了三个策略——即以下内容：'
- en: '**Fixed window** : Limits requests to 5 per minute. Once the limit is reached,
    no further requests will be allowed until the window is reset.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定窗口**：每分钟限制请求量为5个。一旦达到限制，将不允许进一步请求，直到窗口重置。'
- en: '**Sliding window** : Similar to the fixed window policy, but divides the window
    into segments, allowing for a more distributed request margin per minute.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动窗口**：类似于固定窗口策略，但将窗口划分为多个段，允许每分钟有更分散的请求余量。'
- en: '**Token bucket** : Allows you to make up to 10 tokens (requests) available,
    with 5 new tokens replenished every 10 seconds. If tokens run out, incoming requests
    will be queued.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌桶**：允许您最多有10个令牌（请求）可用，每10秒补充5个新令牌。如果令牌耗尽，则入站请求将被排队。'
- en: '**app.UseRateLimiter()** : This line adds the rate-limiting middleware to the
    request pipeline, enabling the configured rate-limiting policies to take effect.
    Unlike the traditional way of adding middleware where the **UseMiddleware<>**
    method is used, rate limiting has an exclusive extension method. We will learn
    how to create extension methods to add middleware in the next section.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**app.UseRateLimiter()**：此行将速率限制中间件添加到请求管道中，使配置的速率限制策略生效。与使用**UseMiddleware<>**方法添加中间件的传统方式不同，速率限制有一个专用的扩展方法。我们将在下一节中学习如何创建扩展方法以添加中间件。'
- en: 'Rate limiting is an important feature that should be considered when developing
    ASP.NET Core 9 applications, bringing some benefits such as the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制是开发 ASP.NET Core 9 应用程序时应考虑的重要功能，它带来了一些好处，例如以下内容：
- en: '**Overload protection** : Prevents the server from being overloaded by too
    many requests, ensuring stable performance'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过载保护**：防止服务器因过多请求而过载，确保稳定的性能。'
- en: '**Fair use** : Ensures that no client can monopolize server resources, promoting
    equitable access for all users'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公平使用**：确保没有客户端可以垄断服务器资源，促进所有用户的公平访问。'
- en: '**Security:** Mitigates certain types of attacks, such as **Distributed Denial-of-Service**
    ( **DDoS** ) attacks, by limiting the rate at which clients can make requests'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：通过限制客户端请求的速率，减轻了某些类型的攻击，例如**分布式拒绝服务**（**DDoS**）攻击。'
- en: '**Improved user experience** : By preventing server overload, rate limiting
    helps maintain consistent response times and service availability'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的用户体验**：通过防止服务器过载，速率限制有助于保持一致的响应时间和服务可用性。'
- en: Learning more about rate-limiting middleware
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于速率限制中间件
- en: 'Rate limiting has several other features that can add to your strategy for
    using this middleware. See the documentation for more details: [https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0)
    .'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制还具有其他一些功能，可以增强您使用此中间件的战略。请参阅文档以获取更多详细信息：[https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0)。
- en: In addition to rate-limiting middleware, ASP.NET Core 9 offers different other
    middleware that are widely used in different types of applications, such as authentication
    and authorization middleware, discussed in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093)
    . Depending on your application requirements, you can combine the capabilities
    of middleware to create powerful, high-quality solutions that run in modern environments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速率限制中间件之外，ASP.NET Core 9 还提供了其他不同类型的中间件，这些中间件在多种类型的应用程序中广泛使用，例如身份验证和授权中间件，如[*第6章*](B21788_06.xhtml#_idTextAnchor093)所述。根据您的应用程序需求，您可以组合中间件的功能，以创建在现代化环境中运行的高效、高质量的解决方案。
- en: ASP.NET Core 9 built-in middleware
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 内置中间件
- en: 'Consult the documentation to analyze the different middleware available on
    the ASP.NET Core 9 platform at the following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in–middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in-middleware)
    .'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下 URL 的文档，分析 ASP.NET Core 9 平台上可用的不同中间件：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in–middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in-middleware)。
- en: Now that we have created customized middleware and learned how to use the rate-limiting
    middleware available in ASP.NET Core 9, it is time to learn a good practice for
    registering middleware using extension methods.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自定义中间件并学习了如何使用 ASP.NET Core 9 中可用的速率限制中间件，是时候学习使用扩展方法注册中间件的良好实践了。
- en: Creating an extension method for middleware registration
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为中间件注册创建扩展方法
- en: With the exception of middleware built into ASP.NET Core 9, which have their
    respective extension methods for registration in the HTTP pipeline, each custom
    middleware must be registered using extension methods, such as **UseMiddleware<>**
    , already used in several code examples from this chapter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置到 ASP.NET Core 9 中的中间件，它们有自己的扩展方法用于在 HTTP 管道中进行注册外，每个自定义中间件都必须使用扩展方法进行注册，例如
    **UseMiddleware<>**，这在本章的几个代码示例中已经使用过。
- en: However, the addition of different middleware to the **Program.cs** file can
    create complexity in reading and maintaining these resources in the application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向 **Program.cs** 文件添加不同的中间件可能会在应用程序中创建读取和维护这些资源的复杂性。
- en: A good practice is to create extension methods in order to centralize the registration
    of middleware and have the benefit of abstracting the complexity of configuring
    these mechanisms, in addition to centralizing responsibilities appropriately.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的实践是创建扩展方法，以便集中注册中间件，并从抽象配置这些机制复杂性的好处中受益，同时适当地集中责任。
- en: Let’s create an extension method to centralize the configurations of the previously
    created middleware. To do this, in the **Middlewares** folder, create a new class
    called **CommonMiddlewareExtension.cs** .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个扩展方法来集中配置之前创建的中间件。为此，在 **Middlewares** 文件夹中，创建一个名为 **CommonMiddlewareExtension.cs**
    的新类。
- en: 'Add the following code to this class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到这个类中：
- en: '[PRE13]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code contains all the rate-limiting middleware settings, in addition
    to the use of global error-handling and request performance measurement middleware.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含所有速率限制中间件的设置，以及全局错误处理和请求性能测量中间件的使用。
- en: This extension method class exposes two **AddCustomRateLimiting** methods, responsible
    for adding the rate-limiting policies, and the **UseCommonApplicationMiddleware**
    method, responsible for adding the previously created custom middleware and the
    rate-limiting middleware to the HTTP pipeline.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展方法类公开了两个 **AddCustomRateLimiting** 方法，负责添加速率限制策略，以及 **UseCommonApplicationMiddleware**
    方法，负责将之前创建的自定义中间件和速率限制中间件添加到 HTTP 管道中。
- en: 'After creating the class, we will change the **Program.cs** file, which will
    have the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类之后，我们将修改 **Program.cs** 文件，其代码如下：
- en: '[PRE14]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see in the highlighted code, the **Program.cs** class uses the previously
    created extension methods, making it more readable and easier to maintain.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如高亮代码所示，**Program.cs** 类使用了之前创建的扩展方法，这使得代码更易于阅读和维护。
- en: The extension method approach is a good practice for grouping a set of configurations
    in your application flow in order to correctly separate responsibilities.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法方法是一种良好的实践，可以将一组配置分组到你的应用程序流程中，以正确地分离责任。
- en: Use these features in your web application deployment flow with ASP.NET Core
    9 and combine different middleware to create more powerful applications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些功能在你的 ASP.NET Core 9 网络应用程序部署流程中，并结合不同的中间件来创建更强大的应用程序。
- en: In the next chapters of the book, we will cover other different techniques to
    further add possibilities to your ASP.NET Core 9 applications, such as secure
    configuration management.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章中，我们将介绍其他不同的技术，以进一步增加你的 ASP.NET Core 9 应用程序的可能性，例如安全配置管理。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the power of middleware to customize
    the execution flow of ASP.NET Core 9 applications, understanding how the middleware
    pipeline works. In addition, we learned how to implement custom middleware, work
    with factory-based middleware, and add capabilities to applications by working
    with global error handling approaches, information logging, and request limit
    settings. In the next chapter, we will explore how to manage application configurations
    securely.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用中间件的力量来定制 ASP.NET Core 9 应用程序的执行流程，并理解了中间件管道的工作原理。此外，我们还学习了如何实现自定义中间件，与基于工厂的中间件协同工作，并通过与全局错误处理方法、信息日志记录和请求限制设置协同工作来为应用程序添加功能。在下一章中，我们将探讨如何安全地管理应用程序配置。
