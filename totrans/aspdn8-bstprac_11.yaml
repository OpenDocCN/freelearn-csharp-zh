- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Appendix
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: When writing code, every language has its nuances and standards. .NET is no
    different when it comes to general guidelines. One example is that placing a bracket
    at the end of a method signature is better than placing the bracket on the next
    line or placing a return immediately on the same line as an `if` statement. This
    is more of a personal preference. Programming guidelines give developers a way
    to stay between guardrails while writing code. These programming guidelines are
    used throughout the industry as standard practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，每种语言都有其细微差别和标准。.NET 在一般指南方面也不例外。一个例子是在方法签名末尾放置括号比将括号放在下一行或立即在 `if` 语句的同一行放置返回语句要好。这更多的是一种个人偏好。编程指南为开发者提供了一种在编写代码时保持平衡的方法。这些编程指南在整个行业中作为标准实践被使用。
- en: 'In the appendix, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录中，我们将涵盖以下主要主题：
- en: Programming guidelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程指南
- en: Project structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构
- en: The guidelines discussed in the following sections are commonly used in the
    industry. They give developers direction and provide guardrails as to how one
    should structure and write code not only for themselves, but also for other developers
    and peers in the future (including our future selves).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节中讨论的指南在行业中普遍使用。它们为开发者提供了方向，并提供了如何构建和编写代码的指导，不仅是为了自己，也是为了未来的开发者和其他同行（包括我们未来的自己）。
- en: In the first section, we’ll review some programming guidelines such as the DRY,
    YAGNI, and KISS principles, along with separation of concerns, the concept of
    SOLID, and how refactoring is a process and not a one-time quick fix. We’ll finish
    the appendix by looking at recommended ways of organizing .NET projects and folder
    structures, and where code resides based on their function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将回顾一些编程指南，如DRY、YAGNI和KISS原则，以及关注点分离、SOLID概念，以及重构是一个过程而不是一次性快速修复。我们将通过查看推荐的.NET项目和文件夹结构的组织方式来结束附录，并基于其功能确定代码的位置。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The only technical requirement for the appendix is access to your editor since
    we’ll be covering general programming guidelines. While we will have snippets
    of code along the way, they don’t justify their own code repository. They’re only
    meant to solidify the understanding of the concepts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 附录的唯一技术要求是访问您的编辑器，因为我们将会涵盖一般编程指南。虽然我们会在过程中提供代码片段，但它们并不需要自己的代码仓库。它们只是为了巩固对概念的理解。
- en: Programming guidelines
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程指南
- en: Throughout the book, I recommend various intermediate and advanced techniques
    of writing code pertaining to a particular topic or technology. While these techniques
    are meant to give developers a balance between requirements and technologies,
    there is also a need to provide common programming guidelines to follow certain
    patterns, making it easier for colleagues and peers to understand a code base.
    Successful developers think about these guidelines while writing and maintaining
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我推荐了与特定主题或技术相关的各种中级和高级编写代码的技术。虽然这些技术旨在在需求和技术的平衡之间为开发者提供帮助，但也需要提供常见的编程指南，以遵循某些模式，使同事和同行更容易理解代码库。成功的开发者会在编写和维护代码时考虑这些指南。
- en: In this section, we’ll review the DRY, YAGNI, KISS, and SOLID principles along
    with understanding separation of concerns, and how refactoring is a process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾DRY、YAGNI、KISS和SOLID原则，以及理解关注点分离，以及重构是一个过程。
- en: DRY
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY
- en: The first acronym we’ll review is probably one of the simplest guidelines to
    follow. The **DRY** principle stands for **don’t** **repeat yourself**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要回顾的第一个缩写可能是最简单的遵循指南之一。**DRY**原则代表**不要重复自己**。
- en: If you have multiple methods performing the same task in different locations
    of your application, it may be time to refactor and consolidate the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序的不同位置有多个执行相同任务的方法，那么可能需要重构和合并代码。
- en: YAGNI
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAGNI
- en: Our next common acronym is **YAGNI** (pronounced yag-nee), which stands for
    **you aren’t gonna** **need it**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的常见缩写是**YAGNI**（发音为yag-nee），代表**你不会需要它**。
- en: Also referred to as “building the bridge to nowhere,” the concept behind this
    acronym is to let developers know they should only write code when there is a
    requirement for it. They shouldn’t add code for a possible future enhancement
    that may not come to fruition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为“建造通向无人的桥”，这个缩写背后的概念是让开发者知道他们只有在有需求时才应该编写代码。他们不应该添加可能不会实现的未来增强功能的代码。
- en: KISS
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS
- en: Since this next acronym has so many meanings, we’ll try to keep it simple (hence
    the name). **KISS** stands for **keep it** **simple, stupid**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个缩写词有如此多的含义，我们将尽量保持简单（因此得名）。**KISS** 代表 **keep it** **simple, stupid**。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Keep your units of code simple enough to understand. This can include the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的代码单元足够简单，以便理解。这可以包括以下内容：
- en: '**Smaller methods** – The smaller the method, the easier it is to read and
    understand'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的方法** – 方法越小，就越容易阅读和理解'
- en: '**Language enhancements** – Based on .NET’s C# language improvements over the
    years, there may be a better (and shorter) way to write code'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言增强** – 基于多年来 .NET 的 C# 语言改进，可能存在更好的（更简短）的编写代码的方式'
- en: '**Reducing complexity** – When reducing complexity, systems become more testable
    and can be a possible candidate for automated testing'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化复杂性** – 当简化复杂性时，系统变得更加可测试，并且可能成为自动化测试的候选者。'
- en: The goal is to build more value by creating a better code base for peers and
    colleagues.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是通过为同行和同事创建更好的代码库来创造更多价值。
- en: Separation of concerns
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: When you started writing your own application, running it and seeing it execute
    on the screen for the first time was a huge achievement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写自己的应用程序，运行它并看到它在屏幕上第一次执行时，这是一项巨大的成就。
- en: Over time, the application required a database. Then it required email capabilities.
    Then logging. Then authentication. The requirements grew and so on and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，应用程序需要数据库。然后需要电子邮件功能。然后是日志记录。然后是身份验证。需求不断增长，如此等等。
- en: 'The separation of concerns concept pertains to how you logically partition
    an application into distinct layers. For example, if an application requires an
    email module, it would be a separate project in the solution called `MyApplication.EmailModule`.
    This email module would provide the following benefits to the application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点的分离概念涉及你如何逻辑地将应用程序划分为不同的层。例如，如果一个应用程序需要电子邮件模块，它将是解决方案中名为 `MyApplication.EmailModule`
    的独立项目。这个电子邮件模块将为应用程序提供以下好处：
- en: '`EmailModule` could be reused in another application if necessary.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，`EmailModule` 可以在另一个应用程序中重用。
- en: '`EmailModule` doesn’t require any outside dependencies; it’s self-contained.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailModule` 不需要任何外部依赖；它是自包含的。'
- en: '`EmailModule`, unit testing (and possibly integration testing) becomes easier.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailModule`，单元测试（以及可能的集成测试）变得更容易。'
- en: '`EmailModule` as opposed to the entire application. When focusing on one particular
    section, it doesn’t require the knowledge of the entire application. The knowledge
    of the project is all that’s required.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailModule` 相比整个应用程序。当专注于特定部分时，不需要了解整个应用程序。只需要了解项目知识即可。'
- en: One of the concepts heard in the industry is “Big Ball of Mud.” This concept
    pertains to all of the application code contained in one project, which is an
    unmaintainable code base. This is a similar concept to a “monolith,” where the
    application is hard to maintain because of its size. Consequently, concepts in
    the application aren’t broken out into modular units of work. If everything in
    the application is coupled together…everywhere, the system is brittle. If a developer
    modifies code in one location, it may fix the current issue but it will introduce
    errors in other locations, causing a ripple effect throughout the entire code
    base.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 行业内听到的其中一个概念是“大泥球”。这个概念涉及一个项目中包含的所有应用程序代码，这是一个难以维护的代码库。这与“单体”类似，由于规模庞大，应用程序难以维护。因此，应用程序中的概念没有被分解成模块化的工作单元。如果应用程序中的所有内容都耦合在一起……到处都是，系统就会变得脆弱。如果一个开发者修改了某个位置的代码，它可能会修复当前的问题，但会在其他位置引入错误，在整个代码库中产生连锁反应。
- en: Separation of concerns is something that experienced developers should share
    with their peers through code reviews to improve software on a larger scale and
    provide healthy discussions on the topic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点的分离是经验丰富的开发者应该通过代码审查与同行分享的，以在更大范围内改进软件并提供关于该主题的健康讨论。
- en: Refactoring as a process
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构作为一个过程
- en: While refactoring is a fundamental concept for developers, there are various
    levels of effort involved in refactoring a code base.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重构是开发者的基本概念，但在重构代码库时涉及各种努力水平。
- en: One simple example could be the renaming of a method. Once a developer renames
    a method, the developer has to change all of the references to that method in
    the code base. A more advanced example is the refactoring of a business rules
    engine to create more flexibility. While both are refactoring, one is easier than
    the other.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子可能是方法的重命名。一旦开发者重命名了一个方法，开发者就必须更改代码库中对该方法的全部引用。一个更高级的例子是将业务规则引擎重构以增加灵活性。虽然两者都是重构，但一个比另一个更容易。
- en: 'Refactoring should be a process. One process I’ve used over the years is as
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重构应该是一个过程。多年来我使用的一个过程如下：
- en: '**Get it functional** – Write functional code that works'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写功能性代码** – 编写能够工作的功能性代码'
- en: '**Get it tested** – Create tests to confirm the code behaves as expected'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保代码通过测试** – 创建测试以确认代码按预期行为'
- en: '**Get it refactored** – Refactor and optimize the code'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构并优化代码** – 重构和优化代码'
- en: The code you write should (usually) have tests (see the “100% Test Coverage”
    myth in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的代码应该（通常）有测试（参见[*第7章*](B19493_07.xhtml#_idTextAnchor163)中的“100%测试覆盖率”神话）。
- en: With that said, if you’re going to refactor code, *it will be beneficial to
    have tests in place* to confirm your refactoring efforts aren’t in vain. Once
    you have tests in place, you are free to refactor and modify as much code as needed
    to achieve your intended goal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你要重构代码，*拥有测试将非常有用*，以确认你的重构努力没有白费。一旦有了测试，你就可以自由地重构和修改所需的代码，以达到你的目标。
- en: The business rules engine was an example in my career where the code was functional
    and a lot of tests were in place (~700 passed). However, the team ran into an
    issue where the code required a more flexible approach and it had to be refactored.
    Two team members took three days to refactor the code. Once they finished the
    refactoring, they ran the final unit tests and found only two failed unit tests.
    The two failed unit tests were because they didn’t rename a method name properly.
    Imagine this refactoring without the tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，业务规则引擎是一个例子，代码是功能性的，并且有大量的测试（约700个通过）。然而，团队遇到了一个问题，代码需要更灵活的方法，因此必须进行重构。两位团队成员花了三天时间重构代码。一旦完成重构，他们运行了最终的单元测试，发现只有两个失败的单元测试。这两个失败的单元测试是因为他们没有正确地重命名方法名称。想象一下没有测试的重构。
- en: Refactoring can be as complex or as simple as the code base allows. Always keep
    in mind that refactoring is a multi-step process and requires tests to confirm
    the refactored code works as expected.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重构可以像代码库允许的那样复杂或简单。始终记住，重构是一个多步骤的过程，需要测试来确认重构后的代码按预期工作。
- en: Book recommendation
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍推荐
- en: One book I would highly recommend is *Refactoring with C#, Matt Eland, Packt
    Publishing*, available at [https://www.packtpub.com/](https://www.packtpub.com/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐的一本书是 *《使用C#重构》，作者：Matt Eland，Packt Publishing*，可在[https://www.packtpub.com/](https://www.packtpub.com/)找到。
- en: SOLID principles
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOLID原则
- en: '**SOLID** principles provide even deeper guidelines for writing code. SOLID
    is an acronym and was created back in 2000 by Robert C. Martin.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID**原则为编写代码提供了更深入的指导。SOLID是一个缩写，由Robert C. Martin在2000年创建。'
- en: Over the years, the SOLID principles have become a standard for writing quality
    software, and give developers a way to gauge their code based on whether it meets
    each principle’s criteria. Developers may disagree with what constitutes SOLID
    code, but again, these discussions should be had with peers or in a team meeting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，SOLID原则已成为编写高质量软件的标准，并为开发者提供了一种根据代码是否符合每个原则的标准来评估代码的方法。开发者可能对构成SOLID代码的内容有不同的看法，但再次强调，这些讨论应该与同行或团队会议中进行。
- en: Single responsibility principle
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The **single responsibility principle** (**SRP**) dictates that a class should
    have one and only one reason to change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（SRP）规定，一个类应该只有一个且仅有一个改变的理由。'
- en: 'The following code violates the SRP:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码违反了单一职责原则（SRP）：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `User` class has two properties: `Name` and `Email`. However, we have extra
    methods performing other responsibilities: an `IsValid()` method and a `Save()`
    method. Our `User` class is doing more than it should. We should create two new
    classes: one called `UserValidation` for validation, and one called `UserService`
    or `UserRepository` for database operations.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类有两个属性：`Name`和`Email`。然而，我们有一些执行其他职责的额外方法：一个`IsValid()`方法和一个`Save()`方法。我们的`User`类做得比它应该做的更多。我们应该创建两个新的类：一个叫做`UserValidation`用于验证，另一个叫做`UserService`或`UserRepository`用于数据库操作。'
- en: 'We created two additional classes but provided better software composition.
    If we add a new property to the `User` class and it requires validation, the developer
    only needs to make a change in one place: the `UserValidation` class.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个额外的类，但提供了更好的软件组合。如果我们向`User`类添加一个新属性，并且它需要验证，开发者只需要在一个地方进行更改：`UserValidation`类。
- en: Open/closed
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开闭
- en: The **open/closed principle** describes how software components should be open
    for extension but closed for modification.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**开闭原则**描述了软件组件应该如何对扩展开放但对修改封闭。'
- en: Most violations of the open/closed principle are usually indicated by long branching
    statements (such as long `if..then` or `switch` statements).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数违反开闭原则的情况通常由长分支语句（如长的`if..then`或`switch`语句）指示。
- en: 'The following code provides an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个示例：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this `ComicBook` class, we have three properties called `Title`, `Issue`,
    and `Grading`. One of the requirements for our class is to return the grading
    name based on the `Grading` property. This violates the open/closed principle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`ComicBook`类中，我们有三个属性，称为`Title`、`Issue`和`Grading`。我们类的一个要求是根据`Grading`属性返回评分名称。这违反了开闭原则。
- en: Why? Even though we already have the complete list of grades, the `GetGradeName()`
    method and add a new grade and name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？尽管我们已经有完整的成绩列表，但`GetGradeName()`方法和添加新的成绩和名称。
- en: 'A better implementation to support the open/closed principle is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 支持开闭原则的更好实现如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While it looks like we simply moved the `switch` statement, we did something
    else. We created a `Grade` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来我们只是移动了`switch`语句，但我们做了其他事情。我们创建了一个`Grade`类。
- en: With a `Grade` class created, we can assign any type of grade to the `ComicBook`
    class. If a new grade type is created, we can easily add it to our list without
    modifying the `ComicBook` class. We also implemented a factory pattern in our
    code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个`Grade`类后，我们可以将任何类型的成绩分配给`ComicBook`类。如果创建了新的成绩类型，我们可以轻松地将其添加到我们的列表中，而无需修改`ComicBook`类。我们还在代码中实现了工厂模式。
- en: Before, we were comparing a string based on a decimal value. Now, if additional
    properties are required for a grade, we can extend our `Grade` class to include
    more information.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们是根据十进制值比较字符串。现在，如果需要额外的属性来评分，我们可以扩展我们的`Grade`类以包含更多信息。
- en: Open for extension, closed to modification.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对扩展开放，对修改封闭。
- en: Liskov substitution
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Liskov替换
- en: The **Liskov substitution principle** explains that any derived type can be
    replaced with its base types. The concept behind the Liskov substitution is based
    on inherited types and/or interfaces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**解释了任何派生类型都可以被其基类型替换。Liskov替换背后的概念基于继承的类型和/或接口。'
- en: 'To continue with our comic book example, the following code shows a simple
    `BasePublisher` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的漫画书示例，以下代码显示了一个简单的`BasePublisher`类：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `BasePublisher` class contains the name and address of a publisher. When
    we create a new publisher (such as the preceding `MyNewPublisher` class), we’ll
    have access to everything available in the base class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasePublisher`类包含出版者的名称和地址。当我们创建一个新的出版者（如前面的`MyNewPublisher`类）时，我们将能够访问基类中所有可用的内容。'
- en: The ability to replace a `BasePublisher` class with a `MyNewPublisher` class
    would be an example of the Liskov substitution principle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用`MyNewPublisher`类替换`BasePublisher`类的功能将是Liskov替换原则的一个例子。
- en: Interface segregation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口分离
- en: The **interface segregation principle** explains that clients shouldn’t be forced
    to implement unnecessary methods they won’t use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口分离原则**解释了客户端不应该被迫实现他们不会使用的非必要方法。'
- en: With every interface created in an application, each method and property defined
    should be implemented in a concrete class. The defined interfaces should not go
    to waste in an implementation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中创建的每个接口中，定义的每个方法和属性都应该在具体类中实现。定义的接口不应在实现中浪费。
- en: 'For example, let’s say we have an interface for our `ComicBook` class. The
    interface and implementation code are listed as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们为`ComicBook`类有一个接口。接口和实现代码如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Everything in our `ComicBook` class is justified except for the `SaveToDatabase()`
    method. Creating a new `ComicBook` instance suggests we’ll be using the database
    every time. This violates the interface segregation principle.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`ComicBook`类中的每一件事都有合理的解释，除了`SaveToDatabase()`方法。创建一个新的`ComicBook`实例暗示我们将每次都使用数据库。这违反了接口分离原则。
- en: 'A better implementation would be splitting the database access out into an
    `IComicBookWriter` with a `SaveToDatabase()` method, as shown in the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的实现是将数据库访问拆分到一个具有`SaveToDatabase()`方法的`IComicBookWriter`中，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The example code shows how inheriting from the `IComicBookWriter` gives the
    `ComicBook` class a way to persist the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码展示了如何通过继承自`IComicBookWriter`为`ComicBook`类提供持久化数据的方式。
- en: The goal of the interface segregation principle is to avoid including methods
    in an interface that you won’t use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接口分离原则的目标是避免在接口中包含你不会使用的方法。
- en: This example is also a violation of the SRP since this class is also accessing
    the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也违反了单一职责原则，因为这个类也在访问数据库。
- en: Dependency inversion
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: The **dependency inversion principle** explains that we should depend on abstractions
    and not on concrete implementations. With .NET, dependency injection is available
    out of the box. With dependency injection automatically available, this satisfies
    half of our dependency inversion principle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**解释了我们应该依赖于抽象而不是具体实现。在.NET中，依赖注入是默认可用的。有了自动可用的依赖注入，这满足了依赖倒置原则的一半。'
- en: While we can dependency-inject concrete classes into constructors, a better
    implementation would be to create an interface for the concrete implementation.
    Using interfaces encourages loose coupling throughout our code base.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将具体类注入到构造函数中，但更好的实现是创建一个具体实现的接口。使用接口鼓励我们在整个代码库中实现松散耦合。
- en: For example, back in [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114) with Entity
    Framework, we created a simple interface for our `DbContext`s for this very reason.
    Instead of registering a concrete implementation of a `DbContext`, we could use
    its interface instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到[*第5章*](B19493_05.xhtml#_idTextAnchor114)中，使用Entity Framework，我们为了这个原因创建了一个简单的接口来支持我们的`DbContext`。我们不是注册一个`DbContext`的具体实现，而是使用其接口。
- en: We registered our abstraction (interface) to support our dependency inversion
    principle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了我们的抽象（接口）以支持我们的依赖倒置原则。
- en: In this section, the terms DRY, YAGNI, and KISS, along with what separation
    of concerns means and how refactoring is a process and not a single task. We finished
    the section by learning each SOLID practice, namely the single responsibility,
    open/closed, Liskov substitution, interface segregation, and dependency inversion
    principles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了DRY、YAGNI和KISS等术语，以及关注点分离的含义以及重构是一个过程而不是单一任务。我们通过学习每个SOLID实践结束本节，即单一职责、开闭、里氏替换、接口分离和依赖倒置原则。
- en: In the next section, we’ll learn about folder organization based on project
    types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习基于项目类型的文件夹组织。
- en: Project structure
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: As mentioned in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163), on testing,
    folder structures can reveal an application’s intent and provide documentation
    as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第7章*](B19493_07.xhtml#_idTextAnchor163)中所述，在测试方面，文件夹结构可以揭示应用程序的意图并提供文档。
- en: In this section, we’ll learn about folder structures with ASP.NET web applications.
    We’ll also learn where to place code based on intent, such as where to place API
    code or Entity Framework code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习ASP.NET Web应用程序的文件夹结构。我们还将学习根据意图放置代码的位置，例如放置API代码或Entity Framework代码的位置。
- en: Understanding the project landscape
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解项目景观
- en: Every project has its own structure based on its type. For example, a **Razor
    Page** project layout is different from a **Model-View-Controller** (**MVC**)
    project or an API project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有其基于类型的结构。例如，**Razor Page**项目的布局与**模型-视图-控制器**（**MVC**）项目或API项目不同。
- en: Let’s examine what folders are in these common projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些常见项目中包含哪些文件夹。
- en: 'First, the following is an example of an ASP.NET Razor Page project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以下是一个ASP.NET Razor Page项目的示例：
- en: '![Figure 11.1 – Common folder structure of a Razor Page project](img/B19493_11_01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – Razor页面项目的常见文件夹结构](img/B19493_11_01.jpg)'
- en: Figure 11.1 – Common folder structure of a Razor Page project
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – Razor页面项目的常见文件夹结构
- en: 'Next is an example of an ASP.NET MVC project:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个ASP.NET MVC项目的示例：
- en: '![Figure 11.2 - Common folder structure of an MVC project](img/B19493_11_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 - MVC项目的常见文件夹结构](img/B19493_11_02.jpg)'
- en: Figure 11.2 - Common folder structure of an MVC project
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - MVC项目的常见文件夹结构
- en: As we move through each project, we’ll explain what each folder does and its
    purpose in the application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐个项目进行，我们将解释每个文件夹的功能以及在应用程序中的目的。
- en: wwwroot folder
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wwwroot文件夹
- en: In either of the preceding project types, the `wwwroot` folder contains all
    of our static content used on the website. Any folder added to this directory
    is static content and visible to the browser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述任何项目类型中，`wwwroot` 文件夹包含网站上使用的所有静态内容。添加到该目录的任何文件夹都是静态内容，并且对浏览器可见。
- en: 'One example is an images folder. If we added an images folder to the `wwwroot`
    folder, the URL to that images folder would look like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是图像文件夹。如果我们向 `wwwroot` 文件夹添加一个图像文件夹，该图像文件夹的 URL 将如下所示：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For JavaScript frameworks (such as Angular, React, etc.), a folder called `source`
    or `src` should be created under the `wwwroot` folder to hold your client-side
    source code. The JavaScript framework should be transpiled to another folder of
    your choosing, such as a `js` or `app` folder for public browser consumption.
    We touched on these folders in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)
    when we were building our client-side tasks using a task runner.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JavaScript 框架（如 Angular、React 等），应在 `wwwroot` 文件夹下创建一个名为 `source` 或 `src`
    的文件夹来存放客户端源代码。JavaScript 框架应转换到您选择的另一个文件夹，例如 `js` 或 `app` 文件夹，以便公开供浏览器使用。我们曾在[*第
    6 章*](B19493_06.xhtml#_idTextAnchor137)中提到这些文件夹，当时我们使用任务运行器构建客户端任务。
- en: Pages folder
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面文件夹
- en: In a Razor Page project, the `Pages` folder is where server-side pages are found.
    Every folder created is a path to a page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Razor Page 项目中，`Pages` 文件夹是服务器端页面所在的位置。创建的每个文件夹都是一个页面的路径。
- en: 'For example, if we created a `Setup` folder and added an `Index.cshtml` file,
    the URL to execute and view that page would look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建了一个 `Setup` 文件夹并添加了一个 `Index.cshtml` 文件，执行和查看该页面的 URL 将如下所示：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Other folders created under the `Pages` directory would follow the same path,
    as shown in *Figure 11**.3*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他在 `Pages` 目录下创建的文件夹将遵循相同的路径，如图 *图 11**.3* 所示：
- en: '![Figure 11.3 – Folder structure for a MenuManager page](img/B19493_11_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – MenuManager 页面的文件夹结构](img/B19493_11_03.jpg)'
- en: Figure 11.3 – Folder structure for a MenuManager page
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – MenuManager 页面的文件夹结构
- en: 'Based on the directory structure in *Figure 11**.3*, the URL to **MenuManager**
    would be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图 *图 11**.3* 中的目录结构，**MenuManager** 的 URL 将如下所示：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The simpler the folder structure, the easier it is to locate a page and identify
    page functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构越简单，定位页面和识别页面功能就越容易。
- en: Shared folder
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享文件夹
- en: The `Shared` folder is used for common components such as layout pages, `ViewComponents`,
    partials, `EditorTemplates`, and `DisplayTemplates`. These shared components are
    accessible through web pages in the `Pages` folder (if it’s a Razor Pages project)
    or the `Views` folder (if it’s an MVC project).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shared` 文件夹用于布局页面、`ViewComponents`、部分、`EditorTemplates` 和 `DisplayTemplates`
    等公共组件。这些共享组件可以通过 `Pages` 文件夹中的网页（如果是一个 Razor Pages 项目）或 `Views` 文件夹（如果是一个 MVC
    项目）访问。'
- en: Controllers folder
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器文件夹
- en: MVC projects always contain a `Controllers` folder and are the traffic cops
    of the web application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 项目总是包含一个 `Controllers` 文件夹，并且是网络应用程序的交通警察。
- en: The MVC web model uses a “convention over configuration” concept where the name
    of the controller is the path and the methods inside the controller class are
    the page names.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 网络模型使用“约定优于配置”的概念，其中控制器的名称是路径，控制器类内部的方法是页面名称。
- en: 'For example, in the aforementioned `Controllers` folder, we have a class called
    `HomeController`. If we look in `HomeController`, we’ll see a method called `Index()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的 `Controllers` 文件夹中，我们有一个名为 `HomeController` 的类。如果我们查看 `HomeController`，我们会看到一个名为
    `Index()` 的方法：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The presence of a `HomeController` class tells us three things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 存在 `HomeController` 类告诉我们三件事：
- en: We will have a `/Home` URL with an `Index()` method for a default page
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将有一个带有 `Index()` 方法的 `/Home` URL 作为默认页面
- en: A `Home` folder is located under the `/``Views` folder
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Home` 文件夹位于 `/``Views` 文件夹下'
- en: Since there is an `Index()` method in `HomeController`, there should be an `Index.cshtml`
    in the `/``Views/Home` directory
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `HomeController` 中有一个 `Index()` 方法，因此 `/``Views/Home` 目录中应该有一个 `Index.cshtml`
    文件
- en: The `Index()` method tells us when the `https://localhost:xxx/Home` URL is called.
    It will automatically hit this `Index()` method and, by default, look for the
    Index view in the `/``Views/Home` directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index()` 方法告诉我们当调用 `https://localhost:xxx/Home` URL 时。它将自动调用这个 `Index()` 方法，并且默认情况下，会在
    `/``Views/Home` 目录中查找 Index 视图。'
- en: Feature folders
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能文件夹
- en: One of the secrets of an MVC application is the ability to move controllers
    around to any folder inside the application. On initial startup, the ASP.NET framework
    locates all of the controllers available throughout the application and creates
    a routing table for incoming web requests. Based on this approach, developers
    in the community have created **feature folders**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MVC应用程序的一个秘密是能够将控制器移动到应用程序内部的任何文件夹中。在初始启动时，ASP.NET框架定位应用程序中所有可用的控制器，并为传入的Web请求创建一个路由表。基于这种方法，社区中的开发者创建了**功能文件夹**。
- en: Feature folders are usually contained in a folder called `/Features` off the
    root with folders underneath to identify the feature implemented. While a `/Features`
    folder is the most common, developers have the ability to name the folder anything
    they want. They can also place controllers under any folder in the project. ASP.NET
    can locate all of the controllers on startup.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 功能文件夹通常包含在根目录下的`/Features`文件夹中，下面有文件夹来标识实现的功能。虽然`/Features`文件夹是最常见的，但开发者有权将文件夹命名为他们想要的任何名称。他们还可以将控制器放在项目中的任何文件夹下。ASP.NET在启动时可以定位所有控制器。
- en: These folders usually contain a minimum of a controller, a ViewModel, and a
    View. They can also contain supporting classes related to the feature. The folder
    is named based on the feature being implemented.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件夹通常包含至少一个控制器、一个ViewModel和一个View。它们还可以包含与功能相关的支持类。文件夹的命名基于要实现的功能。
- en: 'For example, if there was an image viewing feature in your MVC application,
    it would look like *Figure 11**.4*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的MVC应用程序中有一个图像查看功能，它看起来会像**图11.4**.4：
- en: '![Figure 11.4 – Example of an ImageViewer feature folder](img/B19493_11_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – ImageViewer功能文件夹示例](img/B19493_11_04.jpg)'
- en: Figure 11.4 – Example of an ImageViewer feature folder
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – ImageViewer功能文件夹示例
- en: 'This folder structure provides the following benefits:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文件夹结构提供了以下好处：
- en: '**Focus** – Each feature is isolated so team members can build the feature
    without causing merge issues'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重点** – 每个功能都是隔离的，这样团队成员可以在不引起合并问题的前提下构建功能'
- en: '**Consolidation** – Instead of moving from one folder to another throughout
    the entire project, features are confined to one folder, making the coding process
    more efficient'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整合** – 而不是在整个项目中的文件夹之间移动，功能被限制在一个文件夹中，这使得编码过程更加高效'
- en: '`Features/AccountsReceiveable` folder'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Features/AccountsReceiveable`文件夹'
- en: In MVC, the View path can be modified to fit your needs. In this case, defining
    a custom path to your views provides even more flexible configurations for your
    application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC中，视图路径可以修改以适应你的需求。在这种情况下，定义一个自定义路径到你的视图提供了更多灵活的配置选项。
- en: The `Features` folder technique is becoming a more viable option for creating
    scalable, feature-based web applications by offering vertical slicing. Vertical
    slicing is the process of writing code for an entire feature across all layers
    (presentation, domain, and data access). Feature folders simplify this process
    and convey isolated features in the application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Features`文件夹技术通过提供垂直切片，正成为创建可扩展、基于功能的Web应用程序的更可行选项。垂直切片是在所有层（表示层、领域和数据访问）上为整个功能编写代码的过程。功能文件夹简化了这一过程，并在应用程序中传达了隔离的功能。'
- en: Models folder
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型文件夹
- en: The `Models` folder contains all of the models used for your Views. This is
    different from a ViewModel. The difference between Models and ViewModels is that
    ViewModels are passed into the View and can contain models to support the ViewModel.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Models`文件夹包含用于你的视图的所有模型。这与ViewModel不同。模型和ViewModel之间的区别在于ViewModel被传递到视图中，并且可以包含支持ViewModel的模型。'
- en: 'An example of a ViewModel is shown in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了ViewModel的一个示例：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A ViewModel is sent to the View (`IndexViewModel`) where a Model can be data
    supporting the ViewModel (`ProductDto`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel被发送到视图（`IndexViewModel`），其中可以包含支持ViewModel的数据模型（`ProductDto`）。
- en: Two common practices include either creating a `ViewModels` directory under
    the `Models` folder, or a `ViewModels` directory in the root of your project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 两种常见的做法包括在`Models`文件夹下创建一个`ViewModels`目录，或者在项目根目录下创建一个`ViewModels`目录。
- en: Views folder
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图文件夹
- en: In an MVC project, the `Views` folder is the equivalent of the `Pages` folder
    in a Razor Pages project. It contains the same folder structure as a Razor Pages
    project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC项目中，`Views`文件夹相当于Razor Pages项目中的`Pages`文件夹。它包含与Razor Pages项目相同的文件夹结构。
- en: Creating project layers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目层
- en: When creating a new web application, the default web project contains the bare
    essentials to run in a browser. But how do you segment the application so you
    don’t have a huge pile of unmanageable code?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的Web应用程序时，默认的Web项目包含在浏览器中运行所需的最基本内容。但你是如何将应用程序分割成多个部分，以避免出现一大堆难以管理的代码呢？
- en: A layer, or tier, is a segment of the application broken up into modules or
    projects designed to perform in a certain way. A presentation layer contains the
    user interface of how the user interacts with the website, while a data access
    layer retrieves data for the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 层或层是应用程序的一部分，被分割成模块或项目，旨在以某种方式执行。表示层包含用户界面，用户如何与网站交互，而数据访问层则检索应用程序的数据。
- en: Identifying project layers can be a bit of a daunting task, but the best way
    is to create application layers based on their functionality. Each project will
    have a consistent naming convention based on its function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 识别项目层可能是一项有些令人畏惧的任务，但最好的方法是根据其功能创建应用程序层。每个项目都将根据其功能采用一致的命名约定。
- en: 'While the following are recommended project layers and names, architect and
    team suggestions may overrule these choices:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下推荐了项目层和名称，但架构师和团队的建议可能会覆盖这些选择：
- en: '`<ProjectName>.Domain` or `<ProjectName>.Core`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectName>.Domain` 或 `<ProjectName>.Core`.'
- en: '`<ProjectName>.Web` or `<ProjectName>.UI`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectName>.Web` 或 `<ProjectName>.UI`.'
- en: '`<ProjectName>.Data` or `<ProjectName>.Infrastructure`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectName>.Data` 或 `<ProjectName>.Infrastructure`.'
- en: '`/api`) or contained in a separate project called `<ProjectName>.Api`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api`) 或包含在名为 `<ProjectName>.Api` 的单独项目中。'
- en: '`Infrastructure` project, the amount of code in an infrastructure project can
    become overwhelming. A services project could provide an alternative to the `Infrastructure`
    project. Services could include a `MailService` or `<Entity>Service`. These projects
    are usually named `<ProjectName>.Services`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`基础设施` 项目，基础设施项目中的代码量可能会变得难以管理。一个服务项目可以提供对 `基础设施` 项目的替代方案。服务可能包括 `MailService`
    或 `<Entity>Service`。这些项目通常命名为 `<ProjectName>.Services`.'
- en: These code layers provide the best layout when organizing your project. Each
    project name describes the intent and gives developers a clear representation
    of the solution as a whole.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码层在组织项目时提供了最佳的布局。每个项目名称都描述了意图，并为开发者提供了一个对整个解决方案的清晰表示。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we learned the DRY, YAGNI, and KISS principles, along with
    separation of concerns, the concept of SOLID, and how refactoring is a process
    and not a one-time quick fix.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们学习了DRY、YAGNI和KISS原则，以及关注点的分离、SOLID概念，以及重构是一个过程而不是一次性的快速修复。
- en: We proceeded to look at how two common ASP.NET web applications were structured
    and what each folder represented. Once we understood a project’s folder structure,
    we examined where code would reside based on its intent, such as Entity Framework
    or service classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探讨两个常见的ASP.NET Web应用程序的结构以及每个文件夹代表的内容。一旦我们理解了一个项目的文件夹结构，我们就根据代码的意图来检查代码将驻留的位置，例如Entity
    Framework或服务类。
- en: Thank you!
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感谢！
- en: Best practices are considered to be what is correct, common, and accepted by
    others in the field. The best practices contained in this book are a combination
    of observations, experience, and feedback over the years from my peers, mentors,
    and the developer community.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践被认为是正确的、常见的，并且被该领域的其他人所接受的。本书中包含的最佳实践是多年观察、经验和来自同行、导师以及开发社区反馈的结合。
- en: I hope these best practices serve as a reference for your ASP.NET development
    career and that you can achieve the same level of excitement as I do when I experience
    a new programming technique or technology.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些最佳实践能成为您ASP.NET开发生涯的参考，并且您能像我体验新的编程技术或技术时一样，达到同样的兴奋程度。
- en: Thank you for your readership!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您的阅读！
- en: Code on, developers... code on!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者们，继续编码吧...
