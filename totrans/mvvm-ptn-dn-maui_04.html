<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor069"/>4</h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Data Binding in .NET MAUI</h1>
<p>In the previous chapter, we introduced the fundamentals of data binding in .NET MAUI. Data binding is not only a core feature of .NET MAUI but also a crucial component for effectively building applications using the MVVM design pattern. It creates a robust link between your View and ViewModel, facilitating efficient communication and synchronization between the two.</p>
<p>As we delve deeper into the realm of data binding, it’s essential to grasp some advanced techniques and features. These are the building blocks that empower you to create dynamic user interfaces as efficiently as possible. They allow us to design user interfaces that are not only more interactive but also easier to manage and maintain.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>ValueConverters and <code>StringFormat</code></li>
<li>Fallbacks</li>
<li>Element and relative binding</li>
<li>Multi-bindings</li>
<li>Compiled bindings</li>
</ul>
<p>By the end of this chapter, combined with what we’ve covered in the previous one, you will have a well-rounded and thorough understanding of data binding in .NET MAUI. This knowledge will enable you to effectively apply these techniques in your applications. Let’s get started!</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Technical requirements</h1>
<p>Throughout this chapter, we will be adding functionality to the <em class="italic">Recipes!</em> app. All the required assets needed to follow along, including all the code used in this chapter, can be found on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter04">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>ValueConverters and StringFormat</h1>
<p>In many<a id="_idIndexMarker257"/> cases, the data in your ViewModel doesn’t perfectly match the format expected by the UI. For example, you may have a <code>DateTime</code> object in your ViewModel that you want to display in a specific string format in your View, or an enumeration that should be represented as a more user-friendly string.</p>
<p>This is where <strong class="bold">ValueConverters</strong> and <strong class="bold">StringFormat</strong> come <a id="_idIndexMarker258"/>into play. Both of these techniques act as intermediaries, transforming and adapting your ViewModel data into a format suitable for display or interaction in the UI.</p>
<p>In this section, we’ll delve into how to create and use ValueConverters to effectively manage these data transformations, and how formatting can further refine the presentation of your data, ensuring it is meaningful and user-friendly.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Creating and using ValueConverters</h2>
<p>A ValueConverter acts<a id="_idIndexMarker259"/> as an intermediary between the source (typically the ViewModel) and the target (the View). It provides a way to transform or convert data as it passes from source to target or vice versa (<em class="italic">Figure 4</em><em class="italic">.1</em>):</p>
<div><div><img alt="Figure 4.1: Usage of a converter" height="255" src="img/B20941_04_01.jpg" width="1207"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Usage of a converter</p>
<p>A common scenario might involve a ViewModel property that is a certain type, such as an enumeration or a complex object, which needs to be displayed differently in the UI. A ValueConverter can convert data from one type to another that is compatible and appropriate for the UI. Similarly, user input received in the UI may need to be converted back into a different format before being stored in the ViewModel.</p>
<p>ValueConverters are classes that implement the <code>Microsoft.Maui.Controls.IValueConverter</code> interface, which defines two methods – <code>Convert</code> and <code>ConvertBack</code>:</p>
<pre class="source-code">
object Convert(object value, Type targetType, object
  parameter, CultureInfo culture);
object ConvertBack(object value, Type targetType, object
  parameter, CultureInfo culture);</pre> <p>The <code>Convert</code> method<a id="_idIndexMarker260"/> is responsible for transforming a value from <a id="_idIndexMarker261"/>the binding source to the binding target. It takes the original value, the target type, an optional parameter, and culture information as parameters. This method performs a conversion and returns an object that represents the transformed data. The transformed data is then used to update the property on the View. It is important to ensure that the returned object matches the expected type of the binding target property or a compatible type.</p>
<p>Let’s take a look at the method’s parameters:</p>
<ul>
<li><code>value</code>: This <a id="_idIndexMarker262"/>is the source data that needs to be converted. This is usually data from your ViewModel that you want to display in your View. Because this can be anything, it is provided as <code>object</code>.</li>
<li><code>targetType</code>: This is <a id="_idIndexMarker263"/>the type of the binding target property. It’s what the method should return the data as. For example, if you’re binding to a property in your View that is of the <code>Microsoft.Maui.Graphics.Color</code> type, then <code>targetType</code> would be <code>Microsoft.Maui.Graphics.Color</code>.</li>
<li><code>parameter</code>: This<a id="_idIndexMarker264"/> is an optional <code>parameter</code> that can be used to pass additional information to the converter.</li>
<li><code>culture</code>: This<a id="_idIndexMarker265"/> is the <code>System.Globalization.CultureInfo</code> culture that should be used in the converter. This is especially important when dealing with dates, times, and numbers, as these can be represented differently in different cultures.</li>
</ul>
<p>The <code>ConvertBack</code> method is<a id="_idIndexMarker266"/> used to reverse the conversion process, transforming data from the binding target back to the binding source. In many cases, the <code>ConvertBack</code> method is not implemented as it only has purpose on <code>TwoWay</code> and <code>OneWayToSource</code> data bindings, where the data on the View needs to be converted before it’s passed to the ViewModel. The return value and parameters are analogous to the <code>Convert</code> method.</p>
<p>This might all be a little abstract at this point, so let’s take a look at building and using a ValueConverter.</p>
<h3>Creating a ValueConverter</h3>
<p>To demonstrate<a id="_idIndexMarker267"/> the flexibility and power of ValueConverters, we’re going to enhance our app by introducing a rating indicator for our recipes. Simply displaying a numeric value isn’t the most appealing or intuitive way to represent a recipe’s rating. Therefore, we’ll utilize a ValueConverter to replace these numbers with star icons, creating a visually engaging and user-friendly rating representation. Our custom ValueConverter, <code>RatingToStarsConverter</code>, will convert a double value into a string. In conjunction with a specific font, this string will display as star icons. But before we can dive into building our converter, we need to take care of some preparatory steps first:</p>
<ol>
<li>First, we are going to create <code>RecipeRatingsSummaryViewModel</code>. Right-click the <code>ViewModels</code> folder and select <code>RecipeRatingsSummaryViewModel.cs</code>.</li>
<li>For now, we are only adding an <code>AverageRating</code> property of the <code>double</code> type to the class:<pre class="source-code">
public class RecipeRatingsSummaryViewModel
{
    public double MaxRating { get; } = 4d;
    public double? AverageRating { get; set; } = 3.5d;
}</pre><p class="list-inset">We are also including a value to indicate the maximum amount of stars that can be given by a user. Next, let’s add an additional property called <code>RatingDetail</code> to <code>RecipeDetailViewModel</code> and assign it a new instance by default:</p><pre class="source-code">public RecipeRatingsSummaryViewModel RatingDetail {
  get; set; } = new ();</pre></li> </ol>
<p>An efficient approach to displaying icons in an application is through the use of a specialized icon font. These fonts, which are readily available both for free and for purchase, allow you to easily incorporate various icons into your application. The principle is simple: incorporate the desired icon font into your app, then assign this font as <code>FontFamily</code> on the <code>Label</code> class where you wish to display the icon. From there, all that’s left is to set the <code>Text</code> property on the <code>Label</code> class to the value that corresponds to the icon you wish to display.</p>
<p>Let’s <a id="_idIndexMarker268"/>include Google’s Material Design Icon font in our app so that we can use this font to display the recipe’s rating later on. You can find the <code>MaterialIcons-Regular.ttf</code> font file in the <code>Chapter 04</code><code>/Assets/Fonts</code> folder or you can download it from <a href="https://github.com/google/material-design-icons/tree/master/font">https://github.com/google/material-design-icons/tree/master/font</a>:</p>
<ol>
<li>In the Visual Studio <code>Resources/Fonts</code> folder in the <strong class="bold">Recipes.Mobile</strong> project and select <strong class="bold">Open Folder in </strong><strong class="bold">File Explorer</strong>.</li>
<li>Copy the <code>MaterialIcons-Regular.ttf</code> font file over to this folder.</li>
<li>Back in Visual Studio, you should see the newly added font file in the <strong class="bold">Solution Explorer</strong>. The file’s <strong class="bold">Build Action</strong> should have automatically been set to <strong class="bold">MauiFont</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.2</em>:</li>
</ol>
<div><div><img alt="Figure 4.2: MaterialIcons-Regular.ttf file properties" height="716" src="img/B20941_04_02.jpg" width="757"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: MaterialIcons-Regular.ttf file properties</p>
<ol>
<li value="4">Next, to be able to use this font in our MAUI app, we need to add it through <code>MauiAppBuilder</code>. Go to <code>MauiProgram.cs</code> and add it:<pre class="source-code">
.ConfigureFonts(fonts =&gt;
{
    ...
<strong class="bold">    fonts.AddFont("MaterialIcons-Regular.ttf",</strong>
<strong class="bold">      "MaterialIconsRegular");</strong>
});</pre><p class="list-inset">The preceding code will allow us to use this font by setting the <code>FontFamily</code> property of a <code>Label</code> class or any control that displays text to <code>MaterialIconsRegular</code>.</p></li> </ol>
<p>Now that all <a id="_idIndexMarker269"/>of this is in place, we can finally start writing our first ValueConverter: <code>RatingToStarsConverter</code>. This converter should convert the rating of a recipe into little star icons.</p>
<h4>RatingToStarsConverter</h4>
<p><code>RatingToStarsConverter</code> should <a id="_idIndexMarker270"/>convert any<a id="_idIndexMarker271"/> double value into a string value that represents stars. This is exactly what converters are for – taking in an object of a particular data type (double) and returning an object of another data type (string). For the visualization of the star icons, we can use the icon font we added earlier. <a href="https://fonts.google.com/icons?icon.set=Material+Icons">https://fonts.google.com/icons?icon.set=Material+Icons</a> provides an overview of all the available icons that exist in the font that we just added. By clicking an icon, you can see different ways to target it. We are interested in the code value. The star icon we want to use has a code of <code>e838</code> and the icon for a half star is identified by the <code>e839</code> code. Packed with this knowledge, let’s see how we can create <code>RatingToStarsConverter</code>:</p>
<ol>
<li>In the <code>Converters</code>.</li>
<li>Right-click the <code>Converters</code> folder and select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>.</li>
<li>Enter the name of our converter, <code>RatingToStarsConverter</code>, and click <strong class="bold">Add</strong>.</li>
<li>Make the <a id="_idIndexMarker272"/>class implement the <code>Microsoft.Maui.Controls.IValueConverter</code> interface, as shown in the following code block:<pre class="source-code">
public class RatingToStarsConverter : IValueConverter
{
    public object Convert(object value, Type
      targetType, object parameter, CultureInfo
        culture)
    {
        throw new NotImplementedException();
    }
    public object ConvertBack(object value, Type
      targetType, object parameter, CultureInfo
        culture)
    {
        throw new NotImplementedException();
    }
}</pre></li> <li>Now, we can start implementing the <code>Convert</code> method. As this converter could be used in any binding statement, the first thing that we need to do is check if the binding<a id="_idIndexMarker273"/> source is indeed a value of the <code>double</code> type:<pre class="source-code">
public object Convert(object value, Type targetType,
    object parameter, CultureInfo culture)
{
    if (value is not double rating
        || rating &lt; 0 || rating &gt; 4)
    {
        return string.Empty;
    }
    ...
}</pre></li> <li>If <a id="_idIndexMarker274"/>the <code>value</code> parameter is not the type that we expect, or it doesn’t fall within the expected range, we are returning a default value – in this case, <code>string.Empty</code>.</li>
<li>After we’ve validated the provided <code>value</code>, we can add the rest of the logic:<pre class="source-code">
string fullStar = "\ue838";
string halfStar = "\ue839";
int fullStars = (int)rating;
bool hasHalfStar = rating % 1 &gt;= 0.5;
return string.Concat(
    string.Join("", Enumerable.Repeat(fullStar,
    fullStars)), hasHalfStar ? halfStar : "");</pre><p class="list-inset">Depending<a id="_idIndexMarker275"/> on the rating value we receive, we will return a string that contains icons defined in the <code>MaterialIcons</code> font we added to our project. For full stars, we must generate a collection of <code>fullStar</code> icons. The <code>string.Join</code> method then consolidates these individual icon strings into a single string. If the rating includes a decimal value of 0.5 or higher, we also append a <code>halfStar</code> icon to the string.</p><p class="list-inset">That’s all we need to do in <code>RatingToStarsConverter</code>. We don’t need to implement the <code>ConvertBack</code> method as this particular converter will not be used in <code>TwoWay</code> or <code>OneWayToSource</code> scenarios. When not implementing the <code>ConvertBack</code> method, it’s good practice to add a comment indicating it’s intentionally not implemented.</p></li> <li>Next, we <a id="_idIndexMarker276"/>want to use our newly created converter, so we need to head over to <code>RecipeDetailPage</code>. The first thing we need to do there is add the namespace of the converter to our XAML, as shown in the following code snippet:<pre class="source-code">
&lt;ContentPage
    x:Class="Recipes.Mobile.RecipeDetailPage"
    
    xmlns:x="http://schemas.microsoft.com/winfx/2009
      /xaml"
    <strong class="bold">xmlns:conv="clr-namespace:Recipes.Mobile</strong>
<strong class="bold">      .Converters"</strong>
    Title="RecipeDetailPage"&gt;</pre><p class="list-inset">By declaring this XML namespace, we can reference anything within the <code>Recipes.Mobile.Converters</code> namespace directly in this XAML page using the <code>conv</code> prefix. The prefix can be anything you choose. To declare it, simply type <code>xmlns:</code> (XML namespace), followed by your chosen prefix, and then set it equal to the CLR namespace you wish to reference. This technique allows for <a id="_idIndexMarker277"/>cleaner and more organized code, as you can use this prefix to reference classes and components from the specified namespace.</p></li> <li>Now, we need to add an instance of <code>RatingToStarsConverter</code> to our page so that we can use it later on in our binding statements. The following code block shows how we can add an instance of the converter as a resource to the page:<pre class="source-code">
&lt;ContentPage
    ...
    &gt;
    &lt;ContentPage.Resources&gt;
        <strong class="bold">&lt;conv:RatingToStarsConverter x:Key=</strong>
<strong class="bold">          "ratingToStarsConverter" /&gt;</strong>
    &lt;/ContentPage.Resources&gt;
    ...</pre><p class="list-inset">By giving <a id="_idIndexMarker278"/>the resource a <code>Key</code> value, we can reference it later on in our XAML.</p></li> <li>Finally, we can now implement the binding of the <code>RatingDetail.AverageRating</code> property and use <code>RatingToStarsConverter</code> as the converter for this binding:<pre class="source-code">
&lt;Label
    <strong class="bold">FontFamily="MaterialIconsRegular"</strong>
    FontSize="18"
    <strong class="bold">Text="{Binding RatingDetail.AverageRating,</strong>
<strong class="bold">      Converter={StaticResource</strong>
<code>Binding Markup Extension</code>, we can define <code>Converter</code>. We can reference the instance we’ve declared on top of this page by using the <code>StaticResource Markup Extension</code> and passing in the key value of the converter<a id="_idIndexMarker279"/> instance. The converter will return a particular string value that, in combination with the label’s <code>FontFamily</code> set to <code>MaterialIconsRegular</code>, will show icons on the screen.</p></li> </ol>
<p class="callout-heading">About resources, StaticResource, and DynamicResource</p>
<p class="callout">The converter we’ve just added to the resources is now accessible on this particular page. It’s important to note that the scope of this resource is local to this page only. That means if you want to use this converter on other pages, you would have to declare it in their resources too.</p>
<p class="callout">If you plan to use this converter across multiple pages, consider adding it to your <code>App.xaml</code> resources instead. By doing this, the converter becomes globally accessible throughout your app, eliminating the need to redeclare it on each page. This leads to cleaner and more maintainable code, especially for resources such as converters, which are often used throughout an application.</p>
<p class="callout">The <code>StaticResource Markup Extension</code> looks <a id="_idIndexMarker280"/>up a resource in a resource dictionary and assigns it to the property that it is set on. This resource lookup is performed only once when the page or control that uses <code>StaticResource</code> is loaded.</p>
<p class="callout">The <code>DynamicResource Markup Extension</code>, on <a id="_idIndexMarker281"/>the other hand, is used when the value can change and the UI needs to be updated to reflect this change. It maintains a link between the property and the resource, so when the resource changes, the property is updated too. <code>DynamicResource</code> is <a id="_idIndexMarker282"/>perfect for scenarios such as theme switching, where the values in the resource dictionary can be updated.</p>
<p>Alternatively, you<a id="_idIndexMarker283"/> can express the converter to use from the code if you define your data binding from code-behind. For this to <a id="_idIndexMarker284"/>work, you need to name the label you want to show the rating on <code>lblRating</code>, using the <code>x:Name</code> attribute:</p>
<pre class="source-code">
lblRating.SetBinding(Label.TextProperty,
$"{nameof(RecipeDetailViewModel.RatingDetail)}.{nameof
  (RecipeRatingsSummaryViewModel.AverageRating)}",
    converter: new RatingToStarsConverter());</pre> <p>The <code>SetBinding</code> method accepts an optional converter parameter that allows you to specify the converter that should be used. When you run the app, you should see stars representing the recipe’s rating, as shown in the following figure:</p>
<div><div><img alt="Figure 4.3: RatingToStartsConverter in action" height="109" src="img/B20941_04_03.jpg" width="559"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: RatingToStartsConverter in action</p>
<p>Let’s enhance <a id="_idIndexMarker285"/>the user interface and user experience of our app a notch further. To achieve this, we’ll assign unique colors to the rating indicator based on the average rating of a recipe.</p>
<h4>RatingToColorConverter</h4>
<p>With <code>RatingToColorConverter</code>, we<a id="_idIndexMarker286"/> should be able to give the stars that represent<a id="_idIndexMarker287"/> the recipe’s rating a color depending on the average rating. Additionally, we want to display four stars consistently in the background, regardless of the recipe’s average score. <em class="italic">Figure 4</em><em class="italic">.4</em> shows exactly what we want to achieve:</p>
<div><div><img alt="Figure 4.4: Rating indicator using different colors" height="90" src="img/B20941_04_04.jpg" width="715"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Rating indicator using different colors</p>
<p>This visual cue serves as a rating scale that helps users immediately comprehend where a recipe stands in terms of rating. As the background stars need to be in a different color from the ones indicating the actual score, our new ValueConverter must accept a parameter to distinguish between foreground and background colors.</p>
<p>So, let’s get started! Like<a id="_idIndexMarker288"/> we did before, we need to add a converter and implement the <code>IValueConverter</code> interface:</p>
<ol>
<li>Right-click the <strong class="bold">Converters</strong> folder in the <strong class="bold">Recipe.Mobile</strong> project and select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>.</li>
<li>Enter <code>RatingToColorConverter</code> as the name and click <strong class="bold">Add</strong>.</li>
<li>Make the class implement the <code>IValueConverter</code> interface.</li>
<li>In the <code>Convert</code> method, we can check the parameter that is being passed in. When the <code>"background"</code> value is passed as a parameter to this converter, we want to return a slightly different color:<pre class="source-code">
bool isBackground = parameter is string param
    &amp;&amp; param.ToLower() == "background";</pre></li> <li>Once we<a id="_idIndexMarker289"/> have this information, we can go ahead and implement the rest of this method:<pre class="source-code">
var hex = value switch
{
    double r when r &gt; 0 &amp;&amp; r &lt; 1.4 =&gt; isBackground ?
      "#E0F7FA" : "#ADD8E6", //blue
    double r when r &lt; 2.4 =&gt; isBackground ? "#F0C085"
      : "#CD7F32", //bronze
    double r when r &lt; 3.5 =&gt; isBackground ? "#E5E5E5"
      : "#C0C0C0", //silver
    double r when r &lt;= 4.0 =&gt; isBackground ? "#FFF9D6"
      : "#FFD700", //gold
    _ =&gt; null,
};
Return hex is null ? null : Color.FromArgb(hex);</pre><p class="list-inset">Depending on the provided rating, this converter returns a particular color. On top of that, if the converter parameter is <code>"background"</code>, a slightly different color accent is returned that should serve as a background color.</p></li> <li>The following<a id="_idIndexMarker290"/> code block shows how we can add this converter as a resource to <code>RecipeDetailPage</code>. This allows us to use the converter on the page:<pre class="source-code">
&lt;ContentPage.Resources&gt;    ...
    <strong class="bold">&lt;conv:RatingToColorConverter</strong>
      <strong class="bold">x:Key="ratingToColorConverter" /&gt;</strong>
&lt;/ContentPage.Resources&gt;</pre><p class="list-inset">With that in place, we can use the defined key, <code>"ratingToColorConverter"</code>, to reference this converter in our data binding statements.</p></li> <li>Finally, replace<a id="_idIndexMarker291"/> the label we had previously showing the <code>Rating</code> property with the following code:<pre class="source-code">
&lt;Grid&gt;
    &lt;Label
        FontFamily="MaterialIconsRegular"
        FontSize="18"
        <strong class="bold">Text="{Binding RatingSummary.MaxRating,</strong>
<strong class="bold">        Converter={StaticResource</strong>
          <strong class="bold">ratingToStarsConverter}}"</strong>
        <strong class="bold">TextColor="{Binding</strong>
          <strong class="bold">RatingSummary.AverageRating,</strong>
<strong class="bold">        Converter={StaticResource</strong>
          <strong class="bold">ratingToColorConverter},</strong>
            <strong class="bold">ConverterParameter=background}"</strong> /&gt;
    &lt;Label
        FontFamily="MaterialIconsRegular"
        FontSize="18"
        <strong class="bold">Text="{Binding RatingSummary.AverageRating,</strong>
<strong class="bold">        Converter={StaticResource</strong>
          <strong class="bold">ratingToStarsConverter}}"</strong>
        <strong class="bold">TextColor="{Binding</strong>
          <strong class="bold">RatingSummary.AverageRating,</strong>
<strong class="bold">        Converter={StaticResource</strong>
          <strong class="bold">ratingToColorConverter}}"</strong> /&gt;
&lt;/Grid&gt;</pre><p class="list-inset">By placing<a id="_idIndexMarker292"/> both labels in <code>Grid</code>, the labels <a id="_idIndexMarker293"/>will overlap and as a result, the first one will act as the backdrop for the rating indicator. This label’s <code>Text</code> property is bound to the <code>RatingSummary.MaxRating</code> property and indicates the upper bound of the ratings. <code>RatingToStarsIconConverter</code> will transform this value into star icons. Additionally, its <code>TextColor</code> property is bound to the <code>RatingSummary.AverageRating</code> property of the ViewModel, using our newly created <code>RatingToColorConverter</code> to decide its color. Note that we’ve set the <code>ConverterParameter</code> property of the <code>Binding Markup Extension</code> to <code>"background"</code>. This parameter is forwarded to the converter, signaling that we need a color suitable for a background icon.</p><p class="list-inset">The second <code>Label</code> class’s <code>Text</code> and <code>TextColor</code> properties are also bound to the <code>RatingSummary.AverageRating</code> property of <code>RecipeDetailViewModel</code>. <code>RatingToColorConverter</code> is used as the converter for the <code>TextColor</code> property, providing a color based on the recipe’s rating. Because we didn’t use <code>ConverterParameter</code> here, the converter understands that it needs to produce a color intended for the foreground.</p></li> </ol>
<p>These<a id="_idIndexMarker294"/> two <a id="_idIndexMarker295"/>simple ValueConverters provide a nice visualization for the recipe’s rating. When running the app, we should see a nice colorful visualization of the recipe’s rating, as shown in the following figure:</p>
<div><div><img alt="Figure 4.5: Rating indicator using different colors" height="108" src="img/B20941_04_05.jpg" width="563"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Rating indicator using different colors</p>
<p>We haven’t implemented the <code>ConvertBack</code> method of the ValueConverters in these examples as they only serve a purpose in <code>TwoWay</code> or <code>OneWayToSource</code> data bindings. Let’s have a quick look at an example.</p>
<h4>InverseBoolConverter</h4>
<p>A very common <a id="_idIndexMarker296"/>and simple converter is <code>InverseBoolConverter</code>: it just takes a <code>bool</code> value and returns the inverse. An implementation<a id="_idIndexMarker297"/> of <code>InverseBoolConverter</code> typically also includes an implementation for its <code>ConvertBack</code> method. This is particularly relevant because, in the context of two-way data binding, an action on the UI can trigger an update to the bound bool value. By providing a <code>ConvertBack</code> implementation, we ensure that changes in the UI are correctly mirrored back to the ViewModel, keeping the data synchronized. Let’s see how we can create a converter with an implemented <code>ConvertBack</code> method:</p>
<ol>
<li>To create <code>InverseBoolConverter</code>, create a new class called <code>InverseBoolConverter</code> and let it implement the <code>IValueConverter</code> interface.</li>
<li>Let’s write an <code>Inverse</code> method that returns a <code>bool</code> value and takes a <code>value</code> parameter of the <code>object</code> type:<pre class="source-code">
private bool Inverse(object value)
    =&gt; value switch
    {
        bool b =&gt; !b,
        _ =&gt; false
    };</pre><p class="list-inset">This method <a id="_idIndexMarker298"/>accepts a <code>value</code> parameter of the <code>object</code> type. Inside this method, we check if the provided value is a <code>bool</code> value. If it is, we return <code>inverse</code>; if it’s not, we return <code>false</code>.</p></li> <li>This<a id="_idIndexMarker299"/> method can now be used by both the <code>Convert</code> and <code>ConvertBack</code> methods as both methods should inverse the given <code>bool</code> value:<pre class="source-code">
public object Convert(object value, Type targetType,
  object parameter, CultureInfo culture)
=&gt; Inverse(value);
public object ConvertBack(object value, Type
  targetType, object parameter, CultureInfo culture)
=&gt; Inverse(value);</pre></li> <li>To see <a id="_idIndexMarker300"/>this converter in action, we can go to <code>RecipeDetailViewModel</code>, update the <code>ShowAllergenInformation</code> property to <code>HideAllergenInformation</code>, and change its default value to <code>true</code>:<pre class="source-code">
private bool _hideAllergenInformation = true;
public bool HideAllergenInformation
{
    get =&gt; _ hideAllergenInformation;
    set
    {
        if (_hideAllergenInformation != value)
        {
            _ hideAllergenInformation = value;
            OnPropertyChanged();
        }
    }
}</pre></li> <li>Because the meaning of this property is now the opposite<a id="_idIndexMarker301"/> of what it was, we need to <a id="_idIndexMarker302"/>update the bindings on our UI. This is exactly where our new <code>InverseBoolConverter</code> comes in. After we’ve added <code>InverseBoolConverter</code> to the resources of <code>RecipeDetailPage</code>, we can update the XAML to this:<pre class="source-code">
&lt;HorizontalStackLayout&gt;
    &lt;Label
        FontAttributes="Italic"
        Text="Show Allergen information"
        VerticalOptions="Center" /&gt;
    &lt;CheckBox IsChecked="<strong class="bold">{Binding</strong>
<strong class="bold">      HideAllergenInformation, Mode=OneWayToSource,</strong>
<strong class="bold">        Converter={StaticResource</strong>
<strong class="bold">          inverseBoolConverter}}</strong>" /&gt;
&lt;/HorizontalStackLayout&gt;
&lt;Label IsVisible="<strong class="bold">{Binding HideAllergenInformation,</strong>
<strong class="bold">  Mode=OneWay, Converter={StaticResource</strong>
<strong class="bold">    inverseBoolConverter}}</strong>"
    Text="ToDo: add allergen information" /&gt;</pre><p class="list-inset"><code>InverseBoolConverter</code> will inverse the <code>HideExtendedAllergenList</code> property’s value. The <code>Convert</code> method will be invoked in the <code>OneWay</code> data binding scenario, whereas the <code>ConvertBack</code> method will be called when tapping <code>CheckBox</code>, triggering an update of <code>IsCheckedProperty</code>, which – through the <code>OneWayToSource</code> data binding – needs to update the property on the ViewModel.</p></li> </ol>
<p>ValueConverters<a id="_idIndexMarker303"/> are a powerful feature in data binding that enables seamless transformation of data between the ViewModel and the View. They provide a clean, maintainable way to control the display of data and handle discrepancies between the format of data in the ViewModel and how it needs to be displayed or inputted in the View.</p>
<p class="callout-heading">Keep converters simple</p>
<p class="callout">Keep in mind that on screens with a lot of converters, these converters can be invoked a lot of times, especially in collections. As such, it is advised to keep converters as simple as possible and consider their performance.</p>
<p>As a developer, mastering<a id="_idIndexMarker304"/> ValueConverters will greatly enhance your ability to build dynamic, data-driven applications with .NET MAUI. In <a href="B20941_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Community Toolkits</em>, we will see that the .NET MAUI Community Toolkit is packed with converters that are up for grabs for you to use in your projects.</p>
<p>An alternative approach to transform how data from the ViewModel needs to be displayed is by providing <code>StringFormat</code>.</p>
<h4>StringFormat</h4>
<p>Despite <a id="_idIndexMarker305"/>being<a id="_idIndexMarker306"/> less powerful than ValueConverters, providing <code>StringFormat</code> to your data binding offers a quick and straightforward way to modify the presentation of your data directly within your data binding expressions, saving you from the overhead of creating a separate converter for simple transformations. It leverages the standard .NET formatting conventions to shape the bound data into a specific string format. It’s particularly useful when the bound data is of a primitive or built-in .NET data type, such as <code>DateTime</code>, <code>int</code>, <code>float</code>, <code>double</code>, and so on, and you want to format that data in a specific way for display.</p>
<p>As a first example, let’s show the calories of the recipe on <code>RecipeDetailPage</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 4.6: Showing the calories and cooking time" height="86" src="img/B20941_04_06.jpg" width="357"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Showing the calories and cooking time</p>
<p>Let’s have a look <a id="_idIndexMarker307"/>at how simple this is to implement:</p>
<ol>
<li>Add the optional <code>Calories</code> and <code>ReadyInMinutes</code> properties to <code>RecipeDetailViewModel</code>:<pre class="source-code">
public int? Calories { get; set; } = 240;
public int? ReadyInMinutes { get; set; } = 35;</pre></li> <li>Now, as we want to show these properties on the screen, we need to indicate what this value means. We don’t just want to show the raw values. For that, we could use multiple labels or a converter to enrich these raw values with additional context. Alternatively, we could use <code>StringFormat</code>, like this:<pre class="source-code">
&lt;Label Text="{Binding Calories,
  <strong class="bold">StringFormat='Calories: {0} kcal'</strong>}" /&gt;
&lt;Label Text="{Binding ReadyInMinutes,
  <strong class="bold">StringFormat='Ready in: {0} minutes'</strong>}" /&gt;</pre></li> </ol>
<p>Much like how <a id="_idIndexMarker308"/>we use the <code>string.Format</code> method in .NET, we can use the <code>StringFormat</code> property of <code>Binding Markup Extension</code>. In the format string, we can use a placeholder (<code>{0}</code>) to indicate where the bound value should be inserted. This approach provides a straightforward way to integrate bound values into formatted string expressions.</p>
<p>And the similarity with <code>string.Format</code> doesn’t stop there. We can even use numeric, timespan, and date and time format strings.</p>
<p>To demonstrate this, let’s add a <code>LastUpdated</code> timestamp to <code>RecipeDetailPage</code>. Let’s look at the<a id="_idIndexMarker309"/> following steps:</p>
<ol>
<li>First, we need to add a property called <code>LastUpdated</code> to <code>RecipeDetailViewModel</code>:<pre class="source-code">
public DateTime LastUpdated { get; set; }
    = new DateTime(2020, 7, 3);</pre></li> <li>Now, we can go to <code>RecipeDetailPage</code> and bind this value to a new label:<pre class="source-code">
&lt;Label
    FontSize="8"
    HorizontalOptions="End"
    Text="{Binding LastUpdated, <strong class="bold">StringFormat='Last</strong>
<code>string.Format</code> method, we can add a format specifier to a placeholder. In this case, <code>D</code> is a standard <code>DateTime</code> format string representing the long date format specifier. It formats the bound <code>DateTime</code> value into a long date pattern. Of course, we could achieve the same result by creating a ValueConverter, but using the <code>StringFormat</code> property is a lot more concise and straightforward for such simple transformations. It saves us from the additional overhead of defining a separate converter class, thereby keeping our code cleaner and more maintainable.</p></li> <li>Additionally, we <a id="_idIndexMarker310"/>might want to show the average ratings textually on the screen as well, limiting it to 1 decimal:<pre class="source-code">
&lt;Label FontSize="8"
    Text="{Binding RatingDetail.AverageRating,
      StringFormat='<code>string.Format</code> method.</p></li> </ol>
<p>Let’s examine the app, specifically focusing on these two labels. Here is what they look like:</p>
<div><div><img alt="Figure 4.7: Leveraging StringFormat" height="153" src="img/B20941_04_07.jpg" width="804"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Leveraging StringFormat</p>
<p>ValueConverters<a id="_idIndexMarker311"/> and <code>StringFormat</code> not only facilitate the translation of data from the ViewModel into something more suitable for our UI, but also allow for the creation of more dynamic, responsive, and user-friendly applications. By using ValueConverters, we can handle complex conversions, while <code>StringFormat</code> helps us effortlessly format strings right in our bindings. Both of these mechanisms empower us to handle data transformations seamlessly, without overloading our ViewModel with UI-related concerns. Remember, effective data binding is not only about linking data; it’s also about presenting data in the most intuitive way possible to our users.</p>
<p>But what <a id="_idIndexMarker312"/>about when things don’t go exactly as planned? What if the data we’re binding to is null? This is where <code>TargetNullValue</code> and <code>FallbackValue</code> in our bindings to handle such cases and ensure a more robust, fail-safe user interface.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Fallbacks</h1>
<p>There are<a id="_idIndexMarker313"/> occasions where data binding can fail; the binding source cannot be resolved (yet) or the returned value is null. Although ValueConverters and additional code could tackle many such situations, we can also enhance the resilience of our data bindings by<a id="_idIndexMarker314"/> setting fallback values. This can easily be done by setting the <code>TargetNullValue</code> or <code>FallbackValue</code> property<a id="_idIndexMarker315"/> in our binding expression.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>TargetNullValue</h2>
<p>The <code>TargetNullValue</code> property<a id="_idIndexMarker316"/> can be used in situations where we want to handle the situation where the resolved binding source target returns <code>null</code>. In other words, the binding engine can resolve the bound property, but this property returns a <code>null</code> value.</p>
<p>In our app, the <code>Calories</code> property on <code>RecipeDetailViewModel</code> is defined as a nullable <code>int</code>. This makes it essential for us to handle any potential null values in our data binding elegantly. If we leave the binding statement as-is, the label would show <code>"Calories:  kcal"</code> if the <code>Calories</code> property is <code>null</code>. Not very clean-looking, right? Let’s fix this:</p>
<pre class="source-code">
&lt;Label Text="{Binding Calories, StringFormat='Calories: {0}
  kcal', <strong class="bold">TargetNullValue='No calories information</strong>
<code>TargetNullValue</code> property, we dictate what value should be used if the bound property returns <code>null</code>. Note that the defined <code>StringFormat</code> will not apply when <code>TargetNullValue</code> is used! We can do the same thing with the binding of the <code>ReadyInMinutes</code> property:</p>
<pre class="source-code">
&lt;Label Text="{Binding ReadyInMinutes, StringFormat='Ready
  in: {0} minutes', <strong class="bold">TargetNullValue='No cooking time</strong>
<code>RecipeDetailPage</code>. And because there might not always be an image added to a recipe, we need to make sure we provide a <code>TargetNullValue</code> property so that a default image is shown. Let’s take a look at how we could implement this:</p>
<ol>
<li>First, we need to add the <code>Chapter 04</code><code>/Assets/caesarsalad.png</code> and <code>Chapter 04</code><code>/Assets/fallback.png</code> images to the <code>Resources/Images</code> folder of the <code>Recipes.Mobile</code> project. The easiest way to do this is by using your operating system’s file manager to copy the files over.</li>
<li>Add an <code>Image</code> property to <code>RecipeDetailViewModel</code>:<pre class="source-code">
public string Image { get; } = "caesarsalad.png";</pre></li> <li>Next, add<a id="_idIndexMarker317"/> the following XAML to <code>RecipeDetailPage.xaml</code>, just above the <strong class="bold">Add</strong>/<strong class="bold">Remove as </strong><strong class="bold">favorite</strong> buttons:<pre class="source-code">
&lt;Image Margin="-10,10"
  Aspect="AspectFill" HeightRequest="200"
  HorizontalOptions="Fill"
  Source="{Binding Image, TargetNullValue=fallback.png}"
  /&gt;</pre><p class="list-inset">Because the value on <code>RecipeDetailViewModel</code> is set to <code>caesarsalad.png</code>, the app will show this image on the screen. However, if you assign <code>null</code> to it, the <code>fallback.png</code> image will be shown as it is defined as <code>TargetNullValue</code>. <em class="italic">Figure 4</em><em class="italic">.8</em> shows what this looks like:</p></li> </ol>
<div><div><img alt="Figure 4.8: Showing the recipe’s image (left) or a fallback value (right)" height="399" src="img/B20941_04_08.jpg" width="1119"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Showing the recipe’s image (left) or a fallback value (right)</p>
<p>Not too complex, right? It does get a little bit more complicated when a ValueConverter is involved. If the bound property is <code>null</code>, this <code>null</code> value will get passed into the ValueConverter. Only if said converter returns null will <code>TargetNullValue</code> be used. If the ValueConverter were to return a non-null value, <code>TargetNullValue</code> would not be used. While it is possible to define <code>TargetNullValue</code> as <code>StaticResource</code> or use the <code>x:Static Markup Extension</code> to assign it a static value, it is not possible to set its value with a binding expression.</p>
<p>Looking at the <code>AverageRating</code> property of <code>RecipeRatingsSummaryViewModel</code>, we could assign this a null value by default and update<a id="_idIndexMarker318"/> the <code>TextColor</code> binding statements to this:</p>
<pre class="source-code">
TextColor="{Binding RatingDetail.AverageRating,
Converter={StaticResource ratingToColorConverter},
ConverterParameter=background, <strong class="bold">TargetNullValue={x:Static</strong>
<code>HotPink</code> because <code>RatingToColorConverter</code> returns <code>null</code> when the provided value is <code>null</code>. When we update <code>RatingToColorConverter</code> so that it returns a default color if the value doesn’t fall within the expected range, the <code>TargetNullValue</code> will not be used:</p>
<pre class="source-code">
public object Convert(object value, Type targetType, object
  parameter, CultureInfo culture)
{
    ...
    var hex = value switch
    {
        ...
        _ =&gt; "#EBEBEB"
    };
    return Color.FromArgb(hex);
}</pre> <p><code>TargetNullValue</code> can be very useful for handling properties that might return a null value. However, it won’t be helpful if the property or its source is inaccessible or doesn’t exist since it isn’t a null value issue but a problem with resolving the property itself. For example, in our app, it could be that the <code>RatingDetail</code> property of <code>RecipeDetailViewModel</code> is still null because it’s not (yet) loaded. For that, we can use the <code>FallBackValue</code> property.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>FallbackValue</h2>
<p><code>FallbackValue</code> is <a id="_idIndexMarker319"/>used when the binding engine is unable to retrieve a value due to an error or if the source itself is <code>null</code>, rather than when the resolved binding source returns <code>null</code>. As an example, we can set the <code>RatingDetail</code> property on <code>RecipeDetailViewModel</code> to <code>null</code> instead of assigning it a new instance and update the following data binding:</p>
<pre class="source-code">
&lt;Label FontSize="8"
Text="{Binding RatingDetail.AverageRating,
  StringFormat='{0:0.#} avg. rating',
    <code>Label</code> class displaying <code>"Ratings not available"</code> when the binding engine is unable to resolve the <code>RatingDetail.AverageRating</code> property. Just like with the <code>TargetNullValue</code> property, when <code>FallbackValue</code> is being used, the <code>StringFormat</code> property will be ignored. Additionally, a converter defined on this binding statement would also be ignored when using the <code>FallbackValue</code> value.</p>
<p>If we wish to combine the two, both <code>TargetNullValue</code> and <code>FallbackValue</code>, we could do the following:</p>
<pre class="source-code">
&lt;Label
    FontSize="8"
    Text="{Binding RatingDetail.AverageRating,
      StringFormat='{0:0.#} avg. rating',
        <strong class="bold">FallbackValue='Ratings not available'</strong>,
          <code>"No ratings yet"</code> will be displayed when the <code>AverageRating</code> property is set to <code>null</code>, whereas <code>"Ratings not available"</code> will be shown when the <code>AverageRating</code> property cannot be resolved due to the <code>RatingDetail</code> property being <code>null</code>.</p>
<p>Both <code>TargetNullValue</code> and <code>FallbackValue</code> are very valuable properties of the <code>Binding Markup Extension</code> and are very often overlooked. However, they can help tremendously in creating simple and easy-to-maintain UIs that make sense to the user. When both <code>FallbackValue</code> and <code>TargetNullValue</code> are defined in a binding, <code>TargetNullValue</code> takes precedence when the source property is null. <code>FallbackValue</code> is used when the binding system is unable to get a property value, such as when the path is <a id="_idIndexMarker320"/>incorrect or the source is not available. So, essentially, <code>TargetNullValue</code> is used for null values, while <code>FallbackValue</code> is used for binding errors.</p>
<p>Up until now, we’ve been binding to data on our ViewModel, but we can also bind to other elements in our visual tree. Let’s have a look at element and relative data binding.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Element and relative binding</h1>
<p>The versatility of data binding extends beyond linking our Views with ViewModel data. It’s also possible to bind to different elements within our visual tree, opening up many new possibilities.</p>
<p>Both <strong class="bold">element bindings</strong> and <strong class="bold">relative bindings</strong> serve the purpose of allowing bindings to <a id="_idIndexMarker321"/>other elements. However, they differ in how they identify the source element:</p>
<ul>
<li>In an element binding, you specify the source element by its name, which is defined by using the <code>x:Name</code> attribute in XAML. The binding refers to this specific named element.</li>
<li>In a relative binding, you <a id="_idIndexMarker322"/>refer to the source element concerning the position of the current element in the XAML tree. For example, you might bind to a property of the parent element or a property of the next sibling element, or you might even bind to a property of the element itself.</li>
</ul>
<p>Let’s have a look at both types of binding in more detail. First up: element binding.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Element binding</h2>
<p>With <a id="_idIndexMarker323"/>element binding, we can bind to the property of another element by referencing that element by its name. For example, in our <em class="italic">Recipes!</em> app, we could remove the <code>HideExtendedAllergenList</code> property from the ViewModel and update our XAML to this:</p>
<pre class="source-code">
&lt;HorizontalStackLayout&gt;
    &lt;Label Text="Show extended allergen list?"
      VerticalOptions="Center" /&gt;
    &lt;CheckBox <strong class="bold">x:Name="cbShowAllergens"</strong> IsChecked="False" /&gt;
&lt;/HorizontalStackLayout&gt;
&lt;VerticalStackLayout Margin="10,0,0,0" <strong class="bold">IsVisible="{Binding</strong>
<strong class="bold">  IsChecked, Source={Reference cbShowAllergens}}"</strong>&gt;
    &lt;Label Text="ToDo, add extended allergen list" /&gt;
&lt;/VerticalStackLayout&gt;</pre> <p>In the <a id="_idIndexMarker324"/>preceding example, we are binding the <code>IsVisible</code> property of <code>VerticalStackLayout</code> to the <code>IsChecked</code> property of the <code>cbShowAllergenList</code> <code>CheckBox</code>. This eliminates the need for an additional property on <code>RecipeDetailViewModel</code> and keeps the ViewModel clean and focused.</p>
<p>This direct connection between UI components streamlines the logic, reduces the ViewModel’s responsibilities, and increases the maintainability of our code. It’s a clear demonstration of how element binding can simplify interactions within the user interface.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Relative binding</h2>
<p>Relative binding<a id="_idIndexMarker325"/> in XAML provides a way to set the source of a binding relative to the position of the binding target in the UI tree, and it can reference either the binding target itself or one of its ancestors.</p>
<p>The three main forms of relative binding are as follows:</p>
<ul>
<li><strong class="bold">Self</strong>: This <a id="_idIndexMarker326"/>mode is used to bind a property to another property on the same element. It’s useful when one property depends on the value of another.</li>
<li><strong class="bold">FindAncestor</strong>: This<a id="_idIndexMarker327"/> mode is used to bind a property to a property on an ancestor element in the visual tree. You can specify the type of the ancestor element and how far up the visual tree to search.</li>
<li><code>ControlTemplate</code> to bind a property to a property on the control the template is applied to. It is particularly <a id="_idIndexMarker329"/>useful when creating custom templates for a control.</li>
</ul>
<p>Let’s have a look at these three forms of relative binding in more detail.</p>
<h3>Self-relative binding mode</h3>
<p>As an<a id="_idIndexMarker330"/> example <a id="_idIndexMarker331"/>of the self-relative binding mode, let’s take a look at the two buttons in our app that allow the user to set or remove a recipe as a favorite. Wouldn’t it be nice if we could hide the disabled button? We can easily achieve this by using the <code>Self</code> relative binding mode:</p>
<pre class="source-code">
&lt;Button
    Command="{Binding AddAsFavoriteCommand}"
    <strong class="bold">IsVisible="{Binding IsEnabled, Source={RelativeSource</strong>
<strong class="bold">      Self}}"</strong>
    Text="Add as favorite" /&gt;</pre> <p><code>AddAsFavoriteCommand</code> is responsible for setting the button to enabled or disabled, depending on what the <code>CanExecute</code> method returns. With this relative binding, we are binding the <code>IsEnabled</code> property of the button itself to the <code>IsVisible</code> property. Now, when the button is disabled, it is not shown on the UI.</p>
<h3>FindAncestor relative binding mode</h3>
<p>In relative <a id="_idIndexMarker332"/>bindings, <code>AncestorType</code> is useful when you <a id="_idIndexMarker333"/>need to bind to a property of a parent element in the visual tree. It essentially “walks up” the tree of UI elements until it finds an instance of the specified type. By specifying <code>AncestorLevel</code>, we can define which ancestor to bind to. By default, <code>AncestorLevel</code> is 1, meaning it will bind to the nearest ancestor of the specified type. However, if you set <code>AncestorLevel</code> to 2, it will bind to the second nearest ancestor of the specified type, and so on. This offers a great deal of flexibility and control in choosing the specific ancestor in the visual tree that you want to bind to.</p>
<p>As a simple example, we can give the root <code>VerticalStackLayout</code> a <code>BackgroundColor</code> of <code>GhostWhite</code>. Now, if we want to bind the <code>TextColor</code> property of the two buttons on the bottom of the page to the <code>BackgroundColor</code> property of <code>VerticalStackLayout</code>, we could write the following:</p>
<pre class="source-code">
&lt;Button
    BackgroundColor="LightSlateGray"
    ...
    TextColor="<strong class="bold">{Binding BackgroundColor,</strong>
<strong class="bold">      Source={RelativeSource AncestorLevel=2,</strong>
<code>TextColor</code> property <a id="_idIndexMarker334"/>of the button is now bound to the <code>BackgroundColor</code> property of its second ancestor (<code>AncestorLevel=2</code>), which is of the <code>VerticalStackLayout</code> type (<code>AncestorType={x:Type VerticalStackLayout}</code>). Keep in mind that whenever the <a id="_idIndexMarker335"/>structure of the page changes, there might be no other ancestor of this type at the second level.</p>
<h3>TemplatedParent relative binding mode</h3>
<p>A <code>Control Template</code> is an <a id="_idIndexMarker336"/>XAML markup snippet that<a id="_idIndexMarker337"/> defines how a control should be rendered. When you’re inside a control template, you can use <code>TemplatedParent</code> to bind to the properties of the control that’s using the template. We will dive into this in more detail in <a href="B20941_11.xhtml#_idTextAnchor182"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating </em><em class="italic">MVVM-Friendly Controls</em>.</p>
<p>Relative bindings in XAML offer a powerful way to connect properties of different elements within our user interface. One of its strongest aspects is its ability to traverse up the visual tree, enabling access to binding contexts of other elements. This feature becomes especially useful when the current element’s binding context isn’t sufficient or when we need to link a property to an element outside of its immediate scope.</p>
<p>In many UI scenarios, a certain state is defined by a combination of multiple properties. While it’s certainly possible to create an additional property in the ViewModel that aggregates these properties for binding, there is a better, more elegant way to deal with this. Let’s have a look at multi-bindings.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Multi-bindings</h1>
<p>Multi-binding<a id="_idIndexMarker338"/> is a powerful feature in XAML data binding that allows you to bind a single target property to multiple source properties and then apply logic to produce one single value. This technique is particularly useful when a target property’s value depends on more than one source property. The simplest example of this is using <code>StringFormat</code>.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Multi-binding StringFormat</h2>
<p>A typical <a id="_idIndexMarker339"/>multi-binding scenario is where you would like to display multiple values in one label. We could, of course, create a property on the ViewModel that concatenates those values, or we could define this as a Multi-binding with <code>StringFormat</code>.</p>
<p>As an example, we want to show the author of the recipe next to the <strong class="bold">Last updated</strong> timestamp that we already have on our page (<em class="italic">Figure 4</em><em class="italic">.9</em>):</p>
<div><div><img alt="Figure 4.9: Showing the author next to the Last updated timestamp" height="131" src="img/B20941_04_09.jpg" width="786"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Showing the author next to the Last updated timestamp</p>
<p>Here’s how it’s done:</p>
<ol>
<li>First, let’s add an <code>Author</code> property to our ViewModel:<pre class="source-code">
public string Author { get; set; } = "Sally Burton";</pre></li> <li>Next, replace the label that shows the <code>LastModified</code> timestamp with the following:<pre class="source-code">
&lt;Label FontSize="8" HorizontalOptions="End"&gt;
    &lt;Label.Text&gt;
        <strong class="bold">&lt;MultiBinding StringFormat="Last updated:</strong>
<strong class="bold">          {0:D} | {1}"&gt;</strong>
<strong class="bold">            &lt;Binding Path="LastUpdated" /&gt;</strong>
<strong class="bold">            &lt;Binding Path="Author" /&gt;</strong>
<strong class="bold">        &lt;/MultiBinding&gt;</strong>
    &lt;/Label.Text&gt;
&lt;/Label&gt;</pre><p class="list-inset">The <code>MultiBinding</code> class allows us to set multiple bindings. The <code>StringFormat</code> property of <code>MultiBinding</code> allows us to construct a single string value from multiple bindings. This operates much like the <code>string.Format</code> method, utilizing different placeholders (<code>{0}</code>, <code>{1}</code>, <code>{2}</code>, and so on) that<a id="_idIndexMarker340"/> correspond to each binding. This makes it easier to construct complex string values from multiple data sources.</p></li> </ol>
<p class="callout-heading">Binding properties</p>
<p class="callout">What you define as <code>Binding</code> inside <code>MultiBinding</code> is the same thing as <code>Binding Markup Extension</code>, which we used in our data bindings previously. It has properties such as <code>Converter</code>, <code>ConverterParameter</code>, <code>StringFormat</code>, <code>TargetNullValue</code>, <code>FallbackValue</code>, and others that can be individually configured for each <code>Binding</code> within <code>MultiBinding</code>, allowing for fine-grained control over each component of <code>MultiBinding</code>.</p>
<p>Multi-binding goes beyond just concatenating strings in a specific format. Let’s have a look at the <code>Converter</code> property of <code>MultiBinding</code>.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>IMultiValueConverter</h2>
<p>The <code>MultiBinding</code> class <a id="_idIndexMarker341"/>has a property called <code>Converter</code> that’s <a id="_idIndexMarker342"/>of the <code>Microsoft.Maui.Controls.IMultiValueConverter</code> type. This interface is similar to <code>IValueConverter</code> but with a significant distinction. The <code>Convert</code> method in <code>IMultiValueConverter</code> accepts an array of objects, representing all the individual bound values, rather than a single object as in <code>IValueConverter</code>. Likewise, the <code>ConvertBack</code> method of <code>IMultiValueConverter</code> returns an array of objects, not just one.</p>
<p>Let’s update the <code>RatingIndicator</code> in <code>RecipeDetailView</code>. The colors of the stars should not only depend on the average rating but also the total of reviews. If the recipe has less <a id="_idIndexMarker343"/>than 15 reviews, we’ll show a generic default color. Only when the recipes have more reviews will <a id="_idIndexMarker344"/>we use the color scale we used earlier. To make that work, we’ll use <code>MultiBinding</code> to bind to both <code>AverageRating</code> and <code>TotalReviews</code> from <code>RecipeRatingsSummaryViewModel</code> and <code>IMultiValueConverter</code> to decide the color of the stars:</p>
<ol>
<li>To start with, we need to add an additional property called <code>TotalReviews</code> to our <code>RecipeRatingsSummaryViewModel</code>:<pre class="source-code">
public class RecipeRatingsSummaryiewModel
{
    <strong class="bold">public int TotalReviews { get; } = 15;</strong>
    public double MaxRating { get; } = 4d;
    public double? AverageRating { get; set; } =
      3.6d;}</pre></li> <li>Next, we can create the <code>RatingAndReviewsToColorConverter</code> class, which implements the <code>IMultiValueConverter</code> interface. For that, we need to right-click the <code>Converter</code> folder, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and enter the name of the converter.</li>
<li>Make the class implement <code>IMultiValueConverter</code> and add the following code to the <code>Convert</code> method:<pre class="source-code">
bool isBackground = parameter is string param
    &amp;&amp; param.ToLower() == "background";
var hex = isBackground ? "#F2F2F2" : "#EBEBEB";
if (<strong class="bold">values.Count() == 2</strong>
<strong class="bold">    &amp;&amp; values[0] is int reviewCount</strong>
<strong class="bold">    &amp;&amp; values[1] is double rating</strong>)
{
    if (reviewCount &gt;= 15)
    {
        hex = rating switch
        {
            …
        };
    }
}
return hex is null ? null : Color.FromArgb(hex);</pre><p class="list-inset">In <a id="_idIndexMarker345"/>this <code>Convert</code> method, we have access <a id="_idIndexMarker346"/>to the array of bound values. This allows us to write logic by taking every given value into account. In this scenario, we are expecting the total number of reviews to be the first value and the rating to be the second.</p></li> <li>Now, we can add this converter as a resource to our <code>RecipeDetailPage</code>, just like we did before with other ValueConverters.<pre class="source-code">
&lt;conv:RatingAndReviewsToColorConverter
  x:Key="ratingAndReviewsToColorConverter" /&gt;</pre></li> <li>Finally, we can use <code>RatingAndReviewsToColorConverter</code> in a <code>MultiBinding</code> class on the <code>Label</code> class’s <code>TextColor</code> property:</li>
</ol>
<pre class="source-code">
&lt;Label.TextColor&gt;
    <strong class="bold">&lt;MultiBinding</strong>
<strong class="bold">        Converter="{StaticResource</strong>
<strong class="bold">          ratingAndReviewsToColorConverter}"</strong>
<strong class="bold">        ConverterParameter="background"</strong>
<strong class="bold">        TargetNullValue="{x:Static Colors.HotPink}"&gt;</strong>
<strong class="bold">        &lt;Binding Path="RatingDetail.TotalReviews" /&gt;</strong>
<strong class="bold">        &lt;Binding Path="RatingDetail.AverageRating" /&gt;</strong>
<strong class="bold">    &lt;/MultiBinding&gt;</strong>
&lt;/Label.TextColor&gt;</pre> <p><code>IMultiValueConverter</code>, in conjunction with <code>MultiBinding</code>, offers a dynamic and flexible <a id="_idIndexMarker347"/>approach to dealing with complex<a id="_idIndexMarker348"/> binding scenarios. By accepting an array of inputs and processing them into a singular output, it allows us to handle multi-source dependencies in our UI.</p>
<p>The last thing we need to look into in the context of data binding is compiled bindings. This feature appears to be a little less known, despite it having a lot of advantages.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Compiled bindings</h1>
<p>Compiled bindings<a id="_idIndexMarker349"/> are a more performant way of creating bindings and they are verified at compile-time instead of at runtime. Typically, the data binding engine uses reflection to get or set property values on the objects being bound. This approach is flexible and powerful because it allows the binding engine to interact with any object, regardless of its type. However, it also has some performance implications because reflection is slower than direct property access, and it can lead to errors that are only detectable at runtime if a property name is misspelled or if the property doesn’t exist. In contrast, compiled bindings are checked at compile time, which means they can catch errors before the app is even run. Furthermore, because the bindings are compiled into the app, the runtime performance is improved as there’s no need for the binding resolution process that takes place with traditional data binding.</p>
<p>Enabling compiled bindings is pretty simple: with the <code>x:DataType</code> attribute, we can specify the type of the object that the XAML element and its children will bind to. So, basically, on our <code>RecipeDetailPage</code>, we could add the following:</p>
<pre class="source-code">
&lt;ContentPage
    x:Class="Recipes.Mobile.RecipeDetailPage"
    …
    xmlns:vms="clr-namespace:Recipes.Client.Core
      .ViewModels;assembly=Recipes.Client.Core"
    <strong class="bold">x:DataType="vms:RecipeDetailViewModel"</strong>
    Title="RecipeDetailPage"&gt;</pre> <p>With<a id="_idIndexMarker350"/> this, we indicate that the type of <code>BindingContext</code> will be <code>Recipes.Client.Core.ViewModels.RecipeDetailViewModel</code>, enabling the XAML compiler to validate bindings at compile time.</p>
<p>However, there is a caveat that will prevent us from compiling and running the application from the bat. In our existing XAML code, we’ve explicitly set <code>BindingContext</code> of <code>HorizontalStackLayout</code> to the <code>IngredientsList</code> property. This confuses the XAML compiler as it assumes elements inside <code>HorizontalStackLayout</code> are still bound to <code>RecipeDetailViewModel</code>, which isn’t the case. This misunderstanding results in an error message in Visual Studio (<em class="italic">Figure 4</em><em class="italic">.10</em>). This error message is evidence that, by adding the <code>x:DataType</code> attribute, bindings are now validated and compiled:</p>
<div><div><img alt="Figure 4.10: Binding error" height="46" src="img/B20941_04_10.jpg" width="1344"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Binding error</p>
<p>Sadly, fixing this error might not be as straightforward as you might think: it’s not only adding setting the <code>x:DataType</code> attribute on <code>VerticalStackLayout</code> to <code>IngredientsListViewModel</code> – the binding itself also needs to be updated:</p>
<pre class="source-code">
&lt;HorizontalStackLayout
  <strong class="bold">x:DataType="vms:IngredientsListViewModel"</strong>
    BindingContext="{Binding IngredientsList,
      <strong class="bold">Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">        vms:RecipeDetailViewModel}}</strong>}"&gt;</pre> <p>With these adjustments in place, we can build and run our app as before. But now, our app benefits from the performance improvements of compiled bindings. Need more proof that bindings are now compiled? Try misspelling the name of a bound property in a binding statement. As shown in <em class="italic">Figure 4</em><em class="italic">.11</em>, Visual Studio will promptly alert you about the nonexistent property:</p>
<div><div><img alt="Figure 4.11: Property not found on the specified type" height="207" src="img/B20941_04_11.jpg" width="1168"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: Property not found on the specified type</p>
<p>Compiled bindings <a id="_idIndexMarker351"/>give you design-time checks and will even give you IntelliSense when writing binding statements. But most importantly, they also lead to faster page load times and better app performance overall.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Summary</h1>
<p>Data binding is a powerful concept in XAML that makes it easier to separate our view logic from our business logic. It’s a huge enabler for doing MVVM in .NET MAUI. It is a complex subject and it can be challenging to fully master every aspect of it. It involves understanding a variety of concepts and techniques, from simple data bindings to multi-bindings and converters, and from element and relative bindings to high-performance compiled bindings.</p>
<p>However, don’t be overwhelmed. Like any complex subject, understanding data binding comes with time and practice. The more you work with it, the more comfortable you’ll become, and many aspects of it will eventually become second nature.</p>
<p>Remember, the ultimate objective is to efficiently apply the MVVM pattern. In this context, data binding plays a crucial role in connecting your ViewModel’s data and business logic with the UI. The knowledge you’ve gathered in this chapter has brought you one step closer to that goal.</p>
<p>In the next chapter, we’ll be looking at community toolkits that can facilitate implementing the MVVM pattern in .NET MAUI.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">Multi-binding</em>: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/multibinding">https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/multibinding</a></li>
<li><em class="italic">Relative </em><em class="italic">bindings</em>: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings">https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings</a></li>
<li><em class="italic">Compiled </em><em class="italic">bindings</em>: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings">https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings</a></li>
</ul>
</div>
</div></body></html>