<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>18 Request-EndPoint-Response (REPR) and Minimal APIs</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="19">18 Request-EndPoint-Response (REPR) and Minimal APIs</h1>

<h2 data-number="19.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file120.png" style="width:10em"/></p>
<p>This chapter introduces the <strong>Request-EndPoint-Response (REPR)</strong> pattern, which builds on top of Vertical Slice Architecture and CQS. We continue to simplify our codebase to make it even more readable, maintainable, and less abstract, yet still testable.</p>
<blockquote>
<p>We pronounce REPR like “reaper”, which sounds way better than “rer” or “reper”. I must credit Steve "ardalis" Smith for this outstanding pattern name. I left a link to his article in the <em>Further reading</em> section.</p>
</blockquote>
<p>We leveraged this pattern already, possibly without you knowing about its name. Now it is time to formally introduce it, then assemble a technology stack to make it scalable for a real-world application.We build that solution, then improve it during the chapter to make it better by exploring manual techniques, existing tools, and open-source libraries. The result is not perfect, but we are not done improving this new e-commerce-inspired solution.</p>
<blockquote>
<p>The key to this approach is learning to think about architecture and improve your design skills, so you have the tools to overcome the unique challenges the real world will throw at you!</p>
</blockquote>
<p>In this chapter, we cover the following topics:</p>
<ul>
<li>Request-EndPoint-Response (REPR) pattern</li>
<li>Project – REPR—A slice of the real-world</li>
</ul>
<p>Let's explore the pattern before jumping into a more hands-on example.</p>


<h2 data-number="19.2">Request-EndPoint-Response (REPR) pattern</h2>
<p>The Request-EndPoint-Response (REPR) pattern offers a simple approach similar to what we explored in Vertical Slice Architecture which deviates from the traditional Model-View-Controller (MVC) pattern. As we explored in the MVC Chapter, REST APIs don't have views, so we have to distort the concept to make it work. REPR is more appropriate than MVC for building REST APIs in the context of HTTP since each URL is a way to describe how to reach an endpoint (execute an operation), not a controller.</p>

<h3 data-number="19.2.1">Goal</h3>
<p>REPR aims to align our REST APIs to HTTP and treat the inherent request-response concept being the web as a first-class citizen in our application design.On top of this, the REPR pattern using Minimal APIs is well-aligned with Vertical Slice Architecture and facilitates building feature-oriented software instead of layer-heavy applications.</p>


<h3 data-number="19.2.2">Design</h3>
<p>REPR has three components:</p>
<ul>
<li>A request that contains the required information for the endpoint to do its work and plays the role of an input DTO.</li>
<li>An endpoint handler containing the business logic to execute, which is the central piece of this pattern.</li>
<li>A response that the endpoint returns to the client and plays the role of an output DTO.</li>
</ul>
<p>You can treat each request as a <em>Query</em> or a <em>Command</em> as we explore in the CQS and Vertical Slice Architecture chapters.Here's a diagram that represents this concept:</p>
<figure>
<img alt="Figure 18.1: a diagram representing the logical flow and the REPR pattern." src="img/file121.png"/><figcaption aria-hidden="true">Figure 18.1: a diagram representing the logical flow and the REPR pattern.</figcaption>
</figure>
<p>The preceding diagram should sound familiar since it resembles what we explored in the Vertical Slice Architecture. However, instead of Request-Handler-Result, we use Request-Endpoint-Response (a.k.a. REPR).Bottom line, a request can be a Query or a Command, then it hits the endpoint that executes the logic and finally returns a response.</p>
<blockquote>
<p>The server returns an HTTP response even when the response’s body is empty.</p>
</blockquote>
<p>Let’s explore an example using Minimal API.</p>


<h3 data-number="19.2.3">Project – SimpleEndpoint</h3>
<p>The SimpleEndpoint project showcases a few simple features and patterns to organize our REPR features without dependencies on external libraries.</p>

<h4 data-number="19.2.3.1">Feature: ShuffleText</h4>
<p>The first feature gets a string as input, shuffles its content, and returns it:</p>
<div><pre><code>namespace SimpleEndpoint;
public class ShuffleText
{
    public record class Request(string Text);
    public record class Response(string Text);
    public class Endpoint
    {
        public Response Handle(Request request)
        {
            var chars = request.Text.ToArray();
            Random.Shared.Shuffle(chars);
            return new Response(new string(chars));
        }
    }
}</code></pre>
</div>
<p>The preceding code leverages the <code>Random</code> API and shuffles the <code>request.Text</code> property then returns the results wrapped in a <code>Response</code> object.Before executing our feature, we must create a minimal API map and register our handler with the container. Here’s the Program.cs class that achieves this:</p>
<div><pre><code>using SimpleEndpoint;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;ShuffleText.Endpoint&gt;();
var app = builder.Build();
app.MapGet(
    "/shuffle-text/{text}",
    ([AsParameters] ShuffleText.Request query, ShuffleText.Endpoint endpoint)
        =&gt; endpoint.Handle(query)
);
app.Run();</code></pre>
</div>
<p>The preceding code registers the <code>ShuffleText.Endpoint</code> as a singleton so we can inject it in the delegate. The delegate leverages the <code>[AsParameters]</code> attribute to bind the route parameter to the <code>ShuffleText.Request</code> property. Finally, the logic is straightforward; the endpoint delegate sends the request to the injected endpoint handler and returns the result, which ASP.NET Core serializes to JSON.When we send the following HTTP request:</p>
<div><pre><code>GET https://localhost:7289/shuffle-text/I%20love%20ASP.NET%20Core</code></pre>
</div>
<p>We receive some gibberish results similar to the following:</p>
<div><pre><code>{
  "text": "eo .e vNrCAT PSElIo"
}</code></pre>
</div>
<p>This pattern is close to the simplest we can get out of the box. Next, we encapsulate the endpoint itself.</p>


<h4 data-number="19.2.3.2">Feature: RandomNumber</h4>
<p>This feature generates a number of random numbers between a minimum and a maximum.The first pattern divided the code between the <code>Program.cs</code> file and the feature itself. In this pattern, we encapsulate the endpoint delegate into the feature (same file in this case):</p>
<div><pre><code>namespace SimpleEndpoint;
public class RandomNumber
{
    public record class Request(int Amount, int Min, int Max);
    public record class Response(IEnumerable&lt;int&gt; Numbers);
    public class Handler
    {
        public Response Handle(Request request)
        {
            var result = new int[request.Amount];
            for (var i = 0; i &lt; request.Amount; i++)
            {
                result[i] = Random.Shared.Next(request.Min, request.Max);
            }
            return new Response(result);
        }
    }
    public static Response Endpoint([AsParameters] Request query, Handler handler)
        =&gt; handler.Handle(query);
}</code></pre>
</div>
<p>The preceding code is very similar to the first feature. However, the delegate we named <code>Endpoint</code> is now part of the feature class (highlighted code). The class that contains the logic is now called <code>Handler</code> instead of <code>Endpoint</code>. This change makes the full feature live closer together.Nonetheless, we still need to register the dependency with the container and map the endpoint to our delegate like this in the <code>Program.cs</code> file:</p>
<div><pre><code>builder.Services.AddSingleton&lt;RandomNumber.Handler&gt;();
// ...
app.MapGet(
    "/random-number/{Amount}/{Min}/{Max}", 
    RandomNumber.Endpoint
);</code></pre>
</div>
<p>The preceding code is routing the request to the <code>RandomNumber.Endpoint</code> method.When we send the following HTTP request:</p>
<div><pre><code>https://localhost:7289/random-number/5/0/100</code></pre>
</div>
<p>We receive a result similar to the following:</p>
<div><pre><code>{
  "numbers": [
    60,
    27,
    78,
    63,
    87
  ]
}</code></pre>
</div>
<p>We moved more of our feature’s code together; however, our code is still divided into two files. Let’s explore a way to fix this next.</p>


<h4 data-number="19.2.3.3">Feature: UpperCase</h4>
<p>This feature transforms the input text to uppercase and returns the result.Our objective is to centralize as much of the code as possible in the <code>UpperCase</code> feature class so we control it from a single place. To achieve this, we create the following extension methods (highlighted):</p>
<div><pre><code>namespace SimpleEndpoint;
public static class UpperCase
{
    public record class Request(string Text);
    public record class Response(string Text);
    public class Handler
    {
        public Response Handle(Request request)
        {
            return new Response(request.Text.ToUpper());
        }
    }
    public static IServiceCollection AddUpperCase(this IServiceCollection services)
    {
        return services.AddSingleton&lt;Handler&gt;();
    }
    public static IEndpointRouteBuilder MapUpperCase(this IEndpointRouteBuilder endpoints)
    {
        endpoints.MapGet(
            "/upper-case/{Text}",
            ([AsParameters] Request query, Handler handler)
                =&gt; handler.Handle(query)
        );
        return endpoints;
    }
}</code></pre>
</div>
<p>In the preceding code, we changed the following:</p>
<ul>
<li>The <code>UpperCase</code> class is static to allow us to create extension methods. Turning the <code>UpperCase</code> class into a static class does not hinder our maintainability because we use it as an organizer and do not instantiate it.</li>
<li>We added the <code>AddUpperCase</code> method that registers the dependencies with the container.</li>
<li>We added the <code>MapUpperCase</code> method that creates the endpoint itself.</li>
</ul>
<p>In the Program.cs file, we can now register our feature like this:</p>
<div><pre><code>builder.Services.AddUpperCase();
// ...
app.MapUpperCase();</code></pre>
</div>
<p>The preceding code calls our extension methods, which move all the related code into the <code>UpperCase</code> class but its connection with ASP.NET Core.</p>
<blockquote>
<p>I find this approach elegant and very clean for a no-dependency project. Of course, we could design this in a million different ways, use an existing library to help us, scan the assembly and auto-register our features, and more.</p>
<blockquote>
<p>You can use this pattern to build a real-world application. I’d suggest creating an <code>AddFeatures</code> and a <code>MapFeatures</code> extension method that register all the features instead of cluttering the <code>Program.cs</code> file, but besides a few final organization touch, this is a robust enough pattern. We explore more of this in the next project.</p>
</blockquote>
</blockquote>
<p>When we send the following HTTP request:</p>
<div><pre><code>GET https://localhost:7289/upper-case/I%20love%20ASP.NET%20Core</code></pre>
</div>
<p>We receive the following response:</p>
<div><pre><code>{
  "text": "I LOVE ASP.NET CORE"
}</code></pre>
</div>
<p>Now that we explored REPR and how to encapsulate our REPR features in several ways, we are almost ready to explore a larger project.</p>



<h3 data-number="19.2.4">Conclusion</h3>
<p>Creating a feature-based design using Minimal APIs, the REPR pattern, and no external dependencies is possible and simple. We organized our project in different ways. Each feature comprises a request, a response, and a handler attached to an endpoint.</p>
<blockquote>
<p>We can combine the handler and the endpoint to make it a three-component pattern. What I like about having a distinct handler is that we can reuse the handler in a non-HTTP context; say, we could create a CLI tool in front of the application and reuse the same logic. It all depends on what we are building.</p>
</blockquote>
<p>Let’s see how the REPR pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: Each piece has a single responsibility, and all pieces are centralized under a feature for ease of navigation, making this pattern a perfect SRP ally.</li>
<li><strong>O</strong>: Using an approach similar to what we did with the <code>UpperCase</code> feature, we can change the feature’s behavior without affecting the rest of the codebase.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: The REPR pattern divides a feature into three smaller interfaces: the request, the endpoint, and the response.</li>
<li><strong>D</strong>: N/A</li>
</ul>
<p>Now that we familiarized ourselves with the REPR pattern, it is time to explore a larger project, including exception handling and grey-box testing.</p>



<h2 data-number="19.3">Project – REPR—A slice of the real-world</h2>
<p><strong>Context</strong>: this project slightly differs from the previous ones about products and stocks. We remove the inventory from the product, add a unit price, and create a barebone shopping basket as a foundation for an e-commerce application. The inventory management became so complex that we had to extract and handle it separately (not included here).By using the REPR pattern, Minimal APIs, and what we learned with Vertical Slice Architecture, we analyzed that the application contains two major areas:</p>
<ul>
<li>A product catalog</li>
<li>A shopping cart</li>
</ul>
<p>For this first iteration, we kept the management of the products away from the application, supporting only the following features:</p>
<ul>
<li>Listing all products</li>
<li>Fetching the details of a product</li>
</ul>
<p>As for the shopping cart, we kept it to a minimum. The basket only persists the <code>Id</code> of the products in the cart and its quantity. The basket does not support any more advanced use cases. Here are the operations it supports:</p>
<ul>
<li>Add an item to the cart</li>
<li>Fetch the items that are in the cart</li>
<li>Remove an item from the cart</li>
<li>Update the quantity of an item in the cart</li>
</ul>
<p>For now, the shopping cart is not aware of the product catalog.</p>
<blockquote>
<p>We improve the application in <em>Chapter 19</em>, <em>Introduction to Microservices Architecture</em>, and <em>Chapter 20</em>, <em>Modular Monolith</em>.</p>
</blockquote>
<p>Let’s assemble the stack we’ll build upon next.</p>

<h3 data-number="19.3.1">Assembling our stack</h3>
<p>I want to keep the project as barebone as possible, using Minimal APIs, yet, we don’t have to struggle with manually implementing every single concern ourselves. Here are the tools we will use to build this project:</p>
<ul>
<li><em>ASP.NET Core Minimal API</em> as our backbone.</li>
<li><em>FluentValidation</em> as our validation framework.</li>
<li><em>FluentValidation.AspNetCore.Http</em> connects FluentValidation into Minimal API.</li>
<li><em>Mapperly</em> is our mapping framework.</li>
<li><em>ExceptionMapper</em> helps us handle exceptions globally, shifting our pattern to error management.</li>
<li><em>EF Core</em> (InMemory) as our ORM.</li>
</ul>
<p>From a terminal window, we can use the CLI to install the packages:</p>
<div><pre><code>dotnet add package FluentValidation.AspNetCore
dotnet add package ForEvolve.ExceptionMapper
dotnet add package ForEvolve.FluentValidation.AspNetCore.Http
dotnet add package Microsoft.EntityFrameworkCore.InMemory
dotnet add package Riok.Mapperly</code></pre>
</div>
<p>We know most of those pieces and will dig deeper into the new ones in time. Meanwhile, let’s explore the structure of the project.</p>


<h3 data-number="19.3.2">Dissecting the code structure</h3>
<p>The directory structure is very similar to what we explored in Vertical Slice Architecture. The root of the project contains the <code>Program.cs</code> file and a <code>Features</code> directory that holds the features or slices. The following diagram represents the features:</p>
<figure>
<img alt="Figure 18.2: The project's directory structure that represents the features' hierarchical relationships." src="img/file122.png"/><figcaption aria-hidden="true">Figure 18.2: The project's directory structure that represents the features' hierarchical relationships.</figcaption>
</figure>
<p>The features inside each area share a cohesive bond and some pieces of code (coupling), while the two areas are entirely disconnected (loosely coupled).The <code>Program.cs</code> file is very light and only bootstraps the application:</p>
<div><pre><code>using Web.Features;
var builder = WebApplication.CreateBuilder(args);
builder.AddFeatures();
var app = builder.Build();
app.MapFeatures();
await app.SeedFeaturesAsync();
app.Run();</code></pre>
</div>
<p>The highlighted lines are extension methods defined in the <code>Features</code> class (located under the <code>Features</code> folder), which cascades the responsibility of registering the dependencies with the container, mapping the endpoints, and seeding the database to each area. Here’s the skeleton of the class:</p>
<div><pre><code>using FluentValidation;
using FluentValidation.AspNetCore;
using System.Reflection;
namespace Web.Features;
public static class Features
{
    public static IServiceCollection AddFeatures(
        this WebApplicationBuilder builder){}
    public static IEndpointRouteBuilder MapFeatures(
        this IEndpointRouteBuilder endpoints){}
    public static async Task SeedFeaturesAsync(
        this WebApplication app){}
}</code></pre>
</div>
<p>Let’s now explore the <code>AddFeatures</code> method:</p>
<div><pre><code>public static IServiceCollection AddFeatures(this WebApplicationBuilder builder)
{
    // Register fluent validation
    builder.AddFluentValidationEndpointFilter();
    return builder.Services
        .AddFluentValidationAutoValidation()
        .AddValidatorsFromAssembly(Assembly.GetExecutingAssembly())
        // Add features
        .AddProductsFeature()
        .AddBasketsFeature()
    ;
}</code></pre>
</div>
<p>The <code>AddFeatures</code> method registers FluentValidation and the Minimal API filters to validate our endpoints (the highlighted line). Each slice defines its own configuration methods, like the <code>AddProductsFeature</code> and <code>AddBasketsFeature</code> methods. We will come back to those. Meanwhile, let’s explore the <code>MapFeatures</code> method:</p>
<div><pre><code>public static IEndpointRouteBuilder MapFeatures(this IEndpointRouteBuilder endpoints)
{
    var group = endpoints
        .MapGroup("/")
        .AddFluentValidationFilter();
    ;
    group
        .MapProductsFeature()
        .MapBasketsFeature()
    ;
    return endpoints;
}</code></pre>
</div>
<p>The <code>MapFeatures</code> method creates a root route group, adds the <em>FluentValidation</em> filter to it so the validation applies to all endpoints in this group, then it calls the <code>MapProductsFeature</code> and <code>MapBasketsFeature</code> methods that map their features into the group. Finally, the <code>SeedFeaturesAsync</code> method seeds the database using the feature extension methods:</p>
<div><pre><code>public static async Task SeedFeaturesAsync(this WebApplication app)
{
    using var scope = app.Services.CreateScope();
    await scope.SeedProductsAsync();
    await scope.SeedBasketAsync();
}</code></pre>
</div>
<p>With those building blocks in place, the program starts, adds features, and registers endpoints. Afterward, each category of features—products and baskets—cascades the calls, letting each feature registers its pieces. Next are a few diagrams representing the call hierarchy from the <code>Program.cs</code> file. Let’s start with the <code>AddFeatures</code> method:</p>
<figure>
<img alt="Figure 18.3: the call hierarchy of the AddFeatures method." src="img/file123.png"/><figcaption aria-hidden="true">Figure 18.3: the call hierarchy of the AddFeatures method.</figcaption>
</figure>
<p>The preceding diagram showcases the division of responsibilities where each piece aggregates its sub-parts or registers its dependencies.A similar flow happens from the <code>MapFeatures</code> method:</p>
<figure>
<img alt="Figure 18.4: the call hierarchy of the MapFeatures method." src="img/file124.png"/><figcaption aria-hidden="true">Figure 18.4: the call hierarchy of the MapFeatures method.</figcaption>
</figure>
<p>Finally, the <code>SeedFeaturesAsync</code> method utilizes a similar approach to seed the in-memory database:</p>
<figure>
<img alt="Figure 18.5: the call hierarchy of the SeedFeaturesAsync method." src="img/file125.png"/><figcaption aria-hidden="true">Figure 18.5: the call hierarchy of the SeedFeaturesAsync method.</figcaption>
</figure>
<p>These diagrams showcase the entry point (<code>Program.cs</code>) sending a request to each feature so that every piece handles itself.</p>
<blockquote>
<p>In a real project using an actual database, you do not want to seed the database this way. In this case, it works because each time we start the project, the database is empty because it only lives for the time the program runs—it lives in memory. There are numerous strategies to seed your data sources in real life, from executing a SQL script to deploying a Docker container that runs only once.</p>
</blockquote>
<p>Now that we explored the high-level view of the program, it is time to dig into a feature and explore how it works.</p>


<h3 data-number="19.3.3">Exploring the shopping basket</h3>
<p>This section explores the <code>AddItem</code> and <code>FetchItems</code> features of the shopping basket slice. The slice is completely decoupled from the <code>Products</code> slice, and does not know the products themselves. All it knows is how to accumulate product identifiers and quantities and associate those with a customer. We address this problem later.</p>
<blockquote>
<p>There are no customer features and no authentication to keep the project simple.</p>
</blockquote>
<p>The code of the <code>Features/Baskets/Baskets.cs</code> file powers the shopping basket features. Here’s the skeleton:</p>
<div><pre><code>using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
namespace Web.Features;
public static partial class Baskets
{
    // Baskets.cs
    public record class BasketItem(int CustomerId, int ProductId, int Quantity);
    public class BasketContext : DbContext {}
    public static IServiceCollection AddBasketsFeature(this IServiceCollection services) {}
    public static IEndpointRouteBuilder MapBasketsFeature(this IEndpointRouteBuilder endpoints) {}
    public static Task SeedBasketsAsync(this IServiceScope scope) {}
    // Baskets.AddItem.cs
    public partial class AddItem {}
    public static IServiceCollection AddAddItem(this IServiceCollection services) {}
    public static IEndpointRouteBuilder MapAddItem(this IEndpointRouteBuilder endpoints) {}
    // Baskets.FetchItems.cs
    public partial class FetchItems {}
    public static IServiceCollection AddFetchItems(this IServiceCollection services) {}
    public static IEndpointRouteBuilder MapFetchItems(this IEndpointRouteBuilder endpoints) {}
    // Baskets.RemoveItem.cs
    public partial class RemoveItem {}
    public static IServiceCollection AddRemoveItem(this IServiceCollection services) {}
    public static IEndpointRouteBuilder MapRemoveItem(this IEndpointRouteBuilder endpoints) {}
    // Baskets.UpdateQuantity.cs
    public partial class UpdateQuantity {}
    public static IServiceCollection AddUpdateQuantity(this IServiceCollection services) {}
    public static IEndpointRouteBuilder MapUpdateQuantity(this IEndpointRouteBuilder endpoints) {}
}</code></pre>
</div>
<p>The highlighted code of the preceding block contains the <code>BasketItem</code> data model and the <code>BasketContext</code> EF Core <code>DbContext</code>, which all basket features share. It also includes the three methods that register and make the features work (<code>AddBasketsFeature</code>, <code>MapBasketsFeature</code>, and <code>SeedBasketsAsync</code>). The other methods and classes are divided into several files. We explore a few of them in the chapter.</p>
<blockquote>
<p>We used the <code>partial</code> modifier to split the nested classes into multiple files. We made the class <code>static</code> to create extension methods in it.</p>
</blockquote>
<p>The <code>BasketItem</code> class allows us to persist a simple shopping cart to the database:</p>
<div><pre><code>public record class BasketItem(
    int CustomerId, 
    int ProductId, 
    int Quantity
);</code></pre>
</div>
<p>The <code>BasketContext</code> class configures the primary key of the <code>BasketItem</code> class and exposes the <code>Items</code> property (highlighted):</p>
<div><pre><code>public class BasketContext : DbContext
{
    public BasketContext(DbContextOptions&lt;BasketContext&gt; options)
        : base(options) { }
    public DbSet&lt;BasketItem&gt; Items =&gt; Set&lt;BasketItem&gt;();
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder
            .Entity&lt;BasketItem&gt;()
            .HasKey(x =&gt; new { x.CustomerId, x.ProductId })
        ;
    }
}</code></pre>
</div>
<p>The <code>AddBasketsFeature</code> method registers each feature and the <code>BasketContext</code> with the IoC container:</p>
<div><pre><code>public static IServiceCollection AddBasketsFeature(this IServiceCollection services)
{
    return services
        .AddAddItem()
        .AddFetchItems()
        .AddRemoveItem()
        .AddUpdateQuantity()
        .AddDbContext&lt;BasketContext&gt;(options =&gt; options
            .UseInMemoryDatabase("BasketContextMemoryDB")
            .ConfigureWarnings(builder =&gt; builder.Ignore(InMemoryEventId.TransactionIgnoredWarning))
        )
    ;
}</code></pre>
</div>
<p>Besides the <code>AddDbContext</code> method, the <code>AddBasketsFeature</code> delegates the registration of dependencies to each feature. We explore the highlighted ones shortly. The EF Core code registers the in-memory provider that serves the <code>BasketContext</code>.Next, the <code>MapBasketsFeature</code> method maps the endpoints:</p>
<div><pre><code>public static IEndpointRouteBuilder MapBasketsFeature(this IEndpointRouteBuilder endpoints)
{
    var group = endpoints
        .MapGroup(nameof(Baskets).ToLower())
        .WithTags(nameof(Baskets))
    ;
    group
        .MapFetchItems()
        .MapAddItem()
        .MapUpdateQuantity()
        .MapRemoveItem()
    ;
    return endpoints;
}</code></pre>
</div>
<p>The preceding code creates a group, naming it <code>baskets</code>, making its endpoints accessible using the <code>/baskets</code> URL prefix. We also tag the group “Baskets” to leverage an OpenAPI generator in the future. Then the method uses a similar pattern to the <code>AddBasketsFeature</code> method and delegates the endpoint mapping to the features.</p>
<blockquote>
<p>Have you noticed that the method returns the <code>endpoints</code> object directly? This allows us to chain the feature mapping. In another scenario, we could return the <code>group</code> object (<code>RouteGroupBuilder</code> instance) to let the caller further configure the group. What we build is always about the needs and objectives.</p>
</blockquote>
<p>Finally, the <code>SeedBasketsAsync</code> method does nothing; we do not create any shopping cart when starting the program, unlike the <code>Products</code> slice:</p>
<div><pre><code>public static Task SeedBasketsAsync(this IServiceScope scope)
{
    return Task.CompletedTask;
}</code></pre>
</div>
<blockquote>
<p>We could have omitted the preceding method. I left it so we follow a linear pattern between the features. Such a linear pattern makes it easier to understand and learn. It also allows identifying the recurring pieces we could work on to automate the registration process.</p>
</blockquote>
<p>Now that we have covered the shared pieces, let’s add data to our shopping basket.</p>

<h4 data-number="19.3.3.1">AddItem feature</h4>
<p>The role of the <code>AddItem</code> feature is to create a <code>BasketItem</code> object and persist it in the database. To achieve this, we leverage the REPR pattern. Inspired by the preceding few chapters, we name the request <code>Command</code> (CQS pattern), add a mapper object using Mapperly, and leverage FluentValidation to ensure the request is valid. Here’s the skeleton of the <code>AddItem</code> class:</p>
<div><pre><code>using FluentValidation;
using Microsoft.EntityFrameworkCore;
using Riok.Mapperly.Abstractions;
namespace Web.Features;
public partial class Baskets
{
    public partial class AddItem
    {
        public record class Command(
            int CustomerId,
            int ProductId,
            int Quantity
        );
        public record class Response(
            int ProductId,
            int Quantity
        );
        [Mapper]
        public partial class Mapper {}
        public class Validator : AbstractValidator&lt;Command&gt; {}
        public class Handler {}
    }
    public static IServiceCollection AddAddItem(this IServiceCollection services) {}
    public static IEndpointRouteBuilder MapAddItem(this IEndpointRouteBuilder endpoints) {}
}</code></pre>
</div>
<p>The preceding code contains all the necessary pieces of the feature:</p>
<ul>
<li>The request (the <code>Command</code> class).</li>
<li>The response (the <code>Response</code> class).</li>
<li>The endpoint (the <code>MapAddItem</code> method pointing the requests to the <code>Handler</code> class).</li>
<li>A mapper object that has Mapperly generate the mapping code for us.</li>
<li>A validator class that ensures the input we receive is valid.</li>
<li>The <code>AddAddItem</code> method registers its services with the IoC container.</li>
</ul>
<p>Let’s start with the <code>AddAddItem</code> method that registers the feature’s services:</p>
<div><pre><code>public static IServiceCollection AddAddItem(this IServiceCollection services)
{
    return services
        .AddScoped&lt;AddItem.Handler&gt;()
        .AddSingleton&lt;AddItem.Mapper&gt;()
    ;
}</code></pre>
</div>
<p>Then the <code>MapAddItem</code> method routes the appropriate POST requests with a valid <code>Command</code> object in its body to the <code>Handler</code> class:</p>
<div><pre><code>public static IEndpointRouteBuilder MapAddItem(
    this IEndpointRouteBuilder endpoints)
{
    endpoints.MapPost(
        "/",
        async (AddItem.Command command, AddItem.Handler handler, CancellationToken cancellationToken) =&gt;
        {
            var result = await handler.HandleAsync(
                command, 
                cancellationToken
            );
            return TypedResults.Created(
                $"/products/{result.ProductId}", 
                result
            );
        }
    );
    return endpoints;
}</code></pre>
</div>
<p>The <code>Command</code> instance is a copy of the <code>BasketItem</code> class, while the response only returns the <code>ProductId</code> and <code>Quantity</code> properties. The highlighted lines represent the endpoint handing off the <code>Command</code> object to the use case <code>Handler</code> class.</p>
<blockquote>
<p>We could write the <code>Handler</code> code in the delegate, which would make unit testing the delegate very hard.</p>
</blockquote>
<p>The <code>Handler</code> class is the glue of the feature:</p>
<div><pre><code>public class Handler
{
    private readonly BasketContext _db;
    private readonly Mapper _mapper;
    public Handler(BasketContext db, Mapper mapper)
    {
        _db = db ?? throw new ArgumentNullException(nameof(db));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
    }
    public async Task&lt;Response&gt; HandleAsync(Command command, CancellationToken cancellationToken)
    {
        var itemExists = await _db.Items.AnyAsync(
            x =&gt; x.CustomerId == command.CustomerId &amp;&amp; x.ProductId == command.ProductId,
            cancellationToken: cancellationToken
        );
        if (itemExists)
        {
            throw new DuplicateBasketItemException(command.ProductId);
        }
        var item = _mapper.Map(command);
        _db.Add(item);
        await _db.SaveChangesAsync(cancellationToken);
        var result = _mapper.Map(item);
        return result;
    }
}</code></pre>
</div>
<p>The preceding code contains the business logic of the feature by ensuring the item is not already in the basket. If it is, it throws a <code>DuplicateBasketItemException</code>. Otherwise, it saves the item to the database. It then returns a <code>Response</code> object.</p>
<blockquote>
<p>Each customer (<code>CustomerId</code>) can have each product (<code>ProductId</code>) once in its cart (composite primary key), which is why we test for this condition.</p>
</blockquote>
<p>The handler leveraged the <code>Mapper</code> class:</p>
<div><pre><code>[Mapper]
public partial class Mapper
{
    public partial BasketItem Map(Command item);
    public partial Response Map(BasketItem item);
}</code></pre>
</div>
<p>Implicitly, the <code>Command</code> object was validated using the following <code>Validator</code> class:</p>
<div><pre><code>public class Validator : AbstractValidator&lt;Command&gt;
{
    public Validator()
    {
        RuleFor(x =&gt; x.CustomerId).GreaterThan(0);
        RuleFor(x =&gt; x.ProductId).GreaterThan(0);
        RuleFor(x =&gt; x.Quantity).GreaterThan(0);
    }
}</code></pre>
</div>
<blockquote>
<p>As a reminder, in the <code>Features.cs</code> file, we called the <code>AddFluentValidationFilter</code> method on the root route group, letting the <code>FluentValidationEndpointFilter</code> class validate the inputs for us using the <code>Validator</code> class.</p>
</blockquote>
<p>With this in place, we can send the following HTTP request:</p>
<div><pre><code>POST https://localhost:7252/baskets
Content-Type: application/json
{
    "customerId": 1, 
    "productId": 3, 
    "quantity": 10
}</code></pre>
</div>
<p>The endpoint responds with the following:</p>
<div><pre><code>{
  "productId": 3,
  "quantity": 10
}</code></pre>
</div>
<p>And has the following HTTP header:</p>
<div><pre><code>Location: /products/3</code></pre>
</div>
<p>To recap, here’s what happens:</p>
<ol>
<li>ASP.NET Core routes the request to the delegate we registered in the <code>MapAddItem</code> method.</li>
<li>The validation middle runs an <code>AddItem.Validator</code> object against the <code>AddItem.Command</code> sent to the endpoint. The request is valid.</li>
<li>The <code>HandleAsync</code> method of the <code>AddItem.Handler</code> class is executed.</li>
<li>Assuming the item is not already in the customer’s basket, it is added to the database.</li>
<li>The <code>HandleAsync</code> method returns a <code>Response</code> object to the delegate.</li>
<li>The delegate returns a <code>201 Create</code> status code with the <code>Location</code> header set to the URL of the product that got added.</li>
</ol>
<p>As the preceding list depicts, the process is quite simple; a request gets in, the business logic is executed (endpoint), then a response goes out: REPR.</p>
<blockquote>
<p>There are a few more pieces, but they save us the trouble of object mapping and validation. Those pieces are optional; you can conceive your own stack with more or less pieces in it.</p>
</blockquote>
<p>On top of the feature code, we also have a few tests to assess that the business logic remains correct over time. We cover those under the <em>Grey-box testing</em> section. Meanwhile, let’s look at the <code>FetchItems</code> feature.</p>


<h4 data-number="19.3.3.2">FetchItems feature</h4>
<p>Now that we know the pattern, this feature should be faster to cover. It allows a client to retrieve the shopping basket of the specified customer using the following request:</p>
<div><pre><code>public record class Query(int CustomerId);</code></pre>
</div>
<p>The client expects a collection of items in the response:</p>
<div><pre><code>public record class Response(IEnumerable&lt;Item&gt; Items) : IEnumerable&lt;Item&gt;
{
    public IEnumerator&lt;Item&gt; GetEnumerator()
        =&gt; Items.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator()
        =&gt; ((IEnumerable)Items).GetEnumerator();
}
public record class Item(int ProductId, int Quantity);</code></pre>
</div>
<p>Since the client knows about the customer, it does not need the endpoint to return the <code>CustomerId</code> property, which is why the <code>Item</code> class only has two of the <code>BasketItem</code> properties.Here are the <code>Mapper</code> and the <code>Validator</code> classes, which should be self-explanatory at this point:</p>
<div><pre><code>[Mapper]
public partial class Mapper
{
    public partial Response Map(IQueryable&lt;BasketItem&gt; items);
}
public class Validator : AbstractValidator&lt;Query&gt;
{
    public Validator()
    {
        RuleFor(x =&gt; x.CustomerId).GreaterThan(0);
    }
}</code></pre>
</div>
<p>Then, a last piece of plumbing is the <code>AddFetchItems</code> method which registers the feature’s services with the containers:</p>
<div><pre><code>public static IServiceCollection AddFetchItems(this IServiceCollection services)
{
    return services
        .AddScoped&lt;FetchItems.Handler&gt;()
        .AddSingleton&lt;FetchItems.Mapper&gt;()
    ;
}</code></pre>
</div>
<p>Now to the endpoint itself, forwarding the <code>FetchItems.Query</code> object to a <code>FetchItems.Handler</code> instance:</p>
<div><pre><code>public static IEndpointRouteBuilder MapFetchItems(this IEndpointRouteBuilder endpoints)
{
    endpoints.MapGet(
        "/{CustomerId}",
        ([AsParameters] FetchItems.Query query, FetchItems.Handler handler, CancellationToken cancellationToken)
            =&gt; handler.HandleAsync(query, cancellationToken)
    );
    return endpoints;
}</code></pre>
</div>
<p>The preceding code is simpler than the <code>AddItem</code> feature because it serializes the handler’s response directly as a 200 OK status code without transforming it.Finally, the <code>Handler</code> class itself:</p>
<div><pre><code>public class Handler
{
    private readonly BasketContext _db;
    private readonly Mapper _mapper;
    public Handler(BasketContext db, Mapper mapper)
    {
        _db = db ?? throw new ArgumentNullException(nameof(db));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
    }
    public async Task&lt;Response&gt; HandleAsync(Query query, CancellationToken cancellationToken)
    {
        var items = _db.Items.Where(x =&gt; x.CustomerId == query.CustomerId);
        await items.LoadAsync(cancellationToken);
        var result = _mapper.Map(items);
        return result;
    }
}</code></pre>
</div>
<p>The preceding code loads all the items associated with the specified customer from the database and returns them. If there are no items, the client receives an empty array.That’s it; we can now send the following HTTP request and hit the endpoint:</p>
<div><pre><code>GET https://localhost:7252/baskets/1</code></pre>
</div>
<p>Assuming we added an item to the basket, we should receive a response similar to the following:</p>
<div><pre><code>[
  {
    "productId": 3,
    "quantity": 10
  }
]</code></pre>
</div>
<p>We now have a working shopping basket!</p>
<blockquote>
<p>You can explore the other features in the codebase available on GitHub (<a href="https://adpg.link/ikAn">https://adpg.link/ikAn</a>). All features have tests and are functional.</p>
</blockquote>
<p>Next, we look at exception handling.</p>



<h3 data-number="19.3.4">Managing exception handling</h3>
<p>The <code>AddItem</code> feature throws a <code>DuplicateBasketItemException</code> when the product is already in the basket. However, when that happens, the server returns an error that resembles the following (partial output):</p>
<div><pre><code>Web.Features.DuplicateBasketItemException: The product '3' is already in your shopping cart.
   at Web.Features.Baskets.AddItem.Handler.HandleAsync(Command command, CancellationToken cancellationToken) in C18\REPR\Web\Features\Baskets\Baskets.AddItem.cs:line 57
   at Web.Features.Baskets.&lt;&gt;c.&lt;&lt;MapAddItem&gt;b__2_0&gt;d.MoveNext() in C18\REPR\Web\Features\Baskets\Baskets.AddItem.cs:line 82
--- End of stack trace from previous location ---</code></pre>
</div>
<p>That error is ugly and impractical for a client calling the API. To circumvent this, we can add a try-catch somewhere and treat each exception individually, or we can use a middleware to catch the exceptions and normalize their output.Managing exceptions one by one is tedious and error-prone. On the other hand, centralizing exception management and treating them as a cross-cutting concern transforms the tedious mechanism into a new tool to leverage. Moreover, it ensures that the API always returns the errors in the same format with no additional effort.Let’s program a basic middleware.</p>

<h4 data-number="19.3.4.1">Creating an exception handler middleware</h4>
<p>A middleware in ASP.NET Core is executed as part of the pipeline and can run before and after the execution of an endpoint.When an exception occurs, the request is re-executed in a parallel pipeline, allowing different middleware to manage the error flow.To create a middleware, we must implement an <code>InvokeAsync</code> method. The easiest way to do this is by implementing the <code>IMiddleware</code> interface. You can add middleware types to the default or exception-handling alternate pipelines.The following code represents a basic exception-handling middleware:</p>
<div><pre><code>using Microsoft.AspNetCore.Diagnostics;
namespace Web;
public class MyExceptionMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var exceptionHandlerPathFeature = context.Features
            .Get&lt;IExceptionHandlerFeature&gt;() ?? throw new NotSupportedException();
        var exception = exceptionHandlerPathFeature.Error;
        await context.Response.WriteAsJsonAsync(new
        {
            Error = exception.Message
        });
        await next(context);
    }
}</code></pre>
</div>
<p>The middleware fetches the <code>IExceptionHandlerFeature</code> to access the error and outputs an object containing the error message (ASP.NET Core manages this feature). If the feature is unavailable, the middleware throws a <code>NotSupportedException</code>, which rethrows the original exception.</p>
<blockquote>
<p>Any type of exception a middleware of the alternate pipeline throws will rethrow the original exception.</p>
</blockquote>
<p>If any, the highlighted code executes the next middleware in the pipeline. These pipelines are like a chain of responsibilities but with a different objective.To register the middleware, we must first add it to the container:</p>
<div><pre><code>builder.Services.AddSingleton&lt;MyExceptionMiddleware&gt;();</code></pre>
</div>
<p>Then, we must register it as part of the exception-handling alternate pipeline:</p>
<div><pre><code>app.UseExceptionHandler(errorApp =&gt;
{
    errorApp.UseMiddleware&lt;MyExceptionMiddleware&gt;();
});</code></pre>
</div>
<blockquote>
<p>We could also register more middleware or create them inline, like this:</p>
</blockquote>
<pre><code>app.UseExceptionHandler(errorApp =&gt;
{
    errorApp.Use(async (context, next) =&gt;
    {
        var exceptionHandlerPathFeature = context.Features
            .Get&lt;IExceptionHandlerFeature&gt;() ?? throw new NotSupportedException();
        var logger = context.RequestServices
            .GetRequiredService&lt;ILoggerFactory&gt;()
            .CreateLogger("ExceptionHandler");
        var exception = exceptionHandlerPathFeature.Error;
        logger.LogWarning(
            "An exception occurred: {message}",
            exception.Message
        );
        await next(context);
    });
    errorApp.UseMiddleware&lt;MyExceptionMiddleware&gt;();
});</code></pre>
<blockquote>
<p>The possibilities are vast.</p>
</blockquote>
<p>Now, if we try to add a duplicated item to the basket, we get a <em>500 Internal Server Error</em> with the following body:</p>
<div><pre><code>{
  "error": "The product \u00273\u0027 is already in your shopping cart."
}</code></pre>
</div>
<p>This response is more elegant than before and easier to handle for the clients. We could also alter the status code in the middleware. However, customizing this middleware would take many pages, so we leverage an existing library instead.</p>


<h4 data-number="19.3.4.2">Exception handling using ExceptionMapper</h4>
<p>The <code>ForEvolve.ExceptionMapper</code> package is an ASP.NET Core middleware that allows us to map exceptions to different status codes. Out-of-the-box, it offers many exception types to get started, handles them, and allows easy mapping between a custom exception and a status code. By default, the library serializes the exceptions to a <code>ProblemDetails</code> object (based on RFC 7807) by leveraging as many ASP.NET Core components as possible, so we can customize parts of the library by customizing ASP.NET Core.To get started, in the <code>Program.cs</code> file, we must add the following lines:</p>
<div><pre><code>// Add the dependencies to the container
builder.AddExceptionMapper();
// Register the middleware
app.UseExceptionMapper();</code></pre>
</div>
<p>Now, if we try to add a duplicated product to the basket, we receive a response with a <em>409 Conflict</em> status code with the following body:</p>
<div><pre><code>{
  "type": "https://tools.ietf.org/html/rfc9110#section-15.5.10",
  "title": "The product \u00273\u0027 is already in your shopping cart.",
  "status": 409,
  "traceId": "00-74bdbaa08064fd97ba1de31802ec6f8f-31ffd9ea8215b706-00",
  "debug": {
    "type": {
      "name": "DuplicateBasketItemException",
      "fullName": "Web.Features.DuplicateBasketItemException"
    },
    "stackTrace": "..."
  }
}</code></pre>
</div>
<p>This output is starting to look like something!</p>
<blockquote>
<p>The <code>debug</code> object (highlighted) only appears in development or as an opt-in option.</p>
</blockquote>
<p>How can the middleware know it’s a 409 Conflict and not a 500 Internal Server Error? Simple! The <code>DuplicateBasketItemException</code> inherits from the <code>ConflictException</code> that comes from the <code>ForEvolve.ExceptionMapper</code> namespace (highlighted):</p>
<div><pre><code>using ForEvolve.ExceptionMapper;
namespace Web.Features;
public class DuplicateBasketItemException : ConflictException
{
    public DuplicateBasketItemException(int productId)
        : base($"The product '{productId}' is already in your shopping cart.")
    {
    }
}</code></pre>
</div>
<p>With this setup, we can leverage exceptions to return errors with different status codes.</p>
<blockquote>
<p>I have used this methodology for many years, and it simplifies the program structure and developers' lives. The idea is to harness the power and simplicity of exceptions.</p>
</blockquote>
<p>For example, we may want to map EF Core errors, <code>DbUpdateException</code> and <code>DbUpdateConcurrencyException</code>, to a <em>409 Conflict</em> as well, so in case we forget to catch a database error, the middleware will do it for us. To achieve this, we can customize the middleware this way:</p>
<div><pre><code>builder.AddExceptionMapper(builder =&gt;
{
    builder
        .Map&lt;DbUpdateException&gt;()
        .ToStatusCode(StatusCodes.Status409Conflict)
    ;
    builder
        .Map&lt;DbUpdateConcurrencyException&gt;()
        .ToStatusCode(StatusCodes.Status409Conflict)
    ;
});</code></pre>
</div>
<p>With that in place, if a client hits an unhandled EF Core exception, the server will respond with something like the following (I omitted the stack trace for brevity reasons):</p>
<div><pre><code>{
  "type": "https://tools.ietf.org/html/rfc9110#section-15.5.10",
  "title": "Exception of type \u0027Microsoft.EntityFrameworkCore.DbUpdateException\u0027 was thrown.",
  "status": 409,
  "traceId": "00-74bdbaa08064fd97ba1de31802ec6f8f-a5ac17f17da8d2db-00",
  "debug": {
    "type": {
      "name": "DbUpdateException",
      "fullName": "Microsoft.EntityFrameworkCore.DbUpdateException"
    },
    "stackTrace": "..."
  },
  "entries": []
}</code></pre>
</div>
<blockquote>
<p>In an actual project, for security reasons, I recommend customizing the error handling further to hide the fact that we are using EF Core. We must give as little information as possible about our systems to malicious actors to keep them as secure and safe as possible. We won’t cover creating custom exception handlers here because it is out of the scope of the chapter.</p>
</blockquote>
<p>As we can see, it is easy to register custom exceptions and associate them with a status code. We can do this with any custom exception or inherit from an existing one to make it work with customization.As of version 3.0.29, <em>ExceptionMapper</em> offers the following custom exception associations:</p>
<table>
<tbody>
<tr class="odd">
<td>Exception Type</td>
<td>Status Code</td>
</tr>
<tr class="even">
<td><code>BadRequestException</code></td>
<td><code>StatusCodes.Status400BadRequest</code></td>
</tr>
<tr class="odd">
<td><code>ConflictException</code></td>
<td><code>StatusCodes.Status409Conflict</code></td>
</tr>
<tr class="even">
<td><code>ForbiddenException</code></td>
<td><code>StatusCodes.Status403Forbidden</code></td>
</tr>
<tr class="odd">
<td><code>GoneException</code></td>
<td><code>StatusCodes.Status410Gone</code></td>
</tr>
<tr class="even">
<td><code>NotFoundException</code></td>
<td><code>StatusCodes.Status404NotFound</code></td>
</tr>
<tr class="odd">
<td><code>ResourceNotFoundException</code></td>
<td><code>StatusCodes.Status404NotFound</code></td>
</tr>
<tr class="even">
<td><code>UnauthorizedException</code></td>
<td><code>StatusCodes.Status401Unauthorized</code></td>
</tr>
<tr class="odd">
<td><code>GatewayTimeoutException</code></td>
<td><code>StatusCodes.Status504GatewayTimeout</code></td>
</tr>
<tr class="even">
<td><code>InternalServerErrorException</code></td>
<td><code>StatusCodes.Status500InternalServerError</code></td>
</tr>
<tr class="odd">
<td><code>ServiceUnavailableException</code></td>
<td><code>StatusCodes.Status503ServiceUnavailable</code></td>
</tr>
</tbody>
</table>
Table 18.1: ExceptionMapper custom exception associations.
<p>You can inherit from those standard exceptions, and the middleware will associate them with the correct status code as we did with the <code>DuplicateBasketItemException</code> class.<em>ExceptionMapper</em> also maps the following .NET exceptions automatically:</p>
<ul>
<li><code>BadHttpRequestException</code> to <code>StatusCodes.Status400BadRequest</code></li>
<li><code>NotImplementedException</code> to <code>StatusCodes.Status501NotImplemented</code></li>
</ul>
<p>In the project, there are three custom exceptions that you can find on GitHub:</p>
<ul>
<li><code>BasketItemNotFoundException</code> that inherits from <code>NotFoundException</code></li>
<li><code>DuplicateBasketItemException</code> that inherits from <code>ConflictException</code></li>
<li><code>ProductNotFoundException</code> that inherits from <code>NotFoundException</code></li>
</ul>
<p>Next, we explore this way of thinking about error propagation a little more.</p>


<h4 data-number="19.3.4.3">Leveraging exceptions to propagate errors</h4>
<p>With the middleware of <em>ExceptionMapper</em> in place, we can treat exceptions as a simple tool to propagate errors to the clients. We can throw an existing exception, like a <code>NotFoundException</code>, or create a custom reusable one with a more precise preconfigured error message.When we want the server to return a specific error, all we must do is:</p>
<ol>
<li>Create a new exception type.</li>
<li>Inherit from an existing type from <em>ExceptionMapper</em> or register our custom exception with the middleware.</li>
<li>Throw our custom exception anywhere in the REPR flow.</li>
<li>Let the middleware do its job.</li>
</ol>
<p>Here’s a simplified representation of this flow, using the <code>AddItem</code> endpoint as an example:</p>
<figure>
<img alt="Figure 18.6: a simplified view of an exception flow using ExceptionMapper." src="img/file126.png"/><figcaption aria-hidden="true">Figure 18.6: a simplified view of an exception flow using ExceptionMapper.</figcaption>
</figure>
<p>With this in place, we have a simple way to return errors to the clients from anywhere in the REPR flow. Moreover, our errors are consistently formatted the same way.</p>
<blockquote>
<p>The exception handling pattern and the <em>ExceptionMapper</em> library also work with MVC and allow customizing the error formatting process.</p>
</blockquote>
<p>Next, let’s explore a few test cases.</p>



<h3 data-number="19.3.5">Grey-box testing</h3>
<p>Using Vertical Slice Architecture or REPR makes writing grey-box tests very convenient. The test project mainly comprises integration tests that use the grey-box philosophy. Since we know the application under test's inner workings, we can manipulate the data from the EF Core <code>DbContext</code> objects, which allows us to write almost end-to-end tests very quickly. The confidence level we get from those tests is very high because they test the whole stack, including HTTP, not just some scattered pieces, leading to a very high level of code coverage per test case. Of course, integration tests are slower, yet not that slow. It is up to you to create the right balance of unit and integration tests. In this case, I focused on grey-box integration testing, which led to 13 tests covering 97.2% of the lines and 63.1% of the branches. The guard clauses represent most of the branches that we do not test. We could write a few unit tests to boost the numbers if we’d like.</p>
<blockquote>
<p>We explored white-, grey- and black-box testing in <em>Chapter 2</em>, <em>Automated Testing</em>.</p>
</blockquote>
<p>Let’s start by exploring the AddItem tests.</p>

<h4 data-number="19.3.5.1">AddItemTest</h4>
<p>The <code>AddItem</code> feature is the first use case we explored. We need three tests to cover all scenarios but the <code>Handler</code> class guard clauses.</p>

<h5 data-number="19.3.5.1.1">First test method</h5>
<p>The following grey-box integration test ensures an HTTP POST request adds the item to the database:</p>
<div><pre><code>[Fact]
public async Task Should_add_the_new_item_to_the_basket()
{
    // Arrange
    await using var application = new C18WebApplication();
    var client = application.CreateClient();
    // Act
    var response = await client.PostAsJsonAsync(
        "/baskets",
        new AddItem.Command(4, 1, 22)
    );
    // Assert the response
    Assert.NotNull(response);
    Assert.True(response.IsSuccessStatusCode);
    var result = await response.Content
        .ReadFromJsonAsync&lt;AddItem.Response&gt;();
    Assert.NotNull(result);
    Assert.Equal(1, result.ProductId);
    Assert.Equal(22, result.Quantity);
    // Assert the database state
    using var seedScope = application.Services.CreateScope();
    var db = seedScope.ServiceProvider
        .GetRequiredService&lt;BasketContext&gt;();
    var dbItem = db.Items.FirstOrDefault(x =&gt; x.CustomerId == 4 &amp;&amp; x.ProductId == 1);
    Assert.NotNull(dbItem);
    Assert.Equal(22, dbItem.Quantity);
}</code></pre>
</div>
<p>The <em>Arrange</em> block of the preceding test case creates a test application and an <code>HttpClient</code>. It then sends an <code>AddItem.Command</code> to the endpoint in its <em>Act</em> block.Afterward, it splits the <em>Assert</em> block in two: the HTTP response and the database itself. The first part ensures that the endpoint returns the expected data. The second part ensures that the database is in the correct state.</p>
<blockquote>
<p>It is a good habit to ensure the database is in the correct state, especially with EF Core or most Unit of Work implementations, because one could add an item and forget to save the changes leading to an incorrect database state. Yet, the data returned by the endpoint would have been correct.</p>
</blockquote>
<p>We could test more or less elements here. We could refactor the <em>Assert</em> block so it becomes more elegant. We can and should continuously improve all types of code, including tests. However, in this case, I wanted to keep as much of the logic in the test method to make it easier to understand.</p>
<blockquote>
<p>It is also a good practice to keep test methods as independent as possible. This does not mean that improving readability and encapsulating code into helper classes or methods is wrong; on the contrary.</p>
</blockquote>
<p>The only opaque piece of the test method is the <code>C18WebApplication</code> class, which inherits from the <code>WebApplicationFactory&lt;Program&gt;</code> class and implements a few helper methods to simplify the configuration of the test application. You can treat it as an instance of the <code>WebApplicationFactory&lt;Program&gt;</code> class. Feel free to browse the code on GitHub and explore its inner workings.</p>
<blockquote>
<p>Creating an <code>Application</code> class is a good reusability pattern. However, creating an application per test method is not the most performant because you are booting the entire program for every test.</p>
<blockquote>
<p>You can use test fixtures to reuse and share an instance of the program between multiple tests. However, remember that the application's state and potentially the database are also shared between tests.</p>
</blockquote>
</blockquote>
<p>To the second test, next.</p>


<h5 data-number="19.3.5.1.2">Second test method</h5>
<p>This test ensures that the <code>Location</code> header contains a valid URL. This test is important since the <code>Baskets</code> and the <code>Products</code> features are loosely coupled and can change independently. Here’s the code:</p>
<div><pre><code>[Fact]
public async Task Should_return_a_valid_product_url()
{
    // Arrange
    await using var application = new C18WebApplication();
    await application.SeedAsync&lt;Products.ProductContext&gt;(async db =&gt;
    {
        db.Products.RemoveRange(db.Products);
        db.Products.Add(new("A test product", 15.22m, 1));
        await db.SaveChangesAsync();
    });
    var client = application.CreateClient();
    // Act
    var response = await client.PostAsJsonAsync(
        "/baskets",
        new AddItem.Command(4, 1, 22)
    );
    // Assert
    Assert.NotNull(response);
    Assert.Equal(HttpStatusCode.Created, response.StatusCode);
    Assert.NotNull(response.Headers.Location);
    var productResponse = await client
        .GetAsync(response.Headers.Location);
    Assert.NotNull(productResponse);
    Assert.True(productResponse.IsSuccessStatusCode);
}</code></pre>
</div>
<p>The preceding test method is similar to the first one. The <em>Arrange</em> block creates an application, seeds the database, and creates an <code>HttpClient</code>. The <code>SeedAsync</code> method is one of the helper methods of the <code>C18WebApplication</code> class.The <em>Act</em> block sends a request to create a basket item.The <em>Assert</em> block is divided in two. The first ensures that the HTTP response contains a <code>Location</code> header and that the status code is 201. The second part (highlighted) takes the <code>Location</code> header and sends an HTTP request to validate the URL’s validity. This test ensures that if we change the URL of the <code>Products.FetchOne</code> endpoint, say we prefer <code>/catalog</code> over <code>/products</code>, this test will alert us.We explore the third test case next.</p>


<h5 data-number="19.3.5.1.3">Third test method</h5>
<p>The last test method ensures that the endpoint responds with a 409 Conflict status when a consumer tries to add an existing item:</p>
<div><pre><code>[Fact]
public async Task Should_return_a_ProblemDetails_with_a_Conflict_status_code()
{
    // Arrange
    await using var application = new C18WebApplication();
    await application.SeedAsync&lt;BasketContext&gt;(async db =&gt;
    {
        db.Items.RemoveRange(db.Items);
        db.Items.Add(new(
            CustomerId: 1,
            ProductId: 1,
            Quantity: 10
        ));
        await db.SaveChangesAsync();
    });
    var client = application.CreateClient();
    // Act
    var response = await client.PostAsJsonAsync(
        "/baskets",
        new AddItem.Command(
            CustomerId: 1,
            ProductId: 1,
            Quantity: 20
        )
    );
    // Assert the response
    Assert.NotNull(response);
    Assert.False(response.IsSuccessStatusCode);
    Assert.Equal(HttpStatusCode.Conflict, response.StatusCode);
    var problem = await response.Content
        .ReadFromJsonAsync&lt;ProblemDetails&gt;();
    Assert.NotNull(problem);
    Assert.Equal("The product \u00271\u0027 is already in your shopping cart.", problem.Title);
    // Assert the database state
    using var seedScope = application.Services.CreateScope();
    var db = seedScope.ServiceProvider
        .GetRequiredService&lt;BasketContext&gt;();
    var dbItem = db.Items.FirstOrDefault(x =&gt; x.CustomerId == 1 &amp;&amp; x.ProductId == 1);
    Assert.NotNull(dbItem);
    Assert.Equal(10, dbItem.Quantity);
}</code></pre>
</div>
<p>The preceding test method is very similar to the other two.The <em>Arrange</em> block creates a test application, seeds the database, and creates an <code>HttpClient</code>.The <em>Act</em> block sends a request using the only item in the database, which we expect to result in a conflict.The first part of the <em>Assert</em> block ensures that the endpoint returns the expected <code>ProblemDetails</code> object. The second part validates that the endpoint has not changed the quantity in the database.With those three tests, we are covering the relevant code of the <code>AddItem</code> feature.The other test cases are similar, sending HTTP requests and validating the database content. Each feature has between one and three tests. We explore a test related to the <code>UpdateQuantity</code> feature next.</p>



<h4 data-number="19.3.5.2">UpdateQuantityTest</h4>
<p>We did not cover the <code>UpdateQuantity</code> feature, but one of its branches is that if the current quantity and the new quantities are the same, the endpoint will not update the data. Here’s the snippet:</p>
<div><pre><code>if (item.Quantity != command.Quantity)
{
    _db.Items.Update(itemToUpdate);
    await _db.SaveChangesAsync(cancellationToken);
}</code></pre>
</div>
<p>To test this use case, we subscribe to the <code>SavedChanges</code> event on the EF Core <code>DbContext</code>, then ensure the code never calls it. This uses no mocks or stubs and tests the real code.This test stands out of the lot, so I considered it worth exploring before moving on. Here’s the code:</p>
<div><pre><code>[Fact]
public async Task Should_not_touch_the_database_when_the_quantity_is_the_same()
{
    // Arrange
    await using var application = new C18WebApplication();
    await application.SeedAsync&lt;BasketContext&gt;(async db =&gt;
    {
        db.Items.RemoveRange(db.Items.ToArray());
        db.Items.Add(new BasketItem(2, 1, 5));
        await db.SaveChangesAsync();
    });
    using var seedScope = application.Services.CreateScope();
    var db = seedScope.ServiceProvider
        .GetRequiredService&lt;BasketContext&gt;();
    var mapper = seedScope.ServiceProvider
        .GetRequiredService&lt;UpdateQuantity.Mapper&gt;();
    db.SavedChanges += Db_SavedChanges;
    var saved = false;
    var sut = new UpdateQuantity.Handler(db, mapper);
    // Act
    var response = await sut.HandleAsync(
        new UpdateQuantity.Command(2, 1, 5),
        CancellationToken.None
    );
    // Assert
    Assert.NotNull(response);
    Assert.False(saved);
    void Db_SavedChanges(object? sender, SavedChangesEventArgs e)
    {
        saved = true;
    }
}</code></pre>
</div>
<p>The preceding test method should sound very familiar by now. However, we use a different pattern here.In the <em>Arrange</em> block, we create a test application and seed the database, but we do not create an <code>HttpClient</code>. We use the <code>ServiceProvider</code> to create the dependencies instead. Then manually instantiate the <code>UpdateQuantity.Handler</code> class. This allows us to customize the <code>BasketContext</code> instance to assess whether the endpoint called its <code>SaveChange</code> method (highlighted code).The <em>Act</em> block invokes the <code>HandleAsync</code> method directly with a command that should not trigger the update because the item has the same quantity as the one we seeded. Unlike the other tests, we are not sending an HTTP request.The <em>Assert</em> block is simpler than the other tests we explored because we test the method, not the HTTP response or the database. In this case, we only care whether the <code>saved</code> variable is <code>true</code> or <code>false</code>.</p>
<blockquote>
<p>This test is much faster than the other because no HTTP is involved. When calling the <code>CreateClient</code> method of a <code>WebApplicationFactory&lt;T&gt;</code> object (the <code>C18WebApplication</code> class in this case), it starts the webserver and then creates the <code>HttpClient</code>, which has a significant performance overhead.</p>
<blockquote>
<p>Remember this tip when you have to optimize your test suites.</p>
</blockquote>
</blockquote>
<p>And we are done; the test knows whether or not the <code>DbContext</code>’s <code>SavedChanges</code> method was called. Let’s summarize what we learned before moving to the next chapter.</p>




<h2 data-number="19.4">Summary</h2>
<p>We delved into the Request-EndPoint-Response (REPR) design pattern and learned that REPR follows the most foundational pattern of the web. The client sends a request to an endpoint, which processes it and returns a response. The pattern focuses on designing the backend code around the endpoint, making it faster to develop, easier to find your way around the project, and more focused on features than MVC and layers.We also took a CQS approach around the requests, making them queries or commands, depicting all that can happen in a program: read or write states.We explored ways to organize the code around such a pattern, from implementing trivial to more complex features. We built a technology stack to create an e-commerce web application that leverages the REPR pattern and a feature-oriented design. We learned how to leverage middleware to handle exceptions globally and how the <em>ExceptionMapper</em> library provides us with this capability. We also used grey-box testing to cover almost all of the project's logic with just a few tests.Next, we explore microservices architecture.</p>


<h2 data-number="19.5">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>Must we use the <em>FluentValidation</em> and <em>ExceptionMapper</em> libraries when implementing the REPR pattern?</li>
<li>What are the three components of the REPR pattern?</li>
<li>Does the REPR pattern dictate that we use nested classes?</li>
<li>Why are grey-box integration tests provide much confidence?</li>
<li>Name an advantage of handling exceptions using middleware.</li>
</ol>


<h2 data-number="19.6">Further reading</h2>
<p>Here are a few links to build upon what we learned in the chapter:</p>
<ul>
<li>FluentValidation: <a href="https://adpg.link/xXgp">https://adpg.link/xXgp</a></li>
<li>FluentValidation.AspNetCore.Http: <a href="https://adpg.link/qsao">https://adpg.link/qsao</a></li>
<li>ExceptionMapper: <a href="https://adpg.link/ESDb">https://adpg.link/ESDb</a></li>
<li>Mapperly: <a href="https://adpg.link/Dwcj">https://adpg.link/Dwcj</a></li>
<li>MVC Controllers are Dinosaurs - Embrace API Endpoints: <a href="https://adpg.link/NGjm">https://adpg.link/NGjm</a></li>
</ul>


<h2 data-number="19.7">Answers</h2>
<ol>
<li>No. REPR does not dictate how to implement it. You can create your own stack or go barebone ASP.NET Core minimal API and implement everything by hand in the project.</li>
<li>REPR consists of a request, an endpoint, and a response.</li>
<li>No. REPR does not prescribe any implementation details.</li>
<li>Grey-box integration tests provide much confidence in their outcome because they test the feature almost end-to-end, ensuring all the pieces are there, from the services in the IoC container to the database.</li>
<li>Handling exceptions using middleware allows for centralizing the management of exceptions, encapsulating that responsibility in a single place. It also provides for uniformizing the output, sending the clients a response in the same format for all errors. It removes the burden of handling each exception individually, eliminating <code>try</code>-<code>catch</code> boilerplate code.</li>
</ol>


</body>
</html>
