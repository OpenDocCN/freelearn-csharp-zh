- en: 12 Behavioral Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 行为模式
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的Discord书社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file67.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file67.png)'
- en: 'This chapter explores two new design patterns from the well-known **Gang of
    Four** (**GoF**). They are behavioral patterns, meaning they help simplify system
    behavior management.Often, we need to encapsulate some core algorithm while allowing
    other pieces of code to extend that implementation. That is where the **Template
    Method** pattern comes into play.Other times, we have a complex process with multiple
    algorithms that all apply to one or more situations, and we need to organize it
    in a testable and extensible fashion. This is where the **Chain of Responsibility**
    pattern can help. For example, the ASP.NET Core middleware pipeline is a Chain
    of Responsibility where all the middleware inspects and acts on the request.In
    this chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了来自知名**四人帮**（**GoF**）的两种新的设计模式。它们是行为模式，意味着它们有助于简化系统行为管理。通常，我们需要封装一些核心算法，同时允许其他代码片段扩展该实现。这就是**模板方法**模式发挥作用的地方。有时，我们有一个复杂的过程，包含多个算法，这些算法都适用于一个或多个情况，我们需要以可测试和可扩展的方式组织它们。这就是**责任链**模式能提供帮助的地方。例如，ASP.NET
    Core中间件管道就是一个责任链，其中所有中间件都会检查并处理请求。在本章中，我们将涵盖以下主题：
- en: Implementing the Template Method pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模板方法模式
- en: Implementing the Chain of Responsibility pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现责任链模式
- en: Mixing the Template Method and Chain of Responsibility patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合模板方法和责任链模式
- en: Implementing the Template Method pattern
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模板方法模式
- en: The **Template Method** is a GoF behavioral pattern that uses inheritance to
    share code between the base class and its subclasses. It is a very powerful yet
    simple design pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板方法**是GoF行为模式，它使用继承在基类及其子类之间共享代码。这是一个非常强大且简单的设计模式。'
- en: Goal
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The goal of the Template Method pattern is to encapsulate the outline of an
    algorithm in a base class while leaving some parts of that algorithm open for
    modification by the subclasses, which adds flexibility at a low cost.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式的目标是在基类中封装算法的轮廓，同时将算法的某些部分留给子类进行修改，这以低成本增加了灵活性。
- en: Design
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'First, we need to define a base class that contains the `TemplateMethod` method
    and then define one or more sub-operations that need to be implemented by its
    subclasses (`abstract`) or that can be overridden (`virtual`).Using UML, it looks
    like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个包含`TemplateMethod`方法的基类，然后定义一个或多个子操作，这些操作需要由其子类（`abstract`）实现，或者可以被覆盖（`virtual`）。使用UML，它看起来像这样：
- en: '![Figure 12.1: Class diagram representing the Template Method pattern](img/file68.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：表示模板方法模式的类图](img/file68.png)'
- en: 'Figure 12.1: Class diagram representing the Template Method pattern'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：表示模板方法模式的类图
- en: How does this work?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？
- en: '`AbstractClass` implements the shared code: the algorithm in its `TemplateMethod`
    method.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractClass`实现了共享代码：在`TemplateMethod`方法中的算法。'
- en: '`ConcreteClass` implements its specific part of the algorithm in its inherited
    `Operation` method.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteClass`在其继承的`Operation`方法中实现算法的特定部分。'
- en: '`Client` calls `TemplateMethod()`, which calls the subclass implementation
    of one or more specific algorithm elements (the `Operation` method in this case).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`调用`TemplateMethod()`，它调用子类实现的一个或多个特定算法元素（在本例中是`Operation`方法）。'
- en: We could also extract an interface from `AbstractClass` to allow even more flexibility,
    but that’s beyond the scope of the Template Method pattern.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还可以从`AbstractClass`中提取一个接口，以提供更大的灵活性，但这超出了模板方法模式的范围。
- en: Let’s now get into some code to see the Template Method pattern in action.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看看一些代码，以了解模板方法模式是如何工作的。
- en: Project – Building a search machine
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 构建搜索机
- en: 'Let’s start with a simple, classic example to demonstrate how the Template
    Method pattern works.**Context**: Depending on the collection, we want to use
    a different search algorithm. We want to use a *binary search* for sorted collections,
    but we want to use a *linear search* for unsorted collections.Let’s start with
    the consumer, a REST endpoint in the `Program.cs` file that returns `plain/text`
    results:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的经典示例开始，以展示模板方法模式是如何工作的。**上下文**：根据集合的不同，我们希望使用不同的搜索算法。对于有序集合，我们希望使用二分搜索，但对于未排序的集合，我们希望使用线性搜索。让我们从消费者开始，它是
    `Program.cs` 文件中的一个 REST 端点，返回 `plain/text` 结果：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As highlighted in the first few lines, we configure `LinearSearchMachine` and
    `BinarySearchMachine` as two `SearchMachine` implementations. We initialize each
    instance using a different sequence of numbers.Afterward, we inject all registered
    `SearchMachine` services into the endpoint (highlighted in the code block). That
    handler iterates all `SearchMachine` instances and tries to find all elements
    of the `elementsToFind` array before outputting the `text/plain` results.Next,
    let’s explore the `SearchMachine` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几行所强调的，我们将 `LinearSearchMachine` 和 `BinarySearchMachine` 配置为两个 `SearchMachine`
    实现。我们使用不同的数字序列初始化每个实例。之后，我们将所有注册的 `SearchMachine` 服务注入到端点（代码块中突出显示）。该处理程序迭代所有
    `SearchMachine` 实例，在输出 `text/plain` 结果之前尝试找到 `elementsToFind` 数组中的所有元素。接下来，让我们探索
    `SearchMachine` 类：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `SearchMachine` class represents `AbstractClass`. It exposes the `IndexOf`
    template method, which uses the required hook represented by the `abstract` `Find`
    method (see highlighted code). The hook is required because each subclass must
    implement that method, thereby making that method a required extension point (or
    hook).Next, we explore our first implementation of `ConcreteClass`, the `LinearSearchMachine`
    class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchMachine` 类代表 `AbstractClass`。它公开了 `IndexOf` 模板方法，该方法使用由 `abstract` `Find`
    方法表示的所需钩子（见突出显示的代码）。钩子是必需的，因为每个子类都必须实现该方法，从而使该方法成为一个必需的扩展点（或钩子）。接下来，我们探索我们的第一个
    `ConcreteClass` 实现，即 `LinearSearchMachine` 类：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `LinearSearchMachine` class is a `ConcreteClass` representing the linear
    search implementation used by `SearchMachine`. It contributes a part of the `IndexOf`
    algorithm through its `Find` method.Finally, we move on to the `BinarySearchMachine`
    class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearSearchMachine` 类是一个表示 `SearchMachine` 使用的线性搜索实现的 `ConcreteClass`。它通过其
    `Find` 方法贡献了 `IndexOf` 算法的一部分。最后，我们继续到 `BinarySearchMachine` 类：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `BinarySearchMachine` class is a `ConcreteClass` representing the binary
    search implementation of `SearchMachine`. As you may have noticed, we skipped
    the binary search algorithm’s implementation by delegating it to the built-in
    `Array.BinarySearch` method. Thanks to the .NET team!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearchMachine` 类是一个表示 `SearchMachine` 的二分搜索实现的 `ConcreteClass`。如您所注意到的，我们通过委托给内置的
    `Array.BinarySearch` 方法来跳过了二分搜索算法的实现。感谢 .NET 团队！'
- en: The binary search algorithm requires an ordered collection to work; hence the
    sorting done in the constructor when passing the values to the base class (`OrderBy`).
    That may not be the most performant way of ensuring the array is sorted (precondition/guard),
    but it is a very fast to write and readable way to write it. Moreover, in our
    case, performance is not an issue.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 二分查找算法需要一个有序集合来工作；因此，在将值传递给基类（`OrderBy`）时，构造函数中执行的排序可能是确保数组排序（先决条件/保护）的最不高效方式，但它是一种快速编写且易于阅读的方式来编写它。此外，在我们的情况下，性能并不是问题。
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you must optimize such an algorithm to work with a large data set, you can
    leverage parallelism (multithreading) to help out. In any case, run a proper benchmark
    to ensure you optimize the right thing and assess your real gains. Look at BenchmarkDotNet
    ([https://adpg.link/C5E9](https://adpg.link/C5E9)) if you are looking at benchmarking
    .NET code.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您必须优化这样的算法以与大数据集一起工作，您可以使用并行性（多线程）来提供帮助。无论如何，运行适当的基准测试以确保您优化了正确的事情，并评估您的实际收益。如果您正在查看基准测试
    .NET 代码，请查看 BenchmarkDotNet（[https://adpg.link/C5E9](https://adpg.link/C5E9)）。
- en: 'Now that we have defined the actors and explored the code, let’s see what is
    happening in our consumer (the `Client`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了演员并探讨了代码，让我们看看我们的消费者（`Client`）中发生了什么：
- en: The `Client` uses the registered `SearchMachine` instances and searches for
    values 1, 10, and 11.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Client` 使用注册的 `SearchMachine` 实例搜索值 1、10 和 11。'
- en: Afterward, `Client` displays to the user whether the numbers were found or not.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，`Client` 向用户显示数字是否被找到。
- en: 'The `Find` method returns `null` when it does not find a value and, by extension,
    the `IndexOf` method.By running the program, we get the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Find`方法找不到值时返回`null`，通过扩展，`IndexOf`方法也是如此。运行程序后，我们得到以下输出：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding output shows the two algorithms at play. Both `SearchMachine`
    implementations did not contain the value `11`. They both contained the values
    `1` and `10` placed at different positions. Here is a reminder of the values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了正在运行的两种算法。两个`SearchMachine`实现都没有包含值`11`。它们都包含了值`1`和`10`，但位置不同。以下是值的提醒：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The consumer was iterating the `SearchMachine` registered with the IoC container.
    The base class implements the `IndexOf` but delegates the search (`Find`) algorithm
    to the subclasses. The preceding output shows that each `SearchMachine` could
    execute the expected task by implementing only the `Find` piece of the algorithm.And
    voilà! We have covered the Template Method pattern, as easy as that. Of course,
    our algorithm was trivial, but the concept remains.To ensure the correctness of
    the implementation, I also created two tests, one per class. Here’s a test for
    the `LinearSearchMachine` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者正在迭代与IoC容器注册的`SearchMachine`。基类实现了`IndexOf`，但将搜索（`Find`）算法委托给子类。前面的输出显示每个`SearchMachine`只需通过实现算法的`Find`部分就能执行预期的任务。就这样！我们已经涵盖了模板方法模式，就像那样简单。当然，我们的算法是微不足道的，但概念仍然存在。为了确保实现的正确性，我还为每个类创建了两项测试。以下是`LinearSearchMachine`类的测试：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding test ensures that the correct values are found or not by the
    `IndexOf` method of the `LinearSearchMachine` class.Next is a similar test for
    the `BinarySearchMachine` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试确保通过`LinearSearchMachine`类的`IndexOf`方法找到或未找到正确的值。接下来是对`BinarySearchMachine`类的一个类似测试：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding test does a similar job of ensuring that the correct values are
    found or not by the `IndexOf` method of the `BinarySearchMachine` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试确保通过`BinarySearchMachine`类的`IndexOf`方法找到或未找到正确的值。
- en: 'We can add `virtual` methods in the base class to create optional hooks. Those
    methods would become optional extension points that subclasses can implement or
    not. That would allow a more complex and more versatile scenario to be supported.
    We will not cover this here because it is not part of the pattern itself, even
    if very similar. There are many examples in the .NET **base class library** (**BCL**),
    like most methods of the `ComponentBase` class (in the `Microsoft.AspNetCore.Components`
    namespace). For example, when overriding the `OnInitialized` method in a Blazor
    component, we leverage an optional extension hook. The base method does nothing
    and is there only for extensibility purposes, allowing us to run code as part
    of the component’s lifecycle. You can consult the `ComponentBase` class code in
    the official .NET repo on GitHub: [https://adpg.link/1WYq](https://adpg.link/1WYq).'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以在基类中添加`virtual`方法来创建可选的钩子。这些方法将成为可选的扩展点，子类可以选择实现或不实现。这将允许支持更复杂和更通用的场景。我们在这里不会涵盖这一点，因为它不是模式本身的一部分，即使非常相似。在.NET
    **基类库**（**BCL**）中有许多例子，比如`ComponentBase`类的大多数方法（在`Microsoft.AspNetCore.Components`命名空间中）。例如，当在Blazor组件中覆盖`OnInitialized`方法时，我们利用了一个可选的扩展钩子。基方法不执行任何操作，仅用于扩展目的，允许我们在组件的生命周期中运行代码。您可以在GitHub上的官方.NET仓库中查看`ComponentBase`类的代码：[https://adpg.link/1WYq](https://adpg.link/1WYq)。
- en: This concludes our study of another simple yet powerful design pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对另一个简单而强大的设计模式的研究。
- en: Conclusion
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Template Method is a powerful and easy-to-implement design pattern allowing
    subclasses to reuse the algorithm’s skeleton while implementing (abstract) or
    overriding (virtual) subparts. It allows implementation-specific classes to extend
    the core algorithm. It can reduce the duplication of logic and improve maintainability
    while not cutting out any flexibility in the process. There are many examples
    in the .NET BCL, and we leverage this pattern at the end of the chapter based
    on a real-world scenario.Now, let’s see how the Template Method pattern can help
    us follow the **SOLID** principles:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法是一种强大且易于实现的设计模式，允许子类在实现（抽象）或覆盖（虚拟）子部分的同时重用算法的骨架。它允许特定实现的类扩展核心算法。它可以减少逻辑的重复，提高可维护性，同时不减少过程中的任何灵活性。在.NET
    BCL中有许多例子，我们根据一个真实世界的场景在章节末尾利用了这个模式。现在，让我们看看模板方法模式如何帮助我们遵循**SOLID**原则：
- en: '**S**: The Template Method pushes algorithm-specific portions of the code to
    subclasses while keeping the core algorithm in the base class. Doing that helps
    follow the **single responsibility principle** (**SRP**) by distributing responsibilities.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：模板方法将算法特定的代码部分推送到子类，同时保持核心算法在基类中。这样做通过分配责任来帮助遵循**单一职责原则**（**SRP**）。'
- en: '**O**: By opening extension hooks, it opens the template for extensions (allowing
    subclasses to extend it) and closes it from modifications (no need to modify the
    base class since the subclasses can extend it).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：通过打开扩展钩子，它打开扩展的模板（允许子类扩展它）并关闭修改（不需要修改基类，因为子类可以扩展它）。'
- en: '**L**: As long as the subclasses are the implementations and do not alter the
    base class per se, following the **Liskov substitution principle** (**LSP**) should
    not be a problem. However, this principle is tricky, so it is possible to break
    it; by throwing a new type of exception or altering the state of a more complex
    base class in a way that changes its behavior, for example.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：只要子类是实现并且没有改变基类本身，遵循**里氏替换原则**（**LSP**）应该不会有问题。然而，这个原则很棘手，所以有可能打破它；例如，通过抛出新的异常类型或以改变更复杂基类状态的方式改变其行为。'
- en: '**I**: As long as the base class implements the smallest cohesive surface possible,
    using the Template Method pattern should not negatively impact the program. On
    top of this, having a smaller interface surface in classes diminishes the chances
    of breaking the LSP.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：只要基类实现了可能的最小内聚表面，使用模板方法模式不应该对程序产生负面影响。此外，在类中拥有较小的接口表面减少了违反**里氏替换原则**（**LSP**）的机会。'
- en: '**D**: The Template Method pattern is based on an abstraction, so as long as
    consumers depend on that abstraction, it should help to get in line with the **dependency
    inversion principle** (**DIP**).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：模板方法模式基于一个抽象，因此只要消费者依赖于这个抽象，它应该有助于符合**依赖倒置原则**（**DIP**）。'
- en: Next, we move to the Chain of Responsibility design pattern before mixing the
    Template Method and the Chain of Responsibility pattern to improve our code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在混合模板方法和责任链模式之前，转向责任链设计模式，以改进我们的代码。
- en: Implementing the Chain of Responsibility pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现责任链模式
- en: The **Chain of Responsibility** is a GoF behavioral pattern that chains classes
    to handle complex scenarios efficiently, with limited effort. Once again, the
    goal is to take a complex problem and break it into multiple smaller units.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**责任链**是GoF行为模式，通过链式连接类来高效处理复杂场景，同时投入有限的努力。再次强调，目标是将复杂问题分解成多个更小的单元。'
- en: Goal
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The Chain of Responsibility pattern aims to chain multiple handlers that each
    solve a limited number of problems. If a handler cannot solve the specific problem,
    it passes the resolution to the chain’s next handler.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式旨在链式连接多个处理者，每个处理者解决有限数量的问题。如果一个处理者不能解决特定的问题，它将解决方案传递给链中的下一个处理者。
- en: We often create a default handler that executes logic at the end of the chain
    as the terminal handler. Such a handler can throw an exception (for example, `OperationNotHandledException`)
    to cascade the issue up the call stack to a consumer who knows how to handle and
    react to it. Another strategy is creating a terminal handler that does the opposite
    and ensures nothing happens.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们通常创建一个默认处理者，作为终端处理者在链的末尾执行逻辑。这样的处理者可以抛出一个异常（例如，`OperationNotHandledException`），将问题级联到调用堆栈中的消费者，该消费者知道如何处理和响应它。另一种策略是创建一个终端处理者，执行相反的操作并确保不发生任何事情。
- en: Design
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'The most basic Chain of Responsibility starts by defining an interface that
    handles a request (`IHandler`). Then we add classes that handle one or more scenarios
    (`Handler1` and `Handler2`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的责任链模式首先通过定义一个处理请求的接口（`IHandler`）开始。然后我们添加处理一个或多个场景的类（`Handler1` 和 `Handler2`）：
- en: '![Figure 12.2: Class diagram representing the Chain of Responsibility pattern](img/file69.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2：表示责任链模式的类图](img/file69.png)'
- en: 'Figure 12.2: Class diagram representing the Chain of Responsibility pattern'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：表示责任链模式的类图
- en: A difference between the Chain of Responsibility pattern and many other patterns
    is that no central dispatcher knows the handlers; all handlers are independent.
    The consumer receives a handler and tells it to handle the request. Each handler
    determines if it can process the request. If it can, it processes it. In both
    cases, it also evaluates if it should forward the request to the next handler
    in the chain. The handler can execute these two tasks in any order, like executing
    some logic, sending the request down the chain, then executing more logic when
    the request comes back (like a pipeline).This pattern allows us to divide complex
    logic into multiple pieces that handle a single responsibility, improving testability,
    reusability, and extensibility in the process. Since no orchestrator exists, each
    chain element is independent, leading to a cohesive and loosely coupled design.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式与其他许多模式的不同之处在于，没有中央调度器知道处理器；所有处理器都是独立的。消费者接收一个处理器并指示它处理请求。每个处理器决定它是否能够处理请求。如果可以，它就处理它。在两种情况下，它还会评估是否应该将请求转发到链中的下一个处理器。处理器可以以任何顺序执行这两个任务，比如执行一些逻辑，将请求沿链向下传递，然后在请求返回时执行更多逻辑（就像一个管道）。这种模式允许我们将复杂的逻辑分解成多个处理单个职责的部分，从而在过程中提高可测试性、可重用性和可扩展性。由于不存在协调器，每个链元素都是独立的，这导致了一个统一且松散耦合的设计。
- en: When creating the chain of responsibility, you can order the handlers so that
    the most requested handlers are closer to the beginning of the chain and the least
    requested handlers are closer to the end. This helps limit the number of “chain
    links” that are visited for each request before reaching the right handler.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在创建责任链时，你可以对处理器进行排序，使得最常请求的处理器靠近链的开始，而最少请求的处理器靠近链的末端。这有助于限制在到达正确的处理器之前，每个请求需要访问的“链链接”数量。
- en: Enough theory; let’s look at some code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了；让我们看看一些代码。
- en: Project – Message interpreter
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 消息解释器
- en: '**Context**: We need to create the receiving end of a messaging application
    where each message is unique, making it impossible to create a single algorithm
    to handle them all.After analyzing the problem, we decided to build a chain of
    responsibility where each handler can manage a single message. The pattern seems
    more than perfect!'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们需要创建一个消息应用接收端，其中每个消息都是唯一的，这使得无法创建一个处理所有消息的单一代码。在分析问题后，我们决定构建一个责任链，其中每个处理器可以管理一个单独的消息。这个模式似乎非常完美！'
- en: This project is based on something that I built years ago. IoT devices were
    sending bytes (messages) due to limited bandwidth. Then, we had to associate those
    bytes with real values in a web application. Each message had a fixed header size
    but a variable body size. The headers were handled in a base handler (template
    method), and each handler in the chain managed a different message type. For the
    current example, we keep it simpler than parsing bytes, but the concept is the
    same.
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个项目基于我多年前构建的东西。由于带宽有限，物联网设备正在发送字节（消息）。然后，我们必须在Web应用中将这些字节与真实值关联起来。每个消息都有一个固定的头部大小，但有一个可变的消息体大小。头部由基本处理器（模板方法）处理，链中的每个处理器管理不同的消息类型。对于当前示例，我们将其简化为解析字节，但概念是相同的。
- en: 'For our demo application, the messages are as simple as this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示应用，消息就像这样简单：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Name` property is used as a discriminator to differentiate messages, and
    each handler is responsible for doing something with the `Payload` property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name` 属性用作区分消息的判别器，每个处理器负责对 `Payload` 属性进行一些操作。'
- en: We won’t do anything with the payload as it is irrelevant to the pattern, but
    conceptually, that is the logic that should happen.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们不会对有效载荷做任何处理，因为它与模式无关，但从概念上讲，这是应该发生的逻辑。
- en: 'The handlers are very simple, here’s the interface:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器非常简单，以下是其接口：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The only thing a handler can do is handle a message. Our initial application
    can handle the following messages:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器唯一能做的就是处理消息。我们的初始应用可以处理以下消息：
- en: The `AlarmTriggeredHandler` class handles `AlarmTriggered` messages.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlarmTriggeredHandler` 类处理 `AlarmTriggered` 消息。'
- en: The `AlarmPausedHandler` class handles `AlarmPaused` messages.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlarmPausedHandler` 类处理 `AlarmPaused` 消息。'
- en: The `AlarmStoppedHandler` class handles `AlarmStopped` messages.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlarmStoppedHandler` 类处理 `AlarmStopped` 消息。'
- en: The real-world logic is that a machine can send an alarm to a REST API indicating
    it has reached a certain threshold. Then the REST API can push that information
    to a UI, send an email, a text message, or whatnot.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现实世界的逻辑是，一台机器可以向REST API发送一个警报，表明它已经达到某个阈值。然后REST API可以将该信息推送到UI，发送电子邮件、短信等。
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An alerted human can then pause the alarm while investigating the issue so other
    people know the alarm is getting handled.
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 被警告的人可以在调查问题时暂停警报，这样其他人就知道警报正在被处理。
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, a human can go to the physical device and stop the alarm because the
    person has resolved the issue.
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，一个人可以前往物理设备并停止警报，因为问题已经得到解决。
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We could extrapolate on many more sub-scenarios, but this is the gist.
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以对许多更多的子场景进行外推，但这只是大概。
- en: 'The three handlers are very similar and share quite a bit of logic, but we
    fix that later. In the meantime, we have the following handlers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个处理程序非常相似，并且共享相当多的逻辑，但我们稍后会解决这个问题。同时，我们有以下处理程序：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each handler does two things:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理程序做两件事：
- en: It receives an optional “next handler” from its constructor (highlighted in
    the code). This creates a chain similar to a singly linked list.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从其构造函数（在代码中高亮显示）接收一个可选的“下一个处理程序”。这创建了一个类似于单链表的链。
- en: It handles only the request it knows about, delegating the others to the next
    handler in the chain.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只处理它所知的请求，将其他请求委托给链中的下一个处理程序。
- en: 'Let’s use `Program.cs` as the consumer of the Chain of Responsibility (the
    Client) and use a POST requests to interface with our REST API and build the message.Here
    is the first part of our REST API:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Program.cs`作为责任链（客户端）的消费者，并使用POST请求与我们的REST API接口并构建消息。以下是我们的REST API的第一部分：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we manually create the Chain of Responsibility and register
    it as a singleton bound to the `IMessageHandler` interface. In that registration
    code, each handler is manually injected in the previous constructor (created with
    the `new` keyword).The next code represents the second half of the `Program.cs`
    file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们手动创建责任链并将其注册为绑定到`IMessageHandler`接口的单例。在注册代码中，每个处理程序都是手动注入到前一个构造函数（使用`new`关键字创建）中的。下面的代码代表了`Program.cs`文件的第二部分：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The consuming endpoint is reachable through the `/handle` URL and expects a
    `Message` object in its body. It then uses the injected implementation of the
    `IMessageHandler` interface and passes it the message. If we run any of the HTTP
    requests in the `ChainOfResponsibility.http` file, we get a successful result
    similar to this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 消费端点可通过`/handle` URL访问，并期望其体中包含一个`Message`对象。然后它使用注入的`IMessageHandler`接口的实现，并将消息传递给它。如果我们运行`ChainOfResponsibility.http`文件中的任何HTTP请求，我们会得到一个类似以下的成功结果：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The problem is that even if we send an invalid message, there is no way to
    know from the consumer, so it is always valid even when no handler picks up the
    message.To handle this scenario, let’s add a fourth handler (terminal handler)
    that notifies the consumers of invalid requests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，即使我们发送一个无效的消息，消费者也无法知道，所以即使没有处理程序拾取消息，它仍然是有效的。为了处理这种情况，让我们添加一个第四个处理程序（终端处理程序），它通知消费者有关无效请求的信息：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This new terminal handler throws an exception that notifies the consumers about
    the error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的终端处理程序会抛出一个异常，通知消费者有关错误。
- en: We can create custom exceptions to make differentiating between system and application
    errors easier. In this case, throwing a system exception is good enough. In a
    real-world application, I recommend creating a custom exception that represents
    the end of the chain and contains the relevant information for the consumers to
    react to it according to your use case.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以创建自定义异常，以便更容易地区分系统和应用程序错误。在这种情况下，抛出一个系统异常就足够了。在现实世界的应用程序中，我建议创建一个自定义异常，它代表链的末端，并包含消费者根据您的用例对其做出反应的相关信息。
- en: 'Next, let’s register it in our chain (highlighted):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的链中注册它（高亮显示）：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we send a POST request with the name `SomeUnhandledMessageName`, the endpoint
    now yields the following exception:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发送一个名为`SomeUnhandledMessageName`的POST请求，端点现在会返回以下异常：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So far, so good, but the experience is not great, so let’s add a try-catch
    block to handle this in the endpoint:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但体验并不好，所以让我们在端点中添加一个try-catch块来处理这种情况：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, when we send an invalid message, the API gently returns the following
    message to us:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们发送一个无效的消息时，API会温和地返回以下消息给我们：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, when you expect machines to consume your APIs, you should produce
    a data structure that is easier to parse, like using JSON.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，当你期望机器消费你的API时，你应该生成一个更容易解析的数据结构，比如使用JSON。
- en: And voilà. We have built a simple Chain of Responsibility that handles messages.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们已经构建了一个简单的责任链来处理消息。
- en: Conclusion
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The Chain of Responsibility pattern is another great GoF pattern. It divides
    a large problem into smaller, cohesive units, each doing one job: handling its
    specific request(s).Now, let’s see how the Chain of Responsibility pattern can
    help us follow the **SOLID** principles:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式是另一个优秀的GoF模式。它将一个大问题分解成更小、更紧密的单元，每个单元只做一项工作：处理其特定的请求。现在，让我们看看责任链模式如何帮助我们遵循**SOLID**原则：
- en: '**S**: The Chain of Responsibility pattern aims to this exact principle: create
    a single unit of logic per class!'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：责任链模式旨在遵循这个确切的原则：每个类创建一个逻辑单元！'
- en: '**O**: The Chain of Responsibility pattern allows the addition, removal, and
    reordering of handlers without touching the code but by altering the chain''s
    composition in the composition root.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：责任链模式允许在不接触代码的情况下通过改变链的组成在组合根中添加、删除和重新排序处理器。'
- en: '**L**: N/A'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: The Chain of Responsibility pattern helps with the ISP if we create
    a small interface. The handler interface is not limited to a single method; it
    can expose multiple.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：如果我们创建一个小的接口，责任链模式有助于ISP。处理器接口不仅限于一个方法；它可以公开多个。'
- en: '**D**: By using the handler interface, no element of the chain, nor the consumers,
    depends on a specific handler; they only depend on the interface that represents
    the chain, which helps invert the dependency flow.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：通过使用处理器接口，链中的任何元素，以及消费者，都不依赖于特定的处理器；它们只依赖于代表链的接口，这有助于反转依赖流。'
- en: Next, let’s use the Template Method and Chain of Responsibility patterns to
    encapsulate our handlers’ duplicated logic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用模板方法和责任链模式来封装我们处理器的重复逻辑。
- en: Mixing the Template Method and Chain of Responsibility patterns
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合模板方法和责任链模式
- en: 'This section explores a combination of two powerful design patterns: the Template
    Method and the Chain of Responsibility. As we are about to explore, those two
    patterns fit together well. We use the Template Method pattern as the base structure,
    providing the handlers'' blueprint. Meanwhile, the Chain of Responsibility pattern
    manages the handling sequence, ensuring each request is routed to the correct
    handler.When these two patterns work in tandem, they form a robust framework that
    facilitates easy management, maintains order, and increases the adaptability of
    our system.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了两种强大的设计模式的组合：模板方法和责任链模式。正如我们即将探讨的，这两个模式配合得很好。我们使用模板方法模式作为基本结构，提供处理器的蓝图。同时，责任链模式管理处理顺序，确保每个请求都被路由到正确的处理器。当这两个模式协同工作时，它们形成了一个健壮的框架，便于管理，保持秩序，并提高我们系统的适应性。
- en: Project – Improved message interpreter
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 - 改进的消息解释器
- en: Now that we know both the **Chain of Responsibility** and the **Template Method**
    patterns, it is time to *DRY* out our handlers by extracting the shared logic
    into an abstract base class using the Template Method pattern and providing extension
    points to the subclasses.OK, so what logic is duplicated?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了**责任链**和**模板方法**模式，现在是时候通过使用模板方法模式将共享逻辑提取到抽象基类中，并为子类提供扩展点来“DRY”我们的处理器了。好的，那么哪些逻辑是重复的？
- en: The `next` handler injection code is the same in all but the terminal handlers.
    Moreover, this is an important part of the pattern we should encapsulate in the
    base class.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了终端处理器外，`next`处理器注入代码都是相同的。此外，这是我们应该在基类中封装的模式的一个重要部分。
- en: The logic testing whether the current handler can handle the message is also
    the same in all but the terminal handlers.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑测试当前处理器是否可以处理消息，除了终端处理器外，都是相同的。
- en: 'Let’s create a new base class that implements the Template Method pattern and
    a large part of the logic of our chain of responsibility:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的基类，该基类实现了模板方法模式以及我们责任链的大部分逻辑：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Based on those few changes, what is the template method, and what are the extension
    points (hooks)?The `MessageHandlerBase` class adds the `Handle` template method.
    Then, the `MessageHandlerBase` class exposes the following extension points:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些少数的更改，模板方法是什么，以及扩展点（钩子）是什么？`MessageHandlerBase`类添加了`Handle`模板方法。然后，`MessageHandlerBase`类公开以下扩展点：
- en: The `CanHandle` method tests whether `HandledMessageName` is equal to the value
    of the `message.Name` property. A subclass can override this method if it requires
    a different comparison logic. This method is an optional hook.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanHandle`方法测试`HandledMessageName`是否等于`message.Name`属性的值。如果子类需要不同的比较逻辑，则可以重写此方法。这是一个可选的钩子。'
- en: All subclasses must implement the `HandledMessageName` property, which is the
    key driver of the `CanHandle` method. This property is a mandatory hook.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有子类都必须实现`HandledMessageName`属性，这是`CanHandle`方法的关键驱动因素。这是一个强制性的钩子。
- en: All subclasses must implement the `Process` method, allowing them to run their
    logic against the message. This method is a mandatory hook.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有子类都必须实现`Process`方法，允许它们在消息上运行它们的逻辑。这是一个强制性的钩子。
- en: 'To understand how these hooks play out, let’s take a look at the three simplified
    alarm handlers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些钩子是如何发挥作用的，让我们看看三个简化的警报处理器：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see from the updated alarm handlers, they are now limited to a single
    responsibility: processing the messages they can handle. In contrast, `MessageHandlerBase`
    now handles the chain of responsibility’s plumbing. We left the `DefaultHandler`
    class unchanged since it is the end of the chain and does not support having a
    next handler, nor processing messages.Mixing those two patterns created a complex
    messaging system that divides responsibilities into handlers. There is one handler
    per message, and the chain logic is pushed into a base class.The beauty of such
    a system is that we don’t have to think about all the messages simultaneously;
    we can focus on just one message at a time. When dealing with a new type of message,
    we can focus on that precise message, implement its handler, and forget about
    the other *N* types. The consumers can also be super dumb, sending the request
    into the pipe without knowing about the Chain of Responsibility, and like magic,
    the right handler shall prevail!Nonetheless, have you noticed an issue with this
    design? Let’s have a look next.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从更新的警报处理器中我们可以看到，它们现在被限制在单一的责任：处理它们可以处理的消息。相比之下，`MessageHandlerBase` 现在处理责任链的管道。我们保留了`DefaultHandler`
    类的原始状态，因为它位于链的末端，不支持有下一个处理器，也不处理消息。将这两种模式混合在一起创建了一个复杂的信息系统，将责任划分到处理器中。每个消息都有一个处理器，并将链逻辑推入基类。这种系统的美妙之处在于我们不必同时考虑所有消息；我们可以一次专注于一个消息。当处理一种新的消息类型时，我们可以专注于那个特定的消息，实现其处理器，并忘记其他
    *N* 种类型。消费者也可以非常简单，将请求发送到管道中，而不了解责任链，就像魔法一样，正确的处理器将占上风！然而，你是否注意到了这个设计的问题？让我们在下一节中看看。
- en: Project – A final, finer-grained design
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 一个最终更细粒度的设计
- en: 'In the last example, we used `HandledMessageName` and `CanHandle` to decide
    whether a handler could handle a request. There is one problem with that code:
    if a subclass decides to override `CanHandle`, and then decides that it no longer
    requires `HandledMessageName`, we would end up having a lingering, unused property
    in our system.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们使用了`HandledMessageName`和`CanHandle`来决定一个处理器是否可以处理一个请求。这个代码有一个问题：如果子类决定重写`CanHandle`，然后决定它不再需要`HandledMessageName`，我们最终会在系统中留下一个持久未使用的属性。
- en: There are worse situations, but we are talking component design here, so why
    not push that system a little further toward a better design?
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有更糟糕的情况，但我们在谈论组件设计，为什么不将这个系统推向更好的设计呢？
- en: 'One way to fix this is to create a finer-grained class hierarchy, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是通过创建一个更细粒度的类层次结构，如下所示：
- en: '![Figure 12.4: Class diagram representing the design of the finer-grained project
    that implements the Chain of Responsibility and Template Method patterns](img/file70.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：表示实现责任链和模板方法模式的更细粒度项目设计的类图](img/file70.png)'
- en: 'Figure 12.4: Class diagram representing the design of the finer-grained project
    that implements the Chain of Responsibility and Template Method patterns'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：表示实现责任链和模板方法模式的更细粒度项目设计的类图
- en: 'The preceding diagram looks more complicated than it is. But let’s look at
    our refactored code first, starting with the new `MessageHandlerBase` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表看起来比实际复杂。但让我们先看看我们的重构代码，从新的`MessageHandlerBase`类开始：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `MessageHandlerBase` class manages the Chain of Responsibility by handling
    the next handler logic and by exposing two hooks (the Template Method pattern)
    for subclasses to extend:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageHandlerBase` 类通过处理下一个处理器的逻辑并暴露两个钩子（模板方法模式）来管理责任链，允许子类扩展：'
- en: '`bool CanHandle(Message message)`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool CanHandle(Message message)`'
- en: '`void Process(Message message)`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Process(Message message)`'
- en: 'This class is similar to the previous one, but the `CanHandle` method is now
    abstract, and we removed the `HandledMessageName` property leading to a better
    responsibility segregation and better hooks.Next, let’s look at the `SingleMessageHandlerBase`
    class, which replaces the logic we removed from the `MessageHandlerBase` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与上一个类类似，但现在 `CanHandle` 方法是抽象的，我们移除了 `HandledMessageName` 属性，这导致了更好的责任分离和更好的钩子。接下来，让我们看看
    `SingleMessageHandlerBase` 类，它替换了从 `MessageHandlerBase` 类中移除的逻辑：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `SingleMessageHandlerBase` class inherits from the `MessageHandlerBase`
    class and overrides the `CanHandle` method. It implements the logic related to
    it and adds the `HandledMessageName` property that subclasses must define for
    the `CanHandle` method to work (a required extension point).The `AlarmPausedHandler`,
    `AlarmStoppedHandler`, and `AlarmTriggeredHandler` classes now inherit from `SingleMessageHandlerBase`
    instead of `MessageHandlerBase`, but nothing else has changed. Here’s the code
    as a reminder:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingleMessageHandlerBase` 类继承自 `MessageHandlerBase` 类，并重写了 `CanHandle` 方法。它实现了相关的逻辑，并添加了
    `HandledMessageName` 属性，子类必须定义此属性以使 `CanHandle` 方法生效（一个必需的扩展点）。`AlarmPausedHandler`、`AlarmStoppedHandler`
    和 `AlarmTriggeredHandler` 类现在继承自 `SingleMessageHandlerBase` 而不是 `MessageHandlerBase`，但其他方面没有变化。以下是代码作为提醒：'
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Those subclasses of `SingleMessageHandlerBase` implement the `HandledMessageName`
    property, which returns the message name they can handle, and they implement the
    handling logic by overriding the `Process` method as before.Next, we look at the
    `MultipleMessageHandlerBase` class, which enables its sub-types to handle more
    than one message type:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `SingleMessageHandlerBase` 的子类实现了 `HandledMessageName` 属性，它返回它们可以处理的消息名称，并且它们通过重写
    `Process` 方法来实现处理逻辑，就像之前一样。接下来，我们来看看 `MultipleMessageHandlerBase` 类，它使它的子类型能够处理多种消息类型：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `MultipleMessageHandlerBase` class does the same as `SingleMessageHandlerBase`,
    but it uses a string array instead of a single string, supporting multiple handler
    names.The `DefaultHandler` class has not changed. For demonstration purposes,
    let’s add the `SomeMultiHandler` class that simulates a message handler that can
    handle `"Foo"`, `"Bar"`, and `"Baz"` messages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultipleMessageHandlerBase` 类与 `SingleMessageHandlerBase` 类执行相同的操作，但它使用字符串数组而不是单个字符串，支持多个处理器名称。`DefaultHandler`
    类没有变化。为了演示目的，让我们添加 `SomeMultiHandler` 类，该类模拟了一个可以处理 `"Foo"`、`"Bar"` 和 `"Baz"`
    消息的消息处理器：'
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This class hierarchy may sound complicated, but what we did was to allow extensibility
    without the need to keep any unnecessary code in the process, leaving each class
    with a single responsibility:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类层次结构可能听起来很复杂，但我们所做的是允许扩展性，而不需要在过程中保留任何不必要的代码，使每个类都只有一个单一的责任：
- en: The `MessageHandlerBase` class handles `_next`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageHandlerBase` 类处理 `_next`。'
- en: The `SingleMessageHandlerBase` class handles the `CanHandle` method of handlers
    supporting a single message.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleMessageHandlerBase` 类处理支持单个消息的处理器的 `CanHandle` 方法。'
- en: The `MultipleMessageHandlerBase` class handles the `CanHandle` method of handlers
    supporting multiple messages.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipleMessageHandlerBase` 类处理支持多个消息的处理器的 `CanHandle` 方法。'
- en: Other classes implement their version of `Process` method to handle one or more
    messages.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类实现了它们自己的 `Process` 方法版本来处理一个或多个消息。
- en: And voilà! This is another example demonstrating the strength of the Template
    Method and Chain of Responsibility patterns working together. That last example
    also emphasizes the importance of the SRP by allowing greater flexibility while
    keeping the code reliable and maintainable.Another strength of that design is
    the interface at the top. Anything that does not fit the class hierarchy can be
    implemented directly from the interface instead of trying to adapt logic from
    inappropriate structures. The `DefaultHandler` class is a good example of that.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是另一个示例，展示了模板方法和责任链模式共同工作的强大之处。最后一个示例还强调了SRP的重要性，它允许更大的灵活性，同时保持代码的可靠性和可维护性。该设计的另一个优点是顶部的接口。任何不适合类层次结构的东西都可以直接从接口实现，而不是试图从不适用的结构中适应逻辑。《DefaultHandler》类就是这样一个很好的例子。
- en: Tricking code into doing your bidding instead of properly designing that part
    of the system leads to half-baked solutions that become hard to maintain.
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将代码欺骗成按照你的意愿执行，而不是正确设计系统的那部分，会导致半成品解决方案，这些解决方案难以维护。
- en: Conclusion
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Mixing the Template Method and the Chain of Responsibility patterns leads to
    smaller classes with a single responsibility each.We removed the lingering property
    while keeping that logic out of the handlers. We even extended the logic to more
    use cases.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将模板方法模式和责任链模式混合使用会导致具有单一职责的更小的类。我们在保持逻辑不在处理程序中时移除了遗留属性。我们甚至将逻辑扩展到更多的用例中。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered two GoF behavioral patterns. These patterns can
    help us create flexible yet easy-to-maintain systems. As the name suggests, behavioral
    patterns aim at encapsulating application behaviors into cohesive pieces.First,
    we looked at the Template Method pattern, which allows us to encapsulate an algorithm’s
    outline inside a base class, leaving some parts open for modification by subclasses.
    The subclasses then fill in the gaps and extend that algorithm at those predefined
    locations. These locations can be required (`abstract`) or optional (`virtual`).Then,
    you learned about the Chain of Responsibility pattern, which opens the possibility
    of chaining multiple small handlers into a chain of processing, inputting the
    message to be processed at the beginning of the chain (the interface), and waiting
    for one or more handlers to execute the logic related to that message against
    it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两个GoF行为模式。这些模式可以帮助我们创建灵活且易于维护的系统。正如其名所示，行为模式旨在将应用行为封装成统一的片段。首先，我们了解了模板方法模式，它允许我们在基类中封装算法的轮廓，同时将算法的一些部分留空，以便子类进行修改。然后，子类填补这些空白，并在预定义的位置扩展该算法。这些位置可以是必需的（`抽象`）或可选的（`虚拟`）。然后，你学习了责任链模式，它打开了将多个小型处理程序链接成处理链的可能性，将待处理的消息输入到链的起始处（接口），并等待一个或多个处理程序执行与该消息相关的逻辑。
- en: You don’t have to stop the chain’s execution at the first handler. The Chain
    of Responsibility can become a pipeline instead of associating one message to
    one handler, as we explored.
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不必在第一个处理程序处停止链的执行。责任链可以变成一个管道，而不是将一条消息关联到一个处理程序，正如我们所探讨的那样。
- en: Lastly, leveraging the Template Method pattern to encapsulate the Chain of Responsibility’s
    chaining logic led us to a simpler, robust, flexible, and testable implementation
    without any sacrifices. The two design patterns fits very well together.In the
    next chapter, we dig into the Operation Result design pattern to discover efficient
    ways of managing return values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，利用模板方法模式封装责任链的链接逻辑，使我们得到了一个更简单、更健壮、更灵活、更可测试的实现，没有任何牺牲。这两个设计模式配合得非常好。在下一章中，我们将深入研究操作结果设计模式，以发现管理返回值的高效方法。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习问题：
- en: What is the main goal of the Template Method pattern?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板方法模式的主要目标是什么？
- en: What is the main goal of the Chain of Responsibility pattern?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 责任链模式的主要目标是什么？
- en: Is it true that we can only add one `abstract` method when implementing the
    Template Method design pattern?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模板方法设计模式时，我们只能添加一个`抽象`方法，这是真的吗？
- en: Can we use the Strategy pattern in conjunction with the Template Method pattern?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否将策略模式与模板方法模式结合使用？
- en: Is it true that there is a limit of 32 handlers in a Chain of Responsibility?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在责任链中有一个处理程序数量的限制为32个，这是真的吗？
- en: In a Chain of Responsibility, can multiple handlers process the same message?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在责任链中，多个处理程序可以处理同一条消息吗？
- en: In what way can the Template Method help implement the Chain of Responsibility
    pattern?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板方法模式如何帮助实现责任链模式？
- en: Answers
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: The Template Method pattern encapsulates an algorithm's outline in a base class
    while leaving some parts of that algorithm open for modification by its subclasses.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板方法模式在基类中封装算法的轮廓，同时将算法的一些部分留空，以便其子类进行修改。
- en: The Chain of Responsibility pattern divides a larger problem into small pieces
    (handlers). Each piece is self-governed, while the chain's existence is abstracted
    from its consumers.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 责任链模式将更大的问题划分为小块（处理程序）。每个部分都是自我管理的，而链的存在对其消费者来说是抽象的。
- en: False; you can create as many `abstract` (required) or `virtual` (optional)
    extension points (hooks) as you need.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误；你可以创建你需要的任意数量的`抽象`（必需）或`虚拟`（可选）扩展点（钩子）。
- en: Yes, there is no reason not to.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，没有理由不这样做。
- en: No, there is no greater limit than with any other code.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，没有比其他代码更大的限制。
- en: Yes, you can have one handler per message or multiple handlers per message.
    It is up to you and your requirements.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你可以为每条消息指定一个处理程序，或者为每条消息指定多个处理程序。这取决于你和你自己的需求。
- en: It helps divide responsibilities between classes by encapsulating the shared
    logic into one or more base classes.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过将共享逻辑封装到一个或多个基类中，帮助在类之间划分责任。
