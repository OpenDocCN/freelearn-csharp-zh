- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: SOLID Principles, from Code to Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则，从代码到系统
- en: Starting from this chapter, we are going to step away from the theoretical part
    and, while we are not yet starting to code (this will start in [*Chapter 13*](B21293_13.xhtml#_idTextAnchor470)),
    we will start applying the theory to designing a small information system made
    of several applications. We will decompose the different functions, show how they
    help produce business process outcomes and create the software behind these functions.
    To do so, we will design the different components and the API contracts for the
    services involved, and think of how the data should be designed and governed.
    And in [*Chapter 13*](B21293_13.xhtml#_idTextAnchor470), we will use all of this
    design phase to actually implement the sample information system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将从理论部分转向，尽管我们还没有开始编码（这将在[*第13章*](B21293_13.xhtml#_idTextAnchor470)开始），但我们将开始将理论应用于设计由几个应用程序组成的小型信息系统。我们将分解不同的功能，展示它们如何帮助产生业务流程结果，并创建这些功能背后的软件。为此，我们将设计不同的组件和涉及服务的API合同，并思考数据应该如何设计和治理。在[*第13章*](B21293_13.xhtml#_idTextAnchor470)中，我们将使用所有这些设计阶段来实际实现样本信息系统。
- en: Of course, this information system will be reduced in perimeter and complexity,
    but the exercise has been designed to include most of the important decisions
    that should be made. You will find strict responsibility separation, nice separation
    between processes and functions, decoupling of the service through APIs, standardization
    of the contracts, best-of-breed approach, adapting the software stack to the functions
    desired, independence between the software and the hardware, and lots of other
    principles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个信息系统将在范围和复杂性上有所缩减，但这个练习已被设计成包括应该做出的大多数重要决策。你会发现严格的责任分离，过程和功能之间有良好的分离，通过API解耦服务，标准化合同，采用最佳实践方法，将软件堆栈适应所需的功能，软件和硬件之间的独立性，以及许多其他原则。
- en: 'In this chapter, we will start designing our demonstration system by thinking
    of the functions it should expose. To do so, we will use the **SOLID principles**,
    extending them to information systems. SOLID is the acronym composed of the first
    letters of the five essential principles of software development, which are the
    following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过思考它应该公开的功能来开始设计我们的演示系统。为此，我们将使用**SOLID原则**，将它们扩展到信息系统。SOLID是由软件开发五个基本原则的首字母组成的缩写，这些原则如下：
- en: '**Single responsibility** states that one module should only do one thing'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一责任**指出一个模块应该只做一件事'
- en: '**Open/closed** differentiates between open to evolution and closed to modification'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开/闭**区分了对进化的开放和对修改的封闭'
- en: '**Liskov’s** principle explains how substitution should work'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov的**原则解释了替换应该如何工作'
- en: '**Interface segregation** follows with how contracts should be strongly aligned
    to business functions'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口分离**随后讨论了合同应该如何与业务功能紧密对齐'
- en: Finally, **dependency inversion** deals with coupling and how it should be done,
    at the inverse of what seems natural in most cases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**依赖倒置**处理了耦合以及它应该如何进行，这与大多数情况下看似自然的方式相反
- en: It happens that these principles, often applied to software applications, actually
    apply to every software system and constitute a great way to design their different
    modules. We will thus use them to design our sample information system. But first,
    we need to describe the business requirements for this system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则，通常应用于软件应用，实际上适用于每个软件系统，并且是设计它们不同模块的绝佳方式。因此，我们将使用它们来设计我们的样本信息系统。但首先，我们需要描述这个系统的业务需求。
- en: Describing the sample information system requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述样本信息系统需求
- en: Before any kind of analysis, we will imagine what the system owner would want
    from it. Of course, as we explained, time is a very important constraint in information
    systems design, which has a long life, and we will simulate the fact that we do
    not know everything about the requirements at first. In particular, the last chapters
    of the book will simulate the fact that new requirements arise for the imaginary
    company owning the information system, and explain how the system will adapt to
    it. This point is particularly important because the main goal of this book is
    to show how a system should be created or adapted so that its evolution is simpler
    in time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何分析之前，我们将想象系统所有者希望从系统中得到什么。当然，正如我们解释的那样，时间是信息系统设计中非常重要的约束条件，其生命周期很长，我们将模拟我们最初并不了解所有需求的事实。特别是，本书的最后一章将模拟信息系统的虚构公司出现新的需求，并解释系统将如何适应这些需求。这一点尤为重要，因为本书的主要目标是展示系统应该如何创建或适应，以便其随时间演变的简单性。
- en: To make the exercise as realistic as possible, while keeping it simple for it
    to be contained in a single book, we will imagine the company, the users of the
    information system, their business, the data they manipulate, and so on. This
    is what we are going to do in this first section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使练习尽可能真实，同时保持简单以便包含在一本书中，我们将想象公司、信息系统的用户、他们的业务、他们操作的数据等等。这就是我们将在本节中要做的事情。
- en: The company and its business
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公司及其业务
- en: The company, which we will call **DemoEditor** for this purpose, would be an
    editing company that contracts with individual authors for the writing of books
    and then sells these books. We will imagine that this is quite a small company
    (less than 50 persons) and that its current information system is extremely reduced,
    mostly composed of a standard Office 365 organization providing them with email
    capability, basic SharePoint document management, an externalized website, and
    lots of internal functions being implemented through Excel workbooks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这家公司为**DemoEditor**，它将是一家与个人作者签订书籍写作合同并随后销售这些书籍的编辑公司。我们将想象这是一家相当小的公司（少于50人），并且其当前的信息系统极其简化，主要由一个标准的Office
    365组织提供电子邮件功能、基本的SharePoint文档管理、一个外部的网站，以及大量通过Excel工作簿实现的内部功能。
- en: While this remains a comfortable situation, because the information system has
    not turned into a spaghetti dish due to a long accumulation of point-to-point
    interoperations, degradation of legacy software applications, and so on, it still
    shows signs of inefficacy. The multiple copies of the Excel workbooks make it
    difficult for the employees to have a clear view of the pool of authors and the
    state of the writing of the books. Also, as the process of writing is not uniform,
    the director of the company complains about not being able to find clear statistics
    about global advances or delays in book delivery.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前这种状况还算舒适，因为信息系统尚未因为长期积累的点对点互操作、遗留软件应用的退化等问题而变成一团乱麻，但它仍然显示出效率低下的迹象。Excel工作簿的多个副本使得员工难以清晰地看到作者池和书籍写作的状态。此外，由于写作过程不统一，公司总监抱怨无法找到关于全球进度或书籍交付延误的清晰统计数据。
- en: The business is mostly about finding the right subjects for the market, choosing
    the right author, following up on the writing of the books, and organizing the
    right sales process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 业务主要是寻找适合市场的主题，选择合适的作者，跟进书籍的写作，以及组织合适的销售流程。
- en: The users and actors of the information system
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息系统的用户和参与者
- en: The 50 persons are, mostly, book editors. Then come the sales team, a bit of
    administration, and the director. For this simple example, we will consider that
    all the printing and distribution of the books is outsourced to another company
    and that DemoEditor concentrates only on the editing process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 50人当中，大多数是图书编辑。接下来是销售团队，一点行政人员，以及总监。在这个简单的例子中，我们将考虑所有书籍的印刷和发行都外包给另一家公司，而DemoEditor只专注于编辑过程。
- en: The book editors’ job is to find authors, find book subjects, and match the
    right author to the right book. Then, they follow the writing process and make
    sure that the quality is there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图书编辑的工作是寻找作者，寻找书籍主题，并将合适的作者与合适的书籍匹配。然后，他们跟进写作过程，确保质量达标。
- en: Then, it is up to the sales team and their job is to find indirect customers,
    which means libraries or book-selling organizations, as DemoEditor does not sell
    directly to readers. This means that commercial people actually sell the books
    by numbers, and not by units. Though we will not deal much with this part in our
    demo software system, it would be important in a real situation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这取决于销售团队，他们的工作是寻找间接客户，这意味着图书馆或书店组织，因为DemoEditor并不直接向读者销售。这意味着商人实际上是通过数量而不是单位来销售书籍的，尽管在我们演示软件系统中我们不会过多地处理这部分，但在实际情况中这会很重要。
- en: Finally, the director needs to keep numbers in check through reporting and statistics
    coming from the sales team and the editors. The smooth running of the company
    heavily depends on the right deadlines for the book as much as the quality of
    the writing, the match between the subject and the author, and the expectations
    of readers and book-selling companies. This means that the director has to measure
    all of these indicators, and the information system is of course expected to provide
    them. Asking editors or salespersons to fill in Excel sheets every week does not
    make sense, as this is time lost for their real jobs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，总监需要通过销售团队和编辑提供的报告和统计数据来监控数字。公司的顺利运营在很大程度上取决于书籍的截止日期，正如写作质量、主题与作者的匹配以及读者和书店的期望一样。这意味着总监必须衡量所有这些指标，信息系统当然也预期提供这些信息。要求编辑或销售人员每周填写Excel表格是没有意义的，因为这会让他们失去实际工作的宝贵时间。
- en: Data manipulation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据操作
- en: As you may have imagined, DemoEditor’s information system will have to manipulate
    data about authors, books, and sales, plus some additional statistics drawn from
    these primary data. The author will be known by their identity, a little contact
    information, maybe their bank coordinates to pay them royalties, and certainly
    information on their skills. Books will be registered with business-wide reference
    numbers, their titles, their summaries, and other information about the content.
    Sales will basically be the number of books sold to booksellers, with the associated
    date and maybe sales conditions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，DemoEditor的信息系统将不得不处理有关作者、书籍和销售的数据，以及从这些原始数据中提取的一些附加统计数据。作者将通过他们的身份、一些联系信息、可能还有支付版税的银行坐标以及他们的技能信息来识别。书籍将使用业务范围内的参考编号、标题、摘要以及其他关于内容的信息进行注册。销售基本上是向书店销售的书籍数量，以及相关的日期和可能的销售条件。
- en: 'Reporting data will be everything that can be used to apply business intelligence
    by the director on sales, authors, and books: how many books are sold for each
    category, what the time trend of selling them is, how many editions authors can
    work on for a given book before sales slow down and the novelty effect does not
    work anymore, who is their best salesperson, which bookseller returns the least
    number of books or reorders some the quickest, and so on. The reporting data is
    definitely bound to time, and not only by the fact that reports evolve in time,
    but also by the fact that reports should show the movements of business in time
    as well as geographically.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 报告数据将是一切可以由总监用于销售、作者和书籍的业务智能的数据：每个类别销售了多少本书，销售的时间趋势如何，作者在销售放缓和新鲜感不再起作用之前可以就给定书籍完成多少版次，谁是他们的最佳销售员，哪个书店退回的书籍最少或重新订购得最快，等等。报告数据无疑是与时间相关的，这不仅是因为报告随时间演变，而且还因为报告应该显示业务在时间和地理上的动态。
- en: The stakes of the information system for the company
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息系统对公司的重要性
- en: DemoEditor is a small company, which means that employees can “fill the gaps”
    and do a little bit of everything. While this is an advantage in some cases, meaning
    that they are agile and adaptive, it also means that they do not tend to do things
    in an industrial, repeatable way. Excel spreadsheets may be copied over and spread
    out in different versions all over the company instead of a unique, reference
    version being kept on the network. Also, data sales are spread around the different
    salespersons because they tend to be competitive toward each other and it is thus
    difficult to homogenize quantity discounts (the price is fixed) as well as customer
    listings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: DemoEditor是一家小型公司，这意味着员工可以“填补空白”并做一点任何事情。虽然这在某些情况下是一个优势，意味着他们敏捷且适应性良好，但它也意味着他们不太倾向于以工业化和可重复的方式做事。电子表格可能会被复制并在公司不同版本中传播，而不是在网络上保持一个独特的参考版本。此外，数据销售被分散到不同的销售人员手中，因为他们往往相互竞争，因此很难统一数量折扣（价格是固定的）以及客户名单。
- en: As the commercial pipe is not very formal, some leads become prospects and then
    customers without the salesperson being able to really give statistics on how
    long and how much effort this takes them. The director really has a hard time
    knowing whether the company would sell more if they hired more salespersons. The
    choice of authors for the right books is also an issue. Generally, the editors
    have a good grasp on the market and know quite well which subjects should be written
    about. But the pool of competent authors is quite restricted and the authors are
    mostly known for the books they have already written. Most of the time, the editors
    do not know which other technologies these experts know about and there have been
    times when a book has been contracted to a new author, after taking a lot of time
    to find them, only for the editor to realize a few weeks later that one of the
    good authors who’s already written several books for DemoEditor actually had the
    right skills for the new project. An updated, shared, and efficient knowledge
    of author competencies is important for DemoEditor.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于商业管道并不非常正式，一些潜在客户在没有销售人员真正能够提供关于花了多长时间和多少努力才能将潜在客户转化为客户的统计数据的情况下，就变成了客户。总监在不知道如果他们雇佣更多的销售人员公司是否会卖出更多产品时，确实很难。为合适的书籍选择作者也是一个问题。一般来说，编辑对市场有很好的把握，并且非常清楚哪些主题应该被撰写。但是，合格的作者池相当有限，而且作者们大多因他们已经写过的书而知名。大多数时候，编辑不知道这些专家还了解哪些其他技术，而且有时候，在花费了大量时间寻找作者之后，一本书被签约给了一个新作者，结果编辑几周后才发现，实际上有一位已经为DemoEditor写过几本书的优秀作者实际上具备新项目的正确技能。对于DemoEditor来说，一个更新、共享和高效的知识库对于作者能力至关重要。
- en: The situation as seen by the person put in charge of improving the system
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负责改进系统的人看到的状况
- en: You are asked by the director to come and help with the information system.
    Everyone in the company knows IT could be more efficient and help them better
    but, as they say, they are not specialists in it. Since there was no internal
    IT guy, they did as best as they could, but they realized the “do it yourself”
    spirit of a small company can only go so far, and they had to get someone to give
    some structure. The director is also anxious about increasing the size of the
    company before this effort is done; otherwise, it may add more problems than growth.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 经理要求你过来帮助处理信息系统。公司里的每个人都清楚IT可以更加高效并帮助他们更好地工作，但他们说，他们并不是IT方面的专家。由于没有内部IT人员，他们尽力而为，但他们意识到小型公司的“自己动手”精神只能走这么远，他们不得不找人来提供一些结构。经理也担心在完成这项工作之前增加公司规模；否则，这可能会带来更多问题而不是增长。
- en: As the business processes go on and the budget is not extensible, you are tasked
    with “*changing the wheel while the car is running*.” There may be some small
    stops in the IT system, but not for long periods. The data has got to be cleaned
    but the databases of authors and books have got to remain available along the
    way since they are everyday tools for most of the company’s employees. The director
    does not care much about its reporting being unavailable, or even destroyed, since
    it is not very useful at the moment and most of the numbers were false anyway.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着业务流程的进行和预算不可扩展，你被分配的任务是“*在汽车行驶时更换轮胎*”。IT系统可能会有一些短暂的停顿，但不会持续很长时间。数据必须被清理，但作者和书籍的数据库必须在过程中保持可用，因为它们是公司大多数员工日常工具。经理并不太关心报告不可用或甚至被破坏，因为目前它并不很有用，而且大多数数字本来就不准确。
- en: In the next chapters, we will put ourselves in the skin of an engineer asked
    to carry out this foundational task and design the different components of the
    renewed IT system, and decide how its services should operate and what business
    domains should be designed. After that, we will implement all this and progressively
    transform the information system. But for now, we have to transform the theory
    learned in the previous chapters into principles that will guide us along the
    way. SOLID principles are a great set of principles that apply perfectly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将置身于一个被要求执行这项基础任务并设计更新后的IT系统不同组件的工程师的角色，并决定其服务应该如何运行以及应该设计哪些业务领域。之后，我们将实施所有这些，并逐步转型信息系统。但到目前为止，我们必须将前几章学到的理论转化为将指导我们前进的原则。SOLID原则是一套非常适合的原则。
- en: SOLID principles and application to systems of whatever scale
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则及其在任意规模系统中的应用
- en: SOLID principles are important principles that apply to software applications,
    but they happen to also apply very well to software systems in general, so we
    will be able to use them to structure our project. We are going to explain the
    five principles one by one, together with how they apply to the transformation
    requested by DemoEditor and the design of its new information system. As this
    is a book about information systems and not software development, even though
    we will eventually build some implementations, I will not describe the principles
    from the coding point of view, but only briefly their main idea and, with more
    details, their translation into systems design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是适用于软件应用的重要原则，但它们也恰好非常适合软件系统的一般应用，因此我们可以使用它们来构建我们的项目。我们将逐一解释这五个原则，以及它们如何应用于DemoEditor要求的转型和其新信息系统的设计。由于这是一本关于信息系统的书，而不是关于软件开发的书，尽管我们最终会构建一些实现，但我将不会从编码的角度描述这些原则，而只是简要地介绍它们的主要思想和，更详细地，它们在系统设计中的转化。
- en: Single responsibility principle
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: This principle states that a class, or in our case, a module of an information
    system, should do one and only one thing. This is quite wide as a definition but
    it can be narrowed down a bit by stating that an entity should have only one business
    reason to change. If the same class should be upgraded when there are changes
    in the author’s management and the book’s management, there is a problem regarding
    this single responsibility principle and the class should be decomposed into at
    least two smaller ones.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，一个类，或者在我们的情况下，一个信息系统模块，应该只做一件事，并且只做一件事。这个定义相当宽泛，但可以通过指出一个实体应该只有一个业务理由来改变来稍微缩小范围。如果同一个类在作者管理和书籍管理发生变化时应该升级，那么这与单一职责原则有关，并且这个类应该被分解成至少两个更小的类。
- en: This principle is obviously easy to translate into an information system where
    it applies directly to modules, whether they are services, components, or other
    grains of entire systems (we will come back to the management of granularity in
    the next chapter). Each entity in the system should do one thing and only one.
    If this is observed from the point of view of the software applications composing
    the system, that means that each application should be in charge of only one business
    domain of the system. Since we manage authors, books, sales, and so on, we should
    indeed find one application for each of these. This notion of a business domain
    is not very precise for now but again, we will come to this in a future chapter,
    namely [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318), detailing the **domain-driven
    design** approach and the concepts of domain and bounded context.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则显然很容易翻译到适用于信息系统的场景中，它直接应用于模块，无论是服务、组件还是整个系统的其他部分（我们将在下一章回到粒度管理的话题）。系统中的每个实体都应该只做一件事，并且只做一件事。如果从组成系统的软件应用的角度来看，这意味着每个应用都应该负责系统的一个业务领域。由于我们管理作者、书籍、销售等等，我们确实应该为这些找到各自的应用。这个业务领域的概念现在还不够精确，但同样，我们将在未来的章节中回到这个话题，即[*第9章*](B21293_09.xhtml#_idTextAnchor318)，详细阐述**领域驱动设计**方法和领域以及边界上下文的概念。
- en: For now, let’s just agree that a business domain needs its own application.
    If you are thinking microservices, yes, this is the track we are going to follow
    but bear with me, as this “micro” qualification is not always necessary and we
    would rather talk about “services” (with a clearer definition in [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需同意一个业务领域需要其自己的应用程序。如果你在考虑微服务，是的，我们将遵循这条路线，但请耐心等待，因为这个“微”的限定条件并不总是必要的，我们更愿意谈论“服务”（在[*第8章*](B21293_08.xhtml#_idTextAnchor271)中有更清晰的定义）。
- en: 'This first principle may sound very simple (and it is in its expression), but
    its implication can be very profound. To give just one example of the complexities
    we will have to deal with in our sample application, let’s unroll the case where
    a service depends on another, like in the case of the relationship of the “author
    of a book.” As said before, author and book management are two separate responsibilities.
    But how should we deal with the relationships between both? Is it another service?
    In any case, when someone reads a book entity from the service, how should the
    author of the book be retrieved and displayed? We can ask the same question the
    other way around: if someone calls the API on a given author, how should we display
    the list of books this author has participated in writing?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个首要原则听起来可能非常简单（它的表述确实如此），但其含义可能非常深远。为了给出我们将在示例应用程序中必须处理的复杂性的一个例子，让我们展开一个服务依赖于另一个服务的案例，比如“书籍作者”的关系。正如之前所说，作者和书籍管理是两个不同的责任。但我们应该如何处理两者之间的关系？是另一个服务吗？无论如何，当有人从服务中读取书籍实体时，应该如何检索和显示书籍的作者？我们可以反过来问相同的问题：如果有人调用特定作者的API，我们应该如何显示这位作者参与编写的书籍列表？
- en: Diving into this last scenario is useful to get a better grasp of the concept
    of responsibility. Imagine that there are two separate services, each with its
    own database since they are supposed to be independent. Now, a user calls the
    API with a `GET` word on a particular book, let’s say `https://demoeditor.org/api/books/123456`.
    The module is indeed responsible for sending the book title, ISBN/EAN number,
    and some other attributes of the book. How about the information about the author?
    This is where the principle of responsibility helps to draw the line. The editors
    would tell you that, most of the time, when they get the information about the
    book, they need to know the author, but only by their identifier and some main
    data, such as their first and last name. This is the responsibility of the book
    service. And if you ask your product owners again (the editors, as they are the
    ones who will be using the information system), and they need some more data,
    they will turn to the `/api/authors` service to get it, using, of course, the
    identifier provided by the initial answer from the `/api/books` service. Thus,
    that data is the only responsibility of the second service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨这个最后场景有助于更好地理解责任的概念。想象有两个独立的服务，每个服务都有自己的数据库，因为它们应该独立。现在，一个用户使用`GET`请求调用特定书籍的API，比如说`https://demoeditor.org/api/books/123456`。模块确实负责发送书籍标题、ISBN/EAN号码和书籍的一些其他属性。那么关于作者的信息呢？这就是责任原则帮助划清界限的地方。编辑们会告诉你，大多数时候，当他们获取书籍信息时，他们需要知道作者，但只需要他们的标识符和一些主要数据，比如他们的首字母和姓氏。这是书籍服务的责任。如果你再次询问你的产品所有者（编辑们，因为他们将是使用信息系统的人），并且他们需要更多数据，他们会转向`/api/authors`服务来获取，当然使用`/api/books`服务提供的初始答案中的标识符。因此，这些数据是第二个服务唯一的责任。
- en: Each reader who knows about the principles of good database design is certainly
    suffocating already, considering that this approach necessitates data duplication.
    Indeed, since `/api/authors` is responsible for the whole data for the authors,
    including of course their first name and last name, that means that, if `/api/books`
    is responsible for providing, upon request, the identifier, first name, and last
    name of the author of the given book, the rule of non-duplication is broken! And
    this is where the concept of responsibility is interesting and should be dug into
    deeper. How about considering the following share of responsibilities?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个了解良好数据库设计原则的读者可能已经感到窒息了，考虑到这种方法需要数据重复。确实，由于`/api/authors`负责作者的全部数据，包括当然的首字母和姓氏，这意味着如果`/api/books`负责在请求时提供给定书籍的标识符、首字母和姓氏，那么非重复规则就被打破了！而且这正是责任概念有趣且应该深入挖掘的地方。我们考虑以下责任分配如何？
- en: 'The `/api/authors` service is responsible for providing always up-to-date data
    about an author, including their first name and last name. This means that it
    is the reference source of truth for the authors: anyone who needs the latest,
    best-so-far information about an author should turn to this service, which will
    be responsible for providing it on time. Since it is the reference for this data,
    the service would certainly provide it with a value date, as the data may change
    over time. For example, an author could change their last name after getting married;
    this should be tracked by the author service, as it is responsible for the data
    about authors and their integrity.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`/api/authors` 服务负责提供关于作者的始终是最新的数据，包括他们的名和姓。这意味着它是作者的真实参考来源：任何需要关于作者最新、最佳信息的人都应该转向这个服务，该服务将负责及时提供这些信息。由于它是这些数据的参考，该服务当然会提供带有价值日期的数据，因为数据可能会随时间变化。例如，作者结婚后可能会更改他们的姓氏；作者服务应该跟踪这一点，因为它负责作者及其数据完整性。'
- en: The `/api/books` service is responsible for providing the same service for books,
    which means the same level of engagement on the book title, identifiers, and so
    on. But when talking about the author of a book, this is a relationship to another
    reference service, so the only data it is responsible for in terms of service
    is to point at the right entity in the other service. And this raises two interesting
    questions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`/api/books` 服务负责为书籍提供相同的服务，这意味着在书名、标识符等方面有相同的服务水平。但当谈到一本书的作者时，这涉及到另一个参考服务的关系，因此它所负责的服务数据仅仅是指出在另一个服务中的正确实体。这提出了两个有趣的问题。'
- en: 'The first one is functional: is the link supposed to simply point to a given
    author, or is it supposed to point to the value of an author *at a given point
    in time*? This necessitates answering some business rules: if an author gets married
    between the first and second editions of a book, should the author’s name as it
    appears on the book change? And if so, how should the registered copyright be
    adjusted? And is the same true for a simple reprint of the original edition of
    the book?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是功能性的：链接应该是简单地指向一个特定的作者，还是应该指向作者在特定时间点的值？这需要回答一些业务规则：如果作者在第一版和第二版之间结婚，书籍上出现的作者名字应该改变吗？如果是这样，如何调整注册的版权？对于书籍原始版本的简单重印，情况是否相同？
- en: 'The second one is more technical: if the book service stores the link to the
    author service and the latter is not available when needed, what happens? If a
    copy of the “usual” data (first name and last name) has been stored in the book
    service, no problem since it is now *independent* of the second one. But this
    comes back to the functional question again: if the name should not be changed
    on the book after an author gets married, no problem, and it is even better, as
    the local copy will prevent the difficulty of reaching the author’s service with
    the date of value to retrieve the “old” data. And if the name should evolve, it
    may be better to temporarily fall back on the old one rather than providing just
    the machine-readable identifier; only editors would know…'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是更技术性的：如果书籍服务存储了作者服务的链接，而后者在需要时不可用，会发生什么？如果“通常”的数据（名和姓）已经在书籍服务中存储，那么没有问题，因为它现在与第二个服务是*独立的*。但这又回到了功能问题：如果作者结婚后书籍上的名字不应该改变，那么没问题，甚至更好，因为本地副本将防止在具有检索“旧”数据的日期时难以访问作者服务。如果名字应该演变，可能最好是暂时退回到旧名字，而不是仅仅提供机器可读的标识符；只有编辑者才会知道……
- en: I hope this example, though complex, has shown you what we mean by the word
    *responsibility*. It is admittedly complex but, remember, everything we talked
    about was linked to business complexity and is not accidental. Indeed, talking
    about value date and the importance of history in reference to data management
    may sound overly complex because it is not very often dealt with in current information
    systems. But this is a real problem and this lack of reflecting on the actual
    functional reality is a problem as it prevents reflecting all business rules!
    That does not mean that the software that will be constructed based on this reflection
    will take all this complexity into account. In a true Agile way, you will certainly
    start with something very simple. But this deep understanding of the functional
    complexity ensures that the software will be easy to evolve in the future and
    that you will not be stuck at some point of implementation because the software
    is not aligned with the business.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个例子，尽管复杂，已经向你展示了我们所说的“责任”一词的含义。诚然，这很复杂，但请记住，我们谈论的一切都与商业复杂性相关，并非偶然。确实，谈论价值日期和参考数据管理中历史的重要性可能听起来过于复杂，因为这在当前的信息系统中并不常见。但这确实是一个真实的问题，而且这种对实际功能现实的缺乏反思也是一个问题，因为它阻止了对所有业务规则的反思！这并不意味着基于这种反思构建的软件将考虑到所有这些复杂性。在真正的敏捷方式中，你肯定会从非常简单的东西开始。但这个对功能复杂性的深入理解确保了软件在未来将易于演化，而且你不会在某个实施点上卡住，因为软件与业务不匹配。
- en: Open/closed principle
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: 'The **open/closed principle** starts with a paradox in its very expression,
    which makes it strange at first sight: how can a module be open and closed at
    the same time? The comprehension of this principle is very important to create
    systems that will evolve because it states what should remain closed and what
    should be open to change for this evolution to work as smoothly as possible.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**在其表达方式上本身就包含了一个悖论，这使得它一开始看起来很奇怪：一个模块怎么可能同时是开放的和封闭的？理解这个原则对于创建将不断演化的系统非常重要，因为它指出了什么应该保持封闭，什么应该开放以改变，以便这种演化尽可能顺利地进行。'
- en: When applied to object-oriented programming, the open/closed principle states
    that a class should be open to extension, but closed to modification. Encapsulation
    and private members are used to prevent any instance in the program from modifying
    directly the state of another instance; otherwise, it would be very difficult
    to follow what happens when executing the program. Even debugging would be complicated
    if there is no way to track what class modifies the state of another one. This
    is why a class keeps its members private and only opens some public functions
    to allow only some changes in its state, in a way that is controlled by its own
    code, following its own rules. This is the closed part of the principle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于面向对象编程时，开放/封闭原则指出，一个类应该对扩展开放，但对修改封闭。封装和私有成员用于防止程序中的任何实例直接修改另一个实例的状态；否则，在执行程序时跟踪发生的事情将非常困难。如果没有办法跟踪哪个类修改了另一个类的状态，那么调试也会变得复杂。这就是为什么一个类保持其成员私有，并且只开放一些公共函数，以允许对其状态的某些更改，这种方式由其自己的代码控制，遵循其自己的规则。这是原则的封闭部分。
- en: But a class, in general, is not marked as `final` to let another class inherit
    from it and specialize the functions that are marked as `virtual`. The inheriting
    class can also add some data members, in addition to accessing the one from the
    inherited class that is marked as `protected` (or, of course, `public`). Again,
    the class controls what can be overridden and what cannot, but at least it is
    open to an extension of its behavior by another class. This is the open part of
    the principle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常情况下，一个类不会被标记为`final`以允许另一个类从它继承并专门化标记为`virtual`的功能。继承的类还可以添加一些数据成员，除了访问标记为`protected`（或者当然，`public`）的从继承类之外。再次强调，类控制着什么可以被覆盖，什么不能，但至少它对另一个类扩展其行为是开放的。这是原则的开放部分。
- en: 'Applying this principle to information systems does not imply a big change
    in reflection, as the services replace the classes, and the techniques to extend
    or protect only vary from the practical point of view. If we continue with examples
    where services are REST APIs, we can draw a parallel between the members of a
    class and the data that is persisted by the implementation of an API contract:
    nothing but the service can modify this data, as only the implementation has access
    to the persistence used (a database or anything else). Of course, some API methods
    may allow some specific modifications to be carried from the API clients, but
    the API implementation controls this and applies business rules to ensure the
    modification is carried as it wants (or maybe rejected, by the way). This is the
    closed part of the principle applied to a module of information systems, and it
    is quite obvious in its resemblance to the application in a class.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将此原则应用于信息系统并不意味着在反思上发生重大变化，因为服务替换了类，扩展或保护的技术仅从实际观点来看有所不同。如果我们继续以服务是REST API的例子为例，我们可以在类的成员和API合同实现持久化的数据之间建立平行关系：只有服务可以修改这些数据，因为只有实现可以访问持久化使用的（数据库或其他）。当然，一些API方法可能允许从API客户端传递一些特定的修改，但API实现控制这一点，并应用业务规则以确保修改按其意愿进行（或者，顺便说一句，可能被拒绝）。这是原则在信息系统模块中的应用的封闭部分，它在与类应用中的相似性方面非常明显。
- en: 'The implementation of the open part of the principle on an API is trickier,
    as the behavior of an API can be extended in many ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在API上实现开放原则的部分更为复杂，因为API的行为可以通过多种方式扩展：
- en: One of the ways to do so is to create an API that will extend the initial API
    contract. Mechanisms exist in the OpenAPI grammar to implement polymorphism and
    it is also possible to aggregate types in such a way that the new one contains
    the initial type and all its content.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是通过创建一个将扩展初始API合同的API。OpenAPI语法中存在实现多态的机制，也可以以这种方式聚合类型，使得新的类型包含初始类型及其所有内容。
- en: Another way is to create an API that replaces the exposition of the old implementation,
    but still relies on it for all the standard data, and then provides its own data
    in addition. If done carefully, the extended API may even be fully compatible
    with the initial API contract, since it only adds new data (and if it just passes
    the initial data without changing any behavior, it even complies with the Liskov
    substitution principle, which we will see shortly).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个API，它替换了旧实现的展示，但仍然依赖于所有标准数据，并在此基础上提供自己的数据。如果做得仔细，扩展后的API甚至可能与初始API合同完全兼容，因为它只添加了新的数据（如果它只是传递初始数据而不改变任何行为，甚至符合我们很快将看到的Liskov替换原则）。
- en: A third option is to use an API gateway to expose the updated contract and implement
    the mixing of data coming from the original API and the additional data coming
    from another service dedicated to its storing and manipulation. This approach
    is a bit closer to the principle of inheritance.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种选择是使用API网关来公开更新的合同，并实现来自原始API和来自另一个服务的附加数据的混合，该服务专门用于其存储和处理。这种方法在继承原则上更接近。
- en: 'These three approaches are schematized as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法可以概括如下：
- en: "![Figure 6.1 – Open/closed\uFEFF approaches to APIs](img/Figure_6.1_B21293.jpg)"
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – API的开放/封闭方法](img/Figure_6.1_B21293.jpg)'
- en: Figure 6.1 – Open/closed approaches to APIs
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – API的开放/封闭方法
- en: Liskov substitution principle
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: The `Display`, that would implement a `print` function that sends black text
    on a white paper (through a printer, a screen, or anything else; no importance
    here). Let’s now suppose that a class called `ColorDisplay` specializes in the
    `Display` class and proposes a new function signature called `print` again, but
    accepts a parameter named `color` that allows the user to specify any color they
    want. How should the parameterless `print` function behave? The inheriting class
    will certainly point to its new and improved `print` function. And in this case,
    what should be the default color passed to this function? If you answer “black,
    of course,” you know what the Liskov substitution principle is about not surprising
    the user of a class, and ensuring them that the behavior is as expected.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display`接口将实现一个`print`函数，该函数在白色纸张上打印黑色文本（通过打印机、屏幕或其他任何东西；这里不重要）。现在假设有一个名为`ColorDisplay`的类专门化`Display`类，并再次提出一个新的函数签名`print`，但接受一个名为`color`的参数，允许用户指定他们想要的任何颜色。无参数的`print`函数应该如何表现？继承的类肯定会指向其新的改进后的`print`函数。在这种情况下，应该将什么默认颜色传递给这个函数？如果你回答“当然是黑色”，你就知道Liskov替换原则是关于不让类的用户感到惊讶，并确保他们知道行为是预期的。'
- en: The same goes for services inside a modular information system. Again, we will
    use APIs, as this is the standard way to decompose modules in such a system. When
    an API contract is provided to you, it states what method can be called, with
    which verbs, and through which URL; it also states the exact name of the attributes
    that you can send or that you will receive. But you may very well respect the
    letter of the contract API without respecting its spirit and this is what the
    Liskov substitution principle is about.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模块化信息系统中的服务也是如此。再次，我们将使用API，因为这是在这种系统中分解模块的标准方式。当你得到一个API合约时，它声明了可以调用哪些方法，使用哪些动词，以及通过哪个URL；它还声明了你可以发送或接收的属性的准确名称。但你完全可以尊重API合约的字面意思而不尊重其精神，这正是Liskov替换原则所涉及的。
- en: 'Let’s translate our previous example from object-oriented programming into
    API services, and imagine one can use version 1.0 of `/api/print` to process some
    text that will be sent to the device in black color. If using version 1.1 of an
    `/api/print` API, with the support of `/api/print?color=[HEX-VALUE]`, we will
    definitely expect that pointing our old client to the new API results in the production
    of black text. In terms of the stream between the API contract and its implementation,
    this can be pictured as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前面向对象编程的示例翻译成API服务，并想象一下，有人可以使用`/api/print`的1.0版本来处理将被发送到设备上的黑色文本。如果使用`/api/print`
    API的1.1版本，并且支持`/api/print?color=[HEX-VALUE]`，我们肯定会期望将我们的旧客户端指向新的API会导致黑色文本的产生。在API合约与其实现之间的流中，这可以描述如下：
- en: "![Figure 6.2\uFEFF – Liskov substitution](img/Figure_6.2_B21293.jpg)"
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – Liskov替换原则](img/Figure_6.2_B21293.jpg)'
- en: Figure 6.2 – Liskov substitution
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – Liskov替换原则
- en: Interface segregation principle
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口分离原则
- en: The `Rectangle` class implements the `IShape` interface. This means that `Rectangle`
    would have to implement the `getSurface` and `getPerimeter` methods but also some
    methods such as `drawShape` and so on. If the only interesting thing in the program
    is to compute the mathematical characteristics of shapes, then the right approach
    would be to split `IShape` into `IGeometricalShape` and `IDrawableShape` (i.e.,
    segregate the interfaces) for the classes to implement only the interface they
    need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`类实现了`IShape`接口。这意味着`Rectangle`必须实现`getSurface`和`getPerimeter`方法，还必须实现一些方法，如`drawShape`等。如果程序中唯一有趣的事情是计算形状的数学特性，那么正确的方法是将`IShape`拆分为`IGeometricalShape`和`IDrawableShape`（即分离接口），以便类只实现它们需要的接口。'
- en: The same goes for API contracts. To come back to our book service, it is better
    to separate two contracts, one for the book characteristics and one for the book
    sales characteristics, even if the same implementation will expose the two interfaces,
    one behind `/api/books` and the other behind `/api/books/sales`, rather than force
    the implementation of all functions by the use of only one contract.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API合约也是如此。回到我们的图书服务，最好将两个合约分开，一个用于图书特性，另一个用于图书销售特性，即使相同的实现会公开两个接口，一个位于`/api/books`之后，另一个位于`/api/books/sales`之后，而不是通过仅使用一个合约来强制实现所有函数。
- en: Though it is always possible (and more acceptable in an API than in a class)
    to respond with a `NotImplemented` message, the separation into two interfaces
    also makes it easier to introduce versions. If the sales interface was not correctly
    defined in version 1.0 and a major, backward-compatible rewrite is necessary,
    it will be possible to continue exposing the book’s characteristics (potentially
    used by most of the clients) without any change.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然总是可能（并且在API中比在类中更可接受）以`NotImplemented`消息响应，但将接口分为两个也使得引入版本更容易。如果销售接口在1.0版本中没有正确定义，并且需要进行重大的、向后兼容的重写，那么将能够在不进行任何更改的情况下继续暴露书籍的特性（可能被大多数客户端使用）。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Backward compatibility** is the quality of a new version of an API where
    all calls used in the previous version work exactly with the same result on the
    new one.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**向后兼容性**是API新版本的质量，其中所有在先前版本中使用的调用在新版本上工作结果完全相同。'
- en: 'The interface segregation even makes it possible (and easy) to expose three
    API contracts, namely `/api/books`, `/api/books/sales`, and `/api/books/sales/v2`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离甚至使得暴露三个API合约成为可能（并且很容易），即`/api/books`、`/api/books/sales`和`/api/books/sales/v2`：
- en: '![Figure 6.3 – Interface segregation](img/Figure_6.3_B21293.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 接口隔离](img/Figure_6.3_B21293.jpg)'
- en: Figure 6.3 – Interface segregation
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 接口隔离
- en: Though quite obvious in the explanation, this principle is sadly often forgotten
    in existing APIs. This is particularly so because editors tend to provide functions
    in the frameworks that generate the OpenAPI contract from the implementation,
    instead of following the contract-first approach (which is admittedly more complicated,
    but the only one that leads to proper, business-aligned APIs). Since the contract
    is automatically generated from the whole source code, the generators do not make
    any difference between the different methods and resources and produce a single,
    monolithic contract that does not respect the interface segregation principle.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在解释中这一点相当明显，但遗憾的是，这个原则在现有的API中经常被遗忘。这尤其是因为编辑倾向于在从实现生成OpenAPI合约的框架中提供函数，而不是遵循合约优先的方法（虽然这确实更复杂，但这是唯一能够产生正确、与业务对齐的API的方法）。由于合约是从整个源代码自动生成的，生成器不会区分不同的方法和资源，产生一个单一、不可分割的合约，该合约不遵守接口隔离原则。
- en: Dependency inversion approach
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置方法
- en: 'The **dependency inversion approach** is named as such because it goes against
    the usual way of thinking about dependency. Imagine that we have a reporting module
    and another module that provides the data to be used for reporting purposes. Naturally,
    we tend to think that the reporting module should depend on the data module in
    technical terms because this is how it works from the functional point of view.
    This is a rare case where aligning the technical design directly with the functional
    concepts is not good enough. If we want to ensure low coupling, we have to make
    one more step and add some indirection to a common interface that both of the
    services will depend on:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置方法**之所以被称为如此，是因为它与传统关于依赖的思考方式相反。想象一下，我们有一个报告模块和另一个提供用于报告目的的数据的模块。自然地，我们倾向于认为从功能角度来看，报告模块应该在技术上依赖于数据模块。这是一个罕见的情况，其中将技术设计直接与功能概念对齐并不足够好。如果我们想确保低耦合，我们必须再迈出一步，向两个服务都将依赖的共同接口添加一些间接性：'
- en: Just like the `Data` class would implement `IData`, the `/api/data` service
    should implement the API contract defined in the data OpenAPI file.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像`Data`类会实现`IData`接口一样，`/api/data`服务应该实现数据OpenAPI文件中定义的API合约。
- en: And like the `Reporting` class would use the `IData` source (and not directly
    the `Data` implementation) to prevent hard coupling, the `/api/reporting` service
    would not directly call the `/api/data` service but the URL provided to it by
    configuration, providing that it implements the data OpenAPI contract. In object-oriented
    programming, this will typically be done by injection. In a service, depending
    on the orchestration mechanism, this can be realized through an API gateway, the
    ingress exposition, or even a (more complicated) service mesh.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像`Reporting`类会使用`IData`源（而不是直接使用`Data`实现）来防止硬耦合一样，`/api/reporting`服务不会直接调用`/api/data`服务，而是调用配置提供的URL，前提是它实现了数据OpenAPI合约。在面向对象编程中，这通常通过注入来完成。在服务中，根据编排机制，这可以通过API网关、入口暴露或甚至（更复杂的）服务网格来实现。
- en: 'The following diagram has already been used in [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069),
    but it is particularly relevant here, as it shows visually the dependency inversion
    principle in information systems: instead of a dependency of one software module
    on another, each of the two modules working together points at the same business
    contract definition (which is purely functional), one to implement it, the other
    to consume it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图已经用于[*第3章*](B21293_03.xhtml#_idTextAnchor069)，但它在这里特别相关，因为它直观地展示了信息系统中的依赖倒置原则：不是软件模块之间的依赖，而是两个模块共同工作，指向同一个业务合同定义（纯粹是功能性的），一个来实现它，另一个来消费它：
- en: '![Figure 6.4 – Coupling on the four layers diagram](img/Figure_6.4_B21293.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 四层耦合图](img/Figure_6.4_B21293.jpg)'
- en: Figure 6.4 – Coupling on the four layers diagram
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 四层耦合图
- en: Let’s move on to the next section where we’ll analyze the SOLID principle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一节，我们将分析SOLID原则。
- en: Critical analysis of SOLID
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对SOLID原则的批判性分析
- en: Though I have realized in time (certainly like many others) that the SOLID principles
    apply almost as well to information systems as to object-oriented classes and
    interfaces, some parts deserve discussion. Indeed, like for any other principle,
    a strict, not thoughtful, application may lead to problems. And even when the
    principles apply well to a given context, they may have strong side effects that
    make them ultimately more harmful than helpful. The necessary measured approach
    has led to lots of polemics and you must be careful in handling these principles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我及时意识到（当然像许多人一样）SOLID原则几乎适用于信息系统，就像适用于面向对象的类和接口一样，但有些部分值得讨论。确实，对于任何其他原则，严格的、不考虑周全的应用可能会导致问题。即使原则在特定情境中适用得很好，它们也可能有强烈的副作用，最终使它们比有帮助更有害。必要的谨慎方法导致了大量的争论，你必须小心处理这些原则。
- en: Limits of the separation of responsibilities
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 职责分离的局限性
- en: The first (and maybe most important) principle, namely the one about separation
    of responsibilities, is sometimes hard – perhaps impossible in some cases – to
    apply to services or high-level modules of an application. With classes, there
    is always the possibility to decompose a class without much impact on the whole
    application, once compiled. Services and modules do not present this ease of composition
    because they come with additional constraints such as exposition, endpoints, coding
    interfaces, documentation, integration subsystems, and so on. All this takes a
    toll on the decomposition, and this is the reason why people who are not careful
    with microservices and decompose them too much in their systems end up spending
    more time evolving them than if they had stayed on a monolith architecture. I
    am not going to talk again about granularity because the subject was already developed
    in the previous chapters, but this is clearly something that must be pondered
    and can limit the reach of the principle of separation of responsibilities, or
    at least its depth.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（也许是最重要的）原则，即职责分离原则，有时很难应用——在某些情况下可能甚至不可能——应用到服务或应用的高级模块中。对于类来说，一旦编译完成，总是有可能在不影响整个应用的情况下分解一个类。服务和模块并不提供这种易于组合的特性，因为它们附带额外的约束，如暴露、端点、编码接口、文档、集成子系统等。所有这些都对分解产生了影响，这也是为什么那些不谨慎对待微服务并在系统中过度分解它们的人最终花费更多时间在它们的演变上，而不是如果他们坚持使用单体架构的话。我不会再次谈论粒度，因为这个问题已经在之前的章节中讨论过了，但这是显然需要深思的问题，可能会限制职责分离原则的适用范围，或者至少是其深度。
- en: 'Another difficulty is not linked to how deeply you can separate the responsibilities,
    but how intricate some of them are sometimes, even at a relatively high level.
    This is, for example, a huge difficulty in “micro-frontend” architectures, and
    I am not talking about the problem associated with how “micro” the frontend component
    is. The simple fact that visual components present functions, but also have a
    visual impact, is a huge difficulty in making them independent. This is what is
    exposed, for example, in [https://jonhilton.net/good-blazor-components/](https://jonhilton.net/good-blazor-components/):
    by delegating the content of a Blazor component to another sub-component (in the
    example of the article, using the `ChildContext` property to include a `Card`
    instance), you indeed externalize the responsibility of displaying the inner part
    of a visual component. But that does not mean it will not have an impact, as the
    rendering of the subcomponent will necessarily have an impact on the one above
    it. Indeed, either the container fixes a size for the child and then takes responsibility
    for its display, or the container – in a purely responsive design manner – lets
    the child component adapt its display. In this case, its own size will be impacted
    by its child, which also ruins the independence that was supposed to be achieved
    by the principle of separation of responsibilities.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个困难与你能将责任分离得多深无关，而是与某些责任有时多么复杂有关，即使在相对较高的层面上也是如此。例如，这是“微前端”架构中的一个巨大困难，我并不是在谈论与前端组件“微”相关的那个问题。简单的事实是，视觉组件不仅呈现功能，还具有视觉影响，这在使它们独立方面是一个巨大的困难。例如，在[https://jonhilton.net/good-blazor-components/](https://jonhilton.net/good-blazor-components/)中暴露了这一点：通过将Blazor组件的内容委托给另一个子组件（在文章的例子中，使用`ChildContext`属性包含一个`Card`实例），你确实将显示视觉组件内部部分的责任外部化了。但这并不意味着它不会产生影响，因为子组件的渲染必然会影响其上方的组件。事实上，容器要么为子组件固定一个大小并承担其显示的责任，要么以纯响应式设计的方式让子组件调整其显示。在这种情况下，它自己的大小将受到其子组件的影响，这也破坏了通过责任分离原则本应实现的独立性。
- en: The intellectual solution for this is to consider that each component has the
    responsibility for its content, but not for its display and that this is the responsibility
    of the display engine in the browser. It may not be very satisfying because it
    comes back to a single point of execution for the whole frontend, which we were
    trying to make modular and easy to evolve, but at least the low coupling between
    the components has been achieved, though on a limited perimeter. This is one of
    the many compromises one will have to make when designing information systems
    and modular applications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，智力解决方案是考虑每个组件对其内容的负责，但不负责其显示，而这是浏览器中显示引擎的责任。这可能并不令人非常满意，因为它回到了整个前端的单一点执行，这是我们试图使其模块化和易于演进的目标，但至少在有限的范围内实现了组件之间的低耦合。这是在设计信息系统和模块化应用程序时必须做出的许多妥协之一。
- en: About the polemics on monoliths
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于单体架构的争论
- en: This chapter may be a good place to talk about the long-held discussion about
    “going back to monoliths,” a reaction to the drawbacks of microservices that have
    been very much observed in the discussions of the communities of software architects.
    In summary, the microservice approach is considered harmful and some people recommend
    going back to monolith applications. This is sadly another example of how polarized
    debates are nowadays, because both approaches (and the huge spectrum between them)
    have value, depending on your needs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能是讨论关于“回归单体架构”这一长期争论的好地方，这是对在软件架构社区讨论中观察到的微服务缺点的一种反应。总的来说，微服务方法被认为是有害的，有些人建议回归单体应用程序。这遗憾的是又是一个当今极端辩论的例子，因为这两种方法（以及它们之间巨大的范围）都有价值，这取决于你的需求。
- en: No one serious has ever pretended microservices were the best solution for every
    architecture. In fact, right from the beginning, most articles explaining the
    approach insisted that they were only adapted to some specific circumstances (high
    volumes, frequent modification of the application, clear cut between teams in
    charge of different modules, and so on). However, some people did not take this
    into account and now complain that microservices were not the right fit for their
    case. Even worse, in a binary and not very thought-out reaction, they discard
    the whole principle of microservices and advertise a so-called “return to the
    monolith.” Any sensible engineer in this case would simply spot the well-known
    pendulum movement where one extreme chases another one. And the solution in this
    case is not in either of them or continuously balancing between one and the other,
    but simply reaching the nice equilibrium between them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 没有哪个严肃的人曾经假装微服务是适合所有架构的最佳解决方案。事实上，从一开始，大多数解释这种方法的文章就坚持认为，它们只适用于某些特定的环境（高流量、频繁修改应用程序、负责不同模块的团队之间有明确的界限等等）。然而，有些人没有考虑到这一点，现在抱怨微服务并不适合他们的案例。更糟糕的是，在一种二元且不太深思熟虑的反应中，他们摒弃了微服务的整个原则，并宣传所谓的“回归单体”。在这种情况下，任何理智的工程师都会简单地发现一个众所周知的摆动运动，其中一种极端追逐另一种极端。在这种情况下，解决方案既不在其中任何一个，也不在两者之间不断平衡，而只是在它们之间达到一个美好的平衡。
- en: In the case of software applications, what do we call a monolith? An application
    made of a single process? No, otherwise that would mean that even the smallest
    application such as `cd` or `exit` should be considered as such. The term has
    been coined precisely to describe single applications that were in charge of too
    many business features, which made them too heavy to have a nice evolution or
    fit the use they were designed for.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件应用程序的情况下，我们称什么为单体？一个由单个进程组成的程序？不，否则这意味着即使是像`cd`或`exit`这样的最小应用程序也应该被视为这样。这个术语正是用来描述那些负责太多业务功能、变得过于沉重以至于无法良好演变或适应其设计用途的单个应用程序。
- en: The situation talked about in the articles on the so-called death of microservice
    architecture and going back to monolith simply do not talk about the right subject,
    which is the granularity of services. Sure, the very small grain of microservices
    did not satisfy their information system needs. But that simply means the grain
    was too fine. Going back to the coarsest grain one can have (the monolith) simply
    displays a lack of depth in the comprehension of the problem. An engineer approach
    to this would be to search for the right granularity of the services. As said
    in [https://codeopinion.com/biggest-scam-in-software-dev-best-practices/](https://codeopinion.com/biggest-scam-in-software-dev-best-practices/),
    the choice is not only between “Amazon is doing it, so let’s do it” and “we are
    not Amazon so we should not do it” – knowledge of the business and analysis of
    the context only will tell you where you should place yourself between the two.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所谓微服务架构的死亡和回归单体的文章中讨论的情况，根本就没有涉及到正确的话题，那就是服务的粒度。当然，微服务的非常小的粒度并没有满足他们的信息系统需求。但这仅仅意味着粒度太细。回到最粗的粒度（单体）只是显示了对于问题的理解深度不足。工程师处理这个问题的方式是寻找服务正确的粒度。正如[https://codeopinion.com/biggest-scam-in-software-dev-best-practices/](https://codeopinion.com/biggest-scam-in-software-dev-best-practices/)中所述，选择不仅仅是在“亚马逊在做，所以我们也做”和“我们不是亚马逊，所以我们不应该做”之间——对业务和上下文的分析知识才会告诉你你应该如何在这两者之间定位自己。
- en: It just happens that there is an existing design method called domain-driven
    design that is the perfect method to find out the right granularity of services
    for an information system. It also relates strongly to the principles of business/IT
    alignment, as it states how business domains can be cut into internally cohesive,
    externally low-coupled modules. Everything we will be doing in the design of our
    demo application will be an illustration of this research of the right granularity,
    based on the business functional needs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好存在一种称为领域驱动设计的设计方法，这是找到信息系统服务正确粒度的完美方法。它也与业务/IT对齐的原则密切相关，因为它说明了业务领域如何被切割成内部紧密耦合、外部低耦合的模块。我们在我们的演示应用程序设计中所做的一切，都将是对这种正确粒度研究的说明，基于业务功能需求。
- en: Beware of unintended coupling
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心无意中的耦合
- en: 'One last piece of advice on the separation of responsibilities (this first
    principle is definitely causing lots of discussions!): once you have established
    a clear cut of responsibilities based on the **business capability map**, you
    are not done with the separation of responsibilities, as it is very easy to recreate
    coupling afterward in the technological transformation of the functions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于职责分离的一些建议（这个首要原则无疑引发了众多讨论！）：一旦你根据**业务能力图**明确划分了职责，职责分离的工作并未完成，因为在功能的技术转型过程中，很容易重新创建耦合。
- en: I will give one simple example of such a problem because it is very representative
    of the trap I described. Imagine we create our demo application with an API for
    the books, an API for the book sales (possibly exposed under the same URL, but
    still independent in terms of contract), and an API for the authors. The director
    of the company may want, at some point, a report on how the geographical origin
    of the authors impacts the localization of their sales (maybe an author from Brittany
    will sell more in their region because their network of contacts is denser around
    them? Or perhaps it has no impact? Anyway, this might be interesting to analyze).
    This is a common issue with microservices, which are supposed to have their own
    persistence. In this case, how can we make links between data, just like we were
    creating `join` operations when we added a single database? One of the standard
    approaches is to add a collecting data structure that gathers, indexes, and aggregates
    data from all the microservices and proposes a dedicated `/api/reporting` service
    with its own API contract.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给出一个此类问题的简单例子，因为它非常典型地代表了我在描述的陷阱。想象一下，我们创建了一个演示应用程序，其中包含一个用于书籍的API，一个用于书籍销售的API（可能位于相同的URL下，但在合同层面上仍然是独立的），以及一个用于作者的API。公司总监可能在某个时候想要一份关于作者的地域起源如何影响其销售本地化的报告（也许布列塔尼的作者在其地区销售会更好，因为他们的联系网络更密集？或者可能没有影响？无论如何，这可能值得分析）。这是微服务中常见的问题，微服务本应拥有自己的持久性。在这种情况下，我们如何建立数据之间的联系，就像我们在添加单个数据库时创建`join`操作一样？一个标准的方法是添加一个收集数据结构，它从所有微服务中收集、索引和汇总数据，并提议一个具有自己API合同的专用`/api/reporting`服务。
- en: This service of course presents a level of coupling toward its source, but this
    can be made a lower level of coupling, for example, by keeping a local cache or
    mixing a subscribe approach to the data changes with a direct collection under
    a lower frequency to ensure that no signal has been lost and the data is reset
    at a controlled frequency. Also, it presents interesting functions that none of
    the atomic data services provide, such as indexing, the capacity of dynamic aggregation,
    and so on. **GraphQL** is a nice protocol to expose such services, and they integrate
    very well in a **Command Query Responsibility** **Segregation** architecture.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个服务对其源存在一定程度的耦合，但这可以通过保持本地缓存或混合订阅数据变化的方法与较低频率的直接收集相结合来降低耦合级别，以确保没有信号丢失，并且数据在可控的频率下重置。此外，它还提供了原子数据服务中没有的有趣功能，例如索引、动态聚合能力等。**GraphQL**是一个很好的协议来公开此类服务，并且它们与**命令查询职责分离**架构集成得非常好。
- en: However, there might be an unintended coupling if the atomic service not only
    provides data for this reporting service but also starts consuming atomic data
    from it. And this can happen very quickly because the performance boost of an
    indexing engine is very appealing to developers. The problem is that this causes
    a circular functional dependency, which is already quite a problem, but also a
    higher level of coupling since, once this dependency is created, the atomic data
    service becomes suddenly coupled to each of the other ones. Of course, the coupling
    may remain low, but nonetheless, a link has been created and this is – in most
    cases I have seen – a real pain to come into the system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果原子服务不仅为这个报告服务提供数据，而且开始从它那里消费原子数据，那么可能会出现意外的耦合。这可能会很快发生，因为索引引擎的性能提升对开发者来说非常有吸引力。问题是这导致了循环功能依赖，这本身就是一个相当大的问题，而且耦合程度更高，因为一旦这种依赖关系建立，原子数据服务就会突然与每个其他服务耦合。当然，耦合可能仍然很低，但无论如何，已经建立了一个联系，这在大多数情况下——我所见到的——都是进入系统的一个真正的痛点。
- en: If you really need fast aggregated reads in an atomic service, you have to deal
    with this internally, by adding indexes on the dedicated persistency, for example.
    This may sound complicated if you see this nice indexing engine right on the other
    side of the service wall, but this is the price to pay to keep your system free
    from coupling and easy to evolve in time. Again, this is a compromise and if the
    architect decides the functional coupling is not a problem, you may save time
    by doing so. But this has to be a conscious (and documented) compromise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要在原子服务中进行快速的聚合读取，你必须通过在专门的持久性上添加索引等方式内部处理。如果你看到这个漂亮的索引引擎就在服务墙的另一边，这可能会听起来很复杂，但这是为了保持你的系统不受耦合影响并且易于随时间进化而必须付出的代价。再次强调，这是一个妥协，如果架构师认为功能耦合不是问题，你可以通过这样做来节省时间。但这是一个有意识的（并且有文档记录的）妥协。
- en: "![\uFEFFFigure 6.5 – Reducing coupling strength](img/Figure_6.5_B21293.jpg)"
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 降低耦合强度](img/Figure_6.5_B21293.jpg)'
- en: Figure 6.5 – Reducing coupling strength
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 降低耦合强度
- en: Wrapping up before going back to the demo
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在回到演示之前总结
- en: In this chapter, we have learned about the SOLID principles that can be applied
    to information systems (and not only object-oriented programming, as they were
    initially aimed at); the single responsibility principle and the interface segregation
    principle have been used to start a definition of the different API contracts
    we will need for our demo application. The open/closed principle will help to
    keep this API grammar free to evolve, and its evolution will have to follow the
    Liskov substitution principle for the system to evolve satisfyingly. Finally,
    dependency inversion has been demonstrated as the core principle behind contract-first
    API and the capacity to align the software implementations on the business-oriented
    functions, which is the main goal we seek in this book.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了可以应用于信息系统（而不仅仅是面向对象编程，因为它们最初的目标是）的SOLID原则；单一职责原则和接口隔离原则已被用来开始定义我们演示应用程序所需的不同的API合约。开放/封闭原则将帮助保持这个API语法的可进化性，并且其进化必须遵循Liskov替换原则，以便系统能够令人满意地进化。最后，依赖倒置已被证明是合同优先API的核心原则，以及能够将软件实现与面向业务的功能对齐，这是我们在这本书中寻求的主要目标。
- en: In the next chapter, we will go one step further in the design of our demo application
    by defining its different components. This will help us to draw a perimeter of
    the first version we want to create in this book, but also to define more clearly
    the different parts of the application using a method that adapts to the depth
    of decomposition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步设计我们的演示应用程序，通过定义其不同的组件。这将帮助我们描绘出我们想要在这本书中创建的第一版的大致轮廓，同时也能更清晰地定义应用程序的不同部分，使用一种适应分解深度的方法。
