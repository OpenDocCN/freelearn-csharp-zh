- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Interactive AR Experiences
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交互式AR体验
- en: Having mastered the basics of crafting and implementing an AR experience in
    Unity for Android and iOS platforms in [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011),
    we’ll now embark on the engaging journey of enhancing your AR scenes with intriguing
    interactions. This chapter will open a whole new world of user experiences for
    you as we strive to augment reality with utility-based overlays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B20869_04.xhtml#_idTextAnchor011)中掌握了在Unity中为Android和iOS平台制作和实现AR体验的基础知识后，我们现在将开始一段有趣的旅程，通过引人入胜的交互来增强您的AR场景。随着我们努力通过基于实用性的叠加来增强现实，这一章节将为您开启一个全新的用户体验世界。
- en: Harnessing the robust capabilities of C#, our adventure will take a turn toward
    creating an innovative AR application tailored to the food industry. This application
    will revolutionize the way customers make their selections, offering an unprecedented
    method for placing orders.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 利用C#强大的功能，我们的冒险将转向创建一个针对食品行业的创新AR应用程序。这个应用程序将彻底改变客户选择的方式，提供一种前所未有的点餐方法。
- en: As we unravel the creation process of this AR app, you’ll discover how to anchor
    and scale 3D models in the real world, facilitate user interactions with the elements
    of your AR app, and comprehend the broad principles to contemplate when architecting
    your own AR application. This immersive journey will equip you with a rich set
    of skills, offering a deeper understanding of the boundless possibilities of AR.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们揭开这个AR应用程序的创建过程时，您将发现如何将3D模型锚定和缩放在现实世界中，促进用户与AR应用程序元素的交互，并理解在构建自己的AR应用程序时需要考虑的广泛原则。这次沉浸式的旅程将为您配备一套丰富的技能，提供对AR无限可能性的更深入理解。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了以下主题：
- en: Understanding the design patterns and core components of an interactive AR application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解交互式AR应用程序的设计模式和核心组件
- en: Building the foundation of our AR menu application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的AR菜单应用程序的基础
- en: Adding interactivity to our AR menu application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的AR菜单应用程序添加交互性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To fully participate in and benefit from the AR application development process
    detailed in this chapter, there are several technical requirements your hardware
    must meet. If you followed along with the project we built in [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011),
    you can skip these requirements, so long as your Unity setup hasn’t changed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分参与并从本章详细介绍的AR应用开发过程中受益，您的硬件必须满足以下技术要求。如果您跟随我们在[*第4章*](B20869_04.xhtml#_idTextAnchor011)中构建的项目，您可以跳过这些要求，只要您的Unity设置没有改变。
- en: To ensure you can follow along with the content and examples in this book, confirm
    that your computer system can handle *Unity 2021.3* LTS or a more recent edition,
    including Android or iOS Build Support.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您能够跟随本书中的内容和示例，请确认您的计算机系统可以处理*Unity 2021.3* LTS或更高版本，包括Android或iOS构建支持。
- en: Additionally, as we delve into the fascinating world of AR, it is helpful to
    have either an Android or iOS device that can support *ARKit* or *ARCore*. You
    can check the compatibility of your device at [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着我们深入探索AR的迷人世界，拥有一个可以支持*ARKit*或*ARCore*的Android或iOS设备将非常有帮助。您可以在[https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)检查您的设备兼容性。
- en: However, if you don’t have a device that fits these requirements, you can still
    participate in these tutorials and test your application on your PC. The *Deploying
    AR experiences onto mobile devices* section of [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011)
    detailed how to do this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您没有符合这些要求的设备，您仍然可以参与这些教程，并在您的PC上测试您的应用程序。[*第4章*](B20869_04.xhtml#_idTextAnchor011)中的*将AR体验部署到移动设备*部分详细说明了如何做到这一点。
- en: Understanding the design patterns and core components of an interactive AR application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解交互式AR应用程序的设计模式和核心组件
- en: In this section, we will delve into the commonly used design patterns and applications
    of AR, equipping you with the knowledge to choose the appropriate use case for
    your AR application. This includes familiarizing yourself with the core concepts
    and integral components of the AR menu application that we will construct in this
    chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究AR常用的设计模式和应用程序，为您提供选择您AR应用程序适当用例的知识。这包括熟悉我们将在本章中构建的AR菜单应用程序的核心概念和基本组件。
- en: Understanding the right applications for interactive AR apps is essential before
    embarking on your journey to develop your first full-fledged AR application. Let’s
    take a look at the various types of AR apps that currently exist, highlighting
    the different ways they enhance the user experience. Not only will this give you
    a clearer picture of the current state of AR applications, but it will also shed
    light on what types of AR experiences resonate most with users.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发你的第一个完整AR应用之前，理解互动AR应用的正确应用至关重要。让我们来看看目前存在的各种AR应用类型，突出它们增强用户体验的不同方式。这不仅会给你一个关于当前AR应用状态的清晰图景，还会揭示哪些类型的AR体验最能引起用户的共鸣。
- en: 'Let’s look at these different kinds of applications:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些不同种类的应用：
- en: '**AR gaming apps**: Games such as Pokémon Go and Minecraft Earth are popular
    examples of AR apps. They place virtual objects such as creatures or blocks into
    the user’s real-world surroundings. Interaction is usually done through touchscreen
    commands, with the game responding to physical location data from the device’s
    GPS.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强现实游戏应用**：例如《精灵宝可梦GO》和《我的世界地球版》这样的游戏是AR应用的流行例子。它们将虚拟对象如生物或方块放置在用户的真实世界环境中。交互通常通过触摸屏命令完成，游戏会响应设备GPS提供的物理位置数据。'
- en: '**AR navigation apps**: Apps such as Google Maps Live View and CityViewAR overlay
    directional cues and points of interest onto real-world images. These apps use
    GPS data and device orientation to decide which AR elements to show and where.
    These elements can include arrows, labels, and even 3D models of buildings. Users
    primarily interact by moving and looking around. Some apps also allow users to
    touch screen elements for more information.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR导航应用**：例如Google Maps Live View和CityViewAR这样的应用将方向提示和兴趣点叠加到现实世界的图像上。这些应用使用GPS数据和设备方向来决定显示哪些AR元素以及在哪里显示。这些元素可以包括箭头、标签，甚至建筑的3D模型。用户主要通过移动和环顾四周进行交互。一些应用还允许用户触摸屏幕元素以获取更多信息。'
- en: '**AR shopping apps**: IKEA Place and Amazon AR View let users visualize products
    in their own homes before buying. These apps access the users’ camera feeds so
    that they can place 3D models of products in their rooms. Advanced apps use environmental
    understanding to place objects on surfaces and scale them correctly. Users move
    around to view the product from different angles and use touch commands to select
    different items, change colors or features, and make a purchase.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR购物应用**：IKEA Place和Amazon AR View允许用户在购买前在自己的家中可视化产品。这些应用访问用户的摄像头流，以便将产品的3D模型放置在他们的房间里。高级应用使用环境理解将对象放置在表面上并正确缩放。用户四处走动以从不同角度查看产品，并使用触摸命令选择不同的项目、更改颜色或功能，并完成购买。'
- en: '**AR education apps**: Apps such as Star Walk 2 and AR Anatomy Learning are
    designed to provide immersive, interactive learning experiences. These apps often
    use image recognition to anchor 3D models such as a star system or a human organ
    to specific locations in the real world. Users can interact with the 3D models
    through touch commands, for example, to rotate the model or activate animations.
    Users may also move around to view the model from different angles.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR教育应用**：例如Star Walk 2和AR解剖学习这样的应用旨在提供沉浸式、互动的学习体验。这些应用通常使用图像识别将如星系或人体器官的3D模型锚定到现实世界中的特定位置。用户可以通过触摸命令与3D模型交互，例如旋转模型或激活动画。用户还可以四处走动以从不同角度查看模型。'
- en: 'These different AR applications may cater to different user groups and industries,
    but they share a core pattern: projecting 3D models into real-world contexts using
    AR. These apps use the camera feed, device orientation, and GPS data to position
    and scale the 3D models. User interaction is achieved through touch commands or
    physical movement, with the interaction often centered on manipulating specific
    features of the 3D models. This pattern, which emphasizes simplicity and focus,
    is the current standard in AR app development and will serve as our blueprint
    for the interactive AR app we’ll discuss in this chapter. It’s also a pattern
    we recommend for our own AR projects.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的AR应用可能针对不同的用户群体和行业，但它们有一个共同的模式：使用AR将3D模型投射到现实世界环境中。这些应用使用摄像头流、设备方向和GPS数据来定位和缩放3D模型。用户交互通过触摸命令或物理动作实现，交互通常集中在操纵3D模型的特定功能上。这种强调简单和专注的模式是当前AR应用开发的标准，也将成为我们本章讨论的交互式AR应用的蓝图。它也是我们推荐用于我们自己的AR项目的模式。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the goal is not to force AR functionality into an app but to use
    it where it enhances user experience. For instance, using AR to display a restaurant
    menu on a table might seem novel, but it doesn’t necessarily add value for the
    user. A traditional 2D app or physical menu would serve the same purpose. However,
    if you create an AR experience where users can visualize each dish on the table,
    scaled to the actual serving size, the user gets a clear sense of what to expect.
    This enhances the dining experience and overall satisfaction, showing how AR can
    create meaningful and beneficial interactions when applied appropriately. And
    this is exactly what we are going to create in the subsequent sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标不是将AR功能强行嵌入到应用中，而是要在增强用户体验的地方使用它。例如，使用AR在桌子上显示餐厅菜单可能看起来很新颖，但并不一定能为用户提供价值。传统的2D应用或实体菜单也能达到同样的目的。然而，如果你创建一个AR体验，让用户能够可视化桌子上每一道菜，并按实际份量缩放，用户就能清楚地了解可以期待什么。这增强了用餐体验和整体满意度，展示了AR如何通过适当的应用创造有意义的和有益的交互。这正是我们在后续章节中将要创建的内容。
- en: With this understanding, let’s proceed and build the foundation of our AR menu
    application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种理解，让我们继续前进，构建我们AR菜单应用的基础。
- en: Building the foundation of our AR menu application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们AR菜单应用的基础
- en: As we start crafting this AR menu application, you’ll set the groundwork for
    your AR project by assembling the essential components. The following sections
    will guide you through the process of sourcing and importing a variety of dishes
    from the Unity Asset Store and adding UI buttons and text elements to your scene,
    providing the basis for your interactive AR menu application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始制作这个AR菜单应用时，您将通过组装基本组件来为您的AR项目打下基础。以下章节将指导您通过Unity Asset Store获取和导入各种菜肴，并将UI按钮和文本元素添加到场景中，为您的交互式AR菜单应用提供基础。
- en: Defining the key components of our AR application
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们AR应用的关键组件
- en: 'Throughout this chapter, we will be building an AR application that allows
    users to place 3D models of food items that have been detected by their mobile
    device’s camera onto real-world surfaces. Before we get into the project, it is
    always good to visualize the functionality of the app we are going to create.
    Our AR application will consist of several key components:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个AR应用，允许用户将他们的移动设备摄像头检测到的食物3D模型放置到现实世界的表面上。在我们进入项目之前，可视化我们即将创建的应用的功能总是很好的。我们的AR应用将包括几个关键组件：
- en: '**AR Session and AR Session Origin**: These are the primary components for
    any AR Foundation application. These form the stage for our performance. For an
    in-depth understanding of AR Session Origin and AR Session, you’re invited to
    revisit the *Exploring the AR Session Origin GameObject* and *Understanding the
    AR Session GameObject* sections of [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR会话和AR会话原点**：这些是任何AR Foundation应用的主要组件。它们构成了我们表演的舞台。为了深入了解AR会话原点和AR会话，您被邀请重新阅读[*第4章*](B20869_04.xhtml#_idTextAnchor011)中的*探索AR会话原点GameObject*和*理解AR会话GameObject*部分。'
- en: '**AR Raycast Manager and AR Plane Manager**: These components come by default
    with AR Session Origin. AR Raycast Manager performs raycasts against tracked AR
    features and geometry, such as detected planes. We’ll use it to find where we
    can place our 3D models in the real world. AR Plane Manager, on the other hand,
    allows you to detect and track horizontal and vertical surfaces in the real world.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR射线投射管理器和AR平面管理器**：这些组件默认与AR会话原点一起提供。AR射线投射管理器会对跟踪的AR特征和几何形状执行射线投射，例如检测到的平面。我们将使用它来找到我们可以在现实世界中放置3D模型的位置。另一方面，AR平面管理器允许您检测和跟踪现实世界中的水平和垂直表面。'
- en: '**Food prefabs**: These are 3D models of food items that users can place in
    the real world. They are the tangible objects that the user will interact with.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**食物预制件**：这些是用户可以在现实世界中放置的食物的3D模型。它们是用户将与之交互的有形对象。'
- en: '**UI buttons and text elements**: These UI elements are needed to guide the
    user on how the app works, to swap the current food prefab to the next or previous
    one in line, and to display nutritional information for each dish. Consider these
    UI elements as the interactive elements of our application where the users can
    participate.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI按钮和文本元素**：这些UI元素用于指导用户了解应用的工作方式，切换当前食物预制件到下一个或上一个，以及显示每道菜的营养成分信息。将这些UI元素视为我们应用的交互元素，用户可以参与其中。'
- en: '**The ARPlacePrefab script**: This is our main script, and it’s responsible
    for managing the placement of the 3D models and a UI button in the AR space. It
    also handles the user interactions for placing objects and updates the placement
    indicator based on AR raycast results.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARPlacePrefab 脚本**：这是我们主要的脚本，负责管理 3D 模型和 UI 按钮在 AR 空间中的放置。它还处理放置对象的用户交互，并根据
    AR 射线结果更新放置指示器。'
- en: '**The SwapPrefab script**: This script works in conjunction with the **ARPlacePrefab**
    script to switch between different food prefabs when the UI button is clicked.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SwapPrefab 脚本**：此脚本与 **ARPlacePrefab** 脚本协同工作，当 UI 按钮被点击时，在不同的食物预制件之间切换。'
- en: '`Food`, which enables us to create `Food` objects with certain characteristics
    or properties, such as a name, ingredients, calories, and diet type.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Food`，它使我们能够创建具有特定特征或属性（如名称、成分、卡路里和饮食类型）的 `Food` 对象。'
- en: By implementing these components, we will have a working AR application that
    lets users place, view, and swap different 3D models of food in their real-world
    environment using their smartphone in place of a traditional printed menu. To
    ensure that the users understand what they are supposed to do in this application,
    dedicated UI elements will be added to the start scene of the application. By
    using visual cues such as grids, the process of finding the optimal position to
    place a dish will be facilitated for the user. By adding a scaling functionality,
    the user will be able to adjust the size of the displayed dish for an enhanced
    user experience.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这些组件，我们将拥有一个可工作的 AR 应用程序，允许用户使用智能手机代替传统的打印菜单，在他们的真实世界环境中放置、查看和交换不同的 3D 食物模型。为了确保用户理解在这个应用程序中他们应该做什么，将在应用程序的开始场景中添加专门的
    UI 元素。通过使用如网格等视觉提示，将有助于用户找到放置菜肴的最佳位置。通过添加缩放功能，用户将能够调整显示菜肴的大小，以增强用户体验。
- en: In the following section, we will set up our AR application so that we’re one
    step closer to building an interactive AR app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将设置我们的 AR 应用程序，以便我们更接近构建一个交互式 AR 应用程序。
- en: Setting up the environment
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'To initiate our journey, let’s start by creating a new project, as explained
    in the *Creating an AR project with Unity’s AR template* section in [*Chapter
    4*](B20869_04.xhtml#_idTextAnchor011). If you’ve already completed these steps,
    you can simply open the existing project for this chapter. After your project
    loads, follow this step-by-step guide to set up your environment:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的旅程，让我们首先创建一个新的项目，正如在 [*第 4 章*](B20869_04.xhtml#_idTextAnchor011) 中 *使用
    Unity 的 AR 模板创建 AR 项目* 部分所解释的那样。如果您已经完成了这些步骤，您可以简单地打开本章的现有项目。在项目加载后，按照以下步骤逐步设置您的环境：
- en: Let’s kick-start the process by crafting a new empty scene. This can be achieved
    by going to `ARFoodMenu`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过创建一个新的空场景来启动这个过程。这可以通过转到 `ARFoodMenu` 来实现。
- en: A quick double-click will transport you into your newly minted scene, which
    currently only houses **Main Camera** and **Directional Light**. **Main Camera**
    can be removed as it won’t be needed.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速双击将带您进入您新创建的场景，该场景目前仅包含 **主相机** 和 **方向光**。**主相机** 可以被移除，因为它将不再需要。
- en: Before diving into the AR setup, it’s important to lay the groundwork for our
    AR app. In our situation, this means incorporating **AR Session Origin** and **AR
    Session**. You can accomplish this by right-clicking in the **Scene Hierarchy**
    window, choosing **XR** | **AR Session Origin**, and repeating the same step for
    **AR Session**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在深入到 AR 设置之前，为我们的 AR 应用程序打下基础是很重要的。在我们的情况下，这意味着要整合 **AR Session Origin** 和 **AR
    Session**。您可以通过在 **场景层次** 窗口中右键单击，选择 **XR** | **AR Session Origin**，然后为 **AR Session**
    重复相同的步骤来完成此操作。
- en: Once `AR Plane Manager` script, and select it. Repeat this process for the **AR
    Raycast** **Manager** script.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `AR Plane Manager` 脚本加载，并选择它。为 **AR Raycast** **Manager** 脚本重复此过程。
- en: In the `ARPlane` and drag the prefab into the **Plane Prefab** cell of the **AR
    Plane Manager** script component in the **Inspector** window. As we just want
    to detect horizontal planes for our AR menu application, select **Horizontal**
    for **Detection Mode**. We don’t need to assign any prefabs for **AR Raycast Manager**
    as we just need the functionality to calculate when the ray encounters the surface.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ARPlane` 中拖动预制件到 **Inspector** 窗口中 **AR Plane Manager** 脚本组件的 **Plane Prefab**
    单元格。由于我们只想检测用于我们的 AR 菜单应用程序的水平平面，因此将 **Detection Mode** 设置为 **Horizontal**。我们不需要为
    **AR Raycast Manager** 分配任何预制件，因为我们只需要计算射线何时遇到表面的功能。
- en: And there you have it! With a few clicks, we’ve added **AR Session**, **AR Session
    Origin**, **AR Raycast Manager**, and **AR Plane Manager** to our scene. Our next
    move is to import food models from the Asset Store, which will showcase the meals
    we aim to present to the user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！通过几点击，我们已经将**AR会话**、**AR会话原点**、**AR射线管理器**和**AR平面管理器**添加到了我们的场景中。我们的下一步是导入来自Asset
    Store的食品模型，这将展示我们打算向用户展示的餐点。
- en: Designing 3D food models
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计3D食品模型
- en: 'As a restaurant proprietor, you need to produce 3D models of your meals at
    this stage. The following are a few strategies you could employ to design 3D models
    of food or dishes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家餐厅的业主，您需要在这个阶段制作您餐点的3D模型。以下是一些您可以采用的策略来设计食品或菜肴的3D模型：
- en: '**3D modeling software**: There are many 3D modeling software tools you can
    use to create 3D models. These include *Blender*, *3ds Max*, *Autodesk Maya*,
    and *SketchUp*. Among these, *Blender* is a popular choice because it’s free and
    open source. There are many online tutorials available to help beginners get started
    with *Blender*, such as *CGFastTrack*’s YouTube channel ([https://www.youtube.com/@CGFastTrack/featured](https://www.youtube.com/@CGFastTrack/featured)).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D建模软件**：有许多3D建模软件工具可以帮助您创建3D模型。这些包括*Blender*、*3ds Max*、*Autodesk Maya*和*SketchUp*。在这些工具中，*Blender*是一个流行的选择，因为它免费且开源。有许多在线教程可以帮助初学者开始使用*Blender*，例如*CGFastTrack*的YouTube频道([https://www.youtube.com/@CGFastTrack/featured](https://www.youtube.com/@CGFastTrack/featured))。'
- en: '**Photogrammetry**: Photogrammetry is a technique where you take multiple photographs
    of an object from different angles and then use software to stitch them together
    into a 3D model. Tools such as *Luma Labs*, *Reality Capture*, *Meshroom*, and
    *Agisoft Metashape* can help with this. For food models, this can give a very
    realistic result, but it may also be more complex to get right, particularly with
    foods that are uniform in color or texture.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄影测量法**：摄影测量是一种技术，您需要从不同的角度拍摄多个物体的照片，然后使用软件将它们拼接成一个3D模型。像*Luma Labs*、*Reality
    Capture*、*Meshroom*和*Agisoft Metashape*这样的工具可以帮助您完成这项工作。对于食品模型，这可以产生非常逼真的效果，但可能也更复杂，尤其是对于颜色或纹理均匀的食品。'
- en: '**Download pre-made 3D models**: If creating models is too time-consuming or
    outside your current skill set, you can download pre-made models from sites such
    as *Sketchfab*, *TurboSquid*, or the *Unity Asset Store*, which is what we will
    do for this project. Just make sure you check the licensing terms to see if they
    fit your needs.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载预制3D模型**：如果您觉得创建模型太耗时或超出了您当前的技术范围，您可以从像*Sketchfab*、*TurboSquid*或*Unity
    Asset Store*这样的网站上下载预制模型，这是我们在这个项目中将要做的。只需确保您检查许可条款，看看它们是否符合您的需求。'
- en: '**Hire a 3D artist**: If you have a budget for your project, you might consider
    hiring a 3D artist to create custom food models for you. This can give you exactly
    what you want, tailored to your specifications.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聘请3D艺术家**：如果您为项目预留了预算，您可能考虑聘请3D艺术家为您创建定制的食品模型。这可以为您提供完全符合您规格的模型。'
- en: 'As we pointed out previously, we are going to import our models through the
    Unity Asset Store for the sake of this AR menu application. Follow these instructions
    to do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指出的，为了这个增强现实菜单应用，我们将通过Unity Asset Store导入我们的模型。按照以下说明进行操作：
- en: 'Go to the Unity Asset Store ([https://assetstore.unity.com/](https://assetstore.unity.com/))
    and search for the `French Fries – Free` package. Alternatively, you can access
    the **French Fries** package page via this link: [https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017](https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017).'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Unity Asset Store([https://assetstore.unity.com/](https://assetstore.unity.com/))并搜索`French
    Fries – Free`包。或者，您也可以通过此链接访问**French Fries**包页面：[https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017](https://assetstore.unity.com/packages/3d/props/food/french-fries-free-164017)。
- en: After adding the package to your assets, click the **Open in Unity** button
    that now appears on the Asset Store’s website.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将包添加到您的资产后，点击现在出现在Asset Store网站上的**在Unity中打开**按钮。
- en: Your Unity project should open, and you should be prompted with the option to
    import the package. Click the **Import** button to proceed.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的Unity项目应该已经打开，您应该会看到一个选项提示您导入包。点击**导入**按钮继续。
- en: Once the package has been successfully imported into your project, repeat the
    previous three steps for the **Japanese Food Tofu – FREE** package ([https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533](https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533))
    and the **Japanese Food Kashipan – FREE** package ([https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938](https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938)).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦包成功导入到您的项目中，重复之前的三个步骤，用于**日本食物豆腐 – 免费**包([https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533](https://assetstore.unity.com/packages/3d/props/food/japanese-food-tofu-free-203533))和**日本食物Kashipan
    – 免费**包([https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938](https://assetstore.unity.com/packages/3d/props/food/japanese-food-kashipan-free-210938))。
- en: Now that we’ve imported the appropriate food meals into our scene, we fulfilled
    the food prefabs requisite. In the next section, we will add the UI button and
    text components that will guide the user through the AR menu application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将适当的食物餐点导入到我们的场景中，我们已经满足了食物预制件的要求。在下一节中，我们将添加UI按钮和文本组件，以引导用户通过AR菜单应用程序。
- en: Adding UI buttons and text elements to our AR menu application
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的AR菜单应用程序添加UI按钮和文本元素
- en: In this section, we’ll focus on integrating three buttons and two text elements
    into our scene. These buttons are divided into one for initiating the app and
    two for transitioning between the dishes. The first text element serves to guide
    the user through the AR menu application, while the second acts as a placeholder
    to contain information about the displayed dish, such as its name, ingredients,
    caloric content, and dietary type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于将三个按钮和两个文本元素集成到我们的场景中。这些按钮分为一个用于启动应用程序和一个用于在菜品之间切换的两个按钮。第一个文本元素用于指导用户通过AR菜单应用程序，而第二个则用作占位符，以包含有关显示菜品的详细信息，例如其名称、成分、卡路里含量和饮食类型。
- en: Excluding the second text element, these UI elements should remain within the
    user’s field of view, regardless of how the device is rotated. This can be accomplished
    by assigning them as child objects to the AR camera.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第二个文本元素外，这些UI元素应始终位于用户的视野内，无论设备如何旋转。这可以通过将它们分配为AR摄像机的子对象来实现。
- en: 'Let’s start with the two dish-swapping buttons. Follow these steps to achieve
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个交换菜品的按钮开始。按照以下步骤操作：
- en: Navigate to the **Scene Hierarchy** window, right-click on the **AR Camera**
    component, and select **UI** | **Canvas**. This action will add **Canvas** as
    a child object of **AR Camera**. The **Canvas** component is necessary for all
    UI elements.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**场景层次结构**窗口，右键点击**AR Camera**组件，选择**UI** | **Canvas**。此操作将**Canvas**添加为**AR
    Camera**的子对象。**Canvas**组件对于所有UI元素都是必要的。
- en: Alter the Canvas’s `0.01`, `0.01`, `0.01`) with `480` and `90`. Position the
    `0`,`0`,`1`).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Canvas的`0.01`、`0.01`、`0.01`调整到`480`和`90`。将`0`,`0`,`1`定位。
- en: Create the buttons by right-clicking on the `ButtonNext` and `ButtonPrevious`.
    Rescale both buttons to (`0.07`, `0.32`, `1`) with `160` and `30`. Position `10`,`40`,`0`)
    and `-10`, `40`, `0`).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击`ButtonNext`和`ButtonPrevious`创建按钮。将两个按钮缩放调整为`0.07`、`0.32`、`1`，并定位到`10`、`40`、`0`和`-10`、`40`、`0`)。
- en: For the child objects of both buttons, enter arrows such as `->` and `<-` as
    the text input in the **Inspector** window. These arrows tell the user which button
    switches to the next or previous dish.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于两个按钮的子对象，在**检查器**窗口中输入箭头，如`->`和`<-`作为文本输入。这些箭头告诉用户哪个按钮切换到下一道或上一道菜。
- en: 'At this point, the two buttons have been fully initialized. Next, we need to
    create an instructional piece of text to guide users on how to use the AR menu
    application. To achieve this, follow these step-by-step instructions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，两个按钮已经完全初始化。接下来，我们需要创建一个指导性文本，以指导用户如何使用AR菜单应用程序。为了实现这一点，请按照以下逐步说明操作：
- en: Right-click on `0.17`, `0.17`, `0.17`). Adjust the panel top to `-46.5` and
    the panel bottom to `-3.4`. This panel will act as a backdrop for our text. You’re
    free to choose its color; in our case, we chose red. Rename this panel `InfoPanel`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`0.17`、`0.17`、`0.17`。调整面板顶部为`-46.5`，面板底部为`-3.4`。这个面板将作为我们的文本的背景。您可以选择其颜色；在我们的案例中，我们选择了红色。将此面板重命名为`InfoPanel`。
- en: For the instructional text, right-click `InstructionText`. Adjust its scale
    to (`0.7`, `0.7`, `0.7`) with `600` and `150`; then, position it at (`0`, `0`,
    `0`).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于指导性文本，右键点击`InstructionText`。将其缩放调整为`0.7`、`0.7`、`0.7`，并定位到`600`和`150`；然后，将其定位到`0`、`0`、`0`。
- en: 'Input the following text: `Wait until the blue surface is visible. This shows
    the area where the food is placed`. This instruction will be critical for the
    user as we’ll implement a blue grid area that indicates where the food prefabs
    will be placed.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下文本：`等待蓝色表面可见。这显示了放置食物的区域`。这条指令对于用户来说至关重要，因为我们将在场景中实现一个蓝色网格区域，以指示食物预制件将被放置的位置。
- en: To prevent the user seeing a meal directly when the application starts, create
    another button below the instruction text. This button is responsible for spawning
    the first dish. To do this, right-click `PlaceFirstMealButton`, scale it to (`2.2`,
    `2.2`, `2.2`), and position it at (`0`, `-292`, `0`) with `160` and `30`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止用户在应用程序启动时直接看到一顿饭，在说明文本下方创建另一个按钮。这个按钮负责生成第一道菜。为此，右键点击 `PlaceFirstMealButton`，将其缩放至
    (`2.2`, `2.2`, `2.2`)，并将其定位在 (`0`, `-292`, `0`)，宽度为 `160`，高度为 `30`。
- en: Open the child text component of `Place First Meal` as the text input in the
    **Inspector** window. Activate the **Active auto size** checkbox to make sure
    that the text is adjusted with the button. Both **InstructionText** and **PlaceFirstMealButton**
    are child objects of **InfoPanel**. They are designed to disappear after the first
    meal is placed. This means we only need to target **InfoPanel** in our code instead
    of all three objects individually.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中打开 `Place First Meal` 的子文本组件作为文本输入。激活 **活动自动大小** 复选框以确保文本与按钮一起调整。**InstructionText**
    和 **PlaceFirstMealButton** 都是 **InfoPanel** 的子对象。它们被设计为在放置第一顿饭之后消失。这意味着我们只需要在我们的代码中针对
    **InfoPanel** 而不是三个对象分别进行操作。
- en: Lastly, we require another text element, but this time, it should not be a child
    object of **AR camera**. This text needs to spawn above the dishes and remain
    there consistently.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要另一个文本元素，但这次它不应是 **AR 相机** 的子对象。这个文本需要生成在盘子上方并保持一致。
- en: 'To accomplish this, let’s perform the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，让我们执行以下步骤：
- en: Create another `0.1`, `0.1`, `0.1`) and position it at (`0.3`, `0.3`, `1`) with
    `480` and `90`. Rename this `FoodInfoCanvas`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个 (`0.1`, `0.1`, `0.1`) 并将其定位在 (`0.3`, `0.3`, `1`)，宽度为 `480`，高度为 `90`。将此重命名为
    `FoodInfoCanvas`。
- en: Right-click `FoodInfoText`, scale it to (`0.005`, `0.005`, `0.005`), and position
    it at (`-3.4`, `0`,`31`, `0`) with `200` and `50`. **FoodInfoText** does not need
    text input as this will be assigned programmatically in correspondence with the
    displayed dish.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `FoodInfoText`，将其缩放至 (`0.005`, `0.005`, `0.005`)，并将其定位在 (`-3.4`, `0`, `31`,
    `0`)，宽度为 `200`，高度为 `50`。**FoodInfoText** 不需要文本输入，因为这将通过程序与显示的菜肴相对应。
- en: At this point, your **Scene Hierarchy** window should look like what is shown
    in *Figure 6**.1*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你的 **场景层次结构** 窗口应该看起来像 *图 6.1* 中所示的那样。
- en: "![Figure 6.1 – \uFEFFOur project’s Scene Hierarchy window, showcasing all components\
    \ in our scene](img/B20869_06_01.jpg)"
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 我们项目的场景层次结构窗口，展示了场景中的所有组件](img/B20869_06_01.jpg)'
- en: Figure 6.1 – Our project’s Scene Hierarchy window, showcasing all components
    in our scene
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 我们项目的场景层次结构窗口，展示了场景中的所有组件
- en: Similarly, all your UI elements should be aligned in your Game view, as shown
    in *Figure 6**.2*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你所有的 UI 元素都应该在游戏视图中对齐，如图 *图 6.2* 所示。
- en: "![Figure 6.2 – \uFEFFOur project’s Game view, showcasing the alignment of the\
    \ different UI elements in the scene](img/B20869_06_02.jpg)"
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 我们项目的游戏视图，展示了场景中不同 UI 元素的排列](img/B20869_06_02.jpg)'
- en: Figure 6.2 – Our project’s Game view, showcasing the alignment of the different
    UI elements in the scene
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 我们项目的游戏视图，展示了场景中不同 UI 元素的排列
- en: Please note that all UI elements are positioned and scaled concerning the **Canvas**
    component. If your UI elements have a different alignment to the one shown in
    *Figure 6**.2*, you can manually adjust the position and scale of your **Canvas**
    component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有 UI 元素都是根据 **Canvas** 组件进行定位和缩放的。如果你的 UI 元素与 *图 6.2* 中显示的对齐方式不同，你可以手动调整你的
    **Canvas** 组件的位置和缩放。
- en: With that, we have successfully added all the necessary UI elements to our scene
    and therefore finished adding UI buttons and text elements to create an interactive
    AR application. Next, we’ll add scripts to our scene to introduce some interactivity
    and life to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功地将所有必要的 UI 元素添加到我们的场景中，因此完成了添加 UI 按钮和文本元素以创建一个交互式 AR 应用程序。接下来，我们将向场景添加脚本以引入一些交互性和活力。
- en: Adding interactivity to our AR menu application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的 AR 菜单应用程序添加交互性
- en: To infuse life into our currently modest AR scene, we must incorporate some
    C# scripts into our project. This key step will empower the users of our AR app,
    allowing them to interact with our imported food prefabs dynamically and engagingly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的当前简陋的AR场景注入活力，我们必须将一些C#脚本整合到我们的项目中。这一关键步骤将赋予我们AR应用的用户动态且吸引人的交互能力。
- en: In the next section, you will get an overview of the short but decisive **Food**
    script.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将概述简短但决定性的**Food**脚本。
- en: Adding the Food script to the scene
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Food脚本添加到场景中
- en: Before we dive into scripting, let’s first organize our project workspace so
    that we can work more efficiently by finding the needed components quickly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入脚本编写之前，让我们首先组织我们的项目工作空间，以便我们可以通过快速找到所需组件来更有效地工作。
- en: Start by adding a new folder to the `Assets` directory in the `Scripts` and
    enter it. Right-click in this empty folder and select `Food`. After double-clicking
    on this script, it should be opened in your preferred **integrated development**
    **environment** (**IDE**).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Scripts`目录下的`Assets`目录中添加一个新的文件夹，并进入该文件夹。在这个空文件夹中右键点击，选择`Food`。双击这个脚本后，它应该会在你偏好的**集成开发环境**（**IDE**）中打开。
- en: The `Food` objects that are created will have certain characteristics or properties,
    just like how every car has a make, model, and color.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`Food`对象将具有某些特性或属性，就像每辆车都有品牌、型号和颜色一样。
- en: 'Here’s a simple breakdown of this script:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个脚本的简单分解：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`[System.Serializable]` is a directive that tells Unity to make this class
    serializable. This means that Unity will be able to save and load `Food` objects
    and that you’ll be able to edit `Food` objects directly in the Unity editor.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`[System.Serializable]`是一个指令，告诉Unity使这个类可序列化。这意味着Unity将能够保存和加载`Food`对象，你将能够在Unity编辑器中直接编辑`Food`对象。'
- en: After defining a new, public class called `Food`, a public property called `name`
    is declared. This property represents the name of the food, such as `French Fries`.
    Next, we declare additional properties such as `ingredients`, `calories`, and
    `dietType`. The latter property stores the type of diet the food fits into, such
    as `Vegetarian`, `Vegan`, or `Paleo`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个新的公共类`Food`之后，声明了一个名为`name`的公共属性。这个属性代表食物的名称，例如`French Fries`。接下来，我们声明了额外的属性，如`ingredients`、`calories`和`dietType`。后者属性存储食物适合的饮食类型，如`Vegetarian`、`Vegan`或`Paleo`。
- en: Lastly, a public property that will hold a `GameObject` is declared that represents
    the 3D model of the food that will be displayed in the AR environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，声明了一个公共属性，它将持有代表将在AR环境中显示的3D模型的`GameObject`。
- en: As we venture into the next section, we’ll continue our journey by incorporating
    the most pivotal C# script in our scene – the **ARPlacePrefab** script. It is
    this crucial component that will truly open the doors of interactivity within
    our AR menu application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入下一节时，我们将通过整合场景中最关键的C#脚本——**ARPlacePrefab**脚本，继续我们的旅程。正是这个关键组件将真正打开我们AR菜单应用中的交互之门。
- en: Adding the ARPlacePrefab script to the scene
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ARPlacePrefab脚本添加到场景中
- en: Similar to the previous scripts we created in this chapter, navigate to the
    `Assets` folder in the `ARPlacePrefab`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中我们创建的先前脚本类似，导航到`ARPlacePrefab`中的`Assets`文件夹。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We highly recommend that you clone the [*Chapter 6*](B20869_06.xhtml#_idTextAnchor020)
    project, which can be found in the GitHub repository of this book, and open it
    in parallel, enabling you to revisit and mimic the steps described in this project
    tutorial more easily.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议你克隆本书GitHub仓库中的[*第6章*](B20869_06.xhtml#_idTextAnchor020)项目，并在并行打开它，这样你可以更容易地回顾并模仿本项目教程中描述的步骤。
- en: We can open the just-created `ARPlacePrefab` script by double-clicking on it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过双击来打开刚刚创建的`ARPlacePrefab`脚本。
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The script will launch in the default IDE that you usually utilize. If you wish
    to switch to a different IDE, simply go to **Edit** | **Preferences** in the Unity
    editor. In the newly opened **Preferences** window, navigate to the **External
    Tools** tab and alter **External Script Editor** to the IDE of your preference.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将在你通常使用的默认IDE中启动。如果你希望切换到不同的IDE，只需在Unity编辑器中转到**编辑** | **首选项**。在新打开的**首选项**窗口中，导航到**外部工具**选项卡，并将**外部脚本编辑器**更改为你偏好的IDE。
- en: The `ARPlacePrefab` script, as previously highlighted, will serve as our primary
    script. It carries out the crucial role of handling the placement of the 3D models
    and UI buttons within the AR space. Moreover, it manages user interactions so
    that it can position objects and dynamically update the placement indicator based
    on AR raycast outcomes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ARPlacePrefab`脚本将作为我们的主要脚本。它执行处理3D模型和UI按钮在AR空间内放置的关键角色。此外，它管理用户交互，以便它可以定位对象并根据AR射线投射结果动态更新放置指示器。
- en: Next, let’s take a look at the various methods and functions in the `ARPlacePrefab`
    script.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`ARPlacePrefab`脚本中的各种方法和函数。
- en: Understanding the ARPlacePrefab script
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解`ARPlacePrefab`脚本
- en: As the `ARPlacePrefab` script is the core of our AR menu application, we must
    understand every method of it to truly grasp the mechanisms of interactive AR
    experiences and successfully replicate the script’s functionality in a wide range
    of projects and contexts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ARPlacePrefab`脚本是我们AR菜单应用的核心，我们必须了解它的每一个方法，才能真正掌握交互式AR体验的机制，并在各种项目和环境中成功复制脚本的功能。
- en: In the following code snippets, you’ll notice some lines that have been commented
    out. This is because they reference the **SwabPrefab** script, which hasn’t been
    created yet, and would result in compile errors if left uncommented.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您会注意到一些被注释掉的行。这是因为它们引用了尚未创建的**SwabPrefab**脚本，如果取消注释，将导致编译错误。
- en: 'At the top of the `ARPlacePrefab` script, various public and private variables
    are declared:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ARPlacePrefab`脚本顶部，声明了各种公共和私有变量：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The public variables of the `ARPlacePrefab` script allow users to interact with
    the AR space, such as positioning `ObjectToPlace` or cycling between 3D models
    using `NextPrefabButton` and `PreviousPrefabButton`. They also enable users to
    view details via `InfoText` and `InfoPanel`, as well as activate specific AR placements
    with `PlaceFirstMealButton`. Additionally, they provide a space for extended details
    or options.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARPlacePrefab`脚本的公共变量允许用户与AR空间交互，例如定位`ObjectToPlace`或使用`NextPrefabButton`和`PreviousPrefabButton`在3D模型之间循环。它们还允许用户通过`InfoText`和`InfoPanel`查看详细信息，以及使用`PlaceFirstMealButton`激活特定的AR放置。此外，它们为扩展的详细信息或选项提供了空间。'
- en: On the other hand, the private variables govern the internal mechanics of the
    AR experience. `_arRaycastManager` handles surface detection in the real-world
    environment, while `_placementPose` denotes the desired position for the AR object.
    Its validity is tracked by `_placementPoseIsValid`. Once an object is placed in
    the AR space, it’s referred to as `_placedObject`. Touch gestures utilize `_oldTouchDistance`.
    Lastly, `_placementIndicator` and `_placementGrid` offer visual cues to users,
    indicating where an AR object will be positioned.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，私有变量控制着AR体验的内部机制。`_arRaycastManager`处理真实世界环境中的表面检测，而`_placementPose`表示AR对象的期望位置。其有效性通过`_placementPoseIsValid`跟踪。一旦对象放置在AR空间中，它就被称为`_placedObject`。触摸手势使用`_oldTouchDistance`。最后，`_placementIndicator`和`_placementGrid`为用户提供视觉提示，指示AR对象将放置的位置。
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some lines, related to the yet-to-be-introduced **SwapPrefab** script, have
    been commented out to prevent any compilation issues. We will uncomment them toward
    the end of our scripting process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与尚未引入的**SwapPrefab**脚本相关的行已被注释掉，以防止任何编译问题。我们将在脚本编写过程的最后取消注释它们。
- en: 'The first method of the `ARPlacePrefab` script is the `Start()` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARPlacePrefab`脚本的第一种方法是`Start()`方法：'
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is called when the program first starts. It’s where the initial
    setup for the script is done, such as finding the `_nextButton` and `_previousButton`
    have been commented out because they reference the yet-to-be-created **SwapPrefab**
    script. This script is associated with the two buttons that enable users to cycle
    through various food choices.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序首次启动时，会调用此函数。这是脚本初始设置的地点，例如找到被注释掉的`_nextButton`和`_previousButton`，因为它们引用了尚未创建的**SwapPrefab**脚本。此脚本与两个按钮相关联，允许用户在各种食物选择之间循环。
- en: 'The next method that is called in the `ARPlacePrefab` class is the `Update()`
    method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ARPlacePrefab`类中调用的下一个方法是`Update()`方法：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Update()` method is like the heartbeat of the script, constantly checking
    on things every moment the game is running. If a two-finger touch input is detected,
    it adjusts the scale of the placed object based on how much the distance between
    the fingers changes, similar to a pinch or stretch movement. It also updates the
    placement pose and indicator, which determines where the object will be placed,
    and listens for a single touch input. If a single touch input is detected, it
    places the object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法就像是脚本的脉搏，在游戏运行时的每一刻都在不断检查事物。如果检测到两指触摸输入，它会根据手指之间距离的变化调整放置对象的缩放，类似于捏合或拉伸动作。它还会更新放置姿态和指示器，这决定了对象将被放置的位置，并监听单一触摸输入。如果检测到单一触摸输入，它会放置对象。'
- en: 'The `PlaceObject()` method follows after the `Update()` method and looks like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaceObject()` 方法紧随 `Update()` 方法之后，其形式如下：'
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function is called when a single touch input is detected in the `Update()`
    function. It places the selected object in the real world at the location determined
    by the placement pose. It also positions and activates the next and previous buttons.
    Then, it fetches some information about the currently selected food item and updates
    the `InfoText` UI with this information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `Update()` 函数中检测到单一触摸输入时，此函数会被调用。它将选定的对象放置在现实世界中，位置由放置姿态确定。然后，它定位并激活下一个和上一个按钮。接着，它获取有关当前选定食物项目的某些信息，并使用这些信息更新
    `InfoText` UI。
- en: 'The next method in the `ARPlacePrefab` class is the `UpdatePlacementPose()`
    method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARPlacePrefab` 类中的下一个方法是 `UpdatePlacementPose()` 方法：'
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method is called in the `Update()` function. It acts like the script’s
    eyes in the sense that it’s always looking at the middle of your screen and figuring
    out where in the real world that corresponds to in the virtual world. This method
    updates the placement pose, which is the position and orientation where the new
    object will be placed. It does this by casting a ray from the center of the screen
    and checking if it hits a plane in the AR environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在 `Update()` 函数中被调用。它就像脚本的眼睛，因为它总是在屏幕中间寻找，并确定在现实世界中对应于虚拟世界中的哪个位置。该方法更新放置姿态，即新对象将被放置的位置和方向。它是通过从屏幕中心发射一条射线并检查它是否击中
    AR 环境中的平面来做到这一点的。
- en: 'The `UpdatePlacementIndicator()` method works similarly to the `UpdatePlacementPose()`
    method and looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdatePlacementIndicator()` 方法与 `UpdatePlacementPose()` 方法类似，其形式如下：'
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function is also called in the `Update()` function. It simply moves and
    rotates the placement indicator to match the placement pose, showing the user
    where the object will be placed. It also turns `LineRenderer` on or off, depending
    on whether a suitable location for placing the object was found.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数也在 `Update()` 函数中被调用。它简单地移动和旋转放置指示器以匹配放置姿态，向用户显示对象将被放置的位置。它还根据是否找到了放置对象的合适位置来打开或关闭
    `LineRenderer`。
- en: 'The next method is called `InstantiateButton()` and looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法被称为 `InstantiateButton()`，其形式如下：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `InstantiateButton` method serves as a vital cog in the `ARPlacePrefab`
    class. Its primary role is to create and set up the buttons that users interact
    with to navigate between food choices. When invoked, the method takes in two parameters:
    a button prefab and an action to be executed upon clicking the button.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstantiateButton` 方法在 `ARPlacePrefab` 类中扮演着至关重要的齿轮角色。其主要作用是创建并设置用户与之交互以在食物选择之间导航的按钮。当被调用时，该方法接收两个参数：一个按钮预制件和一个在点击按钮时要执行的操作。'
- en: The method begins by creating a new instance of the button using the provided
    prefab. Once instantiated, the button is initially set to be inactive, ensuring
    it doesn’t immediately appear or interfere with the user interface. Then, the
    method fetches the button’s built-in **On Click** event and attaches the specified
    action to it, ensuring the desired function is executed when the button is pressed.
    Finally, the newly created and configured button is returned by the method, ready
    for use in the AR interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先使用提供的预制件创建一个新的按钮实例。一旦实例化，按钮最初被设置为不活动状态，确保它不会立即出现或干扰用户界面。然后，该方法获取按钮内置的 **On
    Click** 事件并将其指定操作附加到它，确保在按下按钮时执行所需的函数。最后，该方法返回新创建和配置的按钮，以便在 AR 界面中使用。
- en: 'The next two methods in the script act as helper functions. They are called
    `CreatePlacementGrid()` and `PlaceObjectIfNeeded()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的下一个两个方法充当辅助函数。它们被命名为 `CreatePlacementGrid()` 和 `PlaceObjectIfNeeded()`：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `CreatePlacementGrid()` method creates a little grid in the virtual world
    to help you see where your dish will be placed before you place it. If everything
    has been set up correctly, the `PlaceObjectIfNeeded()` method places the food
    prefab in the virtual world and then hides `InfoPanel`, cleaning up your screen.
    Pay attention to the following line in the `CreatePlacementGrid()` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreatePlacementGrid()` 方法在虚拟世界中创建一个小网格，帮助你看到你的菜肴将被放置的位置。如果一切设置正确，`PlaceObjectIfNeeded()`
    方法将在虚拟世界中放置食物预制件，然后隐藏 `InfoPanel`，清理你的屏幕。注意 `CreatePlacementGrid()` 方法中的以下行：'
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we assign a `grid` so that the user sees a visual cue of where the food
    prefab will be placed. Besides using the Unity editor’s interface, C# scripting
    provides us with another way to assign materials to `GameObject` – that is, by
    defining the precise path and name of the material that we want to use. In this
    case, a material named `GridMaterial` is expected to be in the `Resources` folder
    of our project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们分配一个 `grid`，以便用户看到食物预制件将被放置的视觉提示。除了使用 Unity 编辑器的界面外，C# 脚本还为我们提供了另一种将材料分配给
    `GameObject` 的方法——即通过定义我们想要使用的材料的精确路径和名称。在这种情况下，一个名为 `GridMaterial` 的材料预计将位于我们项目的
    `Resources` 文件夹中。
- en: Before continuing with the next few methods, let’s quickly create a material
    called `GridMaterial` in the `Resources` folder of our project. Simply head to
    the `Assets` folder, and select `Resources` and enter it. Right-click inside this
    folder and select `GridMaterial` and select a blue albedo color of your choice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续介绍接下来的几种方法之前，让我们快速在我们的项目“资源”文件夹中创建一个名为 `GridMaterial` 的材料。只需前往 `Assets` 文件夹，选择
    `Resources` 并进入。在文件夹内右键点击，选择 `GridMaterial` 并选择你喜欢的蓝色漫反射颜色。
- en: 'Now, back in the `ARPlacePrefab` class, let’s have a look at the `PinchToScale()`
    and `ScalePlacedObject()` methods, which look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `ARPlacePrefab` 类，让我们看看 `PinchToScale()` 和 `ScalePlacedObject()` 方法，它们看起来是这样的：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As the names of these two methods already suggest, they enable the zoom feature
    of the food prefabs. The `PinchToScale()` method checks whether you’re using two
    fingers to pinch the screen, and if you are, it changes the size of your placed
    object by calling the `ScalePlacedObject()` method. This functionality is very
    useful in the context of our AR menu application as it enables the user to scale
    the displayed food prefab to the desired size.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如这两个方法的名称所暗示的，它们启用了食物预制件的缩放功能。`PinchToScale()` 方法检查你是否正在使用两只手指捏屏幕，如果是，它通过调用
    `ScalePlacedObject()` 方法来改变你放置对象的大小。这种功能在我们的 AR 菜单应用程序的上下文中非常有用，因为它使用户能够将显示的食物预制件缩放到所需的大小。
- en: 'The `PositionButton()` method provides another useful functionality for application
    users. It consists of these components:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionButton()` 方法为应用程序用户提供了另一个有用的功能。它由以下组件组成：'
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `PositionButton()` method ensures the next and previous buttons are always
    near your placed object so that you can easily press them. Hence, this method
    is fundamental to ensure a satisfying user experience of the AR menu application
    across different devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionButton()` 方法确保下一个和上一个按钮始终靠近你的放置对象，这样你可以轻松地按下它们。因此，这个方法对于确保在不同设备上提供令人满意的
    AR 菜单应用程序的用户体验是基本的。'
- en: 'The `UpdateFoodInfoText()` method is another integral part of the`ARPlacePrefab`
    class. Let’s see what the method looks like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateFoodInfoText()` 方法是 `ARPlacePrefab` 类的另一个重要部分。让我们看看这个方法的样子：'
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you’ve placed a food prefab in the environment, the `UpdateFoodInfoText()`
    method tells you more about this specific dish, such as its name, ingredients,
    how many calories it has, and which diet it aligns with. As before, the initial
    lines have been commented out due to their reference to the yet-to-be-created
    **SwapPrefab** script.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在环境中放置了一个食物预制件，`UpdateFoodInfoText()` 方法会告诉你更多关于这个特定菜肴的信息，例如它的名称、成分、有多少卡路里以及它符合哪种饮食。与之前一样，由于它们引用尚未创建的
    **SwapPrefab** 脚本，初始行已被注释掉。
- en: 'Finally, there is only one small script left for you to understand in the `ARPlacePrefab`
    class. It’s the `PositionGrid()` method and it looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `ARPlacePrefab` 类中，你还需要理解一个小脚本。它是 `PositionGrid()` 方法，看起来是这样的：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method simply moves the placement grid to the right spot in the virtual
    world so that it matches where your indicator is pointing in the real world.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地将放置网格移动到虚拟世界中的正确位置，以便它与你在现实世界中的指示器所指的位置相匹配。
- en: With that, you have successfully understood the `ARPlacePrefab` script, which
    is the primary script that’s used in our AR menu application. In the next section,
    you will learn how to attach this script to **AR Session Origin** as a component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就成功理解了 `ARPlacePrefab` 脚本，这是我们 AR 菜单应用中使用的首要脚本。在下一节中，您将学习如何将此脚本作为组件附加到 **AR
    Session Origin**。
- en: Assigning the ARPlacePrefab script as a component
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 ARPlacePrefab 脚本作为组件分配
- en: 'By attaching the main script of any AR application to `ARPlacePrefab` script
    as a component of **AR Session Origin** in the **Inspector** window in the Unity
    editor before progressing to the next step. To do this, simply follow these steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器的 **Inspector** 窗口中，在进入下一步之前，将任何 AR 应用程序的主脚本作为组件附加到 `ARPlacePrefab`
    脚本。为此，只需遵循以下步骤：
- en: Select `ARPlacePrefab` script. By selecting it, the script’s public fields are
    shown in the **Inspector** window.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ARPlacePrefab` 脚本。通过选择它，脚本的可公开字段将在 **Inspector** 窗口中显示。
- en: For the **Object to Place** field, you can assign one of the food prefabs, such
    as **Tofu**, by dragging and dropping it from the **Project** window into the
    corresponding cell.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 **Object to Place** 字段，您可以通过从 **Project** 窗口中将其拖放到相应的单元格来分配一个食物预制件，例如 **Tofu**。
- en: Following the same principle, you can drag and drop **ButtonNext** into the
    **Next Prefab Button** cell, **ButtonPrevious** into the **Previous Prefab Button**
    cell, **FoodInfoText** into the **InfoText** cell, **PlaceFirstMealButton** into
    the **Place First Meal Button** cell, and **InfoPanel** into the **Info** **Panel**
    cell.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照同样的原则，您可以将 **ButtonNext** 拖放到 **Next Prefab Button** 单元格，**ButtonPrevious**
    拖放到 **Previous Prefab Button** 单元格，**FoodInfoText** 拖放到 **InfoText** 单元格，**PlaceFirstMealButton**
    拖放到 **Place First Meal Button** 单元格，以及 **InfoPanel** 拖放到 **Info** **Panel** 单元格。
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **SwapPrefab** cell expects the **SwapPrefab** script, which we are going
    to create and assign in the upcoming sections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**SwapPrefab** 单元格期望的是 **SwapPrefab** 脚本，我们将在接下来的章节中创建并分配它。'
- en: 'Congratulations – you have successfully fulfilled the `ARPlacePrefab` script
    requirement on our roadmap to create an interactive AR menu application! In the
    next section, you will come even closer to the final application by delving into
    the script that swaps our food prefabs: the **SwapPrefab** script.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您 – 您已成功完成我们路线图上创建交互式 AR 菜单应用的 `ARPlacePrefab` 脚本要求！在下一节中，您将通过深入研究交换我们的食物预制件的脚本：**SwapPrefab**
    脚本来更接近最终应用。
- en: Adding the SwapPrefab script to the scene
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 SwapPrefab 脚本添加到场景中
- en: To add the `Assets` folder in the `SwapPrefab`. Double-click on the script to
    open it in your preferred IDE.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `SwapPrefab` 中的 `Assets` 文件夹添加到场景中，双击脚本以在您首选的 IDE 中打开它。
- en: 'The `SwapPrefab` script is tied to the two buttons that allow the user to cycle
    through different food options. It starts like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwapPrefab` 脚本与允许用户循环选择不同食物选项的两个按钮相关联。它看起来是这样的：'
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, you can see the declaration of a list of `Food`
    objects called `AvailableFoods`, a variable to keep track of the current food
    called `currentFoodIndex`, and a reference to the `ARPlacePrefab` script called
    `ARPlacePrefab`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您可以看到名为 `AvailableFoods` 的 `Food` 对象列表的声明，一个用于跟踪当前食物的变量 `currentFoodIndex`，以及一个指向
    `ARPlacePrefab` 脚本的引用 `ARPlacePrefab`。
- en: Next, let’s have a look at the methods of the `SwapPrefab` class to understand
    how the user can cycle through the different dishes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `SwapPrefab` 类的方法，以了解用户如何循环选择不同的菜肴。
- en: 'The first method that is relevant for this is the `Start()` method. It looks
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的第一个方法是 `Start()` 方法。它看起来是这样的：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is called when the scene starts. It grabs a reference to the `ARPlacePrefab`
    script and sets the first food object in the list as the one to be placed in the
    AR environment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在场景开始时被调用。它获取 `ARPlacePrefab` 脚本的引用并将列表中的第一个食物对象设置为在 AR 环境中放置的对象。
- en: 'Next, there is the `SwapFoodPrefab()` method, which looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是 `SwapFoodPrefab()` 方法，它看起来是这样的：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method is linked to a button. When the button is clicked, it advances `currentFoodIndex`
    to the next food in the list or back to the start if it’s at the end and updates
    `objectToPlace` in the `ARPlacePrefab` script to the new food. Then, it immediately
    places the new food object in the AR environment and updates the displayed information
    about the food.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与一个按钮相关联。当按钮被点击时，它将 `currentFoodIndex` 进度推进到列表中的下一个食物，或者如果它在末尾则回到开始，并在 `ARPlacePrefab`
    脚本中更新 `objectToPlace` 到新的食物。然后，它立即在 AR 环境中放置新的食物对象并更新显示的食物信息。
- en: 'The `SwapToPreviousFoodPrefab()` method in the `SwapPrefab` class consists
    of the following lines of code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwapPrefab`类中的`SwapToPreviousFoodPrefab()`方法由以下代码行组成：'
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method works similarly to `SwapFoodPrefab()`, but it goes back to the previous
    food in the list instead of moving forward. If it’s already at the start of the
    list, it loops back to the end. Like `SwapFoodPrefab()`, it then immediately places
    the new food object and updates the displayed information.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与`SwapFoodPrefab()`类似，但它会回到列表中的上一个食物，而不是向前移动。如果它已经在列表的起点，它会循环回末尾。像`SwapFoodPrefab()`一样，然后它会立即放置新的食物对象并更新显示的信息。
- en: 'Lastly, there is the short `GetCurrentFood()` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个简短的`GetCurrentFood()`方法：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a simple helper method that other parts of the program can call to find
    out what the current food is.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的辅助方法，其他程序部分可以调用它来找出当前的食物是什么。
- en: Remember those lines we commented out in the `ARPlacePrefab` script because
    they referenced the `SwapPrefab` script? Now is the time to go back to the `ARPlacePrefab`
    script and uncomment those lines. Once you’ve done this, we can dive into the
    last missing snippets of our AR menu application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在`ARPlacePrefab`脚本中注释掉的那些行吗？因为它们引用了`SwapPrefab`脚本？现在是我们回到`ARPlacePrefab`脚本并取消注释那些行的时候了。一旦完成，我们就可以深入到最后缺失的AR菜单应用程序片段。
- en: Setting up On Click events for the buttons
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为按钮设置点击事件
- en: 'Now, we need to link `SwapPrefab` script by adding **On Click** events to both.
    Follow these steps to do this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过为两个添加**点击**事件来链接`SwapPrefab`脚本。按照以下步骤进行操作：
- en: We need to attach the `SwapPrefab` script to a `GameObject` object in our scene.
    We can do this by creating an empty `GameObject` object in the `GameObject` to
    `PrefabManager` and attach the `SwapPrefab` script to it.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`SwapPrefab`脚本附加到场景中的`GameObject`对象上。我们可以在`GameObject`到`PrefabManager`中创建一个空的`GameObject`对象，并将`SwapPrefab`脚本附加到它上面。
- en: Now, we must link `SwapPrefab` script. Let’s start with `PrefabManager` `GameObject`
    into the object cell. In the drop-down menu, select the `SwapPrefab` | `SwapFoodPrefab()`
    function. This calls the `SwapFoodPrefab()` function of the `SwapPrefab` script,
    whenever **ButtonNext** is pressed. *Figure 6**.3* shows what the **On Click**
    event of **ButtonNext** should look like.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须链接`SwapPrefab`脚本。让我们从将`PrefabManager` `GameObject`拖放到对象单元格开始。在下拉菜单中，选择`SwapPrefab`
    | `SwapFoodPrefab()`函数。这将在**ButtonNext**被按下时调用`SwapPrefab`脚本的`SwapFoodPrefab()`函数。*图6**.3*显示了**ButtonNext**的**点击**事件应该看起来像什么。
- en: "![Figure 6.3 – \uFEFFButtonNext’s On Click event](img/B20869_06_03.jpg)"
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – ButtonNext的点击事件](img/B20869_06_03.jpg)'
- en: Figure 6.3 – ButtonNext’s On Click event
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – ButtonNext的点击事件
- en: Repeat this process for `SwapPrefab` | `SwapToPreviousFoodPrefab()` function
    from the dropdown.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，从下拉菜单中选择`SwapPrefab` | `SwapToPreviousFoodPrefab()`函数。
- en: 'Do you remember the takeaway from the *Assigning the ARPlacePrefab script as
    a component* section in that the `SwapPrefab` script is the last missing cell
    input of the `ARPlacePrefab` script that is attached to `SwapPrefab` script to
    this cell. You can do this in a few, simple steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在*将ARPlacePrefab脚本作为组件分配*部分中的要点吗？即`SwapPrefab`脚本是附加到`SwapPrefab`脚本的`ARPlacePrefab`脚本中最后缺失的单元格输入。你可以通过以下几个简单的步骤来完成：
- en: Select **AR Session Origin** in the **Scene** **Hierarchy** window.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景****层次结构**窗口中选择**AR Session Origin**。
- en: Search for `SwapPrefab` via the search bar of the **Project** window.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**项目**窗口的搜索栏搜索`SwapPrefab`。
- en: Now, drag and drop the script into the respective cell of the AR Session Origin’s
    `ARPlacePrefab` script component in the `ARPlacePrefab` script component should
    look like now.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将脚本拖放到AR Session Origin的`ARPlacePrefab`脚本组件的相应单元格中。`ARPlacePrefab`脚本组件现在应该看起来像这样。
- en: "![Figure 6.4 – \uFEFFThe ARPlacePrefab script component of AR Session Origin\
    \ once all of its cells have been correctly assigned](img/B20869_06_04.jpg)"
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 当所有单元格都正确分配后，AR Session Origin的ARPlacePrefab脚本组件](img/B20869_06_04.jpg)'
- en: Figure 6.4 – The ARPlacePrefab script component of AR Session Origin once all
    of its cells have been correctly assigned
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 当所有单元格都正确分配后，AR Session Origin的ARPlacePrefab脚本组件
- en: 'Before testing the scene on your PC or deploying it to your phone, there is
    one last step you have to take: add some nutritional information to our food prefabs.
    This can be done very easily:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在在您的PC上测试场景或将其部署到手机之前，您必须采取最后一步：为我们的食物预制件添加一些营养信息。这可以非常容易地完成：
- en: Select **PrefabManager** in the **Scene Hierarchy** window and navigate to the
    **Inspector** window.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景层次结构**窗口中选择**PrefabManager**，然后导航到**检查器**窗口。
- en: In the `SwapPrefab` script component, click the **+** button three times to
    add three dishes to our AR menu application.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SwapPrefab`脚本组件中，点击**+**按钮三次，将三个菜品添加到我们的AR菜单应用中。
- en: Insert the names, nutritional information, diet type, and prefabs of our three
    dishes, namely **French Fries**, **Tofu**, and **Kashipan**, into the respective
    cells, as shown in *Figure 6**.5*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们三个菜品的名称、营养成分信息、饮食类型和预制件，即**薯条**、**豆腐**和**咖喱饭**，插入到相应的单元格中，如图*图6.5*所示。
- en: "![Figure 6.5 – \uFEFFThe inserted names, nutritional information, diet type,\
    \ and prefabs of our three dishes in the PrefabManager’s SwapPrefab script component](img/B20869_06_05.jpg)"
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 在PrefabManager的SwapPrefab脚本组件中插入的三个菜品的名称、营养成分信息、饮食类型和预制件](img/B20869_06_05.jpg)'
- en: Figure 6.5 – The inserted names, nutritional information, diet type, and prefabs
    of our three dishes in the PrefabManager’s SwapPrefab script component
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 在PrefabManager的SwapPrefab脚本组件中插入的三个菜品的名称、营养成分信息、饮食类型和预制件
- en: With that, you have completed the final step in our roadmap to create an interactive
    AR menu application. To celebrate this milestone, the next section explains how
    you can explore the different features of your newly developed AR application
    on your mobile device.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您已经完成了创建交互式AR菜单应用的路线图中的最后一步。为了庆祝这一里程碑，下一节将解释您如何在您的移动设备上探索您新开发的AR应用的不同功能。
- en: Exploring the completed, interactive AR menu application on a mobile device
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动设备上探索完成的交互式AR菜单应用
- en: To test your interactive AR menu application on your PC or deploy it onto your
    mobile device, please refer to the step-by-step instructions provided in the *Deploying
    AR experiences onto mobile devices* section of [*Chapter 4*](B20869_04.xhtml#_idTextAnchor011).
    *Figure 6**.6* shows you what should be displayed on your screen once you have
    successfully deployed the AR menu application onto your mobile device and opened
    it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的PC上测试您的交互式AR菜单应用或将它部署到您的移动设备上，请参阅[*第4章*](B20869_04.xhtml#_idTextAnchor011)中“将AR体验部署到移动设备”部分提供的逐步说明。*图6.6*展示了您成功将AR菜单应用部署到您的移动设备并打开后屏幕上应该显示的内容。
- en: "![Figure 6.6 – \uFEFFThe initial screen of the newly deployed AR menu application\
    \ on a mobile device](img/B20869_06_06.jpg)"
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 在移动设备上新部署的AR菜单应用的初始屏幕](img/B20869_06_06.jpg)'
- en: Figure 6.6 – The initial screen of the newly deployed AR menu application on
    a mobile device
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 在移动设备上新部署的AR菜单应用的初始屏幕
- en: Notice how we can see the instruction text, which familiarizes the user with
    the nature of the application, and the button at the bottom of the application,
    which the user has to press to place the first dish on the detected plane. You
    can also see the two buttons that the user can press to see the next or previous
    prefab. If there is a horizontal plane in your scene, you will see the blue placement
    grid element in the center of your screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何看到说明文本，它使用户熟悉应用的本质，以及应用底部的按钮，用户必须按下此按钮才能将第一道菜放置在检测到的平面上。您还可以看到用户可以按下的两个按钮，用于查看下一个或上一个预制件。如果您的场景中有一个水平平面，您将在屏幕中央看到蓝色的放置网格元素。
- en: '*Figure 6**.7* shows what the screen of your device should look like once you
    have pressed the **Place First** **Meal** button.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.7* 展示了您按下**放置第一餐**按钮后，设备屏幕应该看起来是什么样子。'
- en: "![Figure 6.7 – \uFEFFThe screen of the AR menu application on a mobile device\
    \ once the “Place First Meal” button has been pressed](img/B20869_06_07.jpg)"
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 在按下“放置第一餐”按钮后，移动设备上的AR菜单应用屏幕](img/B20869_06_07.jpg)'
- en: Figure 6.7 – The screen of the AR menu application on a mobile device once the
    “Place First Meal” button has been pressed
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 按下“放置第一餐”按钮后，移动设备上的AR菜单应用屏幕
- en: By touching the screen with two of your fingers and moving them closer together
    or further apart, you can scale the **French Fries** to become bigger or smaller.
    By changing the rotation of your mobile device after the first food prefab has
    been placed and clicking on the **->** button, the next food prefab should be
    placed at the new position, as indicated by the blue placement grid element.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用两个手指触摸屏幕并将它们靠近或分开，您可以调整**薯条**的大小，使其变大或变小。在放置第一个食物预制件后，更改您的移动设备的旋转并点击**->**按钮，下一个食物预制件应该放置在新的位置，如蓝色放置网格元素所示。
- en: The upcoming section offers a summary of the valuable skills you’ve acquired
    in your journey to create XR applications in Unity. Specifically, you’ve harnessed
    the power of C# scripting to craft interactive AR applications. This newfound
    expertise marks a significant enhancement to your repertoire, expanding your capacity
    to develop sophisticated XR experiences.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的部分为您在Unity中创建XR应用之旅中获得的宝贵技能提供了一个总结。具体来说，您已经利用C#脚本来制作交互式AR应用。这种新获得的专业技能对您的技能组合是一个重大的提升，扩大了您开发复杂XR体验的能力。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, you’ve embarked on the exciting journey of building
    your very first interactive AR application, testing it meticulously on your mobile
    device. This experience should have empowered you to evaluate prospective AR app
    ideas critically in terms of their utility.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开始了构建您第一个交互式AR应用的激动人心的旅程，并在您的移动设备上对其进行了细致的测试。这次经历应该使您能够从实用性角度批判性地评估潜在的AR应用想法。
- en: Leveraging intuitive design patterns, you should now feel equipped to create
    engaging AR applications that allow users to interact seamlessly with virtual
    objects within a real-world context. From establishing the core components of
    the AR app, such as user interface and text elements, to invoking their interactivity
    through C# scripting, you’re now well-equipped to create a diverse array of interactive
    AR applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 利用直观的设计模式，您现在应该感到有足够的装备来创建引人入胜的AR应用，使用户能够无缝地在现实世界环境中与虚拟对象互动。从建立AR应用的核心组件，如用户界面和文本元素，到通过C#脚本调用它们的交互性，您现在已经准备好创建各种交互式AR应用。
- en: These applications will breathe life into virtual objects placed within real-world
    environments, inviting users to interact with them in significant and captivating
    ways. Congratulations on reaching this milestone in your AR development journey.
    You are now more than capable of bringing your creative AR ideas to life.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用将为放置在现实世界环境中的虚拟对象注入生命，邀请用户以重要且引人入胜的方式与之互动。恭喜您在AR开发之旅中达到这一里程碑。您现在完全有能力将您的创意AR想法变为现实。
- en: Looking forward, the next chapter promises to elevate your VR development skills
    to a new level. It’s all about adding magic to your VR scenes through audio and
    visual effects. The upcoming chapter will delve into the theory of audio in Unity,
    guide you through the process of incorporating audio sources and mixers, and unveil
    the secrets of adding particle effects and animations to your VR experiences.
    The road ahead is set to be an exciting journey of discovery and application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章将承诺将您的VR开发技能提升到新的水平。这全部都是为了通过音效和视觉效果为您的VR场景增添魔力。即将到来的章节将深入探讨Unity中音频的理论，引导您通过整合音频源和混音器的过程，并揭示将粒子效果和动画添加到您的VR体验中的秘密。前方的道路注定是一场激动人心的发现与应用之旅。
