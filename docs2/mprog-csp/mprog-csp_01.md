# 1

# 元编程如何对你有益？

那么，什么是**元编程**，为什么你应该关心？如果你拿起这本书希望学习关于**元宇宙**编程的知识，你很快就会非常失望。

元编程全部关于代码将其他代码视为数据。这可能只是为了理解和推理代码，或者实际上基于元数据通过结构或显式添加来隐式地创建新代码。

“但我为什么要关心这些呢？”你可能会问，“难道仅仅编写代码并交付就足够了吗？”在本章中，我们将探讨从进行元编程中可以获得的实际好处，以及它如何使你日常受益。我们还将提供有关如何提高生产力和消除我们开发者往往必须做的繁琐任务的技巧。

本章的主要目标是向你介绍元编程及其用例示例。在这个过程中，我们将了解.NET 为元编程提供的构建块。在本章中，我们将涵盖以下主题：

+   对你的代码进行推理

+   移除手动结构和流程

到本章结束时，你应该对元编程如何对你有益有一些很好的想法和灵感。你也应该对元编程的实质有所了解。

# 对你的代码进行推理

软件行业非常年轻。在过去的 20-30 年里，我们看到了其使用的显著增长。

今天，软件已经融入我们生活的方方面面——我们的工作、我们的交通，以及我们的家庭，甚至包括我们许多人安装的智能灯泡。

由于我们制作的软件的应用范围和用户众多，软件有相应的期望。今天的用户对软件的期望远高于 20 年前。由于软件在我们的生活中如此根深蒂固，我们变得更加脆弱，这使其成为一个风险因素。

在本节中，我们将讨论为什么作为开发者的你应该关心元编程。我们将探讨开发者的关注点，如何进行一些巧妙的自动化，并介绍元编程的一些基础知识。

## 开发者关注点

对于我们开发者来说，我们需要涵盖很多不同的方面来保证我们软件的成功。

最终用户对优秀的用户体验有很高的期望，他们希望被置于成功的顶峰。我们还需要对我们的系统将拥有的不同类型的用户表示同情，并确保它对每个人都是可访问的。

我们的系统需要保持其数据的完整性，并帮助最终用户做正确的事情。为此，我们需要根据我们期望的或我们的数据模型要求的来验证所有输入。此外，我们还需要有强制执行系统完整性的业务规则。

数据也是我们想要保护的东西，因此安全性扮演着重要的角色。用户需要进行身份验证，我们还想确保用户有执行系统不同任务的正确授权。

我们还必须确保我们的系统没有安全漏洞，否则黑客可以入侵系统。用户的输入也需要被清理，以防止通过诸如**SQL 注入**之类的恶意攻击。

为了让我们的软件对用户可用，我们需要确保它在某处运行，无论是在本地服务器上还是在托管合作伙伴的服务器上，或者在云中，无论是物理的还是虚拟的。这意味着我们需要考虑如何打包软件，然后如何将其部署到运行环境中。

一旦运行，我们必须确保它始终运行，没有停机时间；我们的用户依赖于它。为此，我们希望考虑运行多个系统实例，以便在主实例出现故障时可以切换到第二个实例。

我们还需要确保运行环境能够处理它所针对的用户数量。

我们不仅要有故障转移实例，还可以水平扩展并有一个负载均衡机制，将用户分散到我们拥有的不同实例中。这使得我们的系统成为一个分布式系统。

这些都是很多不同的关注点。理想情况下，你希望有不同的人做不同方面的工作，但这种情况并不总是如此（取决于组织的规模以及其文化）。今天，你经常在招聘广告中看到公司正在寻找*全栈开发者*。在许多情况下，这可能意味着期望你需要与以下所有方面合作：

+   **用户体验**：这关乎交互、流程以及整体的感觉

+   **可访问性**：这涉及到创建对残疾人友好的同理心软件

+   **前端代码**：这是布局、样式以及使用户体验生动起来的必要逻辑

+   **后端代码**：这是为了创建代表我们正在工作的领域的粘合剂

+   **数据建模**：这是我们如何存储数据以及如何为我们需要的用途建模

+   **身份验证和授权**：这是为了确保用户已经通过身份验证，并且对不同的功能应用了适当的授权策略

+   **安全**：这使得应用程序能够抵御任何攻击并保护数据

+   **DevOps**：这涉及到及时地将功能交付到生产环境中，而不需要任何仪式

## 自动化

作为人类，我们会犯错，会忘记事情。有时，这会有一些非常糟糕的结果，比如系统崩溃，或者更糟的是，被黑客入侵。

幸运的是，计算机擅长执行它们被告诉的事情并且无限重复。它们从不抱怨，也不犯错误。这意味着我们有大量工作流程简化的机会。随着行业多年的成熟，我们看到了改进的工作流程和工具，这些可以帮助我们实现我们的目标，通常可以消除繁琐和耗时的工作。

自动化的一个绝佳例子是过去十年云计算领域所发生的变化。在此之前，我们必须设置物理硬件，并且通常需要手动流程将我们的软件部署到该硬件上。这一切已经完全改变，我们现在只需点击几下就能启动我们想要的一切，将其连接到一些持续部署软件，它会构建我们的软件，并自动将其部署到运行环境中。所有这些都可以在几分钟内完成，而不是几个小时或几天。

## 元编程

我为什么要讲这么多？这本书不是应该讲关于元编程的内容吗？

元编程全部关于围绕你的代码的附加信息。这些信息有时是隐含的——也就是说，它已经存在。然而，有时它需要你作为开发者明确或故意地添加。

运行软件的计算机只理解存储在内存中并为 CPU 执行准备的机器语言指令。对我们人类来说，这不太直观。早期，我们发明了可以帮助我们编写更友好、更容易推理的语言。这始于**汇编语言**，后来是能够编译成汇编语言的高级语言。

使用这些工具，我们获得了不仅仅是将一种语言翻译成另一种语言的能力，还可以推理我们的代码中正在发生的事情。1978 年，贝尔实验室的 Stephen C. Johnson 提出了他称之为**lint**的工具——一个静态代码分析工具，可以用来推理 C 代码并检测其潜在问题。如今，这已成为大多数编程语言的常见做法。对于**JavaScript**或**TypeScript**的 Web 开发，我们通常可以在构建管道中添加像**ESLint**这样的工具来完成这项工作。对于**C#**，这已经内置到编译器中，并且使用 Roslyn 编译器，它可以完全通过我们自己的自定义规则进行扩展，这一点我们将在*第十七章*，*静态代码分析*中介绍。

对于像**C**/**C++**这样的编程语言，它们编译成在 CPU 上本地运行的代码，我们在编译级别上所能推理的有限。然而，对于像 Java 或 C#这样的编程语言，通常被称为托管语言，我们现在在托管环境中运行代码。我们编写的代码编译成中间语言，在运行时会被即时翻译。这些语言携带有关我们编写的代码的信息——这被称为**元数据**。这使得我们可以在运行时将我们的程序或他人视为数据，并允许我们推理代码；我们甚至可以在运行时发现代码。

从*C#的*第一个版本开始，我们可以添加额外的信息和更多的元数据。通过使用 C# **特性**，我们可以给类型、类型上的属性和方法添加额外的信息。这些信息会传递到运行程序中，我们可以用它来对软件进行推理。

例如，对于属性，我们现在可以添加额外的信息，我们可以在编译时和运行时对其进行分析。我们可以做诸如在对象上标记验证信息，例如**[必需]**：

```cs
public class RegisterPerson
{
    [Required]
    public string FirstName { get; set; }
    [Required]
    public string LastName { get; set; }
    [Required]
    public string SocialSecurityNumber { get; set; }
}
```

这段代码表示注册一个人所需的内容。我们需要的所有属性都有**[必需]**属性作为元数据。

现在我们已经将元数据添加到代码中，我们可以根据它采取具体行动。

# 移除手动结构和流程

添加显式元数据对于可见性很好，并且使代码中添加的元数据类型非常明确。然而，这些元数据本身是不可执行的。这意味着没有什么是固有的来处理它——例如，我们看到的属性是必需的。

这种元数据使我们能够不仅对围绕我们的代码的元数据进行推理，而且将其付诸行动。我们可以构建我们的系统，使其利用这些信息为我们做出决策，或者我们可以自动化繁琐的任务。

在我的整个职业生涯中，我见到的最常见的事情是我称之为**步骤驱动开发**。代码库往往会固定一种结构，并且在创建其中的功能时，开发者需要执行一系列特定的操作。这些*步骤*通常被记录为代码库文档的一部分，每个人都需要阅读并确保遵循。这并不一定是一件坏事，我认为所有代码库都有这种程度的情况。

退一步，可能会有一些潜在的改进我们的生产力和减少代码量的机会。这些步骤和模式可以被形式化和自动化。这样做的主要原因是因为遵循步骤可能会出错。我们可能会忘记做某事或者做错，甚至可能混淆步骤的顺序。

假设你有一个 API，并且对于每个操作，你都有以下步骤：

+   检查用户是否有权限

+   检查所有输入是否有效

+   检查恶意输入（例如，SQL 注入）

+   检查操作是否被域逻辑允许，通常是特定于业务的规则

+   执行业务逻辑

+   根据是否成功返回正确的 HTTP 状态码和结果

这些都是在同一个地方混合了很多关注点。在这个时候，你可能认为这不是我们在现代**ASP.NET** API 开发中做事的方式。这是正确的——它们通常被分成关注点和像 SQL 注入这样的管道处理的事情。

重要提示

我们将在*第三章*“通过现有*现实世界示例*去神秘化”中重新审视 ASP.NET 如何利用元编程来提供开发者体验。

即使这些事情可能不在同一种方法中且分散开来，它们仍然是我们必须注意的问题，因此食谱会明确指出这些事情需要被执行。通常，它们是重复的，并且有可能被优化以提高开发者的体验，同时降低系统发生致命错误的风险。

## 软件维护

这种重复代码的另一个方面是，我们添加到系统中的所有代码都需要维护。构建一个功能可能不会花费太多时间，但很可能会需要多年维护。可能不是由你维护，而是由团队中的其他人或你的继任者维护。因此，我们应该首先优化我们的代码库以适应维护。及时推出功能是我们所期望的，但如果我们不考虑代码的维护，作为代码的所有者，当需要维护时，我们将遭受痛苦。

维护不仅仅是保持代码正常运行并履行其承诺。它还关乎其适应和适应新需求的能力，无论是业务需求还是技术需求。项目的初期正是你对它了解最少的时候。

因此，为此进行规划非常困难，需要我们能够预测未来。但我们可以编写代码，使其更适应变化。

而不是在所有地方重复所有这些代码，我们可以在代码中放入元数据，我们可以利用这些数据。这通常是 ASP.NET 所支持的——例如，对于控制器的授权，使用**[Authorize]**属性。它需要满足特定的策略，例如用户必须处于某个角色。如果我们的系统为我们的功能有明确的结构，你可能会发现属于特定角色的功能自然分组。然后我们可以通过查看类型上的命名空间元数据并设置正确的授权规则来推理这种结构。对于开发者来说，你通过结构替换了显式信息的需求，使其变得隐式。这看起来可能是一件小事，但整个代码库的生命周期中，这种思维方式可以对生产力和可维护性产生巨大影响。

## 代码生成

使用 C#，我们可以比仅仅推理代码和基于我们找到的内容做出决策更进一步——我们可以生成代码。如果拥有所有必要的信息或被推到运行时级别，代码生成可以在编译时进行。这提供了更多的灵活性，并赋予我们巨大的力量。

例如，如果你曾经使用过基于 XAML 的前端技术，如 **Windows Presentation Foundation** (**WPF**) 或 **Universal Windows Platform** (**UWP**)，并使用过数据绑定，你可能已经遇到过 **INotifyPropertyChanged** 接口。它的目的是使视图控件能够通知你，当绑定到视图的对象的属性值发生变化时。

假设你有一个表示人的对象：

```cs
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
```

现在，假设我们想要在任何一个属性发生变化时显示这个通知。使用用于绑定目的的 **INotifyPropertyChanged** 接口，对象需要扩展为以下内容：

```cs
public class Person : INotifyPropertyChanged
{
    private string _firstName;
    public string FirstName
    {
        get { return _firstName; }
        set
        {
            _name = value;
            RaisePropertyChanged("FirstName");
        }
    }
    public string LastName { get; set; }
    public event PropertyChangedEventHandler
      PropertyChanged;
    protected void RaisePropertyChanged(string
      propertyName)
    {
        if (PropertyChanged != null)
        {
            PropertyChanged(this, new
              PropertyChangedEventArgs(propertyName));
        }
    }
}
```

正如你所见，创建属性现在变得非常繁琐。想象一下，如果对象的所有属性都这样做。这很容易变成难以阅读的代码，需要维护的代码更多，而且这并没有给你的代码增加任何业务价值。

这可以通过最新的 C# 编译器版本得到改进。

几年前，微软重写了 C# 编译器。编译器被命名为 Roslyn。他们重写编译器有几个原因，其中之一是他们希望编译器本身是用 C# 编写的——这是语言和 .NET 运行时成熟度的证明。此外，作为微软向开源转变的一部分，重写并在公开环境中进行，放弃旧的许可模式更有意义。但在我看来，最重要的原因是使其更具可扩展性，而不仅仅是针对微软自身，而是针对所有人。

这种可扩展性的一部分被称为 Roslyn 代码生成。有了它，我们可以使代码非常接近原始代码。让我们假设我们引入了一些元数据，形式为 **[Bindable]** 属性，并创建了一个编译器扩展，将所有私有字段转换为需要的 **InotifyPropertyChanged** 属性。在这里，我们的对象看起来是这样的：

```cs
[Bindable]
public class Person
{
    private string _firstName;
    private string _lastName;
}
```

我们也可以在运行时做这件事。然而，在运行时，我们受限于已编译的内容，无法更改类型。因此，方法会有所不同。我们不会更改现有类型，而是需要创建一个新的类型，它继承自原始类型并对其进行扩展。这要求我们将原始属性设置为 **virtual**，以便在生成的类型中覆盖它们：

```cs
[Bindable]
public class Person
{
    public virtual string FirstName { get; set; }
    public virtual string LastName { get; set; }
}
```

为了使这可行，我们需要一个工厂，它知道如何创建这些对象。我们需要在需要其实例时调用它。

权力越大，责任也越大，而且选择走这条路需要非常谨慎。我们将在 *第十八章* 中讨论，*注意事项和* *结语*。

我们将在 *第十五章* 中更深入地讨论 Roslyn 可扩展性，*Roslyn 编译器扩展*。

## 编译时安全性

有时候我们也必须添加某些元数据以使系统正常工作。这将是为 Roslyn 编译器编写代码分析器的候选任务。分析器将找出缺少的内容，并尽快通知开发者，从而提供一个紧密的反馈循环，而不是让开发者必须在运行时发现这个问题。

例如，在我工作的一个名为 **Cratis** ([`cratis.io`](https://cratis.io)) 的平台上，这是一个事件源平台。对于所有被持久化的事件，我们都需要一个唯一标识符来表示事件的类型。这个标识符作为事件的属性被添加：

```cs
[EventType("66f58b90-c027-41b3-aa2c-2cfd18e7db69")]
public record PersonRegistered(string FirstName, string LastName);
```

当在事件日志上调用 **Append()** 方法时，类型必须与唯一标识符相关联。如果事件类型与 .NET 类型之间没有关联，**Append()** 方法将抛出异常。这是一个在编译时检查发送到 **Append()** 方法的任何内容以及检查对象类型是否具有 **[****EventType]** 属性的绝佳机会。

我们将在 *第十七章*，*静态代码分析* 中重新回顾所有这些内容。

# 摘要

希望你现在已经了解了元编程的巨大潜力。它非常强大。这伴随着巨大的责任——在编译时间或运行时神秘添加的代码与每个代码文件中的明确性之间的平衡是困难的。根据我的经验，新开发者进入一个有很多隐式自动化的代码库时可能会遇到麻烦，并可能最终不相信这种魔法。

但过了一段时间后，一旦他们习惯了，他们往往想要更多的魔法。一旦你有了经验，这些好处是显而易见的，但一开始可能会有些可怕。为了解决这个问题，你应该沟通你所拥有的自动化。这样至少会让它更符合 *最小惊讶原则*。

在下一章中，我们将深入探讨元编程的更具体的概念，并探讨这些概念背后的内容。我们将熟悉 .NET 运行时如何看待代码以及它产生的元数据，以及如何在运行中的应用程序中利用这些数据。最后，我们将学习如何扩展这些元数据。
