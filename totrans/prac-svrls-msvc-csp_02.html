<html><head></head><body>
<div id="_idContainer050">
<h1 class="chapterNumber"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 class="chapterTitle" id="_idParaDest-29"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.2.1">Demystifying Microservices Applications</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Over the last decade, microservices architecture has taken a central role in modern software development. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will define what microservices architecture is. </span><span class="koboSpan" id="kobo.3.3">You will learn the reasons behind the success of microservices, their pros and cons, and when it is worth adopting them. </span><span class="koboSpan" id="kobo.3.4">Starting with the problems that led to their conception, we will discuss typical scenarios of when to use them, the impact of their adoption on overall project costs, and the returns you might expect.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">You will get insights into the organization of microservices, discovering how it differs from the usual monolithic application by resembling more of an assembly line than user-requests-driven processing. </span><span class="koboSpan" id="kobo.4.2">This newly conceived organization brings with it new challenges that require ad hoc techniques to enforce coherence, coordination, and reliability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">Moreover, new patterns and best practices have been created to tackle challenges with microservices and optimize their advantages. </span><span class="koboSpan" id="kobo.5.2">We will introduce and summarize some fundamental patterns here, while their practical implementation, together with more specific patterns, will be detailed throughout the remainder of the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">More specifically, this chapter covers the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">The rise of </span><strong class="keyWord"><span class="koboSpan" id="kobo.8.1">Service-Oriented Architectures</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.10.1">SOAs</span></strong><span class="koboSpan" id="kobo.11.1">) and microservices</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">The definition and </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.13.1">organization of microservices architecture</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">When is it worth adopting microservices architectures?</span><a id="_idTextAnchor040"/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Microservices common patterns</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-30"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.16.1">The rise of Service-Oriented Architectures (SOAs) and microservices</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Briefly defined, microservices are chunks of software deployed on computer networks that communicate through network protocols. </span><span class="koboSpan" id="kobo.17.2">However, this is not all; they must also obey a set of further constraints.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">Before giving a more detailed definition of what a microservices architecture is, we must understand how the idea of microservices evolved and what kind of problems it was called to solve. </span><span class="koboSpan" id="kobo.18.2">We will describe the two main steps of this evolution across two separate subsections.</span></p>
<h2 class="heading-2" id="_idParaDest-31"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.19.1">The rise of SOA</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.20.1">The first step in the direction of </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.21.1">microservices was taken by the so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.22.1">service-oriented architectures</span></strong><span class="koboSpan" id="kobo.23.1">, or </span><strong class="keyWord"><span class="koboSpan" id="kobo.24.1">SOAs</span></strong><span class="koboSpan" id="kobo.25.1">, that is, architectures based on networks of communicating processes. </span><span class="koboSpan" id="kobo.25.2">Initially, SOAs were implemented as web services similar to the ones you might have already experienced in ASP.NET Core.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">In an SOA, different macro-modules that implement different features or roles in software applications are exposed as separate processes that communicate with each other through standard protocols. </span><span class="koboSpan" id="kobo.26.2">The first SOA implementation was web services communicating through the XML-based SOAP protocol. </span><span class="koboSpan" id="kobo.26.3">Then, most web services architectures moved toward JSON-based web APIs, which you might already know about since REST web services are available as standard ASP.NET project templates. </span><span class="koboSpan" id="kobo.26.4">The </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Further reading</span></em><span class="koboSpan" id="kobo.28.1"> section contains useful links that provide more details on REST web services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.29.1">SOAs were conceived during the boom in the creation of software for business applications as one of the ways to integrate the various preexisting applications used by different branches and divisions into a unique company information system. </span><span class="koboSpan" id="kobo.29.2">Since the preexisting applications were implemented with different technologies, and the software expertise available in the various branches and divisions was heterogeneous, SOA was the answer to the following compelling needs:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.30.1">Enabling software communication between modules implemented with different technologies and running on different platforms (Linux + Apache, Linux + NGINX, or Windows + IIS). </span><span class="koboSpan" id="kobo.30.2">In fact, software based on different technologies is not binary compatible, but it can still cooperate with others if each of them is implemented as a web service that communicates with the others through a technology-independent standard protocol. </span><span class="koboSpan" id="kobo.30.3">Among them, it is worth mentioning the text-based HTTP REST protocol and the binary gRPC protocol. </span><span class="koboSpan" id="kobo.30.4">Worth mentioning also is that the HTTP REST protocol is an actual standard while at the moment, gRPC is just a de facto standard proposed by Google. </span><span class="koboSpan" id="kobo.30.5">The </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Further reading</span></em><span class="koboSpan" id="kobo.32.1"> section contains useful links for getting more details about these protocols.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.33.1">Enabling the versioning of each macro-module to evolve independently from the others. </span><span class="koboSpan" id="kobo.33.2">For instance, you might decide to move some web service toward the new .NET 9 version to take advantage of new .NET features or new, available libraries, while leaving other web services that don’t need modifications with a previous version, say, .NET 8.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.34.1">Promoting public web services that offer services to other applications. </span><span class="koboSpan" id="kobo.34.2">As an example, think of the various public services offered by Google, such as Google Maps, or the </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.35.1">artificial intelligence services offered by Microsoft, such as language translation services.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.36.1">Below is a diagram that summarizes classical SOA.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.37.1"><img alt="" role="presentation" src="../Images/B31916_02_1.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.38.1">Figure 2.1: SOA</span></p>
<ol>
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.39.1">Over time, the company information system and other complex SOA applications conquered more markets and users, so new needs and constraints appeared. </span><span class="koboSpan" id="kobo.39.2">We will discuss them in the next subsection.</span></li>
</ol>
<h2 class="heading-2" id="_idParaDest-32"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.40.1">Toward microservices architectures</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.41.1">As application users and traffic increased up to a different order of magnitude, the optimization of performance and the optimal balancing</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.42.1"> of hardware resources among the various software modules became a </span><em class="italic"><span class="koboSpan" id="kobo.43.1">must</span></em><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">This led to a new requirement:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.45.1"> Each software module must be scalable independently from the others so that we can allocate to each module the optimal quantity of resources it needs.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.46.1">As the company information system gained a central role, its continuous operation, that is, almost zero downtime, became a </span><em class="italic"><span class="koboSpan" id="kobo.47.1">must</span></em><span class="koboSpan" id="kobo.48.1">, leading to another important constraint:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.49.1"> Microservices architecture must be redundant. </span><span class="koboSpan" id="kobo.49.2">Each software module must have several replicas running on different hardware nodes to resist software crashes and hardware failures.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.50.1">Moreover, to adapt each application to a rapidly evolving market, the requirements on the development times became more compelling. </span><span class="koboSpan" id="kobo.50.2">Accordingly, more developers were needed to develop and maintain each application with the given strict milestones.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.51.1">Unfortunately, handling software projects involving more than around four people to the required quality </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.52.1">proved to be substantially impossible. </span><span class="koboSpan" id="kobo.52.2">So, a new constraint was added to SOAs:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.53.1"> The services composing an application must be completely independent of each other so that they can be implemented by loosely interacting separate teams.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.54.1">However, the maintenance effort also needed to be optimized, yielding another important constraint:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.55.1"> Modifications to a service must not propagate to other services. </span><span class="koboSpan" id="kobo.55.2">Accordingly, each service must have a well-defined interface that doesn’t change with software maintenance (or that, at least, rarely changes). </span><span class="koboSpan" id="kobo.55.3">For the same reason, design choices adopted in the implementation of a service must not constrain any other application service.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.56.1">The first and second requirements can be satisfied by implementing each software module as a separate service so that we might allocate more hardware resources to it by simply replicating it in N different instances as needed to optimize the overall performance and ensure redundancy.</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.57.1">We also need a new actor, something that decides how many copies of each service to use and on what hardware to place them. </span><span class="koboSpan" id="kobo.57.2">There are similar entities called </span><strong class="keyWord"><span class="koboSpan" id="kobo.58.1">orchestrators</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">It is worth</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.60.1"> pointing out that we might also have several orchestrators, each taking care of a subset of the services, or no orchestrator at all!</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.61.1">Summing up, we moved from applications made of coarse-grained coupled web services to fine-grained and loosely coupled microservices, each implemented by a different developer team, as shown in the following figure.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.62.1"><img alt="Figure 2.2: Microservices architecture" src="../Images/B31916_02_2.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.63.1">Figure 2.2: Microservices architecture</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.64.1">The diagram shows fine-grained microservices assigned to different loosely coupled teams. </span><span class="koboSpan" id="kobo.64.2">It is worth pointing out that while loose coupling was also an initial target for the primordial </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.65.1">web services architectures, it took time to improve to a good level, till reaching its peak with the advent of microservices techniques.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.66.1">The preceding diagram and requirements do not define exactly what microservices are; they just explain the start of the microservices era. </span><span class="koboSpan" id="kobo.66.2">In the next section, we will give a more formal definition of microservices that reflects their current stage of evolution.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-33"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.67.1">The definition and organization of microservices architectures</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.68.1">In this section, we will give a </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.69.1">definition of microservices and detail their immediate consequences on an organization, distinguishing between the </span><em class="italic"><span class="koboSpan" id="kobo.70.1">microservices definition</span></em><span class="koboSpan" id="kobo.71.1">, which is expected to change gradually over time, and </span><em class="italic"><span class="koboSpan" id="kobo.72.1">microservices practical organization</span></em><span class="koboSpan" id="kobo.73.1">, which might evolve at a faster rate as new technologies appear.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.74.1">In the first subsection, we will focus on the definition and its immediate consequences.</span></p>
<h2 class="heading-2" id="_idParaDest-34"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.75.1">A definition of microservices architectures</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.76.1">Let’s first list all the microservices</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.77.1"> requirements. </span><span class="koboSpan" id="kobo.77.2">Then, we will discuss each of them in a separate subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.78.1">A microservices architecture is an architecture based on SOA that satisfies all the constraints below:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.79.1">Module boundaries are defined according to the domain of expertise they require. </span><span class="koboSpan" id="kobo.79.2">As we will discuss in the subsections below, this should ensure they are loosely coupled.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.80.1">Each module is implemented as a </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.81.1">replicable service, called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.82.1">microservice</span></strong><span class="koboSpan" id="kobo.83.1">, where replicable means one can create several instances of each service to enforce scalability and redundancy.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.84.1">Each service can be implemented and maintained by a different team, where all teams are loosely coupled.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.85.1">Each service has a well-defined interface known to all teams involved in the development project.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.86.1">Communication protocols are decided at the project start and are known by all teams.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.87.1">Each service must depend just on the interface exposed by the others and on the communication protocols adopted. </span><span class="koboSpan" id="kobo.87.2">In particular, no design choice adopted for a service can impose constraints on the implementation of the others.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.88.1">You are encouraged to compare each of the above constraints with the requirements that led to the conception of microservices architecture discussed in the previous section. </span><span class="koboSpan" id="kobo.88.2">In fact, each of these constraints is the immediate result of one or more of the previous requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.89.1">Let’s discuss each constraint in detail.</span></p>
<h3 class="heading-3" id="_idParaDest-35"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.90.1">Domain of expertise and microservices</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.91.1">This constraint has the purpose of</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.92.1"> providing a practical rule for defining the boundary of each microservice so that microservices are kept loosely coupled and can be </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.93.1">handled by loosely coupled teams. </span><span class="koboSpan" id="kobo.93.2">It is based on the theory of </span><strong class="keyWord"><span class="koboSpan" id="kobo.94.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.95.1"> developed by Eric Evans (see </span><em class="italic"><span class="koboSpan" id="kobo.96.1">Domain-Driven Design</span></em><span class="koboSpan" id="kobo.97.1">: </span><a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20"><span class="url"><span class="koboSpan" id="kobo.98.1">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</span></span></a><span class="koboSpan" id="kobo.99.1">). </span><span class="koboSpan" id="kobo.99.2">Here, we will go over just a few essential concepts of this theory, but if you’re interested in reading more, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.100.1">Further reading</span></em><span class="koboSpan" id="kobo.101.1"> section for more details.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">Basically, each domain of expertise uses a typical language. </span><span class="koboSpan" id="kobo.102.2">Therefore, during the analysis, it is enough to detect changes in the language used by the experts you speak with to understand what is included in and excluded from each microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.103.1">The rationale behind this technique is that toughly interacting people always develop a specific language recognized by others who share the same domain of expertise, while the absence of such a common language is a signal of loose interaction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.104.1">This way, the application </span><strong class="keyWord"><span class="koboSpan" id="kobo.105.1">domain</span></strong><span class="koboSpan" id="kobo.106.1"> or an application </span><strong class="keyWord"><span class="koboSpan" id="kobo.107.1">subdomain</span></strong><span class="koboSpan" id="kobo.108.1"> is split into so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.109.1">bounded contexts</span></strong><span class="koboSpan" id="kobo.110.1">, each characterized by the usage of a</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.111.1"> common language. </span><span class="koboSpan" id="kobo.111.2">It is worth </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.112.1">pointing out that </span><strong class="keyWord"><span class="koboSpan" id="kobo.113.1">domain</span></strong><span class="koboSpan" id="kobo.114.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.115.1">subdomain</span></strong><span class="koboSpan" id="kobo.116.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.117.1">bounded context</span></strong><span class="koboSpan" id="kobo.118.1"> are all core concepts of DDD. </span><span class="koboSpan" id="kobo.118.2">For more </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.119.1">details on them and </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.120.1">DDD, you may refer to the </span><em class="italic"><span class="koboSpan" id="kobo.121.1">Further reading</span></em><span class="koboSpan" id="kobo.122.1"> section, but our simple description should suffice for getting started with microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.123.1">Thus, we get the first division of the application</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.124.1"> into </span><strong class="keyWord"><span class="koboSpan" id="kobo.125.1">bounded contexts</span></strong><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">Each is assigned to a team and a formal interface for each of them is defined. </span><span class="koboSpan" id="kobo.126.3">This interface becomes the specification of a microservice, and it is also </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.127.1">everything the other teams must know about the microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.128.1">Then, each team that has been assigned a microservice can split it further into smaller microservices to scale each of them independently from the others, checking that each resulting microservice exchanges an acceptable quantity of messages with the others (loose coupling).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.129.1">The first division is used to split the work among the teams, while the second division is designed to optimize performance in various ways, which we will detail in the </span><em class="italic"><span class="koboSpan" id="kobo.130.1">Microservices organization</span></em><span class="koboSpan" id="kobo.131.1"> subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-36"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.132.1">Replicable microservices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.133.1">There should be a way to create several instances of the same microservice and place them on the available hardware to allocate </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.134.1">more hardware resources to the </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.135.1">most critical microservices. </span><span class="koboSpan" id="kobo.135.2">For some applications or single microservices, this can be done manually; but, more often, dedicated software tools called </span><strong class="keyWord"><span class="koboSpan" id="kobo.136.1">orchestrators</span></strong><span class="koboSpan" id="kobo.137.1"> are </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.138.1">adopted. </span><span class="koboSpan" id="kobo.138.2">In this book, we will describe</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.139.1"> two orchestrators: </span><strong class="keyWord"><span class="koboSpan" id="kobo.140.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.141.1">, in </span><a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic"><span class="koboSpan" id="kobo.142.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.143.1">, </span><em class="italic"><span class="koboSpan" id="kobo.144.1">Practical Microservices Organization with Kubernetes</span></em><span class="koboSpan" id="kobo.145.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.146.1">Azure Container Apps</span></strong><span class="koboSpan" id="kobo.147.1">, in </span><a href="Chapter_9.xhtml#_idTextAnchor261"><em class="italic"><span class="koboSpan" id="kobo.148.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.149.1">, </span><em class="italic"><span class="koboSpan" id="kobo.150.1">Simplifying Containers and Kubernetes: Azure Container Apps</span></em><em class="italic"><span class="koboSpan" id="kobo.151.1"> and other Tools</span></em><span class="koboSpan" id="kobo.152.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-37"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.153.1">Splitting microservices development among different teams</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.154.1">The way microservices are defined, so that they can be assigned to different loosely coupled teams, has already been explained in the </span><em class="italic"><span class="koboSpan" id="kobo.155.1">Domain of expertise and microservices</span></em><span class="koboSpan" id="kobo.156.1"> subsection. </span><span class="koboSpan" id="kobo.156.2">Here, it is worth pointing out that</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.157.1"> the microservices defined at this stage are </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.158.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.159.1">logical microservices</span></strong><span class="koboSpan" id="kobo.160.1">, and then each team can decide to split each</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.161.1"> logical microservice into one or more </span><strong class="keyWord"><span class="koboSpan" id="kobo.162.1">physical microservices</span></strong><span class="koboSpan" id="kobo.163.1"> for various practical reasons.</span></p>
<h3 class="heading-3" id="_idParaDest-38"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.164.1">Microservices, interfaces, and communication protocols</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.165.1">Once microservices are assigned to different teams, it is time to define their interfaces and the communication protocol used for each kind of message. </span><span class="koboSpan" id="kobo.165.2">This information is shared among all teams so that each team knows how to communicate with the microservices handled by the other teams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.166.1">Only the interfaces of all logical microservices and the associated communication protocols must be shared among all teams, while the division of each logical microservice into physical microservices is just shared within each team.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.167.1">The coordination of the various teams, and the documentation and monitoring of all services, is achieved with various tools. </span><span class="koboSpan" id="kobo.167.2">Below are the main tools used:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.168.1">Context maps</span></strong><span class="koboSpan" id="kobo.169.1"> are a graphical </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.170.1">representation of the organizational relationships among the various teams working on all application-bounded contexts. </span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.171.1">Service catalogs</span></strong><span class="koboSpan" id="kobo.172.1"> collect information </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.173.1">about all microservice requirements, teams, costs, and </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.174.1">other properties. </span><span class="koboSpan" id="kobo.174.2">Tools like </span><strong class="keyWord"><span class="koboSpan" id="kobo.175.1">Datadog</span></strong><span class="koboSpan" id="kobo.176.1"> (</span><a href="https://docs.datadoghq.com/service_catalog/"><span class="url"><span class="koboSpan" id="kobo.177.1">https://docs.datadoghq.com/service_catalog/</span></span></a><span class="koboSpan" id="kobo.178.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.179.1">Backstage</span></strong><span class="koboSpan" id="kobo.180.1"> (</span><a href="https://backstage.io/docs/features/software-catalog/"><span class="url"><span class="koboSpan" id="kobo.181.1">https://backstage.io/docs/features/software-catalog/</span></span></a><span class="koboSpan" id="kobo.182.1">) perform various </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.183.1">types of monitoring, while tools like </span><strong class="keyWord"><span class="koboSpan" id="kobo.184.1">Postman</span></strong><span class="koboSpan" id="kobo.185.1"> (</span><a href="https://www.postman.com/"><span class="url"><span class="koboSpan" id="kobo.186.1">https://www.postman.com/</span></span></a><span class="koboSpan" id="kobo.187.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.188.1">Swagger</span></strong><span class="koboSpan" id="kobo.189.1"> (</span><a href="https://swagger.io/"><span class="url"><span class="koboSpan" id="kobo.190.1">https://swagger.io/</span></span></a><span class="koboSpan" id="kobo.191.1">) are mainly</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.192.1"> focused on formal requirements, such as the</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.193.1"> testing and automatic generation of clients for interacting with the services.</span></li>
</ul>
<h3 class="heading-3" id="_idParaDest-39"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.194.1">Just the interfaces of the logical microservices are public</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.195.1">The code of each microservice can’t make</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.196.1"> any assumptions about how the public interface of all other logical microservices is implemented. </span><span class="koboSpan" id="kobo.196.2">Nothing can be assumed about the technologies used (.NET, Python, Java, and so on) and their versions, and nothing can be assumed about the algorithms and data architectures used by other microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.197.1">Having analyzed the definition of microservices architecture, and its immediate consequences, we can move to the current most practical way to organize them.</span></p>
<h2 class="heading-2" id="_idParaDest-40"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.198.1">Microservices organization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.199.1">The first consequence of the independence of microservices design choices is that each microservice must have private </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.200.1">storage because a shared database would cause dependencies among the microservices sharing it. </span><span class="koboSpan" id="kobo.200.2">Suppose microservices A and B both access the same database table, T. </span><span class="koboSpan" id="kobo.200.3">Now, we’re modifying microservice A to meet a new user’s requirements. </span><span class="koboSpan" id="kobo.200.4">As part of this update, the solution for A will require us to replace table T with two new tables, T1 and T2.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">In a similar situation, we would be forced to also change the code of B to adapt it to the replacement of T with T1 and T2. </span><span class="koboSpan" id="kobo.201.2">Clearly, the same limitation doesn’t apply to different instances of the same microservice, so they can both share the same database. </span><span class="koboSpan" id="kobo.201.3">To summarize, we can state the following:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.202.1"> Instances of different microservices can’t share a common database.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.203.1">Unfortunately, moving away from a single-application database inevitably leads to data duplication and coordination challenges. </span><span class="koboSpan" id="kobo.203.2">More specifically, the same chunk of data must be duplicated in several microservices, so when it changes, the change must be communicated to all microservices that are using a duplicated copy of it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.204.1">Thus, we may state another organizational constraint:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.205.1">Microservices must be designed in a way that minimizes the duplication of data, or stated differently, duplications should involve as few microservices as possible.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.206.1">As has been said in the previous section, if we define microservices according to the domain of expertise, the last constraint should be ensured automatically because different domains of expertise usually share just a little data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.207.1">No other constraints descend immediately from the definition of microservices, but it is enough to add a trivial performance constraint on the response time to force the organization of microservices in a way</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.208.1"> that it more closely resembles an assembly line than a usual user-request-driven software. </span><span class="koboSpan" id="kobo.208.2">Let’s see why.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.209.1">A user request coming to microservice A might cause, in turn, a long chain of requests issued to other microservices, as shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.210.1"><img alt="Figure 2.3: Chain of synchronous request-responses" src="../Images/B31916_02_3.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.211.1">Figure 2.3: Chain of synchronous request-responses</span></p>
<p class="normal"><span class="koboSpan" id="kobo.212.1">Messages 1-6 are triggered by a request to microservice </span><em class="italic"><span class="koboSpan" id="kobo.213.1">A</span></em><span class="koboSpan" id="kobo.214.1"> and are sent in sequence, so their processing times sum up to the response time. </span><span class="koboSpan" id="kobo.214.2">Moreover, microservice </span><em class="italic"><span class="koboSpan" id="kobo.215.1">A</span></em><span class="koboSpan" id="kobo.216.1">, after having sent message </span><em class="italic"><span class="koboSpan" id="kobo.217.1">1</span></em><span class="koboSpan" id="kobo.218.1">, remains blocked, waiting for a response, until it receives the last message (</span><em class="italic"><span class="koboSpan" id="kobo.219.1">6</span></em><span class="koboSpan" id="kobo.220.1">); that is, it remains blocked for the whole lifetime of the</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.221.1"> overall chained communication process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.222.1">Microservice </span><strong class="keyWord"><span class="koboSpan" id="kobo.223.1">B</span></strong><span class="koboSpan" id="kobo.224.1"> remains blocked twice, waiting for an answer to a request it issued. </span><span class="koboSpan" id="kobo.224.2">The first time is during the </span><em class="italic"><span class="koboSpan" id="kobo.225.1">2</span></em><span class="koboSpan" id="kobo.226.1">-</span><em class="italic"><span class="koboSpan" id="kobo.227.1">3</span></em><span class="koboSpan" id="kobo.228.1"> communication and then the second is during the </span><em class="italic"><span class="koboSpan" id="kobo.229.1">4</span></em><span class="koboSpan" id="kobo.230.1">-</span><em class="italic"><span class="koboSpan" id="kobo.231.1">5</span></em><span class="koboSpan" id="kobo.232.1"> communication. </span><span class="koboSpan" id="kobo.232.2">To sum up, a naive request-response pattern to microservices communication implies high response times and a waste of microservices computation time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.233.1">The only ways to overcome the above problems are either avoiding complete dependencies among microservices or caching all information needed to satisfy any user request into the first microservice, </span><em class="italic"><span class="koboSpan" id="kobo.234.1">A</span></em><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">Since</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.236.1"> reaching total independence is basically impossible, the usual solution is caching in </span><em class="italic"><span class="koboSpan" id="kobo.237.1">A</span></em><span class="koboSpan" id="kobo.238.1"> whatever data it needs to answer requests without asking for further information about other microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.239.1">To achieve this goal, microservices are p</span><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.240.1">roactive and adopt </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.241.1">the so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.242.1">asynchronous data-sharing</span></strong><span class="koboSpan" id="kobo.243.1"> approach. </span><span class="koboSpan" id="kobo.243.2">Whenever they update data, they send the updated information to all other microservices that need it for their responses. </span><span class="koboSpan" id="kobo.243.3">Put simply, in the example above, tree nodes, instead of waiting for requests from their parent nodes, send pre-processed data to all their possible callers each time their private data changes, as shown in the figure below.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.244.1"><img alt="Figure 2.4: Data-driven communication" src="../Images/B31916_02_4.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.245.1">Figure 2.4: Data-driven communication</span></p>
<p class="normal"><span class="koboSpan" id="kobo.246.1">Both communications labeled </span><em class="italic"><span class="koboSpan" id="kobo.247.1">1</span></em><span class="koboSpan" id="kobo.248.1"> are triggered when the data of the </span><em class="italic"><span class="koboSpan" id="kobo.249.1">C</span></em><span class="koboSpan" id="kobo.250.1">/</span><em class="italic"><span class="koboSpan" id="kobo.251.1">D</span></em><span class="koboSpan" id="kobo.252.1"> microservices changes, and they may occur in parallel. </span><span class="koboSpan" id="kobo.252.2">Moreover, once communication is sent, each microservice can return to its job without waiting for a response. </span><span class="koboSpan" id="kobo.252.3">Finally, when a request arrives at microservice </span><em class="italic"><span class="koboSpan" id="kobo.253.1">A</span></em><span class="koboSpan" id="kobo.254.1">, it already has all the data it needs to build the response with no need to interact with other microservices. </span><span class="koboSpan" id="kobo.254.2">In general, microservices </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.255.1">based on </span><strong class="keyWord"><span class="koboSpan" id="kobo.256.1">asynchronous data sharing</span></strong><span class="koboSpan" id="kobo.257.1"> pre-process data and send it to whichever</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.258.1"> other service might need it as soon as their data changes. </span><span class="koboSpan" id="kobo.258.2">This way, each microservice already contains precomputed data that it can use to respond immediately to user requests with no need for further request-specific communications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.259.1">This time, we can’t speak of requests and responses but simply of messages exchanged. </span><span class="koboSpan" id="kobo.259.2">People working with classical web applications will be accustomed to request/response communications where a client issues a request and a server processes that request and sends back a response.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.260.1">In general, in a request/response communication, one of the involved actors, say, </span><strong class="keyWord"><span class="koboSpan" id="kobo.261.1">A</span></strong><span class="koboSpan" id="kobo.262.1">, sends a message containing a </span><strong class="keyWord"><span class="koboSpan" id="kobo.263.1">request</span></strong><span class="koboSpan" id="kobo.264.1"> to perform some </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.265.1">specific processing to another actor, say, </span><strong class="keyWord"><span class="koboSpan" id="kobo.266.1">B</span></strong><span class="koboSpan" id="kobo.267.1">, then </span><strong class="keyWord"><span class="koboSpan" id="kobo.268.1">B</span></strong><span class="koboSpan" id="kobo.269.1"> performs the required processing and </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.270.1">returns a result (the </span><strong class="keyWord"><span class="koboSpan" id="kobo.271.1">response</span></strong><span class="koboSpan" id="kobo.272.1">), which may also be an error notification.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.273.1">However, we may also have communications that are not request/response-based. </span><span class="koboSpan" id="kobo.273.2">In this case, we simply speak of messages. </span><span class="koboSpan" id="kobo.273.3">In this case, there are not responses but just acknowledgments that the messages have been correctly received by either the final target or an intermediate actor. </span><span class="koboSpan" id="kobo.273.4">Differently from responses, acknowledgments are sent before completing the processing of the messages.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.274.1">Returning to </span><strong class="keyWord"><span class="koboSpan" id="kobo.275.1">asynchronous data sharing</span></strong><span class="koboSpan" id="kobo.276.1">, as new </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.277.1">data becomes available, each microservice does its job and then sends the results to all interested microservices, and then it continues performing its job without waiting for a response from its recipients.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.278.1">Each sender just waits for an acknowledgment from its immediate recipient, so wait times do not add up like in the initial </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.279.1">chained request/response example.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.280.1">What about message acknowledgments? </span><span class="koboSpan" id="kobo.280.2">They also cause small delays. </span><span class="koboSpan" id="kobo.280.3">Is it possible to also remove this smaller inefficiency? </span><span class="koboSpan" id="kobo.280.4">Of course, with the help of asynchronous communication!</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.281.1">In synchronous communication, the sender waits for the message acknowledgment before continuing its processing. </span><span class="koboSpan" id="kobo.281.2">This way, if the acknowledgment times out or is replaced by an error notification, the sender can perform corrective actions, such as resending the message.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.282.1">In asynchronous communication, the sender doesn’t wait for either an acknowledgment or an error notification but continues its processing, immediately after the message is sent, while acknowledgments or error notifications are sent to a callback.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.283.1">Asynchronous communication is more effective in microservices because it completely avoids wait times. </span><span class="koboSpan" id="kobo.283.2">However, the necessity to perform corrective actions in case of possible errors complicates the overall message-sending action. </span><span class="koboSpan" id="kobo.283.3">More specifically, all sent messages must be added to a queue, and each time an acknowledgment arrives, the message is marked as correctly sent and removed from this queue. </span><span class="koboSpan" id="kobo.283.4">Otherwise, if no acknowledgment arrives within a configurable </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">timeout</span></code><span class="koboSpan" id="kobo.285.1"> time, or if an error is raised, the message is marked to be re-sent according to some retry policies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.286.1">The microservices </span><strong class="keyWord"><span class="koboSpan" id="kobo.287.1">asynchronous data-sharing</span></strong><span class="koboSpan" id="kobo.288.1"> approach is</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.289.1"> often accompanied by the </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.290.1">so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.291.1">Command Query Responsibility Segregation</span></strong><span class="koboSpan" id="kobo.292.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.293.1">CQRS</span></strong><span class="koboSpan" id="kobo.294.1">) pattern. </span><span class="koboSpan" id="kobo.294.2">According to CQRS, microservices are split into </span><em class="italic"><span class="koboSpan" id="kobo.295.1">updates microservices</span></em><span class="koboSpan" id="kobo.296.1">, which perform the usual CRUD operations, and </span><em class="italic"><span class="koboSpan" id="kobo.297.1">query microservices</span></em><span class="koboSpan" id="kobo.298.1">, which are specialized in answering queries that aggregate data from several other microservices, as shown in the following figure:</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.299.1"><img alt="Figure 2.5: Updates and query microservices" src="../Images/B31916_02_5.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.300.1">Figure 2.5: Updates and query microservices</span></p>
<p class="normal"><span class="koboSpan" id="kobo.301.1">According to the </span><strong class="keyWord"><span class="koboSpan" id="kobo.302.1">asynchronous data-sharing</span></strong><span class="koboSpan" id="kobo.303.1"> approach, each update microservice sends all its modifications to the query services </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.304.1">that need them, while query microservices precompute all queries to ensure short response times. </span><span class="koboSpan" id="kobo.304.2">It is worth pointing out that data-driven updates resemble a factory assembly line that builds all possible query results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.305.1">Both updates and query</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.306.1"> microservices are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.307.1">frontend </span></strong><span class="koboSpan" id="kobo.308.1">microservices because </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.309.1">they are involved in the usual request-response pattern with the user. </span><span class="koboSpan" id="kobo.309.2">However, data updates in their path may also encounter microservices that do not interact at all with a user. </span><span class="koboSpan" id="kobo.309.3">They are </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.310.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.311.1">worker</span></strong><span class="koboSpan" id="kobo.312.1"> microservices. </span><span class="koboSpan" id="kobo.312.2">The following figure shows the relationship between worker and frontend microservices.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.313.1"><img alt="Figure 2.6: Frontend and worker microservices" src="../Images/B31916_02_6.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.314.1">Figure 2.6: Frontend and worker microservices</span></p>
<p class="normal"><span class="koboSpan" id="kobo.315.1">While frontend microservices usually respond to several user requests in parallel by creating a thread for each request, worker microservices are involved only in data updates, so they don’t need to parallelize requests to ensure low response times to the user.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.316.1">Accordingly, their operation is completely analogous to the one of the stations that compose an assembly line. </span><span class="koboSpan" id="kobo.316.2">They extract their input messages from an input queue and process them one after the other. </span><span class="koboSpan" id="kobo.316.3">Output data is</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.317.1"> sent to all interested microservices as soon as they are available. </span><span class="koboSpan" id="kobo.317.2">This </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.318.1">kind of processing is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.319.1">data-driven</span></strong><span class="koboSpan" id="kobo.320.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.321.1">One might object that worker microservices are not necessary since their job might be taken care of by the frontend services that consume their outputs. </span><span class="koboSpan" id="kobo.321.2">This is not the case! </span><span class="koboSpan" id="kobo.321.3">For instance, let’s imagine accounting data that needs to be consolidated over a period of time before being used as fields of complex queries. </span><span class="koboSpan" id="kobo.321.4">Of course, each query microservice that needs the consolidated data might take care of consolidating it. </span><span class="koboSpan" id="kobo.321.5">However, this would result in the duplication of the processing effort and the storage needed to hold the partial sums.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.322.1">Moreover, embedding the consolidation processing in other microservices would enable its independent scaling, with better optimization of the overall performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.323.1">The next subsection shows an example that exemplifies all the concepts learned so far.</span></p>
<h2 class="heading-2" id="_idParaDest-41"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.324.1">Car-sharing example</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.325.1">The following figure shows a </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.326.1">communication diagram of the routes-handling part of a car-sharing application. </span><span class="koboSpan" id="kobo.326.2">Dashed lines surround all physical microservices belonging to the same logical microservice. </span><span class="koboSpan" id="kobo.326.3">Query microservices are at the top of the image, updates microservices are at the bottom, and worker microservices are in the middle (with gray shading).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.327.1"><img alt="Figure 2.7: Route-handling subsystem of a car-sharing application" src="../Images/B31916_02_7.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.328.1">Figure 2.7: Route-handling subsystem of a car-sharing application</span></p>
<p class="normal"><span class="koboSpan" id="kobo.329.1">The language analysis detected two logical microservices. </span><span class="koboSpan" id="kobo.329.2">The first one speaks the language of the car sharer and is made of six physical microservices. </span><span class="koboSpan" id="kobo.329.3">The second one is focused on topology since it finds the best routes between a source and a destination and matches intermediate source-destination pairs with existing routes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.330.1">Car holders handle their requests with CRUD operations on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">Car-Holding-Requests</span></code><span class="koboSpan" id="kobo.332.1"> updates microservice, whi</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.333.1">le users looking for a car interact with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">Car-Seeking-Requests</span></code><span class="koboSpan" id="kobo.335.1"> updates microservice in a similar way. </span><span class="koboSpan" id="kobo.335.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">Routes-Listing</span></code><span class="koboSpan" id="kobo.337.1"> microservice lists all available trips with empty slots for </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.338.1">new passengers to help car seekers choose the date of their trip. </span><span class="koboSpan" id="kobo.338.2">Once the date is chosen, the request is submitted through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">Car-Seeking-Requests</span></code><span class="koboSpan" id="kobo.340.1"> microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.341.1">Both car holders and car seekers interact with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">Route-Choosing</span></code><span class="koboSpan" id="kobo.343.1"> updates microservice. </span><span class="koboSpan" id="kobo.343.2">Car seekers choose one of several available routes for both the source and destination, while car holders accept car seekers by selecting the routes that fit their sources and destinations. </span><span class="koboSpan" id="kobo.343.3">Once a route is selected by a car seeker and accepted by the car holder, all other incompatible options are deleted from the best matches of both the car holder and the car seeker.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.344.1">All available routes for b</span><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.345.1">oth car seekers and car holders are listed by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">My-Best-Matches</span></code><span class="koboSpan" id="kobo.347.1"> microservice. </span><span class="koboSpan" id="kobo.347.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">Routes-Planner</span></code><span class="koboSpan" id="kobo.349.1"> worker microservice computes the best routes that fit for the source and destination of a car holder that contains also sources and destinations for some car seekers. </span><span class="koboSpan" id="kobo.349.2">It stores unmatched car-seeker requests until a route passing at an acceptable distance from them is added. </span><span class="koboSpan" id="kobo.349.3">When this happens, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">Routes-Planner</span></code><span class="koboSpan" id="kobo.351.1"> microservice creates a new alternative route for the same trip that contains the new source-destination pair. </span><span class="koboSpan" id="kobo.351.2">All routes’ changes are sent to both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">My-Best-Matches</span></code><span class="koboSpan" id="kobo.353.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">Route-Choosing</span></code><span class="koboSpan" id="kobo.355.1"> microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.356.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">Locations-Listing</span></code><span class="koboSpan" id="kobo.358.1"> microservice handles a database of known locations, and it is used in various kinds of user suggestions, such as autocomplete of user sources and destinations and suggestions for interesting trips based on user preferences statistics. </span><span class="koboSpan" id="kobo.358.2">It takes its input from all car-holder and car-seeker requests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.359.1">We have seen what kind of problems microservices were conceived to solve and how their adoption adds complexity to the application design. </span><span class="koboSpan" id="kobo.359.2">Moreover, it is not difficult to imagine that testing and maintaining an application that runs on several different machines and relies on complex data-driven</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.360.1"> communication patterns should be a complex and time-consuming task.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.361.1">Therefore, it is important to assess the impact of using microservices architecture in our application to verify that the cost is affordable and that the advantages of the adoption outweigh the disadvantages and extra costs. </span><span class="koboSpan" id="kobo.361.2">In the next section, we will cover som</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.362.1">e criteria for facing this kind of assessment.</span></p>
<h1 class="heading-1" id="_idParaDest-42"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.363.1">When is it worth adopting microservices architectures?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.364.1">An application that requires </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.365.1">more than five developers is certainly a good target for a microservices architecture since logical microservices help split the workforce into small, loosely coupled teams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.366.1">A high-traffic application with several time-consuming modules is also a good target for microservices architecture since it needs module-level performance optimizations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.367.1">Low-traffic applications that require just a small team of less than five people for their implementation are not a good target for a microservices architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.368.1">Deciding when to adopt microservices in all other situations that fall between the above extreme cases is not easy. </span><span class="koboSpan" id="kobo.368.2">In general, it requires a detailed analysis of costs and returns.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.369.1">Considering costs, using a microservices architecture requires a development effort of about five times that of a usual monolithic application. </span><span class="koboSpan" id="kobo.369.2">We got this scale as an average on 7 total rewrites of monolithic applications with a Microservices architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.370.1">This is in part due to the extra effort needed to handle reliable communications, coordination, and detailed resource management. </span><span class="koboSpan" id="kobo.370.2">However, most of the costs come from the difficulties of testing, debugging, and monitoring a distributed application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.371.1">Later in the book, we will describe tools and methodologies for efficaciously handling all of the above problems, but the extra cost brought on by microservices remains.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.372.1">Considering expected returns, the most significant advantage is the capability of focusing maintenance on just the critical modules, since if the interface of a microservice doesn’t change also the more drastic changes in its implementation, such as moving to a different operating system, or to a different development stack, or simply to a newer version of the same stack, will not require any change to all other Microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.373.1">We may decide to reduce the maintenance of modules that do not require several market-critique changes to a minimum while focusing on just the market-critique modules that either increase the perceived value of the application or require changes to adapt them to a quickly evolving market. </span><span class="koboSpan" id="kobo.373.2">To summarize, we may focus on just the important changes required by the users, leaving all modules that are not involved in these changes unchanged.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.374.1">Focusing on just a few modules ensures a low time to market, so we can satisfy market opportunities as soon as they appear without the risk of releasing a new version too late.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.375.1">We are also able to fine-tune performance quickly when the traffic on some specific functionalities increases by scaling just the involved microservices. </span><span class="koboSpan" id="kobo.375.2">It is worth pointing out that the capability of fine-tuning each specific building block of our application allows for better usage of the available hardware, thus reducing the overall hardware costs. </span><span class="koboSpan" id="kobo.375.3">Moreover, the ability to fine-tune and monitor </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.376.1">specific microservices simplifies achieving better response times and, in general, performance goals.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.377.1">Having analyzed the evolution that led to the microservices architecture, as well as its very nature and basic organization, we can move on to patterns that, while not specific to microservices, are common in microservices architectures.</span></p>
<h1 class="heading-1" id="_idParaDest-43"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.378.1">Microservices common patterns</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.379.1">In this section, we will analyze the fundamental patterns used in all microservices architectures whose description is not tied to a specific </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.380.1">programming language or tool. </span><span class="koboSpan" id="kobo.380.2">Most of them concern microservice communication. </span><span class="koboSpan" id="kobo.380.3">Let’s start with common retry strategies.</span></p>
<h2 class="heading-2" id="_idParaDest-44"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.381.1">Resilient task execution</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.382.1">Microservices can be moved from one machine to another to achieve better load balancing. </span><span class="koboSpan" id="kobo.382.2">They can also be restarted to reset some possible memory leaks or to solve other performance issues. </span><span class="koboSpan" id="kobo.382.3">During these operations, they may</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.383.1"> miss some messages sent to them, or they may abort some ongoing computation. </span><span class="koboSpan" id="kobo.383.2">Moreover, failure due to software bugs or hardware faults may occur, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">Since microservices architectures are required to be reliable (almost zero downtime), they are usually redundant, and particular care is needed to detect faults and apply corrective actions. </span><span class="koboSpan" id="kobo.384.2">Therefore, all microservices architectures must provide mechanisms to both detect failures, such as simple timeouts, and correct failed operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.385.1">Failures are detected through the detection of either unexpected exceptions or timeouts. </span><span class="koboSpan" id="kobo.385.2">Since the code can always be arranged in a way to turn timeouts into exceptions, failure detection can always be reduced to adequate exception handling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.386.1">To resolve this problem, the community of microservices developers defined useful </span><strong class="keyWord"><span class="koboSpan" id="kobo.387.1">retry policies</span></strong><span class="koboSpan" id="kobo.388.1"> one can attach to specific exceptions. </span><span class="koboSpan" id="kobo.388.2">They are usually implemented through specific libraries together with other reliability patterns, but sometimes they are offered out of the box by cloud providers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.389.1">Below are the standard reliability patterns used in </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.390.1">microservices architectures:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.391.1">Exponentials retry</span></strong><span class="koboSpan" id="kobo.392.1">: It has been designed to overcome temporary faults, such as a failure due to a microservice instance restart. </span><span class="koboSpan" id="kobo.392.2">After each failure, the operation is retried with a delay that increases exponentially with the number of attempts, until a maximum number of attempts is reached. </span><span class="koboSpan" id="kobo.392.3">For instance, first, we would retry after 10 milliseconds, and if this retry operation results in a new failure, a new attempt is made after 20 milliseconds, then after 40 milliseconds, and so on. </span><span class="koboSpan" id="kobo.392.4">If the maximum number of attempts is reached, an exception is thrown, where it can find another retry policy or some other exception-handling strategy.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.393.1">Circuit break</span></strong><span class="koboSpan" id="kobo.394.1">: It has been designed to handle long-term failures and it is usually triggered after an exponential retry reaches its maximum number of retries. </span><span class="koboSpan" id="kobo.394.2">When a long-term failure is assumed, access to the resource is interdicted for a fixed amount of time by returning an immediate exception without attempting all the required operations. </span><span class="koboSpan" id="kobo.394.3">The interdiction time must be sufficient to allow human intervention or any other kind of manual fix.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.395.1">Bulkhead isolation</span></strong><span class="koboSpan" id="kobo.396.1">: Bulkhead isolation has been designed to prevent failure and congestion propagation. </span><span class="koboSpan" id="kobo.396.2">The basic idea is to organize services and/or resources into isolated partitions so that failures or congestions originating in a partition remain confined to that partition, and the remainder of the system continues working properly.</span></li>
</ul>
<p class="normal-one"><span class="koboSpan" id="kobo.397.1">Suppose, for instance, that </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.398.1">several microservice replicas use the same database (as is common). </span><span class="koboSpan" id="kobo.398.2">Due to a failure, a replica might start opening too many database connections, thus also congesting all other replicas that need to access the same database.</span></p>
<p class="normal-one"><span class="koboSpan" id="kobo.399.1">In this case, we recognize that database connections are critical resources that need bulkhead isolation. </span><span class="koboSpan" id="kobo.399.2">Thus, we compute the maximum number of connections the database can properly handle and partition them among all replicas, assigning, for instance, a maximum of five simultaneous connections to each microservice replica.</span></p>
<p class="normal-one"><span class="koboSpan" id="kobo.400.1">This way, a failure in a replica doesn’t affect the proper access of other replicas to the database. </span><span class="koboSpan" id="kobo.400.2">Moreover, if the application is properly organized, requests that fail to be served because of the failed replica will eventually be retried on a properly working replica so that the overall application can continue working properly. </span><span class="koboSpan" id="kobo.400.3">In general, if we would like to partition all requests to a shared resource, we can proceed as follows:</span></p>
<ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1"><span class="koboSpan" id="kobo.401.1">Only a maximum number of similar pending simultaneous outbound requests to the shared resource is allowed; let’s say 5, as in the previous database example. </span><span class="koboSpan" id="kobo.401.2">This is like putting an upper bound on thread creation.</span></li>
<li class="numberedList level-2"><span class="koboSpan" id="kobo.402.1">Requests exceeding the previous bound are queued.</span></li>
<li class="numberedList level-2"><span class="koboSpan" id="kobo.403.1">If a maximum queue length is reached, any further requests result in exceptions being thrown to abort them.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.404.1">It is worth pointing out that the requests partitioning and throttling pattern previously shown is a common way of applying bulkhead isolation, but it is not the only way. </span><span class="koboSpan" id="kobo.404.2">Any partition plus isolation strategy can be classified as bulkhead isolation. </span><span class="koboSpan" id="kobo.404.3">For instance, one might split the replicas of two interacting microservices into two isolated partitions such that only replicas belonging to the same partition might interact. </span><span class="koboSpan" id="kobo.404.4">This way, a failure in a partition can’t affect the other partition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.405.1">Together with the actions and strategies for handling failures exposed above, microservices architectures also offer failure prevention strategies. </span><span class="koboSpan" id="kobo.405.2">Failure prevention is achieved by monitoring anomalous consumptions of hardware resources and performing periodic hardware and software health checks. </span><span class="koboSpan" id="kobo.405.3">For this purpose, orchestrators monitor the usage of memory and CPU resources and restart a </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.406.1">microservice instance or add a new instance when they fall out of a developer-defined range. </span><span class="koboSpan" id="kobo.406.2">Moreover, they offer the possibility of declaring periodic software checks that the orchestrator can perform to verify if the microservice is working properly. </span><span class="koboSpan" id="kobo.406.3">The most common of such health checks is a call to a </span><strong class="keyWord"><span class="koboSpan" id="kobo.407.1">health REST endpoint</span></strong><span class="koboSpan" id="kobo.408.1"> exposed </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.409.1">by the microservice. </span><span class="koboSpan" id="kobo.409.2">Again, if the microservice fails a health check, it is restarted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.410.1">When a hardware node fails a health check, all of its microservices are moved to a different hardware node.</span></p>
<h2 class="heading-2" id="_idParaDest-45"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.411.1">Efficacious handling of asynchronous communication</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.412.1">Asynchronous communication with </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.413.1">associated asynchronous acknowledgment causes three important problems:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.414.1">Since after the communication the sending microservice moves to serving other requests without waiting for the acknowledgment, it must keep a copy of all messages it sent until an acknowledgment or a communication failure, such as a timeout, is detected, so that it can retry the operation (with an exponential retry, for instance), or it can take another kind of corrective action.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.415.1">Since in case of a timeout a message may be re-sent, the intended recipient can receive several copies of the same message.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.416.1">Messages can reach a recipient in an order that is different from the one they were sent. </span><span class="koboSpan" id="kobo.416.2">For instance, if two messages that instruct the recipient to modify the name of a product are sent in the order M1, M2, we expect the final name to be the one contained in M2. </span><span class="koboSpan" id="kobo.416.3">However, if the recipient receives the two messages in the wrong order, M2, M1, the final product name will be the one contained in M1, thus causing an error.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.417.1">The first problem is handled by keeping all messages in a queue, as shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.418.1"><img alt="Figure 2.8: Output message queue" src="../Images/B31916_02_8.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.419.1">Figure 2.8: Output message queue</span></p>
<p class="normal"><span class="koboSpan" id="kobo.420.1">When an acknowledgment is received, the involved message is removed from the queue. </span><span class="koboSpan" id="kobo.420.2">If, on the contrary, a failure or timeout is detected, the message is added to the end of the queue to be retried. </span><span class="koboSpan" id="kobo.420.3">If a retry must be handled with an exponential retry, each queue entry must contain both the number of the</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.421.1"> current attempt and the minimum time when the message can be re-sent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.422.1">The second and third problems require that each received message has a unique identifier and a sequence number. </span><span class="koboSpan" id="kobo.422.2">The unique identifier helps recognize and discard duplicates, while the sequence number helps the recipient to reconstruct the right message order. </span><span class="koboSpan" id="kobo.422.3">The following figure shows a possible implementation.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.423.1"><img alt="Figure 2.9: Input message queue" src="../Images/B31916_02_9.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.424.1">Figure 2.9: Input message queue</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">Messages can be read from the input queue only after all sequence holes before them have been filled and read, while duplicates are easily recognized and discarded.</span></p>
<h2 class="heading-2" id="_idParaDest-46"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.426.1">Event-based communications</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.427.1">Suppose we add a new microservice to the car-sharing application in </span><em class="italic"><span class="koboSpan" id="kobo.428.1">Figure 2.7</span></em><span class="koboSpan" id="kobo.429.1">, say, a worker microservice that computes statistics </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.430.1">about user trips. </span><span class="koboSpan" id="kobo.430.2">We would be forced to modify all microservices it needs input from, because all these microservices must also send some messages to the newly added microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.431.1">The main constraint of microservices architectures is that modifications to a microservice must not propagate to other microservices, but by simply adding a new microservice, we have already violated this basic principle.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.432.1">To overcome this problem, messages that might also interest newly added microservices are handled with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.433.1">publisher-subscriber</span></strong><span class="koboSpan" id="kobo.434.1"> pattern. </span><span class="koboSpan" id="kobo.434.2">That is, the</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.435.1"> sender sends the message to a publisher endpoint instead of sending it directly to the final recipients. </span><span class="koboSpan" id="kobo.435.2">Then, each microservice that is interested in that message simply subscribes to this endpoint, so that the subscription endpoint will automatically send to it all messages it receives. </span><span class="koboSpan" id="kobo.435.3">The following figure shows how the publisher-subscriber pattern works.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.436.1"><img alt="Figure 2.10: Publisher-subscriber pattern" src="../Images/B31916_02_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.437.1">Figure 2.10: Publisher-subscriber pattern</span></p>
<p class="normal"><span class="koboSpan" id="kobo.438.1">Once a publish endpoint receives a message, it resends it to all subscribers that added themselves to its subscriptions queue. </span><span class="koboSpan" id="kobo.438.2">This way, if we add a new microservice, no modification is required for all message senders since they need just to continue sending their messages to the adequate publish endpoints. </span><span class="koboSpan" id="kobo.438.3">It is up to the newly added microservice to register itself to the proper publish endpoints.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">Publish endpoints are handled by applications called message brokers that offer this service together with other message-delivering services. </span><span class="koboSpan" id="kobo.439.2">Message brokers can be deployed themselves as replicable microservices, but they are typically offered as standard services by all main cloud providers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.440.1">Among them, it is worth mentioning </span><strong class="keyWord"><span class="koboSpan" id="kobo.441.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.442.1">, which must </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.443.1">be installed as a microservice, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.444.1">Azure Service Bus</span></strong><span class="koboSpan" id="kobo.445.1">, which is available</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.446.1"> as a cloud service in Azure. </span><span class="koboSpan" id="kobo.446.2">We will say more about them throughout the rest of the book, but interested readers may find links with more details in the </span><em class="italic"><span class="koboSpan" id="kobo.447.1">Further reading</span></em><span class="koboSpan" id="kobo.448.1"> section.</span></p>
<h2 class="heading-2" id="_idParaDest-47"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.449.1">Interfacing the external world</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.450.1">Microservices applications are usually confined to a private network and expose their services through public or private IP addresses by</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.451.1"> means of gateways, load balancers, and web servers. </span><span class="koboSpan" id="kobo.451.2">These components may route external addresses to internal microservices. </span><span class="koboSpan" id="kobo.451.3">However, it is hard to leave to the user client-application the choice of the microservice to send each of their requests to.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.452.1">Typically, input requests are all handled by a unique</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.453.1"> endpoint called an </span><strong class="keyWord"><span class="koboSpan" id="kobo.454.1">API gateway</span></strong><span class="koboSpan" id="kobo.455.1"> that analyzes them and translates the request to an appropriate request for internal microservices. </span><span class="koboSpan" id="kobo.455.2">This way, the user client application doesn’t need any knowledge of how the microservices application is organized internally. </span><span class="koboSpan" id="kobo.455.3">Therefore, we are free to change the application organization during its maintenance without affecting the clients that use it, since the needed translations are performed </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.456.1">by the application API gateway. </span><span class="koboSpan" id="kobo.456.2">This process is known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.457.1">web API interface translation</span></strong><span class="koboSpan" id="kobo.458.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.459.1">The following figure summarizes the API gateway operation:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.460.1"><img alt="Figure 2.11: API gateway" src="../Images/B31916_02_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.461.1">Figure 2.11: API gateway</span></p>
<p class="normal"><span class="koboSpan" id="kobo.462.1">API gateways can also handle application versioning by sending all requests to the microservices that belong to the version required by the client application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.463.1">Moreover, they typically also handle authentication tokens; that is, they have the keys to decode them and to verify all user information they contain, such as user ID and its access privileges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.464.1">Please do not confuse authentication with login. </span><span class="koboSpan" id="kobo.464.2">Login is performed once per session when the user starts interacting with the application, and it is performed by a dedicated microservice. </span><span class="koboSpan" id="kobo.464.3">The result of a successful login is an authentication token that encodes information about the user and that must be included in</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.465.1"> all subsequent requests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.466.1">Summing up, API gateways offer the following services:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.467.1">Web API interface translation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.468.1">Versioning</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.469.1">Authentication</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.470.1">However, they often also offer other services, such as:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.471.1">API documentation endpoints, that is, endpoints that offer a formal description of the services offered by the application and how to request them. </span><span class="koboSpan" id="kobo.471.2">In the case of REST communication, API documentation is based </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.472.1">on the </span><strong class="keyWord"><span class="koboSpan" id="kobo.473.1">OpenAPI</span></strong><span class="koboSpan" id="kobo.474.1"> standard (see </span><em class="italic"><span class="koboSpan" id="kobo.475.1">Further reading</span></em><span class="koboSpan" id="kobo.476.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.477.1">Caching, that is, adding the right HTTP headers to handle appropriate caching of all responses in both the user client and the web intermediate nodes.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.478.1">It is worth pointing out that the above services are just common examples of the services available in commercial or open-source API gateways that usually offer a wide range of services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.479.1">API gateways can be implemented as ad hoc microservices using libraries like YARP (</span><a href="https://microsoft.github.io/reverse-proxy/index.html"><span class="url"><span class="koboSpan" id="kobo.480.1">https://microsoft.github.io/reverse-proxy/index.html</span></span></a><span class="koboSpan" id="kobo.481.1">), or they can use preexisting configurable applications, for instance, the open-source Ocelot (</span><a href="https://github.com/ThreeMammals/Ocelot"><span class="url"><span class="koboSpan" id="kobo.482.1">https://github.com/ThreeMammals/Ocelot</span></span></a><span class="koboSpan" id="kobo.483.1">). </span><span class="koboSpan" id="kobo.483.2">All main </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.484.1">providers offer powerful configurable API gateways, called </span><strong class="keyWord"><span class="koboSpan" id="kobo.485.1">API management systems</span></strong><span class="koboSpan" id="kobo.486.1"> (for Azure, see </span><a href="https://azure.microsoft.com/en-us/products/api-management"><span class="url"><span class="koboSpan" id="kobo.487.1">https://azure.microsoft.com/en-us/products/api-management</span></span></a><span class="koboSpan" id="kobo.488.1">). </span><span class="koboSpan" id="kobo.488.2">However, there are also independent cloud-native offers, like Kong (</span><a href="https://docs.konghq.com/gateway/latest/"><span class="url"><span class="koboSpan" id="kobo.489.1">https://docs.konghq.com/gateway/latest/</span></span></a><span class="koboSpan" id="kobo.490.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-48"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.491.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.492.1">In this chapter, we described the basics of microservices, starting from their evolution and continuing on to their definition, organization, and main patterns.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.493.1">We described the main features and requirements of a microservices-based application, how its organization resembles more of an assembly line than a user-requests-driven application, how to make microservices reliable, and how to handle efficaciously both failures and all problems caused by efficient asynchronous communication.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.494.1">Finally, we described how to make all microservices more independent from each other with publisher-subscriber-based communication and how to interface a microservices application with the external word.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.495.1">The next chapter describes two important building blocks for building enterprise-level microservices: Docker and Onion architectures.</span></p>
<h1 class="heading-1" id="_idParaDest-49"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.496.1">Questions</span></h1>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.497.1">What is the main difference between a hold-style SOA and a modern microservices architecture?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.498.1">In Microservices architectures are fine-grained. </span><span class="koboSpan" id="kobo.498.2">Moreover, each Microservices must not depend on the design choices of other Microservices. </span><span class="koboSpan" id="kobo.498.3">Furthermore, microservices must be redundant, replicable, and resilient.</span></p>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.499.1">Why are loosely coupled teams so important?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.500.1">Because it is quite easy to coordinate loosely coupled teams.</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.501.1">Why must each logical microservice have dedicated storage?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.502.1">This is an immediate consequence of the independence of the design choices of a Microservice from the design choices adopted in all other Microservices. </span><span class="koboSpan" id="kobo.502.2">In fact, sharing a common database would force common design choices on the database structure.</span></p>
<ol>
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.503.1">Why is data-driven communication needed?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.504.1">This is the only way to avoid long chains of recursive request and answers that would cause unacceptable overall response times.</span></p>
<ol>
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.505.1">Why is event-driven communication so important?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.506.1">Because event-driven communication completely decouples Microservices, so that developers can add a new Microservice without modifying any of the preexisting Microservices.</span></p>
<ol>
<li class="numberedList" value="6"><span class="koboSpan" id="kobo.507.1">Do API gateways usually offer login services?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.508.1">No login services are offered by specific Microservices called Authentication Servers.</span></p>
<ol>
<li class="numberedList" value="7"><span class="koboSpan" id="kobo.509.1">What is exponential retry?</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.510.1">A retry policy that exponentially increases the delay between failures and retries after each failure.</span></p>
<h1 class="heading-1" id="_idParaDest-50"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.511.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.512.1">Eric Evans, Domain-Driven Design: </span><a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20 "><span class="url"><span class="koboSpan" id="kobo.513.1">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.514.1">More resources on DDD can be found here: </span><a href="https://www.domainlanguage.com/ddd/"><span class="url"><span class="koboSpan" id="kobo.515.1">https://www.domainlanguage.com/ddd/</span></span></a><a href="https://domainlanguage.com/ddd/ "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.516.1">A detailed discussion of CQRS design principles can be found here: </span><a href="https://udidahan.com/2009/12/09/clarified-cqrs/"><span class="url"><span class="koboSpan" id="kobo.517.1">https://udidahan.com/2009/12/09/clarified-cqrs/</span></span></a><a href="http://udidahan.com/2009/12/09/clarified-cqrs/ "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.518.1">ASP.NET Core REST API: </span><a href="https://docs.microsoft.com/en-US/aspnet/core/web-api/"><span class="url"><span class="koboSpan" id="kobo.519.1">https://docs.microsoft.com/en-US/aspnet/core/web-api/</span></span></a><a href="https://docs.microsoft.com/en-US/aspnet/core/web-api/ "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.520.1">Datadog: </span><a href="https://docs.datadoghq.com/service_catalog/"><span class="url"><span class="koboSpan" id="kobo.521.1">https://docs.datadoghq.com/service_catalog/</span></span></a><a href="https://docs.datadoghq.com/service_catalog/ "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.522.1">Backstage: </span><a href="https://backstage.io/docs/features/software-catalog/"><span class="url"><span class="koboSpan" id="kobo.523.1">https://backstage.io/docs/features/software-catalog/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.524.1">OpenAPI (REST API specifications): </span><a href="https://swagger.io/docs/specification/v3_0/about/"><span class="url"><span class="koboSpan" id="kobo.525.1">https://swagger.io/docs/specification/v3_0/about/</span></span></a><a href="https://swagger.io/docs/specification/ "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.526.1">Postman: </span><a href="https://www.postman.com/"><span class="url"><span class="koboSpan" id="kobo.527.1">https://www.postman.com/</span></span></a><a href="https://www.postman.com/ "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.528.1">gRPC: </span><a href="https://grpc.io/ "><span class="url"><span class="koboSpan" id="kobo.529.1">https://grpc.io/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.530.1">RabbitMQ: </span><a href="https://www.rabbitmq.com/"><span class="url"><span class="koboSpan" id="kobo.531.1">https://www.rabbitmq.com/</span></span></a></li>
<li class="bulletList"><span class="url"><span class="koboSpan" id="kobo.532.1">Azure Service Bus: </span></span><a href="https://azure.microsoft.com/en-us/products/service-bus/"><span class="url"><span class="koboSpan" id="kobo.533.1">https://azure.microsoft.com/en-us/products/service-bus/</span></span></a></li>
<li class="bulletList"><span class="url"><span class="koboSpan" id="kobo.534.1">Ocelot: </span></span><a href="https://github.com/ThreeMammals/Ocelot"><span class="url"><span class="koboSpan" id="kobo.535.1">https://github.com/ThreeMammals/Ocelot</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.536.1">YARP: </span><a href="https://microsoft.github.io/reverse-proxy/index.html"><span class="url"><span class="koboSpan" id="kobo.537.1">https://microsoft.github.io/reverse-proxy/index.html</span></span></a><a href="https://microsoft.github.io/reverse-proxy/index.html "/></li>
<li class="bulletList"><span class="koboSpan" id="kobo.538.1">Kong: </span><a href="https://docs.konghq.com/gateway/latest/"><span class="url"><span class="koboSpan" id="kobo.539.1">https://docs.konghq.com/gateway/latest/</span></span></a></li>
<li class="bulletList"><span class="url"><span class="koboSpan" id="kobo.540.1">Azure API Management: </span></span><a href="https://azure.microsoft.com/en-us/products/api-management"><span class="url"><span class="koboSpan" id="kobo.541.1">https://azure.microsoft.com/en-us/products/api-management</span></span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-51"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.542.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.543.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_2.xhtml"><span class="url"><span class="koboSpan" id="kobo.544.1">https://packt.link/PSMCSharp</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.545.1"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="../Images/B31916_Discord-QR-Code.png"/></span></p>
</div>
</body></html>