<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.200rem;">
<head><title>Chapter&#160;1.&#160;Performing Common Optimizations in F#</title>
<link rel="stylesheet" href="../Styles/style0001.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<div class="chapter" title="Chapter&#160;1.&#160;Performing Common Optimizations in F#"><div class="titlepage" id="aid-E9OE2"><div><div><h1 class="title"><a id="ch01"></a>Chapter&#160;1.&#160;Performing Common Optimizations in F#</h1>
</div>
</div>
</div>
<p>It's quite well-known today that F# has been a first class citizen, a built-in part of programming language support in Visual Studio, starting from Visual Studio 2010. F# is a programming language that has its own unique trait: it is a functional programming language and at the same time it has object-oriented programming (OOP) support. F# from the start has run on .NET, although we can also run F# on cross-platform, such as Android (using Mono).</p>
<p>Although F# mostly runs faster than C# or VB when doing computations, its own performance characteristics and some not so obvious bad practices and subtleties may have led to performance bottlenecks. The bottlenecks may or may not be faster than the C#/VB counterparts, although some of the bottlenecks may share the same performance characteristics, such as the use of .NET APIs. The main goal of this book is to identify performance problems in F#, measuring and also optimizing F# code to run more efficiently, while also maintaining the functional programming style as appropriately as possible.</p>
<div class="note" title="Note"><h3 class="title"><a id="note4"></a>Note</h3>
<p>A basic knowledge of F# (including the functional programming concept and basic OOP) is required as a prerequisite to start understanding the performance problems and the optimization of F#.</p>
</div>
<p>There are many ways to define F# performance characteristics and at the same time to measure them, but understanding the mechanics of running F# code, especially on top of .NET, is crucial and is also a part of the performance characteristics itself. This includes other aspects of approaches to identify concurrency problems and language constructs. This chapter describes the optimization of F# code and will cover the following topics:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Understanding the nature of F# code</li>
<li class="listitem">Overview of common bottlenecks</li>
<li class="listitem">Commonly misunderstood concurrency problems</li>
<li class="listitem">Overview of tooling in .NET including Visual Studio to help understanding the running code</li>
<li class="listitem">Immediate testing of F# code in F# interactive</li>
<li class="listitem">Introduction to debugging in F#</li>
</ul>
</div>
<div class="section" title="Understanding the nature of F# code"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"></a>Understanding the nature of F# code</h1>
</div>
</div>
</div>
<p>Understanding the nature of F# code is very crucial and is a definitive prerequisite before we begin to measure how long it runs and its effectiveness. We can measure a running F# code by running time, but to fully understand why it may run slow or fast, there are some basic concepts we have to consider first.</p>
<p>Before we dive more into this, we must meet the basic requirements and setup.</p>
<p>After the requirements have been set, we need to put in place the environment setting of Visual Studio 2015. We have to set this because we need to maintain the consistency of the default setting of Visual Studio. The setting should be set to <span class="strong"><strong>General</strong></span>.</p>
<p>These are the steps:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the <span class="strong"><strong>Tools</strong></span> menu from Visual Studio's main menu.</li>
<li class="listitem">Select <span class="strong"><strong>Import and Export Settings...</strong></span> and the <span class="strong"><strong>Import and Export Settings Wizard</strong></span> screen is displayed:<p>
</p><div class="mediaobject"><img src="../Images/image00237.jpeg" alt="Understanding the nature of F# code"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">Select <span class="strong"><strong>Reset all Settings</strong></span> and then <span class="strong"><strong>Next</strong></span> to proceed.</li>
<li class="listitem">Select <span class="strong"><strong>No, just reset my settings overwriting my current setting</strong></span> and then <span class="strong"><strong>Next</strong></span> to proceed</li>
<li class="listitem">Select&#160; <span class="strong"><strong>General</strong></span> and then click on <span class="strong"><strong>Finish</strong></span>:<p>
</p><div class="mediaobject"><img src="../Images/image00238.jpeg" alt="Understanding the nature of F# code"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>After setting it up, we will have a consistent layout to be used throughout this book, including the menu locations and the look and feel of Visual Studio.</p>
<p>Now, we are going to scratch the surface of F# runtime with an introductory overview of common F# runtime, which will give us some insights into F# performance.</p>
<div class="section" title="F# runtime characteristics"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec6"></a>F# runtime characteristics</h2>
</div>
</div>
</div>
<p>The release of Visual Studio 2015 occurred at the same time as the release of .NET 4.6 and the rest of the tools, including the F# compiler. The compiler version of F# in Visual Studio 2015 is F# 4.0.</p>
<p>F# 4.0 has no large differences or notable new features compared to the previous version, F# 3.0 in Visual Studio 2013.</p>
<p>Its runtime characteristic is essentially the same as F# 4.0, although there are some subtle performance improvements and bug fixes.</p>
<p>For more information on what's new in F# 4.0 (described as release notes) visit:&#160;</p>
<p>

<a class="ulink" href="https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md">https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md</a>

</p>
<div class="note" title="Note"><h3 class="title"><a id="note5"></a>Note</h3>
<p>At the time of writing this book, the online and offline MSDN Library of F# in Visual Studio does not have F# 4.0 release notes documentation, but you can always go to the GitHub repository of F# to check the latest update.</p>
</div>
<p>These are the common characteristics of F# as part of managed programming language:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">F# must conform to .NET CLR. This includes the compatibilities, the IL emitted after compilation, and support for .NET BCL (the basic class library). Therefore, F# functions and libraries can be used by other CLR-compliant languages such as C#, VB, and managed C++.</li>
<li class="listitem">The debug symbols (PDB) have the same format and semantics as the other CLR-compliant languages. This is important because F# code must be able to be debugged from other CLR-compliant languages as well.</li>
</ul>
</div>
<p>From the managed languages perspective, measuring the performance of F# is similar when measured by tools such as the CLR profiler. But from an F# unique perspective, the following are the unique characteristics of F#:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">By default, all types in F# are immutable. Therefore, it's safe to assume it is intrinsically thread safe.</li>
<li class="listitem">F# has a distinctive collection library, and it is immutable by default. It is also safe to assume it is intrinsically thread safe.</li>
<li class="listitem">F# has a strong type inference model, and when a generic type is inferred without any concrete type, it automatically performs generalizations.</li>
<li class="listitem">Default functions in F# are implemented internally by creating an internal class derived from F#'s <code class="literal">FSharpFunc</code>. This <code class="literal">FSharpFunc</code> is essentially a delegate that is used by F# to apply functional language constructs such as currying and partial application.</li>
<li class="listitem">With <span class="strong"><strong>tail call recursive optimization</strong></span> in the IL, the F# compiler may emit <code class="literal">.tail</code> IL, and then the CLR will recognize this and perform optimization at runtime. More on this in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</li>
<li class="listitem">F# has inline functions as options. More on this in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization.</em></span></li>
<li class="listitem">F# has a computation workflow that is used to compose functions. This will be described in more detail in <a class="link" title="Chapter&#160;8.&#160;Optimizing Computation Expressions" href="fsp-hiperf_cu08.html#aid-1JFUC2">Chapter 8</a>, <span class="emphasis"><em>Optimizing Computation Expressions.</em></span></li>
<li class="listitem">F# async computation doesn't need <code class="literal">Task&lt;T&gt;</code> to implement it.</li>
</ul>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note6"></a>Note</h3>
<p>Although F# async doesn't need the <code class="literal">Task&lt;T&gt;</code> object, it can operate well with the async-await model in C# and VB. The async-await model in C# and VB is inspired by F# async, but behaves semantically differently based on more things than just the usage of <code class="literal">Task&lt;T&gt;</code>. More on this in <a class="link" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#" href="fsp-hiperf_cu04.html#aid-11C3M2">Chapter 4</a>, <span class="emphasis"><em>Introduction to Concurrency in F#</em></span>.</p>
</div>
<p>All of those characteristics are not only unique, but they can also have performance implications when used to interoperate with C# and VB.</p>
</div>
<div class="section" title="Relation between F# code and its generated assembly"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec7"></a>Relation between F# code and its generated assembly</h2>
</div>
</div>
</div>
<p>The F# assembly (commonly known as DLL or executable EXE in .NET running on Windows) is the same as the C#/VB assembly upon compilation. The end product of the compiler is a .NET assembly.</p>
<p>An assembly may contain multiple namespaces, and each namespace may contain multiple files of modules, classes, or a mix of both.</p>
<p>The following table describes the F# relation of code and compiled code (assembly):</p>
<div class="informaltable"><table border="1"><colgroup><col/>
<col/>
<col/>
</colgroup>
<tbody><tr><td>
<p>
<span class="strong"><strong>F# code</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>Compiled code</strong></span>
</p>
</td>
</tr>
<tr><td>
<p>Project</p>
</td>
<td>
<p>
</p>
<p>An organization of an F# project. It may contain F# script (FSX) and F# source files (FS).</p>
<p>
</p>
<p>In the conceptual layout, a project may contain multiple namespaces that spawn across multiple files of FSX and F# script.</p>
<p>
</p>
</td>
<td>
<p>An assembly of either executable EXE or DLL class library</p>
</td>
</tr>
<tr><td>
<p>Namespace</p>
</td>
<td>
<p>
</p>
<p>A logical organization of modules and classes to help organizing within an organization, company, or functionality.</p>
<p>
</p>
<p>For example: the <code class="literal">System.Web</code> namespace that contains many classes related to enable browser/server communication, including HTTP and HTTPS.</p>
<p>
</p>
</td>
<td>
<p>A namespace may spawn across different assemblies instead of a namespace for only one assembly</p>
</td>
</tr>
<tr><td>
<p>Module</p>
</td>
<td>
<p>A module in F# is equal to a C# static class or module in VB. An F# FS file may contain multiple modules, although it is not recommended to have this practice.</p>
</td>
<td>
<p>Part of a generated assembly</p>
</td>
</tr>
<tr><td>
<p>Classes and interfaces</p>
</td>
<td>
<p>A file can contain multiple classes and interfaces under different namespaces. It is recommended to have not more than one namespace for each file as this also minimizes compilation time when it tries to resolve references.</p>
</td>
<td>
<p>Part of a generated assembly</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" title="Immutability versus mutability"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec8"></a>Immutability versus mutability</h2>
</div>
</div>
</div>
<p>F# implementation of types and collection types are immutable. Immutable in this sense means it is read-only, and we can only initialize the object with an initial value and we can't change it afterwards.</p>
<p>Mutability means once we initialize an object, it can be changed afterwards. This is why it is sometimes called a <span class="emphasis"><em>mutating object value</em></span> instead of a changing object value.</p>
<p>For example consider the following:</p>
<pre class="programlisting">let anynumber = 0 
</pre>
<p>By default, <code class="literal">anynumber</code> is immutable and the value of it will always be <code class="literal">0</code>.</p>
<p>To mark a variable as mutable, F# has the <code class="literal">mutable</code> keyword and we can use <code class="literal">mutable</code> in the <code class="literal">let</code> declaration, as in this example:</p>
<pre class="programlisting">let mutable anymutablenumber = 0 
</pre>
<p>However, changing the value requires the use of the <code class="literal">&lt;-</code> symbol in F#, for example:</p>
<pre class="programlisting">anymutablenumber &lt;- anymutablenumber + 1 
</pre>
<p>Since the nature of F# is functional, a symbol can be both a data and a function. The content of the symbol is read-only, so does a function in it.</p>
<p>Immutability also has another advantage: it scales well across multiple threads or even in parallel, no matter whether it's a value or a function. The immutability guarantee means that it is free of side effects. It is then safe to spawn multiple symbols in parallel because the result of an execution will be guaranteed to have the same result. This is also simply called <span class="strong"><strong>thread safe</strong></span>.</p>
<p>The fact that F# has a mixed support for functional and OOP&#160;at the same time (including having support for the inherent mutable state of OOP) may lead to bottlenecks as described next.</p>
</div>
</div>
</div>


<div class="section" title="Overview of common bottlenecks" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"></a>Overview of common bottlenecks</h1>
</div>
</div>
</div>
<p>F# has common bottlenecks although they might be subtle as well.</p>
<p>In order to be able to quickly understand the bottleneck factors in F#, we will categorize the shared general bottlenecks of .NET as managed bottlenecks (also in C#/VB), and F#-only bottlenecks (this includes when using F# with other languages).</p>
<p>The following are managed .NET bottlenecks (from obvious to less obvious):</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">String concatenations, such as using string <code class="literal">String.Concat</code> instead of <code class="literal">StringBuilder</code>. This is often overlooked because of a lack of awareness of the string's immutability.</li>
<li class="listitem">Usage of non-generic collections such as <code class="literal">ArrayList</code>.</li>
<li class="listitem">Incorrectly handling side effects, such as exceptions and I/O.</li>
<li class="listitem">Mutable objects usage, including casting.</li>
<li class="listitem">Complex objects that will be serialized and deserialized, for example: sending <code class="literal">DataSet</code> that has <code class="literal">DataTables</code> over HTTP.</li>
<li class="listitem">Ignoring performance profiling.</li>
</ul>
</div>
<p>Side effects mean all of the elements outside the formal computation (it is often called the <span class="emphasis"><em>outside world</em></span>) that we interact with, and this includes the changing global state. The outside world can be all of the things that we cannot fully determine as the end result. Examples of the outside world include:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">I/O: This is included as being part of the outside world because you cannot determine or guarantee any kind of work you pass to I/O to be successfully completed. For example, when sending a command to a printer to print a document, we cannot guarantee 100% success of the printing operation. We cannot even guarantee that the process of sending the data to the printer will be successful or not before the printer receives the data and begins to print the document.</li>
<li class="listitem">Global static mutable variables: A quick example of this is when we define a <code class="literal">public static</code> variable in the scope of ASP.NET. Every value change will always change the condition of any user of the ASP.NET application.</li>
<li class="listitem">Functions or properties that always have different results when they are invoked, such as <code class="literal">DateTime.Now</code>.</li>
</ul>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note7"></a>Note</h3>
<p>
<code class="literal">DateTime.Now</code> will always return different results and this is as expected because the result <span class="emphasis"><em>must</em></span> change every time it is called or instantiated. It is not free of side effects, but it is still expected to always return a different result.</p>
</div>
<p>Side effects are not just for functional programming developers, as many of us are now becoming quite aware. There are no absolute side effect-free computations because we should learn and be able to correctly handle them. For example, even printing a screen to a console is also a side effect because it involves I/O, and it changes the state of the outside world.</p>
<p>The following are F#'s unique bottlenecks:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Incorrect use of data structures and collections</li>
<li class="listitem">Incorrect use of auto generalization and other language constructs</li>
<li class="listitem">Incorrectly implemented concurrency problems, such as mixing synchronous and asynchronous although the original intention is asynchronous</li>
<li class="listitem">Slow performance when having to interoperate with other languages' class libraries such as C#/VB</li>
<li class="listitem">Scaling <code class="literal">MailboxProcessor</code> in F#</li>
<li class="listitem">Identifying when <span class="strong"><strong>tail call optimization</strong></span> should occur</li>
<li class="listitem">Slow response when resolving type in type provider implementation</li>
<li class="listitem">Slow performance when implementing computation workflow</li>
</ul>
</div>
</div>


<div class="section" title="Common samples of misunderstood concurrent problems"><div class="titlepage" id="aid-G6PI2"><div><div><h1 class="title"><a id="ch01lvl1sec9"></a>Common samples of misunderstood concurrent problems</h1>
</div>
</div>
</div>
<p>Many of us, when dealing with concurrent problems, sometimes try to use a hammer for every nail. There is no silver bullet for all of the problems of implementing concurrency.</p>
<p>It is also recommended to understand concurrency, as concurrency is now becoming more relevant because of the many core models in the releases of modern microprocessors (or simply processors) in the last 7 years. This fact is also becoming a trend as the clock speed of the latest processors has been usually limited to 3.2 GHz for the last 3 years.</p>
<p>Microsoft's Visual C++ architect, Herb Sutter, has written a very thorough article in the form of a whitepaper famously known as <span class="emphasis"><em>The Free Lunch Is Over</em></span>:&#160;</p>
<p>

<a class="ulink" href="http://www.gotw.ca/publications/concurrency-ddj.htm">http://www.gotw.ca/publications/concurrency-ddj.htm</a>

</p>
<p>Let's understand first what concurrency is and the F# supports.</p>
<div class="section" title="Introduction to concurrency in F#"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec9"></a>Introduction to concurrency in F#</h2>
</div>
</div>
</div>
<p>Before we dive deeper into concurrency in F#, we should understand the definition of concurrency.</p>
<p>Concurrency is one of the main disciplines of computer science and it is still one of the main problems of computations.</p>
<p>Simply defined, concurrency is the composition of the order of independent process units or partially-ordered process units that can be executed in parallel or not in parallel, but not in sequential order. The term&#160;<span class="emphasis"><em>order</em></span> in this context means ordered as sequentially.</p>
<p>The following diagram illustrates the concept of sequential (not concurrent) in action:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00239.jpeg" alt="Introduction to concurrency in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>
<span class="strong"><strong>Process 1</strong></span> to <span class="strong"><strong>Process 4</strong></span> as shown in the preceding diagram is executed sequentially step by step. <span class="strong"><strong>Process 2</strong></span> must wait for <span class="strong"><strong>Process 1</strong></span> to be completed first, as do <span class="strong"><strong>Process 3</strong></span> and <span class="strong"><strong>Process 4</strong></span>.</p>
<p>This sequence is also called a synchronous process or is simply referred to as being synchronous.</p>
<p>The following figure is a sample illustration of a parallel concurrency combination of parallel and synchronous processes:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00240.jpeg" alt="Introduction to concurrency in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>
<span class="strong"><strong>Processes&#160;</strong></span>
<span class="strong"><strong>1A</strong></span>, <span class="strong"><strong>2A</strong></span>, and <span class="strong"><strong>3A</strong></span> run in parallel, although each parallel lane has its own sequence of processes that are run sequentially.</p>
<p>The term parallel means that it is not just executing simultaneously in parallel, but parallel also means that it may run on many processors or on many cores, as is common in modern processors that have multiple cores.</p>
</div>
<div class="section" title="Defining asynchronous"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"></a>Defining asynchronous</h2>
</div>
</div>
</div>
<p>A simple definition of asynchronous means <span class="emphasis"><em>not synchronous</em></span>. This means that if we have an asynchronous flow, the process is not run synchronously.</p>
<p>These are the implications of an asynchronous flow:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Processes run not sequentially. For example, if the first process is running asynchronously, the next process doesn't have to wait for the first process to be completed.</li>
<li class="listitem">There has to be a way of scheduling and telling the scheduler to inform that the asynchronous process is completed. Typically, the asynchronous process is usually related to blocking I/O or some long computations.</li>
<li class="listitem">At first, the processes may look sequential, but the next process run may not be sequential at all.</li>
</ul>
</div>
<p>This is a sample case of asynchronous: a customer is going to have dinner in a restaurant. The flows are:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="emphasis"><em>Customer A</em></span> orders some food or drinks, and the order is noted by <span class="emphasis"><em>waiter X</em></span>. Usually, most restaurants have more than one waiter, but for this illustration, the waiter available currently to serve <span class="emphasis"><em>customer A</em></span> is <span class="emphasis"><em>waiter X</em></span>.</li>
<li class="listitem"><span class="emphasis"><em>Waiter X</em></span> then gives the list of the customer's order to <span class="emphasis"><em>chef Y</em></span>.</li>
<li class="listitem"><span class="emphasis"><em>Chef Y</em></span> accepts the order, and checks if he is currently occupied or not. If he is occupied, the order is registered as part of his cooking queue. Otherwise, he will start to cook the order.</li>
<li class="listitem">The waiter does not have to wait for the chef to complete his cooking. He can then serve other customers who have just arrived or there might be customers that want to add more food or drinks as well.</li>
<li class="listitem"><span class="emphasis"><em>Chef Y</em></span> finishes his cooking for <span class="emphasis"><em>customer A</em></span>, and then gives a notification to <span class="emphasis"><em>waiter X</em></span> to inform that his cooking for <span class="emphasis"><em>customer A</em></span> is finished. Or he can inform all waiters to tell that the cooking for <span class="emphasis"><em>customer A</em></span> is finished. This concept of informing to tell a process is finished is commonly called a callback.</li>
<li class="listitem"><span class="emphasis"><em>Waiter X</em></span> (or any other waiter) delivers the finished food to <span class="emphasis"><em>customer A</em></span>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>The asynchronous model that uses a notification to inform that a process is completed is called <span class="strong"><strong>asynchronous callback</strong></span>.</p>
<p>The result returned at the end of the execution later (or in the future) is called a <span class="strong"><strong>Future</strong></span>. It is also the future, in a sense, when many processes are executed in parallel, having results later.</p>
<p>This is the official documentation of Future in MSDN Library:&#160;</p>
<p>

<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ff963556.aspx">https://msdn.microsoft.com/en-us/library/ff963556.aspx</a>

</p>
<p>For I/O operations, such as printing a document, we cannot determine whether the printing is successful or not, so the notification of the end process is not available. We can implement an asynchronous operation on I/O, and the fact that there is no observable notification of this is why this asynchronous model is called the asynchronous <span class="emphasis"><em>fire and forget</em></span> model.</p>
</div>
<div class="section" title="Misunderstood concurrency problems"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"></a>Misunderstood concurrency problems</h2>
</div>
</div>
</div>
<p>Many developers, even seasoned or experienced developers, still think that concurrency and parallel programming are different. Actually, parallel programming is just one member within the concurrency discipline, together with the differentiation of asynchronous and synchronous processing models.</p>
<p>This is also one of the most misunderstood concurrency concepts or problems, and there are many more regarding how we approach concurrency.</p>
<p>These are some common organized sample cases of misunderstood concurrency problems:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Assuming all concurrent problems can be solved using parallel programming.<p>Fact: Not all concurrent problems are easily solved with parallelism.</p></li>
<li class="listitem">Assuming all implementation of asynchronous is asynchronous.<p>Fact: This depends on how we implement async; sometimes the execution of an async construct is executed synchronously.</p></li>
<li class="listitem">Ignoring blocking threads such as I/O.<p>Fact: Blocking I/O threads should be handled asynchronously; otherwise, the current thread is always waiting indefinitely until the I/O thread is finished.</p></li>
<li class="listitem">The synchronized lock is blocking.<p>Fact: The lock is not a blocking thread.</p></li>
<li class="listitem">Relying on the CPU speed.<p>Fact: The CPU speed increase is becoming less of an issue. The research and development of modern CPUs is focusing on multiple core CPUs.</p></li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>A few sample cases of concurrent problems are mentioned as follows:</p>
<p>The case samples of the first case are:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Ordering or sorting a collection</strong></span>: Ordering is by default a sequential process, and it requires iterating all the elements of the collection. Therefore, it's useless to use parallelism.</li>
<li class="listitem"><span class="strong"><strong>Grouping data</strong></span>: Grouping data is implicitly one of the sequential processes; it is also quite useless to use parallelism.</li>
<li class="listitem"><span class="strong"><strong>Printing reports</strong></span>: Printing is part of I/O and I/O is intrinsically without support for parallelism. Unless the I/O is part of I/O parallelism, it is useless to use parallelism in this context.</li>
</ul>
</div>
<p>Sample cases of the second case are listed as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Mixing <code class="literal">Parallel.For</code> that has F# async in it. The implications of having <code class="literal">Parallel.For</code> is by default taking a multiple core or a CPU to run it is not the same as running asynchronously, as it is not guaranteed to run as a combined async in parallel.</li>
<li class="listitem">Using <code class="literal">Thread.Sleep</code> instead of <code class="literal">Async.Sleep</code> to signify a <span class="emphasis"><em>wait</em></span> operation. The call to <code class="literal">Thread.Sleep</code> will instead make the flow synchronous, as the <code class="literal">Sleep</code> method simply puts on hold the current thread as a <span class="emphasis"><em>delay</em></span> synchronously.</li>
</ul>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note8"></a>Note</h3>
<p>RAID array in the storage I/O is one of the best samples of parallelism in I/O. It stores data in parallel across multiple disks. It is faster than common I/O because data is stored in parts (not whole data to a disk) to several disks in parallel.</p>
</div>
<p>The third case is related to all of the I/O operations including sending data to a printer and saving large data into a disk. These operations are always blocking threads.</p>
<p>For the case of <code class="literal">lock</code>, Microsoft has issued official statements that <code class="literal">lock</code> in .NET used by C# and VB is executed without any interruption, and it only locks an object until it has finished executing the block in the synchronized lock. It's still allowing other threads to run without waiting for the thread that has the lock to finish.</p>
<p>This is the official thread synchronization of C# and VB in MSDN:&#160;</p>
<p>

<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms173179.aspx">https://msdn.microsoft.com/en-us/library/ms173179.aspx</a>

</p>
<p>It is recommended to always check online the MSDN Library of the .NET class library, as this is always updated.</p>
</div>
<div class="section" title="Introduction to concurrency support in .NET and F#"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"></a>Introduction to concurrency support in .NET and F#</h2>
</div>
</div>
</div>
<p>Concurrency support in F# is based on the existing work of concurrency support features in .NET BCL (the Base Class Library). It's also by design, since F# runs on top of .NET CLR and can use .NET BCL. F# also has its unique ways that bring more features other than just language features (for example, asynchronous computations).</p>
<p>The .NET BCL part of concurrency has basic support for the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Thread</li>
<li class="listitem">Lock</li>
<li class="listitem">Mutex</li>
</ul>
</div>
<p>Beginning with .NET 4.0, we have the <span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>). This library makes concurrent support easier. TPL consists of the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Data parallelism (for example: <code class="literal">Parallel.For</code> and <code class="literal">ForEach</code>)</li>
<li class="listitem">Task parallelism</li>
<li class="listitem">Asynchronous task (this is also the base foundation of C#/VB's async-await)</li>
<li class="listitem">Parallel LINQ (often abbreviated as PLINQ)</li>
</ul>
</div>
<p>For a more complete reference of concurrency support in .NET, please visit <a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx</a>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note9"></a>Note</h3>
<p>.NET has no support yet for fiber API in Win32 API. Microsoft currently has no definite plan for fiber support.</p>
</div>
<p>F# has its own unique features of concurrency supports. They are:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Asynchronous workflow or computation</li>
<li class="listitem">MailboxProcessor</li>
<li class="listitem">Parallel async</li>
<li class="listitem">Parallel async combined with I/O</li>
</ul>
</div>
<p>More on concurrency support in F# is available in <a class="link" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#" href="fsp-hiperf_cu04.html#aid-11C3M2">Chapter 4</a>, <span class="emphasis"><em>Introduction to Concurrency in F#</em></span> and <a class="link" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#" href="fsp-hiperf_cu05.html#aid-164MG2">Chapter 5</a>, <span class="emphasis"><em>Advanced Concurrency Support in F#</em></span>.</p>
<p>Now it's time to dive more into some codes. To start writing F# code, we can use F# and Visual Studio combined. This includes IDE supports for F#.</p>
</div>
</div>


<div class="section" title="Overview of F# tooling in Visual Studio"><div class="titlepage" id="aid-H5A42"><div><div><h1 class="title"><a id="ch01lvl1sec10"></a>Overview of F# tooling in Visual Studio</h1>
</div>
</div>
</div>
<p>F# has been supported in Visual Studio since Visual Studio 2010, and in Visual Studio 2015 the support has improved with better syntax colorizations than Visual Studio 2010, not just IDE. This F# IDE support is officially called <span class="emphasis"><em>Visual F#.</em></span>
</p>
<p>This tooling is available as open source from Microsoft and it is available to be downloaded from GitHub at&#160;<a class="ulink" href="https://github.com/Microsoft/visualfsharp/">https://github.com/Microsoft/visualfsharp/</a>.</p>
<p>And the F# compiler itself is open source and it is also available from GitHub (including the design proposal discussions) at <a class="ulink" href="https://github.com/fsharp">https://github.com/fsharp</a>.</p>
<p>The tooling is under the governance of Microsoft, but it is welcoming community contributions as it is available on GitHub. All of the community participations of tooling, compilers and the language specifications are under the governance of the F# Software Foundation (FSSF).</p>
<p>We can also support FSSF directly. For more information about FSSF, please visit <a class="ulink" href="http://fsharp.org/">http://fsharp.org/</a>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note10"></a>Note</h3>
<p>The F# community projects are also managed by FSSF, and it is welcoming contributions as well. FSSF is an independent entity and it is not tied to Microsoft.</p>
</div>
<p>Visual F# in Visual Studio 2015 has mainly the following capabilities:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Project template support, including the NuGet package addition and references to other projects in the same solution file. The other projects can be VB or C# projects, not just F#.</li>
<li class="listitem"><code class="literal">AssemblyInfo</code> support in a separate file. This feature has been available since Visual Studio 2015. Previously it was only available in C# and VB projects.</li>
<li class="listitem">The F# compiler, FSC, is used to compile F# into .NET executable and libraries in the form of DLL.</li>
<li class="listitem">Integration of the F# compiler, MSBuild infrastructure, and also Intellisense.</li>
<li class="listitem">F# libraries, a foundation to the functional programming constructs of F# and F# unique concurrency features such as asynchronous workflow and <code class="literal">MailboxProcessor</code>. It also contains many useful functions to further interoperate with C#/VB, including interoperating with .NET delegates.</li>
<li class="listitem">Interactive support for the F# interactive (FSI) prompt in the IDE.</li>
</ul>
</div>
<p>For more information about F# tooling, this is the official MSDN Library link:&#160;</p>
<p>

<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp">https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp</a>

</p>
<p>It is recommended to always consult the Visual F# documentation on GitHub first, then combine it with the online MSDN Library section of F#.</p>
<p>Microsoft has planned to rebuild all of the online MSDN Library to use the GitHub participation model, so developers can submit a pull request to modify or to amend any documentation page. Visual F# is now being reworked on as well, but there are some pages still left behind inside Visual F# GitHub repo.</p>
<p>To always check the latest development of F# documentation on GitHub, visit <a class="ulink" href="https://github.com/Microsoft/visualfsharpdocs">https://github.com/Microsoft/visualfsharpdocs</a>.</p>
<div class="section" title="Interactive support for F# interactive"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"></a>Interactive support for F# interactive</h2>
</div>
</div>
</div>
<p>F# interactive is a tool to interpret your F# code and run it immediately. It will also process and show the results, the types, and the syntax errors. The code can be run in the interactive prompt or taken from the source code and then run into F# interactive.
</p>
<div class="note" title="Note"><h3 class="title"><a id="note11"></a>Note</h3>
<p>The concept of having interpreted code, executing it, and seeing the results is called REPL. <span class="strong"><strong>REPL</strong></span> is abbreviated from <span class="strong"><strong>Read-Eval-Print-Loop</strong></span>, and it was first available as the system's command-line prompt. There is nothing new about this REPL concept, as other programming languages such as Python already have had REPL before F#.</p>
</div>
<p>Compared to C# and VB, F# interactive is the first to have interactive REPL support since Visual Studio 2010. Unfortunately, there is no Visual Studio's Intellisense support for F# interactive yet.</p>
<p>There are two ways to use F# interactive:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In Visual Studio IDE</li>
<li class="listitem">In Command Prompt</li>
</ul>
</div>
<p>The most common usage of F# interactive is within Visual Studio IDE.</p>
<p>We have to set up the <span class="strong"><strong>F# Interactive</strong></span> window to be displayed in order to use F# interactive.</p>
<p>These are the steps to display the <span class="strong"><strong>F# Interactive</strong></span> window:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <span class="strong"><strong>View</strong></span> menu from the Visual Studio main menu.</li>
<li class="listitem">Choose <span class="strong"><strong>Other Windows..</strong></span> and then choose <span class="strong"><strong>F# Interactive</strong></span>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>A window that hosts the <span class="strong"><strong>F# Interactive</strong></span> within Visual Studio will appear and it will be ready to interpret our F# code:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00241.jpeg" alt="Interactive support for F# interactive"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>As a starter, type <code class="literal">#help</code> followed by <code class="literal">;;</code> to mark as closing statements to be evaluated. We now see some further options:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00242.jpeg" alt="Interactive support for F# interactive"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>F# interactive can be used to not only interpret and run F# code but also as a way to see immediate results of a calculation.</p>
<p>Type <code class="literal">5 * 25;;</code> and press <span class="emphasis"><em>Enter</em></span>.</p>
<p>We now see the result of that calculation:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00243.jpeg" alt="Interactive support for F# interactive"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>We can also execute codes in the Visual Studio editor when we are opening F# source code file.</p>
<p>For example, create a new project using the F# tutorial project template:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00244.jpeg" alt="Interactive support for F# interactive"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>You may find that your display of Visual Studio is different from the previous screenshot. Actually, the aforementioned display depends on what Visual Studio edition we have. For Visual Studio Enterprise, more templates are available for us to use, such as the <span class="strong"><strong>Modeling Projects</strong></span> to create UML.</p>
<p>For the purpose of F#, the project templates of the F# projects are the same for the Community Edition and above.</p>
<p>After creating the project, an F# project contains <code class="literal">Tutorial.fsx</code>.</p>
<p>Before we use F# interactive, we should turn on the option for displaying line numbers. It is also recommended to have this option always turned on, as it will provide easier navigation to the code we write:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the <span class="strong"><strong>Tools</strong></span> menu and choose <span class="strong"><strong>Options</strong></span>. It is available in F# options in the <span class="strong"><strong>Options</strong></span> dialog:<p>
</p><div class="mediaobject"><img src="../Images/image00245.jpeg" alt="Interactive support for F# interactive"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">Now double-click <code class="literal">Tutorial.fsx</code>, and highlight lines <span class="strong"><strong>44</strong></span> to <span class="strong"><strong>61</strong></span>:<p>
</p><div class="mediaobject"><img src="../Images/image00246.jpeg" alt="Interactive support for F# interactive"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">Then press <span class="emphasis"><em>Alt </em></span>+ <span class="emphasis"><em>Enter</em></span>. F# interprets the code. We can see the result of the interpretation in <span class="strong"><strong>F# Interactive</strong></span>:<p>
</p><div class="mediaobject"><img src="../Images/image00247.jpeg" alt="Interactive support for F# interactive"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>We have tried F# interactive from within the Visual Studio IDE. Let's use F# interactive from Command Prompt.</p>
<div class="note" title="Note"><h3 class="title"><a id="note12"></a>Note</h3>
<p>We can also use <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>F</em></span> to activate or open <span class="strong"><strong>F# Interactive</strong></span>.</p>
</div>
<p>To use F# interactive from Command Prompt, we call the executable FSI directly from Command Prompt.</p>
<p>The best way to run FSI is from Visual Studio's developer Command Prompt. This developer Command Prompt is available under the <code class="literal">Visual Studio 2015</code> folder on the start menu of the Windows desktop menu bar.</p>
<p>Select it, and now we have the <span class="strong"><strong>Developer Command Prompt for VS2015</strong></span>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00248.jpeg" alt="Interactive support for F# interactive"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Type <code class="literal">FSI</code> and press <span class="emphasis"><em>Enter</em></span>.</p>
<p>We can try to write some code to evaluate, such as:</p>
<pre class="programlisting">let anynumber = 5 * 25;; 
</pre>
<p>Press <span class="emphasis"><em>Enter</em></span>. The immediate result will be displayed:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00249.jpeg" alt="Interactive support for F# interactive"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>To quit the FSI, type <code class="literal">#quit;;</code> and press <span class="emphasis"><em>Enter</em></span>.</p>
<p>Using F# interactive from Command Prompt is faster but it is also not quite so user-friendly because we cannot evaluate multiple lines of code easily. It is easier to evaluate this in Visual Studio IDE.</p>
<div class="note" title="Note"><h3 class="title"><a id="note13"></a>Note</h3>
<p>For simplicity and ease of use, the rest of this book will always use FSI within the Visual Studio IDE.</p>
</div>
<p>For more information about F# FSI, consult the FSI reference from the MSDN Library at&#160;
<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference">https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference</a>.
</p>
<p>FSI is also configurable. We can configure FSI further by leveraging the FSI class library in the <code class="literal">Microsoft.FSharp.Compiler.Interactive</code> namespace. More information on this library is also available at the F# FSI URL mentioned previously.</p>
</div>
</div>


<div class="section" title="Introduction to debugging in F#"><div class="titlepage" id="aid-I3QM2"><div><div><h1 class="title"><a id="ch01lvl1sec11"></a>Introduction to debugging in F#</h1>
</div>
</div>
</div>
<p>There is one aspect of understanding running F# code that is crucial: debugging F# code. We have to be able to debug F# code, especially when we have very large projects that have hundreds of F# code files, not to mention when each of the code files may have too many lines of code. For example, having to check a running F# code that has more than 2,000 lines.</p>
<p>The following are the advantages of the debug features:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Isolating the error and focusing on it by inserting a breakpoint can ease the fixing of an error or bug. Developers are gaining more productivity because they can fix errors/bugs faster.</li>
<li class="listitem">Debugging can also provide insightful information about the correctness of any value returning from a function.</li>
<li class="listitem">Debugging can also be used to trace bugs further by examining the results from other referenced libraries as well. It is possible that we may use the referenced library incorrectly or the referenced library may also have bugs.</li>
</ul>
</div>
<p>Visual F# in Visual Studio 2015 also has debugging capabilities. It was not as powerful when it was introduced in Visual Studio 2008 as additional add-on, but now the debugging experience is much better. It has been integrated with the Visual Studio extensibility model nicely, providing, for example, faster execution while running in the debug mode and having conditional breakpoints.</p>
<p>It is different from the C#/VB debugger because F#, although being a strongly and strictly typed language, currently has no support for evaluating expressions in the debugger's immediate windows in Visual Studio 2015.</p>
<div class="note" title="Note"><h3 class="title"><a id="note14"></a>Note</h3>
<p>Some experienced F# developers may argue that this additional debug feature is not a big concern at all as F# has a tendency to enforce type restriction and correctness at the fabric of F# as a programming language. But for most other developers, especially those who&#160;jump from C#/VB to F#, the overall debugging experience is still lacking some features.</p>
</div>
<p>Currently these are the differences between the F# and C#/VB debugger in Visual Studio 2015:</p>
<div class="informaltable"><table border="1"><colgroup><col/>
<col/>
<col/>
</colgroup>
<tbody><tr><td>
<p>
<span class="strong"><strong>Feature</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>F#</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>C#/VB</strong></span>
</p>
</td>
</tr>
<tr><td>
<p>Breakpoint insertion</p>
</td>
<td>
<p>Yes.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr><td>
<p>Condition in breakpoint</p>
</td>
<td>
<p>Yes.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr><td>
<p>Intellisense in editing condition in breakpoint</p>
</td>
<td>
<p>Not supported because Intellisense is not yet linked to the whole infrastructure of the Visual Studio 2015 IDE extensibility and the F# compiler. There is a plan to have this feature for the next Visual Studio release after Visual Studio 2015.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr><td>
<p>Lightbulb assistant</p>
</td>
<td>
<p>Not available. There is a plan to have this feature for the next Visual Studio release after Visual Studio 2015, but the exact planned release is not quite clear.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr><td>
<p>Expression evaluation in immediate window</p>
</td>
<td>
<p>Not available.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr><td>
<p>Locals value</p>
</td>
<td>
<p>Yes.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr><td>
<p>Auto watch value</p>
</td>
<td>
<p>Yes.</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>Other than the features in the previous table, basic debugging with breakpoints in Visual F# is essentially the same as debugging in C#/VB.</p>
<p>Let's take some code to debug. To quickly have some code, we can use the F# 3.0 sample from CodePlex at:</p>
<p>
<a class="ulink" href="http://fsharp3sample.codeplex.com/">http://fsharp3sample.codeplex.com/</a>
</p>
<p>After downloading the ZIP file of the code samples, unzip it to a folder and open the <code class="literal">SampleProject.sln</code> solution file in Visual Studio.</p>
<div class="note" title="Note"><h3 class="title"><a id="note15"></a>Note</h3>
<p>You may read <code class="literal">Readme.txt</code> first before using the whole sample code. This readme guide is available in the <code class="literal">Solution Item</code> folder when opened in <span class="strong"><strong>Solution Explorer</strong></span>.</p>
</div>
<p>Now, your screen should look like this:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00250.jpeg" alt="Introduction to debugging in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Some of the samples in F# 3.0 are not valid anymore. You have to register for Azure DataMarket to access the F# Type Provider of Azure DataMarket.</p>
<p>There are some compiler errors if we try to rebuild the solution without changing the code at all, and one of the sample type providers, ESRI DataMarket, is not working.</p>
<p>Based on those invalid type provider conditions, to build this sample solution successfully, you have to follow these steps:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Register with Azure DataMarket. You need to have your own Azure account key to access Azure DataMarket.</li>
<li class="listitem">The ESRI sample has not been working since 2014. Please comment the lines from line 135 to line 157 in the <code class="literal">Samples.TypeProviders.AzureMarketPlace.fs</code> file.</li>
<li class="listitem">Rebuild the solution. This will compile the whole solution and also resolve the type provider in the background for us to use.</li>
<li class="listitem">Now open the <code class="literal">Samples.Beginners.fs</code> file. Put the debugger breakpoints at lines 19 and 20 by clicking the line.</li>
<li class="listitem">To add breakpoints, you can simply toggle the highlighted column on the left before the line number like this:<p>
</p><div class="mediaobject"><img src="../Images/image00251.jpeg" alt="Introduction to debugging in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">And we can also add breakpoints by right clicking and choosing <span class="strong"><strong>Breakpoints..</strong></span> and then <span class="strong"><strong>Insert Breakpoint</strong></span>.</li>
<li class="listitem">Compile the code by initiating the <span class="strong"><strong>Build Solution</strong></span>. Then press <span class="emphasis"><em>F5</em></span> to run. The window of <span class="strong"><strong>F# Micro Sample Explore</strong></span> is displayed:<p>
</p><div class="mediaobject"><img src="../Images/image00252.jpeg" alt="Introduction to debugging in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>This sample is actually a showcase of many F# features, from basic language constructs, units of measure, type providers, and LINQ, to concurrency such as async and parallelism.</p></li>
<li class="listitem">Now expand the <span class="strong"><strong>Basic</strong></span> node on the left and choose <span class="strong"><strong>Basic Data Types</strong></span>, and then choose the last node of <span class="strong"><strong>Integer Arithmetic</strong></span>, as illustrated here:<p>
</p><div class="mediaobject"><img src="../Images/image00253.jpeg" alt="Introduction to debugging in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
<li class="listitem">Going back to the source code of <code class="literal">Samples.Beginner.fs</code>, we can see that the node name is also the same as the name of the attributes in the code to categorize:<pre class="programlisting">&#160; &#160;&#160;  [&lt;Category("Basic Data Types"); 
  &#160; &#160;&#160;  Title("Integer Arithmetic"); 
  &#160; &#160;&#160;  Description("This sample shows some basic integer arithmetic")&gt;] 
&#160; &#160;&#160;  let SampleArithmetic1() = 
    &#160; &#160;&#160;  let x = 10 + 12 - 3  
    &#160; &#160;&#160;  let y = x * 2 + 1  
    &#160; &#160;&#160;  let r1,r2 = x/3, x%3 
    &#160; &#160;&#160;  printfn "x = %d, y = %d, r1 = %d, r2 = %d" x y r1 r2 
</pre></li>
<li class="listitem">Click the <span class="strong"><strong>Run Sample!</strong></span> button and Visual Studio will stop the execution at the breakpoint:<p>
</p><div class="mediaobject"><img src="../Images/image00254.jpeg" alt="Introduction to debugging in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we can debug our code easily. We can also look at the value of the variables or symbols that are currently in scope by checking the value at the <span class="strong"><strong>Locals</strong></span> window.</p></li>
<li class="listitem">Press <span class="emphasis"><em>F10</em></span> to step over, and now we see the evaluated value of <code class="literal">x</code> and <code class="literal">y</code>:<p>
</p><div class="mediaobject"><img src="../Images/image00255.jpeg" alt="Introduction to debugging in F#"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Any local variables in <span class="strong"><strong>Locals</strong></span> and watch expressions displayed in the <span class="strong"><strong>Watch1</strong></span> window always have the name, value, and type of the variables. The type displayed is using the F# keyword, not the full type name.</p>
<p>For example, <code class="literal">int</code> is displayed instead of <code class="literal">System.Int32</code> as shown in <span class="strong"><strong>Locals</strong></span>.</p>
<p>We can always check other values as well if we have another <code class="literal">global</code> or <code class="literal">static global</code> variable in the <span class="strong"><strong>Watch1</strong></span> window. The values can contain immediate values from an expression, for example <code class="literal">DateTime.Now</code>.</p>
<p>Unfortunately, we have to write using the full namespace of <code class="literal">System.DateTime</code>, so we have to write the expression as <code class="literal">System.DateTime.Now</code>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00256.jpeg" alt="Introduction to debugging in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>This requirement to have the full namespace proves that debugger support in Visual F# still requires improvements compared to its C#/VB counterparts. Typing the full object name may be error prone, as F# watch does not support Intellisense yet.</p>
<p>After we have finished debugging and bug fixing, it is recommended to change the compilation to the <span class="strong"><strong>Release</strong></span> mode. The <span class="strong"><strong>Release</strong></span> mode will have a smaller compiled F# code and it executes faster because it does not contain debug symbols and any other debug information attached to the compiled code.</p>
<p>To change back and forth between <span class="strong"><strong>Debug</strong></span> and <span class="strong"><strong>Release</strong></span> is quite easy. We can simply change the mode at the drop-down menu in the Visual Studio toolbar:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00257.jpeg" alt="Introduction to debugging in F#"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>There is no apparent distinction on the compiled DLL or EXE filename, other than the smaller size of the release mode.</p>
<p>To summarize, the following are the differences of the <span class="strong"><strong>Debug</strong></span> mode and the <span class="strong"><strong>Release</strong></span> mode:</p>
<div class="informaltable"><table border="1"><colgroup><col/>
<col/>
<col/>
</colgroup>
<tbody><tr><td>
<p>
<span class="strong"><strong>Elements</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>Debug</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>Release</strong></span>
</p>
</td>
</tr>
<tr><td>
<p>Debug symbol (PDB)</p>
</td>
<td>
<p>Included</p>
</td>
<td>
<p>Not included.</p>
</td>
</tr>
<tr><td>
<p>Size of compiled code</p>
</td>
<td>
<p>Bigger than the release mode, excluding the PDB file</p>
</td>
<td>
<p>Smaller than the debug mode.</p>
</td>
</tr>
<tr><td>
<p>Code optimization</p>
</td>
<td>
<p>Not optimized, as it is focused for debugging and it is also synchronized</p>
</td>
<td>
<p>
</p>
<p>Yes, but the code will not be able to be debugged easily, as the code is optimized for executions.</p>
<p>
</p>
<p>In .NET 4.6 and Windows 10, it is optimized further by compiling into native code using the Ahead Of Time (AOT) model instead of Just In Time (JIT).</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>Compilation symbol availability</p>
</td>
<td>
<p>
<code class="literal">DEBUG</code>
</p>
</td>
<td>
<p>Not applicable.</p>
</td>
</tr>
<tr><td>
<p>Execution</p>
</td>
<td>
<p>Slower than Release, as there is no optimization</p>
</td>
<td>
<p>Fast, since it is optimized for runtime, and there is no debug symbol overhead.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>For more information about AOT and JIT, consult the MSDN Library at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx</a>.</p>
</div>


<div class="section" title="Summary" id="aid-J2B81"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"></a>Summary</h1>
</div>
</div>
</div>
<p>We discussed the introduction to performing common performance optimizations, from the performance characteristics of F# and .NET to the most commonly used optimization concepts such as concurrency. We also have a basic knowledge to start troubleshooting performance problems by debugging using Visual Studio. But debugging running F# code is still a small part of performance optimization because debugging only provides an insight of the values and the states of objects in our code.</p>
<p>The debug support of F# tooling itself is not enough to fully understand the details of performance problems because most of the detailed performance optimization requires us to measure the benchmark of our code. The measurement of performance in order to objectively measure optimization will be described in 
<a class="link" title="Chapter&#160;2.&#160;Performance Measurement" href="fsp-hiperf_cu02.html#aid-K0RQ2">Chapter 2</a>
,&#160;<span class="emphasis"><em>Performance Measurement</em></span>.</p>
</div>
</body>
</html>