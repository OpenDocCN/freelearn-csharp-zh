- en: Dynamic Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态图形
- en: There is no question that the Rendering Pipeline of a modern graphics device
    is complicated. Even rendering a single triangle to the screen requires a multitude
    of graphics API calls. This includes tasks such as creating a buffer for the camera
    view that hooks into the operating system (usually via some kind of windowing
    system), allocating buffers for vertex data, setting up data channels to transfer
    vertex and texture data from RAM to VRAM, configuring each of these memory spaces
    to use a specific set of data formats, determining the objects that are visible
    to the camera, setting up and initiating a draw call for the triangle, waiting
    for the Rendering Pipeline to complete its task(s), and finally, presenting the
    rendered image to the screen. However, there's a simple reason for this seemingly
    convoluted and over-engineered way of drawing such a simple object—rendering often
    involves repeating the same tasks over and over again, and all of this initial
    setup makes future rendering tasks very fast.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，现代图形设备的渲染管线非常复杂。即使是将单个三角形渲染到屏幕上，也需要调用大量的图形API。这包括创建用于相机视图的缓冲区，该缓冲区连接到操作系统（通常通过某种类型的窗口系统），为顶点数据分配缓冲区，设置数据通道以将顶点和纹理数据从RAM传输到VRAM，配置每个内存空间以使用特定的数据格式，确定相机可见的对象，设置并初始化三角形的绘制调用，等待渲染管线完成其任务，最后将渲染的图像呈现到屏幕上。然而，这种看似复杂且过度设计的绘制简单对象的方式有一个简单的理由——渲染通常涉及重复执行相同的任务，而所有这些初始设置使得未来的渲染任务非常快速。
- en: CPUs are designed to handle virtually any computational scenario, but can't
    handle too many tasks simultaneously, whereas GPUs are designed for incredibly
    large amounts of parallelism, but they are limited in the complexity they can
    handle without breaking that parallelism. Their parallel nature requires immense
    amounts of data to be copied around very rapidly. During the setup of the Rendering
    Pipeline, we configure memory data channels for our graphics data to flow through.
    So, if these channels are properly configured for the types of data we will be
    passing, then they will operate more efficiently. However, setting them up poorly
    will result in the opposite.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CPU被设计来处理几乎任何计算场景，但不能同时处理太多任务，而GPU被设计用于处理极其大量的并行处理，但它们在处理复杂度方面有限，否则会破坏这种并行性。它们的并行性质需要大量数据被非常快速地复制。在渲染管线的设置过程中，我们为我们的图形数据配置内存数据通道。因此，如果这些通道被正确配置为传递的数据类型，那么它们将更有效地运行。然而，配置不当会导致相反的结果。
- en: Both the CPU and GPU are used during all graphics rendering, making it a high-speed
    dance of processing and memory management that spans software; hardware; multiple
    memory spaces, programming languages (each suited to different optimizations),
    processors, and processor types; and a large number of special-case features that
    can be thrown into the mix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个图形渲染过程中，CPU和GPU都被使用，这使得它成为跨越软件；硬件；多个内存空间，编程语言（每种语言都适合不同的优化），处理器和处理器类型；以及大量可以添加到混合中的特殊情况的高速度处理和内存管理舞蹈。
- en: To make matters even more complicated, every rendering situation we will come
    across is different in its own way. Running the same application against two different
    GPUs often results in an apples-versus-oranges comparison due to the different
    capabilities and APIs they support.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的是，我们将遇到的每个渲染情况都有其独特之处。在两个不同的GPU上运行相同的应用程序通常会导致苹果与橙子的比较，因为它们支持不同的功能和API。
- en: It can be challenging to determine where a bottleneck resides within such a
    complex web of hardware and software systems, and it can take a lifetime of industry
    work in 3D graphics if we want to have a strong and immediate intuition about
    the source of performance issues in modern Rendering Pipelines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此复杂的硬件和软件系统中确定瓶颈所在可能具有挑战性，如果我们想要对现代渲染管线中性能问题的来源有强烈的直接直觉，这可能需要一生在3D图形行业的经验工作。
- en: Thankfully, profiling comes to the rescue once again, which makes becoming a
    Rendering Pipeline wizard less of a necessity. If we can gather data about each
    device, use multiple performance metrics for comparison, and tweak our scenes
    to observe how different rendering features affect their behavior, then we should
    have sufficient evidence to find the root cause of an issue and make appropriate
    changes. So, in this chapter, you will learn how to gather the right data, dig
    just deep enough into the Rendering Pipeline to find the real source of the problem,
    and explore various solutions and workarounds for a multitude of potential issues.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，性能分析再次发挥了救星的作用，这使得成为渲染管线大师变得不那么必要。如果我们能够收集到关于每个设备的资料，使用多个性能指标进行比较，并调整我们的场景来观察不同的渲染特性如何影响其行为，那么我们应该有足够的证据来找到问题的根源并做出适当的改变。因此，在本章中，你将学习如何收集正确的数据，深入挖掘渲染管线以找到问题的真正源头，并探索各种解决方案和针对众多潜在问题的应对措施。
- en: 'There are many topics to be covered when it comes to improving rendering performance.
    So, in this chapter, we will explore the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到提高渲染性能时，有许多主题需要讨论。因此，在本章中，我们将探讨以下主题：
- en: A brief exploration of the Rendering Pipeline, focusing on the parts where the
    CPU and GPU come into play
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对渲染管线的简要探索，重点关注CPU和GPU介入的部分
- en: General techniques on how to determine whether our rendering is limited by the
    CPU or GPU
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定我们的渲染是否受CPU或GPU限制的一般技术
- en: 'A series of performance optimization techniques and features, such as:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列性能优化技术和特性，例如：
- en: Using GPU instancing
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPU实例化
- en: Taking advantage **of Level of Detail** (**LOD**) and other culling groups
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用**细节级别**（**LOD**）和其他剔除组
- en: Using Occlusion Culling
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遮挡剔除
- en: Optimizing Particle Systems
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化粒子系统
- en: Improve Unity UI
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进Unity UI
- en: Optimize your Shaders
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化你的着色器
- en: Optimize lighting and shadow with lightmaps
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光照贴图优化光照和阴影
- en: Applying mobile-specific rendering enhancements
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用移动特定的渲染增强
- en: Exploring the Rendering Pipeline
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索渲染管线
- en: Poor rendering performance can manifest itself in several ways, depending on
    whether the device is limited by CPU activity (we are CPU bound) or by GPU activity
    (we are GPU bound). Investigating a CPU-bound application can be relatively simple
    since all of the CPU work is wrapped up in loading data from disk/memory and calling
    graphics API instructions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备是受CPU活动限制（我们受CPU限制）还是受GPU活动限制（我们受GPU限制），渲染性能不佳可能以多种方式表现出来。调查受CPU限制的应用程序可能相对简单，因为所有的CPU工作都包括从磁盘/内存加载数据和调用图形API指令。
- en: However, a GPU-bound application can be more difficult to analyze since the
    root cause could originate from one of a large number of potential places within
    the Rendering Pipeline. We might find that we need to rely on a little guesswork
    or *process of elimination* to determine the source of a GPU bottleneck. In either
    case, once the problem is discovered and resolved, we can expect significant improvements
    since small fixes tend to reap big rewards when it comes to fixing issues in the
    Rendering Pipeline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，受GPU限制的应用程序可能更难分析，因为根本原因可能来自渲染管线中的大量潜在位置之一。我们可能会发现，我们需要依赖一点猜测或*排除法*来确定GPU瓶颈的来源。在任何情况下，一旦问题被发现并解决，我们都可以期待显著的改进，因为小的修复在解决渲染管线中的问题时往往会带来巨大的回报。
- en: We briefly touched on the Rendering Pipeline in Chapter 3, *The Benefits of
    Batching*. To briefly summarize the essential points, we know that the CPU sends
    rendering instructions through the graphics API that funnels through the hardware
    driver to the GPU device, which results in a list of rendering instructions being
    accumulated in a queue known as the command buffer. The GPU processes these commands
    one by one until the command buffer is empty. So long as the GPU can keep up with
    the rate and complexity of instructions before the next frame is due to begin,
    we will maintain our frame rate. However, if the GPU falls behind, or the CPU
    spends too much time generating commands, the frame rate will start to drop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章《批处理的好处》中，我们简要介绍了渲染管线。为了简要总结关键点，我们知道CPU通过图形API发送渲染指令，通过硬件驱动程序流向GPU设备，这导致一系列渲染指令积累在一个称为命令缓冲区的队列中。GPU逐个处理这些命令，直到命令缓冲区为空。只要GPU能够跟上下一帧开始前的指令速率和复杂性，我们就能保持帧率。然而，如果GPU落后，或者CPU花费太多时间生成命令，帧率就会开始下降。
- en: 'The following is a greatly simplified diagram of a typical Rendering Pipeline
    on a modern GPU (which can also vary based on device, technology support, and
    custom optimizations), showing a broad view of the steps that take place:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个现代GPU上典型渲染管线的高度简化图（这也可以根据设备、技术支持和自定义优化而有所不同），展示了发生的步骤的广泛视图：
- en: '![](img/186d7479-5654-40b1-bf0a-c938668e9bf1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/186d7479-5654-40b1-bf0a-c938668e9bf1.png)'
- en: The top row represents the work that takes place in the CPU, which includes
    both the act of calling into the graphics API through the hardware driver and
    pushing commands into the GPU. The next two rows represent the steps that take
    place in the GPU. Owing to the GPU's complexity, its internal processes are often
    split into two different sections—the **Frontend** and the **Backend**, which
    require a little added explanation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面一行表示在CPU中进行的操作，这包括通过硬件驱动程序调用图形API以及将命令推送到GPU。接下来的两行表示在GPU中进行的步骤。由于GPU的复杂性，其内部过程通常分为两个不同的部分——**前端**和**后端**，这需要一些额外的解释。
- en: The GPU frontend
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU前端
- en: 'The frontend refers to the part of the rendering process where the GPU handles
    vertex data. Let''s understand how it works:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前端指的是渲染过程中GPU处理顶点数据的部分。让我们了解它是如何工作的：
- en: The frontend will receive mesh data from the CPU (a big bundle of vertex information),
    and a draw call will be issued.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端将从CPU接收网格数据（一个包含大量顶点信息的大包），并发出一个绘制调用。
- en: The GPU then gathers all pieces of vertex information from the mesh data and
    passes them through vertex shaders, which are allowed to modify them and output
    them in a *1-to-1* manner.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPU随后从网格数据中收集所有顶点信息，并通过顶点着色器传递它们，顶点着色器可以修改它们并以*1-to-1*的方式输出。
- en: From this, the GPU now has a list of primitives to process (triangles—the most
    primitive shapes in 3D graphics).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，GPU现在有一个要处理的原始数据列表（三角形——3D图形中最原始的形状）。
- en: Next, the rasterizer takes these primitives and determines which pixels of the
    final image will need to be drawn on to create the primitive based on the positions
    of its vertices and the current camera view. The list of pixels generated from
    this process is known as **fragments**, which will be processed in the backend.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，光栅化器将这些原始数据转换为最终图像需要绘制的像素，基于其顶点的位置和当前相机视图创建原始数据。从这个过程中生成的像素列表被称为**片段**，将在后端进行处理。
- en: Vertex shaders are small C-like programs that determine the input data that
    they are interested in and the way that they will manipulate it, and then will
    output a set of information for the rasterizer to generate fragments with. It
    is also home to the process of tessellation, which is handled by geometry shaders
    (sometimes called **tessellation shaders**), similar to a vertex shader in that
    they are small scripts uploaded to the GPU, except that they are allowed to output
    vertices in a *1-to-many* manner, hence, generating additional geometry programmatically.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器是类似于C语言的程序，它们确定它们感兴趣的数据输入以及它们将如何操作这些数据，然后输出一组信息供光栅化器生成片段。它也是细分过程的家，这个过程由几何着色器（有时称为**细分着色器**）处理，类似于顶点着色器，因为它们是上传到GPU的小脚本，但它们被允许以*1-to-many*的方式输出顶点，因此可以程序化地生成额外的几何形状。
- en: The term **shader** is an anachronism from back when these scripts primarily
    handled lighting and shading tasks before their role was expanded to include all
    of the tasks they are used for today.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**这个术语是从这些脚本最初主要处理光照和着色任务时的一个时代遗留下来的，那时它们的作用还没有扩展到包括今天它们所使用的所有任务。'
- en: The GPU backend
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU后端
- en: 'The backend represents the part of the Rendering Pipeline where fragments are
    processed. Let''s see how it works:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 后端代表渲染管线中处理片段的部分。让我们看看它是如何工作的：
- en: Each fragment will pass through a fragment shader (also known as a **pixel shader**).
    These shaders tend to involve a lot more complex activity compared to vertex shaders,
    such as depth testing, alpha testing, colorization, texture sampling, lighting,
    shadows, and various post-processing effects, to name but a few of the possibilities.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个片段都将通过一个片段着色器（也称为**像素着色器**）。与顶点着色器相比，这些着色器通常涉及更多的复杂活动，例如深度测试、alpha测试、着色、纹理采样、光照、阴影以及各种后期处理效果，仅举几例。
- en: This data is then drawn onto the frame buffer, which holds the current image
    that will eventually be sent to the display device (our monitor) once rendering
    tasks for the current frame are complete. There usually are two Frame Buffers
    in use by graphics APIs by default (although more could be generated for custom
    rendering scenarios).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这些数据会被绘制到帧缓冲区上，帧缓冲区保存了当前图像，一旦完成当前帧的渲染任务，最终会发送到显示设备（我们的显示器）上。图形API默认情况下通常使用两个帧缓冲区（尽管在自定义渲染场景中可以生成更多）。
- en: At any given moment, one of the frame buffers contains the data from the frame
    we rendered to and is being presented to the screen, while the other is actively
    being drawn to by the GPU while it completes commands from the command buffer.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何给定时刻，一个帧缓冲区包含我们渲染到帧的数据，并且正在被展示到屏幕上，而另一个帧缓冲区则被GPU积极绘制，同时它完成命令缓冲区中的命令。
- en: Once the GPU reaches a `swap buffers` command (the final instruction the CPU
    asks it to complete for the given frame), the frame buffers are flipped around
    so that the new frame is presented.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当GPU达到`swap buffers`命令（CPU要求GPU完成的给定帧的最后一个指令）时，帧缓冲区就会翻转，以便展示新的帧。
- en: The GPU will then use the old frame buffer to draw the next frame.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，GPU将使用旧的帧缓冲区来绘制下一个帧。
- en: This process repeats each time a new frame is rendered; hence, the GPU only
    needs two Frame Buffers to handle this task.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当渲染一个新的帧时，这个过程就会重复；因此，GPU只需要两个帧缓冲区来处理这个任务。
- en: This entire process, from making graphics API calls to swapping Frame Buffers,
    repeats continuously for every mesh, vertex, fragment, and frame, so long as our
    application is still rendering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用图形API到交换帧缓冲区，这个过程会持续不断地为每个网格、顶点、片段和帧重复，只要我们的应用程序仍在渲染。
- en: Two metrics tend to be the source of bottlenecks in the backend—Fill Rate and
    memory bandwidth. Let's explore them a little.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 两个指标往往会导致后端出现瓶颈——填充率和内存带宽。让我们来稍微了解一下它们。
- en: Fill Rate
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充率
- en: Fill Rate is an inclusive term referring to the speed at which the GPU can draw
    fragments. However, this only includes fragments that have survived all of the
    various conditional tests we might have enabled within the given fragment shader.
    A fragment is merely a *potential pixel*, and if it fails any of the enabled tests,
    then it is immediately discarded. This can be an enormous performance-saver, as
    the Rendering Pipeline can skip the costly drawing step and begin working on the
    next fragment instead.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 填充率是一个包含性术语，指的是GPU绘制片段的速度。然而，这仅包括在给定的片段着色器中启用了所有各种条件测试后幸存下来的片段。片段只是一个*潜在像素*，如果它未能通过任何启用的测试，那么它就会被立即丢弃。这可以是一个巨大的性能提升，因为渲染管线可以跳过昂贵的绘制步骤，转而开始处理下一个片段。
- en: One such example of a test that might cull a fragment is *Z-testing*, which
    checks whether the fragment from a closer object has already been drawn to the
    same fragment location (the *Z* refers to the depth dimension from the point of
    view of the camera). If so, the current fragment is discarded. If not, then the
    fragment is pushed through the fragment shader and drawn over the target pixel,
    which consumes exactly one fill from our Fill Rate. Now, imagine multiplying this
    process by thousands of overlapping objects, each of which generates hundreds
    or thousands of possible fragments (higher screen resolutions require more fragments
    to be processed). This could easily lead to millions of fragments to process every
    frame due to all of the possible overlaps of the main camera. On top of this,
    we're trying to repeat this process dozens of times every second. This is why
    performing so much initial setup in the Rendering Pipeline is important, and it
    should be reasonably obvious that skipping as many of these draws as we can results
    in significant rendering cost savings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能剔除片段的测试示例是*Z测试*，它检查来自较近对象的片段是否已经绘制到相同的片段位置（*Z*指的是从摄像机的视角来看的深度维度）。如果是这样，当前片段就会被丢弃。如果不是，那么片段就会通过片段着色器并绘制到目标像素上，这正好消耗了我们的填充率中的一个。现在，想象一下将这个过程乘以成千上万的重叠对象，每个对象都生成数百或数千个可能的片段（更高的屏幕分辨率需要处理更多的片段）。由于主摄像机的所有可能重叠，这可能导致每帧处理数百万个片段。此外，我们每秒试图重复这个过程数十次。这就是为什么在渲染管线中进行如此多的初始设置很重要，而且应该很明显，跳过尽可能多的这些绘制操作可以显著节省渲染成本。
- en: Graphics card manufacturers typically advertise a particular Fill Rate as a
    feature of the card, usually in the form of gigapixels per second, but this is
    a bit of a misnomer, as it would be more accurate to call it gigafragments per
    second; however, this argument is mostly academic. Either way, larger values tell
    us that the device can potentially push more fragments through the Rendering Pipeline.
    So, with a budget of 30 gigapixels per second and a target frame rate of 60 Hz,
    we can afford to process *30,000,000,000/60 = 500 million fragments* per frame
    before being bottlenecked on Fill Rate. With a resolution of 2,560 x 1,440 and
    a best-case scenario where each pixel is drawn over only once, we could theoretically
    draw the entire scene about 125 times without any noticeable problems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图形卡制造商通常将特定的填充率作为卡的特性进行宣传，通常以每秒千兆像素的形式出现，但这有点误导，因为它更准确地应该被称为每秒千兆片段；然而，这个论点主要是学术性的。无论如何，较大的值告诉我们设备可以潜在地通过渲染管线推送更多的片段。因此，在每秒30千兆像素的预算和60Hz的目标帧率下，我们可以在填充率瓶颈之前处理*30,000,000,000/60
    = 5亿个片段*每帧。以2,560 x 1,440的分辨率和最佳情况，即每个像素只绘制一次，理论上我们可以绘制整个场景大约125次而不会出现任何明显的问题。
- en: Sadly, this is not a perfect world. Fill Rate is also consumed by other advanced
    rendering techniques, such as shadows and post-processing effects, that need to
    take the same fragment data and perform their passes on the Frame Buffer. Even
    so, we will always end up with some amount of redraw over the same pixels due
    to the order in which objects are rendered. This is known as **Overdraw**, and
    it is a useful metric to measure how efficiently we are making use of our Fill
    Rate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这不是一个完美的世界。填充率也被其他高级渲染技术消耗，例如阴影和后期处理效果，这些技术需要处理相同的片段数据并在帧缓冲区上执行它们的遍历。即便如此，由于对象渲染的顺序，我们最终总是会因为相同的像素而有一些重绘。这被称为**过度绘制**，它是衡量我们如何有效地利用填充率的一个有用的指标。
- en: Overdraw
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度绘制
- en: How much Overdraw we have can be represented visually by rendering all objects
    with additive alpha blending and a flat coloration. Areas of high Overdraw will
    show up more brightly, as the same pixel is drawn over with additive blending
    multiple times. This is precisely how the Scene window's Overdraw shading mode
    reveals how much Overdraw our scene is undergoing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多少过度绘制可以通过将所有对象以加法alpha混合和平滑着色渲染来直观表示。过度绘制高的区域会显得更亮，因为相同的像素通过加法混合多次绘制。这正是场景窗口的过度绘制着色模式揭示我们的场景正在经历多少过度绘制的方式。
- en: 'The following screenshot shows a scene with several thousand boxes drawn normally
    (left) versus the Scene window''s Overdraw shading mode (right):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了正常绘制（左）与场景窗口的过度绘制着色模式（右）的几个千个盒子场景：
- en: '![](img/fd3557fb-135a-49c9-8f45-1bb112fb42bd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd3557fb-135a-49c9-8f45-1bb112fb42bd.png)'
- en: The more Overdraw we have, the more Fill Rate we are wasting by overwriting
    fragment data. There are several techniques we can apply to reduce Overdraw, which
    we will explore later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的过度绘制越多，我们就浪费了更多的填充率，因为我们需要覆盖片段数据。我们可以应用几种技术来减少过度绘制，我们将在稍后探讨。
- en: 'Note that there are several different queues used for rendering, which can
    be separated into two types: **opaque queues** and **transparent queues**.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于渲染的队列有几种不同类型，可以分为两种：**不透明队列**和**透明队列**。
- en: Objects rendered in one of the opaque queues can cull away fragments via *Z*-testing,
    as explained previously. However, objects rendered in a transparent queue cannot
    do so since their transparent nature means we can't assume that they won't need
    to be drawn no matter how many other objects are in the way, which leads to a
    lot of overdraws.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在不透明队列中渲染的对象可以通过*Z*-测试剔除片段，正如之前所解释的。然而，在透明队列中渲染的对象不能这样做，因为它们的透明性质意味着我们无法假设无论有多少其他对象挡在前面，它们都不需要被绘制，这导致了很多不必要的绘制。
- en: All Unity UI objects always render in a transparent queue, making them a significant
    source of Overdraw.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Unity UI对象总是以透明队列渲染，这使得它们成为过度绘制的一个重要来源。
- en: Memory bandwidth
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存带宽
- en: The other potential source of bottlenecks in the backend comes from memory bandwidth.
    memory bandwidth is consumed whenever a texture must be pulled from a section
    of the GPU's VRAM down into the lower memory levels. This typically happens when
    a texture is sampled, where a fragment shader attempts to pick the matching texture
    pixel (or *texel*) to draw for a given fragment at a given location. The GPU contains
    multiple cores that each have access to the same area of VRAM, but they also each
    contain a much smaller, local texture cache that stores the texture(s) the GPU
    has been most with most recently. This is similar in design with the multitude
    of CPU memory cache levels that allow memory transfer up and down the chain. This
    is a hardware design workaround for the fact that faster memory will, invariably,
    be more difficult and expensive to produce. So, rather than having a giant, expensive
    block of VRAM, we have a large, cheap block of VRAM, but use a smaller, very fast,
    lower-level texture cache to perform sampling with, which gives us the best of
    both worlds; that is, fast sampling with lower costs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 后端瓶颈的另一个潜在来源是内存带宽。每当需要从GPU的VRAM的一部分将纹理拉到较低的内存级别时，就会消耗内存带宽。这通常发生在纹理采样时，片段着色器试图为给定位置上的给定片段选择匹配的纹理像素（或*texel*）。GPU包含多个核心，每个核心都可以访问相同的VRAM区域，但它们也各自包含一个更小、本地的纹理缓存，存储GPU最近最频繁使用的纹理。这与CPU内存缓存级别的多样性设计相似，允许内存在链中上下传输。这是硬件设计的一个解决方案，因为更快的内存不可避免地会更容易生产且成本更高。因此，我们不是有一个巨大的、昂贵的VRAM块，而是一个大型的、廉价的VRAM块，但使用一个更小、非常快速的底层纹理缓存来进行采样，这样我们就得到了两者的最佳结合；也就是说，快速采样且成本较低。
- en: If a texture is needed that is already within the core's local texture cache,
    then sampling often becomes lightning fast and is barely perceivable. If not,
    then the texture must be pulled in from VRAM before it can be sampled. This is
    effectively a cache miss for the texture cache since it will now take time to
    find and pull the required texture from VRAM. This transfer consumes a certain
    amount of our available memory bandwidth, specifically an amount equal to the
    total size of the texture file stored within VRAM (which may not be the exact
    size of the original file or the size in RAM, due to GPU-level compression techniques).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的纹理已经存在于核心的本地纹理缓存中，那么采样通常变得非常快，几乎感觉不到。如果不是这样，那么纹理必须从VRAM中拉入，才能进行采样。这实际上是对纹理缓存的一个缓存未命中，因为它现在需要时间来查找和从VRAM中拉取所需的纹理。这种传输消耗了我们可用内存带宽的一部分，具体来说，是存储在VRAM中纹理文件的总大小（这可能不是原始文件的确切大小或RAM中的大小，因为GPU级别的压缩技术）。
- en: If we are bottlenecked in memory bandwidth, the GPU will keep fetching the necessary
    texture files, but the entire process will be throttled, as the texture cache
    keeps waiting for data to appear before it can process a given batch of fragments.
    The GPU won't be able to push data back to the Frame Buffer in time to be rendered
    onto the screen, blocking the whole process and culminating in a poor frame rate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在内存带宽上遇到瓶颈，GPU将不断获取必要的纹理文件，但整个过程将被限制，因为纹理缓存需要等待数据出现才能处理给定的片段批次。GPU无法及时将数据推回帧缓冲区以在屏幕上渲染，这会阻塞整个过程，并导致帧率低下。
- en: Proper usage of memory mandwidth is another budgeting concern. For example,
    with a memory bandwidth of 96 GBs per second per core and a target frame rate
    of 60 frames per second, the GPU can afford to pull roughly 1.6 GBs (*96/60*) worth
    of texture data every frame before being bottlenecked in memory bandwidth. This
    is not an exact budget, of course, because of the potential for cache misses,
    but it does give us a rough value to work with.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用内存带宽是另一个预算关注点。例如，每核心每秒96 GB的内存带宽和每秒60帧的目标帧率，GPU可以承受在内存带宽瓶颈之前，每帧大约提取1.6 GB（*96/60*）的纹理数据。当然，这不是一个精确的预算，因为存在缓存未命中，但它确实为我们提供了一个大致的数值来工作。
- en: Memory bandwidth is normally listed on a per-core basis, but some GPU manufacturers
    may try to mislead by multiplying memory bandwidth by the number of cores to list
    a bigger, but less practical number. Due to this, research may be necessary to
    compare apples with apples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内存带宽通常按每核心列出，但一些GPU制造商可能会通过将内存带宽乘以核心数来误导，列出更大的但不太实用的数字。因此，可能需要进行研究，以便比较苹果与苹果。
- en: Note that this value is not the maximum limit on the amount of texture data
    that our game can contain in the project, nor in CPU RAM, nor even in VRAM. It
    is a metric that essentially limits how much texture swapping can occur during
    one frame. The same texture could be pulled back and forth multiple times in a
    single frame, depending on how many shaders need to use the texture, the order
    that the objects are rendered, and how often texture sampling must occur. Only
    a handful of objects can consume whole GBs of memory bandwidth since there is
    only a finite amount of texture cache space available. Having a shader that needs
    a lot of large textures is more likely to cause cache misses, hence causing a
    bottleneck on Memory Bandwidth. This is surprisingly easy to trigger if we consider
    multiple objects requiring different high-quality textures and multiple secondary
    texture maps (normal maps, emission maps, and so on), which are not batched together.
    In this case, the texture cache will be unable to hang on to a single texture
    file long enough to immediately sample it during the next rendering pass.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个值并不是我们游戏在项目中可以包含的纹理数据量的最大限制，也不是CPU RAM，甚至不是VRAM。这是一个本质上限制一帧内可以发生多少纹理交换的指标。同一个纹理可以在一帧内被多次拉回和推去，这取决于需要使用纹理的着色器的数量、对象的渲染顺序以及纹理采样必须发生的频率。只有少数对象可以消耗整个GB的内存带宽，因为可用的纹理缓存空间是有限的。如果一个着色器需要大量的大纹理，则更有可能造成缓存未命中，从而在内存带宽上造成瓶颈。如果我们考虑多个需要不同高质量纹理的对象以及多个二级纹理贴图（法线贴图、发射贴图等），并且这些贴图没有批量处理在一起，那么这种情况会令人惊讶地容易触发。在这种情况下，纹理缓存将无法长时间保留单个纹理文件，以便在下一个渲染过程中立即采样它。
- en: 'We have now covered the GPU front and backend and will now move on to our next
    section in exploring our Rendering Pipeline: lighting and shadowing.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了GPU的前端和后端，接下来我们将继续探索我们的渲染管线下一部分：光照和阴影。
- en: Lighting and shadowing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照和阴影
- en: In modern games, a single object rarely finishes rendering completely in a single
    step, primarily due to lighting and shadowing. These tasks are often handled in
    multiple *passes* of a fragment shader, once for each of the several light sources,
    and the final result is combined so that multiple lights are given a chance to
    be applied. The result appears much more realistic, or, at least, more visually
    appealing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代游戏中，单个对象很少在单个步骤中完全完成渲染，这主要是由于光照和阴影。这些任务通常在多个片段着色器的多个“遍”中处理，每个遍对应于几个光源之一，最终结果被组合起来，以便多个光源都有机会被应用。结果看起来更加逼真，或者至少更具有视觉吸引力。
- en: 'Several passes are required to gather shadowing information. So, let''s begin:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多次遍历来收集阴影信息。因此，让我们开始：
- en: We will first set up our scene to have shadow casters and shadow receivers,
    which will create or receive shadows, respectively.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先设置场景，使其包含产生阴影的对象和接收阴影的对象，分别负责产生和接收阴影。
- en: Then, each time a shadow receiver is rendered, the GPU renders any shadow caster
    objects from the point of view of the light source into a texture to collect distance
    information for each of their fragments.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每次渲染阴影接收者时，GPU都会从光源的视角渲染任何阴影产生者对象到一个纹理中，以收集每个片段的距离信息。
- en: It then does the same for the shadow receiver, except now that it knows which
    fragments the shadow casters would overlap from the light source, it can render
    those fragments darker since they will be in the shadow created by the light source
    bearing down on the shadow caster.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会对阴影接收者执行相同的操作，但现在它知道阴影产生者会从光源重叠哪些片段，因此它可以渲染这些片段为较暗，因为它们将位于光源施加在阴影产生者上产生的阴影中。
- en: This information then becomes an additional texture known as a **shadow map** and
    is blended with the surface for the Shadow Receiver when it is rendered from the
    point of view of the main camera. This will make its surface appear darker in
    certain spots where other objects stand between the light source and the given
    object.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此信息随后成为被称为**阴影贴图**的附加纹理，并在从主摄像机的视角渲染时与阴影接收者的表面混合。这会使其表面在某些位置看起来更暗，因为这些位置有其他物体位于光源和指定物体之间。
- en: A similar process is used to create lightmaps, which are pre-generated lighting
    information for the more static parts of our scene.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建光照贴图的过程与此类似，光照贴图是为场景中更静态的部分预先生成的光照信息。
- en: Lighting and shadowing tend to consume a lot of resources throughout all parts
    of the Rendering Pipeline. We need each vertex to provide a normal direction (a
    vector pointing away from the surface) to determine how lighting should reflect
    off that surface, and we might need additional vertex color attributes to apply
    some extra coloring. This gives the CPU and frontend more information to pass
    along. Since multiple passes of fragment shaders are required to complete the
    final rendering, the backend is kept busy, both in terms of Fill Rate (lots and
    lots of pixels to draw, redraw, and merge) and in terms of memory bandwidth (extra
    textures to pull in or out for lightmaps and shadow maps). This is why real-time
    shadows are exceptionally expensive compared to most other rendering features
    and will inflate draw call counts dramatically when enabled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 光照和阴影在整个渲染管线中往往消耗大量资源。我们需要每个顶点提供一个法线方向（一个指向表面的向量）以确定光照应该如何从该表面反射，并且我们可能还需要额外的顶点颜色属性来应用一些额外的着色。这为CPU和前端提供了更多信息以传递。由于需要多次遍历片段着色器才能完成最终的渲染，后端在填充率（需要绘制、重绘和合并的大量像素）和内存带宽（为光照贴图和阴影贴图拉入或拉出的额外纹理）方面都保持忙碌。这就是为什么实时阴影与其他大多数渲染功能相比异常昂贵，并且当启用时，会大幅增加绘制调用次数。
- en: However, lighting and shadowing are perhaps two of the most important parts
    of game art and design to get right, often making the extra performance requirements
    worth the cost. Good lighting and shadowing can turn a mundane scene into something
    spectacular, as there is something magical about professional coloring that makes
    it visually appealing. Even a low-poly art style (for example, the mobile game,
    *Monument Valley*) relies heavily on a good lighting and shadowing profile to
    allow the player to distinguish one object from another and create a visually
    pleasing scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，光照和阴影可能是游戏艺术和设计中最重要的两个部分，需要正确处理，通常使得额外的性能要求值得成本。良好的光照和阴影可以将一个平凡的场景转变为壮观的事物，因为专业的着色有一种神奇的魅力，使其视觉上吸引人。即使是低多边形艺术风格（例如，移动游戏《纪念碑谷*》）也严重依赖于良好的光照和阴影配置文件，以便玩家能够区分不同的对象并创建一个视觉上令人愉悦的场景。
- en: Unity offers multiple features that affect lighting and shadows, from real-time
    lighting and shadows (of which there are multiple types of each) to static lighting
    called **lightmapping**. There are a lot of options to explore and, of course,
    a lot of things that can cause performance issues if we're not careful.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了多个影响光照和阴影的功能，从实时光照和阴影（每种类型都有多种）到静态光照，称为**光照贴图**。有很多选项可以探索，当然，如果不小心，会有很多可能导致性能问题。
- en: 'The Unity documentation covers all of the various lighting features in an excellent
    amount of detail. Start with the following pages and work through them. Doing
    so will be well worth the time since these systems affect the entire Rendering
    Pipeline. Refer to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Unity文档详细介绍了所有各种光照功能。从以下页面开始，并逐步学习。这样做将非常值得花费时间，因为这些系统影响整个渲染管线。参考以下内容：
- en: '[https://docs.unity3d.com/Manual/LightingOverview.html](https://docs.unity3d.com/Manual/LightingOverview.html)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D文档：光照概述](https://docs.unity3d.com/Manual/LightingOverview.html)'
- en: '[https://learn.unity.com/tutorial/introduction-to-lighting-and-rendering](https://learn.unity.com/tutorial/introduction-to-lighting-and-rendering)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity学习教程：光照和渲染简介](https://learn.unity.com/tutorial/introduction-to-lighting-and-rendering)'
- en: There are two different rendering formats, which can greatly affect our lighting
    performance, known as **Forward Rendering** and **Deferred Rendering**. The setting
    for these Rendering options can be found under Edit | Project Settings | Player
    | Other Settings | Rendering and configured on a per-platform basis.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的渲染格式，它们可以极大地影响我们的光照性能，称为**前向渲染**和**延迟渲染**。这些渲染选项的设置可以在“编辑 | 项目设置 | 玩家
    | 其他设置 | 渲染”下找到，并且可以在每个平台上进行配置。
- en: Forward Rendering
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向渲染
- en: Forward Rendering is the traditional form of rendering lights in our scene,
    as explored previously. During Forward Rendering, each object will be rendered
    in multiple passes through the same shader. How many passes are required will
    be based on the number, distance, and brightness of light sources. Unity will
    try to prioritize the `DirectionalLight` component that is affecting the object
    the most and render the object in a *base* pass as a starting point. It will then
    take several of the most powerful `PointLight` components nearby and re-render
    the same object multiple times through the same fragment shader. Each of these
    light points will be processed on a per-vertex basis, and all remaining lights
    will be condensed into an *average* color using a technique called spherical harmonics.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前向渲染是我们场景中渲染灯光的传统形式，如前所述。在前向渲染过程中，每个对象将通过相同的着色器进行多次渲染。所需的遍历次数将基于光源的数量、距离和亮度。Unity将尝试优先渲染对对象影响最大的`DirectionalLight`组件，并以一个*基础*遍历作为起点渲染对象。然后，它将取附近的一些最强大的`PointLight`组件，并通过相同的片段着色器多次重新渲染同一个对象。每个光源点将基于顶点进行处理，所有剩余的光源将使用称为球谐函数的技术合并成一个*平均*颜色。
- en: Some of this behavior can be simplified by setting a light's Render Mode to
    values such as Not Important and changing the value of Edit | Project Settings
    | Quality | Pixel Light Count. This value limits the number of lights that will
    be gathered for Forward Rendering but is overridden by any lights with a Render
    Mode set to Important. It is, therefore, up to us to use this combination of settings
    responsibly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将灯光的渲染模式设置为例如“不重要”等值，并更改“编辑 | 项目设置 | 质量 | 像素光照数量”的值，可以简化这种行为。此值限制了用于前向渲染的光照数量，但任何设置为“重要”渲染模式的光照将覆盖此限制。因此，我们必须负责任地使用这些设置的组合。
- en: As we might imagine, using Forward Rendering can utterly explode our draw call
    count very quickly in scenes with a lot of light points present due to the number
    of Render States being configured and shader passes required.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们可能想象的那样，在存在大量光源的场景中使用前向渲染可能会迅速增加我们的绘制调用次数，这是由于配置的渲染状态和所需的着色器遍历数量。
- en: More information on Forward Rendering can be found in the Unity documentation
    at [http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html](http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前向渲染的更多信息可以在Unity文档中找到，链接为[http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html](http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html)。
- en: Deferred Shading
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟着色
- en: Deferred Rendering, or Deferred Shading as it is sometimes known, is a technique
    that has been available on GPUs for about a decade or so, but it has not resulted
    in a complete replacement of the Forward Rendering method due to the caveats involved
    and somewhat limited support on mobile devices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '延迟渲染，或称为延迟着色（Deferred Shading），是一种大约十年前就在GPU上可用的技术，但由于涉及的限制和移动设备上支持有限，它并没有完全取代前向渲染方法。 '
- en: Deferred Shading is named as such because actual shading does not occur until
    much later in the process, that is, it is deferred until later. It works by creating
    a geometry buffer (called a *G-Buffer*), where our scene is initially rendered
    without any lighting applied. With this information, the Deferred Shading system
    can generate a lighting profile within a single pass.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟着色（Deferred Shading）之所以被称为“延迟着色”，是因为实际的着色过程直到处理过程的后期才会发生，也就是说，它被延迟到后期。它通过创建一个几何缓冲区（称为*G-Buffer*），在没有任何光照应用的情况下首先渲染场景。有了这些信息，延迟着色系统可以在单次遍历中生成一个光照配置文件。
- en: From a performance perspective, the results are quite impressive as it can generate
    very good per-pixel lighting with little draw call effort. One disadvantage is
    that effects such as anti-aliasing, transparency, and applying shadows to animated
    characters cannot be managed through Deferred Shading alone. In this case, the
    Forward Rendering technique is applied as a fallback to cover those tasks, hence
    requiring extra draw calls to complete it. A bigger issue with Deferred Shading
    is that it often requires more powerful and more expensive hardware and is not
    available for all platforms, so fewer users will be able to make use of it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，结果相当令人印象深刻，因为它可以在很少的绘制调用努力下生成非常好的每像素光照。一个缺点是，如抗锯齿、透明度和将阴影应用于动画角色等效果不能仅通过延迟着色来管理。在这种情况下，将前向渲染技术作为后备方案应用，以覆盖这些任务，因此需要额外的绘制调用来完成。延迟着色的一个更大问题是，它通常需要更强大、更昂贵的硬件，并且并非所有平台都可用，因此较少的用户能够使用它。
- en: The Unity documentation contains an excellent source of information on the Deferred
    Shading technique, along with its benefits and pitfalls, which can be found at [http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html](http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 文档包含了关于延迟着色技术及其优点和缺点的优秀信息来源，这些信息可以在[http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html](http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html)找到。
- en: Vertex-Lit shading (legacy)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点光照着色（遗留）
- en: Technically, there are more than two lighting methods. The remaining two are
    Vertex-Lit shading and a very primitive, feature-lax version of Deferred Rendering
    (in the Unity documentation, this is called the Legacy Deferred lighting Rendering
    Path). Vertex-Lit shading is a massive simplification of lighting, as lighting
    will only be considered per-vertex and not per-pixel. In other words, entire faces
    are colored the same based on the incoming light color rather than blending lighting
    colors across the face through individual pixels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，除了两种光照方法之外，还有其他两种。剩下的两种是顶点光照着色和非常原始、功能宽松的延迟渲染版本（在 Unity 文档中，这被称为遗留延迟光照渲染路径）。顶点光照着色是对光照的极大简化，因为光照只考虑每个顶点而不是每个像素。换句话说，整个面基于入射光颜色进行着色，而不是通过单个像素混合光照颜色。
- en: It is not expected that many, or really any, 3D games will make use of this
    legacy technique, since a lack of shadows and proper lighting make visualizations
    of depth very difficult. It is mostly used by simple 2D games that don't need
    to make use of shadows, normal maps, and various other lighting features.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并不期望许多，或者实际上任何，3D 游戏会使用这种遗留技术，因为缺乏阴影和适当的光照使得深度可视化非常困难。它主要被简单的 2D 游戏使用，这些游戏不需要使用阴影、法线贴图以及各种其他光照功能。
- en: Global Illumination
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局照明
- en: Global Illumination (**GI**) is an implementation of baked lightmapping. Lightmapping
    is similar to the shadow maps created by shadowing techniques in that one or more
    textures are generated for each object that represents extra lighting information
    and is later applied to the object during its lighting pass of a fragment shader
    to simulate static lighting effects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 全局照明（**GI**）是烘焙光照贴图的一种实现。光照贴图与阴影技术创建的阴影贴图类似，为每个代表额外光照信息的对象生成一个或多个纹理，这些纹理随后在片段着色器的光照过程中应用于对象，以模拟静态光照效果。
- en: The main difference between these lightmaps and other forms of lighting is that
    lightmaps are pre-generated (or baked) in the Editor and packaged into the game
    build. This ensures that we don't need to keep regenerating this information at
    runtime, saving numerous draw calls and significant GPU activity. Since we can
    bake this data, we have the luxury of time to generate very high-quality lightmaps
    (at the expense of larger generated texture files we need to work with, of course).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些光照贴图与其他形式的光照之间的主要区别在于，光照贴图是在编辑器中预先生成（或烘焙）并打包到游戏构建中的。这确保了我们不需要在运行时不断重新生成这些信息，从而节省了大量的绘制调用和显著的
    GPU 活动。由于我们可以烘焙这些数据，我们有时间生成非常高质量的光照贴图（当然，这要以我们需要处理的更大的生成纹理文件为代价）。
- en: Since this information is baked ahead of time, it cannot respond to real-time
    activity during gameplay, and so, by default, any lightmapping information will
    only be applied to static objects that were present in the scene when the lightmap
    was generated and at the exact location they were placed. However, light probes
    can be added to the scene to generate an additional set of lightmap textures that
    can be applied to nearby dynamic objects that move, allowing such objects to benefit
    from pre-generated lighting. This won't have pixel-perfect accuracy and will cost
    disk space for the extra light probe maps and memory bandwidth at runtime to swap
    them around, but it does generate a more believable and pleasant lighting profile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些信息是在游戏开始前烘焙的，它们不能在游戏过程中对实时活动做出反应，因此，默认情况下，任何光照贴图信息都只会应用于在光照贴图生成时场景中存在的静态对象，以及它们放置的确切位置。然而，可以向场景中添加光照探针以生成一组额外的光照贴图纹理，这些纹理可以应用于附近移动的动态对象，使这些对象能够从预先生成光照中受益。这不会达到像素级的精度，并且会消耗额外的光照探针地图的磁盘空间，以及在运行时交换这些地图所需的内存带宽，但它确实生成了一个更可信且令人愉悦的光照配置文件。
- en: There have been several techniques for generating lightmaps developed throughout
    the years, and Unity has used a couple of different solutions since its initial
    release. Global Illumination is simply the latest generation of the mathematical
    techniques behind lightmapping, which offers very realistic coloring by calculating
    not only how lighting affects a given object, but also how light reflects off
    nearby surfaces, allowing an object to affect the lighting profile of those around
    it. This effect is calculated by an internal system called **enlighten**. This
    tool is used both to create static lightmaps, as well as create something called
    **Precomputed Realtime GI**, which is a hybrid of real-time and static shading and
    allows us to simulate effects such as time-of-day (where the direction of light
    from the sun changes over time) without relying on expensive real-time lighting
    effects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，已经开发出几种生成光照贴图的技术，Unity 自从最初发布以来已经使用了几种不同的解决方案。全局照明仅仅是光照贴图背后数学技术的最新一代，它通过计算不仅影响给定对象的光照，还影响光线如何从附近的表面反射，从而提供非常逼真的着色效果。这种效果是通过一个名为
    **enlighten** 的内部系统计算的。这个工具既用于创建静态光照贴图，也用于创建称为 **预计算实时全局照明** 的东西，它是实时和静态着色的混合，允许我们模拟诸如
    **一天中的时间**（随着时间的推移，太阳光的方向发生变化）等效果，而不依赖于昂贵的实时光照效果。
- en: A typical issue with generating lightmaps is the length of time it can take
    to generate them and get visual feedback on the current settings because the lightmapper
    is often trying to generate full-detail lightmaps in a single pass. If the user
    attempts to modify its configuration, then the entire job must be canceled and
    started over. To solve this problem, Unity Technologies implemented Progressive
    Lightmapper, which performs lightmapping tasks more gradually over time, but also
    allows them to be modified while they are being calculated. This makes lightmaps
    of the scene appear to get progressively more detailed as it works in the background
    while also allowing us to change certain properties when it is still working and
    without having to restart the entire job. This provides almost immediate feedback
    and improves the workflow of generating lightmaps immensely.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 生成光照贴图时常见的典型问题是生成它们所需的时间长度以及获取当前设置视觉反馈的时间，因为光照映射器通常试图在一次遍历中生成全细节光照贴图。如果用户尝试修改其配置，则整个工作必须取消并重新开始。为了解决这个问题，Unity
    Technologies 实现了渐进式光照映射器，它在一段时间内更渐进地执行光照映射任务，同时允许在计算过程中对其进行修改。这使得场景中的光照贴图看起来在后台工作时会逐渐变得更加详细，同时允许我们在它仍在工作时更改某些属性，而无需重新启动整个工作。这提供了几乎即时的反馈，并极大地改善了生成光照贴图的流程。
- en: Multithreaded Rendering
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程渲染
- en: Multithreaded Rendering is enabled by default on most systems, such as desktop
    and console platforms whose CPUs provide multiple cores. Other platforms still
    support many low-end devices to enable this feature by default, so it is a toggleable
    option for them. For Android, it can be enabled via a checkbox under Edit | Project
    Settings | Player | Other Settings | Multithreaded Rendering, whereas, for iOS,
    Multithreaded Rendering can be enabled by configuring the application to make
    use of Apple's Metal API under Edit | Project Settings | Player| Other Settings
    | Graphics API. At the time of writing this book, WebGL does not support Multithreaded
    Rendering.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程渲染在大多数系统上默认启用，例如提供多个核心的桌面和游戏机平台。其他平台仍然支持许多低端设备，默认启用此功能，因此它们是一个可切换的选项。对于 Android，可以通过在“编辑
    | 项目设置 | 播放器 | 其他设置 | 多线程渲染”下的复选框中启用，而对于 iOS，可以通过在“编辑 | 项目设置 | 播放器 | 其他设置 | 图形
    API”下配置应用程序以使用 Apple 的 Metal API 来启用多线程渲染。在撰写本书时，WebGL 不支持多线程渲染。
- en: 'For each object in our scene, there are three tasks to complete: determine
    whether the object needs to be rendered (through a technique known as **Frustum
    Culling**), and if so, generate commands to render the object (since rendering
    a single object can result in dozens of different commands), and then send the
    command to the GPU using the relevant graphics API. Without Multithreaded Rendering,
    all of these tasks must happen on the main thread of the CPU; hence, any activity
    on the main thread becomes part of the critical path for all rendering. When Multithreaded
    Rendering is enabled, the task of pushing commands into the GPU is handled by
    a render thread, whereas other tasks, such as culling and generating commands,
    get spread across multiple worker threads. This setup can save an enormous number
    of CPU cycles for the main thread, which is where the overwhelming majority of
    other CPU tasks take place, such as physics and script code.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于场景中的每个对象，我们需要完成三个任务：确定对象是否需要渲染（通过一种称为**视锥剔除**的技术），如果是的话，生成渲染对象的命令（因为渲染单个对象可能会产生数十个不同的命令），然后使用相关的图形API将命令发送到GPU。在没有多线程渲染的情况下，所有这些任务都必须在CPU的主线程上执行；因此，主线程上的任何活动都成为所有渲染的关键路径。当启用多线程渲染时，将命令推送到GPU的任务由渲染线程处理，而其他任务，如剔除和生成命令，则分散到多个工作线程。这种设置可以为CPU的主线程节省大量的CPU周期，而主线程是大多数其他CPU任务发生的地方，例如物理和脚本代码。
- en: Enabling this feature will affect what it means to be CPU bound. Without Multithreaded
    Rendering, the main thread is performing all of the work necessary to generate
    instructions for the command buffer, meaning that any performance we can save
    elsewhere will free up more time for the CPU to generate commands. However, when
    Multithreaded Rendering is taking place, a good portion of the workload is pushed
    onto separate threads, meaning that improvements to the main thread will have
    less of an impact on rendering performance via the CPU.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能将影响CPU绑定的含义。在没有多线程渲染的情况下，主线程正在执行生成命令缓冲区指令所需的所有工作，这意味着我们可以在其他地方节省的任何性能都将为CPU生成命令腾出更多时间。然而，当进行多线程渲染时，大量工作量被推送到单独的线程，这意味着对主线程的改进对通过CPU的渲染性能的影响将较小。
- en: Note that being GPU bound is the same regardless of whether Multithreaded Rendering
    is taking place. The GPU always performs its tasks in a multithreaded fashion.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论是否进行多线程渲染，GPU绑定都是相同的。GPU始终以多线程的方式执行其任务。
- en: Low-level rendering APIs
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级渲染API
- en: Unity exposes a rendering API to us through their `CommandBuffer` class. This
    allows us to control the Rendering Pipeline directly through our C# code by issuing
    high-level rendering commands, such as `render this object`, `with this Material`,
    `using this Shader`, or `draw N instances of this piece of procedural geometry`.
    This customization is not as powerful as having direct graphics API access, but
    it is a step in the right direction for Unity developers to customize unique graphical
    effects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Unity通过他们的`CommandBuffer`类向我们公开了渲染API。这允许我们通过发出高级渲染命令，如`渲染此对象`、`使用此材质`、`使用此着色器`或`绘制此程序几何体的N个实例`，直接通过我们的C#代码控制渲染管线。这种定制功能不如直接访问图形API强大，但对于Unity开发者来说，这是朝着定制独特图形效果的正确方向迈出的一步。
- en: Check out the Unity documentation on `CommandBuffer` to make use of this feature
    at [http://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html](http://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Unity文档中的`CommandBuffer`，以使用此功能，请访问[http://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html](http://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html)。
- en: If an even more direct level of rendering control is needed, such as we wish
    to make direct graphics API calls to OpenGL, DirectX, and Metal, then be aware
    that it is possible to create a native plugin (a small library written in C++
    code that is compiled specifically for the architecture of the target platform)
    that hooks into the Unity's Rendering Pipeline, setting up callbacks for when
    particular rendering events happen, similar to how `MonoBehaviours` hook into
    various callbacks of the main Unity Engine. This is certainly an advanced topic
    for most Unity users, but useful to know for the future as our knowledge of rendering
    techniques and graphics APIs matures.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更直接的渲染控制级别，例如我们希望直接调用 OpenGL、DirectX 和 Metal 的图形 API，那么请注意，可以创建一个本地插件（一个用
    C++ 编写的库，专门为目标的平台架构编译），该插件可以挂钩到 Unity 的渲染管线，为特定的渲染事件设置回调，类似于 `MonoBehaviours`
    如何挂钩到主 Unity 引擎的各种回调。这绝对是一个对大多数 Unity 用户来说的高级话题，但对于我们渲染技术和图形 API 知识的成熟来说是有用的。
- en: Unity provides some good documentation on generating a rendering interface in
    a native plugin at [https://docs.unity3d.com/Manual/NativePluginInterface.html](https://docs.unity3d.com/Manual/NativePluginInterface.html).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 在[https://docs.unity3d.com/Manual/NativePluginInterface.html](https://docs.unity3d.com/Manual/NativePluginInterface.html)提供了关于在本地插件中生成渲染界面的良好文档。
- en: It should be obvious that, due to the number of complex processes involved,
    there are a lot of different ways in which the GPU can become bottlenecked. Now
    that we have a thorough understanding of the Rendering Pipeline and how bottlenecks
    may occur, let's explore how to detect these problems.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，由于涉及到的复杂过程数量众多，GPU 可能以多种不同的方式成为瓶颈。现在我们已经彻底了解了渲染管线和瓶颈可能发生的方式，让我们来探讨如何检测这些问题。
- en: Detecting performance issues
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测性能问题
- en: When you start looking at issues in your game, lighting is often neglected.
    That's a novice mistake. In the following sections, we will see how to detect
    and solve lighting-related performance issues.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始查看游戏中的问题时，照明往往被忽视。这是一个新手错误。在接下来的几节中，我们将看到如何检测和解决与照明相关的性能问题。
- en: Profiling rendering issues
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析渲染问题
- en: The Profiler can be used to quickly narrow down which of the two devices used
    in the Rendering Pipeline we are bottlenecked within—whether it is the CPU or
    GPU. We must examine the problem using both the CPU Usage and GPU Usage Areas
    of the Profiler window, as this can tell us which device is working the hardest.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器可以用来快速缩小在渲染管线中使用的那两个设备中哪一个是我们瓶颈所在——是 CPU 还是 GPU。我们必须使用分析器窗口的 CPU 使用率和 GPU
    使用率区域来检查问题，因为这可以告诉我们哪个设备工作最努力。
- en: 'The following screenshot shows Profiler data for a CPU-bound application. The
    test involved creating thousands of simple cube objects, with no batching or shadowing
    techniques taking place. This resulted in an extremely large draw call count (around
    32,000) for the CPU to generate commands for, but giving the GPU relatively little
    work to do due to the simplicity of the objects being rendered:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了针对 CPU 密集型应用程序的分析器数据。测试涉及创建成千上万的简单立方体对象，没有批处理或阴影技术。这导致 CPU 需要生成命令的绘制调用次数非常大（大约
    32,000 次），但由于渲染的对象非常简单，GPU 的工作量相对较少：
- en: '![](img/2be38ead-357c-45eb-aa7c-4e8597909433.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2be38ead-357c-45eb-aa7c-4e8597909433.png)'
- en: This example shows that the CPU's Rendering task is consuming a large number
    of cycles (around 25 ms per frame), whereas the GPU is processing for less than
    4 milliseconds, indicating that the bottleneck resides in the CPU. Note that this
    profiling test was performed against a standalone app, not within the Editor.
    We now know that our rendering is CPU bound and can begin to apply some CPU-saving
    performance improvements (being careful not to introduce rendering bottlenecks
    elsewhere by doing so).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本例表明，CPU 的渲染任务消耗了大量的周期（每帧约 25 毫秒），而 GPU 的处理时间不到 4 毫秒，这表明瓶颈位于 CPU。请注意，这个分析测试是在独立应用程序上进行的，而不是在编辑器内。我们现在知道我们的渲染是
    CPU 密集型的，可以开始应用一些节省 CPU 的性能改进（注意不要通过这种方式在其他地方引入渲染瓶颈）。
- en: Meanwhile, profiling a GPU-bound application via the Profiler is a little trickier.
    This time, the test involves creating a simple object requiring minimal draw calls,
    but using a very expensive shader that samples a texture thousands of times to
    create an absurd amount of activity in the backend.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，通过Profiler对GPU瓶颈应用进行性能分析要复杂一些。这次测试涉及创建一个需要最少绘制调用的简单对象，但使用一个非常昂贵的着色器，该着色器对纹理进行数千次采样，在后台创建大量活动。
- en: To perform fair GPU-bound profiling tests, you should ensure that you disable
    vertical sync through Edit | Project Settings | Quality | Other | V Sync Count;
    otherwise, it is likely to pollute our data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行公平的GPU瓶颈性能分析测试，你应该确保通过“编辑 | 项目设置 | 质量 | 其他 | V同步计数”禁用垂直同步；否则，很可能会污染我们的数据。
- en: 'The following screenshot shows Profiler data for this test when it is run in
    a standalone application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在独立应用程序中运行此测试时的Profiler数据：
- en: '![](img/916fe7ca-a952-4f7c-81c2-ab787fc36be4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/916fe7ca-a952-4f7c-81c2-ab787fc36be4.png)'
- en: As we can see in the preceding screenshot, the rendering task of the CPU Usage
    Area matches closely with the total rendering costs of the GPU Usage Area. We
    can also see that the CPU and GPU time costs at the bottom of the image are relatively
    similar (about 29 milliseconds each). This is somewhat confusing as we seem to
    be bottlenecked equally in both devices, where we would expect the GPU to be working
    much harder than the CPU.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，CPU使用区域的渲染任务与GPU使用区域的总渲染成本非常接近。我们还可以看到，图像底部的CPU和GPU时间成本相对相似（大约各29毫秒）。这有些令人困惑，因为我们似乎在这两个设备上都有瓶颈，而我们预期GPU的工作量应该远大于CPU。
- en: In actuality, if we drill down into the Breakdown View of the CPU Usage Area
    using the Hierarchy Mode, we will note that most of the CPU time is spent on the
    task labeled Gfx.WaitForPresent. This is the amount of time that the CPU is wasting
    while it waits for the GPU to finish the current frame. Hence, we are, in fact,
    bottlenecked by the GPU despite appearing as though we are bound by both. Even
    if Multithreaded Rendering is enabled, the CPU must still wait for the Rendering
    Pipeline to finish before it can begin the next frame.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们使用分层模式深入到CPU使用区域的分析视图，我们会注意到大部分CPU时间都花在了标记为Gfx.WaitForPresent的任务上。这是CPU在等待GPU完成当前帧时浪费的时间。因此，尽管看起来我们似乎同时受到CPU和GPU的限制，但实际上我们是受GPU瓶颈所限。即使启用了多线程渲染，CPU也必须等待渲染管线完成才能开始下一帧。
- en: Gfx.WaitForPresent is also used to signal that the CPU is waiting on Vertical
    Sync to complete, hence the need to disable it for this test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Gfx.WaitForPresent也用于表示CPU正在等待垂直同步完成，因此需要禁用它进行此测试。
- en: Brute force testing
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制测试
- en: If we're poring over our profiling data and still not sure where the source
    of the problem resides, or we're GPU bound and need to determine where we're bottlenecked
    in the Rendering Pipeline, we should try the brute-force method, that is, cull
    a specific activity from the scene and check whether it results in greatly improved
    performance. If a small change results in a significant speed improvement, then
    we have a strong clue about where the bottleneck lies. There's no harm in this
    approach if we eliminate enough unknown variables to ensure that the data is leading
    us in the right direction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在仔细查看性能分析数据，但仍不确定问题的根源在哪里，或者我们遇到GPU瓶颈并需要确定在渲染管线中的瓶颈位置，我们应该尝试强制测试方法，即从场景中删除特定的活动并检查它是否会导致性能显著提升。如果小的改动能带来显著的速度提升，那么我们就有了关于瓶颈位置的强烈线索。如果我们消除了足够的未知变量以确保数据引导我们走向正确的方向，那么这种方法并没有什么害处。
- en: The obvious brute-force test for CPU bounding will be to reduce draw calls to
    check whether performance suddenly improves. However, this is often not possible
    since, presumably, we've already been reducing our draw calls to a minimum through
    techniques such as static batching, dynamic batching, and atlasing. This would
    mean that we have a very limited scope for reducing them further.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CPU瓶颈的明显强制测试将是减少绘制调用以检查性能是否突然提升。然而，这通常是不可能的，因为我们可能已经通过静态批处理、动态批处理和纹理图集等技术将绘制调用减少到最小。这意味着我们进一步减少它们的范围非常有限。
- en: What we can do, however, is intentionally increase our draw call count by a
    small number, either by introducing more objects or disabling draw call-saving
    features, such as static and dynamic batching, and observe whether the situation
    gets significantly worse than before. If so, then we have evidence that we're
    either very close to being CPU bound or have already become so.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以故意增加绘制调用次数的小幅度，要么通过引入更多对象，要么禁用节省绘制调用的功能，如静态和动态批处理，并观察情况是否比之前显著恶化。如果是这样，那么我们有证据表明我们可能非常接近CPU限制，或者已经达到这种状态。
- en: 'There are two good brute-force tests we can apply to a GPU-bound application
    to determine whether we''re bound by Fill Rate or by memory bandwidth: reducing
    screen resolution or reducing texture resolution, respectively.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于受GPU限制的应用程序，我们可以应用两种有效的暴力测试来确定我们是否受限于填充率或内存带宽：分别降低屏幕分辨率或降低纹理分辨率。
- en: By reducing screen resolution, we will ask the rasterizer to generate significantly
    fewer fragments and transpose them over a smaller canvas of pixels for the backend
    to process. This will reduce the Fill Rate consumption of the application, giving
    this key part of the Rendering Pipeline some additional breathing room. Ergo,
    if performance suddenly improves with a screen resolution reduction, then Fill
    Rate should be our primary concern.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过降低屏幕分辨率，我们将要求光栅化器生成显著更少的片段，并将它们传输到更小的像素画布上供后端处理。这将减少应用程序的填充率消耗，为渲染管线这个关键部分提供额外的空间。因此，如果性能随着屏幕分辨率的降低而突然提升，那么填充率应该是我们首要关注的问题。
- en: A reduction from a resolution of 2560 x 1440 to 800 x 600 is an improvement
    factor of about eight, which is often more than enough to reduce Fill Rate costs
    sufficiently to make the application perform well again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将分辨率从2560 x 1440降低到800 x 600，改善因子约为八倍，这通常足以足够减少填充率成本，使应用程序再次表现良好。
- en: Similarly, if we're bottlenecked on memory bandwidth, then reducing texture
    quality is likely to result in significant performance improvement. By doing so,
    we have shrunk the size of our textures, greatly reducing the memory bandwidth
    costs of our fragment shaders, allowing the GPU to fetch the necessary textures
    much more quickly. Globally reducing texture quality can be achieved by going
    to Edit | Project Settings | Quality | Texture Quality and setting the value to Half
    Res, Quarter Res, or Eighth Res.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们受限于内存带宽，那么降低纹理质量可能会带来显著的性能提升。通过这样做，我们缩小了纹理的大小，大大减少了片段着色器的内存带宽成本，使得GPU能够更快地获取必要的纹理。通过访问“编辑
    | 项目设置 | 质量 | 纹理质量”，并将值设置为“半分辨率”、“四分之一分辨率”或“八分之一分辨率”，可以全局降低纹理质量。
- en: An application bound by the CPU has ample opportunities for performance enhancements
    through practically every performance-enhancing tip in this book. If we free up
    CPU cycles from other activities, then we can afford to render more objects through
    more draw calls, keeping in mind, of course, that each will cost us more activity
    in the GPU. There are, however, additional opportunities to make some indirect
    improvements in draw call count while we try to improve other parts of the Rendering
    Pipeline. This includes Occlusion Culling, tweaking our lighting and shadowing
    behavior, and modifying our shaders. These will be explained in the following
    sections as we investigate various performance enhancements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 受CPU限制的应用程序，通过本书中几乎每一项性能提升技巧，都有充足的机会进行性能优化。如果我们从其他活动中释放CPU周期，那么我们可以通过更多的绘制调用渲染更多对象，当然，这也意味着每个对象都会让GPU承担更多的活动。然而，当我们试图改进渲染管线其他部分时，还有额外的机会在绘制调用次数上做一些间接的改进。这包括遮挡剔除、调整我们的光照和阴影行为，以及修改我们的着色器。这些内容将在以下章节中解释，当我们研究各种性能提升方法时。
- en: Meanwhile, we will probably need to apply a little brute-force testing and guesswork
    to determine how a GPU-bound application is bottlenecked. Most applications are
    bottlenecked by Fill Rate or memory bandwidth, so we should start there. It is
    rare to find performance bottlenecks in the frontend, at least on desktop applications,
    so it is worth checking only after we've verified that the other sources are not
    the problem. Vertex shaders are often trivial compared to fragment shaders, and
    so the only real opportunity to cause problems with frontend processing is either
    to push too much geometry or to have overly complex geometry shaders.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们可能需要应用一些暴力测试和猜测来确定一个GPU受限的应用程序瓶颈在哪里。大多数应用程序的瓶颈在于填充率或内存带宽，因此我们应该从这里开始。在桌面应用程序中，前端很少出现性能瓶颈，所以只有在确认其他来源不是问题之后才值得检查。与片段着色器相比，顶点着色器通常很简单，因此前端处理可能引起问题的唯一机会是推入过多的几何形状或者拥有过于复杂的几何着色器。
- en: Ultimately, this investigation should help us to determine whether we are CPU
    bound or GPU bound, and, in the latter case, whether we are bound by the frontend
    or backend, and again in the latter case, whether we are bound by Fill Rate or
    memory bandwidth. With this knowledge, there are several techniques we can apply
    to improve performance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这项调查应该帮助我们确定我们是CPU受限还是GPU受限，在后一种情况下，我们是在前端受限还是后端受限，再次在后一种情况下，我们是在填充率受限还是内存带宽受限。有了这些知识，我们可以应用几种技术来提高性能。
- en: Rendering performance enhancements
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染性能提升
- en: We should now have all of the information we need to make sense of performance
    bottlenecks so that we can start to apply fixes. For the remainder of this chapter,
    we will cover a series of techniques to improve Rendering Pipeline performance
    for CPU-bound and GPU-bound applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该拥有所有必要的信息来理解性能瓶颈，以便我们可以开始应用修复。在本章的剩余部分，我们将介绍一系列技术，以提高CPU受限和GPU受限应用程序的渲染管线性能。
- en: Enabling/disabling GPU skinning
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用/禁用GPU皮肤
- en: The first tip involves a setting that eases the burden on the CPU or GPU frontend
    at the expense of the other, that is, GPU Skinning. Skinning is the process where
    mesh vertices are transformed based on the current location of their animated
    bones. The animation system, working on the CPU, transforms the object's bones
    that are used to determine its current pose, but the next important step in the
    animation process is wrapping the mesh vertices around those bones to place the
    mesh in the final pose. This is achieved by iterating over each vertex and performing
    a weighted average against the bones connected to those vertices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条建议涉及一个设置，它以牺牲另一方的代价减轻CPU或GPU前端的工作负担，即GPU皮肤。皮肤是这样一个过程，即根据动画骨骼的当前位置转换网格顶点。动画系统在CPU上工作，转换用于确定对象当前姿态的骨骼，但动画过程中的下一个重要步骤是将网格顶点围绕这些骨骼包裹，以放置网格在最终姿态。这是通过遍历每个顶点并对其连接的骨骼执行加权平均来实现的。
- en: This vertex processing task can either take place on the CPU or within the frontend
    of the GPU, depending on whether the GPU Skinning option is enabled. This feature
    can be toggled under Edit | Project Settings | Player Settings | Other Settings
    | GPU Skinning. Enabling this option pushes skinning activity to the GPU, although
    bear in mind that the CPU must still transfer the data to the GPU and will generate
    instructions on the command buffer for the task, so it doesn't remove the CPU's
    workload entirely. Disabling this option eases the burden on the GPU by making
    the CPU resolve the mesh's pose before transferring mesh data across and simply
    asking the GPU to draw it as is. Obviously, this feature is useful if we have
    lots of animated meshes in our scenes and can be used to help either bounding
    case by pushing the work onto the least busy device.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶点处理任务可以发生在CPU上，也可以发生在GPU的前端，这取决于是否启用了GPU皮肤选项。此功能可以在“编辑 | 项目设置 | 玩家设置 | 其他设置
    | GPU皮肤”下切换。启用此选项将皮肤活动推送到GPU，但请注意，CPU仍然需要将数据传输到GPU，并为任务在命令缓冲区生成指令，因此它并没有完全消除CPU的工作量。禁用此选项通过在传输网格数据之前让CPU解决网格的姿态来减轻GPU的负担，并简单地要求GPU按原样绘制。显然，如果我们场景中有许多动画网格，这个功能很有用，并且可以帮助将工作推送到最不繁忙的设备。
- en: Reducing geometric complexity
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少几何复杂性
- en: This tip concerns the GPU frontend. We have already covered some techniques
    on mesh optimization in Chapter 4, *Optimizing Your Art Assets*, which can help
    to reduce our mesh's vertex attributes. As a quick reminder, it is not uncommon
    to use a mesh that contains a lot of unnecessary UV and normal vector data, so
    our meshes should be double-checked for this kind of superfluous fluff. We should
    also let Unity optimize the structure for us, which minimizes cache misses as
    vertex data is read within the frontend.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧关注的是 GPU 前端。我们已经在第 4 章“优化您的艺术资产”中介绍了一些网格优化技术，这些技术可以帮助减少我们的网格顶点属性。作为一个快速提醒，使用包含大量不必要的
    UV 和法线向量数据的网格并不罕见，因此我们应该检查我们的网格是否存在这种多余的冗余。我们还应该让 Unity 为我们优化结构，这可以最小化缓存未命中，因为顶点数据是在前端读取的。
- en: 'The goal is simply to reduce actual vertex counts. There are three solutions
    to this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目标仅仅是减少实际的顶点数。这里有三种解决方案：
- en: First, we can simplify the mesh by either having the art team manually tweak
    and generate meshes with lower polycounts or using a mesh decimation tool to do
    this for us.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以通过艺术团队手动调整并生成具有较低多边形计数的网格，或者使用网格简化工具来简化网格。
- en: Second, we could simply remove meshes from the scene, but this should be a last
    resort.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们可以简单地从场景中删除网格，但这应该是最后的手段。
- en: The third option is to implement automatic culling through features such as
    LOD, which will be explained later in this chapter.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种方案是通过实现自动剔除，例如使用 LOD 等功能，这些将在本章后面解释。
- en: Reducing tessellation
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少细分
- en: Tessellation through geometry shaders can be a lot of fun, as it is a relatively
    underused technique that can really make our graphical effects stand out from
    among the crowd of games that use only the most common effects. However, it can
    contribute enormously to the amount of processing work taking place in the frontend.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几何着色器进行细分可以非常有趣，因为它是一种相对较少使用的技巧，可以使我们的图形效果在仅使用最常见效果的众多游戏中脱颖而出。然而，它可能会极大地增加前端处理的工作量。
- en: There aren't really any simple tricks we can exploit to improve tessellation,
    besides improving our tessellation algorithms or easing the burden caused by other
    frontend tasks to give our tessellation tasks more room to breathe. Either way,
    if we have a bottleneck in the frontend and are making use of tessellation techniques,
    we should double-check that they are not consuming the lion's share of the frontend's
    budget.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改进我们的细分算法或减轻其他前端任务带来的负担，以便我们的细分任务有更多的空间呼吸之外，我们实际上没有可以利用的简单技巧来提高细分。无论如何，如果我们前端存在瓶颈并正在使用细分技术，我们应该检查它们是否没有消耗前端预算的大部分。
- en: Employing GPU instancing
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPU 实例化
- en: GPU Instancing is a means to render multiple copies of the same mesh quickly
    by exploiting the fact that they will have identical Render States, hence require
    minimal draw calls. This is practically identical to dynamic batching, except
    that it is not an automatic process. In fact, we can think of dynamic batching
    as a poor man's *GPU instancing* since GPU instancing can enable even better savings
    and allows for more customization by allowing parameterized variations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 实例化是一种通过利用它们将具有相同的渲染状态这一事实来快速渲染相同网格多个副本的方法，因此需要最少的绘制调用。这实际上与动态批处理非常相似，但不是自动过程。实际上，我们可以将动态批处理视为“穷人的
    GPU 实例化”，因为 GPU 实例化可以带来更好的节省，并允许通过允许参数化变化来实现更多定制。
- en: GPU Instancing is applied at the Material level with the Enable Instancing checkbox,
    and variations can be introduced by modifying shader code. This way, we can give
    different instances of different rotations, scales, colors, and so on. This is
    useful for rendering scenes such as forests and rocky areas where we want to render
    hundreds or thousands of different copies of a mesh with some slight variation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 实例化在材质级别通过勾选“启用实例化”复选框应用，可以通过修改着色器代码来引入变化。这样，我们可以为不同的实例提供不同的旋转、缩放、颜色等。这对于渲染森林和岩石区域等场景非常有用，在这些场景中，我们希望渲染数百或数千个略有变化的网格副本。
- en: Note that Skinned Mesh Renderers cannot be instanced for similar reasons that
    they cannot be dynamically batched, and not all platforms and APIs support GPU
    Instancing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于与它们不能动态批处理类似的原因，骨骼网格渲染器不能实例化，并且并非所有平台和 API 都支持 GPU 实例化。
- en: 'The following screenshot shows the benefits of GPU Instancing on a group of
    512 cube objects (with some extra lighting and shadowing applied to increase the
    total draw call count):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了GPU实例化在一组512个立方体对象（应用了一些额外的光照和阴影以增加总绘制调用次数）上的好处：
- en: '![](img/00c67826-051c-41b4-ab2e-9035543c2cd2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00c67826-051c-41b4-ab2e-9035543c2cd2.png)'
- en: This system is much more versatile than dynamic batching since we have more
    control over how objects are batched together. Of course, there are more opportunities
    for mistakes if we batch things in inefficient ways, so we should be careful to
    use them wisely.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态批处理相比，此系统具有更高的灵活性，因为我们能更好地控制对象是如何一起批处理的。当然，如果我们以低效的方式批处理事物，会有更多的错误机会，因此我们应该谨慎地明智使用它们。
- en: Check out the Unity documentation for more information on GPU Instancing at [https://docs.unity3d.com/Manual/GPUInstancing.html](https://docs.unity3d.com/Manual/GPUInstancing.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Unity文档以获取更多关于GPU实例化的信息，请访问[https://docs.unity3d.com/Manual/GPUInstancing.html](https://docs.unity3d.com/Manual/GPUInstancing.html)。
- en: Using mesh-based LOD
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于网格的LOD
- en: LOD is a broad term referring to the dynamic replacement of features based on
    their distance from the camera and/or how much space they take up in the camera's
    view. Since it can be difficult to tell the difference between a low- and high-quality
    object at great distances, there is very little reason to render the high-quality
    version, and so we may as well dynamically replace distant objects with something
    more simplified. The most common implementation of LOD is mesh-based LOD, where
    meshes are dynamically replaced with lower detailed versions as the camera gets
    farther and farther away.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: LOD是一个广泛的概念，指的是根据对象与摄像机的距离以及/或它们在摄像机视图中占据的空间大小动态替换特征。由于在远处很难区分低质量和高质量对象，因此几乎没有必要渲染高质量版本，所以我们不妨用更简化的东西动态替换远处的对象。LOD最常见实现是基于网格的LOD，其中网格随着摄像机越来越远而动态替换为更低的细节版本。
- en: Making use of mesh-based LOD can be achieved by placing multiple objects in
    the scene and making them children of `GameObject` with an attached `LODGroup` component.
    The LOD group's purpose is to generate a bounding box from these objects and decide
    which object should be rendered based on the size of the bounding box within the
    camera's field of view. If the object's bounding box consumes a large area of
    the current view, then it will enable the mesh(es) assigned to lower LOD groups,
    and if the bounding box is very small, it will replace the mesh(es) with those
    from higher LOD groups. If the mesh is too far away, it can be configured to hide
    all child objects. So, with the proper setup, we can have Unity replace meshes
    with simpler alternatives, or cull them entirely, which eases the burden on the
    rendering process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在场景中放置多个对象并将它们设置为具有附加`LODGroup`组件的`GameObject`的子对象，可以实现基于网格的LOD。LOD组的作用是从这些对象生成边界框，并根据边界框在摄像机视野中的大小决定渲染哪个对象。如果对象的边界框占据了当前视图的大部分区域，则它将启用分配给较低LOD组的网格（们），如果边界框非常小，则用来自较高LOD组的网格（们）替换网格（们）。如果网格太远，可以配置为隐藏所有子对象。因此，通过适当的设置，我们可以让Unity用更简单的替代品替换网格，或者完全剔除它们，从而减轻渲染过程的负担。
- en: Check out the Unity documentation for more detailed information on the mesh-based
    LOD feature at [http://docs.unity3d.com/Manual/LevelOfDetail.html](http://docs.unity3d.com/Manual/LevelOfDetail.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Unity文档以获取更多关于基于网格的LOD功能的详细信息，请访问[http://docs.unity3d.com/Manual/LevelOfDetail.html](http://docs.unity3d.com/Manual/LevelOfDetail.html)。
- en: This feature can cost us a large amount of development time to fully implement;
    artists must generate lower polygon count versions of the same object, and level
    designers must generate LOD groups, configure them, and test them to ensure that
    they don't cause jarring transitions as the camera moves closer or farther away.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完全实现此功能可能需要我们投入大量的开发时间；艺术家必须生成相同对象的低多边形版本，关卡设计师必须生成LOD组，配置它们，并测试它们以确保在摄像机靠近或远离时不会引起令人不快的过渡。
- en: Note that some game development middleware companies offer third-party tools
    for automated LOD mesh generation. These might be worth investigating to compare
    their ease of use versus quality loss versus cost-effectiveness.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些游戏开发中间件公司提供用于自动LOD网格生成的第三方工具。这些工具可能值得调查，以比较它们的使用便捷性、质量损失和成本效益。
- en: Mesh-based LOD will also cost us in disk footprint as well as RAM and CPU; the
    alternative meshes need to be bundled, loaded into RAM, and the `LODGroup` component
    must routinely test whether the camera has moved to a new position that warrants
    a change in LOD level. The benefits on the Rendering Pipeline are rather impressive,
    however. Dynamically rendering simpler meshes reduces the amount of vertex data
    we need to pass and potentially reduces the number of draw calls, Fill Rate, and
    memory bandwidth needed to render the object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网格的LOD也会在磁盘占用、RAM和CPU方面给我们带来成本；替代网格需要被打包、加载到RAM中，并且`LODGroup`组件必须定期检查相机是否移动到了需要改变LOD级别的新位置。然而，在渲染管线上的好处是非常令人印象深刻的。动态渲染更简单的网格可以减少我们需要传递的顶点数据量，并可能减少绘制调用次数、填充率和渲染对象所需的内存带宽。
- en: Due to the number of sacrifices needed for mesh-based LOD to function, developers
    should avoid preoptimizing by automatically assuming that mesh-based LOD will
    help them. Excessive use of the feature will lead to burdening other parts of
    our application's performance and chew up precious development time, all for the
    sake of paranoia. It should only be used if we start to observe problems in the
    Rendering Pipeline, and we've got CPU, RAM, and development time to spare.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于网格的LOD（细节层次）功能需要大量的牺牲，开发者应该避免通过自动假设基于网格的LOD会帮助他们来预先优化。过度使用该功能将导致应用程序性能的其他部分负担加重，消耗宝贵的发展时间，这一切都是为了不必要的担忧。只有在开始观察到渲染管线中的问题时，并且我们有足够的CPU、RAM和开发时间时，才应该使用它。
- en: Having said that, scenes that feature large, expansive views of the world and
    have lots of camera movement might want to consider implementing this technique
    very early, as the added distance and a massive number of visible objects will
    likely exacerbate the vertex count enormously. As a counterexample, scenes that
    are always indoors or feature a camera with a viewpoint looking down at the world
    will find little benefit in this technique since objects will tend to be at a
    similar distance from the camera at all times. Examples include **R****eal-Time
    Strategy** (**RTS**) and **Multiplayer Online Battle Arena** (**MOBA**) games.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，具有广阔世界视野和大量相机移动的场景可能需要尽早实施这项技术，因为增加的距离和大量可见对象可能会极大地增加顶点计数。作为反例，始终在室内或具有向下看世界的视点的相机场景将发现这项技术几乎没有好处，因为对象通常会始终以相似的距离从相机移动。例如包括**实时策略**（**RTS**）和**多人在线战斗竞技场**（**MOBA**）游戏。
- en: Culling groups
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮挡剔除组
- en: Culling groups are a part of the Unity API that effectively allows us to create
    our own custom LOD system as a means of coming up with our own ways of dynamically
    replacing certain gameplay or rendering behaviors. Some examples of things we
    might want to apply LOD to include replacing animated characters with a version
    with fewer bones, applying simpler shaders, skipping Particle System generation
    at great distances, and simplifying AI behavior.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡剔除组是Unity API的一部分，它有效地允许我们创建自己的自定义LOD系统，作为动态替换某些游戏或渲染行为的方式。我们可能想要应用LOD的一些例子包括用骨骼较少的版本替换动画角色、应用更简单的着色器、在远距离跳过粒子系统生成，以及简化AI行为。
- en: Since the culling group system at its most basic level simply tells us whether
    objects are visible to the camera and how big they are, it also has other uses
    in the realm of gameplay, such as determining whether certain enemy spawn points
    are currently visible to the player or whether a player is approaching certain
    areas. There is a wide range of possibilities available with the culling group
    system that makes it worth considering. Of course, the time spent to implement,
    test, and redesign scenes to exploit can be significant.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遮挡剔除组系统在最基本层面上只是告诉我们对象是否对相机可见以及它们有多大，它还在游戏领域有其他用途，例如确定某些敌人出生点是否当前对玩家可见，或者玩家是否正在接近某些区域。遮挡剔除组系统提供了广泛的可能性，使其值得考虑。当然，实现、测试和重新设计场景以利用这些功能所花费的时间可能是相当大的。
- en: Check out the Unity documentation for more information on culling groups at [https://docs.unity3d.com/Manual/CullingGroupAPI.html](https://docs.unity3d.com/Manual/CullingGroupAPI.html).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Unity文档以获取有关遮挡剔除组的更多信息，请访问[https://docs.unity3d.com/Manual/CullingGroupAPI.html](https://docs.unity3d.com/Manual/CullingGroupAPI.html)。
- en: Making use of Occlusion Culling
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用遮挡剔除
- en: One of the best ways to reduce both Fill Rate consumption and Overdraw is to
    make use of Unity's Occlusion Culling system. The system works by partitioning
    the world into a series of small cells and flying a virtual camera through the
    scene, making a note of which cells are invisible from other cells (are *occluded*)
    based on the size and position of the objects present.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 减少填充率消耗和过度绘制最有效的方法之一是利用Unity的遮挡剔除系统。该系统通过将世界划分为一系列小单元，并通过场景中的虚拟相机进行飞行，根据现有对象的大小和位置记录哪些单元对其他单元不可见（被遮挡）来工作。
- en: Note that this is different from the technique of Frustum Culling, which culls
    objects outside the current camera view. Frustum Culling is always active and
    automatic. Objects culled by this process are, therefore, automatically ignored
    by the Occlusion Culling system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与视锥剔除技术不同，视锥剔除技术剔除当前相机视图外的对象。视锥剔除始终处于激活和自动状态。因此，通过此过程剔除的对象将自动被遮挡剔除系统忽略。
- en: Occlusion Culling data can only be generated for objects properly labeled Occluder
    Static and/or Occludee Static under the StaticFlags drop-down menu. Occluder Static
    is the general setting for static objects we expect to be so large that they will
    both occlude and be occluded by other objects, such as skyscrapers or mountains,
    which can hide other objects behind them, as well as be hidden behind each other,
    and so on. Occludee Static is a special case for things, such as transparent objects
    that always require other objects behind them to be rendered, but they themselves
    need to be hidden if something large blocks their visibility.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡剔除数据只能为在“静态标志”下拉菜单下正确标记为“遮挡器静态”和/或“被遮挡静态”的对象生成。遮挡器静态是我们期望的静态对象的一般设置，这些对象可能非常大，以至于它们将同时遮挡其他对象并被其他对象遮挡，例如摩天大楼或山脉，这些可以隐藏它们后面的其他对象，以及相互之间隐藏，等等。被遮挡静态是某些事物的特殊情况，例如始终需要渲染其他对象背后的透明对象，但它们自己如果被大物体遮挡其可见性时需要被隐藏。
- en: Naturally, because Static flags must be enabled for Occlusion Culling, this
    feature will not work for dynamic objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，因为静态标志必须启用才能进行遮挡剔除，所以此功能对动态对象不起作用。
- en: The following screenshot shows how effective Occlusion Culling can be at reducing
    the number of rendered objects from our scene from an external point of view for
    the sake of demonstration. From the point of view of the main camera, the two
    situations appear identical.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了为了演示目的，从外部视角如何有效地使用遮挡剔除来减少场景中渲染对象的数量。从主相机的视角来看，两种情况看起来是相同的。
- en: 'The Rendering Pipeline is not wasting time rendering objects that are obscured
    by closer ones:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管线不会浪费时间渲染被更近的对象遮挡的对象：
- en: '![](img/a9858734-38ee-4ee6-a23b-3c2ab7d506bf.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9858734-38ee-4ee6-a23b-3c2ab7d506bf.png)'
- en: Enabling the Occlusion Culling feature will cost additional disk space, RAM,
    and CPU time. Extra disk space is required to store the occlusion data, extra
    RAM is needed to keep the data structure in memory, and there will be a CPU processing
    cost to determine which objects are being occluded in each frame. The Occlusion
    Culling data structure must be properly configured to create cells of the appropriate
    size for our scene, and the smaller the cells, the longer it takes to generate
    the data structure. However, if it is configured correctly for the scene, Occlusion
    Culling can provide both fill rate savings through reduced Overdraw and draw call
    savings by culling nonvisible objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 启用遮挡剔除功能将消耗额外的磁盘空间、RAM和CPU时间。需要额外的磁盘空间来存储遮挡数据，需要额外的RAM来保持数据结构在内存中，并且每帧确定哪些对象被遮挡都会有CPU处理成本。遮挡剔除数据结构必须正确配置，以创建适合我们场景的适当大小的单元，单元越小，生成数据结构所需的时间越长。然而，如果为场景正确配置，遮挡剔除可以通过减少过度绘制和剔除不可见对象来提供填充率节省和绘制调用节省。
- en: Note that even though an object may be culled by occlusion, its shadows must
    still be calculated, so we won't save any draw calls or fill rate from those tasks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使一个对象可能被遮挡剔除，其阴影仍然需要计算，所以我们不会从这些任务中节省任何绘制调用或填充率。
- en: Optimizing Particle Systems
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化粒子系统
- en: Particle Systems are useful for a huge number of different visual effects, and
    usually, the more particles they generate, the better the effect looks. However,
    we will need to be responsible about the number of particles generated and the
    complexity of shaders used since they can touch on all parts of the Rendering
    Pipeline; they generate a lot of vertices for the frontend (each particle is a
    quad) and could use multiple textures, which consume Fill Rate and memory bandwidth
    in the backend, so they can potentially cause an application to be bound anywhere
    if used irresponsibly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统适用于大量不同的视觉效果，通常情况下，它们生成的粒子越多，效果看起来越好。然而，我们需要对生成的粒子数量和使用的着色器的复杂性负责，因为它们会影响到渲染管道的各个部分；它们为前端生成大量的顶点（每个粒子都是一个四边形）并可能使用多个纹理，这会在后端消耗填充率和内存带宽，因此如果使用不当，可能会使应用程序在任何地方都受限。
- en: Reducing Particle System density and complexity is fairly straightforward—use
    fewer Particle Systems, generate fewer particles, and/or use fewer special effects.
    Atlasing is also another common technique for reducing Particle System performance
    costs. However, there is an important performance consideration behind Particle
    Systems that is not too well known and happens behind the Scenes, and that is
    the process of automatic Particle System culling.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 减少粒子系统的密度和复杂性相对简单——使用更少的粒子系统，生成更少的粒子，以及/或者使用更少的特殊效果。图集也是减少粒子系统性能成本的另一种常见技术。然而，粒子系统背后有一个重要的性能考虑因素并不太为人所知，并且发生在幕后，那就是自动粒子系统剔除的过程。
- en: Making use of Particle System culling
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用粒子系统剔除
- en: The basic idea is that all Particle Systems are either predictable or not (deterministic
    versus non-deterministic), depending on various settings. When a Particle System
    is predictable and not visible to the main view, then the entire Particle System
    can be automatically culled away to save performance. As soon as a predictable
    Particle System comes back into view, Unity can figure out exactly how the Particle
    System is meant to look at that moment as if it had been generating particles
    the entire time it wasn't visible.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，所有粒子系统要么是可预测的，要么不是（确定性与非确定性），这取决于各种设置。当一个粒子系统是可预测的并且对主视图不可见时，整个粒子系统可以自动剔除以节省性能。一旦可预测的粒子系统重新进入视图，Unity就可以确定粒子系统在那一刻应该看起来是什么样子，就像它一直在生成粒子一样，尽管它之前是不可见的。
- en: So long as the Particle System generates particles in a very procedural way,
    then the state is immediately solvable mathematically.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只要粒子系统以非常程序化的方式生成粒子，状态就可以立即通过数学方法解决。
- en: However, if any setting forces the Particle System to become unpredictable or
    nonprocedural, then it would have no idea what the current state of the Particle
    System needs to be, had it been hidden previously, and will hence need to render
    it fully every frame regardless of whether or not it is visible. Settings that
    break a Particle System's predictability include, but are not limited to, making
    the Particle System render in world-space; applying external forces, collisions,
    and trails; or using complex animation curves. Check out the blog post mentioned
    previously for a rigorous list of nonprocedural conditions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果任何设置迫使粒子系统变得不可预测或非程序化，那么它将无法知道如果之前被隐藏，粒子系统的当前状态需要是什么，因此将需要在每一帧完全渲染它，无论它是否可见。破坏粒子系统可预测性的设置包括但不限于使粒子系统在世界空间中渲染；应用外部力、碰撞和尾迹；或使用复杂的动画曲线。请参阅之前提到的博客文章，以获取非程序化条件的严格列表。
- en: 'Note that Unity provides a useful warning on Particle Systems when something
    would cause it to break automatic culling, as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当Unity检测到某些情况会导致粒子系统自动剔除功能失效时，它会提供一个有用的警告，如下面的截图所示：
- en: '![](img/3f6ba5ab-ee42-45e7-8c6e-0a361636a0cf.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f6ba5ab-ee42-45e7-8c6e-0a361636a0cf.png)'
- en: Unity Technologies has released an excellent blog post covering this topic,
    which can be found at [https://blogs.unity3d.com/2016/12/20/unitytips-particlesystem-performance-culling/](https://blogs.unity3d.com/2016/12/20/unitytips-particlesystem-performance-culling/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Technologies发布了一篇关于这个主题的优秀博客文章，可以在[https://blogs.unity3d.com/2016/12/20/unitytips-particlesystem-performance-culling/](https://blogs.unity3d.com/2016/12/20/unitytips-particlesystem-performance-culling/)找到。
- en: Avoiding recursive Particle System calls
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免递归调用粒子系统
- en: Many methods available to a `ParticleSystem` component are recursive calls.
    Calling them will iterate through each child of the Particle System, which then
    calls `GetComponent<ParticleSystem>()` on each child, and, if the component exists,
    it will call the appropriate method. This then repeats for each child `ParticleSystem`
    beneath the original parent, its grandchildren, and so on. This can be a huge
    problem with deep hierarchies of Particle Systems, which is sometimes the case
    with complex effects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可供`ParticleSystem`组件使用的许多方法都是递归调用。调用它们将遍历粒子系统的每个子代，然后对每个子代调用`GetComponent<ParticleSystem>()`，如果组件存在，它将调用相应的方法。然后，这将对原始父代下的每个`ParticleSystem`子代、孙子代等重复进行。这在具有深层粒子系统层次结构的情况下可能是一个大问题，这在复杂效果中有时是常见的情况。
- en: There are several `ParticleSystem` API calls affected by this behavior, such
    as `Start()`, `Stop()`, `Pause()`, `Clear()`, `Simulate()`, and `isAlive()`. We
    obviously cannot avoid these methods entirely since they represent the most common
    methods we would want to call on a Particle System. However, each of these methods
    has a `withChildren` parameter that defaults to `true`. Bypassing `false` in place
    of this parameter (for example, by calling `Clear(false)`, it disables the recursive
    behavior and will not call into its children. Hence, the method call will only
    affect the given Particle System, reducing the overhead cost of the call.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 受此行为影响的`ParticleSystem` API调用有几个，例如`Start()`、`Stop()`、`Pause()`、`Clear()`、`Simulate()`和`isAlive()`。显然，我们无法完全避免这些方法，因为它们代表了我们在粒子系统上最希望调用的最常见方法。然而，这些方法中的每个都有一个默认为`true`的`withChildren`参数。通过用`false`绕过此参数（例如，通过调用`Clear(false)`），它将禁用递归行为，并且不会调用其子代。因此，方法调用将仅影响给定的粒子系统，从而减少调用开销。
- en: This is not always ideal since we do often want all children of the Particle
    System to be affected by the method call. Another approach, therefore is to, cache
    the `ParticleSystem` components in the same way we learned in Chapter 2, *Scripting
    Strategies*, and iterate through them manually ourselves (making sure that we
    pass `false` for the `withChildren` parameter each time).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是理想的，因为我们通常希望粒子的所有子代都受到方法调用的影響。因此，另一种方法是，以我们在第二章“脚本策略”中学到的方式缓存`ParticleSystem`组件，并手动遍历它们（确保每次传递`false`给`withChildren`参数）。
- en: Note that there is a bug in Unity 2017.1 and older, where additional memory
    is allocated each time `Stop()` and `Simulate()` are called (even if the Particle
    System has already been stopped). This bug was fixed in Unity 2017.2.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Unity 2017.1及更早版本中存在一个bug，每次调用`Stop()`和`Simulate()`时都会分配额外的内存（即使粒子系统已经被停止）。这个bug在Unity
    2017.2中得到了修复。
- en: Optimizing Unity UI
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Unity UI
- en: Unity's first few attempts at built-in UI systems were not particularly successful;
    it is often quickly supplanted by products on the Asset Store. However, the latest
    generation of their solution (simply called Unity UI) has become a much more popular
    solution, so many developers are starting to rely on it for their UI needs, so
    much so, in fact, that Unity Technologies bought the company behind the Text Mesh
    Pro asset in early 2017 and merged it into the Unity UI as a built-in feature.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在内置UI系统方面的最初几次尝试并不特别成功；它们通常很快就被资产商店上的产品所取代。然而，他们最新一代的解决方案（简单地称为Unity UI）已经变得非常受欢迎，以至于许多开发者开始依赖它来满足他们的UI需求，实际上，到了2017年初，Unity
    Technologies收购了Text Mesh Pro资产背后的公司，并将其作为内置功能合并到Unity UI中。
- en: Let's explore a few techniques we can use to improve the performance of Unity's
    built-in UI.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些可以提高Unity内置UI性能的技术。
- en: Using more Canvases
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更多画布
- en: A `Canvas` component's primary task is to manage the meshes that are used to
    draw the UI elements beneath them in the Hierarchy window and issue the draw calls
    necessary to render those elements. An important task of the Canvas is to batch
    these meshes together (which can only happen if they share the same Material)
    to reduce draw calls. However, when changes are made to a Canvas, or any of its
    children, this is known as *dirtying* the Canvas.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`组件的主要任务是管理用于在层次结构窗口中绘制UI元素及其下元素的网格，并发出必要的绘制调用。Canvas的一个重要任务是批量处理这些网格（这只能在它们共享相同的材质时发生），以减少绘制调用。然而，当对Canvas或其任何子代进行更改时，这被称为*污染*Canvas。'
- en: When a Canvas is *dirty*, it needs to regenerate meshes for all of the UI elements
    beneath it before it can issue a draw call. This regeneration process is not a
    simple task and is a common source of performance problems in Unity projects because,
    unfortunately, many things can cause the Canvas to be made dirty. Even changing
    a single UI element within a Canvas can cause this to occur. There are so many
    things that cause dirtying, and so few that don't (and usually only in certain
    circumstances) that it's best to simply err on the side of caution and assume
    that any change will cause this effect.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当画布变脏时，它需要在发出绘制调用之前重新生成其下所有UI元素的网格。这个过程不是一项简单的任务，并且是Unity项目中性能问题的常见来源，因为不幸的是，许多事情都可以使画布变脏。甚至在一个画布内更改单个UI元素也可能导致这种情况发生。引起脏化的因素如此之多，而没有引起脏化的因素如此之少（通常只在某些情况下），因此最好谨慎行事，假设任何更改都会产生这种效果。
- en: Perhaps the only notable action that doesn't cause dirtying is changing a `Color`
    property of a UI element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可能唯一不会引起脏化的操作是改变UI元素的`Color`属性。
- en: If we find that our UI causes a large spike in CPU usage any time something
    changes (or sometimes literally every frame if they're being changed every frame),
    one solution we can apply is to simply use more Canvases. A common mistake is
    to build the entire game's UI in a single Canvas and keep it this way as the game
    code, and its UI continues to become more complex.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现我们的UI在每次发生变化时都会导致CPU使用量大幅上升（有时如果它们每帧都在变化，那么实际上每帧都会发生变化），我们可以应用的一个解决方案是简单地使用更多的画布。一个常见的错误是将整个游戏的UI构建在一个画布中，并且随着游戏代码和UI的复杂度增加，保持这种方式。
- en: This means that it will need to check every element every time anything changes
    in the UI, which can become more and more disastrous on performance as more elements
    are crammed into a single Canvas. However, each Canvas is independent and does
    not need to interact with other Canvases in the UI, and so by splitting up the
    UI into multiple Canvases, we can separate the workload and simplify the tasks
    required by any single Canvas.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次UI中任何内容发生变化时，都需要检查每个元素，随着更多元素被挤入单个画布，这可能会对性能造成越来越大的影响。然而，每个画布都是独立的，不需要与其他UI中的画布交互，因此通过将UI拆分为多个画布，我们可以分离工作量并简化单个画布所需的任务。
- en: Ensure that you add a `GraphicsRaycaster` component to the same `GameObject` as
    the child Canvas so that its own child elements can still be interacted with.
    Conversely, if none of the Canvas' child elements are interactable, then we can
    safely remove any `GraphicsRaycaster` components from it to reduce performance
    costs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`GraphicsRaycaster`组件添加到与子画布相同的`GameObject`中，以便其自身的子元素仍然可以交互。相反，如果画布的子元素没有任何交互性，那么我们可以安全地从中移除任何`GraphicsRaycaster`组件以降低性能成本。
- en: In this case, even though an element still changes, fewer other elements will
    need to be regenerated in response, reducing the performance cost. The downside
    of this approach is that elements across different Canvases will not be batched
    together, so we should try to keep similar elements with the same Material grouped
    together within the same Canvas, if possible.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使一个元素仍在变化，也需要重新生成的其他元素会更少，从而降低性能成本。这种方法的缺点是，不同画布上的元素不会一起批量处理，因此，如果可能的话，我们应该尽量将具有相同材质的相似元素分组放在同一个画布中。
- en: It's also possible to make a Canvas a child of another Canvas, for the sake
    of organization, and the same rules apply. If an element changes in one Canvas,
    the other will be unaffected.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了组织目的，也可以将一个画布作为另一个画布的子画布，并且适用相同的规则。如果一个画布中的元素发生变化，另一个画布将不受影响。
- en: Separating objects between static and dynamic Canvases
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在静态和动态画布之间分离对象。
- en: 'We should strive to try and generate our Canvases in a way that groups elements
    based on when they get updated. We should think of our elements as fitting within
    one of three groups:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该努力尝试根据元素更新的时间来生成画布。我们应该将我们的元素视为适合以下三个组之一：
- en: '**Static**: Static UI elements are those that never change; good examples of
    these are background images, labels, and so on'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：静态UI元素是指永远不会变化的元素；这些元素的例子包括背景图像、标签等。'
- en: '**Incidental Dynamic**: Dynamic elements are those that can change, where Incidental
    Dynamic objects are those UI elements that only change in response to something,
    such as a UI button press or a hover action'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偶然动态**：动态元素是指可以变化的元素，而偶然动态对象是指那些仅对某些事件（如UI按钮点击或悬停操作）做出响应的UI元素。'
- en: '**Continuous Dynamic**: Continuous Dynamic objects are those UI elements that
    update regularly, such as animated elements'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续动态**：连续动态对象是那些定期更新的UI元素，例如动画元素'
- en: We should try to split UI elements from these three groups into three different
    Canvases for any given section of our UI, as this will minimize the amount of
    wasted effort during regeneration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尝试将UI元素从这三个组中分离出来，为UI的任何给定部分创建三个不同的Canvas，这样将最小化再生过程中的浪费。
- en: Disabling Raycast Target for non-interactive elements
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用非交互元素的Raycast目标
- en: UI elements have a Raycast Target option, which enables them to be interacted
    with by clicks, taps, and other user behavior. Each time one of these events takes
    place, the `GraphicsRaycaster` component will perform pixel-to-bounding box checks
    to figure out which element has been interacted with and is a simple iterative
    `for` loop. By disabling this option for non-interactive elements, we're reducing
    the number of elements that `GraphicsRaycaster` needs to iterate through, thereby
    saving performance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: UI元素有一个Raycast目标选项，它使它们能够通过点击、轻触和其他用户行为进行交互。每次发生这些事件之一时，`GraphicsRaycaster`组件将执行像素到边界框的检查，以确定哪个元素被交互，这是一个简单的迭代`for`循环。通过为非交互元素禁用此选项，我们减少了`GraphicsRaycaster`需要迭代的元素数量，从而节省了性能。
- en: Hiding UI elements by disabling the parent Canvas component
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过禁用父Canvas组件来隐藏UI元素
- en: The UI uses a separate layout system to handle the regeneration of certain element
    types, which operates in a similar way as dirtying a Canvas. `UIImage`, `UIText`,
    and `LayoutGroup` are all examples of components that fall under this system.
    Many things can cause a layout system to become dirty, the most obvious of which
    are enabling and disabling such elements. However, if we want to disable a portion
    of the UI, we can avoid these expensive regeneration calls from the layout system
    by simply disabling the `Canvas` component they are children of. This can be done
    by setting the `Canvas` component's `enabled` property to `false`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: UI使用一个独立的布局系统来处理某些元素类型的再生，它的工作方式与污染Canvas类似。`UIImage`、`UIText`和`LayoutGroup`都是属于这个系统的组件。许多事情都可以导致布局系统变得污染，其中最明显的是启用和禁用这些元素。然而，如果我们想禁用UI的一部分，我们可以通过简单地禁用它们所拥有的`Canvas`组件来避免布局系统中的这些昂贵的再生调用。这可以通过将`Canvas`组件的`enabled`属性设置为`false`来实现。
- en: The drawback of this approach is that, if any child objects that have some `Update()`,
    `FixedUpdate()`, `LateUpdate()`, or coroutine code, then we would also need to
    disable them manually, otherwise they will continue to run. By disabling the `Canvas` component,
    we're only stopping the UI from being rendered and interacted with, and we should
    expect various update calls to continue to happen as normal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，如果任何子对象具有一些`Update()`、`FixedUpdate()`、`LateUpdate()`或协程代码，那么我们也需要手动禁用它们，否则它们将继续运行。通过禁用`Canvas`组件，我们只是停止了UI的渲染和交互，我们应该期望各种更新调用继续正常发生。
- en: Avoiding Animator components
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用Animator组件
- en: Unity's `Animator` components were never intended to be used with the latest
    version of its UI System, and their interaction with it is a naive implementation.
    Each frame, the animator will change properties on UI elements that cause their
    layouts to be dirtied and cause regeneration of a lot of internal UI information.
    We should avoid using Animators entirely, and instead perform tweening ourselves
    or use a utility asset intended for such operations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的`Animator`组件从未打算与UI系统的最新版本一起使用，它们之间的交互是一个简单的实现。每一帧，动画师都会更改UI元素上的属性，导致它们的布局被污染并重新生成大量的内部UI信息。我们应该完全避免使用动画师，而是自己执行缓动或使用专为这些操作设计的实用资产。
- en: Explicitly defining the event camera for World Space Canvases
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确定义世界空间Canvas的事件相机
- en: Canvases can be used for UI interactions in both 2D and 3D. This is determined
    by whether the Canvas has its Render Mode setting configured to Screen Space (2D)
    or World Space (3D). Any time a UI interaction takes place, the `Canvas` Component
    will check its `eventCamera` property (exposed as Event Camera in the Inspector
    window) to figure out which camera to use. By default, a 2D Canvas will set this
    property to the main camera, but a 3D Canvas leaves it set to `null`. This is
    unfortunate because, each time the event camera is needed, it will still use the
    main camera, but will do so by calling `FindObjectWithTag()`. Finding objects
    by tag isn't as bad of a performance cost as using the other variations of `Find()`,
    but its performance cost scales linearly with the more tags we use in a given
    project. To make matters worse, the event camera is accessed fairly often during
    a given frame for a World Space Canvas, which means that leaving this property
    `null` will cause a huge performance hit for no real benefit. We should manually
    set this property to the main camera for all of our World Space Canvases.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 画布可以用于 2D 和 3D 中的 UI 交互。这取决于画布的渲染模式设置是否配置为屏幕空间（2D）或世界空间（3D）。每次进行 UI 交互时，`Canvas`
    组件都会检查其 `eventCamera` 属性（在检查器窗口中暴露为 Event Camera），以确定要使用哪个相机。默认情况下，2D 画布会将此属性设置为主相机，但
    3D 画布将其设置为 `null`。这是不幸的，因为每次需要事件相机时，它仍然会使用主相机，但会通过调用 `FindObjectWithTag()` 来这样做。通过标签查找对象并不像使用其他
    `Find()` 变化那样有性能成本，但其性能成本与在给定项目中使用的标签数量成线性关系。更糟糕的是，在给定帧中，对于世界空间画布，事件相机会被频繁访问，这意味着将此属性保留为
    `null` 将导致巨大的性能损失，而没有任何实际的好处。我们应该手动将此属性设置为所有我们的世界空间画布的主相机。
- en: Don't use alpha to hide UI elements
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用 alpha 隐藏 UI 元素
- en: Rendering a UI element with an alpha value of `0` in its `color` property will
    still cause a draw call to be issued. We should favor changing the `IsActive`
    property of a UI element to hide it when necessary. Another alternative is to
    use Canvas Groups via `CanvasGroup` Components, which can be used to control the
    alpha transparency of all child elements beneath them. Setting the `alpha` value
    of a Canvas Group to `0` will cull away its child objects, and, therefore, no
    draw calls will be issued.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在其 `color` 属性中使用 alpha 值为 `0` 的 UI 元素仍然会导致发出绘制调用。我们应该优先考虑更改 UI 元素的 `IsActive`
    属性来在必要时隐藏它。另一个选择是使用通过 `CanvasGroup` 组件的 Canvas 组，这可以用来控制它们下方所有子元素的 alpha 透明度。将
    Canvas 组的 `alpha` 值设置为 `0` 将剔除其子对象，因此不会发出绘制调用。
- en: Optimizing ScrollRects
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 ScrollRects
- en: '`ScrollRect` Components are UI elements that are used to scroll through a list
    of other UI elements and are fairly common in mobile applications. Unfortunately,
    the performance of these elements scales very poorly with size since the Canvas
    needs to regenerate them regularly. There are several things we can do to improve
    the performance of our `ScrollRect` Components. Let''s take a look at some of
    them in the following.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollRect` 组件是用于在列表中滚动其他 UI 元素的 UI 元素，在移动应用中相当常见。不幸的是，这些元素的性能与尺寸的缩放非常差，因为画布需要定期重新生成它们。我们可以做几件事情来提高我们的
    `ScrollRect` 组件的性能。以下是一些方法。'
- en: Make sure to use a RectMask2D
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保使用 RectMask2D
- en: It's possible to create scrolling UI behavior by simply placing other UI elements
    with a lower `depth` value than the `ScrollRect` elements. However, this is bad
    practice since there will be no culling taking place in `ScrollRect`, and every
    element will need to be regenerated for each frame that `ScrollRect` is moving.
    If we haven't already, we should use a `RectMask2D` Component to clip and cull
    child objects that are not visible. This Component creates a region of space,
    whereby any child UI elements within it will be culled away if they are outside
    the bounds of the `RectMask2D` Component. The cost of determining whether to cull
    an object compared to the savings of rendering too many invisible ones is typically
    worth it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地放置具有比 `ScrollRect` 元素更低 `depth` 值的其他 UI 元素，可以创建滚动 UI 行为。然而，这并不是一个好的实践，因为在
    `ScrollRect` 中不会发生剔除，并且每个元素都需要在 `ScrollRect` 移动时为每一帧重新生成。如果我们还没有这样做，我们应该使用 `RectMask2D`
    组件来剪辑和剔除不可见的子对象。此组件创建一个空间区域，其中任何位于其内的子 UI 元素如果超出 `RectMask2D` 组件的边界，将被剔除。与渲染过多不可见对象相比，确定是否剔除对象的成本通常是值得的。
- en: Disable Pixel Perfect for ScrollRects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用 ScrollRects 的像素完美
- en: Pixel Perfect is a setting on a `Canvas` component that forces its child UI
    elements to be drawn with direct alignment to the pixels on the screen. This is
    often a requirement for art and design, as the UI elements will appear much sharper
    than if it was disabled. While this alignment behavior is a relatively expensive
    operation, it is effectively mandatory that it will be enabled for the majority
    of our UI to keep things crisp and clear. However, for animating and fast-moving
    objects, it can be somewhat pointless due to the motion involved.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 像素完美（Pixel Perfect）是`Canvas`组件上的一个设置，它强制其子UI元素以直接对齐屏幕上的像素进行绘制。这对于艺术和设计通常是必需的，因为UI元素将比禁用时看起来更清晰。虽然这种对齐行为是一个相对昂贵的操作，但对于动画和快速移动的对象来说，由于涉及到的运动，它可能有点没有意义。
- en: Disabling Pixel Perfect for `ScrollRect` elements is a good way to make some
    impressive savings. However, since the Pixel Perfect setting affects the entire
    Canvas, we should make sure to enable the `ScrollRect` element as a child object
    beneath a separate Canvas so that other elements will maintain their pixel-aligned
    behavior.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用`ScrollRect`元素的像素完美（Pixel Perfect）设置是一种很好的节省资源的方法。然而，由于像素完美设置会影响整个画布，我们应该确保将`ScrollRect`元素作为一个子对象在单独的画布下启用，这样其他元素将保持其像素对齐的行为。
- en: Different kinds of animated UI elements actually look better with Pixel Perfect
    disabled. Be sure to do some testing, as this can save quite a bit of performance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，禁用像素完美（Pixel Perfect）后，不同类型的动画UI元素看起来更好。务必进行一些测试，因为这可以节省相当多的性能。
- en: Manually stop ScrollRect motion
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动停止`ScrollRect`运动
- en: The Canvas will always need to regenerate the entire `ScrollRect` element even
    if the velocity is moving by a fraction of a pixel each frame. We can manually
    freeze its motion once we detect that its velocity is below a certain threshold
    using `ScrollRect.velocity` and `ScrollRect.StopMovement()`. This can help to
    reduce the frequency of regeneration a great deal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 即使每帧的速度只移动了像素的一部分，画布（Canvas）也总是需要重新生成整个`ScrollRect`元素。一旦我们检测到其速度低于某个阈值，我们可以使用`ScrollRect.velocity`和`ScrollRect.StopMovement()`手动冻结其运动。这可以大大减少重新生成的频率。
- en: Using empty UIText elements for full-screen interaction
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空`UIText`元素进行全屏交互
- en: A common implementation in most UIs is to activate a large, transparent interactable
    element that covers the entire screen, forcing the player to handle a popup before
    proceeding, while still allowing the player to see what's going on behind it (as
    a means of not ripping the player out of the game experience entirely). This is
    often done with a `UIImage` element, but unfortunately, this can break batching
    operations, and transparency can be a problem on mobile devices.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数用户界面（UIs）中，常见的实现方式是激活一个覆盖整个屏幕的大透明交互元素，迫使玩家在继续之前处理一个弹出窗口，同时仍然允许玩家看到其背后的内容（作为不让玩家完全脱离游戏体验的手段）。这通常使用一个`UIImage`元素来完成，但不幸的是，这可能会破坏批处理操作，并且在移动设备上透明度可能成为问题。
- en: A hacky way around this problem is to use a `UIText` element with no Font or
    Text defined. This creates an element that doesn't need to generate any renderable
    information and only handles bounding box checks for interaction.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个技巧是使用一个没有字体或文本定义的`UIText`元素。这创建了一个不需要生成任何可渲染信息的元素，并且只处理交互的边界框检查。
- en: Checking the Unity UI source code
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Unity UI源代码
- en: If we're having significant problems with the performance of our UI, it is possible
    to look into the source code to figure out exactly what might be going on and
    hopefully discover ways to get around the problem.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的UI性能存在重大问题，查看源代码以确定可能发生的问题并希望发现绕过问题的方法是有可能的。
- en: A more drastic measure, but a potential option, could be to actually modify
    the UI code, compile it, and add it to our project manually.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更激进的措施，但可能是一个选项，是实际上修改UI代码，编译它，并将其手动添加到我们的项目中。
- en: Unity provides the code for its UI system in a Bitbucket repository, found at [https://bitbucket.org/Unity-Technologies/ui](https://bitbucket.org/Unity-Technologies/ui).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在其UI系统的一个Bitbucket仓库中提供了代码，位于[https://bitbucket.org/Unity-Technologies/ui](https://bitbucket.org/Unity-Technologies/ui)。
- en: Checking the documentation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文档
- en: The tips mentioned previously are some of the more obscure, undocumented, or
    critical performance optimization tips for the UI system. There are several great
    resources on the Unity website that explain how the UI system works and how best
    to optimize it, which is far too large to fit in this book verbatim.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的技巧是一些较为隐蔽、未记录或关键的性能优化技巧，适用于UI系统。Unity网站上有多篇优秀的资源解释了UI系统的工作原理以及如何最佳优化它，这些内容太多，无法完整地放入本书中。
- en: Start with the following page and work your way through them for many more helpful
    UI optimization tips: [https://unity3d.com/learn/tutorials/temas/best-practices/guide-optimizing-unity-ui](https://unity3d.com/learn/tutorials/temas/best-practices/guide-optimizing-unity-ui).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下页面开始，逐步阅读以获取更多有用的UI优化技巧：[https://unity3d.com/learn/tutorials/temas/best-practices/guide-optimizing-unity-ui](https://unity3d.com/learn/tutorials/temas/best-practices/guide-optimizing-unity-ui)。
- en: Shader optimization
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器优化
- en: Fragment shaders are the primary consumers of Fill Rate and memory bandwidth.
    The costs depend on their complexity—how much texture sampling takes place, how
    many mathematical functions are used, and many more factors. The GPU's parallel
    nature (sharing small pieces of the overall job between hundreds of threads) means
    that any bottleneck in a thread will limit how many fragments can be pushed through
    that thread during a frame.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器是填充率和内存带宽的主要消费者。其成本取决于它们的复杂度——包括纹理采样量、使用的数学函数数量以及许多其他因素。GPU的并行特性（将整个工作的小部分分配给数百个线程）意味着任何线程中的瓶颈都会限制在帧内可以通过该线程的片段数量。
- en: The classic analogy is a vehicle assembly line. A complete vehicle requires
    multiple stages of manufacture to complete. The critical path to completion might
    involve stamping, welding, painting, assembly, and inspection, where each step
    is completed by a single team. For any given vehicle, no stage can begin before
    the previous one is finished, but whatever team handled the stamping for the last
    vehicle can begin stamping for the next vehicle as soon as it has finished. This
    organization allows each team to become masters of their particular domain rather
    than trying to spread their knowledge too thin, which would likely result in less
    consistent quality in the batch of vehicles.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的类比是汽车装配线。一辆完整的汽车需要多个制造阶段才能完成。完成的关键路径可能包括冲压、焊接、喷漆、组装和检查，每个步骤都由一个团队完成。对于任何给定的车辆，任何阶段都不能在之前的阶段完成之前开始，但处理最后一辆车冲压的团队可以在完成工作后立即开始为下一辆车冲压。这种组织方式允许每个团队成为其特定领域的专家，而不是试图过于分散他们的知识，这可能会导致车辆批次的质量不一致。
- en: We can double the overall output by doubling the number of teams, but if any
    team gets blocked, then precious time is lost for any given vehicle, as well as
    all future vehicles that would pass through the same team. If these delays are
    rare, then they can be negligible in the grand scheme, but if not, and even if
    one stage takes several minutes longer than normal each and every time it must
    complete the task, then it can become a bottleneck that threatens the release
    of the entire batch.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加团队数量来加倍整体输出，但如果任何团队受阻，那么任何给定车辆以及所有未来将通过同一团队的车辆都会损失宝贵的时间。如果这些延迟很少，那么在整体方案中它们可以忽略不计，但如果不是这样，即使每个阶段每次都要比正常情况下多花几分钟才能完成任务，那么它可能成为一个瓶颈，威胁到整个批次的发布。
- en: 'The GPU parallel processors work similarly: each processor thread is an assembly
    line, each processing stage is a team, and each fragment is the thing that needs
    to be built. If the thread spends a long time processing a single stage, then
    time is lost on each fragment. This delay will multiply such that all future fragments
    coming through the same thread will be delayed. This is a bit of an oversimplification,
    but it often helps to paint a picture of how quickly some poorly optimized shader
    code can chew up our Fill Rate, and how small improvements in shader optimization
    provide big benefits in backend performance.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: GPU的并行处理器工作方式类似：每个处理器线程是一个装配线，每个处理阶段是一个团队，每个片段是需要构建的东西。如果线程在一个阶段上花费了很长时间，那么每个片段都会损失时间。这种延迟会成倍增加，以至于所有通过同一线程的未来片段都会被延迟。这有点过于简化，但它经常有助于描绘一些优化不良的着色器代码如何迅速消耗我们的填充率，以及着色器优化的小幅改进如何在后端性能上带来巨大好处。
- en: Shader programming and optimization is a very niche area of game development.
    Their abstract and highly specialized nature requires a very different kind of
    thinking to generate high-quality shader code compared to typical gameplay or
    Engine code. They often feature mathematical tricks and back-door mechanisms for
    pulling data into the shader, such as pre-computing values and putting them in
    texture files. Because of this, and the importance of optimization, shaders tend
    to be very difficult to read and reverse-engineer.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器编程和优化是游戏开发中的一个非常狭窄的领域。它们的抽象和高度专业化的性质需要一种非常不同的思维方式来生成高质量的着色器代码，与典型的游戏玩法或引擎代码相比。它们通常包含数学技巧和后门机制，用于将数据拉入着色器，例如预先计算值并将它们放入纹理文件中。正因为如此，以及优化的重要性，着色器往往很难阅读和逆向工程。
- en: Consequently, many developers rely on prewritten shaders, visual shader creation
    tools from the Asset Store, such as Shader Forge or Amplify Shader Editor. This
    simplifies the act of initial shader code generation, but might not result in
    the most efficient form of shaders. Whether we're writing our own shaders, or
    we're relying on pre-written/pre-generated shaders, we might find it worthwhile
    to perform some optimization passes over them using some tried-and-true techniques, which
    we are going to see in the following sections.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多开发者依赖于预写的着色器，来自Asset Store的视觉着色器创建工具，如Shader Forge或Amplify Shader Editor。这简化了初始着色器代码生成的过程，但可能不会产生最有效的着色器形式。无论我们是编写自己的着色器，还是依赖于预写/预生成的着色器，我们可能会发现使用一些经过验证的技术对它们进行一些优化是有价值的，这些技术我们将在以下章节中看到。
- en: Consider using shaders intended for mobile platforms
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑使用针对移动平台设计的着色器
- en: The built-in mobile shaders in Unity do not have any specific restrictions that
    force them only to be used on mobile devices. They are simply optimized for minimum
    resource usage (and tend to feature some of the other optimizations listed in
    this section).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中内置的移动端着色器没有特定的限制，迫使它们只能在移动设备上使用。它们只是针对最小资源使用进行了优化（并且往往具有本节中列出的其他一些优化）。
- en: Desktop applications are perfectly capable of using these shaders, but they
    tend to feature a loss of graphical quality. It only becomes a question of whether
    the loss of graphical quality is acceptable. So, consider doing some testing with
    the mobile equivalents of common shaders to check whether they are a good fit
    for your game.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序完全可以使用这些着色器，但它们往往会导致图形质量的损失。这仅仅是一个问题，即图形质量的损失是否可以接受。因此，考虑使用常见着色器的移动端等效产品进行一些测试，以检查它们是否适合您的游戏。
- en: Using small data types
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用小型数据类型
- en: GPUs can calculate with smaller data types more quickly than larger types (particularly
    on mobile platforms), so the first tweak we can attempt is replacing our `float`
    data types (32-bit, floating-point) with smaller versions such as `half` (16-bit,
    floating-point) or even `fixed` (12-bit, fixed point). The size of the data types
    listed previously will vary depending on what floating-point formats the target
    platform prefers. The sizes listed are the most common.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: GPU可以使用比大型数据类型更小的数据类型更快地计算（尤其是在移动平台上），因此我们可以尝试的第一个调整是将我们的`float`数据类型（32位，浮点数）替换为更小的版本，例如`half`（16位，浮点数）或甚至`fixed`（12位，定点数）。之前列出的数据类型的大小将取决于目标平台首选的浮点数格式。列出的尺寸是最常见的。
- en: Optimization stems from the relative size between formats since there are fewer
    bits to process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 优化源于格式之间的相对大小，因为要处理的位数更少。
- en: Color values are good candidates for precision reduction, as we can often get
    away with fewer precise color values without a noticeable loss in coloration.
    However, the effects of reducing precision can be very unpredictable for graphical
    calculations. So, changes such as these can require some testing to verify that
    the reduced precision is costing too much graphical fidelity.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色值是进行精度降低的良好候选者，因为我们通常可以减少精确的颜色值数量，而不会在色彩上产生明显的损失。然而，降低精度的效果对于图形计算来说可能非常不可预测。因此，这些变化可能需要一些测试来验证降低精度是否导致图形保真度损失过多。
- en: Note that the effects of these tweaks can vary enormously between one GPU architecture
    and another (for example, AMD versus Nvidia versus Intel) and even GPU brands
    from the same manufacturer. In some cases, we can make some decent performance
    gains for a trivial amount of effort. In other cases, we might see no benefit
    at all.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些调整的效果在不同GPU架构之间（例如，AMD与Nvidia与Intel）以及同一制造商的GPU品牌之间可能会有很大差异。在某些情况下，我们只需付出微小的努力，就能获得一些相当的性能提升。在其他情况下，我们可能根本看不到任何好处。
- en: Avoiding changing precision while swizzling
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在混色时更改精度
- en: Swizzling is the shader programming technique of creating a new vector (an array
    of values) from an existing vector by listing the components in the order in which
    we wish to copy them into the new structure.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 混色是着色器编程技术，通过列出我们希望按顺序复制到新结构中的组件来从现有向量创建一个新的向量（值数组）。
- en: 'Here are some examples of swizzling:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些混色的示例：
- en: '[PRE0]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use both the `xyzw` and `rgba` representations to refer to the same components,
    sequentially. It does not matter whether it is a color or a vector; they just
    make the shader code easier to read. We can also list components in any order
    we like to fill in the desired data, repeating them if necessary.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`xyzw`和`rgba`表示法来引用相同的组件，顺序无关紧要。无论是颜色还是向量，它们只是使着色器代码更容易阅读。我们还可以按任何我们喜欢的顺序列出组件，以填充所需的数据，如果需要可以重复。
- en: Converting from one precision type to another in a shader can be a costly operation,
    but converting the precision type while simultaneously swizzling can be particularly
    painful. If we have mathematical operations that use swizzling, ensure that they
    don't also convert the precision type. In these cases, it would be wiser to simply
    use the high-precision data type from the very beginning or reduce precision across
    the board to avoid the need for changes in precision.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中将一个精度类型转换为另一个类型可能是一个昂贵的操作，但在同时进行混色转换时可能会特别痛苦。如果我们有使用混色的数学运算，确保它们不会同时转换精度类型。在这些情况下，最好从一开始就简单地使用高精度数据类型，或者全面降低精度以避免需要更改精度。
- en: Using GPU-optimized helper functions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPU优化的辅助函数
- en: The shader compiler often performs a good job of reducing mathematical calculations
    down to an optimized version for the GPU, but compiled custom code is unlikely
    to be as effective as both the **Cg** library's built-in helper functions and
    the additional helpers provided by the Unity **Cg** included files. If we are
    using shaders that include custom function code, perhaps we can find an equivalent
    helper function within the **Cg** or Unity libraries that can do a better job
    than our custom code can.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器编译器通常能很好地将数学计算优化为适合GPU的版本，但编译的定制代码可能不如**Cg**库的内置辅助函数以及Unity **Cg**包含文件提供的额外辅助函数有效。如果我们使用包含定制函数代码的着色器，也许我们可以在**Cg**或Unity库中找到一个等效的辅助函数，它比我们的定制代码做得更好。
- en: 'These extra `include` files can be added to our shader within the `CGPROGRAM`
    block, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的`include`文件可以添加到我们的着色器中的`CGPROGRAM`块中，如下所示：
- en: '[PRE1]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example **Cg** library functions to use are `abs()` for absolute values, `lerp()`
    for linear interpolation, `mul()` for multiplying matrices, and `step()` for step
    functionality. Useful `UnityCG.cginc` functions include `WorldSpaceViewDir()`
    for calculating the direction toward the camera and `Luminance()` for converting
    color into grayscale.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的示例**Cg**库函数包括`abs()`用于绝对值，`lerp()`用于线性插值，`mul()`用于矩阵乘法，以及`step()`用于步进功能。有用的`UnityCG.cginc`函数包括`WorldSpaceViewDir()`用于计算朝向摄像机的方向和`Luminance()`用于将颜色转换为灰度。
- en: Check out [http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html) for
    a full list of Cg standard library functions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html)以获取Cg标准库函数的完整列表。
- en: Check out the Unity documentation for a complete and up-to-date list of possible
    `include` files and their accompanying helper functions at [http://docs.unity3d.com/Manual/SL-BuiltinIncludes.html](http://docs.unity3d.com/Manual/SL-BuiltinIncludes.html).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Unity文档，以获取可能的`include`文件及其相关辅助函数的完整和最新列表，请访问[http://docs.unity3d.com/Manual/SL-BuiltinIncludes.html](http://docs.unity3d.com/Manual/SL-BuiltinIncludes.html)。
- en: Disabling unnecessary features
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用不必要的功能
- en: Perhaps we can make savings by simply disabling shader features that aren't
    vital. Does the shader really need transparency, *Z*-writing, alpha testing, and/or
    alpha blending? Will tweaking these settings or removing these features give us
    a good approximation of our desired effect without losing too much graphical fidelity?
    Making such changes is a good way of making Fill Rate cost savings.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以通过简单地禁用非关键着色器功能来节省一些资源。着色器真的需要透明度、*Z*-写入、alpha测试和/或alpha混合吗？调整这些设置或删除这些功能是否会给我们一个很好的近似效果，而不会损失太多的图形保真度？进行这样的更改是节省填充率成本的好方法。
- en: Removing unnecessary input data
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除不必要的输入数据
- en: Sometimes, the process of writing a shader involves a lot of back and forth
    experimentation in editing code and viewing it in the Scene. The typical outcome
    of this process is that input data that was needed when the shader was going through
    early development is now surplus fluff once the desired effect has been obtained,
    and it's easy to forget what changes were made when/if the process drags on for
    an extended period. However, these redundant data values can cost the GPU valuable
    time, as they must be fetched from memory even if they are not explicitly used
    by the shader. So, we should double-check our shaders to ensure that all of their
    input geometry, vertices, and fragment data is actually being used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，编写着色器的过程涉及到在编辑代码和查看场景中的代码之间进行大量的来回实验。这个过程典型的结果是在着色器早期开发时需要的输入数据，一旦达到期望的效果，就变成了多余的冗余数据，而且如果这个过程拖得时间过长，很容易忘记都做了哪些更改。然而，这些冗余的数据值可能会让GPU付出宝贵的时间，因为即使它们没有被着色器明确使用，也必须从内存中检索。因此，我们应该仔细检查我们的着色器，以确保它们的所有输入几何、顶点和片段数据实际上正在被使用。
- en: Exposing only necessary variables
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅暴露必要的变量
- en: Exposing unnecessary variables from our shader to the accompanying Material
    can be costly, as the GPU can't assume these values are constant, which means
    the compiler cannot compile away these values. This data must be pushed from the
    CPU with every pass since they can be modified at any time through a Material
    object's methods such as `SetColor()` and `SetFloat()`. If we find that, toward
    the end of the project, we always use the same value for these variables, then
    they should be replaced with a constant in the shader to remove such excess runtime
    workload. The only cost is obfuscating what could be critical graphical effect
    parameters, so this should be done very late in the process.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们着色器中的不必要的变量暴露给配套的材质可能会造成成本，因为GPU不能假设这些值是恒定的，这意味着编译器不能将这些值编译掉。这些数据必须每次从CPU推送，因为它们可以通过材质对象的`SetColor()`和`SetFloat()`等方法在任意时刻被修改。如果我们发现，在项目后期，我们总是使用这些变量的相同值，那么它们应该被着色器中的常量替换，以消除这种过度的运行时工作负载。唯一的成本是混淆可能至关重要的图形效果参数，因此这应该在过程的后期进行。
- en: Reducing mathematical complexity
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低数学复杂性
- en: Complicated mathematics can severely bottleneck the rendering process, so we
    should do whatever we can to limit the damage. It is entirely possible to store
    a map of complex mathematical function outputs by precalculating them and placing
    them as floating-point data in a texture file. A texture file is, after all, just
    a huge blob of floating-point values that can be indexed quickly with three dimensions: `x`,
    `y`, and color (`rgba`).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的数学运算可能会严重限制渲染过程，因此我们应该尽一切可能来限制这种损害。通过预先计算并将它们作为浮点数据放置在纹理文件中，可以完全存储复杂数学函数输出的映射。毕竟，纹理文件只是一个由浮点值组成的巨大块，可以用三个维度快速索引：`x`、`y`和颜色（`rgba`）。
- en: We can feed this texture into the shader and sample the pre-generated table
    in the shader at runtime instead of completing a complex calculation at runtime.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个纹理输入到着色器中，并在运行时从着色器中采样预先生成的表格，而不是在运行时完成复杂的计算。
- en: We may not see any improvement with functions such as `sin()` and `cos()` since
    they've been heavily optimized to make use of GPU architecture, but complex methods
    such as `pow()`, `exp()`, `log()`, and our own custom mathematical calculations
    can only be optimized so much and would be good candidates for simplification.
    This is assuming that we can easily index the result from the texture with *x*
    and *y* coordinates. If complex calculations are required to generate those coordinates,
    then it may not be worth the effort.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`sin()`和`cos()`这样的函数，我们可能看不到任何改进，因为它们已经被高度优化以利用GPU架构，但像`pow()`、`exp()`、`log()`以及我们自己的自定义数学计算这样的复杂方法只能优化到一定程度，并且会是简化的良好候选者。这是假设我们可以轻松地使用*x*和*y*坐标索引结果。如果需要复杂的计算来生成这些坐标，那么可能不值得付出努力。
- en: This technique will cost us additional graphics memory to store the texture
    at runtime and some memory bandwidth, but if the shader has already been receiving
    a texture (which they are, in most cases), but the alpha channel is not being
    used, then we could sneak the data in through the texture's alpha channel, costing
    us literally no performance since that data has already been passed through anyway.
    This will involve hand-editing our art assets to include such data in any unused
    color channel(s), possibly requiring coordination between programmers and artists,
    but is a very good way of saving shader processing costs with no runtime sacrifices.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将使我们额外的图形内存来存储运行时的纹理，以及一些内存带宽，但如果着色器已经接收到了纹理（在大多数情况下是这样的），但alpha通道没有被使用，那么我们可以通过纹理的alpha通道偷偷地传输数据，实际上不会影响性能，因为数据已经无论如何都通过了。这将涉及到手动编辑我们的艺术资产，以包括任何未使用的颜色通道中的数据，可能需要程序员和艺术家之间的协调，但这是一个非常好的方法，可以在不牺牲运行时的情况下节省着色器处理成本。
- en: Reducing texture sampling
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少纹理采样
- en: Texture sampling is at the core of all memory bandwidth costs. The fewer textures
    we use, and the smaller we make them, the better. The more we use, the more cache
    misses we are likely to invoke, and the larger they are, the more memory bandwidth
    is consumed transferring them to the texture cache. Such situations should be
    simplified as much as possible to avoid severe GPU bottlenecks.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理采样是所有内存带宽成本的核心。我们使用的纹理越少，它们越小，就越好。我们使用的越多，我们可能遇到的缓存未命中就越多，它们越大，传输到纹理缓存所需的内存带宽就越多。这些情况应该尽可能地简化，以避免严重的GPU瓶颈。
- en: Even worse, sampling textures in a non-sequential order would likely result
    in some very costly cache misses for the GPU to suffer through. So, if this is
    being done, then the texture should be reordered so that it can be sampled in
    a more sequential order. For example, if we're sampling by inverting the `x` and
    `y` coordinates (for example, `tex2D(y, x)` instead of `tex2D(x, y)`), the texture
    lookup would iterate through the texture vertically, then horizontally, inflicting
    a cache-miss almost every iteration. A lot of performance could be saved by simply
    rotating the texture file data and performing a sample in the correct order (`tex2D(x,y)`).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，以非顺序的方式采样纹理可能会给GPU带来一些非常昂贵的缓存未命中。所以，如果这样做，那么纹理应该重新排序，以便可以以更顺序的方式采样。例如，如果我们是通过反转`x`和`y`坐标来采样（例如，`tex2D(y,
    x)`而不是`tex2D(x, y)`），纹理查找将垂直迭代通过纹理，然后水平迭代，几乎每次迭代都会发生缓存未命中。通过简单地旋转纹理文件数据并在正确的顺序中进行采样（`tex2D(x,y)`），可以节省大量的性能。
- en: Avoiding conditional statements
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免条件语句
- en: When conditional statements are run through a modern-day CPU, they undergo a
    lot of clever predictive techniques to make use of *instruction-level parallelism*.
    This is a feature where the CPU attempts to predict which direction a conditional
    statement will go in before it has actually been resolved and speculatively begins
    processing the most likely result of the conditional using any free cores that
    aren't being used to resolve the conditional (fetching some data from memory,
    copying some floating-point values into unused registers, and so on). If it turns
    out that the decision is wrong, then the current result is discarded, and the
    proper path is taken instead. So long as the cost of speculative processing and
    discarding false results is less than the time spent waiting to decide the correct
    path, and it is right more often than it is wrong, then this is a net gain for
    the CPU's speed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件语句在现代CPU上运行时，它们会经历许多聪明的预测技术来利用*指令级并行性*。这是一个功能，CPU试图在条件语句实际解决之前预测其将采取的方向，并使用任何未用于解决条件的空闲核心（从内存中获取一些数据，将一些浮点值复制到未使用的寄存器等）来投机性地开始处理条件最可能的结果。如果最终证明这个决定是错误的，那么当前的结果将被丢弃，并采取正确的路径。只要投机处理和丢弃错误结果的成本低于等待决定正确路径的时间，并且它正确的情况比错误的情况多，那么这对CPU的速度来说就是一个净收益。
- en: 'However, this feature is less beneficial for GPU architecture because of its
    parallel nature. The GPU''s cores are typically managed by some higher-level construct
    that instructs all cores under its command to perform the same machine code-level
    instruction simultaneously, such as a huge stamping machine that stamps sheets
    of metal in groups simultaneously. So, if the fragment shader requires `float`
    to be multiplied by `2`, then the process will begin by having all cores copy
    data into the appropriate registers in one coordinated step. Only when all cores
    are finished copying to the registers will the cores be instructed to begin the
    second step: multiplying all registers by `2` all in a second simultaneous action.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于GPU架构的并行性质，这个特性对GPU来说不太有益。GPU的核心通常由一些高级结构管理，该结构指示其命令下的所有核心同时执行相同的机器代码级指令，例如一个巨大的冲压机，可以同时冲压金属板。因此，如果片段着色器需要将`float`乘以`2`，那么这个过程将开始于所有核心在一步中协调地将数据复制到适当的寄存器中。只有当所有核心都完成复制到寄存器后，核心才会被指示开始第二步：在第二步中，所有寄存器同时乘以`2`。
- en: Hence, when this system stumbles onto a conditional statement, it cannot resolve
    the two statements independently. It must determine how many of its child cores
    will go down each path of the conditional, grab the list of required machine code
    instructions for one path, resolve them for all cores taking that path, and repeat
    these steps for each path until all possible paths have been processed. So, for
    an `if-else` statement (two possibilities), it will tell one group of cores to
    process the `true` path, and then ask the remaining cores to process the `false`
    path. Unless every core takes the same path, it must process both paths every
    time.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当这个系统遇到一个条件语句时，它不能独立解决这两个语句。它必须确定其子核心中有多少会走条件语句的每条路径，获取一条路径所需的机器代码指令列表，为所有走这条路径的核心解决这些指令，并重复这些步骤，直到处理完所有可能的路径。所以，对于一个`if-else`语句（两种可能性），它会告诉一组核心处理`true`路径，然后要求剩余的核心处理`false`路径。除非每个核心都走相同的路径，否则它必须每次都处理两条路径。
- en: So, we should avoid branching and conditional statements in our shader code.
    Of course, this depends on how essential the conditional is to achieving the graphical
    effect we desire. However, if the conditional is not dependent on per-pixel behavior,
    then we would often be better off absorbing the cost of unnecessary mathematics
    than inflicting a branching cost on the GPU.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该在我们的着色器代码中避免分支和条件语句。当然，这取决于条件语句对于实现我们想要的图形效果有多重要。然而，如果条件语句不依赖于每像素的行为，那么我们通常会更好，吸收不必要的数学成本，而不是在GPU上施加分支成本。
- en: Reducing data dependencies
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少数据依赖
- en: 'The compiler will try its best to optimize our shader code into the more GPU-friendly
    low-level language so that it is not waiting on data to be fetched when it could
    be processing some other task. For example, the following poorly optimized code
    could be written in our shader:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会尽力将我们的着色器代码优化成更符合GPU的低级语言，以便它不会在等待数据被获取时处理其他任务。例如，以下优化不良的代码可以写在我们的着色器中：
- en: '[PRE2]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code has a data dependency such that each calculation cannot begin until
    the last finishes due to the dependency on the `sum` variable. However, such situations
    are often detected by the shader compiler and optimized into a version that uses
    instruction-level parallelism. The following code is the high-level code equivalent
    of the resulting machine code after the previous code is compiled:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个数据依赖，即每个计算必须在最后一个完成之前开始，因为依赖于`sum`变量。然而，这种情况通常会被着色器编译器检测到，并优化成一个使用指令级并行的版本。以下代码是编译前代码的结果机器代码的高级代码等效。
- en: '[PRE3]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the compiler would recognize that it can fetch the four values
    from memory in parallel and complete the summation once all four have been fetched
    independently via thread-level parallelism. This can save a lot of time relative
    to performing the four fetches one after another.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器会认识到它可以并行从内存中获取四个值，并在所有四个值都独立通过线程级并行性获取后完成求和。这相对于依次执行四个获取可以节省大量时间。
- en: However, long chains of data dependency that cannot be compiled away can absolutely
    murder shader performance. If we create a strong data dependency in our shader's
    source code, then it has no freedom to make any optimizations. For example, the
    following data dependency would be painful on performance, as one step literally
    cannot be completed without waiting on another to fetch data, since sampling each
    texture requires sampling another texture beforehand, and the compiler cannot
    assume that the data hasn't changed in the meantime.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无法编译消除的长链数据依赖关系绝对会摧毁着色器的性能。如果我们在我们着色器源代码中创建一个强大的数据依赖，那么它就没有自由去进行任何优化。例如，以下的数据依赖会对性能造成痛苦，因为一个步骤实际上不能完成，除非等待另一个步骤去获取数据，因为采样每个纹理都需要先采样另一个纹理，而编译器无法假设数据在此期间没有发生变化。
- en: 'The following code represents a very strong data dependency between instructions
    since each relies on texture data being sampled from the previous instruction:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示指令之间存在非常强的数据依赖，因为每个指令都依赖于从上一个指令中采样到的纹理数据：
- en: '[PRE4]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Strong data dependencies such as these should be avoided whenever possible.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应尽可能避免这种强大的数据依赖。
- en: Surface Shaders
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表面着色器
- en: Unity's Surface Shaders are a simplified form of fragment shaders, allowing
    Unity developers to get to grips with shader programming in a more simplified
    fashion. The Unity Engine takes care of converting our Surface Shader code for
    us, abstracting away some of the optimization opportunities we have just covered.
    However, it does provide some miscellaneous values that can be used as replacements,
    which reduce accuracy but simplify the mathematics in the resulting code. Surface
    Shaders are designed to handle the general case fairly efficiently, but optimization
    is best achieved with a personal touch by writing our own shaders.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的表面着色器是片段着色器的一种简化形式，允许Unity开发者以更简化的方式掌握着色器编程。Unity引擎会为我们处理转换我们的表面着色器代码，抽象掉我们刚刚提到的某些优化机会。然而，它确实提供了一些可以用来替换的杂项值，这些值降低了精度但简化了结果代码中的数学。表面着色器旨在高效地处理一般情况，但最佳优化是通过编写我们自己的着色器来实现，带有个人风格。
- en: The `approxview` attribute will approximate the view direction, saving costly
    operations. The `halfasview` attribute will reduce the precision of the view vector,
    but beware of its effect on mathematical operations involving multiple-precision
    types. The `noforwardadd` attribute will limit the shader to only considering
    a single directional light, reducing draw calls, since the shader will render
    in only a single pass, and lighting complexity. Finally, the `noambient` attribute
    will disable ambient lighting in the shader, removing some extra mathematical
    operations that we may not need.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`approxview` 属性将近似视图方向，节省昂贵的操作。`halfasview` 属性将降低视图向量的精度，但要注意其对涉及多精度类型的数学运算的影响。`noforwardadd`
    属性将限制着色器只考虑单一方向光源，减少绘制调用，因为着色器将只进行一次渲染，并降低光照复杂性。最后，`noambient` 属性将在着色器中禁用环境光照，移除一些可能不需要的额外数学运算。'
- en: Use shader-based LOD
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于着色器的LOD
- en: We can force Unity to render distant objects using simpler shaders, which can
    be an effective way of saving Fill Rate, particularly if we're deploying our game
    onto multiple platforms or supporting a wide range of hardware capability. The
    `LOD` keyword can be used in the shader to set the onscreen size factor that the
    shader supports. If the current LOD level does not match this value, it will drop
    to the next fallback shader and so on until it finds the shader that supports
    the given size factor. We can also change a given shader object's LOD value at
    runtime using the `maximumLOD` property.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制Unity使用更简单的着色器渲染远距离对象，这可以是一种有效的节省填充率的方法，尤其是如果我们将游戏部署到多个平台或支持广泛的硬件能力时。可以在着色器中使用`LOD`关键字来设置着色器支持的屏幕尺寸因子。如果当前LOD级别不匹配此值，它将降级到下一个后备着色器，依此类推，直到找到支持给定尺寸因子的着色器。我们还可以在运行时使用`maximumLOD`属性更改给定着色器对象的LOD值。
- en: This feature is similar to the mesh-based LOD covered earlier and uses the same
    LOD values for determining object form factor, so it should be configured as such.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能与之前介绍的基于网格的LOD类似，并使用相同的LOD值来确定对象形状因子，因此应按此方式配置。
- en: Check out [https://docs.unity3d.com/Manual/SL-ShaderLOD.html](https://docs.unity3d.com/Manual/SL-ShaderLOD.html) in
    the Unity documentation for more information on shader-based LOD.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有关基于着色器的LOD的更多信息，请参阅Unity文档中的[https://docs.unity3d.com/Manual/SL-ShaderLOD.html](https://docs.unity3d.com/Manual/SL-ShaderLOD.html)。
- en: Using less texture data
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更少的纹理数据
- en: This approach is simple, straightforward, and always a good idea to consider.
    Reducing texture quality, either through resolution or bit rate, is not ideal
    for graphical quality, but we can sometimes get away with using 16-bit textures
    without any noticeable degradation.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单直接，始终是一个好主意考虑。通过分辨率或比特率降低纹理质量，对图形质量来说并不理想，但我们有时可以使用16位纹理而不会出现任何明显的降级。
- en: Mipmaps (explored in Chapter 4, * Optimizing* * Your Art Assets*) are another
    excellent way of reducing the amount of texture data being pushed back and forth
    between VRAM and the Texture Cache. Note that the Scene window has a Mipmaps shading
    mode, which will highlight textures in our scene blue or red, depending on whether
    the current texture scale is appropriate for the current Scene window's camera
    position and orientation. This will help identify what textures are good candidates
    for further optimization.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Mipmaps（在第4章“优化您的艺术资源”中探讨）是减少VRAM和纹理缓存之间来回传输的纹理数据量的另一种优秀方法。请注意，场景窗口有一个Mipmaps着色模式，它将根据当前纹理比例是否适合当前场景窗口的相机位置和方向，将场景中的纹理以蓝色或红色突出显示。这将有助于识别哪些纹理是进一步优化的良好候选者。
- en: Testing different GPU texture compression formats
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试不同的GPU纹理压缩格式
- en: As you learned in Chapter 4, *Optimizing Your Art Assets*, there are different
    texture compression formats, which can reduce our application's disk footprint
    (executable file size), runtime CPU, and RAM usage. These compression formats
    are designed to support GPU architecture for the given platform. There are many
    different formats, such as DXT, PVRTC, ETC, and ASTC, but only a handful of these
    are available on a given platform.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在第4章“优化您的艺术资源”中学习到的，存在不同的纹理压缩格式，这些格式可以减少我们应用程序的磁盘占用（可执行文件大小）、运行时CPU和RAM使用。这些压缩格式旨在支持给定平台的GPU架构。有众多不同的格式，如DXT、PVRTC、ETC和ASTC，但在特定平台上只有少数几种可用。
- en: By default, Unity will pick the best compression format determined by the Compression
    setting for a texture file. If we drill down into platform-specific options for
    a given texture file, then different compression type options will be available,
    listing the different texture formats the given platform supports. We may be able
    to find some space or performance savings by overriding the default choices for
    compression.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity将选择由纹理文件的压缩设置确定的最佳压缩格式。如果我们深入到特定纹理文件的平台特定选项，那么将提供不同的压缩类型选项，列出给定平台支持的纹理格式。我们可能可以通过覆盖默认的压缩选择来找到一些空间或性能上的节省。
- en: Although beware that if we're at the point where individually tweaking texture
    compression techniques is necessary, then hopefully we have already exhausted
    all other options for reducing memory bandwidth. By going down this road, we would
    be committing ourselves to support many different devices each in their own specific
    way. Many developers would prefer to keep things simple with a general solution
    instead of personal customization and time-consuming handiwork for small performance
    gains.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然要注意，如果我们已经到了需要单独调整纹理压缩技术的地步，那么我们可能已经用尽了所有其他减少内存带宽的选项。沿着这条路走下去，我们将承诺支持许多不同的设备，每种设备都有其特定的方式。许多开发者宁愿使用通用解决方案来保持事情简单，而不是进行个人定制和耗时的人工操作以换取微小的性能提升。
- en: Check out the Unity documentation for an overview of all of the different texture
    formats available and which formats Unity prefers by default at [https://docs.unity3d.com/Manual/class-TextureImporterOverride.html](https://docs.unity3d.com/Manual/class-TextureImporterOverride.html).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Unity文档以了解所有可用的不同纹理格式以及Unity默认首选的格式，请参阅[https://docs.unity3d.com/Manual/class-TextureImporterOverride.html](https://docs.unity3d.com/Manual/class-TextureImporterOverride.html)。
- en: In older versions of Unity, all formats were exposed for Advanced texture types,
    but if the platform did not support the given type, it would be handled at the
    software level. In other words, the CPU would need to stop and recompress the
    texture to the desired format the GPU wants, as opposed to the GPU taking care
    of it with a specialized hardware chip. Unity Technologies decided to remove this
    capability in more recent versions so that we can't accidentally cause these problems.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的旧版本中，所有格式都对外部高级纹理类型开放，但如果平台不支持给定的类型，它将在软件级别进行处理。换句话说，CPU需要停止并重新压缩纹理到GPU想要的格式，而不是由GPU通过专门的硬件芯片来处理。Unity
    Technologies决定在较新版本中移除此功能，以避免意外引发这些问题。
- en: Minimizing texture swapping
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化纹理交换
- en: This one is fairly straightforward. If memory bandwidth is a problem, then we
    need to reduce the amount of texture sampling we're doing. There aren't really
    any special tricks to exploit here since memory bandwidth is all about throughput,
    so the primary metric under consideration is the volume of data we're pushing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点相当直接。如果内存带宽有问题，那么我们需要减少我们正在进行的纹理采样的数量。在这里实际上没有特别的技巧可以利用，因为内存带宽完全是关于吞吐量，所以主要考虑的指标是我们推送的数据量。
- en: One way to reduce volume is to simply lower texture resolution and, hence, quality.
    This is obviously not ideal, so another approach is to find clever ways to reuse
    textures on different meshes, but using different Material and shader properties.
    For instance, a properly darkened brick texture may appear to look like a stone
    wall instead. Of course, this will require different Render States, and hence,
    we won't save on draw calls, but it could reduce memory bandwidth consumption.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 减少体积的一种方法是通过简单地降低纹理分辨率和质量来实现。这显然不是理想的选择，因此另一种方法是找到巧妙的方法在不同的网格上重复使用纹理，但使用不同的材质和着色器属性。例如，一个适当变暗的砖块纹理看起来可能像一块石头墙。当然，这将需要不同的渲染状态，因此我们不会节省绘制调用，但它可以减少内存带宽消耗。
- en: Did you ever notice how clouds and bushes looked exactly the same in Super Mario
    Bros but with different colors? This is the same concept.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾注意到在超级马里奥兄弟中云和灌木看起来完全一样，但颜色不同？这是同样的概念。
- en: There could also be ways to combine textures into atlases to reduce the number
    of swaps needed. If there are a group of textures that are always used together
    at similar times, then they could potentially be merged together. This could save
    the GPU from having to pull in separate texture files over and over again during
    the same frame.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 还可能有将纹理组合到图集中的方法来减少所需的交换次数。如果有几组纹理总是在相似的时间一起使用，那么它们可能可以合并在一起。这可以节省GPU在相同帧内反复拉取单独的纹理文件。
- en: Finally, removing textures from the application entirely is always the last
    resort option we could employ.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，完全从应用程序中移除纹理始终是我们能采取的最后手段。
- en: VRAM limits
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VRAM限制
- en: One last consideration related to textures is how much VRAM we have available.
    Most texture transfer from CPU to GPU occurs during initialization, but can also
    occur when a non-existent texture is first required by the current view. This
    process is normally asynchronous and will result in a blank texture being used
    until the full texture is ready for rendering (refer to Chapter 4, *Optimizing
    Your Art Assets*, to note that this assumes read/write access is disabled for
    the texture). As such, we should avoid introducing new textures at runtime too
    frequently.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与纹理相关的一个最后考虑因素是我们有多少可用的VRAM。大多数从CPU到GPU的纹理传输发生在初始化期间，但也可以在当前视图首次需要不存在的纹理时发生。这个过程通常是异步的，并且会导致使用空白纹理，直到完整的纹理准备好进行渲染（参考第4章，*优化您的艺术资产*，注意这假设对纹理的读写访问已被禁用）。因此，我们应该避免在运行时过于频繁地引入新的纹理。
- en: Preloading textures with hidden GameObjects
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐藏的GameObject预加载纹理
- en: The blank texture that is used during asynchronous texture loading can be jarring
    when it comes to game quality. We would like a way to control and force the texture
    to be loaded from disk to RAM and then to VRAM before it is actually needed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步纹理加载期间使用的空白纹理在游戏质量方面可能会令人不快。我们希望有一种方法来控制和强制纹理从磁盘加载到RAM，然后再加载到VRAM，在它实际需要之前。
- en: A common workaround is to create a hidden `GameObject` that uses the texture
    and place it somewhere in the scene on the route that the player will take toward
    the area where it is actually needed. As soon as the player looks at that object,
    the texture is needed by the Rendering Pipeline (even if it's technically hidden),
    it will begin the process of copying the data from RAM to VRAM. This is a little
    clunky but easy to implement and works sufficiently well in most cases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是创建一个使用纹理的隐藏`GameObject`，并将其放置在场景中玩家将前往的区域的路径上。一旦玩家看向该对象，渲染管线就需要该纹理（即使它技术上被隐藏），它将开始从RAM复制数据到VRAM的过程。这有点笨拙，但易于实现，并且在大多数情况下效果足够好。
- en: 'We can also control such behavior via Script code by changing a Material''s
    `texture` property:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过脚本代码通过更改材质的`texture`属性来控制这种行为：
- en: '[PRE5]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Avoid texture thrashing
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免纹理抖动
- en: In the rare event that too much texture data is loaded into VRAM, and the required
    texture is not present, the GPU will need to request it from RAM and overwrite
    one or more existing textures to make room for it. This is likely to worsen over
    time as the memory becomes fragmented, and it introduces a risk that the texture
    just flushed from VRAM needs to be pulled again within the same frame. This will
    result in a serious case of memory thrashing and should be avoided at all costs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果加载到VRAM的纹理数据过多，并且所需的纹理不存在，GPU将需要从RAM请求它，并覆盖一个或多个现有纹理以腾出空间。随着时间的推移，内存变得碎片化，这可能会加剧问题，并且它引入了风险，即刚刚从VRAM中清除的纹理需要在同一帧内再次拉取。这将导致严重的内存抖动，应该不惜一切代价避免。
- en: This is less of a concern on modern consoles such as the PS4, Xbox One, and
    Wii U since they share a common memory space for both CPU and GPU. This design
    is a hardware-level optimization, given the fact that the device is always running
    a single application, and almost always rendering 3D graphics. However, most other
    platforms must share time and space with multiple applications, where a GPU is
    merely an optional device and is not always present. They, therefore, feature
    separate memory spaces for the CPU and GPU, and we must ensure that the total
    texture usage at any given moment remains below the available VRAM of the target
    hardware.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代控制台如PS4、Xbox One和Wii U上，这个问题不太令人担忧，因为它们共享CPU和GPU的公共内存空间。这种设计是硬件级别的优化，考虑到设备始终运行单个应用程序，并且几乎总是渲染3D图形。然而，大多数其他平台必须与多个应用程序共享时间和空间，其中GPU只是一个可选设备，并不总是存在。因此，它们为CPU和GPU提供独立的内存空间，我们必须确保在任何给定时刻的总纹理使用量都低于目标硬件可用的VRAM。
- en: Note that this thrashing is not precisely the same as hard disk thrashing, where
    memory is copied back and forth between the main memory and the virtual memory
    (the swap file), but it is analogous. In either case, data is being unnecessarily
    copied back and forth between two regions of memory because too much data is being
    requested in too short a time period for the smaller of the two memory regions
    to hold it all.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种抖动并不完全等同于硬盘抖动，其中内存在主内存和虚拟内存（交换文件）之间来回复制，但它具有相似性。在任何情况下，数据都在两个内存区域之间不必要地来回复制，因为请求的数据量太大，以至于较小的内存区域无法容纳。
- en: Thrashing such as this can be a common cause of dreadful rendering performance
    when games are ported from modern consoles to desktop platforms and should be
    treated with care.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏从现代游戏机移植到桌面平台时，这种类型的过度渲染可能是导致糟糕渲染性能的常见原因，因此应该谨慎处理。
- en: Avoiding this behavior may require customizing texture quality and file sizes
    on a per-platform and per-device basis. Be warned that some players are likely
    to notice these inconsistencies if we're dealing with hardware from the same console
    or desktop GPU generation. As many of us will know, even small differences in
    hardware can lead to a lot of apples-versus-oranges comparisons, but hardcore
    gamers tend to expect a similar level of quality across the board.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种行为可能需要根据每个平台和每个设备定制纹理质量和文件大小。请注意，如果我们处理的是同一台游戏机或桌面GPU代系的硬件，一些玩家可能会注意到这些不一致性。正如我们许多人所知，即使是硬件上的微小差异也可能导致大量的苹果与橙子比较，但硬核玩家通常期望在所有方面都能达到相似的质量水平。
- en: Lighting optimization
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照优化
- en: We covered the theory of lighting behavior earlier in this chapter, so let's
    run through some techniques we can use to improve lighting costs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们已经讨论了光照行为理论，现在让我们回顾一下我们可以使用的技巧来提高光照成本。
- en: Using real-time shadows responsibly
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负责任地使用实时阴影
- en: As mentioned previously, shadowing can easily become one of the largest consumers
    of draw calls and Fill Rate, so we should spend the time to tweak these settings
    until we get the performance and/or graphical quality we need.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，阴影很容易成为消耗绘制调用和填充率最大的因素之一，因此我们应该花时间调整这些设置，直到我们获得所需的性能和/或图形质量。
- en: 'There are multiple important settings for shadowing that can be found under
    Edit | Project Settings | Quality | Shadows. As far as the Shadows option is concerned, Soft
    Shadows are expensive, Hard Shadows are cheap, and No Shadows are free. Shadow
    Resolution, Shadow Projection, Shadow Distance, and Shadow Cascades are also important
    settings that affect the performance of our shadows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在“编辑 | 项目设置 | 质量 | 阴影”下可以找到多个重要的阴影设置。就阴影选项而言，软阴影成本较高，硬阴影成本较低，无阴影则是免费的。阴影分辨率、阴影投影、阴影距离和阴影级联也是影响我们阴影性能的重要设置：
- en: '![](img/0a9db04b-a94b-4c06-bf69-2a5fe8d7e102.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a9db04b-a94b-4c06-bf69-2a5fe8d7e102.png)'
- en: Shadow Distance is a global multiplier for runtime shadow rendering. There is
    little point in rendering shadows at a great distance from the camera, so this
    setting should be configured specific to our game and how much shadowing we expect
    to witness during gameplay. It is also a common setting that is exposed to the
    user in an options screen, so they can choose how far to render shadows to get
    the game's performance to match their hardware (at least on desktop machines).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影距离是运行时阴影渲染的全局乘数。在相机远处渲染阴影几乎没有意义，因此这个设置应根据我们的游戏和预期在游戏过程中看到的阴影量进行配置。它也是一个常见的设置，通常在选项屏幕中向用户公开，他们可以选择渲染阴影的距离以使游戏性能与他们的硬件相匹配（至少在桌面机器上）。
- en: Higher values of Shadow Resolution and Shadow Cascades will increase our memory
    bandwidth and Fill Rate consumption. Both of these settings can help to curb the
    effects of artifacts generated by shadow rendering, but at the cost of much larger
    shadow map texture sizes, costing increased memory bandwidth and VRAM.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 高阴影分辨率和阴影级联的值会增加我们的内存带宽和填充率消耗。这两个设置都可以帮助减轻由阴影渲染产生的伪影效果，但代价是更大的阴影贴图纹理尺寸，这会增加内存带宽和VRAM的使用。
- en: The Unity documentation contains an excellent summary of the topic of the aliasing
    effect of shadow maps and how the Shadow Cascades feature helps to solve the problem
    at [http://docs.unity3d.com/Manual/DirLightShadows.html](http://docs.unity3d.com/Manual/DirLightShadows.html).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Unity文档中对阴影贴图别名效应的总结以及阴影级联功能如何帮助解决这个问题有很好的概述，请参阅[http://docs.unity3d.com/Manual/DirLightShadows.html](http://docs.unity3d.com/Manual/DirLightShadows.html)。
- en: It's worth noting that Soft Shadows do not consume any more memory or CPU overhead
    relative to Hard Shadows, as the only difference is a more complex shader. This
    means that applications with enough Fill Rate to spare can enjoy the improved
    graphical fidelity of Soft Shadows.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，与硬阴影相比，软阴影不会消耗更多的内存或CPU开销，因为唯一的区别是更复杂的着色器。这意味着具有足够填充率的程序可以享受软阴影带来的改进的图形保真度。
- en: Using culling masks
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用剔除掩码
- en: A `Light` component's Culling Mask property is a layer-based mask that can be
    used to limit the objects that will be affected by the given light. This is an
    effective way of reducing lighting overhead, assuming that the layer interactions
    also make sense with how we are using layers for physics optimization. Objects
    can only be a part of a single layer, and reducing physics overhead probably trumps
    lighting overhead in most cases; hence, if there is a conflict, then this may
    not be the ideal approach.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`Light`组件的裁剪遮罩属性是一个基于层的遮罩，可以用来限制受给定光照影响的物体。这是一个有效减少光照开销的方法，假设层交互也符合我们使用层进行物理优化的方式。物体只能属于单个层，并且减少物理开销在大多数情况下可能比减少光照开销更重要；因此，如果存在冲突，那么这种方法可能不是最佳选择。'
- en: Note that there is limited support for Culling Masks when using Deferred Shading.
    Due to the way it treats lighting in a very global fashion, only four Layers can
    be disabled from the mask, limiting our ability to optimize its behavior.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用延迟着色时，对裁剪遮罩的支持有限。由于它以非常全局的方式处理光照，遮罩中只能禁用四个层，这限制了优化其行为的能力。
- en: Using baked lightmaps
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用烘焙光照贴图
- en: Baking lighting and shadowing into a scene is significantly less processor-intensive
    than generating them at runtime. The downside is the added application disk footprint,
    memory consumption, and potential for memory bandwidth abuse. Ultimately, unless
    a game's lighting effects are being handled exclusively through the legacy Vertex-Lit
    Shading format or through a single `DirectionalLight` instance, then it should
    probably include lightmapping somewhere to make some huge budget savings on lighting
    calculations. Relying entirely on real-time lighting and shadows is a recipe for
    disaster due to the performance costs they are likely to inflict.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将光照和阴影烘焙到场景中，与在运行时生成它们相比，处理器消耗显著降低。缺点是增加了应用程序的磁盘占用、内存消耗和潜在的内存带宽滥用。最终，除非游戏的光照效果完全通过传统的顶点光照着色格式或通过单个`DirectionalLight`实例处理，否则可能应该在某个地方包含光照贴图，以在光照计算上节省大量预算。完全依赖实时光照和阴影可能会导致灾难，因为它们可能带来的性能成本。
- en: Several metrics can affect the cost of lightmapping, however, such as their
    resolution, compression, whether we are using pre-computed real-time GI, and,
    of course, the number of objects in our scene. The lightmapper generates textures
    that span all of the objects marked Lightmap Static in the scene, and, hence,
    the more we have, the more texture data must be generated for them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 几个指标可以影响光照贴图的成本，例如它们的分辨率、压缩、我们是否使用预计算的实时全局光照，以及当然，场景中物体的数量。光照贴图生成覆盖场景中所有标记为光照贴图静态的物体的纹理，因此，我们拥有的越多，必须为它们生成的纹理数据就越多。
- en: This would be an opportunity to make use of additive or subtractive scene loading
    to minimize how many objects need to be processed in each frame. This, of course,
    pulls in even more lightmap data while more than one scene is loaded, so we should
    expect a big bump in memory consumption each time this happens, only to have it
    freed once the old scene is unloaded.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个利用加法或减法场景加载来最小化每帧需要处理的物体数量的机会。当然，当加载多个场景时，这会引入更多的光照贴图数据，因此我们应该预期每次发生这种情况时，内存消耗都会大幅增加，只有在旧场景卸载后才会释放。
- en: Optimizing rendering performance for mobile devices
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化移动设备的渲染性能
- en: Unity's ability to deploy to mobile devices has contributed greatly to its popularity
    among hobbyist, small, and mid-size development teams. As such, it would be prudent
    to cover some approaches that are more beneficial for mobile platforms than for
    desktop and other devices. Let's take a look at a few of these approaches.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Unity部署到移动设备的能力极大地促进了它在业余爱好者、小型和中型开发团队中的普及。因此，明智的做法是介绍一些比桌面和其他设备更有益于移动平台的方法。让我们来看看这些方法中的几个。
- en: Note that any, or all, of the following approaches may eventually become obsolete,
    at least for newer devices. The capabilities of mobile devices have advanced blazingly
    fast, and the following techniques as they apply to mobile devices merely reflect
    conventional wisdom from the last half-decade or so. We should test the assumptions
    behind these approaches to check whether the limitations of mobile devices still
    fit the mobile marketplace.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下任何或所有方法最终可能变得过时，至少对于新设备来说是这样。移动设备的性能已经飞速发展，以下技术作为移动设备的应用，仅仅反映了过去五年左右的常规智慧。我们应该测试这些方法背后的假设，以检查移动设备的限制是否仍然适合移动市场。
- en: Avoiding alpha testing
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免alpha测试
- en: Mobile GPUs haven't quite reached the same levels of chip optimization as desktop
    GPUs, and alpha testing remains a particularly costly task on mobile devices.
    In most cases, it should simply be avoided in favor of alpha blending.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 移动GPU尚未达到桌面GPU相同的芯片优化水平，alpha测试在移动设备上尤其成本高昂。在大多数情况下，应简单地避免alpha测试，转而使用alpha混合。
- en: Minimizing draw calls
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化绘制调用
- en: Mobile applications are more often bottlenecked on draw calls than on Fill Rate.
    Not that Fill Rate concerns should be ignored (nothing should, ever!), but this
    makes it almost necessary for any mobile application of reasonable quality to
    implement mesh combining, batching, and atlasing techniques from the very beginning.
    Deferred Rendering is also the preferred technique, as it fits well with other
    mobile-specific concerns, such as avoiding transparency and having too many animated
    characters, but of course, not all mobile devices and graphics APIs support it.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序在绘制调用上的瓶颈通常比填充率要高。虽然不能忽视填充率的问题（永远不能忽视！），但这几乎使得任何质量合理的移动应用程序在最初就必须实现网格合并、批处理和纹理图集技术。延迟渲染也是首选技术，因为它很好地适应了其他移动特定的问题，例如避免透明度和拥有过多的动画角色，但当然，并非所有移动设备和图形API都支持它。
- en: Check out the Unity documentation for more information on which platforms/APIs
    support Deferred Shading at [https://docs.unity3d.com/Manual/RenderingPaths.html](https://docs.unity3d.com/Manual/RenderingPaths.html).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Unity文档以获取有关哪些平台/API支持延迟着色的更多信息，请访问[https://docs.unity3d.com/Manual/RenderingPaths.html](https://docs.unity3d.com/Manual/RenderingPaths.html)。
- en: Minimizing Material count
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化材质数量
- en: This concern goes hand in hand with the concepts of batching and atlasing. The
    fewer Materials we use, the fewer draw calls required. This strategy will also
    help with concerns relating to VRAM and memory bandwidth, which tend to be very
    limited on mobile devices.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与批处理和纹理图集的概念密切相关。我们使用的材质越少，所需的绘制调用就越少。这种策略还将有助于与VRAM和内存带宽相关的问题，这些在移动设备上通常非常有限。
- en: Minimizing texture size
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化纹理大小
- en: Most mobile devices feature a very small texture cache relative to desktop GPUs.
    There are very few devices on the market still supporting OpenGL ES 1.1 or lower,
    such as the iPhone 3G, but these devices could only support a maximum texture
    size of 1024 x 1024\. Devices supporting OpenGLES 2.0, such as everything from
    the iPhone 3GS to the iPhone 6S, can support textures up to 2048 x 2048\. Finally,
    devices supporting OpenGLES 3.0 or greater, such as devices running iOS 7, can
    support textures up to 4096 x 4096.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面GPU相比，大多数移动设备的纹理缓存非常小。市场上仍然支持OpenGL ES 1.1或更低版本的设备非常少，例如iPhone 3G，但这些设备只能支持最大1024
    x 1024的纹理大小。支持OpenGLES 2.0的设备，例如从iPhone 3GS到iPhone 6S的所有设备，可以支持高达2048 x 2048的纹理。最后，支持OpenGLES
    3.0或更高版本的设备，例如运行iOS 7的设备，可以支持高达4096 x 4096的纹理。
- en: There are way too many Android devices to list here, but the Android developer
    portal gives a handy breakdown of OpenGLES device support. This information is
    updated regularly to help developers to determine supported APIs in the Android
    market at [https://developer.android.com/about/dashboards/index.html](https://developer.android.com/about/dashboards/index.html).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里无法列出所有Android设备，但Android开发者门户提供了一个方便的OpenGLES设备支持的细分。这些信息定期更新，以帮助开发者确定Android市场上支持的API，请访问[https://developer.android.com/about/dashboards/index.html](https://developer.android.com/about/dashboards/index.html)。
- en: "Double-check the device hardware we are targeting to be sure that it supports\
    \ the texture file sizes we wish to use.\P However, later-generation devices are\
    \ never the most common devices in the mobile marketplace. If we wish our game\
    \ to reach a wide audience (increasing its chances of success), then we must be\
    \ willing to support weaker hardware."
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查我们针对的设备硬件，以确保它支持我们希望使用的纹理文件大小。然而，新一代设备永远不会是移动市场上的最常见设备。如果我们希望我们的游戏能够触及广泛的受众（增加其成功的可能性），那么我们必须愿意支持较弱的硬件。
- en: Note that textures that are too large for the GPU will be downscaled by the
    CPU during initialization. This wastes valuable loading time and is going to leave
    us with unintended loss of quality due to an uncontrolled reduction in resolution.
    This makes texture reuse of paramount importance for mobile devices due to the
    limited VRAM and texture cache sizes available.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于GPU无法处理的过大纹理，CPU将在初始化过程中将其降级。这浪费了宝贵的加载时间，并可能导致由于分辨率的无控制降低而造成的不预期的质量损失。这使纹理重用在移动设备上变得极为重要，因为可用的VRAM和纹理缓存大小有限。
- en: Making textures square and the power-of-two
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使纹理成为正方形和2的幂次
- en: We have already covered this topic in Chapter 4, *Optimizing Your Art Assets*,
    but it is worth revisiting the subject of GPU-level Texture Compression. The GPU
    will find it difficult, or simply be unable, to compress the texture if it is
    not in a square format, so make sure that you stick to the common development
    convention and keep things square and sized to a power-of-two.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第4章“优化您的艺术资产”中讨论了这一主题，但回顾GPU级纹理压缩的问题仍然很有价值。如果纹理不是正方形格式，GPU将难以压缩纹理，或者根本无法压缩，因此请确保您坚持常见的开发约定，保持正方形并按2的幂次大小进行。
- en: Using the lowest possible precision formats in shaders
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在着色器中使用最低可能的精度格式
- en: Mobile GPUs are particularly sensitive to precision formats in its shaders,
    so the smallest formats should be used, such as `half`. On a related note, precision
    format conversion should be avoided at all costs for the same reason.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 移动GPU对其着色器中的精度格式特别敏感，因此应使用最小的格式，例如`half`。相关地，出于同样的原因，应尽量避免进行精度格式转换。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you've made it this far without skipping ahead, then congratulations are
    in order. That was a lot of information to absorb for just one subsystem of the
    Unity Engine, but then it is clearly the most complicated of them all, requiring
    a matching depth of explanation. Hopefully, you've learned a lot of approaches
    to help you to improve your rendering performance and enough about the Rendering
    Pipeline to know how to use them responsibly.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有跳过前面的内容，那么恭喜您。对于Unity引擎的一个子系统来说，这已经是一个需要吸收大量信息的内容，但显然它是其中最复杂的，需要相应的深度解释。希望您已经学到了许多有助于提高渲染性能的方法，以及足够关于渲染管道的知识，以便能够负责任地使用它们。
- en: By now, we should be used to the idea that, except for algorithm improvements,
    every performance enhancement we implement will come with some related cost that
    we must be willing to bear for the sake of removing one bottleneck. We should
    always be ready to implement multiple techniques until we've squashed them all,
    and potentially spend a lot of additional development time to implement and test
    some performance-enhancing features.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们应该已经习惯了这样的想法，即除了算法改进之外，我们实施的每一项性能提升都将带来一些相关的成本，我们必须愿意承担这些成本，以消除一个瓶颈。我们应该随时准备实施多种技术，直到我们全部克服它们，并且可能需要花费大量的额外开发时间来实施和测试一些性能增强功能。
- en: In the next chapter, let's bring performance optimization into the modern era
    by exploring some performance improvements we can apply to VR and AR projects.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，让我们通过探索可以应用于VR和AR项目的性能改进，将性能优化带入现代时代。
