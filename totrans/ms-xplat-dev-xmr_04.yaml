- en: Chapter 4. Local Data Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 本地数据管理
- en: 'In this chapter, you will find patterns and techniques to efficiently use,
    manage, and roam data on mobile devices. It also investigates SQLite database
    creation and usage strategies. The chapter is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将找到高效使用、管理和漫游移动设备上数据的模式和技巧。它还探讨了SQLite数据库的创建和使用策略。本章分为以下部分：
- en: Data in mobile applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序中的数据
- en: Application data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序数据
- en: Local filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统
- en: Data roaming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据漫游
- en: SQLite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: Patterns and best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Backup/roaming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份/漫游
- en: Data in mobile applications
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动应用程序中的数据
- en: The term "data" can refer to different types of information and storage locations
    in mobile app development. It can be used to describe a volatile state that is
    created and destroyed each time a view in the application is used, or it might
    refer to persisted settings and configuration information that are required to
    run the application, or even the data stored in the local filesystem. Each type
    of data is created and persisted or destroyed throughout the lifecycle of the
    application or a view in the application. We can talk about four distinct groups
    for this discussion.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序开发中，“数据”一词可以指代不同类型的信息和存储位置。它可以用来描述每次使用应用程序中的视图时创建和销毁的易失状态，或者它可能指的是运行应用程序所需的持久设置和配置信息，甚至可能是存储在本地文件系统中的数据。每种类型的数据在应用程序或应用程序中的视图的生命周期中创建、持久化或销毁。我们可以就这一点讨论四个不同的组。
- en: Each data type is stored and accessed from different locations and each location
    has its own unique restriction and access models.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数据类型都存储和访问于不同的位置，每个位置都有其独特的限制和访问模型。
- en: '![Data in mobile applications](img/B04693_04_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![移动应用程序中的数据](img/B04693_04_01.jpg)'
- en: Data type storage locations
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型存储位置
- en: State
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: Mobile applications are generally *stateful*. Transient data that is used to
    visualize items on the UI or the data created by the user of the application falls
    into this category. The purpose of state is to maintain a consistent app experience
    across sessions, devices, and/or process lifecycle. Application settings or the
    current state of the view is a good example for this category.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序通常是**有状态的**。用于在UI上可视化项目或由应用程序用户创建的数据属于这一类别。状态的目的在于在会话、设备以及/或进程生命周期中保持一致的app体验。应用程序设置或视图的当前状态是这一类别的良好例子。
- en: App data
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数据
- en: App data generally refers to the data that is essential for the execution of
    the application. This data is created, stored, and managed by the application
    itself. It can be structured data storage or it might be the cached version of
    online application resources. This type of data can be raw, in the form of a SQLite
    database, or stored by other facilities on the current device by the current application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据通常指的是执行应用程序所必需的数据。这些数据由应用程序本身创建、存储和管理。它可以是结构化数据存储，也可能是在线应用程序资源的缓存版本。这类数据可以是原始数据，以SQLite数据库的形式存在，或者由当前应用程序在当前设备上通过其他设施存储。
- en: App data stored in different locations can survive through different stages
    of an application lifecycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据存储在不同的位置可以经历应用程序生命周期的不同阶段。
- en: '![App data](img/B04693_04_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![应用数据](img/B04693_04_02.jpg)'
- en: App data lifecycle
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据生命周期
- en: Local files
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地文件
- en: Local files are the stored items in the local filesystem. These files are generally
    created outside the lifecycle and/or scope of the application and are only made
    use of by the application. For instance, a photo taken by the user can later on
    be used by the mail client app as an attachment item.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本地文件是存储在本地文件系统中的项目。这些文件通常在应用程序的生命周期和/或作用域之外创建，并且仅由应用程序使用。例如，用户拍摄的照片可以后来被邮件客户端应用程序用作附件项。
- en: External data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部数据
- en: External data can be described as the combination of all the other data sources
    that are used by the application during runtime. This can include network or web
    resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数据可以描述为应用程序在运行时使用的所有其他数据源的组合。这可以包括网络或网络资源。
- en: Application data
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序数据
- en: Application data makes up the core of the data storage on Xamarin platforms
    and Windows Runtime. This data is specific to your application. It lives and eventually
    dies with it, and in most cases it is not relevant or even accessible by other
    applications running on the same device or even by the user who is using the application
    (at least directly).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序数据构成了Xamarin平台和Windows Runtime上数据存储的核心。这些数据专属于您的应用程序。它们与它共存，最终消亡，在大多数情况下，它们对运行在同一设备上的其他应用程序甚至使用该应用程序的用户（至少直接）来说不相关或不可访问。
- en: The application has unrestricted access to application data, or so-called isolated
    storage, without having to ask for permission from the user or add a declaration
    and can (in most cases) write, read, and query items in this storage according
    to the type of the application data location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以无限制地访问应用程序数据，或所谓的隔离存储，无需请求用户权限或添加声明，并且可以在大多数情况下根据应用程序数据位置的类型写入、读取和查询此存储中的项目。
- en: Installation directory
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装目录
- en: The installation directory is the innermost part of the accessible data storages
    and is the most intimate location for the application. Access to this location
    by the application is unrestricted but read-only. The access models on iOS, Android,
    and Windows Runtime vary greatly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装目录是可访问数据存储的最内层部分，是应用程序最亲密的位置。应用程序对此位置的访问不受限制，但仅限于读取。iOS、Android和Windows Runtime上的访问模型差异很大。
- en: Android
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android
- en: For Xamarin.Android applications, the installation directory essentially refers
    to the compressed Android package (the `.apk` file), and the defined subdivisions
    are just abstractions of folders packaged and added to the manifest during the
    compilation. The installation directory and subfolders can be accessed in various
    ways.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Xamarin.Android应用程序，安装目录本质上指的是压缩的Android包（即`.apk`文件），而定义的子目录仅仅是打包并添加到编译时清单中的文件夹的抽象。安装目录和子目录可以通过多种方式访问。
- en: '![Android](img/B04693_04_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Android](img/B04693_04_03.jpg)'
- en: Android package and the project tree
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Android包和项目树
- en: The most important location in the installation directory for Android apps is
    the `Resources` folder. Resources can be generalized as the UI-related items that
    will be used to render the views of the application. One of the resource types
    that can be included in the application package is the `drawable` type. Drawable
    resources are image resources and can exist in alternate flavors for different
    conditions and devices that the application runs on (see [Chapter 9](ch09.html
    "Chapter 9. Reusable UI Patterns"), *Reusable UI Patterns*). In order for the
    compiler to include the resources in the application package, the build action
    of each item in this folder has to be set to `AndroidResource`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装目录中对于Android应用程序最重要的位置是`Resources`文件夹。资源可以概括为用于渲染应用程序视图的UI相关项。可以包含在应用程序包中的资源类型之一是`drawable`类型。Drawable资源是图像资源，可以根据应用程序运行的不同条件和使用设备存在不同的版本（参见[第9章](ch09.html
    "第9章。可重用UI模式")，*可重用UI模式*）。为了使编译器将资源包含到应用程序包中，此文件夹中每个项目的构建操作必须设置为`AndroidResource`。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to mention that Android packages do not allow filenames to contain
    uppercase characters, and yet Xamarin developers can include these types of files
    in their projects. Xamarin.Android deals with this by renaming the resources during
    compilation (for example, see the `XamarinLogo.png` file in the `drawable` folder).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别指出的是，Android包不允许文件名包含大写字母，而Xamarin开发者可以将这类文件包含到他们的项目中。Xamarin.Android通过在编译期间重命名资源来处理这个问题（例如，参见`drawable`文件夹中的`XamarinLogo.png`文件）。
- en: 'Programmatically, they can be accessed using the generated `Resource` class
    to get the assigned resource ID and the `Resources` static class that provides
    access methods, or by using the `android.resource://` protocol and the resource
    identifier (or the package name together with the resource name). However, in
    most scenarios, using only the assigned id to use the resources with UI controls
    will suffice. The code is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程方式，可以使用生成的`Resource`类来获取分配的资源ID，或者使用提供访问方法的`Resources`静态类，或者使用`android.resource://`协议和资源标识符（或者包名与资源名称一起）。然而，在大多数情况下，仅使用分配的ID来使用与UI控件相关的资源就足够了。代码如下：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the declarative UI (layouts), the drawable resources folder can be accessed
    with the alias `@drawable`. Similarly, string resources can be accessed with `@string`.
    The code is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式UI（布局）中，可绘制资源文件夹可以通过别名`@drawable`访问。同样，字符串资源可以通过`@string`访问。代码如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another important location in the installation directory is the `Assets` folder.
    The `Assets` folder is used for any raw assets that you want deployed together
    with your application (other than the `Resources` folder) and not to be processed
    by the compiler or the runtime. Assets can be retrieved with the `AssetManager`
    class, and the `Assets` property in the `Activity` class can be used to access
    the `AssetManager` class. The code is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装目录中的另一个重要位置是`Assets`文件夹。`Assets`文件夹用于存放您希望与应用程序一起部署的任何原始资源（除了`Resources`文件夹），并且不会被编译器或运行时处理。可以使用`AssetManager`类检索资源，并且`Activity`类中的`Assets`属性可以用来访问`AssetManager`类。代码如下：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other resource types in the installation location, such as layouts, raw, and
    string resources can also be accessed in the described manner using the abstraction
    provided by Android runtime.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装位置中的其他资源类型，如布局、原始和字符串资源，也可以使用Android运行时提供的抽象以这种方式访问。
- en: iOS
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS
- en: The building units of an iOS application, such as executable code and associated
    resources, are contained in a so-called **bundle**. A bundle is part of the application
    sandbox and the path to the bundle is determined by the operating system during
    installation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: iOS应用程序的构建单元，如可执行代码和相关资源，包含在一个所谓的**包**中。包是应用程序沙盒的一部分，包的路径在安装期间由操作系统确定。
- en: Similar to Android applications, iOS application projects can also include compiled
    image resources (bundle resources). These items are then accessed using the abstraction
    layer provided by the runtime.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android应用程序类似，iOS应用程序项目也可以包含编译后的图像资源（包资源）。然后，使用运行时提供的抽象层来访问这些项。
- en: 'For instance, in order to access an image resource from the bundle directory,
    you would need to call the `FromFile` method on the `UIImage` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了从包目录中访问图像资源，您需要在`UIImage`类上调用`FromFile`方法：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to the access model in Android applications, the bundle container is
    read-only and should not be modified. The simple reason for this is that iOS application
    bundles are signed by the publisher key and any change in the bundle container
    would invalidate the package signature.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android应用程序的访问模型类似，包容器是只读的，不应修改。简单的原因是iOS应用程序包由发布者密钥签名，任何对包容器的更改都会使包签名无效。
- en: Local storage
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地存储
- en: There is a both in the second part as well. Android and iOS runtimes provide
    different storage facilities for application data both in the form of structured
    data and raw content files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分也有类似的情况。Android和iOS运行时为应用程序数据提供不同的存储设施，无论是结构化数据还是原始内容文件。
- en: Android
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android
- en: On the Android platform, **Shared Preferences** and **Internal Storage** are
    the two local storage options. Both of these options have different access models
    and your applications have read/write access to these locations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，**Shared Preferences**和**Internal Storage**是两种本地存储选项。这两个选项有不同的访问模型，并且您的应用程序对这些位置有读写访问权限。
- en: Using `SharedPreferences` is the most basic way of storing data on the Android
    platform. This class provides a simple persistent dictionary implementation that
    allows the application to create, modify, and retrieve primitive data types (that
    is, `boolean`, `float`, `int`, `long`, `string`, and `string_array`) and their
    associated key. The size on these values is only restricted by the data type itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上使用`SharedPreferences`是存储数据的最基本方式。此类提供了一个简单的持久字典实现，允许应用程序创建、修改和检索原始数据类型（即`boolean`、`float`、`int`、`long`、`string`和`string_array`）及其相关键。这些值的尺寸仅受数据类型本身限制。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As the name suggests, `SharedPreferences` is generally used to store configuration
    options selected by the user and is persisted across user sessions. There is also
    a base activity implementation, `PreferenceActivity`, to easily create and reuse
    a view for user preferences that makes use of the `SharedPreferences` for the
    application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`SharedPreferences`通常用于存储用户选择的配置选项，并且跨用户会话持久化。还有一个基本活动实现`PreferenceActivity`，可以轻松创建和重用用于用户偏好的视图，该视图利用`SharedPreferences`来为应用程序提供服务。
- en: 'The usage pattern for `SharedPreferences` class is straightforward. In order
    to use the default preferences for the activity or a custom preference file, the
    `Activity` class provides specialized methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences` 类的使用模式很简单。为了使用活动的默认首选项或自定义偏好文件，`Activity` 类提供了专用方法：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the retrieve call, the preference file is created according to the `FileCreationMode`
    class selected if it did not exist already. To get the value of a preference entry,
    you can use one of the get methods provided by the class. The code is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索调用之后，如果偏好文件尚未存在，则会根据选择的 `FileCreationMode` 类创建该文件。要获取偏好条目的值，您可以使用该类提供的获取方法。代码如下：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To edit the values, the `Editor` class for the `SharedPreferences` class can
    be used. The code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑值，可以使用 `SharedPreferences` 类的 `Editor` 类。代码如下：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Internal Storage** is the dedicated storage for your application. The application
    is free to create and retrieve any type of file (and folder) in this directory.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部存储**是应用程序的专用存储。应用程序可以自由创建和检索此目录中的任何类型的文件（和文件夹）。'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`FileCreationMode` is an access modifier used in Android runtime to define
    the access type and permission levels of a file.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileCreationMode` 是在 Android 运行时中使用的访问修饰符，用于定义文件的访问类型和权限级别。'
- en: '**Append**: If the file already exists, then write data to the end of the existing
    file instead of erasing. This is to be used with `Android.Content.Context.OpenFileOutput`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加**: 如果文件已存在，则将数据写入现有文件的末尾而不是删除。这应该与 `Android.Content.Context.OpenFileOutput`
    一起使用。'
- en: '**EnableWriteAheadLogging**: When this database''s open flag is set, the database
    is opened with write-ahead logging enabled by default.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用预写日志记录**: 当此数据库的打开标志被设置时，数据库默认启用预写日志记录功能打开。'
- en: '**MultiProcess**: legacy behavior in and before Gingerbread (Android 2.3) and
    is implied when targeting such releases. For applications targeting higher SDK
    versions, it must be set explicitly. When used together with `SharedPreferences`,
    the file on disk will be checked for modifications even if the shared preferences
    instance is already loaded in this process. This behavior is desired when the
    application has multiple processes accessing the same file.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多进程**: 在 Gingerbread（Android 2.3）及之前版本中是遗留行为，并且当针对这些版本时默认启用。对于针对更高 SDK 版本的程序，必须显式设置。当与
    `SharedPreferences` 一起使用时，即使共享首选项实例已经加载到该进程中，也会检查磁盘上的文件是否有修改。当应用程序有多个进程访问同一文件时，这种行为是期望的。'
- en: '**Private**: This is the default file creation mode where the created file
    can only be accessed by the calling application (or all applications sharing the
    same user ID).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**: 这是默认的文件创建模式，其中创建的文件只能由调用应用程序（或所有共享相同用户 ID 的应用程序）访问。'
- en: '**WorldReadable/WorldWritable**: Both deprecated in API level 17 for security
    vulnerabilities, they can pose to enable file access to application files.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界可读/世界可写**: 两者在 API 级别 17 中已弃用，因为存在安全漏洞，它们可能导致应用程序文件的可访问性。'
- en: 'Files in this folder, without any manifest declaration, can be accessed with
    the designated methods on the application context or by using the Xamarin/Mono
    implementation of IO methods. The code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹中的文件，如果没有任何清单声明，可以通过应用程序上下文上的指定方法或使用 Xamarin/Mono 的 IO 方法实现访问。代码如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to basic CRUD operations, you can also create additional folders
    and enumerate files and folders.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 CRUD 操作外，您还可以创建额外的文件夹并枚举文件和文件夹。
- en: iOS
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS
- en: The simplest data storage option on iOS applications are the property lists.
    (the `.plist` files). These files are designed to be used for relatively small
    amounts of data that can be represented with primitive data types. They can be
    defined as dictionaries or arrays that are serialized and persisted in XML format.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 应用程序中最简单的数据存储选项是属性列表（`.plist` 文件）。这些文件旨在用于相对较小的数据量，这些数据可以用原始数据类型表示。它们可以定义为字典或数组，并以
    XML 格式序列化和持久化。
- en: 'You can read and write to a property list directly using the associated classes
    (`NSArray` and `NSDictionary`). For instance, a simple implementation that creates
    and reads a property list would look similar to the following code (with additional
    diagnostic entries):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接使用相关类（`NSArray` 和 `NSDictionary`）读取和写入属性列表。例如，一个简单的实现，创建和读取属性列表的代码可能如下所示（带有额外的诊断条目）：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output from the preceding implementation would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现的结果如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When it comes to the local file storage, the iOS filesystem reserves several
    locations for applications; each of these locations have a specific purpose from
    the application's perspective.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到本地文件存储时，iOS文件系统为应用程序预留了几个位置；从应用程序的角度来看，这些位置都有特定的用途。
- en: '`Documents/`: The `Documents` library is generally designated for user-generated
    content. This folder should be used if the contents of the files are to be exposed
    to the user. Contents of this folder are backed up by iTunes.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documents/`：`Documents`库通常用于用户生成的内容。如果文件内容要向用户公开，则应使用此文件夹。此文件夹的内容由iTunes备份。'
- en: '`Documents/Inbox`: The `Inbox` folder is where files that are requested to
    be opened by the application are kept. An application can read and delete these
    files; it does not have privileges to modify these documents.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documents/Inbox`：`Inbox`文件夹是存储应用程序请求打开的文件的地方。应用程序可以读取和删除这些文件；它没有修改这些文档的权限。'
- en: '`Library/`: The `Library` folder is the root directory for the files that you
    don''t want to expose to the user. Applications can create files and additional
    folders in this directory.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Library/`：`Library`文件夹是您不希望向用户公开的文件的根目录。应用程序可以在该目录中创建文件和额外的文件夹。'
- en: '`Library/Application Support`: This subdirectory in the library folder is generally
    used to contain files managed by your application, such as configuration files,
    templates, saved data, and purchases. Contents destined for this folder should
    be placed in a custom subdirectory with the bundle identifier or company ID of
    your app.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Library/Application Support`：这个库文件夹中的子目录通常用于包含由您的应用程序管理的文件，例如配置文件、模板、保存的数据和购买内容。应将目的地为该文件夹的内容放置在具有应用程序捆绑标识符或公司ID的自定义子目录中。'
- en: '`Library/Caches`: The `Caches` folder is used for non-essential, application
    created files.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Library/Caches`：`Caches`文件夹用于存储非必需的应用程序创建的文件。'
- en: '`Library/Preferences`: App-specific preferences are stored in this folder.
    However, access to this folder should be done through the preferences API.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Library/Preferences`：应用程序特定的首选项存储在这个文件夹中。然而，访问这个文件夹应通过首选项API进行。'
- en: '`tmp/`: The `tmp` folder is another location for non-essential temporary files.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmp/`：`tmp`文件夹是另一个非必需临时文件的位置。'
- en: Access to these library locations is possible using the `System.IO` namespace
    and associated classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`System.IO`命名空间和相关类访问这些库位置。
- en: Temporary storage
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时存储
- en: Temporary storage and/or the cache directory is another location that the application
    does not need any specific permission. This is where non-essential files can be
    saved by the application to decrease network or processing time. The persistence
    of these folders is not guaranteed by the operating system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 临时存储和/或缓存目录是应用程序不需要任何特定权限的另一个位置。这是应用程序可以保存非必需文件以减少网络或处理时间的地方。这些文件夹的持久性不受操作系统的保证。
- en: In both Android and iOS systems, designated cache and/or temp locations are
    accessed through the context properties and the CRUD operations can be performed
    using the `System.IO` namespace and the related classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android和iOS系统中，指定的缓存和/或临时位置可以通过上下文属性访问，并且可以使用`System.IO`命名空间和相关类执行CRUD操作。
- en: 'On Android, the cache directory can be accessed with the `CacheDir` property
    on the context:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，可以通过上下文的`CacheDir`属性访问缓存目录：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On iOS, there are two separate locations for temporary files (`/temp/`) and
    cache files (`Library/Caches/`). Cache files are persisted for longer than the
    temporary data, but they still might be deleted by the system to free up disk
    space. The code is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，有两个单独的位置用于临时文件（`/temp/`）和缓存文件（`Library/Caches/`）。缓存文件比临时数据持久化时间更长，但它们仍然可能被系统删除以释放磁盘空间。代码如下：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Neither of these directories are backed up or synchronized to iCloud.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个目录都没有备份或同步到iCloud。
- en: Local filesystem
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地文件系统
- en: On iOS, applications cannot programmatically access files external to the application
    sandbox (for example, an iOS application cannot programmatically navigate to the
    user's picture directory and pick a file). The bridge between the local filesystem
    and the iOS app's sandbox was limited to the image picker controller until iOS
    8\. iOS 8 introduces the new document picker controller and document provider
    API. In this interaction model, the application implementing the document provider
    extension creates the document picker UI and the host application uses this provided
    UI to let the user select the documents to be used in the host application execution
    (similar to the file open picker and provider capability on the Windows Runtime
    platform).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，应用程序无法以编程方式访问应用程序沙盒之外的外部文件（例如，iOS应用程序无法以编程方式导航到用户的图片目录并选择文件）。本地文件系统和iOS应用程序沙盒之间的桥梁仅限于iOS
    8之前的图片选择控制器。iOS 8引入了新的文档选择控制器和文档提供者API。在此交互模型中，实现文档提供者扩展的应用程序创建文档选择UI，宿主应用程序使用提供的UI让用户选择在宿主应用程序执行中使用的文档（类似于Windows运行平台上的文件打开选择器和提供者功能）。
- en: '![Local filesystem](img/B04693_04_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![本地文件系统](img/B04693_04_04.jpg)'
- en: UIImagePickerController
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: UIImagePickerController
- en: 'For Android, on top of the local file storage that is only app-specific, applications
    have access to two other locations: public and private external storage (depending
    on the hardware). External storage in this context refers to SD card storage,
    which is not available on iOS systems. On Android runtime, applications can have
    access to the root path (OS root path) and iterate through public folders.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，除了仅适用于应用程序特定的本地文件存储之外，应用程序还可以访问两个其他位置：公共和私有外部存储（取决于硬件）。在此上下文中，外部存储指的是SD卡存储，这在iOS系统中不可用。在Android运行时，应用程序可以访问根路径（操作系统根路径）并遍历公共文件夹。
- en: 'Let''s have a look at the returned paths for some of the internal and external
    paths on an Android filesystem:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Android文件系统中一些内部和外部路径返回的路径：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output to these calls identifies the app-specific and public locations:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用的输出标识了应用程序特定和公共位置：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In spite of the fact that Android developers have access to a vast set of options
    for storage access methods, they are required to implement their own file picker
    dialogs or use interfaces provided by other installed applications (Android runtime
    also offers a provider-consumer type of file sharing implementation between applications).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Android开发者可以访问大量存储访问方法选项，但他们需要实现自己的文件选择对话框或使用其他已安装应用程序提供的接口（Android运行时还提供了应用程序之间的提供者-消费者类型的文件共享实现）。
- en: '![Local filesystem](img/B04693_04_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![本地文件系统](img/B04693_04_05.jpg)'
- en: A sample file browser implementation (Xamarin recipes)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例文件浏览器实现（Xamarin食谱）
- en: If there is an application that, by default, handles the file dialogs (the activity
    that can handle `ActionGetContent` intent), it can be invoked with an intent and
    the result can be accessed through the `OnActivityResult` callback method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个默认处理文件对话框的应用程序（可以处理`ActionGetContent`意图的活动），则可以通过意图调用它，并且可以通过`OnActivityResult`回调方法访问结果。
- en: SQLite
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite
- en: SQLite database implementations provide a relational persisted data structure
    in mobile application projects. Unlike the general server/client model that is
    used by relational databases, SQLite is a local database implementation and the
    data is stored in application local storage. Both Xamarin.iOS and Xamarin.Android
    application projects can include a SQLite database and associated implementations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库实现为移动应用程序项目提供关系型持久化数据结构。与关系数据库使用的通用服务器/客户端模型不同，SQLite是一个本地数据库实现，数据存储在应用程序本地存储中。Xamarin.iOS和Xamarin.Android应用程序项目都可以包含SQLite数据库及其相关实现。
- en: In order to use SQLite, developers are to choose to between the cross-platform
    implementation of ADO.Net, where the SQL queries are supposed to be created and
    included as plain text, or use the linq-2-entities access model of the SQLite.Net
    portable class library. It is available as a NuGet package and a component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用SQLite，开发者需要在跨平台实现ADO.Net之间进行选择，其中SQL查询应创建并作为纯文本包含，或者使用SQLite.Net便携式类库的linq-2-entities访问模型。它作为NuGet包和组件提供。
- en: '![SQLite](img/B04693_04_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![SQLite](img/B04693_04_06.jpg)'
- en: SQLite.Net PCL
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite.Net PCL
- en: For the following demonstration, we will use the asynchronous version of the
    SQLite.Net library.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下演示，我们将使用SQLite.Net库的异步版本。
- en: 'Implementation of the SQLite data access layer with SQLite.Net generally follows
    a code first database programming paradigm. In this pattern, developers first
    define their data model by creating entity classes and defining the data structure
    using the provided attributes. The code is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLite.Net实现SQLite数据访问层通常遵循代码优先的数据库编程范式。在这个模式中，开发者首先通过创建实体类并使用提供的属性定义数据结构来定义他们的数据模型。代码如下：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the data model implementation is finished, we can start creating the SQLite
    access methods.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成数据模型实现，我们就可以开始创建SQLite访问方法。
- en: 'In order to create a SQLite connection, first an application storage location
    has to be defined for the database file. The code is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个SQLite连接，首先需要为数据库文件定义一个应用程序存储位置。代码如下：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this implementation, `ISQLitePlatform` provides the much needed abstraction
    for the platform-specific APIs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`ISQLitePlatform`提供了平台特定API所需的抽象。
- en: 'After the SQLite connection is ready for use, we can implement the data tables''
    access and creation methods. The code is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQLite连接准备好使用时，我们可以实现数据表的访问和创建方法。代码如下：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now expose the tables through public properties in our data context,
    so the upper layers can execute queries against these tables. The code is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过数据上下文中的公共属性公开表，以便上层可以对这些表执行查询。代码如下：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is possible to extend the data model with entity relations and cascade operations.
    There are also available extensions for the SQLite.Net PCL library for lazy loading
    and child-related operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过实体关系和级联操作扩展数据模型。还有SQLite.Net PCL库的扩展，用于懒加载和子相关操作。
- en: Patterns and best practices
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: In this section, we will have a look at two common patterns that are common
    to mobile applications and how to implement these usage scenarios in a platform
    agnostic manner.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两个在移动应用程序中常见的模式，以及如何以平台无关的方式实现这些使用场景。
- en: Application preferences
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序偏好设置
- en: Application preferences is a common scenario in mobile applications. In order
    to use the previously described property list on iOS and `SharedPreferences` on
    Android, a common dictionary interface is often the most appropriate approach.
    The interface would then be inherited on platform-specific projects and can be
    injected into the common library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序偏好设置是移动应用程序中常见的场景。为了在iOS上使用之前描述的属性列表和在Android上使用`SharedPreferences`，通常最合适的做法是使用一个公共的字典接口。然后该接口将在平台特定项目中继承，并可以注入到公共库中。
- en: 'For a simple demonstration, we can define a simple interface that will retrieve
    and save string values. The code is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单演示，我们可以定义一个简单的接口，用于检索和保存字符串值。代码如下：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The implementation on the Android side would use a simple dictionary using
    a shared preference implementation. The code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android端实现将使用一个简单的字典，通过共享偏好设置实现。代码如下：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the iOS side, the implementation would use an `NSMutableDictionary` class
    to facilitate the preferences being edited by the user. The code is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS端，实现将使用`NSMutableDictionary`类来方便用户编辑偏好设置。代码如下：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that the persisted dictionary has been implemented on both platforms, we
    can include the application settings as a singleton to be used with a dependency
    injection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在持久化字典已在两个平台上实现，我们可以将应用程序设置作为一个单例包括进来，以便与依赖注入一起使用。
- en: This implementation can be extended using the Settings API on the iOS platform
    and using the preferences views (`PreferencesFragment` and `PreferencesActivity`)
    on the Android platform to create a more native-looking implementation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现可以通过iOS平台的设置API和Android平台的偏好设置视图（`PreferencesFragment`和`PreferencesActivity`）来扩展，以创建一个看起来更原生的方式。
- en: File picker
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件选择器
- en: In a cross-platform application project, if we are following an MVVM pattern,
    the view-model should reside in a shared project or a PCL so that the business
    logic can be shared between the apps. However, if we have a requirement to pick
    a file for processing, the method implementation should reside in the view itself
    since the platform-specific project that holds the view has access to platform
    features. Although it would be moving the business logic to the UI components,
    the work has to be done by the view.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个跨平台应用程序项目中，如果我们遵循MVVM模式，视图模型应该位于共享项目或PCL中，这样业务逻辑就可以在应用程序之间共享。然而，如果我们有选择文件进行处理的必要，方法实现应该位于视图本身，因为包含视图的平台特定项目可以访问平台功能。尽管这会将业务逻辑移动到UI组件中，但工作必须由视图来完成。
- en: You can, however, delegate the responsibility of the view model to the view
    without compromising the MVVM implementation. The delegation process can be executed
    through **Inversion of Control** (**IOC**) into the interface that defines the
    file picking operation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以将视图模型的责任委托给视图，而不会损害MVVM实现。委托过程可以通过定义文件选择操作的接口的**控制反转**（**IOC**）来执行。
- en: 'To demonstrate this usage, we will use an interface called `IFilePickerService`.
    In this example, we just want to let the user pick a file and return the resulting
    file path back to the view-model and maybe the model. The code is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种用法，我们将使用一个名为`IFilePickerService`的接口。在这个例子中，我们只想让用户选择一个文件，并将结果文件路径返回给视图模型和可能的数据模型。代码如下：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will use this interface in the view-model to call for the view to execute
    the logic. The code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在视图模型中使用此接口来调用视图执行逻辑。代码如下：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For Android implementation, we will be using the default file manager application
    that supports the respective intent type. We need to convert intent execution
    and the callback call on the `OnActivityResult` class into an asynchronous implementation.
    In order to do this, we will be using a task completion source. The code is as
    follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android实现，我们将使用支持相应意图类型的默认文件管理应用程序。我们需要将`OnActivityResult`类上的意图执行和回调调用转换为异步实现。为了做到这一点，我们将使用任务完成源。代码如下：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The private variable will be initialized every time the intent is called and
    the result will be set in the callback method. With this pattern in mind, the
    interface method implementation would look similar to this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用意图时，私有变量将被初始化，并在回调方法中设置结果。考虑到这种模式，接口方法实现将类似于以下内容：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the callback method implementation would be just setting the result
    on the `TaskCompletionSource` class. The code is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回调方法实现只是将结果设置在`TaskCompletionSource`类上。代码如下：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have the `IFilePickerService` interface created, at least on the
    Android side, we have to register the type with the dependency injection provider
    we are using, and then we can rely on it to resolve the type in the view-model
    initialization. (We will be using the MVVMCross framework in this example.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`IFilePickerService`接口，至少在Android端，我们必须使用我们正在使用的依赖注入提供程序注册类型，然后我们就可以依赖它在视图模型初始化中解析类型。（在这个例子中，我们将使用MVVMCross框架。）
- en: 'The code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The resulting application would execute the pick file command and open up the
    file browser, returning the file path back to the view model. If the user cancels
    the file selection, the task would throw an exception notifying that the operation
    has been cancelled.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应用程序将执行选择文件命令并打开文件浏览器，将文件路径返回给视图模型。如果用户取消文件选择，任务将抛出一个异常，通知操作已被取消。
- en: '![File picker](img/B04693_04_07.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![文件选择器](img/B04693_04_07.jpg)'
- en: Default file browser
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认文件浏览器
- en: 'For the iOS side of the story, our job is a little easier:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS部分，我们的工作要简单一些：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this completed, we just need to register the type and we finally have a
    cross-platform implementation of a command relying on the dependency injected,
    platform-specific methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们只需注册类型，我们最终就有一个依赖于依赖注入的平台特定方法的跨平台命令实现。
- en: Backup/Roaming
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份/漫游
- en: Xamarin target platforms both offer cloud sync and backup mechanisms. While
    the Android backup strategy is more of an async background process where backup
    and restore operations have to be initiated by the calling application, the iOS
    and iCloud roaming strategy provides seamless integration to the filesystem.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin 目标平台都提供了云同步和备份机制。虽然 Android 备份策略更像是异步后台进程，其中备份和恢复操作必须由调用应用程序启动，但 iOS
    和 iCloud 游走策略提供了对文件系统的无缝集成。
- en: Android and Backup API
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 和备份 API
- en: Android Backup API and Google-provided backup transport services provide an
    easily accessible way for application developers to back up and restore application
    data to remote cloud storage. It is possible to restore data after a factory reset
    or one device to another using the APIs provided by the `BackupManager`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Android 备份 API 和 Google 提供的备份传输服务为应用程序开发者提供了一个简单易用的方式，用于将应用程序数据备份和恢复到远程云存储。使用
    `BackupManager` 提供的 API，在工厂重置后或一个设备到另一个设备之间恢复数据是可能的。
- en: Backup operations are executed by the `BackupManager` in Android runtime and
    operations related to the application data are delegated to the `BackupAgent`
    registered in the application manifest. It is important to remember the fact that
    your application has to be registered in the Android Backup Service. It is crucial
    to include the backup service key that you receive from the registration in the
    package manifest.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 备份操作由 Android 运行时的 `BackupManager` 执行，与应用程序数据相关的操作委托给在应用程序清单中注册的 `BackupAgent`。记住这一点很重要，即您的应用程序必须在
    Android 备份服务中注册。在包清单中包含您从注册中获得的备份服务密钥至关重要。
- en: In order to create a `BackupAgent`, you must implement the `OnBackup` and `OnRestore`
    methods of the `BackupAgent` abstract class. In these methods, the old and new
    states of your data are served in the form of `ParcelFileDescriptor` (file metadata
    that can be used to access the actual file). In the restore method, you also receive
    the application version that might be helpful if the data structure has changed
    between application updates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 `BackupAgent`，您必须实现 `BackupAgent` 抽象类的 `OnBackup` 和 `OnRestore` 方法。在这些方法中，您的数据的老旧和新旧状态以
    `ParcelFileDescriptor` 的形式提供（可以用来访问实际文件的文件元数据）。在恢复方法中，您还会收到应用程序版本，如果数据结构在应用程序更新之间发生变化，这可能很有帮助。
- en: Another way to create an agent is to use the existing agent template (`BackupAgentHelper`)
    and use the existing helper classes to back up and restore certain subsets of
    your application data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代理的另一种方式是使用现有的代理模板（`BackupAgentHelper`）并使用现有的辅助类来备份和恢复应用程序数据的一定子集。
- en: For instance, the `SharedPreferencesBackupHelper` class is a generic implementation
    of a backup operator on `SharedPreferences` files that are used by your application.
    The preferences groups for the application can be passed onto the helper and the
    helper class can deal with the backup logic implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`SharedPreferencesBackupHelper` 类是用于您的应用程序的 `SharedPreferences` 文件上的备份操作的一般实现。可以将应用程序的首选项组传递给辅助器，辅助器类可以处理备份逻辑实现。
- en: Another helper class is the `FileBackupHelper` class that can be used to back
    up and restore application files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个辅助类是 `FileBackupHelper` 类，它可以用来备份和恢复应用程序文件。
- en: 'In order to demonstrate the Backup API and a usual backup scenario, we can
    create a backup agent that will trace out the backup events and method executions.
    The implementation class should derive from the `BackupAgentHelper` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示备份 API 和一个常见的备份场景，我们可以创建一个备份代理，它会跟踪备份事件和方法执行。实现类应该从 `BackupAgentHelper`
    类派生：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To include this backup agent in our application, we can either edit the application
    manifest or use the `ApplicationAttribute` attribute in the assembly info. Both
    `AssemblyInfo.cs` and `AndroidManifest.xml` can be found under the `Properties`
    project folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此备份代理包含到我们的应用程序中，我们可以编辑应用程序清单或使用程序集信息中的 `ApplicationAttribute` 属性。`AssemblyInfo.cs`
    和 `AndroidManifest.xml` 都可以在 `Properties` 项目文件夹下找到。
- en: '![Android and Backup API](img/B04693_04_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Android 和备份 API](img/B04693_04_08.jpg)'
- en: Application manifest and AssemblyInfo
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单和 AssemblyInfo
- en: 'Using the `ApplicationManifest.xml` file, let''s add the backup agent and backup
    services key:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ApplicationManifest.xml` 文件，让我们添加备份代理和备份服务密钥：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding application manifest entry is how it would look if we were dealing
    with Java class libraries, not Xamarin and the JNI Bridge. In fact, this registration
    would throw an error as soon as a backup request is received. The code is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是 Java 类库而不是 Xamarin 和 JNI 桥接，前面的应用程序清单条目将看起来是这样。实际上，一旦收到备份请求，此注册就会抛出错误。代码如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To register the `PreferencesBackupService` class with the Android runtime,
    we need to add an identifier for the type itself. Since we are not using a namespace
    qualifier in the manifest declaration, we can register the class in the application
    default namespace:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `PreferencesBackupService` 类注册到 Android 运行时，我们需要为该类型本身添加一个标识符。由于我们不在清单声明中使用命名空间限定符，我们可以在应用程序默认命名空间中注册该类：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we were to use the `Application` attribute to register our backup agent
    without the application manifest entries, the attributes would look similar to
    the following using the `AssemblyInfo.cs` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用应用程序清单条目来注册备份代理而使用 `Application` 属性，则属性将类似于以下使用 `AssemblyInfo.cs` 文件：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, the **android callable wrapper** (**ACW**) is created with the
    default naming convention for our backup agent and inserted into the application
    manifest, so we didn''t need to register our class additionally. The generated
    entry for the application manifest contains the MD5 hash of the pair namespace
    and the containing assembly:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**Android 可调用包装器**（**ACW**）使用我们备份代理的默认命名约定创建，并插入到应用程序清单中，因此我们不需要额外注册我们的类。应用程序清单中生成的条目包含对命名空间和包含的程序的
    MD5 哈希：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are developing with Visual Studio and running your application on Emulator,
    you can see the generated MD5 values for the Android exposed classes in the `<projectdir>\obj\<buildconfig>\android\src`
    directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio 进行开发并在模拟器上运行应用程序，你可以在 `<projectdir>\obj\<buildconfig>\android\src`
    目录中看到为 Android 暴露的类生成的 MD5 值。
- en: '![Android and Backup API](img/B04693_04_09.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Android 和备份 API](img/B04693_04_09.jpg)'
- en: Android source directory
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Android 源目录
- en: 'Once the registration is complete, we can override a couple of methods in the
    agent class to get the trace information. The code is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，我们可以在代理类中重写几个方法以获取跟踪信息。代码如下：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now open an Android Adb Console and use the following commands to trigger
    a backup request:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以打开 Android Adb 控制台并使用以下命令来触发备份请求：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once your data segments change, you can use the `DataChanged` method of the
    `BackupManager` class and use it to request restore operations. (Restore operations
    are, under normal circumstances, scheduled and performed by Android backup services,
    so the app does not need to explicitly call it.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据段发生变化，你可以使用 `BackupManager` 类的 `DataChanged` 方法并使用它来请求恢复操作。（在正常情况下，恢复操作由
    Android 备份服务安排和执行，因此应用程序不需要显式调用它。）
- en: 'The code is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: iOS and ubiquitous storage
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS 和通用存储
- en: In order to use iCloud features in your iOS applications, they must be configured
    in the *Apple Provisioning Portal* and the project manifest.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 iOS 应用程序中使用 iCloud 功能，它们必须在 *Apple 配置门户* 和项目清单中进行配置。
- en: 'In the provisioning portal, while creating the App ID, iCloud must be selected
    as one of the enabled services. Then, using the `<TeamID>.<BundeID>` format, the
    container identifier must be inserted into the `Entitlements.plist` file. The
    keys that have to be edited are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置门户中，创建 App ID 时，必须将 iCloud 选择为启用服务之一。然后，使用 `<TeamID>.<BundleID>` 格式，将容器标识符插入到
    `Entitlements.plist` 文件中。需要编辑的键如下：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On iOS, the simplest synchronization mechanism provided is for primitive data
    types in the form of key/value pairs. This is used for simple user preferences
    or application required values that need to be synchronized between separate clients.
    The total size of a key/value pair cannot exceed 64 kilobytes, while the maximum
    value size is 64 kB and key size is 64 bytes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上，提供的最简单的同步机制是以键/值对的形式对原始数据类型进行同步。这用于简单的用户首选项或需要在不同客户端之间同步的应用程序所需值。键/值对的总大小不能超过
    64 千字节，最大值大小为 64 kB，键大小为 64 字节。
- en: 'The synchronizing context can be accessed through the `NSUbiquitousKeyValueStore`
    class. The code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `NSUbiquitousKeyValueStore` 类访问同步上下文。代码如下：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using the same store, you can access the values:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的存储，你可以访问值：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The synchronization process does not happen right after the synchronize method
    is invoked. The process is initiated according to iCloud's own schedule; up-sync
    generally happens within 5 seconds, while the only way to exactly know when the
    down-sync occurs is by adding an `Observer` delegate to the `NSUbiquitousKeyValueStore`
    events.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同步过程并不是在调用同步方法后立即发生。该过程根据iCloud自己的计划启动；上同步通常在5秒内发生，而确切知道下同步何时发生的方法是向`NSUbiquitousKeyValueStore`事件添加`Observer`代理。
- en: 'The code is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For synchronized files, the implementation is a little more complicated. While
    backup and restore scenarios are automatically handled by the iOS application
    and iTunes, for keeping a synchronized file storage, developers need to implement
    the `UIDocument` class to prepare type of documents that needs to be synced between
    devices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同步文件，实现稍微复杂一些。虽然备份和恢复场景由iOS应用程序和iTunes自动处理，但为了保持同步文件存储，开发者需要实现`UIDocument`类以准备需要在设备之间同步的文档类型。
- en: The `UbiquityContainer` directory is managed by the so-called daemons to coordinate
    the synchronization and modifications of the files on the iCloud context. In order
    not to cause concurrency problems and interfere with the daemon processing, the
    files in question need to be accessed and modified with the `NSFilePresenter`
    and `NSFileCoordinator` classes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`UbiquityContainer`目录由所谓的守护进程管理，以协调iCloud上下文中文件的同步和修改。为了避免引起并发问题并干扰守护进程处理，需要访问和修改相关文件时，必须使用`NSFilePresenter`和`NSFileCoordinator`类。'
- en: The easiest way to use the presenters and coordinators for file operations is
    to implement the `UIDocument` base class. There are two virtual methods that need
    to be implemented to read data and write data to documents.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用演示者和协调器进行文件操作的最简单方法是实现`UIDocument`基类。需要实现两个虚拟方法来读取数据并将数据写入文档。
- en: 'Let''s assume that we want to keep a synchronized context for serialized entity
    data for our application. First, we need to declare our class as inheriting and
    implementing the required constructor from the `UIDocument` class. The code is
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为我们的应用程序保持序列化实体数据的同步上下文。首先，我们需要将我们的类声明为继承并实现从`UIDocument`类所需的构造函数。代码如下：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We then need to implement the two virtual methods. The following load method
    defined just deserializes the data from the cloud into the entity defined in the
    generic class type definition. The code is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现两个虚拟方法。以下加载方法仅从云中反序列化数据到泛型类类型定义中定义的实体。代码如下：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can implement the save method that will serialize the object and
    serve the stream to be saved in the ubiquitous container. The code is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现保存方法，该方法将序列化对象并将流保存到无处不在的容器中。代码如下：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In order to be able to use this implementation with an example class, named
    `LocationInfo`, we can first implement a load file procedure (we are using a single
    file query for each location loaded, but this can be extended using queries like
    `ENDSWITH` or `CONTAINS`). The code is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用名为`LocationInfo`的示例类实现此实现，我们首先可以实施一个加载文件程序（我们正在为每个加载的位置使用单个文件查询，但这可以通过使用`ENDSWITH`或`CONTAINS`之类的查询进行扩展）。代码如下：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the query returns, we can expand the object into the data needed. The
    code is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦查询返回，我们就可以将对象扩展到所需的数据。代码如下：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `LoadLocationInfo` function in the example would simply try to open the
    file and deal with the loaded data. The code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的`LoadLocationInfo`函数将简单地尝试打开文件并处理加载的数据。代码如下：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that we are also subscribing to the data changed event with the notification
    name we defined in the `EntityDocument<T>` class (`string.Format("{0}DocumentModified",
    m_Type.Name` ). The reload implementation is simply gathering the object from
    the notification itself. The code is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在使用在`EntityDocument<T>`类中定义的通知名称（`string.Format("{0}DocumentModified",
    m_Type.Name`）订阅数据更改事件。重新加载的实现只是简单地从通知本身收集对象。代码如下：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For saving and synchronizing the data, we just need to assign the new data
    and update the change count on the `UIDocument` class. The code is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于保存和同步数据，我们只需在`UIDocument`类上分配新数据并更新更改计数即可。代码如下：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This topic will be discussed further in [Chapter 5](ch05.html "Chapter 5. Networking"),
    *Networking*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题将在[第5章](ch05.html "第5章。网络")*网络*中进一步讨论。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some of the local storage containers and access
    strategies. In both of the Xamarin platforms, with the additional option to back
    up and synchronize the data to the cloud, developers can create a consistent user
    interface as well as stateful mobile applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些本地存储容器和访问策略。在Xamarin的两个平台中，通过额外的将数据备份和同步到云端的选项，开发者可以创建一致的用户界面以及具有状态感的移动应用程序。
- en: In the next chapter, we will discuss the network connectivity options and how
    to use connected data together with local storage options provided with the target
    Xamarin platforms.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论网络连接选项以及如何使用目标Xamarin平台提供的本地存储选项与连接数据一起使用。
