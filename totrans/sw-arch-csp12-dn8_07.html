<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer144">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 class="chapterTitle" id="_idParaDest-138"><span class="koboSpan" id="kobo.2.1">Understanding the Different Domains in Software Solutions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter is dedicated to a modern software development technique called </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">DDD</span></strong><span class="koboSpan" id="kobo.7.1">), which was first proposed by Eric Evans (see </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Domain-Driven Design</span></em><span class="koboSpan" id="kobo.9.1">: </span><a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20"><span class="url"><span class="koboSpan" id="kobo.10.1">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</span></span></a><span class="koboSpan" id="kobo.11.1">). </span><span class="koboSpan" id="kobo.11.2">While DDD has existed for more than 15 years, it has achieved great success in the last few years because of its ability to cope with two important problems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">The main problem is modeling complex systems that involve several domains of knowledge. </span><span class="koboSpan" id="kobo.12.2">No single expert has in-depth knowledge of the whole domain; this knowledge is instead split among several people. </span><span class="koboSpan" id="kobo.12.3">The second problem is that each expert speaks a language that is specific to his domain of expertise, so for effective communication between the experts and the development team, objects, interfaces, and methods must mimic the language of the domain experts. </span><span class="koboSpan" id="kobo.12.4">This means that the different modules that compose an application must use a different vocabulary for each domain of expertise. </span><span class="koboSpan" id="kobo.12.5">Consequently, the application must be split into modules that reflect the different domains of knowledge, and the interface between modules that deal with the different domains of knowledge must be carefully designed to carry out the necessary translations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.13.1">DDD copes with this problem by splitting the whole CI/CD cycle into independent parts, assigned to different teams. </span><span class="koboSpan" id="kobo.13.2">This way, each team can focus on a specific domain of knowledge by interacting only with the experts in that domain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.14.1">That’s why the evolution of DDD is interleaved with the evolution of microservices and DevOps. </span><span class="koboSpan" id="kobo.14.2">Thanks to DDD, big projects can be split among several development teams, with each team having a different domain of knowledge. </span><span class="koboSpan" id="kobo.14.3">There are many reasons why a project is split among several teams, with the most common being the team’s size and all of its members having different skills and/or being in different locations. </span><span class="koboSpan" id="kobo.14.4">In fact, experience has proven that teams of more than 6–8 people are not effective, and, clearly, different skills and locations prevent tight interaction from occurring.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">In turn, the importance of the two aforementioned problems has grown in the last few years. </span><span class="koboSpan" id="kobo.15.2">Software systems have always taken up a lot of space inside every organization, and they have become more and more complex and geographically distributed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.16.1">At the same time, the need for frequent updates has increased so that these complex software systems can be adapted to the needs of a quickly changing market.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.17.1">As a result of the increasing complexity and need for frequent updates in software systems, we now face a scenario where it’s common to implement complex software systems with associated fast CI/CD cycles that always require more people to evolve and maintain them. </span><span class="koboSpan" id="kobo.17.2">In turn, this created a need for technologies that were adequate for high-complexity domains and for the cooperation of several loosely coupled development teams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">In this chapter, we will analyze the basic principles, advantages, and common patterns related to DDD, as well as how to use them in our solutions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">More specifically, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">What are software domains?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Understanding DDD</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Common DDD patterns and architectures</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.23.1">Let’s get started.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.24.1">As you progress through the second part of the book, you might find it enriching to revisit this particular chapter. </span><span class="koboSpan" id="kobo.24.2">Reflecting on these concepts with a deeper understanding can offer new insights and enhance your overall experience. </span><span class="koboSpan" id="kobo.24.3">Feel free to come back to this chapter as a resource whenever you encounter related ideas later on.</span></p>
</div>
<h1 class="heading-1" id="_idParaDest-139"><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.26.1">This chapter requires the free Visual Studio 2022 Community Edition or better, with all the database tools installed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">All the code snippets in this chapter can be found in the GitHub repository associated with this book: </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.29.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-140"><span class="koboSpan" id="kobo.30.1">What are software domains?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.31.1">As we discussed in </span><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 2</span></em><span class="koboSpan" id="kobo.33.1">, </span><em class="italic"><span class="koboSpan" id="kobo.34.1">Non-Functional Requirements</span></em><span class="koboSpan" id="kobo.35.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 3</span></em><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Managing Requirements</span></em><span class="koboSpan" id="kobo.39.1">, the transfer of knowledge from domain experts to the development team plays a fundamental role in software design. </span><span class="koboSpan" id="kobo.39.2">Developers try to communicate with experts </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.40.1">and describe their solutions in a language that domain experts and stakeholders can also understand. </span><span class="koboSpan" id="kobo.40.2">However, often, the same word has a different meaning in various parts of an organization, and what appears to be the same conceptual entities have completely different shapes in different contexts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.41.1">For instance, in our WWTravelClub use case, the order-payment and package-handling subsystems use completely different models for customers. </span><span class="koboSpan" id="kobo.41.2">The order-payment subsystem characterizes a customer by their payment methods, currency, bank accounts, and credit cards, while package-handling is more concerned with the locations that have been visited and/or the packages that have been purchased, the user’s preferences, and their geographical location. </span><span class="koboSpan" id="kobo.41.3">Moreover, while order-payment refers to various concepts with a language that we may roughly </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.42.1">define as a </span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">bank language</span></strong><span class="koboSpan" id="kobo.44.1">, package-handling uses a language that is typical of travel agencies/operators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.45.1">The classic way to cope with these discrepancies is to use a unique abstract entity called </span><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">customer</span></strong><span class="koboSpan" id="kobo.47.1">, which projects</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.48.1"> into two different views—the order-payment view and the package-handling view. </span><span class="koboSpan" id="kobo.48.2">Each projection operation takes some operations and some properties from the </span><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">customer</span></strong><span class="koboSpan" id="kobo.50.1"> abstract entity and changes their names. </span><span class="koboSpan" id="kobo.50.2">Since domain experts only give us the projected views, our main task as system designers is to create a conceptual model that can explain all the views. </span><span class="koboSpan" id="kobo.50.3">The following diagram shows how different views are handled:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.51.1"><img alt="" role="presentation" src="../Images/B19820_07_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.52.1">Figure 7.1: Creating a unique model</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">The main advantage of the classic approach is that we have a unique and coherent representation of the data of the domain. </span><span class="koboSpan" id="kobo.53.2">If this conceptual model is built successfully, all the operations will have a formal definition and purpose and the whole abstraction will be a rationalization of the way the whole organization should work, possibly highlighting and correcting</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.54.1"> errors and simplifying some procedures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.55.1">However, what are the </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.56.1">downsides of this approach?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.57.1">The sharp adoption of a new monolithic data model may cause an acceptable impact in a small organization when the software is destined for a small part of the overall organization, or when the software automates a small enough percentage of the data flow. </span><span class="koboSpan" id="kobo.57.2">However, if the software becomes the backbone of a complex, geographically distributed organization, sharp changes become unacceptable and unfeasible. </span><span class="koboSpan" id="kobo.57.3">On the one hand, big structured companies need to react quickly to market changes, but on the other hand, due to the complexity of their organizations, only gradual changes are feasible. </span><span class="koboSpan" id="kobo.57.4">Therefore, the changes in their organizations and information systems that are needed to adapt to the market must be gradual. </span><span class="koboSpan" id="kobo.57.5">In turn, a gradual transition is possible only if old data models can coexist </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.58.1">with new data models, and if each of the various components of the organization is allowed to change at its own speed—that is, if each component of the organization can evolve independently of the others.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.59.1">Moreover, as the complexity of</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.60.1"> a software system grows, several other issues make the unique data model of classical architectures hard to maintain:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.61.1">Coherency issues</span></strong><span class="koboSpan" id="kobo.62.1">: Arriving at a uniquely coherent view of data becomes more difficult since we can’t retain the complexity when we break these tasks into smaller, loosely coupled tasks.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.63.1">Difficulties updating</span></strong><span class="koboSpan" id="kobo.64.1">: As complexity grows, there is a need for frequent system changes, but it is quite difficult to update and maintain a unique global model. </span><span class="koboSpan" id="kobo.64.2">Moreover, bugs/errors that are introduced by changes in small subparts of the system may propagate to the whole organization through the uniquely shared model.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.65.1">Team organization issues</span></strong><span class="koboSpan" id="kobo.66.1">: System modeling must be split among several teams, and only loosely coupled tasks can be given to separate teams; if two tasks are strongly coupled, they need to be given to the same team.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.67.1">Parallelism issues</span></strong><span class="koboSpan" id="kobo.68.1">: As we will discuss in more detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.69.1">Chapter 11</span></em><span class="koboSpan" id="kobo.70.1">, </span><em class="italic"><span class="koboSpan" id="kobo.71.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.72.1">, the need to move to a microservice-based architecture often makes the bottleneck of a unique database unacceptable.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.73.1">Language issues</span></strong><span class="koboSpan" id="kobo.74.1">: As the system grows, we need to communicate with more domain experts, each speaking a different language and each with a different view of that data model. </span><span class="koboSpan" id="kobo.74.2">Thus, we need to translate our unique model’s properties and operations to/from more languages to be able to communicate with them.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.75.1">As the system grows, it becomes more inefficient to deal with records with hundreds/thousands of fields that project in smaller views. </span><span class="koboSpan" id="kobo.75.2">Such inefficiencies originate in database engines that inefficiently handle big records with several fields (memory fragmentation, problems with too many related indices, and so on). </span><span class="koboSpan" id="kobo.75.3">However, the main inefficiencies take place in </span><strong class="keyWord"><span class="koboSpan" id="kobo.76.1">object-relational mappings</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.78.1">ORMs</span></strong><span class="koboSpan" id="kobo.79.1">) and business layers that are forced to handle</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.80.1"> these big records in their update operations. </span><span class="koboSpan" id="kobo.80.2">In fact, while query operations usually require just a few fields that have been retrieved from the storage engine, updates and business processing involve the whole entity. </span><span class="koboSpan" id="kobo.80.3">ORMs are described in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.81.1">Chapter 13</span></em><span class="koboSpan" id="kobo.82.1">, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.84.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">As the traffic in the data storage subsystem grows, we need read and update/write parallelism in all the data operations. </span><span class="koboSpan" id="kobo.85.2">As we will discover in </span><em class="chapterRef"><span class="koboSpan" id="kobo.86.1">Chapter 12</span></em><span class="koboSpan" id="kobo.87.1">, </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Choosing Your Data Storage in the Cloud</span></em><span class="koboSpan" id="kobo.89.1">, while read parallelism is easily achieved with data replication, write parallelism requires sharding; that is, splitting database records among several distributed databases, and</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.90.1"> it is difficult to shard a uniquely monolithic and tightly connected data model.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.91.1">These issues are the reason for DDD’s success in the last few years because they were characterized by more complex software systems that became the backbones of entire organizations. </span><span class="koboSpan" id="kobo.91.2">DDD’s basic principles will be discussed in detail in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-141"><span class="koboSpan" id="kobo.92.1">Understanding DDD</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.93.1">According to DDD, we should not </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.94.1">construct a unique domain model that projects into different views in each application subsystem. </span><span class="koboSpan" id="kobo.94.2">Instead, the whole application domain is split into smaller domains, each with its own data model. </span><span class="koboSpan" id="kobo.94.3">These separate domains are </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.95.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.96.1">Bounded Contexts</span></strong><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">Each Bounded Context is characterized by the language used by the experts and used to name all the domain concepts and operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.98.1">Thus, each Bounded Context defines a common language used by both the experts and the development team called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.99.1">Ubiquitous Language</span></strong><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">Translations are </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.101.1">not needed anymore, and if the development team uses C# interfaces as bases for its code, the domain expert is able to understand and validate them since all the operations and properties are expressed in the same language that’s used by the expert.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">Here, we’re getting rid of a cumbersome unique abstract model, but now we have several separate models that we need to relate somehow. </span><span class="koboSpan" id="kobo.102.2">DDD proposes that we handle all these separate models (that is, all the Bounded Contexts) as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.103.1">We need to add Bounded Context boundaries whenever the meanings of the language terms change</span></strong><span class="koboSpan" id="kobo.104.1">. </span><span class="koboSpan" id="kobo.104.2">For instance, in the WWTravelClub use case, order-payment and package-handling belong to different Bounded Contexts because they give a different meaning to the word </span><strong class="keyWord"><span class="koboSpan" id="kobo.105.1">customer</span></strong><span class="koboSpan" id="kobo.106.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.107.1">We need to explicitly represent relations among Bounded Contexts</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">Different development teams may work on different Bounded Contexts, but each team must have a clear picture of the relationship between the Bounded Context it is working on and all the other models. </span><span class="koboSpan" id="kobo.108.3">For this reason, such relationships are represented in a unique document that’s shared with every team.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.109.1">We need to keep all the Bounded Contexts aligned with CI</span></strong><span class="koboSpan" id="kobo.110.1">.</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.111.1">Meetings are organized and simplified system prototypes are built in order to verify that all the Bounded Contexts are evolving coherently—that is, that all the Bounded Contexts can be integrated into the desired application behavior.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.112.1">The following diagram shows how</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.113.1"> the WWTravelClub example that we discussed in the previous section changes with the adoption of DDD:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.114.1"><img alt="Diagram, venn diagram  Description automatically generated" src="../Images/B19820_07_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.115.1">Figure 7.2: Relationships between DDD-Bounded Contexts</span></p>
<p class="normal"><span class="koboSpan" id="kobo.116.1">There is a relationship between the Customer entities of each Bounded Context, while the Purchase entity of the package-handling Bounded Context is related to the Payments. </span><span class="koboSpan" id="kobo.116.2">Identifying entities that map to each other in the various Bounded Contexts is the first step of formally defining the interfaces that represent all the possible communications among the contexts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.117.1">For instance, in the previous diagram, since payments are made after purchases, we can deduce that the order-payment Bounded Context must have an operation to create a payment for a specific customer. </span><span class="koboSpan" id="kobo.117.2">In this domain, new customers are created if they don’t already exist.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">The payment creation</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.119.1"> operation is triggered immediately after purchase. </span><span class="koboSpan" id="kobo.119.2">Since several more operations are triggered after an item is purchased, we can implement all the communication related to a purchase event with the Publisher/Subscriber pattern we explained in </span><em class="italic"><span class="koboSpan" id="kobo.120.1">Chapter 6</span></em><span class="koboSpan" id="kobo.121.1">, </span><em class="italic"><span class="koboSpan" id="kobo.122.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">In DDD, these are </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.124.1">known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.125.1">domain events</span></strong><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">Using events to implement communications between Bounded Contexts is very common since it helps keep Bounded Contexts loosely coupled.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.127.1">Once an instance of either an event or an operation that’s been defined in the Bounded Context’s interface crosses the context boundary, it is immediately translated into the Ubiquitous Language of the receiving context. </span><span class="koboSpan" id="kobo.127.2">It is important that this translation be performed before the input data starts interacting with the other domain entities to prevent the Ubiquitous Language of the receiving domain from becoming contaminated by extra-contextual terms. </span><span class="koboSpan" id="kobo.127.3">An inadequate translation is usually evidenced by the domain experts complaining about “strange words.”</span></p>
<p class="normal"><span class="koboSpan" id="kobo.128.1">Each Bounded Context implementation must contain a domain model completely expressed in terms of the Bounded Context Ubiquitous Language (class and interface names and property and method names), with no contamination from other Bounded Contexts’ Ubiquitous Languages, and without contamination from technical programming stuff. </span><span class="koboSpan" id="kobo.128.2">This is necessary to ensure good communication with domain experts and to ensure that domain rules are translated correctly into code so that they can be easily validated by domain experts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.129.1">When there is a strong mismatch between the communication language and the target Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded Context boundary. </span><span class="koboSpan" id="kobo.129.2">The only purpose of this anti-corruption layer is to perform a language translation.</span></p>
<h2 class="heading-2" id="_idParaDest-142"><span class="koboSpan" id="kobo.130.1">Relationships among Bounded Contexts</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.131.1">The document that contains a representation of all the Bounded Contexts, along with the Bounded Contexts’ mutual relationships </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.132.1">and interface definitions, is called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.133.1">context map</span></strong><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">The relationships between contexts contain organizational constraints that specify the kind of cooperation required among the teams that are working on the different Bounded Contexts. </span><span class="koboSpan" id="kobo.134.3">Such</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.135.1"> relationships don’t constrain the Bounded Context interfaces but do affect the way they may evolve during the software CI/CD cycle. </span><span class="koboSpan" id="kobo.135.2">They represent patterns of team cooperation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.136.1">The most common patterns are as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.137.1">Partner</span></strong><span class="koboSpan" id="kobo.138.1">: This is the original pattern suggested by Eric Evans. </span><span class="koboSpan" id="kobo.138.2">The idea is that the two teams have a mutual dependency on each other for delivery. </span><span class="koboSpan" id="kobo.138.3">In other words, they </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.139.1">decide together the Bounded Context’s mutual communication specifications during the software development lifecycle.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.140.1">Customer/supplier development teams</span></strong><span class="koboSpan" id="kobo.141.1">: In this case, one team acts as a customer and another one acts as a supplier. </span><span class="koboSpan" id="kobo.141.2">In the preliminary stage, both teams define the interface</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.142.1"> of the customer side of the Bounded Context and some automated acceptance tests to validate it. </span><span class="koboSpan" id="kobo.142.2">After that, the supplier can work independently.
    </span><p class="normal"><span class="koboSpan" id="kobo.143.1">This pattern works when the customer’s Bounded Context is the only active part that invokes the interface methods exposed by the other Bounded Context. </span><span class="koboSpan" id="kobo.143.2">This is adequate for the interaction between the order-payment and the package-handling contexts, where order-payment acts as a supplier since its functions are subordinate to the needs of package-handling. </span><span class="koboSpan" id="kobo.143.3">When this pattern can be applied, it decouples both the implementation and the maintenance of the two Bounded Contexts completely.</span></p> </li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.144.1">Conformist</span></strong><span class="koboSpan" id="kobo.145.1">: This is similar to the customer/supplier pattern, but in this case, the customer side accepts an interface that’s been imposed by the supplier side with no preliminary</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.146.1"> negotiation stage. </span><span class="koboSpan" id="kobo.146.2">This pattern offers no advantages to the other patterns, but sometimes we are forced into the situation depicted by the pattern since either the supplier’s Bounded Context is implemented in a preexisting product that can’t be configured/modified too much, or because it is a legacy subsystem that we don’t want to modify.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.147.1">It is worth pointing out that the separation in Bounded Contexts is only effective if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction of complexity that’s obtained by breaking a whole system into parts would be overwhelmed by the complexity of the coordination and communication processes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.148.1">However, if Bounded Contexts are defined with the language criterion—that is, Bounded Context boundaries are added whenever the Ubiquitous Language changes—this should actually be the case. </span><span class="koboSpan" id="kobo.148.2">In fact, different languages may arise as a result of a loose interaction between an organization’s subparts since the more each subpart has tight interactions inside of it and loose interactions with other subparts, the more each subpart ends up defining and using its own internal language, which differs from the language used by the other subparts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.149.1">Moreover, as all human organizations grow just by evolving into loosely coupled subparts, similarly, complex software systems may be implemented just as the cooperation of loosely coupled </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.150.1">submodules: this is the only way humans are able to cope with complexity. </span><span class="koboSpan" id="kobo.150.2">From this, we can conclude that complex organizations/artificial systems can always be decomposed into loosely coupled subparts. </span><span class="koboSpan" id="kobo.150.3">We just need to understand </span><em class="italic"><span class="koboSpan" id="kobo.151.1">how</span></em><span class="koboSpan" id="kobo.152.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Beyond the basic principles we’ve mentioned so far, DDD provides a few basic primitives to describe each Bounded Context, as well as some implementation patterns. </span><span class="koboSpan" id="kobo.153.2">While Bounded Context primitives are an integral part of DDD, the patterns are simply useful heuristics we can use in our implementation, so their usage in some or all Bounded Contexts is not obligatory once we opt for DDD adoption.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.154.1">In the next section, we will describe Bounded Context primitives, while the various patterns will be described in the remaining sections of the chapter.</span></p>
<h2 class="heading-2" id="_idParaDest-143"><span class="koboSpan" id="kobo.155.1">Entities</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.156.1">DDD entities represent domain objects that have a well-defined identity, as well as all the operations that are defined on</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.157.1"> them. </span><span class="koboSpan" id="kobo.157.2">They don’t differ too much from the</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.158.1"> entities of other, more classical approaches.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.159.1">The main difference is that DDD stresses the entities’ object-oriented nature, while other approaches use them mainly as </span><strong class="keyWord"><span class="koboSpan" id="kobo.160.1">records</span></strong><span class="koboSpan" id="kobo.161.1"> whose</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.162.1"> properties can be written/updated without too many constraints.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.163.1">DDD, on the other hand, forces strong SOLID principles on them to ensure that only certain information is encapsulated inside of them and that only certain information is accessible from outside of them, to stipulate which operations are allowed on them, and to set which business-level validation criteria apply to them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.164.1">In other words, DDD entities are richer than the entities of record-based approaches.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.165.1">In the record-based approach, operations that manipulate entities are defined outside of them in classes that represent business and/or domain operations. </span><span class="koboSpan" id="kobo.165.2">In DDD, these operations are moved into the entity definitions as their class methods. </span><span class="koboSpan" id="kobo.165.3">The reason for this is that this approach offers better modularity and keeps related chunks of software in the same place so that they </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.166.1">can be maintained and tested easily.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.167.1">More details on the difference between the record-based approach and the DDD approach will be given later on, in the </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Repository pattern</span></em><span class="koboSpan" id="kobo.169.1"> subsection of this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.170.1">For the same reason, business validation rules that are specific for each entity are moved inside of DDD entities. </span><span class="koboSpan" id="kobo.170.2">DDD entity validation rules are business-level rules, so they must not be confused with database integrity rules or user-input validation rules. </span><span class="koboSpan" id="kobo.170.3">They contribute to</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.171.1"> the way entities represent domain objects by encoding the constraints the represented objects must obey.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.172.1">For instance, it might be obligatory to provide an entity property such as “Shipping Address” on a web page (user input validation rule), even though property is not obligatory in general (no corresponding business validation rule). </span><span class="koboSpan" id="kobo.172.2">In fact, the “Shipping Address” property becomes obligatory only if we need to ship something, so if the context of the web page is about shipping something, then “Shipping Address” must be obligatory as a user input in that specific web page but not as a general business rule.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.173.1">User input validation will be discussed in more detail in </span><em class="italic"><span class="koboSpan" id="kobo.174.1">Chapter 17</span></em><span class="koboSpan" id="kobo.175.1">, </span><em class="italic"><span class="koboSpan" id="kobo.176.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.177.1">, which will show, in practice, how user input validation and business validation have different and complementary purposes. </span><span class="koboSpan" id="kobo.177.2">While business-level validation rules encode domain rules, input validation rules enforce the format of every single input (string length, correct email and URL formats, and so on), ensure that all the necessary input has been provided, enforce the execution of the chosen user machine interaction protocols, and provide fast and immediate feedback that drives the user to interact with the system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.178.1">It is worth pointing out that not all business validation rules can be encoded inside DDD entities. </span><span class="koboSpan" id="kobo.178.2">Business rules that are not specific to single DDD entities but involve the interaction of several entities must be encoded in the software module that handles and coordinates the interaction among entities. </span><span class="koboSpan" id="kobo.178.3">We will speak more about the software module that coordinates entity interactions later on in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.179.1">The subsection that follows</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.180.1"> gives more details on entity-level validation rules.</span></p>
<h3 class="heading-3" id="_idParaDest-144"><span class="koboSpan" id="kobo.181.1">Entity-level validation in .NET</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.182.1">In .NET, business validation</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.183.1"> can be carried out with one of the following techniques:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.184.1">Calling the validation methods in all the class methods that modify the entity.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.185.1">Hooking the validation methods to all the property setters.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.186.1">Decorating the class and/or its properties with custom validation attributes and then invoking the </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">TryValidateObject</span></code><span class="koboSpan" id="kobo.188.1"> static method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">System.ComponentModel.DataAnnotations.Validator</span></code><span class="koboSpan" id="kobo.190.1"> class on the entity each time it is modified. </span><span class="koboSpan" id="kobo.190.2">The .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">System.ComponentModel.DataAnnotations</span></code><span class="koboSpan" id="kobo.192.1"> namespace contains predefined validation attributes (see </span><a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes"><span class="url"><span class="koboSpan" id="kobo.193.1">https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes</span></span></a><span class="koboSpan" id="kobo.194.1">), but the developer can define also custom validation attributes by inheriting from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">System.ComponentModel.DataAnnotations.ValidationAttribute</span></code><span class="koboSpan" id="kobo.196.1"> abstract class (see </span><a href="https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/"><span class="url"><span class="koboSpan" id="kobo.197.1">https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/</span></span></a><span class="koboSpan" id="kobo.198.1">).</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.199.1">More details on validation attributes will be given in </span><em class="chapterRef"><span class="koboSpan" id="kobo.200.1">Chapter 17</span></em><span class="koboSpan" id="kobo.201.1">, </span><em class="italic"><span class="koboSpan" id="kobo.202.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.203.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.204.1">Once detected, validation errors must be handled somehow; that is, the current operation must be aborted and the error must be reported to an appropriate error handler. </span><span class="koboSpan" id="kobo.204.2">The simplest way to handle validation errors is by throwing an exception. </span><span class="koboSpan" id="kobo.204.3">This way, both purposes are easily achieved and we can choose where to intercept and handle them. </span><span class="koboSpan" id="kobo.204.4">Unfortunately, as we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.205.1">Performance issues that need to be considered while programming in C#</span></em><span class="koboSpan" id="kobo.206.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.207.1">Chapter 2</span></em><span class="koboSpan" id="kobo.208.1">, </span><em class="italic"><span class="koboSpan" id="kobo.209.1">Non-Functional Requirements</span></em><span class="koboSpan" id="kobo.210.1">, exceptions imply big performance penalties and must be used to deal just with “exceptional circumstances” so, often, different options are considered. </span><span class="koboSpan" id="kobo.210.2">Handling errors in the normal flow of control would break modularity by spreading the code that’s needed to handle the error all over the stack of methods that caused the error, with a never-ending set of conditions all over that code. </span><span class="koboSpan" id="kobo.210.3">Therefore, more sophisticated options are needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.211.1">A good alternative to exceptions is to notify errors to an error handler that is unique for each processing request. </span><span class="koboSpan" id="kobo.211.2">For instance, it can be implemented as a scoped service in the dependency injection engine. </span><span class="koboSpan" id="kobo.211.3">Being scoped, the same service instance is returned while each request is being processed so that the handler that controls the execution of the whole call stack can inspect possible errors when the flow of control returns to it, and can handle them </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.212.1">appropriately. </span><span class="koboSpan" id="kobo.212.2">Unfortunately, this sophisticated technique can’t automatically abort the operation’s execution and return immediately to the most adequate controlling handler that is in the call stack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.213.1">This is why exceptions are often used for this scenario, notwithstanding their performance issues. </span><span class="koboSpan" id="kobo.213.2">The other option is the</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.214.1"> usage of a </span><strong class="keyWord"><span class="koboSpan" id="kobo.215.1">result object</span></strong><span class="koboSpan" id="kobo.216.1"> that informs the caller of the success of the operation in all method calls. </span><span class="koboSpan" id="kobo.216.2">However, result objects have their cons: they imply more coupling between the methods involved in the call stack, so during software maintenance, each change might require modifications in several methods.</span></p>
<h3 class="heading-3" id="_idParaDest-145"><span class="koboSpan" id="kobo.217.1">DDD entities in .NET</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.218.1">Since DDD entities must have a well-defined identity, they must have properties that act as primary keys. </span><span class="koboSpan" id="kobo.218.2">It is common to</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.219.1"> override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">Object.Equals</span></code><span class="koboSpan" id="kobo.221.1"> method of all the DDD entities in such a way that two objects are considered equal whenever they have the same primary keys. </span><span class="koboSpan" id="kobo.221.2">This is easily achieved by letting all the entities inherit from an abstract </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">Entity</span></code><span class="koboSpan" id="kobo.223.1"> class, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.225.1">abstract</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.226.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.227.1">Entity</span></span><span class="koboSpan" id="kobo.228.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.229.1">K</span></span><span class="koboSpan" id="kobo.230.1">&gt;: </span><span class="hljs-title"><span class="koboSpan" id="kobo.231.1">IEntity</span></span><span class="koboSpan" id="kobo.232.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.233.1">K</span></span><span class="koboSpan" id="kobo.234.1">&gt;
{
       
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.235.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.236.1">virtual</span></span><span class="koboSpan" id="kobo.237.1"> K Id { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.238.1">get</span></span><span class="koboSpan" id="kobo.239.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">protected</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">set</span></span><span class="koboSpan" id="kobo.242.1">; }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.243.1">public</span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.244.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.245.1">IsTransient</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.246.1">()</span></span><span class="koboSpan" id="kobo.247.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.248.1">return</span></span><span class="koboSpan" id="kobo.249.1"> Object.Equals(Id, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.250.1">default</span></span><span class="koboSpan" id="kobo.251.1">(K));
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.253.1">override</span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.254.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.255.1">Equals</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.256.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.257.1">object</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.258.1"> obj</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.259.1">)</span></span><span class="koboSpan" id="kobo.260.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">return</span></span><span class="koboSpan" id="kobo.262.1"> obj </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">is</span></span><span class="koboSpan" id="kobo.264.1"> Entity&lt;K&gt; entity &amp;&amp;
          Equals(entity);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.265.1">public</span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.266.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.267.1">Equals</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.268.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.269.1">IEntity&lt;K&gt;? </span><span class="koboSpan" id="kobo.269.2">other</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.270.1">)</span></span><span class="koboSpan" id="kobo.271.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.272.1">if</span></span><span class="koboSpan" id="kobo.273.1"> (other == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.274.1">null</span></span><span class="koboSpan" id="kobo.275.1"> ||
            other.IsTransient() || </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.276.1">this</span></span><span class="koboSpan" id="kobo.277.1">.IsTransient())
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.278.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.279.1">false</span></span><span class="koboSpan" id="kobo.280.1">;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.281.1">return</span></span><span class="koboSpan" id="kobo.282.1"> Object.Equals(Id, other.Id);
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.283.1">int</span></span><span class="koboSpan" id="kobo.284.1">? </span><span class="koboSpan" id="kobo.284.2">_requestedHashCode;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.285.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.286.1">override</span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.287.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.288.1">GetHashCode</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.289.1">()</span></span><span class="koboSpan" id="kobo.290.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.291.1">if</span></span><span class="koboSpan" id="kobo.292.1"> (!IsTransient())
        {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.293.1">if</span></span><span class="koboSpan" id="kobo.294.1"> (!_requestedHashCode.HasValue)
                _requestedHashCode = HashCode.Combine(Id);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.295.1">return</span></span><span class="koboSpan" id="kobo.296.1"> _requestedHashCode.Value;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.297.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.298.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.299.1">base</span></span><span class="koboSpan" id="kobo.300.1">.GetHashCode();
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.301.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.302.1">static</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.303.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.304.1">operator</span></span><span class="koboSpan" id="kobo.305.1"> ==(Entity&lt;K&gt; left, Entity&lt;K&gt; right)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.306.1">if</span></span><span class="koboSpan" id="kobo.307.1"> (Object.Equals(left, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.308.1">null</span></span><span class="koboSpan" id="kobo.309.1">))
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.310.1">return</span></span><span class="koboSpan" id="kobo.311.1"> Object.Equals(right, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.312.1">null</span></span><span class="koboSpan" id="kobo.313.1">);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">return</span></span><span class="koboSpan" id="kobo.315.1"> left.Equals(right);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.316.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.317.1">static</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.318.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.319.1">operator</span></span><span class="koboSpan" id="kobo.320.1"> !=(Entity&lt;K&gt; left, Entity&lt;K&gt; right)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.321.1">return</span></span><span class="koboSpan" id="kobo.322.1"> !(left == right);
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.323.1">Note the following</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.324.1"> things in the code:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.325.1">It is worth implementing an </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">IEntity&lt;K&gt;</span></code><span class="koboSpan" id="kobo.327.1"> interface that defines all the properties/methods of </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">Entity&lt;K&gt;</span></code><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">This interface is useful whenever we need to hide data classes behind interfaces.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.330.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">IsTransient</span></code><span class="koboSpan" id="kobo.332.1"> predicate returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">true</span></code><span class="koboSpan" id="kobo.334.1"> whenever the entity has been recently created and hasn’t been recorded in the permanent storage, so its primary key is still undefined.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.335.1">In .NET, it is good practice that, whenever you override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">Object.Equals</span></code><span class="koboSpan" id="kobo.337.1"> method of a class, you also override its </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">Object.GetHashCode</span></code><span class="koboSpan" id="kobo.339.1"> method so that class instances can be efficiently stored in data structures such as dictionaries and sets. </span><span class="koboSpan" id="kobo.339.2">That’s why the </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">Entity</span></code><span class="koboSpan" id="kobo.341.1"> class overrides it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.342.1">It is worth pointing out that once we’ve redefined the </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">Object.Equals</span></code><span class="koboSpan" id="kobo.344.1"> method in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">Entity</span></code><span class="koboSpan" id="kobo.346.1"> class, we can also override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">==</span></code><span class="koboSpan" id="kobo.348.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">!=</span></code><span class="koboSpan" id="kobo.350.1"> operators.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.351.1">Entities are not the only data</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.352.1"> ingredient of DDD. </span><span class="koboSpan" id="kobo.352.2">Domain modeling also requires data with no unique identities. </span><span class="koboSpan" id="kobo.352.3">That’s why value objects were conceived.</span></p>
<h2 class="heading-2" id="_idParaDest-146"><span class="koboSpan" id="kobo.353.1">Value objects</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.354.1">Value objects, in contrast to entities, represent complex types that can’t be encoded with numbers or strings. </span><span class="koboSpan" id="kobo.354.2">Therefore, they have no identity and no principal keys. </span><span class="koboSpan" id="kobo.354.3">They have no operations defined on them and are immutable; that is, once they’ve been created, all their fields </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.355.1">can be read but cannot be modified. </span><span class="koboSpan" id="kobo.355.2">For this reason, they </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.356.1">are usually encoded with classes whose properties have protected/private setters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.357.1">Two value objects are considered equal when all their independent properties are equal. </span><span class="koboSpan" id="kobo.357.2">Some properties are not independent since they just show data that’s been encoded by other properties in a different way, as is the case for the ticks of </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">DateTime</span></code><span class="koboSpan" id="kobo.359.1"> and its representation of the date and time fields.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.360.1">Value objects are easily implemented with C# 12 </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">record</span></code><span class="koboSpan" id="kobo.362.1"> types since all </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">record</span></code><span class="koboSpan" id="kobo.364.1"> types automatically override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">Equals</span></code><span class="koboSpan" id="kobo.366.1"> method so that it performs a property-by-property comparison. </span><span class="koboSpan" id="kobo.366.2">Record types can also be made immutable by adequately defining their properties; once immutable objects are initialized, the only way to change their values is to create a new instance. </span><span class="koboSpan" id="kobo.366.3">Here is an example of how to modify a </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">record</span></code><span class="koboSpan" id="kobo.368.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.369.1">var</span></span><span class="koboSpan" id="kobo.370.1"> modifiedAddress = myAddress </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.371.1">with</span></span><span class="koboSpan" id="kobo.372.1"> {Street = </span><span class="hljs-string"><span class="koboSpan" id="kobo.373.1">"new street"</span></span><span class="koboSpan" id="kobo.374.1">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.375.1">Here is an example of how to define a </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">record</span></code><span class="koboSpan" id="kobo.377.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.378.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.379.1">record</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.380.1">Address</span></span><span class="koboSpan" id="kobo.381.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.382.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.383.1">string</span></span><span class="koboSpan" id="kobo.384.1"> Country {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.385.1">get</span></span><span class="koboSpan" id="kobo.386.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">init</span></span><span class="koboSpan" id="kobo.388.1">;}
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.390.1">string</span></span><span class="koboSpan" id="kobo.391.1"> Town {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.392.1">get</span></span><span class="koboSpan" id="kobo.393.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">init</span></span><span class="koboSpan" id="kobo.395.1">;}
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.396.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.397.1">string</span></span><span class="koboSpan" id="kobo.398.1"> Street {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.399.1">get</span></span><span class="koboSpan" id="kobo.400.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.401.1">init</span></span><span class="koboSpan" id="kobo.402.1">;}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.403.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">init</span></code><span class="koboSpan" id="kobo.405.1"> keyword is what makes </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">record</span></code><span class="koboSpan" id="kobo.407.1"> type properties immutable since it means they can only be initialized.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.408.1">If we pass all the properties in the constructor instead of using initializers, the preceding definition can be simplified as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.409.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.410.1">record</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.411.1">Address</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.412.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.413.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.414.1"> Country, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.415.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.416.1"> Town, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.417.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.418.1"> Street</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.419.1">)</span></span><span class="koboSpan" id="kobo.420.1"> ;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.421.1">Typical value objects include costs represented as a number and a currency symbol, locations represented as</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.422.1"> longitude and latitude, addresses, and contact information.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.423.1">The way both entities and value objects typically interact with data storage in .NET applications is explained in </span><em class="chapterRef"><span class="koboSpan" id="kobo.424.1">Chapter 13</span></em><span class="koboSpan" id="kobo.425.1">, </span><em class="italic"><span class="koboSpan" id="kobo.426.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.427.1">.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-147"><span class="koboSpan" id="kobo.428.1">Aggregates</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.429.1">So far, we have talked about entities as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.430.1">units</span></strong><span class="koboSpan" id="kobo.431.1"> that are processed by a DDD-based business layer. </span><span class="koboSpan" id="kobo.431.2">However, several entities can be manipulated and made into single entities. </span><span class="koboSpan" id="kobo.431.3">An example of this is a</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.432.1"> purchase order and all of its items. </span><span class="koboSpan" id="kobo.432.2">In fact, it makes </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.433.1">absolutely no sense to process a single order item independently of the order it belongs to. </span><span class="koboSpan" id="kobo.433.2">This happens because order items are actually subparts of an order, not independent entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.434.1">There is no transaction that may affect a single order item without it affecting the order that the item is in. </span><span class="koboSpan" id="kobo.434.2">Imagine that two different people in the same company are trying to increase the total quantity of cement, but one increases the quantity of type-1 cement (item 1) while the other increases the quantity of type-2 cement (item 2). </span><span class="koboSpan" id="kobo.434.3">If each item is processed as an independent entity, both quantities will be increased, which could cause an incoherent purchase order since the total quantity of cement would be increased twice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.435.1">On the other hand, if the whole order, along with all its order items, is loaded and saved with every single transaction by both people, one of the two will overwrite the changes of the other one, so whoever makes the final change will have their requirements set.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.436.1">A purchase order, along with all its subparts (its order items), is called an </span><strong class="keyWord"><span class="koboSpan" id="kobo.437.1">aggregate</span></strong><span class="koboSpan" id="kobo.438.1">, while the order entity is </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.439.1">called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.440.1">root</span></strong><span class="koboSpan" id="kobo.441.1"> of the aggregate. </span><span class="koboSpan" id="kobo.441.2">Aggregates always have roots since they are hierarchies of entities connected</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.442.1"> by </span><strong class="keyWord"><span class="koboSpan" id="kobo.443.1">subpart</span></strong><span class="koboSpan" id="kobo.444.1"> relationships.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.445.1">Since each aggregate represents a single complex entity, all the operations on it must be exposed by a unique interface. </span><span class="koboSpan" id="kobo.445.2">Therefore, the aggregate root usually represents the whole aggregate, and all the </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.446.1">operations on the aggregate are defined as methods of the root entity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.447.1">When the aggregate pattern is used, the units of information that are transferred between the business layer and the data layer are called aggregates, queries, and query results. </span><span class="koboSpan" id="kobo.447.2">Thus, aggregates replace single entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.448.1">In a few words, aggregates </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.449.1">are in-memory representations of storage information that need to be dealt with as a single object. </span><span class="koboSpan" id="kobo.449.2">Being an in-memory representation based on an object-oriented paradigm, they take full advantage of all the benefits of object-oriented programming.</span></p>
<h2 class="heading-2" id="_idParaDest-148"><span class="koboSpan" id="kobo.450.1">Domain events</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.451.1">Domain events are the main </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.452.1">communication ingredient of DDD. </span><span class="koboSpan" id="kobo.452.2">While DDD doesn’t impose constraints on the way communication among bounded contexts is achieved, a communication based on the publisher/subscriber pattern described in </span><em class="italic"><span class="koboSpan" id="kobo.453.1">Chapter 6</span></em><span class="koboSpan" id="kobo.454.1">, </span><em class="italic"><span class="koboSpan" id="kobo.455.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.456.1">, maximizes independence among bounded contexts. </span><span class="koboSpan" id="kobo.456.2">Each bounded context publishes all information that might interest other bounded contexts, and interested bounded contexts subscribe. </span><span class="koboSpan" id="kobo.456.3">This way, the publisher doesn’t need to know about each</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.457.1"> subscriber and how it works, but just publish the result of its job in a general format. </span><span class="koboSpan" id="kobo.457.2">More implementation details will be given in the</span><em class="italic"><span class="koboSpan" id="kobo.458.1"> Command handlers and domain events</span></em><span class="koboSpan" id="kobo.459.1"> subsection of this chapter.</span></p>
<h1 class="heading-1" id="_idParaDest-149"><span class="koboSpan" id="kobo.460.1">Common DDD patterns and architectures</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.461.1">In this and the sections that follow, we will describe some of the patterns and architectures that are commonly used with DDD. </span><span class="koboSpan" id="kobo.461.2">Some of them can be adopted in all projects, while others can only be</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.462.1"> used for certain Bounded Contexts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.463.1">Before we begin, we should note that, from a conceptual point of view, the functionality of each application can be classified into three groups:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.464.1">Handling the interaction with the user</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.465.1">Performing business-related processing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.466.1">Interacting with the storage engine</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.467.1">Each of the above groups uses a different language and different technologies. </span><span class="koboSpan" id="kobo.467.2">The first group uses the language of the target users and user interface technologies, the second group uses the language of the domain expert and is focused on application domain modeling, and the third group uses both language and technologies related to databases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.468.1">Each of the architectures we will look at organize these functionalities in different ways. </span><span class="koboSpan" id="kobo.468.2">We will start with the classic layers architecture since it is simpler to understand, and then we will describe the more sophisticated onion architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-150"><span class="koboSpan" id="kobo.469.1">Classic layers architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.470.1">The classic layers architecture organizes the</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.471.1"> three groups of functionalities as three loosely coupled sets of classes/interfaces called </span><strong class="keyWord"><span class="koboSpan" id="kobo.472.1">layers</span></strong><span class="koboSpan" id="kobo.473.1">, put one </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.474.1">after the other:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.475.1">The first layer in the sequence</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.476.1"> is the one that takes care of user interaction and is called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.477.1">presentation layer</span></strong><span class="koboSpan" id="kobo.478.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.479.1">The second layer in the</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.480.1"> sequence is the one that performs business-related processing and is called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.481.1">business layer</span></strong><span class="koboSpan" id="kobo.482.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.483.1">The third layer is the one dedicated to </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.484.1">database interaction and is called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.485.1">data layer</span></strong><span class="koboSpan" id="kobo.486.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.487.1">Each layer can communicate directly just with the layer that precedes it and the layer that follows it, as shown in the figure below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.488.1"><img alt="" role="presentation" src="../Images/B19820_07_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.489.1">Figure 7.3: Classic layers architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.490.1">Each layer call can pass data to methods of public objects in the layer that follows it and receive the resulting data back.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.491.1">The presentation layer handles not only graphics but also the whole user-machine interaction protocol. </span><span class="koboSpan" id="kobo.491.2">During</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.492.1"> its interaction protocol, the presentation layer uses business layer methods either to present data to the user or to update the application state.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.493.1">In turn, the business layer uses data layer methods to retrieve all data it needs to prepare the user answer from the data storage and to update the application state.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.494.1">Each layer offers a well-defined interface to the layer that precedes it while hiding all implementation details.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.495.1">The layer architecture promotes modularity since each layer doesn’t depend on how the layers that precede it are implemented, and avoids the possibility of the language used by each layer contaminating the language used by the others.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.496.1">However, data exchanged in the classic layer architecture are record-type objects with no methods that encode any processing logic, since the whole processing logic is contained in the objects and methods that compose the three layers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Since record-like objects used by the classic layers architecture are very different from DDD domain objects, which are rich objects that encode most of the business logic in their methods, the classic</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.498.1"> layers architecture has a poor match with DDD. </span><span class="koboSpan" id="kobo.498.2">That’s why an improvement on the classic layers architecture, called the onion architecture, has been proposed.</span></p>
<h2 class="heading-2" id="_idParaDest-151"><span class="koboSpan" id="kobo.499.1">Onion architecture</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.500.1">In the onion architecture, layers</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.501.1"> obey different rules and are defined in a slightly different way. </span><span class="koboSpan" id="kobo.501.2">There is:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.502.1">An outermost layer that takes care of all interactions with the application environment—that is, user interface, test software, and interaction with operating system and data storage</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.503.1">An application layer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.504.1">A domain layer</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.505.1">Here, the domain layer is an abstraction of the classical data layer based on the Ubiquitous Language. </span><span class="koboSpan" id="kobo.505.2">It is where DDD entities and value objects are defined, together with abstractions of the operations that retrieve and save them. </span><span class="koboSpan" id="kobo.505.3">For better modularity, all or some domain layer classes may be made internal and hidden behind public interfaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.506.1">The application layer, instead, defines operations that use the domain layer public interface (public interfaces and public classes) to get DDD entities and value objects and manipulate them to implement the application business logic. </span><span class="koboSpan" id="kobo.506.2">The DDD application layer is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.507.1">application services</span></strong><span class="koboSpan" id="kobo.508.1"> since it </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.509.1">exposes its functionalities through an API that is completely independent of the outermost layers. </span><span class="koboSpan" id="kobo.509.2">This way, for instance, any user interface layer and a test suite both call exactly the same methods to interact with the application logic.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.510.1">The outermost layer contains the user interface, the functional test suites (if any), and the application interface with the infrastructure that hosts the application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.511.1">The infrastructure represents the environment in which the application runs and includes the operating system, any devices, filesystem services, cloud services, and databases. </span><span class="koboSpan" id="kobo.511.2">The infrastructure interface is placed on the outermost level to ensure that no other onion layer depends on it. </span><span class="koboSpan" id="kobo.511.3">This maximizes both usability and modifiability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.512.1">The infrastructure layer contains all the drivers needed to adapt the application to its environment. </span><span class="koboSpan" id="kobo.512.2">Infrastructure resources communicate with the application through these drivers, and, in turn, drivers expose the infrastructure resources to all application layers through interfaces that are </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.513.1">associated with the drivers implementing them in the dependency injection engine. </span><span class="koboSpan" id="kobo.513.2">This way, adapting the application to a different environment just requires changing the drivers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.514.1">Here’s a sketch of the onion architecture:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.515.1"><img alt="" role="presentation" src="../Images/B19820_07_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.516.1">Figure 7.4: Onion architecture</span></p>
<p class="normal"><span class="koboSpan" id="kobo.517.1">Each ring is a layer. </span><span class="koboSpan" id="kobo.517.2">Inward from the outermost</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.518.1"> layer are the </span><strong class="keyWord"><span class="koboSpan" id="kobo.519.1">application services</span></strong><span class="koboSpan" id="kobo.520.1">, and inward from the application </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.521.1">services we have the </span><strong class="keyWord"><span class="koboSpan" id="kobo.522.1">domain layer</span></strong><span class="koboSpan" id="kobo.523.1">, which contains the representation of the entities involved in the Bounded Context knowledge.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.524.1">Both the application services</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.525.1"> and the domain layer can be split into sublayers, and all layers/sublayers must conform to the following rule: </span><em class="italic"><span class="koboSpan" id="kobo.526.1">Each layer may depend only on the inner layers.</span></em></p>
<p class="normal"><span class="koboSpan" id="kobo.527.1">For instance, the domain layer </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.528.1">may be split into </span><strong class="keyWord"><span class="koboSpan" id="kobo.529.1">Domain Model</span></strong><span class="koboSpan" id="kobo.530.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.531.1">Domain Services</span></strong><span class="koboSpan" id="kobo.532.1">, where Domain Model</span><em class="italic"> </em><span class="koboSpan" id="kobo.533.1">is below Domain Services. </span><span class="koboSpan" id="kobo.533.2">The </span><em class="italic"><span class="koboSpan" id="kobo.534.1">Domain Model</span></em><span class="koboSpan" id="kobo.535.1"> layer </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.536.1">contains the classes and interfaces that represent all domain objects, while the </span><em class="italic"><span class="koboSpan" id="kobo.537.1">Domain Services</span></em><span class="koboSpan" id="kobo.538.1"> layer contains the so-called repositories that are explained later on in this chapter in the</span><em class="italic"><span class="koboSpan" id="kobo.539.1"> Repository pattern</span></em><span class="koboSpan" id="kobo.540.1"> and</span><em class="italic"><span class="koboSpan" id="kobo.541.1"> Unit of work pattern </span></em><span class="koboSpan" id="kobo.542.1">sections.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.543.1">As we will see later on in this chapter, it is common to interact with the domain layer through interfaces that are defined in a separate library and implemented in the domain layer. </span><span class="koboSpan" id="kobo.543.2">Thus, the domain layer must have a reference to the library containing all domain layer interfaces since it must implement those interfaces, while the application layer is where each domain layer interface is connected with its implementation through a record of the application layer dependency injection engine. </span><span class="koboSpan" id="kobo.543.3">More specifically, the only data layer objects referenced by the application layer are these interface implementations that are only referenced in the dependency injection engine.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.544.1">Outer layers that implement interfaces defined in the next inner layer are a common pattern used in the onion architecture.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.545.1">Each application layer operation requires the interfaces it needs from the dependency engine, uses them to get DDD entities and value objects, manipulates them, and possibly saves them through the same interfaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.546.1">Here is a diagram that shows the relationships among the three layers discussed in this section:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.547.1"><img alt="" role="presentation" src="../Images/B19820_07_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.548.1">Figure 7.5: Relationships among the layers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.549.1">Thus, the domain layer</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.550.1"> contains the representation of the domain objects, the methods to use on them, validation constraints, and the domain layer’s relationship with various entities. </span><span class="koboSpan" id="kobo.550.2">To increase modularity and decoupling, communication among entities is usually encoded with events—that is, with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.551.1">Publisher/Subscriber pattern</span></strong><span class="koboSpan" id="kobo.552.1">. </span><span class="koboSpan" id="kobo.552.2">This means entity updates can trigger events that have been hooked to business operations, and these </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.553.1">events act on other entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.554.1">This layered architecture allows us to change the whole data layer without affecting the domain layer, which only depends on the domain specifications and language and doesn’t depend on the technical details of how the data is handled.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">The application layer contains the definitions of all the operations that may potentially affect several entities and the definitions of all the queries that are needed by the applications. </span><span class="koboSpan" id="kobo.555.2">Both business operations and queries use the interfaces defined in the domain layer to interact with the data layer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.556.1">However, while business operations manipulate and exchange entities with these interfaces, queries send query specifications and </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.557.1">receive generic </span><strong class="keyWord"><span class="koboSpan" id="kobo.558.1">Data Transfer Objects</span></strong><span class="koboSpan" id="kobo.559.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.560.1">DTOs</span></strong><span class="koboSpan" id="kobo.561.1">) from them. </span><span class="koboSpan" id="kobo.561.2">In fact, the</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.562.1"> purpose of queries is just to show data to the user, not to act on them; accordingly, query operations don’t need whole entities with all their methods, properties, and validation rules, but just property tuples.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.563.1">Business operations are invoked either by other layers (typically the presentation layer) or by communication operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.564.1">Summing up, the application layer operates on the interfaces defined in the domain layer instead of interacting directly with their data layer implementations, which means that the application layer is decoupled from the data layer. </span><span class="koboSpan" id="kobo.564.2">More specifically, data layer objects are only mentioned in the dependency injection engine definitions. </span><span class="koboSpan" id="kobo.564.3">All the other application layer components refer to the interfaces that are defined in the domain layers, and the dependency injection engine injects the appropriate implementations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.565.1">The application layer communicates with other application components through one or more of the following patterns:</span></p>
<ul>
<li class="bulletList"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.566.1">It exposes business operations and queries on a communication endpoint</span></strong><span class="koboSpan" id="kobo.567.1">, such as an HTTP Web API (see </span><em class="chapterRef"><span class="koboSpan" id="kobo.568.1">Chapter 15</span></em><span class="koboSpan" id="kobo.569.1">, </span><em class="italic"><span class="koboSpan" id="kobo.570.1">Applying Service-Oriented Architectures with .NET</span></em><span class="koboSpan" id="kobo.571.1">). </span><span class="koboSpan" id="kobo.571.2">In this case, the presentation layer may connect to this endpoint or to other endpoints that, in turn, take information from this and other endpoints. </span><span class="koboSpan" id="kobo.571.3">Application components that collect information from several endpoints and expose them in a</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.572.1"> unique endpoint are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.573.1">gateways</span></strong><span class="koboSpan" id="kobo.574.1">. </span><span class="koboSpan" id="kobo.574.2">They may be either custom or general-purpose, such as Ocelot.</span></li>
<li class="bulletList"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.575.1">It is referenced as a library by an application that directly implements the presentation layer</span></strong><span class="koboSpan" id="kobo.576.1">, such as an ASP.NET Core MVC Web application.</span></li>
<li class="bulletList"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.577.1">It doesn’t expose all the information through endpoints and communicates some of the data it processes/creates to other application components that, in turn, expose endpoints</span></strong><span class="koboSpan" id="kobo.578.1">. </span><span class="koboSpan" id="kobo.578.2">Such communication is often implemented with the Publisher/Subscriber pattern to increase modularity.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-152"><span class="koboSpan" id="kobo.579.1">Repository pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.580.1">The repository pattern is an entity-centric </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.581.1">approach to the definition of the domain layer interfaces: each entity—or better, each aggregate—has its own repository interface that defines how to retrieve and create it, and</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.582.1"> defines all queries that involve entities in the aggregate. </span><span class="koboSpan" id="kobo.582.2">The implementation of each repository</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.583.1"> interface is called a repository. </span><span class="koboSpan" id="kobo.583.2">Repositories are associated with aggregates instead of entities, since, as discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.584.1">Aggregates</span></em><span class="koboSpan" id="kobo.585.1"> subsection, aggregates represent the minimum granularity that makes sense to consider in each data operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.586.1">With the repository pattern, each operation has an easy-to-find place where it must be defined: the interface of the aggregate the operation works on, or, in the case of a query, the aggregate that contains the root entity of the query.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.587.1">The repository pattern was initially conceived for the classical layer architecture and its record-like objects. </span><span class="koboSpan" id="kobo.587.2">Then, it was adapted to work with rich DDD entities/aggregates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.588.1">Classical repositories contain all methods needed to handle record-like objects—that is, modification, creation and delete methods since record-like objects have no modification methods. </span><span class="koboSpan" id="kobo.588.2">DDD-adapted repositories, instead, only contain create and delete methods since all methods that modify each aggregate are defined as aggregate methods. </span><span class="koboSpan" id="kobo.588.3">Moreover, applications based on classic repositories and record-like objects do not have a unique record-like object that represents each domain aggregate, but there are several record-like objects, each containing a different view of the overall domain aggregate. </span><span class="koboSpan" id="kobo.588.4">Therefore, classic repositories have modification methods for several different record-like objects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.589.1">Both classic and DDD-adapted repositories have methods to retrieve data to be returned to the user. </span><span class="koboSpan" id="kobo.589.2">In both cases, this data is represented by record-like objects, since aggregates are built only when domain entities must be modified or created.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.590.1">The diagram below summarizes the differences between classical and DDD-adapted repository patterns.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.591.1"><img alt="" role="presentation" src="../Images/B19820_07_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.592.1">Figure 7.6: Classical and DDD-adapted repository pattern</span></p>
<h3 class="heading-3" id="_idParaDest-153"><span class="koboSpan" id="kobo.593.1">Unit of work pattern</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.594.1">While it is preferable for transactions to be confined within the boundary of a single aggregate design, sometimes application</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.595.1"> layer transactions might span </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.596.1">several aggregates and, accordingly, might use several different repository interfaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.597.1">For instance, buying a travel involves the simultaneous modifications of the following entities:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.598.1">Hotel/travel available places</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.599.1">Customer shopping basket</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.600.1">Both operations must be accomplished in a single transaction since either they are both successful or they must both fail. </span><span class="koboSpan" id="kobo.600.2">Therefore, we need a way to execute operations on several entities/aggregates in a single transaction, while keeping the methods/code of the involved entities decoupled, according to object-oriented programming best practices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.601.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.602.1">Unit of Work</span></strong><span class="koboSpan" id="kobo.603.1"> pattern is a solution that maintains the independence of the domain layer from the underlying domain layer implementation. </span><span class="koboSpan" id="kobo.603.2">It states that each repository interface must also contain</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.604.1"> a reference to a Unit of Work interface that represents the identity of the current transaction. </span><span class="koboSpan" id="kobo.604.2">This means that several repositories </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.605.1">with the same Unit of Work reference belong to the same transaction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.606.1">The Unit of Work pattern can be used with both aggregates and record-like entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.607.1">Both the repository and the Unit of Work patterns can be implemented by defining some seed interfaces:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.610.1">IUnitOfWork</span></span><span class="koboSpan" id="kobo.611.1">
{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.612.1">Task&lt;</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.613.1">bool</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.614.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.615.1">SaveEntitiesAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.616.1">()</span></span><span class="koboSpan" id="kobo.617.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.618.1">Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.619.1">StartAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.620.1">()</span></span><span class="koboSpan" id="kobo.621.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.622.1">Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.623.1">CommitAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.624.1">()</span></span><span class="koboSpan" id="kobo.625.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.626.1">Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.627.1">RollbackAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.628.1">()</span></span><span class="koboSpan" id="kobo.629.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.630.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.631.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.632.1">IRepository</span></span><span class="koboSpan" id="kobo.633.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.634.1">T</span></span><span class="koboSpan" id="kobo.635.1">&gt;: </span><span class="hljs-title"><span class="koboSpan" id="kobo.636.1">IRepository</span></span><span class="koboSpan" id="kobo.637.1">
{
   IUnitOfWork UnitOfWork { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.638.1">get</span></span><span class="koboSpan" id="kobo.639.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.640.1">All repository interfaces inherit from </span><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">IRepository&lt;T&gt;</span></code><span class="koboSpan" id="kobo.642.1"> and bind </span><code class="inlineCode"><span class="koboSpan" id="kobo.643.1">T</span></code><span class="koboSpan" id="kobo.644.1"> to the aggregate root or entity they are associated with, while Unit of Work simply implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.646.1">. </span><span class="koboSpan" id="kobo.646.2">When </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">SaveEntitiesAsync()</span></code><span class="koboSpan" id="kobo.648.1"> is called, all pending modifications, deletions, and creations done on aggregates or record-like objects are saved in a single transaction in the storage engine. </span><span class="koboSpan" id="kobo.648.2">If a wider transaction that starts when some data is retrieved from the storage engine is needed, it must be started and committed/aborted by the application layer handler, which takes care of the whole operation with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">IUnitOfWork</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.650.1">StartAsync</span></code><span class="koboSpan" id="kobo.651.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">CommitAsync</span></code><span class="koboSpan" id="kobo.653.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.654.1">RollbackAsync</span></code><span class="koboSpan" id="kobo.655.1"> methods. </span><code class="inlineCode"><span class="koboSpan" id="kobo.656.1">IRepository&lt;T&gt;</span></code><span class="koboSpan" id="kobo.657.1"> inherits from an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">IRepository</span></code><span class="koboSpan" id="kobo.659.1"> interface </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.660.1">to help automatic</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.661.1"> repository discovery.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.662.1">The GitHub repository associated with this book contains a </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">RepositoryExtensions</span></code><span class="koboSpan" id="kobo.664.1"> class whose </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">AddAllRepositories</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.666.1">IServiceCollection</span></code><span class="koboSpan" id="kobo.667.1"> extension method automatically discovers all the repository implementations contained in an assembly and adds them to the dependency injection engine.</span></p>
</div>
<h3 class="heading-3" id="_idParaDest-154"><span class="koboSpan" id="kobo.668.1">Classic repository pattern versus DDD aggregates</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.669.1">The DDD patterns discussed so far, such as aggregates and DDD-adapted repositories, ensure modularity and modifiability, and, since whole domain aggregates are loaded in memory, they also prevent various kinds</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.670.1"> of bugs due to wrong partial updates. </span><span class="koboSpan" id="kobo.670.2">However, each addition of new functionality is cumbersome since it usually</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.671.1"> involves a complex modeling activity, the reengineering or creation of whole aggregates, and the definition of several classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.672.1">On the one hand, record-like objects are easier to define and we may define different classes for different usages. </span><span class="koboSpan" id="kobo.672.2">So, adding a new functionality simply requires the definition of an independent repository method, and possibly the definition of a new record-like class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.673.1">Suppose we need just to maintain travel descriptions and features. </span><span class="koboSpan" id="kobo.673.2">It is a very simple domain, and we need just to perform CRUD operations—that is, creating and deleting travels and modifying their features. </span><span class="koboSpan" id="kobo.673.3">In this case, there is no advantage in loading the whole aggregates in memory and performing all operations as methods of a unique entity class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.674.1">On the other hand, with the classical repository pattern, we can load just the features of the travel we would like to modify, say a marketing-optimized description in some web pages, price in other pages where the user is an administrator with the power of deciding on prices, and so on. </span><span class="koboSpan" id="kobo.674.2">This way each operation uses a different object that is specific and optimized for that operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.675.1">Suppose now we are designing a complex resource allocation software for an industrial application. </span><span class="koboSpan" id="kobo.675.2">All properties of each entity are constrained by complex business rules, and also several entities are constrained by several complex business rules. </span><span class="koboSpan" id="kobo.675.3">Therefore, a partial update of a few properties has consequences that propagate to the whole entity and to other connected entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.676.1">In this case, each classical repository method would be forced to take into account all possible consequences of each property change, resulting in complex spaghetti code and in the recoding of the same</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.677.1"> operations several times in different repository methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.678.1">In this case, a DDD approach </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.679.1">performs much better. </span><span class="koboSpan" id="kobo.679.2">We load in memory the full aggregates involved and let their methods handle the business rule complexity with the help of object-oriented best practices. </span><span class="koboSpan" id="kobo.679.3">It is enough that each aggregate encodes the behavior of the real word object it represents, with no need to care about consequences on other entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.680.1">Summing up, when a Bounded Context is quite simple, meaning a few entities with a few interactions among them and a few different update operations, there is no doubt that the classic repository pattern is more convenient. </span><span class="koboSpan" id="kobo.680.2">On the other hand, when there are many entities, or complex entities, and many different update operations are added, repositories turn into spaghetti code with several partially overlapping methods, code duplication, and no easy-to-understand interaction rules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.681.1">A full example showing the DDD-adapted repository pattern is given in the </span><em class="italic"><span class="koboSpan" id="kobo.682.1">A frontend microservice</span></em><span class="koboSpan" id="kobo.683.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.684.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.685.1">, while a full example showing the classical repository pattern is given in the </span><em class="italic"><span class="koboSpan" id="kobo.686.1">Using client technologies </span></em><span class="koboSpan" id="kobo.687.1">section of the same chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.688.1">Moreover, as already pointed out, partial updates performed by several record-like projections of domain aggregates may cause bugs due to simultaneous modifications performed by different users. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.689.1">Therefore, when the probability of similar bugs becomes high because of complex update patterns, it is very dangerous to use the classic repository pattern.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.690.1">Thus, again, complexity is the main factor that drives us to the usage of DDD patterns. </span><span class="koboSpan" id="kobo.690.2">Moreover, the need to centralize the triggering of domain events used to synchronize Bounded Context data stores (review the previous </span><em class="italic"><span class="koboSpan" id="kobo.691.1">Understanding domain-driven design</span></em><span class="koboSpan" id="kobo.692.1"> section) forces the loading of whole aggregates in memory, and the usage of DDD patterns. </span><span class="koboSpan" id="kobo.692.2">Therefore, when a Bounded Context needs to trigger several domain events in complex circumstances, we can’t use the simpler classic repository pattern.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.693.1">Now that we’ve discussed </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.694.1">the basic patterns of DDD, we can discuss </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.695.1">some more advanced DDD patterns. </span><span class="koboSpan" id="kobo.695.2">In the next section, we will introduce the CQRS pattern.</span></p>
<h2 class="heading-2" id="_idParaDest-155"><span class="koboSpan" id="kobo.696.1">Command Query Responsibility Segregation (CQRS) pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.697.1">In its general form, the usage of this pattern is quite easy: </span><em class="italic"><span class="koboSpan" id="kobo.698.1">use different structures to store/update and query data</span></em><span class="koboSpan" id="kobo.699.1">. </span><span class="koboSpan" id="kobo.699.2">Here, the requirements regarding how to store and update data differ from the requirements of queries. </span><span class="koboSpan" id="kobo.699.3">This means that both the domain layer and application services of </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.700.1">queries and store/update operations must be designed in completely different ways.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.701.1">In the case of DDD, the unit of storage is the </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.702.1">aggregate, so additions, deletions, and updates involve aggregates. </span><span class="koboSpan" id="kobo.702.2">On the other hand, differently from storages/updates, queries don’t perform business operations but involve transformations of properties that have been taken from several aggregates (projections, sums, averages, and so on).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.703.1">Therefore, while updates require entities enriched with business logic and constraints (methods, validation rules, encapsulated information, and so on), query results just need sets of property/value pairs, so DTOs with only public properties and no methods work well.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.704.1">In its common form, the pattern can be depicted as follows:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.705.1"><img alt="Diagram  Description automatically generated" src="../Images/B19820_07_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.706.1">Figure 7.7: Command and query processing</span></p>
<p class="normal"><span class="koboSpan" id="kobo.707.1">Where:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.708.1">The middle boxes (Handlers and Repository interfaces) represent operations.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.709.1">The leftmost and rightmost boxes represent data.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.710.1">Arrows simply represent the direction of data.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.711.1">The main takeaway from this is that the extraction of query results doesn’t need to pass through the construction of entities and aggregates, but the fields shown in the query must be extracted from the storage</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.712.1"> engine and projected into ad hoc DTOs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.713.1">However, in more complex situations, CQRS may be implemented in a stronger form. </span><span class="koboSpan" id="kobo.713.2">Namely, we can use different Bounded Contexts to store preprocessed query results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.714.1">In fact, the other option would be</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.715.1"> an aggregator microservice that queries all the necessary microservices in order to assemble each query result. </span><span class="koboSpan" id="kobo.715.2">However, recursive calls to other microservices to build an answer may result in unacceptable response times. </span><span class="koboSpan" id="kobo.715.3">Moreover, factoring out some preprocessing ensures better usage of the available resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.716.1">This pattern is implemented as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.717.1">Query handling is delegated to separated and specialized components.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.718.1">Each query-handling component uses a database table for each query it must handle. </span><span class="koboSpan" id="kobo.718.2">There, it stores all fields to be returned by the query. </span><span class="koboSpan" id="kobo.718.3">This means that queries are not computed at each request, but precomputed and stored in specific database tables. </span><span class="koboSpan" id="kobo.718.4">Clearly, queries with child collections need additional tables, one for each child collection.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.719.1">All components that process updates forward all changes to the interested query-handling components. </span><span class="koboSpan" id="kobo.719.2">Records are versioned so the query-handling components that receive the changes can apply them in the right order to their query-handling tables. </span><span class="koboSpan" id="kobo.719.3">In fact, since communication is asynchronous to improve performance, changes are not guaranteed to be received in the same order they were sent.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.720.1">Changes received by each query-handling microservice are cached while they wait for the changes to be applied. </span><span class="koboSpan" id="kobo.720.2">Whenever a change has a version number that immediately follows the last change applied, it is applied to the right query-handling table.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.721.1">It is worth noticing that the software “components” we mentioned above run as separate processes on possibly different machines, and are called microservices. </span><span class="koboSpan" id="kobo.721.2">They will be discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.722.1">Chapter 11</span></em><span class="koboSpan" id="kobo.723.1">, </span><em class="italic"><span class="koboSpan" id="kobo.724.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.725.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.726.1">The usage of this stronger form of the</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.727.1"> CQRS pattern transforms typical local database transactions into complex time-consuming distributed transactions since a failure in a single query preprocessor microservice should invalidate the whole transaction. </span><span class="koboSpan" id="kobo.727.2">As we will discuss in </span><em class="chapterRef"><span class="koboSpan" id="kobo.728.1">Chapter 11</span></em><span class="koboSpan" id="kobo.729.1">, </span><em class="italic"><span class="koboSpan" id="kobo.730.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.731.1">, implementing distributed transactions is usually unacceptable for performance reasons and sometimes is not supported at all, so the common solution is to renounce the idea of a database that is immediately consistent overall and to accept that the overall database will eventually be consistent after each update. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.732.1">Transient failures can be solved with retry policies, which we will discuss in </span><em class="italic"><span class="koboSpan" id="kobo.733.1">Chapter 11</span></em><span class="koboSpan" id="kobo.734.1">, </span><em class="italic"><span class="koboSpan" id="kobo.735.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.736.1">, while permanent failures are handled by performing corrective actions on the already committed local transactions instead of pretending to</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.737.1"> implement an overall globally distributed transaction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.738.1">At this point, you may be asking the following question:</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.739.1">“Why do we need to keep the original data once we have all the preprocessed query results? </span><span class="koboSpan" id="kobo.739.2">We will never use it to answer queries!”</span></em></p>
<p class="normal"><span class="koboSpan" id="kobo.740.1">Some of the answers to this</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.741.1"> question are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.742.1">They are the source of truth that we may need to recover from failures.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.743.1">We need them to compute new preprocessed results when we add new queries.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.744.1">We need them to process new updates. </span><span class="koboSpan" id="kobo.744.2">In fact, processing updates usually requires that some of the data is retrieved from the database, possibly shown to the user, and then modified.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.745.1">For instance, to modify an item in an existing purchase order, we need the whole order so that we can show it to the user and compute the changes so that we can forward it to other microservices. </span><span class="koboSpan" id="kobo.745.2">Moreover, whenever we modify or add data to the storage engine, we must verify the coherence of the overall database (unique key constraints, foreign key constraints, and so on).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.746.1">The next subsection is dedicated to an extreme implementation of the CQRS pattern.</span></p>
<h2 class="heading-2" id="_idParaDest-156"><span class="koboSpan" id="kobo.747.1">Event sourcing</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.748.1">Event sourcing is a more advanced implementation of the stronger form of CQRS. </span><span class="koboSpan" id="kobo.748.2">It is useful when the original Bounded </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.749.1">Context is a </span><strong class="keyWord"><span class="koboSpan" id="kobo.750.1">source of truth</span></strong><span class="koboSpan" id="kobo.751.1">—that is, for</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.752.1"> recovering from failures and for software maintenance. </span><span class="koboSpan" id="kobo.752.2">In this case, instead of updating data, we simply add events that describe the operation that </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.753.1">was performed, such as </span><em class="italic"><span class="koboSpan" id="kobo.754.1">deleted record Id 15</span></em><span class="koboSpan" id="kobo.755.1">, </span><em class="italic"><span class="koboSpan" id="kobo.756.1">changed the name to John in Id 21</span></em><span class="koboSpan" id="kobo.757.1">, and so on. </span><span class="koboSpan" id="kobo.757.2">These events are immediately sent to all the dependent Bounded Contexts, and in the case of failures and/or the addition of new queries, all we have to do is reprocess some of them. </span><span class="koboSpan" id="kobo.757.3">For performance reasons, together with the events representing all changes, the current state is also maintained; otherwise, each time it is needed, it will need to be recomputed, replaying all events. </span><span class="koboSpan" id="kobo.757.4">Moreover, usually, the full state is cached after, say, every </span><em class="italic"><span class="koboSpan" id="kobo.758.1">N</span></em><span class="koboSpan" id="kobo.759.1"> changes. </span><span class="koboSpan" id="kobo.759.2">This way, if there is a crash or any kind of failure, only a few events must be replayed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.760.1">Replaying events can’t cause problems if events are </span><strong class="keyWord"><span class="koboSpan" id="kobo.761.1">idempotent</span></strong><span class="koboSpan" id="kobo.762.1">—that is, if processing the same event several times has the same effect as processing it once.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.763.1">As we will discuss in </span><em class="chapterRef"><span class="koboSpan" id="kobo.764.1">Chapter 11</span></em><span class="koboSpan" id="kobo.765.1">, </span><em class="italic"><span class="koboSpan" id="kobo.766.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.767.1">, idempotency is a standard requirement for microservices that communicate through events.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.768.1">In the next section, we will describe </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.769.1">a common pattern that’s used for handling operations that span several aggregates and several Bounded Contexts.</span></p>
<h2 class="heading-2" id="_idParaDest-157"><span class="koboSpan" id="kobo.770.1">Command handlers and aggregate events</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.771.1">According to the Command pattern, each application domain operation is handled by a so-called command handler. </span><span class="koboSpan" id="kobo.771.2">Since each command handler encodes a single application domain operation, all of its actions must </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.772.1">take place in the same transaction because the operation must succeed or fail as</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.773.1"> a whole. </span><span class="koboSpan" id="kobo.773.2">Command handlers perform their job by calling aggregates and repository methods. </span><span class="koboSpan" id="kobo.773.3">However, some actions might be triggered by state changes inside aggregates, so they can’t be called by command handlers but must rely on some form of direct aggregate-to-aggregate communication.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.774.1">To keep aggregates separated, usually, communication among aggregates and also with other Bounded Contexts is done through events. </span><span class="koboSpan" id="kobo.774.2">We already discussed domain events used to communicate with other bounded contexts in the </span><em class="italic"><span class="koboSpan" id="kobo.775.1">Domain events</span></em><span class="koboSpan" id="kobo.776.1"> subsection. </span><span class="koboSpan" id="kobo.776.2">However, direct communication among aggregates can also take advantage of the publisher/subscriber pattern to keep the code more modular and easy to modify. </span><span class="koboSpan" id="kobo.776.3">It is good practice to store all the events when they are triggered during the processing of each aggregate, instead of executing</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.777.1"> them immediately, in order to prevent event execution from interfering </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.778.1">with the ongoing aggregate processing. </span><span class="koboSpan" id="kobo.778.2">This is easily achieved by adding the following code to the abstract </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">Entity</span></code><span class="koboSpan" id="kobo.780.1"> class defined in the </span><em class="italic"><span class="koboSpan" id="kobo.781.1">Entities</span></em><span class="koboSpan" id="kobo.782.1"> subsection of this chapter, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.783.1">public</span></span><span class="koboSpan" id="kobo.784.1"> List&lt;IEventNotification&gt; DomainEvents { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">get</span></span><span class="koboSpan" id="kobo.786.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.787.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.788.1">set</span></span><span class="koboSpan" id="kobo.789.1">; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.790.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.791.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.792.1">AddDomainEvent</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.793.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.794.1">IEventNotification evt</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.795.1">)</span></span><span class="koboSpan" id="kobo.796.1">
{
    DomainEvents ??= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">new</span></span><span class="koboSpan" id="kobo.798.1"> List&lt;IEventNotification&gt;();
    DomainEvents.Add(evt);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.800.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.801.1">RemoveDomainEvent</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.802.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.803.1">IEventNotification evt</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.804.1">)</span></span><span class="koboSpan" id="kobo.805.1">
{
    DomainEvents?.Remove(evt);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.806.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">IEventNotification</span></code><span class="koboSpan" id="kobo.808.1"> is an empty interface that’s used to mark classes as events.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.809.1">Event processing is usually performed immediately before changes are stored in the storage engine. </span><span class="koboSpan" id="kobo.809.2">Accordingly, a good place to perform event processing is immediately before the command handler calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">SaveEntitiesAsync()</span></code><span class="koboSpan" id="kobo.811.1"> method of each </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">IUnitOfWork</span></code><span class="koboSpan" id="kobo.813.1"> implementation (see the </span><em class="italic"><span class="koboSpan" id="kobo.814.1">Repository pattern </span></em><span class="koboSpan" id="kobo.815.1">subsection). </span><span class="koboSpan" id="kobo.815.2">Similarly, if event handlers can create other events, they must process them after they finish processing all their aggregates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.816.1">Subscriptions to an event, </span><code class="inlineCode"><span class="koboSpan" id="kobo.817.1">T</span></code><span class="koboSpan" id="kobo.818.1">, can be provided as an implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.819.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.820.1"> interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.821.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.823.1">IEventHandler</span></span><span class="koboSpan" id="kobo.824.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.825.1">T</span></span><span class="koboSpan" id="kobo.826.1">&gt;: </span><span class="hljs-title"><span class="koboSpan" id="kobo.827.1">IEventHandler</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.828.1">where</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.829.1">T</span></span><span class="koboSpan" id="kobo.830.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.831.1">IEventNotification</span></span><span class="koboSpan" id="kobo.832.1">
{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.833.1">Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.834.1">HandleAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.835.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.836.1">T ev</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.837.1">)</span></span><span class="koboSpan" id="kobo.838.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.839.1">Analogously, the command pattern is implemented with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.840.1">command</span></code><span class="koboSpan" id="kobo.841.1"> object, which contains all the input data of the application domain operation, while the code that implements the actual operation can be provided through a command handler that is an implementation of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">ICommandHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.843.1"> interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.844.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.845.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.846.1">ICommandHandler</span></span><span class="koboSpan" id="kobo.847.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.848.1">T</span></span><span class="koboSpan" id="kobo.849.1">&gt;: </span><span class="hljs-title"><span class="koboSpan" id="kobo.850.1">ICommandHandler</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">where</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.852.1">T</span></span><span class="koboSpan" id="kobo.853.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.854.1">ICommand</span></span><span class="koboSpan" id="kobo.855.1">
{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.856.1">Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.857.1">HandleAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.858.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.859.1">T command</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.860.1">)</span></span><span class="koboSpan" id="kobo.861.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.862.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.863.1">ICommand</span></code><span class="koboSpan" id="kobo.864.1"> is an empty interface that’s used to mark classes as commands. </span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">ICommandHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.866.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.867.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.868.1"> are examples of the </span><strong class="keyWord"><span class="koboSpan" id="kobo.869.1">Command pattern</span></strong><span class="koboSpan" id="kobo.870.1"> we described in </span><em class="chapterRef"><span class="koboSpan" id="kobo.871.1">Chapter 6</span></em><span class="koboSpan" id="kobo.872.1">, </span><em class="italic"><span class="koboSpan" id="kobo.873.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.874.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.875.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">ICommandHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.877.1"> can be registered in the dependency injection engine so that classes that need to execute a command, </span><code class="inlineCode"><span class="koboSpan" id="kobo.878.1">T</span></code><span class="koboSpan" id="kobo.879.1">, can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.880.1">ICommandHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.881.1"> in their constructor. </span><span class="koboSpan" id="kobo.881.2">This way, we decouple the abstract definition of a command (the class that implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">ICommand</span></code><span class="koboSpan" id="kobo.883.1">) from the way it is executed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.884.1">The same construction can’t be applied to events, </span><code class="inlineCode"><span class="koboSpan" id="kobo.885.1">T</span></code><span class="koboSpan" id="kobo.886.1">, and their </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.888.1">, because when an event is triggered, we need to retrieve several instances of </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.890.1"> and not just one. </span><span class="koboSpan" id="kobo.890.2">We need</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.891.1"> to do this since each event may have several subscriptions. </span><span class="koboSpan" id="kobo.891.2">However, a few lines of code </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.892.1">can easily solve this difficulty. </span><span class="koboSpan" id="kobo.892.2">First, we need to define a class that hosts all the handlers for a given event type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.893.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.894.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.895.1">EventTrigger</span></span><span class="koboSpan" id="kobo.896.1">&lt;</span><span class="hljs-title"><span class="koboSpan" id="kobo.897.1">T</span></span><span class="koboSpan" id="kobo.898.1">&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.899.1">where</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.900.1">T</span></span><span class="koboSpan" id="kobo.901.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.902.1">IEventNotification</span></span><span class="koboSpan" id="kobo.903.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.904.1">private</span></span><span class="koboSpan" id="kobo.905.1"> IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.906.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.907.1">EventTrigger</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.908.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.909.1">IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.910.1">)</span></span><span class="koboSpan" id="kobo.911.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.912.1">this</span></span><span class="koboSpan" id="kobo.913.1">.handlers = handlers;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.914.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.915.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.916.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.917.1">Trigger</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.918.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.919.1">T ev</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.920.1">)</span></span><span class="koboSpan" id="kobo.921.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.922.1">foreach</span></span><span class="koboSpan" id="kobo.923.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">var</span></span><span class="koboSpan" id="kobo.925.1"> handler </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">in</span></span><span class="koboSpan" id="kobo.927.1"> handlers)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">await</span></span><span class="koboSpan" id="kobo.929.1"> handler.HandleAsync(ev);
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.930.1">Declaring a </span><code class="inlineCode"><span class="koboSpan" id="kobo.931.1">handlers</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.932.1">IEnumerable&lt;IEventHandler&lt;T&gt;&gt;</span></code><span class="koboSpan" id="kobo.933.1"> parameter in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.935.1"> constructor lets a .NET dependency injection engine pass all </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.937.1"> implementations available in the dependency injection container to this </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">handlers</span></code><span class="koboSpan" id="kobo.939.1"> parameter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.940.1">The idea is that each class that needs to trigger event </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">T</span></code><span class="koboSpan" id="kobo.942.1"> requires </span><code class="inlineCode"><span class="koboSpan" id="kobo.943.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.944.1"> and then passes the event to be triggered </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.945.1">to its </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">Trigger</span></code><span class="koboSpan" id="kobo.947.1"> method, which, in turn, invokes all the handlers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.948.1">Then, we need to register </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.950.1"> in the dependency injection engine. </span><span class="koboSpan" id="kobo.950.2">A good idea is to define the dependency </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.951.1">injection extensions that we can invoke to declare each event, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.952.1">        service.AddEventHandler&lt;MyEventType, MyHandlerType&gt;()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.953.1">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.954.1">AddEventHandler</span></code><span class="koboSpan" id="kobo.955.1"> extension must automatically produce a dependency injection definition for </span><code class="inlineCode"><span class="koboSpan" id="kobo.956.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.957.1"> and must process all the handlers that are declared with </span><code class="inlineCode"><span class="koboSpan" id="kobo.958.1">AddEventHandler</span></code><span class="koboSpan" id="kobo.959.1"> for each type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.960.1">T</span></code><span class="koboSpan" id="kobo.961.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.962.1">The following extension class does this for us:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.963.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.965.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.966.1">EventDIExtensions</span></span><span class="koboSpan" id="kobo.967.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.970.1"> IServiceCollection </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.971.1">AddEventHandler</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.972.1">&lt;</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.973.1">T</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.974.1">, </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.975.1">H</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.976.1">&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.977.1">        (</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.978.1">this</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.979.1"> IServiceCollection services</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.980.1">)</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.981.1">where</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.982.1"> T : IEventNotification</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.983.1">where</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.984.1"> H: </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.985.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.986.1">, </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.987.1">IEventHandler</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.988.1">&lt;</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.989.1">T</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.990.1">&gt;</span></span><span class="koboSpan" id="kobo.991.1">
    {
        services.AddScoped&lt;H&gt;();
        services.TryAddScoped(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.992.1">typeof</span></span><span class="koboSpan" id="kobo.993.1">(EventTrigger&lt;&gt;));
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">return</span></span><span class="koboSpan" id="kobo.995.1"> services;
    }
    ...
    </span><span class="koboSpan" id="kobo.995.2">...
</span><span class="koboSpan" id="kobo.995.3">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.996.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.997.1">H</span></code><span class="koboSpan" id="kobo.998.1"> type passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.999.1">AddEventHandler</span></code><span class="koboSpan" id="kobo.1000.1"> is recorded in the dependency injection engine, and the first time </span><code class="inlineCode"><span class="koboSpan" id="kobo.1001.1">AddEventHandler</span></code><span class="koboSpan" id="kobo.1002.1"> is called, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1003.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1004.1"> is also added to the dependency injection engine. </span><span class="koboSpan" id="kobo.1004.2">Then, when an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1005.1">EventTrigger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1006.1"> instance is required by the dependency injection engine, all </span><code class="inlineCode"><span class="koboSpan" id="kobo.1007.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1008.1"> types added to the dependency injection engine are created, collected, and passed to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">EventTrigger(IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers)</span></code><span class="koboSpan" id="kobo.1010.1"> constructor.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1011.1">When the program starts up, all the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1012.1">ICommandHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1013.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1014.1">IEventHandler&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1015.1"> implementations can be retrieved with reflection and registered automatically. </span><span class="koboSpan" id="kobo.1015.2">To help with automatic discovery, they inherit from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1016.1">ICommandHandler</span></code><span class="koboSpan" id="kobo.1017.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">IEventHandler</span></code><span class="koboSpan" id="kobo.1019.1">, which are both empty</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.1020.1"> interfaces.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1021.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">EventDIExtensions</span></code><span class="koboSpan" id="kobo.1023.1"> class, which is available in this book’s GitHub repository, contains methods for the automatic discovery and registration of command handlers and event handlers. </span><span class="koboSpan" id="kobo.1023.2">The GitHub repository also contains an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">IEventMediator</span></code><span class="koboSpan" id="kobo.1025.1"> interface and its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">EventMediator</span></code><span class="koboSpan" id="kobo.1027.1"> implementation, whose </span><code class="inlineCode"><span class="koboSpan" id="kobo.1028.1">TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)</span></code><span class="koboSpan" id="kobo.1029.1"> method retrieves all the handlers associated with the events it receives in its argument from the dependency injection engine and executes them. </span><span class="koboSpan" id="kobo.1029.2">It is sufficient to have </span><code class="inlineCode"><span class="koboSpan" id="kobo.1030.1">IEventMediator</span></code><span class="koboSpan" id="kobo.1031.1"> injected into a class so that it can trigger events. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1032.1">EventDIExtensions</span></code><span class="koboSpan" id="kobo.1033.1"> also contains an extension method that discovers all the queries that implement the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.1034.1">IQuery</span></code><span class="koboSpan" id="kobo.1035.1"> interface and adds them to the dependency injection engine.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1036.1">A more sophisticated</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.1037.1"> implementation is given by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1038.1">MediatR</span></code><span class="koboSpan" id="kobo.1039.1"> NuGet package.</span></p>
<h1 class="heading-1" id="_idParaDest-158"><span class="koboSpan" id="kobo.1040.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1041.1">In this chapter, we analyzed the main reasons for the adoption of DDD and why and how it meets the needs of the market. </span><span class="koboSpan" id="kobo.1041.2">We described how to identify domains and how to coordinate the teams that work on different domains of the same application with domain maps. </span><span class="koboSpan" id="kobo.1041.3">Then, we analyzed the way DDD represents data with entities, value objects, and aggregates, providing advice and code snippets so that we can implement them in practice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1042.1">We also described the onion architecture frequently used in conjunction with DDD-based projects, and compared it with the classical layer architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1043.1">We also covered some typical patterns that are used with DDD—that is, the repository and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. </span><span class="koboSpan" id="kobo.1043.2">Then, we learned how to implement them in practice. </span><span class="koboSpan" id="kobo.1043.3">We also showed you how to implement domain events and the command pattern with decoupled handling so that we can add code snippets to real-world projects.</span></p>
<h1 class="heading-1" id="_idParaDest-159"><span class="koboSpan" id="kobo.1044.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1045.1">What provides the main hints so that we can discover domain boundaries?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1046.1">What is the main tool that’s used for coordinating the development of a separate Bounded Context?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1047.1">Is it true that each entry that composes an aggregate communicates with the remainder of the system with its own methods?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1048.1">Why is there a single aggregate root?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1049.1">How many repositories can manage an aggregate?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1050.1">How does a repository interact with the application layer?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1051.1">Why is the Unit of Work pattern needed?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1052.1">What are the reasons for the light form of CQRS? </span><span class="koboSpan" id="kobo.1052.2">What about the reasons for its strongest form?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1053.1">What is the main tool that allows us to couple commands/domain events with their handlers?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1054.1">Is it true that event sourcing can be used to implement any Bounded Context?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-160"><span class="koboSpan" id="kobo.1055.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1056.1">Eric Evans, Domain-Driven Design: </span><a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20"><span class="url"><span class="koboSpan" id="kobo.1057.1">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1058.1">More resources on DDD can be found here: </span><a href="https://domainlanguage.com/ddd/"><span class="url"><span class="koboSpan" id="kobo.1059.1">https://domainlanguage.com/ddd/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1060.1">A detailed discussion of CQRS design principles can be found here: </span><a href="http://udidahan.com/2009/12/09/clarified-cqrs/"><span class="url"><span class="koboSpan" id="kobo.1061.1">http://udidahan.com/2009/12/09/clarified-cqrs/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1062.1">More information on MediatR can be found on MediatR’s GitHub repository: </span><a href="https://github.com/jbogard/MediatR"><span class="url"><span class="koboSpan" id="kobo.1063.1">https://github.com/jbogard/MediatR</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1064.1">A good description of event sourcing, along with an example of it, can be seen in the following blog post by Martin Fowler: </span><a href="https://martinfowler.com/eaaDev/EventSourcing.html"><span class="url"><span class="koboSpan" id="kobo.1065.1">https://martinfowler.com/eaaDev/EventSourcing.html</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1066.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.1068.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1069.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>