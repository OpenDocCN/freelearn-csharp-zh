<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Plain Text, XML, and JSON Text Files</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Loading external text files using the TextAsset public variable</li>
<li>Loading external text files using C# file streams</li>
<li>Saving external text files with C# file streams</li>
<li>Loading and parsing external XML files</li>
<li>Creating XML text data manually using XMLWriter</li>
<li>Saving and Loading XML text data automatically through serialization</li>
<li>Creating XML text files, and saving XML directly to text files with XMLDocument.Save()</li>
<li>Creating JSON strings from individual objects and lists of objects</li>
<li>Creating individual objects and lists of objects from JSON strings</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Text-based external data is very common and very useful as it is both computer- and human- readable. Text files may be used to allow non-technical team members to edit written content or for recording game performance data during development and testing. Text-based formats also permit <strong>serialization</strong>—the encoding of live object data suitable for transmission, storing, and later retrieval.</p>
<p>Unity treats all of the following (and also C# scripts) as <strong>Text Assets</strong>:</p>
<ul>
<li><kbd>.txt</kbd>: Plain text file</li>
<li><kbd>.html</kbd>, <kbd>.htm</kbd>: HTML page markup (HyperText Markup Language)</li>
<li><kbd>.xml</kbd>: XML data (eXtensible Markup Language)</li>
<li><kbd>.bytes</kbd>: Binary data (accessed through bytes property)</li>
<li><kbd>.json</kbd>: JSON (JavaScript Object Notation)</li>
<li><kbd>.csv</kbd>: CSV (Comma Separate Variable)</li>
<li><kbd>.yaml</kbd>: YAML Ain't Markup Language</li>
<li><kbd>.fnt</kbd>: Bitmap font data (with associated image texture file)</li>
</ul>
<div class="packt_infobox">To learn more about Unity Text Assets in the manual pages, click on the following link: <a href="https://docs.unity3d.com/Manual/class-TextAsset.html"><span class="URLPACKT">https://docs.unity3d.com/Manual/class-TextAsset.html</span></a><span class="URLPACKT">.</span><a href="https://docs.unity3d.com/Manual/class-TextAsset.html"/></div>
<p>Many web-based systems use XML for asynchronous communications without requiring user interaction, leading to the term <strong>AJAX</strong>: <strong>Asynchronous JavaScript XML</strong>. Some modern web-based systems now use JSON for text-based communication. For this reason, this chapter puts special focus on these two text file formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Big picture</h1>
                </header>
            
            <article>
                
<p>Apart from plain text, there are two common text interchange file formats: XML and JSON. Each is discussed and illustrated through recipe examples in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XML – the eXtensible markup language</h1>
                </header>
            
            <article>
                
<p>XML is a meta-language, that is, a set of rules that allows markup languages to be created to encode specific kinds of data. Some examples of data-description language formats using the XML syntax include the following:</p>
<ul>
<li><kbd>.txt</kbd>: Plain text file</li>
<li><kbd>.html</kbd>, <kbd>.htm</kbd>: HTML page markup (HyperText Markup Language)</li>
<li><kbd>.xml</kbd>: XML data (eXtensible Markup Language)</li>
<li><kbd>SVG</kbd>: Scalable Vector Graphics—an open standard method of describing graphics supported by the Worldwide Web consortium</li>
<li><kbd>SOAP</kbd>: Simple Object Access Protocol for the exchange of messages between computer programs and web services</li>
<li><kbd>X3D</kbd>: Xml 3D—an ISO standard for representing 3D objects—it is the successor to <strong>VRML</strong> (<strong>Virtual Reality Modeling Language</strong>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON – the JavaScript object notation</h1>
                </header>
            
            <article>
                
<p>JSON is sometimes referred to as the <em>fat-free alternative to XML</em>—offering similar data interchange strengths, but being smaller, and simpler, both by not offering extensibility and using just three characters for formatting:</p>
<ul>
<li><kbd>property : value</kbd>: the colon character separates a property name form its value</li>
<li><kbd>{ }</kbd>: braces are for an object</li>
<li><kbd>[ ]</kbd>: square brackets are for an array of values/objects</li>
</ul>
<p>You can read more about JSON versus XML at <a href="https://www.json.org/xml.html" target="_blank"><span class="URLPACKT">https://www.json.org/xml.html</span></a></p>
<p>In <a href="" target="_blank">Chapter 10</a>, <em>Working with External Resource Files</em>, several methods for loading external resource files were demonstrated, which work for image, audio, and text resources. In this chapter, several additional methods for loading text files in particular are presented.</p>
<p>In <a href="80a35b7a-7c45-4b18-adcf-b9c99c2e486d.xhtml">Chapter 13</a>,  <em>Shader Graphs and Video Players</em>, some recipes illustrate the use of JSON for a database-driven web leaderboard, and Unity game communication with that leaderboard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading external text files using the TextAsset public variable</h1>
                </header>
            
            <article>
                
<p>A straightforward way to store data in text files and then choose between them before compiling is to use a public variable of the class <kbd>TextAsset</kbd>.</p>
<div class="packt_tip">This technique is only appropriate when there will be no change to the data file after game compilation, since the text file data is serialized (mixed into) the general build resources, and so cannot be changed after the build has been created.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, you'll need a text <kbd>(.txt</kbd>) file. In the <kbd>11_01</kbd> folder, we have provided two such files:</p>
<ul>
<li><kbd>cities.txt</kbd></li>
<li><kbd>countries.txt</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To load external text files using <kbd>TextAsset</kbd>, perform the following steps:</p>
<ol>
<li>Create a new 2D project.</li>
<li>Create a <strong>UI TextGameObject</strong>, center it on screen with the <strong>Rect Transform</strong>, and set its horizontal and vertical overflow to overflow.</li>
<li>Import the text file you wish to use into your project (for example, <kbd>cities.txt</kbd>)</li>
<li>Create a C# <kbd>ReadPublicTextAsset</kbd> <span>script class a</span>nd attach an instance as a component to your <strong>UI Text GameObject</strong>:</li>
</ol>
<pre style="padding-left: 60px">   using UnityEngine;<br/>    using UnityEngine.UI;<br/><br/>    public class ReadPublicTextAsset : MonoBehaviour {<br/>     public TextAsset dataTextFile;<br/><br/>     private void Start() {<br/>         string textFromFile = dataTextFile.text;<br/>         Text textOnScreen = GetComponent&lt;Text&gt;();<br/>         textOnScreen.text = textFromFile;<br/>     }<br/>    } </pre>
<ol start="5">
<li>With <strong>Ma</strong><strong>in Camera</strong> selected in the <strong>Hierarchy</strong> view, drag the <kbd>cities.txt</kbd> file into the public string variable <kbd>dataTextFile</kbd> in the <strong>Inspector</strong>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When the scene starts, the text content of the text file is read into variable <kbd>textFromFile</kbd>. A reference is found to the <strong>UI Text</strong> component, and the text property of that UI component is set to be the content of <kbd>textFromFile</kbd>. The user can then see the content of the text file displayed in the middle of the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading external text files using C# file streams</h1>
                </header>
            
            <article>
                
<p>For standalone executable games that both read from and write to (create or change) text files, <strong>.NET</strong> data streams are often used for both reading and writing. This recipe illustrates how to read a text file, while the next recipe illustrates how to write text data to files.</p>
<div class="packt_tip">This technique only works when you compile to a Windows or Mac standalone executable; it will not work for <strong>WebGL</strong> builds, for example.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, you'll need a text file; two have been provided in the <kbd>11_01</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To load external text files using C# file streams, perform the following steps:</p>
<ol>
<li>Create a new C# script-class <kbd>FileReadWriteManager</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using System.IO;<br/><br/> public class FileReadWriteManager {<br/>     public void WriteTextFile(string pathAndName, string stringData) {<br/>         FileInfo textFile = new FileInfo( pathAndName );<br/>         if( textFile.Exists )<br/>              textFile.Delete();<br/><br/>         StreamWriter writer;<br/>         writer = textFile.CreateText();<br/><br/>         writer.Write(stringData);<br/>         writer.Close();<br/>     }<br/><br/>     public string ReadTextFile(string pathAndName) {<br/>         string dataAsString = "";<br/><br/>         try {<br/>             StreamReader textReader = File.OpenText( pathAndName );<br/><br/>             dataAsString = textReader.ReadToEnd();<br/>             textReader.Close();<br/>         }<br/>         catch (Exception e) {<br/>             return "error:" + e.Message;<br/>         }<br/><br/>         return dataAsString;<br/>     }<br/> } </pre>
<ol start="2">
<li>Create a C# <kbd>ReadWithStream</kbd> <span>script class a</span>nd attach an instance as a component to your <strong>UI Text GameObject</strong>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEngine.UI;<br/> using System.IO;<br/><br/> public class ReadWithStream : MonoBehaviour {<br/>     private string fileName = "cities.txt";<br/><br/>     private string textFileContents = "(file not found yet)";<br/>     private FileReadWriteManager fileReadWriteManager = new FileReadWriteManager();<br/><br/>     private void Start () {<br/>         string filePath = Path.Combine(Application.dataPath, "Resources");<br/>         filePath = Path.Combine(filePath, fileName);<br/><br/>         textFileContents = fileReadWriteManager.ReadTextFile( filePath );<br/><br/>         Text textOnScreen = GetComponent&lt;Text&gt;();<br/>         textOnScreen.text = textFileContents;<br/>     }<br/> } </pre>
<ol start="3">
<li>Save the current scene and then add this to the list of scenes in the build.</li>
<li>Build and run your (Windows, Mac, or Linux) standalone executable.</li>
<li>Copy the text file containing your data into your standalone's <kbd>Resources</kbd> folder (that is, the filename you set in the first statement in the <kbd>Start()</kbd> method—in our listing, this is the <kbd>cities.txt</kbd> file).</li>
</ol>
<p>You will need to place the files in the <kbd>Resources</kbd> folder manually after every compilation.</p>
<div class="packt_tip">For Windows and Linux users: When you create a Windows or Linux standalone executable, there is a <kbd>_Data</kbd> folder that is created with the executable application file. The <kbd>Resources</kbd> folder can be found inside this data folder.</div>
<div class="packt_tip">For Mac users: A Mac standalone application executable looks like a single file, but it is actually a macOS "package" folder. Right-click on the executable file and select <span class="packt_screen">Show Package Contents</span>. You will then find the standalone's <span class="packt_screen">Resources</span> folder inside the <span class="packt_screen">Contents</span> folder.</div>
<ol start="6">
<li>When you run your built executable, you should see the text file content loaded and displayed in the middle of the application window.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When the game runs, the <kbd>Start()</kbd> method creates the <kbd>filePath</kbd> string and then calls the <kbd>ReadTextFile()</kbd> method from the <kbd>fileReadWriteManager</kbd> object, to which it passes the filePath string. This method reads the content of the file and returns them as a string, which is stored in the <kbd>textFileContents</kbd> variable. Our <kbd>OnGUI()</kbd> method displays the values of these two variables (<kbd>filePath</kbd> and <kbd>textFileContents</kbd>).</p>
<p>Note the need to use the <kbd>System.IO</kbd> package for this recipe. The C# script <kbd>FileReadWriteManager.cs</kbd> contains two general purpose file read and write methods that you may find useful in many different projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving external text files with C# file streams</h1>
                </header>
            
            <article>
                
<p>This recipe illustrates how to use C# streams to write text data to a text file, either into the standalone project's <kbd>Data</kbd> folder or to the <kbd>Resources</kbd> folder.</p>
<p>This technique only works when you compile to a Windows or Mac standalone executable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In the <kbd>11_02</kbd> folder, we have provided a text file containing the completed C# script class created in the previous recipe:</p>
<pre>FileReadWriteManager.cs</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To save external text files using C# file streams, follow these steps:</p>
<ol>
<li>Create a new 2D project.</li>
<li>Import the C# <kbd>FileReadWriteManager.cs</kbd> <span>script class </span>into your project.</li>
<li>Add the following C# <kbd>SaveTextFile</kbd> <span>script class </span>to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System.IO;<br/><br/> public class SaveTextFile : MonoBehaviour {<br/>     public string fileName = "hello.txt";<br/>     public string folderName = "Data";<br/>     private string filePath = "(no file path yet)";<br/>     private FileReadWriteManager fileManager;<br/><br/>     void Start () {<br/>         string textData = "hello \n and goodbye";<br/>         fileManager = new FileReadWriteManager();<br/>         filePath = Path.Combine(Application.dataPath, folderName);<br/>         filePath = Path.Combine(filePath, fileName);<br/>         fileManager.WriteTextFile( filePath, textData );<br/>     }<br/> } </pre>
<ol start="4">
<li>Save the current scene and then add this to the list of scenes in the build.</li>
<li>Build and run your (Windows, Mac, or Linux) standalone executable.</li>
<li>After running the built executable, you should now find a new text file named <kbd>hello.txt</kbd> in the <kbd>Data</kbd> folder of your project's standalone files, containing the lines <span class="packt_screen">hello</span> and <span class="packt_screen">and goodbye</span></li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/67d41db9-a45d-42d8-ae2f-c5d5a3c59641.png" style="width:29.17em;height:8.92em;"/></div>
<p>It is possible to test this when running within the Unity editor (that is, before building a standalone application). To test this way, you'll need to create a <kbd>Data</kbd> folder in your project panel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When the game runs, the <kbd>Start()</kbd> method creates the <kbd>filePath</kbd> string from the public variables <kbd>fileName</kbd> and <kbd>folderName</kbd>, and then calls the <kbd>WriteTextFile()</kbd> method from the <kbd>fileReadWriteManager</kbd> object, to which it passes the <kbd>filePath</kbd> and <kbd>textData</kbd> strings. This method creates (or overwrites) a text file (for the given file path and filename) containing the string data received.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The following are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing the Data or the Resources folder</h1>
                </header>
            
            <article>
                
<p>Standalone build applications contain both a <kbd>Data</kbd> folder and a <kbd>Resources</kbd> folder. Either of these can be used for writing (or some other folder, if desired). We generally put read-only files into the <kbd>Resources</kbd> folder and use the <kbd>Data</kbd> folder for files that are to be created from scratch or that have had their content changed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Before you build your executable, you can specify a different file and folder name (for example, <kbd>Resources</kbd> instead of <kbd>Data</kbd>). Ensure the <strong>Main Camera GameObject</strong> is selected in the <strong>Hierarchy</strong>, and then change the values in those public variables in the <strong>Inspector</strong> component <span class="packt_screen">Save text File (Script)</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading and parsing external XML</h1>
                </header>
            
            <article>
                
<p>It is useful to be able to parse (process the content of) text files and strings containing data in the XML format. C# offers a range of classes and methods to make such processing straightforward, which we'll explore in this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You'll find player name and score data in XML format in the <kbd>playerScoreData.xml</kbd> file in the <kbd>11_04</kbd> folder. The content of this file is as follows:</p>
<pre>&lt;scoreRecordList&gt;<br/>        &lt;scoreRecord&gt;<br/>            &lt;player&gt;matt&lt;/player&gt;<br/>            &lt;score&gt;2200&lt;/score&gt;<br/>            &lt;date&gt;<br/>                &lt;day&gt;1&lt;/day&gt;<br/>                &lt;month&gt;Sep&lt;/month&gt;<br/>                &lt;year&gt;2012&lt;/year&gt;<br/>            &lt;/date&gt;<br/>        &lt;/scoreRecord&gt;<br/>        &lt;scoreRecord&gt;<br/>            &lt;player&gt;jane&lt;/player&gt;<br/>            &lt;score&gt;500&lt;/score&gt;<br/>            &lt;date&gt;<br/>                &lt;day&gt;12&lt;/day&gt;<br/>                &lt;month&gt;May&lt;/month&gt;<br/>                &lt;year&gt;2012&lt;/year&gt;<br/>            &lt;/date&gt;<br/>        &lt;/scoreRecord&gt;<br/>    &lt;/scoreRecordList&gt; </pre>
<p>The data is structured by a root element named <kbd>scoreRecordList</kbd>, which contains a sequence of <kbd>scoreRecord</kbd> elements. Each <kbd>scoreRecord</kbd> element contains a player element (which contains a player's name), a score element (which has the integer content of the player's score), and a date element, which itself contains three child elements – day, month, and year.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To load and parse external XML files, follow these steps:</p>
<ol>
<li>Create a C# <kbd>PlayerScoreDate</kbd> <span>script class </span>containing the following:</li>
</ol>
<pre style="padding-left: 60px">    public class PlayerScoreDate<br/>     {<br/>         private string playerName;<br/>         private int score;<br/>         private string date;<br/><br/>         public void SetPlayerName(string playerName)<br/>         { this.playerName = playerName; }<br/><br/>         public void SetScore(int score)<br/>         { this.score = score; }<br/><br/>         public void SetDate(string date)<br/>         { this.date = date; }<br/><br/>         override public string ToString()<br/>         {<br/>             return "Player = " + this.playerName + ",<br/>             score = " + this.score + ", date = " + this.date;<br/>         }<br/>     } </pre>
<ol start="2">
<li>Create a C# <kbd>ParseXML</kbd> <span>script class a</span>nd attach an instance as a component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System;<br/> using System.Xml;<br/> using System.IO;<br/><br/> public class ParseXML : MonoBehaviour {<br/>     public TextAsset scoreDataTextFile;<br/>     private PlayerScoreDate[] playerScores = new PlayerScoreDate[999];<br/><br/>     private void Start() {<br/>         string textData = scoreDataTextFile.text;<br/>         int numberObjects = ParseScoreXML( textData );<br/><br/>         for (int i = 0; i &lt; numberObjects; i++)<br/>             print(playerScores[i]);<br/>     }<br/><br/>     private int ParseScoreXML(string xmlData) {<br/>         XmlDocument xmlDoc = new XmlDocument();<br/>         xmlDoc.Load( new StringReader(xmlData) );<br/><br/>         string xmlPathPattern = "//scoreRecordList/scoreRecord";<br/>         XmlNodeList myNodeList = xmlDoc.SelectNodes( xmlPathPattern );<br/><br/>         int i = 0;<br/>         foreach(XmlNode node in myNodeList){<br/>             playerScores[i] = NodeToPlayerScoreObject(node);<br/>             i++;<br/>         }<br/><br/>         return i;<br/>     }<br/><br/>     private PlayerScoreDate NodeToPlayerScoreObject(XmlNode node) {<br/>         XmlNode playerNode = node.FirstChild;<br/>         string playerName = playerNode.InnerXml;<br/><br/>         XmlNode scoreNode = playerNode.NextSibling;<br/>         string scoreString = scoreNode.InnerXml;<br/>         int score = Int32.Parse(scoreString);<br/><br/>         XmlNode dateNode = scoreNode.NextSibling;<br/>         string date = NodeToDateString(dateNode);<br/><br/>         PlayerScoreDate playerObject = new PlayerScoreDate();<br/>         playerObject.SetPlayerName(playerName);<br/>         playerObject.SetScore(score);<br/>         playerObject.SetDate(date);<br/><br/>         return playerObject;<br/><br/>     }<br/><br/>     private string NodeToDateString(XmlNode dateNode) {<br/>         XmlNode dayNode = dateNode.FirstChild;<br/>         XmlNode monthNode = dayNode.NextSibling;<br/>         XmlNode yearNode = monthNode.NextSibling;<br/><br/>         return dayNode.InnerXml + "/" + monthNode.InnerXml + "/" + yearNode.InnerXml;<br/>     }<br/> } </pre>
<ol start="3">
<li>Run the scene, and the output of the <kbd>print()</kbd> statements should be visible in the <span class="packt_screen">Console</span> window:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7e7b5cdc-274f-4065-bbec-6eb17cad6056.png" style="width:27.25em;height:9.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>PlayerScoreDate</kbd> <span>script class </span>simply contains the three pieces of data for player-dated scores:</p>
<ul>
<li>The player's name (string)</li>
<li>The player's score (integer)</li>
<li>The date the score was recorded (string—to keep this recipe short...)</li>
</ul>
<p>Note the need to use the <kbd>System</kbd>, <kbd>System.Xml</kbd> and <kbd>System.IO</kbd> packages for the C# <kbd>ParseXML</kbd> script <span>class.</span></p>
<p>The <kbd>text</kbd> property of the <kbd>TextAsset</kbd> variable <kbd>scoreDataTextFile</kbd> provides the content of the XML file as a string, which is passed to the <kbd>ParseScoreXML(...)</kbd> method.</p>
<p>This <kbd>ParseScoreXML(...)</kbd> method creates a new <kbd>XmlDocument</kbd> variable with the content of this string. The <kbd>XmlDocument</kbd> class provides the <kbd>SelectNodes()</kbd> method, which returns a list of node objects for a given element path. In this example, a list of <kbd>scoreRecord</kbd> nodes is requested. A for-each statement loops for each scoreRecord, passing the current node to method <kbd>NodeToPlayerScoreObject(...),</kbd> and storing the returned object into the next slot in the <kbd>playerScores </kbd>array.</p>
<p>The <kbd>NodeToPlayerScoreObject(...)</kbd> method relies on the ordering of the XML elements to retrieve the player's name, score, and data strings. The score string is parsed into an integer, and the date node is converted to a date string using method <kbd>NodeToDateString(...)</kbd>. A new <kbd>PlayerScoreDate</kbd> object is created, and the name, score and date stored in it, and then that object is returned.</p>
<p>The <kbd>NodeToDateString(...)</kbd> method creates a date string as a slash-separated string by parsing the node containing the three date components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The following are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving XML data files from the web</h1>
                </header>
            
            <article>
                
<p>You can use the <span class="packt_screen">WWW</span> Unity class if the XML file is located on the web rather than in your Unity project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating XML text data manually using XMLWriter</h1>
                </header>
            
            <article>
                
<p>One way to create XML data structures from game objects and properties is by hand-coding a method to create each element and its content, using the <kbd>XMLWriter</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create XML text data using <kbd>XMLWriter</kbd>, follow these steps:</p>
<ol>
<li>Create a C# <kbd>CreateXMLString</kbd> script class to add an instance as a component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System.Xml;<br/> using System.IO;<br/><br/> public class CreateXMLString : MonoBehaviour {<br/><br/>     private void Start () {<br/>         string output = BuildXMLString();<br/>         print(output);<br/>     }<br/><br/>     private string BuildXMLString() {<br/>         StringWriter str = new StringWriter();<br/>         XmlTextWriter xml = new XmlTextWriter(str);<br/><br/>         // start doc and root element<br/>         xml.WriteStartDocument();<br/>         xml.WriteStartElement("playerScoreList");<br/><br/>         // data element<br/>         xml.WriteStartElement("player");<br/>         xml.WriteElementString("name", "matt");<br/>         xml.WriteElementString("score", "200");<br/>         xml.WriteEndElement();<br/><br/>         // data element<br/>         xml.WriteStartElement("player");<br/>         xml.WriteElementString("name", "jane");<br/>         xml.WriteElementString("score", "150");<br/>         xml.WriteEndElement();<br/><br/>         // end root and document<br/>         xml.WriteEndElement();<br/>         xml.WriteEndDocument();<br/><br/>         return str.ToString();<br/>     }<br/> } </pre>
<ol start="2">
<li>The XML text data should be visible in the <span class="packt_screen">Console</span> panel when the scene is run, and should look as follows (some newline characters have been added to make the output more human-readable...):</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-16"?&gt;<br/>   &lt;playerScoreList&gt;<br/>   &lt;player&gt;<br/>   &lt;name&gt;matt&lt;/name&gt;<br/>   &lt;score&gt;200&lt;/score&gt;<br/>   &lt;/player&gt;<br/>   &lt;player&gt;<br/>   &lt;name&gt;jane&lt;/name&gt;<br/>   &lt;score&gt;150&lt;/score&gt;<br/>   &lt;/player&gt;<br/>   &lt;/playerScoreList&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Start()</kbd> method calls <kbd>BuildXMLString()</kbd> and stores the returned string in the output variable. This output text is then printed to the Console debug panel.</p>
<p>The <kbd>BuildXMLString()</kbd> method creates a <kbd>StringWriter</kbd> object, into which <kbd>XMLWriter</kbd> builds the string of XML elements. The XML document starts and ends with the <kbd>WriteStartDocument()</kbd> and <kbd>WriteEndDocument()</kbd> methods. Elements start and end with <kbd>WriteStartElement()</kbd> and <kbd>WriteEndElement().</kbd> String content for an element is added using <kbd>WriteElementString().</kbd></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here are some details that you won't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding new lines to make XML strings more human readable.</h1>
                </header>
            
            <article>
                
<p>After every instance of the <kbd>WriteStartElement()</kbd> and <kbd>WriteElementString()</kbd> methods, you can add a newline character using <kbd>WriteWhiteSpace().</kbd> These are ignored by XML parsing methods, but if you intend to display the XML string for a human to see, the presence of the new line's characters makes it much more readable:</p>
<pre>xml.WriteWhitespace("\n ");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making data class responsible for creating XML from list</h1>
                </header>
            
            <article>
                
<p>The XML to be generated is often from a list of objects, all of the same class. In this case, it makes sense to make the class of the objects responsible for generating the XML for a list of those objects.</p>
<p>The <kbd>CreateXMLFromArray</kbd> class simply creates an instance of <kbd>List&lt;T&gt;</kbd> containing <kbd>PlayerScore</kbd> objects, and then calls the (static) method <kbd>ListToXML(),</kbd> passing in the list of objects.</p>
<p>The following should be a single block of code: </p>
<pre>using UnityEngine;<br/>using System.Collections.Generic;<br/><br/>public class CreateXMLFromArray : MonoBehaviour {<br/><span>   private </span>List&lt;PlayerScore&gt; <span>playerScoreList</span><span>;<br/></span><span><br/></span><span>   private void </span><span>Start </span>() {<br/>       playerScoreList = <span>new </span>List&lt;PlayerScore&gt;()<span>;<br/></span><span>       </span>playerScoreList.Add (<span>new </span>PlayerScore(<span>"matt"</span><span>, </span><span>200</span>) )<span>;<br/></span><span>       </span>playerScoreList.Add (<span>new </span>PlayerScore(<span>"jane"</span><span>, </span><span>150</span>) )<span>;<br/></span><span><br/></span><span>       </span><span>string </span>output = PlayerScore.ListToXML( playerScoreList )<span>;<br/></span><span>       </span>print(output)<span>; <br/></span>   }<br/>}</pre>
<p>All the hard work is now the responsibility of the <kbd>PlayerScore</kbd> class. This class has two private variables for the player's name and score and a constructor that accepts values for these properties. The public static method <kbd>ListToXML()</kbd> takes a <kbd>List</kbd> object as an argument, and uses <kbd>XMLWriter</kbd> to build the XML string, looping through each object in the list and calling the object's <kbd>ObjectToElement()</kbd> method. This method adds an XML element to the <kbd>XMLWriter</kbd> argument received for the data in that object:</p>
<pre>using System.Collections.Generic;<br/>using System.Xml;<br/>using System.IO;<br/><br/>public class PlayerScore {<br/>   private string _name;<br/>   private int _score;<br/><br/>   public PlayerScore(string name, int score) {<br/>       _name = name;<br/>       _score = score;<br/>   }<br/><br/>   static public string <span>ListToXML</span><span>(List&lt;PlayerScore&gt; playerList) {<br/></span>       StringWriter str = new StringWriter();<br/>       XmlTextWriter xml = new XmlTextWriter(str);<br/>       xml.WriteStartDocument();<br/>       xml.WriteStartElement("playerScoreList");<br/>       foreach (PlayerScore playerScoreObject in playerList) {<br/>          playerScoreObject.ObjectToElement( xml );<br/>       }<br/><br/>       xml.WriteEndElement();<br/>       xml.WriteEndDocument();<br/>       return str.ToString();<br/>    }<br/><br/>    private void ObjectToElement(XmlTextWriter xml) {<br/>       // data element<br/>       xml.WriteStartElement("player");<br/>       xml.WriteElementString("name", _name);<br/>       string scoreString = "" + _score; // make _score a string<br/>       xml.WriteElementString("score", scoreString);<br/>       xml.WriteEndElement();<br/>    }<br/> }<br/><br/></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving and loading XML text data automatically through serialization</h1>
                </header>
            
            <article>
                
<p>Another way to work with XML data structures from game objects and properties is by serializing the content of an object automatically. This technique automatically generates XML for all the public properties of an object. This recipe uses the <kbd>XmlSerializer</kbd> class that can be found in the standard <kbd>System.Xml</kbd> C# package.</p>
<div class="packt_infobox">This recipe has been adapted from this 2013 (still works!) Unify Community Wiki article: <a href="http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer" target="_blank"><span class="URLPACKT">http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer</span></a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In the <kbd>11_06</kbd> folder, you'll find two XML data files, allowing you to test the reader with different XML text file data files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create XML text data through serialization, perform the following steps:</p>
<ol>
<li>Create a C# <kbd>PlayerScore</kbd> <span>script class:</span></li>
</ol>
<pre style="padding-left: 30px">    using System.Xml.Serialization;<br/><br/>     [System.Serializable]<br/>     public class PlayerScore<br/>     {<br/>         [XmlElement("Name")]<br/>         public string name;<br/><br/>         [XmlElement("Score")]<br/>         public int score;<br/><br/>         [XmlElement("Version")]<br/>         public string version;<br/>     } </pre>
<ol start="2">
<li>Create a C# <kbd>PlayerScoreCollection</kbd> <span>scrip class: </span></li>
</ol>
<pre style="padding-left: 30px">    using System.Xml.Serialization;<br/>     using System.IO;<br/><br/>     [XmlRoot("PlayerScoreCollection")]<br/>     public class PlayerScoreCollection<br/>     {<br/>         [XmlArray("PlayerScores"), XmlArrayItem("PlayerScore")]<br/>         public PlayerScore[] playerScores;<br/><br/>         public void Save(string path) {<br/>             var serializer = new XmlSerializer(typeof(PlayerScoreCollection));<br/>             using (var stream = new FileStream(path, FileMode.Create)) {<br/>                 serializer.Serialize(stream, this);<br/>             }<br/>         }<br/>     } </pre>
<ol start="3">
<li>Create a C# <kbd>XmlWriter</kbd> <span>script class </span>and attach an instance as a component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using System.IO;<br/><br/>     public class XmlWriter : MonoBehaviour {<br/>         public string fileName = "playerData.xml";<br/>         public string folderName = "Data";<br/><br/>         private void Start() {<br/>             string filePath = Path.Combine(Application.dataPath, folderName);<br/>             filePath = Path.Combine(filePath, fileName);<br/><br/>             PlayerScoreCollection psc = CreatePlayScoreCollection();<br/>             psc.Save(filePath);<br/>             print("XML file should now have been created at: " + filePath);<br/>         }<br/><br/>         private PlayerScoreCollection CreatePlayScoreCollection() {<br/>             PlayerScoreCollection playerScoreCollection = new PlayerScoreCollection();<br/><br/>             // make 2 slot array<br/>             playerScoreCollection.playerScores = new PlayerScore[2];<br/><br/>             playerScoreCollection.playerScores[0] = new PlayerScore();<br/>             playerScoreCollection.playerScores[0].name = "matt";<br/>             playerScoreCollection.playerScores[0].score = 22;<br/>             playerScoreCollection.playerScores[0].version = "v0.5";<br/><br/>             playerScoreCollection.playerScores[1] = new PlayerScore();<br/>             playerScoreCollection.playerScores[1].name = "joelle";<br/>             playerScoreCollection.playerScores[1].score = 5;<br/>             playerScoreCollection.playerScores[1].version = "v0.9";<br/><br/>             return playerScoreCollection;<br/>         }<br/>     } </pre>
<ol start="4">
<li>You can quickly test the scene in the Unity Editor if you create a <kbd>Data</kbd> folder in the <span class="packt_screen">Project</span> panel and then run the scene. After 10-20 seconds, you should now find that text file <kbd>playerData.xml</kbd> has been created in the <kbd>Data</kbd> folder.</li>
<li>Save the current scene and then add this to the list of scenes in the build.</li>
<li>Build and run your (Windows, Mac, or Linux) standalone executable.</li>
<li>You should now find a new text file named <kbd>playerData.xml</kbd> in the <kbd>Data</kbd> folder of your project's standalone files, containing the XML data for the three players.</li>
<li>The content of the <kbd>playerData.xml</kbd> file should be the XML player list data, that is:</li>
</ol>
<pre style="padding-left: 60px">    &lt;?xml version="1.0" encoding="us-ascii"?&gt;<br/>     &lt;PlayerScoreCollection<br/>         <br/>         &gt;<br/>       &lt;PlayerScores&gt;<br/>         &lt;PlayerScore&gt;<br/>           &lt;Name&gt;matt&lt;/Name&gt;<br/>           &lt;Score&gt;22&lt;/Score&gt;<br/>           &lt;Version&gt;v0.5&lt;/Version&gt;<br/>         &lt;/PlayerScore&gt;<br/>         &lt;PlayerScore&gt;<br/>           &lt;Name&gt;joelle&lt;/Name&gt;<br/>           &lt;Score&gt;5&lt;/Score&gt;<br/>           &lt;Version&gt;v0.9&lt;/Version&gt;<br/>         &lt;/PlayerScore&gt;<br/>       &lt;/PlayerScores&gt;<br/>     &lt;/PlayerScoreCollection&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Start()</kbd> method of class <kbd>XmlWriter</kbd> defines the file path (<kbd>Data/playerData.xml</kbd>) and creates a new <kbd>PlayerScoreCollection</kbd> object <span class="packt_screen">psc</span>, by invoking the method <kbd>CreatePlayScoreCollection().</kbd> The Save(...) method of the <kbd>PlayerScoreCollection</kbd> object is then invoked, passing the file path.</p>
<p>The <kbd>CreatePlayScoreCollection()</kbd> method of class <kbd>XmlWriter</kbd> creates a new <kbd>PlayerScoreCollection</kbd>, and inserts into this an array of two <kbd>PlayerScore</kbd> objects with name/score/version values as follows:</p>
<pre>    matt, 22, v0.5<br/>    joelle, 5, v.09 </pre>
<p>The <kbd>Save(...)</kbd> method of class <kbd>PlayerScoreCollection</kbd> creates a new <kbd>XmlSerializer</kbd> for the class type, and uses a <kbd>FileStream</kbd> to tell C# to serialize the content of the <kbd>PlayerScoreCollection</kbd> object (that is, its array of <kbd>PlayerScore</kbd> objects) as text to that file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the XML node names</h1>
                </header>
            
            <article>
                
<p>We can use compiler statements to define the XML element name that will be used to encode each object property. For example, we have defined element <span class="packt_screen">Name</span> (with a capital letter <span class="packt_screen">N</span>) for the name property of each <kbd>PlayerScore</kbd>:</p>
<pre>    [XmlElement("Name")]<br/>    public string name; </pre>
<p>If this hadn't been declared, then the <span class="packt_screen">XML Serializer</span> would have defaulted to the lowercase property name <kbd>name</kbd> for these data elements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading data objects from XML text</h1>
                </header>
            
            <article>
                
<p>We can write static (class) methods for class <kbd>PlayerScoreCollection</kbd> that use the <kbd>XML</kbd><kbd>Serializer</kbd> to load XML data and create data objects from that loaded data.</p>
<p>Here is a method to load from a <span class="packt_screen">filepath</span>:</p>
<pre>    public static PlayerScoreCollection Load(string path) {<br/>         var serializer = new XmlSerializer(typeof(PlayerScoreCollection));<br/>         using (var stream = new FileStream(path, FileMode.Open)) {<br/>             return serializer.Deserialize(stream) as PlayerScoreCollection;<br/>         }<br/>     } </pre>
<p>Another method can be written to load from a text string:</p>
<pre>    public static PlayerScoreCollection LoadFromString(string text) {<br/>         var serializer = new XmlSerializer(typeof(PlayerScoreCollection));<br/>         return serializer.Deserialize(new StringReader(text)) as PlayerScoreCollection;<br/>     } </pre>
<p>For example, you could create a public <kbd>TextAsset</kbd> variable, and then create a <kbd>PlayerScoreCollection</kbd> object by invoking this static method, then loop through and print out the loaded objects with code such as the following:</p>
<pre>    public TextAsset dataAsXmlString;<br/><br/>     private void Start()<br/>     {<br/>         PlayerScoreCollection objectCollection =   <br/>         PlayerScoreCollection.LoadFromString(dataAsXmlString.text);<br/><br/>         foreach(PlayerScore playerScore in objectCollection.playerScores){<br/>             print("name = " + playerScore.name + ", score = " + playerScore.score + ",<br/>                 version = " + playerScore.version);<br/>         }<br/>     } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating XML text files – saving XML directly to text files with XMLDocument.Save()</h1>
                </header>
            
            <article>
                
<p>It is possible to create an XML data structure and then save that data directly to a text file using the <kbd>XMLDocument.Save()</kbd> method; this recipe illustrates how.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To save XML data to text files directly, perform the following steps:</p>
<ol>
<li>Create a new C# <kbd>PlayerXMLWriter</kbd> <span>script class:</span></li>
</ol>
<pre style="padding-left: 60px">    using System.Xml;<br/>     using System.IO;<br/><br/>     public class PlayerXMLWriter {<br/>         private string filePath;<br/>         private XmlDocument xmlDoc;<br/>         private XmlElement elRoot;<br/><br/>         public PlayerXMLWriter(string filePath) {<br/>             this.filePath = filePath;<br/>             xmlDoc = new XmlDocument();<br/><br/>             if(File.Exists (filePath)) {<br/>                 xmlDoc.Load(filePath);<br/>                 elRoot = xmlDoc.DocumentElement;<br/>                 elRoot.RemoveAll();<br/>             }<br/>             else {<br/>                 elRoot  = xmlDoc.CreateElement("playerScoreList");<br/>                 xmlDoc.AppendChild(elRoot);<br/>             }<br/>         }<br/><br/>         public void AddXMLElement(string playerName, string playerScore) {<br/>             XmlElement elPlayer = xmlDoc.CreateElement("playerScore");<br/>             elRoot.AppendChild(elPlayer);<br/><br/>             XmlElement elName = xmlDoc.CreateElement("name");<br/>             elName.InnerText = playerName;<br/>             elPlayer.AppendChild(elName);<br/><br/>             XmlElement elScore = xmlDoc.CreateElement("score");<br/>             elScore.InnerText = playerScore;<br/>             elPlayer.AppendChild(elScore);<br/>         }<br/><br/>         public void SaveXMLFile() {<br/>            xmlDoc.Save(filePath);<br/>         }<br/>     } </pre>
<ol start="2">
<li>Create a C# <kbd>CreateXMLTextFile</kbd> <span>script class </span>and attach an instance as a component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using System.IO;<br/><br/>     public class CreateXMLTextFile : MonoBehaviour {<br/>         public string fileName = "playerData.xml";<br/>         public string folderName = "Data";<br/><br/>         private void Start() {<br/>             string filePath = Path.Combine( Application.dataPath, folderName);<br/>             filePath = Path.Combine( filePath, fileName);<br/><br/>             PlayerXMLWriter playerXMLWriter = new PlayerXMLWriter(filePath);<br/>             playerXMLWriter.AddXMLElement("matt", "55");<br/>             playerXMLWriter.AddXMLElement("jane", "99");<br/>             playerXMLWriter.AddXMLElement("fred", "101");<br/>             playerXMLWriter.SaveXMLFile();<br/><br/>             print( "XML file should now have been created at: " + filePath);<br/>         }<br/>     } </pre>
<ol start="3">
<li>You can quickly test the scene in the Unity Editor if you create a <kbd>Data</kbd> folder in the <span class="packt_screen">Project</span> panel and then run the scene. After 10-20 seconds, you should now find that text file <kbd>playerData.xml</kbd> has been created in the <kbd>Data</kbd> folder.</li>
<li>Save the current scene and then add this to the list of scenes in the build.</li>
<li>Build and run your (Windows, Mac, or Linux) standalone executable.</li>
<li>You should now find a new text file named <kbd>playerData.xml</kbd> in the <kbd>Data</kbd> folder of your project's standalone files, containing the XML data for the three players:</li>
<li>The content of the <kbd>playerData.xml</kbd> file should be the XML player list data:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/921244fb-5937-498c-944b-9212e785db90.png" style="width:26.42em;height:15.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Start()</kbd> method creates <kbd>playerXMLWriter</kbd>, a new object of the <kbd>PlayerXMLWriter</kbd> class, to which it passes the new, required XML text file <kbd>filePath</kbd> as an argument. Three elements are added to the <kbd>PlayerXMLWriter</kbd> object, which store the names and scores of three players. The <kbd>SaveXMLFile()</kbd> method is called and a debug <kbd>print()</kbd> message is displayed.</p>
<p>The constructor method of the <kbd>PlayerXMLWriter</kbd> class works as follows: when a new object is created, the provided file path string is stored in a private variable; at the same time, a check is made to see whether any file already exists. If an existing file is found, the content elements are removed; if no existing file is found, then a new root element, <kbd>playerScoreList</kbd>, is created as the parent for child data nodes. The method <kbd>AddXMLElement()</kbd> appends a new data node for the provided player name and score. The method <kbd>SaveXMLFile()</kbd> saves the XML data structure as a text file for the stored file path string.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating JSON strings from individual objects and lists of objects</h1>
                </header>
            
            <article>
                
<p>The <kbd>JsonUtility</kbd> class allows us to easily create JSON strings from individual objects, and also <strong>Lists</strong> of objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create JSON strings from individual and <strong>Lists</strong> of objects perform the following steps:</p>
<ol>
<li>Create a new C# script class named <kbd>PlayerScore</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/><br/>     [System.Serializable]<br/>     public class PlayerScore {<br/>         public string name;<br/>         public int score;<br/><br/>         public string ToJson() {<br/>             bool prettyPrintJson = true;<br/>             return JsonUtility.ToJson(this, prettyPrintJson);<br/>         }<br/>     } </pre>
<ol start="2">
<li>Create a new C# script class named <kbd>PlayerScoreList</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using System.Collections.Generic;<br/><br/>     [System.Serializable]<br/>     public class PlayerScoreList {<br/>         public List&lt;PlayerScore&gt; list = new List&lt;PlayerScore&gt;();<br/><br/>         public string ToJson() {<br/>             bool prettyPrint = true;<br/>             return JsonUtility.ToJson(this, prettyPrint);<br/>         }<br/>     } </pre>
<ol start="3">
<li>Create a C# <kbd>ToJson</kbd> <span>script clas</span><span>s a</span>nd attach an instance as a component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/><br/>     public class ToJson : MonoBehaviour {<br/>         private PlayerScore playerScore1 = new PlayerScore();<br/>         private PlayerScore playerScore2 = new PlayerScore();<br/>         private PlayerScoreList playerScoreList = new PlayerScoreList();<br/><br/>         private void Awake() {<br/>             playerScore1.name = "matt";<br/>             playerScore1.score = 800;<br/><br/>             playerScore2.name = "joelle";<br/>             playerScore2.score = 901;<br/><br/>             playerScoreList.list.Add(playerScore1);<br/>             playerScoreList.list.Add(playerScore2);<br/>         }<br/><br/>         void Start() {<br/>             ObjectToJson();<br/>             CollectionToJson();<br/>         }<br/><br/>         public void ObjectToJson() {<br/>             string objectAsString = playerScore1.ToJson();<br/>             print("1: Object to JSON \n" + objectAsString);<br/>         }<br/><br/>         public void CollectionToJson() {<br/>             string objectListAsString = playerScoreList.ToJson();<br/>             print("2: List of objects to JSON \n" + objectListAsString);<br/>         }<br/>     } </pre>
<ol start="4">
<li>Run the scene. Two messages should be output to the <span class="packt_screen">Console</span> panel:</li>
</ol>
<pre style="padding-left: 60px">    1: Object to JSON<br/>     {<br/>         "name": "matt",<br/>         "score": 800<br/>     } </pre>
<p style="padding-left: 60px">These should be followed by this:</p>
<pre style="padding-left: 60px">    2: List of objects to JSON<br/>     {<br/>         "list": [<br/>             {<br/>                 "name": "matt",<br/>                 "score": 800<br/>             },<br/>             {<br/>                 "name": "joelle",<br/>                 "score": 901<br/>             }<br/>         ]<br/>     } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>PlayerScore</kbd> scrip class declares two public properties: <kbd>name</kbd> and <kbd>score</kbd>. It also defines a public method <kbd>ToJson()</kbd> that returns a string containing the values of the properties encoded in JSON via the <kbd>JsonUtility.ToJson(...)</kbd> method.</p>
<p>The <kbd>PlayerScoreList</kbd><span> script class d</span>eclares a single public property <kbd>list</kbd> , which is a C# <kbd>List&lt;&gt;</kbd> of <kbd>PlayerScore</kbd> obejcts. So, we can store zero, one, or any number of <kbd>PlayerScore</kbd> objects in our list. Also declared is a single public method <kbd>ToJson()</kbd> that returns a string containing the values of the content of the <kbd>list</kbd> <span>property e</span>ncoded in JSON via the <kbd>JsonUtility.ToJson(...)</kbd> method.</p>
<p>It also defines a public <kbd>ToJson()</kbd> <span>method t</span>hat returns a string containing the values of the properties encoded in JSON via the <kbd>JsonUtility.ToJson(...)</kbd> method.</p>
<p>The <kbd>Awake()</kbd> method creates two <kbd>PlayerScore</kbd> objects, with some demo data in objects <kbd>playerScore1</kbd> and <kbd>playerScore2</kbd>. It also creates an instance-object of class <kbd>PlayerScoreList</kbd>, and adds references to the two objects to this list.</p>
<p>The <kbd>Start()</kbd> method first invokes the <kbd>ObjectToJson()</kbd> method, then it invokes the <kbd>CollectionToJson()</kbd>.</p>
<p>Method <kbd>ObjectToJson()</kbd> invokes the <kbd>ToJson()</kbd> method of object <kbd>playerScore1</kbd>, which returns a string, which is then printed to the <span class="packt_screen">Console</span> panel.</p>
<p>Method <kbd>CollectionToJson()</kbd> invokes the <kbd>ToJson()</kbd> method of object list <kbd>playerScoreList</kbd> which returns a string, which is then printed to the Console panel.</p>
<p>As we can see, both <kbd>PlayerScore</kbd> and <kbd>PlayerScoreList</kbd> classes define a <kbd>ToJson()</kbd> method, which makes use of the <kbd>JsonUtilty</kbd><kbd>ToJson()</kbd> method. In both cases, their <kbd>ToJson()</kbd> method returns a string that is the JSON representation of the object's data.</p>
<p>The <kbd>PlayerScore</kbd> class's <kbd>ToJson()</kbd> method outputs a JSON object string in this form:</p>
<pre>    { "name": "matt", "score": 800 }. </pre>
<p>The <kbd>ToJson()</kbd> method of the <span> </span><kbd>PlayerScoreList</kbd><span> class </span>outputs a JSON array string in this form:</p>
<pre>    {<br/>         "list": [<br/>             { "name": "matt", "score": 800 },<br/>             { "name": "joelle", "score": 901 }<br/>         ]<br/>     } </pre>
<p>As we can see, the <kbd>JsonUtility</kbd> class's <kbd>ToString()</kbd> method is capable of serializing individual objects, and C# <span class="packt_screen">Lists</span> of objects into a storable string.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating individual objects and Lists of objects from JSON strings</h1>
                </header>
            
            <article>
                
<p>The <kbd>JsonUtility</kbd> class allows us to easily parse (process) JSON strings and extract individual objects, and also <span class="packt_screen">Lists</span> of objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create individual objects and <span class="packt_screen">Lists</span> of objects from JSON strings, perform the following steps:</p>
<ol>
<li>Create a new C# script class named <kbd>PlayerScore</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/><br/>     [System.Serializable]<br/>     public class PlayerScore {<br/>         public string name;<br/>         public int score;<br/><br/>         public static PlayerScore FromJSON(string jsonString) {<br/>             return JsonUtility.FromJson&lt;PlayerScore&gt;(jsonString);<br/>         }<br/>     } </pre>
<ol start="2">
<li>Create a new C# script class named <kbd>PlayerScoreList</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using System.Collections.Generic;<br/><br/>     [System.Serializable]<br/>     public class PlayerScoreList {<br/>         public List&lt;PlayerScore&gt; list = new List&lt;PlayerScore&gt;();<br/><br/>         public static PlayerScoreList FromJSON(string jsonString) {<br/>             return JsonUtility.FromJson&lt;PlayerScoreList&gt;(jsonString);<br/>         }<br/>     } </pre>
<ol start="3">
<li>Create a C# <kbd>ToJson</kbd> <span>script class a</span>nd attach an instance as a component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/><br/>     public class FromJson : MonoBehaviour {<br/>         private void Start() {<br/>             JsonToObject();<br/>             JsonToList();<br/>         }<br/><br/>         public void JsonToObject() {<br/>             string playerScoreAsString = "{ \"name\":\"matt\", \"score\":201}";<br/>             PlayerScore playerScore = PlayerScore.FromJSON(playerScoreAsString);<br/><br/>             print(playerScore.name + ", " + playerScore.score);<br/>         }<br/><br/>         public void JsonToList() {<br/>             string playerScorelistAsString = "";<br/><br/>             playerScorelistAsString += "{";<br/>             playerScorelistAsString += "\"list\": [";<br/>             playerScorelistAsString += "        {";<br/>             playerScorelistAsString += "            \"name\": \"matt\",";<br/>             playerScorelistAsString += "            \"score\": 800";<br/>             playerScorelistAsString += "        },";<br/>             playerScorelistAsString += "        {";<br/>             playerScorelistAsString += "            \"name\": \"joelle\",";<br/>             playerScorelistAsString += "            \"score\": 901";<br/>             playerScorelistAsString += "        }";<br/>             playerScorelistAsString += "    ]";<br/>             playerScorelistAsString += "}";<br/><br/>             PlayerScoreList playerScoreList = PlayerScoreList.FromJSON(playerScorelistAsString);<br/><br/><br/>             foreach (var playerScore in playerScoreList.list) {<br/>                 print("from list :: " + playerScore.name + ", " + playerScore.score);<br/>             }<br/>         }<br/>     } </pre>
<ol start="4">
<li>Run the scene. Three messages should be output to the <span class="packt_screen">Console</span> panel:</li>
</ol>
<pre style="padding-left: 60px">    matt, 201 </pre>
<p style="padding-left: 60px">They should be followed by this:</p>
<pre style="padding-left: 60px">    from list :: matt, 800<br/>    from list :: joelle, 901 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Start()</kbd> method first invokes method <kbd>JsonToObject()</kbd>, and then it invokes method <kbd>JsonToList().</kbd></p>
<p>The method <kbd>JsonToObject()</kbd> declares a string that defines one <kbd>PlayerScore</kbd> object: <kbd>{name:matt, score:201}.</kbd> The string is created using escaped double-quote characters for property names and text data (quotes aren't needed for the numeric data). The JSON string contains the following:</p>
<pre>{ 
   "name":"matt",  
   "score":201 
} </pre>
<p>Using escaped double-quote characters for property names and text data (quotes aren't needed for the numeric data). The <strong>static</strong> method <kbd>FromJSON(...)</kbd> of the class <kbd>PlayerScore</kbd> is then invoked with this JSON data string as its argument. The method returns a <kbd>PlayerScore</kbd> object, whose value is then printed to the <span class="packt_screen">Console</span> panel.</p>
<p>The <strong>static</strong> method <kbd>FromJSON(...)</kbd> of class <kbd>PlayerScore</kbd> invokes the <kbd>FromJson()</kbd> method of the <kbd>JsonUtility</kbd> class, and provides the class type <kbd>PlayerScore</kbd>.</p>
<p>The method <kbd>JsonToList()</kbd> declares a string that defines a list of two <kbd>PlayerScore</kbd> objects: <kbd>{name:matt, score:800}</kbd> and <kbd>{name:joelle, score:901}</kbd>. The JSON string contains the following:</p>
<pre>{ 
   "list": [         
         {             
               "name": "matt",             
               "score": 800         
         },         
         {             
               "name": "joelle",            
               "score": 901         
         }     
   ] 
} </pre>
<p>The <strong>static</strong> method <kbd>FromJSON(...)</kbd> of the class <kbd>PlayerScoreList</kbd> is then invoked with this JSON data string as its argument. The method returns a <kbd>PlayerScoreList</kbd> object. A <kbd>foreach</kbd> loop extracts each <kbd>PlayerScore</kbd> object from the <span class="packt_screen">list</span> property of the <kbd>PlayerScoreList</kbd> object. Each object's <kbd>name</kbd> and <kbd>score</kbd> values are printed out to the <span class="packt_screen">Console</span> panel, prefixed with the text from the list.</p>
<p>The <strong>static</strong> method <kbd>FromJSON(...)</kbd> of class <kbd>PlayerScoreList</kbd> invokes the <kbd>FromJson()</kbd> method of the <kbd>JsonUtility</kbd> class, and provides the class type <kbd>PlayerScoreList</kbd>.</p>
<p>As we can see, the <kbd>JsonUtility</kbd> class's <kbd>FromJson()</kbd> method is capable of deserializing data into individual objects, and C# <strong>Lists</strong> of objects inside repository objects, such as <kbd>PlayerScoreList</kbd>.</p>


            </article>

            
        </section>
    </body></html>