- en: '*Chapter 14*: Building HTTP APIs and Real-Time Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exposing an HTTP API endpoint is a fairly common way of allowing client applications
    to consume your application functionalities. Building HTTP APIs makes your application
    open to any client since almost all devices that connect to a network already
    implement the HTTP protocol.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about options to create HTTP APIs for your
    solutions. You will also see how ABP makes it easy to consume your HTTP APIs from
    client applications by using ABP''s dynamic and generated client-side proxies.
    Finally, we will explain how you can use Microsoft''s **SignalR** library in ABP
    applications to implement real-time server-client communication. Here is a list
    of topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Building HTTP APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming HTTP APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SignalR with ABP Framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development. We will use the ABP CLI at some points,
    so you need to install the ABP CLI, as explained in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026),
    *Getting Started with ABP Framework*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the example application from the following GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples given in this chapter.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Building HTTP APIs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will begin with ASP.NET Core's standard approach for creating
    HTTP APIs. Then we will see how ABP can automatically convert standard application
    services to HTTP API endpoints. But first, let's see how we can create API-only
    solutions with ABP Framework.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTP API project
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new application or module with ABP Framework's startup solution
    templates, it already contains HTTP APIs for all the functionality provided by
    the application. However, it is also possible to create an HTTP API endpoint without
    an application UI if you want to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-u none` parameter when you create a new solution using ABP
    Framework, as shown in the following example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ApiDemo` is our solution name here. In this way, we have a solution with an
    HTTP API endpoint but without a UI. The following figure shows the solution opened
    in Visual Studio:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – An HTTP API solution created by the ABP CLI'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.01_B17287.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – An HTTP API solution created by the ABP CLI
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We should first run the `ApiDemo.DbMigrator` application to create the database,
    so the HTTP API properly works. To do that, right-click the `ApiDemo.DbMigrator`
    project, click the `ApiDemo.DbMigrator` project and execute the `dotnet run` command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run the `ApiDemo.HttpApi.Host` project to start the HTTP API application.
    The HTTP API application shows Swagger UI by default, as shown in the following
    figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Swagger UI'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.02_B17287.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Swagger UI
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI is a very useful tool to explore and test our HTTP API endpoints.
    We can use the `admin`, and the default password is `1q2w3E*`), so we can also
    test the APIs that require authorization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use the `/api/identity/roles` endpoint to get a list of
    roles defined in the system. This endpoint requires authorization, so log in first
    with the `/api/identity/roles` endpoint under the **Role** group, click to expand
    it, click the **Try it out** button, then the **Execute** button to call the endpoint.
    When you call it, the server returns a JSON value as shown in the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, we've learned how to create and launch an HTTP API solution with ABP Framework.
    Now, let's see how we can add new APIs using ASP.NET Core's standard controllers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creating ASP.NET Core controllers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core''s controllers provide a convenient infrastructure to create HTTP
    APIs. The following example exposes HTTP endpoints to get the product list and
    update a product:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ProductController` class is inherited from the `ControllerBase` class.
    It is suggested to inherit your API controller classes from the `ControllerBase`
    class instead of the `Controller` class since it contains some view-related functionality
    that is unnecessary for API Controllers. Alternatively, you can inherit your API
    controller classes from the `AbpControllerBase` class, which provides some common
    ABP services as pre-injected properties for you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `[ApiController]` attribute on top of the controller class enables
    ASP.NET Core's default API-specific behaviors (such as automatic HTTP 400 responses
    and attribute routing requirement), so it is also suggested.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `[Route]` attribute defines the URL of the APIs while the
    `HttpGet` and `HttpPut` attributes determine the HTTP method associated with the
    API endpoints.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP is 100% compatible with ASP.NET Core''s standard structures, so you can
    refer to Microsoft''s documentation to learn all the details of creating API Controllers:
    [https://docs.microsoft.com/en-us/aspnet/core/web-api](https://docs.microsoft.com/en-us/aspnet/core/web-api).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'When you implement layering in your solution, you generally find yourself creating
    controller classes, which wrap your application services. For example, assume
    that you have `IProductAppService`, which already implements the product-related
    use cases, and you want to expose its methods as HTTP API endpoints. The following
    example defines a controller that redirects all requests to the underlying application
    service:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we didn't use ABP Framework, we'd need to write such controllers to be able
    to define the route, HTTP method, and other HTTP-related details for the endpoint.
    However, ABP Framework can automatically expose your application services as HTTP
    API endpoints, as explained in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Auto API Controllers
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP''s Auto API Controller system converts your application services to API
    controllers by convention. To enable Auto API Controllers, we should configure
    `AbpAspNetCoreMvcOptions` as shown in the following code block:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That configuration code is located in the UI or HTTP API layer of the solution
    (the `ApiDemoHttpApiHostModule` class of the `options.ConventionalControllers.Create`
    method takes an `Assembly` object, finds all the application service classes inside
    that `Assembly`, and exposes them as controllers using pre-defined conventions.
    When you create a new ABP solution from the startup template, you already have
    that configuration inside your solution, so you don't need to configure it yourself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have defined an application service as in the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remember that the `ProductAppService` class is defined in the `ApiDemo.Application`
    project and the `IProductAppService` interface is defined in the `ApiDemo.Application.Contracts`
    project. We can run the application without any additional configuration to see
    the new HTTP API endpoints on Swagger UI:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Auto API Controller on Swagger UI'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.03_B17287.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Auto API Controller on Swagger UI
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP Framework configured ASP.NET Core so `ProductAppService` becomes a controller.
    ABP Framework determines the HTTP method automatically by the name of the related
    C# method. For example, methods starting with the `Get` prefix are considered
    HTTP GET methods. Routes are also automatically determined by convention. You
    can refer to the ABP documentation to learn about all the conventions and customization
    options for the HTTP method and route determination: [https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers](https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: When to Define Controllers Manually
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: When you use ABP Framework, you generally don't need to define the API controllers
    manually. However, you can still write the controllers in a standard way if you
    want to do so. An advantage of writing manual controllers is that you can fully
    use HTTP layer capabilities to define and shape your APIs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP Framework converts all the application services to API controllers in the
    configured assembly. If you want to disable it for a specific application service,
    you can use the `[RemoteService]` attribute with the `false` parameter as shown
    in the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ABP Framework also enables ASP.NET Core's API explorer feature for the application
    service. In this way, your API endpoints become discoverable and are shown on
    Swagger UI. If you want to expose the HTTP endpoint but disable the API explorer,
    you can set the `IsMetadataEnabled` parameter of the `[RemoteService]` attribute
    to `false`, for example, `[RemoteService(IsMetadataEnabled = false)]`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: As we've learned in this section, ABP can automate exposing your application
    services to remote clients, while you can still use your existing skills to create
    standard ASP.NET Core controllers whenever you need them. In the next section,
    we will explore the ways you consume your HTTP APIs from client applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节所学，ABP 可以自动化将你的应用程序服务暴露给远程客户端，同时你仍然可以使用现有的技能在需要时创建标准的 ASP.NET Core 控制器。在下一节中，我们将探讨从客户端应用程序消费
    HTTP API 的方法。
- en: Consuming HTTP APIs
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费 HTTP API
- en: Consuming your HTTP APIs from your client applications typically requires a
    lot of common and repetitive logic to apply. You deal with authorization, object
    serialization, exception handling, and more in every HTTP request to the server.
    ABP Framework can completely automate that process via dynamic and generated (static)
    client-side proxies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的客户端应用程序消费 HTTP API 通常需要大量的常见和重复的逻辑来应用。你需要在每个发送到服务器的 HTTP 请求中处理授权、对象序列化、异常处理等。ABP
    框架可以通过动态和生成的（静态）客户端代理完全自动化这个过程。
- en: We've already covered the practical usage of ABP's client-side proxy system
    in the *Consuming HTTP APIs* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, and in the *Consuming HTTP APIs* section of [*Chapter
    13*](B17287_13_Epub_AM.xhtml#_idTextAnchor407), *Working with the Blazor WebAssembly
    UI*. So, I won't repeat it here but will bring it all together and fill in the
    missing points.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 12 章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356) 的 *消费 HTTP API* 部分、*与
    MVC/Razor Pages 一起工作* 以及在 [*第 13 章*](B17287_13_Epub_AM.xhtml#_idTextAnchor407)
    的 *消费 HTTP API* 部分中介绍了 ABP 客户端代理系统的实际用法，*与 Blazor WebAssembly UI 一起工作*。因此，这里不再重复，但会将所有内容汇总在一起，并填补缺失的要点。
- en: Let's start with dynamic client proxies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从动态客户端代理开始。
- en: Using ABP's dynamic client-side proxies
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ABP 的动态客户端代理
- en: The dynamic proxy system allows us to consume server-side HTTP APIs with a simple
    configuration. The *dynamic* name states that the proxy code is generated dynamically
    at runtime.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代理系统允许我们通过简单的配置来消费服务器端 HTTP API。*动态* 名称表明代理代码是在运行时动态生成的。
- en: 'ABP''s dynamic client proxy system supports two types of client applications:
    .NET and JavaScript.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的动态客户端代理系统支持两种类型的客户端应用程序：.NET 和 JavaScript。
- en: Using dynamic .NET client proxies
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用动态 .NET 客户端代理
- en: 'ABP''s startup solution separates the application layer into two projects.
    The project that ends with `Application.Contracts` contains the interfaces and
    `Application` contains the implementation of these interfaces. The following figure
    shows the `IProductAppService` interface and the `ProductAppService` class inside
    the `Application.Contracts` and the `Application` projects in an example solution:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 的启动解决方案将应用程序层分为两个项目。以 `Application.Contracts` 结尾的项目包含接口，而 `Application`
    包含这些接口的实现。以下图显示了示例解决方案中 `Application.Contracts` 和 `Application` 项目内的 `IProductAppService`
    接口和 `ProductAppService` 类：
- en: '![Figure 14.4 – The application layer, separated into two projects'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 14.4 – The application layer, separated into two projects](img/Figure_14.04_B17287.jpg)'
- en: '](img/Figure_14.04_B17287.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 14.04_B17287.jpg](img/Figure_14.04_B17287.jpg)'
- en: Figure 14.4 – The application layer, separated into two projects
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 将应用程序层分离成两个项目
- en: 'Separating the contracts from the implementation has an advantage: we can reuse
    the `ApiDemo.Application.Contracts` project from a .NET client application without
    making the client application reference the implementations of the application
    services.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将契约与实现分离具有优势：我们可以从 .NET 客户端应用程序重用 `ApiDemo.Application.Contracts` 项目，而无需让客户端应用程序引用应用程序服务的实现。
- en: 'A .NET client application can reference the `ApiDemo.Application.Contracts`
    project and configure ABP''s dynamic .NET client proxy system to be able to consume
    the HTTP APIs, just like consuming a local service. The following example shows
    that configuration, which is done in a client application (that configuration
    exists in the `ApiDemoHttpApiClientModule` class of the `ApiDemo.HttpApi.Client`
    project):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 .NET 客户端应用程序可以引用 `ApiDemo.Application.Contracts` 项目，并配置 ABP 的动态 .NET 客户端代理系统，以便能够消费
    HTTP API，就像消费本地服务一样。以下示例显示了这种配置，该配置在客户端应用程序中完成（该配置存在于 `ApiDemo.HttpApi.Client`
    项目的 `ApiDemoHttpApiClientModule` 类中）：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AddHttpClientProxies` method takes an `Assembly` and creates dynamic proxies
    for all the application service interfaces in that `Assembly`. Here, we pass the
    assembly of the `ApiDemo.Application.Contracts` project by using the module class
    inside it. When you create a new ABP solution, you will see that configuration
    in the `HttpApi.Client` project. So, any .NET client application that references
    the `HttpApi.Client` project can directly consume your HTTP APIs without any configuration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: With such a simple single configuration, we can inject any application service
    interface into the `ApiDemo.Application.Contracts` project and use it as we use
    a local service. See the *Consuming HTTP APIs* section of [*Chapter 13*](B17287_13_Epub_AM.xhtml#_idTextAnchor407),
    *Working with the Blazor WebAssembly UI*, for example usage in a Blazor WebAssembly
    client application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we configure and use the dynamic .NET client proxies, ABP does all the
    heavy logic and performs an HTTP request to the server for us. Surely, ABP should
    know the server''s root URL to make the request. We can define it in the `appsettings.json`
    file of the client application as shown in the following example (there is an
    example of how to do that inside the `ApiDemo.HttpApi.Client.ConsoleTestApp` project):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can understand from this example, we can actually define multiple server
    endpoints. In this way, a client application can consume APIs from more than one
    server. The `Default` configuration one is used by default. You can add a second
    remote service configuration as shown in the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then you should specify the `remoteServiceConfigurationName` parameter to the
    `AddHttpClientProxies` method to map the configurations:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can add retry logic on failure to the dynamic client proxies. Please refer
    to the documentation for more configuration options: [https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients](https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework provides a special API endpoint from the server application that
    exposes the API definition to the clients. This endpoint contains the mapping
    between the application service contracts and the HTTP API endpoints of the application.
    The URL of that endpoint is `/api/abp/api-definition` on the server. Client applications
    first read that API definition endpoint to learn how to make HTTP calls to the
    server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen, ABP makes it extremely easy to consume HTTP APIs from .NET clients.
    In the next section, we will look at consuming HTTP APIs in a JavaScript client.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic JavaScript client proxies
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the .NET dynamic client proxies, ABP dynamically creates proxies to consume
    your HTTP API endpoints from JavaScript applications. ABP Framework provides a
    special endpoint that returns a JavaScript file that contains proxy functions
    for all of your HTTP API endpoints. The URL of the endpoint is `/Abp/ServiceProxyScript`.
    This URL is already added to the application layout by the current theme, so you
    can directly consume the HTTP APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET动态客户端代理类似，ABP动态创建代理以从JavaScript应用程序中消费您的HTTP API端点。ABP框架提供了一个特殊的端点，该端点返回一个包含所有HTTP
    API端点代理函数的JavaScript文件。该端点的URL是`/Abp/ServiceProxyScript`。这个URL已经被当前主题添加到应用程序布局中，因此您可以直接消费HTTP
    API。
- en: 'The following code block is a part of the service proxy script endpoint that
    contains the proxy functions for the `ProductAppService` class that we previously
    created in the *Understanding the Auto API Controllers* section of this chapter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是服务代理脚本端点的一部分，其中包含我们之前在本章*理解自动API控制器*部分创建的`ProductAppService`类的代理函数：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in that example, ABP Framework has created two JavaScript functions
    for the `ProductAppService` class''s methods. For example, we can call the `getList`
    function to get a list of the products, as shown in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在示例中看到的，ABP框架为`ProductAppService`类的每个方法创建了两个JavaScript函数。例如，我们可以调用`getList`函数来获取产品列表，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's that easy! Authorization, validation, exception handling, **CSRF** (**Cross-Site
    Request Forgery**), and the other details are handled by ABP Framework. The result
    value will be the product list (array) returned by the server. You can see the
    *Using dynamic client proxies* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, for more examples and information about this topic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就这么简单！授权、验证、异常处理、**CSRF**（**跨站请求伪造**）以及其他细节都由ABP框架处理。结果值将是服务器返回的产品列表（数组）。您可以在[*第12章*](B17287_12_Epub_AM.xhtml#_idTextAnchor356)的*使用MVC/Razor页面*部分查看*使用动态客户端代理*部分，以获取更多示例和相关信息。
- en: In the next section, we will explore an alternative way to use dynamic client
    proxies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用动态客户端代理的另一种方法。
- en: Using ABP's static (generated) client proxies
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ABP的静态（生成）客户端代理
- en: The dynamic proxy system completely automates proxy generation to consume HTTP
    endpoints from the client applications. It generates code at runtime based on
    dynamically obtained endpoint configuration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代理系统完全自动化代理生成，以从客户端应用程序中消费HTTP端点。它根据动态获取的端点配置在运行时生成代码。
- en: On the other hand, the static client proxy system (that comes with ABP v5.0)
    doesn't require obtaining the API definitions at runtime since it generates the
    client proxy code at development time. The disadvantage of the static proxy system
    is that you need to re-generate the client proxy code whenever a server API changes.
    However, static proxies are slightly faster than dynamic proxies since the code
    generation is done at development time and no runtime information is required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，ABP v5.0附带的静态客户端代理系统不需要在运行时获取API定义，因为它在开发时生成客户端代理代码。静态代理系统的缺点是，每当服务器API发生变化时，您需要重新生成客户端代理代码。然而，由于代码生成是在开发时完成的，并且不需要运行时信息，因此静态代理比动态代理稍微快一些。
- en: In some scenarios, such as when your client consumes HTTP APIs of multiple microservices
    behind an API gateway, the dynamic client proxy system can't directly work because
    the API gateway cannot combine and return the API definitions of all microservices
    from a single endpoint. In such cases, using static client proxies that were generated
    at development time can save us.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，例如当您的客户端消费位于API网关后面的多个微服务的HTTP API时，动态客户端代理系统无法直接工作，因为API网关无法从单个端点组合并返回所有微服务的API定义。在这种情况下，使用在开发时生成的静态客户端代理可以节省我们很多麻烦。
- en: In any case if you want to use the static client proxies, you use the ABP CLI
    to generate the client code. The following section shows how to use the ABP CLI
    to generate static C# client proxy code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果您想使用静态客户端代理，您可以使用ABP CLI生成客户端代码。下一节将展示如何使用ABP CLI生成静态C#客户端代理代码。
- en: Generating static C# client proxies
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成静态C#客户端代理
- en: In order to create static proxies, the client application/project should have
    a reference to the application service interfaces defined by the server because
    the client proxies implement the same interfaces and are used just like the dynamic
    proxies. So, in practice, the client application should reference the `Application.Contracts`
    project of the target application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The server application should be running when we use the ABP CLI to generate
    the proxy classes since the ABP CLI gets the API definition from the server. Once
    the server is up and running, use the `generate-proxy` command in the root folder
    of the client application/project, as shown in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`https://localhost:44367` is the server application''s URL here. The `-t` parameter
    specifies the client language, which is `csharp` for this example.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the newly added project files after running the
    `generate-proxy` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Generated client proxy files'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.05_B17287.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – Generated client proxy files
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the ABP CLI adds the `app-generate-proxy.json` file, which contains
    the API definition obtained from the `https://localhost:44367/api/abp/api-definition`
    endpoint for this example. ABP Framework then uses this file to get information
    about the API endpoint and make proper HTTP calls.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductClientProxy.Generated.cs` file contains the proxy class, which implements
    the `IProductAppService` interface for this example. In this way, we can inject
    the `IProductAppService` interface into any class and use it just like a local
    service. ABP performs the necessary HTTP API calls for us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductClientProxy.cs` is a partial class to add your additional methods and
    customize the class. The `ProductClientProxy.Generated.cs` file is re-generated
    whenever you execute the `generate-proxy` command, so your changes are overwritten
    if you edit that class. However, the `ProductClientProxy.cs` file can be safely
    edited since ABP won''t touch it again. It is left for you to customize the class.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will generate JavaScript proxies to consume HTTP APIs
    from a browser application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Generating static JavaScript client proxies
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ABP CLI can generate HTTP API client proxies for JavaScript clients, just
    like .NET clients. We can specify the `-t` parameter as `js` for JavaScript code
    generation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The JavaScript client proxy system works on jQuery and is compatible with ABP's
    MVC/Razor Pages UI. We've already seen the usage of JavaScript client code generation
    in the *Using static client proxies* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*. Please refer to that chapter to remember its usage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Generating static Angular client proxies
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While not covered in this book, ABP has a first-class Angular UI integration
    option. The ABP CLI''s `generate-proxy` command also works natively with Angular
    UI. You can specify the `-t` parameter as `ng` to generate TypeScript proxy code
    for Angular:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书没有涵盖，但 ABP 提供了一流的 Angular UI 集成选项。ABP CLI 的 `generate-proxy` 命令也原生支持 Angular
    UI。您可以将 `-t` 参数指定为 `ng` 以生成 Angular 的 TypeScript 代理代码：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The ABP CLI creates services and DTO classes on the Angular side, so you can
    directly inject proxies and consume the HTTP APIs without dealing with low-level
    HTTP details. Please refer to the ABP documentation to learn more about Angular
    client proxies: [https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies](https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ABP CLI 在 Angular 端创建服务和 DTO 类，因此您可以直接注入代理并消费 HTTP API，而无需处理低级 HTTP 细节。请参阅 ABP
    文档了解有关 Angular 客户端代理的更多信息：[https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies](https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies)。
- en: Generating proxies for other client types
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为其他客户端类型生成代理
- en: ABP provides client proxy generation for the client types it supports out of
    the box. It is suggested to use the ABP CLI's code generation for the supported
    client types. However, you may use another type of language, framework, or library
    on the client side and may want to generate the client proxies instead of manually
    writing them. In this case, you can use another tool that supports your platform
    since the ABP startup solution is compatible with Swagger/OpenAPI specifications.
    There are many tools around that can read the Swagger/OpenAPI specification and
    generate client-side proxy code for you. For example, the NSwag tool can generate
    client proxies for many different languages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 为其支持的客户端类型提供客户端代理生成。建议使用 ABP CLI 的代码生成功能来生成支持的客户端类型的代码。然而，您可能在客户端使用另一种类型的语言、框架或库，并可能希望生成客户端代理而不是手动编写它们。在这种情况下，您可以使用支持您平台的其他工具，因为
    ABP 启动解决方案与 Swagger/OpenAPI 规范兼容。有许多工具可以读取 Swagger/OpenAPI 规范并为您生成客户端代理代码。例如，NSwag
    工具可以为许多不同的语言生成客户端代理。
- en: We've learned how to consume server-side HTTP APIs from our client applications
    with ABP Framework. In the next section, we will learn how to establish a real-time
    communication channel with the server using Microsoft's SignalR library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 ABP 框架从我们的客户端应用程序中消费服务器端 HTTP API。在下一节中，我们将学习如何使用微软的 SignalR 库与服务器建立实时通信通道。
- en: Using SignalR with ABP Framework
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ABP 框架与 SignalR 一起使用
- en: Building REST-style HTTP APIs is good to consume server-side functionalities
    from client applications. However, it is limited – only the client application
    can call server APIs, and the server cannot normally start an operation on the
    client. WebSocket technology makes it possible to establish a two-way communication
    channel between the browser and the server to send messages to each other independently.
    So, with WebSocket, the server can notify the browser, send data, and trigger
    an action on the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 REST 风格的 HTTP API 便于从客户端应用程序消费服务器端功能。然而，它有一定的局限性——只有客户端应用程序可以调用服务器 API，而服务器通常不能在客户端启动操作。WebSocket
    技术使得在浏览器和服务器之间建立双向通信通道成为可能，以便独立地相互发送消息。因此，使用 WebSocket，服务器可以通知浏览器，发送数据，并在应用程序上触发操作。
- en: SignalR is a library by Microsoft that runs on WebSocket technology and simplifies
    the communication between the server and the client by abstracting WebSocket details.
    You can directly call the methods defined on the client from the server and vice
    versa.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 是微软的一个库，它运行在 WebSocket 技术上，并通过抽象 WebSocket 细节简化了服务器和客户端之间的通信。您可以直接从服务器调用客户端上定义的方法，反之亦然。
- en: ABP Framework does not add much value to SignalR since it is already easy to
    use. However, it provides a simple integration package that automates some common
    tasks for you. In the next two sections, we will see how to install and configure
    SignalR in your solutions. Let's start with ABP's server-side SignalR integration
    package.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架对 SignalR 的贡献不大，因为使用它已经很方便了。然而，它提供了一个简单的集成包，可以自动化一些常见的任务。在接下来的两个部分中，我们将了解如何在解决方案中安装和配置
    SignalR。让我们从 ABP 的服务器端 SignalR 集成包开始。
- en: Using the ABP SignalR integration package
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ABP SignalR 集成包
- en: '`Volo.Abp.AspNetCore.SignalR` is the NuGet package that adds the SignalR library
    to your server-side ABP application. You can install it using the ABP CLI. Open
    a command-line terminal in the root directory of the project where you want to
    add a server-side SignalR endpoint and execute the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The ABP CLI will install the NuGet package and add ABP module dependency for
    you. It also adds SignalR to dependency injection and configures the hub endpoint.
    So, you don't need an additional configuration after the installation. The next
    sections explain how to create SignalR hubs and do additional configuration when
    you need to.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Creating hubs
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SignalR hubs are used to create a high-level pipeline to handle client-server
    communication. You should define at least one hub to use SignalR. Creating a hub
    is pretty easy; just define a new class derived from the `Hub` base class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'ABP automatically registers the hub to the dependency injection system and
    configures the endpoint mapping. The URL of this example hub will be `/signalr-hubs/messaging`.
    The hub URL starts with `/signalr-hubs/` and continues with the hub class name
    converted to *kebab-case* without the `Hub` suffix. You can use the `[HubRoute]`
    attribute on top of the hub class to specify a different URL, as shown in the
    following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As an alternative to the `Hub` class, you can inherit your hub from the `AbpHub`
    class. The `AbpHub` class provides some common services (such as `ICurrentUser`,
    `ILogger`, and `IAuthorizationService`) pre-injected as base properties, so you
    don't need to inject them manually.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Configuring hubs
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ABP automatically maps your hubs and does the basic configuration. If you want
    to customize the hub configuration, you can do it in the `ConfigureServices` method
    of your module class, as shown in the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example configures `MessagingHub`, sets a custom route, and changes the
    `LongPolling` options.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Using the ABP SignalR integration package doesn't add much value but simplifies
    integrating and configuring the SignalR library on the server side of our ABP
    applications. In the next section, we will see ways of connecting to a SignalR
    hub from a client application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SignalR clients
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connecting to a SignalR hub from a client application depends on your client
    type. In this section, I will explain how to install the SignalR client library
    to an ABP application with the ASP.NET Core MVC UI. Please refer to Microsoft''s
    documentation for other client types, such as TypeScript or .NET clients: [https://docs.microsoft.com/en-us/aspnet/core/signalr](https://docs.microsoft.com/en-us/aspnet/core/signalr).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'To install SignalR in an ABP application with the ASP.NET Core MVC UI, first,
    add the `@abp/signalr` NPM package to your web project with the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command will install the package and update the `package.json` file in
    the web project. You should then run the ABP CLI's `install-libs` command to copy
    SignalR's JavaScript file under your project's `wwwroot/libs` folder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装包并更新 Web 项目的 `package.json` 文件。然后，你应该运行 ABP CLI 的 `install-libs` 命令，将
    SignalR 的 JavaScript 文件复制到你的项目 `wwwroot/libs` 文件夹下。
- en: 'After the installation, you can use SignalR in your pages by importing SignalR''s
    JavaScript file. You can use ABP''s `abp-script` tag helper with the pre-defined
    bundle contributor for SignalR, as in the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过导入 SignalR 的 JavaScript 文件在你的页面中使用 SignalR。你可以使用 ABP 的 `abp-script`
    标签助手与预定义的 SignalR 包贡献者一起使用，如下例所示：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using `SignalRBrowserScriptContributor` is the suggested approach since it always
    adds the script file from the right path with the right version, so you don't
    need to change it when you upgrade the SignalR package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SignalRBrowserScriptContributor` 是建议的方法，因为它总是从正确的路径添加正确的版本的脚本文件，所以当你升级 SignalR
    包时，你不需要更改它。
- en: 'Using SignalR with ABP Framework is no different from using it in a regular
    ASP.NET Core application. So, please refer to Microsoft''s documentation if you
    are new to SignalR: [https://docs.microsoft.com/en-us/aspnet/core/signalr](https://docs.microsoft.com/en-us/aspnet/core/signalr).
    You can also find a fully working example in ABP''s official samples: [https://docs.abp.io/en/abp/latest/Samples/Index](https://docs.abp.io/en/abp/latest/Samples/Index).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ABP 框架与 SignalR 没有区别于在常规 ASP.NET Core 应用程序中使用它。所以，如果你是 SignalR 的新手，请参阅 Microsoft
    的文档：[https://docs.microsoft.com/en-us/aspnet/core/signalr](https://docs.microsoft.com/en-us/aspnet/core/signalr)。你还可以在
    ABP 的官方示例中找到一个完全工作的示例：[https://docs.abp.io/en/abp/latest/Samples/Index](https://docs.abp.io/en/abp/latest/Samples/Index)。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've learned different methods for server-client communication
    with ABP Framework and ASP.NET Core. ABP Framework automates that communication
    wherever possible.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了使用 ABP 框架和 ASP.NET Core 的不同服务器-客户端通信方法。ABP 框架尽可能自动化这种通信。
- en: We started by creating REST-style HTTP APIs with the standard ASP.NET Core controllers
    and learned how ABP can automatically create such controllers using the application
    services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用标准的 ASP.NET Core 控制器创建了 REST 风格的 HTTP API，并学习了 ABP 如何使用应用程序服务自动创建这样的控制器。
- en: We then explored various ways of consuming the HTTP APIs from different clients.
    It becomes very simple to call server-side APIs from a client application when
    you use the dynamic or static client proxies of ABP Framework. While you can always
    go your own way, using the fully integrated client proxies is the best way to
    consume your own HTTP APIs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了从不同客户端消费 HTTP API 的各种方法。当你使用 ABP 框架的动态或静态客户端代理时，从客户端应用程序调用服务器端 API 变得非常简单。虽然你可以始终走自己的路，但使用完全集成的客户端代理是消费你自己的
    HTTP API 的最佳方式。
- en: Finally, we saw how we can install SignalR in your ABP applications using the
    pre-built integration packages. SignalR, with the WebSocket technology, makes
    it possible to establish a two-way communication channel between the server and
    the client, so the server can also send messages to the client whenever it needs
    to.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何使用预构建的集成包在你的 ABP 应用程序中安装 SignalR。SignalR，结合 WebSocket 技术，使得在服务器和客户端之间建立双向通信通道成为可能，因此服务器也可以在需要时向客户端发送消息。
- en: 'In the next chapter, we will learn about one of the most powerful structures
    of ABP Framework: modular application development.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 ABP 框架中最强大的结构之一：模块化应用程序开发。
