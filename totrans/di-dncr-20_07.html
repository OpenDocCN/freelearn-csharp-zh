<html><head></head><body>
        

                            
                    <h1 class="header-title">Interception</h1>
                
            
            
                
<p class="mce-root">We have already discussed two pillars of the DI ecosystem in the previous two chapters. Those pillars provided us with ways to identify dependencies, register them and then manage their lifetimes as required. In this chapter, we are going to cover something different which addresses the architectural problem of DI.</p>
<p class="mce-root">An application without security, logging, caching, transaction management, and so on seems very incomplete. When we write codes to cover up all these functionalities for the app, we might end up writing repetitive codes in each module all around the application. Even if Dependency Injection has an existence in our application, solving the purpose of managing the requirements of a class and trying to provide all the types needed for logging, or others as mentioned previously, violates SRP and DRY. Thus, we need a different approach to solve this problem and that is <strong>Interception</strong>. Simply put, Interception will help us dynamically inject blocks of code wherever required.</p>
<p>Now, you might have a question regarding when and how we can inject this code. Let's hold on to the <em>how</em> for now and focus on the <em>when</em>. We will discuss the <em>how</em> soon. To answer <em>when</em>, the injection can be done before or after, or it can even totally replace the actual method execution.</p>
<p>In this chapter, we will understand what Interception is and how it can be implemented. We will find out possible techniques to interrupt the flow of execution. Definitely, we will discuss why we even need <em>Interception</em>.</p>
<p>Patterns and principles of Interception in .NET Core is the next thing we are going to illustrate. We will even extend the concept of Interception in ASP.NET MVC Core using filters and middleware.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Cross-cutting concerns and aspects</li>
<li><strong>Aspect-oriented programming</strong> (<strong>AOP</strong>): Its types, advantages, disadvantages, and process</li>
<li>Demos of each type of AOP</li>
<li>Interception adoption in ASP.NET Core MVC using filters and middleware</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Interception</h1>
                
            
            
                
<p>In this section, I will introduce you to <em>Interception</em> along with the connection it has with the <em>Dependency Injection</em>.</p>
<p class="mce-root">Interception is another important pillar. Interception is the process through which we can easily intercept the call between a consumer and a service in order to execute certain codes before or after the service is invoked.</p>
<p>The following diagram shows what happens with and without the Interception process:</p>
<div><img height="156" width="212" src="img/280c7e04-d3e5-4578-b67b-515d13b3436c.png"/></div>
<p>If we consider the preceding request as a call that comes to the index action of a controller named <kbd>CompanyController</kbd> and before the company details are served to the client, we can run a few bookkeeping tasks such as <em>Who requested the company details?</em>, <em>When was the call </em><em>made?</em>, <em>I</em><em>s the user authorized</em> <em>to receive the company details?</em>, and so on. For all these tasks, we have to stop the flow in the controller to do all these operations, and after we are done, we can again resume the main task of returning data. But all these tasks can't be written inside the controller action, because the main responsibility of the action is to return the company details. If we write everything inside the action method, it would violate SRP.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The decorator</h1>
                
            
            
                
<p>Let's find out by a class that requires basic logging as a part of its operations. A <kbd>CompanyRepository</kbd> might have a method to assign a <kbd>User</kbd> to a <kbd>Company</kbd>.</p>
<pre>    public void AssignUserToCompany(int userId, int companyId)<br/>    {<br/>      // Database operation to assign User to Company.<br/>    }</pre>
<p>Now, a client asks you to log some important information while this operation takes place, just for bookkeeping and future reference. The information could be the start time of the operation, end time of the operation, who requested for the operation, exceptions if any, and so on. The instant solution that comes to your mind might look something like the following:</p>
<pre>    public void AssignUserToCompany(int userId, int companyId)<br/>    {<br/><strong>      _logger.Log("Assign to User started.");</strong><br/>      // Database operation to assign User to Company.<br/><strong>      _logger.Log("Assign to User ended.");</strong><br/>    }</pre>
<p>Notice the bold lines. <kbd>ILogger</kbd> can be injected to the repository through a constructor for log operations. We can also put <kbd>try...catch</kbd> block and log exceptions. Everything looks good, but don't you think the class is doing more than what it is intended for and that we are violating the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>). Therefore, let's think of another solution. How about the following?</p>
<pre>    public class <strong>LoggingCompanyRepository : CompanyRepository</strong><br/>    { <br/>      private readonly CompanyRepository _companyReposiory;<br/><strong>      private readonly ILogger _logger;</strong><br/>      public LoggingCompanyRepository(CompanyRepository <br/>         companyRepository, ILogger logger)<br/>      {<br/>        this._companyReposiory = companyRepository ??<br/>           throw new ArgumentNullException("companyRepository");<br/>        this._logger = logger ?? throw new <br/>           ArgumentNullException("logger");<br/>     }<br/>     public override void AssignUserToCompany(int userId,<br/>         int companyId)<br/>     {<br/><strong>        _logger.Log("Assign to User started.");</strong><br/>        _companyReposiory.AssignUserToCompany(userId, <br/>            companyId);<br/><strong>        _logger.Log("Assign to User ended.");</strong><br/>     }<br/>    }</pre>
<p>We introduced a decorated <kbd>CompanyRepository</kbd> named as <kbd>LoggingCompanyRepository</kbd>, which is managing the logging part. It is initialized by taking repository and logger dependencies and executing the method as needed with log entries. Following the Decorator Pattern, the new class tries to coordinate the work between the repository and logger.</p>
<p>The final task would be to compose the decorator, which has the following steps:</p>
<ol>
<li>We can create the instances of <kbd>SqlCompanyRepository</kbd> and <kbd>SqlLogger</kbd> which derive from related abstractions.</li>
<li>Then, we create the instance of the decorator by injecting these dependencies.</li>
<li>We return the <kbd>CompanyService</kbd> instance with the decorated repository.</li>
</ol>
<p>Refer to the following code for these steps:</p>
<pre>    public ICompanyService ResolveCompanyService()<br/>    {<br/>      CompanyRepository companyRepository = new <br/>          SqlCompanyRepository("ConnectionString");<br/>      Controllers.ILogger logger = new SqlLogger();<br/>      CompanyRepository loggingCompanyRepository = <strong>new <br/>          LoggingCompanyRepository(companyRepository, logger);</strong><br/>      return new CompanyService(loggingCompanyRepository);<br/>    }</pre>
<p>This is what Interception is all about. We are able to interrupt the call made to <kbd>AssignUserToCompany</kbd> of the concrete class <kbd>SqlCompanyRepository</kbd> because the <kbd>Service</kbd> is now composed of a decorator with the concrete class, instead of the direct code block. When you call the method, it would first go to the decorator's method and then call the concrete class method.</p>
<p>The following diagram explains the flow:</p>
<div><img height="171" width="393" src="img/216a1091-ff1a-4ed5-8bc4-65a81ac9da54.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Patterns and principles for Interception</h1>
                
            
            
                
<p>You must be getting a hint that I want you to taste the DI from the perspective of not only injecting dependencies, but also managing and maintaining code for a good architecture. We explored the Decorator Pattern in the last section, which enabled us to decorate the concrete implementation with a little additional code without even touching any classes in the application. This forms the basis of Interception.</p>
<p>With Interception, we clearly followed SOLID principles of Software Design. The moment we started designing the decorator class, that class played a vital role in the SRP. <kbd>CompanyRepository</kbd> is managing the database part and the <kbd>LoggingCompanyRepository</kbd> takes the responsibility for logging.</p>
<p>The <strong>Liskov Substitution Principle</strong> (<strong>LSP</strong>) demands that the consumer should not feel the change of any implementations of the dependency. We achieved this by the decorator implementing the same abstraction that the <kbd>Service</kbd> demanded, which is <kbd>CompanyRepository</kbd> so that we would be able to replace the original one <kbd>SqlCompanyRepository</kbd> with the decorator one <kbd>LoggingCompanyRepository</kbd>, without any breakage to the service codes.</p>
<p>As we were doing all the preceding steps, we did not change any class for implementing the decorator. Instead, we extended, which strongly followed the Open/Closed Principle. There is no such necessity to touch the <kbd>Service</kbd> class or the consumer.</p>
<p>The principles behind the Interception following SOLID gives us a hint as to how the Decorator Pattern is closely related to DI, since DI supports Interception. The Decorator Pattern is the fundamental building block of the concept, but the way we implemented it does not solve the architectural problems in hand. Let's analyze the associated benefits and problems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of the Decorator approach</h1>
                
            
            
                
<p>With the Decorator approach, we achieved many benefits. Refer to the following list:</p>
<ul>
<li>The <kbd>Service</kbd> does not know what repository it is receiving. Notice that <kbd>CompanyRepository</kbd> and <kbd>LoggingCompanyRespository</kbd> are both declared as <kbd>CompanyRepository</kbd> instances.</li>
<li>Just because the types are the same, there is no need to do any changes to the <kbd>Service</kbd> class. Moreover, we added logging behavior to the <kbd>CompanyRepository</kbd> class without even changing it. It supports the Open/Closed principle. All classes are intact.</li>
<li>We were able to intercept the concrete <kbd>SqlCompanyRepository</kbd> methods in order to have log entries. Thus, we did not violate the SRP of the repository.</li>
</ul>
<p>However, we did not realize a few problems with this approach. This structure would lead us to a bad architecture in the long run. Let's find out why.</p>
<p>Instead of dealing with the instances manually, always use DI Container to resolve the dependencies. We will see how we can work with DI Container for Interception in a while.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Problems of the Decorator approach</h1>
                
            
            
                
<p>In a typical project, we will have many of these repositories and services. We will definitely encounter the following problems:</p>
<ul>
<li>Imagine the number of lines of codes you would have to write to compose the decorators in order to do Interceptions for hundreds of classes</li>
<li>The next thing is very important, which is actually the basis of our topic in discussion. What if you have to log in a thousand methods of those hundred classes. This is common and we need it in almost every method. Think of the work involved and the size of your app.</li>
</ul>
<p>Due to all these, we will end up going for a different approach for intercepting calls to methods using Aspects. DI Containers make it easy for us to design aspects and attach Interceptors. Let's move on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aspect-oriented programming</h1>
                
            
            
                
<p><strong>Object-oriented programming</strong> (<strong>OOP</strong>) deals with techniques to solve real-world problems with underlying object models. To design a software, we need to adopt OOP along with good design methodologies in order to make it maintainable, consistent and reliable. There are many such patterns or problems we will encounter during the application development which are of design decisions, that can neither be solved by OOP practices nor with procedural approaches.</p>
<p>In this chapter, we will address one design decision that can be managed easily by Aspects. To clarify, we can consider a simple example which is very often seen in codes and that is <strong>logging</strong>. We do logging in almost every method. This means you are repeating codes everyday violating the <strong>DRY</strong> (<strong>Don't Repeat Yourself</strong>) principle.</p>
<p>The following diagram shows you the repeated codes of logging commonly found in your codes:</p>
<div><img height="189" width="352" src="img/3d5d05ef-62f3-4930-99ba-0d81f67aec70.png"/></div>
<p>If I tell you that we can package those logging lines into one modular piece of code and just ask all the methods that need logging, to just import that while running, what would be your reaction? Yes, that is what an aspect is all about. So, we can write an aspect to manage logging. The pattern we follow in order to implement an aspect in our app is known as <strong>Aspect-oriented programming</strong> (<strong>AOP</strong>)<em>.</em> It<em> </em>aims to separate or modularise these repeated codes from the core functionality.</p>
<p>The following is a sneak peak of the solution with an aspect called <kbd>LoggingAspect</kbd>, which packages all the logging codes inside it and is attached to the methods as an attribute above the method (written like <kbd>[LoggingAspect]</kbd>). Don't worry about the rules for how the logging lines are applied to the methods at the particular location such as <em>start</em> or <em>end</em> for now. We will learn all these soon, which are the concepts behind AOP:</p>
<div><img height="179" width="406" src="img/1715faca-ea25-4ace-bdbb-b785b0910fab.png"/></div>
<p>When we follow AOP in our application, we can easily attach these modules automatically to our methods. Thus, developers have all the freedom to only focus on the business logic or core concerns inside the methods, instead of worrying about all the repetitive code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-cutting concerns</h1>
                
            
            
                
<p>A <strong>concern</strong> can be defined as a part of a system providing some specific functionality. If you consider a typical example of saving a user in your system, it may have a business logic something like the following:</p>
<ol>
<li>Validate all fields of user for proper datatype, <kbd>null</kbd> values, and so on.</li>
<li>Check for the user existence in the system by a unique value such as <kbd>Email</kbd> or <kbd>UserName</kbd>.</li>
<li>If a user does not exist, create the user, otherwise update the user.</li>
</ol>
<p>All these steps are denoted as <strong>Business Logic</strong>, which might be different in different applications since it depends on your requirements and design. So, our <kbd>SaveUser</kbd> method's principal duty is to perform all these steps, which can be defined as a <strong>Main Concern</strong>.</p>
<p>However, in a typical application, these are not the only things that happen inside a <kbd>SaveUser</kbd> method. You might have to do the following during saving a user:</p>
<ol>
<li>Check whether the logged-in user is authorized to save the user.</li>
<li>Log in text/database that <kbd>SaveUser</kbd> started.</li>
<li>[Perform the <em>Business Logic</em> (all the steps previously defined) ] - Main Concern.</li>
<li>Log in text/database that the <kbd>SaveUser</kbd> method succeeded.</li>
</ol>
<p>Steps 1, 2, and 3 are the steps which are secondary and don't align with the Main Concern. But these steps can't be ignored. Moreover, these particular steps are performed in almost every method of the application.</p>
<p>While our method is trying to run the Main Concern, these guys try to interfere and cut the execution and do something else. That's why they are known as <strong>Cross-Cutting Concerns</strong>. These concerns are located throughout the application and affect the entire architecture. Have a look at the following diagram where the arrows indicate the Main Concern and the rectangular areas represent the Cross-Cutting Concerns:</p>
<div><img height="150" width="337" src="img/ae91997c-b0ae-47a3-b12b-9fee783f0f59.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Aspect</h1>
                
            
            
                
<p>In simple words, when we see some repetitive patterned codes throughout our app, that's the clue for us to consider them as Cross-Cutting Concerns. These are the code patches, which do not fit with the Main Concern inside the method in execution.</p>
<p>When I say <em>aspect</em> in the programming paradigm, it basically states the behavioral pattern independent of the actual task/concern at hand. So, when you package the Cross-Cutting Concerns into one modular piece that can be injected to the methods, you actually design an aspect.</p>
<p>For instance, we want to log at certain lines inside many methods:</p>
<pre>    public void SaveUser(User user)
    {
      Log.Debug("SaveUser started");   
      try
      {
        // Service call to save the user.
      }
      catch(Exception ex)
      {
        Log.Error(ex, "Exception in SaveUser Method");
        throw;
      }
      finally
      {
          Log.Debug("SaveUser Method completed.");
      }
    }</pre>
<p>Clearly, <kbd>Log</kbd> class methods help us to log debug steps and exceptions inside a method. This particular pattern can be seen often at many places in the app. That is what a Cross-Cutting Concern is. The actual task at hand for the <kbd>SaveUser</kbd> method is to update the user details such as <kbd>UserName</kbd>, <kbd>Email</kbd>, <kbd>Password</kbd>, and so on, but this method also takes the responsibility to log some lines into files, which violates the SRP. Also, when these kinds of patterns are repeated across the project, it does not follow the DRY principle.</p>
<p>Look at the following diagram, which depicts logging as a common paradigm across layers of the application:</p>
<div><img height="137" width="277" src="img/23be4d3a-508f-4637-b303-3d1741f67b18.png"/></div>
<p>So, here, AOP comes to our rescue which encapsulates this pattern to log the start, log the end, and log the exception, and then wrap it around the <kbd>SaveUser</kbd> method.</p>
<p>Another common scenario is wrapping our database operations with a <kbd>Transaction</kbd> block consisting of <kbd>Begin Transaction</kbd>, and <kbd>Commit/Rollback Transaction</kbd>. How about having someone else handling that part for us, while we concentrate on the core codes to operate on the database?</p>
<p>Cross-cutting concerns can be commonly found in the application where you log steps, handle exceptions, manage cache, access control, and so on. For example, while handling exceptions, you wrap your code using a <kbd>try..catch</kbd> block so that you are able to operate on that exception found (log to text file/database or send email to admin, and so on). This particular pattern is needed inside every method. Now we need to find out a way to ask (more specifically wrap) every method that we need for exception handling, instead of adding the <kbd>try..catch</kbd> lines inside it. Thus, that wrapped modular piece can be termed as an aspect, which eventually wraps all methods instructed to it to perform the exception handling, instead of the methods themselves doing the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aspect characteristics</h1>
                
            
            
                
<p>When we try to encapsulate these Cross-Cutting Concerns to create aspects, we actually make sure they follow some characteristics:</p>
<ul>
<li><strong>Wrapper:</strong> All these aspects will be a wrapper around some business functionalities.</li>
<li><strong>Single Responsibility Principle (SRP): </strong>The wrapper is concerned only about one particular task. For example, logging will only do the task of logging and nothing else.</li>
<li><strong>Decorator Pattern: </strong>The aspect then attached with the existing functions with the Decorator Pattern.
<ul>
<li><strong>Open Close Principle: </strong>When these repetitive codes were in business functions and we if needed any change in them in the future, then we would have to change the business function as it contains those pieces, which violates the Open Close Principle. Now, when we isolated those pieces to a module, the business functions became <em>Open</em> for extension, but <em>Close</em> to change.</li>
</ul>
</li>
</ul>
<p>Refer to the following diagram for a pictorial explanation:</p>
<div><img height="218" width="412" src="img/1b1bffb1-1fbd-416e-8c42-fd5c4b1815b5.png"/></div>
<p>AOP is not a competitor of OOP. Both are totally different. One is not a replacement for the other. With all these characteristics, AOP helps us to maintain a good structure for the project, hence resulting in a good OOP practice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages</h1>
                
            
            
                
<p>Let me summarise the important advantages of AOP:</p>
<ul>
<li><strong>Increases modularity:</strong> Common functionality is centralized into independent modules and is attached those modules or aspects at many places in the app. </li>
<li><strong>Manages Cross-Cutting Concerns:</strong> The concerns which are scattered comes to one place which can be managed easily without making any code change to the actual business codes.</li>
<li><strong>Better architecture: </strong>Separation of these concerns into singly responsible aspects helps us to architect and organise business needs without unnecessarily repeating ourselves in the codes.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Aspect attached locations</h1>
                
            
            
                
<p>There are basically three locations where an Aspect can be attached to a method:</p>
<ul>
<li><strong>On Start:</strong> When we want an aspect to execute immediately before the underlying function execution.</li>
<li><strong>On Error: </strong>Obviously, an aspect at this location will run only if an exception occurs in the method. </li>
<li><strong>On Success:</strong> Runs immediately after the method execution. However, it is limited to the functions which don't throw exceptions.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of AOP</h1>
                
            
            
                
<p>There are two techniques in AOP:</p>
<ul>
<li><strong>Interceptors:</strong> Dynamic, which attaches the interceptors during runtime</li>
<li><strong>IL Code Weaving:</strong> Static, which runs after compilation and inserts code into the assembly</li>
</ul>
<p>Static (post-compilation) ones include Fody, SheepAspect, Mono.Cecil, and PostSharp. Static might be faster, but we get more flexibility in a dynamic one, as we can change the code dynamically.</p>
<p>Applying the aspects to the code depends on the framework used. There are different techniques to attach the aspects such as writing attributes, XML configuration, and fluent interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Investigating Interception</h1>
                
            
            
                
<p>To intercept means to prevent something or someone from reaching an intended destination.</p>
<p>Interception (a programming paradigm), helps us to design aspects and inject cross-cutting concerns wherever demanded at the runtime. Using an Interceptor, we can easily intercept the calls to methods and properties in a class. To achieve this, we usually end up using an <strong>Inversion Of Control</strong> (<strong>IoC</strong>) container.</p>
<p>IoC provides the class functionality and then wraps it with our requested interceptor. Suppose somewhere in the code you ask for a class (say <kbd>Student</kbd>) to the IoC container of a specific type (say <kbd>IStudent</kbd>), which has an aspect for logging, then the IoC container would be able to provide the class (<kbd>Student</kbd>) with an interceptor decorated with it for the aspect demanded.</p>
<p>Interceptors are managed by external components that create dynamic decorators dealing with wrapping the aspects around your existing business components.</p>
<p>The main advantage of Interceptors is that they are not bound by the compilation process and don't modify our assemblies post-build. In other words, it's just the configurations for IoC containers, which you can easily take to another project instead of taking the DLLs and compiling them again.</p>
<p>However, Interceptors are configurable to work either at runtime or compile time.</p>
<p>Unity, Ninject, Spring.NET, Castle Windsor, LinFu, Autofac, LOOM.NET, Seasar, and so on are some IoC containers that allow injecting Interception at compile time or runtime.</p>
<p>These IoC containers use a Dynamic Proxy to create in-memory decorators that wrap your existing code. Those Dynamic Proxies are responsible for code execution. Thus, it allows execution of the wrapper aspect as well as the underlying code being wrapped.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Interception process</h1>
                
            
            
                
<p>The Interception process can be depicted as follows:</p>
<div><img height="243" width="274" src="img/8dfd86a3-37b0-4b8c-abab-fd43c45fcb5e.png"/></div>
<p>Here is what happens:</p>
<ol>
<li>The calling code asks IoC container about the type it is looking for. For example, the <kbd>IExampleInterface</kbd> type.</li>
<li>IoC container now tries to match the concrete implementation of the type requested, which it can return back to the calling code that is <kbd>Example</kbd> class. While it is doing this, it recognizes that the type is already configured to use an interceptor.</li>
<li>Instead of directly returning to the calling code, the IoC container now sends the Interceptor and the implementation class for the requested type to the Dynamic Proxy.</li>
<li>The Dynamic Proxy now takes the concrete class and wraps it with the interceptor. Then it generates a class implementing the type initially requested with an instance of the concrete class given by the IoC container and the interceptor. After that, it returns back that implementation of the requested type to the IoC container. That is the <kbd>Interceptor</kbd> class.</li>
<li>The IoC container now sends back the <kbd>Interceptor</kbd> class generated by Dynamic Proxy to the calling code.</li>
<li>Calling code executes the returned class which in turn runs the interceptor and the underlying code of the concrete class <kbd>Example</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Castle Windsor</h1>
                
            
            
                
<p>Castle Windsor is an Inversion of Control Container. This library is a part of the open source project known as the <strong>Castle Project</strong>. The Castle Project (<a href="http://www.castleproject.org/">http://www.castleproject.org/</a>) provides reusable libraries for many purposes. Castle has many components and Windsor is the DI CONTAINER component of the Castle Project. However, it can be used independently of other Castle components.</p>
<p>We have many other libraries available on the market such as Microsoft Unity, Autofac, Ninject, and so on. Each framework offers slightly different advantages and features. However, at the bottom, they implement the same for most of the core concepts, including Type Registration, Resolution, and Injection. You can, no doubt use any of these to apply Interception in your application.</p>
<p>There is no such logic as to why we are going to use Castle Windsor though. Using this tool, we can easily attach Interceptors to our codes. We will see that in a moment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Demonstration for using the Castle Windsor</h1>
                
            
            
                
<p>Let's start to implement one Interceptor using the <kbd>Nuget</kbd> package Castle Windsor. First of all, create a Console App, go to Nuget Package Manager and install the Castle Windsor package. After successful installation, your Project Reference will look like the following:</p>
<div><img height="421" width="275" src="img/bb4c6919-282d-4667-869f-45ff7e086a2f.png"/></div>
<p>So, it installs <kbd>Castle.Core</kbd> and <kbd>Castle.Windsor</kbd>. Now we are ready to create an Interceptor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Interceptor</h1>
                
            
            
                
<p>We will do a simple Logging Interceptor which will log steps as well as exceptions for us. Let's name that <kbd>LoggingInterceptor.cs</kbd>. To qualify as an Interceptor, the class should implement the <kbd>Interceptor</kbd> interface. The only method inside this interface is <kbd>Intercept</kbd> which takes <kbd>IInvocation</kbd> as an argument.</p>
<p>The following code block illustrates what I said:</p>
<pre>    using Castle.DynamicProxy;
    using System;
    namespace ConsolePacktApp
    {
      public class LoggingInterceptor : IInterceptor
      {
        public void Intercept(IInvocation invocation)
        {
          invocation.Proceed();
        }
      }
    }</pre>
<p>The call <kbd>invocation.Proceed()</kbd> just calls the underlying method which is supposed to be intercepted. That means, when any method which is registered to use this interceptor, it will come to this method, which in turn, calls the same method from here with the <kbd>Proceed()</kbd>.</p>
<p>To investigate the actual benefit of having an interceptor, we will add more codes here in the following block:</p>
<pre>    using Castle.DynamicProxy;
    using System;
    namespace ConsolePacktApp
    {
      public class LoggingInterceptor : IInterceptor
      {
        public void Intercept(IInvocation invocation)
        {
            try
            {
                Console.WriteLine("Log Interceptor Starts");
                invocation.Proceed();
                Console.WriteLine("Log Interceptor Success");
            }
            catch (Exception e)
            {
                Console.WriteLine("Log Interceptor Exception");
                throw;
            }
            finally
            {
                Console.WriteLine("Log Interceptor Exit");
            }
        }
      }
    }</pre>
<p>Next is to design an interface and a concrete class:</p>
<pre>    using System;<br/>    namespace ConsolePacktApp
    {
      public interface IExample
      {
        void PrintName(string FirstName, string LastName);
      }
    
      public class Example : IExample
      {
        public void PrintName(string FirstName, string LastName)
        {
            Console.WriteLine($"Name is {FirstName} {LastName}");
        }
      }
    }</pre>
<p>So, the <kbd>PrintName()</kbd> method prints the name using <kbd>FirstName</kbd> and <kbd>LastName</kbd>. We will intercept this method and try to add log steps using an interceptor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching an Interceptor</h1>
                
            
            
                
<p>The most important part now is <kbd>ExampleRegistration</kbd>, which implements the interface <kbd>IRegistration</kbd> of <kbd>Castle.MicroKernel.Registration</kbd> namespace.</p>
<p>This is the place where we register <kbd>LoggingInterceptor</kbd> (refer to the first comment in the following code block) and then declare that <kbd>Example</kbd>, class which will be intercepted by <kbd>LoggingInterceptor</kbd> (refer to the second comment):</p>
<pre>    using Castle.MicroKernel.Registration;
    using Castle.MicroKernel;
    using Castle.Core;
    namespace ConsolePacktApp
    {
      public class ExampleRegistration : <strong>IRegistration</strong>
      {
        public void Register(IKernelInternal kernel)
        {<br/>            <strong>// 1. Interceptor Registration</strong>
            <strong>kernel.Register(
                Component.For&lt;LoggingInterceptor&gt;()
                    .ImplementedBy&lt;LoggingInterceptor&gt;());</strong>
<br/>            <strong>// 2. Interceptor attached with Example Class.</strong>
            <strong>kernel.Register(
                Component.For&lt;IExample&gt;()
                .ImplementedBy&lt;Example&gt;()
                .Interceptors(InterceptorReference.ForType&lt;LoggingInterceptor&gt;<br/>                   ()).Anywhere);</strong>
        }
      }
    }</pre>
<p>Last but not the least, the <kbd>main</kbd> method:</p>
<pre>    using Castle.Windsor;
    using System;
    namespace ConsolePacktApp
    {
      class Program
      {
        private static IWindsorContainer _container;
        static void Main(string[] args)
        {
            _container = new WindsorContainer();
            _container.Register(new ExampleRegistration());

            var example = _container.Resolve&lt;IExample&gt;();

            try
            {
                example.PrintName("Gobinda", "Dash");   
            }
            catch (Exception ex)
            {
            }

            Console.ReadKey();
        }
      }
    }</pre>
<p>We take an <kbd>IWindsorContainer</kbd> instance. First, we register our <kbd>ExampleRegistration</kbd> class which contains our target method and interceptor configurations. Then, <kbd>_container.Resolve()</kbd> helps us to get the required instance implementing <kbd>IExample</kbd>.</p>
<p>As we have already defined that <kbd>Example</kbd> is the class implementing <kbd>IExample</kbd> in the <kbd>Register()</kbd> method of the <kbd>ExampleRegistration</kbd> class, one instance of <kbd>Example</kbd> class is created. Then, we have a <kbd>PrintName()</kbd> call inside the <kbd>try</kbd> block.</p>
<p>Time to run the app and see the output:</p>
<div><img height="100" width="303" src="img/6d2113fb-eda5-4e43-ac81-c3c26325555b.png"/></div>
<p>Clearly, before printing the name, the first thing that executes is the log Starts message. Secondly, the actual method execution which prints the name. After that, as we expected, the Success and Exit messages. Exit means it exited from the interceptor.</p>
<p>Obviously, we did not get any exception, so that message got skipped.</p>
<p>Now, let's try to see that. The modified <kbd>Example</kbd> class will be like the following with a <kbd>throw new Exception()</kbd> code line:</p>
<pre>    using System;
    namespace ConsolePacktApp
    {
      public class Example : IExample
      {
        public void PrintName(string FirstName, string LastName)
        {
            <strong>throw new Exception();</strong>
            Console.WriteLine($"Name is {FirstName} {LastName}");
        }
      }
    }</pre>
<p>Forcefully, we are throwing one exception before the <kbd>Console.WriteLine</kbd>. We will see the following output when we run this:</p>
<div><img height="85" width="279" src="img/5317171d-e369-4988-a854-624bf766e51a.png"/></div>
<p>Interestingly, we don't see the Success log message, but the Exit message is printed and the actual execution of the method which was printing the name did not happen either. That is because the Exit message will definitely get printed no matter what happens to the calling code as that is inside the <kbd>finally</kbd> block of the interceptor.</p>
<p>We manually threw an exception before the actual code execution to print the name, which resulted in printing the exception log message along with Start and Exit.</p>
<div><p>Multiple Interceptors can be attached to a single class. There are two types of interceptor registrations, coded as follows. You can use either the following:</p>
<kbd>     kernel.Register(<br/>
       Component.For()<br/>
      .ImplementedBy()<br/>
      .Interceptors&lt;LoggingInterceptor,<br/>
          AnotherInterceptor&gt;());</kbd>
<p>Or you can use this one:</p>
<kbd>    kernel.Register(<br/>
     Component.For&lt;IExample&gt;()<br/>
     .ImplementedBy&lt;Example&gt;()<br/>
     .Interceptors(new InterceptorReference[] {<br/>
     InterceptorReference.ForType&lt;LoggingInterceptor&gt;(),<br/>
     InterceptorReference.ForType&lt;AnotherInterceptor&gt;() }).Anywhere);</kbd></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Intermediate Language (IL) Weaving</h1>
                
            
            
                
<p>In this type of AOP, the aspects are attached to the underlying code after the application has been compiled. This post-compilation process alters the assemblies at the IL level so that the aspect hook points are called where they are configured.</p>
<p>If I explain in simple words, it is a process by which the aspect codes are interjected into the original code after compilation, but that happens only to the IL code (original source code remains intact) and packaged into the assemblies. Your original code will be intact. However, along with your code, the aspect blocks will be included and the assembly gets the modified code. Unlike Interception, where the codes are interjected at the runtime, this process is static and codes are included beforehand.</p>
<p>The most widely used tool for weaving is PostSharp, which we will demo in a while. Others include LOOM.NET, Fody, SheepAspect, Mono.Cecil, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">IL Weaving process</h1>
                
            
            
                
<p>Since I explained the process, let's see that in action in the following diagram:</p>
<div><img height="320" width="292" src="img/3600f40b-ce25-455e-9e7a-3c1e55138211.png"/></div>
<p>Simple, isn't it! Now that we understand how the process goes along, it's time to get our hands dirty on some real code and try it out.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an aspect</h1>
                
            
            
                
<p>Before starting up, we need to add the <kbd>Nuget</kbd> package named as PostSharp to the project.</p>
<p>To create an aspect, we need to design the class which would inherit from the <kbd>OnMethodBoundaryAspect</kbd> aspect class, which is an abstract class inside the <kbd>PostSharp.Aspects</kbd> namespace. This can be seen in the following code block:</p>
<pre>    using PostSharp.Aspects;
    using System;
    namespace ConsolePacktApp
    {
      [Serializable]
      class LoggingWeaverAspect : OnMethodBoundaryAspect
      {
        public override void OnEntry(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnEntry");
        }

        public override void OnExit(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnExit");
        }

        public override void OnException(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnException");
        }

        public override void OnSuccess(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnSuccess");
        }
      }
    }</pre>
<p><kbd>OnMethodBoundaryAspect</kbd> helps to write code which can execute before or after a method execution or in the case of an exception. As you can see from the previous class, we are overriding the <kbd>OnEntry</kbd>, <kbd>OnExit</kbd>, <kbd>OnException</kbd> and <kbd>OnSucess</kbd> methods. There are other aspect classes which can solve the different purposes.</p>
<p>Update the <kbd>main</kbd> method as follows:</p>
<pre>    static void Main(string[] args)
    {
      try
      {
        Example example = new Example();
        example.PrintName("Gobinda", "Dash");
      }
      catch
      {
      }
      Console.ReadKey();
    }</pre>
<p>Now, when you run the app, nothing happens. We get a confirmation if we can see the generated assembly codes.</p>
<div><p>ILSpy is the open-source .NET assembly browser and decompiler. You can download it from <a href="http://ilspy.net/">http://ilspy.net/</a>. This will help us see the actual codes packaged inside the assemblies.</p>
</div>
<p>When you run the ILSpy application and then select the assembly of our app, it will look something like the following:</p>
<div><img src="img/c9afb9af-a342-460e-a017-2037ad8ce301.png"/></div>
<p>You can see the <kbd>Example</kbd> class has code intact. No other code got inserted into the assembly. That's because we have not yet attached the Weaver with our <kbd>Example</kbd> class. Let's do that next.</p>
<div><p>If you encounter a PostSharp license error while building the app, that means you have to purchase one license. You can also use the free license, which has certain limitations. You can find the download page at <a href="https://www.postsharp.net/essentials">https://www.postsharp.net/essentials</a>.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching the aspect</h1>
                
            
            
                
<p>Attaching the aspect is very easy. You can simply add the weaver as an attribute to the classes you want to wrap the aspect to.</p>
<p>Notice the bold line above the <kbd>PrintName</kbd> method in the following code snippet:</p>
<pre>    using System;
    namespace ConsolePacktApp
    {
      public class Example : IExample
      {
        <strong>[LoggingWeaverAspect]</strong>
        public void PrintName(string FirstName, string LastName)
        {
            Console.WriteLine($"Name is {FirstName} {LastName}");
        }
      }
    }</pre>
<p>We attributed the <kbd>[LoggingWeaverAspect]</kbd> around the <kbd>Example</kbd> class. Now, let's run it and see the output:</p>
<div><img height="133" width="305" src="img/14e6bbc1-bd8f-4254-baa1-d27cc33bd5ff.png"/></div>
<p>Have a look at the assembly code as follows:</p>
<div><img src="img/02849973-1275-4e45-9366-8391ef64d4da.png"/></div>
<p>The red boxes here indicate the code which was inserted into the assembly after you built the application. Since we had one <kbd>OnException</kbd> in the weaver aspect, the <kbd>PrintName()</kbd> method now contains a <kbd>try...catch</kbd> block. Finally, <kbd>OnEntry</kbd> is at the beginning and <kbd>OnExit</kbd> is inside. After the <kbd>Console.Writeline()</kbd>, we can see the <kbd>OnSuccess</kbd> call. </p>
<p>If we get an exception before the actual execution of the method (before <kbd>Console.WriteLine()</kbd> in this case), we will see the following output without the success message:</p>
<div><img height="131" width="286" src="img/e1e66995-aca1-4118-b724-0d483ae8322e.png"/></div>
<p>Now that we've had a sneak peek at the concepts, let's explore how Interception is implemented in .NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interception in ASP.NET Core</h1>
                
            
            
                
<p>ASP.NET Core implements the concept of Interception to interrupt the calls to controller actions and request-response pipeline. We can do this by different techniques known as filters and middleware. We will discuss each one with examples next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Filters</h1>
                
            
            
                
<p>Filters allow ASP.NET Core to intercept action methods. You can configure one global filter which would run every time one controller action is requested, or have individual unique filters for some action methods.</p>
<p>The filters would implement one of the filter interface residing in the <kbd>Microsoft.AspNet.Mvc.Filters</kbd> namespace. Let's see a simple filter skeleton as follows:</p>
<pre>    using Microsoft.AspNetCore.Mvc.Filters;<br/>    namespace FiltersAndMiddlewares.Filters<br/>    {<br/>      public class SomeFilter : IActionFilter<br/>      {<br/>        public void OnActionExecuted(ActionExecutedContext context)<br/>        {<br/>          // Do something.<br/>        }<br/><br/>        public void OnActionExecuting(ActionExecutingContext context)<br/>        {<br/>          // Do something.<br/>        }<br/>      }<br/>    }</pre>
<p>As you can see in the preceding example, <kbd>SomeFilter</kbd> implements <kbd>IActionFilter</kbd>.  <kbd>OnActionExecuting</kbd> and  <kbd>OnActionExecuted</kbd>, as the names suggest, would run when an action is being executed and completes execution respectively.</p>
<p>If you recall the principle of Interception (which says that the <em>process by which we can run some code before or after the method which is being executed or totally replace that</em>), you will notice that these <kbd>IActionFilter</kbd> methods also follow the principle and are intended to intercept the calls to a controller action method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Global filter</h1>
                
            
            
                
<p>Suppose you want to create an interceptor which would intercept all the action methods. Sounds like a common or globally declared code block that can be termed as a <strong>Global filter</strong>. Registering a filter to the MVC filters using the service collection inside <kbd>ConfigureServices</kbd> would make a filter globally executable or interceptable.</p>
<p>Refer to the following code, which is the only line to convert a normal filter to a Global filter except the definition of the filter, which of course you need to code:</p>
<pre>    services.AddMvc(mvc =&gt; mvc.Filters.AddService(<br/>        typeof(SomeGlobalFilter)));</pre>
<p><kbd>SomeGlobalFilter</kbd> can also be injected with dependencies. The following code block can be considered as a Global filter, where <kbd>ISomeService</kbd> is injected using the most popular Constructor Injection Pattern:</p>
<pre>    using FiltersAndMiddlewares.Interfaces;<br/>    using Microsoft.AspNetCore.Mvc.Filters;<br/>    namespace FiltersAndMiddlewares.Filters<br/>    {<br/>      public class SomeGlobalFilter : IActionFilter<br/>      {<br/><strong>        public SomeGlobalFilter(ISomeService service)</strong><br/><strong>        {</strong><br/><strong>            // Do something with the service.</strong><br/><strong>        }</strong><br/><br/>        public void OnActionExecuted(ActionExecutedContext context)<br/>        {<br/>            // Do something.<br/>        }<br/><br/>        public void OnActionExecuting(ActionExecutingContext context)<br/>        {<br/>            // Do something.<br/>        }<br/>      }<br/>    }</pre>
<p>Did you notice one thing? The parameterized constructor in <kbd>SomeGlobalFilter</kbd> is injected with the dependency of type <kbd>ISomeService</kbd>. Not optional though, but it can be done if we need any of the required dependency in filters. Imagine, if we need to add a log entry in the database whenever an action starts execution, something like a bookkeeping of what events occur in what sequence. To achieve this, we can inject a service and then use its methods to operate on the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attributes</h1>
                
            
            
                
<p>Another way to attach filters is to write attributes for required actions. When you do global, it applies to all the actions. However, if we want to attach to certain actions only, then we can write attributes. Let's take a look at an action method which is attributed with <kbd>SomeFilter</kbd>:</p>
<div><img height="154" width="493" src="img/e7f41471-53db-4914-bf27-962f70922f23.png"/></div>
<p>The compiler is complaining. If you hover, it will say SomeFilter is not an attribute class. It actually expects the <kbd>SomeFilter</kbd> like as follows:</p>
<pre>    public class SomeFilterAttribute : <strong>Attribute</strong> {}</pre>
<p>Notice the name of the filter which was changed to <kbd>SomeFilterAttribute</kbd> and derived from <kbd>Attribute</kbd> abstract class. This is by syntax. Also, attributes require parameterless constructors. But to intercept, we need to implement some filter interface like <kbd>IActionFilter</kbd>. </p>
<p>To overcome this, we can take the help of the  <kbd>TypeFilterAttribute</kbd> class which derives from the <kbd>Attribute</kbd> class and takes a type through its constructor. Thus, the following code shows the correct pattern to use a filter as an attribute:</p>
<pre><strong>    [TypeFilter(typeof (SomeFilter))]</strong><br/>    public IActionResult About()<br/>    {<br/>      ViewData["Message"] = "Your application description page.";<br/>      return View();<br/>    }</pre>
<p>A couple of important things to note here are as follows:</p>
<ul>
<li>We have not registered <kbd>SomeFilter</kbd> in the entry point of the app; still, it works</li>
<li>The <kbd>TypeFilter</kbd> attribute helps to create an instance of <kbd>SomeFilter</kbd></li>
</ul>
<p>As we are playing with .NET Core, we should get the filter instance from the service registrations, instead of creating it dynamically through <kbd>TypeFilter</kbd>. That is where the <kbd>ServiceFilterAttribute</kbd> class comes onto the scene. Let's see how we can modify the code to use <kbd>ServiceFilter</kbd>:</p>
<pre><strong>    [ServiceFilter(typeof (SomeFilter))]</strong><br/>    public IActionResult About()<br/>    {<br/>      ViewData["Message"] = "Your application description page.";<br/>      return View();<br/>    }</pre>
<p>Are you sure this change will work? No, it won't. When you run the app, you will see the error captured as follows:</p>
<div><img height="62" width="740" src="img/c9824fd1-d0dc-45fd-8f93-65851f826231.png"/></div>
<p>Ah, I know! Now you got what we missed. This is a very familiar exception when you are working with DI. As I said, <kbd>ServiceFilter</kbd> finds the filter instance from the service collection; if you don't register it, it will definitely throw an exception.</p>
<p>The following code is what you need to make it work. It is not mandatory to make it transient though, it depends on your scenario:</p>
<pre>    services.AddTransient&lt;SomeFilter&gt;();</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Middleware</h1>
                
            
            
                
<p>Middleware, what it is known for, intercepts the pipeline of execution, and the developer can do anything before the response is served to the client. We will see how exactly we can implement Middlewares to intercept in the next section.</p>
<p>Middleware in ASP.NET core follows the Interception technique to interject aspects between request and response. It's basically some block of code which is registered with the application pipeline. The following diagram shows how Request goes through Middlewares one by one before Response comes out:</p>
<div><img height="333" width="461" src="img/933025b8-e773-4af0-9cbf-f34f38b955cb.png"/></div>
<p>A large amount of Middleware can be inserted into the pipeline. Each Middleware decides whether to pass the execution to the next one and can perform some logic before and after the invocation of the next component. These components are designed to solve specific purposes like logging, exception handling, authorizing, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registration</h1>
                
            
            
                
<p>The <kbd>IApplicationBuilder</kbd> interface helps us register the Middleware using the <kbd>app.Use</kbd> inside the <kbd>Configure()</kbd>. Let's check a simple code block:</p>
<pre>    public void Configure(IApplicationBuilder app)
    {
      var response = string.Empty;
      app.Use(async (context, next) =&gt;
      {
        response += "Inside Middleware 1\n";
        await next.Invoke();
      });
       app.Use(async (context, next) =&gt;
       {
        response += "Inside Middleware 2\n";
        await next.Invoke();
       });
       app.Run(async context =&gt;
       {
         response += "App run\n";
         await context.Response.WriteAsync(response);
       });
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Execution</h1>
                
            
            
                
<p>We have two Middlewares and then <kbd>app.Run</kbd>. When we run this, we will see the following one:</p>
<div><img height="191" width="438" src="img/b6ccb1b3-9b7d-4664-9e8d-964b2ce97a62.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">There is a catch here. If you refresh the page, without building the code, the following is what you see next:</p>
<div><img height="187" width="412" src="img/ce483d01-0a7a-4828-a190-ce4deb8b1637.png"/></div>
<p>The reason is I have concatenated the string and when you refresh the page, it directly comes to the Middleware 1 followed by Middleware 2 and then <kbd>app.Run</kbd>. As the variable got initialised inside the <kbd>Configure</kbd>, it has an application scope. It will be appended henceforth. If you refresh the page again, you will see another set of the same messages getting appended to what you see in the preceding screenshot.</p>
<p>This is the way Middlewares hijack the application pipeline and execute before the response is delivered to the client. Let's consider another code block:</p>
<pre>    public void Configure(IApplicationBuilder app, IHostingEnvironment env, <br/>       ILoggerFactory loggerFactory)
    {
     var response = string.Empty;
     app.Use(async (context, next) =&gt;
     {
        response += "Inside Middleware 1\n";
        await next.Invoke();
     });
     app.Run(async context =&gt;
     {
        response += "App run\n";
        await context.Response.WriteAsync(response);
     });
     app.Use(async (context, next) =&gt;
     {
        response += "Inside Middleware 2\n";
        await next.Invoke();
     });
    }</pre>
<p class="mce-root">What do you think the output will be? Check it out:</p>
<div><img height="201" width="445" src="img/276333d2-1a54-42ed-89b6-7feaf2824c53.png"/></div>
<p>Middleware 2 got missed. That is because we wrote <kbd>app.Run</kbd> before Middleware 2. <kbd>app.Run</kbd> is the exit point which terminates the pipeline. Anything after that won't be considered by the runtime.</p>
<div><p>You can, definitely, code before and after invoke is called, as follows:</p>
<kbd>   app.Use(async (context, next) =&gt;<br/>
    {<br/>
    // Do something before the next middleware is<br/>
        invoked.<br/>
         await next.Invoke();<br/>
    // Do something after next middleware invocation.<br/>
   });</kbd></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Ordering</h1>
                
            
            
                
<p>There is a simple rule that the order in which they are registered is the order in which they will be executed. The ordering plays an important role while one component depends on another. The exception is something which may occur anytime, anywhere, within the app. So, we need to register it first before everything else, so that we can easily capture the exceptions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We explored what aspects are and how to determine Cross-Cutting Concerns in a typical programming scenario. There are specific locations where aspects can be tagged, which we illustrated next.</p>
<p>Aspect-oriented programming helps us to run custom logic before, after, or even replacing the method completely, where it is registered. We saw static as well as dynamic techniques to attach aspects with IL Weaving and Interceptors respectively. Interception is the technique which is more preferred over IL Weaving as it dynamically runs the registered block of code (otherwise called an aspect). On the other hand, IL Weaving deals with assembly update after the build process is over to insert aspect codes into the methods registered.</p>
<p>We then got into a thorough discussion on how Interception is adopted in ASP.NET Core in the form of filters and Middlewares.</p>
<p>Filters can intercept the path of action method execution, which can be either be attributed to the method as required, or can be registered with service collection to label it as a Global filter.  One line of registration of a filter can make the filter intercept all action methods easily.</p>
<p>Middleware is a technique in ASP.NET Core which allows us to insert built-in/custom code chunks into the request-response pipeline.</p>
<p>Now that we have learned all the fundamental concepts of DI, in <a href="795befd2-857f-40d2-ba05-cb2921168bcc.xhtml" target="_blank">Chapter 8</a>, <em>Patterns - Dependency Injection</em>, we are going to discover different techniques/patterns to inject dependencies into the clients.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>