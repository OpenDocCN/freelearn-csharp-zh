- en: '*Chapter 12*: Unit Testing Async, Concurrent, and Parallel Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 12 章*：单元测试异步、并发和平行代码'
- en: Unit testing asynchronous, concurrent, and parallel code can be a challenge
    for .NET developers. Fortunately, there are some steps you can take to help ease
    the difficulty. This chapter will provide some concrete advice and useful examples
    of how developers can unit test code that leverages multi-threaded constructs.
    These examples will illustrate how unit tests can still be reliable while covering
    code that performs multithreaded operations. In addition, we will explore a third-party
    tool that facilitates the creation of automated unit tests that monitor your code
    for potential memory leaks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 .NET 开发者来说，单元测试异步、并发和平行代码可能是一个挑战。幸运的是，您可以采取一些步骤来帮助减轻难度。本章将提供一些具体的建议和有用的示例，说明开发者如何对利用多线程结构的代码进行单元测试。这些示例将说明，即使在执行多线程操作时，单元测试仍然可以保持可靠性。此外，我们还将探讨一个第三方工具，该工具有助于创建自动化的单元测试，以监控您的代码中可能存在的内存泄漏。
- en: Creating unit tests for your .NET projects is important to maintain the health
    of your code base as it grows and evolves. When developers make changes to code
    that has unit test coverage, they can run the existing tests to feel confident
    that no existing functionality has been broken by the code changes. Visual Studio
    makes it simple to create, run, and maintain unit test projects throughout the
    life cycle of your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的 .NET 项目创建单元测试对于维护代码库的健康成长和演变至关重要。当开发人员对具有单元测试覆盖的代码进行更改时，他们可以运行现有测试，以确信没有现有功能因代码更改而被破坏。Visual
    Studio 使您在整个代码生命周期中创建、运行和维护单元测试项目变得简单。
- en: The **Test Explorer** window in Visual Studio can detect and run unit tests
    created with Microsoft’s MSTest framework, as well as third-party frameworks such
    as NUnit and xUnit.net. Whether you are developing applications for Windows, mobile
    devices, or the cloud, you should always plan to develop a suite of unit tests
    for your projects and define goals for test coverage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中的 **测试资源管理器** 窗口可以检测并运行使用微软的 MSTest 框架创建的单元测试，以及 NUnit 和 xUnit.net
    等第三方框架。无论您是开发 Windows 应用程序、移动设备还是云应用程序，您都应该始终计划为您的项目开发一系列单元测试，并定义测试覆盖率的目标。
- en: Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter assumes that you have some familiarity with unit testing and good
    unit testing practices. For a good primer on unit testing projects with xUnit.net,
    you can review Microsoft’s documentation at [https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test](https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test)
    and at [https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing](https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对单元测试和良好的单元测试实践有所了解。如果您想了解使用 xUnit.net 进行单元测试项目的良好入门指南，可以查看微软的文档，网址为 [https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test](https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test)
    和 [https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing](https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing)。
- en: 'In this chapter, we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Unit testing asynchronous code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试异步代码
- en: Unit testing concurrent code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试并发代码
- en: Unit testing parallel code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试并行代码
- en: Checking for memory leaks with unit tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单元测试检查内存泄漏
- en: By the end of this chapter, you will be armed with tools and advice to help
    you confidently write modern multithreaded code with unit test coverage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有工具和建议，帮助您自信地编写具有单元测试覆盖的现代多线程代码。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The unit tests in this chapter are created with the **xUnit.net** unit testing
    framework. You can achieve the same results with your unit testing framework of
    choice, including **MSTest** and **NUnit**. The memory unit testing framework
    we will be demonstrating later in this chapter uses xUnit.net, but it also supports
    MSTest and NUnit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的单元测试是使用 **xUnit.net** 单元测试框架创建的。您可以使用您选择的任何单元测试框架实现相同的结果，包括 **MSTest** 和
    **NUnit**。我们将在本章后面展示的内存单元测试框架使用 xUnit.net，但也支持 MSTest 和 NUnit。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例，以下软件被推荐给 Windows 开发者：
- en: Visual Studio 2022 version 17.2 or later
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.2 或更高版本
- en: .NET 6
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6
- en: A JetBrains dotMemory Unit standalone console runner
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 JetBrains dotMemory Unit 独立控制台运行器
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12)。
- en: Let’s get started by examining how to write unit tests that cover `async` C#
    methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何编写覆盖`async` C#方法的单元测试。
- en: Unit testing asynchronous code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试异步代码
- en: Unit testing asynchronous code requires the same approach as writing good asynchronous
    C# code. If you need a refresher on how to work with `async` methods, you can
    review [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试异步代码需要与编写良好的异步C#代码相同的方法。如果你需要关于如何使用`async`方法的复习，你可以查看[*第5章*](B18552_05_ePub.xhtml#_idTextAnchor082)。
- en: 'When writing a unit test for an `async` method, you will use the `await` keyword
    to wait for the method to complete. This requires that your unit test method is
    `async` and returns `Task`. Just like other C# code, creating `async void` methods
    is not permitted. Let’s look at a very simple test method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个针对`async`方法的单元测试时，你将使用`await`关键字来等待方法完成。这要求你的单元测试方法是`async`并返回`Task`。就像其他C#代码一样，不允许创建`async
    void`方法。让我们看看一个非常简单的测试方法：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This probably looks like most tests you have written for synchronous code.
    There are only a couple of differences:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像你为同步代码编写的多数测试。只有几个不同之处：
- en: First, the test method is `async` and returns `Task`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，测试方法是`async`并返回`Task`。
- en: Second, the call to `GetBookAsync` uses the `await` keyword to wait for the
    result. Otherwise, this test follows the typical **Arrange–Act–Assert** pattern
    and tests the result as you typically would.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，调用`GetBookAsync`时使用了`await`关键字来等待结果。否则，这个测试遵循典型的**安排-行动-断言**模式，并像通常那样测试结果。
- en: 'Let’s create a simple project to try this in Visual Studio and see the results:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Visual Studio中创建一个简单的项目来尝试这个，并查看结果：
- en: 'Start by creating a new `AsyncUnitTesting`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个新的`AsyncUnitTesting`：
- en: '![Figure 12.1 – Creating a new Class Library project ](img/Figure_12.1_B18552.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 创建一个新的类库项目](img/Figure_12.1_B18552.jpg)'
- en: Figure 12.1 – Creating a new Class Library project
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 创建一个新的类库项目
- en: 'Next, we are going to add a test project to the `AsyncUnitTesting.Tests`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向`AsyncUnitTesting.Tests`添加一个测试项目：
- en: '![Figure 12.2 – Adding an xUnit Test project to the solution ](img/Figure_12.2_B18552.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 将xUnit测试项目添加到解决方案中](img/Figure_12.2_B18552.jpg)'
- en: Figure 12.2 – Adding an xUnit Test project to the solution
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 将xUnit测试项目添加到解决方案中
- en: In the `BookOrderService.cs`. When Visual Studio asks whether you want to rename
    all uses of `Class1`, select **Yes**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BookOrderService.cs`中。当Visual Studio询问你是否想要重命名所有对`Class1`的使用时，选择**是**。
- en: 'Open the `BookOrderService` class and add an `async` method named `GetCustomerOrdersAsync`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BookOrderService`类，并添加一个名为`GetCustomerOrdersAsync`的`async`方法：
- en: '[PRE12]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method takes `customerId` as a parameter and returns `List<string>` containing
    the order numbers. If `customerId` provided is less than `1`, `ArgumentException`
    is thrown. Otherwise, a list of six order numbers is created, with `customerId`
    as the prefix. After injecting `Task.Delay` of `1500` milliseconds, `orders` is
    returned to the calling method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受`customerId`作为参数，并返回包含订单号的`List<string>`。如果提供的`customerId`小于`1`，则抛出`ArgumentException`。否则，创建一个包含六个订单号且以`customerId`为前缀的列表。在注入`Task.Delay`为`1500`毫秒后，将`orders`返回给调用方法。
- en: Next, right-click the **AsyncUnitTesting.Tests** project and click on **Add**
    | **Project Reference**. In the **Reference Manager** dialog, check the box for
    the **AsyncUnitTesting** project and click **OK**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击**AsyncUnitTesting.Tests**项目，然后点击**添加** | **项目引用**。在**引用管理器**对话框中，勾选**AsyncUnitTesting**项目的复选框，然后点击**确定**。
- en: Now, rename the `UnitTest1` class `BookOrderServiceTests` and open the file
    in the Visual Studio editor.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`UnitTest1`类重命名为`BookOrderServiceTests`，并在Visual Studio编辑器中打开该文件。
- en: 'It’s time to start adding tests. Let’s start by testing the happy path. Add
    a test method named `GetCustomerOrdersAsync_Returns_Orders_For_Valid_CustomerId`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候开始添加测试了。让我们先测试一下快乐路径。添加一个名为`GetCustomerOrdersAsync_Returns_Orders_For_Valid_CustomerId`的测试方法：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After calling `GetCustomerOrdersAsync` with `customerId` of `3`, our code has
    three assertions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`customerId`为`3`调用`GetCustomerOrdersAsync`之后，我们的代码有三个断言：
- en: First, we’re checking that the list of orders is not `null`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们检查订单列表不是`null`。
- en: Second, we’re checking that the list contains some items.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们检查列表中包含一些项目。
- en: Finally, we check that the first order starts with `customerId`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们检查第一个订单以`customerId`开头。
- en: Click on **Test** | **Run All Tests** to ensure that this test passes.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试** | **运行所有测试**以确保这个测试通过。
- en: 'Let’s write that same test with a new `customerId` but without `async` and
    `await`. Assume that you have some legacy test code that just cannot be refactored,
    and you have to test the `GetCustomerOrdersAsync` method. That code would look
    like this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一个新的`customerId`编写相同的测试，但不使用`async`和`await`。假设你有一些无法重构的遗留测试代码，你必须测试`GetCustomerOrdersAsync`方法。这段代码看起来是这样的：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The test method is not `async` and returns `void`. Instead of using `await`
    to allow `GetCustomerOrdersAsync` to run to completion, we are calling `GetAwaiter().GetResult()`.
    The setup and assertion sections of the code remain the same.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法不是`async`并返回`void`。我们不是使用`await`来允许`GetCustomerOrdersAsync`运行到完成，而是调用`GetAwaiter().GetResult()`。代码的设置和断言部分保持不变。
- en: Click on **Test** | **Run All Tests** to make sure both of our tests are *green*
    (passing).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**测试** | **运行所有测试**以确保我们的两个测试都是*绿色*（通过）。
- en: 'Finally, we are going to test the exception case. Create another test but pass
    a negative `customerId` to the method under test. The entire call to `GetCustomerOrdersAsync`
    will be wrapped in an `Assert.ThrowsAsync<ArgumentException>` invocation:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将测试异常情况。创建另一个测试，但向被测试的方法传递一个负的`customerId`。对`GetCustomerOrdersAsync`的整个调用将包裹在`Assert.ThrowsAsync<ArgumentException>`调用中：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Execute **Run All Tests** one last time and ensure that they are all passing:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后再执行一次**运行所有测试**并确保它们都通过：
- en: '![Figure 12.3 – Viewing three passing tests in Test Explorer ](img/Figure_12.3_B18552.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 在测试资源管理器中查看三个通过测试](img/Figure_12.3_B18552.jpg)'
- en: Figure 12.3 – Viewing three passing tests in Test Explorer
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 在测试资源管理器中查看三个通过测试
- en: We now have three passing unit tests for the `GetCustomerOrdersAsync` method.
    The first two are essentially testing the same thing, but they are demonstrating
    two different ways of writing the test. You will be using the `async` method in
    most cases. The final test provides test coverage of the code that throws `ArgumentException`.
    If you are using Visual Studio Enterprise edition or a third-party tool such as
    dotCover, you can use their visualization tools to view which parts of your code
    are covered by unit tests and which are not.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个通过单元测试针对`GetCustomerOrdersAsync`方法。前两个基本上在测试同一件事，但它们展示了两种不同的编写测试方式。在大多数情况下，你将使用`async`方法。最后的测试提供了抛出`ArgumentException`的代码的测试覆盖率。如果你使用
    Visual Studio Enterprise 版本或像 dotCover 这样的第三方工具，你可以使用它们的可视化工具来查看你的代码哪些部分被单元测试覆盖，哪些没有被覆盖。
- en: Now that we have some familiarity with testing `async` methods, let’s move on
    to working with concurrent data structures in a system under test.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对测试`async`方法有了些熟悉，让我们继续在测试系统中使用并发数据结构。
- en: Unit testing concurrent code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发代码的单元测试
- en: In this section, we will adapt a sample from [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146),
    to add unit test coverage. When your code uses `async` and `await`, adding reliable
    test coverage is very simple. At the end of the example, we will examine an alternative
    method of waiting to perform your assertions by using the `SpinLock` struct.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从[*第 9 章*](B18552_09_ePub.xhtml#_idTextAnchor146)的一个示例中进行适配，以添加单元测试覆盖率。当你的代码使用`async`和`await`时，添加可靠的测试覆盖率非常简单。在示例的末尾，我们将检查使用`SpinLock`结构等待执行断言的替代方法。
- en: 'Let’s create an xUnit.net unit test project for the `ConcurrentOrderQueue`
    project and add several tests:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`ConcurrentOrderQueue`项目创建一个 xUnit.net 单元测试项目并添加几个测试：
- en: 'Start by copying the **ConcurrentOrderQueue** project from [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146).
    You can get the source code from the GitHub repository if you do not already have
    a copy of it: [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue).'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先从[*第 9 章*](B18552_09_ePub.xhtml#_idTextAnchor146)复制**ConcurrentOrderQueue**项目。如果你还没有这个项目的副本，你可以从
    GitHub 仓库获取源代码：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue)。
- en: Open the **ConcurrentOrderQueue** solution in Visual Studio.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 **ConcurrentOrderQueue** 解决方案。
- en: Right-click the solution file in `ConcurrentOrderQueue.Tests`. Make sure to
    add the new project inside the **ConcurrentOrderQueue** folder.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ConcurrentOrderQueue.Tests` 中的解决方案文件上右键点击。确保将新项目添加到 **ConcurrentOrderQueue**
    文件夹内。
- en: If your new test project also appears as a folder under the **ConcurrentOrderQueue**
    project, right-click on the **ConcurrentOrderQueue.Tests** folder and select **Exclude
    from Project**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的新测试项目也作为文件夹出现在 **ConcurrentOrderQueue** 项目下，右键点击 **ConcurrentOrderQueue.Tests**
    文件夹并选择 **Exclude from Project**。
- en: Add `UnitTest1` class `OrderServiceTests`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UnitTest1` 类到 `OrderServiceTests`。
- en: 'In order to control which `CustomerId` values are used to generate the list
    of orders, we are going to create a new overload for the public `EnqueueOrders`
    method in the `OrderService` class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了控制用于生成订单列表的 `CustomerId` 值，我们将在 `OrderService` 类中创建一个新的 `EnqueueOrders` 公共方法重载：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method takes a list of `customerId` and calls the private `EnqueueOrders`
    method for each of them, adding `Task` from each call to `List<Task>` to be awaited
    before exiting the method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个 `customerId` 列表，并为每个 `customerId` 调用私有的 `EnqueueOrders` 方法，将每个调用中的 `Task`
    添加到 `List<Task>` 中，在退出方法之前等待这些 `Task` 完成。
- en: 'We can now optimize the parameterless version of `EnqueueOrders` by having
    it call this new overload:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用这个新重载来优化无参数版本的 `EnqueueOrders`：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new unit test method in the `OrderServiceTests` class to test `EnqueueOrders`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OrderServiceTests` 类中创建一个新的单元测试方法来测试 `EnqueueOrders`：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The test will call `EnqueueOrders` with three customer IDs. After `EnqueueOrders`
    and `DequeueOrders` are complete, we assert that the `orders` collection is not
    `null`, contains some orders, and contains orders with all three of our customer
    IDs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将使用三个客户 ID 调用 `EnqueueOrders`。在 `EnqueueOrders` 和 `DequeueOrders` 完成后，我们断言
    `orders` 集合不是 `null`，包含一些订单，并且包含包含我们所有三个客户 ID 的订单。
- en: Run the new test and ensure that it passes.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新的测试并确保它通过。
- en: This covers the basics of working with a system under test that uses `ConcurrentQueue`.
    Let’s consider another scenario where we are working with code but cannot use
    `async` and `await` in our tests. Perhaps the method under test is not `async`.
    One of the tools at our disposal is the `SpinWait` struct. This struct contains
    some methods that provide non-locking mechanisms for waiting in our code. We will
    use `SpinWait.WaitUntil()` to wait until all orders have been enqueued.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了使用 `ConcurrentQueue` 的系统测试的基本知识。让我们考虑另一个场景，其中我们正在处理代码，但在测试中不能使用 `async`
    和 `await`。也许被测试的方法不是 `async`。我们可用的工具之一是 `SpinWait` 结构体。这个结构体包含一些提供非锁定等待机制的方法。我们将使用
    `SpinWait.WaitUntil()` 等待直到所有订单都已入队。
- en: 'The following steps will demonstrate how to reliably test the result of a method
    when you cannot explicitly wait for it to complete:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将演示如何可靠地测试无法显式等待其完成的方法的结果：
- en: 'Start by adding a new public variable to the `OrderService` class to expose
    the number of customers whose orders have been enqueued:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向 `OrderService` 类中添加一个新的公共变量，以公开已入队订单的客户数量：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, increment `EnqueueCount` at the end of the private `EnqueueOrders` method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在私有方法 `EnqueueOrders` 的末尾增加 `EnqueueCount`：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, create an `EnqueueOrdersSync` public method to be called from our new
    test. It will be similar to the public `EnqueueOrders` method. The differences
    between the previous example and this one are that it is not `async`, it resets
    `EnqueueCount` to `0`, and it does not wait for the tasks to be completed:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 `EnqueueOrdersSync` 公共方法，以便从我们的新测试中调用。它将类似于公共的 `EnqueueOrders` 方法。与前一个示例相比，不同之处在于它不是
    `async`，它将 `EnqueueCount` 重置为 `0`，并且不等待任务完成：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will create a new synchronous test method to test `EnqueueOrdersSync`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的同步测试方法来测试 `EnqueueOrdersSync`：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The differences are highlighted in the preceding code snippet. `SpinWait.SpinUntil`
    will wait without locking until the `orderService.EnqueueCount` value matches
    the `orderNumbers.Count`. If you want to ensure it doesn’t spin forever, there
    are overloads for providing a timeout period as either `TimeSpan` or in milliseconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在前面的代码片段中突出显示。`SpinWait.SpinUntil` 将在没有锁定的情况下等待，直到 `orderService.EnqueueCount`
    的值与 `orderNumbers.Count` 匹配。如果你想确保它不会无限期地旋转，有提供超时周期的重载，可以是 `TimeSpan` 或以毫秒为单位。
- en: Run the tests again and make sure that they both pass. We now have unit test
    methods that are testing the two methods available to enqueue orders in the `OrderService`
    class. In your own projects, you would add more scenarios to increase the test
    coverage of the class. You should always test things, such as how your code handles
    invalid input.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试，并确保它们都通过。我们现在有了测试单元测试方法，这些方法正在测试`OrderService`类中可用的两个方法来排队订单。在你的项目中，你应该添加更多场景来增加类的测试覆盖率。你应该始终测试事情，例如你的代码如何处理无效输入。
- en: It is important to remember when unit testing multithreaded code that if you
    are not using `async` and `await` or some other synchronization method, your tests
    are going to be unreliable. Having unreliable tests is as bad as having no tests
    at all. Be sure to design and develop your unit tests with care. It is best to
    use `async`/`await` wherever possible for maximum reliability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在对多线程代码进行单元测试时，重要的是要记住，如果你没有使用`async`和`await`或某些其他同步方法，你的测试将不可靠。拥有不可靠的测试和没有测试一样糟糕。务必仔细设计和开发你的单元测试。尽可能使用`async`/`await`以获得最大的可靠性。
- en: In the next section, we will build some unit tests for code that use the `Parallel.ForEach`
    and `Parallel.ForEachAsync` methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为使用`Parallel.ForEach`和`Parallel.ForEachAsync`方法的代码构建一些单元测试。
- en: Unit testing parallel code
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试并行代码
- en: Creating unit tests for code that use `Parallel.Invoke`, `Parallel.For`, `Parallel.ForEach`,
    and `Parallel.ForEachAsync` is relatively straightforward. While they can run
    processes in parallel when conditions are suitable, they run synchronously relative
    to the invoking code. Unless you wrap `Parallel.ForEach` in a `Task.Run` statement,
    the flow of code will not continue until all iterations of the loop have been
    completed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为使用`Parallel.Invoke`、`Parallel.For`、`Parallel.ForEach`和`Parallel.ForEachAsync`的代码创建单元测试相对简单。虽然它们在条件合适时可以并行运行进程，但它们相对于调用代码是同步运行的。除非你在`Parallel.ForEach`中包装`Task.Run`语句，否则代码流将不会继续，直到循环的所有迭代都已完成。
- en: 'The one caveat to consider when testing code that uses parallel loops is the
    type of exceptions to expect. If an exception is thrown within the body of one
    of these constructs, the surrounding code must catch `AggregateException`. The
    exception to this `Exception` rule is `Parallel.ForEachAsync`. Because it is called
    with `async`/`await`, you must handle `Exception` instead of `AggregateException`.
    Let’s create an example to illustrate these scenarios:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试使用并行循环的代码时需要考虑的一个注意事项是预期的异常类型。如果在这些构造函数的任何构造函数体中抛出异常，则周围的代码必须捕获`AggregateException`。这个`Exception`规则的例外是`Parallel.ForEachAsync`。因为它使用`async`/`await`调用，所以你必须处理`Exception`而不是`AggregateException`。让我们创建一个示例来阐述这些场景：
- en: Create a new `ParallelExample`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ParallelExample`。
- en: 'Rename `Class1` `TextService` and create a method named `ProcessText` in this
    class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Class1`重命名为`TextService`，并在该类中创建一个名为`ProcessText`的方法：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method accepts a list of strings and appends `Environment.TickCount` to
    each value inside a `Parallel.ForEach` loop. If any of the strings are `null`
    or empty, `Exception` will be thrown.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个字符串列表，并在`Parallel.ForEach`循环中将`Environment.TickCount`追加到每个值中。如果任何字符串为`null`或空，将抛出`Exception`。
- en: 'Next, create the `async` version of `ProcessText` and name it `ProcessTextAsync`.
    The `async` version uses `Parallel.ForEachAsync` to perform the same operation:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`ProcessText`的`async`版本，并将其命名为`ProcessTextAsync`。`async`版本使用`Parallel.ForEachAsync`执行相同的操作：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Add a new `ParallelExample.Tests`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`ParallelExample.Tests`。
- en: Rename the `UnitTest1` class `TextServiceTests` and add a **Project** reference
    to the **ParallelExample** project.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UnitTest1`类重命名为`TextServiceTests`，并将**项目**引用添加到**ParallelExample**项目中。
- en: 'Next, we will add two unit tests to test the `ProcessText` method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加两个单元测试来测试`ProcessText`方法：
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first test calls `ProcessText` with a list of five-string values containing
    fruit names. The assertion checks that `results.Count` matches `fruits.Count`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试使用包含五个字符串值（水果名称）的列表调用`ProcessText`。断言检查`results.Count`是否与`fruits.Count`匹配。
- en: The second test makes the same call, but one of the `fruits` string values is
    empty. This test will ensure that `AggregateException` is thrown by the `Parallel.ForEach`
    loop in the method under test.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试执行相同的调用，但其中一个`fruits`字符串值是空的。这个测试将确保在测试的方法中`Parallel.ForEach`循环抛出`AggregateException`。
- en: 'Add two more tests. These two tests will run the same assertions on the `ProcessTextAsync`
    method. The difference here is that `Assert.ThrowsAsync` must check for `Exception`
    instead of `AggregateExceptoin` because we are using `async`/`await`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run all four tests with the **Run All Tests in View** button in the **Text
    Explorer** window. If the window is not visible in Visual Studio, you can open
    it from **View** | **Test Explorer**. All tests should pass:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Four tests passing in the TextServiceTests class ](img/Figure_12.4_B18552.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Four tests passing in the TextServiceTests class
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: You now have two tests for each of the methods for processing text in the `TextService`
    class. They are testing valid and invalid input data successfully. Spend some
    time on your own to examine how the test coverage could be expanded. What other
    types of input could be used?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will examine how you can build memory
    leak detection into your automated unit test suite.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Checking for memory leaks with unit tests
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory leaks are by no means unique to multithreaded code, but they certainly
    can happen. The more code that is executing in your application, the more likely
    it is that some objects are going to leak. The company that makes the popular
    .NET tools, **ReSharper** and **Rider**, also makes a tool called **dotMemory**
    for analyzing memory leaks. While these tools are not free, JetBrains does offer
    its memory unit testing tool for free. It’s called **dotMemory Unit**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a dotMemory Unit test to check whether we are
    leaking one of our objects. You can run these dotMemory Unit tests for free with
    .NET on the command line by downloading the standalone test runner here: https://www.jetbrains.com/dotmemory/unit/.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about using the free tooling, you can read about it here:
    [https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml](https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml).
    JetBrains also has integration for dotMemory Unit in its ReSharper and Rider tools.
    If you have licenses for either of these tools, it greatly simplifies the process
    of running these tests.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an example demonstrating how to create a unit test that determines
    whether objects are being leaked in memory by the code under test:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new `MemoryExample`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename `Class1` `WorkService` and add another class named `Worker`. Add the
    following code to the `Worker` class. The `DoWork` method in this class will handle
    a `TimerElapsed` event in `WorkService`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class implements `IDisposable`, so we can use it with a `using` statement
    elsewhere.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `WorkWithTimer` method to the `WorkService` class:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code has some problems that will prevent the `worker` object from being
    released from memory. The `timer` object is not stopped or disposed of, and the
    `Elapsed` event is never unhooked. When we check for leaks, we should find some.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在一些问题，将阻止 `worker` 对象从内存中释放。`timer` 对象既没有被停止也没有被处置，并且 `Elapsed` 事件从未被取消绑定。当我们检查泄漏时，我们应该找到一些。
- en: Add a new `MemoryExample.Tests`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `MemoryExample.Tests`。
- en: 'Add a project reference to **MemoryExample** and add a **NuGet package reference**
    to **JetBrains.dotMemoryUnit**:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目引用添加到 **MemoryExample**，并将 **NuGet 包引用** 添加到 **JetBrains.dotMemoryUnit**：
- en: '![Figure 12.5 – Referencing the dotMemoryUnit NuGet package ](img/Figure_12.5_B18552.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 引用 dotMemoryUnit NuGet 包](img/Figure_12.5_B18552.jpg)'
- en: Figure 12.5 – Referencing the dotMemoryUnit NuGet package
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 引用 dotMemoryUnit NuGet 包
- en: 'Rename the `UnitTest1` class in `WorkServiceMemoryTests` and add the following
    code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `WorkServiceMemoryTests` 中的 `UnitTest1` 类重命名，并添加以下代码：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A few lines are highlighted in the previous snippet. An `assembly` attribute
    must be added to suppress an error in the console runner when using xUnit.net
    with dotMemory Unit. After calling the method under test, `WorkWithTimer`, we
    are calling `GC.Collect` to attempt to clean all unused managed objects from memory.
    Finally, `dotMemory.Check` is called to determine whether there are any objects
    of the `Worker` type remaining in memory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有几行被突出显示。必须添加一个 `assembly` 属性来抑制在控制台运行器中使用 xUnit.net 和 dotMemory Unit
    时出现的错误。在调用测试中的方法 `WorkWithTimer` 之后，我们调用 `GC.Collect` 尝试从内存中清理所有未使用的托管对象。最后，调用
    `dotMemory.Check` 以确定内存中是否还有 `Worker` 类型的对象。
- en: 'Run the following command either in `.\` characters are required:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.\` 字符之前运行以下命令：
- en: '[PRE30]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The path to .NET should be the same on your system. You will need to replace
    the path to `MemoryExample.Tests.dll` with your own output path where this DLL
    resides. The test should fail, with one `Worker` object remaining in memory, and
    your output will look something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的路径在您的系统上应该是相同的。您需要将 `MemoryExample.Tests.dll` 的路径替换为您自己的输出路径，其中此 DLL 存在。测试应该失败，有一个
    `Worker` 对象留在内存中，并且您的输出将类似于以下内容：
- en: '![Figure 12.6 – Reviewing the failed dotMemoryUnit test run ](img/Figure_12.6_B18552.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 检查失败的 dotMemoryUnit 测试运行](img/Figure_12.6_B18552.jpg)'
- en: Figure 12.6 – Reviewing the failed dotMemoryUnit test run
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 检查失败的 dotMemoryUnit 测试运行
- en: 'In order to fix the problem, make the following changes to your `WorkService.WorkWithTimer`
    method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复问题，请对您的 `WorkService.WorkWithTimer` 方法进行以下更改：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To make sure the `worker` object instance is released, we’re initializing `timer`
    in a `using` statement, stopping `timer` when it’s finished, and unhooking the
    `timer.Elapsed` event handler.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `worker` 对象实例被释放，我们在 `using` 语句中初始化 `timer`，在完成时停止 `timer`，并取消绑定 `timer.Elapsed`
    事件处理器。
- en: 'Now, execute the `dotMemory` Unit command again. The test should succeed now:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次执行 `dotMemory` 单元命令。测试应该现在成功：
- en: '![Figure 12.7 – The dotMemoryUnit test runs successfully ](img/Figure_12.7_B18552.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – dotMemoryUnit 测试运行成功](img/Figure_12.7_B18552.jpg)'
- en: Figure 12.7 – The dotMemoryUnit test runs successfully
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – dotMemoryUnit 测试运行成功
- en: 'That concludes this example and the section on memory unit tests. If you would
    like to read more about dotMemory Unit, you can find its documentation here: [https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml](https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml).
    The command-line tool can also be deployed to a **continuous integration** (**CI**)
    build server to execute these tests as part of a CI build process.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本例和关于内存单元测试的部分。如果您想了解更多关于 dotMemory Unit 的信息，可以在此处找到其文档：[https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml](https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml)。命令行工具也可以部署到持续集成（**CI**）构建服务器，以作为
    CI 构建过程的一部分执行这些测试。
- en: Let’s finish up by reviewing what we have learned in the final chapter of this
    book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾本书最后一章所学的内容来结束。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about some tools and techniques to unit test .NET
    projects that contain different multithreaded constructs. We started by discussing
    the best methods for testing C# code that employs `async`/`await`. This will be
    common in modern applications, and it is important to have a suite of automated
    unit tests covering your `async` code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些用于单元测试包含不同多线程结构的 .NET 项目的工具和技术。我们首先讨论了测试使用 `async`/`await` 的 C#
    代码的最佳方法。这在现代应用程序中很常见，并且拥有覆盖您 `async` 代码的自动化单元测试套件非常重要。
- en: We also walked through some examples of unit tests that test methods that leverage
    parallel constructs and concurrent data structures. In the last section of the
    chapter, we learned about dotMemory Unit from JetBrains. This free unit testing
    tool adds the ability to detect objects leaked by methods under test. It is a
    powerful automation tool for synchronous and asynchronous .NET code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了几个单元测试的例子，这些测试方法利用了并行构造和并发数据结构。在章节的最后部分，我们学习了 JetBrains 的 dotMemory Unit。这个免费的单元测试工具增加了检测测试方法中泄漏的对象的能力。它是一个强大的自动化工具，用于同步和异步
    .NET 代码。
- en: This is the final chapter. Thanks for following along on this multithreading
    journey. Hopefully, you didn’t encounter any deadlocks or race conditions along
    the way. This book provided guidance for your path through the modern, multithreaded
    world of .NET and C#. You should now have an understanding of the asynchronous,
    concurrent, and parallel methods and structures to build fast and reliable .NET
    applications. If you want to learn more about these topics, I suggest reading
    the *.NET Parallel Programming* blog ([https://devblogs.microsoft.com/pfxteam/](https://devblogs.microsoft.com/pfxteam/))
    and relying on the .NET documentation ([https://docs.microsoft.com/dotnet/](https://docs.microsoft.com/dotnet/)).
    You can search for documentation on any of the topics in this book to learn more.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一章。感谢您跟随我们走过这段多线程之旅。希望您在旅途中没有遇到任何死锁或竞态条件。这本书为您在 .NET 和 C# 的现代多线程世界中找到了一条路径。您现在应该已经了解了异步、并发和并行方法和结构，以构建快速可靠的应用程序。如果您想了解更多关于这些主题的信息，我建议阅读
    *.NET 并行编程* 博客 ([https://devblogs.microsoft.com/pfxteam/](https://devblogs.microsoft.com/pfxteam/))
    并依赖 .NET 文档 ([https://docs.microsoft.com/dotnet/](https://docs.microsoft.com/dotnet/))。您可以在本书的任何主题上搜索文档以了解更多信息。
- en: Questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the keyword used in .NET attributes that decorate an `xUnit.net` test
    method?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET 属性中，用于装饰 `xUnit.net` 测试方法的关键字是什么？
- en: What method can you use to add `await` to your code without locks?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用什么方法在不使用锁的情况下将 `await` 添加到您的代码中？
- en: What type of exception should you expect in unit test assertions when the method
    under test contains a `Parallel.ForEach` loop?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试的方法包含 `Parallel.ForEach` 循环时，在单元测试断言中你应该期望哪种异常？
- en: What type of exception should you expect in unit test assertions when the method
    under test contains a `Parallel.ForEachAsync` loop?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试的方法包含 `Parallel.ForEachAsync` 循环时，在单元测试断言中你应该期望哪种异常？
- en: How can you check that an object isn’t `null` in an xUnit.net assertion?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 xUnit.net 断言中检查一个对象是否不是 `null`？
- en: What is the name of the window in Visual Studio where unit tests can be managed
    and run?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，可以管理并运行单元测试的窗口叫什么名字？
- en: What are the three most popular unit test frameworks for .NET?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 中最受欢迎的三个单元测试框架是什么？
- en: Which JetBrains products provide tooling to run dotMemory Unit tests?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些 JetBrains 产品提供了运行 dotMemory Unit 测试的工具？
