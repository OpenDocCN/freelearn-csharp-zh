<html><head></head><body>
<div id="_idContainer046">
<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.2.1">Performing Health Checks on Your Services</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Maintaining maximum uptime is an important aspect of any system. </span><span class="koboSpan" id="kobo.3.2">In the previous chapter, we saw where we can write code in a fault-tolerant manner that will reduce the prevalence of outages in our infrastructure and network. </span><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.4.1">This, however, is not a long-term solution, and things fail regardless of these measures. </span><span class="koboSpan" id="kobo.4.2">It then leads to the notion that we need to know when there are failures.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This is where we start thinking about health checks. </span><span class="koboSpan" id="kobo.5.2">Health checks exist as a mechanism to inform us of outages in our services and supporting databases and connections in our application. </span><span class="koboSpan" id="kobo.5.3">Generally, this can be accomplished with a simple ping request to a resource. </span><span class="koboSpan" id="kobo.5.4">The resource is available and operating as expected if we get a response. </span><span class="koboSpan" id="kobo.5.5">In the absence of a response, we assume that the resource is down and trigger an alert.</span></p>
<p><span class="koboSpan" id="kobo.6.1">There are statuses between the service’s up and down status, and we will discover those options in this chapter. </span><span class="koboSpan" id="kobo.6.2">We will also explore some of the functionality that .NET Core provides to implement these checks.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will look at various scenarios and countermeasures that we can implement when navigating possible failures in our microservices architecture.</span></p>
<p><span class="koboSpan" id="kobo.8.1">After reading this chapter, we will be able to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understand why health checks are necessary</span></li>
<li><span class="koboSpan" id="kobo.10.1">Understand how to implement health checks in ASP.NET Core</span></li>
<li><span class="koboSpan" id="kobo.11.1">Understand how orchestrators monitor and respond to failures</span></li>
</ul>
<h1 id="_idParaDest-148"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">Code references used in this chapter can be found in the project repository, which is hosted on GitHub at this URL: </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10"><span class="koboSpan" id="kobo.14.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10</span></a><span class="koboSpan" id="kobo.15.1">.</span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.16.1">Health checks and microservices</span></h1>
<p><span class="koboSpan" id="kobo.17.1">A health check allows us to monitor</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.18.1"> the health of our services. </span><span class="koboSpan" id="kobo.18.2">Frankly, another service</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.19.1"> or resource that exposes an HTTP endpoint becomes a capable candidate for health checks. </span><span class="koboSpan" id="kobo.19.2">We can simply make a request to this endpoint and hope for a response that indicates a successful response. </span><span class="koboSpan" id="kobo.19.3">The simplest form of a health check can come from implementing a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">GET</span></strong><span class="koboSpan" id="kobo.21.1"> request, which returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">200OK</span></strong><span class="koboSpan" id="kobo.23.1"> HTTP response. </span><span class="koboSpan" id="kobo.23.2">We can add further intelligence to such an endpoint, check connectivity to other key services, and use those to influence the response code returned.</span></p>
<p><span class="koboSpan" id="kobo.24.1">Health checks are useful mechanisms for both monolithic and microservices applications. </span><span class="koboSpan" id="kobo.24.2">In the context of microservices, however, we have an increased challenge of monitoring and maintaining several services. </span><span class="koboSpan" id="kobo.24.3">Even more so if they are configured to scale on individual levels. </span><span class="koboSpan" id="kobo.24.4">Health checks can be used to monitor the health and uptime of interdependent services and carry out some form of corrective action when a service is down.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Using .NET Core, we can return a successful response and include additional information that gives some details on the health of the service. </span><span class="koboSpan" id="kobo.25.2">In this case, we cannot simply go by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">200OK</span></strong><span class="koboSpan" id="kobo.27.1"> response, but we need to interrogate the actual response body to check whether the service is healthy, degraded, or unhealthy.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.28.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.29.1"> shows a typical health check:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.30.1"><img alt="Figure 10.1 – Shows a health check request and healthy response after verifying that all services are available" src="image/Figure_10.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.31.1">Figure 10.1 – Shows a health check request and healthy response after verifying that all services are available</span></p>
<p><span class="koboSpan" id="kobo.32.1">Let’s break down</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.33.1"> what each state entails:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Healthy</span></strong><span class="koboSpan" id="kobo.35.1">: This indicates that the service</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.36.1"> is healthy and the application is operating as expected</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Degraded</span></strong><span class="koboSpan" id="kobo.38.1">: This indicates that the service</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.39.1"> is live, but some functionality may be unavailable</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">Unhealthy</span></strong><span class="koboSpan" id="kobo.41.1">: This indicates that the service</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.42.1"> is failing and is not operating as expected</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.43.1">Figure 10.2</span></em><span class="koboSpan" id="kobo.44.1"> shows a failed health check:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.45.1"><img alt="Figure 10.2 – Shows a health check that sent a failure response since one of the services was not available" src="image/Figure_10.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.46.1">Figure 10.2 – Shows a health check that sent a failure response since one of the services was not available</span></p>
<p><span class="koboSpan" id="kobo.47.1">The health of a service depends on several things, including correct configuration, access to keys and dependencies, the status of the hosting platform and infrastructure, and the connection to the database. </span><span class="koboSpan" id="kobo.47.2">They may also be used for external application monitoring and overall application health.</span></p>
<p><span class="koboSpan" id="kobo.48.1">A common deployment model</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.49.1"> for microservices is using container orchestrators, such as </span><em class="italic"><span class="koboSpan" id="kobo.50.1">Kubernetes</span></em><span class="koboSpan" id="kobo.51.1">, to deploy</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.52.1"> and run our services in production. </span><span class="koboSpan" id="kobo.52.2">Most orchestrators perform periodical </span><em class="italic"><span class="koboSpan" id="kobo.53.1">liveness health checks</span></em><span class="koboSpan" id="kobo.54.1"> on their pods during runtime and </span><em class="italic"><span class="koboSpan" id="kobo.55.1">readiness health checks</span></em><span class="koboSpan" id="kobo.56.1"> during deployments. </span><span class="koboSpan" id="kobo.56.2">Health checks help the orchestrator determine which pods are in a ready state and are capable of handling traffic. </span><span class="koboSpan" id="kobo.56.3">It is important to understand the differences between the liveness health check and the readiness health check and when which one is most suitable. </span><span class="koboSpan" id="kobo.56.4">The easier one to implement is the liveness health check; we will discuss this next.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.57.1">The liveness health check</span></h2>
<p><span class="koboSpan" id="kobo.58.1">The liveness health check </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.59.1">endpoint is a specific endpoint</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.60.1"> that is implemented for the sole purpose of the health check. </span><span class="koboSpan" id="kobo.60.2">In this health probe, the service is considered healthy when it responds to the </span><em class="italic"><span class="koboSpan" id="kobo.61.1">liveness health check</span></em><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">A failure to respond to this endpoint indicates a serious issue with the application. </span><span class="koboSpan" id="kobo.62.3">This issue could be caused by a range of reasons, such as a crash or unplanned application restart. </span><span class="koboSpan" id="kobo.62.4">For this reason, restarting an application that has failed this check is a common course of action.</span></p>
<p><span class="koboSpan" id="kobo.63.1">Applications that monitor the infrastructure, such as </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Kubernetes</span></em><span class="koboSpan" id="kobo.65.1"> monitoring Docker containers, use </span><em class="italic"><span class="koboSpan" id="kobo.66.1">liveness health checks</span></em><span class="koboSpan" id="kobo.67.1"> to determine the health of pods and trigger restarts as needed. </span><span class="koboSpan" id="kobo.67.2">Cloud providers also offer health probe functionality with load balancers, which can check the availability of the deployed application by periodically sending a request to the liveness check endpoint. </span><span class="koboSpan" id="kobo.67.3">This approach is generally sufficient for web applications and services as we do not need a complicated liveness check endpoint. </span><span class="koboSpan" id="kobo.67.4">If the service can accept the request and return a response, then we consider it healthy.</span></p>
<p><span class="koboSpan" id="kobo.68.1">Checking whether the application</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.69.1"> or services is alive is simple enough, but we may</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.70.1"> also need to mitigate false positives after application deployments and/or upgrades. </span><span class="koboSpan" id="kobo.70.2">This can occur when the application might not be completely ready for usage, yet we are getting positive responses from the liveness checks. </span><span class="koboSpan" id="kobo.70.3">At this point, we need to consider implementing </span><em class="italic"><span class="koboSpan" id="kobo.71.1">readiness health checks</span></em><span class="koboSpan" id="kobo.72.1">.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.73.1">Readiness health checks</span></h2>
<p><em class="italic"><span class="koboSpan" id="kobo.74.1">Readiness health checks</span></em><span class="koboSpan" id="kobo.75.1"> are used in situations</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.76.1"> where we need to verify more</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.77.1"> than just an HTTP response. </span><span class="koboSpan" id="kobo.77.2">An application with several third-party dependencies might take longer to be ready for use. </span><span class="koboSpan" id="kobo.77.3">So, while it is operational and able to respond to a simple HTTP request, the databases or message bus services, for instance, might not yet be ready. </span><span class="koboSpan" id="kobo.77.4">We want to ensure that we have a full picture of the status of the application from a startup perspective before proceeding to use it or continuing with the deployment activity.</span></p>
<p><span class="koboSpan" id="kobo.78.1">A </span><em class="italic"><span class="koboSpan" id="kobo.79.1">readiness health check</span></em><span class="koboSpan" id="kobo.80.1"> will generally only return a healthy status once the startup task has been completed. </span><span class="koboSpan" id="kobo.80.2">These checks will then take a bit longer to return a healthy status than a </span><em class="italic"><span class="koboSpan" id="kobo.81.1">liveness health check</span></em><span class="koboSpan" id="kobo.82.1"> will. </span><span class="koboSpan" id="kobo.82.2">With readiness health checks in place, an orchestrator will not attempt to restart the application, but it will not route request traffic. </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Kubernetes</span></em><span class="koboSpan" id="kobo.84.1"> can perform readiness probes periodically during the application’s runtime, but it can also be configured to only perform this probe during the startup of the application. </span><span class="koboSpan" id="kobo.84.2">Once the application reports that it is healthy, then this probe will not be executed again for the lifetime of the application.</span></p>
<p><span class="koboSpan" id="kobo.85.1">This </span><em class="italic"><span class="koboSpan" id="kobo.86.1">readiness health check</span></em><span class="koboSpan" id="kobo.87.1"> is best used for applications where there are long-running tasks that must finish before the application can be considered ready and operational. </span><span class="koboSpan" id="kobo.87.2">Recall that with microservices, we introduce several additional infrastructure dependencies, and we need to monitor and confirm the overall health of the system to ensure that only the healthiest pods get traffic directed to them. </span><span class="koboSpan" id="kobo.87.3">Therefore, properly configuring health checks is essential to ensuring that we have the best representation of our application’s health.</span></p>
<p><span class="koboSpan" id="kobo.88.1">Now that we have explored how health</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.89.1"> checks work and how</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.90.1"> orchestrators and monitoring systems use them, we can explore implementing health checks in our ASP.NET Core API.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.91.1">Implementing ASP.NET Core health checks</span></h1>
<p><span class="koboSpan" id="kobo.92.1">ASP.NET Core has a built-in health check</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.93.1"> middleware that allows us to natively implement very robust health checks. </span><span class="koboSpan" id="kobo.93.2">This middleware is not limited to API projects, and it comes in handy to help us to monitor the health of our application. </span><span class="koboSpan" id="kobo.93.3">Both readiness and liveness health checks can be created natively, and there is support for a UI dashboard. </span><span class="koboSpan" id="kobo.93.4">Using the liveness health check, which is relatively simple to implement, we can implement a simple API endpoint that returns a simple response, as expected. </span><span class="koboSpan" id="kobo.93.5">We can also check on the health of the dependencies of the app using a more comprehensive readiness health check.</span></p>
<p><span class="koboSpan" id="kobo.94.1">For this example, we will be adding liveness and readiness health checks to our appointment booking service. </span><span class="koboSpan" id="kobo.94.2">This service has several dependencies and is integral to several operations in our application. </span><span class="koboSpan" id="kobo.94.3">We need to ensure that it is always healthy and react quickly if it degrades.</span></p>
<p><span class="koboSpan" id="kobo.95.1">Let us start off by exploring how we can outfit an ASP.NET Core API with a liveness health check.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.96.1">Adding liveness health checks</span></h2>
<p><span class="koboSpan" id="kobo.97.1">As discussed, a liveness check</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.98.1"> is the most basic health</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.99.1"> check that can be implemented. </span><span class="koboSpan" id="kobo.99.2">The basic configuration needed for this in our ASP.NET Core application is to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">AddHealthChecks</span></strong><span class="koboSpan" id="kobo.101.1"> service and the addition of the health check middleware, where we define a URL.</span></p>
<p><span class="koboSpan" id="kobo.102.1">We make the following changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Program.cs</span></strong><span class="koboSpan" id="kobo.104.1"> file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
var builder = WebApplication.CreateBuilder(args);
// code omitted for brevity
builder.Services.AddHealthChecks();
var app = builder.Build();
// code omitted for brevity
app.MapHealthChecks("/healthcheck ");
app.Run();</span></pre>
<p><span class="koboSpan" id="kobo.106.1">Any attempt to navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">/healthcheck</span></strong><span class="koboSpan" id="kobo.108.1"> endpoint will yield a simple plain text response as </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">HealthStatus</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">The possible </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">HealthStatus</span></strong><span class="koboSpan" id="kobo.112.1"> values are </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">HealthStatus.Healthy</span></strong><span class="koboSpan" id="kobo.114.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">HealthStatus.Degraded</span></strong><span class="koboSpan" id="kobo.116.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">HealthStatus.Unhealthy</span></strong><span class="koboSpan" id="kobo.118.1">.</span></p>
<p><span class="koboSpan" id="kobo.119.1">Health checks</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.120.1"> are created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">IHeathCheck</span></strong><span class="koboSpan" id="kobo.122.1"> interface. </span><span class="koboSpan" id="kobo.122.2">This</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.123.1"> interface allows us to extend the default health checks and add more logic to our health check and further customize the possible response values. </span><span class="koboSpan" id="kobo.123.2">We can create a health check extension using the following code block:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
 public class HealthCheck : IHealthCheck
{
    public Task&lt;HealthCheckResult&gt; CheckHealthAsync(
        HealthCheckContext context, CancellationToken =
            default)
    {
        var healthy = true;
        if (healthy)
        {
            // additional custom logic when the health is
            confirmed.
</span><span class="koboSpan" id="kobo.124.2">            return Task.FromResult(
                HealthCheckResult.Healthy("Service is
                    healthy"));
        }
        // additional custom logic when the api is not
           healthy
        return Task.FromResult(
            new HealthCheckResult(
                context.Registration.FailureStatus,
                    "Service is unhealthy"));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.125.1">This inheriting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">IHeathCheck</span></strong><span class="koboSpan" id="kobo.127.1"> forces us to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">CheckHealthAsync</span></strong><span class="koboSpan" id="kobo.129.1"> method. </span><span class="koboSpan" id="kobo.129.2">This method gets called</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.130.1"> when a health check</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.131.1"> is triggered, and we can include additional code to check other factors and determine whether we deem our application to be healthy or not. </span><span class="koboSpan" id="kobo.131.2">Based on the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">healthy</span></strong><span class="koboSpan" id="kobo.133.1">, we can return a custom message.</span></p>
<p><span class="koboSpan" id="kobo.134.1">Now to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">HealthCheack</span></strong><span class="koboSpan" id="kobo.136.1"> to our services, we modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">AddHealthChecks</span></strong><span class="koboSpan" id="kobo.138.1"> service registration like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
builder.Services.AddHealthChecks()
    .AddCheck&lt;HealthCheack&gt;("ApiHealth");</span></pre>
<p><span class="koboSpan" id="kobo.140.1">Here, we add our new health check logic and give it a name for a specific reference in other parts of the application. </span><span class="koboSpan" id="kobo.140.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">AddCheck</span></strong><span class="koboSpan" id="kobo.142.1"> method allows us to define a name for the health check, a default failure status value, tags to map to custom health check endpoints, and a default timeout value.</span></p>
<p><span class="koboSpan" id="kobo.143.1">Now building on the notion</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.144.1"> that our orchestrators and load balancers</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.145.1"> that are performing health checks will also prefer to see appropriate responses relative to the health status, we can extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">app.MapHealthChecks</span></strong><span class="koboSpan" id="kobo.147.1"> middleware code to return a specific HTTP response relative to the health status. </span><span class="koboSpan" id="kobo.147.2">While we are at it, we can also disable cached responses:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
app.MapHealthChecks("/healthcheck", new HealthCheckOptions
{
    AllowCachingRepsonses = false,
    ResultStatusCodes =
    {
          [HealthStatus.Unhealthy] =
                 StatusCodes.Status503ServiceUnavailable,
        [HealthStatus.Healthy] = StatusCodes.Status200OK,
        [HealthStatus.Degraded] = StatusCodes.Status200OK,
    }
});</span></pre>
<p><span class="koboSpan" id="kobo.149.1">The next thing we may want to investigate is returning details in our response. </span><span class="koboSpan" id="kobo.149.2">As it stands, we are only returning the plain text response with the status. </span><span class="koboSpan" id="kobo.149.3">We can use methods found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.151.1"> library to create a custom delegate method that can be implemented as follows.</span></p>
<p><span class="koboSpan" id="kobo.152.1">We first need to indicate to the middleware that we have a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">ResponseWriter</span></strong><span class="koboSpan" id="kobo.154.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">WriteJsonResponse</span></strong><span class="koboSpan" id="kobo.156.1">. </span><span class="koboSpan" id="kobo.156.2">We need to add this to the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">HealthCheckOptions</span></strong><span class="koboSpan" id="kobo.158.1">, using the following:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
app.MapHealthChecks("/healthcheck", new HealthCheckOptions
{
    // code omitted for brevity
    ResponseWriter = JsonResponse
});</span></pre>
<p><span class="koboSpan" id="kobo.160.1">We then define</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.161.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">WriteJsonResponse</span></strong><span class="koboSpan" id="kobo.163.1"> writer with</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.164.1"> the following:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
private static Task JsonResponse(HttpContext context,
    HealthReport healthReport)
{
    context.Response.ContentType = "application/json;
        charset=utf-8";
   var options = new JsonWriterOptions { Indented = true };
    using var memoryStream = new MemoryStream();
    using (var jsonWriter = new Utf8JsonWriter
        (memoryStream, options))
    {
        jsonWriter.WriteStartObject();
        jsonWriter.WriteString("status",
            healthReport.Status.ToString());
        jsonWriter.WriteStartObject("results");
        foreach (var healthReportEntry in
           healthReport.Entries)
        {
            jsonWriter.WriteStartObject
                (healthReportEntry.Key);
            jsonWriter.WriteString("status",
                healthReportEntry.Value.Status.ToString());
            jsonWriter.WriteString("description",
                healthReportEntry.Value.Description);
            jsonWriter.WriteStartObject("data");
            foreach (var item in
                healthReportEntry.Value.Data)
            {
                jsonWriter.WritePropertyName(item.Key);
                JsonSerializer.Serialize(jsonWriter,
                    item.Value,
                    item.Value?.GetType() ??
</span><span class="koboSpan" id="kobo.165.2">                        typeof(object));
            }
            jsonWriter.WriteEndObject();
            jsonWriter.WriteEndObject();
        }
        jsonWriter.WriteEndObject();
        jsonWriter.WriteEndObject();
    }
    return context.Response.WriteAsync(
        Encoding.UTF8.GetString(memoryStream.ToArray()));
}</span></pre>
<p><em class="italic"><span class="koboSpan" id="kobo.166.1">Figure 10.3</span></em><span class="koboSpan" id="kobo.167.1"> shows the results</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.168.1"> of a health</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.169.1"> check:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.170.1"><img alt="Figure 10.3 – Shows a health check response where both the service and database are available and in good health" src="image/Figure_10.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">Figure 10.3 – Shows a health check response where both the service and database are available and in good health</span></p>
<p><span class="koboSpan" id="kobo.172.1">Now we can include details about the health status if the API reports an unhealthy or degraded status. </span><span class="koboSpan" id="kobo.172.2">Furthermore, when we add more health checks, the content of this JSON response will be populated with each check’s details.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.173.1">Figure 10.4</span></em><span class="koboSpan" id="kobo.174.1"> shows the results of an unhealthy check:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.175.1"><img alt="Figure 10.4 – Shows a health check response where the database is not available" src="image/Figure_10.4_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Figure 10.4 – Shows a health check response where the database is not available</span></p>
<p><span class="koboSpan" id="kobo.177.1">Now that we have more detailed</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.178.1"> responses, we can add</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.179.1"> more detailed checks, such as a database probe. </span><span class="koboSpan" id="kobo.179.2">This will serve as a check to verify that the API can communicate with the database through the configured database. </span><span class="koboSpan" id="kobo.179.3">By extension, since we are using Entity Framework for this connection, we can implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">DbContext</span></strong><span class="koboSpan" id="kobo.181.1"> check. </span><span class="koboSpan" id="kobo.181.2">We start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore</span></strong><span class="koboSpan" id="kobo.183.1"> NuGet package. </span><span class="koboSpan" id="kobo.183.2">We then modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">AddHealthChecks</span></strong><span class="koboSpan" id="kobo.185.1"> method registration using the following piece of code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
builder.Services.AddHealthChecks()
    .AddCheck&lt;HealthCheack&gt;("ApiHealth")
      .AddDbContextCheck&lt;ApplicationDbContext&gt;
        ("DatabaseHealth");</span></pre>
<p><span class="koboSpan" id="kobo.187.1">This context health calls Entity Framework Core’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">CanConnectAsync</span></strong><span class="koboSpan" id="kobo.189.1"> method and uses that response to infer the database connectivity health.</span></p>
<p><span class="koboSpan" id="kobo.190.1">Now that we can check</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.191.1"> on the health of our service</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.192.1"> and its connectivity to our database let us configure it for readiness checks.</span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.193.1">Adding readiness health checks</span></h2>
<p><span class="koboSpan" id="kobo.194.1">As we have discussed, the readiness</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.195.1"> check indicates when the application</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.196.1"> and its dependencies have started successfully and are ready to begin receiving requests. </span><span class="koboSpan" id="kobo.196.2">We can define a separate endpoint for the readiness check and further customize the checks that should be performed based on the URL used.</span></p>
<p><span class="koboSpan" id="kobo.197.1">To implement liveness and readiness checks on different URLs, we can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">tags</span></strong><span class="koboSpan" id="kobo.199.1"> parameter to the extensions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">AddHealthChecks</span></strong><span class="koboSpan" id="kobo.201.1"> method. </span><span class="koboSpan" id="kobo.201.2">This allows us to pass in an array of tag names. </span><span class="koboSpan" id="kobo.201.3">We can tag our health checks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
builder.Services.AddHealthChecks()
    .AddCheck&lt;HealthCheack&gt;("ApiHealth", tags: new[] {
      "live"})
 .AddDbContextCheck&lt;ApplicationDbContext&gt;("DatabaseHealth",
    tags: new[] { "ready" });</span></pre>
<p><span class="koboSpan" id="kobo.203.1">Now that we have tagged our health checks, we can proceed to create our specific check endpoints and associate them with the tags:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
app.MapHealthChecks("/healthcheck/ready", new
    HealthCheckOptions
{
    Predicate = healthCheck =&gt;
        healthCheck.Tags.Contains("ready"),
    // code omitted for brevity
});
app.MapHealthChecks("/healthcheck/live", new
    HealthCheckOptions
{
    Predicate = healthCheck =&gt; false;
    // code omitted for brevity
});</span></pre>
<p><span class="koboSpan" id="kobo.205.1">With this new code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">/healthcheck/ready</span></strong><span class="koboSpan" id="kobo.207.1"> endpoint will filter only health checks that are tagged as </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">ready</span></strong><span class="koboSpan" id="kobo.209.1">. </span><span class="koboSpan" id="kobo.209.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">/health/live</span></strong><span class="koboSpan" id="kobo.211.1"> endpoint, we set the predicate value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">false</span></strong><span class="koboSpan" id="kobo.213.1"> to ignore all tags and conduct all health checks.</span></p>
<p><span class="koboSpan" id="kobo.214.1">While we will not be</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.215.1"> exploring Kubernetes or other</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.216.1"> orchestrators in detail, we want to look at how orchestrators interact with our health check endpoints.</span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.217.1">Configuring health probes in orchestrators</span></h1>
<p><span class="koboSpan" id="kobo.218.1">Monitoring is not unique</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.219.1"> to orchestrators, as we have already</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.220.1"> established. </span><span class="koboSpan" id="kobo.220.2">There are services that offer monitoring services for our applications and allow us to configure probes into our applications. </span><span class="koboSpan" id="kobo.220.3">These services generally allow us to add alerts and configure response time thresholds. </span><span class="koboSpan" id="kobo.220.4">These alerts can come in handy in helping us to respond to failures or situations of concern based on our configured thresholds.</span></p>
<p><span class="koboSpan" id="kobo.221.1">In a microservices application, we need a way of monitoring many services as efficiently as possible. </span><span class="koboSpan" id="kobo.221.2">The fewer unique configurations we need to do, the better. </span><span class="koboSpan" id="kobo.221.3">We have several deployment models that can be used, and most predominantly, containers managed by orchestrators. </span><span class="koboSpan" id="kobo.221.4">Microsoft</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.222.1"> Azure has several</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.223.1"> web application</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.224.1"> deployment models, including </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">Web App for Containers</span></strong><span class="koboSpan" id="kobo.226.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.227.1">WAC</span></strong><span class="koboSpan" id="kobo.228.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">Azure Container Instances</span></strong><span class="koboSpan" id="kobo.230.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.231.1">ACI</span></strong><span class="koboSpan" id="kobo.232.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.234.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.235.1">AKS</span></strong><span class="koboSpan" id="kobo.236.1">).</span></p>
<p><span class="koboSpan" id="kobo.237.1">WAC is a part of App Service, so the health check works the same way as it would for an Azure web app. </span><span class="koboSpan" id="kobo.237.2">It allows you to specify a health check endpoint that will return a response within the 2xx and 3xx HTTP response range. </span><span class="koboSpan" id="kobo.237.3">It should also return this health check response within a minute for the service to be considered healthy.</span></p>
<p><span class="koboSpan" id="kobo.238.1">The next option</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.239.1"> is the ACI, where health checks</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.240.1"> are called health probes. </span><span class="koboSpan" id="kobo.240.2">These probes are configured with a check period, which determines the frequency with which checks are made. </span><span class="koboSpan" id="kobo.240.3">When the health check is completed successfully, then the container is considered healthy, and if not, then it is unhealthy or just unavailable. </span><span class="koboSpan" id="kobo.240.4">With the ACI, we can configure both liveness and readiness health checks. </span><span class="koboSpan" id="kobo.240.5">Our probes can either execute a command on the container or perform an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">GET</span></strong><span class="koboSpan" id="kobo.242.1"> request. </span><span class="koboSpan" id="kobo.242.2">When we perform a liveness probe, we verify that our container is healthy, and if not, the ACI might proceed to shut down the container and spin up a new instance. </span><span class="koboSpan" id="kobo.242.3">The readiness probe is designed to confirm whether a container is available for request processing, which, as we discussed, is more important during the application startup process.</span></p>
<p><span class="koboSpan" id="kobo.243.1">In the Azure Kubernetes Service of AKS, we have a very similar approach to health checks and probes, as we saw in the ACI. </span><span class="koboSpan" id="kobo.243.2">Out of the box, Kubernetes supports both liveness and readiness probes; as seen before, the major difference is that Kubernetes suggests that you have a separate probe for checking the application’s health at startup, separate from the readiness probe that is continuous during the application runtime. </span><span class="koboSpan" id="kobo.243.3">We can also implement HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">GET</span></strong><span class="koboSpan" id="kobo.245.1"> request probes as well as TCP probes to check on our containers.</span></p>
<p><span class="koboSpan" id="kobo.246.1">Kubernetes is configured</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.247.1"> using a markup language called </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">YAML Ain’t Markup Language</span></strong><span class="koboSpan" id="kobo.249.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.250.1">YAML</span></strong><span class="koboSpan" id="kobo.251.1">), which is a human-friendly scripting language. </span><span class="koboSpan" id="kobo.251.2">Kubernetes administrators use YAML</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.252.1"> to define configurations called a </span><em class="italic"><span class="koboSpan" id="kobo.253.1">manifest</span></em><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">This manifest is then used to infer Kubernetes objects. </span><span class="koboSpan" id="kobo.254.3">A Kubernetes deployment specifies the configuration for a </span><em class="italic"><span class="koboSpan" id="kobo.255.1">deployment object</span></em><span class="koboSpan" id="kobo.256.1">, which then creates </span><em class="italic"><span class="koboSpan" id="kobo.257.1">pods</span></em><span class="koboSpan" id="kobo.258.1">. </span><span class="koboSpan" id="kobo.258.2">Each governs the running of specific containers as outlined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">spec.template</span></strong><span class="koboSpan" id="kobo.260.1"> field of the YAML configuration.</span></p>
<p><span class="koboSpan" id="kobo.261.1">The following is an example of a YAML configuration that creates a deployment object that performs startup, liveness, and readiness health checks on a container:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness-api
  name: liveness-http
spec:
  ports:
  - name: api-port
    containerPort: 8080
    hostPort: 8080
  containers:
  - name: liveness-api
    image: registry.k8s.io/liveness
    args:
    - /server
    livenessProbe:
      httpGet:
        path: /healthcheck/live
        port: api-port
      initialDelaySeconds: 3
      failureThreshold: 1
      periodSeconds: 3
    startupProbe:
      httpGet:
        path: /healthcheck/ready
        port: api-port
      failureThreshold: 30
      periodSeconds: 10
    readinessProbe:
      httpGet:
        path: /healthcheck/ready
        port: api-port
      failureThreshold: 30
      periodSeconds: 10</span></pre>
<p><span class="koboSpan" id="kobo.263.1">The sections of the YAML file that outline the health checks are </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">livenessProbe</span></strong><span class="koboSpan" id="kobo.265.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">startupProbe</span></strong><span class="koboSpan" id="kobo.267.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">readinessProbe</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">The probe definition with the major difference is the readiness</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.270.1"> probe, which executes a command</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.271.1"> as opposed to making a call to an endpoint.</span></p>
<p><span class="koboSpan" id="kobo.272.1">With this, we have gained some fundamental knowledge of health checks, how they work, and why we need them.</span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.273.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.274.1">Health checks are simple yet powerful constructs that aid us in ensuring that our applications are running at maximum efficiency. </span><span class="koboSpan" id="kobo.274.2">We see where it is important for us to not only monitor and report on the uptime of the service but also the dependencies, such as the database and other services that may be needed for the application to operate properly.</span></p>
<p><span class="koboSpan" id="kobo.275.1">Using ASP.NET Core, we have access to a built-in health check mechanism that can be customized and extended to implement specific checks and associate them with different endpoints. </span><span class="koboSpan" id="kobo.275.2">This is especially useful when we need to separate the types of tests that are conducted relative to the endpoint being called.</span></p>
<p><span class="koboSpan" id="kobo.276.1">We have also explored how orchestrators can be configured to poll our health check endpoints. </span><span class="koboSpan" id="kobo.276.2">Orchestrators make monitoring and responding to failures easier since they will handle the routing of traffic to healthy instances and restart instances as needed.</span></p>
<p><span class="koboSpan" id="kobo.277.1">Health checks help us not only monitor the target web service, but we can also configure health checks to report on downstream services as well. </span><span class="koboSpan" id="kobo.277.2">This will come in handy, especially when we implement dependencies between our microservices through patterns like the API gateway pattern. </span><span class="koboSpan" id="kobo.277.3">We will investigate implementing this pattern in the next chapter.</span></p>
</div>
</body></html>