<html><head></head><body>
<div><h1 class="chapterNumber">18</h1>
<h1 class="chapterTitle" id="_idParaDest-363">Implementing Frontend Microservices with ASP.NET Core</h1>
<p class="normal"><em class="italic">Chapter 14</em>, <em class="italic">Implementing Microservices with .NET</em>, described general techniques for implementing microservices in .NET but focused mainly on worker microservices, that is, on microservices that perform background jobs without communicating with anything outside of the application.</p>
<p class="normal">Microservices that communicate with the world outside of the application bring with them other problems and need further techniques.</p>
<div><p class="normal">More specifically, microservices that communicate with a human user must implement a presentation layer, while microservices that expose APIs must conform to well-established standards and should preferably have documentation. Moreover, web APIs that target <strong class="keyWord">single-page applications</strong> (<strong class="keyWord">SPAs</strong>) must conform with browser policies; that is, either they are exposed on a single domain that is the same domain the SPA was downloaded from, or they must configure CORS policies. We will see how to address both CORS and issues due to browser policies in <em class="italic">Chapter 19</em>, <em class="italic">Client Frameworks: Blazor</em>.</p>
</div>
<p class="normal">Worth mentioning also are all the challenges brought by any presentation layer, that is, ensuring a fast and effective interaction with the user and managing the state of the interaction with the user with maintainable code without falling into spaghetti code. General usability problems and solutions were discussed in <em class="italic">Chapter 2, Non-Functional Requirements</em>. We will discuss more technology-specific usability and status management problems in this chapter and in <em class="italic">Chapter 19</em>, <em class="italic">Client Frameworks: Blazor</em>.</p>
<p class="normal">Finally, all front end microservices must put solid security policies in place to defend the application from hackers. Some techniques are common to both front-ends and web APIs and are automatically handled by all major web servers, such as countermeasures against path-transversal attacks and denial of service. Others, instead, are specific to HTML pages, such as forgery. ASP.NET Core MVC defenses against forgery are discussed in the <em class="italic">Chapter 21,</em> <em class="italic">Case study</em>.</p>
<p class="normal">Techniques for implementing public self-documented web APIs were described in <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>, while techniques for implementing server-based presentation layers were covered in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, and techniques for implementing client-based presentation layers will be covered in <em class="italic">Chapter 19</em>, <em class="italic">Client Frameworks: Blazor</em>. Moreover, general techniques for implementing microservices were covered in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, <em class="italic">Chapter 7</em>, <em class="italic">Understanding the Different Domains in Software Solutions</em>, and <em class="italic">Chapter 14</em>, <em class="italic">Implementing Microservices with .NET</em>.</p>
<p class="normal">Therefore, in this chapter, after a short section about concepts and techniques specific to front-end microservices, we will show you how to put all these concepts and techniques together in the practical implementation of a front-end microservice. More specifically, we will discuss various implementation options and how to architect the whole layer structure of a front-end microservice. A complete example that shows how all layers of a front-end microservice work together, in practice, is described in the <em class="italic">A frontend microservice</em> section of <em class="italic">Chapter 21, Case Study</em>.</p>
<p class="normal">More specifically, this chapter covers the following topics:</p>
<ul>
<li class="bulletList">Front-ends and micro-frontends</li>
<li class="bulletList">Defining the domain layer interface</li>
<li class="bulletList">Defining the domain layer implementation</li>
<li class="bulletList">Defining the application layer</li>
<li class="bulletList">Defining controllers</li>
</ul>
<p class="normal">We will use the onion architecture and the patterns described in <em class="italic">Chapter 7</em>, <em class="italic">Understanding the Different Domains in Software Solutions</em>.</p>
<h1 class="heading-1" id="_idParaDest-364">Technical requirements</h1>
<p class="normal">This chapter requires the free Visual Studio 2022 Community edition or better with all database tools installed.</p>
<p class="normal">The code samples necessary to clarify the concepts in this chapter will be taken from a practical example application based on the <code class="inlineCode">WWTravelClub</code> book use case. The full example application is described in detail in the <em class="italic">A front end microservice</em> section of <em class="italic">Chapter 21, Case Study</em>. Its code is available at <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>.</p>
<h1 class="heading-1" id="_idParaDest-365">Front-ends and micro-frontends</h1>
<p class="normal">The main peculiarity of front-end microservices is that they need a robust web server that is able to optimize all <a id="_idIndexMarker1274"/>the request/response handling and ensure the needed level of security. Moreover, high-traffic applications also need a load balancer.</p>
<p class="normal">Examples of <a id="_idIndexMarker1275"/>services offered by robust web servers like IIS, Apache, and NGINX are:</p>
<ul>
<li class="bulletList">Limiting access to just some file types and directories to prevent access to private files and to prevent remote file execution; that is, execution of server commands/scripts through web requests.</li>
<li class="bulletList">Blocking dangerous requests that might cause access to unwanted files or directories (path-traversal attacks).</li>
<li class="bulletList">Blocking requests that exceed a customizable length since they might cause a denial of service.</li>
<li class="bulletList">Logging and IP address blocking to discover and contrast hacker attacks.</li>
<li class="bulletList">Redirecting requests to the application associated with each URL.</li>
<li class="bulletList">Queueing requests and assigning them to available threads. This capability is fundamental for performance optimization since executing too many requests compared to the available processor cores might cause unacceptable performance.</li>
<li class="bulletList">Ensuring the isolation of applications running on the same process but in different threads and more.</li>
</ul>
<p class="normal">If the front-end service is hosted on a Kubernetes cluster, both an adequate web server and load balancing can be provided <a id="_idIndexMarker1276"/>through an <strong class="keyWord">Ingress</strong>.</p>
<p class="normal">Otherwise, <strong class="keyWord">Azure App Service</strong> (see the <em class="italic">Further reading</em> section) might be a good option since it offers a scalable level <a id="_idIndexMarker1277"/>of load balancing, excellent security, monitoring services, and so on.</p>
<p class="normal">A front-end <a id="_idIndexMarker1278"/>microservice doesn’t need to interface directly with anything outside of an application. In fact, in micro-frontend architectures, there is no unique front-end, but the role of the front-end is split among several microservices. In these architectures, typically, the role of directing traffic toward the right front-end and/or of combining several responses into a unique response is taken by an interface front-end that is load-balanced and carries the burden of ensuring the right level of security.</p>
<p class="normal">The reasons for <a id="_idIndexMarker1279"/>using micro-frontends are the same as the ones for using other microservices. We discussed them in detail in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, but it is worth repeating the more important ones here:</p>
<ul>
<li class="bulletList">Optimizing the usage of hardware resources by scaling just the microservices that need more resources</li>
<li class="bulletList">Having independent software lifecycles for each microservice, so each microservice can evolve independently from the others to match the user needs and so that each microservices developer team can work independently from the others</li>
</ul>
<p class="normal">Micro-frontend architectures use quite different techniques for HTML websites, like ASP.NET Core MVC websites, and for web APIs. Actually, the word “micro-frontend” is used just with HTML websites/SPAs, while web APIs exposed to the outside world are referred to as public web APIs. We will describe public web APIs and HTML micro-frontends and the techniques they use in two dedicated subsections, starting with public web APIs.</p>
<h2 class="heading-2" id="_idParaDest-366">Public web APIs</h2>
<p class="normal">In the case <a id="_idIndexMarker1280"/>of web APIs, all microservices are accessible through a unique load-balanced piece of software called an <strong class="keyWord">API gateway</strong> that sits <a id="_idIndexMarker1281"/>in between the clients and the various API services. The basic role of an API gateway is to make the whole API accessible from a unique domain to both avoid problems with the browser’s unique domain policy and make the usage of all API services simpler.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_18_01.png"/></figure>
<p class="packt_figref">Figure 18.1: API gateway</p>
<p class="normal">However, the API gateway <a id="_idIndexMarker1282"/>offers the opportunity to centralize other functions that are common to all API services, such as:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Authentication</strong>, that is, validating and decoding the authentication token that comes with each request (please do not confuse authentication with login).</li>
<li class="bulletList"><strong class="keyWord">Caching</strong>, that is, caching responses according to configurable caching policies.</li>
<li class="bulletList"><strong class="keyWord">Translation</strong>, that is, adapting the interface, as seen by the client, to the actual signature of the various API methods. This way, each API can change its interface without affecting existing clients.</li>
<li class="bulletList"><strong class="keyWord">Versioning</strong>, that is, directing each request toward a compatible version of each API service.</li>
<li class="bulletList"><strong class="keyWord">Documentation</strong>, that is, offering a unique documentation endpoint.</li>
</ul>
<p class="normal">API gateways <a id="_idIndexMarker1283"/>have continued to evolve, absorbing and offering more and more functions, giving rise to the so-called <strong class="keyWord">API management systems</strong> that now automate and take care of most of the burden of handling public web APIs.</p>
<p class="normal">Azure, like all clouds, offers a good API management service. You can find more information about it here: <a href="https://azure.microsoft.com/en-us/services/api-management/#overview">https://azure.microsoft.com/en-us/services/api-management/#overview</a>.</p>
<p class="normal">It is also <a id="_idIndexMarker1284"/>worth mentioning <strong class="keyWord">Ocelot</strong> (<a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot"</a>), a library for easily creating custom API gateways. You can either use it to fill in configuration files or as a base for a completely custom API gateway.</p>
<p class="normal">Now, we are ready to discuss HTML micro-frontends, which also add the challenge of combining several HTML fragments into a unique HTML page.</p>
<h2 class="heading-2" id="_idParaDest-367">HTML micro-frontends</h2>
<p class="normal">Several HTML micro-frontends can cooperate on the same application by furnishing each with a different set of web pages. In this case, coordinating them requires nothing more than links pointing to the other micro-frontends <a id="_idIndexMarker1285"/>and a common sign-in so that users don’t need to log in each time they move to a different micro-frontend.</p>
<p class="normal">However, very often, several micro-frontends cooperate in the construction of the same page by supplying various page areas. In this case, a software component must take the burden of assembling the various parts into a unique page.</p>
<p class="normal">The main difficulty of combining several HTML fragments into a single HTML page is offering a coherent experience to the user, thus avoiding assembling all page areas in a way that is hard to understand for the user. Another problem is avoiding the continuous page flipping and reorganization each time new content reaches the browser. In what follows, we will discuss how these problems are solved by different technologies.</p>
<p class="normal">In the case of classic web applications that build the HTML on the server side, an interface application furnishes the page layout and then calls the various micro-frontends to fill the various layout areas.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_18_02.png"/></figure>
<p class="packt_figref">Figure 18.2: Server-side micro-frontend</p>
<p class="normal">In this case, there is no browser page flipping and reorganization issue since the whole HTML page is assembled on the server side and sent to the browser only when it is ready. However, we pay for this advantage with the memory consumption for the whole time needed to assemble the whole page before sending it to the browser.</p>
<p class="normal">Both the layout to use and which calls to make to the involved micro-frontends are obtained by processing the request URL according to rules that are either hardwired in the code or, better, stored in one or more configuration sources (in the simplest case, a unique configuration file). Using predefined page patterns ensures coherence and a good user experience, but we pay the cost in maintainability because we need to update and test the interface application at each non-trivial change of any single micro-frontend that furnishes page areas.</p>
<p class="normal">In the case <a id="_idIndexMarker1286"/>of SPAs, the assembly process takes place on the client, that is, in the browser:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">A kernel application furnishes the initial HTML page.</li>
<li class="numberedList">The kernel application downloads a JavaScript file from each micro-frontend. Each of these JavaScript files is a micro-SPA that creates page areas.</li>
<li class="numberedList">The kernel application, based on the current URL, decides which URL to pass to each micro-SPA and then puts the HTML produced by each micro-SPA in the right place.</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_18_03.png"/></figure>
<p class="packt_figref">Figure 18.3: Client-side micro-frontend</p>
<p class="normal">The various <a id="_idIndexMarker1287"/>micro-SPAs do not interfere with each other because each of them runs in a separate JavaScript scope. Therefore, for instance, we can mix micro-SPAs implemented with different and incompatible versions of Angular and/or React.</p>
<p class="normal">Micro-frontends can also be implemented using WebAssembly frameworks like Blazor (see <em class="italic">Chapter 19</em>,<em class="italic"> Client Frameworks: Blazor</em>) that run .NET code. However, in this case, the various micro-SPAs do not run in separate environments, so they must be based on compatible .NET versions.</p>
<p class="normal">SPA micro-frontends have the same maintainability costs as server-based micro-frontends and have browser page flipping and reorganization issues since the page is created dynamically as new content and/or data reach the browser. This problem can be solved by pre-allocating each content area of the browser page with fixed-size HTML tags. Thus, for instance, we may pre-allocate a 300 px X 300 px area to show weather forecasts and some pictures or animation while the actual content is loading.</p>
<p class="normal">In the next section, we will introduce the architectural schema for building a front-end microservice based on ASP.NET Core MVC.</p>
<h1 class="heading-1" id="_idParaDest-368">Defining the application architecture</h1>
<p class="normal">The application will be implemented with the <strong class="keyWord">Domain-Driven Design</strong> (<strong class="keyWord">DDD</strong>) approach and associated patterns <a id="_idIndexMarker1288"/>described in <em class="italic">Chapter 7</em>, <em class="italic">Understanding the Different Domains in Software Solutions</em>, and <em class="italic">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>, so having a <a id="_idIndexMarker1289"/>good understanding of the content covered in those chapters is a fundamental prerequisite to reading this chapter.</p>
<p class="normal">The application is organized based on a DDD approach and uses SOLID principles to map your domain sections. That is, the application is organized into three layers, each implemented as a different project:</p>
<ul>
<li class="bulletList">There’s a domain layer, which contains the repository’s implementation and the classes describing database entities. It is a .NET library project. However, since it needs some interfaces, like <code class="inlineCode">IServiceCollection</code>, which are defined in <code class="inlineCode">Microsoft.NET.Sdk.web</code>, and since the <code class="inlineCode">DBContext</code> layer must inherit from the identity framework in order to also handle the application authentication and authorization database tables, we must add a reference not only to the .NET SDK but also to the ASP.NET Core SDK. However, it is also common to implement custom user management.</li>
<li class="bulletList">There’s also a domain layer abstraction, which contains repository specifications; that is, interfaces that describe repository implementations and DDD aggregates. In our implementation, we decided to implement aggregates by hiding the forbidden operations/properties of root data entities behind interfaces, as discussed in the <em class="italic">How data and domain layers communicate with other layers</em> section of <em class="italic">Chapter 13, Interacting with Data in C# – Entity Framework Core</em>. Hence, for instance, the <code class="inlineCode">Package</code> data layer class, which is an aggregate root, has a corresponding <code class="inlineCode">IPackage</code> interface in the domain layer abstraction that hides all the property setters of the <code class="inlineCode">Package</code> entity. The domain layer abstraction also contains the definitions of all the domain events, while the event handlers that will subscribe to these events are defined in the application layer.</li>
<li class="bulletList">Finally, there’s the application layer – that is, the ASP.NET Core MVC application (ASP.NET Core MVC is discussed in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>) – where we define DDD queries, commands, command handlers, and event handlers. Controllers fill query objects and execute them to get ViewModels they can pass to Views. They update storage by filling command objects and executing their associated command handlers. In turn, command handlers use <code class="inlineCode">IRepository</code> interfaces and <code class="inlineCode">IUnitOfWork</code> instances coming from the domain layer to manage and coordinate transactions.</li>
</ul>
<p class="normal">The application <a id="_idIndexMarker1290"/>uses the <strong class="keyWord">Command Query Responsibility Segregation</strong> (<strong class="keyWord">CQRS</strong>) pattern; therefore, it uses command objects to modify the storage and the query object to query it. CQRS was described in the <em class="italic">Command Query Responsibility Segregation (CQRS) pattern</em> subsection of <em class="italic">Chapter 7, Understanding the Different Domains in Software Solutions.</em></p>
<p class="normal">The query is simple to use and implement: controllers fill their parameters and then call their execution methods. In turn, query objects have direct LINQ implementations that project results directly onto the ViewModels used by the controller Views with <code class="inlineCode">Select</code> LINQ methods. You may also decide to hide the LINQ implementation behind the same repository classes used for the storage update operations, but this would turn the definition and modification of simple queries into very time-consuming tasks.</p>
<p class="normal">In any case, it could be beneficial to encapsulate query objects behind interfaces so that their implementations can be replaced by fake implementations when you test controllers.</p>
<p class="normal">However, the chain of objects and calls involved in the execution of commands is more complex. This is because it requires the construction and modification of aggregates, as well as a definition of the interaction between several aggregates and between aggregates and other applications through domain events to be provided.</p>
<p class="normal">The following diagram is a sketch of how storage update operations are performed. The circles are data being exchanged <a id="_idIndexMarker1291"/>between the various layers, while the rectangles are the procedures that process them. Moreover, dotted arrows connect interfaces with the types that implement them:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_18_04.png"/></figure>
<p class="packt_figref">Figure 18.4: Diagram of command execution</p>
<p class="normal">Here’s the flow of action through <em class="italic">Figure 18.4</em> as a list of steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">A controller’s action method receives one or more ViewModels and performs validation.</li>
<li class="numberedList">One or more ViewModels containing changes to apply are hidden behind interfaces (<code class="inlineCode">IMyUpdate</code>) defined in the domain layer. They are used to fill the properties of a command object. These interfaces must be defined in the domain layer since they will be used as arguments of the repository aggregate methods defined there.</li>
<li class="numberedList">A command handler <a id="_idIndexMarker1292"/>matching the previous command is retrieved via <strong class="keyWord">Dependency Injection</strong> (<strong class="keyWord">DI</strong>) in the controller action method. Then, the handler is executed. During its execution, the handler interacts with various repository interface methods and with the aggregates they return.</li>
<li class="numberedList">When creating the command handler discussed in <em class="italic">step 3</em>, the ASP.NET Core DI engine automatically injects all parameters declared in its constructor. In particular, it injects all <code class="inlineCode">IRepository</code> implementations needed to perform all command handler transactions. The command handler performs its job by calling the methods of these <code class="inlineCode">IRepository</code> implementations received in its constructor to build aggregates and modify the built aggregates. Aggregates either represent already-existing entities or newly created ones. Handlers use the <code class="inlineCode">IUnitOfWork</code> interface contained in each <code class="inlineCode">IRepository</code>, as well as the concurrency exceptions returned by the data layer, to organize their operations as transactions. It is worth pointing out that each aggregate has its own <code class="inlineCode">IRepository</code> and that the whole logic for updating each aggregate is defined in the aggregate itself, not in its associated <code class="inlineCode">IRepository</code>, to keep the code more modular.</li>
<li class="numberedList">Behind the scenes, in the data layer, <code class="inlineCode">IRepository</code> implementations use Entity Framework to perform their job. Aggregates are implemented by root data entities hidden behind interfaces defined in the domain layer, while <code class="inlineCode">IUnitOfWork</code> methods, which handle transactions and pass changes to the database, are implemented with <code class="inlineCode">DbContext</code> methods. In other words, <code class="inlineCode">IUnitOfWork</code> is implemented with the application’s <code class="inlineCode">DbContext</code>.</li>
<li class="numberedList">Domain events are generated during each aggregate processing and are added to the aggregates themselves by calling their <code class="inlineCode">AddDomainEvent</code> methods. However, they are not triggered immediately. Usually, they are triggered at the end of all the aggregates’ processing and before changes are passed <a id="_idIndexMarker1293"/>to the database; however, this is not a general rule.</li>
<li class="numberedList">The application handles errors by throwing exceptions. A more efficient approach would be to define a request-scoped object in the dependency engine, where each application subpart may add its errors as domain events. However, while this approach is more efficient, it increases the complexity of the code and the application development time.</li>
</ol>
<p class="normal">The Visual Studio solution is composed of three projects:</p>
<ul>
<li class="bulletList">There’s a project containing the domain layer abstraction, which is a .NET Standard 2.1 library. When a library doesn’t use features or NuGet packages that are specific to a .NET version, it is a good practice to implement it as a .NET Standard library because this way, it doesn’t need modifications when the application is moved to a newer .NET version.</li>
<li class="bulletList">There’s a project containing the whole data layer, which is a .NET 8.0 library based on Entity Framework.</li>
<li class="bulletList">Finally, there’s an ASP.NET Core MVC 8.0 project that contains both the application and presentation layers. When you define this project, select <strong class="keyWord">No Authentication</strong>; otherwise, the user database will be added directly to the ASP.NET Core MVC project instead of to the database layer. We will add the user database manually in the data layer.</li>
</ul>
<p class="normal">In the remaining sections, we will describe the implementation of each layer that composes the architecture described so far, starting with domain layer abstraction.</p>
<h1 class="heading-1" id="_idParaDest-369">Defining the domain layer interface</h1>
<p class="normal">Once the <code class="inlineCode">PackagesManagementDomain</code> Standard 2.1 library project has been added to the solution, we’ll add a <code class="inlineCode">Tools</code> folder to the project root. Then, we’ll place all the <code class="inlineCode">DomainLayer</code> tools contained in the code associated with <code class="inlineCode">ch7</code>. Since the <a id="_idIndexMarker1294"/>code contained in this folder uses data annotations and defines DI extension methods, we must also add references to the <code class="inlineCode">System.ComponentModel.Annotations</code> and<code class="inlineCode"> Microsoft.Extensions.DependencyInjection.Abstration</code> NuGet packages.</p>
<p class="normal">Then, we need an <code class="inlineCode">Aggregates</code> folder containing all the aggregate definitions (which, as already said, we will implement as interfaces).</p>
<p class="normal">Below is an example of an aggregate definition:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IPackage : IEntity&lt;int&gt;
{
    void FullUpdate(IPackageFullEditDTO packageDTO);
    string Name { get; set; }
    string Description { get;}
    decimal Price { get; set; }
    int DurationInDays { get; }
    DateTime? StartValidityDate { get;}
    DateTime? EndValidityDate { get; }
    int DestinationId { get; }
       
}
</code></pre>
<p class="normal">It contains the <a id="_idIndexMarker1295"/>same properties as the <code class="inlineCode">Package</code> entity, which we saw in <em class="italic">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>. The only differences are the following:</p>
<ul>
<li class="bulletList">It inherits from <code class="inlineCode">IEntity&lt;int&gt;</code>, which furnishes all basic functionalities of aggregates</li>
<li class="bulletList">It has no <code class="inlineCode">Id</code> property since it is inherited from <code class="inlineCode">IEntity&lt;int&gt;</code></li>
<li class="bulletList">All properties are read-only, and it has a <code class="inlineCode">FullUpdate</code> method since all aggregates can only be modified through update operations defined in the user domain (in our case, the <code class="inlineCode">FullUpdate</code> method)</li>
</ul>
<p class="normal">Now, let’s also add a <code class="inlineCode">DTOs</code> folder. Here, we place all interfaces used to pass updates to the aggregates. Such interfaces are implemented by the application layer ViewModels used to define such updates. In our case, it contains <code class="inlineCode">IPackageFullEditDTO</code>, which we can use to update existing packages.</p>
<p class="normal">An <code class="inlineCode">IRepositories</code> folder contains all repository specifications; the following is an example repository interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IPackageRepository:
        IRepository&lt;IPackage&gt;
{
    Task&lt;IPackage&gt; Get(int id);
    IPackage New();
    Task&lt;IPackage&gt; Delete(int id);
}
</code></pre>
<p class="normal">Repositories always contain just a few methods since all business logic should be represented as aggregate methods – in our case, just the methods to create a new package, retrieve an existing package, and delete an existing package. The logic to modify an existing package is included in the <code class="inlineCode">FullUpdate</code> method of <code class="inlineCode">IPackage</code>.</p>
<p class="normal">Finally, we also have an event folder containing all domain event definitions. We can name this folder <code class="inlineCode">Events</code>. Events are triggered whenever a change to an aggregate has consequences either on other aggregates or on other microservices. They are a way to implement weak interactions between aggregates and microservices while keeping the code of aggregates independent of each other.</p>
<p class="normal">By using events, we may keep the code of each aggregate substantially independent of the code of other aggregates that are involved in the same database transactions: each aggregate generates events that might interest other aggregates, such as a price change in a touristic package aggregate, and all other aggregates that depend on this price subscribe to that event, so they can update their data coherently. This way, when a new aggregate that depends on the tourist package price is added during system maintenance, we don’t need to modify the tourist package aggregate.</p>
<p class="normal">When the event might also interest other microservices, the event is also passed to a message broker, which makes <a id="_idIndexMarker1296"/>the event also available for subscription to code in other microservices. Message brokers were discussed in <em class="italic">Chapter 14</em>, <em class="italic">Implementing Microservices with .NET</em>.</p>
<p class="normal">Below is an example event definition:</p>
<pre class="programlisting code"><code class="hljs-code">public class PackagePriceChangedEvent: IEventNotification
{
    public PackagePriceChangedEvent(int id, decimal price,
 long oldVersion, long newVersion)
    {
            PackageId = id;
            NewPrice = price;
            OldVersion = oldVersion;
            NewVersion = newVersion;
     }
    public int PackageId { get; }
    public decimal NewPrice { get; }
    public long OldVersion { get; }
    public long NewVersion { get; }
}
</code></pre>
<p class="normal">When an aggregate sends all its changes to another microservice, it should have a version property. The microservice that receives the changes uses this version property to apply all changes in the right order. An explicit version number is necessary because changes are sent asynchronously, so the order in which they are received may differ from the order in which they were sent. For this purpose, events that are used to publish changes outside of the application have both <code class="inlineCode">OldVersion</code> (the version before the change) and <code class="inlineCode">NewVersion</code> (the version after the change) properties. Events associated with delete events have no <code class="inlineCode">NewVersion</code> since, after being deleted, an entity can’t store any versions.</p>
<p class="normal">The next subsection explains how all interfaces defined in the domain layer are implemented in the data layer.</p>
<h1 class="heading-1" id="_idParaDest-370">Defining the domain layer implementation</h1>
<p class="normal">The domain layer implementation contains the implementation of all repository interfaces and aggregate <a id="_idIndexMarker1297"/>interfaces defined in the domain layer interface. In the case of .NET 8, it uses Entity Framework Core entities to implement aggregates. Adding a domain layer interface in between the domain layer’s actual implementation and the application layer decouples the application layer from EF and entity-specific details. Moreover, it conforms with the onion architecture, which, in turn, is an advised way to architect microservices.</p>
<p class="normal">The domain layer implementation project should contain references to <code class="inlineCode">Microsoft.AspNetCore.Identity.EntityFrameworkCore</code> and <code class="inlineCode">Microsoft.EntityFrameworkCore.SqlServer</code> NuGet packages, since we are using Entity Framework Core with SQL Server. It references <code class="inlineCode">Microsoft.EntityFrameworkCore.Tools</code> and <code class="inlineCode">Microsoft.EntityFrameworkCore.Design</code>, which is needed to generate database migrations, as explained in the <em class="italic">Entity Framework Core migrations</em> section of <em class="italic">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>.</p>
<p class="normal">We should have a <code class="inlineCode">Models</code> folder that contains all database entities. They are similar to the ones in <em class="italic">Chapter 13</em>. The only differences are as follows:</p>
<ul>
<li class="bulletList">They inherit from <code class="inlineCode">Entity&lt;T&gt;</code>, which contains all the basic features of aggregates. Please note that inheriting from <code class="inlineCode">Entity&lt;T&gt;</code> is only needed for aggregate roots; all other entities must be defined as explained in <em class="italic">Chapter 13</em>.</li>
<li class="bulletList">They have no <code class="inlineCode">Id</code> since it is inherited from <code class="inlineCode">Entity&lt;T&gt;</code>.</li>
<li class="bulletList">Some of them might have an <code class="inlineCode">EntityVersion</code> property decorated with the <code class="inlineCode">[ConcurrencyCheck]</code> attribute. It contains the entity version that is needed to send changes to other microservices. The <code class="inlineCode">ConcurrencyCheck</code> attribute is needed to prevent concurrency errors while updating the entity version. This prevents suffering the performance penalty implied by a transaction.</li>
</ul>
<p class="normal">More specifically, when saving entity changes, if the value of a field marked with the <code class="inlineCode">ConcurrencyCheck</code> attribute is <a id="_idIndexMarker1298"/>different from the one that was read when the entity was loaded in memory, a concurrency exception is thrown to inform the calling method that someone else modified this value after the entity was read, but before we attempted to save its changes. This way, the calling method can repeat the whole operation with the hope that this time, no one will write the same entity in the database during its execution.</p>
<p class="normal">It is worth analyzing an example entity:</p>
<pre class="programlisting code"><code class="hljs-code">public class Package: Entity&lt;int&gt;, IPackage
{
    public void FullUpdate(IPackageFullEditDTO o)
    {
        if (IsTransient())
        {
            Id = o.Id;
            DestinationId = o.DestinationId;
        }
        else
        {
            if (o.Price != this.Price)
                this.AddDomainEvent(new PackagePriceChangedEvent(
                        Id, o.Price, EntityVersion, EntityVersion+1));
        }
        Name = o.Name;
        Description = o.Description;
        Price = o.Price;
        DurationInDays = o.DurationInDays;
        StartValidityDate = o.StartValidityDate;
        EndValidityDate = o.EndValidityDate;
    }
    [MaxLength(128)]
    public string Name { get; set; }
    [MaxLength(128)]
    public string? Description { get; set; }
    public decimal Price { get; set; }
    public int DurationInDays { get; set; }
    public DateTime? StartValidityDate { get; set; }
    public DateTime? EndValidityDate { get; set; }
    public Destination MyDestination { get; set; }
    [ConcurrencyCheck]
    public long EntityVersion{ get; set; }
    public int DestinationId { get; set; }
}
</code></pre>
<p class="normal">The <code class="inlineCode">FullUpdate</code> method is <a id="_idIndexMarker1299"/>the only way to update the <code class="inlineCode">IPackage</code> aggregate. When the price changes, it adds a <code class="inlineCode">PackagePriceChangedEvent</code> to the entity list of events.</p>
<p class="normal"><code class="inlineCode">MainDBContext</code> implements <code class="inlineCode">IUnitOfWork</code>. The following code shows the implementation of all methods that start, rollback, and commit a transaction:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task StartAsync()
{
    await Database.BeginTransactionAsync();
}
public Task CommitAsync()
{
    Database.CommitTransaction();
    return Task.CompletedTask;
}
public Task RollbackAsync()
{
    Database.RollbackTransaction();
    return Task.CompletedTask;
}
</code></pre>
<p class="normal">However, they are rarely used by command classes in a distributed environment. In fact, like distributed transactions, local database-blocking transactions are also avoided because they might block database resources for too much time, which is incompatible with the maximization of traffic typical of microservices-based applications.</p>
<p class="normal">Likely, as already mentioned, all databases support tagging some row fields as <strong class="keyWord">concurrency checks</strong>. In Entity Framework Core, this is done by decorating the entity property corresponding to the field with the <code class="inlineCode">ConcurrencyCheck</code> attribute.</p>
<p class="normal">Concurrency checks detect interferences of another transaction, B, on a record while performing transaction A. This way, we can perform transaction A without blocking any database record or table, and if we detect interference, we abort transaction A and retry it till it succeeds without interference. This technique works well if transactions are very quick and, consequently, interferences are rare.</p>
<p class="normal">More specifically, if during transaction A, the value of the concurrency checks specified by an update operation differs from the one stored in the record being updated, the update is aborted, and a concurrency exception is thrown. The rationale is that another transaction, B, modified the concurrency check, thus interfering with the operation being performed by A.</p>
<p class="normal">Accordingly, the method <a id="_idIndexMarker1300"/>that passes all changes applied to <code class="inlineCode">DbContext</code> to the database performs a check for concurrency exceptions:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task&lt;bool&gt; SaveEntitiesAsync()
{
    try
    {
        return await SaveChangesAsync() &gt; 0;
    }
    catch (DbUpdateConcurrencyException ex)
    {
        foreach (var entry in ex.Entries)
        {
            entry.State = EntityState.Detached;
                        
        }
        throw;
    }
}
</code></pre>
<p class="normal">The preceding implementation just calls the <code class="inlineCode">SaveChangesAsync DbContext</code> context method, which saves all changes to the database, but then it intercepts all concurrency exceptions and detaches all the entities involved in the concurrency error from the context. This way, the next time a command retries the whole failed operation, their updated versions will be reloaded from the database.</p>
<p class="normal">In other words, when the update fails because of the interference of transaction B, we allow the interfering transaction B to complete its process. Then, EF automatically reloads all entities modified by B that contain the value of the concurrency check modified by B. This way, when the operation is retried, if no other transaction interferes, there will be no conflict on the concurrency check.</p>
<p class="normal">The practical usage of concurrency checks is detailed in the <em class="italic">A frontend microservice </em>example of<em class="italic"> Chapter 21</em>, <em class="italic">Case Study</em>.</p>
<p class="normal">All repository implementations are defined in a <code class="inlineCode">Repositories</code> folder to ensure better maintainability.</p>
<p class="normal">Finally, all repositories are automatically discovered and added to the application DI engine, calling the <code class="inlineCode">AddAllRepositories</code> method, which is defined in the DDD tools we added to the domain layer project. More details on how to ensure this method is called when the application starts are given in the example detailed description in the <em class="italic">A frontend microservice</em> section of <em class="italic">Chapter 21, Case Study</em>.</p>
<h1 class="heading-1" id="_idParaDest-371">Defining the application layer</h1>
<p class="normal">The application <a id="_idIndexMarker1301"/>layer contains the definition of all business operations. These business operations use data provided by the user to modify domain layer abstraction aggregates, such as touristic packages. When all business operations involved in the current user request have been performed, an <code class="inlineCode">IUnitOfWork.SaveEntitiesAsync()</code> operation is performed to save all changes to the database.</p>
<p class="normal">As a first step, for simplicity, let’s freeze the application culture to <code class="inlineCode">en-US</code> by adding the following code to the ASP.NET Core pipeline:</p>
<pre class="programlisting code"><code class="hljs-code">app.UseAuthorization();
// Code to add: configure the Localization middleware
var ci = new CultureInfo("en-US");
app.UseRequestLocalization(new RequestLocalizationOptions
{
    DefaultRequestCulture = new RequestCulture(ci),
    SupportedCultures = new List&lt;CultureInfo&gt;
    {
        ci,
    },
     SupportedUICultures = new List&lt;CultureInfo&gt;
    {
        ci,
    }
});
</code></pre>
<p class="normal">As a second step, we can create a <code class="inlineCode">Tools</code> folder to place the <code class="inlineCode">ApplicationLayer</code> code, which you can find in the <code class="inlineCode">ch7</code> code of <a id="_idIndexMarker1302"/>the GitHub repository associated with this book. With these tools in place, in <code class="inlineCode">Program.cs</code>, we can add the code that automatically discovers and adds all queries, command handlers, and event handlers to the DI engine, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">...
...
builder.Services.AddAllQueries(this.GetType().Assembly);
builder.Services.AddAllCommandHandlers(this.GetType().Assembly);
builder.Services.AddAllEventHandlers(this.GetType().Assembly);
</code></pre>
<p class="normal">Then, we must add a <code class="inlineCode">Queries</code> folder to place all queries and their associated interfaces. As an example, let’s have a look at the query that lists all packages:</p>
<pre class="programlisting code"><code class="hljs-code">public class PackagesListQuery:IPackagesListQuery
{
    private readonly MainDbContext ctx;
    public PackagesListQuery(MainDbContext ctx)
    {
        this.ctx = ctx;
    }
    public async Task&lt;IReadOnlyCollection&lt;PackageInfosViewModel&gt;&gt; GetAllPackages()
    {
        return await ctx.Packages.Select(m =&gt; new PackageInfosViewModel
        {
            StartValidityDate = m.StartValidityDate,
            ...
        })
            .OrderByDescending(m=&gt; m.EndValidityDate)
            .ToListAsync();
    }
}
</code></pre>
<p class="normal">The query object is automatically injected into the application DB context. The <code class="inlineCode">GetAllPackages</code> method uses LINQ to project all of the required information into <code class="inlineCode">PackageInfosViewModel</code> and sorts all results in descending order on the <code class="inlineCode">EndValidityDate</code> property.</p>
<p class="normal">The <code class="inlineCode">Commands</code> folder contains all commands. As an example, let’s have a look at the command used to modify packages:</p>
<pre class="programlisting code"><code class="hljs-code">public class UpdatePackageCommand: ICommand
{
    public UpdatePackageCommand(IPackageFullEditDTO updates)
    {
        Updates = updates;
    }
    public IPackageFullEditDTO Updates { get; private set; }
}
</code></pre>
<p class="normal">Command handlers <a id="_idIndexMarker1303"/>can be placed in the <code class="inlineCode">Handlers</code> folder. It is worth analyzing the command that updates packages:</p>
<pre class="programlisting code"><code class="hljs-code">private readonly IPackageRepository repo;
private readonly IEventMediator mediator;
public UpdatePackageCommandHandler(IPackageRepository repo, IEventMediator mediator)
{
    this.repo = repo;
    this.mediator = mediator;
}
</code></pre>
<p class="normal">Its constructor has automatically injected the <code class="inlineCode">IPackageRepository</code> repository and an <code class="inlineCode">IEventMediator</code> instance needed to trigger event handlers. The following code also shows the implementation of the standard <code class="inlineCode">HandleAsync</code> command handler method:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task HandleAsync(UpdatePackageCommand command)
{
    bool done = false;
    IPackage model;
    while (!done)
    {
        try
        {
            model = await repo.Get(command.Updates.Id);
            if (model == null) return;
            model.FullUpdate(command.Updates);
            await mediator.TriggerEvents(model.DomainEvents);
            await repo.UnitOfWork.SaveEntitiesAsync();
            done = true;
        }
        catch (DbUpdateConcurrencyException)
        {
          // add some logging here
        }
    }
}
</code></pre>
<p class="normal">Command operations are repeated until no concurrency exception is returned. <code class="inlineCode">HandleAsync</code> uses the repository to get an instance of the entity to modify. If the entity is not found (it has been deleted), the commands stop its execution. Otherwise, all changes are passed to the retrieved aggregate. Immediately after the update, all events contained in the aggregate are triggered. In particular, if the price has changed, the event handler associated with the price change is executed. The concurrency check declared with the <code class="inlineCode">[ConcurrencyCheck]</code> attribute on the <code class="inlineCode">EntityVersion</code> property of the <code class="inlineCode">Package</code> entity ensures <a id="_idIndexMarker1304"/>that the package version is updated properly (by incrementing its previous version number by 1), as well as that the price-changed event is passed the right version numbers.</p>
<p class="normal">Also, event handlers are placed in the <code class="inlineCode">Handlers</code> folder. As an example, let’s have a look at the price-changed event handler:</p>
<pre class="programlisting code"><code class="hljs-code">public class PackagePriceChangedEventHandler :
    IEventHandler&lt;PackagePriceChangedEvent&gt;
{
    private readonly IPackageEventRepository repo;
    public PackagePriceChangedEventHandler(IPackageEventRepository repo)
    {
        this.repo = repo;
    }
    public Task HandleAsync(PackagePriceChangedEvent ev)
    {
        repo.New(PackageEventType.CostChanged, ev.PackageId,
            ev.OldVersion, ev.NewVersion, ev.NewPrice);
      return Task.CompletedTask;
    }
}
</code></pre>
<p class="normal">The constructor has automatically injected the <code class="inlineCode">IPackageEventRepository</code> repository, which handles the database table and all the events to send to other applications. The <code class="inlineCode">HandleAsync</code> implementation simply calls the repository method that adds a new record to this table.</p>
<p class="normal">All records in the table are handled by <code class="inlineCode">IPackageEventRepository</code>, which can be retrieved and sent to all interested microservices by a parallel task defined in the DI engine with a call such as <code class="inlineCode">builder.Services.AddHostedService&lt;MyHostedService&gt;();</code>, as detailed in the <em class="italic">Using generic hosts</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>. However, this parallel task is not implemented in the GitHub code associated with this chapter.</p>
<p class="normal">It is worth recalling that the usage of events promotes code decoupling, and when events cross the microservice boundary, they implement efficient asynchronous communication between microservices, which improves performance and maximizes hardware resource usage.</p>
<p class="normal">The next subsection describes how to define controllers.</p>
<h1 class="heading-1" id="_idParaDest-372">Defining controllers</h1>
<p class="normal">Each controller <a id="_idIndexMarker1305"/>interacts with a use case that emerged in the analysis stage with its action methods. Action methods do their job by requiring command handlers and query interfaces from the dependency injection engine.</p>
<p class="normal">Below is an example of how query objects are required and used:</p>
<pre class="programlisting code"><code class="hljs-code">[HttpGet]
public async Task&lt;IActionResult&gt; Index(
    [FromServices] IPackagesListQuery query)
{
    var results = await query.GetAllPackages();
    var vm = new PackagesListViewModel { Items = results };
    return View(vm);
}
</code></pre>
<p class="normal">Below, instead, is an <a id="_idIndexMarker1306"/>example of the usage of command handlers:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task&lt;IActionResult&gt; Edit(
    PackageFullEditViewModel vm,
    [FromServices] ICommandHandler&lt;UpdatePackageCommand&gt; command)
{
    if (ModelState.IsValid)
    {
        await command.HandleAsync(new UpdatePackageCommand(vm));
        return RedirectToAction(
            nameof(ManagePackagesController.Index));
    }
    else
return View(vm);
}
</code></pre>
<p class="normal"><code class="inlineCode">ICommandHandler&lt;UpdatePackageCommand&gt;</code> retrieves the command handler associated with the <code class="inlineCode">UpdatePackageCommand</code> command from DI.</p>
<p class="normal">If <code class="inlineCode">ModelState</code> is valid, <code class="inlineCode">UpdatePackageCommand</code> is created, and its associated handler is invoked; otherwise, the View is displayed again to the user to enable them to correct all the errors.</p>
<h1 class="heading-1" id="_idParaDest-373">Summary</h1>
<p class="normal">In this chapter, we analyzed the peculiarities of front-end microservices and the techniques used to implement them.</p>
<p class="normal">Then, we put together the techniques learned in this chapter and in previous chapters in the complete implementation of a front-end microservice.</p>
<p class="normal">We used an onion architecture with a data layer and a domain layer abstraction, and we implemented each as a separate project. The application layer and the presentation layer were implemented together in the same ASP.NET Core MVC project.</p>
<p class="normal">The microservice used the CQRS pattern and used a queue implemented with a database table to store the events to send to other microservices.</p>
<p class="normal">The next chapter explains how to implement a presentation layer with client-based techniques. We will use Blazor as an example client framework.</p>
<h1 class="heading-1" id="_idParaDest-374">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">What is the difference between a front-end and an API gateway?</li>
<li class="numberedList">Why should all front-ends and API gateways use a robust web server?</li>
<li class="numberedList">Why should complex blocking database transactions be avoided?</li>
<li class="numberedList">When does the concurrency technique ensure a better performance?</li>
<li class="numberedList">What is the advantage of using domain events to implement interactions between different aggregates?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-375">Further reading</h1>
<p class="normal">Since this chapter just put into practice concepts explained in other chapters (mainly <em class="italic">Chapter 7</em>, <em class="italic">Understanding the Different Domains in Software Solutions</em>, <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, and <em class="italic">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>), here we will include just a few links on how to use API gateways and further information on the MediatR library, which was mentioned in the example:</p>
<ul>
<li class="bulletList">Ocelot GitHub repository: <a href="https://github.com/ThreeMammals/Ocelot">https://github.com/ThreeMammals/Ocelot</a></li>
<li class="bulletList">How to implement your API gateway with Ocelot: <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot</a></li>
<li class="bulletList">Azure API Management: <a href="https://azure.microsoft.com/en-us/services/api-management/#overview ">https://azure.microsoft.com/en-us/services/api-management/#overview</a></li>
<li class="bulletList">Azure App Service: <a href="https://azure.microsoft.com/en-us/services/app-service/">https://azure.microsoft.com/en-us/services/app-service/</a></li>
<li class="bulletList">More information on MediatR can be found on MediatR’s GitHub repository: <a href="https://github.com/jbogard/MediatR">https://github.com/jbogard/MediatR</a></li>
</ul>
<h1 class="heading-1">Leave a review!</h1>
<p class="normal">Enjoying this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 20% discount code.</p>
<p class="normal"><img alt="" role="presentation" src="img/Leave_a_review_QR.png"/></p>
<p class="normal"><em class="italic">*Limited Offer</em></p>
</div>
</body></html>