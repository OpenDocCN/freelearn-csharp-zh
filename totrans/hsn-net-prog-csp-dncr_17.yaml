- en: Transport Layer Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层安全性
- en: Now that we've seen how network interactions are executed down to the lowest
    level, we need to understand how those interactions can be secured for users.
    One of the most fundamental aspects of the public Internet is the ability to secure
    certain interactions between two hosts. In this chapter, we'll explore how that's
    done. We'll start by looking at the underlying security mechanisms that supported
    the original **Secure Sockets Layer** (**SSL**), which was the standard for secured
    network interactions for decades. Then, we'll take a close look at its successor,
    **Transport Layer Security** (**TLS**), and consider some of the reasons for the
    transition. Finally, we'll see how both of these mechanisms are intended to provide
    secure interactions between network hosts by implementing our own simulation of
    the protocol. In doing so, we'll also see how we can leverage TLS and network
    security, right out of the box, with .NET Core.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了网络交互是如何在最低级别执行的，我们需要了解这些交互如何为用户提供安全保障。公共互联网最基本的一个方面就是能够在两个主机之间安全地执行某些交互。在本章中，我们将探讨这是如何实现的。我们将从查看支持原始**安全套接字层**（**SSL**）的底层安全机制开始，这是数十年来安全网络交互的标准。然后，我们将仔细研究其继任者**传输层安全性**（**TLS**），并考虑一些过渡的原因。最后，我们将看到这两种机制是如何通过实现我们自己的协议模拟来为网络主机提供安全交互的。在这个过程中，我们还将看到如何利用TLS和网络安全性，直接在.NET
    Core中实现。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主题：
- en: The level of data integrity and session privacy users should expect when an
    application leverages TLS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序利用TLS时，用户应该期望的数据完整性和会话隐私水平
- en: Why SSL is being deprecated, and what TLS does to support secure connections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么SSL正在被弃用，以及TLS是如何支持安全连接的
- en: Understanding how to leverage the out-of-the-box capabilities of .NET Core to
    support TLS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何利用.NET Core的即用功能来支持TLS
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll be writing sample software that configures and leverages
    both SSL and TLS from a Web API application. You'll need your .NET Core IDE or
    code editor of choice, and you can access the sample code here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    13](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2013).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写示例软件，从Web API应用程序配置和利用SSL和TLS。你需要你的.NET Core IDE或你选择的代码编辑器，并且你可以在这里访问示例代码：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2013](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2013)。
- en: Check out the following video to see the code in action: [http://bit.ly/2HY63Ty](http://bit.ly/2HY63Ty)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HY63Ty](http://bit.ly/2HY63Ty)
- en: Private connections and SSL
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私人连接和SSL
- en: The moment the Internet began supporting something as simple as real-time chat,
    or even email, the need for a secure connection between two network hosts became
    apparent. Imagine sending a confidential message to a friend of yours without
    being able to make any reasonable assumption that your message would remain private.
    Certainly, you would restrict your online interactions to only the most mundane
    of tasks and messages. And that's only considering our intuitive desire for privacy
    in personal matters. That says nothing for the need to protect private, personally
    identifying information that could be used by a malicious actor to commit fraud.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当互联网开始支持像实时聊天或电子邮件这样简单的东西时，两个网络主机之间建立安全连接的需求就变得明显了。想象一下，如果你无法合理地假设你的消息会保持私密，向你的朋友发送一个机密信息。当然，你只会将在线交互限制在最为平凡的任务和消息上。而且这仅仅考虑了我们对于个人事务隐私的直观需求。对于保护可能被恶意行为者用来进行欺诈的私人、个人识别信息的需求，更是不言而喻。
- en: Without some measure of security in our online interactions, no one would dream
    of doing anything as critical as banking, accessing medical information, or paying
    our taxes. Indeed, tasks that seem so basic and fundamental to a modern user of
    the Internet would be unthinkable without some measure of protection from malicious
    third parties. It's precisely these scenarios that secure connections are designed
    to facilitate. But have you ever wondered how they work? Have you ever considered
    what that lock icon in your Chrome address bar means?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的在线交互中没有一定的安全措施，没有人会梦想进行像银行、访问医疗信息或支付税款这样关键的事情。确实，对现代互联网用户来说，这些看似基本和根本的任务如果没有来自恶意第三方的某种保护，将是不可想象的。正是这些场景使得安全连接被设计出来以促进。但你有没有想过它们是如何工作的？你有没有考虑过Chrome地址栏中的那个锁形图标意味着什么？
- en: That's what we'll be exploring in this section. We'll see what first prompted
    the need for a secure interaction mechanism between network hosts. Then, we'll
    look at how that secure interaction is secured. We'll find out how your browser
    knows how to warn you of potentially insecure connections, and how we can provide
    that level of security for our own users. Finally, we'll learn what SSL is and
    how to leverage it in our own software to provide peace of mind for our own consumers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中探讨这个问题。我们将了解最初为什么需要网络主机之间的安全交互机制。然后，我们将看看如何确保这种安全交互的安全性。我们将弄清楚你的浏览器是如何知道如何警告你潜在的不安全连接，以及我们如何为我们自己的用户提供这种级别的安全性。最后，我们将了解SSL是什么，以及如何在我们的软件中利用它为我们自己的消费者提供安心。
- en: Establishing secure connections
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立安全连接
- en: If you've ever followed a link to a website and had your browser first warn
    you that you were about to enter an insecure connection, you may have wondered
    why and how that warning was generated. The answer is that your browser detected
    an attempt to establish a connection using the SSL standard. SSL is a universally
    agreed standard for establishing an encrypted link between a remote server and
    its client.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经点击链接访问网站，浏览器首先警告你即将进入一个不安全的连接，你可能想知道为什么以及如何生成这个警告。答案是，你的浏览器检测到尝试使用SSL标准建立连接的尝试。SSL是建立远程服务器与其客户端之间加密链接的普遍同意的标准。
- en: You might remember from [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml),* HTTP
    in .NET,* that the `https://` schema designation is the schema for Hypertext Transfer
    Protocol Secure. That schema designation is a signal to your browser that the
    content sent back and forth between your machine, and the remote host should be
    encrypted first. When you navigate to a URL with a schema, your browser will first
    try to negotiate a secure connection with the server. Its ability to do so, or
    inability to do so in some cases, is what determines whether or not you are presented
    with a warning prompt prior to rendering the content that's received from the
    server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[第9章](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)，“.NET中的HTTP”，`https://`方案指定是安全超文本传输协议的方案。这个方案指定是向你的浏览器发出信号，表明在机器和远程主机之间来回发送的内容应该首先加密。当你导航到具有方案的URL时，你的浏览器将首先尝试与服务器协商一个安全连接。它是否能做到这一点，或者在某些情况下不能做到这一点，决定了你是否在渲染从服务器接收到的内容之前看到一个警告提示。
- en: When a user, or circumstance, dictates that a secure connection should be used
    (for instance, by specifying HTTPS as the schema in a URI) it's the responsibility
    of the software establishing that connection to ensure that it's secured. This
    means that if you were to write a web browser from scratch (in a lower-level language,
    like C++), your software would be responsible for authenticating the server on
    the receiving end for any https requests your users want to make. So, how is this
    connection established? The primary mechanisms for a well-established secure connection
    are cryptographic translation and third-party authority. Let's take a look at
    third-party authority first, as it's a bit more straightforward than the cryptography
    machinations at work with SSL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户或情况要求使用安全连接（例如，通过在URI中指定HTTPS作为方案）时，建立该连接的软件有责任确保其安全性。这意味着，如果你从头开始编写一个网络浏览器（使用像C++这样的底层语言），你的软件将负责验证用户想要进行的任何https请求的接收端服务器。那么，这个连接是如何建立的？建立良好安全连接的主要机制是加密转换和第三方权威。让我们首先看看第三方权威，因为它比SSL中工作的加密机制更为直接。
- en: Trusted certificate authorities
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信任的证书颁发机构
- en: When a server claims to support a secure connection (historically, via SSL,
    and today, via TLS), the client must have some way of ensuring that the server
    is who it claims to be. Without this identity verification step, it would be very
    simple for malicious actors to invalidate the premise of a secure connection.
    You would simply need to set up a working dummy version of a targeted website
    as a trap. Then, by providing fraudulent links to their malicious site, disguised
    as a link to the legitimate site, they could trick vulnerable users into providing
    access credentials, user information, and more to a malicious dummy interface.
    The whole purpose of HTTPS is to provide users with an assurance that their information
    is being delivered to the entity they intend to deliver it to, in such a way that
    no one can see what they're sending while it's en route.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器声称支持安全连接（历史上通过SSL，今天通过TLS）时，客户端必须有一种方式来确保服务器就是它所声称的那个。如果没有这个身份验证步骤，恶意行为者将很容易使安全连接的前提无效。你只需要设置一个目标网站的模拟版本作为陷阱。然后，通过提供指向恶意网站的欺诈链接，伪装成指向合法网站的链接，他们可以诱骗易受攻击的用户向恶意模拟界面提供访问凭证、用户信息等。HTTPS的全部目的就是向用户提供一种保证，即他们的信息正在以他们期望的方式发送到他们期望的实体，在信息传输过程中，没有人能看到他们发送的内容。
- en: Establishing that a server on the other end of a secure connection is, in fact,
    the entity it is claiming to be is done with authentication certificates, issued
    by a **trusted certificate authority** (**CA**). A CA is an organization or entity
    that will generate, sign, and issue an authentication certificate to any server
    that wants to support interactions over HTTPS or TLS. Specifically, the certificates
    issued by a trusted authority are a cryptographically secure X.509 public key
    certificate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认证证书来确认安全连接另一端的服务器确实是它所声称的实体，这是由**受信任的证书授权机构**（**CA**）发行的。CA是一个组织或实体，它将为任何想要支持通过HTTPS或TLS进行交互的服务器生成、签名和发行认证证书。具体来说，受信任机构发行的证书是加密安全的X.509公钥证书。
- en: This public-key encryption is something we'll see more of shortly, but it's
    basically a one-way security mechanism that allows the owner of a private key
    to validate a freely distributed public key. The public key is generated with
    a combination of the identity of the recipient and the private key, which must
    remain secret for the certificate to remain valid. Then, whenever a client wants
    to validate the identity of the **server**, they take the certificate, along with
    the identity of the server that presented it, directly back to the trusted authority. Using
    their private key, the trusted authority checks the identity and the certificate's
    public key to ensure that it hasn't been tampered with, or fraudulently generated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种公钥加密我们很快就会看到更多，但基本上是一种单向安全机制，允许私钥的所有者验证一个自由分发的公钥。公钥是通过接收者的身份和私钥的组合生成的，私钥必须保持秘密，以便证书保持有效。然后，每当客户端想要验证**服务器**的身份时，他们就会将证书以及展示该证书的服务器身份直接发送回受信任的机构。使用他们的私钥，受信任的机构检查身份和证书的公钥，以确保它没有被篡改或欺诈性地生成。
- en: 'The whole process can be broken down into two key steps. First, the server
    requests and is issued an X.509 certificate from a **trusted certificate authority**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以分解为两个关键步骤。首先，服务器请求并从**受信任的证书授权机构**获得一个X.509证书：
- en: '![](img/b3ad1a40-ddd8-404f-a6f3-5adbcc9906a5.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3ad1a40-ddd8-404f-a6f3-5adbcc9906a5.png)'
- en: 'Then, whenever a client wants to establish a secure connection with the server,
    it must first establish the identity of the server by checking its X.509 certificate
    with the issuing CA:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当客户端想要与服务器建立安全连接时，它必须首先通过检查其X.509证书与发行CA来确认服务器的身份：
- en: '![](img/aa084d55-41d7-42c7-832e-b874c3a928aa.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa084d55-41d7-42c7-832e-b874c3a928aa.png)'
- en: And through this series of round-trips, the server's identity can be assured,
    and the client can, to at least some degree, trust that the secured connection
    is with the intended entity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一系列往返，可以确保服务器的身份，并且客户端至少在一定程度上可以信任所建立的加密连接是与预期的实体。
- en: The basis of trust in certificate authorities
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书授权机构信任的基础
- en: As you've probably already guessed, though, this system of certificate authorities
    has a certain measure of trust baked in at various levels. First, the user must
    trust that their web browser has actually requested a certificate from the remote
    server, and requested authentication from the signing authority. Next, the user
    and the browser must trust that the CA is only authenticating valid certificates
    for valid certificate holders.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可能已经猜到了，这个证书机构的系统在各个层面上都内置了一定程度的信任。首先，用户必须信任他们的网络浏览器确实已经从远程服务器请求了证书，并从签名机构请求了认证。接下来，用户和浏览器必须信任CA只为有效证书持证人认证有效证书。
- en: This may seem obvious, but it's entirely possible that a CA is not as trustworthy
    as you would hope. In 2013, we learned that there were serious violations of basic
    Internet security protocols by government intelligence agencies, including working
    with trusted certificate authorities to generate signed and authenticated certificates
    for invalid holders for the purposes of surveillance and counterintelligence operations.
    Regardless of your personal opinions about the ethical implications of such actions,
    it cannot be argued that by doing so, the agencies responsible severely undermined
    the trust of engineers and the broader public in the validity of a trusted third-party
    security measure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显，但完全有可能认证机构（CA）并不像你希望的那样值得信赖。2013年，我们得知政府情报机构严重违反了基本的互联网安全协议，包括与受信任的证书机构合作，为无效持证人生成已签名和认证的证书，用于监视和反情报行动。无论你对这些行为的道德影响有何个人看法，都无法否认，通过这样做，负责的机构严重破坏了工程师和更广泛公众对受信任第三方安全措施有效性的信任。
- en: So long as the CA can be (reasonably) trusted, though, the certificates that
    are issued and signed by that authority can also, generally, be considered trustworthy.
    And with those certificates and the validation of the trusted authority, the identity
    of the server can be established. Once that step is complete, it's time to secure
    the packets in transit.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要CA可以被（合理地）信赖，那么该机构签发的证书通常也可以被认为是可信的。有了这些证书和受信任机构的验证，就可以确定服务器的身份。一旦这一步骤完成，就需要确保传输中的数据包安全。
- en: Simple and mutual authentication
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单和相互认证
- en: So far, we've only been concerned with validating the identity of the server
    when establishing a secure connection. This is what's called a **simple authentication**
    mechanism**.** The client is given a certificate from the server, and validates
    it with a certificate authority. Provided the certificate is valid, the client
    is permitted to proceed with a secure connection. There's no effort made by the
    server to authenticate the client.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注在建立安全连接时验证服务器的身份。这就是所谓的**简单认证**机制****。客户端从服务器获得一个证书，并使用证书机构进行验证。只要证书有效，客户端就可以继续进行安全连接。服务器没有努力去验证客户端。
- en: However, this pattern could just as easily be applied to the client as well.
    This extension of certificate validation procedures is what's called **mutual
    authentication.** In a mutual authentication scheme, both parties are authenticated
    with their own certificates. This can allow the server to authenticate a user
    without having to request access credentials or authentication information directly
    from the client every time a connection is made.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式同样可以应用于客户端。这种证书验证程序的扩展被称为**相互认证**。在相互认证方案中，双方都使用自己的证书进行认证。这可以允许服务器在每次建立连接时无需直接从客户端请求访问凭证或认证信息来验证用户。
- en: With mutual authentication, the server is still required to deliver an X.509
    certificate that's issued by a trusted authority to any client that wants to establish
    a secure connection. The client is also still responsible for validating that
    certificate with the authority. What's different is how the client's certificate
    is acquired and validated. While a server must allow a third-party authority to
    sign its certificate, the client need not bother. Instead, in most mutual authentication
    scenarios, the server itself signs and issues an X.509 certificate for the client.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在相互认证中，服务器仍然需要向任何想要建立安全连接的客户端提供由受信任机构签发的X.509证书。客户端也仍然需要负责使用该机构验证该证书。不同之处在于客户端证书的获取和验证方式。虽然服务器必须允许第三方机构为其证书签名，但客户端无需麻烦。相反，在大多数相互认证场景中，服务器本身为客户端签名并发起一个X.509证书。
- en: The server will need its own private cryptographic key to generate the public
    key that was issued to the client, but as long as it has that key, it can validate
    any certificates it has issued. In this way, the server can reliably restrict
    access to only those clients it has issued a certificate too. The identity verification
    step is a matter of process, and the owner of the server is responsible for determining
    what constitutes sufficient identity verification prior to issuing a certificate.
    However, once that process is established, it should have every reason to trust
    certificates presented by a client, which it can validate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器需要自己的私钥来生成颁发给客户端的公钥，但只要它拥有这个密钥，它就可以验证它颁发的任何证书。这样，服务器可以可靠地限制只有它颁发证书的客户端才能访问。身份验证步骤是过程问题，服务器所有者负责在颁发证书之前确定什么构成足够的身份验证。然而，一旦这个过程建立，它应该有充分的理由信任客户提供的证书，它可以验证这些证书。
- en: Now, it might not be immediately apparent why a server would require a trusted
    authority to sign its identity certificate, while a client does not. This is because
    of the specific nature of client-server interactions on the internet. In almost
    all cases, a client is responsible for initiating a connection with the server.
    The server, by design, has no prior knowledge of when or from where a given request
    will be received from a given client.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能并不立即明显为什么服务器需要可信权威机构来签署其身份证书，而客户则不需要。这是因为互联网上客户端-服务器交互的特定性质。在几乎所有情况下，客户端负责与服务器建立连接。按照设计，服务器对何时或从何地收到特定客户端的请求没有任何先验知识。
- en: 'For each request, the server must assert its own identity in such a way that
    the client can rely on the assertion. It must be able to do this for any client,
    regardless of whether a prior relationship has been established. There must be
    some way of validating the server''s identity for any given client and any given
    request. So, the job of initially validating, and then subsequently verifying,
    the identity of the server is centralized to an entity all potential clients can
    trust, and use as a single shared resource: the trusted authority.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，服务器必须以客户可以依赖的方式声明自己的身份。它必须能够对任何客户端做到这一点，无论是否已经建立了先前的关系。必须有一种方式来验证服务器对任何特定客户端和任何特定请求的身份。因此，最初验证然后随后验证服务器身份的工作集中在所有潜在客户都可以信任并作为单一共享资源的实体：可信权威机构。
- en: With a client certificate, however, the server can reasonably trust its own
    public key validation, and apply its private key to validate the certificate with
    the client's asserted identity. The encryption mechanism for generating an X.509
    certificate is the same, regardless of whether it's being executed by a server
    or a trusted authority validating the certificate. The only difference is where
    trust is being placed and why.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于客户端证书，服务器可以合理地信任自己的公钥验证，并将自己的私钥应用于验证与客户端声明的身份相符的证书。生成X.509证书的加密机制在服务器或可信权威机构执行证书验证时是相同的。唯一的区别是信任放置的位置和原因。
- en: A client uses third-party authority because, otherwise, how could a client trust
    a certificate signed by a server if the client doesn't know the server's assertions
    can be trusted in the first place? The server doesn't need to use a third-party
    authority, because there is no trust being placed in the client. The server is
    performing its own validation with its own private key. An invalid client certificate
    simply wouldn't pass validation. Thus, a server-issued certificate is sufficient
    to identify the client. So, once a client has installed the certificate on their
    host machine, they can use it to access the server, fully authenticated, and establish
    and leverage secure connections without any additional steps.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 客户使用第三方权威机构，因为否则，如果客户一开始就不知道服务器的声明可以信赖，他们怎么能信任由服务器签发的证书呢？服务器不需要使用第三方权威机构，因为并没有在客户身上建立信任。服务器使用自己的私钥进行自己的验证。无效的客户证书根本无法通过验证。因此，服务器颁发的证书足以识别客户。所以，一旦客户在自己的主机上安装了证书，他们就可以使用它来访问服务器，完全认证，并建立和利用安全连接，无需任何额外步骤。
- en: Encrypting transmitted data
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密传输数据
- en: Once the identity of the server has been established in such a way that the
    client can trust any interaction between the two hosts, the next step is to ensure
    no one else can observe those interactions. To do this, packets must be encrypted
    in transit. However, to leverage an encryption mechanism that both the client
    and the server can use, the specifics must be established beforehand.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式确立了服务器身份，使得客户端可以信任两个主机之间的任何交互，下一步就是确保没有其他人可以观察这些交互。为此，必须在传输过程中加密数据包。然而，为了利用客户端和服务器都可以使用的加密机制，必须事先确定具体细节。
- en: Asymmetric and symmetric cryptography
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称和对称加密
- en: When determining the identity of a server with a signed X.509 certificate, clients
    are using what's called **asymmetric cryptography**. All that means is that there
    is an imbalance between the parties with respect to the distribution of secret
    information that's necessary for the cryptography. Two parties are using the same
    cryptographic scheme, but only one party has access to the secret key. This system
    is necessary for something like a security certificate because some of that information
    must be made publicly available to anyone who asks for it. Remember, by the time
    the certificate is changing hands from a server to a client, a secure connection
    hasn't been established yet. Any malicious parties that want to read that information
    from the packets in transit can do so freely. Asymmetric cryptography schemes
    account for that inevitability and are designed to remain secure, even when the
    public keys are freely distributed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有签名X.509证书的服务器身份时，客户端正在使用所谓的**非对称加密**。这仅仅意味着在各方之间，对于加密所需必要秘密信息的分配上存在不平衡。双方使用相同的加密方案，但只有一方可以访问秘密密钥。这种系统对于像安全证书这样的东西是必要的，因为其中一些信息必须对任何请求的人公开。记住，当证书从服务器传到客户端时，安全连接尚未建立。任何想要从传输中的数据包中读取该信息的恶意方都可以自由地这样做。非对称加密方案考虑到这种不可避免性，并且设计成即使在公钥自由分发的情况下也能保持安全。
- en: Once a secure connection is finally established, however, hosts will leverage
    what's known as **symmetric cryptography**. This is where the secret information
    that's necessary to encrypt and decrypt a message is shared equally (or symmetrically)
    between all parties involved. Both parties in the exchange will have to agree
    upon a secure encryption algorithm for which both hosts have an implementation
    available to leverage. Next, they'll need to agree upon the cryptographic keys
    they will each use with that algorithm to decrypt messages that are encrypted
    by the other party. It's this symmetrical cryptography method that is used by
    two hosts to communicate over a secure transport protocol.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦最终建立了安全连接，主机将利用所知的**对称加密**。这就是加密和解密消息所需的秘密信息在所有相关方之间平等（或对称）共享的地方。交换中的双方都必须就一个双方都有实现可以利用的安全加密算法达成一致。接下来，他们需要就每个将使用该算法与对方加密的消息进行解密的加密密钥达成一致。正是这种对称加密方法被两个主机用于通过安全传输协议进行通信。
- en: Negotiating cryptographic keys
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协商加密密钥
- en: Now, you might have noticed a bit of a chicken and egg problem with using symmetrical
    cryptography to avoid eavesdropping on packets that are transmitted between hosts.
    Specifically, how can you send shared private cryptographic keys that will be
    used to establish a secure connection without firstestablishing a secure connection?
    For that, we have to leverage the same asymmetric cryptography we looked at when
    we were considering how to validate client certificates in a mutual authentication
    setup.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到使用对称加密来避免监听主机之间传输的数据包时存在一点鸡生蛋的问题。具体来说，如何在尚未建立安全连接的情况下发送将被用于建立安全连接的共享私有加密密钥？为此，我们必须利用我们在考虑如何在相互认证设置中验证客户端证书时所考虑的非对称加密。
- en: The first step in establishing a secure connection after validating the identity
    of the server through a CA is to establish the algorithm both parties will use
    for the encryption of packets. There are a number of what are considered secure
    cryptographic algorithms (though there is a number which, for reasons outside
    the scope of this book, were previously considered secure but are not anymore),
    and each of them can be found in the `System.Security.Cryptography` namespace
    of C#. The reason for establishing the algorithm is that it's entirely possible
    that the two hosts don't have implementations of the same set of algorithms, so
    it's important that they identify a mutually implemented algorithm before they
    proceed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过CA验证服务器身份后，建立安全连接的第一步是确定双方将用于加密数据包的算法。存在许多被认为是安全的加密算法（尽管有一些，由于本书范围之外的原因，以前被认为是安全的，但现在不再是这样），它们都可以在C#的`System.Security.Cryptography`命名空间中找到。建立算法的原因是，两个主机可能没有相同算法的实现，因此在他们继续之前，确定一个双方都实现的算法是很重要的。
- en: Once the algorithm is selected, the hosts must exchange a set of unique private
    keys that they'll use for the lifetime of the session to encrypt and decrypt packets.
    To make this exchange, the server first sends a publickey for which only it has
    the private key. Then, the client uses this public key to encrypt a random number,
    and returns the value to the server. At this point, it's perfectly acceptable
    if the packet is intercepted. The relevant information (the random number generated
    by the client) is encrypted, and the public key used for that encryption is useless
    without the private key, which hasn't been transmitted and thus cannot have been
    intercepted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了算法，主机必须交换一组唯一的私钥，这些私钥将在会话期间用于加密和解密数据包。为了进行这种交换，服务器首先发送一个只有它自己拥有的私钥的公钥。然后，客户端使用这个公钥加密一个随机数，并将该值返回给服务器。在这个时候，如果数据包被截获是完全可以接受的。相关信息（客户端生成的随机数）被加密了，用于加密的那个公钥没有私钥就无用了，而私钥尚未传输，因此不可能被截获。
- en: When the server receives the random number generated by the client, it can decrypt
    it using its private key, and then use the number as the initialization value
    for a cryptographic key that will be appropriate for the agreed upon an algorithm
    that will be used throughout the session. The client will have done the same,
    and with that both parties will have established a shared secret without ever
    having to transmit the details of that secret in an insecure way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到客户端生成的随机数时，它可以使用其私钥对其进行解密，然后使用该数字作为初始化值，为整个会话中将要使用的、商定的算法生成一个合适的加密密钥。客户端也会做同样的事情，这样双方就无需以不安全的方式传输该秘密的细节，就能建立一个共享的秘密。
- en: The SSL protocol
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL协议
- en: For years, the standard for implementing secure network connections was what's
    known as the **SSL**. Piggybacking on earlier efforts to develop a secure transport
    mechanism for network interactions, SSL was developed by a company called NetScape
    as a way of establishing a global standard for secure networking. The history
    of SSL as a standard actually serves as an illuminating warning about the nature
    of network security.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，实现安全网络连接的标准是众所周知的**SSL**。NetScape公司利用之前为网络交互开发安全传输机制的早期努力，开发了SSL，作为一种建立全球网络安全标准的方式。SSL作为标准的历史实际上作为了一个关于网络安全性质的启发性的警告。
- en: Security on a network will always be a cat-and-mouse game between hackers and
    security researchers. Every effort that's made to establish a secure algorithm
    for reliable encryption of data will almost always fall prey to an unforeseen
    exploit that renders the algorithm useless as a security measure. This has been
    true of everything, from network security protocols to digital rights management
    applications, to basic OS-level libraries and utilities.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全始终是黑客和安全研究人员之间的一场猫捉老鼠的游戏。为了建立一个可靠加密数据的安全算法而做出的每一项努力，几乎都会成为未预见的漏洞的牺牲品，使得该算法作为安全措施变得无用。这一点在从网络安全协议到数字版权管理应用，再到基本的操作系统级库和工具的各个方面都是如此。
- en: While it's well outside the scope of this book, there's a very interesting bit
    of research being done in the computer science community that could have a major
    impact on the state of security software. It's around a theorem in algorithm analysis
    that, if it is eventually *dis*proved, could simultaneously invalidate every known
    security algorithm in use. If you're curious about it, I recommend researching
    the P=NP Problem. Be prepared for high-level math if you start reading it, but
    also be advised that there is still, at the time of this publishing, a million
    dollar reward for the first person to prove or disprove the theorem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这超出了本书的范围，但在计算机科学界正在进行一项非常有趣的研究，这可能会对安全软件的现状产生重大影响。它围绕算法分析中的一个定理，如果最终被**证伪**，将同时使所有已知的安全算法失效。如果你对此感兴趣，我建议研究
    P=NP 问题。如果你开始阅读它，要做好准备迎接高阶数学，但也要注意，截至本书出版时，仍有百万美元的奖金悬赏给第一个证明或证伪该定理的人。
- en: This constant leapfrogging of secure algorithms and exploits of those algorithms
    is especially true of early versions of SSL. In fact, SSL 1.0 was never even released
    to the public due to glaring security flaws discovered in the protocol during
    testing phases. Instead, SSL 2.0 was released to the public in early 1995\. It
    was barely a year later, however, that the next version, a complete overhaul of
    the protocol, was released as SSL 3.0 in 1996\. This was due to another series
    of major flaws that were quickly discovered by the hacker community that rendered
    SSL 2.0 insufficiently secure for many confidential transactions. Compared to
    its previous iterations, SSL 3.0 enjoyed a relatively long shelf life before a
    successor was finally designed for it again in 1999.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在安全算法和算法漏洞之间的持续跳跃，特别是在 SSL 的早期版本中尤为明显。事实上，SSL 1.0 由于在测试阶段发现协议中存在明显的安全漏洞，从未向公众发布。相反，SSL
    2.0 在 1995 年初向公众发布。然而，仅仅一年后，下一个版本，即对协议的全面改版，于 1996 年作为 SSL 3.0 发布。这是由于黑客社区迅速发现的一系列重大缺陷，使得
    SSL 2.0 对于许多机密交易来说不够安全。与之前的版本相比，SSL 3.0 在其继任者最终于 1999 年被设计出来之前，拥有相对较长的使用寿命。
- en: The somewhat jarring leaps from one version to the next in the SSL lifespan
    were precipitated by flaws in the hashing and encryption algorithms underlying
    each standard. With SSL 2.0, a combination of vulnerable processes in handling
    secure keys, along with flaws in the algorithms that were used to generate those
    keys, added up to a glaringly insecure protocol. It provided no protection for
    the initial handshake, leaving the interaction open to exactly the kind of man-in-the-middle
    attacks we described in the previous section. It used hash algorithms that had
    known collisions (when two different inputs can generate the same hashed output),
    rendering its keys functionally insecure. Finally, quirks in its implementation
    of the CA verification process rendered most consumer-facing websites unable to
    support the protocol in the first place. All of this combined illustrates why
    such a major redesign of the protocol was necessary so quickly for version 3.0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 生命周期中从一个版本到下一个版本的跳跃多少有些令人震惊，这主要是由于每个标准背后的哈希和加密算法中的缺陷所引起的。在 SSL 2.0 中，处理安全密钥的易受攻击的过程以及生成这些密钥所使用的算法中的缺陷，共同构成了一个明显不安全的协议。它没有为初始握手提供保护，使得交互容易受到我们在上一节中描述的中间人攻击。它使用了已知存在冲突的哈希算法（当两个不同的输入可以生成相同的哈希输出时），使得其密钥在功能上不安全。最后，其在
    CA 验证过程中的怪癖使得大多数面向消费者的网站最初都无法支持该协议。所有这些加在一起说明了为什么在 3.0 版本中如此快速地进行协议的重大重新设计是必要的。
- en: The story of SSL 3.0 is a fair bit more successful than its predecessor. While
    some parts of its cryptographic key generation algorithm relied entirely on insecure
    hash functions, it also incorporated the new (at the time, at least) SHA-1 standard.
    This new algorithm had no known hash collisions and thus strengthened the secure
    claim of the new protocol. It also introduced the pattern for CA support that
    is still seen today, enabling wider adoption and support of the protocol by public-facing
    websites.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 3.0 的故事比其前身要成功得多。尽管其加密密钥生成算法的部分内容完全依赖于不安全的哈希函数，但它也引入了当时的新标准 SHA-1。这个新算法没有已知的哈希冲突，从而增强了新协议的安全声明。它还引入了今天仍可见的
    CA 支持模式，使得公共网站能够更广泛地采用和支持该协议。
- en: The 3.0 iteration was not without its flaws, though. Because it still relied,
    at least in part, on a hash algorithm with known collisions, it was not considered
    sufficiently secured for highly critical or classified applications by the US
    government's **Federal Information Processing Standard** (**FIPS**). Furthermore,
    while there were far fewer procedural vulnerabilities in the design of the protocol
    (as opposed to cryptographic vulnerabilities), it was found to be vulnerable to
    a rather sophisticated procedural attack in October 2014\. This vulnerability
    cemented the need for the official deprecation of the standard in 2015\. This
    opened the door for its successor, TLS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然3.0版本并非没有缺陷。因为它至少部分依赖于一个已知碰撞的哈希算法，所以美国政府的**联邦信息处理标准**（**FIPS**）并没有认为它足够安全，适用于高度关键或机密的应用。此外，尽管在协议设计（与加密漏洞相比）中的程序漏洞要少得多，但在2014年10月发现它容易受到一种相当复杂的程序攻击。这种漏洞使得2015年官方废弃该标准成为必要。这为它的继任者TLS敞开了大门。
- en: TLS as the new standard
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS作为新的标准
- en: Currently, the global standard for secure network interactions, TLS, was originally
    developed as an improvement over the then standard SSL protocol back in 1999\.
    While it was designed to be an upgrade to the existing SSL 3.0 protocol, there
    were sufficient differences in the design of each protocol to make interoperability
    between the two schemes infeasible. Instead, the authors released it as the first
    version of a newer, more secure protocol.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，全球安全的网络交互标准TLS最初是在1999年作为对当时标准SSL协议的改进而开发的。虽然它被设计为现有SSL 3.0协议的升级，但每个协议的设计差异足够大，使得两种方案之间的互操作性变得不可行。相反，作者将其作为更新、更安全协议的第一个版本发布。
- en: A minor evolution from SSL
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从SSL的微小演变
- en: When it was introduced, TLS certainly represented an improvement over SSL 3.0\.
    However, the major distinctions were in the header design for the packets exchanged
    during the handshake phase of connection establishment. The underlying algorithms
    and principles remained mostly unchanged. In fact, were it not for the header
    incompatibility, TLS might just as well have been named SSL 4.0 at the time of
    its release.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当TLS被引入时，它确实代表了相对于SSL 3.0的改进。然而，主要的区别在于连接建立握手阶段交换的数据包的头部设计。底层算法和原理基本保持不变。事实上，如果不是因为头部不兼容，TLS在发布时完全可以被命名为SSL
    4.0。
- en: Remember from [Chapter 12](0311281d-9a21-4dd0-a3cd-4e047ced436a.xhtml),* The
    Internet Protocol*, that it was this same header-incompatibility issue that made
    IPv4 and IPv6 interoperability impossible. The ability to parse a standardized
    header is the most fundamental first step of any shared interaction between hosts.
    A mismatch or incompatibility between the headers of two versions of a protocol
    will make that first step impossible, rendering the packets unreadable. This will
    often have the impact of preventing mutual compatibility between versions of a
    protocol with different header definitions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第12章](0311281d-9a21-4dd0-a3cd-4e047ced436a.xhtml)，“互联网协议”中记住，正是这个头部不兼容问题使得IPv4和IPv6的互操作性成为不可能。解析标准化头部是任何主机之间共享交互的最基本第一步。两个版本协议头部之间的不匹配或不兼容将使这一步成为不可能，使得数据包无法读取。这通常会导致具有不同头部定义的协议版本之间相互兼容性受阻。
- en: There were certainly security improvements with TLS, however. The first of which
    was that in TLS, no single part of its cryptographic algorithms relied entirely
    on a hashing algorithm with known collisions. Any key that was generated was always
    done so with at least some inputs from a cryptographically secure hash algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TLS确实有安全性的改进。首先，在TLS中，其加密算法的任何一部分都不完全依赖于一个已知碰撞的哈希算法。任何生成的密钥总是至少使用一些来自加密安全哈希算法的输入。
- en: It also introduced added protection against lost or modified data during the
    handshake phase of a connection attempt. It did this by sending a secure hash
    of every message that was transmitted from both parties during the final step
    of connection negotiation. This way, the client and the server can both check
    the result against their own hashes and validate that each host perceived the
    same interactions, eliminating the possibility of a man-in-the-middle attack modifying
    any part of their exchange. However, this still didn't guarantee that a man-in-the-middle
    attack wasn't successful in attempting to read packets—only that none were successfully
    modified.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它还在连接尝试的手动阶段引入了对丢失或修改数据的额外保护。它是通过在连接协商的最后一步发送每条消息的安全哈希来实现的。这样，客户端和服务器都可以将结果与其自己的哈希值进行比较，并验证每个主机是否感知到相同的交互，从而消除了中间人攻击修改任何交换部分的可能性。然而，这仍然不能保证中间人攻击在尝试读取数据包时没有成功——只是没有成功修改。
- en: Forward secrecy
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向保密
- en: One of the most important features that was introduced by TLS was the notion
    of forward secrecy**.** This is a concept in secured communication where, by using
    a unique session key over the course of each interaction, two hosts can guarantee
    that even if a secret is exposed through some attack, previous interactions will
    remain secure, even if they were recorded and stored by the attacker. This is
    because the unique session key is used as an additional input to the encryption
    mechanism for securing messages. Thus, private keys alone are insufficient to
    decrypt messages previously sent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TLS引入的最重要特性之一是**前向保密**的概念。这是在安全通信中的一个概念，通过在每个交互过程中使用唯一的会话密钥，两个主机可以保证即使某个秘密通过某种攻击被暴露，之前的交互仍然保持安全，即使它们被攻击者记录并存储。这是因为唯一的会话密钥被用作加密机制的一个额外输入，以保护消息。因此，仅凭私钥本身不足以解密之前发送的消息。
- en: For perfect secrecy to work, the session key must be randomly generated via
    a non-deterministic function. For those not aware, in the context of computer
    science, a function is considered non-deterministic if and only if it could return
    two distinct results given the exact same inputs. Typically, this non-determinism
    is achieved by use of a random number generator, and some other temporary external
    state. So, if I had, for example, the `GetNextPrime(startingIndex)` method, then
    we would expect it to be deterministic. For any number, *n, *there is only one
    next prime after it. Every attempt to call the method with `GetNextPrime(n)` would
    result in the same output. Meanwhile, if I had a method called `RollDie(sides)`
    then I would reasonably expect that to be non-deterministic. I could pass in the
    same `sides`, parameter five times and get five completely distinct results. That's
    a non-deterministic algorithm in a nutshell.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现完美的保密，会话密钥必须通过非确定性函数随机生成。对于那些不了解的人来说，在计算机科学的背景下，一个函数被认为是非确定性的，当且仅当它可以在给出相同的输入时返回两个不同的结果。通常，这种非确定性是通过使用随机数生成器和一些其他临时外部状态来实现的。所以，如果我有，例如，`GetNextPrime(startingIndex)`方法，那么我们就会期望它是确定性的。对于任何数字*n*，在它之后只有一个下一个素数。每次尝试使用`GetNextPrime(n)`调用该方法都会产生相同的结果。与此同时，如果我有名为`RollDie(sides)`的方法，那么我合理地期望它是非确定性的。我可以传递相同的`sides`参数五次，并得到五个完全不同的结果。这就是非确定性算法的精髓。
- en: This concept of non-determinism is important when generating a session key because
    it ensures that subsequent attempts to generate the same session key would fail.
    Thus, when an attacker gains access to the private keys of a server, they would
    still be missing a critical component that's necessary to decode messages from
    previous sessions. That missing piece of the puzzle would be much easier to find
    if session keys were persisted beyond the lifetime of the session, though. For
    that reason, it's critical to ensure for forward secrecy that a session key is
    destroyed as soon as a session is terminated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非确定性的概念在生成会话密钥时很重要，因为它确保了后续尝试生成相同的会话密钥将失败。因此，当攻击者获取到服务器的私钥时，他们仍然缺少解码之前会话消息所需的关键组件。如果会话密钥在会话生命周期结束后仍然持续存在，那么这个缺失的拼图碎片将更容易找到。因此，确保前向保密的关键是，一旦会话终止，就销毁会话密钥。
- en: Reliability of secured messages
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密消息的可靠性
- en: The integrity of the data in a packet is critical to its successful delivery
    and decryption by the recipient host. If even one bit is out of place, the value
    of the decrypted message would become wholly unreadable. This property of secure
    encryption that even minor changes in a message will result in drastic changes
    to its encrypted counterpart, and vice versa, which means it is far more difficult
    to recover from errors occurring in transit than with unsecured messages. For
    that reason, TLS leverages what are called **message authentication codes (MACs)**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包中的数据完整性对于其成功交付和解密至关重要。如果即使是一个比特位出现错误，解密消息的值将变得完全不可读。这种安全加密的特性，即消息的微小变化会导致其加密副本发生剧烈变化，反之亦然，这意味着在传输过程中发生错误时，从错误中恢复比不安全消息要困难得多。因此，TLS利用所谓的**消息认证码（MACs）**。
- en: These MACs are used to validate both that the data that's been transmitted has
    not been modified in any way, and that it was sent by the host that the recipient
    is expecting. In TLS, these codes are generated using sequential packet ID numbers
    as an added security measure. This sequential tag provides an additional level
    of verification on a message, thus increasing the complexity of the work a malicious
    actor would have to perform to successfully modify both a payload and its corresponding
    MAC for successful fraudulent packet delivery.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些MACs用于验证已传输的数据是否以任何方式被修改，以及是否由接收者期望的主机发送。在TLS中，这些代码使用顺序包ID号作为额外的安全措施来生成。这个顺序标签为消息提供了额外的验证级别，从而增加了恶意行为者成功修改有效载荷及其相应MAC以成功发送欺诈数据包的复杂性。
- en: This additional security measure, along with the session ID that's used for
    forward secrecy, and the multilayered secure hash algorithms that's used to generate
    shared keys for encryption and decryption provide a robust foundation for TLS,
    and have allowed its reliable use across a small number of versions for nearly
    two decades.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这项额外的安全措施，以及用于前向安全的会话ID，以及用于生成加密和解密共享密钥的多层安全哈希算法，为TLS提供了坚实的基础，并使其在近二十年的时间里在少数几个版本中可靠地使用。
- en: Configuring TLS in .NET Core
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在.NET Core中配置TLS
- en: While we've explored the nature of the interactions between hosts that want
    to establish secure communications in depth, we've kept the discussion to a fairly
    high level so far. There's a reason for this, though. In .NET Core, you'll never
    be coding the specific steps of the TLS protocol directly. As a high-level language
    executed on a portable runtime, .NET Core is not the ideal environment for attempting
    to implement those operations on your own. And, as you have probably already figured
    out, the ASP.NET Core libraries that are used to facilitate low-level socket interactions
    between hosts already implement TLS for us. We just have to know how to configure
    it and enforce its use. So, while the step-by-step interactions of TLS are important for
    any network engineer to understand, the low-level details are well beyond the
    scope of this book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经深入探讨了想要建立安全通信的主机之间的交互性质，但到目前为止，我们的讨论还停留在相当高的层面。这样做是有原因的。在.NET Core中，你永远不会直接编写TLS协议的具体步骤。作为一个在可移植运行时上执行的高级语言，.NET
    Core并不是尝试自行实现这些操作的理想环境。而且，正如你可能已经猜到的，用于在主机之间促进低级套接字交互的ASP.NET Core库已经为我们实现了TLS。我们只需要知道如何配置它并强制其使用。因此，虽然TLS的逐步交互对于任何网络工程师来说都很重要，但低级细节已经远远超出了本书的范围。
- en: For the purposes of this demonstration, though, we'll write a simple Web API
    project that simulatesthe interactions of a TLS handshake. Hopefully, this will
    cement some of the more abstract ideas in your mind by giving them a concrete
    in-code representation. We'll also configure our application to leverage HTTPS
    so that you can see the steps you'll be taking in your own projects to provide
    this feature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个演示中，我们将编写一个简单的Web API项目来模拟TLS握手的交互过程。希望这样能通过在代码中给出具体的表示来巩固你心中的一些更抽象的概念。我们还将配置我们的应用程序以利用HTTPS，这样你就可以看到在你的项目中提供此功能时将采取的步骤。
- en: Enabling HTTPS in .NET Core
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在.NET Core中启用HTTPS
- en: 'The first thing we''ll do is set up our project as a new Web API project using
    the .NET CLI command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是使用.NET CLI命令将我们的项目设置为一个新的Web API项目：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we want to allow clients to interact with our services using TLS. Thankfully,
    to enable this, we don''t actually have to do anything! Astute readers will remember
    that in my previous demo application in [Chapter 9, ](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)*HTTP
    in .NET*, in the *Using launchSettings.json* section, I had you remove the following
    line of code from the `Startup.cs` file of our application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望允许客户端使用TLS与我们服务交互。幸运的是，为了启用这一点，我们实际上并不需要做任何事情！敏锐的读者会记得，在我的上一章演示应用程序中，在[第9章](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)*《.NET中的HTTP》*的*使用launchSettings.json*部分，我让您从我们的应用程序的`Startup.cs`文件中删除了以下代码行：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Well, it turns out that by not removing that, our application's web server will
    respond to any standard HTTP requests with a `307 - Temporary Redirect` status
    code, directing the client to the appropriate port for HTTPS interactions. We
    took that out of our previous demo to simplify our discussion of the specifics
    of HTTP in [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml), *HTTP in .NET*,
    but now let's leave it in and see it in action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，结果证明，如果没有删除这一行，我们的应用程序的Web服务器将使用`307 - Temporary Redirect`状态码响应任何标准的HTTP请求，将客户端重定向到HTTPS交互的适当端口。我们在之前的演示中移除了这一点，以简化我们对[第9章](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)*《.NET中的HTTP》*中HTTP具体讨论，但现在让我们保留它并看看它的实际效果。
- en: 'Simply run your application, and when your default browser opens up, you should
    notice that it''s routed to the `https://localhost:5001/api/values` launch URL
    that is configured for every new Web API project. There''s nothing particularly
    interesting about that, but now open up your browser developer tools, and navigate
    to the tab that displays the request traffic. I''m using Chrome, myself, and can
    access the developer tools by navigating through the settings or simply hitting
    *F12*. Once in the Network tab, there''s an option to preserve the network logs
    for a browser session, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地运行您的应用程序，当您的默认浏览器打开时，您应该会注意到它被路由到为每个新的Web API项目配置的`https://localhost:5001/api/values`启动URL。这没有什么特别有趣的地方，但现在打开您的浏览器开发者工具，导航到显示请求流量的标签页。我自己使用Chrome，可以通过设置导航或简单地按*F12*来访问开发者工具。一旦进入网络标签页，有一个选项可以保留浏览器会话的网络日志，如下面的截图所示：
- en: '![](img/60fb5bfc-5f36-4bbe-8978-66da42249410.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60fb5bfc-5f36-4bbe-8978-66da42249410.png)'
- en: 'After choosing that setting, attempt to navigate directly to the unsecured
    URL for your API at `http://localhost:5000/api/values` and then look at the response
    you get in your Network tab. You should see your browser automatically reload
    the page to the secure URL again, and the following response in your Network tab:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择该设置后，尝试直接导航到您API的不安全URL `http://localhost:5000/api/values`，然后查看您在网络标签页中收到的响应。您应该看到浏览器自动将页面重新加载到安全的URL，并在您的网络标签页中看到以下响应：
- en: '![](img/6f7b00c0-5e87-4ec2-a3e0-82c614aa888f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f7b00c0-5e87-4ec2-a3e0-82c614aa888f.png)'
- en: This is the behavior that your web server provides when you enable HTTPS with
    the `UseHttpsRedirection` middleware configuration. The initial request for the
    unsecured URL was not satisfied, and instead the browser was given a directive
    to use the secured URL. That's what the second line in our log is. It's telling
    us that the navigation to the secured URL (the one that returned a 200 response)
    was initiated by the server when we tried to navigate to the unsecured URL (the
    Initiator field of our log). That's a lot of power and reliability to get from
    a web server without any work on our part!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`UseHttpsRedirection`中间件配置启用HTTPS时，您的Web服务器会提供这种行为。对不安全URL的初始请求没有得到满足，相反，浏览器被赋予了使用安全URL的指令。这就是我们日志中的第二行所告诉我们的。它告诉我们，当我们尝试导航到不安全的URL时（日志中的发起者字段），服务器启动了对安全URL的导航（返回了200响应的那个URL）。这为我们提供了大量的功能和可靠性，而无需我们做任何工作！
- en: Enforcing HTTPS with HSTS
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HSTS强制执行HTTPS
- en: Now, if we want to notify our clients that they should be using HTTPS at all
    times, instead of simply trusting them to follow our redirect messages, we can
    do so by leveraging **HTTP Strict Transport Security** (**HSTS**). This is an
    interaction mechanism whereby a web server can notify any client interacting with
    it over an HTTPS connection that allsubsequent interactions should happen over
    HTTPS. It delivers this notification by way of an HSTS header with a  `Strict-Transport-Security` key
    and some arbitrary value, such as an expiration timestamp, after which the client
    can resume attempts to connect using unsecured URLs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想通知我们的客户他们应该始终使用HTTPS，而不是简单地信任他们遵循我们的重定向消息，我们可以通过利用**HTTP严格传输安全**（**HSTS**）来实现。这是一种交互机制，其中Web服务器可以通知通过HTTPS连接与之交互的任何客户端，所有后续交互都应该通过HTTPS进行。它通过带有`Strict-Transport-Security`键和一些任意值（例如过期时间戳）的HSTS头来传递此通知，在此之后，客户端可以重新尝试使用未加密的URL进行连接。
- en: If the client complies with HSTS, it will respond to the header by updating
    any cached links that hold references to the unsecured URL to now hold references
    to the secured URL. It will also prevent any user interaction with the unsecured
    URL, even when a connection to the secure URL cannot be made.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端遵守HSTS，它将通过更新任何包含对未加密URL引用的缓存链接来响应头，使其现在引用安全的URL。它还将防止任何用户与未加密的URL交互，即使无法建立到安全URL的连接。
- en: 'Now, you might be curious how we can enable this feature in our web server,
    and begin returning that header in our responses. Well, hopefully you won''t be
    surprised that it''s just as simple as enabling HTTPS redirection in the first
    place. If you look inside the conditional `if/else` statement that checks if your
    application is currently running in a development environment, you''ll see the
    following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道我们如何在我们的Web服务器中启用此功能，并在我们的响应中开始返回该头。希望您不会对它和最初启用HTTPS重定向一样简单感到惊讶。如果您查看检查应用程序是否正在开发环境中运行的`if/else`条件语句，您将看到以下内容：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we're already leveraging HSTS. We just can't see as much because
    we're running our application locally using development settings. This is very
    much by design. It's strongly recommended that you don't use HSTS in development
    because the header value and its corresponding expiration are considered highly
    cacheable by browsers. This could make debugging and troubleshooting especially
    difficult during development. On your local environment, the setting isn't even
    available out of the box because the local loopback address is excluded by the
    middleware by default.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经在利用HSTS。但我们看不到这么多，因为我们正在本地使用开发设置运行我们的应用程序。这完全是出于设计考虑。强烈建议您在开发环境中不要使用HSTS，因为浏览器认为其头值及其相应的过期时间被认为是高度可缓存的。这可能会使开发期间的调试和故障排除特别困难。在您的本地环境中，该设置甚至默认不可用，因为中间件默认排除了本地回环地址。
- en: HTTPS port configuration
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS端口配置
- en: It's important to note that the only reason our application successfully redirects
    to our HTTPS URL is because we are listening on a distinct port for incoming HTTPS
    requests by default. The `launchSettings.json` file for a new Web API project
    is always configured to listen on both an HTTP and an HTTPS port. That same port
    is leveraged by the `UseHttpsRedirection` middleware when it's invoked on our
    application. Without configuring an HTTPS port for our application to listen on,
    the redirection middleware will simply fail to resolve, and requests that are
    made of the unsecured HTTP URLs will be processed and responded to accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们的应用程序成功重定向到我们的HTTPS URL的唯一原因是因为我们默认监听一个独立的端口来接收HTTPS请求。新Web API项目的`launchSettings.json`文件始终配置为监听HTTP和HTTPS端口。当在应用程序上调用时，`UseHttpsRedirection`中间件使用相同的端口。如果没有为我们的应用程序配置要监听的HTTPS端口，重定向中间件将无法解析，并且对未加密的HTTP
    URL的请求将被相应地处理和响应。
- en: 'There are a number of ways to configure the port that your middleware should
    redirect users to, but in each case you still have to make sure you''re also configuring
    your web server to listen over that port. This includes registering `HttpsRedirectionOptions`
    in your application''s service resolver, with the following code segment inside
    your `ConfigureServices(IServiceCollection services)` method, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式来配置你的中间件应重定向用户到的端口，但在每种情况下，你仍然需要确保你也配置了你的Web服务器来监听该端口。这包括在你的应用程序的服务解析器中注册`HttpsRedirectionOptions`，在`ConfigureServices(IServiceCollection
    services)`方法中包含以下代码段，如下所示：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can set a secure scheme in the `UseUrls()` method of the
    `IWebHostBuilder` object when you're configuring your web server in your `Program.cs`
    file. This has the added bonus of simultaneously configuring your web server to
    listen on a secure port, while also configuring the `UseHttpsRedirection()` middleware
    to redirect users to it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在配置 `Program.cs` 文件中的 `IWebHostBuilder` 对象的 `UseUrls()` 方法时设置一个安全方案。这还有一个额外的好处，即同时配置您的
    web 服务器在安全端口上监听，同时配置 `UseHttpsRedirection()` 中间件将用户重定向到它。
- en: As you can hopefully see by now, though, the default support for HTTPS and secure
    interactions provided by .NET Core will make your life substantially easier. This
    is especially the case when you have to implement any sort of confidential interactions,
    as we'll be doing in the next chapter when we discuss authentication and authorization
    in web applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如您现在可能希望看到的，.NET Core 提供的 HTTPS 和安全交互的默认支持将使您的生活大大简化。这尤其适用于您必须实现任何类型的机密交互时，正如我们在下一章讨论
    Web 应用程序中的身份验证和授权时将要做的。
- en: Trusting your development certificate
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信任您的开发证书
- en: As we discussed at length in the section of this chapter about CA, any attempt
    to interact with a resource via HTTPS through a typical browser will result in
    a warning if the browser cannot verify the identity of the server with a trusted
    certificate authority. Since our applications will typically be hosted and run
    locally while we're developing and debugging them, we won't have access to a certificate
    signed by a trusted CA. Instead, we'll be using what's called a self-signed certificate.
    This is exactly the kind of certificate I warned you about being untrustworthy,
    since you can't trust the signature of a server until you can trust that you know
    who the server is. However, in this case, where we're developing an application
    locally and testing responses through our browser or REST client, we know *exactly *who
    the server is. It's us!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章关于 CA 的部分详细讨论的那样，任何通过典型浏览器通过 HTTPS 与资源交互的尝试，如果浏览器无法使用受信任的证书颁发机构验证服务器的身份，都会导致警告。由于我们的应用程序在开发和调试期间通常会在本地托管和运行，我们将无法访问由受信任的
    CA 签署的证书。相反，我们将使用所谓的自签名证书。这正是我警告您不要信任的证书类型，因为您无法信任服务器的签名，直到您信任自己知道服务器的身份。然而，在这种情况下，当我们在本地的应用程序中进行开发并通过我们的浏览器或
    REST 客户端测试响应时，我们确切地知道服务器是谁。那就是我们！
- en: 'Since this scenario is common, Microsoft and Windows provide a simple one-time
    mechanism for getting past the untrusted certificate issue when testing HTTPS
    locally. Every time you install the .NET Core SDK, it includes an HTTPS development
    certificate that is issued by your web server whenever it is being hosted by the
    `dotnet` runtime application. To configure your local web browsers and other clients
    to trust this self-signed certificate, you only need to register it with your
    OS using the following CLI command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种场景很常见，Microsoft 和 Windows 提供了一种简单的单次机制，用于在本地测试 HTTPS 时绕过不受信任的证书问题。每次您安装
    .NET Core SDK 时，它都会包含一个 HTTPS 开发证书，该证书由您的 web 服务器在由 `dotnet` 运行时应用程序托管时颁发。要配置您的本地网络浏览器和其他客户端信任此自签名证书，您只需使用以下
    CLI 命令将其注册到您的操作系统：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running this command will add the self-signed certificate that was included
    in your .NET SDK into the trusted root certificates store of your operating system.
    This store is then used by any application that needs to validate that an external
    host is who they claim to be. By storing our development certificate in this store
    with that CLI command, we can eliminate the warnings and alerts from our browsers
    any time we want to test an application that is configured to use HTTPS. And just
    like that, you're all set to leverage TLS within your .NET Core application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令会将包含在您的 .NET SDK 中的自签名证书添加到操作系统的受信任根证书存储中。然后，任何需要验证外部主机身份的应用程序都会使用此存储。通过使用该
    CLI 命令将我们的开发证书存储在此存储中，我们可以在测试配置为使用 HTTPS 的应用程序时消除浏览器中的警告和警报。就这样，您就可以在 .NET Core
    应用程序中利用 TLS 了。
- en: The TLS handshake simulation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS 握手模拟
- en: To keep things simple and to clarify the contents of this chapter, the actual
    implementation of the demo API we wrote will highlight each step in the TLS handshake.
    I've renamed my one controller to `TlsController`, and have implemented each step
    as its own controller action. The purpose of this is to reflect the conceptual
    steps taken by your web server whenever a user connects with your application
    over TLS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情简单明了，并阐明本章的内容，我们编写的演示API的实际实现将突出TLS握手中的每个步骤。我已经将我的一个控制器重命名为`TlsController`，并将每个步骤实现为其自己的控制器操作。这样做的目的是反映您的Web服务器在用户通过TLS与您的应用程序连接时采取的概念步骤。
- en: Identity verification
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'As you may recall, the first step of the TLS protocol is to establish the identity
    of the server. In that step, the client simply initiates a secure connection by
    sending a request to a secure endpoint (an endpoint leveraging HTTPS) and the
    server responds with an X.509 certificate. To that end, we''ve created a simple
    `GET` method named `initiate-connection`, which returns a certificate, which here
    is just a string:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，TLS协议的第一步是建立服务器的身份。在这一步中，客户端只需通过向一个安全端点（利用HTTPS的端点）发送请求来启动一个安全连接，服务器就会响应一个X.509证书。为此目的，我们创建了一个简单的`GET`方法，名为`initiate-connection`，它返回一个证书，这里只是一个字符串：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you may recall, the responsibility for interacting with a trusted CA falls
    on the client. So, at this point, we merely wait for them to confirm that we are
    who we say we are. Once they notify us that the certificate has been verified,
    we can send over our public encryption key, which they can use to encrypt their
    subsequent requests in the handshake protocol. For that interaction, we have the
    following `certificate-verified` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，与受信任的CA交互的责任在于客户端。因此，在这个时候，我们只是等待他们确认我们就是他们所说的那个人。一旦他们通知我们证书已被验证，我们就可以发送我们的公钥加密密钥，他们可以使用它来加密随后的握手协议请求。为此交互，我们有一个名为`certificate-verified`的方法：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And just like that, we're ready to start negotiating our encryption scheme.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们准备好开始协商我们的加密方案了。
- en: Negotiating the encryption scheme
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协商加密方案
- en: 'Now that we''ve given them a public encryption key, we''re waiting on our client
    to encrypt their next message with it. Both hosts must establish which encryption
    algorithms they support so that a mutual strong algorithm can be agreed upon.
    For that, we give our clients an endpoint named hash-algorithms, which will return
    all of the secure algorithms we support, and allow them to choose one they also
    support for use:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经给了他们一个公钥加密密钥，我们正在等待我们的客户使用它来加密他们的下一条消息。双方必须确定他们支持的加密算法，以便可以商定一个共同的强大算法。为此，我们给我们的客户一个名为hash-algorithms的端点，该端点将返回我们支持的所有安全算法，并允许他们选择一个他们也支持的算法来使用：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once they''ve determined which algorithm is most suitable for their needs and
    purposes, they''ll notify us. So, we have another method configured to handle
    that response from our client. However, once this one is done, we can use the
    algorithm they''ve selected, along with our private keys, to generate a session
    key that will serve as the shared secret between us for the data-transfer segment
    of the communication session. So, the last method of our simulation API uses a
    static `SessionService` class to store the selected algorithm, and then uses it
    to return a shared key, generated from our private keys and a random session key:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们确定哪种算法最适合他们的需求和目的，他们就会通知我们。因此，我们已配置了另一种方法来处理来自我们客户的响应。然而，一旦这项工作完成，我们就可以使用他们选择的算法，结合我们的私钥，生成一个会话密钥，该密钥将作为我们之间通信会话数据传输段的共享秘密。因此，我们模拟API的最后一个方法使用一个静态的`SessionService`类来存储所选算法，然后使用它来返回一个共享密钥，该密钥是由我们的私钥和一个随机会话密钥生成的：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With that method, our session is established, and data transfer can proceed
    safely. Hopefully, by breaking it down into it's most basic, high-level steps
    like that, it's a bit more clear what's going on every time you navigate to a
    website with the `https://` schema. More importantly, now you know how to configure
    and enforce HTTPS and TLS from within your .NET Core projects going forward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该方法，我们的会话就建立了，数据传输可以安全进行。希望通过将其分解为最基本、最高级步骤，每次您导航到使用`https://`方案的网站时，事情会变得更加清晰。更重要的是，现在您知道如何从您的.NET
    Core项目中配置和强制执行HTTPS和TLS。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot in this chapter, while managing to focus on a rather narrow
    subject. We started by taking a high-level view of the necessary steps to secure
    communications between two hosts over an open network. Then, we looked at how
    each of those steps is implemented (conceptually, at least). First, we looked
    at the process of verifying the identity of the host you want to interact with.
    We learned about trusted certificate authorities, and learned how they are leveraged
    by web clients to validate the identity of a server by examining a signed, cryptographic
    certificate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容，同时成功地聚焦于一个非常狭窄的主题。我们首先从高层次上审视了在开放网络中保护两个主机之间通信所需的必要步骤。然后，我们探讨了这些步骤是如何实现的（至少在概念上）。首先，我们研究了验证你想要交互的主机身份的过程。我们了解了受信任的证书颁发机构，并学习了它们是如何通过检查签名的加密证书来由Web客户端验证服务器身份的。
- en: In exploring this topic, we also considered how much trust must be placed in
    these CAs, and how that level of trust opens the wider public up to an incredibly
    high level of risk if it is ever violated. We also learned why a CA is necessary
    to validate a server identity, but is not necessary to validate the identity of
    a client in a mutual authentication scenario.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨这个主题时，我们还考虑了必须对这些CA投入多少信任，以及如果这种信任水平被违反，它如何使更广泛的公众面临极高的风险。我们还了解到，CA是验证服务器身份所必需的，但在相互认证场景中验证客户端身份则不是必需的。
- en: Next, we looked at how two hosts, whose identities have been sufficiently verified,
    can proceed to secure their communications over the course of a session. We saw
    how symmetric and asymmetric encryption is used to make sure that interactions
    are encrypted well before even a single byte of application data is transmitted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了两个主机（其身份已得到充分验证）如何在会话过程中继续确保其通信的安全性。我们看到了对称加密和非对称加密是如何在传输任何应用数据字节之前就确保交互加密的。
- en: Next, we looked at how these high-level steps for securing a communication session
    have been standardized and leveraged by secure protocols over the years. We saw
    how frequently security vulnerabilities can render a protocol functionally insecure,
    and how subsequent versions or standards can leverage ever-increasing tool sets
    to stay ahead of vulnerabilities and evolve over time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了这些用于保护通信会话的高级步骤是如何在过去的几年中被标准化并由安全协议所利用的。我们看到了安全漏洞如何使协议功能上不安全，以及后续版本或标准如何利用不断增长的工具集来领先于漏洞并随时间发展。
- en: Finally, we looked at how all of this is handled in the .NET Core framework.
    We saw how to configure our web services to support and rely on TLS, and how to
    avoid some of the additional overhead of using a CA while we're still in the development
    phase of a project. All of this has positioned us well to consider how to leverage
    this to allow for authentication and authorization in an application, which we'll
    be exploring in the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了所有这些在.NET Core框架中的处理方式。我们看到了如何配置我们的Web服务以支持并依赖TLS，以及如何在项目开发阶段避免使用CA的一些额外开销。所有这些都使我们能够考虑如何利用这些来允许在应用程序中进行身份验证和授权，这将在下一章中进行探讨。
- en: Questions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does HTTPS stand for? How is it distinct from HTTP?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTPS代表什么？它与HTTP有什么区别？
- en: What is a trusted certificate authority? What is their role in verifying the
    identity of a server?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是受信任的证书颁发机构？它们在验证服务器身份方面扮演什么角色？
- en: What is the difference between simple and mutual authentication?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单认证和相互认证之间有什么区别？
- en: What is the difference between symmetric and asymmetric cryptography?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称加密和非对称加密之间有什么区别？
- en: What is forward secrecy? How is it provided?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前向保密是什么？它是如何提供的？
- en: What is a non-deterministic function? Why is it important for securing a communication
    session?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非确定性函数是什么？为什么它在保护通信会话中很重要？
- en: What are message authentication codes? How are they used to provide reliability
    in TLS?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息认证码是什么？它们是如何在TLS中提供可靠性的？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about establishing secure software practices and the principles
    underlying SSL, TLS, and all things concerning network security, I recommend *Cybersecurity
    – Attack and Defense Strategies,* *Yuri Diogenes,* *Dr. Erdal Ozkaya, Packt Publishing*.
    It's an illuminating guide to the daily considerations of the engineers who design
    secure protocols like TLS. It's available through Packt Publishing, here: [https://www.packtpub.com/networking-and-servers/cybersecurity-attack-and-defense-strategies.](https://www.packtpub.com/networking-and-servers/cybersecurity-attack-and-defense-strategies)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解更多关于建立安全的软件开发实践以及SSL、TLS等网络安全相关原则的信息，我推荐阅读 *《网络安全 – 攻击与防御策略》*，作者：Yuri Diogenes，Dr.
    Erdal Ozkaya，Packt Publishing。这是一本关于设计TLS等安全协议的工程师日常考量的启发式指南。你可以在Packt Publishing购买，链接如下：[https://www.packtpub.com/networking-and-servers/cybersecurity-attack-and-defense-strategies](https://www.packtpub.com/networking-and-servers/cybersecurity-attack-and-defense-strategies)
- en: To understand just how much risk you assume whenever you expose your software
    to an open network, I'd also recommend *Network Vulnerability Assessment,* *Sagar
    Rahalkar, Packt Publishing*. It approaches the problem more from the perspective
    of a DevOps engineer or systems engineer than that of a software engineer, but
    I think it's important to have that kind of big-picture understanding. And this
    book is a great resource for that. It's also available through Packt, here: [https://www.packtpub.com/networking-and-servers/network-vulnerability-assessment.](https://www.packtpub.com/networking-and-servers/network-vulnerability-assessment)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解每次将你的软件暴露在开放网络中时你承担的风险有多大，我也推荐阅读 *《网络漏洞评估》*，作者：Sagar Rahalkar，Packt Publishing。这本书更多地从DevOps工程师或系统工程师的角度来探讨这个问题，而不是从软件工程师的角度，但我认为拥有这种宏观理解是很重要的。这本书也是这方面的宝贵资源。你还可以通过Packt购买，链接如下：[https://www.packtpub.com/networking-and-servers/network-vulnerability-assessment](https://www.packtpub.com/networking-and-servers/network-vulnerability-assessment)
