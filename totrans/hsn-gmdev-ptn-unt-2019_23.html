<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Dependency Injection</h1>
                </header>
            
            <article>
                
<p>I was introduced to the <strong>Dependency Injection</strong> (<strong>DI</strong>) pattern when I was working as a web developer, and I've been using it for years. However, I have noticed that DI is not well-known in the gaming industry. I suspect this is because it's a pattern that was developed to resolve design issues in business-oriented applications, and not for high-performance software such as video games.</p>
<p>As its names implies, DI is about injecting dependencies; it might sound abstract at first, but it's a quite simple concept. Classes often need instances of other classes to complete specific functions. So instead of having a class initialize its own dependencies, we inject them through its constructor or a parameter in one of its functions. This approach decouples the explicit relationships between classes, and it makes it easier to test our code, because we can easily inject mock objects that execute unit tests.</p>
<p>As you will see in this book, DI has its limitations, and it is not necessarily compatible with Unity's programming environment. This will become especially clear when you start to introduce more advanced versions of DI, in the form of<strong> Inversion of Control</strong> (<strong>IoC</strong>) containers.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will review the fundamentals of the DI pattern</li>
<li>We will explore the core concepts behind IoC containers and how they relate to DI</li>
<li>We will resolve a dependency issue prompted by the implementation of a feature that permits customizing the initial configurations of a superbike for a racing game</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The following chapter is hands-on; you will need to have a basic understanding of Unity and C#.</p>
<p class="mce-root"/>
<p>We will be using the following specific Unity engine and C# language concepts:</p>
<ul>
<li>Interfaces</li>
<li>Constructors</li>
</ul>
<p>If you are unfamiliar with these concepts, please review them before moving forward.</p>
<p>The code files from this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2Oww7WM">http://bit.ly/2Oww7WM</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of Dependency Injection</h1>
                </header>
            
            <article>
                
<p class="mce-root">As its name implies, the DI pattern's core purpose is to inject dependencies into the classes that need them. There are three ways to achieving this with DI, as follows:</p>
<ul>
<li class="mce-root"><strong>Constructor injection</strong>: We inject dependencies through a class's constructor.</li>
<li class="mce-root"><strong>Setter injection</strong>: We inject dependencies through a class's function parameters.</li>
<li class="mce-root"><strong>Interface injection</strong>: The dependency's interface offers an injector method to pass a dependency to a client.</li>
</ul>
<p>In this chapter, we will only review the constructor and setter techniques, because they are the most common.</p>
<p>Dependencies are usually classes that offer a particular service that other classes can utilize to complete specific functions. A classic example is a manager class that is responsible for establishing a connection to a database to execute queries. To fulfill this responsibility, the database manager is dependent on vendor-specific classes that act as interfaces to certain types of databases.</p>
<p>To avoid having the database manager retrieve and initialize a specific dependency every time it needs to connect to a particular type of database, we could provide them by injecting them when needed. In other words, we are decoupling the relationship between the dependent and its dependencies.</p>
<p class="mce-root"/>
<p>A UML diagram is not the best tool to describe the purposes of a DI pattern, but let's review a simplified diagram that outlines what we are going to implement as our use case:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a8371126-f7a1-436c-a544-971e5cbe2c5a.png"/></p>
<p class="mce-root"/>
<p>The case presented in the preceding diagram is similar to the database manager example that we just examined. We have a class named <kbd>Bike</kbd> that needs an engine to run correctly. Instead of having the <kbd>Bike</kbd> class initialize a specific type of engine depending on a particular condition, we made it accept a parameter of the <kbd>IEngine</kbd> type in its constructor. With this approach, we can have <kbd>Bike</kbd> receive any concrete class that implements <kbd>IEngine</kbd>, like in this example, with <kbd>JetEngine</kbd> and <kbd>NitroEngine</kbd>.</p>
<p>This arrangement provides us with a lot of extensibility; we could write dozens of different types of engines, each with their particular features, and the <kbd>Bike</kbd> would be able to accept them without any modification to its current structure.</p>
<p>But of course, DI is not without its drawbacks, as you are going to see in the next section.</p>
<p class="mce-root"/>
<div class="packt_infobox">DI follows the core principals of IoC, which is about inverting the flow control of a system. In the case of DI, it's about inverting the process of dependency management. Another pattern that follows IoC principals is the service locator, which you can review in <a href="56a2aeed-924d-4d95-b44b-b10ac7595d4a.xhtml">Chapter 16</a>, <em>Service Locator</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p class="mce-root">Like the Singleton pattern, the DI pattern is somewhat controversial, and its actual benefits and drawbacks are often contested. I suspect this is because its design is straightforward and programmers tend to be cautious of anything that looks too simple, because it's usually too good to be true.</p>
<p>The benefits are as follows:</p>
<ul>
<li><strong>Loose coupling</strong>: Having classes receive instances to dependencies instead of explicitly initializing them can reduce tight coupling in a code base.</li>
<li><strong>Testable code</strong>: DI makes it easier to run tests by making it possible to inject mock objects that can run specific scenarios.</li>
<li><strong>Concurrent development</strong>: DI offers a way to decouple objects and enforce communication through interfaces. This approach makes it easier for a team of programmers to write classes that utilize each other.</li>
</ul>
<p>The drawbacks are as follows:</p>
<ul>
<li><strong>Disputes</strong>: DI is a type of pattern that causes a lot of debates in a team, because the best approach is not always clear, especially when a more advanced form of DI is considered, such as the use of IoC injection containers.</li>
<li><strong>Framework dependency</strong>: The basic form of DI is very limited; once a certain degree of complexity is achieved, it becomes necessary to implement a third-party IoC framework to manage the injection of dependencies in a configurable manner. As a consequence, the code base often becomes dependent on the framework and cannot be easily removed.</li>
<li><strong>Ravioli code</strong>: Overzealous use of DI and related best practices can result in a code base that's overly encapsulated and broken up into too many individual classes, making it difficult to understand.</li>
</ul>
<div class="packt_tip">To test a candidate's ability to debate technical subject matters, interviewers often ask a candidate to give an opinion on a controversial pattern, such as DI and Singleton. It's a good practice, as an interviewee, to showcase a balanced view on any issue by taking into account the benefits and drawbacks.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p>Let's suppose that we are working on a racing game set in the future, with superbikes. We have to implement a feature quickly, in which a player can customize their bike by choosing an engine and driver from a list of available options before starting a race. In other words, our bike object has two specific dependencies: an engine and a driver. Using the DI pattern, we are going to manage these dependencies without adding unnecessary complexity to our code base.</p>
<p>First, we are going to look at the incorrect way to manage dependencies in a class so that you can understand the benefits of DI in contrast to the opposite approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The wrong way, without DI</h1>
                </header>
            
            <article>
                
<p>Before going into the implementation phase of our use case, let's first review an example of a class that uses an ill-considered way of initializing and managing its dependencies:</p>
<pre style="padding-left: 30px">using UnityEngine;<br/><br/>public class Bike : MonoBehaviour<br/>{<br/>    public enum EngineType<br/>    {<br/>        Jet,<br/>        Turbo,<br/>        Nitro<br/>    };<br/><br/>    public enum DriverType<br/>    {<br/>        Human,<br/>        Android<br/>    };<br/><br/>    private Engine m_Engine;<br/>    private Driver m_Driver;<br/><br/>    public void SetEngine(EngineType type)<br/>    {<br/>        switch (type)<br/>        {<br/>            case EngineType.Jet:<br/>                m_Engine = new JetEngine();<br/>                break;<br/>            case EngineType.Turbo:<br/>                m_Engine = new TurboEngine();<br/>            case EngineType.Nitro:<br/>                m_Engine = new NitroEngine();<br/>        }<br/><br/>        Debug.Log("The bike is running with the engine: " + m_Engine);<br/>    }<br/><br/>    public void SetDriver(DriverType type)<br/>    {<br/>        switch (type)<br/>        {<br/>            case DriverType.Human:<br/>                m_Driver = new HumanDriver();<br/>                break;<br/>            case DriverType.Android:<br/>                m_Driver = new AndroidDriver();<br/>        }<br/><br/>        Debug.Log("The driver of the bike is a: " + driver);<br/>    }<br/><br/>    public void StartEngine()<br/>    {<br/>        if (m_Engine != null)<br/>        {<br/>            // Start the bike's engine<br/>            m_Engine.Start();<br/>            // Give control of the bike to the driver<br/>            m_Driver.Control(this);<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">At first glance, this might seem like a reasonable approach, but let's imagine that we are working in a team of game programmers and each is implementing new types of engine behaviors. If we want our <kbd>Bike</kbd> class to support them, we will need to modify the <kbd>EngineType</kbd> <span>enum </span>and also update the <kbd>switch</kbd> case inside the body of the <kbd>SetEgnine()</kbd> method. This approach can become very bothersome over time if multiple programmers are working on the class at the same time.</p>
<p class="mce-root">We are having the same issue with the <kbd>SetDriver()</kbd> function; with this arrangement, adding new types of drivers will become a choir and will probably be prone to errors. So let's implement the same class in a step-by-step approach by using DI as our foundation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The right way with DI</h1>
                </header>
            
            <article>
                
<p>The implementation of DI is quite straightforward, and that's probably its main benefit. So, this section should be painless:</p>
<ol>
<li>Let's start by writing our <kbd>Bike</kbd> class; we could say that it's the actual client in this DI pattern example, mainly because it's the class that's dependent on receiving dependencies during the injection process:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Bike : MonoBehaviour<br/>{<br/>    private IEngine m_Engine;<br/>    private IDriver m_Driver;<br/><br/>    // Setter injection<br/>    public void SetEngine(IEngine engine)<br/>    {<br/>        m_Engine = engine;<br/>    }<br/>    <br/>    // Setter injection<br/>    public void SetDriver(IDriver driver)<br/>    {<br/>        m_Driver = driver;<br/>    }<br/><br/>    public void StartEngine()<br/>    {<br/>        // Starting the engine<br/>        m_Engine.StartEngine();<br/>        <br/>        // Giving control of the bike to a driver (AI or player)<br/>        m_Driver.Control(this);<br/>    }<br/><br/>    public void TurnLeft()<br/>    {<br/>        Debug.Log("The bike is turning left");<br/>    }<br/><br/>    public void TurnRight()<br/>    {<br/>        Debug.Log("The bike is turning right");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see, the <kbd>SetEngine()</kbd> and <kbd>SetDriver()</kbd> functions are not aware of what specific engine or driver they are receiving<span>—</span>only that they expect a generic type of them. In other words, the <kbd>Bike</kbd> class is no longer responsible for the initialization process of its dependencies. This approach is very flexible; we could write an infinite number of engine classes, each with their own specific behaviors, and if we stayed consistent with the implementation contract of the <kbd>IEngine</kbd> interface, we wouldn't need to modify the <kbd>Bike</kbd> class directly for it to be suitable to use new engines.</p>
<p style="padding-left: 60px">You will also notice that this approach is likewise valid for the <kbd>driver</kbd> dependency. The <kbd>Bike</kbd> doesn't need to know who the driver is; it just needs to know that the entity that's taking control implemented the <kbd>IDriver</kbd> interface so that they could communicate with each other.</p>
<p style="padding-left: 60px">For testing purposes, this flexibility is helpful; we could easily inject mock <kbd>engine</kbd> or <kbd>driver</kbd> objects at runtime and run some automated unit tests on the <kbd>Bike</kbd> implementations.</p>
<ol start="2">
<li>Now, let's write the interfaces for our two primary types of dependencies: engines and drivers:</li>
</ol>
<ul>
<li style="padding-left: 30px">The <kbd>IEngine</kbd> interface is as follows:</li>
</ul>
<pre style="padding-left: 90px">public interface IEngine<br/>{<br/>    void StartEngine();<br/>}</pre>
<ul>
<li style="padding-left: 30px">The <kbd>IDriver</kbd> interface is as follows:</li>
</ul>
<pre style="padding-left: 90px">public interface IDriver<br/>{<br/>    void Control(Bike bike);<br/>}</pre>
<ol start="3">
<li>In the following step, we are going to write all of our concrete classes for each primary type of component that our bike needs to function correctly:</li>
</ol>
<ul>
<li style="padding-left: 30px">The <kbd>JetEngine</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 90px">using UnityEngine;<br/><br/>public class JetEngine : IEngine<br/>{<br/>    public void StartEngine()<br/>    {<br/>        ActivateJetStream();<br/>        Debug.Log("Engine started");<br/>    }<br/><br/>    private void ActivateJetStream()<br/>    {<br/>        Debug.Log("The jet stream is activated");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px">The <kbd>NitroEngine</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 90px">using UnityEngine;<br/><br/>public class NitroEngine : IEngine<br/>{<br/>    public void StartEngine()<br/>    {<br/>        OpenNitroValve();<br/>        Debug.Log("Engine started");<br/>    }<br/><br/>    private void OpenNitroValve()<br/>    {<br/>        Debug.Log("The nitro valve is open");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">It's important to note that each engine encapsulates its internal mechanism while staying consistent with the implementation of the <kbd>IEngine</kbd> interface. It's this consistent approach that permits DI.</p>
<ul>
<li style="padding-left: 30px">The <kbd>HumanDriver</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 90px">using UnityEngine;<br/><br/>public class HumanDriver : IDriver<br/>{<br/>    private Bike m_Bike;<br/><br/>    public void Control(Bike bike)<br/>    {<br/>        m_Bike = bike;<br/>        Debug.Log("A human (player) will control the bike");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px">The <kbd>AndroidDriver</kbd> class is as follows:</li>
</ul>
<pre style="padding-left: 90px">using UnityEngine;<br/><br/>public class AndroidDriver : IDriver<br/>{<br/>    private Bike m_Bike;<br/><br/>    public void Control(Bike bike)<br/>    {<br/>        m_Bike = bike;<br/>        Debug.Log("This bike will be controlled by an AI");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>HumanDriver</kbd> class is intended to give control of the <kbd>Bike</kbd> to a player, which we will do in the upcoming <kbd>Client</kbd> class. The <kbd>AndroidDriver</kbd> class is meant to support an AI entity that could drive the <kbd>Bike</kbd> and act as a rival to the player during a race.</p>
<ol start="4">
<li>Finally, our <kbd>Client</kbd> class, which we will use to test our system, is as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.DependencyInjection<br/>{<br/>    public class Client : MonoBehaviour<br/>    {<br/>        // Bike controlled by the player<br/>        public Bike m_PlayerBike;<br/><br/>        // Bike controlled by an android (AI)<br/>        public Bike m_AndroidBike;<br/><br/>        void Awake()<br/>        {<br/>            // Set up a bike with a human driver and jet engine<br/>            IEngine jetEngine = new JetEngine();<br/>            IDriver humanDriver = new HumanDriver();<br/><br/>            m_PlayerBike.SetEngine(jetEngine);<br/>            m_PlayerBike.SetDriver(humanDriver);<br/>            m_PlayerBike.StartEngine();<br/><br/>            // Set up a bike with a AI driver and a nitro engine<br/>            IEngine nitroEngine = new NitroEngine();<br/>            IDriver androidDriver = new AndroidDriver();<br/><br/>            m_PlayerBike.SetEngine(jetEngine);<br/>            m_PlayerBike.SetDriver(humanDriver);<br/>            m_PlayerBike.StartEngine();<br/>        }<br/><br/>        void Update()<br/>        {<br/>            if (Input.GetKeyDown(KeyCode.A))<br/>            {<br/>                m_PlayerBike.TurnLeft();<br/>            }<br/><br/>            if (Input.GetKeyDown(KeyCode.D))<br/>            {<br/>                m_PlayerBike.TurnRight();<br/>            }<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            GUI.color = Color.black;<br/>            GUI.Label(new Rect(10, 10, 500, 20), "Press A to turn LEFT and D to turn RIGHT");<br/>            GUI.Label(new Rect(10, 30, 500, 20), "Output displayed in the debug console");<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 30px">Our <kbd>Client</kbd> class is quite straightforward; in the <kbd>Awake()</kbd> function, we inject the dependencies into two instances of a <kbd>Bike</kbd> class: <kbd>m_PlayerBike</kbd> and <kbd>m_AndroidBike</kbd>. In the <kbd>Update()</kbd> function, we listen for a player's input that permits them to control the <kbd>m_PlayerBike</kbd> instance.</p>
<p>This might look very straightforward and too simple to be true, but this pattern offers a lot of extensibility and flexibility, with little complexity, if used in moderation. In the next section, we are going to review a more advanced form of DI, which uses IoC containers.</p>
<div class="packt_infobox">You may have noticed that we didn't use constructor injection in our code example; it's because we were working with a <kbd>MonoBehaviour</kbd> class, and we don't have access to its constructor. Some Unity developers do use the <kbd>Awake()</kbd> function to inject dependencies during the initialization process.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DI with IoC containers</h1>
                </header>
            
            <article>
                
<p>IoC containers usually come in the form of frameworks; their primary responsibilities are to automate the DI process and manage the life space of dependencies. Before we start, it's important to note that most IoC containers are not designed to be compatible with Unity's coding model, and I don't recommend using them. On the other hand, it's important to be aware that they exist.</p>
<p>As we mentioned at the beginning of this chapter, DI is a handy and straightforward pattern, but it has its limitations. In the code example that we just implemented, we managed the injection of two dependencies at once, but imagine if we had dozens of them spread out over multiple classes. In that type of context, DI can become a choke point in your architecture. That is when IoC containers become useful, because they can automate the process of managing all of those injections.</p>
<p>The following is a quick summary of the functions that most IoC containers offer:</p>
<ul>
<li><strong>Registration</strong>: The container offers a way to register dependencies and map them to the dependents correctly.</li>
<li><strong>Resolving</strong>: The container takes the responsibility of resolving the dependencies by initializing and injecting them.</li>
<li><strong>Disposing</strong>: The container will manage the lifespan of objects, including disposing them once they are not needed anymore.</li>
</ul>
<p>The goal of this quick review of the IoC containers is not to debate whether they are necessary, but to become aware that the simple version of the DI pattern has its limitations. Once we have reached a certain degree of complexity and density with regard to the dependencies to inject, we need to consider implement or integrating an IoC container framework to manage the process.</p>
<div class="packt_tip">Always be cautious about making your code base dependent on third-party frameworks; you might find yourself falling into the vendor lock-in anti-pattern, which I will describe in more detail in the final chapter of this book.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we reviewed the DI pattern, a simple pattern that has grown in popularity over the years. Its fame is explainable by the fact that it resolves a common challenge that every programmer faces daily, which is the management of dependencies between classes. In other words, it's a powerful tool to have in your toolkit, as long as you don't abuse it.</p>
<p>In the next chapter, we will explore the object pool pattern, another handy tool that is very popular with mobile game programmers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practical exercise</h1>
                </header>
            
            <article>
                
<p class="mce-root">As a practical exercise, I recommend writing an application in C# using a popular IoC container framework. Because most of them are incompatible with the Unity engine, I suggest going native and coding a simple Windows application in Visual Studio.</p>
<p class="mce-root">In the <em>Further reading</em> section, I have added a list of popular IoC container frameworks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Some books that may be used as reference are as follows:</p>
<ul>
<li><span><em>Dependency Injection in .NET</em> by Mark Seemann: <a href="https://www.manning.com/books/dependency-injection-in-dot-net">https://www.manning.com/books/dependency-injection-in-dot-net</a></span></li>
<li><em>Dependency Injection Principles, Practices, and Patterns</em> by Steven van Deursen and Mark Seemann: <a href="https://www.manning.com/books/dependency-injection-principles-practices-patterns">https://www.manning.com/books/dependency-injection-principles-practices-patterns</a></li>
</ul>
<p>Some IoC frameworks to consider are as follows:</p>
<ul>
<li>Ninject:<em> </em><a href="http://www.ninject.org">http://www.ninject.org</a><a href="https://unitycontainer.github.io"/></li>
<li>Castle Windsor:<em> </em><a href="https://github.com/castleproject/Windsor">https://github.com/castleproject/Windsor</a></li>
</ul>


            </article>

            
        </section>
    </body></html>