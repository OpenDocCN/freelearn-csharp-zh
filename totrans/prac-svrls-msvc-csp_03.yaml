- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setup and Theory: Docker and Onion Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discusses two important building blocks of modern microservices
    architectures, which will be used in most of the book’s examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Containers**: Docker containers are a virtualization tool that enables
    your microservices to run on a wide range of hardware platforms, preventing compatibility
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Onion Architecture**: The Onion Architecture confines dependencies from
    both the **user interface** (**UI**) and from the deployment platform in drivers
    so that the software modules that encode the whole business knowledge are completely
    independent of the chosen UI, tools, and runtime environment. Moreover, in order
    to optimize the interaction between domain experts and developers, all domain
    entities are implemented as classes in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each entity interacts with the remainder of the code only through methods that
    represent the behavior of all actual domain entities.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Names of entities and entity members are taken from the vocabulary of the application
    domain. The purpose is to build up a common language between developers and users
    called the **ubiquitous language**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: While Docker containers are roughly tied to microservice performance optimization,
    the Onion Architecture is not specific for microservices. However, the Onion Architecture
    described here was designed specifically for use with microservices, as it makes
    wide use of some of the microservice-specific patterns we described in [*Chapter
    2*](Chapter_2.xhtml#_idTextAnchor038)*, Demystifying Microservices Applications*,
    such as publisher-subscriber events, to maximize the independence of software
    modules and to ensure separation between update and query software modules.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce a Visual Studio solution template based on
    the Onion Architecture along with code snippets that we will use throughout the
    remainder of the book for implementing any kind of microservice. We will discuss
    both the theory behind it and its pros.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, this chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Onion Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solution template based on the Onion Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be able to create an application based
    on the Onion Architecture and work with Docker containers, which are the building
    blocks of complex microservices applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: At a minimum, the Visual Studio 2022 free *Community edition*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docker Desktop** for Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docker Desktop**, in turn, requires **Windows Subsystem for Linux (WSL)**,
    which can be installed by following these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `powershell` in the Windows 10/11 search bar.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When Windows PowerShell is proposed as a search result, click on **Run as an
    administrator**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Windows PowerShell administrative console that appears, run the `wsl
    --install` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  prefs: []
  type: TYPE_NORMAL
- en: The Onion Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Onion Architecture makes a clear distinction between domain-specific code
    and the technical code that handles the UI, storage interaction, and hardware
    resources. This keeps the domain-specific code completely independent of technical
    tools, such as the operating system, web technology, database, and database interaction
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole application is organized into layers, with the outermost layer having
    the sole purpose of providing all the necessary infrastructure (i.e., drivers),
    UI, and test suites, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Basic Onion Architecture](img/B31916_03_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Basic Onion Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the application-specific code is organized into several more nested
    layers. All layers must satisfy the following constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: Each layer may reference only inner layers. The way this constraint is implemented
    depends on the underlying language and stack. For instance, layers can be implemented
    as packages, namespaces, or libraries. We will implement layers with .NET library
    projects that can be easily turned into NuGet packages, too.
  prefs: []
  type: TYPE_NORMAL
- en: So, for instance, in the preceding figure, the outermost layer may reference
    all application-specific libraries, plus all libraries that implement all the
    required drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application-specific code references the functionalities implemented in
    the outermost layer’s drivers through interfaces, while the outermost layer has
    the main function of providing a dependency injection engine that couples each
    of these interfaces with a driver that implements it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The application-specific layer, in turn, is composed of at least two main layers:
    a layer that contains all domain entity definitions, called the **Domain layer**,
    and a layer that contains the definition of all application operations, called
    the **Application Services** layer, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Complete Onion Architecture](img/B31916_03_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Complete Onion Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: If needed, the Application Services layer can be split into more sublayers,
    and more layers can be placed between the Application Services and Domain layers,
    but this is rarely done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Domain layer is often split into two sublayers: **the Model layer,** which
    contains the actual domain entity definitions, and the **Domain Services** layer,
    which contains further business rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will use just the Application Services and Domain layers.
    We will discuss each of them in a separate subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The Domain layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Domain layer contains the class representation of each domain entity with
    its behavior encoded in the public method of such classes.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, domain entities can be modified just with methods that represent actual
    domain operations. Thus, for instance, we can’t directly access and modify all
    fields of a purchase order; we are limited to manipulating it just through methods
    that represent actual domain operations, such as adding or deleting an item, applying
    a discount, or modifying the delivery date.
  prefs: []
  type: TYPE_NORMAL
- en: The names of all public methods and properties must be built with the actual
    language used by the domain experts, the previously mentioned **ubiquitous language**.
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding constraints have the purpose of optimizing communication between
    developers and experts. In this way, domain experts and developers can discuss
    the public interface of the entity since it uses the same vocabulary and actual
    domain operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a part of a hypothetical `PurchaseOrde`r entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once taken from the constructor, `CreationTime` cannot be modified anymore,
    so it is implemented as a {`get; init;}` property. The list of all items can be
    modified through the `AddItem` and `RemoveItem` methods, which are understandable
    by all domain experts. Finally, we can delay the delivery date but we can’t anticipate
    it. This automatically encodes a domain business rule by enforcing the use of
    the `DelayDeliveryTime` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can improve the `PurchaseOrde`r entity by adding a `PurchaseTotal` **get
    property** that returns the total amount of the purchase, and by adding an `ApplyDiscount`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up, we can state the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain entity states can only be changed through methods that encode actual
    domain operations and that automatically enforce all business rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'These entities differ a lot from the usual **Entity Framework Core** entities
    we are used to for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core entities are record-like classes with no methods. That
    is, they are just a set of property-value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Entity Framework Core entity corresponds to a single object related somehow
    to other entities, while domain entities are often trees of nested objects. That
    is why domain entities are usually called **aggregates**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, for instance, the `PurchaseOrder` aggregate contains a main entity and
    a `PurchaseOrderItem` collection. It is worth pointing out that `PurchaseOrderItem`
    cannot be considered a separate domain entity since there are no domain operations
    that involve a single `PurchaseOrderItem`, but `PurchaseOrderItem` can be manipulated
    just as a part of `PurchaseOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar phenomenon doesn’t occur with flat Entity Framework entities, as
    they lack the concept of domain operations. We may conclude the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain operations on domain entities can force them to merge with dependent
    entities, thus becoming a complex tree of objects called **aggregates**.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this book, we will refer to domain entities as aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have given entities a strong application domain semantic together
    with the concept of aggregation. These aggregates differ a lot from database tuples
    and also from their object representation provided by ORMS such as Entity Framework
    Core, so we have a mismatch between aggregates and the structures used to persist
    them. This mismatch could be solved in several ways, but all solutions must conform
    to the **persistence ignorance** principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates must not be impacted by how they might be persisted. They must be
    completely decoupled from the persistence code, and the persistence technique
    must not impose any constraint on the aggregate design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now observe another phenomenon: entities without an identity!'
  prefs: []
  type: TYPE_NORMAL
- en: Two purchase orders with exactly the same dates and items remain two different
    entities; in fact, they must have a different delivery for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens with two addresses containing exactly the same fields?
    If we consider the semantics of an address, can we say they are two different
    entities?
  prefs: []
  type: TYPE_NORMAL
- en: 'Each address denotes a place, and if two addresses have the same fields, they
    denote exactly the same place. Thus, addresses are just like numbers: even though
    we may replicate them several times, each copy always denotes the same abstract
    entity.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we may conclude that addresses with the same fields are indistinguishable.
    Relational databases use principal keys to verify when two tuples reference the
    same abstract entity, so we may conclude that the principal key of an address
    should be the set of all its fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the theory of domain entities, objects similar to addresses are called value
    objects, and their in-memory representation must not contain explicit principal
    keys. An equality operator applied to two instances of them must return `true`
    if and only if all their fields are equal. Moreover, they must be immutable –
    that is, once created, their properties cannot be changed, so the only way to
    modify a value object is to create a new object with some property value changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, value objects are easily represented with **records**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `init` keyword is what makes record-type properties immutable since it means
    they can only be
  prefs: []
  type: TYPE_NORMAL
- en: 'initialized. A modified copy of a record can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass all the properties in the constructor instead of using initializers,
    the preceding definition can be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Typical value objects include costs (represented as a number and a currency
    symbol), locations (represented as longitude and latitude), addresses, and contact
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, value objects can be represented in databases with the usual tuple
    with a principal key (for instance, an autoincremented integer). Then, a new copy
    of each tuple can be created differently for each occurrence of the same address.
    It is also possible to enforce a unique database copy by defining complex composite
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Since aggregates and value objects differ a lot from the entities used by all
    main ORMs such as Entity Framework, when we use ORMS to interact with databases,
    we must translate ORM entities into aggregates and value objects, and vice versa,
    each time we exchange data with an ORM.
  prefs: []
  type: TYPE_NORMAL
- en: According to general Onion Architecture rules, the Domain layer interacts with
    the actual implementation provided by an ORM through an interface. This is usually
    done with the so-called **repository pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: According to the repository pattern, a storage service must be provided through
    one separate interface for each aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: This means the Domain layer must contain a different interface for each aggregate,
    which takes care of retrieving, saving, and deleting the whole aggregate. The
    repository pattern helps keep the code modular and easy to search and update since
    we know we must have one and only one repository interface for each aggregate,
    so we can organize the whole aggregate-related code in a single folder.
  prefs: []
  type: TYPE_NORMAL
- en: The actual implementation of each repository is contained in the Infrastructure
    layer of the Onion Architecture in a kind of database (or persistence) driver,
    together with various other drivers that virtualize the interaction with the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Each aggregate repository interface contains methods that return aggregates,
    delete aggregates, and make any other kind of persistency-related operations on
    aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: In complex applications, it is best practice to split the Domain layer into
    a Model layer, which contains just aggregates, and an outer Domain Services layer,
    which contains the repository interfaces and the definition of domain operations
    that can’t be implemented as aggregate methods.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, **Domain Services** interfaces handle the tuples used to encode
    the results returned by query microservices. These tuples are not aggregates but
    a mix of data taken from different data tables, so they conform to a completely
    different design pattern. They are returned as record-like objects with no methods
    and just properties that correspond to the database tuples fields. Further **Domain
    Services** interfaces are implemented in the persistence driver of the infrastructure
    layer, too.
  prefs: []
  type: TYPE_NORMAL
- en: Handling queries and modifications separately and with different design patterns
    is known as the **Command Query Responsibility Segregation (CQRS**) pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Since, the microservices described in this book are quite simple, in our code
    examples, we will not split the domain layer into the model and domain services
    layers. Therefore, the repository and other domain services interfaces will be
    mixed with aggregates in the same Visual Studio project. However, when implementing
    more complex applications, you should use the division of the domain layer into
    the model and domain services layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some examples of a repository interface. The `PurchaseOrder`
    aggregate might have an associated repository interface that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is no update method since updates are implemented by directly calling
    the aggregate methods. The last method in the code shown returns a collection
    of record-like DTOs called `OrderBasicInfoDTO`.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that there are no repository interfaces associated
    with value objects since value objects are handled just as primitive types, such
    as integers, decimals, or strings.
  prefs: []
  type: TYPE_NORMAL
- en: Several changes to different aggregates can be dealt with in a transactional
    way thanks to the **Unit Of Work** pattern, which will be described later on in
    the *Command* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: More details on how Entity Framework Core supports the implementation of repository
    interfaces and on how domain objects are tied and translated back and forth to
    Entity Framework Core entities will be given in the *A solution template based
    on the Onion Architecture* section.
  prefs: []
  type: TYPE_NORMAL
- en: Having understood the in-memory representation of domain objects, we can move
    on to the way a microservices-oriented Onion Architecture represents all business
    transactions/operations.
  prefs: []
  type: TYPE_NORMAL
- en: Application services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Microservices organization* subsection of[*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038)*,
    Demystifying Microservices Applications*, we saw that microservices architectures
    often use the **CQRS** pattern, which is where some microservices specialize in
    queries and others specialize in updates. That is the strong version of the CQRS
    pattern, but there is also a weaker version that simply requires that queries
    and updates be organized into different modules, possibly belonging to the same
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: While it is not always convenient to apply CQRS in its stronger form, its weaker
    form is a must when implementing microservices, as updates involve aggregates
    while queries involve just record-like DTOs, so they require completely different
    types of processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the operations defined in the application services layer of a
    microservice are split into two different types: **queries** and **commands**.
    As we will see, the execution of commands can trigger events, so together with
    commands and queries, application services must also handle so-called **domain
    events**. We will discuss all these different operations in the dedicated subsections
    that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A query object represents one or several similar queries, so it usually has
    one or several methods that take some inputs and return the query results. Most
    query methods just call a single repository method that implements the needed
    query, but in some cases, they may execute several repository methods and then
    they may somehow merge their results.
  prefs: []
  type: TYPE_NORMAL
- en: During system testing, actual query implementations must be replaced by fake
    implementations, so, usually, each query has an associated interface that is coupled
    with the actual implementation in the dependency injection engine. This way, the
    UI may just require the interface in some constructor, thus enabling testing with
    a fake implementation of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a possible definition of a query that returns all purchase
    orders emitted after a given date, together with its associated interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The interface inherits from an empty interface whose unique purpose is to mark
    both the interface and its implementation as queries. This way, all queries and
    their associated implementation can be automatically found with the help of reflection
    and added to the dependency injection engine. We will provide the code that discovers
    all queries in the *A solution template based on the Onion Architecture* section
    together with a complete solution template.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the implementation just calls a repository method and passes it
    adequate parameters. An implementation of the repository is passed in the principal
    constructor of the class by the same dependency injection engine that will inject
    the query itself in the constructor of a presentation layer object (a controller,
    in the case of an ASP.NET Core website).
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Commands work in a slightly different way because, for better code readability,
    each command represents a single application operation. For this reason, each
    command instance represents both the abstract operation and its input. The actual
    operation implementation is contained in a command handler object. The following
    is the code of a hypothetical command that applies a discount to a purchase order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Commands must be immutable; that’s why we implanted them as records. In fact,
    the only operation allowed on them is their execution. Similar to queries, commands
    also implement an empty interface that marks them as commands (in this case, `ICommand`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Command handlers are implementations of the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can, see all command handlers implement the same `HandleAsync` method
    that accepts the command as its single input. Thus, for instance, the handler
    associated with `ApplyDiscountCommand` is something like the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All handlers must be added to the dependency injection engine, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This can be done automatically by scanning the application services assembly
    with reflection. We will provide the code that discovers all command handlers
    in the *A solution template based on the Onion Architecture* section.
  prefs: []
  type: TYPE_NORMAL
- en: Each command handler gets or creates aggregates, modifies them by calling their
    methods, and then executes a save instruction to persist all modifications in
    the underlying storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The save operation must be implemented in the storage driver (for instance,
    Entity Framework Core), so, as usual for all Onion Architecture drivers’ operations,
    it is mediated by an interface. The interface that performs the save operations
    and other transaction-related operations is usually called **IUnitOfWork**. A
    possible definition of this interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SaveEntitiesAsync` saves all updaters performed so far in a single transaction.
    It returns `true` if the storage engine actually changed after the save operation,
    and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartAsync` starts a transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommitAsync` and `RollbackAsync` respectively commit and roll back an opened
    transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All methods that explicitly control the start and end of a transaction are
    useful for enclosing both a get operation and the final `SaveEntitiesAsync` save
    in the same transaction, as in the following simplified flight reservation snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If there are no more available seats, the transaction is aborted, but if there
    are available seats, we are sure that no other passenger can take the available
    seat because both the query and the update are performed in the same transaction,
    thus preventing interference from other reservation operations.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the preceding code works if the transaction has an adequate isolation
    level and if the database supports that isolation level. We can use a high enough
    isolation level for all operations in our microservice; otherwise, we are forced
    to pass the isolation level as a `StartAsync` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to explain why domain events are needed, and how they are
    handled.
  prefs: []
  type: TYPE_NORMAL
- en: Domain events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may define **domain events** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain events** are events originating from something happening in the microservice
    domain and are handled within the boundaries of the microservice itself. This
    means they involve communications based on the publisher-subscriber pattern between
    two chunks of code of the same microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, they must not be confused with the events involved in the communications
    between different microservices, which are called **integration events** to distinguish
    them from domain events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why use events inside the boundaries of a microservice? The reason is always
    the same: to ensure a better decoupling between parts. Here, the parts involved
    are aggregates. The code of each aggregate must be completely independent of other
    aggregates to ensure modularity and modifiability, so relations between aggregates
    are either mediated by command handlers or by some publisher-subscriber pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, if the interaction between two aggregates is somehow decided by
    the code of a command handler, the same command handler might take care of processing
    the data of both of them and then somehow update them. However, if the interaction
    is tied to the processing within an aggregate method, we are forced to use events
    because we can’t make an aggregate aware of all the other aggregates that need
    to be informed about some of its data changes. Summing up, we may state the following
    principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain events are triggered just inside aggregate methods because other kinds
    of interactions are better handled by command handlers’ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important principle is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Events triggered inside an aggregate method must not interfere with the ongoing
    method processing because these might undermine the contract between the aggregate
    and the command handlers that manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, each aggregate stores all events inside of it in an events list,
    and then the command handler decides when to execute these handlers. Typically,
    all events of all aggregates processed by a command handler are executed just
    before the handler saves all changes by calling `unitOfWork.SaveEntitiesAsync()`.
    However, this is not a general rule.
  prefs: []
  type: TYPE_NORMAL
- en: Events are handled in a similar way to commands, the only difference being that
    each command has just one associated handler, while each event may have several
    subscriptions attached to it. Luckily, this difficulty can be easily handled with
    some advanced features of the .NET dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, events are classes marked with the empty `IEventNotification`
    interface, while event handlers are an implementation of the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All data structures involved are completely analogous to the ones needed to
    handle commands. However, now we must add some enhancements to associate each
    event with all its handlers. The following generic class does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `IEventNotification` is an empty interface used just to mark a class as
    representing an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add the preceding generic class to the dependency injection engine with
    `service.AddScoped(typeof(EventTrigge<>))`, then whenever we require a specific
    instance of this class (say, for the `MyEvent` event generic argument), the dependency
    injection engine will automatically retrieve all `IEventHandler<MyEvent>` implementations
    and will pass it in the constructor of the `EventTrigger<MyEvent>` instance being
    returned. After that, we may launch all subscribed handlers with something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that the `IEventNotification` interface must be defined
    in the domain layer since it must use aggregates, while all other interfaces and
    classes connected to events are defined in the application services DLL.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of an event, let’s consider a purchase order aggregate of an e-commerce
    application. When the purchase order is finalized by calling its `Finalize` method,
    if the purchase is greater than a given threshold, then an event must be created
    for adding some scores to the user profiles that the user can spend to get discounts
    on further purchases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure exemplifies what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Domain event example](img/B31916_03_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Domain event example'
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of command handlers, all event handlers defined in the application
    services DLL can be automatically discovered and added to the dependency injection
    engine through reflection. We will show how to do it in the next section, which
    will propose a general .NET solution template for the Onion Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: A solution template based on the Onion Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we describe a solution template based on the Onion Architecture
    that we will use throughout the remainder of the book, which you can find in the
    `ch03` folder of the book’s GitHub repository ([https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)).
    This template shows how to put into practice what you have learned about the Onion
    Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution contains two .NET library projects, called `ApplicationServices`
    and `DomainLayer`, which implement, respectively, the application services and
    domain layers of an Onion Architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Solution template based on the Onion Architecture](img/B31916_03_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Solution template based on the Onion Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As prescribed by the Onion Architecture, the `ApplicationServices` project has
    a reference to the `DomainLayer` architecture project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ApplicationServices`, we added the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Queries` to place all queries and query interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Commands` to place all command classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommandHandlers` to place all command handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventHandlers` to place all event handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tools`, which contains all Onion Architecture-related interfaces used by the
    application services we described in the previous section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Extensions`, which contains the `HandlersDIExtensions.AddApplicationServices()`
    extension method that adds all queries, event handlers, and command handlers defined
    in the project to the dependency injection engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding folders can be organized into subfolders to increase the code
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DomainLayer` project, we added the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Models` to place all aggregates and value objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Events` to place all events that may be raised by the aggregates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tools`, which contains all Onion Architecture-related interfaces used by the
    domain we described in the previous section, and some further utility classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Extensions` folder of the `ApplicationServices` project contains just
    one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: ApplicationServices extensions](img/B31916_03_5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: ApplicationServices extensions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HandlersDIExtensions` static class contains two overloads of an extension
    method, which adds all queries, command handlers, event handlers, and the `EventMediator`
    class to the dependency injection engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses three different private methods that scan the assembly with reflection,
    looking respectively for queries, command handlers, and event handlers. The full
    code is available in the `ch03` folder of the GitHub repository associated with
    the book. Here, we analyze just `AddAllCommandHandlers` to show the basic ideas
    exploited by all three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we collect all nonabstract classes that implement the `ICommandHandler`
    empty interface. This interface was specifically added to all command handlers
    to retrieve all of them with reflection. Then, for each of them, we retrieve the
    `ICommandHandler<T>` that it implements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we find such an interface, we add the pair to the dependency injection
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Tools` folder of the `ApplicationServices` project contains the files
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: ApplicationServices tools](img/B31916_03_6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: ApplicationServices tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'We already analyzed all interfaces and classes contained in the preceding `Tools`
    folder, except `EventMediator` in the previous section. Let’s recall them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IQuery` and `ICommand` are empty interfaces that mark, respectively, queries
    and commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ICommandHandler<T>` and `IEventHandler<T>` are the interfaces that must be
    implemented, respectively, by command handlers and event handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventTrigger<T>` is the class that does the magic of collecting all event
    handlers associated with the same event, `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventMediator` is a utility class that solves a practical problem. A command
    handler that needs to trigger all event handlers associated with an event, `T`,
    must inject `EventTrigger<T>` in its constructor. However, the point is that a
    command discovers that it needs to trigger the `T` event just when it finds the
    `T` event in the event lists of an aggregate, so it should inject all possible
    `EventTrigger<T>` in its constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem, the `EventMediator` class uses `IServiceProvide`r
    to require the event handlers associated with a list of events it is passed in
    its `TriggerEvents(IEnumerable<IEventNotification> events)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, it is enough to inject `EventMediator` in the constructor of each
    command handler so that whenever it finds a nonempty event list, `L`, in an aggregate,
    it can simply call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once `EventMediator` receives the preceding call, it scans the event list to
    discover all the events contained in it, then for each of them, it requires the
    corresponding `EventTrigger<T>` to get all associated event handlers, and finally,
    it executes all retrieved handlers, passing them the corresponding events.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform its job, the `EventMediator` class requires `IServiceProvider` in
    its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it uses this service provider to require each needed `EventTrigger<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it invokes the `EventTrigger<T>.Trigger` methods with reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the full code of the `EventMediator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Tools` folder of the `DomainLayer` project contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: DomainLayer tools](img/B31916_03_7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: DomainLayer tools'
  prefs: []
  type: TYPE_NORMAL
- en: '`IEventNotification` and `IRepository` are empty interfaces that mark, respectively,
    events and repository interfaces. We already discussed them in the previous section.
    We also already discussed `IUnitOfWork`, which is the interface needed by command
    handlers to persist changes and handle transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entity<T>` is a class that all aggregates must inherit from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class contains two minimized code regions. The `K` generic parameter
    is the type of the aggregate’s `Id` principal key.
  prefs: []
  type: TYPE_NORMAL
- en: The `IsTransient()` method returns `true` if the aggregate has not been assigned
    a principal key yet.
  prefs: []
  type: TYPE_NORMAL
- en: '`Override Equal region` contains the code that overrides the `Equal` method
    and defines equality and inequality operators. The redefined `Equal` method considers
    equal two instances if and only if they have the same principal key.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Domain events handling region` handles the list of events triggered during
    all calls to the aggregate methods. The exploded code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need an abstract class for value objects because, as discussed in the
    previous section, the .NET `record` type perfectly represents all value type features.
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing in more detail how to connect the two library projects of
    the template with the actual storage drivers and with an actual UI, we need to
    understand how to handle the mismatch between aggregates and record-like ORM classes.
    We will do this in the dedicated subsection that follows.
  prefs: []
  type: TYPE_NORMAL
- en: Matching aggregates and ORM entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several techniques to match ORM entities and aggregates. The simplest
    one consists of implementing the aggregates with the ORM entities themselves.
    The main difficulty with this approach is that aggregates do not expose the properties
    that must match the database fields as public properties. However, since they
    usually expose them as private fields, we may try to use these private fields
    for the database field mapping if the chosen ORM supports mapping with private
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core supports the mapping with private fields, but if we are
    looking for complete independence from the database driver, we can’t rely on this
    peculiarity of Entity Framework Core. Moreover, this approach forces us to define
    the ORM entities in the domain layer since they are also aggregates. This means
    that we can’t decorate the class member with ORM-specific attributes and that
    we need to worry about how the class will be used by the ORM while defining each
    aggregate, thus undermining independence from a specific storage driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is the **state object** approach:'
  prefs: []
  type: TYPE_NORMAL
- en: We associate each aggregate with an interface that stores the state of the aggregate
    in its properties. This way, instead of using private backing fields, the aggregate
    uses the properties of this interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state interface is passed in the constructor of the aggregate and then stored
    in a private `readonly` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ORM entity associated with the aggregate implements this interface. This
    way, the database driver adapts to the aggregates and not vice versa, thus achieving
    the required independence of the Domain layer from the database driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the domain layer requires either a new fresh aggregate or an aggregate
    already stored in the database through a repository interface method, the database
    implementation of the repository method creates or retrieves the corresponding
    ORM entity and then creates a new aggregate, passing this ORM entity in its constructor
    as a state object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the aggregates are modified, all their modifications are reflected on their
    state objects, which, being ORM entities, are tracked by the ORM. Therefore, when
    we instruct the ORM to save all changes, all aggregates’ changes are automatically
    passed to the underlying database because these changes are stored in tracked
    objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure shows the preceding flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Aggregates lifecycle](img/B31916_03_8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Aggregates lifecycle'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to modify our previous `PurchaseOrder` aggregate by using the following
    state interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Modifications are straightforward and do not increase the complexity of the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to understand how to connect the two projects of our template
    with an actual database driver and an actual UI.
  prefs: []
  type: TYPE_NORMAL
- en: A complete solution based on the Onion Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *ch03* folder of the book’s GitHub repository ([https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp))
    contains a complete solution, which, together with the application services and
    domain layer libraries, also features a database driver based on Entity Framework
    Core and a presentation layer based on an ASP.NET Core Web API project.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this project is to show how to use the general Onion Architecture
    template described in this section in an actual solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the complete solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: A complete solution based on the Onion Architecture](img/B31916_03_9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: A complete solution based on the Onion Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DBDrive`r project is a .NET library project where we added a dependency
    on the following Nuget packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.SqlServer`: This package loads both Entity Framework
    Core and its SQL Server provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Tools`: This package provides all tools for
    scaffolding and handling database migrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `DBDriver` project must provide a storage driver, it also has a dependency
    on the domain library project.
  prefs: []
  type: TYPE_NORMAL
- en: The `WebApi` project is an ASP.NET Core Web API project. It works as the outermost
    layer of the Onion Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The outermost layer of the Onion Architecture (in our example, `WebApi`) must
    have a dependency on the application services directory and all drivers’ projects
    (in our example, just `DBDrive`r).
  prefs: []
  type: TYPE_NORMAL
- en: 'We added some folders and classes to the `DBDriver` project that should be
    used in all drivers based on Entity Framework Core. The following figure shows
    the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: DBDriver project structure](img/B31916_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: DBDriver project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the description of all the folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entities`: Put all your Entity Framework Core entities here, possibly organized
    in subfolders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repositories`: Put all repository implementations here, possibly organized
    in subfolders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainDbContext`: This is the skeleton of the project Entity Framework DB context,
    which also contains the implementation of the `IUnitOfWork` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Extensions`: This folder contains two extension classes. `RepositoryExtensions`
    just provides the `AddAllRepositories` extension method, which discovers all repository
    implementations and adds them to the dependency injection engine. Its code is
    similar to one of the `AddAllCommandHandlers` extension methods that we described
    in the previous subsection, so we will not describe it here. `DBExtension` contains
    just the `AddDbDriver` extension method, which adds all implementations provided
    by `DBDriver` to the dependency injection engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the `AddDbDriver` extension method is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It accepts the database connection string as its only input and adds the `MainDbContext`
    Entity Framework context as implementation for the `IUnitOfWork` interface with
    the usual `AddDbContext` Entity Framework Core extension method. Then, it calls
    the `AddAllRepositories` method to add all repository implementations provided
    by `DBDriver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `MainDbContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The class is defined as internal since it must not be visible outside of the
    database driver. All entity configurations must be placed inside the `OnModelCreating`
    method as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `IUnitOfWork` is minimized. The exploded code is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `IUnitOfWork` implementation is straightforward since it consists of a one-to-one
    coupling with `DBContext` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Since we expose just `IUnitOfWork` in the dependency injection engine, all repositories
    that need `MainDbContext` for their job must require `IUnitOfWork` in their constructors,
    and then they must cast it to `MainDbContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Having discussed what we need to know about `DBDriver`, let’s move to the Web
    API project.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the outermost project of an Onion Architecture is easy. We just need
    to call the extension method exposed by the application services, which injects
    all application services implementations in the dependency injection engine, and
    we need to call the extension methods of all drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we need to add just two calls to `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At this point, in the case of the ASP.NET Core project, all that remains is
    to acquire the command handlers for the commands that we need in the constructors
    of our controllers. After that, each action method must just use the input that
    it received to build adequate commands, and then it must invoke the handler associated
    with each command.
  prefs: []
  type: TYPE_NORMAL
- en: The short description of how to handle the outermost layer of an Onion Architecture
    completes our short introduction to this architecture, but we will find examples
    throughout the remainder of the book since we will use them for most of our code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to another important building block of microservices architecture:
    containers!'
  prefs: []
  type: TYPE_NORMAL
- en: Containers and Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already discussed the advantages of having microservices that don’t depend
    on the environment where they run; microservices can be moved from busy nodes
    to idle nodes without constraints, thus achieving a better load balance and, consequently,
    better usage of the available hardware.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we need to mix legacy software with newer modules or if we would
    like to use the best stack for each module, with the ability to mix several development
    stack implementations, we are faced with the problem that each different stack
    has different hardware/software prerequisites. In these cases, the independence
    of each microservice from the hosting environment can be restored by deploying
    each microservice, together with all its dependencies, on a private virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, starting a virtual machine with its private copy of the operating
    system takes a lot of time, and microservices must be started and stopped quickly
    to reduce load-balancing and fault recovery costs. Luckily, microservices can
    rely on a lighter form of virtualization technology: containers. Containers provide
    a lightweight and efficient form of virtualization. Unlike traditional virtual
    machines that virtualize an entire machine, including the operating system, containers
    virtualize at the operating system’s filesystem level, sitting on top of the host
    operating system kernel. They use the operating system of the host machine (kernel,
    DLLs, and drivers) and use the operating system’s native features to isolate processes
    and resources, creating an isolated environment for the images they run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how containers work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Container basic principles](img/B31916_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Container basic principles'
  prefs: []
  type: TYPE_NORMAL
- en: Containers are run by the containers’ runtime from **images** that encode their
    content. The same image can create several identical containers. Images are stored
    in **image registries** that identify them through both an image name and an image
    version. In turn, images are created by commands in a text file that specify both
    the container’s content and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, names are URLs whose domain part is the registry domain,
    and the path part is composed of a namespace that includes related images and
    a repository name. The version is attached to this URL with a colon and is called
    `tag` since it can be any string. Summing up, the name and version are encoded
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, for instance, the ASP.NET CORE 9.0 runtime Docker image’s full URL is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `mcr.microsoft.com` is the registry domain, `dotnet` is the namespace,
    `asp.net` is the repository name, and `9.0` is the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any runtime that needs to create containers downloads its image from a registry,
    possibly providing credentials, and then uses the downloaded images to create
    the containers. The following figure shows the whole process of container creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Containers/images lifecycle](img/B31916_03_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Containers/images lifecycle'
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of the book, we will use Docker containers as a de facto standard.
    Each Docker image is generated by specifying changes to apply to another preexisting
    image with the **Docker containers description language**. The instructions for
    creating a Docker image are contained in a file that must be named **Dockerfile**
    (without any file extension).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each **Dockerfile** usually starts with a `FROM` instruction that specifies
    the preexisting image to modify, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The tag with the ASP.NET CORE version to use is specified after the image URL,
    preceded by a colon, as shown in the preceding code. Images taken from private
    repositories must be specified with their complete URL, which starts with the
    domain of the registry. Images without their complete URL are allowed only when
    they are hosted on the Docker free public registry, `hub.docker.com/r/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the hierarchical organization of Docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Hierarchy of images and containers](img/B31916_03_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Hierarchy of images and containers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` statement specifies the environment you are in, called the **build
    stage**. After that, you can deal with the image as if it were a filesystem by
    copying files from your computer into it and by executing shell commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Building the image](img/B31916_03_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Building the image'
  prefs: []
  type: TYPE_NORMAL
- en: In all copy operations, you can use relative paths on your computer. They are
    assumed to be relative to the directory that contains the `Dockerfile` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main `Dockerfile` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: WORKDIR <path in the image file system>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This instruction defines the current directory in the image filesystem. If the
    directory doesn’t exist, it is created. After that, you can use relative paths
    also in the image filesystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: COPY <path in your computer> <path in the image>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy one or more files into the image filesystem. If the source path denotes
    a folder, the whole folder is recursively copied; otherwise, a single file is
    copied. In any case, the directory or file copied takes the name specified in
    the image path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy <path1> <path2> … ./ (or [<path1>, <path2>, …, ./]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content specified by all source paths is copied into the image’s current
    directory. Source file names are not changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy –-from=<image name or url>:<version> …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This works like the previous copy commands but files are taken from the image
    specified by the name/URL after `from=`. A name can be specified instead of a
    URL only if the image is contained in your computer or the Docker public repository.
    If no version is specified, `latest` is assumed as the default version name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RUN <command> <arg1> <arg2> ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This executes the specified shell command with the specified arguments in the
    current directory of the image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CMD [<command>, <arg1>, <arg2>, ...]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This specifies what happens when the container is executed. More specifically,
    it declares both the command and arguments to run when the container is executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: EXPOSE <port1> <port2>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This declares all ports supported by the container. Network traffic should be
    redirected into the container only through the ports declared here, but traffic
    directed to other ports is not blocked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A Dockerfile can also build intermediary images as a step to define the final
    image. For instance, an image containing the whole .NET SDK can be created with
    the only purpose of compiling a .NET solution. Then, the final binaries will be
    copied with the `Copy –-from=…` instruction in the final image, which contains
    just the .NET runtime. We will analyze this possibility in more detail when discussing
    Visual Studio support for Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a very simple example to familiarize ourselves with both Dockerfile
    instructions and the shell commands that manipulate Docker images and containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Desktop: a simple example'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to operate with Docker on a client computer, you need to install **Doker
    Desktop**. Please refer to the instructions in the *Technical requirements* section
    for its installation. As described in the *Technical requirements* section, all
    examples suppose a Windows machine with WSL installed and Docker Desktop configured
    for Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed Docker Desktop, you will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker runtime, so you can instantiate containers from images, and run them
    on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker client, so you can compile Dockerfiles into images, and execute other
    Docker-related shell commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker local registry. All images compiled on your computer will be placed
    here. From here, you can move them to other registries. Moreover, before creating
    containers on your machine, you need to download their images here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to show the power of Docker, we will start with a simple Java example.
    You will see that you don’t need either the Java runtime or Java SDK to compile
    and run a simple Java program because everything needed is downloaded into the
    image being built.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a folder in which to place all the files needed to build
    the image. Let’s call it `SimpleExample`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this folder, place a `Hello.java` file containing the following simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the same folder, we need just a Dockerfile with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`eclipse-temurin` is a Java SDK. This will enable us both to compile and execute
    Java code in our image and our containers. Then, the code copies everything in
    our folder into the newly created `/var/www/java` path in the image being built.
    Please remember that relative paths on the source are evaluated with respect to
    the position of the Dockerfile.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we move to the `var/www/java` folder and run the Java compiler, which
    will create a `.jar` file in the same folder. The `CMD` instruction specifies
    invoking the Java command on the previously created `.jar` file when a container
    based on this image will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need a Linux shell opened in our `SimpleExample` folder to execute Docker
    commands. Right-click on the image of the `SimpleExample` folder by simultaneously
    pressing the *shift* key, and choose the option to open a Linux shell from the
    menu that appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we need to *build* our `Dockerfile` instructions to create
    an image. This is done with the `build` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first argument specifies the location of the Dockerfile, while the `-t`
    option specifies a tag (an image URL) to attach to the image, in our case, `simpleexample`.
    Since the image will be placed in our local Docker Desktop registry, it is enough
    to specify the repository part of the URL, but if you have several local images,
    you can also add a namespace to better classify your images. Usually, at this
    stage, no version tag is added, and Docker assumes the `latest` default tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: all image names must be lowercase!'
  prefs: []
  type: TYPE_NORMAL
- en: The compilation might take a few seconds. If you look at the console while it
    is compiling, you can see that other images are recursively downloaded, because
    each image is built upon other images, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, issue the `docker images` command to see all images defined on your local
    registry. You should see `simpleexample` among them. Images are also listed in
    the UI that appears when you double-click on the Docker Desktop icon on your desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a container based on the newly created images. The `run`
    command creates a container based on a given image and immediately executes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `--name` option specifies a name for the container while the other argument
    is the name of the image we want to use to create the container. The container
    prints the string we put in our Java class and then exits quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s list all executing containers with `docker ps`. No container has been
    listed since our container finished its execution. However, we can see also all
    non-running containers with the `--all` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s re-execute our container. If we re-execute the `run` command, we will
    create another container, so the right way to re-execute a sleeping container
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: However, in this case, no string is printed on the console because `restart`
    runs the container into another process. You might find this strange but it is
    not, because containers usually run a never-ending loop that might block your
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neverending containers can be stopped with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have finished with your container, you can remove it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can remove also the image used to create the container with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You have learned a lot of useful Docker shell commands. The next section is
    dedicated to the description of some more advanced useful commands.
  prefs: []
  type: TYPE_NORMAL
- en: A few more Docker commands and options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During microservice operations, Docker containers are moved from one hardware
    node to another to balance the load. Unfortunately, when a container is removed
    to create it elsewhere, all files saved in its filesystem are lost. For this reason,
    some portions of the container’s filesystem are mapped to external storage, typically
    provided by network disk units.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible because the `run` command has the option to map a directory
    in the host machine (say, `S`) to a directory in the container’s internal storage
    space (say, `D`) so that files written to `D` are actually saved in `S`, and remain
    safe also after the container has been removed. This operation is called **bind
    mount**, and the option to add it to the `run` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option allows the mapping of each port exposed by the container to
    an actual port on the host computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This option can be repeated several times to map more than one port. Without
    this option, it would be impossible to redirect network traffic inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-e` option passes operating system environment variables to the container.
    The code running in the container can easily ask the values of these variables
    to the operating system, so they are the preferred way to configure an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful option of the `run` command is the `-d` option (*d* stands for
    *detached*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When this option is provided, the container is launched detached from the current
    shell prompt, that is, in a different process. This way, a container that hosts
    a never-ending program, such as a web server, doesn’t block the shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each image can be attached to an indefinite number of tags that can be used
    as alternative names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tagging is the first step for pushing a local image into a public registry.
    Suppose we have an image called `myimage` that we would like to push to a private
    registry we have on Azure, say, `myregistry.azurecr.io/`. Suppose we would like
    to place this image in the `mypath/mymage` path of this registry, that is, to
    `myregistry.azurecr.io/mypath/mymage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we tag our image with its final URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it is enough to execute a `push` operation that uses the new tag attached
    to the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Pulling public registry images to our local registry instead is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Before interacting with a registry that requires a login, we must perform a
    login operation. Each registry has its own login procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to log in to an Azure registry is by using the Azure CLI.
    You can download its installer here: [https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, log in to your Azure account with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should start your default browser and should drive you through
    the manual login procedure in your Azure account. Once logged in to your Azure
    account, you can log in to your private registry by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<registryname>` is the unique name of your Azure registry, not its complete
    URL. After logging in, you can freely work with your Azure registry.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio has native support for Docker. Let’s analyze all the possibilities
    offered by this support.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio support for Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio support for Docker can be enabled by simply selecting the **Enable
    container support** checkbox in the appropriate Visual Studio project options.
    Let’s experiment with an ASP.NET Core MVC project. After the project selection
    and after having chosen the project name, say, `DockerTest`, you should arrive
    at the following option page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: Enabling Docker support](img/B31916_03_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Enabling Docker support'
  prefs: []
  type: TYPE_NORMAL
- en: Please check the **Enable container support** checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: If you forgot to enable Docker support here, you can always right-click on the
    project icon in Visual Studio Solution Explorer and then select **Add** -> **Docker
    support**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project contains a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: Visual Studio Dockerfile](img/B31916_03_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Visual Studio Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Dockerfile; it should contain the definition of four images. In
    fact, the final image is built in four stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first stage defines the .NET runtime and the ports used by the application
    in the final image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `base` after `AS` will be called by other `FROM` instructions in the
    same file. The second stage performs the project build by using the `dotnet` SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `ARG` instruction defines a variable that can be recalled as `$BUILD_CONFIGURATION`
    in other instructions. Here, it is used to define the chosen configuration for
    the build. You can replace its value with `Debug` to compile in Debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: The first `Copy` instruction just copies the project file in the `/src/DockerTest`
    directory of the image. Then, Nuget packages are restored and all source files
    are copied from the directory containing the Dockerfile to the current image directory,
    `/src`. Finally, we move into `/src/DockerTest` and perform a build. The build
    output files are placed in the `/app/build` directory in the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third stage is built on top of the `build` image and simply publishes the
    project files in the `/app/publish` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We could have merged stages 2 and 3 into a single stage but it is convenient
    to split stages into smaller stages because intermediary images are cached, so
    in subsequent builds, when the image input does not change, cached images are
    used instead of recomputing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the fourth and last stage is built on top of the first stage since
    it just needs the .NET runtime, and simply copies the published files from the
    image created in the third stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, place a breakpoint in the `Index` method of the `HomeController.cs` file
    and run the solution. Visual Studio automatically builds the Dockerfile and runs
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: The breakpoint will be hit since Visual Studio is able to perform debugging
    inside the container images!
  prefs: []
  type: TYPE_NORMAL
- en: 'While the application is running, for each container, Visual Studio shows logs,
    environment variables, bind mounts, and other information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17: Visual Studio Containers console](img/B31916_03_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: Visual Studio Containers console'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get also an interactive shell inside each container where you can explore
    the container’s filesystem, execute shell commands, and perform diagnostics and
    performance measurement operations, by simply opening a Linux shell and issuing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, let’s list all running containers with `docker ps` to get our
    container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are in the container filesystem! Let’s try some shell commands, such
    as `Is`, for instance. When you have finished with the container, it is enough
    to run `exit` to return to your host computer console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter described two important building blocks of microservices architectures:
    the Onion Architecture and Docker containers. The chapter described the basic
    principles of the Onion Architecture and how both the Application Services and
    Domain layers are organized. More specifically, we described commands, queries,
    events, and their handlers together with aggregates and value objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you learned how to use the preceding concepts in a Visual Studio solution
    thanks to the Visual Studio solution templates provided.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter explained the importance of containers, how to build a Dockerfile,
    and how to use Docker shell commands in practice. Finally, the chapter described
    Visual Studio support for Docker.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on Azure functions and their main triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it true that the Domain layer project must have a reference to the database
    driver project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it is false. References to drivers must be added to the infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: Which solution projects are among the application services references?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only those projects that are part of the Domain Layer.
  prefs: []
  type: TYPE_NORMAL
- en: Which solution projects are among the references of the outermost layer project
    of an Onion Architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application Services, Db Drivers, and all infrastructure drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Is it true that an aggregate always corresponds to a unique database table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it is false.
  prefs: []
  type: TYPE_NORMAL
- en: Why are domain events needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are needed to decouple the code of different aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the `WORKDIR` Dockerfile instruction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To set the image current directory.
  prefs: []
  type: TYPE_NORMAL
- en: How is it possible to pass environment variables to a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through the -e options of the docker run command.
  prefs: []
  type: TYPE_NORMAL
- en: What is the right way to persist the storage of Docker containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Volume binds is the way to persist the storage of Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More on queries, commands, and the domain layer can be found here: [https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on Docker can be found on Docker’s official website: [https://docs.docker.com/](https://docs.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
