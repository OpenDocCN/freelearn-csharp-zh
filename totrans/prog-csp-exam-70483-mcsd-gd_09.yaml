- en: Managing the Object Life Cycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象生命周期
- en: C# is a managed language. Unlike other languages, such as C++, where we need
    to explicitly manage memory cleanup, in C# we do not need to worry about it. The
    garbage collector in the .NET Framework manages the allocation and release of
    memory for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种托管语言。与需要显式管理内存清理的其他语言，如C++不同，在C#中我们不需要担心这一点。.NET Framework中的垃圾回收器为我们管理内存的分配和释放。
- en: The garbage collector ensures that, as long as we use managed types, that is,
    value and reference type variables, then we don't have to explicitly destroy an
    object in order to free its memory. However, as we discovered in [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml),
    *Creating and Using Types in C#*, C# also gives us the freedom to utilize the
    capabilities of pointer object types in it. In C#, we must declare that code using
    the unsafe syntax. Apart from that, for variables declared in unsafe code, we
    also need to manage the release of memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器确保只要我们使用托管类型，即值类型和引用类型变量，我们就不需要显式销毁对象来释放其内存。然而，正如我们在[第8章](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml)，*在C#中创建和使用类型*中发现的，C#也赋予我们利用指针对象类型的能力。在C#中，我们必须声明使用不安全语法的代码。除此之外，对于在不安全代码中声明的变量，我们还需要管理内存的释放。
- en: 'In this chapter, as well as looking into memory management for unsafe code
    we will delve into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，除了探讨非托管代码的内存管理外，我们还将深入研究以下主题：
- en: The differences between managed and unmanaged code in C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中托管代码和非托管代码的区别
- en: How garbage collection works in C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中垃圾回收的工作原理
- en: How a garbage collector uses a managed heap to allocate memory to objects during
    application execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在应用程序执行期间，垃圾回收器使用托管堆为对象分配内存
- en: Understanding the mark-compact algorithm used by the garbage collector
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解垃圾回收器使用的标记-压缩算法
- en: How to manage unmanaged resources in C#
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中管理非托管资源
- en: Understanding finalization and the performance implications of using the finalize
    method
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解终结和终结方法的使用对性能的影响
- en: Understanding the `IDisposable` interface and how it helps overcome the shortcomings
    of the finalize method
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`IDisposable`接口以及它如何帮助克服终结方法的不足
- en: Understanding how we can combine the `Dispose` method with the finalize method
    to ensure the best performance of our applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何将`Dispose`方法与终结方法结合使用，以确保我们应用程序的最佳性能
- en: Understanding using the `using` block for all classes that implement the `IDisposable`
    interface
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使用`using`块为所有实现`IDisposable`接口的类
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As with the previous chapters in this book, the programs explained here will
    be developed in VS 2017.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中前面的章节一样，这里解释的程序将在VS 2017中开发。
- en: The example code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples)。
- en: Managed code versus unmanaged code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管代码与非托管代码的比较
- en: In this section, we will understand the difference between managed and unmanaged
    code. Recall that we also studied this in [Chapter 1](ccec4122-6067-4279-843b-6123b1eff017.xhtml),
    *Learning the Basics of C#*. Therefore, for a quick recap, we will just revise
    the concepts that we covered there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解托管代码和非托管代码之间的区别。回想一下，我们也在[第1章](ccec4122-6067-4279-843b-6123b1eff017.xhtml)，*学习C#基础知识*中学习了这一点。因此，为了快速回顾，我们只需复习那里覆盖的概念。
- en: 'These concepts apply not just to the C# language, they are also relevant to
    all languages written in the .NET Framework. The following are some of the differences
    between managed and unmanaged code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念不仅适用于C#语言，也适用于所有在.NET Framework中编写的语言。以下是一些托管代码和非托管代码之间的区别：
- en: Managed code is executed by the **Common Language Runtime** (**CLR**). Due to
    this, the code is independent of the underlying OS. On the other hand, unmanaged
    code is code that is executed by the OS directly.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管代码由**公共语言运行时**（**CLR**）执行。因此，代码与底层操作系统独立。另一方面，非托管代码是直接由操作系统执行的代码。
- en: In the case of managed code, the code is independent of the underlying framework
    or the OS. CLR compiles the code into an **Intermediate Language** (**IL**) code,
    which is then compiled to machine code. IL code consists of an underlying system
    or the OS on which the program is executing. On the other hand, in the case of
    unmanaged code, the code is directly compiled to the underlying machine code.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管理代码的情况下，代码与底层框架或操作系统是独立的。CLR 将代码编译成中间语言（**IL**）代码，然后将其编译成机器代码。IL 代码由程序正在执行的底层系统或操作系统组成。另一方面，在非管理代码的情况下，代码直接编译成底层机器代码。
- en: As managed code is executed by the CLR, the .NET Framework provides several
    built-in capabilities such as garbage collection and type checking exceptions.
    However, for unmanaged code, as we will learn in this chapter, a programmer needs
    to explicitly manage memory cleanup activities, which are otherwise done by the
    garbage collector.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于管理代码是由 CLR 执行的，.NET 框架提供了几个内置功能，如垃圾回收和类型检查异常。然而，对于非管理代码，正如我们将在本章中学习的，程序员需要显式管理内存清理活动，否则这些活动将由垃圾回收器执行。
- en: Now, before we learn how a programmer can manage memory for unmanaged code,
    let's first understand how garbage collection works in C# and how useful it is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们学习程序员如何管理非管理代码的内存之前，让我们首先了解 C# 中的垃圾回收是如何工作的以及它有多有用。
- en: Garbage collection
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Garbage collection is a functionality, provided by CLR in .NET, which helps
    us to clean up the memory occupied by managed objects. It is a thread that executes
    in the .NET Framework and, at regular intervals, checks whether there is any unused
    memory in the application. If it does find memory, then it reclaims that memory
    and destroys the underlying object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是 .NET 中由 CLR 提供的一种功能，它帮助我们清理由管理对象占用的内存。这是一个在 .NET 框架中执行的线程，并且定期检查应用程序中是否有任何未使用的内存。如果它确实找到了内存，那么它将回收该内存并销毁底层对象。
- en: 'Suppose we have implemented a .NET web application in C#. Now, let''s assume
    that during any interval of time, there are several people who are trying to access
    this .NET application. The following is one particular scenario that will give
    us an idea of why garbage collection is a very important part of C# or, for that
    matter, any .NET application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经使用 C# 实现了一个 .NET 网络应用程序。现在，让我们假设在任何时间间隔内，都有多个人试图访问这个 .NET 应用程序。以下是一个特定的场景，它将给我们一个关于为什么垃圾回收是
    C# 或任何 .NET 应用程序非常重要的部分的启示：
- en: When a user browses the application, they can execute a number of functionalities,
    such as accessing their profile or executing operations (for example, creating,
    updating, and deleting information).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户浏览应用程序时，他们可以执行许多功能，例如访问他们的个人资料或执行操作（例如创建、更新和删除信息）。
- en: This information can be stored in different sources such as SQL, Oracle, or
    more.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此信息可以存储在不同的来源中，例如 SQL、Oracle 或更多。
- en: To access this information and to execute these operations, the application
    will require the creation of different objects during the application runtime.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了访问此信息和执行这些操作，应用程序将在应用程序运行时需要创建不同的对象。
- en: Assuming a scenario where memory is just being allocated to different objects
    but is not being cleaned up, over the course of time we will end up with a system
    that has too much unused memory. Memory cleanup is logical when the object declared
    in the memory is no longer required. For example, suppose that a user, after performing
    the intended operations in the application, logs out. In this case, the memory
    that was allocated for the operations of that particular user is no longer required.
    Therefore, that memory can be reclaimed.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设一个场景，其中内存正在分配给不同的对象，但没有被清理，随着时间的推移，我们将最终得到一个拥有过多未使用内存的系统。当内存中声明的对象不再需要时，内存清理是逻辑的。例如，假设用户在应用程序中执行了预期的操作后注销。在这种情况下，为该特定用户的操作分配的内存不再需要。因此，可以回收该内存。
- en: A the memory allocated to the application could be limited, this will lead to
    performance degradation over time.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分配给应用程序的内存有限，这将在一段时间后导致性能下降。
- en: Garbage collection in the .NET Framework ensures that such situations never
    arise for managed code. This thread runs in the background of the application
    and, at set intervals, reclaims the memory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架中的垃圾回收确保了管理代码不会出现此类情况。此线程在应用程序的背景中运行，并在设定的时间间隔内回收内存。
- en: Please note that garbage collection can only reclaim the unused memory of managed
    code. For unmanaged code, which we will learn about later, we need to explicitly
    write code to ensure that no memory leaks occur in the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，垃圾回收只能回收托管代码的未使用内存。对于稍后我们将学习的非托管代码，我们需要显式编写代码以确保应用程序中不会发生内存泄漏。
- en: 'The garbage collector in .NET executes the following tasks in an application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的垃圾回收器在应用程序中执行以下任务：
- en: '**Allocation of memory**: Each application running on .NET maintains a memory
    block required for its execution in a managed heap. The garbage collection manages
    the allocation of memory from this heap structure to the objects used in the program.
    In upcoming sections, we will learn more about managed heaps.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分配**：在.NET上运行的每个应用程序都在托管堆中维护一个执行所需的内存块。垃圾回收管理从该堆结构到程序中使用的对象的内存分配。在接下来的章节中，我们将了解更多关于托管堆的内容。'
- en: '**Deallocation of memory**: The garbage collector runs at set time periods
    during the application runtime and looks for objects that are no longer required
    by the application. It then destroys those objects and reclaims the memory for
    future use.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存释放**：垃圾回收器在应用程序运行时以设定的时间间隔运行，寻找应用程序不再需要的对象。然后销毁这些对象，并为未来的使用回收内存。'
- en: 'The garbage collector reclaims the memory when one of the following three conditions
    occurs during the execution of a program:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当程序执行期间出现以下三种条件之一时，垃圾回收器会回收内存：
- en: '**The application has low memory**: Each application running in .NET requires
    memory for its successful execution. If CLR determines that the application is
    getting free low memory from the OS, it tells the garbage collector to free any
    unused memory.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序内存不足**：在.NET上运行的每个应用程序都需要内存以成功执行。如果CLR确定应用程序从操作系统获得空闲的内存，它会告诉垃圾回收器释放任何未使用的内存。'
- en: '**The relocation of memory**: Garbage collection in C# is based on generations.
    Generations are simply divisions in the managed heap used by the application.
    In C#, we can have three generations: generation 0, generation 1, and generation
    2\. In upcoming sections, we will learn how generations are classified. The garbage
    collector tries to optimize the performance of the system by classifying the objects
    used in the application among the three generations of a managed heap. In generation
    0, it keeps the newly created objects in the application run. In comparison, in
    successive runs it identifies the objects that are being used for a longer period
    in the application execution. It classifies them as generation 1 and generation
    2 and then loops through these generations less extensively than it does for generation
    0\. This, therefore, results in better performance.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存重定位**：C#中的垃圾回收基于代。代只是应用程序使用的托管堆中的划分。在C#中，我们可以有三个代：0代、1代和2代。在接下来的章节中，我们将学习如何对代进行分类。垃圾回收器试图通过将应用程序中使用的对象分类到托管堆的三个代中，来优化系统的性能。在0代中，它将新创建的对象保留在应用程序运行中。相比之下，在后续运行中，它识别出在应用程序执行中被使用时间较长的对象。它将它们分类为1代和2代，然后比0代更少地遍历这些代。因此，这导致了更好的性能。'
- en: '**When the** **Collect** **method is called**: As programmers, we hardly need
    to call the garbage collector method explicitly, as .NET is smart enough to ensure
    that garbage collection occurs at regular intervals. However, there could be certain
    scenarios where we would need to call this method explicitly. In such cases, we
    can do it by calling the `GC.Collect` method. In this chapter, we will look at
    a program implementation in which we do this.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当调用** **Collect** **方法时**：作为程序员，我们几乎不需要显式调用垃圾回收方法，因为.NET足够智能，能够确保垃圾回收定期发生。然而，在某些情况下，我们可能需要显式调用此方法。在这种情况下，我们可以通过调用`GC.Collect`方法来实现。在本章中，我们将查看一个程序实现示例，其中我们就是这样做的。'
- en: Now, let's go through some of the basic structures that garbage collection works
    with in C#. We will start with a managed heap, which we will explore in the next
    section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下垃圾回收在C#中与之协同工作的基本结构。我们将从托管堆开始，我们将在下一节中对其进行探索。
- en: Managed heap
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**托管堆**'
- en: When an application is executed in the .NET Framework, the garbage collector
    allocates a section of memory to store and manage the objects declared during
    the application execution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在.NET框架中执行时，垃圾回收器为存储和管理应用程序执行期间声明的对象分配一段内存。
- en: 'This memory is referred to as the managed heap. It''s called "managed" because
    it''s used to save the managed variables. The following diagram illustrates what
    a typical heap structure looks like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内存被称为托管堆。它被称为“托管”，因为它用于保存托管变量。以下图表展示了典型的堆结构：
- en: '![](img/fb6be0e3-aaa6-48a7-b1fb-cfff26f5889a.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb6be0e3-aaa6-48a7-b1fb-cfff26f5889a.png)'
- en: The preceding diagram is a typical example of what a heap structure looks like.
    At the top of the structure, we have a root node. Each node can have two child
    nodes. The address of the child node is saved in the parent node itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是典型的堆结构示例。在结构的最顶部，我们有一个根节点。每个节点可以有多个子节点。子节点的地址被保存在父节点本身中。
- en: The garbage collector allocates and deallocates memory on this managed heap.
    The heap is referred to as the managed heap. When an object is allocated in the
    application, the object is stored in the heap. The object then saves the reference
    to the next object in the heap.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器在这个托管堆上分配和释放内存。这个堆被称为托管堆。当应用程序中分配一个对象时，该对象被存储在堆中。然后对象保存对堆中下一个对象的引用。
- en: While allocating the memory, the CLR checks whether any free memory is available
    in the heap. If memory is available, it allocates it from the heap. However, every
    so often, the garbage collector performs a check on all of the objects present
    in the managed heap and checks whether the object is being used in the application.
    The garbage collector loops through the heap and finds out which objects are not
    associated with the application root as well as those that are not referred to
    anywhere in the heap. These objects are classified as dead objects. The garbage
    collector then removes such dead objects from the heap.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配内存时，CLR会检查堆中是否有可用的空闲内存。如果有内存可用，它就会从堆中分配。然而，垃圾收集器会不时地对托管堆中所有对象进行检查，以确定对象是否在应用程序中被使用。垃圾收集器遍历堆，找出那些与应用程序根不相关以及在任何地方都没有被引用的对象。这些对象被归类为死亡对象。然后，垃圾收集器将这些死亡对象从堆中移除。
- en: Before we can begin to understand the phases in which the garbage collector
    works, let's understand how the garbage collector segregates the managed heap
    into different divisions called **generations**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始理解垃圾收集器工作的各个阶段之前，让我们先了解垃圾收集器是如何将托管堆划分为不同的部分，这些部分被称为**代**。
- en: Generations
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代
- en: 'The garbage collector segregates the managed heap into three divisions or generations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器将托管堆划分为三个部分或代：
- en: Generation 0
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代0
- en: Generation 1
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代1
- en: Generation 2
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代2
- en: The idea behind this is to optimize the application by handling long-lived and
    short-lived objects in memory separately. For example, if we have determined that
    object `a` is a long-term object used during the application execution, then,
    ideally, the garbage collector would not want to check through this object on
    every occasion in order to see whether it is still valid.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是通过在内存中分别处理长寿命和短寿命对象来优化应用程序。例如，如果我们确定对象`a`是在应用程序执行期间使用的长期对象，那么理想情况下，垃圾收集器就不希望在每次检查时都查看这个对象是否仍然有效。
- en: Instead, the garbage collector classifies short-term objects in generation 0
    and long-term objects in generation 1 or 2\. Only objects present in generation
    0 are checked during every run of the garbage collection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，垃圾收集器将短期对象归类到代0，将长期对象归类到代1或2。只有在每次垃圾收集运行时，才会检查存在于代0中的对象。
- en: On the other hand, the objects present in higher generations are not checked
    as frequently. Therefore, this avoids unnecessary checks and improves the performance
    of the overall application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，高代中的对象不会被频繁检查。因此，这避免了不必要的检查，提高了整体应用程序的性能。
- en: Generation 0 is the youngest generation and all new objects are allocated to
    generation 0\. Generation 1 objects contain objects that live longer. Similarly,
    generation 2 consists of the longest living objects in the application execution.
    Let's go through the following example to see how generations help in optimizing
    application performance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代0是最年轻的代，所有新的对象都分配到代0。代1的对象包含寿命较长的对象。同样，代2由应用程序执行中最长寿的对象组成。让我们通过以下示例来看看代是如何帮助优化应用程序性能的。
- en: Let's say we have an application, *A*, which is declaring different objects
    during execution. The square brackets indicate the different divisions or generations
    maintained by the garbage collector. Each of the following steps indicates a particular
    stage during the application execution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，*A*，它在执行过程中声明了不同的对象。方括号表示垃圾收集器维护的不同分区或代。以下每个步骤都表示应用程序执行过程中的一个特定阶段。
- en: Please note that the following example is just for explanation purposes only.
    The garbage collection calls will depend on different factors and are not necessarily
    be based upon the scope of the function execution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下示例仅用于说明目的。垃圾收集调用将取决于不同的因素，并不一定基于函数执行的范围。
- en: 'Let''s take a look at the following code example and see how it works. In the
    code example, we have declared a private `ReturnResult` function, which does not
    have any input parameter and returns an output parameter of the `object` type.
    In this function, just for the sake of explanation, we have declared some variables
    and are returning back one variable, `a`, to the calling function. Now, let''s
    execute the code as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码示例，看看它是如何工作的。在代码示例中，我们声明了一个私有的`ReturnResult`函数，该函数没有输入参数，并返回一个`object`类型的输出参数。在这个函数中，仅为了说明，我们声明了一些变量，并将一个变量`a`返回给调用函数。现在，让我们按照以下方式执行代码：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the application execution begins, the application calls the `ReturnResult`
    function. Then, in the function, when the execution encounters the `new` keyword,
    the garbage collector gets triggered. As all the variables are newly created variables,
    these variables will be added to generation 0:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序执行开始时，应用程序调用`ReturnResult`函数。然后，在函数中，当执行遇到`new`关键字时，垃圾收集器被触发。由于所有变量都是新创建的变量，因此这些变量将被添加到第0代：
- en: '![](img/5a8fd323-914d-4cdc-9611-1863f0c0e418.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a8fd323-914d-4cdc-9611-1863f0c0e418.png)'
- en: Now, suppose that in the next statement, we return the execution to the main
    function and pass object `a`. By doing so, the program execution shifts to the
    main operation. However, as we are just returning `a`, all the other `b`, `c`,
    `d`, and `e` objects will no longer be required in the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设在下一个语句中，我们将执行权返回到主函数，并传递对象`a`。通过这样做，程序执行转移到主操作。然而，因为我们只是返回`a`，所以其他所有`b`、`c`、`d`和`e`对象在应用程序中就不再需要了。
- en: Additionally, we are also declaring new objects, `f`, `g`, and `h`, in the main
    program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在主程序中声明了新的对象`f`、`g`和`h`。
- en: If the garbage collector is called during this time, it will identify that object
    `a` is still required in the program execution but all other objects can be released.
    Therefore, the garbage collector will reclaim the memory in the variables `b`,
    `c`, `d`, and `e`. The new objects, `f`, `g`, and `h`, will be added to generation
    0\. For object `a`, the garbage collector will assume that it's a long-lived object
    and this will be moved to the generation 1 division.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个时候调用垃圾收集器，它将确定对象`a`在程序执行中仍然需要，但所有其他对象都可以释放。因此，垃圾收集器将回收变量`b`、`c`、`d`和`e`中的内存。新的对象`f`、`g`和`h`将被添加到第0代。对于对象`a`，垃圾收集器将假设它是一个长期存在的对象，这将移动到第1代分区。
- en: 'This is what the generations now look like:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些代看起来是这样的：
- en: '![](img/0752b5d9-b10d-412c-8b7a-d4ef0e66a77f.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0752b5d9-b10d-412c-8b7a-d4ef0e66a77f.png)'
- en: 'Now, let''s suppose that, again, the main program calls for another `ReturnResultFinal`
    function passing object `a`. The newly added program does not return anything
    back. The following is the code implementation for this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设，再次，主程序调用另一个`ReturnResultFinal`函数，传递对象`a`。新添加的程序不返回任何内容。以下是这个功能的代码实现：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this stage, the garbage collector can determine that all the other variables
    can be removed from the memory except `a`. During this time, it can also determine
    that this object can be promoted to generation 2\. This is what the generations
    now look like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，垃圾收集器可以确定除了`a`之外的所有其他变量都可以从内存中移除。在此期间，它还可以确定此对象可以被提升到第2代。现在，这些代看起来是这样的：
- en: '![](img/1e35c0c3-1b89-4ece-82eb-6b7be517598f.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e35c0c3-1b89-4ece-82eb-6b7be517598f.png)'
- en: Before we move on to the next topic, let's briefly go through the mark-compact
    algorithm, used by the garbage collector.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，让我们简要地回顾一下垃圾收集器使用的标记-压缩算法。
- en: The mark-compact algorithm
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记-压缩算法
- en: 'The mark-compact algorithm is used by the garbage collector to maintain the
    memory. Essentially, it can be classified into three phases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标记紧凑算法被垃圾收集器用于维护内存。本质上，它可以分为三个阶段：
- en: '**The mark phase**: In the mark phase, the garbage collector loops through
    the different objects in the heap and identifies the one that is being referenced
    by a root item. A root item can be either the starting point of the program execution
    or a particular function. If the element is being referenced, it marks the object.
    All other objects, which are not referenced, are then classified as **dead** objects.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记阶段**：在标记阶段，垃圾收集器遍历堆中的不同对象，并识别出被根项引用的对象。根项可以是程序执行的起点或特定的函数。如果元素被引用，它就会标记该对象。然后，所有未被引用的其他对象被分类为**死亡**对象。'
- en: '**The relocating phase**: In the relocating phase, the garbage collector moves
    all the objects that are being referenced, groups them together, and then updates
    the memory address for each of the next objects in the memory heap.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重定位阶段**：在重定位阶段，垃圾收集器将所有被引用的对象移动，将它们分组，然后更新内存堆中每个后续对象的内存地址。'
- en: In addition to this, the garbage collector also classifies objects that are
    being used in the application to one of the different generations.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，垃圾收集器还将应用程序中正在使用的对象分类到不同的代中。
- en: '**The compacting phase**: In the compacting phase, the garbage collector destroys
    the dead objects classified in the previous phase and reclaims their memory.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩阶段**：在压缩阶段，垃圾收集器销毁上一阶段分类的死亡对象，并回收它们的内存。'
- en: The entire process that the garbage collector undertakes can lead to a performance
    impact on the application. This is due to the fact that during the program execution,
    the garbage collector needs to make sure that the references in the heap are not
    changed during its run. This means that all the other threads of the application
    are paused while the run is in progress.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器所执行的全部过程可能会对应用程序的性能产生影响。这是因为，在程序执行期间，垃圾收集器需要确保在运行过程中堆中的引用没有被更改。这意味着在运行过程中，应用程序的所有其他线程都会暂停。
- en: Fortunately, this situation does not arise often as the garbage collector starts
    cleaning only when the memory available for the application execution is low.
    Therefore, while the memory is high, the collection algorithm does not kick in.
    Additionally, as explained while we were discussing generations, when the garbage
    collection starts, it first checks the generation 0 heap objects. If they survive
    the cleanup, they are promoted to the next generation. For objects in the higher
    generations, the garbage collector assumes that the objects in higher generations
    will probably be used in the application for a longer period of time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种情况并不常见，因为垃圾收集器仅在应用程序执行可用的内存较低时开始清理。因此，当内存较高时，收集算法不会启动。此外，正如我们在讨论代时解释的那样，当垃圾收集开始时，它首先检查0代堆对象。如果它们在清理过程中幸存，它们将被提升到下一代。对于更高代的对象，垃圾收集器假设这些对象将在应用程序中使用更长时间。
- en: In the next section, we will look at how we can explicitly call the garbage
    collection method in C#.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在C#中显式调用垃圾收集方法。
- en: Calling garbage collection
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用垃圾收集
- en: 'Although it''s not recommended, and we hardly find any reason or circumstance
    where we seldom need to call the garbage collector explicitly during the program
    execution, we can use the following syntax to execute the `Collect` method in
    garbage collection. The following is the code implementation for this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不推荐这样做，我们也几乎找不到任何理由或情况，在程序执行期间很少需要显式调用垃圾收集器，但我们可以使用以下语法来执行垃圾收集中的`Collect`方法。以下是对此的代码实现：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`GC` is present in the system namespace. The `Collect` method executes the
    mark-compact algorithm, which we discussed in the previous section. The `WaitForPendingFinalizers`
    method pauses or suspends the current thread until the garbage collector finishes
    its execution.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`GC`存在于系统命名空间中。`Collect`方法执行我们在上一节中讨论的标记紧凑算法。`WaitForPendingFinalizers`方法暂停或挂起当前线程，直到垃圾收集器完成其执行。'
- en: Now that we have a fair understanding of how garbage collection works in C#,
    we will look at how we can perform memory management for unmanaged objects or
    unmanaged code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对C#中的垃圾收集工作原理有了相当的了解，我们将探讨如何对非托管对象或非托管代码进行内存管理。
- en: Managing unmanaged resources
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理非托管资源
- en: 'The garbage collection provided by the .NET Framework is good enough when we
    are dealing with managed objects. However, there are several instances in which
    we need to use unmanaged resources in our code. Some of these instances include
    the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理托管对象时，.NET Framework 提供的垃圾回收器已经足够好了。然而，有几个情况下我们需要在我们的代码中使用非托管资源。以下是一些这样的实例：
- en: When we need to access OS memory using pointers
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要使用指针访问操作系统内存时
- en: When we are doing I/O operations related to file objects
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们进行与文件对象相关的 I/O 操作时
- en: In each of these circumstances, the garbage collector does not explicitly free
    up the memory. We need to explicitly manage the release of such resources. If
    we do not release such resources, then we may end up with problems related to
    memory leaks in the application, locks on OS files, leaks on connection threads
    to resources such as databases, and more.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，垃圾回收器不会明确释放内存。我们需要明确管理这些资源的释放。如果我们不释放这些资源，我们可能会遇到与内存泄漏相关的应用程序问题、操作系统文件上的锁定、连接数据库等资源的连接线程泄漏等问题。
- en: To avoid these situations, C# provides finalization. Finalization allows us
    to cleanup unmanaged code in a class before the garbage collector is invoked.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些情况，C# 提供了终结器。终结器允许我们在垃圾回收器被调用之前在类中清理非托管代码。
- en: Please note that when using finalization, we cannot control when the code specified
    in finalization will be called. It's up to the garbage collector to determine
    when the object is no longer required. However, what we are sure of is that the
    finalization code will be called before the object gets cleaned up by the garbage
    collector.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用终结器时，我们无法控制指定的终结代码何时被调用。这取决于垃圾回收器来决定对象何时不再需要。然而，我们可以确定的是，终结代码将在对象被垃圾回收器清理之前被调用。
- en: 'To declare a finalizer in a class, we use the `~` syntax. The following is
    the code implementation we use to declare a finalizer for a particular class in
    C#:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中声明终结器，我们使用 `~` 语法。以下是我们用于在 C# 中为特定类声明终结器的代码实现：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code example, we have declared a `SampleFinalizerClass` syntax.
    In order to clean up unmanaged resources in the class, we have declared a finalizer.
    The name of the finalizer is the same as that of the class but is appended with
    a `~`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们声明了 `SampleFinalizerClass` 语法。为了在类中清理非托管资源，我们声明了一个终结器。终结器的名称与类名相同，但后面附加了一个
    `~`。
- en: In Finalizer, we can do things such as destroying pointer objects, releasing
    connections on files, releasing connection threads to databases, and more.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在终结器中，我们可以执行诸如销毁指针对象、释放文件连接、释放连接数据库的线程等操作。
- en: Now, although using the `Finalizer` keyword does clean up unmanaged code before
    the object is destroyed by the garbage collector, it does introduce some extra
    overhead for the garbage collector. Let's examine the following example in order
    to understand the reason behind this overhead.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管使用 `Finalizer` 关键字可以在对象被垃圾回收器销毁之前清理非托管代码，但它确实为垃圾回收器引入了一些额外的开销。让我们通过以下示例来了解这种开销背后的原因。
- en: The finalization mechanism
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终结机制
- en: 'In this section, we will understand how the garbage collector performs finalization
    in the .NET Framework. To do finalization, it maintains two queues in the system:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解垃圾回收器如何在 .NET Framework 中执行终结操作。为了执行终结操作，它在系统中维护两个队列：
- en: '**The finalization queue**: The finalization queue is a data structure maintained
    by the garbage collector, which contains a reference to all the objects in a managed
    heap that have implemented the finalize method. Using this queue, the garbage
    collector essentially identifies all the objects that it needs to call the finalize
    method for in order to clean up the unmanaged code before the object can itself
    be destroyed.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终结器队列**：终结器队列是由垃圾回收器维护的数据结构，它包含了对所有在托管堆中实现了终结方法的对象的引用。使用这个队列，垃圾回收器本质上识别出所有需要调用终结方法的对象，以便在对象本身被销毁之前清理非托管代码。'
- en: '**The** **fReachable queue**: The `fReachable` queue is a data structure maintained
    by the garbage collector. It contains a reference to all the objects in the managed
    heap, which, even though they don''t have any reference with the application root,
    can be deleted. However, before deleting them, it must call the finalize method
    to clean up the unmanaged code.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f可达队列**: `fReachable`队列是垃圾回收器维护的数据结构。它包含托管堆中所有对象的引用，尽管它们与应用程序根没有任何引用，但可以被删除。然而，在删除之前，它必须调用终结方法来清理未管理的代码。'
- en: Let's try and understand this with the following example. Suppose we have an
    application wherein we have declared an object class, `A`, which has the finalize
    method. All other objects don't have the finalize method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来尝试理解这一点。假设我们有一个应用程序，其中我们声明了一个具有终结方法的对象类`A`，而其他所有对象都没有终结方法。
- en: 'Please refer to the following representational diagram of the different structures
    that could be in the garbage collector:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下垃圾回收器中可能存在的不同结构的表示图：
- en: '![](img/2dedb77c-e354-4a23-a698-642ff8bf6778.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2dedb77c-e354-4a23-a698-642ff8bf6778.png)'
- en: 'These structures can be described as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构可以描述如下：
- en: '**Program Scope**: This represents the different objects that may be in the
    scope of the application root or, in other words, are being used in the particular
    block of the program.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序作用域**: 这代表可能存在于应用程序根作用域中的不同对象，换句话说，是在程序的特定块中被使用的。'
- en: '**Managed Heap**: This represents the heap memory structure maintained by the
    garbage collector to allocate memory to the objects present in the program scope.
    There are two divisions in the managed heap. One is **Generation 0**, which is
    used for newly created short-lived objects, and another is **Generation 1**, which
    is used to save long-lived objects.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管堆**: 这代表由垃圾回收器维护的堆内存结构，用于为程序作用域中存在的对象分配内存。托管堆中有两个部分。一个是**0代**，用于存放新创建的短生命周期对象，另一个是**1代**，用于存放长生命周期对象。'
- en: '**Finalization Queue**: As indicated previously, this will contain a reference
    to all the objects in a managed heap that have an implementation of the finalize
    method.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终结队列**: 如前所述，这将包含托管堆中所有实现了终结方法的对象的引用。'
- en: '**fReachable Queue**: As indicated previously, this will contain a reference
    to all the objects in a managed heap for which, although they are not used in
    the program scope, the garbage collector needs to call the finalize method before
    their memory can be reclaimed.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f可达队列**: 如前所述，这将包含托管堆中所有对象的引用，尽管它们在程序作用域中未被使用，但在回收其内存之前，垃圾回收器需要调用终结方法。'
- en: 'Take a look at the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下步骤：
- en: 'Declare the following two classes: `SampleFinalizeClass` and `SampleNoFinalizeClass`.
    Please note that the `SampleFinalizeClass` class has a finalize method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下两个类：`SampleFinalizeClass`和`SampleNoFinalizeClass`。请注意，`SampleFinalizeClass`类有一个终结方法：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create three objects; one for `SampleFinalizerClass` and two for `SampleNoFinalizerClass`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个对象；一个用于`SampleFinalizerClass`，两个用于`SampleNoFinalizerClass`：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As objects `b`, `c`, and `d` are newly created objects, they will be added
    to generation 0 in the managed heap. While doing so, the garbage collector will
    also recognize that object `b` needs to have an additional call of the finalize
    method before it can be cleared. It will make this entry in the finalization queue
    by adding a reference to object `b`. The following diagram indicates what this
    would look like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象`b`、`c`和`d`是新创建的对象，它们将被添加到托管堆的0代。在此过程中，垃圾回收器还将认识到对象`b`需要在清除之前进行额外的终结方法调用。它将通过向终结队列添加对象`b`的引用来创建这个条目。以下图表显示了这会是什么样子：
- en: '![](img/129f5e99-00bb-45ef-b767-9b1276a74486.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/129f5e99-00bb-45ef-b767-9b1276a74486.png)'
- en: 'Pass the execution to another function by passing it to object `c`. The following
    is the code snippet for this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将对象`c`传递给另一个函数来传递执行权。以下是这个操作的代码片段：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, suppose that, during program execution when the control is at the `GarbageCollectorFinalize`
    function, the garbage collector gets called. The garbage collector will identify
    that object `d` is no longer required and, therefore, its memory can be reclaimed.
    However, object `c` is being still referenced. Therefore, it will make an assumption
    that this could be a long-lived object and will thus promote the object to generation
    1\.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设在程序执行过程中，当控制位于 `GarbageCollectorFinalize` 函数时，垃圾收集器被调用。垃圾收集器将识别出对象 `d`
    已不再需要，因此其内存可以被回收。然而，对象 `c` 仍然被引用。因此，它将假设这可能是一个长期存在的对象，并将该对象提升到第 1 代。
- en: For object `b`, it will recognize that it's not referenced now; however, it
    does have a finalize method and so cannot be cleaned. Therefore, it keeps object
    `b` in memory for now. However, it removes the entry in the **Finalization Queue**
    and adds an entry in the **fReachable Queue** so that the variable can be cleared
    later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象 `b`，它将识别出它现在没有被引用；然而，它确实有一个终结方法，因此不能被清理。因此，它目前将对象 `b` 保留在内存中。但是，它从 **终结队列**
    中移除了条目，并在 **f可达队列** 中添加了一个条目，以便稍后可以清除变量。
- en: 'Object `b`, as it cannot be removed from memory in the same way as object `c`,
    will also be promoted to **Generation 1**. The following shows this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `b`，由于不能像对象 `c` 那样从内存中移除，也将被提升到 **第 1 代**。以下显示了这一点：
- en: '![](img/de4ee592-6c98-4834-900d-ae02780f3f3b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de4ee592-6c98-4834-900d-ae02780f3f3b.png)'
- en: 'This illustrates the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了以下内容：
- en: Even though object `b` may not still be required, it will be persisted for a
    longer period of time in the memory.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使对象 `b` 可能不再需要，它也将在内存中持续更长时间。
- en: As in the previous example, the garbage collector will need to execute another
    iteration in order to clear these objects from the memory.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前例所示，垃圾收集器需要执行另一个迭代，以便从内存中清除这些对象。
- en: Unused objects that are implementing finalize may be moved to a higher generation.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了终结器的未使用对象可能被移动到更高的代。
- en: Due to these reasons, it's highly advisable that whenever we need to declare
    an object that has the finalize method, we must implement the `IDisposable` interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们强烈建议，每次我们需要声明具有终结方法的对象时，我们必须实现 `IDisposable` 接口。
- en: 'Before we go on to look at the `IDisposable` interface, let''s take a look
    at the following code implementation illustrating how the `Finalizer` function
    works in C#:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查看 `IDisposable` 接口之前，让我们看看以下代码实现，它说明了在 C# 中 `Finalizer` 函数是如何工作的：
- en: 'Consider the following code implementation, in which we declare a `Finalizer`
    class and then add a `Finalizer` function to it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码实现，其中我们声明一个 `Finalizer` 类，并向其中添加一个 `Finalizer` 函数：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we have added text in both the `Finalizer` class constructor and in
    the `Finalizer` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `Finalizer` 类构造函数和 `Finalizer` 方法中都添加了文本。
- en: 'Use the following code snippet to create an object of this class. Additionally,
    note that we have set a `null` value to the object. Setting a `null` value signifies
    that the object is no longer required in the application:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段创建此类的对象。此外，请注意，我们已经将对象的值设置为 `null`。设置 `null` 值表示对象在应用程序中不再需要：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that, by using the `Console.ReadLine()` syntax, we are preventing the
    application from terminating. We have done this to analyze the output coming from
    the program. When we execute `.exe`, we get the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用 `Console.ReadLine()` 语法，我们正在防止应用程序终止。我们这样做是为了分析程序输出的内容。当我们执行 `.exe`
    时，我们得到以下输出：
- en: '![](img/a53d7d64-7390-42c8-8af3-05d901e498b3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a53d7d64-7390-42c8-8af3-05d901e498b3.png)'
- en: In the preceding output, we are only getting the message from the constructor
    of the `Finalizer` class. Even though the object has been set as `null`, the finalizer
    of object `f` has not been executed yet.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们只从 `Finalizer` 类的构造函数中获取消息。尽管对象已被设置为 `null`，但对象 `f` 的终结器尚未执行。
- en: 'This is due to the fact that we cannot specify when the garbage collector kicks
    in. Now, press *Enter* in the `.exe` execution. Notice that the program stops
    the execution; however, before it terminates, the finalizer is called to reclaim
    the memory of object `f`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们无法指定垃圾收集器何时启动。现在，在 `.exe` 执行中按 *Enter*。注意，程序停止执行；然而，在终止之前，终结器被调用以回收对象
    `f` 的内存：
- en: '![](img/6e03c708-2376-4ed3-9868-a081b3e63723.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e03c708-2376-4ed3-9868-a081b3e63723.png)'
- en: This proves we were right about finalizers, which we discussed earlier in this
    section. Even though object `f` was no longer needed in the application, it was
    still kept in the managed heap memory until the garbage collector executed the
    `Finalizer` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们关于终结器的观点是正确的，我们之前在本节中讨论过。即使对象 `f` 在应用程序中不再需要，它仍然保留在托管堆内存中，直到垃圾回收器执行 `Finalizer`
    方法。
- en: 'Now, add the following code to implicitly call the garbage collector and note
    that the finalize method is called immediately:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下代码以隐式调用垃圾回收器，并注意终结方法立即被调用：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we execute the program now, we will see the output from the finalizer of
    the `Finalizer` class, illustrating that the garbage collector immediately reclaimed
    the memory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在执行程序，我们将看到来自 `Finalizer` 类终结器的输出，这表明垃圾回收器立即回收了内存：
- en: '![](img/42ecd167-1a77-40a3-a227-2845fd6b2624.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42ecd167-1a77-40a3-a227-2845fd6b2624.png)'
- en: When we call the `GC.Collect()` method, internally, it calls the finalizers
    for all the objects that are no longer required. Thus we get the message, Inside
    the finalizer of class Finalizer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `GC.Collect()` 方法时，内部会调用所有不再需要的对象的终结器。因此我们得到消息，类 Finalizer 的终结器内部。
- en: In the preceding code example, we discovered that if we use `Finalizer`, we
    may have some performance implications in the program. Although we can use the
    `GC.Collect()` command to implicitly call the garbage collector, even that can
    cause some lag in the program. To overcome these issues, C# is capable of using
    the `IDisposable` interface in such circumstances. In the next section, we will
    understand how we can implement this interface and how it helps us achieve better
    performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们发现如果我们使用 `Finalizer`，我们可能在程序中遇到一些性能影响。虽然我们可以使用 `GC.Collect()` 命令隐式调用垃圾回收器，但这也可能导致程序中出现一些延迟。为了克服这些问题，C#
    能够在这种情况下使用 `IDisposable` 接口。在下一节中，我们将了解如何实现此接口以及它如何帮助我们实现更好的性能。
- en: The IDisposable interface
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口'
- en: The finalize method, which we examined in the preceding section, has some performance
    implications for the system. With the `Finalizer` method, we are not sure of when
    the memory will be reclaimed by the garbage collector even after the object is
    no longer required. This implies that there is a possibility that unused memory
    will be persisted in a managed heap for longer than the desired amount of time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中检查的终结方法对系统有一些性能影响。使用 `Finalizer` 方法，即使对象不再需要，我们也不确定垃圾回收器何时会回收内存。这意味着有可能会发生未使用的内存比期望的时间更长地保留在托管堆中。
- en: With the `IDisposable` interface, we can assume control over when the memory
    is reclaimed for unmanaged resources in the application. The `IDisposable` interface
    in C# only has one method, which is `Dispose()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `IDisposable` 接口，我们可以假设控制应用程序中非托管资源何时被回收的内存。C# 中的 `IDisposable` 接口只有一个方法，即
    `Dispose()`。
- en: 'In this method, we can perform the same cleanup of unmanaged resources that
    we did in the `Finalizer` method. The following is the code implementation of
    the `IDisposable` interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们可以执行与 `Finalizer` 方法中相同的清理非托管资源。以下是实现 `IDisposable` 接口的代码实现：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that in the preceding example, we have declared a `DisposeImplementation`
    class and have implemented a `IDisposable` interface in this class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的示例中，我们声明了一个 `DisposeImplementation` 类，并在该类中实现了 `IDisposable` 接口。
- en: As we are implementing the `IDisposable` interface, we have defined a `Dispose`
    function in the same class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现 `IDisposable` 接口时，我们在同一个类中定义了一个 `Dispose` 函数。
- en: 'With the `Dispose` method, we need to clear all the unmanaged resources we
    are using in this class. While this approach is reliable in terms of when the
    resources will be reclaimed, there are some points we need to understand:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Dispose` 方法，我们需要清理这个类中使用的所有非托管资源。虽然这种方法在资源将被回收的时间方面是可靠的，但还有一些要点我们需要理解：
- en: It's the programmer's responsibility is to ensure that the `Dispose` method
    is called to reclaim the memory.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保调用 `Dispose` 方法以回收内存是程序员的职责。
- en: If the programmer misses calling the `Dispose` method, there is a chance that
    the unmanaged resources will not be cleared.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序员遗漏了调用 `Dispose` 方法，那么非托管资源可能不会被清理。
- en: Therefore, as a good programming practice, we should use both the `Finalize`
    and `Dispose` methods together in any implementation related to unmanaged resources.
    This will ensure that if the programmer has missed calling the `Dispose` method,
    then the `Finalize` method will always be there to reclaim the memory of the unmanaged
    resources.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个好的编程实践，我们应该在任何与未托管资源相关的实现中使用`Finalize`和`Dispose`方法。这将确保如果程序员遗漏了调用`Dispose`方法，那么`Finalize`方法将始终存在以回收未托管资源的内存。
- en: Additionally, in order to ensure that we do not duplicate the work in `Finalize`
    and `Dispose`, we can use the approach illustrated in the following example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了确保我们不会在`Finalize`和`Dispose`中重复工作，我们可以使用以下示例中说明的方法。
- en: For the same class that we used in the preceding implementation, we will declare
    an `isDisposed` field. The value of this field is set to `false`. In the `Dispose`
    method, we will reset its value to `true` to indicate that the cleanup for the
    unmanaged resources has occurred.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面实现中使用的相同类，我们将声明一个`isDisposed`字段。该字段的值设置为`false`。在`Dispose`方法中，我们将将其值重置为`true`，以指示已对非托管资源进行了清理。
- en: 'Now, to make sure that we do not do a cleanup of the resources a second time,
    we will check the value of this property in the `Finalize` method. If the `Dispose`
    property is set to `true`, indicating that cleanup has already occurred, then
    nothing will happen. If the `Dispose` property is set to `false`, indicating that
    cleanup has not occurred, then finalize will do a cleanup of the resources just
    as before. The following is the code implementation for this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了确保我们不会对资源进行第二次清理，我们将在`Finalize`方法中检查这个属性的值。如果`Dispose`属性设置为`true`，表示清理已经发生，那么将不会发生任何操作。如果`Dispose`属性设置为`false`，表示清理尚未发生，那么`finalize`将像以前一样对资源进行清理。以下是这个功能的代码实现：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's demonstrate these classes in two ways. First, we will call the `Dispose`
    method before calling the `GC.Collect()` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以两种方式演示这些类。首先，我们将在调用`GC.Collect()`方法之前调用`Dispose`方法。
- en: 'Call the `Dispose` method as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式调用`Dispose`方法：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, in the `Dispose` method we are setting the value in the
    flag to `true`. Apart from setting the flag, we will also be reclaiming memory
    from unmanaged resources. Therefore, when we call the finalize method, as the
    value in the flag is already set to `true`, the block inside the finalize method
    does not get executed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`Dispose`方法中将标志的值设置为`true`。除了设置标志外，我们还将从非托管资源中回收内存。因此，当我们调用`finalize`方法时，由于标志的值已经设置为`true`，`finalize`方法内部的代码块将不会执行。
- en: 'The following is the output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出结果：
- en: '![](img/b3a46fce-6a6a-480c-8b1a-7c0a823b814b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3a46fce-6a6a-480c-8b1a-7c0a823b814b.png)'
- en: 'Now, let''s consider another scenario in which the programmer forgets to call
    the `Dispose` method explicitly. The following is the code snippet for this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一种场景，即程序员忘记显式调用`Dispose`方法。以下是这个场景的代码片段：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we are not calling the `Dispose` method, so the value
    in the flag is set to `false`. Therefore, when the garbage collector executes
    the finalize method in object `d`, it also executes the code block to explicitly
    call the `Dispose` method for the same object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们没有调用`Dispose`方法，因此标志的值被设置为`false`。因此，当垃圾回收器在对象`d`上执行`finalize`方法时，它也会执行代码块来显式调用同一对象的`Dispose`方法。
- en: 'The following is the output for this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个的输出结果：
- en: '![](img/a52c72d8-0acc-43dd-ae4e-40a8a00a9e4d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a52c72d8-0acc-43dd-ae4e-40a8a00a9e4d.png)'
- en: 'There is also a property that we can use to suppress calling the finalize method
    in the `Dispose` method. We can use this when we are sure that we don''t need
    to verify the resources in the finalize method. The following is the syntax we
    can use to suppress calling the finalize method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用一个属性来在`Dispose`方法中抑制调用`finalize`方法。当我们确定不需要在`finalize`方法中验证资源时，我们可以使用这个属性。以下是我们可以使用来抑制调用`finalize`方法的语法：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code block, we have used `GC.SupressFinalize()` for the current
    object. This will remove the references from the finalization queue, ensuring
    that the finalize method is never triggered for the current object. Therefore,
    if we execute the same input, we get the following output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们为当前对象使用了`GC.SupressFinalize()`。这将移除最终化队列中的引用，确保`finalize`方法永远不会为当前对象触发。因此，如果我们执行相同的输入，我们将得到以下输出：
- en: '![](img/7fc6532b-860d-4595-821f-bd9f4c922543.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc6532b-860d-4595-821f-bd9f4c922543.png)'
- en: Using this pattern, we can ensure that unmanaged resources are released from
    memory without compromising the performance of the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，我们可以确保在不影响应用程序性能的情况下，从内存中释放非托管资源。
- en: In the next section, we will look at using the `using` block as a good practice
    for when we are dealing with any classes implementing the `IDisposable` interface.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将`using`代码块作为处理实现`IDisposable`接口的任何类时的良好实践。
- en: The using block
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码块
- en: Any program is bound to have errors. There could be several unforeseen circumstances
    where our written logic will throw exceptions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序都难免会有错误。可能会有一些不可预见的情况，我们的编写逻辑会抛出异常。
- en: If we are using unmanaged resources, then unhandled exceptions can be very harmful.
    They can lead to issues related to dangling memory, unclosed connections to file
    objects, and more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用非托管资源，未处理的异常可能会非常有害。它们可能导致悬空内存、文件对象未关闭的连接等问题。
- en: For example, consider the preceding example, where we have written a `Dispose`
    method to free up the memory. Let's say we have a scenario in which the application
    throws an exception before the `Dispose` method is called. In this case, the application
    will never have a chance to reclaim the memory occupied by the unmanaged resources.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑先前的例子，我们编写了一个`Dispose`方法来释放内存。假设我们在调用`Dispose`方法之前，应用程序抛出了一个异常。在这种情况下，应用程序将永远不会有机会回收由非托管资源占用的内存。
- en: 'To avoid such scenarios, C# lets us use the `using` block in our code. When
    we use the `using` block, no matter what happens inside the `using` block, the
    `Dispose` method is always called. Let''s understand this with the following code
    implementation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免此类情况，C# 允许我们在代码中使用`using`代码块。当我们使用`using`代码块时，无论`using`代码块内部发生什么，`Dispose`方法总是会调用。让我们通过以下代码实现来理解这一点：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that in the preceding code block, we are using the same `DisposeImplementation`
    class but are using it inside the `using` block. We are not explicitly nullifying
    the `d` object, to indicate to the garbage collector that it''s no longer needed.
    Additionally, we are not explicitly calling the `Dispose` method to free up the
    unmanaged resources. Yet, when we run the program, we get the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的代码块中，我们使用了相同的`DisposeImplementation`类，但它是放在`using`代码块内部的。我们没有显式地将`d`对象置为null，以向垃圾回收器指示它不再需要。此外，我们也没有显式调用`Dispose`方法来释放非托管资源。然而，当我们运行程序时，我们得到以下输出：
- en: '![](img/87a2f90f-36bc-42ff-a009-a13b405708e1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87a2f90f-36bc-42ff-a009-a13b405708e1.png)'
- en: The `using` block handles it automatically. The `using` block ensures that as
    soon as the control is out of the `using` block, it will call the `Dispose` method
    for the object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`代码块会自动处理它。`using`代码块确保一旦控制权离开`using`代码块，它就会为该对象调用`Dispose`方法。'
- en: Now, let's consider a scenario in which we get an error in the `using` block.
    For the sake of explanation, we will introduce an error manually by throwing an
    exception.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个在`using`代码块中发生错误的场景。为了解释，我们将手动引入一个错误，通过抛出异常。
- en: 'The following is the code snippet for this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个代码片段：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we execute the code, we get the following result:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行代码，我们会得到以下结果：
- en: '![](img/83163c92-bfb7-450a-afb7-afed5615d21b.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83163c92-bfb7-450a-afb7-afed5615d21b.png)'
- en: 'Now, in the code, we have thrown an exception that is not being handled. However,
    even then, the `Dispose` method of the `DisposeImplementation` object is called
    before the application errors out due to the exception. If we don''t use the `using`
    block, this will not happen. To illustrate this, remove the `using` block and
    throw the same exception in the application. The following is the code implementation
    for this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在代码中，我们抛出了一个未处理的异常。然而，即使如此，在应用程序由于异常而出错之前，`DisposeImplementation`对象的`Dispose`方法仍然会被调用。如果我们不使用`using`代码块，这种情况就不会发生。为了说明这一点，请从应用程序中移除`using`代码块，并抛出相同的异常。以下是这个实现的代码：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding block, we have removed the `using` statement and are throwing
    an unhandled exception after the object is created. If we execute the code, we
    get the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们移除了`using`语句，并在对象创建后在对象后面抛出一个未处理的异常。如果我们执行代码，我们会得到以下输出：
- en: '![](img/50af78a9-ada0-4830-85a2-ed16a9417456.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50af78a9-ada0-4830-85a2-ed16a9417456.png)'
- en: As you can see in the preceding screenshot, during the program execution the
    `Dispose` method is never called for the `DisposeImplementation` object. This
    illustrates that, as a best practice, we must always use a `using` block for classes
    implementing the `IDisposable` interface.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，在程序执行过程中，`Dispose`方法从未为`DisposeImplementation`对象调用。这说明了作为一个最佳实践，我们必须始终为实现`IDisposable`接口的类使用`using`块。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about memory management for unmanaged resources
    in C#. We revised the differences between managed code and unmanaged code in C#.
    We then looked at garbage collectors and delved into how they work. We learned
    about the memory storage structure of a managed heap, which it uses internally
    to allocate memory to different objects created during program execution. We learned
    about the internal divisions of generations, which the garbage collector uses
    internally to improve the performance of the system. We also learned about the
    mark-compact algorithm, which the garbage collector uses. We then explored how
    we can invoke garbage collection implicitly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C#中非托管资源的内存管理。我们复习了C#中托管代码和非托管代码之间的区别。然后我们探讨了垃圾回收器及其工作原理。我们学习了托管堆的内存存储结构，它是程序执行期间创建的不同对象分配内存时使用的。我们学习了垃圾回收器内部使用的代数划分，这有助于提高系统的性能。我们还学习了垃圾回收器使用的标记-压缩算法。然后我们探讨了如何隐式调用垃圾回收。
- en: Following this, we went on to understand concepts about memory management for
    unmanaged objects. We learned about the `Finalize` method and how it facilitates
    memory management of an unmanaged object. We learned about the performance implications
    of using the `Finalize` method, and then we went on to understand how the `IDisposable`
    interface helps overcome its shortcomings. We learned about how we implement the
    `IDisposable` interface in a class and how we can combine both the `Dispose` and
    `Finalize` methods to improve the performance of the system. Finally, we learned
    about using the `using` block for classes that implement the `IDisposable` interface.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们继续了解关于非托管对象内存管理的概念。我们学习了`Finalize`方法及其如何促进非托管对象的内存管理。我们学习了使用`Finalize`方法时的性能影响，然后我们继续了解`IDisposable`接口如何帮助克服其缺点。我们学习了如何在类中实现`IDisposable`接口，以及如何结合`Dispose`和`Finalize`方法来提高系统的性能。最后，我们学习了为实现`IDisposable`接口的类使用`using`块。
- en: In the next chapter, we will look at how reflection works in C#.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C#中反射的工作原理。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A garbage collector can reclaim memory for unmanaged resources used in C# code.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收器可以回收C#代码中使用的非托管资源的内存。
- en: 'True'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: Which of the following can be used to make sure the `Finalize` method is not
    called?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个可以用来确保不调用`Finalize`方法？
- en: '`GC.Collect();`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GC.Collect();`'
- en: '`GC.SupressFinalize(this);`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GC.SupressFinalize(this);`'
- en: '`GC.WaitForPendingFinalizers();`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GC.WaitForPendingFinalizers();`'
- en: None of these
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无
- en: 3\. Which one of the following statements is incorrect?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 以下哪个陈述是不正确的？
- en: '`Finalize` can lead to performance implications due to the object remaining
    in memory longer than required.'
  id: totrans-213
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Finalize`可能导致性能影响，因为对象在内存中保留的时间比所需的时间更长。'
- en: Generation 0 is used to save objects that are short-lived.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0代用于保存短生命周期的对象。
- en: Even if we use the `IDisposable` interface, we will not be able to suppress
    the calls that the garbage collector performs to execute the code in the `Finalize`
    method.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使使用`IDisposable`接口，我们也不能抑制垃圾回收器执行`Finalize`方法时进行的调用。
- en: The `using` block ensures that the `Dispose` method is called by the garbage
    collector automatically.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`using`块确保垃圾回收器自动调用`Dispose`方法。
- en: Answers
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**b**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**b**'
- en: '**b**'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**b**'
- en: '**c, using SupressFinalize method we will be able to remove the reference from
    the finalize queue thus the finalize method will not be executed.**'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**c, 使用SupressFinalize方法，我们能够从终结队列中移除引用，因此终结方法将不会执行。**'
