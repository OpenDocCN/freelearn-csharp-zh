<html><head></head><body>
        

                            
                    <h1 class="header-title">Anti-Patterns and Misconceptions on Dependency Injection</h1>
                
            
            
                
<p class="mce-root">Patterns show us the proper way to implement Dependency Injection. In the last chapter, we got an insight into every pattern available in the DI Ecosystem and explored their usage, their pros, their cons, and which one to select when. If these patterns are followed correctly, we achieve a loosely coupled architecture which will be easier to unit test.</p>
<p>However, while applying these patterns, we generally neglect some principles, which leads us to problems in the future. That might happen either to the ignorance about pattern' behavior or simply due to laziness.</p>
<p>At that point, a pattern becomes an anti-pattern, as it does not solve the problem; rather it gives birth to more bugs and maintenance becomes a headache.</p>
<p>After reading this chapter, don't worry if you find anti-patterns in your project because we will learn the steps to refactor each anti-pattern to a proper Pattern by selecting any technique from the patterns we discussed in the last chapter. If you directly came to this chapter, I suggest you complete the previous chapter (which covers everything you should know about DI Patterns in detail) first before moving ahead.</p>
<p>In this chapter, we will talk about such scenarios in projects with examples to understand how a pattern can behave as an anti-pattern.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>When DI becomes an anti-pattern</li>
<li>DI anti-patterns</li>
<li>Identifying anti-patterns in the project</li>
<li>Problems anti-patterns introduce to apps</li>
<li>Solutions and refactoring steps for each type of anti-pattern</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">When does Dependency Injection become an anti-pattern?</h1>
                
            
            
                
<p>We are heading towards exploring anti-patterns followed by developers in projects with DI in place. However, have you envisaged the scenario where DI itself becomes an anti-pattern! Yes, it can be an anti-pattern sometimes. The cases are listed as follows:</p>
<p>Suppose we have a controller that is depending on a <kbd>Service</kbd> for some database operation. For instance, <kbd>UsersController</kbd> would need an <kbd>IUsersService</kbd> type as a dependency for <kbd>User</kbd> table-related operations. We configured <kbd>UsersService</kbd> for the dependency and it got registered with the container. Now, help yourself a little bit and ask the following question. </p>
<p><em>Are you going to change the dependency to any other implementation of</em> <strong><kbd>IUsersService</kbd></strong><em>? </em>If your answer is <em>No</em>, then hold back and think a bit. The reason is, if you won't change the implementation for the dependency either dynamically through code or configurations, then DI is not going to play an important role. For example, if you save data to a database/XML/text file, you might have different implementations and swapping is needed in certain conditions, then DI will definitely come in handy. But if you only save to the database and nothing else, there is no necessity to have extra codes for injecting dependencies. It does not make much sense.</p>
<p><em>Are you going to need a dependency as soon as you start the app? </em>DI recommends that we register everything at one place called the Composition Root. However, imagine a <kbd>Service</kbd> called <kbd>CompanyService</kbd> whose instance is needed only when I want to add a <kbd>User</kbd> to a company. For example, see the following code:</p>
<pre>    public IActionResult AddUser(UserModel userModel)<br/>    {<br/>      var user = _usersService.CreateUser(userModel);<br/>      if (userModel.AddUserToCompany)<br/>      {<br/>        var companyService = new CompanyService();<br/>        companyService.AssignUserToCompany(user);<br/>      }<br/>      return View();<br/>    }</pre>
<p>Normally we have admins in a company who manages user records. Imagine a scenario, where the admin is logged in and wants to assign a few users to a certain company. In this case, there is a <kbd>boolean</kbd> coming from the model named <kbd>AddUserToCompany</kbd>. If that is <kbd>true</kbd>, we need to assign the user to the company. This means a lazy instantiation and it is looking pretty good.</p>
<p>So, here, it's meant to get a <kbd>CompanyService</kbd> instance quickly and work with it. However, if you have chosen DI, then the <kbd>CompanyService</kbd> instance stays in the container (because you register it at the Composition Root) till you actually use it inside the code, which often does not happen. Sometimes, it doesn't happen at all if the user logged in as a normal user and not an admin.</p>
<p>This is just a small example. You can visualize a complex application with these types of scenarios that might create a nasty impact with DI in place. Sometimes it's better to have lazy instantiation instead of having them in a container which consumes memory space unnecessarily.</p>
<p>Like a pattern, if DI is selected unnecessarily or used incorrectly, that leads to an anti-pattern itself. If you are never going to inject different dependencies for one implementation, then no need to use DI. Let's now explore anti-patterns, which we might encounter while using DI in the project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Anti-patterns</h1>
                
            
            
                
<p>There are four major types of anti-pattern found in projects where DI is implemented and those are listed as follows:</p>
<ul>
<li>Control Freak</li>
<li>Bastard Injection</li>
<li>Constrained Construction</li>
<li>Service Locator</li>
</ul>
<p>Let's analyze each type and see how to avoid them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Control Freak</h1>
                
            
            
                
<p>Control Freak is opposite to Inversion of Control. When a class holds its dependencies and tries to manage them itself without any interference from others, it will be tagged as a <strong>Control Freak</strong>.</p>
<p>The following diagram shows Control Freak at a glance:</p>
<div><img height="141" width="227" src="img/bb44cae7-c5fc-46ae-9bed-747d3b101475.png"/></div>
<p>When we said that <em>it tries to manage the dependencies itself</em>, what do we mean by that? Remember in <a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank">Chapter 6</a>, <em>Object Lifetime</em>, if a class wants to manage a dependency, that means it wants to instantiate it, then manage its lifetime and kill or dispose of it as well.</p>
<p>Instantiation, yes, that is done by our well-known keyword <kbd>new</kbd>.  The class instantiates every dependency with the <kbd>new</kbd> keyword inside it, then works with the objects and disposes of them through a <kbd>destructor</kbd> or <kbd>finalizer</kbd>. As a result, it is creating a tightly coupled system as soon as it does so. Moreover, it makes unit testing difficult.</p>
<p>The class either creates the object itself or asks some other class to do so on its behalf. Let's understand the scenario with an example:</p>
<pre>    public class EmployeeService
    {
      private readonly EmployeeRepository repository;
      public EmployeeService()
      {
         string connectionString = "Read String from config";
         this.repository = <strong>new SqlEmployeeRepository(connectionString)</strong>;
      }
    }</pre>
<p>The first thing that instantly comes into play is <kbd>new SqlEmplyeeRepository()</kbd>. Now, this service is tightly coupled with <kbd>SqlEmployeeRepository</kbd>. Suppose you want to use another repository class instead of this, then we have to change the service code and recompile. There is no such plugin point to say <em>I am providing you with this repository, please use it</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Problem</h1>
                
            
            
                
<p>To fix this problem, the developer might think of different patterns, which eventually complicates the scene. We can see the following types of factory used commonly:</p>
<ul>
<li>Concrete Factory</li>
<li>Abstract Factory</li>
<li>Static Factory</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Concrete Factory</h1>
                
            
            
                
<p>Creating <kbd>EmployeeRepositoryFactory</kbd> is another excuse (and a lazy approach) to have a <kbd>Create()</kbd> method that will create a <kbd>SqlEmployeeRepository</kbd> instance by the <kbd>new</kbd> keyword:</p>
<pre>    public class EmployeeRepositoryFactory
    {
      public EmployeeRepository Create()
      {
        string connectionString = "Read String from config";
        return new SqlEmployeeRepository(connectionString);
      }
    }</pre>
<p>We removed this block from <kbd>EmployeeService</kbd> but added another class which is working very similar to the previous one. We can then use the factory as follows:</p>
<pre>    public EmployeeService()
    {
      var employeeRepofactory = new EmployeeRepositoryFactory();
      this.repository = employeeRepofactory.Create();
    }</pre>
<p>Inside the <kbd>EmployeeService</kbd> constructor, we use the <kbd>new</kbd> keyword to get a factory instance and then call <kbd>Create()</kbd> to get the <kbd>SqlEmployeeRepository</kbd> instance and assign it to the <kbd>repository</kbd> variable.</p>
<p>Did we achieve anything useful? Not at all. We just added another bunch of code to the <kbd>Service</kbd>, doing the same thing (using the <kbd>new</kbd> keyword to instantiate) in an indirect way through the factory. Basically, the factory uses the same <kbd>new</kbd> keyword to instantiate the <kbd>SqlEmployeeRepository</kbd> class. That is what we wanted to avoid, but we could not achieve this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Abstract Factory</h1>
                
            
            
                
<p>Abstract Factory behaves as an encapsulating component that encapsulates complex logic including dependencies associated with it. It can transfer the control from the consumer because it does not totally allow the consumer to control the lifetime of objects.</p>
<p>A Derived Factory is responsible for the creation and management of the required repository instead of the initially designed factory. Consider the following code snippet:</p>
<pre>    public abstract class EmployeeRepositoryFactory
    {
        public abstract EmployeeRepository Create();
    }</pre>
<p>That means we are trying to hide which repository will be served. We are trying to achieve loose coupling by hiding the actual supplied type.</p>
<p>In order to assign the <kbd>repository</kbd> variable, we have to inherit this class and create one child of it returning <kbd>SqlEmployeeRepository</kbd>:</p>
<pre>    public class SqlEmployeeService : EmployeeRepositoryFactory
    {
      public override EmployeeRepository Create()
      {
        string connectionString = "Read String from config";
        return new SqlEmployeeRepository(connectionString);
      }
    }</pre>
<p>Basically, we decoupled the instantiation of the <kbd>repository</kbd> from the main service. The same question again arises. Did we achieve anything useful? I don't think so. That is because this new architecture  again achieved at the cost of one instantiation inside the <kbd>EmployeeService </kbd>(with the <kbd>new</kbd> keyword):</p>
<pre>    public EmployeeService()
    {
      var sqlEmployeeService = new SqlEmployeeService();
      this.repository = sqlEmployeeService.Create();
    }</pre>
<p class="mce-root">Although you were able to hide the <kbd>SqlEmplyeeRepository</kbd> from the factory by making it abstract, you made no change to the way things are handled inside the <kbd>EmployeeService</kbd> constructor. You are now instantiating <kbd>SqlEmployeeService</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Static Factory</h1>
                
            
            
                
<p>The next approach is to avoid factory instantiation by introducing the <kbd>static</kbd> pattern. Consider the following code snippet:</p>
<pre>    public static class EmployeeRepositoryFactory<br/>    {<br/>      public static EmployeeRepository Create()<br/>      {<br/>        string connectionstring = "read string from config";<br/>        return new SqlEmployeeRepository(connectionstring);<br/>      }<br/>    }</pre>
<p>This would prevent us from creating an object and using it directly. Let's see how:</p>
<pre>    public EmployeeService()<br/>   {<br/>      repository = EmployeeRepositoryFactory.Create(); <br/>   }</pre>
<p>Horray! We finally removed the <kbd>new</kbd> keyword. Alright, looks like we are done. Oh, wait! We still have <kbd>SqlEmployeeRepository</kbd> instantiated using <kbd>new</kbd> inside <kbd>Create()</kbd>. But there is a simple solution to reading this type of repository from the <kbd>config</kbd> or something:</p>
<pre>    public static EmployeeRepository Create()<br/>    {<br/>      var repository = "read from config";<br/>      switch (repository)<br/>      {<br/>        case "sql":<br/>            return EmployeeRepositoryFactory.CreateSql();<br/>        case "azure":<br/>            return EmployeeRepositoryFactory.CreateAzure();<br/>        default:<br/>            throw new InvalidOperationException("Invalid operation");<br/>      }<br/>    }</pre>
<p>It looks promising at first glance, but it is actually something else. All classes become tightly coupled. This is depicted in the following diagram:</p>
<div><img height="191" width="409" src="img/f36aaab7-6112-4fb2-814c-497ae3b09222.png"/></div>
<p><kbd>EmployeeService</kbd> depends upon the <kbd>EmployeeRepositoryFactory</kbd> for the <kbd>EmployeeRepository</kbd> instance, which means that clients of the service need to refer to the factory, repository, and then the types of repository such as <kbd>SqlEmployeeRepository</kbd> and <kbd>AzureEmployeeRepository</kbd> returned by <kbd>CreateSql()</kbd> and <kbd>CreateAzure()</kbd>.</p>
<p>These concrete classes got coupled, which can't produce a flexible design resulting in bad days for upcoming programmers of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Solution</h1>
                
            
            
                
<p>We have already explored patterns in the last chapter. The best fit for Control Freak issues is Constructor Injection. Consider the following code snippet:</p>
<pre>    public class EmployeeService<br/>    {<br/>      private readonly IEmployeeRepository repository;<br/>      public EmployeeService(<strong>IEmployeeRepository repository</strong>)<br/>      {<br/>        this.repository = repository ?? throw new<br/>          ArgumentNullException("repository");<br/>      }<br/>    }</pre>
<p>In this way, you abstracted out the concrete repository and also inserted the dependency through the constructor. More refactoring can be applied by introducing a factory class, which will be responsible for generating the repository.</p>
<p>Now using the DI Containers, you can register either the factory interface or the repository interface and resolve as required so that the dependency will be available for the service.</p>
<p>Control Freak is the most commonly found anti-pattern implemented in projects. While developers consider using DI in their project, they find it difficult sometimes and they are attracted to controlling the object creation instead of any other component doing it for them. The outcome will be awesome if they just ignore being a control freak and go with the DI flow.</p>
<p>The next anti-pattern is Bastard Injection. However, before going to that, we need to understand a manual approach to dependency management called <strong>Poor Man's DI</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Poor Man's DI</h1>
                
            
            
                
<p>Poor Man's DI; the name sounds very interesting, doesn't it! When you yourself try to take care of the registrations of dependencies at commonplace (which otherwise can be denoted as the Composition Root) instead of using a library (specifically a DI Container), that technique can be defined as Poor Man's DI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The approach</h1>
                
            
            
                
<p>Let's find out how this can be done with a quick code example. Suppose <kbd>EmployeeService</kbd> has a dependency of the <kbd>EmployeeRepository</kbd> type, which we can directly provide into the constructor, shown as follows:</p>
<pre>    static void Main(string[] args)<br/>    {<br/>      EmployeeService empService = new <br/>         EmployeeService(new EmployeeRepository());<br/>      Console.ReadKey();<br/>    }</pre>
<p>Consider this console app example, where <kbd>EmployeeService</kbd> is instantiated inside the <kbd>Main</kbd> method. It looks simple and beautiful. But it is not that effective if the dependency nesting runs deep.</p>
<p>What if <kbd>EmployeeRepository</kbd> again needs some other dependency and then another one and so on. You might end up doing something like the following:</p>
<pre>    EmployeeService empService = new <br/>      EmployeeService(new EmployeeRepository(new<br/>      Cass1(new Class2(new Class3()))));</pre>
<p>Now it becomes ugly and not so maintainable. Then you might think of simplifying this structure to some extent by introducing a default constructor for each class. So, the following is what you will do for <kbd>Service</kbd> and <kbd>Repository</kbd>:</p>
<pre>    public class EmployeeService : IEmployeeService<br/>    {<br/>      private readonly IEmployeeRepository repository;<br/><strong>      // Default Constructor calls the parameterized one</strong><br/>      <strong>public EmployeeService() : this(new EmployeeRepository()) </strong><br/><strong>      {</strong><br/><strong>      }</strong><br/>      public EmployeeService(IEmployeeRepository employeeRepository)<br/>      {<br/>         repository = employeeRepository;<br/>      }<br/>    }<br/>    public class EmployeeRepository : IEmployeeRepository<br/>    {<br/>      private readonly ISomeClass class1;<br/><strong>      // Default constructor calls the parameterised one.</strong><br/>      <strong>public EmployeeRepository() : this(new Class1())</strong><br/><strong>      {</strong><br/><strong>      }</strong><br/>      public EmployeeRepository(ISomeClass someClass)<br/>      {<br/>        class1 = someClass;<br/>      }<br/>    }</pre>
<p>You can do the same thing to all the nested classes. We added default constructors for all the classes; these a call internally to the parameterized constructors with a default dependency instance. It will definitely, reduce the code. Check the following reduced code:</p>
<pre>    static void Main(string[] args)<br/>    {<br/>      EmployeeService empService = <strong>new <br/>        EmployeeService(); // No Dependency passed here.</strong><br/>      Console.ReadKey();<br/>    }</pre>
<p class="mce-root">Now there is no need to pass any dependency to these constructors. Moreover, if you pass any dependency of the expected type, that will also work because a parameterized constructor also exists. That means we got a very flexible structure for the class and we also reduced the instantiation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Problem</h1>
                
            
            
                
<p class="mce-root">While we tried to make the instantiation flexible, testable, and simple, we did not realize the following disadvantages with this approach:</p>
<ul>
<li>A concrete reference was created in the default constructor when we did <kbd>new EmployeeRepository()</kbd>.</li>
<li>The default dependency instance is tied with all the classes using the <kbd>new</kbd> operator. But the whole point of the dependency injection technique is to reduce the <kbd>new</kbd> keywords in the app.</li>
<li>We also violated another principle in registering all dependencies in one place known as the Composition Root. Now, we have Composition Roots everywhere across the app in all classes. This is bad.</li>
<li>Imagine the situation of having 10 classes using the same dependency; now it would be very problematic to instantiate everything with the same <kbd>new</kbd> keyword again and again.</li>
<li>You don't have any facility to manage the lifetime of the dependencies created like this using the <kbd>new</kbd> keyword. You have to manually dispose of everything which can become a headache in a fully fledged application. Moreover, if you want to reuse one instance, you need to carefully deal with that. This might lead to inconsistent behavior and wrong data.</li>
</ul>
<p>So, how do we deal with this? Let's find out.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Solution</h1>
                
            
            
                
<p>Obviously, using a DI Container to register the dependencies solves the problem. We can remove the default constructor that is actually creating a tight coupling with the required types:</p>
<ul>
<li>The registration of dependencies can be restricted to one place unlike Poor Man's DI, where you instantiate concrete classes here and there.</li>
<li>With the registrations inside the Composition Root using a DI Container, we can make use of the facility to configure the app to use different types of dependency using different configuration options.</li>
<li>We get cleaner code for deeply nested dependencies.</li>
<li>For a dependency to be used by many classes, it's just a matter of registering it to the container and sitting back and relaxing.</li>
<li>You can manage the lifetime of dependencies as you like. The instance can behave as a <kbd>Singleton</kbd> , <kbd>Transient</kbd> , or <kbd>Scoped</kbd> as you configure them.</li>
</ul>
<p>It's recommended to use a DI Container to register and resolve dependencies instead of manually managing them in the Composition Root. So, the default constructor approach is denoted as Bastard Injection. In the next section, we will explore this a bit more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bastard Injection</h1>
                
            
            
                
<p>Usually, classes have more than one constructor. You might have a situation where you have referred to some class from another assembly in your default constructor.</p>
<p>The following diagram shows how one class has two constructors: one default and one parameterized. The parameterized constructor handles the injection and makes the <kbd>ISomeClass</kbd> implementation available for the class to operate on. Thus, the default constructor that is creating an instance of <kbd>SomeClass</kbd> becomes unnecessary:</p>
<div><img height="202" width="402" src="img/6b599f09-8916-4f3f-85ac-54710d8b7933.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Problem</h1>
                
            
            
                
<p>For simplicity, let's consider the same example: <kbd>EmployeeService</kbd>, which needs a repository to work with:</p>
<pre>    public class EmployeeService<br/>    {<br/>      private readonly IEmployeeRepository repository;<br/>      // Default Constructor.<br/>      public EmployeeService()<br/>      {<br/>         repository = CreateDefaultRepository();<br/>      }<br/><br/>      // Constructor Injection can happen here.<br/>      public EmployeeService(IEmployeeRepository repository)<br/>      {<br/>        if (repository == null)<br/>        {<br/>          throw new ArgumentNullException("repository");<br/>        }<br/>        this.repository = repository;<br/>      }<br/>      // Method creating a default repository.<br/>      private static EmployeeRepository CreateDefaultRepository()<br/>      {<br/>        string connectionString = "Read String from config";<br/>        return new SqlEmployeeRepository(connectionString);<br/>      }<br/>    }</pre>
<p>There is a default constructor which ensures repository availability by creating an instance of <kbd>SqlEmployeeRepository</kbd>. The default repository is referred from another assembly, obviously, as the service and repository don't stay in one assembly together. That's why the default can be denoted as a <strong>Foreign Default</strong>.</p>
<p>While we thought of having a default repository just because we wanted to make the service usable as soon as it is instantiated, unknowingly we designed a tightly coupled system between the service and repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Solution</h1>
                
            
            
                
<p>Bastard Injection is bad just because of this Foreign Default. Also, it might be depending on something we don't even need inside the class. From the preceding example, it's quite clear that, if we use a DI Container, it will automatically wire up the resolved dependency to the other parameterized constructor. However, if we have these kinds of default constructor, then DI Container might get confused while selecting which one to target. Having just one constructor for injection ensures a smooth operation with the container.</p>
<p>When you encounter a default constructor generating coupling with a Foreign Default, you can consider eliminating that, as you decide to apply Constructor Injection. Having one constructor for DI is enough because it is the responsibility of the DI Container to make sure that Foreign Default is in place whenever the service is requested.</p>
<p>While you refactor the code and remove the default constructor, the compiler might complain. In that case, you need to move instantiation codes to the Composition Root. If the referred dependency is a <em>Local Default</em> (it resides inside the same assembly), then we still need to remove that constructor, because constructor ambiguity leads to an increase in the complexity of <em>Auto-Wiring</em>.</p>
<p>If you remember, we have already discussed local defaults in <a href="795befd2-857f-40d2-ba05-cb2921168bcc.xhtml" target="_blank">Chapter 8</a>, <em>Patterns - Dependency Injection</em>. The easiest way to handle local defaults is to introduce <em>Property Injection</em>. The default constructor can be converted to a writable property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constrained Construction</h1>
                
            
            
                
<p class="mce-root">Here comes yet another type of <em>Anti-Pattern,</em> that tries to hijack the constructor. So, the developer forces the dependency's constructor to have a particular signature, which creates the problem. The reason behind this might be the intention of defining the dependencies in external configuration files to achieve late binding.</p>
<p>Late binding can be referred to as reading the type of repository (the derived class of the repository) and connection string from the configuration file to instantiate some repository.</p>
<p>Having a late binding technique not only helps to isolate code from the dependency but also makes sure that the code is not recompiled if the configuration is updated. Using a commonplace or application root to define all dependencies doesn't expose any problem, but recompiling is a must when we want to update dependencies:</p>
<div><img height="119" width="517" src="img/b26c2b49-2055-4fa7-93d7-8a9bab80c914.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Problem</h1>
                
            
            
                
<p>Imagine two repositories <kbd>EmployeeRepository</kbd> and <kbd>StaffRepository</kbd> used in an application. Both have constructors and you will pass the type of repository and connection string to both of them in order to create the repositories using these params. This is bad as you will now fetch the repository type and connection string from the config which might create issues if the <kbd>config</kbd>, does not have the required keys.</p>
<p>Now after you fetch the repository type name from the <kbd>config</kbd>, you have to create a <kbd>System.Type</kbd> instance using that name:</p>
<pre>    var employeeRepositoryTypeName = "Read from config"; <br/>      //SqlEmployeeRepository<br/>    var connectionString = "Read from config";<br/><br/>    var employeeRepositoryType = Type.GetType(employeeRepositoryTypeName,<br/>         true);<br/>    var employeeRepository = Activator.CreateInstance(employeeRepositoryType,<br/>       connectionString);</pre>
<p><kbd>Activator.CreateInstance</kbd> is used to call the constructor of the given type. The second param in this method is passed to the constructor of the type provided in the first param.</p>
<p>Suppose the type in the <kbd>config</kbd> is <kbd>SqlEmployeeRepository</kbd>. Basically, it assumes the following:</p>
<ul>
<li><kbd>SqlEmployeeRepository</kbd> derives from <kbd>EmployeeRepository</kbd></li>
<li>The implementation should contain a constructor that can take a connection string as a parameter</li>
</ul>
<p>These are the constraints, actually.</p>
<p>From the object construction perspective, it might look perfect, but there are disadvantages. For instance, think of constructing the repositories with the same dependency such as a single context. With the <kbd>Activator.CreateInstance</kbd>, we can no doubt create instances of the type specified to it, which in our case will create instances of <kbd>EmployeeRepository</kbd> and <kbd>StaffRepository</kbd>. But we can never assign a single context to both of them, as everyone will create their individual context based on their constructors. The following diagram depicts what I want to convey:</p>
<div><img height="201" width="344" src="img/1f2672df-330e-436b-be6f-604db85e0e54.png"/></div>
<p>Sharing of context can only happen if someone from the outside provides that to each of them instead of their creating the context themselves:</p>
<div><img height="263" width="377" src="img/c9fddb65-626d-49b7-b507-867a49852a70.png"/></div>
<p>Sharing a single dependency across the classes becomes difficult in this situation. More than one instance of the same dependency will be created, which is unnecessary. This would consume memory and resources as well.</p>
<p>A single instance of a particular dependency should be carefully chosen while designing. If not handled with care, there might be an adverse effect on the application running in different threads. If you remember, we have already discussed the Singleton Lifetime in <a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank">Chapter 6</a>, <em>Object Lifetime, </em>where we talked about the pattern's benefits and usage.</p>
<p>The Someone can be considered to be a Factory which we are going to explore next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Solution</h1>
                
            
            
                
<p>A DI container comes to the rescue at the composition root to overcome these difficulties and resolve all the dependencies in one go. Thus, the injection can take place and everything works smoothly. There is no need to have individual constructors for the dependencies with connection strings.</p>
<p>Even without a DI Container, we can formulate our solution differently. Abstract Factory comes into the play when we think of centralizing the dependency construction.</p>
<p>First of all, the Factory, Service, and Repository should be in different assemblies. There is a strong reason behind that. We will explore it shortly.</p>
<p>Instead of creating every dependency object inside the <em>Global asax</em> for ASP.NET app using <kbd>Activator.CreateInstance</kbd>, we will design in a different way so that there will be no need to recompile the app every time you want to use different types of repositories.</p>
<p>We will design a Factory named <kbd>EmployeeServiceFactory</kbd> implementing <kbd>IEmployeeServiceFactory</kbd> using a particular repository. This factory will be responsible for creating the service. <kbd>Service</kbd> would look something like the following:</p>
<pre>    public class EmployeeService : IEmployeeService<br/>    {<br/>      public EmployeeService(IEmployeeRepository repository)<br/>      {<br/>      }<br/>    }</pre>
<p><kbd>EmployeeServiceFactory</kbd> contains a <kbd>CreateService()</kbd> method to create the service it is responsible for (<kbd>EmployeeService</kbd> in this case).</p>
<p>It's important to isolate the Factory from the app and <kbd>DataAccess</kbd> to remove coupling. So, the Factory should be in a different assembly.</p>
<p>You can store the assembly-qualified type name for a factory in a <kbd>.config</kbd> file. <kbd>Activator.CreateInstance</kbd> can then be used to create an instance of the <kbd>IEmployeeServiceFactory</kbd> implementation (that you will define in the config) because that has a default constructor:</p>
<pre>    var employeeFactoryTypeName = "Read from config";<br/>    var employeeFactoryType = Type.GetType(employeeFactoryTypeName, true);<br/>    var employeeFactory = Activator.CreateInstance(employeeFactoryType);</pre>
<p>With <kbd>employeeFactory</kbd> now you can fire <kbd>CreateService()</kbd>, which will return the <kbd>EmployeeService</kbd> instance by using the related repository <kbd>EmployeeRepository</kbd>.</p>
<p>If you decide to use another type of dependency for the service instead of <kbd>EmployeeRepository</kbd>, then you can update the related key in the <kbd>config</kbd>. But before that, you need to add another factory in the factory assembly to implement <kbd>IEmployeeServiceFactory</kbd> and operate on the new configured repository. In this way, you recompile the factory assembly without compiling the application again and everything works as expected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service Locator</h1>
                
            
            
                
<p>If you remember, in the <em>Control Freak</em> section, we discussed Static Factories. With certain modifications, a Static Factory can behave as a Service Locator. As the name suggests, it will locate or find your required service:</p>
<div><img height="128" width="312" src="img/eb58b76b-a22f-41d5-bc18-e7063e0a4694.png"/></div>
<p><em>Service Locator</em> is very useful in many cases, which is why developers consider it to be a pattern. But it has many disadvantages. That's why we are listing this in this chapter instead of the previous one.</p>
<p>I am not going to discourage you from using this technique, but I would like to shed some light on its pros and cons. This will definitely help you to make better design decisions according to your application.</p>
<p>Some noticeable properties of Locator include the following:</p>
<ul>
<li>The important logic behind <em>Locator</em> is that it allows dependencies or services to be injected into it easily</li>
<li>A Static Factory, when configured with services or dependencies, is usually considered a <em>Service Locator</em></li>
<li>The configuration of a Service Locator can happen at the Composition Root</li>
<li>Service Locator configuration can be managed through code or reading-related settings from config</li>
</ul>
<p>A DI Container looks like a <em>S</em>ervice Locator. The principal duty of a Locator or Container in the DI Context is to resolve the dependency graph before every other operation starts. Ideally, resolving the graph should only happen at the Composition Root for proper implementation. The problem starts when you ask for dependencies or services in the application directly using the Locator or Container, instead of injecting them to the consumer. In this case, Locator will be tagged as an anti-pattern.</p>
<p>The Locator Process can be defined as follows:</p>
<ol>
<li><strong>While registering a service, Locator stores one instance of it in a Dictionary</strong>: The registration is normally done using an interface. You basically inform the Locator about an interface and its concrete implementation. For example, you would say <em>Serve <kbd>EmployeeService</kbd> if <kbd>IEmployeeService</kbd> is requested, Serve <kbd>StudentService</kbd> if <kbd>IStudentService</kbd> is demanded</em>.</li>
<li><strong>Locator receives the request to serve one instance of a service registered by its interface</strong>: So, when some code in your application wants to work with a <kbd>Student</kbd> entity, it will ask the Locator for an <kbd>IStudentInterface</kbd> implementation. </li>
<li><strong>Locator searches for the instance from the stored instances and then returns that to the client: </strong>As you have already trained the Locator, it will just return the requested implementation of the interface by checking all the stored instances.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Design</h1>
                
            
            
                
<p>A simple Service Locator would resemble the following class:</p>
<pre>    public static class ServiceLocator<br/>    {<br/>      static Dictionary&lt;Type, object&gt; servicesDictionary = <br/>        new Dictionary&lt;Type, object&gt;();<br/>      public static void Register&lt;T&gt;(T service)<br/>      {<br/>         servicesDictionary[typeof(T)] = service;<br/>      }<br/>       public static T GetService&lt;T&gt;()<br/>       {<br/>         T instance = default(T);<br/>         if (servicesDictionary.ContainsKey(typeof(T)) == true)<br/>         {<br/>            instance = (T)servicesDictionary[typeof(T)];<br/>         }<br/>         return instance;<br/>       }<br/>    }</pre>
<p>The <kbd>Register</kbd> method stores the service in the dictionary and <kbd>GetService</kbd> returns. We can use the locator to get the instance of a particular type:</p>
<pre>    public class EmployeeService : IEmployeeService<br/>    {<br/>      private readonly IEmployeeRepository repository;<br/>      public EmployeeService()<br/>      {<br/>        this.repository = ServiceLocator.GetService&lt;IEmployeeRepository&gt;();<br/>      }<br/>     } </pre>
<p>If you have registered the service beforehand using the <kbd>Register</kbd> method, then you can get it from the dictionary.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages</h1>
                
            
            
                
<p>Of course, the pattern has some advantages:</p>
<ul>
<li>It supports late binding by altering the registration codes.</li>
<li>It adopts program against interfaces so that we can develop code in parallel and we can replace modules as per our requirements.</li>
<li>Separation of concerns can be achieved. We can write maintainable code, though it is not so easy.</li>
</ul>
<p>Don't get fooled by the advantages. It might look perfectly fine to you, but there are many disadvantages with this approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Problem</h1>
                
            
            
                
<p>Service Locator acts as a proper pattern; however, you have to live with the following issues:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code reusability</h1>
                
            
            
                
<p>It hampers the reusability of the class as dependencies are not centralized anymore with Locator. They might be scattered throughout the class by the Locator's <kbd>GetService</kbd> method:</p>
<div><img height="109" width="294" src="img/a995e4f8-b337-47e6-9b84-2d9a7e91033c.png"/></div>
<p><kbd>EmployeeService</kbd> now depends upon both <kbd>EmployeeRepository</kbd> and <kbd>ServiceLocator</kbd>. Ideally, it should just rely upon the repository to follow the DI principle.</p>
<p>With both these dependencies in place, if someone wants to reuse <kbd>EmployeeService</kbd>, then they have to refer to both of them. If <kbd>ServiceLocator</kbd> stays in a different assembly, then the assembly reference is also required, which draws a very inefficient design. You will definitely agree with me if I say that it is a tightly coupled architecture.</p>
<p>Moreover, the consumer of the service won't be able to identify the dependencies while instantiating the service. That is because Locator is used internally inside the constructor or the methods and not exposed, unlike the DI strategy:</p>
<pre>    var empService = new EmployeeService();</pre>
<p>Now you might argue, Why would the developer would try to know what's inside because the dependencies are internally handled inside the default constructor? But what will happen if you forgot to register the dependency to Locator? Don't say that you won't forget. Most likely it will happen because, while you instantiate the class, the dependency's existence is not clear through the constructor. Therefore, if the class is not telling you what it depends on, you won't be so careful in finding and registering it, which would throw up unexpected exceptions.</p>
<p>I know what you are thinking now; apparently, the service is a type of Control Freak, isn't it? It is taking control of the dependencies using Locator.</p>
<p>The needy class means the class that depends on someone else. It no longer follows DI because the dependency is not injected; rather, it is fetched from Locator's <kbd>static</kbd> dictionary.</p>
<p>Another problem is clearly identifiable when the developer wants to add more dependencies to the class that has already adopted the Locator Pattern. Either you follow the same principle to introduce more dependencies or remove the Service Locator pattern and implement DI. Compilation errors are a certainty in both these cases.</p>
<p>For all the preceding reasons, Service Locator is considered an anti-pattern. Let's talk about a robust solution to address this anti-pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Solution</h1>
                
            
            
                
<p>As usual, Constructor Injection is the best fit and comes to mind first when we decide to refactor Service Locator codes. Complete removal of Service Locator can be achieved through Constructor Injection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring steps</h1>
                
            
            
                
<p>In most cases, Locator is used everywhere in the code base to get an instance of the dependency. Follow these steps to refactor it towards DI:</p>
<ol>
<li>Identify all the Locator calls in the code base.</li>
<li>Introduce a member variable to the class to hold the dependency, if that is not present.</li>
<li>Mark the field <kbd>readonly</kbd> so that it can't be modified outside the constructor.</li>
<li>Assign the field inside the constructor using the Locator. Now the Locator call is in one place.</li>
<li>Add a constructor parameter for the dependency.</li>
<li>Remove Locator from the constructor block and directly assign the constructor parameter to the <kbd>readonly</kbd> field.</li>
<li> Identify all the instantiation made to the class and move the wiring to a Composition Root.</li>
</ol>
<p>After all these steps, the same <kbd>EmployeeService</kbd> with the Constructor Injection Pattern can be designed, shown as follows:</p>
<pre>    public class EmployeeService : IEmployeeService<br/>    {<br/>      private readonly IEmployeeRepository repository;<br/>      public EmployeeService(IEmployeeRepository repository)<br/>      {<br/>        this.repository = repository;<br/>      }<br/>    }</pre>
<p>The service now asks its consumers to provide a dependency of type <kbd>IEmployeeRepository</kbd> implementation, which was not happening before.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The last chapter illustrated ways to implement DI. When we don't implement patterns correctly, we end up with a bad design for our app. We learned about mistakes we regularly make while implementing DI.</p>
<p>Before moving on to DI anti-patterns, we discussed why and when we can consider DI as an anti-pattern itself!</p>
<p>Then we moved ahead and touched upon all those common anti-patterns<em> </em>caused by misconceptions regarding Dependency Injection. We explored Control Freak, Bastard Injection, Constrained Construction, and (the most important) Service Locator.</p>
<p>Control Freak is the easiest one to discover. Whenever you see any class using the <kbd>new</kbd> keyword to instantiate its dependencies, that means it is trying to manage them without any external module controlling it. This is bad and should be avoided in the DI ecosystem.</p>
<p>This is the most dangerous one, which we should address first while refactoring. Other patterns are less damaging than this because it has a direct impact on loose coupling. Composition Root should be the place to instantiate everything needed for the application and then every possible dependency will be available by injection.</p>
<p>Bastard Injection can be seen with Foreign Defaults which is unnecessary from the DI point of view. We can easily move to Constructor Injection by removing codes related to Foreign Defaults.</p>
<p>On the other hand, Constrained Construction imposes restrictions on constructors to support late binding of services by taking types from configuration files, which in turn creates tight coupling. Adopting a DI Container or one Abstract Factory would help to eliminate constraints.</p>
<p>Last but not the least, we discussed Service Locator, which is arguably a proper Pattern. However, we explored its pros and cons and came to the conclusion that it is an anti-pattern.</p>
<p>If you have reached this point, that means you have now have grasped the ways to implement DI and what to avoid. In the next chapter, we will be discussing more realistic problems in projects and how to deal with them.</p>


            

            
        
    </body></html>