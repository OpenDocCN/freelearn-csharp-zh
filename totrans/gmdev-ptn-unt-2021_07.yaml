- en: Managing Character States with the State Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态模式管理角色状态
- en: In video games, entities continually transition from one state to another depending
    on player inputs or events. An enemy character might go from an idle state to
    an attack state depending on whether it spots the player moving across the map.
    A player character is constantly blending from one animation to another as it
    responds to the player inputs. In this chapter, we will review a pattern that
    permits us to define the individual states of an entity and its stateful behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，实体根据玩家输入或事件不断从一个状态转换到另一个状态。一个敌人角色可能会从空闲状态转换到攻击状态，这取决于它是否看到玩家在地图上移动。玩家角色会不断从一个动画转换到另一个动画，以响应玩家的输入。在本章中，我们将回顾一个允许我们定义实体的单个状态及其状态行为的模式。
- en: To start, we will use the traditional State pattern to manage the individual
    finite states of our main character. In the context of our racing game project,
    the main character is a motorcycle, so it has a set of mechanical behaviors and
    animations. As we progress in our implementation of the State pattern, we will
    soon see its limitations, which we will overcome by introducing FSM (Finite State
    Machine) concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用传统的状态模式来管理我们主要角色的单个有限状态。在我们的赛车游戏项目中，主要角色是一辆摩托车，因此它有一套机械行为和动画。随着我们对状态模式的实现进展，我们很快就会看到其局限性，我们将通过引入FSM（有限状态机）概念来克服这些局限性。
- en: We will not write an FSM by hand, but instead explore the native state machine
    implementation in Unity's native animation system. Therefore, this chapter will
    provide a two-fold approach, an introduction to the core concepts of the State
    pattern, and how to repurpose Unity's animation system to manage character states
    and animations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会手动编写FSM，而是探索Unity原生动画系统中的原生状态机实现。因此，本章将提供两种方法，介绍状态模式的核心概念，以及如何重新利用Unity的动画系统来管理角色状态和动画。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of the State pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式概述
- en: Implementation of the State pattern to manage the main character's states
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态模式实现为管理主要角色状态
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on. You will need to have a basic understanding of Unity
    and C#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的。你需要对Unity和C#有基本的了解。
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05)。
- en: Check out the following video to see the code in action: [https://bit.ly/36EbbHe](https://bit.ly/36EbbHe)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行效果：[https://bit.ly/36EbbHe](https://bit.ly/36EbbHe)
- en: An overview of the State pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式概述
- en: We use the State design pattern to implement a system that will permit an object
    to change its behavior based on its internal state. Thus, a change of context
    will bring on a change of behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用状态设计模式来实现一个系统，允许对象根据其内部状态改变其行为。因此，上下文的变化将导致行为的变化。
- en: 'The State pattern has three core participants in its structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式在其结构中有三个核心参与者：
- en: The `Context` class defines an interface that permits a client to request a
    change in the internal state of an object. It also holds a pointer to the current
    state.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 类定义了一个接口，允许客户端请求改变对象的内部状态。它还持有当前状态的指针。'
- en: The `IState` interface establishes an implementation contract for the concrete
    state classes.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IState` 接口为具体状态类建立了一个实现合同。'
- en: The `ConcreteState` classes implement the `IState` interface and expose a public
    method named `handle()` that the `Context` object can call to trigger the state's
    behavior.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteState` 类实现了 `IState` 接口，并公开了一个名为 `handle()` 的方法，`Context` 对象可以调用此方法来触发状态的行为。'
- en: 'Let''s now review a diagram of this pattern definition, but in the context
    of an actual implementation:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下这个模式定义的图表，但是在实际实现的环境中：
- en: '![](img/e7163ee9-b7f9-4b58-8e2f-190b406eab17.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7163ee9-b7f9-4b58-8e2f-190b406eab17.png)'
- en: Figure 5.1 – UML diagram of the State pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 状态模式的UML图
- en: To update an object's state, the client can set the expected state through the
    `Context` object and request a transition to the new state. Thus, the context
    is always aware of the current state of the object it handles. However, it doesn't
    need to be acquainted with each of the concrete state classes that exist. We can
    add as many state classes as we wish without modifying a single line of code in
    the `Context` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新一个对象的状态，客户端可以通过`Context`对象设置预期的状态并请求转换到新状态。因此，上下文总是知道它所处理的对象的当前状态。然而，它不需要熟悉每个具体的州类。我们可以添加尽可能多的州类，而无需修改`Context`类中的一行代码。
- en: 'For example, this approach scales better than defining all our states in a
    single class and managing the transition between them with a switch case, as we
    can see in the following pseudo-code example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这种方法比在单个类中定义所有状态并使用switch case管理它们之间的转换具有更好的可扩展性，正如我们可以在以下伪代码示例中看到：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have a basic understanding of the structure of the State pattern,
    we can start defining the states and behaviors of our main character, in this
    case, the bike, as we are going to see in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对状态模式的结构有了基本的了解，我们可以开始定义我们主要角色的状态和行为，在这个案例中，是自行车，正如我们将在下一节中看到的。
- en: Defining character states
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义角色状态
- en: In our game, the entity that will transition between states the most is our
    racing bike. It's under the player's control; it interacts with almost every element
    in the environment, including obstacles and enemy drones. Therefore, it will never
    stay in the same state for long.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，将在状态之间转换最多的实体是我们的赛车。它处于玩家的控制之下；它与环境中的几乎所有元素互动，包括障碍物和敌机。因此，它将不会长时间停留在同一状态。
- en: 'The following diagram showcases a shortlist of finite states for our bike:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们自行车的有限状态列表：
- en: '![](img/25554af1-79f0-40a6-8a49-e3e7e94b8da8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25554af1-79f0-40a6-8a49-e3e7e94b8da8.png)'
- en: Figure 5.2 – Diagram illustrating the finite states of the bike
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 说明自行车有限状态的图表
- en: 'And now let''s define some expected behaviors for some of the listed states:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些对于所列状态的一些预期行为：
- en: '**Stop**: In this state, the bike is not moving. Its current speed is at zero.
    Its gears are set to neutral. If we decide that the engine should be on, but running
    in idle mode in that state, we could have an animation of the chassis of the bike
    vibrating to show that the motor is running.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：在这个状态下，自行车没有移动。它的当前速度为零。它的档位设置为空档。如果我们决定在那个状态下发动机应该开启，但以怠速模式运行，我们可以在自行车底盘上添加一个振动的动画来显示发动机正在运行。'
- en: '**Start**: In this state, the bike moves at full speed, and the wheels turn
    to match the forward motion.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动**：在这个状态下，自行车以全速行驶，车轮转动以匹配前进运动。'
- en: '**Turn**: In the turning state, the bike turns to the left or to the right,
    depending on the player''s input.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转向**：在转向状态下，自行车根据玩家的输入向左或向右转向。'
- en: '**Crash**: If the bike is in a crash state, it means it''s on fire and on its
    side. The vehicle will no longer respond to the player''s input.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞**：如果自行车处于碰撞状态，这意味着它着火了，并且侧翻在地。车辆将不再对玩家的输入做出反应。'
- en: These are just unpolished definitions of potential states for our vehicle. We
    could go as granular and specific as we wish, but for our use case, it's enough.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是对我们车辆潜在状态的未经打磨的定义。我们可以根据需要细化到非常具体，但就我们的用例而言，这已经足够了。
- en: It is necessary to keep in mind that each definition of a state contains the
    description of behavior and animations. These requirements will be essential to
    consider when we write and review our implementation of the State pattern in the
    next section of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 必须记住，每个状态的定义都包含了行为和动画的描述。在下一节中编写和审查我们实现状态模式时，这些要求将是必须考虑的。
- en: Implementing the State pattern
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现状态模式
- en: In this part of the chapter, we will implement the State pattern with the explicit
    goal of encapsulating the expected behaviors of each of the vehicle's finite states
    that we defined in the previous section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将实现状态模式，明确的目标是封装我们在上一节中定义的每个车辆有限状态的预期行为。
- en: We are going to focus on writing minimalist skeleton classes for reasons of
    brevity and clarity. This approach will permit us to focus on the pattern's structure
    without being bogged down by implementation details.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于编写简洁的骨架类，以简明扼要和清晰。这种方法将使我们能够专注于模式的结构，而不会被实现细节所拖累。
- en: It's also important to note that the version of the State pattern presented
    in this book might be slightly unorthodox as it deviates somewhat from traditional
    approaches. Therefore, it should be considered a permutation of the State pattern
    adapted to the context of a Unity project and for a specific use case.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，本书中展示的状态模式版本可能有些不寻常，因为它与传统方法有些偏差。因此，它应该被视为适应Unity项目上下文和特定用例的状态模式的排列组合。
- en: Implementing the State pattern
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态模式
- en: 'We are going to review our code example in several steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分几个步骤回顾我们的代码示例：
- en: 'Let''s start by writing down the main interface that each of our concrete state
    classes will implement:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先写下每个具体状态类将实现的接口：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We should note that we are passing an instance of `BikeController` in the `Handle()`
    method. This approach permits state classes to access public properties of `BikeController`.
    This approach might deviate slightly from tradition as usually, it's the `Context`
    object that gets passed to the states.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，我们在`Handle()`方法中传递了一个`BikeController`的实例。这种方法允许状态类访问`BikeController`的公共属性。这种方法可能略偏离传统，因为通常是将`Context`对象传递给状态。
- en: However, nothing stops us from passing both the `Context` object and the instance
    of `BikeController` to the state classes. Alternatively, we could set an instance
    reference to `BikeController` when we initialize each state class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有任何阻止我们将`Context`对象和`BikeController`实例传递给状态类。或者，我们可以在初始化每个状态类时设置`BikeController`的实例引用。
- en: However, it was just simpler to do, as we are going to do for this use case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这个用例来说，这样做更简单。
- en: 'Now that we have our interface, let''s implement the context class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了接口，让我们来实现上下文类：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the `BikeStateContext` class exposes a public property that points
    to the current state of the bike; thus, it's aware of any state change. Therefore,
    we could update the current state of our entity through its property and transition
    into it by calling the `Transition()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`BikeStateContext`类公开了一个属性，指向自行车的当前状态；因此，它知道任何状态变化。因此，我们可以通过其属性更新我们实体的当前状态，并通过调用`Transition()`方法进入该状态。
- en: For instance, this mechanism is beneficial if we wanted to link states together
    by letting each state class declare the next one in the chain. Then, we could
    cycle through the linked states by simply calling the `Transition()` method of
    the `Context` object. However, this approach won't be necessary for our use case,
    as we will call the overloaded `Transition()` method and simply pass the state
    in which we want to transition.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想通过让每个状态类声明链中的下一个状态来将状态链接在一起，这种机制是有益的。然后，我们可以通过简单地调用`Context`对象的`Transition()`方法来遍历链接的状态。然而，对于我们的用例来说，这种方法是不必要的，因为我们将会调用重载的`Transition()`方法，并简单地传递我们想要转换到的状态。
- en: 'Next up is `BikeController`. This class initializes the `Context` object and
    the states, and it also triggers state changes:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`BikeController`。这个类初始化`Context`对象和状态，并且触发状态变化：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we didn't encapsulate the behaviors of the bike inside individual state classes,
    we would probably implement them inside `BikeController`. This approach would
    have likely resulted in a bloated controller class that's difficult to maintain.
    Therefore, by using the State pattern, we are making our classes smaller and easier
    to maintain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有将自行车的行为封装在单独的状态类中，我们可能会在`BikeController`中实现它们。这种方法可能会导致控制器类膨胀，难以维护。因此，通过使用状态模式，我们使我们的类更小，更容易维护。
- en: And we are also giving back to `BikeController` its original responsibilities
    of controlling the bike's core components. It exists to offer an interface to
    control the bike, expose its configurable properties, and manage its structural
    dependencies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把`BikeController`的原始职责，即控制自行车的核心组件，归还给它。它的存在是为了提供一个控制自行车的接口，公开其可配置属性，并管理其结构依赖。
- en: 'The following three classes are going to be our states; they are quite self-explanatory.
    Notice that each implements the `IBikeState` interface. Let''s start with `BikeStopState`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下三个类将成为我们的状态；它们相当直观。注意，每个都实现了`IBikeState`接口。让我们从`BikeStopState`开始：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next state class is `BikeStartState`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个状态类是`BikeStartState`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And lastly, there is `BikeTurnState`, which makes the bike turn left or right:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，还有`BikeTurnState`，它可以使自行车向左或向右转弯：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For our final class, `BikeController` references an enum named `Direction`,
    which we will implement here:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的最终类`BikeController`，它引用了一个名为`Direction`的枚举，我们将在下面实现它：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have all our ingredients ready to test our State pattern implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了所有配料，可以测试我们的状态模式实现。
- en: Testing the State pattern implementation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试状态模式实现
- en: 'To quickly test our implementation of the State pattern in your own instance
    of Unity, you need to follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速测试你在Unity实例中状态模式的实现，你需要遵循以下步骤：
- en: Copy all the scripts we just reviewed inside your Unity project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚审查的所有脚本复制到你的Unity项目中。
- en: Create a new empty scene.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空场景。
- en: Add a 3D GameObject to the scene, such as a cube, ensuring that it's visible
    to the main camera.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向场景中添加一个3D GameObject，例如一个立方体，确保它对主摄像机可见。
- en: Attach the `BikeController` script to the GameObject.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BikeController`脚本附加到GameObject上。
- en: 'Also attach the following client script to the GameObject:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还将以下客户端脚本附加到GameObject上：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you start the scene, you should see the following GUI buttons on your
    screen, which you can use to control the GameObject by triggering state changes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始场景，你应该在你的屏幕上看到以下GUI按钮，你可以使用它们通过触发状态变化来控制GameObject：
- en: '![](img/f5ed8b4c-d1d7-4a42-a1ce-d2f84c6d4ed1.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5ed8b4c-d1d7-4a42-a1ce-d2f84c6d4ed1.png)'
- en: Figure 5.3 – Screenshot of the code example in action
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 代码示例的截图
- en: In the next section of the book, we are going to review the benefits of the
    State pattern, but also its limitations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一节中，我们将回顾状态模式的优点，但也会讨论其局限性。
- en: Benefits and drawbacks of the State pattern
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式的优缺点
- en: 'The following are the benefits of using the State pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用状态模式的优点：
- en: '**Encapsulation**: The State pattern allows us to implement an entity''s stateful
    behaviors as a collection of components that can be assigned dynamically to an
    object when it changes states.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：状态模式允许我们将一个实体的状态行为实现为一个组件集合，当它改变状态时，可以动态地分配给对象。'
- en: '**Maintenance**: We can easily implement new states without having to modify
    long conditional statements or bloated classes.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**：我们可以轻松实现新状态，而无需修改长的条件语句或臃肿的类。'
- en: However, the State pattern does have its limitations when we use it to manage
    an animated character.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用状态模式来管理一个动画角色时，它确实有其局限性。
- en: 'Here''s a shortlist of potential limitations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个潜在局限性的简短列表：
- en: '**Blending**: In its native form, the State pattern doesn''t offer a solution
    to blend animations. This limitation can become an issue when you want to achieve
    a smooth visual transition between the animated states of a character.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：在原生形式中，状态模式不提供混合动画的解决方案。当你想要在角色的动画状态之间实现平滑的视觉过渡时，这种限制可能会成为一个问题。'
- en: '**Transitioning**: In our implementation of the pattern, we can easily switch
    between states, but we are not defining the relation between them. Therefore,
    if we wish to define transitions between states based on relationships and conditions,
    we will have to write a lot more code; for instance, if I want the idle state
    to transition to the walk state, and then the walk state to transition to the
    run state. And this happens automatically and smoothly, back and forth, depending
    on a trigger or condition. This could be time-consuming to do in code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：在我们的模式实现中，我们可以轻松地在状态之间切换，但我们没有定义它们之间的关系。因此，如果我们希望根据关系和条件定义状态之间的转换，我们可能需要编写更多的代码；例如，如果我想让空闲状态转换到行走状态，然后行走状态转换到奔跑状态。这会根据触发器或条件自动和顺畅地来回转换。在代码中这样做可能会很耗时。'
- en: 'However, the limitations listed above can be overcome by using the Unity animation
    system and its native state machine. We can easily define animation states and
    attach animation clips and scripts to each of the configured states. But its more
    important feature is that it lets us define and configure a set of transitions
    between states with conditions and triggers through a visual editor, as we can
    see here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述限制可以通过使用Unity动画系统和其原生状态机来克服。我们可以轻松定义动画状态，并将动画剪辑和脚本附加到配置的每个状态上。但它的更重要特性是，它允许我们通过可视化编辑器定义和配置状态之间的一系列转换，条件触发器，正如我们在这里看到的：
- en: '![](img/b87b4fc2-6426-4513-98f8-6a9224524a71.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b87b4fc2-6426-4513-98f8-6a9224524a71.png)'
- en: Figure 5.4 – Screenshot of the Unity animation system editor
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – Unity动画系统编辑器的截图
- en: The rectangles present represent individual animation states, and the arrows
    indicate relationships and transitions. A deep dive into how to use Unity animation
    is beyond the scope of this book. The goal of this chapter was to get introduced
    to the State pattern in the context of the Unity engine. As we see, Unity offers
    us a native solution that we can leverage to manage the animation states of our
    characters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现的矩形代表单个动画状态，箭头表示关系和转换。深入探讨如何使用Unity动画超出了本书的范围。本章的目标是在Unity引擎的上下文中介绍状态模式。正如我们所见，Unity为我们提供了一个原生解决方案，我们可以利用它来管理我们角色的动画状态。
- en: It's essential to keep in mind that this tool is not limited to animating humanoid
    characters. We could use it for mechanical entities such as cars or even background
    ingredients, such as a vending machine; hence, anything that has states, animations,
    and behaviors.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 必须记住，这个工具不仅限于动画人形角色。我们可以用它来处理机械实体，如汽车，甚至背景元素，如自动售货机；因此，任何具有状态、动画和行为的东西。
- en: In the next section, we will review a shortlist of alternative patterns to consider
    before using the State pattern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将审查在使用状态模式之前需要考虑的替代模式短名单。
- en: 'For more information on Unity''s animation system, you can read the official
    documentation at the following link:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Unity动画系统的更多信息，您可以在以下链接的官方文档中阅读：
- en: '[https://docs.unity3d.com/Manual/AnimationSection.html](https://docs.unity3d.com/Manual/AnimationSection.html).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/AnimationSection.html](https://docs.unity3d.com/Manual/AnimationSection.html)。'
- en: Reviewing alternative solutions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代方案
- en: 'The following is a list of patterns that are related or alternatives to the
    State pattern:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表是相关或作为状态模式替代方案的模式的列表：
- en: '**Blackboard/Behavior Trees**:If you are planning to implement complex AI behaviors
    for NPC characters, I would recommend considering patterns such as the Blackboard
    or concepts such as **Behavior Trees** (**BT**). For example, if you need to implement
    AI with dynamic decision-making behaviors, then BT is a more appropriate approach
    because it permits you to implement behavior using a tree of actions.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑板/行为树**：如果你计划为NPC角色实现复杂的AI行为，我建议考虑黑板或行为树等模式。例如，如果你需要实现具有动态决策行为的AI，那么行为树（BT）是一个更合适的方法，因为它允许你使用动作树来实现行为。'
- en: '**FSM**:A question that often arises when discussing the State pattern is the
    core difference between an FSM and the State pattern. The quick answer is that
    the State pattern is concerned with encapsulating an object''s state-dependent
    behaviors. However, FSM is more deeply involved with transitioning between finite
    states based on specific input triggers. And so, FSM is often considered more
    suited for the implementation of automaton-like systems.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限状态机（FSM）**：在讨论状态模式时，经常出现的一个问题是有限状态机（FSM）与状态模式之间的核心区别。简短的回答是，状态模式关注封装对象的状态相关行为。然而，FSM在基于特定输入触发器在有限状态之间转换方面涉及更深。因此，FSM通常被认为更适合实现类似自动机的系统。'
- en: '**Memento**: Memento is similar to the State pattern, but with an extra feature
    that gives objects the ability to roll back to a previous state. This pattern
    could be useful in implementing a system that needs the ability to undo a change
    made to itself.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录（Memento）**：备忘录与状态模式类似，但具有一个额外功能，使对象能够回滚到之前的状态。这种模式在实现需要能够撤销对其自身所做的更改的系统时可能很有用。'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were able to leverage the State pattern to define and implement
    stateful behaviors of our main character. In our case, the character is a vehicle.
    After reviewing its structure in the context of a specific code example, we saw
    its limits when dealing with animated entities. However, Unity offers us a native
    solution that permits us to manage the states of animated characters with a sophisticated
    state machine and a visual editor.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够利用状态模式来定义和实现我们主要角色的状态化行为。在我们的案例中，这个角色是一辆车。在特定代码示例的上下文中审查其结构后，我们看到了它在处理动画实体时的局限性。然而，Unity为我们提供了一个原生解决方案，允许我们使用复杂的状态机和可视化编辑器来管理动画角色的状态。
- en: However, it doesn't mean that the State pattern in itself is useless in Unity.
    We could easily use it as a foundation to build stateful systems or mechanics.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着在Unity中状态模式本身是无用的。我们可以轻松地将其用作构建状态化系统或机制的基础。
- en: In the next chapter, we will define the global states of our racing game and
    manage them with Event Bus.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将定义我们赛车游戏的全球状态，并使用事件总线来管理它们。
