- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Currying and Partial Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化和部分应用
- en: Congratulations! You have already covered more than 90% of the book! You are
    awesome and I’m giving you a virtual high-five! In this chapter, we will talk
    about currying and partial application. I know there is a special keyword, `partial`,
    that allows us to split our class, struct, or interface into parts; however, in
    functional programming, partial application has a different meaning. Currying
    transforms a function with multiple arguments into a sequence of functions, each
    taking a single argument. This transformation allows for incremental application
    of arguments, where each step returns a new function awaiting the next input.
    Partial application, on the other hand, involves fixing a number of arguments
    to a function, producing a function with fewer arguments. Both techniques are
    helpful in scenarios where not all arguments to a function are available at the
    same point in execution, thereby providing the flexibility to apply these arguments
    as they become available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经覆盖了这本书的超过90%！你太棒了，我要给你一个虚拟的击掌！在本章中，我们将讨论柯里化和部分应用。我知道有一个特殊的关键字，`partial`，它允许我们将类、结构体或接口拆分成多个部分；然而，在函数式编程中，部分应用有着不同的含义。柯里化将具有多个参数的函数转换成一系列函数，每个函数只接受一个参数。这种转换允许参数的增量应用，其中每一步都会返回一个新的函数，等待下一个输入。另一方面，部分应用涉及将一些参数固定到函数中，从而产生一个参数更少的函数。这两种技术都在函数的参数在执行过程中不是同时可用的情况下非常有用，因此提供了在参数可用时应用这些参数的灵活性。
- en: 'To learn these new techniques, we will go through the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习这些新技术，我们将通过以下部分进行学习：
- en: Understanding currying
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解柯里化
- en: Step-by-step currying implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化实现的步骤
- en: Partial application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用
- en: Areas for partial application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用的应用领域
- en: Challenges and limitations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战和限制
- en: Before moving on, I can’t leave you without regular self-check tasks to measure
    your knowledge before and after reading the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我不能不给你留下定期的自我检查任务来衡量你在阅读本章前后的知识水平。
- en: Task 1 – Currying tower attack functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务1 – 柯里化塔攻击函数
- en: 'Refactor the `AttackEnemy` function using currying, allowing the `towerType`
    to be preset for multiple uses throughout the game while accepting dynamic inputs
    for `enemyId` and `damage`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柯里化重构`AttackEnemy`函数，允许在游戏过程中预设`towerType`以供多次使用，同时接受动态输入的`enemyId`和`damage`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Partial application for game settings
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务2 – 游戏设置的柯里化部分应用
- en: 'Apply partial application to create a function for quick setup of standard
    game settings where the `map` is predefined but allows for dynamic setting of
    `difficultyLevel` and `isMultiplayer`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用部分应用来创建一个函数，用于快速设置标准游戏设置，其中`map`是预定义的，但允许动态设置`difficultyLevel`和`isMultiplayer`：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Currying permission checks for game features
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务3 – 为游戏功能进行柯里化权限检查
- en: 'Curry this function so that it can first accept a `userRole` and then return
    another function that takes a `feature`, determining whether the specified role
    has access to it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化此函数，使其首先接受一个`userRole`，然后返回另一个函数，该函数接受一个`feature`，确定指定角色是否有权访问它：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might think these methods are already optimal, but their simplicity is intentional.
    These focused tasks let you practice functional programming without distractions.
    As always, these tasks are just for your self-assessment, and you’re not supposed
    to solve them easily. So, don’t worry if you have any difficulties with them,
    and just proceed with reading the chapter. By its end, you’ll tackle these challenges
    like a pro. Keep that in mind, and I hope you have a happy coding experience!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这些方法已经是最优的，但它们的简单性是有意为之的。这些专注的任务让你在不受干扰的情况下练习函数式编程。像往常一样，这些任务只是供你自我评估，你并不需要轻易解决它们。所以，如果你对它们有任何困难，就继续阅读本章。到本章结束时，你将像专业人士一样应对这些挑战。记住这一点，希望你能有一个愉快的编码体验！
- en: Understanding currying
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解柯里化
- en: '**Currying** is a technique that converts a function with multiple arguments
    into a sequence of functions, each accepting a single argument. Named after the
    mathematician Haskell Curry, currying enables the partial application of arguments,
    where each supplied argument returns a new function poised for the next input.
    This approach is helpful when we want to reuse parts of the function in different
    scenarios or make some calculations between steps in a multi-step function.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**是一种将具有多个参数的函数转换为接受单个参数的函数序列的技术。以数学家哈斯克尔·柯里命名，柯里化允许参数的部分应用，其中每个提供的参数都返回一个准备接受下一个输入的新函数。这种方法在想要在不同场景中重用函数的部分或在多步函数的步骤之间进行一些计算时很有帮助。'
- en: Before diving into the concepts, let’s catch up with Steve and Julia.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入概念之前，让我们回顾一下史蒂夫和朱莉娅的对话。
- en: 'Julia: *Hey Steve, I see you’ve made great progress with functional programming.
    Today, we’ll explore currying and partial application, two powerful techniques
    that can help you write even more reusable and* *modular code.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*嗨，史蒂夫，我看到你在函数式编程方面取得了很大的进步。今天，我们将探讨柯里化和部分应用这两种强大的技术，它们可以帮助你编写更可重用和* *模块化的代码。*
- en: 'Steve: *Hi Julia! That sounds interesting. I’ve heard about these concepts
    but never really understood how to apply them in C#. Can you break it down* *for
    me?*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*嗨，朱莉娅！这听起来很有趣。我听说过这些概念，但从未真正理解如何在C#中应用它们。你能为我解释一下吗？*
- en: 'Julia: *Absolutely! Let’s start with currying. Currying transforms a function
    with multiple arguments into a sequence of functions, each taking a single argument.
    This transformation allows for the incremental application of arguments, where
    each step returns a new function awaiting the* *next input.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*绝对是这样！让我们从柯里化开始。柯里化将具有多个参数的函数转换为一串函数，每个函数只接受一个参数。这种转换允许参数的增量应用，其中每一步都返回一个等待下一个输入的新函数。*
- en: 'Steve: *So, it’s like creating a chain of functions, each taking* *one argument?*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*所以，它就像创建一个函数链，每个函数都接受* *一个参数吗？*
- en: 'Julia: *Exactly! Let me show you a currying application in a practical example
    within a YouTube video management system. Often, we need to check whether a user
    has the appropriate permissions for different actions, such as viewing, commenting,
    and* *uploading videos.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*没错！让我通过一个YouTube视频管理系统中的实际示例向你展示柯里化的应用。我们经常需要检查用户是否有执行不同操作（如查看、评论和* *上传视频）的适当权限。*
- en: Standard approach
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准方法
- en: 'Typically, we might use a function such as this to check permissions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可能会使用这样的函数来检查权限：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function is effective but requires both parameters each time you check
    a different action for the same role.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有效，但每次检查同一角色的不同操作时都需要两个参数。
- en: Curried approach
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化方法
- en: 'By currying this function, we create a more adaptable permission checker, useful
    when handling multiple actions for the same user role during a session or in similar
    contexts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过柯里化此函数，我们创建了一个更适应的权限检查器，在会话期间处理同一用户角色的多个操作或在类似环境中非常有用：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use the curried approach as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式使用柯里化方法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in this example, currying has several benefits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的示例中可以看到的，柯里化有几个优点：
- en: '**Reusability**: The curried function allows you to predefine the action and
    create specific functions for checking each role. This is especially beneficial
    when multiple roles need to be checked for the same action repeatedly during a
    session.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**可复用性**：柯里化函数允许你预先定义操作并创建用于检查每个角色的特定函数。这在会话期间需要重复检查同一操作的多重角色时特别有益。'
- en: '**Reduction in redundant code**: Currying separates the action from the role
    evaluation, reducing repetitive code when performing multiple checks for different
    roles under the same action. This improves code readability and maintainability.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少冗余代码**：柯里化将操作与角色评估分离，在执行同一操作下的多个不同角色的多次检查时减少了重复代码。这提高了代码的可读性和可维护性。'
- en: '**Convenience of partial application**: You can partially apply the action
    when you know that all subsequent checks will be for that action, which is common
    in scenarios where a session or particular interface segment is focused on a single
    type of action.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分应用便利性**：当你知道所有后续检查都将针对该操作时，你可以部分应用该操作，这在会话或特定接口段专注于单一类型操作的场景中很常见。'
- en: Step-by-step implementation of currying
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化的逐步实现
- en: As Julia finished explaining the currying example, Steve nodded thoughtfully.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当朱莉娅解释完柯里化示例后，史蒂夫若有所思地点了点头。
- en: 'Steve: *I think I’m starting to get it. But how do we actually implement currying
    in* *our code?*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Steve：*我觉得我开始明白了。但我们如何在代码中实际实现柯里化呢？*
- en: 'Julia: *Great question! Let’s break it* *down step-by-step...*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Julia：*这是一个很好的问题！让我们一步一步地分解它...*
- en: 'A process for implementing currying is actually quite easy:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实现柯里化的过程实际上相当简单：
- en: 'Identify the function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别函数：
- en: Select a function that takes multiple parameters. This function is a candidate
    for currying if you often find yourself using only some of the parameters at a
    time or if the parameters are naturally grouped in stages.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择一个接受多个参数的函数。如果您经常发现自己一次只使用一些参数，或者参数自然地按阶段分组，则该函数是柯里化的候选者。
- en: 'Define curried functions:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义柯里化函数：
- en: Transform the multi-parameter function into a sequence of nested, single-parameter
    functions. Each function returns another function that expects the next parameter
    in the sequence.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将多参数函数转换为一系列嵌套的单参数函数。每个函数返回另一个函数，该函数期望序列中的下一个参数。
- en: 'Implement using Func delegates:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Func 委托实现：
- en: We can utilize `Func` delegates to implement curried functions. Each Func returns
    another Func until all parameters are accounted for, culminating in the return
    of the final value.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以利用 `Func` 委托来实现柯里化函数。每个 `Func` 返回另一个 `Func`，直到所有参数都被考虑在内，最终返回最终值。
- en: 'Simplify invocation:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化调用：
- en: Although currying adds a level of indirection to function invocation, it simplifies
    the process by breaking it down into manageable steps, each of which can be handled
    separately as needed.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管柯里化给函数调用增加了一层间接性，但它通过将其分解为可管理的步骤来简化过程，每个步骤都可以根据需要单独处理。
- en: Use cases
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: Although currying might look a bit cumbersome, it has many situations where
    it is beneficial. Let’s explore some common use cases and see how currying can
    be applied to improve code modularity and reusability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然柯里化可能看起来有些繁琐，但它有许多有益的情况。让我们探讨一些常见的用例，看看柯里化如何应用于提高代码模块化和可重用性。
- en: Configuration settings
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置设置
- en: 'When setting up configurations that involve multiple parameters, currying allows
    these settings to be specified incrementally throughout the application. Consider
    an example where we need to set up a notification service limiting the maximum
    number of notifications sent per minute for each user group:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置涉及多个参数的配置时，柯里化允许在整个应用程序中增量地指定这些设置。考虑一个例子，我们需要为每个用户组设置一个通知服务，限制每分钟发送的最大通知数：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `CurryNotificationConfig` function accepts the notification
    type, maximum notifications per minute, and recipient email as curried parameters.
    Each group of users has its own settings, making the configuration for each specific
    user more reusable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`CurryNotificationConfig` 函数接受通知类型、每分钟最大通知数和收件人电子邮件作为柯里化参数。每个用户组都有自己的设置，这使得为每个特定用户的配置更具可重用性。
- en: Event handling
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理
- en: 'In event-driven programming, currying can be used to handle events with specific
    pre-filled parameters, simplifying event handler logic. Let’s consider an example
    of handling button click events:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，柯里化可以用于处理具有特定预填充参数的事件，简化事件处理程序逻辑。让我们考虑一个处理按钮点击事件的例子：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By currying the button click handler, you can create specialized functions for
    each button (`handleSaveClick` and `handleCancelClick`) with the button name pre-filled.
    This simplifies the event handler attachment and makes the code more readable
    and maintainable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对按钮点击处理程序进行柯里化，您可以创建针对每个按钮（`handleSaveClick` 和 `handleCancelClick`）的专用函数，并预先填充按钮名称。这简化了事件处理程序附加过程，并使代码更易于阅读和维护。
- en: Partial application
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分应用
- en: 'Currying facilitates partial application, where a function with many parameters
    can be transformed into a function with fewer parameters by fixing some parameter
    values ahead of time. We will discuss it in detail in the next section, but for
    now, let’s look at an example of a logging function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化促进了部分应用，其中可以通过在事先固定一些参数值来将具有许多参数的函数转换为具有较少参数的函数。我们将在下一节中详细讨论它，但现在让我们看看一个日志函数的例子：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, currying allows you to partially apply the `logLevel` parameter,
    creating `logError` and `logWarning` functions for different log levels. This
    reduces the need to pass the log level repeatedly and makes the logging calls
    more concise and expressive.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，柯里化允许您部分应用 `logLevel` 参数，创建 `logError` 和 `logWarning` 函数以适应不同的日志级别。这减少了重复传递日志级别的需求，并使日志调用更加简洁和表达性强。
- en: Asynchronous programming
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程
- en: 'Currying can simplify asynchronous code by separating the preparation of parameters
    from the execution of asynchronous operations. Here is an example of making an
    HTTP request:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化可以通过将参数的准备与异步操作的执行分离来简化异步代码。以下是一个制作 HTTP 请求的示例：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By currying the HTTP `GET` request function, we can separate the configuration
    of the URL, headers, and cancellation token. This allows for more flexible and
    modular asynchronous code, where each request aspect can be prepared independently
    and combined when needed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过柯里化 HTTP `GET` 请求函数，我们可以将 URL 的配置、头部信息和取消令牌分开。这允许我们编写更灵活和模块化的异步代码，其中每个请求方面都可以独立准备并在需要时组合。
- en: In general, currying aims to reduce redundancy and simplify the function’s usage
    across different parts of the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，柯里化的目标是通过减少冗余并简化函数在应用程序不同部分的使用来简化代码。
- en: Partial application
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: In simple terms, partial application involves taking a function that accepts
    several arguments, supplying some of these arguments, and returning a new function
    that only requires the remaining arguments. This is very similar to what currying
    does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，部分应用涉及取一个接受多个参数的函数，提供其中一些参数，并返回一个只需要剩余参数的新函数。这与柯里化所做的非常相似。
- en: Currying transforms a function with multiple arguments into a sequence of functions,
    each accepting a single argument. This enables partial application naturally,
    as each function returned by a curried function can be considered a partially
    applied function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化将具有多个参数的函数转换为一串函数，每个函数只接受一个参数。这使得部分应用变得自然，因为柯里化函数返回的每个函数都可以被视为部分应用函数。
- en: 'The key difference between currying and partial application lies in their implementation
    and usage:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化和部分应用之间的关键区别在于它们的实现和使用：
- en: '**Currying** is about transforming the function structure itself, turning a
    multi-argument function into a chain of single-argument functions'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**是关于转换函数结构本身，将多参数函数转换为一串单参数函数'
- en: '**Partial application**, on the other hand, does not necessarily change the
    function structure but reduces the number of arguments it needs by pre-filling
    some of them'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**部分应用**并不一定改变函数结构，但通过预先填充一些参数来减少它需要的参数数量
- en: Partial application can be particularly useful in scenarios involving configurations,
    repetitive tasks, and predefined conditions. It simplifies the interface for the
    end user of the function and can make the code base easier to maintain by encapsulating
    common parameters within partially applied functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用在涉及配置、重复性任务和预定义条件的情况下尤其有用。它简化了函数最终用户的接口，并通过在部分应用函数中封装常见参数，可以使代码库更容易维护。
- en: Steve scratched his head, looking a bit confused.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫挠了挠头，看起来有些困惑。
- en: 'Steve: *Julia, I’m having trouble seeing the difference between currying and
    partial application. They seem* *really similar*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*朱莉娅，我有点难以区分柯里化和部分应用。它们看起来* *非常相似*。
- en: 'Julia: *You’re* *right that they’re related, Steve. The key difference is in
    how they’re implemented and used. Let me* *explain further...*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*史蒂夫，你* *说得对，它们是相关的。关键区别在于它们的实现和使用方式。让我* *进一步解释...*
- en: Areas for partial application
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用的应用领域
- en: 'Although partial application is used in quite similar scenarios to the currying
    ones, the possibility of having more than just one parameter makes it more applicable.
    Here are some good places to apply partial application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管部分应用在相当类似的场景中使用，但拥有多个参数的可能性使其更适用。以下是一些应用部分应用的好地方：
- en: '**Configuration management**: In systems where configurations vary slightly
    between environments or parts of the application, partial application can simplify
    configuration management by pre-setting common parameters.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**：在配置在不同环境或应用程序的部分之间略有差异的系统，部分应用可以通过预先设置常见参数来简化配置管理。'
- en: '**User interface events**: In GUI programming, event handlers often require
    specific parameters that don’t change once set. Partial application allows developers
    to prepare these handlers with predefined arguments, making the code cleaner and
    easier to manage.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面事件**：在 GUI 编程中，事件处理器通常需要特定的参数，一旦设置就不会改变。部分应用允许开发者使用预定义的参数准备这些处理器，使代码更整洁且易于管理。'
- en: '**API integration**: When interacting with external APIs, certain parameters
    such as API keys and user tokens remain constant across requests. Partially applying
    these parameters to API request functions can simplify function calls and enhance
    security by isolating sensitive data.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API集成**：在与外部API交互时，某些参数（如API密钥和用户令牌）在请求之间保持不变。将这些参数部分应用到API请求函数中可以简化函数调用，并通过隔离敏感数据来提高安全性。'
- en: '**Logging and monitoring**: A common requirement across applications, logging
    often involves repetitive information such as log levels and categories. Partial
    applications can create specialized logging functions that are easier to use and
    reduce the likelihood of errors.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录和监控**：在应用程序中，日志记录通常涉及重复的信息，如日志级别和类别。部分应用可以创建更易于使用且减少错误发生可能性的专用日志记录函数。'
- en: '**Data processing pipelines**: In scenarios involving data transformation and
    processing, functions often need specific settings or operations to be applied
    consistently. Partial applications can preconfigure these functions with the necessary
    settings, making the pipeline more modular and reusable.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理管道**：在涉及数据转换和处理的场景中，函数通常需要特定的设置或操作以保持一致性。部分应用可以预先配置这些函数所需的设置，使管道更加模块化和可重用。'
- en: Example of partially applying a function for configuration settings
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分应用函数的配置设置示例
- en: Consider a scenario in a content management system where different types of
    content require specific rendering settings. The function that handles rendering
    might take multiple parameters, but many of these parameters are common across
    content types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在内容管理系统中的场景，不同类型的内容可能需要特定的渲染设置。处理渲染的函数可能需要多个参数，但许多这些参数在内容类型之间是通用的。
- en: Standard rendering function
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准渲染函数
- en: 'Let’s say we have a function to render our content that takes multiple parameters
    and can be used only when we have all of them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个渲染内容的函数，它接受多个参数，并且只有在拥有所有这些参数的情况下才能使用：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Partially applied function
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: 'To simplify the use of this function across the application, particularly when
    most content uses a standard format and theme, you can partially apply these common
    parameters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化在整个应用程序中使用此功能，尤其是在大多数内容使用标准格式和主题的情况下，您可以部分应用这些常用参数：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This approach allows us to use the `renderStandard` function without repeatedly
    specifying the format and theme. You must be thinking now that we could use default
    parameters here and get rid of all this partial application. But what if we have
    not just one “standard” way of rendering, but several of them: desktop, cellphone,
    and tablet? That’s when we create specific functions for each case with shared
    code in the “main” `RenderContent` function. It looks like an inheritance for
    functions of sorts.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们能够在不重复指定格式和主题的情况下使用`renderStandard`函数。你现在可能认为我们在这里可以使用默认参数，并消除所有这些部分应用。但如果我们不仅有“标准”的渲染方式，还有多种方式：桌面、手机和平板？这就是我们在“主要”的`RenderContent`函数中创建针对每种情况的具体函数，并在其中共享代码的时候。这看起来像是函数的某种继承。
- en: After studying currying and partial application, Steve couldn’t help but feel
    a bit overwhelmed. He reached out to Julia to voice his apprehensions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了柯里化和部分应用之后，史蒂夫不禁感到有些不知所措。他联系了朱莉娅，表达了他的担忧。
- en: 'Steve: *Julia, while I see the potential of these techniques, I’m worried about
    the increased complexity and potential performance issues. How do you manage those
    challenges in* *your projects?*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*朱莉娅，虽然我看到了这些技术的潜力，但我担心复杂性增加和潜在的性能问题。你是如何在你的项目中管理这些挑战的？*
- en: 'Julia: *Those are valid points, Steve. It’s true that currying and partial
    application have their challenges and limitations. Let’s go through some of them
    and discuss strategies to* *overcome them...*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*史蒂夫，这些观点是有效的。确实，柯里化和部分应用有其挑战和局限性。让我们探讨一些这些挑战，并讨论克服它们的策略...*
- en: Challenges and limitations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战和局限性
- en: After studying currying and partial application, Steve couldn’t help but feel
    a bit overwhelmed. He reached out to Julia to voice his apprehensions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了柯里化和部分应用之后，史蒂夫不禁感到有些不知所措。他联系了朱莉娅，表达了他的担忧。
- en: 'Steve: *Julia, while I see the potential of these techniques, I’m worried about
    the increased complexity and potential performance issues. How do you manage those
    challenges in* *your projects?*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*朱莉娅，虽然我看到了这些技术的潜力，但我担心复杂性增加和潜在的性能问题。你是如何在你的项目中管理这些挑战的？*
- en: 'Julia: *Those are valid points, Steve. It’s true that currying and partial
    application have their challenges and limitations. The following are* *some examples:*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*这些观点很有道理，史蒂夫。确实，柯里化和部分应用有其挑战和局限性。以下是一些例子：*
- en: '**Increased complexity**: For developers unfamiliar with functional programming,
    currying and partial application can make the code seem more complex and harder
    to understand, leading to a steeper learning curve.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的复杂性**：对于不熟悉函数式编程的开发者来说，柯里化和部分应用可能会使代码看起来更复杂，更难以理解，从而导致学习曲线更陡峭。'
- en: '**Performance overheads**: Every function call in .NET involves a certain overhead,
    and currying increases the number of function calls by transforming a single multi-parameter
    function into multiple single-parameter functions. This can potentially impact
    performance, especially in performance-critical applications.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：.NET中的每个函数调用都涉及一定的开销，而柯里化通过将单个多参数函数转换为多个单参数函数来增加函数调用的数量。这可能会对性能产生潜在影响，尤其是在性能关键的应用中。'
- en: '**Debugging difficulty**: Debugging curried functions can be more challenging
    because the flow of data and execution is spread across multiple function calls
    rather than being concentrated in a single function body.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试难度**：调试柯里化函数可能更具挑战性，因为数据流和执行流程分布在多个函数调用中，而不是集中在单个函数体内。'
- en: '*Sounds a bit scary, but there is no need to worry because we can overcome
    these challenges using the* *following strategies:*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*听起来有点吓人，但不必担心，因为我们可以使用以下策略来克服这些挑战：*'
- en: '**Education and training**: Providing training sessions and resources on functional
    programming concepts can help team members understand and effectively use currying
    and partial applications.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育和培训**：提供关于函数式编程概念的培训课程和资源，可以帮助团队成员理解和有效使用柯里化和部分应用。'
- en: '**Selective use**: Apply currying and partial application selectively, focusing
    on areas where they provide clear benefits, such as in configuration management
    and API interaction, rather than applying them universally.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性使用**：有选择地应用柯里化和部分应用，专注于它们能提供明确好处的地方，例如在配置管理和API交互中，而不是普遍应用。'
- en: '**Performance monitoring**: Always monitor the performance implications of
    currying in your specific context. Use profiling tools to identify any bottlenecks
    and refactor the code if necessary to optimize performance.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能监控**：始终监控柯里化在特定环境中的性能影响。使用分析工具来识别任何瓶颈，并在必要时重构代码以优化性能。'
- en: '**Enhanced debugging techniques**: Utilize advanced debugging tools and techniques,
    such as conditional breakpoints and call stack analysis, to better manage the
    debugging of curried functions.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的调试技术**：利用高级调试工具和技术，如条件断点和调用栈分析，以更好地管理柯里化函数的调试。'
- en: '**Integration strategies**: When working within an object-oriented framework,
    integrate functional programming techniques gradually and ensure they complement
    rather than complicate the architecture.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成策略**：在面向对象框架内工作时，逐步集成函数式编程技术，并确保它们补充而不是复杂化架构。'
- en: While currying and partial application can introduce some complexity and challenges,
    with the right strategies and tools, these challenges can be managed effectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然柯里化和部分应用可能会引入一些复杂性和挑战，但有了正确的策略和工具，这些挑战可以有效地得到管理。
- en: As they wrapped up their discussion on currying and partial application, Steve
    looked thoughtful.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们讨论完柯里化和部分应用后，史蒂夫看起来很深思。
- en: 'Steve: *This has been really enlightening, Julia. I can see how these techniques
    could make our tower defense game code more flexible* *and maintainable.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*这真的很启发人心，朱莉娅。我可以看出这些技术如何使我们的塔防游戏代码更加灵活* *和易于维护。*
- en: 'Julia: *Exactly, Steve! And remember, like any tool in programming, the key
    is knowing when and how to apply these* *concepts effectively.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*没错，史蒂夫！记住，就像编程中的任何工具一样，关键在于知道何时以及如何有效地应用这些* *概念。*
- en: 'Steve: *Thanks, Julia. I’m looking forward to trying these out in our next*
    *coding session!*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*谢谢，朱莉娅。我期待在下次* *编码会议* *中尝试这些！*
- en: Julia smiled, pleased with Steve’s enthusiasm and progress in functional programming
    concepts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅微笑着，对史蒂夫在函数式编程概念上的热情和进步感到满意。
- en: Exercises
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this chapter, we’ve explored the functional programming concepts of currying
    and partial application. Now, let’s apply these techniques to practical scenarios
    in a mobile tower defense game.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了柯里化和部分应用的功能编程概念。现在，让我们将这些技术应用到移动塔防游戏的实际场景中。
- en: Exercise 1
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Refactor the `AttackEnemy` function using currying, allowing the `towerType`
    to be preset for multiple uses throughout the game while accepting dynamic inputs
    for `enemyId` and `damage`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柯里化重构 `AttackEnemy` 函数，允许在游戏过程中预设 `towerType` 以供多次使用，同时接受 `enemyId` 和 `damage`
    的动态输入：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exercise 2
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Apply partial application to create a function for quick setup of standard
    game settings where the `map` is predefined but allows for dynamic setting of
    `difficultyLevel` and `isMultiplayer`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用部分应用创建一个用于快速设置标准游戏设置的函数，其中 `map` 是预定义的，但允许动态设置 `difficultyLevel` 和 `isMultiplayer`：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Exercise 3
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Curry this function so that it can first accept a `userRole` and then return
    another function that takes a `feature`, determining whether the specified role
    has access to it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数柯里化，使其首先接受一个 `userRole`，然后返回另一个函数，该函数接受一个 `feature`，以确定指定角色是否有权访问它：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These exercises are tailored to help you apply currying and partial application
    within the context of a mobile tower defense game. By practicing these techniques,
    you’ll enhance the functionality and scalability of the game’s code base, making
    it easier to manage and extend. Remember, the more you practice these functional
    programming techniques, the more proficient you’ll become in building sophisticated
    game logic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习旨在帮助你在移动塔防游戏的背景下应用柯里化和部分应用。通过练习这些技术，你将增强游戏代码库的功能性和可扩展性，使其更容易管理和扩展。记住，你练习这些函数式编程技术越多，你在构建复杂游戏逻辑方面的熟练程度就会越高。
- en: Solutions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Here are the solutions to the exercises related to currying and partial application
    within the context of a mobile tower defense game. These solutions demonstrate
    how to implement the concepts discussed and provide practical examples of their
    use in game development.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于移动塔防游戏中柯里化和部分应用练习的解决方案。这些解决方案展示了如何实现所讨论的概念，并提供了在游戏开发中实际使用这些概念的示例。
- en: Solution 1
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1
- en: 'To refactor the `AttackEnemy` function using currying, we first define the
    original function and then transform it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用柯里化重构 `AttackEnemy` 函数，我们首先定义原始函数，然后将其转换：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This curried function allows the `towerType` to be set once and reused for multiple
    attacks, enhancing code reusability and reducing redundancy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此柯里化函数允许一次设置 `towerType` 并在多次攻击中重复使用，从而提高代码的可重用性并减少冗余。
- en: Solution 2
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2
- en: 'Use partial application for simplifying game settings configuration:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部分应用简化游戏设置配置：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function partially applies the map setting, allowing other settings such
    as `difficultyLevel` and `isMultiplayer` to be configured dynamically.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数部分应用了映射设置，允许动态配置其他设置，例如 `difficultyLevel` 和 `isMultiplayer`。
- en: Solution 3
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 3
- en: 'Implement a curried function for managing permissions based on user roles and
    actions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个基于用户角色和动作的权限管理的柯里化函数：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This curried function simplifies permission checks by setting the `userRole`
    once and allowing dynamic checks for various features, streamlining the permission
    management process.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此柯里化函数通过一次设置 `userRole` 并允许对各种功能进行动态检查，简化了权限检查过程，从而简化了权限管理流程。
- en: These solutions demonstrate practical applications of currying and partial application,
    improving the structure and maintainability of code within a mobile tower defense
    game. By implementing these techniques, developers can enhance both the flexibility
    and readability of their game logic.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案展示了柯里化和部分应用在移动塔防游戏中的实际应用，提高了代码的结构和可维护性。通过实施这些技术，开发者可以增强游戏逻辑的灵活性和可读性。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored currying and partial application. Currying transforms
    a multi-parameter function into a sequence of single-parameter functions, each
    accepting one argument and returning another function ready to take the next argument.
    This technique is particularly beneficial for creating configurable and highly
    modular code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了柯里化和部分应用。柯里化将多参数函数转换为一系列单参数函数，每个函数接受一个参数并返回另一个函数，该函数准备好接受下一个参数。这种技术特别有利于创建可配置和高度模块化的代码。
- en: Partial application involves fixing some arguments of a function and creating
    a new function that requires fewer arguments. This approach is invaluable in scenarios
    where certain parameters are repeatedly used with the same values, as it simplifies
    function calls and reduces redundancy.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用涉及固定函数的一些参数，并创建一个需要较少参数的新函数。这种方法在特定参数反复使用相同值的情况下非常有价值，因为它简化了函数调用并减少了冗余。
- en: If something is still not clear, use the examples provided in this chapter –
    modify them, experiment with them, and integrate them with your projects. In other
    words, see how it works in practice. Whether simplifying configuration management,
    making event handling more straightforward, or reducing the complexity of API
    interactions, currying and partial application can help you to reduce complexity
    in function calls, enhance code modularity and readability, and overall, bring
    your programs to the next level in terms of functional programming.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些内容仍然不清楚，请使用本章提供的示例——修改它们，实验它们，并将它们整合到你的项目中。换句话说，看看它在实际中的应用。无论是简化配置管理、使事件处理更加直接，还是减少API交互的复杂性，柯里化和部分应用都能帮助你减少函数调用的复杂性，增强代码的模块化和可读性，并且总体上，将你的程序在函数式编程方面提升到新的水平。
- en: In the next chapter, we will sum up all we’ve learned about pipelines and composition
    from the previous chapters, add more real-world scenarios, and discuss more advanced
    topics such as error handling, testing, and performance consideration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结前几章中关于管道和组合所学的所有内容，增加更多现实世界的场景，并讨论更多高级主题，如错误处理、测试和性能考虑。
