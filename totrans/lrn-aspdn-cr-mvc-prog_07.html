<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Routing">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07"/>&#13;
 Chapter 7. Routing</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Routing is one of the important concepts in the ASP.NET MVC application as it takes care of incoming requests and maps them to the appropriate controller's actions.</p>&#13;
<p>In this chapter, we are going to learn about the following topics:</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">Using the <code class="literal">MapRoute</code>&#13;
 method to configure routing</li>&#13;
<li class="listitem">Different types of routing with examples—convention and attribute-based</li>&#13;
<li class="listitem">Using HTTP verbs in attribute-based routing</li>&#13;
</ul>&#13;
</div>&#13;
<p>We briefly discussed routing in <a class="link" title="Chapter 3. Controllers" href="text00027.html#page">Chapter 3</a>&#13;
 , <span class="emphasis">&#13;
<em>Controllers</em>&#13;
</span>&#13;
 . In this chapter, we are going to discuss routing along with several options available to customize it in ASP.NET Core.</p>&#13;
<div class="section" title="Convention-based routing">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07lvl1sec48"/>&#13;
 Convention-based routing</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>The routing engine is responsible for mapping the incoming requests to the appropriate action method of the controller.</p>&#13;
<p>In the <code class="literal">Configure</code>&#13;
 method of the <code class="literal">Startup</code>&#13;
 class, we have mapped the following route:</p>&#13;
<pre class="programlisting">app.UseMvc(routes =&gt; 
    { 
        routes.MapRoute(name: "default", 
        template: "{controller=Employee}/{action=Index}/{id?}"); 
    }); 
</pre>&#13;
<p>The <code class="literal">MapRoute</code>&#13;
 method has two parameters:</p>&#13;
<div class="itemizedlist">&#13;
<ul class="itemizedlist">&#13;
<li class="listitem">&#13;
<code class="literal">name</code>&#13;
 : This represents the name of the route as we could configure multiple routes for the same application.</li>&#13;
<li class="listitem">&#13;
<code class="literal">template</code>&#13;
 : This signifies the actual configuration for the route. There are three parts to this configuration value. As we are supplying default parameters, if the values are not passed, it will take the default parameter values.</li>&#13;
<li class="listitem">&#13;
<code class="literal">{controller=Employee}</code>&#13;
 : The first value acts as the name of the controller and we use the <code class="literal">Employee</code>&#13;
 controller as the default controller when the controller value is not available in the URL.</li>&#13;
<li class="listitem">&#13;
<code class="literal">{action=Index}</code>&#13;
 : The <code class="literal">Index</code>&#13;
 action method will be acting as the default action method and the second parameter from the URL will be taken as the action method name.</li>&#13;
<li class="listitem">&#13;
<code class="literal">{id?</code>&#13;
 <code class="literal">}</code>&#13;
 : By specifying "<code class="literal">?</code>&#13;
 " after the <code class="literal">id</code>&#13;
 parameter, we are saying that <code class="literal">id</code>&#13;
 is the optional parameter. If the value is passed as the third parameter, the <code class="literal">id</code>&#13;
 value will be taken. Otherwise, it would not be considered.</li>&#13;
</ul>&#13;
</div>&#13;
<p>There is another method with the same functionality. The <code class="literal">app.UseMvcWithDefaultRoute()</code>&#13;
 method configures the route <code class="literal">"{controller=Employee}/{action=Index}/{id?}"</code>&#13;
 . But we have used the earlier method to show that we can customize the route as we want.</p>&#13;
<p>Let us see a few examples and observe how our routing engine works. We are assuming the following routing for the preceding examples:</p>&#13;
<pre class="programlisting">"{controller=Employee}/{action=Index}/{id?}" 
</pre>&#13;
<div class="section" title="Example 1">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch07lvl2sec47"/>&#13;
 Example 1</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>URL-<code class="literal">http://localhost:49831/</code>&#13;
</p>&#13;
<p>In this URL, we have not passed a value for the <code class="literal">controller</code>&#13;
 , <code class="literal">action</code>&#13;
 , or <code class="literal">id</code>&#13;
 . Since we have not passed anything, it would take the default values for the controller and the action. So, the URL is converted into the following URL by the routing engine:</p>&#13;
<p>&#13;
<code class="literal">http://localhost:49831/Employee/Index</code>&#13;
</p>&#13;
</div>&#13;
<div class="section" title="Example 2">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch07lvl2sec48"/>&#13;
 Example 2</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>URL-<code class="literal">http://localhost:49831/Employee/</code>&#13;
</p>&#13;
<p>In this URL, we have passed the value for the <code class="literal">controller</code>&#13;
 (the first parameter), which is <code class="literal">Employee</code>&#13;
 , whereas we did not pass anything for <code class="literal">action</code>&#13;
 method (the second parameter) or <code class="literal">id</code>&#13;
 (the third parameter). So, the URL will be converted into the following URL by taking the default value for the <code class="literal">action</code>&#13;
 method:</p>&#13;
<p>&#13;
<code class="literal">http://localhost:49831/Employee/Index</code>&#13;
</p>&#13;
</div>&#13;
<div class="section" title="Example 3">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch07lvl2sec49"/>&#13;
 Example 3</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>URL-<code class="literal">http://localhost:49831/Manager/List</code>&#13;
</p>&#13;
<p>The routing engine will take the first parameter, <code class="literal">Manager</code>&#13;
 , as the <code class="literal">controller</code>&#13;
 method name and the second parameter, <code class="literal">List</code>&#13;
 , as the <code class="literal">action</code>&#13;
 method name.</p>&#13;
</div>&#13;
<div class="section" title="Example 4">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h2 class="title"><a id="ch07lvl2sec50"/>&#13;
 Example 4</h2>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>URL-<code class="literal">http://localhost:49831/Manager/Details/2</code>&#13;
</p>&#13;
<p>We have passed all three parameters in this URL. So, the first parameter value, <code class="literal">Manager</code>&#13;
 , will be considered as the <code class="literal">controller</code>&#13;
 method name, the second parameter value will be considered as the <code class="literal">action</code>&#13;
 method name, and the third parameter value will be considered as the <code class="literal">id</code>&#13;
 method name.</p>&#13;
<p>When defining the map route, we have used the <code class="literal">MapRoute</code>&#13;
 method with a couple of parameters. The first parameter, <code class="literal">name</code>&#13;
 , represents the name of the route and the second parameter, <code class="literal">template</code>&#13;
 , represents the URL pattern to be matched along with the default values:</p>&#13;
<pre class="programlisting">routes.MapRoute(name: "default",
               template: "{controller=Employee}/{action=Index}/{id?}");</pre>&#13;
<p>There are other overloaded variations of this <code class="literal">MapRoute</code>&#13;
 method. The following is another commonly overloaded <code class="literal">MapRoute</code>&#13;
 method, where the incoming URL pattern and the default values are passed for different parameters. The name of the route is <code class="literal">FirstRoute</code>&#13;
 and this route will be applied for all URLs starting with <code class="literal">Home</code>&#13;
 . The default values for the controller and the action are <code class="literal">Home</code>&#13;
 and <code class="literal">Index2</code>&#13;
 respectively:</p>&#13;
<pre class="programlisting">routes.MapRoute(name:"FirstRoute",
               template:"Home",
               defaults:new {controller ="Home", action="Index2"});</pre>&#13;
<p>You can define any number of routing maps for your ASP.NET MVC application. There is no restriction or limit on the routing maps. Let us add another routing map to our application. We have added another route map called <code class="literal">FirstRoute</code>&#13;
 to our application (highlighted in bold):</p>&#13;
<pre class="programlisting">public void Configure(IApplicationBuilder app) 
    { 
        app.UseIISPlatformHandler(); 
        app.UseMvc(routes =&gt; 
        { 
            <span class="strong">
<strong>routes.MapRoute(name:"FirstRoute",
            template:"Home", defaults:new {controller ="Home", action="Index2"});
</strong>&#13;

</span>&#13;


            routes.MapRoute(name: "default",
            template: "{controller=Employee}/{action=Index}/{id?}");
        }); 
    } 
</pre>&#13;
<p>And we have added another <code class="literal">controller</code>&#13;
 method by the name <code class="literal">HomeController</code>&#13;
 with a couple of simple <code class="literal">action</code>&#13;
 methods returning different strings:</p>&#13;
<pre class="programlisting">public class HomeController : Controller 
    { 
        // GET: /&lt;controller&gt;/ 
        public IActionResult Index() 
        { 
            return Content("Index action method"); 
        } 
 
        public IActionResult Index2() 
        { 
            return Content("Index2 action method"); 
        } 
    } 
</pre>&#13;
<p>When you try to access the application through the URL, <code class="literal">http://localhost:49831/Hello</code>&#13;
 , both routing maps, <code class="literal">FirstRoute</code>&#13;
 and the <code class="literal">default</code>&#13;
 , match with the URL pattern.</p>&#13;
<p>Which map routing, do you think, will get applied in this scenario?</p>&#13;
<p>The routing engine maps the incoming URL based on the following factors:</p>&#13;
<div class="orderedlist">&#13;
<ol class="orderedlist arabic">&#13;
<li class="listitem" value="1">Matching pattern.</li>&#13;
<li class="listitem" value="2">On the order defined in the routing engine.</li>&#13;
</ol>&#13;
<div style="height:10px; width: 1px"/>&#13;
</div>&#13;
<p>The first factor is an obvious one. For a routing map to be picked up by the routing engine, the pattern of the incoming URL should get matched with the defined template in the routing map.</p>&#13;
<p>The second factor is subtle but important. If more than one routing map matches with the incoming URL, the routing engine will pick the first URL as defined in the configuration. For example, if the incoming URL matches with both the <code class="literal">FirstRoute</code>&#13;
 and <code class="literal">default</code>&#13;
 maps, the routing engine will pick the <code class="literal">FirstRoute</code>&#13;
 map as it was defined first in the configuration.</p>&#13;
<div class="mediaobject"><img src="Image00109.jpg" alt="Example 4"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
<p>If the routing engine could not map the incoming URL to any of the mapping routes, we get an <code class="literal">HTTP 404 error</code>&#13;
 , meaning that no resource could be found. You can see the status (200 means <span class="emphasis">&#13;
<em>OK</em>&#13;
</span>&#13;
 , 404 means <span class="emphasis">&#13;
<em>No resource found</em>&#13;
</span>&#13;
 ) by looking at the <span class="strong">&#13;
<strong>Network</strong>&#13;
</span>&#13;
 tab in the developer tools as shown in the following screenshot:</p>&#13;
<div class="mediaobject"><img src="Image00110.jpg" alt="Example 4"/>&#13;
</div>&#13;
<p style="clear:both; height: 1em;"/>&#13;
</div>&#13;
</div>&#13;
</div>&#13;

<div class="section" title="Attribute-based routing">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07lvl1sec49"/>&#13;
 Attribute-based routing</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Until now, we have used convention-based routing. In convention-based routing, we define the routing templates (which are just parameterized strings) in a centralized place these are applicable to all the available controllers. The problem with convention-based routing is that, if we want to define different URL patterns for different controllers, we need to define a custom URL pattern that is common to all the controllers. This makes things difficult.</p>&#13;
<p>There is another option for configuring the routing engine-attribute-based routing. In attribute-based routing, instead of configuring all the routing in a centralized location, the configuration will happen at the controller level.</p>&#13;
<p>Let us see an example of attribute-based routing.</p>&#13;
<p>First, let us remove the convention-based routing that we created earlier in the <code class="literal">Configure</code>&#13;
 method in the <code class="literal">startup.cs</code>&#13;
 class file:</p>&#13;
<pre class="programlisting">public void Configure(IApplicationBuilder app) 
    { 
        app.UseIISPlatformHandler(); 
        app.UseMvc(); 
        //app.UseMvc(routes =&gt; 
        //{ 
        //    routes.MapRoute(name: "FirstRoute",
        //                    template: "Hello", 
        //                    defaults: new { controller = "Home",  
        //                    action = "Index2" }); 
 
        //    routes.MapRoute(name: "default",
        //                 template:"
        //                {controller=Employee}/{action=Index}/{id?}"); 
        //}); 
    } 
</pre>&#13;
<p>Then, we can configure the routing at the controller itself. In the following code, we have added the routing configuration for the <code class="literal">home</code>&#13;
 controller that we created earlier:</p>&#13;
<pre class="programlisting">namespace Validation.Controllers 
{ 
    public class HomeController : Controller 
    { 
        // GET: /&lt;controller&gt;/ 
        [Route("Home")] 
        public IActionResult Index() 
        { 
            return Content("Index action method"); 
        } 
        [Route("Home/Index3")] 
        public IActionResult Index2() 
        { 
            return Content("Index2 action method"); 
        } 
    } 
} 
</pre>&#13;
<p>We have used the <code class="literal">Route</code>&#13;
 attribute in the <code class="literal">action</code>&#13;
 methods of the controller. The value passed in the <code class="literal">Route</code>&#13;
 attribute will be acting as the URL pattern. For example, when we access the URL <code class="literal">http://localhost:49831/Home/</code>&#13;
 , the <code class="literal">Index</code>&#13;
 method of <code class="literal">HomeController</code>&#13;
  will be called. When we access the URL <code class="literal">http://localhost:49831/Home/Index3</code>&#13;
 , the <code class="literal">Index2</code>&#13;
 method of <code class="literal">HomeController</code>&#13;
 will be called. Please note that the URL pattern and <code class="literal">action</code>&#13;
 method name do not need to match. In the preceding example, we are calling the <code class="literal">Index2</code>&#13;
 action method but the URL pattern uses <code class="literal">Index3</code>&#13;
 , <code class="literal">http://localhost:49831/Home/Index3</code>&#13;
 .</p>&#13;
<p>When you use attribute-based routing and convention-based routing together, attribute-based routing will take precedence.</p>&#13;
</div>&#13;

<div class="section" title="Route attribute at the controller level">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07lvl1sec50"/>&#13;
 Route attribute at the controller level</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>You will notice that, with the URL pattern for the <code class="literal">action</code>&#13;
 methods, <code class="literal">Index</code>&#13;
 and <code class="literal">Index2</code>&#13;
 , we repeat the controller name, <code class="literal">Home</code>&#13;
 , in both URL patterns, <code class="literal">Home</code>&#13;
 and <code class="literal">Home/Index3</code>&#13;
 . Instead of repeating the <code class="literal">controller</code>&#13;
 method name (or any common part in the URL) at the <code class="literal">action</code>&#13;
 method level, we can define it at the <code class="literal">controller</code>&#13;
 level.</p>&#13;
<p>In the following code, the common part of the URL (<code class="literal">Home</code>&#13;
 ) is defined at the <code class="literal">controller</code>&#13;
 level and the unique part is defined at the <code class="literal">action</code>&#13;
 method level. When the URL pattern is getting mapped to the <code class="literal">action</code>&#13;
 methods of the controller, both route parts (at the <code class="literal">controller</code>&#13;
 level and at the <code class="literal">action</code>&#13;
 method level) are merged and matched. So there will be no difference between the routes defined earlier and those that follow.</p>&#13;
<p>If you want two parameters in attribute-based routing, you can pass them within curly braces. In the following example, we did this for the <code class="literal">SayHello</code>&#13;
 action method.</p>&#13;
<p>For example, the URL pattern <code class="literal">http://localhost:49831/Home/Index3</code>&#13;
 , will still get mapped to <code class="literal">Index2</code>&#13;
 method of the <code class="literal">Homecontroller</code>&#13;
 :</p>&#13;
<pre class="programlisting">namespace Validation.Controllers 
{     
    [Route("Home")] 
    public class HomeController : Controller 
    { 
        // GET: /&lt;controller&gt;/ 
        [Route("")] 
        public IActionResult Index() 
        { 
            return Content("Index action method"); 
        } 
 
        [Route("Index3")] 
        public IActionResult Index2() 
        { 
            return Content("Index2 action method"); 
        } 
 
 [Route("SayHello/{id}")] 
        public IActionResult SayHello(int id) 
        { 
            return Content("Say Hello action method"+id); 
        } 
    } 
} 
</pre>&#13;
</div>&#13;

<div class="section" title="Passing routing values in HTTP action verbs in the Controller">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07lvl1sec51"/>&#13;
 Passing routing values in HTTP action verbs in the Controller</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Instead of passing the routing values as <code class="literal">Route</code>&#13;
 attributes, we can even pass the routing values in HTTP action verbs such as <code class="literal">HTTPGet</code>&#13;
  and <code class="literal">HTTPPost</code>&#13;
 .</p>&#13;
<p>In the following code, we have used the <code class="literal">HTTPGet</code>&#13;
 attribute to pass the route values. For the <code class="literal">Index</code>&#13;
 method, we did not pass any value and hence no route value will get appended to the route value defined at the <code class="literal">controller</code>&#13;
 method level. For the <code class="literal">Index2</code>&#13;
 method, we are passing the value <code class="literal">Index3</code>&#13;
 and <code class="literal">Index3</code>&#13;
 will get appended to the route value defined at the <code class="literal">controller</code>&#13;
 level. Please note that only URLs with <code class="literal">GET</code>&#13;
 methods will be mapped to the <code class="literal">action</code>&#13;
 methods. If you access the same URL pattern with the <code class="literal">POST</code>&#13;
 method, these routes will not get matched and hence these <code class="literal">action</code>&#13;
 methods will not get called.</p>&#13;
<pre class="programlisting">namespace Validation.Controllers 
{     
    [Route("Home")] 
    public class HomeController : Controller 
    { 
        // GET: /&lt;controller&gt;/ 
        [HttpGet()] 
        public IActionResult Index() 
        { 
            return Content("Index action method"); 
        } 
 
        [HttpGet("Index3")] 
        public IActionResult Index2() 
        { 
            return Content("Index2 action method"); 
        } 
    } 
} 
</pre>&#13;
</div>&#13;

<div class="section" title="Route Constraints">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07lvl1sec52"/>&#13;
 Route Constraints</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>Route Constraints enable you to constrain the type of values that you pass to the controller action. For example, if you want to restrict the value to be passed to the <code class="literal">int</code>&#13;
 type <code class="literal">int</code>&#13;
 , you can do so. The following is one such instance:</p>&#13;
<pre class="programlisting">[HttpGet("details/{id:int?}")] 
    public IActionResult Details(int id) 
    { 
      return View(); 
    } 
</pre>&#13;
<p>ASP.NET 5 (ASP.NET Core) even supports default parameter values so that you can pass the default parameters:</p>&#13;
<pre class="programlisting">[HttpGet("details/{id:int = 123}")] 
    public IActionResult Details(int id) 
    { 
      return View(); 
    } 
</pre>&#13;
</div>&#13;

<div class="section" title="Summary">&#13;
<div class="titlepage">&#13;
<div>&#13;
<div>&#13;
<h1 class="title"><a id="ch07lvl1sec53"/>&#13;
 Summary</h1>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
<p>In this chapter, we have learned about routing and how it works. We learned about different kinds of routing available. We discussed convention-based routing and attribute-based routing with different examples. We also discussed route constraints and the default parameter values that could be passed.</p>&#13;
<p>In the next chapter, we are going to see how we can make the application look good.</p>&#13;
</div>&#13;
</body></html>