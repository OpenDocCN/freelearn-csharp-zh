- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Appendix
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing code, every language has its nuances and standards. .NET is no
    different when it comes to general guidelines. One example is that placing a bracket
    at the end of a method signature is better than placing the bracket on the next
    line or placing a return immediately on the same line as an `if` statement. This
    is more of a personal preference. Programming guidelines give developers a way
    to stay between guardrails while writing code. These programming guidelines are
    used throughout the industry as standard practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In the appendix, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Programming guidelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The guidelines discussed in the following sections are commonly used in the
    industry. They give developers direction and provide guardrails as to how one
    should structure and write code not only for themselves, but also for other developers
    and peers in the future (including our future selves).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we’ll review some programming guidelines such as the DRY,
    YAGNI, and KISS principles, along with separation of concerns, the concept of
    SOLID, and how refactoring is a process and not a one-time quick fix. We’ll finish
    the appendix by looking at recommended ways of organizing .NET projects and folder
    structures, and where code resides based on their function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only technical requirement for the appendix is access to your editor since
    we’ll be covering general programming guidelines. While we will have snippets
    of code along the way, they don’t justify their own code repository. They’re only
    meant to solidify the understanding of the concepts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Programming guidelines
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, I recommend various intermediate and advanced techniques
    of writing code pertaining to a particular topic or technology. While these techniques
    are meant to give developers a balance between requirements and technologies,
    there is also a need to provide common programming guidelines to follow certain
    patterns, making it easier for colleagues and peers to understand a code base.
    Successful developers think about these guidelines while writing and maintaining
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review the DRY, YAGNI, KISS, and SOLID principles along
    with understanding separation of concerns, and how refactoring is a process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: DRY
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first acronym we’ll review is probably one of the simplest guidelines to
    follow. The **DRY** principle stands for **don’t** **repeat yourself**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple methods performing the same task in different locations
    of your application, it may be time to refactor and consolidate the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next common acronym is **YAGNI** (pronounced yag-nee), which stands for
    **you aren’t gonna** **need it**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Also referred to as “building the bridge to nowhere,” the concept behind this
    acronym is to let developers know they should only write code when there is a
    requirement for it. They shouldn’t add code for a possible future enhancement
    that may not come to fruition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: KISS
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS
- en: Since this next acronym has so many meanings, we’ll try to keep it simple (hence
    the name). **KISS** stands for **keep it** **simple, stupid**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个缩写词有如此多的含义，我们将尽量保持简单（因此得名）。**KISS** 代表 **keep it** **simple, stupid**。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Keep your units of code simple enough to understand. This can include the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的代码单元足够简单，以便理解。这可以包括以下内容：
- en: '**Smaller methods** – The smaller the method, the easier it is to read and
    understand'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的方法** – 方法越小，就越容易阅读和理解'
- en: '**Language enhancements** – Based on .NET’s C# language improvements over the
    years, there may be a better (and shorter) way to write code'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言增强** – 基于多年来 .NET 的 C# 语言改进，可能存在更好的（更简短）的编写代码的方式'
- en: '**Reducing complexity** – When reducing complexity, systems become more testable
    and can be a possible candidate for automated testing'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化复杂性** – 当简化复杂性时，系统变得更加可测试，并且可能成为自动化测试的候选者。'
- en: The goal is to build more value by creating a better code base for peers and
    colleagues.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是通过为同行和同事创建更好的代码库来创造更多价值。
- en: Separation of concerns
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: When you started writing your own application, running it and seeing it execute
    on the screen for the first time was a huge achievement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写自己的应用程序，运行它并看到它在屏幕上第一次执行时，这是一项巨大的成就。
- en: Over time, the application required a database. Then it required email capabilities.
    Then logging. Then authentication. The requirements grew and so on and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，应用程序需要数据库。然后需要电子邮件功能。然后是日志记录。然后是身份验证。需求不断增长，如此等等。
- en: 'The separation of concerns concept pertains to how you logically partition
    an application into distinct layers. For example, if an application requires an
    email module, it would be a separate project in the solution called `MyApplication.EmailModule`.
    This email module would provide the following benefits to the application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点的分离概念涉及你如何逻辑地将应用程序划分为不同的层。例如，如果一个应用程序需要电子邮件模块，它将是解决方案中名为 `MyApplication.EmailModule`
    的独立项目。这个电子邮件模块将为应用程序提供以下好处：
- en: '`EmailModule` could be reused in another application if necessary.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，`EmailModule` 可以在另一个应用程序中重用。
- en: '`EmailModule` doesn’t require any outside dependencies; it’s self-contained.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailModule` 不需要任何外部依赖；它是自包含的。'
- en: '`EmailModule`, unit testing (and possibly integration testing) becomes easier.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailModule`，单元测试（以及可能的集成测试）变得更容易。'
- en: '`EmailModule` as opposed to the entire application. When focusing on one particular
    section, it doesn’t require the knowledge of the entire application. The knowledge
    of the project is all that’s required.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailModule` 相比整个应用程序。当专注于特定部分时，不需要了解整个应用程序。只需要了解项目知识即可。'
- en: One of the concepts heard in the industry is “Big Ball of Mud.” This concept
    pertains to all of the application code contained in one project, which is an
    unmaintainable code base. This is a similar concept to a “monolith,” where the
    application is hard to maintain because of its size. Consequently, concepts in
    the application aren’t broken out into modular units of work. If everything in
    the application is coupled together…everywhere, the system is brittle. If a developer
    modifies code in one location, it may fix the current issue but it will introduce
    errors in other locations, causing a ripple effect throughout the entire code
    base.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 行业内听到的其中一个概念是“大泥球”。这个概念涉及一个项目中包含的所有应用程序代码，这是一个难以维护的代码库。这与“单体”类似，由于规模庞大，应用程序难以维护。因此，应用程序中的概念没有被分解成模块化的工作单元。如果应用程序中的所有内容都耦合在一起……到处都是，系统就会变得脆弱。如果一个开发者修改了某个位置的代码，它可能会修复当前的问题，但会在其他位置引入错误，在整个代码库中产生连锁反应。
- en: Separation of concerns is something that experienced developers should share
    with their peers through code reviews to improve software on a larger scale and
    provide healthy discussions on the topic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点的分离是经验丰富的开发者应该通过代码审查与同行分享的，以在更大范围内改进软件并提供关于该主题的健康讨论。
- en: Refactoring as a process
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构作为一个过程
- en: While refactoring is a fundamental concept for developers, there are various
    levels of effort involved in refactoring a code base.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重构是开发者的基本概念，但在重构代码库时涉及各种努力水平。
- en: One simple example could be the renaming of a method. Once a developer renames
    a method, the developer has to change all of the references to that method in
    the code base. A more advanced example is the refactoring of a business rules
    engine to create more flexibility. While both are refactoring, one is easier than
    the other.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactoring should be a process. One process I’ve used over the years is as
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Get it functional** – Write functional code that works'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get it tested** – Create tests to confirm the code behaves as expected'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get it refactored** – Refactor and optimize the code'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code you write should (usually) have tests (see the “100% Test Coverage”
    myth in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: With that said, if you’re going to refactor code, *it will be beneficial to
    have tests in place* to confirm your refactoring efforts aren’t in vain. Once
    you have tests in place, you are free to refactor and modify as much code as needed
    to achieve your intended goal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The business rules engine was an example in my career where the code was functional
    and a lot of tests were in place (~700 passed). However, the team ran into an
    issue where the code required a more flexible approach and it had to be refactored.
    Two team members took three days to refactor the code. Once they finished the
    refactoring, they ran the final unit tests and found only two failed unit tests.
    The two failed unit tests were because they didn’t rename a method name properly.
    Imagine this refactoring without the tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring can be as complex or as simple as the code base allows. Always keep
    in mind that refactoring is a multi-step process and requires tests to confirm
    the refactored code works as expected.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Book recommendation
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: One book I would highly recommend is *Refactoring with C#, Matt Eland, Packt
    Publishing*, available at [https://www.packtpub.com/](https://www.packtpub.com/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SOLID** principles provide even deeper guidelines for writing code. SOLID
    is an acronym and was created back in 2000 by Robert C. Martin.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the SOLID principles have become a standard for writing quality
    software, and give developers a way to gauge their code based on whether it meets
    each principle’s criteria. Developers may disagree with what constitutes SOLID
    code, but again, these discussions should be had with peers or in a team meeting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **single responsibility principle** (**SRP**) dictates that a class should
    have one and only one reason to change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code violates the SRP:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `User` class has two properties: `Name` and `Email`. However, we have extra
    methods performing other responsibilities: an `IsValid()` method and a `Save()`
    method. Our `User` class is doing more than it should. We should create two new
    classes: one called `UserValidation` for validation, and one called `UserService`
    or `UserRepository` for database operations.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two additional classes but provided better software composition.
    If we add a new property to the `User` class and it requires validation, the developer
    only needs to make a change in one place: the `UserValidation` class.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **open/closed principle** describes how software components should be open
    for extension but closed for modification.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Most violations of the open/closed principle are usually indicated by long branching
    statements (such as long `if..then` or `switch` statements).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this `ComicBook` class, we have three properties called `Title`, `Issue`,
    and `Grading`. One of the requirements for our class is to return the grading
    name based on the `Grading` property. This violates the open/closed principle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Why? Even though we already have the complete list of grades, the `GetGradeName()`
    method and add a new grade and name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation to support the open/closed principle is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While it looks like we simply moved the `switch` statement, we did something
    else. We created a `Grade` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: With a `Grade` class created, we can assign any type of grade to the `ComicBook`
    class. If a new grade type is created, we can easily add it to our list without
    modifying the `ComicBook` class. We also implemented a factory pattern in our
    code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Before, we were comparing a string based on a decimal value. Now, if additional
    properties are required for a grade, we can extend our `Grade` class to include
    more information.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Open for extension, closed to modification.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Liskov substitution principle** explains that any derived type can be
    replaced with its base types. The concept behind the Liskov substitution is based
    on inherited types and/or interfaces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with our comic book example, the following code shows a simple
    `BasePublisher` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `BasePublisher` class contains the name and address of a publisher. When
    we create a new publisher (such as the preceding `MyNewPublisher` class), we’ll
    have access to everything available in the base class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The ability to replace a `BasePublisher` class with a `MyNewPublisher` class
    would be an example of the Liskov substitution principle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **interface segregation principle** explains that clients shouldn’t be forced
    to implement unnecessary methods they won’t use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: With every interface created in an application, each method and property defined
    should be implemented in a concrete class. The defined interfaces should not go
    to waste in an implementation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we have an interface for our `ComicBook` class. The
    interface and implementation code are listed as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Everything in our `ComicBook` class is justified except for the `SaveToDatabase()`
    method. Creating a new `ComicBook` instance suggests we’ll be using the database
    every time. This violates the interface segregation principle.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation would be splitting the database access out into an
    `IComicBookWriter` with a `SaveToDatabase()` method, as shown in the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的实现是将数据库访问拆分到一个具有`SaveToDatabase()`方法的`IComicBookWriter`中，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The example code shows how inheriting from the `IComicBookWriter` gives the
    `ComicBook` class a way to persist the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码展示了如何通过继承自`IComicBookWriter`为`ComicBook`类提供持久化数据的方式。
- en: The goal of the interface segregation principle is to avoid including methods
    in an interface that you won’t use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接口分离原则的目标是避免在接口中包含你不会使用的方法。
- en: This example is also a violation of the SRP since this class is also accessing
    the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也违反了单一职责原则，因为这个类也在访问数据库。
- en: Dependency inversion
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: The **dependency inversion principle** explains that we should depend on abstractions
    and not on concrete implementations. With .NET, dependency injection is available
    out of the box. With dependency injection automatically available, this satisfies
    half of our dependency inversion principle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**解释了我们应该依赖于抽象而不是具体实现。在.NET中，依赖注入是默认可用的。有了自动可用的依赖注入，这满足了依赖倒置原则的一半。'
- en: While we can dependency-inject concrete classes into constructors, a better
    implementation would be to create an interface for the concrete implementation.
    Using interfaces encourages loose coupling throughout our code base.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将具体类注入到构造函数中，但更好的实现是创建一个具体实现的接口。使用接口鼓励我们在整个代码库中实现松散耦合。
- en: For example, back in [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114) with Entity
    Framework, we created a simple interface for our `DbContext`s for this very reason.
    Instead of registering a concrete implementation of a `DbContext`, we could use
    its interface instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到[*第5章*](B19493_05.xhtml#_idTextAnchor114)中，使用Entity Framework，我们为了这个原因创建了一个简单的接口来支持我们的`DbContext`。我们不是注册一个`DbContext`的具体实现，而是使用其接口。
- en: We registered our abstraction (interface) to support our dependency inversion
    principle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了我们的抽象（接口）以支持我们的依赖倒置原则。
- en: In this section, the terms DRY, YAGNI, and KISS, along with what separation
    of concerns means and how refactoring is a process and not a single task. We finished
    the section by learning each SOLID practice, namely the single responsibility,
    open/closed, Liskov substitution, interface segregation, and dependency inversion
    principles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了DRY、YAGNI和KISS等术语，以及关注点分离的含义以及重构是一个过程而不是单一任务。我们通过学习每个SOLID实践结束本节，即单一职责、开闭、里氏替换、接口分离和依赖倒置原则。
- en: In the next section, we’ll learn about folder organization based on project
    types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习基于项目类型的文件夹组织。
- en: Project structure
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: As mentioned in [*Chapter 7*](B19493_07.xhtml#_idTextAnchor163), on testing,
    folder structures can reveal an application’s intent and provide documentation
    as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第7章*](B19493_07.xhtml#_idTextAnchor163)中所述，在测试方面，文件夹结构可以揭示应用程序的意图并提供文档。
- en: In this section, we’ll learn about folder structures with ASP.NET web applications.
    We’ll also learn where to place code based on intent, such as where to place API
    code or Entity Framework code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习ASP.NET Web应用程序的文件夹结构。我们还将学习根据意图放置代码的位置，例如放置API代码或Entity Framework代码的位置。
- en: Understanding the project landscape
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解项目景观
- en: Every project has its own structure based on its type. For example, a **Razor
    Page** project layout is different from a **Model-View-Controller** (**MVC**)
    project or an API project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有其基于类型的结构。例如，**Razor Page**项目的布局与**模型-视图-控制器**（**MVC**）项目或API项目不同。
- en: Let’s examine what folders are in these common projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些常见项目中包含哪些文件夹。
- en: 'First, the following is an example of an ASP.NET Razor Page project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以下是一个ASP.NET Razor Page项目的示例：
- en: '![Figure 11.1 – Common folder structure of a Razor Page project](img/B19493_11_01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – Razor页面项目的常见文件夹结构](img/B19493_11_01.jpg)'
- en: Figure 11.1 – Common folder structure of a Razor Page project
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – Razor页面项目的常见文件夹结构
- en: 'Next is an example of an ASP.NET MVC project:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个ASP.NET MVC项目的示例：
- en: '![Figure 11.2 - Common folder structure of an MVC project](img/B19493_11_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 - MVC项目的常见文件夹结构](img/B19493_11_02.jpg)'
- en: Figure 11.2 - Common folder structure of an MVC project
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - MVC项目的常见文件夹结构
- en: As we move through each project, we’ll explain what each folder does and its
    purpose in the application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐个项目进行，我们将解释每个文件夹的功能以及在应用程序中的目的。
- en: wwwroot folder
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wwwroot文件夹
- en: In either of the preceding project types, the `wwwroot` folder contains all
    of our static content used on the website. Any folder added to this directory
    is static content and visible to the browser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'One example is an images folder. If we added an images folder to the `wwwroot`
    folder, the URL to that images folder would look like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For JavaScript frameworks (such as Angular, React, etc.), a folder called `source`
    or `src` should be created under the `wwwroot` folder to hold your client-side
    source code. The JavaScript framework should be transpiled to another folder of
    your choosing, such as a `js` or `app` folder for public browser consumption.
    We touched on these folders in [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)
    when we were building our client-side tasks using a task runner.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Pages folder
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a Razor Page project, the `Pages` folder is where server-side pages are found.
    Every folder created is a path to a page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we created a `Setup` folder and added an `Index.cshtml` file,
    the URL to execute and view that page would look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Other folders created under the `Pages` directory would follow the same path,
    as shown in *Figure 11**.3*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Folder structure for a MenuManager page](img/B19493_11_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Folder structure for a MenuManager page
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the directory structure in *Figure 11**.3*, the URL to **MenuManager**
    would be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The simpler the folder structure, the easier it is to locate a page and identify
    page functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Shared folder
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Shared` folder is used for common components such as layout pages, `ViewComponents`,
    partials, `EditorTemplates`, and `DisplayTemplates`. These shared components are
    accessible through web pages in the `Pages` folder (if it’s a Razor Pages project)
    or the `Views` folder (if it’s an MVC project).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Controllers folder
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVC projects always contain a `Controllers` folder and are the traffic cops
    of the web application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The MVC web model uses a “convention over configuration” concept where the name
    of the controller is the path and the methods inside the controller class are
    the page names.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the aforementioned `Controllers` folder, we have a class called
    `HomeController`. If we look in `HomeController`, we’ll see a method called `Index()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The presence of a `HomeController` class tells us three things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We will have a `/Home` URL with an `Index()` method for a default page
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Home` folder is located under the `/``Views` folder
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is an `Index()` method in `HomeController`, there should be an `Index.cshtml`
    in the `/``Views/Home` directory
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Index()` method tells us when the `https://localhost:xxx/Home` URL is called.
    It will automatically hit this `Index()` method and, by default, look for the
    Index view in the `/``Views/Home` directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Feature folders
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the secrets of an MVC application is the ability to move controllers
    around to any folder inside the application. On initial startup, the ASP.NET framework
    locates all of the controllers available throughout the application and creates
    a routing table for incoming web requests. Based on this approach, developers
    in the community have created **feature folders**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Feature folders are usually contained in a folder called `/Features` off the
    root with folders underneath to identify the feature implemented. While a `/Features`
    folder is the most common, developers have the ability to name the folder anything
    they want. They can also place controllers under any folder in the project. ASP.NET
    can locate all of the controllers on startup.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: These folders usually contain a minimum of a controller, a ViewModel, and a
    View. They can also contain supporting classes related to the feature. The folder
    is named based on the feature being implemented.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if there was an image viewing feature in your MVC application,
    it would look like *Figure 11**.4*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Example of an ImageViewer feature folder](img/B19493_11_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Example of an ImageViewer feature folder
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'This folder structure provides the following benefits:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus** – Each feature is isolated so team members can build the feature
    without causing merge issues'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consolidation** – Instead of moving from one folder to another throughout
    the entire project, features are confined to one folder, making the coding process
    more efficient'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Features/AccountsReceiveable` folder'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In MVC, the View path can be modified to fit your needs. In this case, defining
    a custom path to your views provides even more flexible configurations for your
    application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The `Features` folder technique is becoming a more viable option for creating
    scalable, feature-based web applications by offering vertical slicing. Vertical
    slicing is the process of writing code for an entire feature across all layers
    (presentation, domain, and data access). Feature folders simplify this process
    and convey isolated features in the application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Models folder
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Models` folder contains all of the models used for your Views. This is
    different from a ViewModel. The difference between Models and ViewModels is that
    ViewModels are passed into the View and can contain models to support the ViewModel.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a ViewModel is shown in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A ViewModel is sent to the View (`IndexViewModel`) where a Model can be data
    supporting the ViewModel (`ProductDto`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Two common practices include either creating a `ViewModels` directory under
    the `Models` folder, or a `ViewModels` directory in the root of your project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Views folder
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an MVC project, the `Views` folder is the equivalent of the `Pages` folder
    in a Razor Pages project. It contains the same folder structure as a Razor Pages
    project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Creating project layers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a new web application, the default web project contains the bare
    essentials to run in a browser. But how do you segment the application so you
    don’t have a huge pile of unmanageable code?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的Web应用程序时，默认的Web项目包含在浏览器中运行所需的最基本内容。但你是如何将应用程序分割成多个部分，以避免出现一大堆难以管理的代码呢？
- en: A layer, or tier, is a segment of the application broken up into modules or
    projects designed to perform in a certain way. A presentation layer contains the
    user interface of how the user interacts with the website, while a data access
    layer retrieves data for the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 层或层是应用程序的一部分，被分割成模块或项目，旨在以某种方式执行。表示层包含用户界面，用户如何与网站交互，而数据访问层则检索应用程序的数据。
- en: Identifying project layers can be a bit of a daunting task, but the best way
    is to create application layers based on their functionality. Each project will
    have a consistent naming convention based on its function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 识别项目层可能是一项有些令人畏惧的任务，但最好的方法是根据其功能创建应用程序层。每个项目都将根据其功能采用一致的命名约定。
- en: 'While the following are recommended project layers and names, architect and
    team suggestions may overrule these choices:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下推荐了项目层和名称，但架构师和团队的建议可能会覆盖这些选择：
- en: '`<ProjectName>.Domain` or `<ProjectName>.Core`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectName>.Domain` 或 `<ProjectName>.Core`.'
- en: '`<ProjectName>.Web` or `<ProjectName>.UI`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectName>.Web` 或 `<ProjectName>.UI`.'
- en: '`<ProjectName>.Data` or `<ProjectName>.Infrastructure`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectName>.Data` 或 `<ProjectName>.Infrastructure`.'
- en: '`/api`) or contained in a separate project called `<ProjectName>.Api`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api`) 或包含在名为 `<ProjectName>.Api` 的单独项目中。'
- en: '`Infrastructure` project, the amount of code in an infrastructure project can
    become overwhelming. A services project could provide an alternative to the `Infrastructure`
    project. Services could include a `MailService` or `<Entity>Service`. These projects
    are usually named `<ProjectName>.Services`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`基础设施` 项目，基础设施项目中的代码量可能会变得难以管理。一个服务项目可以提供对 `基础设施` 项目的替代方案。服务可能包括 `MailService`
    或 `<Entity>Service`。这些项目通常命名为 `<ProjectName>.Services`.'
- en: These code layers provide the best layout when organizing your project. Each
    project name describes the intent and gives developers a clear representation
    of the solution as a whole.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码层在组织项目时提供了最佳的布局。每个项目名称都描述了意图，并为开发者提供了一个对整个解决方案的清晰表示。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, we learned the DRY, YAGNI, and KISS principles, along with
    separation of concerns, the concept of SOLID, and how refactoring is a process
    and not a one-time quick fix.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们学习了DRY、YAGNI和KISS原则，以及关注点的分离、SOLID概念，以及重构是一个过程而不是一次性的快速修复。
- en: We proceeded to look at how two common ASP.NET web applications were structured
    and what each folder represented. Once we understood a project’s folder structure,
    we examined where code would reside based on its intent, such as Entity Framework
    or service classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探讨两个常见的ASP.NET Web应用程序的结构以及每个文件夹代表的内容。一旦我们理解了一个项目的文件夹结构，我们就根据代码的意图来检查代码将驻留的位置，例如Entity
    Framework或服务类。
- en: Thank you!
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感谢！
- en: Best practices are considered to be what is correct, common, and accepted by
    others in the field. The best practices contained in this book are a combination
    of observations, experience, and feedback over the years from my peers, mentors,
    and the developer community.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践被认为是正确的、常见的，并且被该领域的其他人所接受的。本书中包含的最佳实践是多年观察、经验和来自同行、导师以及开发社区反馈的结合。
- en: I hope these best practices serve as a reference for your ASP.NET development
    career and that you can achieve the same level of excitement as I do when I experience
    a new programming technique or technology.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些最佳实践能成为您ASP.NET开发生涯的参考，并且您能像我体验新的编程技术或技术时一样，达到同样的兴奋程度。
- en: Thank you for your readership!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您的阅读！
- en: Code on, developers... code on!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者们，继续编码吧...
