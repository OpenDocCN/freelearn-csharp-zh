<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Code Reusability in C# 8</h1>
                
            
            
                
<p>Code reusability is one of the most important topics in software architecture. This chapter aims to discuss ways to enable code reuse and understand how .NET Standard goes in this direction to solve the problem of managing and maintaining a reusable library.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">Understanding the principles of code reuse</li>
<li>The advantages of working with .NET Standard</li>
<li>Creating reusable libraries</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the following things:</p>
<ul>
<li>You need Visual Studio 2017 or the 2019 free community edition or better with all the database tools installed.</li>
<li>A free Azure account: The <em>Creating an Azure Account</em> section in <a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml"/><a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml">Chapter 1</a>, <em>Understanding the Importance of Software Architecture</em>, explains how to create one.</li>
<li>An Azure DevOps account: The <em>What is Azure DevOps?</em> section in <a href="bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml">Chapter 3</a>, <em>Documenting Requirements with Azure DevOps</em>, explains how to create one.</li>
</ul>
<p>You will find the sample code of this chapter at <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the principles of code reusability</h1>
                
            
            
                
<p>There is a single reason that you can always use to justify code reuse—you cannot spend your valuable time recreating the wheel if it is already running well in other scenarios. That is why most engineering domains are based on reusability principles. Think about the light switch you have in your house.</p>
<p>Can you imagine the number of applications that can be made with the same interface components? The fundamentals of code reuse are the same. Again, it is a matter of planning a good solution so part of it can be reused later.</p>
<p>In software engineering, code reuse is one of the techniques that can bring to software project a bunch of advantages, such as the following:</p>
<ul>
<li class="mce-root">There's confidence in the software, considering that the reused piece of code was already tested in another application</li>
<li class="mce-root">There's better usage of software architects since they can be dedicated to solving this kind of problem</li>
<li class="mce-root">There's the possibility of bringing to the project a pattern that's already accepted by the market</li>
<li class="mce-root">Development speed goes up due to the already implemented components</li>
<li>Maintenance is easier</li>
</ul>
<p>These aspects indicate that code reuse shall be done whenever it is possible. It is your responsibility, as a software architect, to ensure the preceding advantages and, more than that, to incentivize your team to enable reuse in the software they are creating.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is not code reuse?</h1>
                
            
            
                
<p>The first thing you have to understand is that code reuse does not mean copying and pasting code from one class to another. Even if this code was written by another team or project, this does not indicate you are properly working with reusability principles. Let's imagine a scenario that we will find in this book's use case, the WWTravelClub evaluation.</p>
<p class="mce-root"/>
<p>In the project scenario, you may want to evaluate different kinds of subjects, such as the Package, Destination Expert, City, Comments, and so on. The process for getting the evaluation average is the same, no matter which subject you are referring to. Due to this, you may want to <em>enable</em> reuse by copying and pasting the code for each evaluation. The (bad) result will be something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e162496d-58fb-41be-a669-778be8f1316d.png"/></p>
<p>In the preceding diagram, the process for calculating the evaluation average is decentralized, which means that the same code will be duplicated in different classes. This will cause a lot of trouble, especially if the same approach starts happening in other applications. For instance, if there is a new specification about how you have to calculate the average or if you just get a bug in the calculation formula, you will have to fix it in all instances of code. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">What is code reuse?</h1>
                
            
            
                
<p>The solution to the problem mentioned in the last section is quite simple. You have to analyze your code and select the parts of it that it would be a good idea to decouple from your application. The greatest reason why you should decouple it is related to how you are sure that this code can be reused in other parts of the application or even in another application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bb4e6ffc-dda0-4379-847f-24cbfa7ded04.png"/></p>
<p>The centralization of the code brings to you, as a software architect, a different responsibility for it. You will have to keep in mind that a bug or an incompatibility of this code can cause damage to many parts of the application or different applications. On the other hand, once you have this code tested and running, you will be able to propagate its usage with no worries. Besides, if you need to evolve the average calculation process, you will have to change the code in a single class.</p>
<p>It is worth mentioning that the more you use the same code, the cheaper this development will become. Cost needs to be mentioned because, in general, the conception of reusable software costs more in the beginning. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inserting reusability into your development cycle</h1>
                
            
            
                
<p>If you understood that reusability will take you to another level of code implementation, you should have been thinking about how to make this technique available in your development cycle. As a matter of fact, creating and maintaining a component library is not very easy, due to the responsibility you will have and the lack of good tools to support the search for existent components. </p>
<p>On the other hand, there are some things that you may consider implementing in your software development process every time you initiate a new development:</p>
<ul>
<li><strong>Use</strong> already implemented components from your user library, selecting features in the software requirements specification that need them.</li>
<li><strong>Identify </strong>features in the software requirements specification that are candidates to be designed as library components.</li>
<li><strong>Modify</strong> the specification considering that these features will be developed using reusable components.</li>
<li><strong>Design</strong> the reusable components and be sure that they have the appropriate interfaces to be used in many projects.</li>
<li><strong>Build</strong> the project architecture with the new component library version.</li>
<li><strong>Document</strong> the component library version so every developer and team knows about it.</li>
</ul>
<p>The <em>use-identify-modify-design-build</em> process is a technique that you may consider implement every time you need to enable software reuse. As soon as you have the components you need to write for this library, you will need to decide on the technology that will provide these components.</p>
<p>During the history of software development, there were many approaches for doing this; some of them are discussed in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, in the <em>Microservices as the evolution of the concept of modul</em><em>e</em> section.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using .NET Standard for code reuse</h1>
                
            
            
                
<p>.NET has evolved a lot since its first version. This evolution is not only related to the number of commands and performance issues, but the supported platforms too. As discussed in <a href="14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml">Chapter 1</a>, <em>Understanding the Importance of Software Architecture</em>, you can run C# .NET in billions of devices, even if they are running Linux, Android, macOS, or iOS. For this reason, .NET Standard was first announced together with .NET Core 1.0, but the breaking changes happened with .NET Standard 2.0, when .NET Framework 4.6, .NET Core, and Xamarin were compatible with it.</p>
<p>The key point is that .NET Standard is not only a kind of Visual Studio project. More than that, it is a formal specification available to all .NET implementations. As you can see in the following table, it covers everything from the .NET Framework to Unity (<a href="https://github.com/dotnet/standard/tree/master/docs/versions">https://github.com/dotnet/standard/tree/master/docs/versions</a>):</p>
<table style="width: 100%;border-collapse: collapse" border="1">
<thead>
<tr>
<th>.NET Standard</th>
<th>1.0</th>
<th>1.1</th>
<th>1.2</th>
<th>1.3</th>
<th>1.4</th>
<th>1.5</th>
<th>1.6</th>
<th>2.0</th>
<th>2.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>.NET Core</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
<td>2.0</td>
<td>3.0</td>
</tr>
<tr>
<td>.NET Framework</td>
<td>4.5</td>
<td>4.5</td>
<td>4.5.1</td>
<td>4.6</td>
<td>4.6.1</td>
<td>4.6.1<sup>1</sup></td>
<td>4.6.1<sup>1</sup></td>
<td>4.6.1<sup>1</sup></td>
<td>N/A<sup>2</sup></td>
</tr>
<tr>
<td>Mono</td>
<td>4.6</td>
<td>4.6</td>
<td>4.6</td>
<td>4.6</td>
<td>4.6</td>
<td>4.6</td>
<td>4.6</td>
<td>5.4</td>
<td>6.2</td>
</tr>
<tr>
<td>Xamarin.iOS</td>
<td>10.0</td>
<td>10.0</td>
<td>10.0</td>
<td>10.0</td>
<td>10.0</td>
<td>10.0</td>
<td>10.0</td>
<td>10.14</td>
<td>12.12</td>
</tr>
<tr>
<td>Xamarin.Mac</td>
<td>3.0</td>
<td>3.0</td>
<td>3.0</td>
<td>3.0</td>
<td>3.0</td>
<td>3.0</td>
<td>3.0</td>
<td>3.8</td>
<td>5.12</td>
</tr>
<tr>
<td>Xamarin.Android</td>
<td>7.0</td>
<td>7.0</td>
<td>7.0</td>
<td>7.0</td>
<td>7.0</td>
<td>7.0</td>
<td>7.0</td>
<td>8.0</td>
<td>9.3</td>
</tr>
<tr>
<td>Unity</td>
<td>2018.1</td>
<td>2018.1</td>
<td>2018.1</td>
<td>2018.1</td>
<td>2018.1</td>
<td>2018.1</td>
<td>2018.1</td>
<td>2018.1</td>
<td>TBD</td>
</tr>
<tr>
<td>Universal Windows Platform</td>
<td>8.0</td>
<td>8.0</td>
<td>8.1</td>
<td>10.0</td>
<td>10.0</td>
<td>10.0.16299</td>
<td>10.0.16299</td>
<td>10.0.16299</td>
<td>TBD</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding table indicates that if you build a class library that's compatible with this standard, you will be able to reuse it in any of the platforms presented. Think about how fast your development process can become if you plan to do so in all your projects.</p>
<p>Obviously, some components are not included in .NET Standard, but its evolution is continuous. It is worth mentioning that Microsoft's official documentation indicates that <em>the higher the version, the more APIs are available to you</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a .NET Standard library</h1>
                
            
            
                
<p>It is quite simple to create a class library compatible with .NET Standard. Basically, you need to choose the following project when creating the library:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/00882bf3-8b23-4eae-9648-94bd40168c5f.png"/></p>
<p>Once you have concluded this part, you will notice that the only difference between a common class library and the one you created is the target framework defined in the project file:</p>
<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/>  &lt;PropertyGroup&gt;<br/>    &lt;TargetFramework&gt;<strong>netstandard2.0</strong>&lt;/TargetFramework&gt;<br/>  &lt;/PropertyGroup&gt;<br/>&lt;/Project&gt;</pre>
<p class="mce-root CDPAlignLeft CDPAlign">As soon as your project is loaded, you can start coding the classes that you intend to reuse. The advantage of building reusable classes using this approach is that you will be able to reuse the written code in all of the project types we checked before. On the other hand, you will find out that some APIs that are available in .NET Framework do not exist in this type of project. You can follow the future of the standard at <a href="https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1">https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How does C# deal with code reuse?</h1>
                
            
            
                
<p>There are many approaches where C# helps us deal with code reuse. The ability to build libraries, as we checked in the last topic, is one of them. The most important one is the fact that the language is object-oriented. Besides, it is worth mentioning the facilities that generics brought to C# language. This topic will discuss the last two mentioned.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object-oriented analysis</h1>
                
            
            
                
<p>The object-oriented analysis approach gives us the ability to reuse code in different ways, from the facility of inheritance to the changeability of polymorphism. Complete adoption of object-oriented programming. will let you implement abstraction and encapsulation too.</p>
<p>The following screenshot presents using the object-oriented approach to make reuse easier. As you can see, there are different ways to calculate the grades of an evaluation, considering you can be a basic or a prime user of the system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0b8c4c20-f04e-4b81-a553-3305d15e75c4.png" style="width:35.00em;height:26.67em;"/></p>
<p>There are two aspects to be analyzed as code reuse in this design. The first is that there's no need to declare the properties in each child class since inheritance is doing it for you.</p>
<p>The second is the opportunity we have to use polymorphism, enabling different behaviors for the same method:</p>
<pre>public class PrimeUsersEvaluation : Evaluation<br/>{<br/>    /// &lt;summary&gt;<br/>    /// The business rule implemented here indicates that grades that <br/>    /// came from prime users have 20% of increase<br/>    /// &lt;/summary&gt;<br/>    /// &lt;returns&gt;the final grade from a prime user&lt;/returns&gt;<br/>    public override double CalculateGrade()<br/>    {<br/>         return Grade * 1.2;<br/>    }<br/>}</pre>
<p>You can check in the preceding code the usage of the polymorphism principle, where the calculation of evaluation for prime users will increase by 20%. Now, take a look at how easy it is to call different objects inherited by the same class. Since the collection content implements the same interface, <kbd>IContentEvaluated</kbd>, it can have basic and prime users too:</p>
<pre>public class EvaluationService<br/>{<br/>    public IContentEvaluated content { get; set; }<br/>    /// &lt;summary&gt;<br/>    /// No matter the Evaluation, the calculation will always get     <br/>    /// values from the method CalculateGrade<br/>    /// &lt;/summary&gt;<br/>    /// &lt;returns&gt;The average of the grade from Evaluations&lt;/returns&gt;<br/>    public double CalculateEvaluationAverage()<br/>    {<br/>        var count = 0;<br/>        double evaluationGrade = 0;<br/>        foreach (var evaluation in content.Evaluations)<br/>        {<br/>            evaluationGrade += evaluation.CalculateGrade();<br/>            count++;<br/>        }<br/>        return evaluationGrade/count;<br/>    }<br/>}</pre>
<p>Object-oriented adoption can be considered mandatory when using C#. However, more specific usage will need study and practice. You, as a software architect, shall always incentivize your team to study object-oriented analysis. The more they have good abstraction abilities, the easier code reuse will become.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generics</h1>
                
            
            
                
<p>Generics were introduced in C# in version 2.0, and it is definitely considered an approach that increases code reuse. It also maximizes type safety and performance. </p>
<p>The basic principle of generics is that you can define in an interface, class, method, property, event, delegate, or even a placeholder that will be replaced with a specific type at a later time when one of the preceding entities will be used. The opportunity you have with this feature is incredible since you can use the same code to run different versions of the type, generically.</p>
<p>The following code is a modification of <kbd>EvaluationService</kbd>, which was presented in the last section. The idea here is to enable the generalization of the service, giving the opportunity to define the goal of evaluation since its creation:</p>
<pre>public class EvaluationService&lt;T&gt; where T: IContentEvaluated</pre>
<p class="mce-root">This declaration indicates that any class that implements the <kbd>IContentEvaluaded</kbd> interface can be used for this service. Besides, the service will be responsible for creating the evaluated content.</p>
<p>The following code implements exactly the evaluated content created since the construction of the service. This code uses <kbd>System.Reflection</kbd> and the generic definition from the class:</p>
<pre>public EvaluationService()<br/>{<br/>    var name = GetTypeOfEvaluation();<br/>    content = (T)Assembly.GetExecutingAssembly().CreateInstance(name);<br/>}</pre>
<p class="mce-root">It is worth mentioning that this code will work because all of the classes are in the same assembly. The result of this modification can be checked in the instance creation of the service:</p>
<pre>var service = new EvaluationService&lt;CityEvaluation&gt;();</pre>
<p class="mce-root">The good news is that now you have a generic service that will automatically instantiate the list object with the evaluations of the content you need. It worth mentioning that generics obviously will need more time dedicated to the first project construction. However, after the design is done, you will have a good, fast, and easy-to-maintain code. This is what we call reuse!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case – reusing code as a fast track to deliver good and safe software</h1>
                
            
            
                
<p>The final design of the solution for evaluating content for WWTravelClub can be checked as follows. This approach consists of the usage of many topics that were discussed in this chapter. First, all of the code is placed in a .NET Standard class library. This means that you can add this code to different types of solutions, such as .NET Core web apps and Xamarin apps for the Android and iOS platforms:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/68fc31e7-4bde-409d-a30a-b6f1d2d55f2c.png"/></p>
<p>This design makes use of object-oriented principles such as inheritance, so you do not need to write properties and methods more than once that can be used in many classes; and polymorphism, so that you can change the behavior of the code without changing the name of the method.</p>
<p>To finish, the design abstracts the idea of the content by introducing generics as a tool that can facilitate the manipulation of similar classes, such as the ones we have in WWTravelClub to evaluate contents regarding cities, comments, destination experts, and travel packages.</p>
<p>The big difference between a team that incentivizes code reuse and one that does not is the velocity of delivering good software to end users. Of course, beginning this approach is not easy, but rest assured that you will get good results after some time working with it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter aimed to help you understand the advantages of code reuse. It also gave you an idea about what is not properly reused code. This chapter also presented approaches for reusing code.</p>
<p>Considering that technology without process does not take you anywhere, a process was presented to enable code reuse. This process is related to using already finished components from your library; identifying features in the software requirements specification that are candidates to be designed as library components; modifying the specification considering these features; designing the reusable components; and building the project architecture with the new component library version.</p>
<p>To finish, this chapter presented .NET Standard libraries as an approach to reuse code for different C # platforms, reinforced the principles of object-oriented programming as a way to reuse code, and presented generics as a sophisticated implementation to simplify the treatment of objects with the same characteristics. In the next chapter, we will be seeing how to apply <strong>service-oriented architecture</strong> (<strong>SOA</strong>) with .NET Core.</p>
<p>It is worth mentioning that SOA is considered a way to implement code reuse in sophisticated environments.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Can copy-and-paste be considered code reuse? What are the impacts of this approach?</li>
<li>How can you make use of code reuse without copying and pasting code?</li>
<li>Is there a process that can help code reuse?</li>
<li>What is the difference between .NET Standard and .NET Core?</li>
<li>What are the advantages of creating a .NET Standard library?</li>
<li>How does object-oriented analysis help with code reuse?</li>
<li>How do generics help with code reuse?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>These are some books and websites where you will find more information about this chapter:</p>
<ul>
<li class="CDPAlignLeft CDPAlign"><em>Clean Architecture: A Craftsman's Guide to Software Structure and Design</em> by Martin, Robert C. Pearson Education, 2018.</li>
<li class="CDPAlignLeft CDPAlign"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erica Gamma [et al.] Addison-Wesley, 1994.</li>
<li class="CDPAlignLeft CDPAlign"><em>Design Principles and Design Patterns</em> by Robert C. Martin, 2000.</li>
<li class="CDPAlignLeft CDPAlign"><a href="https://devblogs.microsoft.com/dotnet/introducing-net-standard/">https://devblogs.microsoft.com/dotnet/introducing-net-standard/</a></li>
<li class="CDPAlignLeft CDPAlign"><a href="https://www.packtpub.com/application-development/net-standard-20-cookbook">https://www.packtpub.com/application-development/net-standard-20-cookbook</a></li>
<li class="CDPAlignLeft CDPAlign"><a href="https://github.com/dotnet/standard/blob/master/docs/versions.md">https://github.com/dotnet/standard/blob/master/docs/versions.md</a></li>
<li class="CDPAlignLeft CDPAlign"><a href="https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/">https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/</a></li>
</ul>


            

            
        
    </body></html>