<html><head></head><body>
		<div id="_idContainer041">
			<h1 id="_idParaDest-73" class="chapter-number"><a id="_idTextAnchor073"/>3</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>MVVM for Maintainability and Testability</h1>
			<p>When building XAML-based applications, one of the most important design patterns to learn is the MVVM pattern. MVVM<a id="_idIndexMarker211"/> provides a clear separation of concerns between the XAML markup in the view and the C# code in the View Model using data binding. With this separation comes ease of maintenance and testability. The View Model classes can be tested without taking a dependency on the underlying <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) platform. For large teams, another benefit of this separation is that changing the XAML enables UI designers to work on the UI independently of developers who specialize in writing the business logic and the backend of <span class="No-Break">the application.</span></p>
			<p>In this chapter, you will learn about the <span class="No-Break">following concepts:</span></p>
			<ul>
				<li>Fundamentals of the MVVM <span class="No-Break">design pattern</span></li>
				<li>Popular <span class="No-Break">MVVM frameworks</span></li>
				<li>Implementing MVVM in <span class="No-Break">WinUI applications</span></li>
				<li>Handling View Model changes in <span class="No-Break">the view</span></li>
				<li>Event handling <span class="No-Break">in MVVM</span></li>
				<li>Streamline View Model implementations with the <span class="No-Break">MVVM Toolkit</span></li>
			</ul>
			<p>By the end of the chapter, you will understand the basics of the MVVM design pattern, have some familiarity with some popular MVVM frameworks available to developers, and know how to implement MVVM in a WinUI application. We will wrap up by getting hands-on with the open <a id="_idIndexMarker212"/>source <span class="No-Break"><strong class="bold">MVVM Toolkit</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, please refer to the <em class="italic">Technical requirements</em> section of <a href="B20908_02.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Configuring the Development Environment and Creating </em><span class="No-Break"><em class="italic">the Project</em></span><span class="No-Break">.</span></p>
			<p>You will find the code files of this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03</span></a></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Understanding MVVM</h1>
			<p>MVVM<a id="_idIndexMarker213"/> was introduced by Microsoft in 2005 and gained popularity with <a id="_idIndexMarker214"/>developers following the launch of <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>) and <strong class="bold">Silverlight</strong> because<a id="_idIndexMarker215"/> it lends itself so well to building applications with XAML. It is like<a id="_idIndexMarker216"/> the <strong class="bold">Presentation Model</strong> pattern, which was created by Martin Fowler – one of the most influential proponents of <span class="No-Break">design patterns.</span></p>
			<p>The MVVM pattern consists of the following <span class="No-Break">three layers:</span></p>
			<ul>
				<li><strong class="bold">Model</strong>: The <a id="_idIndexMarker217"/>Model layer contains the application’s business logic and should perform all the data access operations. The View Model communicates with the Model to retrieve and save the <span class="No-Break">application’s data.</span></li>
				<li><strong class="bold">View</strong>: The <a id="_idIndexMarker218"/>View layer is only responsible for the presentation of data in the application. The layout or structure is defined here, along with style definitions. This is the layer responsible for interacting with the user and receiving input events and data. The View is aware of the View Model only through <span class="No-Break">data-binding expressions.</span></li>
				<li><strong class="bold">ViewModel</strong>: The<a id="_idIndexMarker219"/> View Model (or ViewModel) layer is responsible for maintaining the state of data for the View. It has a set of properties that provide data to the View through data binding and a set of commands invoked by the View in response to user input events. View Model classes have no knowledge of their <span class="No-Break">corresponding Views.</span></li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>MVVM – the big picture</h2>
			<p>Let’s look at how <a id="_idIndexMarker220"/>the components of MVVM fit into the overall architecture of an application implementing the pattern, depicted in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B20908_03_01.jpg" alt="Figure 3.1 – The MVVM pattern in use"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The MVVM pattern in use</p>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, you can see a representation of the MVVM pattern along with other parts of the application: services, data, and unit tests. The arrows in the diagram represent dependencies, not the data flow. You can imagine that data would need to move both ways along most of these pathways to create a <span class="No-Break">functional application.</span></p>
			<p>As with many design patterns, the MVVM pattern is meant to be a guide for developers to create reliable, maintainable applications. However, not all developers implement the pattern in the same way. The differences usually lie in the implementation of the model. Some developers will create a domain model <a id="_idIndexMarker221"/>in the <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) style. This makes sense for large applications with complex business logic. For simpler applications, the model may only be a simple data access layer, residing either on the client or behind a service layer. In some of these cases, the <strong class="bold">Services</strong> cloud <a id="_idIndexMarker222"/>in the preceding diagram would move between the View Model and <span class="No-Break">Model layers.</span></p>
			<p>The point of <a id="_idIndexMarker223"/>MVVM is to help guide you in building the best app for your users. As you gain experience with MVVM and WinUI, you will find the right implementation for your applications. A good way to get started is to find some frameworks that make it easier to work <span class="No-Break">with MVVM.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>MVVM libraries for WinUI</h1>
			<p>When working with MVVM in WinUI <a id="_idIndexMarker224"/>applications, you must create a little infrastructure code to facilitate data binding between Views and View Models. You can either write this yourself or choose a framework that abstracts this plumbing code away from your application. Although we will start by writing our own plumbing code for the application in the next section, let’s review some popular MVVM frameworks <span class="No-Break">for WinUI.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>The MVVM Toolkit</h2>
			<p>We<a id="_idIndexMarker225"/> will <a id="_idIndexMarker226"/>discuss the <strong class="bold">Windows Community Toolkit</strong> (<strong class="bold">WCT</strong>) and <strong class="bold">.NET Community Toolkit</strong> in <a id="_idIndexMarker227"/>more detail<a id="_idIndexMarker228"/> in <a href="B20908_09.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Enhancing Applications with the Windows Community Toolkit</em>, but one of the libraries included in this open source toolkit is the <strong class="bold">MVVM Toolkit</strong>. The toolkit supports any .NET application platform, including UWP, WinUI 3, .NET MAUI, Uno Platform, WPF, and others. You can<a id="_idIndexMarker229"/> get the <strong class="source-inline">CommunityToolkit.Mvvm</strong> <strong class="bold">NuGet package</strong> through the <strong class="bold">NuGet Package Manager</strong> in <a id="_idIndexMarker230"/>Visual Studio or view its details on the NuGet website, <span class="No-Break">at </span><a href="https://www.nuget.org/packages/CommunityToolkit.Mvvm/"><span class="No-Break">https://www.nuget.org/packages/CommunityToolkit.Mvvm/</span></a><span class="No-Break">.</span></p>
			<p>The library includes base classes to support <strong class="source-inline">INotifyPropertyChanged</strong>, <strong class="source-inline">IMessenger</strong>, and <strong class="source-inline">ICommand</strong>. It<a id="_idIndexMarker231"/> also includes other messaging and <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) helper classes. In addition, the latest versions of the MVVM Toolkit <a id="_idIndexMarker232"/>use <strong class="bold">Roslyn source generators</strong> to reduce the amount of boilerplate code developers need <span class="No-Break">to write.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are unfamiliar with Roslyn, it is the code name<a id="_idIndexMarker233"/> of the <strong class="bold">.NET Compiler Platform</strong>. It was first <strong class="bold">released to manufacturing</strong> (<strong class="bold">RTM</strong>) with Visual Studio 2015, and it is the current compiler for the C# and VB.NET languages. Roslyn’s extensibility, via the .NET Compiler Platform SDK, allows developers to create things such as custom source generators and source code analyzers for Visual Studio. For more information about the platform, you can check out the documentation on Microsoft <span class="No-Break">Learn: </span><a href="https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/"><span class="No-Break">https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/</span></a><span class="No-Break">.</span></p>
			<p>Later in the chapter, after you have learned how to implement your own MVVM base class, we will leverage the MVVM Toolkit in our <span class="No-Break">sample application.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>The Prism Library</h2>
			<p><strong class="bold">Prism</strong> started <a id="_idIndexMarker234"/>out as a<a id="_idIndexMarker235"/> library created and maintained by Microsoft. It was part of the <strong class="bold">Patterns &amp; Practices</strong> guidance, reference <a id="_idIndexMarker236"/>architectures, and libraries that Microsoft’s developer division used <span class="No-Break">to maintain.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The remaining <a id="_idIndexMarker237"/><em class="italic">Patterns &amp; Practices</em> projects still maintained by Microsoft are available on GitHub <span class="No-Break">here: </span><a href="https://github.com/mspnp"><span class="No-Break">https://github.com/mspnp</span></a><span class="No-Break">.</span></p>
			<p>Microsoft decided to open source the Prism Library and transferred ownership to the community. The project is<a id="_idIndexMarker238"/> hosted on GitHub and can be found on the web at <a href="https://prismlibrary.com/">https://prismlibrary.com/</a>. Prism has packages available for WPF, Xamarin, UWP, and <span class="No-Break">WinUI projects.</span></p>
			<p>Prism is much more than an MVVM framework. It also includes <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) that <a id="_idIndexMarker239"/>help developers<a id="_idIndexMarker240"/> implement <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>), commands, and <strong class="source-inline">EventAggregator</strong> for loosely coupled application messaging. Prism can be added to a project through NuGet. There is also an installer available on the Prism site to add a Visual Studio project and <span class="No-Break">item templates.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>MVVMCross</h2>
			<p><strong class="bold">MVVMCross</strong> is an <a id="_idIndexMarker241"/>MVVM framework that was first created <a id="_idIndexMarker242"/>for Xamarin developers. It now has NuGet packages available for Xamarin, .NET MAUI, WPF, UWP, and WinUI. As with Prism, MVVMCross does much more than facilitate data binding in WinUI applications. It has helpers for <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Data binding</span></li>
				<li><span class="No-Break">Navigation</span></li>
				<li>Logging <span class="No-Break">and tracing</span></li>
				<li>DI <span class="No-Break">and IoC</span></li>
				<li><span class="No-Break">Unit testing</span></li>
			</ul>
			<p>There are some additional libraries, but most are specific to .NET MAUI applications. The MVVMCross package can also be added to your project via NuGet. For more information about MVVMCross <a id="_idIndexMarker243"/>use with WinUI, check out their <span class="No-Break">site: </span><a href="https://www.mvvmcross.com/"><span class="No-Break">https://www.mvvmcross.com/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Choosing a framework for WinUI applications</h2>
			<p>Using a third-party framework <a id="_idIndexMarker244"/>for building production XAML applications is a great choice. These provide built-in support for things such as logging and DI. For the WinUI application in this book, we will use the MVVM Toolkit for data binding at the end of this chapter. However, first, we will implement the MVVM pattern from scratch. This will help you understand the underlying mechanisms of data binding, DI, and other core concepts relating <span class="No-Break">to MVVM.</span></p>
			<p>Before jumping into the code, you should have some background on exactly how data binding works <span class="No-Break">in WinUI.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Understanding data binding in WinUI</h1>
			<p>In the previous chapter, you saw some simple examples of <a id="_idIndexMarker245"/>data binding, using both the <strong class="source-inline">Binding</strong> and <strong class="source-inline">x:Bind</strong> markup extensions. Let’s dissect some of the components that allow the View to receive updates when the View Model <span class="No-Break">data changes.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>What are markup extensions?</h2>
			<p>An in-depth discussion of<a id="_idIndexMarker246"/> markup extensions is beyond the scope of this introductory book. In brief, they are a class that executes some logic to return a value to the XAML parser. You can identify their use in XAML by looking for some markup inside curly braces. Take this example of <strong class="source-inline">Binding</strong> in the <strong class="source-inline">Text</strong> property of <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">TextBlock</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;TextBlock Text="{Binding Path=Name, Mode=TwoWay}"/&gt;</pre>			<p>From this, you can derive that there is a markup extension class named <strong class="source-inline">Binding</strong> and that two of its properties are <strong class="source-inline">Path</strong> and <strong class="source-inline">Mode</strong>. This markup extension takes these properties, resolves a value, and returns it to the XAML parser for display in the <span class="No-Break">application’s View.</span></p>
			<p>Some XAML markup languages allow developers to write their own custom markup extensions. WPF and .NET MAUI have custom markup extensions, but WinUI does not. If you’re curious about the implementation of a markup extension, Microsoft Learn has documentation on how to create one for .NET <span class="No-Break">MAUI: </span><a href="https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create</span></a><span class="No-Break">.</span></p>
			<p>Now, let’s learn more about the <strong class="source-inline">Binding</strong> markup extension <span class="No-Break">in WinUI.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Binding markup extension</h2>
			<p>As you briefly<a id="_idIndexMarker247"/> saw, the <strong class="source-inline">Binding</strong> markup extension maps <a id="_idIndexMarker248"/>data from the binding source, the View Model in MVVM, and provides it to a binding target in the View. These are all the properties of the <strong class="source-inline">Binding</strong> <span class="No-Break">markup extension:</span></p>
			<ul>
				<li><strong class="source-inline">Path</strong>: The path to the value in the data-binding source. For our application, this will be the property name on the <span class="No-Break">View Model.</span></li>
				<li><strong class="source-inline">Converter</strong>: If the data type of the source property does not match the data type of the control’s property in the View, a <strong class="source-inline">Converter</strong> property is used to define the mapping between the two <span class="No-Break">data types.</span></li>
				<li><strong class="source-inline">ConverterLanguage</strong>: If a <strong class="source-inline">Converter</strong> property is specified, a <strong class="source-inline">ConverterLanguage</strong> property can optionally be set to <span class="No-Break">support internationalization.</span></li>
				<li><strong class="source-inline">ConverterParameter</strong>: If a <strong class="source-inline">Converter</strong> property takes a parameter, use the <strong class="source-inline">ConverterParameter</strong> property to provide it. It’s not common to use <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Converter</strong></span><strong class="source-inline"> Parameter</strong> property, and it is typically a <strong class="source-inline">string</strong> value. If you need to provide multiple values to a <strong class="source-inline">Converter</strong>, you can concatenate them and then parse them inside <span class="No-Break">the method.</span></li>
				<li><strong class="source-inline">ElementName</strong>: This parameter is used when binding to an attribute of another element in <span class="No-Break">the View.</span></li>
				<li><strong class="source-inline">FallBackValue</strong>: If the data binding fails for any reason, you can specify a <strong class="source-inline">FallBackValue</strong> property to display in <span class="No-Break">the View.</span></li>
				<li><strong class="source-inline">Mode</strong>: This defines whether the data binding is <strong class="source-inline">OneTime</strong> (sets the value only when the XAML is first parsed), <strong class="source-inline">OneWay</strong> (fetches the value from the View Model when changes are detected), or <strong class="source-inline">TwoWay</strong> (the value flows both ways between the View and View Model). The default <strong class="source-inline">Mode</strong> setting for <strong class="source-inline">Binding</strong> varies depending on the control and property being bound. It is important to check the documentation if you are unsure of the <span class="No-Break">default </span><span class="No-Break"><strong class="source-inline">Mode</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">RelativeSource</strong>: This is used to define a data-binding source that is relative to the current control. This is usually used with control templates that get their data through a <span class="No-Break">parent element.</span></li>
				<li><strong class="source-inline">Source</strong>: Specifies <a id="_idIndexMarker249"/>the data-binding source. This is<a id="_idIndexMarker250"/> usually defined at a top-level control level in WinUI as the View Model. However, it is possible for child controls to set a different <strong class="source-inline">Source</strong>, overriding the <strong class="source-inline">Source</strong> inherited from their ancestor. The <strong class="source-inline">Source</strong> value defined at any level in the View will be inherited by all child elements unless a new <strong class="source-inline">Source</strong> <span class="No-Break">is set.</span></li>
				<li><strong class="source-inline">TargetNullValue</strong>: Specifies a default value to display if the data-binding source is resolved but has a <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> value.</span></li>
				<li><strong class="source-inline">UpdateSourceTrigger</strong>: Specifies the frequency with which to update <strong class="source-inline">TwoWay</strong> binding sources. The options are <strong class="source-inline">PropertyChanged</strong>, <strong class="source-inline">Explicit</strong>, and <strong class="source-inline">LostFocus</strong>. The default frequency for most properties <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">PropertyChanged</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p><strong class="source-inline">Path</strong> is the default property and is assumed when no property name is given for a parameter. For example, the earlier <strong class="source-inline">TextBlock</strong> example could also be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;TextBlock Text="{Binding Name, Mode=TwoWay}"/&gt;</pre>			<p>Here, <strong class="source-inline">Name</strong> is assumed to be the value provided for the <strong class="source-inline">Path</strong> parameter. Providing two parameters without specifying parameter names will result in a XAML <span class="No-Break">parser error.</span></p>
			<p>The <strong class="source-inline">Binding</strong> markup <a id="_idIndexMarker251"/>extension is found in every XAML<a id="_idIndexMarker252"/> language. The other option for data binding, <strong class="source-inline">x:Bind</strong>, is not. It is only an option with UWP <span class="No-Break">and WinUI.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>x:Bind markup extension</h2>
			<p><strong class="source-inline">x:Bind</strong> is an alternative <a id="_idIndexMarker253"/>markup extension for WinUI. It is faster and uses less <a id="_idIndexMarker254"/>memory than <strong class="source-inline">Binding</strong> and has better debugging support. It achieves this performance gain by generating code at compile time to be used during binding at runtime. By contrast, the <strong class="source-inline">Binding</strong> markup extension is executed by the XAML parser at runtime, which incurs additional overhead. Compile-time bindings also result in incorrect data binding expressions being caught when compiling, rather than generating data binding failures <span class="No-Break">at runtime.</span></p>
			<p>Another important distinction between <strong class="source-inline">Binding</strong> and <strong class="source-inline">x:Bind</strong> is that <strong class="source-inline">Binding</strong> requires <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Data</strong></span><strong class="source-inline"> Context</strong> to be set. Data is bound to properties of objects within the <strong class="source-inline">DataContext</strong>. When using <strong class="source-inline">x:Bind</strong>, you are binding directly to properties on the current <strong class="source-inline">Window</strong> or <strong class="source-inline">UserControl</strong>. You can also bind events directly to event handlers in the code-behind for the Window <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">x:Bind</strong></span><span class="No-Break">.</span></p>
			<p>While most of the properties of <strong class="source-inline">x:Bind</strong> are the same as those in <strong class="source-inline">Binding</strong>, let’s highlight those that differ, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">ElementName</strong>: Not available in <strong class="source-inline">x:Bind</strong>. You must use <strong class="source-inline">Binding</strong> to data-bind to other XAML element attributes. If your application must bind to other elements, <strong class="source-inline">x:Bind</strong> and <strong class="source-inline">Binding</strong> can be used in the <span class="No-Break">same View.</span></li>
				<li><strong class="source-inline">Mode</strong>: The only difference here is that the default <strong class="source-inline">Mode</strong> for <strong class="source-inline">x:Bind</strong> is usually <strong class="source-inline">OneTime</strong>, <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">OneWay</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">RelativeSource</strong>: Not available <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">x:Bind</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Source</strong>: Not available in <strong class="source-inline">x:Bind</strong>. Instead, you will typically define a <strong class="source-inline">ViewModel</strong> property in the code-behind file of each View with a data type of the corresponding View Model class. You could also create a domain-specific name for the property, such as <strong class="source-inline">MediaItems</strong> for <span class="No-Break">our application.</span></li>
				<li><strong class="source-inline">BindBack</strong>: This property is unique to <strong class="source-inline">x:Bind</strong>. It allows a custom function to be called in <strong class="source-inline">TwoWay</strong> binding when reverse data binding is invoked. This is not commonly used, and we <a id="_idIndexMarker255"/>will not use it in <span class="No-Break">our application.</span></li>
			</ul>
			<p><strong class="source-inline">x:Bind</strong> is a<a id="_idIndexMarker256"/> powerful and complex markup extension. For more information about it, you can read this page on Microsoft <span class="No-Break">Learn: </span><a href="https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension"><span class="No-Break">https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension</span></a><span class="No-Break">.</span></p>
			<p>Next, let’s discuss <strong class="source-inline">INotifyPropertyChanged</strong>, the interface that enables changes in data-bound properties in the ViewModel to be reflected in <span class="No-Break">the view.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Updating View data with INotifyPropertyChanged</h2>
			<p>So, how does the<a id="_idIndexMarker257"/> View get notified when data <a id="_idIndexMarker258"/>changes in the ViewModel? That magic lies within the <strong class="source-inline">Microsoft.UI.Xaml.Data.INotifyPropertyChanged</strong> interface. This interface consists of a single member, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public interface INotifyPropertyChanged
{
    event PropertyChangedEventHandler PropertyChanged;
}</pre>			<p>Every ViewModel class must implement this interface and raise the <strong class="source-inline">PropertyChanged</strong> event to update the View. Indicate which property is changed by passing its name in the <strong class="source-inline">PropertyChangedEventArgs</strong> parameter. To refresh all properties, pass <strong class="source-inline">null</strong> or <strong class="source-inline">string.Empty</strong> as the property name, but be aware of the potential <a id="_idIndexMarker259"/>performance implications this<a id="_idIndexMarker260"/> can have on <span class="No-Break">large views.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Updating collection data with INotifyCollectionChanged</h2>
			<p><strong class="source-inline">INotifyPropertyChanged</strong> works<a id="_idIndexMarker261"/> great for <a id="_idIndexMarker262"/>most properties, but it will not update the View if items from a collection have been added or removed. This is where the <strong class="source-inline">Microsoft.UI.Xaml.Interop.INotifyCollectionChanged</strong> interface is used. Again, this interface only has a single member, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public interface INotifyCollectionChanged
{
    event NotifyCollectionChangedEventHandler
      CollectionChanged;
}</pre>			<p>None of the collections or collection interfaces commonly used in .NET (<strong class="source-inline">List&lt;T&gt;</strong>, <strong class="source-inline">IEnumerable&lt;T&gt;</strong>, and so on) implement this interface. You can create your own collection derived from an existing list type and implement <strong class="source-inline">INotifiedCollectionChanged</strong> yourself, but it’s much easier to use the <strong class="source-inline">ObservableCollection&lt;T&gt;</strong> list type that is already available to WinUI developers. This is a collection that will update the View when items are added or removed, or when the contents are <span class="No-Break">completely refreshed.</span></p>
			<p>The <strong class="source-inline">Items</strong> property of an <strong class="source-inline">ObservableCollection&lt;T&gt;</strong> is read-only, thus it cannot be directly set. You can add items by passing a <strong class="source-inline">List&lt;T&gt;</strong> or <strong class="source-inline">IEnumerable&lt;T&gt;</strong> to the constructor when creating <strong class="source-inline">ObservableCollection&lt;T&gt;</strong> or by using its <strong class="source-inline">Add</strong> or <strong class="source-inline">Insert</strong> methods (there is no <strong class="source-inline">AddRange</strong> method to add multiple items). You can update individual values in the collection by assigning a new item to the current index. You can remove<a id="_idIndexMarker263"/> items with <a id="_idIndexMarker264"/>the <strong class="source-inline">Remove</strong>, <strong class="source-inline">RemoveAt</strong>, <strong class="source-inline">ClearItems</strong>, or <span class="No-Break"><strong class="source-inline">Clear</strong></span><span class="No-Break"> methods.</span></p>
			<p>In the next section, when we implement the MVVM pattern for ourselves, you will see these concepts <span class="No-Break">in practice.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Implementing MVVM in WinUI applications</h1>
			<p>It’s time <a id="_idIndexMarker265"/>to start converting <a id="_idIndexMarker266"/>our project to use MVVM. To gain a thorough understanding of the MVVM pattern, we will start by building our own MVVM infrastructure. For simple applications, it doesn’t require more than a single <span class="No-Break">base class:</span></p>
			<ol>
				<li>Start by adding a <strong class="bold">ViewModels</strong> folder to the project. If you are using the code from GitHub, you can either continue with your project from the previous chapter or use the <strong class="bold">Start</strong> project in the folder for <span class="No-Break">this chapter.</span></li>
				<li>Next, add a new class to the <strong class="bold">ViewModels</strong> folder and name it <strong class="source-inline">BindableBase</strong>. This will be the base class for all our View Model classes in the project. It will be responsible for notifying the corresponding views of any property changes. This is accomplished by implementing the <strong class="source-inline">INotifyPropertyChanged</strong> interface. Let’s review the <strong class="source-inline">BindableBase</strong> class code, <span class="No-Break">as follows:</span><pre class="source-code">
public class BindableBase : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler
      PropertyChanged;
    protected void OnPropertyChanged(
      [CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new Property
          ChangedEventArgs(propertyName));
    }
    protected bool SetProperty&lt;T&gt;(ref T originalValue,
      T newValue, [CallerMemberName] string
        propertyName = null)
    {
        if (Equals(originalValue, newValue))
        {
            return false;
        }
        originalValue = newValue;
        OnPropertyChanged(propertyName);
        return true;
    }
}</pre></li>			</ol>
			<p>By using this<a id="_idIndexMarker267"/> as the base<a id="_idIndexMarker268"/> class of our View Models, they will have two new methods available to use, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">OnPropertyChanged</strong>: Use this to trigger a <strong class="source-inline">PropertyChanged</strong> event to notify the View of changes in <span class="No-Break">the data</span></li>
				<li><strong class="source-inline">SetProperty</strong>: This method is used to set the value of a property if the value has been changed and will then <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">OnPropertyChanged</strong></span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Be sure you have these two using directives at the top of the <strong class="source-inline">BindableBase</strong> <span class="No-Break">class file:</span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">using System.ComponentModel;</strong></span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">using System.Runtime.CompilerServices;</strong></span></p>
			<p>Now that we have a base <a id="_idIndexMarker269"/>class, let’s<a id="_idIndexMarker270"/> add our first View Model to the project. Right-click the <strong class="bold">ViewModels</strong> folder and add a new class named <strong class="source-inline">MainViewModel</strong>. This View Model is going to replace most of the code in the <strong class="bold">MainWindow.xaml.cs</strong> code-behind file for our <strong class="source-inline">MainWindow</strong>. The following code is part of the revised class. Please refer to <strong class="source-inline">MainViewModel.txt</strong> in the GitHub repository for the chapter (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels</a>) for the current version of the <span class="No-Break">complete class:</span></p>
			<pre class="source-code">
public class MainViewModel : BindableBase
{
    private string selectedMedium;
    private ObservableCollection&lt;MediaItem&gt; items;
    private ObservableCollection&lt;MediaItem&gt; allItems;
    private IList&lt;string&gt; mediums;
    public MainViewModel()
    {
        PopulateData();
    }
    ...
    public IList&lt;string&gt; Mediums
    {
        get
        {
            return mediums;
        }
        set
        {
            SetProperty(ref mediums, value);
        }
    }
    ...
}</pre>			<p>You may have <a id="_idIndexMarker271"/>noticed that <a id="_idIndexMarker272"/>the code has been updated, using the new <strong class="source-inline">BindableBase.SetProperty</strong> method inside each property’s <strong class="source-inline">Set</strong> block. This ensures that the UI will be notified when the property value has <span class="No-Break">been changed:</span></p>
			<ol>
				<li>Now, we’ll need to make the <strong class="source-inline">MainViewModel</strong> class available to the <strong class="source-inline">MainWindow</strong> view. Because there will be a single instance of this View Model used throughout the lifetime of the app, we will add a static read-only property to the <strong class="source-inline">App.xaml.cs</strong> file to make it available to the application, <span class="No-Break">as follows:</span><pre class="source-code">
public static MainViewModel ViewModel { get; } = new
MainViewModel();</pre></li>				<li>We can now strip out all the code from <strong class="bold">MainWindow.xaml.cs</strong> that we copied to the <strong class="source-inline">MainViewModel</strong> class. In addition, add a property to make <strong class="source-inline">App.ViewModel</strong> available to <strong class="source-inline">MainWindow</strong> for data binding, <span class="No-Break">as follows:</span><pre class="source-code">
public sealed partial class MainWindow : Window
{
    public MainWindow()
    {
        this.InitializeComponent();
        Loaded += MainPage_Loaded;
    }
    public MainViewModel ViewModel =&gt; App.ViewModel;
    private async void AddButton_Click(object sender,
      Microsoft.UI.Xaml.RoutedEventArgs e)
    {
        var dialog = new MessageDialog("Adding items
          to the collection is not yet available.",
            "My Media Collection");
        await dialog.ShowAsync();
    }
}</pre><p class="list-inset">The only <a id="_idIndexMarker273"/>other code we <a id="_idIndexMarker274"/>need to keep in the code-behind file right now is for the <strong class="bold">Add</strong> button, which we will update in the <span class="No-Break">next section.</span></p><p class="list-inset">Finally, it’s time to update the <strong class="bold">MainWindow.xaml</strong> file to bind to the data of the <strong class="source-inline">MainViewModel</strong>. There are only two changes required to handle the new data source, <span class="No-Break">detailed next.</span></p></li>				<li>First, update <strong class="source-inline">ComboBox</strong> to remove the <strong class="source-inline">x:Name</strong> property and add <strong class="source-inline">x:Bind</strong> data binding for the <strong class="source-inline">ItemsSource</strong> and <strong class="source-inline">SelectedItem</strong> properties. The <strong class="source-inline">SelectedItem</strong> binding needs to be set to <strong class="source-inline">TwoWay</strong>. This will ensure that the data in <strong class="source-inline">MainViewModel</strong> is updated when the user changes <strong class="source-inline">SelectedMedium</strong> in the UI. The code can be seen in the <span class="No-Break">following snippet:</span><pre class="source-code">
&lt;ComboBox <strong class="bold">ItemsSource="{x:Bind ViewModel.Mediums}"</strong>
<strong class="bold">  SelectedItem="{x:Bind ViewModel.SelectedMedium,</strong>
<strong class="bold">    Mode=TwoWay}"</strong> HorizontalAlignment="Right"
      MinWidth="120" Margin="0,2,6,4"/&gt;</pre></li>				<li>Now, update <strong class="source-inline">ListView</strong> to remove the <strong class="source-inline">x:Name</strong> property and add an <strong class="source-inline">ItemsSource</strong> <strong class="source-inline">x:Bind</strong> data binding, <span class="No-Break">as follows:</span><pre class="source-code">
&lt;ListView Grid.Row="1" <strong class="bold">ItemsSource="{x:Bind</strong>
<strong class="bold">  ViewModel.Items}"</strong>&gt;</pre><p class="list-inset">The assigned <a id="_idIndexMarker275"/>names for <a id="_idIndexMarker276"/>these controls are no longer needed because we are not referencing them anywhere in <span class="No-Break">the code.</span></p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Assigning names to XAML elements allocates additional resources. It is recommended to only name elements when the elements must be referenced directly from code-behind files or by other View elements’ data binding <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">ElementName</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Now, run the application and try changing the <strong class="source-inline">Medium</strong> filter with the <strong class="source-inline">ComboBox</strong>. It should behave exactly as it did before, but now we have decoupled the View <a id="_idIndexMarker277"/>Model data from the UI, making it easier to test or <a id="_idIndexMarker278"/><span class="No-Break">potentially reuse.</span></li>
			</ol>
			<p>Next, we will address the button <strong class="source-inline">Click</strong> event that we still have in the <span class="No-Break"><strong class="bold">MainWindow.xaml.cs</strong></span><span class="No-Break"> file.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Working with events and commands</h1>
			<p>It’s time to<a id="_idIndexMarker279"/> update the<a id="_idIndexMarker280"/> project to move the event handling code to <strong class="source-inline">MainViewModel</strong>. By the end of this section, you will have removed all the code that was added to the <strong class="bold">MainWindow.xaml.cs</strong> file, except for the <strong class="source-inline">ViewModel</strong> property. This will be great for the separation of concerns, as well as for the maintainability and testability of <span class="No-Break">the project.</span></p>
			<p>We could use the same process of wiring up events with the <strong class="bold">Add</strong> button’s <strong class="source-inline">Click</strong> event and connect it to a method on the <strong class="source-inline">MainViewModel</strong> class. There are two problems with <span class="No-Break">this approach:</span></p>
			<ul>
				<li>The View and View Model layers become more tightly coupled, <span class="No-Break">reducing maintainability</span></li>
				<li>UI concerns are injected into the view model, reducing the testability of <span class="No-Break">the class</span></li>
			</ul>
			<p>Let’s take <a id="_idIndexMarker281"/>another route. The MVVM pattern has the concept of <strong class="bold">Commands</strong> to handle<a id="_idIndexMarker282"/> events. Instead of adding a handler to the event of our view element, we will bind that event to a property on the view model. The <strong class="source-inline">Command</strong> properties all expect a type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">System.Windows.Input.ICommand</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>Implementing ICommand</h2>
			<p>To use commands in the project, we’ll <a id="_idIndexMarker283"/>start by creating an implementation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ICommand</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another advantage of using an MVVM framework such as Prism or the MVVM Toolkit is that they provide implementations <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ICommand</strong></span><span class="No-Break">.</span></p>
			<p>Add a new class to the <strong class="source-inline">ViewModel</strong> folder in the project and name it <strong class="source-inline">RelayCommand</strong>. This class will implement the <strong class="source-inline">ICommand</strong> interface. The <strong class="source-inline">RelayCommand</strong> class will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public class RelayCommand : ICommand
{
    private readonly Action action;
    private readonly Func&lt;bool&gt; canExecute;
    public RelayCommand(Action action)
        : this(action, null)
    {
    }
    public RelayCommand(Action action, Func&lt;bool&gt;
      canExecute)
    {
        if (action == null)
            throw new ArgumentNullException
              (nameof(action));
        this.action = action;
        this.canExecute = canExecute;
    }
    public bool CanExecute(object parameter) =&gt; canExecute
      == null || canExecute();
    public void Execute(object parameter) =&gt; action();
    public event EventHandler CanExecuteChanged;
    public void RaiseCanExecuteChanged() =&gt;
      CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}</pre>			<p><strong class="source-inline">RelayCommand</strong> has two<a id="_idIndexMarker284"/> constructors that both take an <strong class="source-inline">Action</strong> that will be invoked when the command is executed. One of the constructors also takes a <strong class="source-inline">Func&lt;bool&gt;</strong>. This will allow us to enable or disable UI actions based on the return value of <strong class="source-inline">CanExecute</strong>. We will use this to enable a <strong class="bold">Delete</strong> button only when a media item is selected in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">ListView</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Using commands in the View Model</h2>
			<p>Now, it’s time to update <strong class="source-inline">MainViewModel</strong> to handle commands from the <strong class="bold">Add</strong> and <strong class="bold">Delete</strong> buttons. In the<a id="_idIndexMarker285"/> next <a id="_idIndexMarker286"/>chapter, we will enhance the add operation so it can add or edit items. So, let’s name the command and <span class="No-Break">method accordingly:</span></p>
			<ol>
				<li>First, add <a id="_idIndexMarker287"/>two new<a id="_idIndexMarker288"/> private variables to the <span class="No-Break"><strong class="source-inline">MainViewModel</strong></span><span class="No-Break"> class:</span><pre class="source-code">
private MediaItem selectedMediaItem;
private int additionalItemCount = 1;</pre><p class="list-inset">The <strong class="source-inline">additionalItemCount</strong> variable is a temporary variable that we will use to track how many new items we have added to the list. The counter will help to generate unique IDs and names for each new media item. <strong class="source-inline">selectedMediaItem</strong> is a backing variable for the new <span class="No-Break"><strong class="source-inline">SelectedMediaItem</strong></span><span class="No-Break"> property.</span></p></li>				<li>Add the <strong class="source-inline">SelectedMediaItem</strong> <span class="No-Break">property next:</span><pre class="source-code">
public MediaItem SelectedMediaItem
{
    get =&gt; selectedMediaItem;
    set
    {
        SetProperty(ref selectedMediaItem, value);
        ((RelayCommand)DeleteCommand)
          .RaiseCanExecuteChanged();
    }
}</pre><p class="list-inset">In addition to calling <strong class="source-inline">SetProperty</strong> to notify the UI that <strong class="source-inline">SelectedMediaItem</strong> has changed, we also need to call <strong class="source-inline">RaiseCanExecuteChanged</strong> on a <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">DeleteCommand</strong></span><span class="No-Break">.</span></p></li>				<li>Next, let’s<a id="_idIndexMarker289"/> add <strong class="source-inline">DeleteCommand</strong> and <strong class="source-inline">AddEditCommand</strong> along <a id="_idIndexMarker290"/>with their <span class="No-Break">corresponding actions:</span><pre class="source-code">
public ICommand AddEditCommand { get; set; }
public void AddOrEditItem()
{
    // Note this is temporary until
    // we use a real data source for items.
    const int startingItemCount = 3;
    var newItem = new MediaItem
    {
        Id = startingItemCount + additionalItemCount,
        Location = LocationType.InCollection,
        MediaType = ItemType.Music,
        MediumInfo = new Medium { Id = 1, MediaType =
          ItemType.Music, Name = "CD" },
        Name = $"CD {additionalItemCount}"
    };
    allItems.Add(newItem);
    Items.Add(newItem);
    additionalItemCount++;
}
public ICommand DeleteCommand { get; set; }
private void DeleteItem()
{
    allItems.Remove(SelectedMediaItem);
    Items.Remove(SelectedMediaItem);
}
private bool CanDeleteItem() =&gt; selectedMediaItem !=
  null;</pre><p class="list-inset">There is an <strong class="source-inline">ICommand</strong> property for each UI operation (<strong class="source-inline">AddEditCommand</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Delete</strong></span><strong class="source-inline"> Command</strong>) and new methods for each command to execute (<strong class="source-inline">AddOrEditItem</strong> and <strong class="source-inline">DeleteItem</strong>). There is also a <strong class="source-inline">CanDeleteItem</strong> method that returns a <strong class="source-inline">bool</strong> value to indicate whether a media item has been selected by <span class="No-Break">the user.</span></p></li>				<li>At the <a id="_idIndexMarker291"/>end of the <strong class="source-inline">MainViewModel</strong> constructor, add <a id="_idIndexMarker292"/>two lines of code to initialize the commands, connecting them to the <span class="No-Break">corresponding methods:</span><pre class="source-code">
DeleteCommand = new RelayCommand(DeleteItem,
  CanDeleteItem);
// No CanExecute param is needed for this command
// because you can always add or edit items.
AddEditCommand = new RelayCommand(AddOrEditItem);</pre></li>			</ol>
			<p>The preceding code is part of the revised <strong class="source-inline">MainViewModel</strong> class. Please refer to <strong class="source-inline">MainViewModel2.txt</strong> in the GitHub repository for the chapter (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter03/Complete/MyMediaCollection/ViewModels</a>) for the current version of the <span class="No-Break">complete class.</span></p>
			<p>Our View Model has<a id="_idIndexMarker293"/> been updated to use commands. Next, we <a id="_idIndexMarker294"/>will update the view to bind <span class="No-Break">to them.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Updating the View</h2>
			<p>Our view model is<a id="_idIndexMarker295"/> ready to go. It’s now safe to remove all the event handling code from the <strong class="source-inline">MainWindow</strong> code. It should look like this when <span class="No-Break">you’re finished:</span></p>
			<pre class="source-code">
public sealed partial class MainWindow : Window
{
    public MainWindow()
    {
        this.InitializeComponent();
    }
    public MainViewModel ViewModel =&gt; App.ViewModel;
}</pre>			<p>The <strong class="bold">MainWindow.xaml</strong> file will need a few updates to get the <strong class="bold">Add Item</strong> and <strong class="bold">Delete Item</strong> buttons fully functional with the temporary test data. Perform the following steps to <span class="No-Break">accomplish this:</span></p>
			<ol>
				<li>Update the <strong class="source-inline">ListView</strong> to bind the <strong class="source-inline">SelectedItem</strong> property to <strong class="source-inline">SelectedMediaItem</strong> in the <span class="No-Break">view model:</span><pre class="source-code">
&lt;ListView Grid.Row="1" ItemsSource="{x:Bind
  ViewModel.Items}" <strong class="bold">SelectedItem="{x:Bind</strong>
<strong class="bold">    ViewModel.SelectedMediaItem, Mode=TwoWay}"</strong>&gt;</pre><p class="list-inset"><strong class="source-inline">TwoWay</strong> data binding is required to allow the UI to update the <span class="No-Break">view model.</span></p></li>				<li>Next, move the <strong class="bold">Add Item</strong> button inside the first column of a new two-column <strong class="source-inline">Grid</strong>. Then, create a <strong class="bold">Delete Item</strong> button in the second column. Remove the <strong class="source-inline">Click</strong> event handler and set the properties of the grid and two buttons to match the <span class="No-Break">following snippet:</span><pre class="source-code">
&lt;StackPanel Grid.Row="2"
            HorizontalAlignment="Right"
            Orientation="Horizontal"&gt;
    &lt;Button Command="{x:Bind
      ViewModel.AddEditCommand}"
            Content="Add Item"
            Margin="8,8,0,8"/&gt;
    &lt;Button Command="{x:Bind ViewModel.DeleteCommand}"
            Content="Delete Item"
            Margin="8"/&gt;
&lt;/StackPanel&gt;</pre><p class="list-inset">Each button’s <strong class="source-inline">Command</strong> property will be bound to the new <strong class="source-inline">ICommand</strong> properties in the view model. The <strong class="source-inline">Command</strong> property of a button is invoked when it’s clicked by <span class="No-Break">the user.</span></p></li>				<li>We’re now done<a id="_idIndexMarker296"/> updating the project to use MVVM. Run the application to see how <span class="No-Break">it works.</span></li>
				<li>When it first loads, the <strong class="bold">Delete Item</strong> button will be disabled. Select an item in the list and notice that the button is automatically enabled. If you click <strong class="bold">Delete Item</strong>, the selected item is removed from the list and the button is <span class="No-Break">disabled again.</span></li>
				<li>Finally, click <strong class="bold">Add Item</strong> a few times to see how new items are created and added to the list. Each new item has a unique name using the counter we created in the view model, as illustrated in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B20908_03_02.jpg" alt="Figure 3.2 – My Media Collection after adding and removing a few items"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – My Media Collection after adding and removing a few items</p>
			<p><strong class="source-inline">MainWindow</strong> now has a<a id="_idIndexMarker297"/> view model that is completely decoupled from any UI concerns. This will allow you to maximize the unit test coverage on <span class="No-Break">the project.</span></p>
			<p>Before we wrap up, let’s see how we can reduce the amount of code in our project by using an MVVM framework such as the <span class="No-Break">MVVM Toolkit.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Leveraging the MVVM Toolkit</h1>
			<p>We briefly introduced the MVVM<a id="_idIndexMarker298"/> Toolkit earlier in the chapter. In this section, we will update the <strong class="source-inline">MainViewModel</strong> to see how we can remove the need for a <strong class="source-inline">BindableBase</strong> class and reduce the amount of code in the view <span class="No-Break">model itself:</span></p>
			<ol>
				<li>Start by right-clicking on the solution file in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Manage NuGet Packages </strong><span class="No-Break"><strong class="bold">for Solution</strong></span><span class="No-Break">.</span></li>
				<li>In the NuGet window, select the <strong class="bold">Browse</strong> tab and search <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">CommunityToolkit.Mvvm</strong></span><span class="No-Break">.</span></li>
				<li>Select the <strong class="bold">CommunityToolkit.Mvvm</strong> package in the results and install the latest stable version (8.2.0 <span class="No-Break">or later).</span></li>
				<li>Close the NuGet window and open the <strong class="source-inline">MainViewModel</strong> class. The first thing we need to do to use the MVVM Toolkit’s source generators is update <strong class="source-inline">MainViewModel</strong> to be a partial class and have it inherit from <strong class="source-inline">CommunityToolkit.Mvvm.ComponentModel.ObservableObject</strong> instead of our <a id="_idIndexMarker299"/>own <span class="No-Break"><strong class="source-inline">BindableBase</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public partial class MainViewModel : ObservableObject</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn more about how the MVVM Toolkit uses <strong class="bold">.NET source generators</strong> to generate public properties and commands, check <a id="_idIndexMarker300"/>out the documentation on Microsoft Learn: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/overview</a>. If you are unfamiliar with .NET source generators, you can also read about them on Microsoft Learn in the .NET <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview"><span class="No-Break">https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Next, each simple property that only calls <strong class="source-inline">SetProperty</strong> in its setter will be removed, and the backing variable will be updated to have an <strong class="source-inline">ObservableProperty</strong> attribute. Remove the <strong class="source-inline">Mediums</strong> and <strong class="source-inline">Items</strong> properties and the private <strong class="source-inline">mediums</strong> and <strong class="source-inline">items</strong> fields should now look <span class="No-Break">like this:</span><pre class="source-code">
[ObservableProperty]
private IList&lt;string&gt; mediums;
[ObservableProperty]
private ObservableCollection&lt;MediaItem&gt; items;</pre><p class="list-inset">We have two public properties remaining in the class. Let’s start with <strong class="source-inline">SelectedMedium</strong>. We will remove <strong class="source-inline">SelectedMediaItem</strong> after updating <span class="No-Break">the commands.</span></p></li>				<li>The setter for <strong class="source-inline">SelectedMedium</strong> has some custom logic after the call to <strong class="source-inline">SetProperty</strong>. Create a new partial method named <strong class="source-inline">OnSelectedMediumChanged</strong> to<a id="_idIndexMarker301"/> contain <span class="No-Break">that code:</span><pre class="source-code">
partial void OnSelectedMediumChanged(string value)
{
    Items.Clear();
    foreach (var item in allItems)
    {
        if (string.IsNullOrWhiteSpace(value) ||
            value == "All" ||
            value == item.MediaType.ToString())
        {
            Items.Add(item);
        }
    }
}</pre><p class="list-inset">Notice that we also updated the uses of <strong class="source-inline">selectedMedium</strong> to <strong class="source-inline">value</strong>. The <strong class="source-inline">value</strong> parameter contains the new <strong class="source-inline">selectedMedium</strong> value. You may have also noticed some green squiggles in Visual Studio inside the <strong class="source-inline">PopulateData</strong> method, indicating that you should be using the generated properties instead of using the private <strong class="source-inline">ObservableProperty</strong> members directly. You can update all of these uses by capitalizing the first letter of <span class="No-Break">each variable.</span></p></li>				<li>Next, we will update the two commands. Add the <strong class="source-inline">RelayCommand</strong> attribute to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">AddOr</strong></span><strong class="source-inline"> EditItem</strong> and <strong class="source-inline">DeleteItem</strong> methods and rename them to <strong class="source-inline">AddEdit</strong> and <strong class="source-inline">Delete</strong> to ensure that the generated commands have the same names that our old <span class="No-Break">commands had.</span></li>
				<li>Remove the<a id="_idIndexMarker302"/> two commands and the code to initialize them in the <strong class="source-inline">MainViewModel</strong> constructor. The code for the constructor and the signatures for the two command methods should now look <span class="No-Break">like this:</span><pre class="source-code">
public MainViewModel()
{
    PopulateData();
}
[RelayCommand]
public void AddEdit()
{
...
}
[RelayCommand(CanExecute = nameof(CanDeleteItem))]
public void Delete()
{
...
}
private bool CanDeleteItem() =&gt; SelectedMediaItem !=
  null;</pre><p class="list-inset">The attribute for <strong class="source-inline">DeleteItem</strong> also indicates that <strong class="source-inline">CanDeleteItem</strong> should be used for checking whether the command can <span class="No-Break">be invoked.</span></p></li>				<li>Finally, let’s replace the <strong class="source-inline">SelectedMediaItem</strong> property with a source-generated property from the MVVM Toolkit. The existing public property tells the <strong class="source-inline">DeleteCommand</strong> that <strong class="source-inline">CanExecute</strong> should be checked. Remove that property and update the private <strong class="source-inline">selectedMediaItem</strong> variable to add <span class="No-Break">two attributes:</span><pre class="source-code">
[ObservableProperty]
[NotifyCanExecuteChangedFor(nameof(DeleteCommand))]
private MediaItem selectedMediaItem;</pre><p class="list-inset">In addition to<a id="_idIndexMarker303"/> the <strong class="source-inline">ObservableProperty</strong> attribute, we’ve added <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">NotifyCan</strong></span><strong class="source-inline"> ExecuteChangedFor</strong> attribute, providing the name of the <strong class="source-inline">DeleteCommand</strong> generated <strong class="source-inline">ICommand</strong> property. The generated property, which is invisible to us, would be equivalent <span class="No-Break">to this:</span></p><pre class="source-code">public MediaItem SelectedMediaItem
{
    get =&gt; selectedMediaItem;
    set
    {
        if (SetProperty(ref selectedMediaItem, value))
        {
            DeleteCommand.NotifyCanExecuteChanged();
        }
    }
}</pre></li>			</ol>
			<p>That’s all you need to do. There are no changes needed in the view, and the application works exactly as it did before. All we’ve done is remove quite a bit of code <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">MainViewModel</strong></span><span class="No-Break">.</span></p>
			<p>We will continue to use the MVVM Toolkit throughout the remaining chapters. Now, let’s review what we’ve learned in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Summary</h1>
			<p>We’ve made quite a bit of progress with the application in this chapter. While it’s not yet connected to a live data source, we have methods in place to add and remove items from the media collection in memory. In addition, the project has been refactored to use the <strong class="bold">MVVM</strong> pattern, moving all the existing view logic from the <strong class="source-inline">MainWindow</strong> code-behind file to a new <strong class="source-inline">MainViewModel</strong> class. The new <strong class="source-inline">MainViewModel</strong> class has no dependencies on the UI. Finally, we saw how integrating the MVVM Toolkit into the project can reduce the boilerplate code in our view models. These good software design habits will serve us well in the chapters ahead as we build more functionality onto <span class="No-Break">the project.</span></p>
			<p>In the next chapter, we will continue learning how to use the MVVM pattern to write robust, maintainable WinUI applications. We will cover some more advanced MVVM topics and learn some techniques for window management in a <span class="No-Break">WinUI project.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Questions</h1>
			<ol>
				<li>What does MVVM <span class="No-Break">stand for?</span></li>
				<li>Which layer typically defines the business entities in the <span class="No-Break">MVVM pattern?</span></li>
				<li>Name one of the popular MVVM frameworks discussed in <span class="No-Break">the chapter.</span></li>
				<li>Which interface must every View Model class implement in an <span class="No-Break">MVVM application?</span></li>
				<li>Which special collection type in .NET notifies the UI of changes to the collection, via <span class="No-Break">data binding?</span></li>
				<li>Which control property of <strong class="source-inline">ComboBox</strong> and <strong class="source-inline">ListView</strong> is used to get or set the currently selected item in <span class="No-Break">the control?</span></li>
				<li>Which interface is implemented to create commands for <span class="No-Break">event binding?</span></li>
			</ol>
		</div>
	</body></html>