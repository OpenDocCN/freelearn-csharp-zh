<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor148"/>9</h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/>Handling User Input and Validation</h1>
<p>User input forms the core of any interactive application. The way we manage this input, validate it, and respond to it directly influences the user experience of our application. While backend validation of user input is indispensable to maintaining data integrity, providing immediate and useful feedback on the frontend is equally important for a good user experience. In this chapter, we’re going to dig into the crucial topic of managing user input and validation within a .NET MAUI application utilizing the MVVM design pattern.</p>
<p>This chapter is organized into the following sections:</p>
<ul>
<li>Implementing input validation on ViewModels</li>
<li>Visualizing validation errors with triggers</li>
<li>Prompts and alerts</li>
<li>Confirming or canceling navigation</li>
</ul>
<p>With the aim of making our application more dynamic and interactive, this chapter will focus on handling user input effectively – ensuring a smooth and seamless user experience. Let’s dive in!</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor150"/>Technical requirements</h1>
<p>In this chapter, we’ll further enrich the <em class="italic">Recipes!</em> app with more features. To stay in sync, all the resources and code snippets are available on GitHub: <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09</a>. If you’re looking to actively code alongside the chapter, it’s best to kick off from the <code>Start</code> folder. The finalized version can be found in the <code>Finish</code> folder.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Implementing input validation on ViewModels</h1>
<p>Input validation can be implemented in various ways and at different points within the life cycle of user interaction. It could happen as soon as a user changes a property, providing immediate feedback on the validity of the data entered. On the other hand, it might be performed only when <a id="_idIndexMarker596"/>the user initiates a certain action, such as clicking a button, thereby offering a more cumulative validation experience. Deciding on when and how to implement validation often depends on the specific requirements of your project. It’s a balance between the need for immediate feedback and maintaining a smooth, uninterrupted user flow. There’s no one-size-fits-all solution, and the strategy can vary based on the complexity of the data, the form of user interaction, and the overall design of your application.</p>
<p>Implementing validation on the frontend offers several advantages: it provides users with immediate feedback, ensuring a more responsive and intuitive experience. Moreover, by catching and rectifying issues right at the source, we can reduce the risk of sending incorrect data to the backend. However, it's essential to note that frontend validation should complement, not replace, backend validation. The ViewModel is the ideal location for frontend validation as it serves as our first line of defense against potential data inconsistencies or errors before they reach backend systems.</p>
<p>In this section, we’ll be focusing on the implementation of input validation in ViewModels. We’ll specifically delve into the use of the <code>ObservableValidator</code>, a powerful tool that’s part of the MVVM Community Toolkit. This feature makes handling validation responses and displaying meaningful feedback to the user a breeze. Let’s move on to explore the <code>ObservableValidator</code> in detail, and how it can enhance our approach to input validation.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/>Using the ObservableValidator</h2>
<p>Validating user input is a<a id="_idIndexMarker597"/> cornerstone of robust applications. While it’s entirely possible to write our own validation logic – checking properties as they update or when commands are invoked and then populating validation properties that can be bound to the UI – it often involves reinventing common <a id="_idIndexMarker598"/>patterns. Instead of starting from scratch, why not leverage existing tools designed for this exact purpose? One of the best practices for user input validation in the MVVM pattern is the use of the <code>ObservableValidator</code>. This class, a part of the MVVM Community Toolkit, inherits from the <code>ObservableObject</code> class and implements the <code>System.ComponentModel.INotifyDataErrorInfo</code> interface. This interface, which isn’t specific to .NET MAUI, provides a robust system for reporting and managing errors in objects. It includes an <code>ErrorsChanged</code> event that you can subscribe to in order to be notified of changes in validation status and a <code>GetErrors</code> method that<a id="_idIndexMarker599"/> retrieves validation errors for a specified property or the entire object.</p>
<p>When a property value is updated, the <code>ObservableValidator</code> has the ability to automatically validate it using its <code>SetProperty</code> method overloads. It also offers <code>TrySetProperty</code> overloads that update a property value only when validation is successful and can return any<a id="_idIndexMarker600"/> generated errors. For scenarios that require manual control over validation, the <code>ObservableValidator</code> provides <code>ValidateProperty</code> and <code>ValidateAllProperties</code> methods, which can be used to manually trigger validation for specific properties or all properties, respectively. Additionally, it offers a <code>ClearAllErrors</code> method, ideal for resetting a form for reuse.</p>
<p>The flexibility of <code>ObservableValidator</code> extends to compatibility with the wide range of validation attributes provided by the <code>System.ComponentModel.DataAnnotations</code> namespace. This means you can leverage a set of common validation rules that are essential in many scenarios, such as <code>[Required]</code>, <code>[StringLength]</code>, <code>[Range]</code>, <code>[Compare]</code>, <code>[RegularExpression]</code>, and many more. These attributes allow for an expressive way to define validation rules directly on your ViewModel’s properties, leading to a highly readable and maintainable code base. The <code>ObservableValidator</code> will pick up these attributes when validating a property, making the validation process seamless and straightforward. You can also define your own specific validation rules by encapsulating complex validation logic into dedicated validation methods or even in custom <code>ValidationAttribute</code> classes, which can be reused across your application.</p>
<p>Let’s go ahead and see how we can add validation to <code>AddRatingViewModel</code> using the <code>ObservableValidator</code>.</p>
<h3>Pre-configured validation rules</h3>
<p>As previously mentioned, the <code>ObservableValidator</code> class leverages the power of the validation attributes found within the <code>System.ComponentModel.DataAnnotations</code> namespace. These attributes can be easily applied to your properties and<a id="_idIndexMarker601"/> the <code>ObservableValidator</code> class will use them for validating the corresponding property values. This relationship between the <code>ObservableValidator</code> and the <code>DataAnnotations</code> namespace offers an array of pre-configured validation rules, simplifying the process of implementing input validation in your ViewModel. Let’s start by marking some properties as required:</p>
<ol>
<li>Head over to <code>AddRatingViewModel</code> and instead of inheriting the <code>ObservableObject</code> class, make it inherit the <code>ObservableValidator</code> class, as shown here:<pre class="source-code">
public class AddRatingViewModel : <code>Required</code> attribute to the <code>EmailAddress</code>, <code>DisplayName</code>, and <code>RatingInput</code> properties:<pre class="source-code">
<strong class="bold">[Required]</strong>
public string EmailAddress { … }
<strong class="bold">[Required]</strong>
public string DisplayName { ... }
<strong class="bold">[Required]</strong>
public string RatingInput { ... }</pre></li> <li>The <code>AddRatingViewModel</code> class contains a <code>SubmitCommand</code>, which calls the <code>OnSubmit</code> method. Let’s update this method so it validates all the properties and writes the validation messages to the debug window:<pre class="source-code">
private Task OnSubmit()
{
    <strong class="bold">ValidateAllProperties();</strong>
    if(<strong class="bold">HasErrors</strong>)
    {
        var errors = <strong class="bold">GetErrors();</strong>
        Debug.WriteLine( string.Join("\n",
            errors.Select(e =&gt; e.ErrorMessage)));
    }
    else
    {
        Debug.WriteLine("All OK");
    }
    return Task.CompletedTask;
}</pre><p class="list-inset">With the <code>ValidateAllProperties</code> method, all properties of the current class are validated. After calling this method, we can check the <code>HasErrors</code> property to see if there <a id="_idIndexMarker602"/>are any violations. If so, the <code>GetErrors</code> method allows us to retrieve a list of <code>ValidationResult</code> objects. A <code>ValidationResult</code> object contains a list of member names affected by this result and an <code>ErrorMessage</code>.</p></li> </ol>
<p>Go ahead and debug the app! If you go to the <code>AddRatingPage</code>, leave everything empty and click the <strong class="bold">Submit</strong> button. You’ll see the error messages printed in the <strong class="bold">Output</strong> window in Visual Studio.</p>
<p class="callout-heading">Validating and errors</p>
<p class="callout">The <code>ValidateAllProperties</code> method validates all <a id="_idIndexMarker603"/>properties in the ViewModel. The <code>ValidateProperty</code> method, which accepts a value and property name<a id="_idIndexMarker604"/> will check whether the given value is valid for the given property. This is an easy way to validate a single property. The <code>HasErrors</code> property will be set according to the properties that have been validated. The same thing goes for the <code>GetErrors</code> method: it returns <code>ValidationResult</code> objects for the properties that have been validated. This method also has an overload where you can pass in a property name to get back the errors for that specific property. The <code>GetErrors</code> method <a id="_idIndexMarker605"/>won’t do any validation by itself, trying to get the errors of a property that hasn’t been validated will yield no results. The <code>ClearErrors</code> method <a id="_idIndexMarker606"/>allows for removing all errors or only those of a particular property when a property name is provided.</p>
<p>Let’s enhance our validation by <a id="_idIndexMarker607"/>adding more validation rules and disabling the <strong class="bold">Submit</strong> button until all input is valid.</p>
<p>On the <code>EmailAddress</code> property, we should add an additional validation attribute. We can use the <code>RegularExpressionAttribute</code> to check whether a value matches a given regex expression:</p>
<ol>
<li>The following snippet shows how we can add an extra validation attribute to the <code>EmailAddress</code> property using the <code>RegularExpressionAttribute</code> to ensure the value matches a specified regex pattern. This pattern will be used to validate whether the given value is an email address:<pre class="source-code">
public const string EmailValidationRegex =
 "^[aA-zZ0-9]+@[aA-zZ]+\.[aA-zZ]{2, 3}$";
...
[Required]
<strong class="bold">[RegularExpression(EmailValidationRegex)]</strong>
public string EmailAddress { ... }</pre></li> <li>To ensure the <code>DisplayName</code> property has a minimum and maximum length, we can use the <code>MinLength</code> and <code>MaxLength</code> attributes. Let’s add them:<pre class="source-code">
<strong class="bold">public const int DisplayNameMinLength = 5;</strong>
<strong class="bold">public const int DisplayNameMaxLength = 25;</strong>
...
[Required]
<strong class="bold">[MinLength(DisplayNameMinLength)]</strong>
<strong class="bold">[MaxLength(DisplayNameMaxLength)]</strong>
public string DisplayName { ... }</pre></li> <li>To constrain the <code>RatingInput</code> property to a value between 0 and 4 with zero or one decimal point, we<a id="_idIndexMarker608"/> can use the <code>RangeAttribute</code> for the range constraint and <code>RegularExpressionAttribute</code> for the decimal limit:<pre class="source-code">
<strong class="bold">public const string RangeDecimalRegex = @"^\d+(\.\d{1,1})?$";</strong>
<strong class="bold">public const double RatingMinVal = 0d;</strong>
<strong class="bold">public const double RatingMaxVal = 4d;</strong>
...
[Required]
<strong class="bold">[RegularExpression(RangeDecimalRegex)]</strong>
<strong class="bold">[Range(RatingMinVal, RatingMaxVal)]</strong>
public string RatingInput { ... }</pre></li> <li>And finally, we want to validate each property when its value gets updated. The <code>ObservableValidator</code> class has an overloaded <code>SetProperty</code> method, which accepts a <code>bool</code> value indicating whether the provided value needs to be validated. This is how it looks for the <code>EmailAddress</code> property:<pre class="source-code">
SetProperty(ref _emailAddress, value, <code>DisplayName</code>, <code>RatingInput</code>, and <code>Review</code> properties on this ViewModel as well, to use this overloaded <code>SetProperty</code> method, passing in <code>true</code> in order to trigger validation when the value is set. If we were to<a id="_idIndexMarker609"/> pass in <code>false</code> as the last parameter, the validation would not be triggered.</p></li> </ol>
<p class="callout-heading">SetProperty and TrySetProperty</p>
<p class="callout">Note that this overloaded <code>SetProperty</code> will set the <a id="_idIndexMarker610"/>value of the backing field and trigger the <code>PropertyChanged</code> event, no matter whether the provided value is valid or not. There <a id="_idIndexMarker611"/>is also a <code>TrySetProperty</code> on the <code>ObservableValidator</code> class, which will not set the value on the property when it is invalid. It returns a <code>bool</code> value indicating whether the value was set or not and has an <code>out</code> parameter, which returns a collection of errors.</p>
<ol>
<li value="5">The <code>AddRatingViewModel</code> class contains a command <code>SubmitCommand</code>. This command should only be executable when the provided values of the properties are considered valid. For that, we can point the <code>canExecute</code> function of the <code>SubmitCommand</code> to the <code>HasErrors</code> property, as shown here:<pre class="source-code">
SubmitCommand =
    new AsyncRelayCommand(OnSubmit, <code>NotifyCanExecuteChanged</code> method of the <code>SubmitCommand</code>, so the <code>canExecute</code> function can be re-evaluated. The <code>ObservableValidator</code> class exposes an event called <code>ErrorsChanged</code>, which gets triggered whenever there is a change in validation errors. That’s the ideal moment to call the <code>NotifyCanExecuteChanged</code> method of the <code>SubmitCommand</code>. Let’s subscribe to this event and implement this:<pre class="source-code">
public AddRatingViewModel(
    INavigationService navigationService)
{
    ...
    <strong class="bold">ErrorsChanged += AddRatingViewModel_ErrorsChanged;</strong>
}
private void AddRatingViewModel_ErrorsChanged(
    object? sender, DataErrorsChangedEventArgs e)
{
    <strong class="bold">SubmitCommand.NotifyCanExecuteChanged();</strong>
}</pre></li> </ol>
<p>Now, if you run the app and<a id="_idIndexMarker612"/> navigate to <code>AddRatingPage</code>, you’ll find the <code>CanExecute</code> method of <code>SubmitCommand</code> being based on the absence of validation errors. <em class="italic">Figure 9</em><em class="italic">.1</em> shows what this looks like:</p>
<div><div><img alt="Figure 9.1: Enabled Submit button when there are no errors (right)" height="799" src="img/B20941_09_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Enabled Submit button when there are no errors (right)</p>
<p>The pre-configured validation attributes we’ve discussed so far can simplify the process of adding validation to your ViewModels. However, there will be scenarios where these built-in rules don’t meet your specific requirements, and you’ll need to create your own custom validation logic. Let’s<a id="_idIndexMarker613"/> explore how to implement that next.</p>
<h3>Creating custom validation rules</h3>
<p>Often, the pre-configured validation <a id="_idIndexMarker614"/>rules just won’t cut it and you’ll need to add your own custom validation logic. When working with the <code>ObservableValidator</code> class, there<a id="_idIndexMarker615"/> are two options for implementing custom validation rules:</p>
<ul>
<li>The first approach involves creating a completely new validation attribute by extending the base <code>ValidationAttribute</code> class. This allows you to encapsulate your own validation logic in a reusable component, keeping your ViewModel cleaner and more focused on its primary responsibility. You can then apply this custom attribute to any property in the same way you’d apply the built-in attributes.</li>
<li>The second option involves using the <code>CustomValidation</code> attribute, which enables you to specify a static method to handle the validation right at the point of declaration. This method allows for more localized, context-specific validation scenarios where creating a separate attribute class might be overkill.</li>
</ul>
<p>Let’s examine both methods in more detail to see how they can be used to address custom validation requirements.</p>
<h4>Create a custom attribute</h4>
<p>Let’s add a validation rule that we<a id="_idIndexMarker616"/> want to use on the <code>Review</code> property. Although a review is optional, if provided, it must fall within a certain length range. Since such a rule could potentially be reused across different scenarios, it makes sense to put this validation logic in a custom attribute. Here’s how we can go about it:</p>
<ol>
<li>Right-click the <code>Recipes.Client.Core</code> project in the <code>Validation</code> as the name of the new folder.</li>
<li>Right-click th<a id="_idTextAnchor153"/>e <code>Validation</code> folder, select <code>EmptyOrWithinRangeAttribute</code> as the class name.</li>
<li>Make this class inherit the <code>ValidationAttribute</code> class like this:<pre class="source-code">
public class EmptyOrWithinRangeAttribute : ValidationAttribute</pre></li> <li>Next, add two <a id="_idIndexMarker617"/>properties, <code>MinLength</code> and <code>MaxLength</code>, of type <code>int</code>:<pre class="source-code">
public int MinLength { get; set; }
public int MaxLength { get; set; }</pre><p class="list-inset">These properties allow an even wider usage of this attribute. They allow developers to customize the length constraints each time they apply this attribute to a property. This way, the exact minimum and maximum lengths required for validation can be tailored to fit each individual property’s needs as the developer can declare the desired minimum and maximum length.</p></li> <li>The next step is to override the <code>IsValid</code> method. This method gets invoked when the validation process begins for the property where the attribute is applied. Let’s see how we can implement it:<pre class="source-code">
protected override ValidationResult IsValid(object? value, ValidationContext validationContext)
{
    if (value is string valueAsString &amp;&amp; (
        string.IsNullOrEmpty(valueAsString) ||
        (valueAsString.Length &gt;= MinLength
        &amp;&amp; valueAsString.Length &lt;= MaxLength)))
    {
        return ValidationResult.Success;
    }
    else
    {
        return new ValidationResult($"The value should be between {MinLength} and {MaxLength} characters long, or empty.");
    }
}</pre><p class="list-inset">The value parameter, of type <code>object</code>, represents the property value that needs to be validated. The <a id="_idIndexMarker618"/>second parameter, of type <code>ValidationContext</code>, provides further context, including the instance of the object being validated and the property. Returning <code>ValidationResult.Success</code> indicates that the given value is valid, else we return a descriptive error message.</p></li> <li>Finally, we can use this attribute on the <code>Review</code> property of the <code>AddRatingViewModel</code> like this:<pre class="source-code">
<strong class="bold">[EmptyOrWithinRange(MinLength = 10, MaxLength = 250)]</strong>
public string Review
{
    get =&gt; _review;
    set =&gt; SetProperty(ref _review, value, true);
}</pre></li> </ol>
<p>With our custom validation attribute in place, the <code>Review</code> property can be validated so that it is empty or falls within<a id="_idIndexMarker619"/> the given length range. This attribute can easily be reused across the entire app.</p>
<h4>Using the CustomValidation attribute</h4>
<p>The <code>ValidationResult</code> object and take a parameter matching the type of the property being validated, along with a <code>ValidationContext</code> object. This is similar to the <code>IsValid</code> method we override when implementing our own <code>ValidationAttribute</code>. Let’s add an additional validation to the <code>Review</code> property so that it is required when the given rating is less than or equal to 2:</p>
<ol>
<li>In the <code>AddRatingViewModel</code>, add a new static method called <code>ValidateReview</code> with the following implementation:<pre class="source-code">
public static ValidationResult ValidateReview(string review, ValidationContext context)
{
    AddRatingViewModel instance =
        (AddRatingViewModel)context.ObjectInstance;
    if (double.TryParse(instance.RatingInput,
        out var rating))
    {
        if (rating &lt;= 2 &amp;&amp;
            string.IsNullOrEmpty(review))
        {
            return new("A review is mandatory when rating the recipe 2 or less.");
        }
    }
    return ValidationResult.Success;
}</pre><p class="list-inset">This method accepts a parameter of type <code>string</code>, matching the type of the property we want to validate. The second parameter is of type <code>ValidationContext</code>, which we can use to access the instance of the object the property is defined on. This allows us to access other properties on the object that is being validated, such as the <code>RatingInput</code> property in our case. When we can parse the <code>RatingInput</code> value to <code>double</code>, we can check whether it is less<a id="_idIndexMarker622"/> than or equal to 2. If that is the case and the given review value is empty, we return a validation error. Otherwise, <code>Success</code> is returned.</p></li> <li>Now, we need to add a <code>CustomValidation</code> attribute to the <code>Review</code> property and point this to the static <code>ValidateReview</code> method that we just created. Let’s see how that’s done:<pre class="source-code">
<strong class="bold">[CustomValidation(</strong>
<strong class="bold">    typeof(AddRatingViewModel),</strong>
<strong class="bold">    nameof(ValidateReview))]</strong>
[EmptyOrWithinRange(MinLength = 2, MaxLength = 250)]
public string Review
{
    get =&gt; _review;
    set =&gt; SetProperty(ref _review, value, true);
}</pre><p class="list-inset">The first parameter the <code>CustomValidation</code> attribute requires is the type the static validation method is defined on. In our case, we defined it on <code>AddRatingViewModel</code> itself, so we pass that in as the type. This means it is possible to define your validation methods elsewhere, bundling them in separate classes, for example. The second parameter is the name of the validation method. We use the <code>nameof</code> keyword to avoid magic strings and add compile-time error checking.</p></li> <li>As the validation of the <code>Review</code> property is also dependent on the entered <code>RatingInput</code> property, we must make sure the <code>Review</code> property is also validated when the <code>RatingInput</code> property changes. As the following snippet shows, we can easily do this by <a id="_idIndexMarker623"/>calling the <code>ValidateProperty</code> method for the <code>Review</code> property when the value on the <code>RatingInput</code> property is updated:<pre class="source-code">
[Required]
[RegularExpression(RangeDecimalRegex)]
[Range(RatingMinVal, RatingMaxVal)]
public string RatingInput
{
    get =&gt; _ratingInput;
    set
    {
        SetProperty(ref _ratingInput, value, true);
        <strong class="bold">ValidateProperty(Review, nameof(Review));</strong>
    }
}</pre></li> </ol>
<p>That’s it! That is all that’s needed to add custom validation, leveraging the <code>CustomValidation</code> attribute. This approach typically is for validation checking that is to be reused on different objects less. In this particular case, we access the <code>ValidationContext</code> <code>ObjectInstance</code> and cast it to a certain type, which naturally makes it unusable on different types.</p>
<p>Run your application and notice how the <strong class="bold">Submit</strong> button gets disabled when a rating of less than 3 is given and the review is left empty. Our validation logic is operating as expected! However, the current implementation lacks user-friendliness because it does not provide any feedback regarding<a id="_idIndexMarker624"/> invalid entries. Let’s see how to display these validation errors to the user.</p>
<h3>Showing errors onscreen</h3>
<p>There are basically two<a id="_idIndexMarker625"/> approaches to show validation errors to the user. The first method usually provides an overview of all issues at once, typically at the top or bottom of a form. The second approach gives feedback right on the input field where the error <a id="_idIndexMarker626"/>occurred. This can often help users to correct the error more directly and quickly. Both methods have their uses and are often combined in applications for the best user ex<a id="_idTextAnchor154"/><a id="_idTextAnchor155"/>perience.</p>
<h4>Showing all errors</h4>
<p>While <code>ObservableValidator</code> doesn’t provide a <a id="_idIndexMarker627"/>property that lists all validation errors directly, it does offer a <code>GetErrors</code> method to fetch them. Sadly, data binding to methods isn’t possible. To align better with MVVM practices and facilitate data binding, it would be beneficial to introduce an <code>Errors</code> property of type <code>ObservableCollection&lt;ValidationResult&gt;</code>. This way, we can bind to our validation errors in the UI.</p>
<p>Let’s see how we can achieve this:</p>
<ol>
<li>Add a property called <code>Errors</code> of type <code>ObservableCollection&lt;ValidationResult&gt;</code> to <code>AddRatingViewModel</code>:<pre class="source-code">
public ObservableCollection&lt;ValidationResult&gt; Errors { get; } = new();</pre></li> <li>The <code>AddRatingViewModel_ErrorsChanged</code> method on <code>AddRatingViewModel</code> is invoked when the <code>ErrorsChanged</code> event of <code>ObservableValidator</code> is triggered. Currently, this calls the <code>NotifyCanExecuteChanged</code> method on the <code>SubmitCommand</code>, but let’s update it so that it also (re-)populates the <code>Errors</code> collection that we just defined. The following code block shows how we can do this:<pre class="source-code">
private void AddRatingViewModel_ErrorsChanged(object? sender, DataErrorsChangedEventArgs e)
{
    <strong class="bold">Errors.Clear();</strong>
<strong class="bold">    GetErrors().ToList().ForEach(Errors.Add);</strong>
    SubmitCommand.NotifyCanExecuteChanged();
}</pre><p class="list-inset">The preceding code first clears the <code>Errors</code> collection. Next, it calls the <code>GetErrors</code> method of <code>ObservableValidator</code> to get all the errors. With the <code>ForEach</code> method, we can loop over all the items and call the <code>Errors.Add</code> method<a id="_idIndexMarker628"/> to add the current item to the <code>Errors</code> collection.</p></li> <li>The preceding code should add all the current validation errors to the <code>Errors</code> property. The only thing that is left to do is to bind this collection to our view, as shown here:<pre class="source-code">
&lt;VerticalStackLayout BindableLayout.ItemsSource="{Binding Errors}"&gt;
    &lt;BindableLayout.ItemTemplate&gt;
        &lt;DataTemplate x:DataType="annotations:ValidationResult"&gt;
            &lt;Label Text="{Binding ErrorMessage}"
                FontSize="12" TextColor="Red"/&gt;
        &lt;/DataTemplate&gt;
    &lt;/BindableLayout.ItemTemplate&gt;
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">At this point, you should find the XAML code familiar and straightforward: the <code>Errors</code> collection is bound to the <code>BindableLayout</code> <code>ItemsSource</code> property on a <code>VerticalStackLayout</code>. The <code>ItemTemplate</code> stipulates that for each item we want to render a <code>Label</code> that shows its <code>ErrorMessage</code> property. The <code>DataType</code> of the <code>DataTemplate</code> is a <code>ValidationResult</code>. The <code>annotations</code> XML namespace<a id="_idIndexMarker629"/> is defined at the top of the page: <strong class="source-inline"/>.</p></li> </ol>
<p>The preceding code will result in showing a list of all the validation errors onscreen. Run the application and you should see the validation errors appearing and disappearing as you enter values, as <em class="italic">Figure </em><em class="italic">9</em><em class="italic">.2</em> demonstrates.</p>
<div><div><img alt="Figure 9.2: Showing up-to-date validation errors" height="906" src="img/B20941_09_02.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Showi<a id="_idTextAnchor156"/>ng up-to-date validation errors</p>
<p>Although this already should improve the user experience a lot, we can take this a step further. Let’s enhance the UX by showing error messages inline, directly adjacent to the relevant inpu<a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>t fields.</p>
<h4>Showing inline errors</h4>
<p>The main challenge when it comes to <a id="_idIndexMarker630"/>displaying individual errors is developing a mechanism that enables us to retrieve and display validation errors related to a single property, rather than all validation errors at once. There is a very simple approach to this: for each property, expose an additional property containing a collection of errors for that property. Take a look at the following exampl<a id="_idTextAnchor159"/>e:</p>
<pre class="source-code">
public List&lt;ValidationResult&gt; EmailValidationErrors
{
    get =&gt; GetErrors(nameof(EmailAddress)).ToList();
}</pre> <p>This <code>EmailValidationErrors</code> property gives a list of only the validation errors related to the <code>EmailAddress</code> property. This <code>EmailValidationErrors</code> property can be bound to the UI so that we can display the errors only relevant to the <code>EmailAddress</code> property on the screen. In order to keep this bound list up-to-date, we need to make sure we trigger the <code>PropertyChanged</code> event of the <code>EmailValidationErrors</code> property each time the <code>EmailAddress</code> property is updated, as shown here:</p>
<pre class="source-code">
public string EmailAddress
{
    get =&gt; _emailAddress;
    set
    {
        SetProperty(ref _emailAddress, value, true);
        <strong class="bold">OnPropertyChanged(nameof(EmailValidationErrors));</strong>
    }
}</pre> <p>By creating a dedicated property for each input’s validation errors and ensuring it’s updated whenever the input value changes, we can effectively isolate and display validation errors for individual fields. However, it does come with a caveat: for forms with numerous input fields, this method can be somewhat labor-intensive and repetitive. Let me show you an alternative that automates this process and saves us some manual work. The end result will be that we are going<a id="_idIndexMarker631"/> to bind to a particular property called <code>ErrorExposer</code>. Then, using its <strong class="bold">indexer</strong>, we will specify which property’s validation errors we want to<a id="_idIndexMarker632"/> retrieve and display, something like this:</p>
<pre class="source-code">
&lt;VerticalStackLayout BindableLayout.ItemsSource="{Binding <strong class="bold">ErrorExposer[EmailAddress]</strong>}"&gt;</pre> <p>Let’s see how we can implement this mechanism:</p>
<ol>
<li>In the <code>Validation</code> folder that we created earlier, select <code>ValidationErrorExposer</code> as the class name.</li>
<li>The <code>ValidationErrorExposer</code> class should implement two interfaces: <code>INotifyPropertyChanged</code> and <code>IDisposable</code>, as shown in the following snippet:<pre class="source-code">
public class ValidationErrorExposer : INotifyPropertyChanged, IDisposable
{
    public event PropertyChangedEventHandler? PropertyChanged;
    public void Dispose()
    {
    }
}</pre></li> <li>Next, let’s introduce a <code>readonly</code> field <code>validator</code> of type <code>ObservableValidator</code>. The value for this field should be passed in through the class constructor, as shown here:<pre class="source-code">
readonly ObservableValidator validator;
public ValidationErrorExposer(
        ObservableValidator observableValidator)
{
    validator = observableValidator;
}</pre><p class="list-inset">The passed-in <code>observableValidator</code> is the instance that we want to automatically expose per-property validation errors.</p></li> <li>It’s time to add the <code>ValidationErrorExposer</code> indexer. An indexer in .NET allows an instance of a class to be accessed using an index, similar to an array or dictionary. This index can be of any type, such as a string or an int, and it lets you retrieve or set values<a id="_idIndexMarker633"/> without explicitly calling a method or property. In this case, we set the index to be a string as it represents the name of the property we want to get the validation errors of. This is how we can do this:<pre class="source-code">
public List&lt;ValidationResult&gt; this[string <strong class="bold">property</strong>]
    =&gt; validator.GetErrors(<code>ValidationErrorExposer</code> accepts a string value as the index and returns a list of <code>ValidationResult</code> objects. This value, which represents the name of the property we want to get the errors of, is passed into the <code>ObservableValidator</code> <code>GetErrors</code> method. The result is returned as a <code>List</code>.</p></li> <li>In the constructor of the <code>ValidationErrorExposer</code> class, we should also subscribe to the <code>ErrorsChanged</code> event of the <code>ObservableValidator</code> that is being passed in, like this:<pre class="source-code">
public ValidationErrorExposer(ObservableValidator observableValidator)
{
    validator = observableValidator;
    validator.ErrorsChanged += ObservableValidator_ErrorsChanged;
}
private void ObservableValidator_ErrorsChanged(object? sender, DataErrorsChangedEventArgs e)
    =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs($"Item[{e.PropertyName}]"));</pre><p class="list-inset">While it might seem<a id="_idIndexMarker634"/> like there’s some magic happening, the concept is fairly straightforward. In .NET MAUI, if an object has an indexer, you can bind to that indexer property as demonstrated by <code>{Binding ErrorExposer[EmailAddress]}</code>, where <code>ErrorExposer</code> is an instance of a type that contains an indexer. To notify the UI of an updated value, we can invoke the <code>PropertyChanged</code> event from the <code>ErrorExposer</code> and pass <code>Item[EmailAddress]</code> as the property name. Doing so will prompt all bindings tied to <code>ErrorExposer[EmailAddress]</code> to re-evaluate. Alternatively, invoking the <code>PropertyChanged</code> event with <code>PropertyChangedEventArgs</code> having <code>Item</code> as the property name will trigger a re-evaluation of all bindings associated with the indexer.</p></li> <li>Finally, in <code>ValidationErrorExposer</code>, we should update the <code>Dispose</code> method to the following:<pre class="source-code">
public void Dispose()
    =&gt; _validator.ErrorsChanged -=         ObservableValidator_ErrorsChanged;</pre><p class="list-inset">Because we have subscribed to the <code>ObservableValidator</code> <code>ErrorsChanged</code> method, we need to provide a mechanism to unhook from this event, preventing any memory leaks. For that, we can use the <code>Dispose</code> method.</p></li> <li>Let’s head back to <code>AddRatingViewModel</code> and add a property of type <code>ValidationErrorExposer</code>, as shown here:<pre class="source-code">
public ValidationErrorExposer ErrorExposer { get; }</pre></li> <li>In the constructor of <code>AddRatingViewModel</code>, assign a new instance to this property:<pre class="source-code">
public AddRatingViewModel(INavigationService navigationService)
{
...
    <strong class="bold">ErrorExposer = new (this);</strong>
...
}</pre><p class="list-inset">We pass in <code>this</code> to the constructor of the <code>ValidationErrorExposer</code> class because it is the instance of the <code>AddRatingViewModel</code> itself that inherits from <code>ObservableValidator</code> and thus holds all validation errors.</p></li> <li>In XAML, we can now<a id="_idIndexMarker635"/> bind to a list of validation errors, specific to a particular property using the indexer on the <code>ValidationErrorExposer</code> class. This allows us to show these errors close to the relevant input fields themselves, as shown in the following snippet:<pre class="source-code">
&lt;Editor Text="{Binding Review, Mode=TwoWay}" /&gt;
&lt;VerticalStackLayout <strong class="bold">BindableLayout.ItemsSource="{Binding ErrorExposer[Review]}"</strong>&gt;
    &lt;BindableLayout.ItemTemplate&gt;
        ...
    &lt;/BindableLayout.ItemTemplate&gt;
&lt;/VerticalStackLayout&gt;</pre></li> </ol>
<p><code>ValidationErrorExposer</code> allows us to easily get validation errors from a specific property, without needing to do any manual work: once this is in place, we can bind to the errors of any specific <a id="_idIndexMarker636"/>property using its indexer property.</p>
<p>Displaying validation errors near user input further improves the user experience. Let’s explore how to visually indicate the validity of entered values, improving the experience even more.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor160"/>Visualizing validation errors with triggers</h1>
<p><strong class="bold">Triggers</strong> help us customize how <a id="_idIndexMarker637"/>UI elements work and look without <a id="_idIndexMarker638"/>building new controls from scratch.</p>
<p>While there are different types of<a id="_idIndexMarker639"/> triggers, we’ll focus on <strong class="bold">data triggers</strong>. These kick in when a property (on the ViewModel) changes, allowing us to adjust elements of a UI control dynamically, based on what the user does.</p>
<p class="callout-heading">Types of triggers</p>
<p class="callout">There are different types of <a id="_idIndexMarker640"/>triggers in .NET MAUI: PropertyTrigger, DataTrigger, EventTrigger, and so on… They all allow you to change the appearance of a UI control declaratively in XAML based upon a trigger. They only differ in what triggers the <a id="_idIndexMarker641"/>change: a property value, a bound value, an event. You can learn more about them at <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/triggers">https://learn.microsoft.com/dotnet/maui/fundamentals/triggers</a>.</p>
<p>In essence, a DataTrigger provides a way to declaratively set up UI changes in response to data changes, directly within your XAML, without having to write procedural code in your code-behind, a custom ValueConverter, or ViewModel.</p>
<p>DataTriggers are a fairly easy-to-understand concept. So, let’s just dive in and add a visual indicator right next to the different <code>Entry</code> controls, indicating with a symbol and a particular color whether the entered value is valid or not, as <em class="italic">Figure </em><em class="italic">9</em><em class="italic">.3</em> shows:</p>
<div><div><img alt="Figure 9.3: Indicating input is valid (right) or not (left)" height="156" src="img/B20941_09_03.jpg" width="1312"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Indicating input is valid (right) or not (left)</p>
<p class="callout-heading">What about ValueConverters?</p>
<p class="callout">In <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Databinding in .NET MAUI</em>, we <a id="_idIndexMarker642"/>discussed the usage of value converters. The things that you can do with DataTriggers are also achievable with value converters and vice versa. But, with a DataTrigger, it is very easy to implement these visual effects declaratively, without a single line of C# code, also making the XAML more readable.</p>
<p>Let’s have a look at how we <a id="_idIndexMarker643"/>can implement these visual cues<a id="_idIndexMarker644"/> using DataTriggers:</p>
<ol>
<li>First, add a <code>Grid</code> around the <code>Entry</code> for the <code>EmailAddress</code> property:<pre class="source-code">
&lt;Grid ColumnDefinitions="*, Auto" HeightRequest="45"&gt;
    &lt;Entry
        Keyboard="Email"
        Text="{Binding EmailAddress, Mode=TwoWay}"
        VerticalOptions="End" /&gt;
&lt;/Grid&gt;</pre><p class="list-inset">This <code>Grid</code> has two columns, with the <code>Entry</code> in the first one, and we will be adding the validity indicator in the second one.</p></li> <li>Inside this <code>Grid</code>, below the <code>Entry</code>, add the following <code>Label</code>, which will serve as the validity indicator:<pre class="source-code">
&lt;Label
    Grid.Column="1" FontFamily="MaterialIconsRegular"
    FontSize="20" Text="&amp;#xe000;" TextColor="Red"
    VerticalOptions="Center"&gt;
&lt;/Label&gt;</pre><p class="list-inset">By default, this <code>Label</code> shows the invalid state: red text and an exclamation mark icon.</p></li> <li>Now, we can add the <code>DataTrigger</code> and define that the <code>Label</code> needs to show a blue checkmark when the<a id="_idIndexMarker645"/> provided email address is valid. The following snippet shows how <a id="_idIndexMarker646"/>we can do that:<pre class="source-code">
&lt;Label ... &gt;
    &lt;Label.Triggers&gt;
        &lt;DataTrigger
            TargetType="Label"
            Binding="{Binding ErrorExposer[EmailAddress].Count}"
            Value="0"&gt;
            &lt;Setter Property="Text"
                Value="&amp;#xe86c;" /&gt;
            &lt;Setter Property="TextColor"
                Value="Blue" /&gt;
        &lt;/DataTrigger&gt;
    &lt;/Label.Triggers&gt;
&lt;/Label&gt;</pre><p class="list-inset">A <code>DataTrigger</code> has a <code>Binding</code> property that allows us to bind to a certain value. In this case, we bind to the <code>Count</code> property of the list of validation errors related to the <code>EmailAddress</code> property. With the <code>Value</code> property, we can set a condition for this bound property. We set the value to <code>"0"</code>, meaning that there are no validation errors associated with the <code>EmailAddress</code> property. When the value of the property meets this condition, the trigger activates. Once activated, the trigger can change one or more properties of the UI control. In this particular case, we’re updating the <code>Text</code> and <code>TextColor</code> properties by specifying a <code>Setter</code> for these properties and providing a certain <code>Value</code>.</p></li> </ol>
<p>As said, this can also be achieved with custom <code>ValueConverter</code>s, but this declarative way of defining it in <a id="_idIndexMarker647"/>XAML is very readable, maintainable, and easy to use.</p>
<p class="callout-heading">Behaviors</p>
<p class="callout">Another way to give the user visual cues about the validity of entered values is by using <strong class="bold">Behaviors</strong>. Behaviors are like little plugins <a id="_idIndexMarker648"/>you can add to your UI elements, enhancing their default behavior without having to subclass them. They’re particularly useful because they encapsulate logic in reusable pieces, allowing developers to apply the same functionality across different controls. For example, a Behavior might allow a text input field to only accept numerical input or change its color when certain conditions are met. The .NET MAUI Community Toolkit comes with a set of ready-to-use Behaviors! You can <a id="_idIndexMarker649"/>learn more about them at <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors">https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors</a>.</p>
<p>In the next section, we’ll have a look at how to display prompts and alerts, essential parts for providing user feedback <a id="_idIndexMarker650"/>and gathering input.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor161"/>Prompts and alerts</h1>
<p>Direct feedback and clear communication are paramount when it comes to a solid user experience. As users navigate your application and interact with various inputs, there are moments where a subtle notification or a direct prompt can make all the difference. Prompts and alerts serve as these essential tools, guiding users through their journey, ensuring they’re informed and make intentional decisions.</p>
<p>Showing prompts and alerts is <a id="_idIndexMarker651"/>something that is platform-specific. Luckily .NET MAUI has got us covered as they provide simple and intuitive APIs for this. On the other hand, in an MVVM scenario, displaying a prompt or alert is mostly triggered from a ViewModel, which should be framework-independent. The solution, of course, is creating an interface for this functionality that a ViewModel can talk to. On the MAUI side of things, we can easily implement this interface and register it in our DI container so the implementation gets injected into the ViewModels. Let’s go ahead and set this up!</p>
<ol>
<li>To begin with, let’s add an interface that defines some methods for displaying prompts and alerts. Right-click the <code>Recipes.Client.Core</code> project in the <code>Services</code>.</li>
<li>Add a new interface to <a id="_idIndexMarker652"/>this folder and call it <code>IDialogService</code>.</li>
<li>The methods defined in an <code>IDialogService</code> can defer from project to project. The following code block shows some method declarations that are often present in an <code>IDialogService</code> interface:<pre class="source-code">
public interface IDialogService
{
    Task Notify(string title, string message,
        string buttonText = "OK");
    Task&lt;bool&gt; AskYesNo(string title, string message,
        string trueButtonText = "Yes",
        string falseButtonText = "No");
    Task&lt;string?&gt; Ask(string title, string message,
        string acceptButtonText = "OK",
        string cancelButtonText = "Cancel");
}</pre><p class="list-inset">As said, depending on your specific use case, this interface might be extended with some other <a id="_idIndexMarker653"/>concrete method definitions.</p></li> <li>Next, we need to add an implementation for this interface. Add a new folder called <code>Services</code> to the <code>Recipes.Mobile</code> project.</li>
<li>Right-click the new <code>Services</code> folder and select <code>DialogService</code> as the name of the new class and add the following code:<pre class="source-code">
public class DialogService : IDialogService
{
    public Task Notify(string title, string message,
        string buttonText = "OK")
        =&gt; Application.Current.MainPage
            .DisplayAlert(title, message, buttonText);
    public Task&lt;bool&gt; AskYesNo(string title,
        string message,
        string trueButtonText = "Yes",
        string falseButtonText = "No")
        =&gt; Application.Current.MainPage
            .DisplayAlert(title, message,
            trueButtonText, falseButtonText);
    public Task&lt;string?&gt; Ask(string title,
        string message,
        string acceptButtonText = "OK",
        string cancelButtonText = "Cancel")
        =&gt; Application.Current.MainPage
            .DisplayPromptAsync(title, message,
            acceptButtonText, cancelButtonText);
}</pre><p class="list-inset">In .NET MAUI, the <code>Page</code> class <a id="_idIndexMarker654"/>provides various methods for displaying alerts, prompts, and action sheets. Within the <code>DialogService</code> class, we can access these methods by referencing <code>MainPage</code> through the static <code>Current</code> property of the <code>Application</code> class.</p></li> <li>The next thing we need to do is register <code>DialogService</code> in our DI container. Move over to <code>MauiProgram.cs</code> and add the following:<pre class="source-code">
builder.Services.AddSingleton&lt;IDialogService, DialogService&gt;();</pre></li> <li>Finally, we can add the <code>IDialogService</code> as a dependency to our ViewModels. Let’s add it to <code>AddRatingViewModel</code> as shown here:<pre class="source-code">
readonly IDialogService dialogService;
...
public AddRatingViewModel(INavigationService navigationSerivce, IDialogService dialogService)
{
...
    this.dialogService = dialogService;
...
}</pre></li> <li>Move over to the <code>OnSubmit</code> method and update it as shown here:<pre class="source-code">
private async Task OnSubmit()
{
    var result = await _dialogService.AskYesNo(
        "Are you sure?",
        "Are you sure you want to add this rating?");
    if (result)
    {
        //ToDo: Submit data
        await _dialogService.Notify("Rating sent",
            "Thank you for your feedback!");
        GoBackCommand.Execute(null);
    }
}</pre><p class="list-inset">In the updated <code>OnSubmit</code> method, we first ask for confirmation. If the user confirms, an alert will be shown<a id="_idIndexMarker655"/> saying the rating was sent (<em class="italic">Figure 9</em><em class="italic">.3</em>). After the user closes the alert, <code>GoBackCommand</code> is invoked, closing the <code>AddRatingPage</code>.</p></li> </ol>
<div><div><img alt="Figure 9.3: Showing alerts and prompts" height="342" src="img/B20941_09_04.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Showing alerts and prompts</p>
<p>With the <code>IDialogService</code> and its <code>DialogService</code> implementation in place, we have laid the foundation for basic<a id="_idIndexMarker656"/> popup interactions in our application. Next, we’ll explore how to leverage this to prompt users for confirmation when they attempt to leave a specific page.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor162"/>Confirming or canceling navigation</h1>
<p>As users interact with our application, there may be moments when they’re about to navigate away from a page containing unsaved changes or important input. To prevent potential data loss, it’s essential to <a id="_idIndexMarker657"/>prompt for confirmation before allowing such navigation. Let’s<a id="_idIndexMarker658"/> see how we could build this by leveraging the <code>NavigationService</code> that we built in the previous chapter:</p>
<ol>
<li>Let’s start by adding the following interface called <code>INavigatable</code> to the <code>Navigation</code> folder of the <code>Recipes.Client.Core</code> project:<pre class="source-code">
public interface INavigatable
{
    Task&lt;bool&gt; CanNavigateFrom(NavigationType navigationType);
}</pre><p class="list-inset">ViewModels that want to<a id="_idIndexMarker659"/> control whether the user is able to navigate can implement this<a id="_idIndexMarker660"/> interface. This is analogous to the other interfaces we introduced in the context of navigation, such as the <code>INavigatedFrom</code>, <code>INavigatedTo</code>, and <code>INavigationParameterReceiver</code> interfaces.</p></li> <li>Extend the <code>INavigationInterceptor</code> interface with the following method definition:<pre class="source-code">
Task&lt;bool&gt; CanNavigate(object bindingContext, NavigationType type);</pre></li> <li>The <code>NavigationService</code> class, which implements the <code>INavigationInterceptor</code> interface, now needs to implement this method. Here’s what it looks like:<pre class="source-code">
public Task&lt;bool&gt; CanNavigate(object bindingContext, NavigationType type)
{
    if(bindingContext is INavigatable navigatable)
        return navigatable.CanNavigateFrom(type);
    return Task.FromResult(true);
}</pre><p class="list-inset">This method checks whether the given <code>bindingContext</code> parameter implements the <code>INavigatable</code> interface. If that’s the case, it returns the result from its <code>CanNavigateFrom</code> method, passing in the <code>NavigationType</code>. If the <code>bindingContext</code> doesn’t<a id="_idIndexMarker661"/> implement the <code>INavigatable</code> interface, <code>true</code> is returned, indicating the<a id="_idIndexMarker662"/> navigation can be executed.</p></li> <li>In the <code>AppShell</code> class, we must now override the <code>OnNavigating</code> method. In this method, we can retrieve a <code>ShellNavigatingDeferral</code> from the passed-in <code>ShellNavigatingEventArgs</code>. This deferral token can be used to complete the navigation. Or, if the navigation should be canceled, the <code>Cancel</code> method on the <code>ShellNavigatingEventArgs</code> can be called. The next code block shows the overridden method:<pre class="source-code">
protected override async void OnNavigating(ShellNavigatingEventArgs args)
{
    base.OnNavigating(args);
    var token = args.GetDeferral();
    if(token is not null)
    {
        var canNavigate = await interceptor
        .CanNavigate(CurrentPage?.BindingContext, GetNavigationType(args.Source));
        if (canNavigate)
            token.Complete();
        else
            args.Cancel();
    }
}</pre><p class="list-inset">By calling the interceptor’s <code>CanNavigate</code> method, we can determine whether we must complete the navigation or not. Depending on the outcome, we can call the <code>Complete</code> method on <a id="_idIndexMarker663"/>the deferral token and complete the navigation or call the <code>Cancel</code> method <a id="_idIndexMarker664"/>on the passed-in <code>args</code> to cancel it.</p></li> <li>Finally, we can go to <code>AddRatingViewModel</code>, make it implement the <code>INavigatable</code> interface, and add the following:<pre class="source-code">
public class AddRatingViewModel : ObservableValidator, INavigationParameterReceiver, INavigatedFrom, <strong class="bold">INavigatable</strong>
{
...
    <strong class="bold">public Task&lt;bool&gt; CanNavigateFrom(</strong>
<strong class="bold">        NavigationType navigationType) =&gt;</strong>
<strong class="bold">        _dialogService.AskYesNo(</strong>
<strong class="bold">        "Leaving this page...",</strong>
<strong class="bold">        "Are you sure you want to leave this page?");</strong>
}</pre></li> </ol>
<p>As a result, when navigating from the <code>AddRatingView</code>, the <code>OnNavigating</code> method on the <code>Shell</code> class will get called, which – via the <code>NavigationService</code> – will call the <code>CanNavigateFrom</code> method on the <code>AddRatingViewModel</code>. The ViewModel will present a dialog to the user and <a id="_idIndexMarker665"/>return the response. Depending on the response given by the user, the navigation will be completed or canceled. The <code>INavigatable</code> interface <a id="_idIndexMarker666"/>can be implemented by any ViewModel and can contain any business logic to determine whether navigation is allowed or not.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor163"/>Summary</h1>
<p>In this chapter, we delved deep into enhancing user experience through effective validation, prompts, and alerts. We explored the power of <code>ObservableValidator</code> for validation logic and learned the nuances of showing errors both as a collective list and inline, right next to input fields. With triggers, we learned how to customize UI elements without reinventing the wheel. We also explored using an <code>IDialogService</code> leveraging alerts and prompts, which is essential in contexts where user feedback or confirmations, such as during critical actions or navigations, are required. As we move forward, we’ll pivot to a vital aspect of many modern apps: making remote API calls.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor164"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><code>ObservableValidator</code>: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator</a></li>
<li>Triggers: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/triggers">https://learn.microsoft.com/dotnet/maui/fundamentals/triggers</a></li>
<li>Behaviors: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors">https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors</a></li>
<li>.NET MAUI Community Toolkit Behaviors: <a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/">https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/</a></li>
<li>.NET MAUI popups: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups">https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups</a></li>
</ul>
</div>
</div></body></html>