- en: Creating Textures, Maps, and Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic material with Standard Shader (Specular setup)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting a basic material from Specular setup to Metallic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Normal maps to a Material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Transparency and Emission maps to a material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting materials at mouse-over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Detail maps to a material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fading the transparency of a material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a close relationship between **Textures**, **Materials**, and **Shaders**,
    and their relationships are important:'
  prefs: []
  type: TYPE_NORMAL
- en: Textures are two-dimensional images. The surface of 2D and 3D objects in Unity
    games are defined by meshes. The **Texture** images are mapped onto meshes by
    **Materials** – each point (vertex) on a mesh has to be mapped to some value in
    the **Texture**. A **Texture** may indicate colors, but may indicate bumps/wrinkles
    or transparency – all of which can contribute to determining what is finally rendered
    for the user to see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Materials** specify which **Shader** should be used to render the images
    onto the meshes, plus values for the **Shader''s** parameters (such as which textures/parts
    of a texture map, colors, other values). Learn more at the Unity documentation
    page about Materials: [https://docs.unity3d.com/Manual/Materials.html](https://docs.unity3d.com/Manual/Materials.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shaders** define the method to render an object. **Shaders** can use multiple
    textures for more sophisticated results, and specify which parameters may be customized
    in the Material Inspector. At the end of the day, **Shaders** are code and mathematics,
    but Unity provides a set of **Shaders** for us. We can also use the new **Shader
    Graph** package, which allows the creation of sophisticated **Shaders** using
    a visual, drag-and-drop graphing interface. In addition, custom shaders can be
    written in the **ShaderLab** language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity offers physically-based Shaders. **Physically-Based Rendering** (**PBR**)
    is a technique that simulates the appearance of **Materials** based on how the
    light reacts with that **Material** (more specifically, the matter from which
    that material is made) in the real world. Such a technique allows for more realistic
    and consistent materials. So, your creations in Unity should look better than
    ever. Creating **Materials** in Unity has also become more efficient now. Once
    you have chosen between the available workflows (**Metallic** or **Specular**
    setup; we'll get back to that later), there is no longer a need to browse the
    drop-down menus in search of specific features, as Unity optimizes the shader
    for the created **Material**, removing unnecessary code for unused properties
    once the material has been set up and the texture maps have been assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and saving texture maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The visual aspects of a material can be modified through the use of textures.
    In order to create and edit image files, you will need an image editor, such as
    Adobe Photoshop (the industry standard, and has its native format supported by
    Unity) or GIMP. In order to follow the recipes in this chapter, it's strongly
    recommended that you have access to a few pieces of software such as these.
  prefs: []
  type: TYPE_NORMAL
- en: 'When saving **Texture Maps**, especially the ones that have an **Alpha Channel**,
    you might want to choose an adequate file format. PSD, Photoshop''s native format,
    is practical for preserving the original artwork in many layers. The PNG format
    is also a great option, but please note that Photoshop doesn''t handle PNG''s
    **Alpha Channel** independently of the transparency, possibly compromising the
    material''s appearance. Also, PNG files don''t support layers. For this chapter,
    we will often use the TIF format for three main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It's open to those not using Photoshop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It preserves the **Alpha Channel** information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file size is significantly greater than in PSDs and PNGs, so feel free to
    save your work as PSDs (if you have Photoshop) or PNGs (if you don't need layers
    and, if using Photoshop, **Alpha Channels**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a word of advice: although it''s possible to manually create **Texture
    Maps** for our materials by using the traditional image-editing software, new
    tools such as Allegorthmic''s Substance Painter and Bitmap2Material make this
    work much more efficient, complete, and intuitive, complementing the traditional
    **Texture**-making process or replacing it altogether. These tools provide Texture
    work support in a similar way to what zBrush and Mudbox did for 3D modeling. For
    design professionals, we strongly recommend at least trying such tools. Note,
    however, that products from Allegorithmic won''t make use of Unity''s Standard
    Shader, relying on the substance files (which are natively supported by Unity).'
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the **Standard Shaders**, it''s a good idea to know the workflows,
    their properties, and how they affect the material''s appearance. There are, however,
    many possible ways to work with **Materials** – texture map requirements, for
    instance, might change from engine to engine, or from one tool to another. Presently,
    Unity supports two different workflows: one based on **Specular**, and another
    based on Metallic values. Although both workflows share similar properties (such
    as **Normal**, **Height**, **Occlusion**, and **Emission**), they differ in the
    way the diffuse color and reflectance properties are set up.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Shader (Specular workflow)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity''s Standard **Shader** (**Specular** setup) uses **Albedo** and **Specular/Smoothness**
    maps, combining them to create some of the material''s aspect – mainly its color
    and reflectance qualities. The following shows the difference between the **Albedo**
    and **Smoothness** maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Albedo**: This is the material''s diffused color. Plainly and simply, this
    is how you usually describe the appearance of the **Material** (the British flag
    is red, white and blue; Ferrari''s logo is a black horse in a yellow setting;
    some sunglasses'' lenses are semi-transparent gradients). This description, however,
    can be deceptive. Purely metallic objects (such as aluminum, chrome, and gold)
    should have black as their diffuse color. Their colors, as we perceive them, have
    originated from their specular channel. Non-metallic objects (plastic, wood, and
    even painted or rusted metal), on the other hand, have very distinct diffuse colors.
    **Texture Maps** for the **Albedo** property feature RGB channels for colors and
    (optionally) an Alpha Channel for transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specular/Smoothness**: This refers to the shininess of the material. **Texture**
    maps make use of RGB channels for specular color (which inform hue and intensity),
    and **Alpha Channel** for smoothness/gloss (dark values for less shiny surfaces
    and blurred reflections; light/white values for shiny, mirror-like appearance).
    It is important to note that non-metallic objects feature neutral, very dark specular
    colors (with plastic, for instance, you should work with a grey value around 59).
    Metallic objects, on the other hand, feature very light values, and are also a
    bit yellowish in hue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate such concepts, we have created a battery object, featuring brushed
    metal caps and a plastic body. Observe how each map contributes to the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0be3aaf1-343d-4ed6-b6a6-ec64080ec85e.png)'
  prefs: []
  type: TYPE_IMG
- en: Standard Shader (Metallic workflow)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity''s default **Standard Shader** combines **Albedo** and **Metallic**/**Glossiness**
    maps to create the color and reflectance qualities of the material. The following
    are the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Albedo**: As in the **Specular** workflow, this is the **Material''s** diffuse
    color; how you would describe the **Material**. However, **Albedo** maps for the
    Metallic workflow should be configured in a slightly different way than ones for
    **Specular** workflow. This time around, the perceived diffuse color of metallic
    materials (grey for iron, yellow/orange for golden, and so on) have to be present
    in the Albedo map. Again, Albedo maps feature RGB channels for the colors and
    (optionally) an Alpha Channel for transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metallic/Smoothness**: This refers to how metallic the **Material** looks.
    **Metallic Texture Maps** make use of the Red channel for the **Metallic** value
    (black for non-metallic and white for metallic **Materials** that are not painted
    or rusted) and the **Alpha Channel** for smoothness (in a similar way to the **Specular**
    workflow). Please note that **Metallic** maps do not include any information on
    hue, and in these cases the yellow-ish nature of the metallic gloss should be
    applied to the **Albedo** map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To reproduce the battery that illustrated the **Specular** workflow by using
    the Metallic workflow, maps would have to be recreated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10084c58-6e08-4a11-85dd-4886cdcedbc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might have noticed that we''ve used white to convey a metallic object.
    Technically, since only the Red channel is relevant, we could have used red (R:
    255, G: 0, B: 0), yellow (R: 255, G: 255, B: 0), or, for that matter, any color
    that has a red value of 255.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity documentation pages provide two very useful charts giving examples
    of common properties for the **Standard Shader** **Metallic** and **Specular**
    workflows ([https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html](https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e14f4b7-f16c-4aa3-82a1-cb0b6bfefee4.png)'
  prefs: []
  type: TYPE_IMG
- en: Other material properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s also worth mentioning that Unity''s **Standard Shaders** support other
    maps such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal Maps**: The normal map adds detailed bumpiness into the **Material**,
    simulating a more complex geometry. For instance, the internal ring on the positive
    (top) node of the battery that illustrated shader workflows is not modeled in
    the 3D object''s geometry, but rather created through a simple **Normal Map**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occlusion Maps**: A greyscale map is used to simulate the dark sections of
    an object under ambient light. Usually, it is used to emphasize joints, creases,
    and other details of geometry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height Maps**: These add a displacement effect, giving the impression of
    depth without the need for complex geometry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emission Maps**: These add color emitted by the **Material**, as if self-illuminated,
    such as fluorescent surfaces or LCDs. **Texture** maps for Emission maps feature
    RGB channels for color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Physically-Based Rendering** (**PBR**) is a complex (and current) topic,
    so it''s a good idea to study it a bit by familiarizing yourself with the tools
    and concepts behind it. To help you with this task, we have included a non-exhaustive
    list of resources that you should take a look at.'
  prefs: []
  type: TYPE_NORMAL
- en: Unity samples and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start, it might be a good idea to read Unity''s documentation on
    **Textures**, **Materials**, and **Shaders**. They can be found online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/Textures.html](https://docs.unity3d.com/Manual/Textures.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/Materials.html](https://docs.unity3d.com/Manual/Materials.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/shader-StandardShader.html](https://docs.unity3d.com/Manual/shader-StandardShader.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers a number of techniques used to create, often manually and
    sometimes automatically, texture maps that are capable of giving distinctive features
    to materials. Hopefully, you will become confident working with Unity's **Physically-Based
    Shading**, which is capable of understanding differences between available workflows,
    is aware of the role of each material property, and is ready to make better-looking
    materials for your games. We have also explored ways of changing the properties
    of materials during runtime by accessing an object's **Material** via script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity has put together a great resource for those looking for some pointers
    regarding how to set up maps for a variety of materials:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Shader Calibration** **Scene**, which can be downloaded (for free) from
    the Unity Asset Store. It is a fantastic collection, featuring sample materials
    (both **Metallic** and **Specular** setup) for wood, metal, rubber, plastic, glass,
    skin, mud, and much more: [https://assetstore.unity.com/packages/essentials/tutorial-projects/shader-calibration-scene-25422](https://assetstore.unity.com/packages/essentials/tutorial-projects/shader-calibration-scene-25422).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a list of interesting, detailed material on **Physically-Based Rendering**
    (within and outside Unity):'
  prefs: []
  type: TYPE_NORMAL
- en: For a deep understanding of **Physically-Based** **Rendering**, we recommend
    you to take a look at The Comprehensive PBR Guide, written by Wes McDermott from
    Allegorithmic. Allegorithmic's guide takes an in-depth look at the practical and
    theoretical aspects of PBR, including a great analysis of possible workflows.
    The guide is freely available in two volumes at [http://www.allegorithmic.com/pbr-guide](http://www.allegorithmic.com/pbr-guide).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering Physically Based Shading in Unity 5 by Renaldas Zioma (Unity), Erland
    Körner (Unity), and Wes McDermott (Allegorithmic), is available at [http://www.slideshare.net/RenaldasZioma/unite2014-mastering-physically-based-shading-in-unity-5](http://www.slideshare.net/RenaldasZioma/unite2014-mastering-physically-based-shading-in-unity-5).
    This is a detailed presentation about using PBS in Unity. Originally presented
    at the Unite 2014 conference, it contains some out-of-date information, but it
    is still worth taking a look at.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physically Based Shading in Unity 5 by Aras Pranckevičius, from Unity, is available
    at [http://aras-p.info/texts/talks.html](http://aras-p.info/texts/talks.html).
    Slides and notes from a presentation on the subject are given at the GDC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tutorial: Physically Based Rendering, And You Can Too! by Joe "EarthQuake"
    Wilson is available at [http://www.marmoset.co/toolbag/learn/pbr-practice](http://www.marmoset.co/toolbag/learn/pbr-practice).
    It is a great overview from the makers of Marmoset Toolbag and Skyshop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polycount PBR Wiki, available at http://wiki.polycount.com/wiki/PBR, is a list
    of resources compiled by the Polycount community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lots of general 3D graphics articles and tutorials from Jeremy Brin of Pixar:
    [http://3drender.com/](http://3drender.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a new generation of texturing software for you to check out, in case
    you haven''t yet:'
  prefs: []
  type: TYPE_NORMAL
- en: Substance Painter is a 3D painting application from Allegorithmic. It is available
    at [http://www.allegorithmic.com/products/substance-painter](http://www.allegorithmic.com/products/substance-painter).
    Again, it's worth mentioning that Allegorithmic products won't make use of Unity's
    Standard Shader, relying instead on substance files that are natively supported
    by Unity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitmap2Material creates full-featured materials (including normal maps and specular
    maps) from a single bitmap image. Also, it is from Allegorithmic, and it is available
    at [http://www.allegorithmic.com/products/bitmap2material](http://www.allegorithmic.com/products/bitmap2material).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quixel DDO is a plugin for creating PBR-ready textures in Adobe Photoshop. From
    Quixel, it is available at [http://www.quixel.se/ddo](http://www.quixel.se/ddo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quixel NDO is a plugin for creating Normal maps in Adobe Photoshop. From Quixel,
    it is available at [http://www.quixel.se/ndo](http://www.quixel.se/ndo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mari is a 3D painting tool from The Foundry. It is available at [http://www.thefoundry.co.uk/products/mari/](http://www.thefoundry.co.uk/products/mari/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CrazyBump is a standalone tool for Windows and Mac, which is available at [http://www.crazybump.com](http://www.crazybump.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GIMP normalmap plugin, available for Windows only, is available at [http://code.google.com/p/gimp-normalmap/](http://code.google.com/p/gimp-normalmap/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NVIDIA Texture Tools for Adobe Photoshop, available for Windows only, is available
    at [http://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop](http://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **NormalMap Online** free online tool, developed by Christian Petry, can
    be used to generate **Normal** maps, regardless of your computers **Operating
    System**. This tool can be accessed at [http://cpetry.github.io/NormalMap-Online/](http://cpetry.github.io/NormalMap-Online/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two new Unity features relating to **Materials** and **Textures** are the **Shader
    Graph** tool, and the **Video Player** component. Learn more about these in their
    own chapter: *Shader* Graphs and *Video Players**.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic material with Standard Shader (Specular setup)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a basic **Material** using the new
    **Standard Shader** (**Specular Setup**), an Albedo map, and a **Specular**/**Smoothness**
    map. The **Material** will feature both metallic and non-metallic parts, with
    various smoothness levels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two files have been prepared to support this recipe: a 3D model (in FBX format)
    of a battery, and an UVW template texture (in PNG format) to guide us when creating
    the diffuse texture map. 3D models and UVW templates can be made with 3D modeling
    software, such as 3DS MAX, Maya, or Blender. All necessary files are available
    in the `05_01` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a basic material, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project and import the **battery.fbx** and **uvw_template.png**
    files to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the battery model in the scene by dragging it from the `Assets` folder,
    in the **Project** panel, to the **Hierarchy** panel. Select it on the **Hierarchy**
    panel and make sure, via the Transform component on the **Inspector** panel, that
    it is positioned at X: 0, Y: 0, Z: 0.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create a **Specular**/**Smoothness** map for our object. Open the image
    file called **uvw_template.png** in your image editor (we'll use Adobe Photoshop
    to illustrate the next steps). Note that the image file has only a single layer,
    mostly transparent, containing the UVW mapping templates that we will use as guidelines
    for our specular map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new layer and place it beneath the one with the guidelines. Fill the
    new layer with dark gray (R: 56, G: 56, B: 56). The guidelines will be visible
    at the top of the solid black fill:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94875c40-4411-4dd3-a97d-9bd3502eebb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new layer and select the upper section of the image (the one with
    the circles). Fill that area with a slightly-hued light gray (R: 196, G: 199,
    B: 199):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The RGB values for our specular map are not arbitrary: **Physically-Based Shading**
    takes out most of the guesswork from the mapping process, replacing it with the
    research for references. In our case, we have used colors based on the reflectance
    values of iron (the slightly-hued light gray) and plastic (the dark gray). Check
    out the chapter''s conclusion for a list of references.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the text elements in white to add a brand, size, and positive/negative
    indicators to the battery body. Then, hide the guidelines layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b693e9a1-92e7-4749-8155-5a5cdb75f150.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select all your layers and organize them into a group (in Photoshop, this can
    be done by clicking on the drop-down menu in the **Layers** window and navigating
    to Window | New Group from Layers...). Name the new group Specular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/12a9d148-88a6-4b71-bbff-0789d609a3b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Duplicate the Specular group (in the Layers window, right-click on the group's
    name and select Duplicate Group...). Name the duplicated group Smoothness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hide the Smoothness group. Expand the Specular group and hide all text layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b6c0e71-e9f3-497f-a268-ceb6e80870d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unhide the Smoothness group, and hide the Specular group. Select the dark gray
    layer. Make an area selection around the upper region of the battery body, and
    fill it with light gray (R: 220, G: 220, B: 220). Rescale and rearrange the Text
    layers if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d02084e-2625-446a-bba2-87643d57670d.png)'
  prefs: []
  type: TYPE_IMG
- en: Duplicate the layer that contains the gray fill for the upper section of the
    image (the one that went over the circles).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a brushed quality to this material, add a Noise filter to the duplicated
    layer (in Photoshop, this can be done by navigating to Filter | Noise | Add Noise...).
    Use 50% as the Amount and set Monochromatic to true. Then, apply a Motion Blur
    filter (Filter | Blur | Motion Blur...) using 30 pixels as the Distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the Smoothness group. Select the duplicated group and merge it into
    a single layer (on the Layers window, right-click on the group's name and select
    Merge Group).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the merged layer, use the *Ctrl* + a key combination to select the entire
    image, and copy it using the *Ctrl + c *keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aed12078-d495-485c-8852-92a9b3e904a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Hide the merged layer and the Smoothness group. Unhide the Specular group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your image editor, access the image channels window (in Photoshop, this can
    be done by navigating to Window | Channels). Create a New Channel. This will be
    our Alpha Channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Paste the image that you previously copied (from the merged layer) in to the
    **Alpha** **Channel**. Set all channels as visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f03bb096-e393-4582-916c-7b9862c0e471.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your image in the project's `Assets` folder as Battery_specular, either
    in Photoshop format (PSD) or TIF format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's work on the Albedo map. Save a copy of **Battery_specular** as **Battery_albedo**.
    From the **Channels** window, delete the **Alpha Channel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Layers** window, hide the **Smoothness** copy merged layer, and
    unhide the **Smoothness** group. Expand the **Smoothness** group, and hide the
    layer where the Noise filter was applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aab26a45-d8e7-4668-b161-3ab75f3d3aea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the color of the upper rectangle to black. Change the light gray area
    to dark red (R: 204, G: 0, B: 0), and the dark gray to red (R: 255, G: 0, B: 0).
    Rename the group Albedo and save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fb820d5-5ca1-41f7-bd85-456f769ed60c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to Unity and make sure that both files were imported. From the **Project**
    panel, create a new **Material** (menu: Create | Material). Name it Battery_MAT.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Battery_MAT. From the Inspector panel, change the Shader to Standard
    (Specular setup), make sure that the rendering mode is set to Opaque, and that
    the Smoothness slider is at the maximum value of 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d15cd6f-0f24-4943-8181-21e63b2b3e1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Set Battery_specular as the Specular map, and Battery_albedo as the Albedo map
    for Battery_MAT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the Battery_MAT Material from the **Project** project and drop it into
    the **battery** object in the Hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb634eaa-f24c-4196-8816-beb37fd43291.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ultimately, the visual aspect of the battery is a combination of three properties
    of its material: **Specular**, **Smoothness,** and **Albedo**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compose the dark red part of the plastic body, for instance, we have mixed
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Specular map (RGB)**: Very dark grey specularity (for non-metallic appearance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Smoothness (the Alpha Channel of the Specular map)**: Light gray (for
    a glossy aspect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Albedo map**: Dark red (for a dark-red color)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The light red portion, on the other hand, combines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Specular map (RGB)**: That same dark grey specular'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Smoothness (the Alpha Channel of the Specular map)**: Dark gray (for
    a matte aspect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Albedo map**: Red (for a red color)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the brushed metal used for the top and bottom covers combines the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Specular map (RGB)**: Light grey (for a metallic aspect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Smoothness (the Alpha Channel of the Specular map)**: A blurred grey
    noise pattern (for a brushed aspect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Albedo map**: Black (for a red color)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding how the image layers are structured, it's good practice to organize
    your layers into groups named after the property that they are related to. As
    texture maps get more diversified, it can be a good idea to keep a file that contains
    all the maps for quick reference and consistency.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some things you should have in mind when working with Albedo
    maps.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the texture type for an image file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since image files can be used for several purposes within Unity (**Texture Maps**,
    UI textures, cursors, and more), it's a good idea to check whether the right **Texture
    Type** is assigned to your file. This can be done by selecting the image file
    in the **Project** panel, and in the **Inspector** panel by using the drop-down
    menu to select the right **Texture Type** (in this case, Texture). Please note
    that other settings can be adjusted, such as Wrap Mode, Filter Mode, and Maximum
    Size. This last parameter is very useful if you want to keep your Texture maps
    small in size for your game, while still being able to edit them in full size.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the map with color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When editing a **Material**, the color picker to the right of the Albedo map
    slot, on the Inspector panel, can be used to select the **Material's** color,
    in case there is no **Texture** map. If a **Texture** map is being used, the selected
    color will be multiplied to the image, allowing variations on the **Material's**
    color hue.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting a basic material from Specular setup to Metallic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a better understanding of the differences between **Metallic** and **Specular**
    workflows, we will modify the Albedo and Specular/Smoothness maps that are used
    on a Specular setup Material, in order to adapt them to the Metallic workflow.
    The material to be generated will feature both metallic and non-metallic parts,
    with various smoothness levels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on the previous one, so make a copy of that project and use
    the copy for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a basic Material using the Metallic workflow, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Project** panel, select the battery_prefab element. From the Inspector,
    access its **Material** (named Battery_MAT) and change its **Shader** to Standard
    (as opposed to its current shader – Standard (Specular setup):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58465255-8446-4383-ac80-f175f9d232ca.png)'
  prefs: []
  type: TYPE_IMG
- en: In the **Project** panel, find the Battery_specular map and rename it Battery_metallic.
    Open it in your image editor (we'll use Adobe Photoshop to illustrate the following
    steps).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the layer group named Specular and rename it Metallic. Fill the light
    gray layer (named Layer 2, in the Metallic group) with white (R: 255, G: 255,
    B: 255), and the dark gray layer (named Layer 1, in the Metallic group) with black
    (R: 0, G: 0, B: 0). Save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc125bc5-64bd-497a-b5f0-5b99a40f02f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to Unity. From the **Inspector**, set the modified Battery_metallic
    map as the Metallic map of the Battery_MAT material. Also, set None as the Albedo
    map for that **Material**. This will give you an idea of how the **Material**
    is coming along:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b4d871f-8cc3-4ec0-a18e-eb7f695a9b5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s adjust the **Albedo** texture map. From the **Project** panel, locate
    the **Battery_albedo** map and open it in your image editor. Use the **Paint Bucket**
    tool to fill the black area of **Layer** **2**, in the **Albedo** group, with
    light gray (R: 196, G: 199, B: 199). Save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c69eb38-ff86-46c1-b9b0-e93878eba73e.png)'
  prefs: []
  type: TYPE_IMG
- en: Go back to Unity. From the **Inspector**, set the modified Battery_albedo map
    as the Albedo map of the Battery_MAT material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your **Material** is ready, combining visual properties based on the different
    maps that you have edited and assigned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6319067e-0c98-4a98-a5b5-a2324ccdd440.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The visual aspect of the battery is a combination of three properties of its
    material: Metallic, Smoothness, and Albedo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compose the dark-red part of the plastic body, for instance, we have mixed
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Metallic map (RGB)**: Black (for a non-metallic appearance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Smoothness (the Alpha Channel of a Metallic map)**: Light gray (for a
    glossy appearance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Albedo map**: Dark red (for a dark-red color)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The light-red portion, on the other hand, combines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Metallic map (RGB)**: Black'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Smoothness (the Alpha Channel of the Metallic map)**: Dark gray (for
    a matte appearance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Albedo map**: Red (for a red color)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the brushed metal used for the top and bottom covers combines the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Metallic map (RGB)**: White (for a metallic aspect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Smoothness (the Alpha Channel of the Metallic map)**: Blurred grey noise
    pattern (for a brushed appearance);'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Albedo map**: Light grey (for an iron-like appearance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to organize your layers into groups named after the property that they
    are related to.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Normal maps to a Material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Normal Maps** are generally used to simulate complex geometry that would
    be too expensive, in terms of computer processing, to be actually represented
    by the 3D polygons during the game''s runtime. To oversimplify: **Normal Maps**
    fake complex geometry on low-definition 3D meshes. These maps can be generated
    either by projecting high-definition 3D meshes onto low-poly ones (a technique
    usually referred to as baking), or, as will be the case for this recipe, from
    another **Texture** map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aca76bb4-a20e-4950-8cb4-17c64dcb8cf6.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will prepare two **Texture** maps: the **Heightmap** and
    the **Normal** map. The former will be made from simple shapes in an image editor.
    The latter will be automatically processed from the Heightmap. Although there
    are a number of tools that can be used to generate **Normal** maps, we will use
    the free, online NormalMap tool: [http://cpetry.github.io/NormalMap-Online/](http://cpetry.github.io/NormalMap-Online/).'
  prefs: []
  type: TYPE_NORMAL
- en: To help you with this recipe, we've provided an FBX 3D model of the battery
    (battery.fbx), and its Albedo and Specular **Textures** (Battery_albedo.tif **and**
    Battery_specular.tif).
  prefs: []
  type: TYPE_NORMAL
- en: We've also included the UVW template texture (in PNG format) to guide you when
    creating the diffuse **Texture** map. All the files are in the `05_03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To apply a **Normal Map** to a **Material**, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import battery.fbx and its Albedo and Specular **Textures** to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of your 3D model in the Scene by dragging asset **battery**
    from the Project panel into the Scene (or Hierarchy) panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, select model asset battery. In the **Inspector**,
    click the **Materials** button and then click Extract Materials... You should
    now have a **Material** asset file in the **Project** panel named BatteryMaterial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select BatteryMaterial, and change the Shader to Standard (Specular setup).
    Drag the Battery_albedo **Texture** from the **Project** panel into the Albedo
    Texture slot in the Inspector. Drag the Battery_specular **Texture** from the
    **Project** panel into the Specular Texture slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After comparing the **battery** model in your project with some reference photos,
    inform yourself about the features that should be reproduced by the Normal map:
    (A) a bumpy ring at the top, and (B) some circular creases at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d9f90e0-76cf-40e4-836d-50fb396187df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In an image editor, open uvw_template.png. Create a new layer, fill it with
    grey (RGB: 128), and position it below the pre-existing layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08eba0a7-00fd-4d8e-a032-c5aba36e676b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On a separate layer, draw a white circle centered on the battery''s top. Then,
    on another layer, draw a black circle, centered on the battery''s bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04ed61fd-9a39-44e7-93e9-74343d5d1cf4.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have used vector shapes to make the circles, rasterize their layers (in
    Adobe Photoshop, right-click on the layer's name and select the Rasterize Layer
    option from the context menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blur the white circle (in Photoshop, this can be done by navigating to Filter
    | Blur | Gaussian Blur...). Use 4,0 pixels as the Radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hide the UVW template layer and save the image as Battery_height.png.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to convert the Heightmap directly from Unity, import it into your
    project. Select it from the Project panel and, from the Inspector panel, change
    its Texture Type to Normal map. Check the Create from Grayscale option, adjust
    Bumpiness and Filtering as you like, and click on Apply to save the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21de53a3-6a0d-4693-a6fd-a764855171e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To convert your Heightmap externally, go to [http://cpetry.github.io/NormalMap-Online/](http://cpetry.github.io/NormalMap-Online/).
    Drag the Battery_height.png file to the appropriate image slot. Feel free to play
    with the Strength, Level, and Blur/Sharp parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/696f8e0f-fb80-444c-a70b-19f56bccd227.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the resulting **Normal** map as Battery_normal.jpg and add it to your Unity
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, select Battery_normal from the **Project** panel. Then, in the Inspector,
    change its Texture Type to Normal, leaving the Create from Grayscale box unchecked.
    Click on Apply to save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Project** panel, select the BatteryMaterial asset. In the Inspector
    for the Material component, assign Battery_normal to the Normal Map slot. To adjust
    its intensity and direction, change its value to -0.35:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6852b8d9-a6d2-4190-8128-94d87727ccc0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Normal Map was calculated from the grey values on the Heightmap, where the
    lighter tones were interpreted as recesses (applied to the top of the battery),
    and the darker tones as bulges (applied to the bottom). Since the desired output
    was actually the opposite, it was necessary to adjust the **Normal Map** to a
    negative value (-0.35). Another possible solution to the issue would have been
    to redraw the Heightmap and switch the colors for the white and black circles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Transparency and Emission maps to a material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Emission property can be used to simulate a variety of self-illuminated
    objects, from the LEDs of mobile displays to futuristic Tron suits. Transparency,
    on the other hand, can make the diffuse color of a **Material** more or less visible.
    In this recipe, you will learn how to configure these properties to produce a
    toy''s cardboard packaging that features a partially-transparent plastic case,
    cutouts (totally transparent), and glow-in-the-dark text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7c3c7b3-f5d3-435c-8d23-351c6d377f57.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we have prepared two files in the `05_04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'package.fbx: A 3D object of a package (FBX format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'card_diffuse_start.png: The diffused texture map for the packaging (PNG format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also provided are the two final, image-edited files you''ll create in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'card_diffuse.png: The Albedo texture map for the packaging with cutouts (PNG
    format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'card_emission.png: The Emission **Texture** map for the emission glow text
    (PNG format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add transparency and color emission maps to materials, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the card_diffuse_start **Texture**, naming the copy card_diffuse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** panel, drag the FBX model package into the **Hierarchy** to
    create a GameObject in the **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **Material** named m_card. Choose **Project** menu: Create | Material.
    Drag the card_diffuse **Texture** into the **Albedo** property of m_card.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select PackageCard (child of package), and assign it your
    new m_card Material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **Material** named m_plastic. Choose **Project** menu: Create
    | Material. Change its Rendering Mode to Transparent. Use the Diffuse color picker
    to change the color''s RGB values to 56/56/56, and Alpha to 25\. Change the Smoothness
    level to 0.9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67bf2148-5a0f-4bf8-bb50-690b74dc99f5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the **Hierarchy**, select PackagePlastic (child of package), and assign it
    your new m_plastic **Material**. The plastic portion of the 3D model should now
    appear partially transparent, as if made of plastic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the cutouts around the package and hang hole, we need to first prepare
    the diffuse image in an image editor (such as Photoshop). Open the card_diffuse
    **Texture** in your image editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will add transparency to the image by deleting the white areas around the
    package (and the hang hole). Make a selection of those areas (in Photoshop, this
    can be done with the Magic Wand Tool).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you unlock the Background layer by clicking on the lock icon, to
    the left of the layer''s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3193dd7a-0d15-4c7e-acef-b047d6fd03c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Delete the previously-made selection (this can be done in Photoshop by pressing
    the Delete key). The background of the image should be transparent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f5d88fc-5756-4257-983b-557600be7199.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your file in your image editor, and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the m_card **Material** in the Project panel. In the Inspector, change
    its Rendering Mode to Cutout, and adjust its Alpha Cutoff to 0.9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94e20698-938e-4418-b2b3-f0e074a5dce2.png)'
  prefs: []
  type: TYPE_IMG
- en: Choosing Cutout means that your material can be either invisible or fully visible,
    not allowing for semi-transparency. The **Alpha Cutoff** is used to get rid of
    unwanted pixels around the transparent borders.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work on the Emission map for the bright lettering. From the **Assets**
    folder, duplicate the card_diffuse.png **Texture**, rename it card_emission.png,
    and open it in your image editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all the characters from the Ms. Laser inscription and the green star
    (in Photoshop, this can be done with the **Magic Wand** tool, keeping the *Shift*
    key pressed while selecting multiple areas).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste your selection into a new layer. Then, select it and apply a
    Noise filter to it (in Photoshop, this can be done by navigating to Filter | Noise
    | Add Noise...). Use 50% as the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new layer and, using a tool such as the Paint Bucket, fill it with
    black (R: 0, G: 0, B: 0). Place this black layer beneath the one with the colored
    elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Flatten your image (in Photoshop this can be done by navigating to Layer |
    Flatten Image):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cfdc4c40-4740-45f2-8c94-8336c3c562cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your file in your image editor, and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the m_card **Material** in the **Project** panel. Check the Emission
    property – three new properties should appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A Texture slot**: Set this to Texture card_emission (drag asset file from
    the Project panel)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Color slot**: Set this to white (R: 255; G: 255; B: 255)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Global Illumination** **drop-down menu**: Ensure this is set to Baked (so
    that its glow won''t be added to the Lightmaps or influence the illumination in
    Real-Time):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/66b98314-62e5-4de4-bd8c-7123d7e32e5b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity is able to read four channels of a texture map: R (Red), G (Green), B
    (Blue), and A (Alpha). When set to Transparent or Cutout, the **Alpha Channel**
    of the diffuse texture map sets the transparency of the material according to
    each pixel''s brightness level (the Cutout mode will not render semi-transparency –
    only fully visible or invisible pixels).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn''t add an Alpha Channel – this is because Photoshop exports the PNG''s
    Alpha map based on its transparency. To help you visualize the Alpha map, the
    provided folder also contains the package_diffuse.tif (TIF format) Texture file;
    an image file featuring an Alpha map that works in exactly the same way as the
    PNG file that we have generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fa82fa6-c7d3-4810-befb-b3e8c7eae32f.png)'
  prefs: []
  type: TYPE_IMG
- en: Regarding the Emission texture map, Unity assigns its RGB colors to the Material,
    combining them with the appropriate color selection slot, and allows adjustments
    to the intensity of that Emission.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a little more information on Transparency and Emission.
  prefs: []
  type: TYPE_NORMAL
- en: Using texture maps with the Transparent Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please note that you can use a bitmap texture for the Diffuse map in the Transparent
    render mode. In this case, RGB values will be interpreted as the Diffuse color,
    while the Alpha will be used to determine that pixel's transparency (in this case,
    semi-transparent materials are allowed).
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding issues with the semi-transparent objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that the plastic case was made from two objects (PackagePlastic
    and innerPlastic). This was done to avoid z-sorting problems, where faces are
    rendered in front of other geometry when they should be behind it. Having multiple
    meshes instead of a single one allows these faces to be correctly sorted for rendering.
    **Materials** in the Cutout mode are not affected by this problem, though.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting light over other objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Emission value can be used to calculate the **Material's** light projection
    over other objects when using Lightmaps.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting materials at mouse-over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Changing the color of an object at runtime can be a very effective way of letting
    players know that they can interact with it. This is very useful in a number of
    game genres, such as puzzles and point-and-click adventures, and it can also be
    used to create 3D user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To highlight a material at mouse-over, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create **3D Cube** in the scene (Hierarchy menu: **Create | 3D Object | Cube**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new **Material** aaset named m_cube. Set its
    Albedo Color to red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy**, select the **Cube** GameObject, and assign it the m_cube
    **Material** (drag the asset from the Project panel).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named MouseOverHighlighter, and add an instance
    object as a component to the Cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the Cube selected, in the Mouse Over Highlighter (Script) component in
    the Inspector, you'll see the mouse-over color is yellow. You may wish to change
    this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the scene. The Cube will be highlighted red when the mouse is over it (and
    green when clicked on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Start()` method does four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Stores a reference to the MeshRenderer component in the `meshRenderer` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores a reference to the original Material of the GameObject in the `originalMaterial`
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new Material named mouseOverMaterial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the color of `mouseOverMaterial` to the color in the mouseOverColor public
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cube is automatically sent the mouse enter/exit events as the user moves
    the mouse pointer over and away from the part of the screen where the cube is
    visible. Our code adds a behavior to the cube when these events are detected.
  prefs: []
  type: TYPE_NORMAL
- en: When the `OnMouseOver` message is received, the method with that name is invoked,
    and the GameObject's material is set to `mouseOverMaterial`. When the `OnMouseExit` message
    is received, the GameObject's material is returned to `originalMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: The material property of the Renderer is a copy of the
  prefs: []
  type: TYPE_NORMAL
- en: If the Material of a GameObject is shared by several objects, we must be careful
    when changing Material properties to only change those we want to. If we wish
    to only change values for a particular GameObject, use the `.material` property
    of `Renderer` – since a separate clone is created if more than one object uses
    the same Material. If we want all GameObjects using the same Material to be affected
    by changes, use the `.sharedMaterial` property of `Renderer`. Since there was
    only one GameObject in this recipe, either could have been used.
  prefs: []
  type: TYPE_NORMAL
- en: Read more at[ https://docs.unity3d.com/ScriptReference/Renderer-material.html](https://docs.unity3d.com/ScriptReference/Renderer-material.html)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to enhance this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Collider needed for custom meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a primitive 3D Cube – this automatically has a Box Collider component.
    If you were to use the preceding script with a custom 3D mesh object, ensure the
    GameObject has a Physics | Collider component, so that it will respond to mouse
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse Down/Up events – for clicking color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend our code to also display a different color when an object is clicked
    on (mouse down/up events).
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the scripted `MouseOverHighlighter` from the Cube `GameObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named `MouseOverDownHighlighter`, and add an instance
    object as a component to the Cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are two public Colors: one for mouse-over and one for mouse-down (click)
    highlighting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Scene. You should now see different highlight colors when the mouse
    pointer is over the Cube, and when you click the mouse button when the mouse pointer
    is over the Cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are creating two new Materials, the reusable `NewMaterialWithColor(...)` C#
    method is included above, to simplify the content of the `Start()` method. A Boolean
    (true/false) variable has been introduced, so that the correct behavior occurs
    after the mouse button is released, depending on whether the mouse pointer is
    still over the object (`mouseOver = true`) or has moved away from the object (`mouseOver
    = false`).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Detail maps to a material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a large object, there is not only the desire to **Texture** it
    as a whole, but also to add details that can make it look better when viewed up
    close. To overcome the need for large, memory-hogging, highly-detailed texture
    maps, the use of Detail maps can make a real difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will add **Detail maps** to a rocket toy by applying a **Detail
    mask** and a **Detail Normal** map. In our case, we want to add a textured quality
    (and a stripe pattern) to the green plastic, except in the region where there
    is a battery compartment and the toy''s logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0992c355-f09f-42d9-bbc9-a91bca56df54.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we have prepared three files in the `05_06` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rocketToy.fbx: A 3D object of a package (FBX format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ship_diffuse.png: The diffused texture map for the rocket ship toy (PNG format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ship_height.png: The heightmap to be used to create a normal map (PNG format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also provided are the four final, image-edited files you''ll create in the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'detail_diffuse.png: The Albedo texture map for the packaging with cutouts (PNG
    format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'detail_height.png: The greyscale gradient circle – for the dimpled surface
    detail effect (PNG format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ship_mask.tif: The detail mask – indicating how much the text and battery holder
    appear raised up (TIF format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ship_mask2.tif: The detail mask – where the Alpha for the battery holder is
    greater, so no dimples will appear from `detail_height` (TIF format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the Detail maps to your object, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, select the rocketToy model asset. In the Inspector, click
    the `Materials` button and then click Extract Materials... Extract the model''s
    Materials into a new folder named `Materials`. You should now have five Materials
    for each part of the rocketToy model (`MAT_base/end/level1/2/3`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3705b1e-91b8-4d41-b41c-8d3ccce5f1fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Select **Mater****ial** MAT_rocketLevel1, and change the Shader to Standard
    (Specular setup). Drag the `ship_diffuse` Texture from the Project panel into
    the **Albedo** Texture slot in the Inspector properties for MAT_rocketLevel1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `rocketToy` model asset from the Project panel into the Scene panel
    (or Hierarchy) to add an instance of the model as a `GameObject` in the Scene.
    You should be able to see the image of the text of the toy's logo ("Rocket") and
    the battery compartment in level 1 (above the base).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the ship_diffuse Texture, naming the copy ship_mask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open ship_mask in your image editor. Select all the solid green pixels around
    the logo and battery compartment (in Photoshop, this can be done with the Magic
    Wand tool, keeping the *Shift* key pressed while selecting multiple areas):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2bd99e7e-351b-4815-8909-b43d6d25d6f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Keeping your selection active, access the image Channels window (in Photoshop,
    this can be done by navigating to Window | Channels). Click on New Channel. This
    will be our Alpha Channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d7a5008-c9f3-4627-bd0e-b0bcc735dfc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hide the Red, Green, and Blue channels. Select the Alpha Channel and paint
    the selection white. Select the area of the battery compartment and paint it grey
    (R, G, and B: 100):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/587ea264-1e9e-41bd-82b9-bbf9241713b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save it in the TIF format as ship_mask.tif, in the `Assets` folder. Make sure
    that you include Alpha Channels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e25e7cd6-5d2f-4853-9c87-3f2755c6cc8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the mask, let''s create a diffuse map for our detail. In your
    image editor, create a new image with the following dimensions: width: 64, and
    height: 64:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d4ef0c4-490e-4bc0-bd1c-3413ebbbcbce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fill the new image with grey (R, G, and B: 128). Use shapes or rectangular
    fills to create a dark grey (R, G, and B: 100) horizontal line that is about 16
    pixels tall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the image as detail_diff.png in the Assets folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new 64 x 64 image. Use a Gradient tool to create a black and white
    Radial Gradient (in Photoshop, this can be done with the Gradient Tool in Radial
    mode):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef807d3f-147d-4412-aaf7-5fbc1448224b.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the image as detail_height.png in the `Assets` folder. Return to the Unity
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `Assets` folder, select detail_height. In the Inspector, change its
    Texture Type to Normal map, check the Create from Grayscale option, adjust Bumpiness
    to 0.25, and set Filtering to smooth. Click on Apply to save the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2bce8852-1024-4696-82e0-e8698b83827d.png)'
  prefs: []
  type: TYPE_IMG
- en: Do the same for the ship_height Texture – in the Inspector, change its Texture
    Type to Normal map, check the Create from Grayscale option, adjust Bumpiness to
    `0.25`, and set Filtering to smooth. Click on Apply to save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `MAT_rocketLevel1` Material and view its properties in the Inspector.
    Set the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the ship_height **Texture** to the Normal Map slot, and set its intensity
    to `0.3`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the ship_mask **Texture** to the Detail Mask slot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the detail_diff **Texture** to Secondary Maps | Detail Albedo x 2.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the detail_height **Texture** as Secondary Maps | Normal Map, and set
    its intensity to `0.6`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Secondary Maps section, change the Tiling values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Tiling X to `200` and Y to `50`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set UV Set to UV1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Until we set UV Set to UV1, you might have noticed that the pattern was not
    seamless. This was because we were using the same UV Set from our Diffuse Texture.
    However, the object has been assigned to two different UV channels (back when
    it was being modelled). While UV channel 1 contains the mapping for our Diffuse
    map, UV channel 2 uses a basic cylindrical mapping. We need to change the **Secondary
    Maps** section's UV Set from UV0 to UV1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Detail map for your Material is ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00c84fc3-bc56-46f6-b4aa-be14a4a837bc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When in use, Secondary Maps are blended onto the Material''s primary Diffuse
    and Normal maps – that''s why our object is green even after the Diffuse Detail
    is applied: the grey tones are superimposed on the original Diffuse Texture. By
    using a Detail Mask, the artist defines which areas of the object should be affected
    by Secondary Maps. This is great for customization, and also for creating nuances
    (such as the semi-bumped battery compartment in our example).'
  prefs: []
  type: TYPE_NORMAL
- en: Another helpful feature is the possibility of using a separate UV channel for
    Details maps and Tiling. Besides adding variation to Texture mapping, this allows
    us to paint the details that can be perceived even at a very close distance by
    dramatically enhancing the visual quality of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: Fading the transparency of a material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A feature of many games is for objects to fade away to invisible, or appear
    gradually from invisible to fully visible. Unity provides the special Rendering
    Mode of Fade for exactly this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create an object that, once clicked, fades out and disappears.
    We'll also look at how to enahnce the code, to take account of the GameObject's
    own initial alpha value, to self-destruct when fading has finished and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **3D Sphere**, named Sphere-Game. Choose menu: 3D Object | Sphere.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Sphere-Game and ensure it has a Collider (if you are using a custom
    3D object, you might have to add a collider through menu: Add Component | Physics
    | Box (or Mesh) Collider).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material named m_fade.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the m_fade **Material** selected, change its Rendering Mode to Fade in
    the Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c51d7b1-d92d-4c4f-95fd-a3447b3906d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Fade** rendering mode is specifically designed for situations such as
    this. Other rendering modes, such as Transparent, will turn the Albedo color transparent,
    but not the specular highlights nor the reflections, in which case the object
    will still be visible.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the m_fade **Material** to Sphere-Game by dragging it from the Project
    panel into the Sphere-Game GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named FadeAway and add an instance object as a
    component to Sphere-Game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Play your Scene and click on the Sphere to see it fade away and self-destruct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The opaqueness of the material using a transparent **Shader** is determined
    by the **alpha** value of its main **color**. This recipe is based around changing
    the Alpha value of the **Color** of the **MeshRenderer**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three public variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fadeDurationSeconds`: The time in seconds we want our fading to take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alphaStart`: The initial alpha (transparency) we want the GameObject to start
    with (1 = fully visible, 0 = invisible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alphaEnd`: The alpha value we want to fade the GameObject into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UpdateMaterialAlpha(...)` method updates the alpha value of the GameObject's
    Color object with the given value by updating the alpha value of the `fadeColor`
    Color variable, and then forcing the MeshRenderer Material to update its Color
    value to match those in fadeColor.
  prefs: []
  type: TYPE_NORMAL
- en: When the Scene begins, the `Start()` method caches a reference to the MeshRenderer
    component (the `meshRenderer` variable), and also the Color object of the Material
    of the MeshRenderer (the `fadeColor` variable). Finally, the GameObject's alpha
    is set to match the value of variable alphaStart, by invoking the `UpdateMaterialAlpha(...)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnMouseUp()` method is invoked when the user clicks the GameObject with
    their mouse. This invokes the `StartFading()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The actions to start fading weren't simply put in this method, since we may
    also wish to start fading due to some other events (such as keyboard clicks, a
    timer hitting some value, or an NPC changing into some mode such as dying). So
    we separate the logic that detects that event that we are interested has taken
    place, with the actions we wish to perform, in this case to start the fading process.
  prefs: []
  type: TYPE_NORMAL
- en: The `StartFading()` method records the current **Time**, since we need that
    to know when to finish fading (time when we started fading + fadeDurationSeconds).
    Also the isFading Boolean flag is set to true, so logic elsewhere relating to
    fading will know it's time to do things.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method, called each frame, tests whether the `isFading` flag
    is true. If it is, the `FadeAlpha()` method is invoked for each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FadeAlpha()` method is where the majority of our alpha-fading logic is
    based:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeFading` is calculated: The time since we started fading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadePercentage` is calculated: How far we are from start (0) to finish (1)
    of our fading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'alpha is calculated: The appropriate alpha value for our fade percentage, using
    the `Lerp(...)` method to choose an `intermedia` value based on a `0..1` percentage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UpdateMaterialAlpha(...)` method with the new alpha value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If fading has finished (`fadePercentage` >= 1), we set the `isFading` Boolean
    flag to false to indicate this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to enhance our fading features.
  prefs: []
  type: TYPE_NORMAL
- en: Start with keypress and fade in from invisible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code can fade in from invisible (`alphaStart` = 0) to fully visible
    (`alphaEnd` = 1). However, if we can''t see the object initially, then it''s a
    bit much to ask the player to click an invisible Sphere! So let''s add code to
    the `Update()` method (checked each frame) to detect when the *F* key is pressed,
    as an alternative way to start our fading process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Destroy object when fading complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If fading to invisible is how a GameObject communicates to the player that it
    is leaving the scene (completed/dying), then we may want that GameObject to be
    Destroyed after the fading process is completed. Let's add this feature to our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new public Boolean variable to our script (default to false):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `EndFade()` method, which sets `isFading` to `false`, and then tests
    whether the public `destroyWhenFadingComplete` variable was set to true, and if
    so, Destroys the GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Refactor the `FadeAlpha()` method so that it invokes `EndFade()` when the fading
    is completed (`fadeProgress >= fadeDurationSeconds`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using GameObect's alpha as our starting alpha value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may be that the game designer has set the alpha value of a GameObject in
    the Inspector to the initial value they want. So let's enhance our code to allow
    this to be indicated by checking a public Boolean flag variable in the **Inspector**,
    and adding code to read and use the GameObject's alpha if that option is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Inspector**, click the Color picker for the Material Albedo, and set
    the `Alpha` value to something other than 255 (for example, set to 32, which is
    mostly transparent):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44bd6cbf-10ea-4cab-84c3-f3a4e6dc1862.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new public Boolean variable to our script (default to false):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add logic to the `Start()` method so that if this flag is true, we use the
    alpha value of the Color read from the GameObject''s Material as the Scene begins
    (`fadeColor.a`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using a coroutine for our fading loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where possible, we should avoid adding code in the `Update()` method, since
    this is invoked every frame, and so can reduce the performance of our games, especially
    if many objects have scripted components with `Update()` methods, all testing
    flags every frame.
  prefs: []
  type: TYPE_NORMAL
- en: One very effective solution is to invoke a coroutine when we want some actions
    performed over several frames, since a coroutine can perform some actions, then
    yield control back to the rest of the Scene, and then resume its actions from
    the point it left off previously, and so on until its logic is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `Update()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new using statement at the top of the script class, since coroutines
    return an `IEnumerator` value, which is part of the `System.Collections` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Refactor the `StartFading()` method, so that is starts our coroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That's it – once the coroutine has been started, it will be called each frame
    until it completes its logic, temporarily suspending its execution each time a
    yield statement is executed.
  prefs: []
  type: TYPE_NORMAL
