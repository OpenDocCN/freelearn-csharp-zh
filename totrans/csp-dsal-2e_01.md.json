["```cs\n// See https://aka.ms/new-console-template\n   for more information\nConsole.WriteLine(\"Hello, World!\");\n```", "```cs\nHello, World!\n```", "```cs\nnamespace GettingStarted\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello, World!\");\n        }\n    }\n}\n```", "```cs\nint a = -20;\nbyte b = 0x0f;\nuint c = 0b01101110;\n```", "```cs\nfloat temperature = 36.6f;\ndouble reading = -4.5178923;\ndecimal salary = 10000.47M;\n```", "```cs\nbool isTrue = true;\nbool first = isTrue || false;  // true\nbool second = isTrue && false; // false\nbool third = true and false values, but also the null. In such circumstances, you can benefit from the nullable Boolean type (bool?), which also supports three-valued logic. You’ll learn more about nullable value types later.\nUnicode characters\nThe last built-in value type we’ll mention here is the `Char` type or the `char` keyword. It represents a single Unicode character.\nImagine a character\nIf you want to understand what a Unicode character is, please write your first name on a piece of paper, separating the following letters. Each one is a character – for example, `M`, `a`, `r`, `c`, `i`, and `n`. You can use also a character to indicate the gender of a person – that is, `m` (for male), `f` (for female), and `o` (for other). As we are talking about UTF-16 encoding, a lot more values can be stored using a `char` variable, including symbols such as `©`, `﷼`, or `ϔ`. But that’s not all – you can use also geometric symbols, such as `▶` and `◉`, or even mathematical ones, such as `⅖` or `∑`.\nA `char` value can be specified using the following:\n\n*   `'a'` or `'M'`\n*   `\\u` – for example, `'\\u25cf'` for `●`\n*   `\\x` – for example, `'\\x107'` for `ć`\n\nThe exemplary code snippet is as follows:\n\n```", "```cs\nconst int DaysInWeek = 7;\n```", "```cs\n0. This means that the Pln constant is equal to 0, while Eur is equal to 2. What’s more, the default value for the enumeration is 0, which means that it is Pln in this case.\nYou can use the defined enumeration as a data type, as follows:\n\n```", "```cs\n\n Please keep in mind that if you place the preceding code in the `Program.cs` file – that is, the line containing the enumeration definition and then a few lines of code with the `switch` statement – you will receive an error stating **Top-level statements must precede namespace and type declarations**. This means that the declaration of the enumeration declaration must be placed at the end of the code, as shown here:\n\n```", "```cs\n\n This note is not related to enumerations only as you could receive a similar error while using other types, such as records or classes. So, please remember the rule and **place type declaration at the end**, even if they are presented in this book before the remaining code.\nShould you add all the code to one file?\nIn simple exemplary applications, there’s nothing wrong with placing all the code within one file. However, if you are developing something even a bit more complex, I strongly encourage you to divide the whole solution into suitable projects, as well as to **put various type declarations in separate files**. When you need to create types (for example, enumerations, classes, or records) while reading the remaining parts of this book, it is assumed that you add them to new files. Each file should be named the same as the type that is declared within it. From my point of view, writing code has some similarities to creating art, so let’s try to **write beautiful code that is not only correct and tested but also greatly arranged** **and organized**!\nYou can also benefit from more advanced features of enumerations, such as changing the underlying type or specifying values for particular constants. You can even do more and use the enumeration as a **bit field** – that is, as a set of **flags** – as presented here:\n\n```", "```cs\n\n Here, you can see the `ActionEnum` enumeration, which represents various actions that are allowed for users of the blog module, such as listing posts, showing details of a particular post, as well as adding, editing, deleting, and publishing a post. The constants have the following powers of two assigned, starting with `0` (`None`). The values are 20 (`1`), 21 (`2`), 22 (`4`), 23 (`8`), 24 (`16`), and 25 (`32`). These values are provided using the binary literal. Have you noticed that in each binary value, the `1`s are located in different places and everywhere there is only one `1`? Thanks to this, you can freely combine various flags, simply by using the `OR` binary operation, which is indicated by the `|` operator, as shown here:\n\n```", "```cs\n(int, int, double) result = Calculate(4, 8, 13);\nConsole.WriteLine($\"Min = {result.Item1}\n    / Max = {Item1, Item2, and Item3 fields. The result is as follows:\n\n```", "```cs\n\n If you don’t want to use `Item1`, `Item2`, and so on, you can change the code to specify the names of variables, as presented here:\n\n```", "```cs\n\n Here, we’ll **deconstruct** a tuple by explicitly declaring the type and name of each field. If you execute the code, the result in the console will be the same as what it was previously. So far, you know how to get a result value that is a value tuple type, but how can you initialize it and return it from the method? Let’s take a look:\n\n```", "```cs\n\n You can further simplify the code and make it more readable by specifying an **alias** for this value tuple type. You can do so by using the following line of code:\n\n```", "```cs\n\n Then, it can be used in the remaining part of the code, as follows:\n\n```", "```cs\n\n You can call the `Calculate` method as follows:\n\n```", "```cs\n\n Now that you understand how value tuples work, let’s move on to the next data type.\nUser-defined structs\nApart from using the previously mentioned value types, you can create **data-centric struct types** (also named **structure types**) and use them in your applications.\nImagine a struct\nIf you want to better visualize a data-centric struct type, think about the readings that are obtained from a weather station. A single reading consists of the current values of temperature, pressure, and humidity. You can specify a type for such readings as a user-defined struct type with three immutable data members, namely for temperature, pressure, and humidity. Such values cannot be changed once you’ve received the results from the weather station.\nStructs have some of the same capabilities as classes, which we’ll cover later. However, there are some differences – for example, a structure does not support inheritance. Despite the similarities to classes, you should only use structs in scenarios when a type does not provide behavior or provide it in a small amount.\nThis means that `readonly` modifier for the whole structure and all its data members, as shown here:\n\n```", "```cs\n\n Here, we define the `Price` immutable struct type, which has two auto-implemented read-only properties, specified using the `init` accessor. This allows us to set a value for such properties during the object’s construction and restrict later modifications. The struct type has also its own implementation of the `ToString` method, formatting the object as the amount and currency, separated by space. There is also a constructor with two parameters that sets the values of both properties.\nYou can make this code a bit shorter, as follows:\n\n```", "```cs\n\n Don’t forget about the declaration of the `CurrencyEnum` enumeration, together with the `public` access modifier, as follows:\n\n```", "```cs\n\n The usage of the `Price` struct is quite simple:\n\n```", "```cs\n\n The result that’s shown in the console is as follows:\n\n```", "```cs\n\n Since we’re talking about struct types, it is worth noting the `with` **expression****, which allows you to create a copy of a structure type instance, together with changing values of some properties and fields**. You can achieve this using the **object initializer syntax** **while specifying** **which members should be modified and what values should be assigned**. Let’s take a look at the following code:\n\n```", "```cs\nint? age = 34;\nfloat? note = 5.5f;\nnull, you can compare it with null or use the HasValue property. Then, you can get a value using the Value property, as presented here:\n\n```", "```cs\nint chosenAge = age ?? 18;\nfloat shownNote = note.age variable is not null, it is assigned to chosenAge. Otherwise, 18 is set. In the second line of code, the note value is assigned to shownNote if it is not null. Otherwise, 5.0f is applied. Seems simple, doesn’t it?\nWhile talking about the null-coalescing operator (`??`), you should also take a look at the `??=`. `??` operator, as presented in the following code:\n\n```", "```cs\n\n Since we’re presenting various `null`-related operators, let’s introduce the **null conditional operator** as well. **It is represented by the** **?.** **operator and returns** **null** **if the left-hand side operand is** **null****. Otherwise, it is used as a standard dot operator**. An example is as follows:\n\n```", "```cs\nint age = 28;\nobject ageBoxing = age;\nint ageUnboxing = ageBoxing to bool instead of int, the code compiles without any errors. However, it fails at runtime with a System.InvalidCastException error. The additional message informs you that it is impossible to cast an object of the System.Int32 type to the System.Boolean type.\nStrings\nThere is often a necessity to store some text values. You can achieve this using the `String` built-in reference type from the `System` namespace, which is also available using the `string` keyword. The `string` type is `string` variable can be set to `null`.\nImagine a string\nIf you want to better visualize a string, take a look at this sentence. It is a string! Your first name is a string too. Close this book for a moment and take a look out of your window. The name of your street is a string. That’s not all – even a car number plate is a string. It is one of the most common types that you’ll use frequently while developing applications, so please read this chapter and this book carefully since all the text in this book is a string as well!\nYou can perform various operations on `string` objects, such as `[]` operator, as shown here:\n\n```", "```cs\n\n First, the `firstName` variable is declared, and the `Marcin` value is assigned to it. Similarly, `Jamro` is set as a value of the `lastName` variable. In the third line, we concatenate five elements (using the `+` operator), namely the current value of `firstName`, the space, the current value of `lastName` converted into uppercase (by calling `ToUpper`), the `was born in` string (with additional spaces), and the current value of `year`. In the last line, the first characters of the `firstName` and `lastName` variables are obtained using the `[]` operator, as well as concatenated with two dots to form the initials – that is, `M.J.` – which are stored as a value of the `initials` variable.\nThe `Format` method can also be used for constructing this string, as shown here:\n\n```", "```cs\n\n In this example, we specify the `firstName` (represented by `{0}`), uppercase `lastName` (`{1}`), and `year` (`{2}`). The objects to format are specified as the following parameters of the method.\nIt is also worth mentioning the `$` character should be placed before `\"`, as shown in the following example:\n\n```", "```cs\nstring[] names = [\"Marcin\", \"Adam\", \"Martyna\"];\nDateTime[] dates = [new(1988, 11, 9), new(1995, 4, 25),\n    new(2003, 7, 24)];\nfloat[] temperatures = [36.6f, 39.1f, 35.9f];\nConsole.WriteLine($\"{\"Name\",-8} {\"Birth date\",10}\n    {\"Temp. [C]\",11} -> Result\");\nfor (int i = 0; i < names.Length; i++)\n{\n    string line = $\"{names[i],-8} {dates[i],10:dd.MM.yyyy}\n        {temperatures[i],11:F1} -> {\n        temperatures[i] switch\n        {\n            > 40.0f => \"Very high\",\n> 37.0f => \"High\",\n            > 36.0f => \"Normal\",\n            > 35.0f => \"Low\",\n            _ => \"Very low\"\n        }\n    }\";\n    Console.WriteLine(line);\n}\n```", "```cs\nName     Birth date   Temp. [C] -> Result\nMarcin   09.11.1988        36.6 -> Normal\nAdam     05.04.1995        39.1 -> High\nMartyna  24.07.2003        35.9 -> Low\n```", "```cs\npublic class Person\n{\n    private string _location = string.Empty;\n    public string Name { get; set; }\n    public required int Age { get; set; }\n    public Person() => Name = \"---\";\n    public Person(string name)\n    {\n        Name = name;\n    }\n    public void Relocate(string location)\n    {\n        if (!string.IsNullOrEmpty(location))\n        {\n            _location = location;\n        }\n    }\n    public float GetDistance(string location)\n        => DistanceHelpers.GetDistance(_location, location);\n}\n```", "```cs\nPerson person = new(\"Martyna\") { Age = 20 };\nperson.Relocate(\"Rzeszow\");\nfloat distance = person.GetDistance(\"Warsaw\");\n```", "```cs\npublic class Person(string name)\n{\n    private string _location = string.Empty;\n    public string Name { get; set; } = name;\n    public required int Age { get; set; }\n    public void Relocate(string? location) =>\n        _location = location ?? _location;\n    public float GetDistance(string location) =>\n        DistanceHelpers.GetDistance(_location, location);\n}\n```", "```cs\npublic record Dog(string Name, string Breed, int Height,\n    float Weight, int Age);\n```", "```cs\nDog rex = ToString method, which is a nice feature while debugging because you can easily see the values of all properties. To see how it works, add the following line of code:\n\n```", "```cs\n\n The result is as follows:\n\n```", "```cs\n\n As you can see, the name of the record is shown, together with the names and values of the following properties. Please keep in mind that properties are defined with `get` and `init` accessors, so their values can be read and cannot be changed after they are initialized. So, the following line will cause a compiler error:\n\n```", "```cs\n\n If you want to change this behavior, you can do so with a record without positional parameters on the record declaration, but by defining the particular properties using the standard syntax, as shown here:\n\n```", "```cs\n\n Another useful feature is a clear syntax for `with` expression, as shown here:\n\n```", "```cs\nName and Age positional properties, ignoring others using _. As you can see, records are equipped with a lot of useful features, but there are even more of them, such as the support for inheritance.\nInterfaces\nPreviously, we mentioned classes. They can implement one or more **interfaces**. This means that such a class must implement all methods, properties, events, and indexers that are specified in all implemented interfaces.\nImagine an interface\nIf you want to remember what an interface is, think about various things that you have on yourself, including a shirt, pants, and a watch. As all of these things have different sets of properties, you can create a dedicated class for each of them. However, how can you indicate which things can be worn and which can be washed in a washing machine? You can mark various classes with special indicators, such as “wearable” and “washable.” This is where interfaces come to the rescue! You can create `IWearable` and `IWashable` interfaces. Then, you can implement `IWearable` by `Shirt`, `Pants`, and `Watch`, as well as implement `IWashable` by `Shirt` and `Pants` only. You can also require that everything washable must have a property regarding a maximum temperature for washing in a washing machine. Looks nice, doesn’t it? But that’s not all – you can also create a class regarding a washing machine with the `Wash` method, which takes the `IWashable` parameter, so you can pass `Shirt` or `Pants`. No watches are allowed here! Is this magic?\nYou can easily define interfaces in the C# language using the `interface` keyword:\n\n```", "```cs\n\n The `IDevice` interface contains three properties representing the following:\n\n*   A device model (`Model`)\n*   A serial number (`Number`)\n*   A production year (`Year`).\n\nWhat’s more, it contains the signatures of three methods:\n\n*   `Configure` for device setup. Please note that the `DeviceConfiguration` class is missing here, so try to prepare it on your own.\n*   `Start` for starting the operation.\n*   `Stop` for stopping the operation.\n\nWhen a class implements the `IDevice` interface, it should contain all of these properties and methods, as presented in the following code snippet:\n\n```", "```cs\n\n As you can see, the `Display` class contains all of the properties and methods specified in the interface it implements. However, you can add more elements to the class according to your preferences, such as the `Diagonal` property in this example.\nDelegates\nThe `delegate` reference type **specifies the required signature of** **a method**.\nImagine a delegate\nIf you want to understand what a delegate type is, think about various ways of calculating the mean of three numbers. You can get it as an arithmetic mean, as a geometric mean, as a harmonic mean, or even as a root mean square or a power mean. However, in all of these cases, you need a function that takes three parameters (for three numbers) and returns a number as the result. In this case, you can understand a delegate as a template for a way of calculating any of the mentioned means. Then, you can prepare an exact implementation of each calculation.\nThe delegate could then be instantiated, as well as invoked, as shown here:\n\n```", "```cs\n6.17 / 6.10 / 6.04\n```", "```cs\ndynamic posts = await GetPostsAsync();\nforeach (dynamic post in posts)\n{\n    string title = post.title;\n    Console.WriteLine($\"Title: {title}\");\n}\nTask<GetPostsAsync method. The result is assigned to the posts variable with the dynamic type. Thus, we bypass dynamic type allows you to significantly limit the amount of code, but it should be used with caution.\nStrongly typed features are cool!\nThe strongly typed features of the C# language give you great development support. Both errors and warnings are useful as they help you make your code robust and more reliable. Remember that warnings are not something that should exist in the production version of your application. You should always try to decrease the number of warnings to zero, as well as take into account various hints provided by the IDE.\nIn the preceding code, the `await` keyword is used. It is related to `async` keyword. The `await` operator is placed in the line where the `GetPostsAsync` method is called. This means that the evaluation of the code is suspended until the asynchronous operation of getting posts from an external API is completed. Then, the `await` operator returns the collection of posts.\nAsynchronous programming is cool too!\nAsynchronous programming is a very interesting and powerful topic and is crucial for the development of robust and highly efficient applications. This topic also involves the `ConcurrentQueue`, which will be covered in [*Chapter 5*](B18069_05.xhtml#_idTextAnchor165), *Stacks and Queues*), as well as some **synchronization primitives**.\nAre you ready to proceed to the last type that will be described in this chapter? If so, let’s go!\nNullable reference types\nNow that we’ve come to the end of this section regarding reference types, let’s take a look at `System.NullReferenceException` type. It is thrown when you access one of the members of a variable using the dot operator (`.`), when a variable is `null`. When using a new feature, you can explicitly mark a reference type as nullable using the `?` operator, similarly as in the case of nullable value types.\nImagine a nullable reference type\nIf you want to understand what nullable reference types are, just remind yourself that reference types allow `null` values. So, why am I talking about nullable reference types? They are a special feature that tells you “*Be careful, it could be null!*” Using nullable reference types could sometimes seem to be an unnecessary complication for reference types. However, when using them for a longer period, you will see that they have a positive impact on your code’s quality and allow you to pay more attention to null reference issues and therefore could limit the number of errors while the program is running. I recommend that you familiarize yourself with this feature, even if it can be quite cumbersome at the beginning. I like it! What about you?\nThis feature is equipped with `null`, so the mechanism emits a warning that can be solved by you. The first solution is to add a conditional statement that checks whether the value is not equal to `null`. Another way is to use the `!`), when you are certain that the variable is not `null` here.\nLet’s take a look at an example:\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```"]