<html><head></head><body>
<div id="_idContainer113">
<h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-144"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.2.1">Exploring Graphs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, you learned about trees. </span><span class="koboSpan" id="kobo.3.2">However, did you know that such data structures also belong to graphs? </span><span class="koboSpan" id="kobo.3.3">But what is a graph and how can you use one in your applications? </span><span class="koboSpan" id="kobo.3.4">You’ll find the answers to these and many other questions in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">this chapter!</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">First, basic information about graphs will be presented, including an explanation of </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">nodes</span></strong><span class="koboSpan" id="kobo.7.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">edges</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">As graphs are data structures that are commonly used in practice, you will also see some of their applications, such as for storing data of friends on social media or for finding a road in a city. </span><span class="koboSpan" id="kobo.9.3">Then, the topic of graph </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">representation</span></strong><span class="koboSpan" id="kobo.11.1"> will be covered, namely using an adjacency list </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and matrix.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">After this short introduction, you will learn how to implement a graph in the C# language. </span><span class="koboSpan" id="kobo.13.2">Moreover, you will learn about two modes of graph </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">traversal</span></strong><span class="koboSpan" id="kobo.15.1">, namely </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">depth-first search</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.18.1">DFS</span></strong><span class="koboSpan" id="kobo.19.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">breadth-first search</span></strong><span class="koboSpan" id="kobo.21.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.22.1">BFS</span></strong><span class="koboSpan" id="kobo.23.1">). </span><span class="koboSpan" id="kobo.23.2">For both of them, the code and a detailed description will </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">be shown.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Next, you will learn about the subject of </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">minimum spanning trees</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">MSTs</span></strong><span class="koboSpan" id="kobo.29.1">), as well as two algorithms for their</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.30.1"> creation, namely Kruskal’s and Prim’s. </span><span class="koboSpan" id="kobo.30.2">Such algorithms will be presented as descriptions, code snippets, and illustrations. </span><span class="koboSpan" id="kobo.30.3">Moreover, an example real-world application will </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">be provided.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Another interesting graph-related problem is the </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">coloring</span></strong><span class="koboSpan" id="kobo.34.1"> of nodes, which will be taken into account in the following part of this chapter. </span><span class="koboSpan" id="kobo.34.2">Finally, the topic of finding the </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">shortest path</span></strong><span class="koboSpan" id="kobo.36.1"> in a graph will be analyzed using </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Dijkstra’s algorithm.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">As you can see, the topic of graphs involves many interesting problems and only some of them will be mentioned in this book. </span><span class="koboSpan" id="kobo.38.2">However, the chosen subjects are suitable for presenting various graph-related aspects in the context of the C# language. </span><span class="koboSpan" id="kobo.38.3">Are you ready to dive into the topic of graphs? </span><span class="koboSpan" id="kobo.38.4">If so, start reading </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">this chapter!</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">In this chapter, the following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">be covered:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.42.1">The concept </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">of graphs</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Applications</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.45.1">Representations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.46.1">Implementation</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Traversal</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Minimum </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">spanning tree</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Coloring</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.51.1">Shortest pat</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.52.1">h</span></span><a id="_idTextAnchor299"/></li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.53.1">The concept of graphs</span></h1>
<p><span class="koboSpan" id="kobo.54.1">Let’s start with the question </span><em class="italic"><span class="koboSpan" id="kobo.55.1">what is a graph?</span></em><span class="koboSpan" id="kobo.56.1"> Broadly speaking, </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">a graph is a data structure that consists of </span></strong><strong class="bold"><span class="koboSpan" id="kobo.58.1">nodes</span></strong><strong class="bold"><span class="koboSpan" id="kobo.59.1"> (also called </span></strong><strong class="bold"><span class="koboSpan" id="kobo.60.1">vertices</span></strong><strong class="bold"><span class="koboSpan" id="kobo.61.1">) and </span></strong><strong class="bold"><span class="koboSpan" id="kobo.62.1">edges</span></strong><strong class="bold"><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">Each edge connects two nodes</span></strong><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">A graph</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.65.1"> data structure does not require any specific </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.66.1">rules regarding</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.67.1"> connections between nodes, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.69.1"><img alt="Figure 8.1 – Illustration of a graph" src="image/B18069_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.70.1">Figure 8.1 – Illustration of a graph</span></p>
<p><span class="koboSpan" id="kobo.71.1">This concept seems very simple, doesn’t it? </span><span class="koboSpan" id="kobo.71.2">Let’s try to analyze the preceding graph to eliminate any doubts. </span><span class="koboSpan" id="kobo.71.3">It contains </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">9 nodes</span></strong><span class="koboSpan" id="kobo.73.1"> with numbers between </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">1</span></strong><span class="koboSpan" id="kobo.75.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">9</span></strong><span class="koboSpan" id="kobo.77.1"> as values. </span><span class="koboSpan" id="kobo.77.2">Such nodes are connected by </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">11 edges</span></strong><span class="koboSpan" id="kobo.79.1">, such as between nodes </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">2</span></strong><span class="koboSpan" id="kobo.81.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">4</span></strong><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">Moreover, a graph can contain </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">cycles</span></strong><span class="koboSpan" id="kobo.85.1"> – for example, with</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.86.1"> nodes indicated by </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">2</span></strong><span class="koboSpan" id="kobo.88.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">3</span></strong><span class="koboSpan" id="kobo.90.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">4</span></strong><span class="koboSpan" id="kobo.92.1"> – as well as separate groups of nodes, which are </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">not connected.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">However, what about the topic of parent and child nodes, which you know from learning about trees? </span><span class="koboSpan" id="kobo.94.2">As there are no specific rules about connections in a graph, such concepts are not used in </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">this case.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.96.1">Imagine a graph</span></p>
<p class="callout"><span class="koboSpan" id="kobo.97.1">If you want to better visualize a graph, take your eyes off this book for a moment and look at a map showing the most important roads in your country, such as highways or expressways. </span><span class="koboSpan" id="kobo.97.2">Each fragment of such a road connects two towns and has a certain length. </span><span class="koboSpan" id="kobo.97.3">Once you have drawn such a structure on a piece of paper, you will see that thanks to it, you can find a route between two towns, along with the total distance of the entire route. </span><span class="koboSpan" id="kobo.97.4">Did you know you just created a graph? </span><span class="koboSpan" id="kobo.97.5">Individual towns are nodes, and the lines connecting them are edges. </span><span class="koboSpan" id="kobo.97.6">The distance between the two towns is the edge weight. </span><span class="koboSpan" id="kobo.97.7">It’s so simple when you can relate theory to practice, isn’t it? </span><span class="koboSpan" id="kobo.97.8">Now, it’s high time to put the map aside and focus on learning about the last data structure that will be covered in this book, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">the graph.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Some more comments are necessary</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.100.1"> for edges in a graph. </span><span class="koboSpan" id="kobo.100.2">In the preceding diagram, you can </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.101.1">see a graph where all the nodes are connected with </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">undirected edges</span></strong><span class="koboSpan" id="kobo.103.1"> – that is, </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">bidirectional edges</span></strong><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">They indicate that </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">it is possible to travel between nodes in both directions</span></strong><span class="koboSpan" id="kobo.107.1"> –  for example, from node </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">2</span></strong><span class="koboSpan" id="kobo.109.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">3</span></strong><span class="koboSpan" id="kobo.111.1"> and from node </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">3</span></strong><span class="koboSpan" id="kobo.113.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">2</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">Such edges </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.116.1">are presented </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.117.1">graphically as </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">straight lines</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">When a graph contains undirected edges, it is an </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.120.1">undirected graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">However, what about a scenario when you need to indicate that </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">traveling between nodes is possible only in one direction</span></strong><span class="koboSpan" id="kobo.124.1">? </span><span class="koboSpan" id="kobo.124.2">In such a case, you can use </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">directed edges</span></strong><span class="koboSpan" id="kobo.126.1"> – that is, </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">unidirectional edges</span></strong><span class="koboSpan" id="kobo.128.1"> – which </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.129.1">are presented graphically</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.130.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">straight lines with arrows indicating the direction of an edge</span></strong><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">If a graph </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.133.1">contains directed edges, it can be named a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.134.1">directed graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.136.1">What about self-loops?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.137.1">A graph can also contain </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">self-loops</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">Each is an </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.140.1">edge that connects a given node with itself. </span><span class="koboSpan" id="kobo.140.2">However, such a topic is outside the scope of this book and won’t be taken into account in the examples shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">An example directed graph is presented in the following diagram on the right, while an undirected one is shown on </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the left:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.144.1"><img alt="Figure 8.2 – The difference between undirected and directed graphs" src="image/B18069_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.145.1">Figure 8.2 – The difference between undirected and directed graphs</span></p>
<p><span class="koboSpan" id="kobo.146.1">As a short explanation, the directed graph (shown on the right in the preceding diagram) contains </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">8 nodes</span></strong><span class="koboSpan" id="kobo.148.1"> connected by </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">15 unidirectional edges</span></strong><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">For example, they indicate that it is possible to travel between node </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">1</span></strong><span class="koboSpan" id="kobo.152.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">2</span></strong><span class="koboSpan" id="kobo.154.1"> in both directions, but it is allowed to travel from the node </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">1</span></strong><span class="koboSpan" id="kobo.156.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">3</span></strong><span class="koboSpan" id="kobo.158.1"> only</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.159.1"> in one direction, so it is impossible to reach node </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">1</span></strong><span class="koboSpan" id="kobo.161.1"> from </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.162.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> directly.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">The division between undirected and directed edges is not the only one. </span><span class="koboSpan" id="kobo.164.2">You can also specify </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">weights</span></strong><span class="koboSpan" id="kobo.166.1"> (also referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">costs</span></strong><span class="koboSpan" id="kobo.168.1">) for </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.169.1">particular edges to indicate the cost of traveling between nodes. </span><span class="koboSpan" id="kobo.169.2">Of course, such weights can be assigned to both undirected and directed edges. </span><span class="koboSpan" id="kobo.169.3">If weights are provided, an edge is</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.170.1"> named a </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">weighted edge</span></strong><span class="koboSpan" id="kobo.172.1">, and the whole graph is named a </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">weighted graph</span></strong><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">Similarly, if no weights are</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.175.1"> provided, </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">unweighted edges</span></strong><span class="koboSpan" id="kobo.177.1"> are used in a graph. </span><span class="koboSpan" id="kobo.177.2">This</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.178.1"> graph is then</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.179.1"> called an </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.180.1">unweighted graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Some example weighted graphs with undirected (on the left) and directed (on the right) edges are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.184.1"><img alt="Figure 8.3 – Difference between weighted undirected and weighted directed graphs" src="image/B18069_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.185.1">Figure 8.3 – Difference between weighted undirected and weighted directed graphs</span></p>
<p><span class="koboSpan" id="kobo.186.1">This graphical presentation of a weighted edge shows the weight of an edge next to the line. </span><span class="koboSpan" id="kobo.186.2">For example, the cost of traveling from node </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">1</span></strong><span class="koboSpan" id="kobo.188.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">2</span></strong><span class="koboSpan" id="kobo.190.1">, as well as from node </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">2</span></strong><span class="koboSpan" id="kobo.192.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">1</span></strong><span class="koboSpan" id="kobo.194.1">, is equal to </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">3</span></strong><span class="koboSpan" id="kobo.196.1"> in the case of the undirected graph, shown on the left in the preceding diagram. </span><span class="koboSpan" id="kobo.196.2">The situation is a bit more complicated in the case of the directed graph (on the right). </span><span class="koboSpan" id="kobo.196.3">Here, you can </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.197.1">travel from node </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">1</span></strong><span class="koboSpan" id="kobo.199.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">2</span></strong><span class="koboSpan" id="kobo.201.1"> with a cost equal to </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">9</span></strong><span class="koboSpan" id="kobo.203.1">, while traveling in the opposite direction (from node </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">2</span></strong><span class="koboSpan" id="kobo.205.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">1</span></strong><span class="koboSpan" id="kobo.207.1">) is much cheaper </span><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.208.1">a</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.209.1">nd costs </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">only </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.211.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.213.1">Applications</span></h1>
<p><span class="koboSpan" id="kobo.214.1">At this point, you know some basic information about graphs, especially regarding nodes and various kinds of edges. </span><span class="koboSpan" id="kobo.214.2">However, why is the topic of graphs so important and why does it take up a whole chapter in this book? </span><span class="koboSpan" id="kobo.214.3">Could you use this data structure in your applications? </span><span class="koboSpan" id="kobo.214.4">The answer is obvious: yes! </span><span class="koboSpan" id="kobo.214.5">Graphs are commonly used while solving algorithmic problems and have numerous </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">real-world applications.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">To start, let’s think about a </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">structure of friends available on social media</span></strong><span class="koboSpan" id="kobo.218.1">. </span><span class="koboSpan" id="kobo.218.2">Each user has many </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.219.1">contacts, but they also have many friends, and so on. </span><span class="koboSpan" id="kobo.219.2">What data structure should you choose to store such data? </span><span class="koboSpan" id="kobo.219.3">A graph is the simplest answer. </span><span class="koboSpan" id="kobo.219.4">In such a scenario, the nodes represent contacts, while the edges depict relationships between people. </span><span class="koboSpan" id="kobo.219.5">As an example, let’s take a look at the following diagram of an undirected and </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">unweighted graph:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.221.1"><img alt="Figure 8.4 – Illustration of a graph representing a structure of friends" src="image/B18069_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">Figure 8.4 – Illustration of a graph representing a structure of friends</span></p>
<p><span class="koboSpan" id="kobo.223.1">As you can see, </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Jimmy Gold</span></strong><span class="koboSpan" id="kobo.225.1"> has five contacts, namely </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">John Smith</span></strong><span class="koboSpan" id="kobo.227.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">Andy Wood</span></strong><span class="koboSpan" id="kobo.229.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">Eric Green</span></strong><span class="koboSpan" id="kobo.231.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">Ashley Lopez</span></strong><span class="koboSpan" id="kobo.233.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">Paula Scott</span></strong><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">In the meantime, </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Paula Scott</span></strong><span class="koboSpan" id="kobo.237.1"> has two other friends: </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">Marcin Jamro</span></strong><span class="koboSpan" id="kobo.239.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Tommy Butler</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">By using a graph as a data structure, you can easily check whether two people are friends or whether they have a </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">common contact.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Another common application of graphs involves the problem of </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">searching for the shortest path</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">Let’s imagine a program that should find a path between two points in the city, taking into account the time necessary for driving particular roads. </span><span class="koboSpan" id="kobo.245.3">In such a case, you can use a graph to present a map of a city, where nodes depict intersections and edges represent roads. </span><span class="koboSpan" id="kobo.245.4">Of course, you should assign weights to edges to indicate the time that’s necessary to drive a given road. </span><span class="koboSpan" id="kobo.245.5">The topic of searching the shortest path can be understood as finding the list of edges from the source to the target node, with the minimum total cost. </span><span class="koboSpan" id="kobo.245.6">A diagram of a city map, based on a graph, is </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.247.1"><img alt="Figure 8.5 – Illustration of a graph representing a city map" src="image/B18069_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Figure 8.5 – Illustration of a graph representing a city map</span></p>
<p><span class="koboSpan" id="kobo.249.1">As you can see, the directed and </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.250.1">weighted graph was chosen. </span><span class="koboSpan" id="kobo.250.2">Directed edges make it possible to support both two-way and one-way roads, while weighted edges allow you to specify the time necessary to travel between </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">t</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.252.1">w</span><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.253.1">o intersections.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.254.1">Representations</span></h1>
<p><span class="koboSpan" id="kobo.255.1">At this point, you know </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.256.1">what a graph is and when one can be used, but how can you represent one in the memory of a computer? </span><span class="koboSpan" id="kobo.256.2">There are two popular approaches to solve this problem, namely using an </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">adjacency list</span></strong><span class="koboSpan" id="kobo.258.1"> and an</span><a id="_idTextAnchor307"/> <a id="_idTextAnchor308"/><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.259.1">adjacency matrix</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.261.1">Adjacency list</span></h2>
<p><span class="koboSpan" id="kobo.262.1">The first approach</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.263.1"> requires you to </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">extend the data of a node by specifying a list of its neighbors</span></strong><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">Thus, you can easily get all the neighbors of a given node</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.266.1"> just by iterating through the adjacency list of a given node. </span><span class="koboSpan" id="kobo.266.2">Such a solution is space-efficient because you only store the data of adjacent edges. </span><span class="koboSpan" id="kobo.266.3">Let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.268.1"><img alt="Figure 8.6 – ﻿Adjacency list representing an undirected and unweighted graph" src="image/B18069_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.269.1">Figure 8.6 – Adjacency list representing an undirected and unweighted graph</span></p>
<p><span class="koboSpan" id="kobo.270.1">This example graph contains 8 nodes</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.271.1"> and 10 edges. </span><span class="koboSpan" id="kobo.271.2">For each node, a list of adjacent nodes (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">neighbors</span></strong><span class="koboSpan" id="kobo.273.1">) is created, as shown on the right-hand side of the diagram. </span><span class="koboSpan" id="kobo.273.2">For example, node </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">1</span></strong><span class="koboSpan" id="kobo.275.1"> has two neighbors, namely nodes </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">2</span></strong><span class="koboSpan" id="kobo.277.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">3</span></strong><span class="koboSpan" id="kobo.279.1">, while node </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">5</span></strong><span class="koboSpan" id="kobo.281.1"> has four </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.282.1">neighbors, namely nodes </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">4</span></strong><span class="koboSpan" id="kobo.284.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">6</span></strong><span class="koboSpan" id="kobo.286.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">7</span></strong><span class="koboSpan" id="kobo.288.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">8</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">As you can see, the representation based</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.291.1"> on the adjacency list for an undirected and unweighted graph is straightforward, as well as easy to use, understand, </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">and implement.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">But how does the adjacency list work in the case of a directed graph? </span><span class="koboSpan" id="kobo.293.2">The answer is obvious because the list that’s assigned to each node just shows adjacent nodes that can be reached from the given node. </span><span class="koboSpan" id="kobo.293.3">Here’s an </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">example diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.295.1"><img alt="Figure 8.7 – Adjacency list representing a directed and unweighted graph" src="image/B18069_08_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.296.1">Figure 8.7 – Adjacency list representing a directed and unweighted graph</span></p>
<p><span class="koboSpan" id="kobo.297.1">Let’s take a look at node </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">3</span></strong><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">Here, the adjacency list contains only one element – that is, node </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">4</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">Node </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">1</span></strong><span class="koboSpan" id="kobo.303.1"> is not included, because</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.304.1"> it cannot be reached directly from </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">node </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.306.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">A bit more clarification may be </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.309.1">useful in the case of a weighted graph. </span><span class="koboSpan" id="kobo.309.2">In such a case, it is also necessary to store weights for particular edges. </span><span class="koboSpan" id="kobo.309.3">You can achieve this by extending data stored in the adjacency list, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 8.8 – Adjacency list representing a directed and weighted graph" src="image/B18069_08_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 8.8 – Adjacency list representing a directed and weighted graph</span></p>
<p><span class="koboSpan" id="kobo.313.1">For example, the adjacency list for node </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">7</span></strong><span class="koboSpan" id="kobo.315.1"> contains two elements, namely regarding an edge to node </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">5</span></strong><span class="koboSpan" id="kobo.317.1"> (with a weight </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.318.1">equal to </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">4</span></strong><span class="koboSpan" id="kobo.320.1">) and to node </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">8</span></strong><span class="koboSpan" id="kobo.322.1"> (with</span><a id="_idTextAnchor310"/><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.323.1"> a weight equal </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.325.1">6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">).</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.327.1">Adjacency matrix</span></h2>
<p><span class="koboSpan" id="kobo.328.1">Another approach to graph </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.329.1">representation involves the adjacency matrix, which uses </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">a two-dimensional array to show which nodes are connected by edges</span></strong><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">The matrix contains the same number of rows and columns, which is equal to the number of nodes. </span><span class="koboSpan" id="kobo.331.3">The main idea is to </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">store information about a particular edge in an element at a given row and column in the matrix</span></strong><span class="koboSpan" id="kobo.333.1">. </span><span class="koboSpan" id="kobo.333.2">The </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.334.1">index of the row and the column depends on the nodes connected with the edge. </span><span class="koboSpan" id="kobo.334.2">For example, if you want to get information about an edge between nodes with indices </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">1</span></strong><span class="koboSpan" id="kobo.336.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">5</span></strong><span class="koboSpan" id="kobo.338.1">, you must check the element in the row with an index set to </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">1</span></strong><span class="koboSpan" id="kobo.340.1"> and in the column with an index set </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.342.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Such a solution provides you with a </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">quick way of checking whether two particular nodes are connected by an edge</span></strong><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">However, it may require you to store significantly more data than the adjacency list, especially if the graph does not contain many edges </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">between nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">To start, let’s analyze the basic scenario of an undirected and unweighted graph. </span><span class="koboSpan" id="kobo.348.2">In such a case, the adjacency matrix may only store Boolean values. </span><span class="koboSpan" id="kobo.348.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">true</span></strong><span class="koboSpan" id="kobo.350.1"> value that’s placed in the element at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">i</span></strong><span class="koboSpan" id="kobo.352.1"> row </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.353.1">and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">j</span></strong><span class="koboSpan" id="kobo.355.1"> column indicates that there is a connection between a node with an</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.356.1"> index equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">i</span></strong><span class="koboSpan" id="kobo.358.1"> and the node with an index set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">j</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">If this sounds complicated, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph" src="image/B18069_08_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph</span></p>
<p><span class="koboSpan" id="kobo.364.1">Here, the adjacency matrix contains 64 elements (for 8 rows and 8 columns) because there are 8 nodes in the graph. </span><span class="koboSpan" id="kobo.364.2">The values of many elements in the array are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">false</span></strong><span class="koboSpan" id="kobo.366.1">, which is represented by missing indicators. </span><span class="koboSpan" id="kobo.366.2">The remaining are marked with crosses, representing </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">true</span></strong><span class="koboSpan" id="kobo.368.1"> values. </span><span class="koboSpan" id="kobo.368.2">For example, such a value in the element at the fourth row and third column means that there is an edge between nodes </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">4</span></strong><span class="koboSpan" id="kobo.370.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">3</span></strong><span class="koboSpan" id="kobo.372.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">preceding diagram.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.374.1">Symmetric adjacency matrix</span></p>
<p class="callout"><span class="koboSpan" id="kobo.375.1">As the preceding graph is </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.376.1">undirected, the adjacency matrix is symmetric. </span><span class="koboSpan" id="kobo.376.2">If there is an edge between nodes </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">i</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">j</span></strong><span class="koboSpan" id="kobo.380.1">, there is also an edge between nodes </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">j</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.382.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">i</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The following example involves a directed and unweighted graph. </span><span class="koboSpan" id="kobo.385.2">In such a case, the same rules can be used, but the adjacency matrix does not need to be symmetric. </span><span class="koboSpan" id="kobo.385.3">Let’s take a look at the illustration of the</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.386.1"> graph, presented together with the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">adjacency matrix:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.388.1"><img alt="Figure 8.10 – Adjacency matrix representing a directed and unweighted graph" src="image/B18069_08_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.389.1">Figure 8.10 – Adjacency matrix representing a directed and unweighted graph</span></p>
<p><span class="koboSpan" id="kobo.390.1">Within the shown adjacency</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.391.1"> matrix, you can find data of 15 edges, represented by 15 elements with </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">true</span></strong><span class="koboSpan" id="kobo.393.1"> values, indicated by crosses in the matrix. </span><span class="koboSpan" id="kobo.393.2">For example, the unidirectional edge from node </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">5</span></strong><span class="koboSpan" id="kobo.395.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">4</span></strong><span class="koboSpan" id="kobo.397.1"> is shown as the cross at the fifth row and the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">fourth column.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">In both previous examples, you learned how to present an unweighted graph using an adjacency matrix. </span><span class="koboSpan" id="kobo.399.2">However, how you can store the data of the weighted graph, either undirected or directed? </span><span class="koboSpan" id="kobo.399.3">The answer is very simple – you just need to change the type of data stored in particular elements in the adjacency matrix from Boolean to numeric. </span><span class="koboSpan" id="kobo.399.4">Thus, you can specify the weight of edges, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.401.1"><img alt="Figure 8.11 – Adjacency matrix representing a directed and weighted graph" src="image/B18069_08_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.402.1">Figure 8.11 – Adjacency matrix representing a directed and weighted graph</span></p>
<p><span class="koboSpan" id="kobo.403.1">To eliminate any doubt, let’s take a look at the edge between nodes </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">5</span></strong><span class="koboSpan" id="kobo.405.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">6</span></strong><span class="koboSpan" id="kobo.407.1"> with the weight set to </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">2</span></strong><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">Such an edge</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.410.1"> is represented by the element at</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.411.1"> the fifth row and the sixth column. </span><span class="koboSpan" id="kobo.411.2">The value of the element is equal to the cos</span><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.412.1">t</span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.413.1"> of traveling </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">between nodes.</span></span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.415.1">Implementation</span></h1>
<p><span class="koboSpan" id="kobo.416.1">You already know some basic information about graphs, including nodes, edges, and two methods of representation, namely using an adjacency list and matrix. </span><span class="koboSpan" id="kobo.416.2">However, how you can use such a data</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.417.1"> structure in your applications? </span><span class="koboSpan" id="kobo.417.2">In this section, you will learn how to implement a graph using the C# language. </span><span class="koboSpan" id="kobo.417.3">To make your understanding of this content easier, </span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.418.1">t</span><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.419.1">wo examples will </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">be provided.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.421.1">Node</span></h2>
<p><span class="koboSpan" id="kobo.422.1">To start with, let’s take a look at the code of a generic class representing a single node in a graph. </span><span class="koboSpan" id="kobo.422.2">Such</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.423.1"> a class is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">Node</span></strong><span class="koboSpan" id="kobo.425.1"> and its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">Node&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.429.1">
{
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">Index</span></strong><span class="koboSpan" id="kobo.431.1"> { get; set; }
    public required T </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">Data</span></strong><span class="koboSpan" id="kobo.433.1"> { get; set; }
    public List&lt;Node&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">Neighbors</span></strong><span class="koboSpan" id="kobo.435.1"> { get; set; } = [];
    public List&lt;int&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">Weights</span></strong><span class="koboSpan" id="kobo.437.1"> { get; set; } = [];
    public override string </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">ToString</span></strong><span class="koboSpan" id="kobo.439.1">() =&gt; $"Index: {Index}.
</span><span class="koboSpan" id="kobo.439.2">        Data: {Data}. </span><span class="koboSpan" id="kobo.439.3">Neighbors: {Neighbors.Count}.";
}</span></pre> <p><span class="koboSpan" id="kobo.440.1">The class contains four properties. </span><span class="koboSpan" id="kobo.440.2">Since all of these elements perform important roles in the code snippets shown in this chapter, let’s analyze them </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">in detail:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.442.1">The first property (</span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">Index</span></strong><span class="koboSpan" id="kobo.444.1">) stores an index of a particular node in a collection of nodes in a graph to simplify </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.445.1">the process of accessing a particular element. </span><span class="koboSpan" id="kobo.445.2">Thus, it is possible to easily get an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Node</span></strong><span class="koboSpan" id="kobo.447.1"> class by using </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">an index.</span></span></li>
<li><span class="koboSpan" id="kobo.449.1">The next property is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Data</span></strong><span class="koboSpan" id="kobo.451.1"> and just stores some data in the node. </span><span class="koboSpan" id="kobo.451.2">It is worth mentioning that the type of such data is consistent with the type specified while creating an instance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">generic class.</span></span></li>
<li><span class="koboSpan" id="kobo.453.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Neighbors</span></strong><span class="koboSpan" id="kobo.455.1"> property represents the adjacency list for a particular node. </span><span class="koboSpan" id="kobo.455.2">Thus, it contains references to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">Node</span></strong><span class="koboSpan" id="kobo.457.1"> instances representing </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">adjacent nodes.</span></span></li>
<li><span class="koboSpan" id="kobo.459.1">The last property is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">Weights</span></strong><span class="koboSpan" id="kobo.461.1"> and stores weights assigned to adjacent edges. </span><span class="koboSpan" id="kobo.461.2">In the case of a weighted graph, the number of elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Weights</span></strong><span class="koboSpan" id="kobo.463.1"> list is the same as the number of neighbors (</span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">Neighbors</span></strong><span class="koboSpan" id="kobo.465.1">). </span><span class="koboSpan" id="kobo.465.2">If a graph is unweighted, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Weights</span></strong><span class="koboSpan" id="kobo.467.1"> list </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">is empty.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.469.1">Apart from the aforementioned properties, the class contains the overridden </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">ToString</span></strong><span class="koboSpan" id="kobo.471.1"> method, which returns the textual representation of the object. </span><span class="koboSpan" id="kobo.471.2">Here, the string is returned in </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">"Index: [index]. </span><span class="koboSpan" id="kobo.472.2">Data: [dat</span><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.473.1">a</span><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.474.1">]. </span><span class="koboSpan" id="kobo.474.2">Neighbors: [</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">count]."</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.476.1"> format.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.477.1">Edge</span></h2>
<p><span class="koboSpan" id="kobo.478.1">As mentioned in the short introduction to the topic of graphs, a graph consists of nodes and edges. </span><span class="koboSpan" id="kobo.478.2">As a node is</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.479.1"> represented by an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Node</span></strong><span class="koboSpan" id="kobo.481.1"> class, the generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Edge</span></strong><span class="koboSpan" id="kobo.483.1"> class can be used to represent an edge. </span><span class="koboSpan" id="kobo.483.2">The suitable part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">Edge&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.487.1">
{
    public required Node&lt;T&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">From</span></strong><span class="koboSpan" id="kobo.489.1"> { get; set; }
    public required Node&lt;T&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">To</span></strong><span class="koboSpan" id="kobo.491.1"> { get; set; }
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.492.1">Weight</span></strong><span class="koboSpan" id="kobo.493.1"> { get; set; }
    public override string </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">ToString</span></strong><span class="koboSpan" id="kobo.495.1">() =&gt; $"{From.Data}
        -&gt; {To.Data}. </span><span class="koboSpan" id="kobo.495.2">Weight: {Weight}.";
}</span></pre> <p><span class="koboSpan" id="kobo.496.1">The class contains three properties, namely representing nodes adjacent to the edge (</span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">From</span></strong><span class="koboSpan" id="kobo.498.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">To</span></strong><span class="koboSpan" id="kobo.500.1">), as well as the weight of the edge (</span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Weight</span></strong><span class="koboSpan" id="kobo.502.1">). </span><span class="koboSpan" id="kobo.502.2">Moreover, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">ToString</span></strong><span class="koboSpan" id="kobo.504.1"> method is overridden to present some </span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.505.1">b</span><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.506.1">asic information about </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">the edge.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.508.1">Graph</span></h2>
<p><span class="koboSpan" id="kobo.509.1">The next class is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">Graph</span></strong><span class="koboSpan" id="kobo.511.1"> and represents a whole graph, with either directed or undirected edges, as well as either weighted or </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.512.1">unweighted edges. </span><span class="koboSpan" id="kobo.512.2">The implementation consists of various properties and methods. </span><span class="koboSpan" id="kobo.512.3">These are described in </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">detail here.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">Let’s take a look at the basic version of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">Graph&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.519.1">
{
    public required bool </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">IsDirected</span></strong><span class="koboSpan" id="kobo.521.1"> { get; init; }
    public required bool </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">IsWeighted</span></strong><span class="koboSpan" id="kobo.523.1"> { get; init; }
    public List&lt;Node&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">Nodes</span></strong><span class="koboSpan" id="kobo.525.1"> { get; set; } = [];
}</span></pre> <p><span class="koboSpan" id="kobo.526.1">The class contains two properties indicating whether edges are directed (</span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">IsDirected</span></strong><span class="koboSpan" id="kobo.528.1">) and weighted (</span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">IsWeighted</span></strong><span class="koboSpan" id="kobo.530.1">). </span><span class="koboSpan" id="kobo.530.2">Moreover, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">Nodes</span></strong><span class="koboSpan" id="kobo.532.1"> property is declared, which stores a list of nodes existing in </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the graph.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">The next interesting </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.535.1">member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">Graph</span></strong><span class="koboSpan" id="kobo.537.1"> class is the indexer, which takes two indices, namely indices of two nodes, to return an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">Edge</span></strong><span class="koboSpan" id="kobo.539.1"> class representing an edge between such nodes. </span><span class="koboSpan" id="kobo.539.2">The implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
public Edge&lt;T&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">this[int from, int to]</span></strong><span class="koboSpan" id="kobo.543.1">
{
    get
    {
        Node&lt;T&gt; nodeFrom = Nodes[from];
        Node&lt;T&gt; nodeTo = Nodes[to];
        int i = nodeFrom.Neighbors.IndexOf(nodeTo);
        if (i &lt; 0) { return null; }
        Edge&lt;T&gt; edge = new()
        {
            From = nodeFrom,
            To = nodeTo,
            Weight = i &lt; nodeFrom.Weights.Count
                ? </span><span class="koboSpan" id="kobo.543.2">nodeFrom.Weights[i] : 0
        };
        return edge;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.544.1">Within the indexer, you get instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Node</span></strong><span class="koboSpan" id="kobo.546.1"> class representing two nodes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">nodeFrom</span></strong><span class="koboSpan" id="kobo.548.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">nodeTo</span></strong><span class="koboSpan" id="kobo.550.1">) according to the indices. </span><span class="koboSpan" id="kobo.550.2">As you want to find an edge from the first node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">nodeFrom</span></strong><span class="koboSpan" id="kobo.552.1">) to the second one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">nodeTo</span></strong><span class="koboSpan" id="kobo.554.1">), you need to try to find the second node in the collection of neighbor nodes of the first node using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">IndexOf</span></strong><span class="koboSpan" id="kobo.556.1"> method. </span><span class="koboSpan" id="kobo.556.2">If such a connection does not exist, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">IndexOf</span></strong><span class="koboSpan" id="kobo.558.1"> method returns a negative value, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">null</span></strong><span class="koboSpan" id="kobo.560.1"> is returned by the indexer. </span><span class="koboSpan" id="kobo.560.2">Otherwise, you create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Edge</span></strong><span class="koboSpan" id="kobo.562.1"> class and set the values of its </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.563.1">properties, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">From</span></strong><span class="koboSpan" id="kobo.565.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">To</span></strong><span class="koboSpan" id="kobo.567.1">. </span><span class="koboSpan" id="kobo.567.2">If the data regarding the weight of particular edges is provided, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Weight</span></strong><span class="koboSpan" id="kobo.569.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">Edge</span></strong><span class="koboSpan" id="kobo.571.1"> class is set </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">At this point, you know how to store data of nodes in the graph, but how can you add a new node? </span><span class="koboSpan" id="kobo.573.2">To do so, you can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">AddNode</span></strong><span class="koboSpan" id="kobo.575.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
public Node&lt;T&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">AddNode</span></strong><span class="koboSpan" id="kobo.579.1">(T value)
{
    Node&lt;T&gt; node = new() { Data = value };
    Nodes.Add(node);
    UpdateIndices();
    return node;
}</span></pre> <p><span class="koboSpan" id="kobo.580.1">Within this method, you create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">Node</span></strong><span class="koboSpan" id="kobo.582.1"> class and set a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Data</span></strong><span class="koboSpan" id="kobo.584.1"> property, according to the value of the parameter. </span><span class="koboSpan" id="kobo.584.2">Then, the newly created instance is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">Nodes</span></strong><span class="koboSpan" id="kobo.586.1"> collection, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">UpdateIndices</span></strong><span class="koboSpan" id="kobo.588.1"> method (described later) is called to update the indices of all the nodes stored in the collection. </span><span class="koboSpan" id="kobo.588.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Node</span></strong><span class="koboSpan" id="kobo.590.1"> instance, representing the newly added node, </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">is returned.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">You can remove the existing node as well. </span><span class="koboSpan" id="kobo.592.2">This operation is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">RemoveNode</span></strong><span class="koboSpan" id="kobo.594.1"> method, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">RemoveNode</span></strong><span class="koboSpan" id="kobo.598.1">(Node&lt;T&gt; nodeToRemove)
{
    Nodes.Remove(nodeToRemove);
    UpdateIndices();
    Nodes.ForEach(n =&gt; RemoveEdge(n, nodeToRemove));
}</span></pre> <p><span class="koboSpan" id="kobo.599.1">This method takes one parameter, namely an instance of the node that should be removed. </span><span class="koboSpan" id="kobo.599.2">First, you remove it from the collection of nodes. </span><span class="koboSpan" id="kobo.599.3">Then, you update the indices of the remaining nodes. </span><span class="koboSpan" id="kobo.599.4">Finally, you iterate through all the nodes in the graph to remove all edges that are connected with the node that has </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">been removed.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">As you already know, a graph</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.602.1"> consists of nodes and edges. </span><span class="koboSpan" id="kobo.602.2">Thus, the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Graph</span></strong><span class="koboSpan" id="kobo.604.1"> class should provide developers with a method for adding a new edge. </span><span class="koboSpan" id="kobo.604.2">Of course, it should support various variants of edges, either directed, undirected, weighted, or unweighted. </span><span class="koboSpan" id="kobo.604.3">The proposed implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">AddEdge</span></strong><span class="koboSpan" id="kobo.608.1">(Node&lt;T&gt; from, Node&lt;T&gt; to, int w = 0)
{
    from.Neighbors.Add(to);
    if (IsWeighted) { from.Weights.Add(w); }
    if (!IsDirected)
    {
        to.Neighbors.Add(from);
        if (IsWeighted) { to.Weights.Add(w); }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.609.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">AddEdge</span></strong><span class="koboSpan" id="kobo.611.1"> method takes three parameters, namely two instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">Node</span></strong><span class="koboSpan" id="kobo.613.1"> class representing nodes connected by the edge (</span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">from</span></strong><span class="koboSpan" id="kobo.615.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">to</span></strong><span class="koboSpan" id="kobo.617.1">), as well as the weight of the connection (</span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">w</span></strong><span class="koboSpan" id="kobo.619.1">), which is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.621.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">In the first line within the method, you add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Node</span></strong><span class="koboSpan" id="kobo.624.1"> instance representing the second node to the list of neighbor nodes of the first one. </span><span class="koboSpan" id="kobo.624.2">If the weighted graph is considered, a weight of the aforementioned edge is added </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">The following part of the code is only taken into account when the graph is undirected. </span><span class="koboSpan" id="kobo.626.2">In such a case, you need to automatically add an edge in the opposite direction. </span><span class="koboSpan" id="kobo.626.3">To do so, you add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Node</span></strong><span class="koboSpan" id="kobo.628.1"> instance representing the first node to the list of neighbor nodes of the second one. </span><span class="koboSpan" id="kobo.628.2">If the edges are weighted, a weight of the aforementioned edge is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Weights</span></strong><span class="koboSpan" id="kobo.630.1"> list </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">as </span></span><span class="No-Break"><a id="_idIndexMarker767"/></span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">well.</span></span></p>
<p><span class="koboSpan" id="kobo.633.1">The process of removing an edge from the graph is supported by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">RemoveEdge</span></strong><span class="koboSpan" id="kobo.635.1"> method. </span><span class="koboSpan" id="kobo.635.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">RemoveEdge</span></strong><span class="koboSpan" id="kobo.639.1">(Node&lt;T&gt; from, Node&lt;T&gt; to)
{
    int index = from.Neighbors.FindIndex(n =&gt; n == to);
    if (index &lt; 0) { return; }
    from.Neighbors.RemoveAt(index);
    if (IsWeighted) { from.Weights.RemoveAt(index); }
    if (!IsDirected)
    {
        index = to.Neighbors.FindIndex(n =&gt; n == from);
        if (index &lt; 0) { return; }
        to.Neighbors.RemoveAt(index);
        if (IsWeighted) { to.Weights.RemoveAt(index); }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.640.1">This method takes two parameters, namely two nodes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">from</span></strong><span class="koboSpan" id="kobo.642.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">to</span></strong><span class="koboSpan" id="kobo.644.1">), between which there is an edge that should be removed. </span><span class="koboSpan" id="kobo.644.2">To start, you try to find the second node in the list of neighbor nodes of the first one. </span><span class="koboSpan" id="kobo.644.3">If it is found, you remove it. </span><span class="koboSpan" id="kobo.644.4">You should also remove the weight data if the weighted graph is considered. </span><span class="koboSpan" id="kobo.644.5">In the case of an undirected graph, you automatically remove a node in an opposite direction, namely between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">to</span></strong><span class="koboSpan" id="kobo.646.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">from</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">The last public method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">GetEdges</span></strong><span class="koboSpan" id="kobo.651.1"> and makes it possible to get a collection of all the edges that are available in the graph. </span><span class="koboSpan" id="kobo.651.2">The proposed implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
public List&lt;Edge&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">GetEdges</span></strong><span class="koboSpan" id="kobo.655.1">()
{
    List&lt;Edge&lt;T&gt;&gt; edges = [];
    foreach (Node&lt;T&gt; from in Nodes)
    {
        for (int i = 0; i &lt; from.Neighbors.Count; i++)
        {
            int weight = i &lt; from.Weights.Count
                ? </span><span class="koboSpan" id="kobo.655.2">from.Weights[i] : 0;
            Edge&lt;T&gt; edge = new()
            {
                From = from,
                To = from.Neighbors[i],
                Weight = weight
            };
            edges.Add(edge);
        }
    }
    return edges;
}</span></pre> <p><span class="koboSpan" id="kobo.656.1">First, a new list of edges is initialized. </span><span class="koboSpan" id="kobo.656.2">Then, you iterate through all the nodes in the graph using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">foreach</span></strong><span class="koboSpan" id="kobo.658.1"> loop. </span><span class="koboSpan" id="kobo.658.2">Within it, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">for</span></strong><span class="koboSpan" id="kobo.660.1"> loop to create instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Edge</span></strong><span class="koboSpan" id="kobo.662.1"> class. </span><span class="koboSpan" id="kobo.662.2">The number of instances should be equal to the number of neighbors of the current node (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">from</span></strong><span class="koboSpan" id="kobo.664.1"> variable </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.665.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">foreach</span></strong><span class="koboSpan" id="kobo.667.1"> loop). </span><span class="koboSpan" id="kobo.667.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">for</span></strong><span class="koboSpan" id="kobo.669.1"> loop, the newly created instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">Edge</span></strong><span class="koboSpan" id="kobo.671.1"> class is configured by setting values of its properties, namely the first node (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">from</span></strong><span class="koboSpan" id="kobo.673.1"> variable – that is, the current node from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">foreach</span></strong><span class="koboSpan" id="kobo.675.1"> loop), the second node (to the currently-analyzed neighbor), and the weight. </span><span class="koboSpan" id="kobo.675.2">Then, the newly created instance is added to the collection of edges, represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">edges</span></strong><span class="koboSpan" id="kobo.677.1"> variable. </span><span class="koboSpan" id="kobo.677.2">Finally, the result </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">is returned.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">In various methods, you </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.680.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">UpdateIndices</span></strong><span class="koboSpan" id="kobo.682.1"> method. </span><span class="koboSpan" id="kobo.682.2">Its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">UpdateIndices</span></strong><span class="koboSpan" id="kobo.686.1">()
{
    int i = 0;
    Nodes.ForEach(n =&gt; n.Index = i++);
}</span></pre> <p><span class="koboSpan" id="kobo.687.1">This method iterates through all the nodes in the graph and updates the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">Index</span></strong><span class="koboSpan" id="kobo.689.1"> property to the consecutive number, starting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">0</span></strong><span class="koboSpan" id="kobo.691.1">. </span><span class="koboSpan" id="kobo.691.2">It is worth noting that the iteration is performed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">ForEach</span></strong><span class="koboSpan" id="kobo.693.1"> method, instead of using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">foreach</span></strong><span class="koboSpan" id="kobo.695.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.697.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">Now, you know how to create a basic implementation of a graph. </span><span class="koboSpan" id="kobo.698.2">The next step is to a</span><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.699.1">pp</span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.700.1">ly it to represent some </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">example graphs.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.702.1">Example – undirected and unweighted edges</span></h2>
<p><span class="koboSpan" id="kobo.703.1">Let’s try to use the previous</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.704.1"> implementation to create an undirected and unweighted graph according to the </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.706.1"><img alt="Figure 8.12 – Illustration of the undirected and unweighted edges example" src="image/B18069_08_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.707.1">Figure 8.12 – Illustration of the undirected and unweighted edges example</span></p>
<p><span class="koboSpan" id="kobo.708.1">As you can see, the graph contains 8 nodes and 10 edges. </span><span class="koboSpan" id="kobo.708.2">The implementation starts with the following line, which </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.709.1">initializes a new undirected and </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">unweighted graph:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.711.1">
Graph&lt;int&gt; graph = new()
    { </span><strong class="bold"><span class="koboSpan" id="kobo.712.1">IsDirected = false, IsWeighted = false</span></strong><span class="koboSpan" id="kobo.713.1"> };</span></pre> <p><span class="koboSpan" id="kobo.714.1">Then, you add the necessary nodes and store references to them as new variables of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Node&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.716.1"> type, </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.718.1">
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);</span></pre> <p><span class="koboSpan" id="kobo.719.1">Finally, you only need to add edges between nodes, as shown in the preceding diagram. </span><span class="koboSpan" id="kobo.719.2">The necessary code is </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.721.1">
graph.AddEdge(n1, n2);
graph.AddEdge(n1, n3);
graph.AddEdge(n2, n4);
graph.AddEdge(n3, n4);
graph.AddEdge(n4, n5);
graph.AddEdge(n5, n6);
graph.AddEdge(n5, n7);
graph.AddEdge(n5, n8);
graph.AddEdge(n6, n7);
graph.AddEdge(n7, n8);</span></pre> <p><span class="koboSpan" id="kobo.722.1">That’s all! </span><span class="koboSpan" id="kobo.722.2">As you can see, configuring a graph is very easy using the proposed implementation of this data </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.723.1">structure. </span><span class="koboSpan" id="kobo.723.2">Now, let’s proceed to a slightly more complex </span><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.724.1">s</span><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.725.1">cenario with directed and </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">weighted edges.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.727.1">Example – directed and weighted edges</span></h2>
<p><span class="koboSpan" id="kobo.728.1">The following example involves a </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.729.1">directed and weighted graph, </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.731.1"><img alt="Figure 8.13 – Illustration of the directed and weighted edges example" src="image/B18069_08_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.732.1">Figure 8.13 – Illustration of the directed and weighted edges example</span></p>
<p><span class="koboSpan" id="kobo.733.1">The implementation is similar to the one described previously. </span><span class="koboSpan" id="kobo.733.2">However, some modifications are necessary. </span><span class="koboSpan" id="kobo.733.3">To start with, different values of the properties are used to indicate that a directed and weighted variant of the edges is </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">being considered:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
Graph&lt;int&gt; graph = new()
    { </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">IsDirected = true, IsWeighted = true</span></strong><span class="koboSpan" id="kobo.737.1"> };</span></pre> <p><span class="koboSpan" id="kobo.738.1">The part regarding adding nodes is the same as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">previous example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);</span></pre> <p><span class="koboSpan" id="kobo.741.1">Some changes are easily visible in the lines of code regarding the addition of edges. </span><span class="koboSpan" id="kobo.741.2">Here, you specify directed </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.742.1">edges and their weights, </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.744.1">
graph.AddEdge(n1, n2, 9);
graph.AddEdge(n1, n3, 5);
graph.AddEdge(n2, n1, 3);
graph.AddEdge(n2, n4, 18);
graph.AddEdge(n3, n4, 12);
graph.AddEdge(n4, n2, 2);
graph.AddEdge(n4, n8, 8);
graph.AddEdge(n5, n4, 9);
graph.AddEdge(n5, n6, 2);
graph.AddEdge(n5, n7, 5);
graph.AddEdge(n5, n8, 3);
graph.AddEdge(n6, n7, 1);
graph.AddEdge(n7, n5, 4);
graph.AddEdge(n7, n8, 6);
graph.AddEdge(n8, n5, 3);</span></pre> <p><span class="koboSpan" id="kobo.745.1">You’ve just completed the basic implementation of a graph, shown in two examples. </span><span class="koboSpan" id="kobo.745.2">So, let’s proceed t</span><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.746.1">o</span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.747.1"> another topic, namely traversing </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">a graph.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.749.1">Traversal</span></h1>
<p><span class="koboSpan" id="kobo.750.1">One of the operations that’s commonly performed on a graph is </span><strong class="bold"><span class="koboSpan" id="kobo.751.1">traversal</span></strong><span class="koboSpan" id="kobo.752.1"> – that is, </span><strong class="bold"><span class="koboSpan" id="kobo.753.1">visiting all of the nodes in some particular order</span></strong><span class="koboSpan" id="kobo.754.1">. </span><span class="koboSpan" id="kobo.754.2">Of course, the aforementioned problem can be solved in various ways, such as using </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">DFS</span></strong><span class="koboSpan" id="kobo.756.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.757.1">BFS</span></strong><span class="koboSpan" id="kobo.758.1"> approaches. </span><span class="koboSpan" id="kobo.758.2">It is worth mentioning that the </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.759.1">traversal topic is strictly connected with the ta</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.760.1">s</span><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.761.1">k of </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">searching for a given node in </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.763.1">a graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.765.1">Depth-first search</span></h2>
<p><span class="koboSpan" id="kobo.766.1">The first graph</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.767.1"> traversal algorithm described in this chapter is named </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">DFS</span></strong><span class="koboSpan" id="kobo.769.1">. </span><span class="koboSpan" id="kobo.769.2">It tries to go as deep as possible</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.770.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">First, it proceeds to the next levels of the nodes instead of visiting all the neighbors of the current node</span></strong><span class="koboSpan" id="kobo.772.1">. </span><span class="koboSpan" id="kobo.772.2">Its steps, in the context of the example graph, are </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.774.1"><img alt="Figure 8.14 – Illustration of a DFS of a graph" src="image/B18069_08_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.775.1">Figure 8.14 – Illustration of a DFS of a graph</span></p>
<p><span class="koboSpan" id="kobo.776.1">Of course, it can be a bit </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.777.1">difficult to understand how the DFS algorithm operates</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.778.1"> just by looking at the preceding diagram. </span><span class="koboSpan" id="kobo.778.2">For this reason, let’s try to analyze </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">its stages.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">Step 1</span></strong><span class="koboSpan" id="kobo.782.1">, there’s the graph with 8 nodes. </span><span class="koboSpan" id="kobo.782.2">In </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">Step 2</span></strong><span class="koboSpan" id="kobo.784.1">, node </span><strong class="bold"><span class="koboSpan" id="kobo.785.1">1</span></strong><span class="koboSpan" id="kobo.786.1"> is marked with a gray background (indicating that the node was already visited), as well as with a bolder border (indicating that it is the node that is currently being visited). </span><span class="koboSpan" id="kobo.786.2">Moreover, an important role in the algorithm is performed by the neighbor nodes (shown as circles with dashed borders) of the current one. </span><span class="koboSpan" id="kobo.786.3">When you know the roles of particular indicators, it is clear that in </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">Step 2</span></strong><span class="koboSpan" id="kobo.788.1">, node </span><strong class="bold"><span class="koboSpan" id="kobo.789.1">1</span></strong><span class="koboSpan" id="kobo.790.1"> is visited. </span><span class="koboSpan" id="kobo.790.2">It has two neighbors, namely nodes </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.792.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.793.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.795.1">Then, the first </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.796.1">neighbor (node </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">2</span></strong><span class="koboSpan" id="kobo.798.1">) is taken into account (</span><strong class="bold"><span class="koboSpan" id="kobo.799.1">Step 3</span></strong><span class="koboSpan" id="kobo.800.1">) and the same operations are performed – that is, the node is visited and its neighbors (nodes </span><strong class="bold"><span class="koboSpan" id="kobo.801.1">1</span></strong><span class="koboSpan" id="kobo.802.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">4</span></strong><span class="koboSpan" id="kobo.804.1">) are analyzed. </span><span class="koboSpan" id="kobo.804.2">As node </span><strong class="bold"><span class="koboSpan" id="kobo.805.1">1</span></strong><span class="koboSpan" id="kobo.806.1"> was visited, it is skipped. </span><span class="koboSpan" id="kobo.806.2">In </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">Step 4</span></strong><span class="koboSpan" id="kobo.808.1">, the first suitable neighbor of node </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">2</span></strong><span class="koboSpan" id="kobo.810.1"> is taken into account, namely node </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">4</span></strong><span class="koboSpan" id="kobo.812.1">. </span><span class="koboSpan" id="kobo.812.2">It has two neighbors, namely node </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">2</span></strong><span class="koboSpan" id="kobo.814.1"> (already visited) and </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">8</span></strong><span class="koboSpan" id="kobo.816.1">. </span><span class="koboSpan" id="kobo.816.2">Next, node </span><strong class="bold"><span class="koboSpan" id="kobo.817.1">8</span></strong><span class="koboSpan" id="kobo.818.1"> is visited (</span><strong class="bold"><span class="koboSpan" id="kobo.819.1">Step 5</span></strong><span class="koboSpan" id="kobo.820.1">) and, according to the same rules, node </span><strong class="bold"><span class="koboSpan" id="kobo.821.1">5</span></strong><span class="koboSpan" id="kobo.822.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.823.1">Step 6</span></strong><span class="koboSpan" id="kobo.824.1">). </span><span class="koboSpan" id="kobo.824.2">It has four neighbors, namely nodes </span><strong class="bold"><span class="koboSpan" id="kobo.825.1">4</span></strong><span class="koboSpan" id="kobo.826.1"> (already visited), </span><strong class="bold"><span class="koboSpan" id="kobo.827.1">6</span></strong><span class="koboSpan" id="kobo.828.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">7</span></strong><span class="koboSpan" id="kobo.830.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">8</span></strong><span class="koboSpan" id="kobo.832.1"> (already visited). </span><span class="koboSpan" id="kobo.832.2">Thus, in </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">Step 7</span></strong><span class="koboSpan" id="kobo.834.1">, node </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">6</span></strong><span class="koboSpan" id="kobo.836.1"> is taken into account. </span><span class="koboSpan" id="kobo.836.2">As it has only one neighbor (node </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">7</span></strong><span class="koboSpan" id="kobo.838.1">), it is </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.839.1">visited next (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.840.1">Step 8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.842.1">Then, you check the neighbors of node </span><strong class="bold"><span class="koboSpan" id="kobo.843.1">7</span></strong><span class="koboSpan" id="kobo.844.1">, namely nodes </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">5</span></strong><span class="koboSpan" id="kobo.846.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.847.1">8</span></strong><span class="koboSpan" id="kobo.848.1">. </span><span class="koboSpan" id="kobo.848.2">Both were already visited, so you return to the node with an unvisited neighbor. </span><span class="koboSpan" id="kobo.848.3">In this example, node </span><strong class="bold"><span class="koboSpan" id="kobo.849.1">1</span></strong><span class="koboSpan" id="kobo.850.1"> has one unvisited node, namely node </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">3</span></strong><span class="koboSpan" id="kobo.852.1">. </span><span class="koboSpan" id="kobo.852.2">When it is visited (</span><strong class="bold"><span class="koboSpan" id="kobo.853.1">Step 9</span></strong><span class="koboSpan" id="kobo.854.1">), all nodes are traversed and no further operations </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">are necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">Given this example, let’s try to create the implementation in the C# language. </span><span class="koboSpan" id="kobo.856.2">To start, the code of the public </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">DFS</span></strong><span class="koboSpan" id="kobo.858.1"> method (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">Graph</span></strong><span class="koboSpan" id="kobo.860.1"> class) is presented </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.862.1">
public List&lt;Node&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.863.1">DFS</span></strong><span class="koboSpan" id="kobo.864.1">()
{
    bool[] isVisited = new bool[Nodes.Count];
    List&lt;Node&lt;T&gt;&gt; result = [];
    </span><strong class="bold"><span class="koboSpan" id="kobo.865.1">DFS(isVisited, Nodes[0], result);</span></strong><span class="koboSpan" id="kobo.866.1">
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.867.1">The important role is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">isVisited</span></strong><span class="koboSpan" id="kobo.869.1"> array. </span><span class="koboSpan" id="kobo.869.2">It has the same number of elements as the number of nodes and stores values indicating whether a given node has already been visited. </span><span class="koboSpan" id="kobo.869.3">If so, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">true</span></strong><span class="koboSpan" id="kobo.871.1"> value is stored. </span><span class="koboSpan" id="kobo.871.2">Otherwise, </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">false</span></strong><span class="koboSpan" id="kobo.873.1"> is stored. </span><span class="koboSpan" id="kobo.873.2">The list of traversed nodes is represented as a list in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">result</span></strong><span class="koboSpan" id="kobo.875.1"> variable. </span><span class="koboSpan" id="kobo.875.2">What’s more, another variant of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">DFS</span></strong><span class="koboSpan" id="kobo.877.1"> method is called here, passing </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">three parameters:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.879.1">A reference to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">isVisited</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.881.1"> array</span></span></li>
<li><span class="koboSpan" id="kobo.882.1">The first node </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">to analyze</span></span></li>
<li><span class="koboSpan" id="kobo.884.1">The list for </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">storing results</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.886.1">The code for the</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.887.1"> aforementioned</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.888.1"> variant of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">DFS</span></strong><span class="koboSpan" id="kobo.890.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.892.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">DFS</span></strong><span class="koboSpan" id="kobo.894.1">(bool[] isVisited, Node&lt;T&gt; node,
    List&lt;Node&lt;T&gt;&gt; result)
{
    result.Add(node);
    isVisited[node.Index] = true;
    foreach (Node&lt;T&gt; neighbor in node.Neighbors)
    {
        if (!isVisited[neighbor.Index])
        {
            </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">DFS(isVisited, neighbor, result);</span></strong><span class="koboSpan" id="kobo.896.1">
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.897.1">First, the current node is added to the collection of traversed nodes, and the element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">isVisited</span></strong><span class="koboSpan" id="kobo.899.1"> array is updated. </span><span class="koboSpan" id="kobo.899.2">Then, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">foreach</span></strong><span class="koboSpan" id="kobo.901.1"> loop to iterate through all the neighbors of the current node. </span><span class="koboSpan" id="kobo.901.2">For each of them, if they haven’t already been visited, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">DFS</span></strong><span class="koboSpan" id="kobo.903.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">called recursively.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">To finish, let’s take a look at the code that can be placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">Program.cs</span></strong><span class="koboSpan" id="kobo.907.1"> file. </span><span class="koboSpan" id="kobo.907.2">Its main parts are presented in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">code snippet:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.909.1">Graph&lt;int&gt; graph = new()</span></strong><span class="koboSpan" id="kobo.910.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.911.1">{ IsDirected = true, IsWeighted = true };</span></strong><span class="koboSpan" id="kobo.912.1">
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 9); (...)
graph.AddEdge(n8, n5, 3);
</span><strong class="bold"><span class="koboSpan" id="kobo.913.1">List&lt;Node&lt;int&gt;&gt; nodes = graph.DFS();</span></strong><span class="koboSpan" id="kobo.914.1">
nodes.ForEach(Console.WriteLine);</span></pre> <p><span class="koboSpan" id="kobo.915.1">Here, you initialize a directed and weighted graph. </span><span class="koboSpan" id="kobo.915.2">It is worth noting that the missing lines of code (indicated by</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.916.1"> three dots) are the same as in the example where you created a graph with directed and </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">weighted edges.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">To start traversing the </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.919.1">graph, you just need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">DFS</span></strong><span class="koboSpan" id="kobo.921.1"> method, which returns a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">Node</span></strong><span class="koboSpan" id="kobo.923.1"> instances. </span><span class="koboSpan" id="kobo.923.2">Then, you can easily iterate through elements of the list to print some basic information about each node in </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.925.1">
Index: 0. </span><span class="koboSpan" id="kobo.925.2">Data: 1. </span><span class="koboSpan" id="kobo.925.3">Neighbors: 2.
</span><span class="koboSpan" id="kobo.925.4">Index: 1. </span><span class="koboSpan" id="kobo.925.5">Data: 2. </span><span class="koboSpan" id="kobo.925.6">Neighbors: 2.
</span><span class="koboSpan" id="kobo.925.7">Index: 3. </span><span class="koboSpan" id="kobo.925.8">Data: 4. </span><span class="koboSpan" id="kobo.925.9">Neighbors: 2.
</span><span class="koboSpan" id="kobo.925.10">Index: 7. </span><span class="koboSpan" id="kobo.925.11">Data: 8. </span><span class="koboSpan" id="kobo.925.12">Neighbors: 1.
</span><span class="koboSpan" id="kobo.925.13">Index: 4. </span><span class="koboSpan" id="kobo.925.14">Data: 5. </span><span class="koboSpan" id="kobo.925.15">Neighbors: 4.
</span><span class="koboSpan" id="kobo.925.16">Index: 5. </span><span class="koboSpan" id="kobo.925.17">Data: 6. </span><span class="koboSpan" id="kobo.925.18">Neighbors: 1.
</span><span class="koboSpan" id="kobo.925.19">Index: 6. </span><span class="koboSpan" id="kobo.925.20">Data: 7. </span><span class="koboSpan" id="kobo.925.21">Neighbors: 2.
</span><span class="koboSpan" id="kobo.925.22">Index: 2. </span><span class="koboSpan" id="kobo.925.23">Data: 3. </span><span class="koboSpan" id="kobo.925.24">Neighbors: 1.</span></pre> <p><span class="koboSpan" id="kobo.926.1">That’s all! </span><span class="koboSpan" id="kobo.926.2">As you can see, the algorithm tries to go as deep as possible and then goes back to find the next unvisited neighbor that can </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">be traversed.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">However, this algorithm is not the only approach to the p</span><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.929.1">roblem of graph traversal. </span><span class="koboSpan" id="kobo.929.2">We’ll cover anothe</span><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.930.1">r method and its implementation in the </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">next section.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.932.1">Breadth-first search</span></h2>
<p><span class="koboSpan" id="kobo.933.1">In the previous section, you learned about the DFS approach. </span><span class="koboSpan" id="kobo.933.2">Now, you will see another solution, namely </span><strong class="bold"><span class="koboSpan" id="kobo.934.1">BFS</span></strong><span class="koboSpan" id="kobo.935.1">. </span><span class="koboSpan" id="kobo.935.2">Its </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.936.1">main aim is to </span><strong class="bold"><span class="koboSpan" id="kobo.937.1">visit all the neighbors of the current node and then proceed to the next level </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.938.1">of nodes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.940.1">If the previous description </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.941.1">sounds a bit complicated, take a look at this diagram, which depicts the steps of the </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">BFS algorithm:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.943.1"><img alt="Figure 8.15 – Illustration of a BFS of a graph" src="image/B18069_08_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.944.1">Figure 8.15 – Illustration of a BFS of a graph</span></p>
<p><span class="koboSpan" id="kobo.945.1">The algorithm starts by</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.946.1"> visiting node </span><strong class="bold"><span class="koboSpan" id="kobo.947.1">1</span></strong><span class="koboSpan" id="kobo.948.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.949.1">Step 2</span></strong><span class="koboSpan" id="kobo.950.1">). </span><span class="koboSpan" id="kobo.950.2">It has two neighbors, namely nodes </span><strong class="bold"><span class="koboSpan" id="kobo.951.1">2</span></strong><span class="koboSpan" id="kobo.952.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">3</span></strong><span class="koboSpan" id="kobo.954.1">, which</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.955.1"> are visited next (</span><strong class="bold"><span class="koboSpan" id="kobo.956.1">Step 3</span></strong><span class="koboSpan" id="kobo.957.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.958.1">Step 4</span></strong><span class="koboSpan" id="kobo.959.1">). </span><span class="koboSpan" id="kobo.959.2">As node </span><strong class="bold"><span class="koboSpan" id="kobo.960.1">1</span></strong><span class="koboSpan" id="kobo.961.1"> does not have more neighbors, the neighbors of its first neighbor (node </span><strong class="bold"><span class="koboSpan" id="kobo.962.1">2</span></strong><span class="koboSpan" id="kobo.963.1">) are considered. </span><span class="koboSpan" id="kobo.963.2">As it has only one unvisited neighbor (node </span><strong class="bold"><span class="koboSpan" id="kobo.964.1">4</span></strong><span class="koboSpan" id="kobo.965.1">), it is visited in the next step. </span><span class="koboSpan" id="kobo.965.2">According to the same method, the remaining nodes are visited in this order: </span><strong class="bold"><span class="koboSpan" id="kobo.966.1">8</span></strong><span class="koboSpan" id="kobo.967.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.968.1">5</span></strong><span class="koboSpan" id="kobo.969.1">, </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.970.1">6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.972.1">7</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.974.1">It sounds very simple, doesn’t it? </span><span class="koboSpan" id="kobo.974.2">Let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">the implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.976.1">
public List&lt;Node&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.977.1">BFS</span></strong><span class="koboSpan" id="kobo.978.1">() =&gt; BFS(Nodes[0]);</span></pre> <p><span class="koboSpan" id="kobo.979.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">BFS</span></strong><span class="koboSpan" id="kobo.981.1"> public method is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">Graph</span></strong><span class="koboSpan" id="kobo.983.1"> class and is used to start the traversal of a graph. </span><span class="koboSpan" id="kobo.983.2">It calls the</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.984.1"> private </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">BFS</span></strong><span class="koboSpan" id="kobo.986.1"> method, passing the first node as the parameter. </span><span class="koboSpan" id="kobo.986.2">Its </span><a id="_idIndexMarker791"/><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.987.1">code is </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.989.1">
private List&lt;Node&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.990.1">BFS</span></strong><span class="koboSpan" id="kobo.991.1">(Node&lt;T&gt; node)
{
    bool[] isVisited = new bool[Nodes.Count];
    isVisited[node.Index] = true;
    List&lt;Node&lt;T&gt;&gt; result = [];
    Queue&lt;Node&lt;T&gt;&gt; queue = [];
    queue.Enqueue(node);
    while (queue.Count &gt; 0)
    {
        Node&lt;T&gt; next = queue.Dequeue();
        result.Add(next);
        foreach (Node&lt;T&gt; neighbor in next.Neighbors)
        {
            if (!isVisited[neighbor.Index])
            {
                isVisited[neighbor.Index] = true;
                queue.Enqueue(neighbor);
            }
        }
    }
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.992.1">The important part of the code is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">isVisited</span></strong><span class="koboSpan" id="kobo.994.1"> array, which stores Boolean values indicating whether particular nodes were already visited. </span><span class="koboSpan" id="kobo.994.2">The array is initialized at the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">BFS</span></strong><span class="koboSpan" id="kobo.996.1"> method, and the value of the element related to the current node is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">true</span></strong><span class="koboSpan" id="kobo.998.1">, which</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.999.1"> indicates that this node </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">was visited.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">Then, the list for</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.1002.1"> storing traversed nodes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">result</span></strong><span class="koboSpan" id="kobo.1004.1">) and the queue for storing nodes that should be visited next (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">queue</span></strong><span class="koboSpan" id="kobo.1006.1">) are created. </span><span class="koboSpan" id="kobo.1006.2">Just after the initialization of the queue, the current node is added </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.1008.1">The following operations are performed until the queue is empty: you get the first node from the queue (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">next</span></strong><span class="koboSpan" id="kobo.1010.1"> variable), add it to the collection of visited nodes, and iterate through the neighbors of the current node. </span><span class="koboSpan" id="kobo.1010.2">For each of them, you check whether it has already been visited. </span><span class="koboSpan" id="kobo.1010.3">If not, it is marked as visited by setting a proper value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">isVisited</span></strong><span class="koboSpan" id="kobo.1012.1"> array, and the neighbor is added to the queue for analysis in one of the next iterations of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.1015.1">Finally, the list of the visited nodes is returned. </span><span class="koboSpan" id="kobo.1015.2">If you want to test this algorithm, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1017.1">Graph&lt;int&gt; graph = new()</span></strong><span class="koboSpan" id="kobo.1018.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">{ IsDirected = true, IsWeighted = true };</span></strong><span class="koboSpan" id="kobo.1020.1">
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 9); (...)
graph.AddEdge(n8, n5, 3);
</span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">List&lt;Node&lt;int&gt;&gt; nodes = graph.BFS();</span></strong><span class="koboSpan" id="kobo.1022.1">
nodes.ForEach(Console.WriteLine);</span></pre> <p><span class="koboSpan" id="kobo.1023.1">The preceding code calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">BFS</span></strong><span class="koboSpan" id="kobo.1025.1"> public method to traverse the graph according to the BFS algorithm. </span><span class="koboSpan" id="kobo.1025.2">The last line is responsible for iterating through the results to present the data of the nodes in the console, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1027.1">
Index: 0. </span><span class="koboSpan" id="kobo.1027.2">Data: 1. </span><span class="koboSpan" id="kobo.1027.3">Neighbors: 2.
</span><span class="koboSpan" id="kobo.1027.4">Index: 1. </span><span class="koboSpan" id="kobo.1027.5">Data: 2. </span><span class="koboSpan" id="kobo.1027.6">Neighbors: 2.
</span><span class="koboSpan" id="kobo.1027.7">Index: 2. </span><span class="koboSpan" id="kobo.1027.8">Data: 3. </span><span class="koboSpan" id="kobo.1027.9">Neighbors: 1.
</span><span class="koboSpan" id="kobo.1027.10">Index: 3. </span><span class="koboSpan" id="kobo.1027.11">Data: 4. </span><span class="koboSpan" id="kobo.1027.12">Neighbors: 2.
</span><span class="koboSpan" id="kobo.1027.13">Index: 7. </span><span class="koboSpan" id="kobo.1027.14">Data: 8. </span><span class="koboSpan" id="kobo.1027.15">Neighbors: 1.
</span><span class="koboSpan" id="kobo.1027.16">Index: 4. </span><span class="koboSpan" id="kobo.1027.17">Data: 5. </span><span class="koboSpan" id="kobo.1027.18">Neighbors: 4.
</span><span class="koboSpan" id="kobo.1027.19">Index: 5. </span><span class="koboSpan" id="kobo.1027.20">Data: 6. </span><span class="koboSpan" id="kobo.1027.21">Neighbors: 1.
</span><span class="koboSpan" id="kobo.1027.22">Index: 6. </span><span class="koboSpan" id="kobo.1027.23">Data: 7. </span><span class="koboSpan" id="kobo.1027.24">Neighbors: 2.</span></pre> <p><span class="koboSpan" id="kobo.1028.1">You’ve just learned about two algorithms for traversing a graph, namely DFS and BFS. </span><span class="koboSpan" id="kobo.1028.2">To make your understanding of such topics easier, this chapter contains detailed descriptions, illustrations, and </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.1029.1">examples. </span><span class="koboSpan" id="kobo.1029.2">Now, let’s proceed to another</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.1030.1"> important</span><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.1031.1"> topic, namely the minimum spanning tree, which has many </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">real-world applications.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1033.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1034.1">There are many online resources regarding traversing a graph. </span><span class="koboSpan" id="kobo.1034.2">You can learn more about DFS at </span><a href="https://en.wikipedia.org/wiki/Depth-first_search"><span class="koboSpan" id="kobo.1035.1">https://en.wikipedia.org/wiki/Depth-first_search</span></a><span class="koboSpan" id="kobo.1036.1">, while you can find more information about the BFS algorithm and its implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">at </span></span><a href="https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/"><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">https</span><span id="_idTextAnchor341"/><span class="koboSpan" id="kobo.1039.1">://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.1041.1">Minimum spanning tree</span></h1>
<p><span class="koboSpan" id="kobo.1042.1">While talking about</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.1043.1"> graphs, it is beneficial to introduce the subject of a </span><strong class="bold"><span class="koboSpan" id="kobo.1044.1">spanning tree</span></strong><span class="koboSpan" id="kobo.1045.1">. </span><span class="koboSpan" id="kobo.1045.2">What is it? </span><strong class="bold"><span class="koboSpan" id="kobo.1046.1">A</span></strong><strong class="bold"><a id="_idIndexMarker798"/></strong><strong class="bold"><span class="koboSpan" id="kobo.1047.1"> spanning tree is a subset of edges that connects all nodes in a graph without cycles</span></strong><span class="koboSpan" id="kobo.1048.1">. </span><span class="koboSpan" id="kobo.1048.2">Of course, it is possible to have many spanning trees within the same graph. </span><span class="koboSpan" id="kobo.1048.3">For example, let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.1050.1"><img alt="Figure 8.16 – Illustration of spanning trees within a graph" src="image/B18069_08_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1051.1">Figure 8.16 – Illustration of spanning trees within a graph</span></p>
<p><span class="koboSpan" id="kobo.1052.1">On the left-hand side is a spanning tree</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.1053.1"> that consists of the following edges: (</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">1</span></strong><span class="koboSpan" id="kobo.1055.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1056.1">2</span></strong><span class="koboSpan" id="kobo.1057.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">1</span></strong><span class="koboSpan" id="kobo.1059.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1060.1">3</span></strong><span class="koboSpan" id="kobo.1061.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">3</span></strong><span class="koboSpan" id="kobo.1063.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1064.1">4</span></strong><span class="koboSpan" id="kobo.1065.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1066.1">4</span></strong><span class="koboSpan" id="kobo.1067.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1068.1">5</span></strong><span class="koboSpan" id="kobo.1069.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1070.1">5</span></strong><span class="koboSpan" id="kobo.1071.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1072.1">6</span></strong><span class="koboSpan" id="kobo.1073.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1074.1">6</span></strong><span class="koboSpan" id="kobo.1075.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1076.1">7</span></strong><span class="koboSpan" id="kobo.1077.1">), and (</span><strong class="bold"><span class="koboSpan" id="kobo.1078.1">5</span></strong><span class="koboSpan" id="kobo.1079.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1080.1">8</span></strong><span class="koboSpan" id="kobo.1081.1">). </span><span class="koboSpan" id="kobo.1081.2">The total weight is equal to 40. </span><span class="koboSpan" id="kobo.1081.3">On the right-hand side, another spanning tree is shown. </span><span class="koboSpan" id="kobo.1081.4">Here, the following edges are chosen: (</span><strong class="bold"><span class="koboSpan" id="kobo.1082.1">1</span></strong><span class="koboSpan" id="kobo.1083.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1084.1">2</span></strong><span class="koboSpan" id="kobo.1085.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1086.1">1</span></strong><span class="koboSpan" id="kobo.1087.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1088.1">3</span></strong><span class="koboSpan" id="kobo.1089.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1090.1">2</span></strong><span class="koboSpan" id="kobo.1091.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1092.1">4</span></strong><span class="koboSpan" id="kobo.1093.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1094.1">4</span></strong><span class="koboSpan" id="kobo.1095.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1096.1">8</span></strong><span class="koboSpan" id="kobo.1097.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1098.1">5</span></strong><span class="koboSpan" id="kobo.1099.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1100.1">8</span></strong><span class="koboSpan" id="kobo.1101.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1102.1">5</span></strong><span class="koboSpan" id="kobo.1103.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1104.1">6</span></strong><span class="koboSpan" id="kobo.1105.1">), and (</span><strong class="bold"><span class="koboSpan" id="kobo.1106.1">6</span></strong><span class="koboSpan" id="kobo.1107.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1108.1">7</span></strong><span class="koboSpan" id="kobo.1109.1">). </span><span class="koboSpan" id="kobo.1109.2">The total weight is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">to 31.</span></span></p>
<p><span class="koboSpan" id="kobo.1111.1">However, neither of the preceding spanning trees is the </span><strong class="bold"><span class="koboSpan" id="kobo.1112.1">minimum spanning tree (MST)</span></strong><span class="koboSpan" id="kobo.1113.1"> of this graph. </span><span class="koboSpan" id="kobo.1113.2">What does it mean that a spanning tree is </span><em class="italic"><span class="koboSpan" id="kobo.1114.1">minimum</span></em><span class="koboSpan" id="kobo.1115.1">? </span><span class="koboSpan" id="kobo.1115.2">The answer is really simple: it is </span><strong class="bold"><span class="koboSpan" id="kobo.1116.1">a spanning tree with the minimum cost from all spanning trees available in the graph</span></strong><span class="koboSpan" id="kobo.1117.1">. </span><span class="koboSpan" id="kobo.1117.2">You can get the MST by replacing the edge (</span><strong class="bold"><span class="koboSpan" id="kobo.1118.1">6</span></strong><span class="koboSpan" id="kobo.1119.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1120.1">7</span></strong><span class="koboSpan" id="kobo.1121.1">) with (</span><strong class="bold"><span class="koboSpan" id="kobo.1122.1">5</span></strong><span class="koboSpan" id="kobo.1123.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1124.1">7</span></strong><span class="koboSpan" id="kobo.1125.1">). </span><span class="koboSpan" id="kobo.1125.2">Then, the cost is equal to 30. </span><span class="koboSpan" id="kobo.1125.3">It is also worth mentioning that the number of edges in a spanning tree is equal to the number of nodes </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">minus one.</span></span></p>
<p><span class="koboSpan" id="kobo.1127.1">Why is the topic of MST so important? </span><span class="koboSpan" id="kobo.1127.2">Let’s imagine a scenario where you need to connect many buildings to a telecommunication cable. </span><span class="koboSpan" id="kobo.1127.3">Of course, there are various possible connections, such as from one building to another, or using a hub. </span><span class="koboSpan" id="kobo.1127.4">What’s more, environmental conditions can have a serious impact on the cost of the investment due to the necessity of crossing a road or even a river. </span><span class="koboSpan" id="kobo.1127.5">Your task is to successfully connect all buildings to the telecommunication cable at the lowest possible cost. </span><span class="koboSpan" id="kobo.1127.6">How should you design the connections? </span><span class="koboSpan" id="kobo.1127.7">To answer this question, you just need to create a graph, where nodes represent connectors and edges indicate possible connections. </span><span class="koboSpan" id="kobo.1127.8">Then, you find the MST, and</span><a id="_idIndexMarker800"/> <span class="No-Break"><span class="koboSpan" id="kobo.1128.1">that’s all!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1129.1">Do you want some examples?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1130.1">The aforementioned problem of connecting many buildings to the telecommunication cable is presented in the example at the end of this section regarding </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">the MST.</span></span></p>
<p><span class="koboSpan" id="kobo.1132.1">The next question is how to find the MST. </span><span class="koboSpan" id="kobo.1132.2">There are various approaches to solving this problem, including the application of Kruskal’s or Prim’s algori</span><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.1133.1">t</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.1134.1">hms. </span><span class="koboSpan" id="kobo.1134.2">These are presented and explained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">following sections.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.1136.1">Kruskal’s algorithm</span></h2>
<p><span class="koboSpan" id="kobo.1137.1">One of the algorithms </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.1138.1">for finding the MST was discovered by </span><strong class="bold"><span class="koboSpan" id="kobo.1139.1">Kruskal</span></strong><span class="koboSpan" id="kobo.1140.1">. </span><span class="koboSpan" id="kobo.1140.2">Its operation is </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.1141.1">very simple to explain. </span><strong class="bold"><span class="koboSpan" id="kobo.1142.1">The algorithm takes an edge with the minimum weight from the remaining ones and adds it to the MST, but only if adding it does not create a cycle</span></strong><span class="koboSpan" id="kobo.1143.1">. </span><span class="koboSpan" id="kobo.1143.2">The algorithm stops when all the nodes </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">are connected.</span></span></p>
<p><span class="koboSpan" id="kobo.1145.1">Let’s take a look at a diagram that presents the steps of finding the MST using </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1146.1">Kruskal’s algorithm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.1148.1"><img alt="Figure 8.17 – Illustration of Kruskal’s algorithm" src="image/B18069_08_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1149.1">Figure 8.17 – Illustration of Kruskal’s algorithm</span></p>
<p><span class="koboSpan" id="kobo.1150.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1151.1">Step 1</span></strong><span class="koboSpan" id="kobo.1152.1">, edge (</span><strong class="bold"><span class="koboSpan" id="kobo.1153.1">5</span></strong><span class="koboSpan" id="kobo.1154.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1155.1">8</span></strong><span class="koboSpan" id="kobo.1156.1">) is chosen </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.1157.1">because it has the minimum </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.1158.1">weight, namely </span><strong class="bold"><span class="koboSpan" id="kobo.1159.1">1</span></strong><span class="koboSpan" id="kobo.1160.1">. </span><span class="koboSpan" id="kobo.1160.2">Then, the following edges are selected: (</span><strong class="bold"><span class="koboSpan" id="kobo.1161.1">1</span></strong><span class="koboSpan" id="kobo.1162.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1163.1">2</span></strong><span class="koboSpan" id="kobo.1164.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1165.1">Step 2</span></strong><span class="koboSpan" id="kobo.1166.1">, (</span><strong class="bold"><span class="koboSpan" id="kobo.1167.1">2</span></strong><span class="koboSpan" id="kobo.1168.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1169.1">4</span></strong><span class="koboSpan" id="kobo.1170.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1171.1">Step 3</span></strong><span class="koboSpan" id="kobo.1172.1">, (</span><strong class="bold"><span class="koboSpan" id="kobo.1173.1">5</span></strong><span class="koboSpan" id="kobo.1174.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1175.1">6</span></strong><span class="koboSpan" id="kobo.1176.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1177.1">Step 4</span></strong><span class="koboSpan" id="kobo.1178.1">, (</span><strong class="bold"><span class="koboSpan" id="kobo.1179.1">1</span></strong><span class="koboSpan" id="kobo.1180.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1181.1">3</span></strong><span class="koboSpan" id="kobo.1182.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1183.1">Step 5</span></strong><span class="koboSpan" id="kobo.1184.1">, as well as (</span><strong class="bold"><span class="koboSpan" id="kobo.1185.1">5</span></strong><span class="koboSpan" id="kobo.1186.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1187.1">7</span></strong><span class="koboSpan" id="kobo.1188.1">) and (</span><strong class="bold"><span class="koboSpan" id="kobo.1189.1">4</span></strong><span class="koboSpan" id="kobo.1190.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1191.1">8</span></strong><span class="koboSpan" id="kobo.1192.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1193.1">Step 6</span></strong><span class="koboSpan" id="kobo.1194.1">. </span><span class="koboSpan" id="kobo.1194.2">It is worth noting that before taking the (</span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">4</span></strong><span class="koboSpan" id="kobo.1196.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1197.1">8</span></strong><span class="koboSpan" id="kobo.1198.1">) edge, (</span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">6</span></strong><span class="koboSpan" id="kobo.1200.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1201.1">7</span></strong><span class="koboSpan" id="kobo.1202.1">) is considered due to its lower weight (6 instead of 8). </span><span class="koboSpan" id="kobo.1202.2">However, adding it to the MST will introduce a cycle formed by the (</span><strong class="bold"><span class="koboSpan" id="kobo.1203.1">5</span></strong><span class="koboSpan" id="kobo.1204.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1205.1">6</span></strong><span class="koboSpan" id="kobo.1206.1">), (</span><strong class="bold"><span class="koboSpan" id="kobo.1207.1">6</span></strong><span class="koboSpan" id="kobo.1208.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1209.1">7</span></strong><span class="koboSpan" id="kobo.1210.1">), and (</span><strong class="bold"><span class="koboSpan" id="kobo.1211.1">5</span></strong><span class="koboSpan" id="kobo.1212.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1213.1">7</span></strong><span class="koboSpan" id="kobo.1214.1">) edges. </span><span class="koboSpan" id="kobo.1214.2">For this reason, such an edge is ignored and the algorithm chooses (</span><strong class="bold"><span class="koboSpan" id="kobo.1215.1">4</span></strong><span class="koboSpan" id="kobo.1216.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1217.1">8</span></strong><span class="koboSpan" id="kobo.1218.1">). </span><span class="koboSpan" id="kobo.1218.2">Finally, the number of edges in the MST is 7. </span><span class="koboSpan" id="kobo.1218.3">The number of nodes is equal to 8, which means that the algorithm can stop operating and the MST has </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">been found.</span></span></p>
<p><span class="koboSpan" id="kobo.1220.1">Let’s take a look at its</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.1221.1"> implementation. </span><span class="koboSpan" id="kobo.1221.2">It involves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">MSTKruskal</span></strong><span class="koboSpan" id="kobo.1223.1"> method, which should be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">Graph</span></strong><span class="koboSpan" id="kobo.1225.1"> class. </span><span class="koboSpan" id="kobo.1225.2">The proposed </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.1226.1">code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1228.1">
public List&lt;Edge&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1229.1">MSTKruskal</span></strong><span class="koboSpan" id="kobo.1230.1">()
{
    List&lt;Edge&lt;T&gt;&gt; edges = GetEdges();
    edges.Sort((a, b) =&gt; a.Weight.CompareTo(b.Weight));
    Queue&lt;Edge&lt;T&gt;&gt; queue = new(edges);
    Subset&lt;T&gt;[] subsets = new Subset&lt;T&gt;[Nodes.Count];
    for (int i = 0; i &lt; Nodes.Count; i++)
    {
        subsets[i] = new() { Parent = Nodes[i] };
    }
    List&lt;Edge&lt;T&gt;&gt; result = [];
    while (result.Count &lt; Nodes.Count - 1)
    {
        Edge&lt;T&gt; edge = queue.Dequeue();
        Node&lt;T&gt; from = GetRoot(subsets, edge.From);
        Node&lt;T&gt; to = GetRoot(subsets, edge.To);
        if (from == to) { continue; }
        result.Add(edge);
        Union(subsets, from, to);
    }
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.1231.1">This method does not take any parameters. </span><span class="koboSpan" id="kobo.1231.2">To start, a list of edges is obtained by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">GetEdges</span></strong><span class="koboSpan" id="kobo.1233.1"> method. </span><span class="koboSpan" id="kobo.1233.2">Then, the edges are sorted in ascending order by weight. </span><span class="koboSpan" id="kobo.1233.3">Such a step is crucial because you need to get an edge with the minimum cost in the following iterations of the algorithm. </span><span class="koboSpan" id="kobo.1233.4">In the next line, a new queue is created and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">Edge</span></strong><span class="koboSpan" id="kobo.1235.1"> instances are enqueued, using </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.1236.1">the constructor of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">Queue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.1239.1">In the next block of code, an array with data of subsets is created. </span><span class="koboSpan" id="kobo.1239.2">By default, each node is added to a separate subset. </span><span class="koboSpan" id="kobo.1239.3">This is the reason why the number of elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">subsets</span></strong><span class="koboSpan" id="kobo.1241.1"> array is equal to the</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.1242.1"> number of nodes. </span><span class="koboSpan" id="kobo.1242.2">The subsets are used to check whether an addition of an edge to the MST causes the creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">a cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.1244.1">Then, the list for storing edges from the MST is created (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">result</span></strong><span class="koboSpan" id="kobo.1246.1">). </span><span class="koboSpan" id="kobo.1246.2">The most interesting part of the code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">while</span></strong><span class="koboSpan" id="kobo.1248.1"> loop, which iterates until the correct number of edges is found in the MST. </span><span class="koboSpan" id="kobo.1248.2">Within this loop, you get the edge with the minimum weight, just by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1250.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">Queue</span></strong><span class="koboSpan" id="kobo.1252.1"> instance. </span><span class="koboSpan" id="kobo.1252.2">Then, you can check whether no cycles were introduced by adding the found edge to the MST. </span><span class="koboSpan" id="kobo.1252.3">In such a case, the edge is added to the target list, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">Union</span></strong><span class="koboSpan" id="kobo.1254.1"> method is called to union </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">two subsets.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">While analyzing the previous method, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">GetRoot</span></strong><span class="koboSpan" id="kobo.1258.1"> one is mentioned. </span><span class="koboSpan" id="kobo.1258.2">It aims to update parents for subsets, as well as return the root node of the subset, </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1260.1">
private Node&lt;T&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1261.1">GetRoot</span></strong><span class="koboSpan" id="kobo.1262.1">(Subset&lt;T&gt;[] subsets, Node&lt;T&gt; node)
{
    int i = node.Index;
    ss[i].Parent = ss[i].Parent != node
        ? </span><span class="koboSpan" id="kobo.1262.2">GetRoot(ss, ss[i].Parent) : ss[i].Parent;
    return ss[i].Parent;
}</span></pre> <p><span class="koboSpan" id="kobo.1263.1">The last private method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">Union</span></strong><span class="koboSpan" id="kobo.1265.1"> and performs the </span><em class="italic"><span class="koboSpan" id="kobo.1266.1">union</span></em><span class="koboSpan" id="kobo.1267.1"> operation (by a rank) of two sets. </span><span class="koboSpan" id="kobo.1267.2">It takes three parameters, namely an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">Subset</span></strong><span class="koboSpan" id="kobo.1269.1"> instances and two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">Node</span></strong><span class="koboSpan" id="kobo.1271.1"> instances, representing root nodes for subsets on which the </span><em class="italic"><span class="koboSpan" id="kobo.1272.1">union</span></em><span class="koboSpan" id="kobo.1273.1"> operation should be performed. </span><span class="koboSpan" id="kobo.1273.2">The suitable </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.1274.1">part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1276.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.1277.1">Union</span></strong><span class="koboSpan" id="kobo.1278.1">(Subset&lt;T&gt;[] ss, Node&lt;T&gt; a, Node&lt;T&gt; b)
{
    ss[b.Index].Parent =
        ss[a.Index].Rank &gt;= ss[b.Index].Rank
            ? </span><span class="koboSpan" id="kobo.1278.2">a : ss[b.Index].Parent;
    ss[a.Index].Parent =
        ss[a.Index].Rank &lt; ss[b.Index].Rank
            ? </span><span class="koboSpan" id="kobo.1278.3">b : ss[a.Index].Parent;
    if (ss[a.Index].Rank == ss[b.Index].Rank)
    {
        ss[a.Index].Rank++;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1279.1">In the previous code </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.1280.1">snippets, you can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">Subset</span></strong><span class="koboSpan" id="kobo.1282.1"> class, but what does it look like? </span><span class="koboSpan" id="kobo.1282.2">Let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">its declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1284.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.1285.1">Subset&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1286.1">
{
    public required Node&lt;T&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1287.1">Parent</span></strong><span class="koboSpan" id="kobo.1288.1"> { get; set; }
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.1289.1">Rank</span></strong><span class="koboSpan" id="kobo.1290.1"> { get; set; }
    public override string </span><strong class="bold"><span class="koboSpan" id="kobo.1291.1">ToString</span></strong><span class="koboSpan" id="kobo.1292.1">() =&gt; $"Rank: {Rank}.
</span><span class="koboSpan" id="kobo.1292.2">        Parent: {Parent.Data}. </span><span class="koboSpan" id="kobo.1292.3">Index: {Parent.Index}.";
}</span></pre> <p><span class="koboSpan" id="kobo.1293.1">The class contains properties representing the parent node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">Parent</span></strong><span class="koboSpan" id="kobo.1295.1">), as well as the rank of the subset (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">Rank</span></strong><span class="koboSpan" id="kobo.1297.1">). </span><span class="koboSpan" id="kobo.1297.2">The class also contains the overridden </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">ToString</span></strong><span class="koboSpan" id="kobo.1299.1"> method, which presents some basic information about the subset in </span><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">textual form.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1301.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1302.1">Did you know that the presented approach is representative of a </span><strong class="bold"><span class="koboSpan" id="kobo.1303.1">greedy algorithm</span></strong><span class="koboSpan" id="kobo.1304.1">? </span><span class="koboSpan" id="kobo.1304.2">The code shown here is based on the implementation available at </span><a href="https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/"><span class="koboSpan" id="kobo.1305.1">https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/</span></a><span class="koboSpan" id="kobo.1306.1">. </span><span class="koboSpan" id="kobo.1306.2">You can find there a lot of interesting information about Kruskal’s algorithm, as well as about many other algorithms regarding graphs, such as about a simple approach to coloring, which is also one of the topics waiting for you in the current chapter. </span><em class="italic"><span class="koboSpan" id="kobo.1307.1">GeeksForGeeks</span></em><span class="koboSpan" id="kobo.1308.1"> is a great resource for various algorithms with a huge collection of content, and it’s something I </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">highly recommend!</span></span></p>
<p><span class="koboSpan" id="kobo.1310.1">Let’s</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.1311.1"> take a look at the</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.1312.1"> usage of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">MSTKruskal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1315.1">
Graph&lt;int&gt; graph = new()
    { IsDirected = false, IsWeighted = true };
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 3);
graph.AddEdge(n1, n3, 5);
graph.AddEdge(n2, n4, 4);
graph.AddEdge(n3, n4, 12);
graph.AddEdge(n4, n5, 9);
graph.AddEdge(n4, n8, 8);
graph.AddEdge(n5, n6, 4);
graph.AddEdge(n5, n7, 5);
graph.AddEdge(n5, n8, 1);
graph.AddEdge(n6, n7, 6);
graph.AddEdge(n7, n8, 20);
</span><strong class="bold"><span class="koboSpan" id="kobo.1316.1">List&lt;Edge&lt;int&gt;&gt; edges = graph.MSTKruskal();</span></strong><span class="koboSpan" id="kobo.1317.1">
edges.ForEach(Console.WriteLine);</span></pre> <p><span class="koboSpan" id="kobo.1318.1">First, you initialize an undirected and</span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.1319.1"> weighted graph, as well as add nodes and edges. </span><span class="koboSpan" id="kobo.1319.2">Then, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">MSTKruskal</span></strong><span class="koboSpan" id="kobo.1321.1"> method to find </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.1322.1">the MST using Kruskal’s algorithm. </span><span class="koboSpan" id="kobo.1322.2">Finally, you use</span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.1323.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">ForEach</span></strong><span class="koboSpan" id="kobo.1325.1"> method to write the data of each edge from the MST in the console. </span><span class="koboSpan" id="kobo.1325.2">The exemplary output is </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1327.1">
8 -&gt; 5. </span><span class="koboSpan" id="kobo.1327.2">Weight: 1.
</span><span class="koboSpan" id="kobo.1327.3">1 -&gt; 2. </span><span class="koboSpan" id="kobo.1327.4">Weight: 3.
</span><span class="koboSpan" id="kobo.1327.5">2 -&gt; 4. </span><span class="koboSpan" id="kobo.1327.6">Weight: 4.
</span><span class="koboSpan" id="kobo.1327.7">5 -&gt; 6. </span><span class="koboSpan" id="kobo.1327.8">Weight: 4.
</span><span class="koboSpan" id="kobo.1327.9">1 -&gt; 3. </span><span class="koboSpan" id="kobo.1327.10">Weight: 5.
</span><span class="koboSpan" id="kobo.1327.11">7 -&gt; 5. </span><span class="koboSpan" id="kobo.1327.12">Weight: 5.
</span><span class="koboSpan" id="kobo.1327.13">8 -&gt; 4. </span><span class="koboSpan" id="kobo.1327.14">Weight: 8.</span></pre> <p><span class="koboSpan" id="kobo.1328.1">As mentioned previously, you </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.1329.1">will learn about two algorithms for finding the MST in this chapter. </span><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.1330.1">Now, it is high time to take a look at the second one, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">Prim’s algorithm.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.1332.1">Prim’s algorithm</span></h2>
<p><span class="koboSpan" id="kobo.1333.1">Another solution to solve the</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.1334.1"> problem </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.1335.1">of finding the MST is </span><strong class="bold"><span class="koboSpan" id="kobo.1336.1">Prim’s algorithm</span></strong><span class="koboSpan" id="kobo.1337.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.1338.1">It uses two sets of nodes that are disjointed, namely the nodes located in the MST and the nodes that are not placed there yet</span></strong><span class="koboSpan" id="kobo.1339.1">. </span><span class="koboSpan" id="kobo.1339.2">In the following iterations, the algorithm </span><strong class="bold"><span class="koboSpan" id="kobo.1340.1">finds an edge with the minimum weight that connects a node from the first group with a node from the second group. </span><span class="koboSpan" id="kobo.1340.2">The node of the edge, which is not already in the MST, is added to </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1341.1">this set.</span></strong></span></p>
<p><span class="koboSpan" id="kobo.1342.1">The preceding description sounds quite simple, doesn’t it? </span><span class="koboSpan" id="kobo.1342.2">Let’s see it in action by analyzing the diagram presenting the steps of finding the MST using </span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">Prim’s algorithm:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.1344.1"><img alt="Figure 8.18 – Illustration of Prim’s algorithm" src="image/B18069_08_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1345.1">Figure 8.18 – Illustration of Prim’s algorithm</span></p>
<p><span class="koboSpan" id="kobo.1346.1">Let’s take a look at the additional indicators that have been added next to the nodes in the graph. </span><span class="koboSpan" id="kobo.1346.2">They present the </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.1347.1">minimum weight necessary to reach such a node from any of its neighbors. </span><span class="koboSpan" id="kobo.1347.2">By</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.1348.1"> default, the starting node has such a value set to </span><strong class="bold"><span class="koboSpan" id="kobo.1349.1">0</span></strong><span class="koboSpan" id="kobo.1350.1">, while all others are set to infinity, as presented in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1351.1">Step 1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1352.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1353.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1354.1">Step 2</span></strong><span class="koboSpan" id="kobo.1355.1">, the starting node is added to the subset of nodes forming the MST, and the distance to its neighbors is updated, namely </span><strong class="bold"><span class="koboSpan" id="kobo.1356.1">5</span></strong><span class="koboSpan" id="kobo.1357.1"> for reaching node </span><strong class="bold"><span class="koboSpan" id="kobo.1358.1">3</span></strong><span class="koboSpan" id="kobo.1359.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1360.1">3</span></strong><span class="koboSpan" id="kobo.1361.1"> for reaching node </span><strong class="bold"><span class="koboSpan" id="kobo.1362.1">2</span></strong><span class="koboSpan" id="kobo.1363.1">. </span><span class="koboSpan" id="kobo.1363.2">The values of the other nodes are still set </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">to infinity.</span></span></p>
<p><span class="koboSpan" id="kobo.1365.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1366.1">Step 3</span></strong><span class="koboSpan" id="kobo.1367.1">, the node with the minimum cost is chosen. </span><span class="koboSpan" id="kobo.1367.2">In this case, node </span><strong class="bold"><span class="koboSpan" id="kobo.1368.1">2</span></strong><span class="koboSpan" id="kobo.1369.1"> is selected because the cost is equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1370.1">3</span></strong><span class="koboSpan" id="kobo.1371.1">. </span><span class="koboSpan" id="kobo.1371.2">Its competitor (namely node </span><strong class="bold"><span class="koboSpan" id="kobo.1372.1">3</span></strong><span class="koboSpan" id="kobo.1373.1">) has a cost equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1374.1">5</span></strong><span class="koboSpan" id="kobo.1375.1">. </span><span class="koboSpan" id="kobo.1375.2">Next, you need to update the cost of reaching the neighbors of the current node, namely node </span><strong class="bold"><span class="koboSpan" id="kobo.1376.1">4</span></strong><span class="koboSpan" id="kobo.1377.1"> with the cost set </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1379.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1381.1">The next chosen node is node </span><strong class="bold"><span class="koboSpan" id="kobo.1382.1">4</span></strong><span class="koboSpan" id="kobo.1383.1"> because it does not exist in the MST set and has the lowest reaching cost (</span><strong class="bold"><span class="koboSpan" id="kobo.1384.1">Step 4</span></strong><span class="koboSpan" id="kobo.1385.1">). </span><span class="koboSpan" id="kobo.1385.2">In the same way, you choose the next edges in the following order: (</span><strong class="bold"><span class="koboSpan" id="kobo.1386.1">1</span></strong><span class="koboSpan" id="kobo.1387.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1388.1">3</span></strong><span class="koboSpan" id="kobo.1389.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1390.1">Step 5</span></strong><span class="koboSpan" id="kobo.1391.1">, (</span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">4</span></strong><span class="koboSpan" id="kobo.1393.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1394.1">8</span></strong><span class="koboSpan" id="kobo.1395.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1396.1">Step 6</span></strong><span class="koboSpan" id="kobo.1397.1">, (</span><strong class="bold"><span class="koboSpan" id="kobo.1398.1">8</span></strong><span class="koboSpan" id="kobo.1399.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1400.1">5</span></strong><span class="koboSpan" id="kobo.1401.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1402.1">Step 7</span></strong><span class="koboSpan" id="kobo.1403.1">, (</span><strong class="bold"><span class="koboSpan" id="kobo.1404.1">5</span></strong><span class="koboSpan" id="kobo.1405.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1406.1">6</span></strong><span class="koboSpan" id="kobo.1407.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1408.1">Step 8</span></strong><span class="koboSpan" id="kobo.1409.1">, and (</span><strong class="bold"><span class="koboSpan" id="kobo.1410.1">5</span></strong><span class="koboSpan" id="kobo.1411.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1412.1">7</span></strong><span class="koboSpan" id="kobo.1413.1">) in </span><strong class="bold"><span class="koboSpan" id="kobo.1414.1">Step 9</span></strong><span class="koboSpan" id="kobo.1415.1">. </span><span class="koboSpan" id="kobo.1415.2">Now, all the nodes are included in the MST and the algorithm can stop </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">its operation.</span></span></p>
<p><span class="koboSpan" id="kobo.1417.1">Given this detailed description of the steps of the algorithm, let’s proceed to the C#-based implementation. </span><span class="koboSpan" id="kobo.1417.2">The majority of operations are performed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">MSTPrim</span></strong><span class="koboSpan" id="kobo.1419.1"> method, which should be added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">Graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1422.1">
public List&lt;Edge&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1423.1">MSTPrim</span></strong><span class="koboSpan" id="kobo.1424.1">()
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1425.1">int[] previous = new int[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1426.1">
    previous[0] = -1;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1427.1">int[] minWeight = new int[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1428.1">
    Array.Fill(minWeight, int.MaxValue);
    minWeight[0] = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1429.1">bool[] isInMST = new bool[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1430.1">
    Array.Fill(isInMST, false);
    for (int i = 0; i &lt; Nodes.Count - 1; i++)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1431.1">int mwi = GetMinWeightIndex(minWeight, isInMST);</span></strong><span class="koboSpan" id="kobo.1432.1">
        isInMST[mwi] = true;
        for (int j = 0; j &lt; Nodes.Count; j++)
        {
            Edge&lt;T&gt;? </span><span class="koboSpan" id="kobo.1432.2">edge = this[mwi, j];
            int weight = edge != null ? </span><span class="koboSpan" id="kobo.1432.3">edge.Weight : -1;
            if (edge != null
                &amp;&amp; !isInMST[j]
                &amp;&amp; weight &lt; minWeight[j])
            {
                </span><strong class="bold"><span class="koboSpan" id="kobo.1433.1">previous[j] = mwi;</span></strong><span class="koboSpan" id="kobo.1434.1">
                </span><strong class="bold"><span class="koboSpan" id="kobo.1435.1">minWeight[j] = weight;</span></strong><span class="koboSpan" id="kobo.1436.1">
            }
        }
    }
    List&lt;Edge&lt;T&gt;&gt; result = [];
    for (int i = 1; i &lt; Nodes.Count; i++)
    {
        result.Add(this[previous[i], i]!);
    }
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.1437.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">MSTPrim</span></strong><span class="koboSpan" id="kobo.1439.1"> method does not</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.1440.1"> take any parameters. </span><span class="koboSpan" id="kobo.1440.2">It uses three auxiliary node-related arrays that assign</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.1441.1"> additional data to the nodes of </span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">the graph:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1443.1">The first, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">previous</span></strong><span class="koboSpan" id="kobo.1445.1">, stores indices of the previous node, from which the given node can be reached. </span><span class="koboSpan" id="kobo.1445.2">By default, the values of all elements are equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">0</span></strong><span class="koboSpan" id="kobo.1447.1">, except the first one, which is set </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1451.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">minWeight</span></strong><span class="koboSpan" id="kobo.1453.1"> array stores the minimum weight of the edge for accessing the given node. </span><span class="koboSpan" id="kobo.1453.2">By default, all elements are set to the maximum value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">int</span></strong><span class="koboSpan" id="kobo.1455.1"> type, while the value for the first element is set </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1459.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">isInMST</span></strong><span class="koboSpan" id="kobo.1461.1"> array indicates whether the given node is already in the MST. </span><span class="koboSpan" id="kobo.1461.2">To start with, the values of all the elements should be set </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1464.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1465.1">The most interesting part of the code is located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">for</span></strong><span class="koboSpan" id="kobo.1467.1"> loop. </span><span class="koboSpan" id="kobo.1467.2">Within it, you’ll find the index of the node from the set of nodes not located in the MST, which can be reached with the minimum cost. </span><span class="koboSpan" id="kobo.1467.3">Such a task is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">GetMinWeightIndex</span></strong><span class="koboSpan" id="kobo.1469.1"> method. </span><span class="koboSpan" id="kobo.1469.2">Then, another </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">for</span></strong><span class="koboSpan" id="kobo.1471.1"> loop is used. </span><span class="koboSpan" id="kobo.1471.2">Within it, you get an edge that connects nodes with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">mwi</span></strong><span class="koboSpan" id="kobo.1473.1"> index (this stands for </span><em class="italic"><span class="koboSpan" id="kobo.1474.1">minimum weight index</span></em><span class="koboSpan" id="kobo.1475.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">j</span></strong><span class="koboSpan" id="kobo.1477.1">. </span><span class="koboSpan" id="kobo.1477.2">You check whether the node is not already located in the MST and whether the cost of reaching the node is smaller than the previous minimum cost. </span><span class="koboSpan" id="kobo.1477.3">If so, values of node-related elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">previous</span></strong><span class="koboSpan" id="kobo.1479.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">minWeight</span></strong><span class="koboSpan" id="kobo.1481.1"> arrays </span><span class="No-Break"><span class="koboSpan" id="kobo.1482.1">are updated.</span></span></p>
<p><span class="koboSpan" id="kobo.1483.1">The remaining part of the code just prepares the final results. </span><span class="koboSpan" id="kobo.1483.2">Here, you create a new instance of the list with the data of edges that form the MST. </span><span class="koboSpan" id="kobo.1483.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">for</span></strong><span class="koboSpan" id="kobo.1485.1"> loop is used to get the data of the following edges and to add them to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">result</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1487.1"> list.</span></span></p>
<p><span class="koboSpan" id="kobo.1488.1">While analyzing the code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">GetMinWeightIndex</span></strong><span class="koboSpan" id="kobo.1490.1"> private method is mentioned. </span><span class="koboSpan" id="kobo.1490.2">Its code is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">following block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1492.1">
private int </span><strong class="bold"><span class="koboSpan" id="kobo.1493.1">GetMinWeightIndex</span></strong><span class="koboSpan" id="kobo.1494.1">(
    int[] weights, bool[] isInMST)
{
    int minValue = int.MaxValue;
    int minIndex = 0;
    for (int i = 0; i &lt; Nodes.Count; i++)
    {
        if (!isInMST[i] &amp;&amp; weights[i] &lt; minValue)
        {
            minValue = weights[i];
            minIndex = i;
        }
    }
    return minIndex;
}</span></pre> <p><span class="koboSpan" id="kobo.1495.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">GetMinWeightIndex</span></strong><span class="koboSpan" id="kobo.1497.1"> method just finds an index of the node, which is not located in the MST and can be reached </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.1498.1">with the minimum cost. </span><span class="koboSpan" id="kobo.1498.2">To do so, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">for</span></strong><span class="koboSpan" id="kobo.1500.1"> loop to iterate through</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.1501.1"> all the nodes. </span><span class="koboSpan" id="kobo.1501.2">For each of them, you check whether the current node is not located in the MST and whether the cost of reaching it is smaller than the already-stored minimum value. </span><span class="koboSpan" id="kobo.1501.3">If so, the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">minValue</span></strong><span class="koboSpan" id="kobo.1503.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">minIndex</span></strong><span class="koboSpan" id="kobo.1505.1"> variables are updated. </span><span class="koboSpan" id="kobo.1505.2">Finally, the index </span><span class="No-Break"><span class="koboSpan" id="kobo.1506.1">is returned.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1507.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1508.1">Similar to Kruskal’s algorithm, Prim’s variant is also representative of a </span><strong class="bold"><span class="koboSpan" id="kobo.1509.1">greedy algorithm</span></strong><span class="koboSpan" id="kobo.1510.1">. </span><span class="koboSpan" id="kobo.1510.2">I strongly encourage you</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.1511.1"> to search for even more interesting information about this algorithm in books, research papers, and on the internet. </span><span class="koboSpan" id="kobo.1511.2">It is worth noting that the presented code is based on the implementation shown </span><span class="No-Break"><span class="koboSpan" id="kobo.1512.1">at </span></span><a href="https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/"><span class="No-Break"><span class="koboSpan" id="kobo.1513.1">https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1515.1">Let’s take a look at the usage of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">MSTPrim</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1517.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1518.1">
Graph&lt;int&gt; graph = new()
    { IsDirected = false, IsWeighted = true };
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 3); (...)
graph.AddEdge(n7, n8, 20);
</span><strong class="bold"><span class="koboSpan" id="kobo.1519.1">List&lt;Edge&lt;int&gt;&gt; edges = graph.MSTPrim();</span></strong><span class="koboSpan" id="kobo.1520.1">
edges.ForEach(Console.WriteLine);</span></pre> <p><span class="koboSpan" id="kobo.1521.1">The missing parts of</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.1522.1"> the code are the same as in the case of the exemplary code regarding </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.1523.1">Kruskal’s algorithm. </span><span class="koboSpan" id="kobo.1523.2">When you run the code, you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.1524.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1525.1">
1 -&gt; 2. </span><span class="koboSpan" id="kobo.1525.2">Weight: 3.
</span><span class="koboSpan" id="kobo.1525.3">1 -&gt; 3. </span><span class="koboSpan" id="kobo.1525.4">Weight: 5.
</span><span class="koboSpan" id="kobo.1525.5">2 -&gt; 4. </span><span class="koboSpan" id="kobo.1525.6">Weight: 4.
</span><span class="koboSpan" id="kobo.1525.7">8 -&gt; 5. </span><span class="koboSpan" id="kobo.1525.8">Weight: 1.
</span><span class="koboSpan" id="kobo.1525.9">5 -&gt; 6. </span><span class="koboSpan" id="kobo.1525.10">Weight: 4.
</span><span class="koboSpan" id="kobo.1525.11">5 -&gt; 7. </span><span class="koboSpan" id="kobo.1525.12">Weight: 5.
</span><span class="koboSpan" id="kobo.1525.13">4 -&gt; 8. </span><span class="koboSpan" id="kobo.1525.14">Weight: 8.</span></pre> <p><span class="koboSpan" id="kobo.1526.1">Now </span><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.1527.1">that we’ve looked at various algorithms for finding the MST, let’s proceed to </span><span class="No-Break"><span class="koboSpan" id="kobo.1528.1">an example.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.1529.1">Example – telecommunication cable</span></h2>
<p><span class="koboSpan" id="kobo.1530.1">As mentioned in the introduction to the topic of MSTs, this problem has some important real-world applications, such as creating a plan of connections between buildings to supply all of them with a</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.1531.1"> telecommunication cable with the smallest cost. </span><span class="koboSpan" id="kobo.1531.2">Of course, there are various possible connections, such as from one building to another or using a hub. </span><span class="koboSpan" id="kobo.1531.3">What’s more, environmental conditions can have a serious impact on the cost of the investment due to the necessity of crossing a road or even </span><span class="No-Break"><span class="koboSpan" id="kobo.1532.1">a river.</span></span></p>
<p><span class="koboSpan" id="kobo.1533.1">For example, let’s create a program that solves this problem in the context of a set of buildings, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.1535.1"><img alt="Figure 8.19 – Illustration of the telecommunication cable example" src="image/B18069_08_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1536.1">Figure 8.19 – Illustration of the telecommunication cable example</span></p>
<p><span class="koboSpan" id="kobo.1537.1">As you can see, the estate community consists of six buildings. </span><span class="koboSpan" id="kobo.1537.2">The buildings are located on two sides of a small river with only one bridge. </span><span class="koboSpan" id="kobo.1537.3">Moreover, two roads exist. </span><span class="koboSpan" id="kobo.1537.4">Of course, there are different costs of connections between various points, depending both on the distance and the environmental conditions. </span><span class="koboSpan" id="kobo.1537.5">For example, the direct connection between two buildings (</span><strong class="bold"><span class="koboSpan" id="kobo.1538.1">B1</span></strong><span class="koboSpan" id="kobo.1539.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1540.1">B2</span></strong><span class="koboSpan" id="kobo.1541.1">) has a cost equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1542.1">2</span></strong><span class="koboSpan" id="kobo.1543.1">, while using the bridge (between </span><strong class="bold"><span class="koboSpan" id="kobo.1544.1">R1</span></strong><span class="koboSpan" id="kobo.1545.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1546.1">R5</span></strong><span class="koboSpan" id="kobo.1547.1">) involves a cost equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1548.1">75</span></strong><span class="koboSpan" id="kobo.1549.1">. </span><span class="koboSpan" id="kobo.1549.2">If you need to cross the river without a bridge (between </span><strong class="bold"><span class="koboSpan" id="kobo.1550.1">R3</span></strong><span class="koboSpan" id="kobo.1551.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1552.1">R6</span></strong><span class="koboSpan" id="kobo.1553.1">), the cost is even higher and equal </span><span class="No-Break"><span class="koboSpan" id="kobo.1554.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1555.1">100</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1556.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1557.1">Your task is to find the MST. </span><span class="koboSpan" id="kobo.1557.2">Within this example, you will apply both Kruskal’s and Prim’s algorithms to solve</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.1558.1"> this problem. </span><span class="koboSpan" id="kobo.1558.2">To start, let’s initialize the undirected and weighted graph, as well as add nodes and edges, </span><span class="No-Break"><span class="koboSpan" id="kobo.1559.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1560.1">
Graph&lt;string&gt; graph = new()
    { IsDirected = false, IsWeighted = true };
Node&lt;string&gt; nodeB1 = graph.AddNode("B1");
Node&lt;string&gt; nodeB2 = graph.AddNode("B2");
Node&lt;string&gt; nodeB3 = graph.AddNode("B3");
Node&lt;string&gt; nodeB4 = graph.AddNode("B4");
Node&lt;string&gt; nodeB5 = graph.AddNode("B5");
Node&lt;string&gt; nodeB6 = graph.AddNode("B6");
Node&lt;string&gt; nodeR1 = graph.AddNode("R1");
Node&lt;string&gt; nodeR2 = graph.AddNode("R2");
Node&lt;string&gt; nodeR3 = graph.AddNode("R3");
Node&lt;string&gt; nodeR4 = graph.AddNode("R4");
Node&lt;string&gt; nodeR5 = graph.AddNode("R5");
Node&lt;string&gt; nodeR6 = graph.AddNode("R6");
graph.AddEdge(nodeB1, nodeB2, 2);
graph.AddEdge(nodeB1, nodeB3, 20);
graph.AddEdge(nodeB1, nodeB4, 30);
graph.AddEdge(nodeB2, nodeB3, 30);
graph.AddEdge(nodeB2, nodeB4, 20);
graph.AddEdge(nodeB2, nodeR2, 25);
graph.AddEdge(nodeB3, nodeB4, 2);
graph.AddEdge(nodeB4, nodeR4, 25);
graph.AddEdge(nodeR1, nodeR2, 1);
graph.AddEdge(nodeR2, nodeR3, 1);
graph.AddEdge(nodeR3, nodeR4, 1);
graph.AddEdge(nodeR1, nodeR5, 75);
graph.AddEdge(nodeR3, nodeR6, 100);
graph.AddEdge(nodeR5, nodeR6, 3);
graph.AddEdge(nodeR6, nodeB5, 3);
graph.AddEdge(nodeR6, nodeB6, 10);
graph.AddEdge(nodeB5, nodeB6, 6);</span></pre> <p><span class="koboSpan" id="kobo.1561.1">Now, you just need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">MSTKruskal</span></strong><span class="koboSpan" id="kobo.1563.1"> method to use Kruskal’s algorithm to find the MST. </span><span class="koboSpan" id="kobo.1563.2">When the results are obtained, you can easily present them in the console, together with the total</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.1564.1"> cost. </span><span class="koboSpan" id="kobo.1564.2">The suitable part of the code is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1">following block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1566.1">
Console.WriteLine("Minimum Spanning Tree - Kruskal:");
</span><strong class="bold"><span class="koboSpan" id="kobo.1567.1">List&lt;Edge&lt;string&gt;&gt; kruskal = graph.MSTKruskal();</span></strong><span class="koboSpan" id="kobo.1568.1">
kruskal.ForEach(Console.WriteLine);
Console.WriteLine("Cost: " + kruskal.Sum(e =&gt; e.Weight));</span></pre> <p><span class="koboSpan" id="kobo.1569.1">The results presented in the console are </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1571.1">
Minimum Spanning Tree - Kruskal:
R4 -&gt; R3. </span><span class="koboSpan" id="kobo.1571.2">Weight: 1.
</span><span class="koboSpan" id="kobo.1571.3">R3 -&gt; R2. </span><span class="koboSpan" id="kobo.1571.4">Weight: 1.
</span><span class="koboSpan" id="kobo.1571.5">R2 -&gt; R1. </span><span class="koboSpan" id="kobo.1571.6">Weight: 1.
</span><span class="koboSpan" id="kobo.1571.7">B1 -&gt; B2. </span><span class="koboSpan" id="kobo.1571.8">Weight: 2.
</span><span class="koboSpan" id="kobo.1571.9">B3 -&gt; B4. </span><span class="koboSpan" id="kobo.1571.10">Weight: 2.
</span><span class="koboSpan" id="kobo.1571.11">R6 -&gt; R5. </span><span class="koboSpan" id="kobo.1571.12">Weight: 3.
</span><span class="koboSpan" id="kobo.1571.13">R6 -&gt; B5. </span><span class="koboSpan" id="kobo.1571.14">Weight: 3.
</span><span class="koboSpan" id="kobo.1571.15">B6 -&gt; B5. </span><span class="koboSpan" id="kobo.1571.16">Weight: 6.
</span><span class="koboSpan" id="kobo.1571.17">B1 -&gt; B3. </span><span class="koboSpan" id="kobo.1571.18">Weight: 20.
</span><span class="koboSpan" id="kobo.1571.19">R2 -&gt; B2. </span><span class="koboSpan" id="kobo.1571.20">Weight: 25.
</span><span class="koboSpan" id="kobo.1571.21">R1 -&gt; R5. </span><span class="koboSpan" id="kobo.1571.22">Weight: 75.
</span><span class="koboSpan" id="kobo.1571.23">Cost: 139</span></pre> <p><span class="koboSpan" id="kobo.1572.1">If you visualize such results</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.1573.1"> on the map, you’ll find the </span><span class="No-Break"><span class="koboSpan" id="kobo.1574.1">following MST:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.1575.1"><img alt="Figure 8.20 – Illustration of the result of the telecommunication cable example" src="image/B18069_08_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1576.1">Figure 8.20 – Illustration of the result of the telecommunication cable example</span></p>
<p><span class="koboSpan" id="kobo.1577.1">Similarly, you can apply </span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1">Prim’s algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1579.1">
Console.WriteLine("\nMinimum Spanning Tree - Prim:");
</span><strong class="bold"><span class="koboSpan" id="kobo.1580.1">List&lt;Edge&lt;string&gt;&gt; prim = graph.MSTPrim();</span></strong><span class="koboSpan" id="kobo.1581.1">
prim.ForEach(Console.WriteLine);
Console.WriteLine("Cost: " + prim.Sum(e =&gt; e.Weight));</span></pre> <p><span class="koboSpan" id="kobo.1582.1">The results are </span><a id="_idIndexMarker831"/><span class="No-Break"><span class="koboSpan" id="kobo.1583.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1584.1">
Minimum Spanning Tree - Prim:
B1 -&gt; B2. </span><span class="koboSpan" id="kobo.1584.2">Weight: 2.
</span><span class="koboSpan" id="kobo.1584.3">B1 -&gt; B3. </span><span class="koboSpan" id="kobo.1584.4">Weight: 20.
</span><span class="koboSpan" id="kobo.1584.5">B3 -&gt; B4. </span><span class="koboSpan" id="kobo.1584.6">Weight: 2.
</span><span class="koboSpan" id="kobo.1584.7">R6 -&gt; B5. </span><span class="koboSpan" id="kobo.1584.8">Weight: 3.
</span><span class="koboSpan" id="kobo.1584.9">B5 -&gt; B6. </span><span class="koboSpan" id="kobo.1584.10">Weight: 6.
</span><span class="koboSpan" id="kobo.1584.11">R2 -&gt; R1. </span><span class="koboSpan" id="kobo.1584.12">Weight: 1.
</span><span class="koboSpan" id="kobo.1584.13">B2 -&gt; R2. </span><span class="koboSpan" id="kobo.1584.14">Weight: 25.
</span><span class="koboSpan" id="kobo.1584.15">R2 -&gt; R3. </span><span class="koboSpan" id="kobo.1584.16">Weight: 1.
</span><span class="koboSpan" id="kobo.1584.17">R3 -&gt; R4. </span><span class="koboSpan" id="kobo.1584.18">Weight: 1.
</span><span class="koboSpan" id="kobo.1584.19">R1 -&gt; R5. </span><span class="koboSpan" id="kobo.1584.20">Weight: 75.
</span><span class="koboSpan" id="kobo.1584.21">R5 -&gt; R6. </span><span class="koboSpan" id="kobo.1584.22">Weight: 3.
</span><span class="koboSpan" id="kobo.1584.23">Cost: 139</span></pre> <p><span class="koboSpan" id="kobo.1585.1">You’ve just completed an example related to the real-world appl</span><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.1586.1">i</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.1587.1">cation of MSTs. </span><span class="koboSpan" id="kobo.1587.2">Are you ready to proceed to another graph-related subject known </span><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">as coloring?</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.1589.1">Coloring</span></h1>
<p><span class="koboSpan" id="kobo.1590.1">The topic of finding the MST is </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.1591.1">not the only graph-related</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.1592.1"> problem. </span><span class="koboSpan" id="kobo.1592.2">Among others, </span><strong class="bold"><span class="koboSpan" id="kobo.1593.1">node coloring</span></strong><span class="koboSpan" id="kobo.1594.1"> exists. </span><span class="koboSpan" id="kobo.1594.2">It aims to </span><strong class="bold"><span class="koboSpan" id="kobo.1595.1">assign colors (numbers) to all nodes to comply with the rule that there cannot be an edge between two nodes with the same color</span></strong><span class="koboSpan" id="kobo.1596.1">. </span><span class="koboSpan" id="kobo.1596.2">Of course, the number of colors should be as low as possible. </span><span class="koboSpan" id="kobo.1596.3">Such a problem has some real-world applications, such as for coloring a map. </span><span class="koboSpan" id="kobo.1596.4">The implementation of the coloring algorithm, which is shown in this chapter, is quite simple and in some cases could use more colors than </span><span class="No-Break"><span class="koboSpan" id="kobo.1597.1">is necessary.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1598.1">Four-color theorem</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1599.1">Did you know that the nodes of each planar graph can be colored with no more than four colors? </span><span class="koboSpan" id="kobo.1599.2">If you are interested in this topic, take</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.1600.1"> a look at the </span><strong class="bold"><span class="koboSpan" id="kobo.1601.1">four-color theorem</span></strong><span class="koboSpan" id="kobo.1602.1"> (</span><a href="http://mathworld.wolfram.com/Four-ColorTheorem.html"><span class="koboSpan" id="kobo.1603.1">http://mathworld.wolfram.com/Four-ColorTheorem.html</span></a><span class="koboSpan" id="kobo.1604.1">). </span><span class="koboSpan" id="kobo.1604.2">Since I am talking about a planar graph, you should understand that it is a graph whose edges do not cross each other while it is drawn on </span><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">the plane.</span></span></p>
<p><span class="koboSpan" id="kobo.1606.1">Let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1607.1">following</span></span><span class="No-Break"><a id="_idIndexMarker835"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1"> diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.1609.1"><img alt="Figure 8.21 – Illustration of graph coloring" src="image/B18069_08_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1610.1">Figure 8.21 – Illustration of graph coloring</span></p>
<p><span class="koboSpan" id="kobo.1611.1">The left-hand side illustration presents a graph that is colored using four colors: red (index equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1612.1">0</span></strong><span class="koboSpan" id="kobo.1613.1">), green (</span><strong class="bold"><span class="koboSpan" id="kobo.1614.1">1</span></strong><span class="koboSpan" id="kobo.1615.1">), blue (</span><strong class="bold"><span class="koboSpan" id="kobo.1616.1">2</span></strong><span class="koboSpan" id="kobo.1617.1">), and yellow (</span><strong class="bold"><span class="koboSpan" id="kobo.1618.1">3</span></strong><span class="koboSpan" id="kobo.1619.1">). </span><span class="koboSpan" id="kobo.1619.2">As you can see, there are no nodes with the same colors connected by an edge. </span><span class="koboSpan" id="kobo.1619.3">The graph shown on the right depicts the graph with two additional edges, namely (</span><strong class="bold"><span class="koboSpan" id="kobo.1620.1">2</span></strong><span class="koboSpan" id="kobo.1621.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1622.1">6</span></strong><span class="koboSpan" id="kobo.1623.1">) and (</span><strong class="bold"><span class="koboSpan" id="kobo.1624.1">2</span></strong><span class="koboSpan" id="kobo.1625.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1626.1">5</span></strong><span class="koboSpan" id="kobo.1627.1">). </span><span class="koboSpan" id="kobo.1627.2">In such a case, the coloring has changed, but the number of colors remains </span><span class="No-Break"><span class="koboSpan" id="kobo.1628.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.1629.1">The question is, how can you find colors for nodes to comply with the aforementioned rule? </span><span class="koboSpan" id="kobo.1629.2">Fortunately, the algorithm is </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.1630.1">very simple and its implementation is presented here. </span><span class="koboSpan" id="kobo.1630.2">Here is the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">Color</span></strong><span class="koboSpan" id="kobo.1632.1"> method, which should be added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1633.1">Graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1635.1">
public int[] </span><strong class="bold"><span class="koboSpan" id="kobo.1636.1">Color</span></strong><span class="koboSpan" id="kobo.1637.1">()
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1638.1">int[] colors = new int[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1639.1">
    Array.Fill(colors, -1);
    colors[0] = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1640.1">bool[] available = new bool[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1641.1">
    for (int i = 1; i &lt; Nodes.Count; i++)
    {
        Array.Fill(available, true);
        foreach (Node&lt;T&gt; neighbor in Nodes[i].Neighbors)
        {
            int ci = colors[neighbor.Index];
            </span><strong class="bold"><span class="koboSpan" id="kobo.1642.1">if (ci &gt;= 0) { available[ci] = false; }</span></strong><span class="koboSpan" id="kobo.1643.1">
        }
        </span><strong class="bold"><span class="koboSpan" id="kobo.1644.1">colors[i] = Array.IndexOf(available, true);</span></strong><span class="koboSpan" id="kobo.1645.1">
    }
    return colors;
}</span></pre> <p><span class="koboSpan" id="kobo.1646.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1647.1">Color</span></strong><span class="koboSpan" id="kobo.1648.1"> method uses two auxiliary node-related arrays. </span><span class="koboSpan" id="kobo.1648.2">The first is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1649.1">colors</span></strong><span class="koboSpan" id="kobo.1650.1"> and stores indices of colors chosen for particular nodes. </span><span class="koboSpan" id="kobo.1650.2">By default, the values of all elements are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1651.1">-1</span></strong><span class="koboSpan" id="kobo.1652.1">, except the first one, which is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">0</span></strong><span class="koboSpan" id="kobo.1654.1">. </span><span class="koboSpan" id="kobo.1654.2">This means that the color of the first node is automatically set to the first color (for example, red). </span><span class="koboSpan" id="kobo.1654.3">The other auxiliary array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">available</span></strong><span class="koboSpan" id="kobo.1656.1">) stores information about the availability of </span><span class="No-Break"><span class="koboSpan" id="kobo.1657.1">particular colors.</span></span></p>
<p><span class="koboSpan" id="kobo.1658.1">The most crucial part of the code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">for</span></strong><span class="koboSpan" id="kobo.1660.1"> loop. </span><span class="koboSpan" id="kobo.1660.2">Within it, you reset the availability of colors by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">true</span></strong><span class="koboSpan" id="kobo.1662.1"> as the </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.1663.1">value of all elements within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">available</span></strong><span class="koboSpan" id="kobo.1665.1"> array. </span><span class="koboSpan" id="kobo.1665.2">Then, you iterate through the neighbor nodes of the current node to read their colors and mark such colors as unavailable by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1666.1">false</span></strong><span class="koboSpan" id="kobo.1667.1"> as a value of a particular element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">available</span></strong><span class="koboSpan" id="kobo.1669.1"> array. </span><span class="koboSpan" id="kobo.1669.2">Then, you find the first available color for the current node and </span><span class="No-Break"><span class="koboSpan" id="kobo.1670.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.1671.1">Let’s take a look at the usage of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1672.1">Color</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1674.1">
Graph&lt;int&gt; graph = new()
    { IsDirected = false, IsWeighted = false };
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2);
graph.AddEdge(n1, n3);
graph.AddEdge(n2, n4);
graph.AddEdge(n3, n4);
graph.AddEdge(n4, n5);
graph.AddEdge(n4, n8);
graph.AddEdge(n5, n6);
graph.AddEdge(n5, n7);
graph.AddEdge(n5, n8);
graph.AddEdge(n6, n7);
graph.AddEdge(n7, n8);
</span><strong class="bold"><span class="koboSpan" id="kobo.1675.1">int[] colors = graph.Color();</span></strong><span class="koboSpan" id="kobo.1676.1">
for (int i = 0; i &lt; colors.Length; i++)
{
    Console.WriteLine(
        $"Node {graph.Nodes[i].Data}: {</span><strong class="bold"><span class="koboSpan" id="kobo.1677.1">colors[i]</span></strong><span class="koboSpan" id="kobo.1678.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.1679.1">Here, you create a new undirected</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.1680.1"> and unweighted graph, the same as shown in the preceding figure, on the left. </span><span class="koboSpan" id="kobo.1680.2">Then, you add nodes and edges, as well as call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">Color</span></strong><span class="koboSpan" id="kobo.1682.1"> method to perform the node coloring. </span><span class="koboSpan" id="kobo.1682.2">As a result, you receive an array with indices of colors for particular nodes. </span><span class="koboSpan" id="kobo.1682.3">Then, you present the results in </span><span class="No-Break"><span class="koboSpan" id="kobo.1683.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1684.1">
Node 1: 0
Node 2: 1
Node 3: 1
Node 4: 0
Node 5: 1
Node 6: 0
Node 7: 2
Node 8: 3</span></pre> <p><span class="koboSpan" id="kobo.1685.1">With this short introductio</span><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.1686.1">n</span><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.1687.1">, you are ready to proceed to the real-world application, namely for coloring the</span><a id="_idIndexMarker839"/> <span class="No-Break"><span class="koboSpan" id="kobo.1688.1">voivodeship map.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.1689.1">Example – voivodeship map</span></h2>
<p><span class="koboSpan" id="kobo.1690.1">Let’s create a program that represents the map of voivodeships in Poland as a graph, and color such areas so that two </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.1691.1">voivodeships with common borders aren’t the same color. </span><span class="koboSpan" id="kobo.1691.2">Of course, you should try to limit the number </span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1">of colors.</span></span></p>
<p><span class="koboSpan" id="kobo.1693.1">To start, let’s think about the graph’s representation. </span><span class="koboSpan" id="kobo.1693.2">Here, nodes represent particular voivodeships, while edges represent common borders </span><span class="No-Break"><span class="koboSpan" id="kobo.1694.1">between voivodeships.</span></span></p>
<p><span class="koboSpan" id="kobo.1695.1">The map of Poland with the graph already colored is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1696.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.1697.1"><img alt="Figure 8.22 – Illustration of the voivodeship map example" src="image/B18069_08_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1698.1">Figure 8.22 – Illustration of the voivodeship map example</span></p>
<p><span class="koboSpan" id="kobo.1699.1">Your task is just to color nodes in the graph using the previously described algorithm. </span><span class="koboSpan" id="kobo.1699.2">To do so, you create an undirected </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.1700.1">and unweighted graph, add nodes representing voivodeships, and add edges to indicate common borders. </span><span class="koboSpan" id="kobo.1700.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1701.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1702.1">
Graph&lt;string&gt; graph = new()
    { IsDirected = false, IsWeighted = false };
List&lt;string&gt; borders =
[
    "PK:LU|SK|MA",
    "LU:PK|SK|MZ|PD",
    "SK:PK|MA|SL|LD|MZ|LU",
    "MA:PK|SK|SL",
    "SL:MA|SK|LD|OP",
    "LD:SL|SK|MZ|KP|WP|OP",
    "WP:LD|KP|PM|ZP|LB|DS|OP",
    "OP:SL|LD|WP|DS",
    "MZ:LU|SK|LD|KP|WM|PD",
    "PD:LU|MZ|WM",
    "WM:PD|MZ|KP|PM",
    "KP:MZ|LD|WP|PM|WM",
    "PM:WM|KP|WP|ZP",
    "ZP:PM|WP|LB",
    "LB:ZP|WP|DS",
    "DS:LB|WP|OP"
];
Dictionary&lt;string, Node&lt;string&gt;&gt; nodes = [];
foreach (string border in borders)
{
    string[] parts = border.Split(':');
    string name = parts[0];
    nodes[name] = graph.AddNode(name);
}
foreach (string border in borders)
{
    string[] parts = border.Split(':');
    string name = parts[0];
    string[] vicinities = parts[1].Split('|');
    foreach (string vicinity in vicinities)
    {
        Node&lt;string&gt; from = nodes[name];
        Node&lt;string&gt; to = nodes[vicinity];
        if (!from.Neighbors.Contains(to))
        {
            graph.AddEdge(from, to);
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1703.1">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1704.1">Color</span></strong><span class="koboSpan" id="kobo.1705.1"> method is called</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.1706.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1707.1">Graph</span></strong><span class="koboSpan" id="kobo.1708.1"> instance and the color indices for particular nodes are returned. </span><span class="koboSpan" id="kobo.1708.2">Finally, you present the results in the console. </span><span class="koboSpan" id="kobo.1708.3">The suitable part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1709.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1710.1">int[] colors = graph.Color();</span></strong><span class="koboSpan" id="kobo.1711.1">
for (int i = 0; i &lt; colors.Length; i++)
{
    Console.WriteLine(
        $"{graph.Nodes[i].Data}: {colors[i]}");
}</span></pre> <p><span class="koboSpan" id="kobo.1712.1">The results are </span><span class="No-Break"><span class="koboSpan" id="kobo.1713.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1714.1">
PK: 0
LU: 1
SK: 2
MA: 1
SL: 0
LD: 1
WP: 0
OP: 2
MZ: 0
PD: 2
WM: 1
KP: 2
PM: 3
ZP: 1
LB: 2
DS: 1</span></pre> <p><span class="koboSpan" id="kobo.1715.1">You just learned how to color nodes in a graph! </span><span class="koboSpan" id="kobo.1715.2">However, this is not the end of the interesting topics regardi</span><a id="_idTextAnchor357"/><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.1716.1">ng </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.1717.1">graphs that will be presented in this book. </span><span class="koboSpan" id="kobo.1717.2">Next, we’ll search for the shortest path in </span><span class="No-Break"><span class="koboSpan" id="kobo.1718.1">the graph.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.1719.1">Shortest path</span></h1>
<p><span class="koboSpan" id="kobo.1720.1">A graph is a great data structure for storing data </span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.1721.1">of various maps, such as cities and the distances between them. </span><span class="koboSpan" id="kobo.1721.2">For this reason, one of the obvious real-world applications of graphs is </span><strong class="bold"><span class="koboSpan" id="kobo.1722.1">searching for the </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1723.1">shortest path</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1724.1"> between two nodes, which takes into account a specific cost</span></strong><span class="koboSpan" id="kobo.1725.1">, such as the distance, the necessary time, or even the amount of </span><span class="No-Break"><span class="koboSpan" id="kobo.1726.1">fuel required.</span></span></p>
<p><span class="koboSpan" id="kobo.1727.1">There are several approaches to the topic of searching for the shortest path in a graph. </span><span class="koboSpan" id="kobo.1727.2">However, one of the common</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.1728.1"> solutions is </span><strong class="bold"><span class="koboSpan" id="kobo.1729.1">Dijkstra’s algorithm</span></strong><span class="koboSpan" id="kobo.1730.1">, which makes it possible to </span><strong class="bold"><span class="koboSpan" id="kobo.1731.1">calculate the distance from a starting node to all nodes located in the graph</span></strong><span class="koboSpan" id="kobo.1732.1">. </span><span class="koboSpan" id="kobo.1732.2">Then, you can easily get not only the cost of the connection between two nodes but also find nodes that are between the start and </span><span class="No-Break"><span class="koboSpan" id="kobo.1733.1">end nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.1734.1">Dijkstra’s algorithm uses two auxiliary </span><span class="No-Break"><span class="koboSpan" id="kobo.1735.1">node-related arrays:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1736.1">One for storing </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.1737.1">an identifier of the previous node, which is the node from which the current node can be reached with the smallest </span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">overall cost</span></span></li>
<li><span class="koboSpan" id="kobo.1739.1">One for storing the minimum distance (cost), which is necessary for accessing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1740.1">current node</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1741.1">What’s more, it uses the queue</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.1742.1"> for storing nodes that should be checked. </span><strong class="bold"><span class="koboSpan" id="kobo.1743.1">During the consecutive iterations, the algorithm updates the minimum distances to particular nodes in the graph</span></strong><span class="koboSpan" id="kobo.1744.1">. </span><span class="koboSpan" id="kobo.1744.2">Finally, the auxiliary arrays contain the minimum distance (cost) to reach all the nodes from the chosen starting node, as well as information on how to reach each node using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1745.1">shortest path.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1746.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1747.1">You can find a lot of content about Dijkstra’s algorithm on the internet. </span><span class="koboSpan" id="kobo.1747.2">Just search for its name and you will see a huge number of results. </span><span class="koboSpan" id="kobo.1747.3">As an example, you can find useful content related to the implementation presented in this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.1748.1">at </span></span><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"><span class="No-Break"><span class="koboSpan" id="kobo.1749.1">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1750.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1751.1">Let’s take a look at the following diagram, which presents two various shortest paths that have been found using Dijkstra’s algorithm. </span><span class="koboSpan" id="kobo.1751.2">The left-hand side shows the path from node </span><strong class="bold"><span class="koboSpan" id="kobo.1752.1">8</span></strong><span class="koboSpan" id="kobo.1753.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1754.1">1</span></strong><span class="koboSpan" id="kobo.1755.1">, while the right-hand side shows the path from node </span><strong class="bold"><span class="koboSpan" id="kobo.1756.1">1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1757.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1758.1">7</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1759.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.1760.1"><img alt="Figure 8.23 – Illustration of the shortest paths in a graph" src="image/B18069_08_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1761.1">Figure 8.23 – Illustration of the shortest paths in a graph</span></p>
<p><span class="koboSpan" id="kobo.1762.1">It is high time that you see some</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.1763.1"> C# code that can be used to implement Dijkstra’s algorithm. </span><span class="koboSpan" id="kobo.1763.2">The main role is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">GetShortestPath</span></strong><span class="koboSpan" id="kobo.1765.1"> method, which should be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">Graph</span></strong><span class="koboSpan" id="kobo.1767.1"> class. </span><span class="koboSpan" id="kobo.1767.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1768.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1769.1">
using Priority_Queue; (...)
public List&lt;Edge&lt;T&gt;&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1770.1">GetShortestPath</span></strong><span class="koboSpan" id="kobo.1771.1">(
    Node&lt;T&gt; source, Node&lt;T&gt; target)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1772.1">int[] previous = new int[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1773.1">
    Array.Fill(previous, -1);
    </span><strong class="bold"><span class="koboSpan" id="kobo.1774.1">int[] distances = new int[Nodes.Count];</span></strong><span class="koboSpan" id="kobo.1775.1">
    Array.Fill(distances, int.MaxValue);
    distances[source.Index] = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1776.1">SimplePriorityQueue&lt;Node&lt;T&gt;&gt; nodes = new();</span></strong><span class="koboSpan" id="kobo.1777.1">
    for (int i = 0; i &lt; Nodes.Count; i++)
    {
        nodes.Enqueue(Nodes[i], distances[i]);
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.1778.1">while (nodes.Count != 0)</span></strong><span class="koboSpan" id="kobo.1779.1">
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1780.1">Node&lt;T&gt; node = nodes.Dequeue();</span></strong><span class="koboSpan" id="kobo.1781.1">
        for (int i = 0; i &lt; node.Neighbors.Count; i++)
        {
            Node&lt;T&gt; neighbor = node.Neighbors[i];
            int weight = i &lt; node.Weights.Count
                ? </span><span class="koboSpan" id="kobo.1781.2">node.Weights[i] : 0;
            </span><strong class="bold"><span class="koboSpan" id="kobo.1782.1">int wTotal = distances[node.Index] + weight;</span></strong><span class="koboSpan" id="kobo.1783.1">
            if (distances[neighbor.Index] &gt; wTotal)
            {
                </span><strong class="bold"><span class="koboSpan" id="kobo.1784.1">distances[neighbor.Index] = wTotal;</span></strong><span class="koboSpan" id="kobo.1785.1">
                </span><strong class="bold"><span class="koboSpan" id="kobo.1786.1">previous[neighbor.Index] = node.Index;</span></strong><span class="koboSpan" id="kobo.1787.1">
                </span><strong class="bold"><span class="koboSpan" id="kobo.1788.1">nodes.UpdatePriority(neighbor,</span></strong><span class="koboSpan" id="kobo.1789.1">
                    </span><strong class="bold"><span class="koboSpan" id="kobo.1790.1">distances[neighbor.Index]);</span></strong><span class="koboSpan" id="kobo.1791.1">
            }
        }
    }
    List&lt;int&gt; indices = [];
    int index = target.Index;
    while (index &gt;= 0)
    {
        indices.Add(index);
        index = previous[index];
    }
    indices.Reverse();
    List&lt;Edge&lt;T&gt;&gt; result = [];
    for (int i = 0; i &lt; indices.Count - 1; i++)
    {
        Edge&lt;T&gt; edge = this[indices[i], indices[i + 1]]!;
        result.Add(edge);
    }
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.1792.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1793.1">GetShortestPath</span></strong><span class="koboSpan" id="kobo.1794.1"> method takes two parameters, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">source</span></strong><span class="koboSpan" id="kobo.1796.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">target</span></strong><span class="koboSpan" id="kobo.1798.1"> nodes. </span><span class="koboSpan" id="kobo.1798.2">First, it creates two node-related auxiliary arrays for storing the indices of previous nodes, from which the</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.1799.1"> given node can be reached with the smallest overall cost (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1800.1">previous</span></strong><span class="koboSpan" id="kobo.1801.1">), as well as for storing the current minimum distances to the given node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1802.1">distances</span></strong><span class="koboSpan" id="kobo.1803.1">). </span><span class="koboSpan" id="kobo.1803.2">By default, the values of all elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1804.1">previous</span></strong><span class="koboSpan" id="kobo.1805.1"> array are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1806.1">-1</span></strong><span class="koboSpan" id="kobo.1807.1">, while in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1808.1">distances</span></strong><span class="koboSpan" id="kobo.1809.1"> array, they are set to the maximum value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1810.1">int</span></strong><span class="koboSpan" id="kobo.1811.1"> type. </span><span class="koboSpan" id="kobo.1811.2">Of course, the distance to the source node is set </span><span class="No-Break"><span class="koboSpan" id="kobo.1812.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1814.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1815.1">Then, you create a new priority queue and enqueue the data of all nodes. </span><span class="koboSpan" id="kobo.1815.2">The priority of each element is equal to the current distance to such a node. </span><span class="koboSpan" id="kobo.1815.3">Here, you use the same implementation of a priority queue, as presented in </span><a href="B18069_05.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1816.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.1817.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1818.1">Stacks and Queues</span></em><span class="koboSpan" id="kobo.1819.1">, namely from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1820.1">OptimizedPriorityQueue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1821.1">NuGet package.</span></span></p>
<p><span class="koboSpan" id="kobo.1822.1">The most interesting part of the code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1823.1">while</span></strong><span class="koboSpan" id="kobo.1824.1"> loop, which is executed until the queue is empty. </span><span class="koboSpan" id="kobo.1824.2">Within this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1825.1">while</span></strong><span class="koboSpan" id="kobo.1826.1"> loop, you get the first node from the queue and iterate through all of its neighbors using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1827.1">for</span></strong><span class="koboSpan" id="kobo.1828.1"> loop. </span><span class="koboSpan" id="kobo.1828.2">Inside such a loop, you calculate the distance to a neighbor by taking the sum of the distance to the current node and the weight of the edge. </span><span class="koboSpan" id="kobo.1828.3">If the calculated distance is smaller than the currently stored value, you update the values regarding the minimum distance to the given neighbor, as well as the index of the previous node, from </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.1829.1">which you can reach the neighbor. </span><span class="koboSpan" id="kobo.1829.2">It’s worth noting that the priority of the element in the queue should be updated </span><span class="No-Break"><span class="koboSpan" id="kobo.1830.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.1831.1">The remaining operations are used to resolve the path using the values stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">previous</span></strong><span class="koboSpan" id="kobo.1833.1"> array. </span><span class="koboSpan" id="kobo.1833.2">To do so, you save the indices of the following nodes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">indices</span></strong><span class="koboSpan" id="kobo.1835.1"> list. </span><span class="koboSpan" id="kobo.1835.2">Then, you reverse it to achieve the order from the source node to the target one. </span><span class="koboSpan" id="kobo.1835.3">Finally, you create the list of edges to present the result in a form that’s suitable for returning from </span><span class="No-Break"><span class="koboSpan" id="kobo.1836.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.1837.1">Let’s take a look at the usage of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">GetShortestPath</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1839.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1840.1">
Graph&lt;int&gt; graph = new()
    { IsDirected = true, IsWeighted = true };
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 9); (...)
graph.AddEdge(n8, n5, 3);
</span><strong class="bold"><span class="koboSpan" id="kobo.1841.1">List&lt;Edge&lt;int&gt;&gt; path = graph.GetShortestPath(n1, n5);</span></strong><span class="koboSpan" id="kobo.1842.1">
path.ForEach(Console.WriteLine);</span></pre> <p><span class="koboSpan" id="kobo.1843.1">Here, you create a new directed and weighted graph, as well as add nodes and edges. </span><span class="koboSpan" id="kobo.1843.2">The missing parts of the code are the same as in the case of the </span><em class="italic"><span class="koboSpan" id="kobo.1844.1">directed and weighted edges</span></em><span class="koboSpan" id="kobo.1845.1"> example. </span><span class="koboSpan" id="kobo.1845.2">Then, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1846.1">GetShortestPath</span></strong><span class="koboSpan" id="kobo.1847.1"> method to search for the shortest path between nodes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1848.1">1</span></strong><span class="koboSpan" id="kobo.1849.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1850.1">5</span></strong><span class="koboSpan" id="kobo.1851.1">. </span><span class="koboSpan" id="kobo.1851.2">As a result, you receive a list of edges forming the shortest path. </span><span class="koboSpan" id="kobo.1851.3">Then, you just iterate through all the edges and present the results in </span><span class="No-Break"><span class="koboSpan" id="kobo.1852.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1853.1">
1 -&gt; 3. </span><span class="koboSpan" id="kobo.1853.2">Weight: 5.
</span><span class="koboSpan" id="kobo.1853.3">3 -&gt; 4. </span><span class="koboSpan" id="kobo.1853.4">Weight: 12.
</span><span class="koboSpan" id="kobo.1853.5">4 -&gt; 8. </span><span class="koboSpan" id="kobo.1853.6">Weight: 8.
</span><span class="koboSpan" id="kobo.1853.7">8 -&gt; 5. </span><span class="koboSpan" id="kobo.1853.8">Weight: 3.</span></pre> <p><span class="koboSpan" id="kobo.1854.1">With this short introduction, together with</span><a id="_idTextAnchor360"/><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.1855.1"> a simple example, let’s proceed to a more advanced and interesting </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.1856.1">application related to </span><span class="No-Break"><span class="koboSpan" id="kobo.1857.1">game development.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.1858.1">Example – path in game</span></h2>
<p><span class="koboSpan" id="kobo.1859.1">The last example we’ll cover in this chapter involves the application of Dijkstra’s algorithm to find the shortest path in a game</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.1860.1"> map. </span><span class="koboSpan" id="kobo.1860.2">Let’s imagine that you have a board with various obstacles. </span><span class="koboSpan" id="kobo.1860.3">For this reason, the player can use only part of the board to move. </span><span class="koboSpan" id="kobo.1860.4">Your task is to find the shortest path between two places located on </span><span class="No-Break"><span class="koboSpan" id="kobo.1861.1">the board.</span></span></p>
<p><span class="koboSpan" id="kobo.1862.1">To start, let’s represent the board as a jagged array. </span><span class="koboSpan" id="kobo.1862.2">The suitable part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1863.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1864.1">
using System.Text;
string[] lines = new string[]
{
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1865.1">00</span></strong><span class="koboSpan" id="kobo.1866.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1867.1">00000</span></strong><span class="koboSpan" id="kobo.1868.1">11111</span><strong class="bold"><span class="koboSpan" id="kobo.1869.1">00000</span></strong><span class="koboSpan" id="kobo.1870.1">11111",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1871.1">00</span></strong><span class="koboSpan" id="kobo.1872.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1873.1">00000</span></strong><span class="koboSpan" id="kobo.1874.1">11111</span><strong class="bold"><span class="koboSpan" id="kobo.1875.1">00000</span></strong><span class="koboSpan" id="kobo.1876.1">11111",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1877.1">00</span></strong><span class="koboSpan" id="kobo.1878.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1879.1">00000</span></strong><span class="koboSpan" id="kobo.1880.1">11111</span><strong class="bold"><span class="koboSpan" id="kobo.1881.1">00000</span></strong><span class="koboSpan" id="kobo.1882.1">11111",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1883.1">00000000000</span></strong><span class="koboSpan" id="kobo.1884.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1885.1">000000</span></strong><span class="koboSpan" id="kobo.1886.1">11111",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1887.1">000000</span></strong><span class="koboSpan" id="kobo.1888.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1889.1">00000000000</span></strong><span class="koboSpan" id="kobo.1890.1">11111",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1891.1">000</span></strong><span class="koboSpan" id="kobo.1892.1">1</span><strong class="bold"><span class="koboSpan" id="kobo.1893.1">00</span></strong><span class="koboSpan" id="kobo.1894.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1895.1">00</span></strong><span class="koboSpan" id="kobo.1896.1">111</span><strong class="bold"><span class="koboSpan" id="kobo.1897.1">000000</span></strong><span class="koboSpan" id="kobo.1898.1">11111",
    "111111111111111</span><strong class="bold"><span class="koboSpan" id="kobo.1899.1">0</span></strong><span class="koboSpan" id="kobo.1900.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1901.1">00</span></strong><span class="koboSpan" id="kobo.1902.1">",
    "111111111111111</span><strong class="bold"><span class="koboSpan" id="kobo.1903.1">0</span></strong><span class="koboSpan" id="kobo.1904.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1905.1">0</span></strong><span class="koboSpan" id="kobo.1906.1">1",
    "111111111111111</span><strong class="bold"><span class="koboSpan" id="kobo.1907.1">0</span></strong><span class="koboSpan" id="kobo.1908.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1909.1">00</span></strong><span class="koboSpan" id="kobo.1910.1">",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1911.1">0000000000000000</span></strong><span class="koboSpan" id="kobo.1912.1">11111111</span><strong class="bold"><span class="koboSpan" id="kobo.1913.1">0</span></strong><span class="koboSpan" id="kobo.1914.1">",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1915.1">0000000000000000</span></strong><span class="koboSpan" id="kobo.1916.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1917.1">00</span></strong><span class="koboSpan" id="kobo.1918.1">",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1919.1">000</span></strong><span class="koboSpan" id="kobo.1920.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1921.1">00</span></strong><span class="koboSpan" id="kobo.1922.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1923.1">0000000</span></strong><span class="koboSpan" id="kobo.1924.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1925.1">0</span></strong><span class="koboSpan" id="kobo.1926.1">1",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1927.1">000</span></strong><span class="koboSpan" id="kobo.1928.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1929.1">00</span></strong><span class="koboSpan" id="kobo.1930.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1931.1">0000000</span></strong><span class="koboSpan" id="kobo.1932.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1933.1">00</span></strong><span class="koboSpan" id="kobo.1934.1">",
    "</span><strong class="bold"><span class="koboSpan" id="kobo.1935.1">000</span></strong><span class="koboSpan" id="kobo.1936.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1937.1">00000000000</span></strong><span class="koboSpan" id="kobo.1938.1">11111111</span><strong class="bold"><span class="koboSpan" id="kobo.1939.1">0</span></strong><span class="koboSpan" id="kobo.1940.1">",
    "11111</span><strong class="bold"><span class="koboSpan" id="kobo.1941.1">00000000000</span></strong><span class="koboSpan" id="kobo.1942.1">1111111</span><strong class="bold"><span class="koboSpan" id="kobo.1943.1">00</span></strong><span class="koboSpan" id="kobo.1944.1">",
    "11111</span><strong class="bold"><span class="koboSpan" id="kobo.1945.1">000</span></strong><span class="koboSpan" id="kobo.1946.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1947.1">00</span></strong><span class="koboSpan" id="kobo.1948.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1949.1">00</span></strong><span class="koboSpan" id="kobo.1950.1">1</span><strong class="bold"><span class="koboSpan" id="kobo.1951.1">000</span></strong><span class="koboSpan" id="kobo.1952.1">1</span><strong class="bold"><span class="koboSpan" id="kobo.1953.1">000</span></strong><span class="koboSpan" id="kobo.1954.1">1",
    "11111</span><strong class="bold"><span class="koboSpan" id="kobo.1955.1">000</span></strong><span class="koboSpan" id="kobo.1956.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1957.1">00</span></strong><span class="koboSpan" id="kobo.1958.1">11</span><strong class="bold"><span class="koboSpan" id="kobo.1959.1">0000</span></strong><span class="koboSpan" id="kobo.1960.1">1</span><strong class="bold"><span class="koboSpan" id="kobo.1961.1">000</span></strong><span class="koboSpan" id="kobo.1962.1">1</span><strong class="bold"><span class="koboSpan" id="kobo.1963.1">00</span></strong><span class="koboSpan" id="kobo.1964.1">"
};
</span><strong class="bold"><span class="koboSpan" id="kobo.1965.1">bool[][] map = new bool[lines.Length][];</span></strong><span class="koboSpan" id="kobo.1966.1">
for (int i = 0; i &lt; lines.Length; i++)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1967.1">map[i] = lines[i]</span></strong><span class="koboSpan" id="kobo.1968.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1969.1">.Select(c =&gt; int.Parse(c.ToString()) == 0)</span></strong><span class="koboSpan" id="kobo.1970.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1971.1">.ToArray();</span></strong><span class="koboSpan" id="kobo.1972.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1973.1">To improve the readability of code, the map is represented as an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1974.1">string</span></strong><span class="koboSpan" id="kobo.1975.1"> values. </span><span class="koboSpan" id="kobo.1975.2">Each row is presented as text, with</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.1976.1"> the number of characters equal to the number of columns. </span><span class="koboSpan" id="kobo.1976.2">The value of each character indicates the availability of the point. </span><span class="koboSpan" id="kobo.1976.3">If it is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1977.1">0</span></strong><span class="koboSpan" id="kobo.1978.1">, the position is available. </span><span class="koboSpan" id="kobo.1978.2">Otherwise, it is not. </span><span class="koboSpan" id="kobo.1978.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1979.1">string</span></strong><span class="koboSpan" id="kobo.1980.1">-based map representation should then be converted into the Boolean jagged array. </span><span class="koboSpan" id="kobo.1980.2">Such a task is performed by a few lines of code, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1981.1">preceding snippet.</span></span></p>
<p><span class="koboSpan" id="kobo.1982.1">The next step is to create the</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.1983.1"> graph, as well as add the necessary nodes and edges. </span><span class="koboSpan" id="kobo.1983.2">The suitable part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1984.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1985.1">Graph&lt;string&gt; graph = new()</span></strong><span class="koboSpan" id="kobo.1986.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1987.1">{ IsDirected = false, IsWeighted = true };</span></strong><span class="koboSpan" id="kobo.1988.1">
for (int i = 0; i &lt; map.Length; i++)
{
    for (int j = 0; j &lt; map[i].Length; j++)
    {
        if (!map[i][j]) { continue; }
        </span><strong class="bold"><span class="koboSpan" id="kobo.1989.1">Node&lt;string&gt; from = graph.AddNode($"{i}-{j}");</span></strong><span class="koboSpan" id="kobo.1990.1">
        if (i &gt; 0 &amp;&amp; map[i - 1][j])
        {
            Node&lt;string&gt; to = graph.Nodes
                .Find(n =&gt; n.Data == $"{i - 1}-{j}")!;
            </span><strong class="bold"><span class="koboSpan" id="kobo.1991.1">graph.AddEdge(from, to, 1);</span></strong><span class="koboSpan" id="kobo.1992.1">
        }
        if (j &gt; 0 &amp;&amp; map[i][j - 1])
        {
            Node&lt;string&gt; to = graph.Nodes
                .Find(n =&gt; n.Data == $"{i}-{j - 1}")!;
            </span><strong class="bold"><span class="koboSpan" id="kobo.1993.1">graph.AddEdge(from, to, 1);</span></strong><span class="koboSpan" id="kobo.1994.1">
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1995.1">First, you initialize a new undirected and weighted graph. </span><span class="koboSpan" id="kobo.1995.2">Then, you use two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1996.1">for</span></strong><span class="koboSpan" id="kobo.1997.1"> loops to iterate through all the places on the board. </span><span class="koboSpan" id="kobo.1997.2">Within such loops, you check whether the given place is available. </span><span class="koboSpan" id="kobo.1997.3">If so, you create a new node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1998.1">from</span></strong><span class="koboSpan" id="kobo.1999.1">). </span><span class="koboSpan" id="kobo.1999.2">Then, you check whether the node placed immediately</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.2000.1"> above the current one is also available. </span><span class="koboSpan" id="kobo.2000.2">If so, a suitable edge is added with a weight equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2001.1">1</span></strong><span class="koboSpan" id="kobo.2002.1">. </span><span class="koboSpan" id="kobo.2002.2">Similarly, you can check whether the node placed on the left of the current one is available and add an edge </span><span class="No-Break"><span class="koboSpan" id="kobo.2003.1">if necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.2004.1">Now, you just need to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2005.1">Node</span></strong><span class="koboSpan" id="kobo.2006.1"> instances representing the source and the target nodes. </span><span class="koboSpan" id="kobo.2006.2">You can do so by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2007.1">Find</span></strong><span class="koboSpan" id="kobo.2008.1"> method and providing the textual representation of the node – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2009.1">0-0</span></strong><span class="koboSpan" id="kobo.2010.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2011.1">16-24</span></strong><span class="koboSpan" id="kobo.2012.1">. </span><span class="koboSpan" id="kobo.2012.2">Then, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2013.1">GetShortestPath</span></strong><span class="koboSpan" id="kobo.2014.1"> method. </span><span class="koboSpan" id="kobo.2014.2">In this case, the algorithm will try to find the shortest path between the node in the first row and column and the node in the last row and column. </span><span class="koboSpan" id="kobo.2014.3">The code is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2015.1">following block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2016.1">
Node&lt;string&gt; s = graph.Nodes.Find(n =&gt; n.Data == "0-0")!;
Node&lt;string&gt; t = graph.Nodes.Find(n =&gt; n.Data == "16-24")!;
</span><strong class="bold"><span class="koboSpan" id="kobo.2017.1">List&lt;Edge&lt;string&gt;&gt; path = graph.GetShortestPath(s, t);</span></strong></pre> <p><span class="koboSpan" id="kobo.2018.1">The last part of the code is related to presenting the map in </span><span class="No-Break"><span class="koboSpan" id="kobo.2019.1">the console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2020.1">
Console.OutputEncoding = Encoding.UTF8;
for (int r = 0; r &lt; map.Length; r++)
{
    for (int c = 0; c &lt; map[r].Length; c++)
    {
        bool isPath = path.Any(e =&gt;
            e.From.Data == $"{r}-{c}"
            || e.To.Data == $"{r}-{c}");
        </span><strong class="bold"><span class="koboSpan" id="kobo.2021.1">Console.ForegroundColor = isPath</span></strong><span class="koboSpan" id="kobo.2022.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.2023.1">? </span><span class="koboSpan" id="kobo.2023.2">ConsoleColor.White</span></strong><span class="koboSpan" id="kobo.2024.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.2025.1">: map[r][c]</span></strong><span class="koboSpan" id="kobo.2026.1">
                </span><strong class="bold"><span class="koboSpan" id="kobo.2027.1">? </span><span class="koboSpan" id="kobo.2027.2">ConsoleColor.Green</span></strong><span class="koboSpan" id="kobo.2028.1">
                </span><strong class="bold"><span class="koboSpan" id="kobo.2029.1">: ConsoleColor.Red;</span></strong><span class="koboSpan" id="kobo.2030.1">
        Console.Write("\u25cf ");
    }
    Console.WriteLine();
}
Console.ResetColor();</span></pre> <p><span class="koboSpan" id="kobo.2031.1">To start, you set the proper encoding in the console to be able to present Unicode characters as well. </span><span class="koboSpan" id="kobo.2031.2">Then, you use two </span><strong class="source-inline"><span class="koboSpan" id="kobo.2032.1">for</span></strong><span class="koboSpan" id="kobo.2033.1"> loops to iterate through all the places on the board. </span><span class="koboSpan" id="kobo.2033.2">Inside such loops, you choose a color that should be used to represent a point in the console, either green (the point is available) or red (unavailable). </span><span class="koboSpan" id="kobo.2033.3">If the currently-analyzed point is a part of the </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.2034.1">shortest path, the white color is set. </span><span class="koboSpan" id="kobo.2034.2">Finally, you write the Unicode character representing a bullet. </span><span class="koboSpan" id="kobo.2034.3">When the program’s execution exits both loops, the console’s color </span><span class="No-Break"><span class="koboSpan" id="kobo.2035.1">is reset.</span></span></p>
<p><span class="koboSpan" id="kobo.2036.1">When you run the application, you will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.2037.1">following result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.2038.1"><img alt="Figure 8.24 –﻿ ﻿Screenshot of the game map example" src="image/B18069_08_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2039.1">Figure 8.24 –</span><a id="_idTextAnchor363"/> <a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.2040.1">Screenshot of the game map example</span></p>
<p><span class="koboSpan" id="kobo.2041.1">Great work! </span><span class="koboSpan" id="kobo.2041.2">Now, let’s</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.2042.1"> summarize the topics that were covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.2043.1">this chapter.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.2044.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2045.1">This chapter was related to one of the most important data structures available while developing applications: graphs. </span><span class="koboSpan" id="kobo.2045.2">As you learned, a </span><strong class="bold"><span class="koboSpan" id="kobo.2046.1">graph</span></strong><span class="koboSpan" id="kobo.2047.1"> is a data structure that consists of </span><strong class="bold"><span class="koboSpan" id="kobo.2048.1">nodes</span></strong><span class="koboSpan" id="kobo.2049.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.2050.1">edges</span></strong><span class="koboSpan" id="kobo.2051.1">. </span><span class="koboSpan" id="kobo.2051.2">Each edge connects two nodes. </span><span class="koboSpan" id="kobo.2051.3">What’s more, there are various variants of edges, such as undirected and directed, as well as unweighted and weighted. </span><span class="koboSpan" id="kobo.2051.4">All of them were described and explained in detail, and illustrations and code examples were provided. </span><span class="koboSpan" id="kobo.2051.5">Two methods of graph representation, namely using an </span><strong class="bold"><span class="koboSpan" id="kobo.2052.1">adjacency list</span></strong><span class="koboSpan" id="kobo.2053.1"> and an </span><strong class="bold"><span class="koboSpan" id="kobo.2054.1">adjacency matrix</span></strong><span class="koboSpan" id="kobo.2055.1">, were explained as well. </span><span class="koboSpan" id="kobo.2055.2">You also learned how to implement a graph in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2056.1">C# language.</span></span></p>
<p><span class="koboSpan" id="kobo.2057.1">While talking about graphs, it’s important to present some </span><strong class="bold"><span class="koboSpan" id="kobo.2058.1">real-world applications</span></strong><span class="koboSpan" id="kobo.2059.1">, especially due to the common use of such a data structure. </span><span class="koboSpan" id="kobo.2059.2">For example, this chapter explained the structure of friends that are available on social media or the problem of searching for the shortest path in </span><span class="No-Break"><span class="koboSpan" id="kobo.2060.1">a city.</span></span></p>
<p><span class="koboSpan" id="kobo.2061.1">Among the topics that were covered in this chapter, you learned how to traverse a graph to visit all of the nodes in some particular order. </span><span class="koboSpan" id="kobo.2061.2">Two approaches were presented, namely </span><strong class="bold"><span class="koboSpan" id="kobo.2062.1">DFS</span></strong><span class="koboSpan" id="kobo.2063.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.2064.1">BFS</span></strong><span class="koboSpan" id="kobo.2065.1">. </span><span class="koboSpan" id="kobo.2065.2">It’s worth mentioning that the traversal topic can be also applied to searching for a given node in </span><span class="No-Break"><span class="koboSpan" id="kobo.2066.1">a graph.</span></span></p>
<p><span class="koboSpan" id="kobo.2067.1">Next, the subject of </span><strong class="bold"><span class="koboSpan" id="kobo.2068.1">spanning trees</span></strong><span class="koboSpan" id="kobo.2069.1">, as well as </span><strong class="bold"><span class="koboSpan" id="kobo.2070.1">minimum spanning trees</span></strong><span class="koboSpan" id="kobo.2071.1">, was introduced. </span><span class="koboSpan" id="kobo.2071.2">As a reminder, a spanning tree is a subset of edges that connects all nodes in a graph without cycles, while an MST is a spanning tree with the minimum cost from all spanning trees available in the graph. </span><span class="koboSpan" id="kobo.2071.3">There are a few approaches to finding the MST, including </span><strong class="bold"><span class="koboSpan" id="kobo.2072.1">Kruskal’s</span></strong><span class="koboSpan" id="kobo.2073.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2074.1">Prim’s algorithms</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2075.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2076.1">Then, you learned how to solve the problem of </span><strong class="bold"><span class="koboSpan" id="kobo.2077.1">coloring</span></strong><span class="koboSpan" id="kobo.2078.1">, where you assigned colors (numbers) to all the nodes to comply with the rule that there cannot be an edge between two nodes with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2079.1">same color.</span></span></p>
<p><span class="koboSpan" id="kobo.2080.1">The other problem was searching for the </span><strong class="bold"><span class="koboSpan" id="kobo.2081.1">shortest path between two nodes</span></strong><span class="koboSpan" id="kobo.2082.1">, which takes into account a specific cost, such as the distance, the necessary time, or even the amount of fuel required. </span><span class="koboSpan" id="kobo.2082.2">There are several approaches to the topic of searching for the shortest path in a graph. </span><span class="koboSpan" id="kobo.2082.3">However, one of the common solutions is </span><strong class="bold"><span class="koboSpan" id="kobo.2083.1">Dijkstra’s algorithm</span></strong><span class="koboSpan" id="kobo.2084.1">, which makes it possible to calculate the distance from a starting node to all the nodes located in the graph. </span><span class="koboSpan" id="kobo.2084.2">We covered this in detail in </span><span class="No-Break"><span class="koboSpan" id="kobo.2085.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.2086.1">Now, i</span><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.2087.1">t is high time to proceed to the next chapter, which focuses on </span><strong class="bold"><span class="koboSpan" id="kobo.2088.1">practical aspects of algorithms</span></strong><span class="koboSpan" id="kobo.2089.1"> from various groups, including recursive, greedy, back-tracking, and even genetic. </span><span class="koboSpan" id="kobo.2089.2">Let’s turn the page and see them </span><span class="No-Break"><span class="koboSpan" id="kobo.2090.1">in action!</span></span></p>
</div>
</body></html>