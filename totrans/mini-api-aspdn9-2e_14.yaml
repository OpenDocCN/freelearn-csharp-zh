- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing, Compatibility, and Deployment of Minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s an exciting time when you’re preparing to deploy an application to production.
    Before that can happen, there are many questions to be answered, namely, “Is this
    quality code?”, “Is everything going to work as intended?”, and “Will it be sustainable
    over a long period of time?”.
  prefs: []
  type: TYPE_NORMAL
- en: To help set our minimal APIs up for success, testing is required before they
    go into the hands of users or become responsible for any critical business operations.
  prefs: []
  type: TYPE_NORMAL
- en: This statement is *really* obvious. Of course we need to test, but in some cases,
    what is less obvious is *how* we will be testing. Unit and integration testing
    can help us in this area, offering an automated solution to testing our acceptance
    criteria, checking for new bugs introduced by code changes, often referred to
    as **regression** , and giving us (in some IDEs literally) a red or green light
    for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: There is also compatibility to consider before deployment. What operating system
    are we deploying to? What kind of web server will be in use? Are we hosting in
    the cloud or on-premises?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the appropriate method of deployment can be dictated by all of the
    preceding considerations. It seems like a lot, but it will be worth it when we
    inevitably deploy our minimal APIs with confidence that they will bring the intended
    value, and hopefully more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and integration testing for minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility and migrating minimal APIs to . NET 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 or the latest version of Visual Studio code is recommended
    in order to run the code from this chapter. The code examples for this chapter
    are available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with all deployment methods in this chapter, you will need to
    have access to an Azure subscription and be able to install Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and integration testing for minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s highly likely that you’ve come across the terms unit testing and integration
    testing, but by way of a refresher, let’s briefly define them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing** involves testing individual components of functions of a code
    base in isolation, whereas integration testing checks how different components
    of modules of a system interact. In a minimal API, a unit test may simply test
    that a service does what it should, while an integration test would confirm that
    an HTTP request to the endpoint uses the services and other components together
    correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, you’re either testing a single unit of code, or you’re testing how
    different units interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a unit test for a service that does something very simple: calculate
    the sum of given numerical values. Here is the service as it looks in **Program.cs**
    , where it is registered for dependency injection and used as part of a POST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several testing frameworks we can implement, but to keep things simple,
    I’m going to use xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click your solution in Visual Studio and select **Add** | **New Project…**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1: Add a new project from within Solution Explorer](img/B20968_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Add a new project from within Solution Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Then search for **xUnit** (or your preferred testing framework if you don’t
    wish to follow along exactly).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2: Creating a new xUnit project](img/B20968_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Creating a new xUnit project'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Do not use top-level statements** option is shown, I recommend unchecking
    it so that you can clearly see the namespaces you’re using in each class. It is
    a personal preference but it will make it easier for you to follow along with
    this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3: Unchecking the Do not use top-level statements box](img/B20968_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Unchecking the Do not use top-level statements box'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created your test project within the solution, right-click **Dependencies**
    for the test project and add a project reference to your API project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4: Adding a reference to another project](img/B20968_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Adding a reference to another project'
  prefs: []
  type: TYPE_NORMAL
- en: You now have two projects in your solution. One is a minimal API project and
    the other is a testing project linked to the former.
  prefs: []
  type: TYPE_NORMAL
- en: We can now start writing some tests. Let’s start with a simple unit test against
    **CalculatorService**
  prefs: []
  type: TYPE_NORMAL
- en: 'In our test project, create a new class called **CalculatorTests** . Then,
    update the code so that a method called **Sum_Test()** exists, with an attribute
    above the method signature, **[Fact]** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The **[Fact]** attribute is what xUnit uses to mark a method as a test. I like
    to think of it in the sense that we are stating that the method represents something
    that should be fact; it should be objective. In this case, we want a test that
    proves the fact that the sum of a given collection of integers is equal to the
    value we are expecting it to be. Let’s explore this in more detail by writing
    the test logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the body of **Sum_Test()** , instantiate a new instance of **CalculatorService**
    and create an array of integers that we can use during our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because we kept this simple, it is easy to see at a glance that the expected
    result for the sum of the values in **integers** must be **10** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to the **Sum()** function within **CalculatorService** and store
    it in a variable. Also, add a hardcoded variable of **10** for the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In unit testing, there is a principle known as the *three As* , which stands
    for arrange, act, and assert:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step, arrange, forces us to gather data and resources in a particular
    state so that testing is possible. We have achieved this by creating an instance
    of **CalculatorService** , an array of integers we know should add up to 10, which
    we have also hardcoded into a variable for reference. Finally, we make the call
    to the **Sum()** function to obtain the actual result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is act. This simply means that action is taken to enable the
    test to be evaluated. For example, if you’re testing a calculation between two
    integer values, the actual calculation would take place at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is assert. An assertion is the test itself. In this, we will
    assert that our **[Fact]** is true. If the assertion is correct, **[Fact]** is
    true and the test will pass. If the assertion is incorrect, the test will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Different testing frameworks have their own implementation of an assertion,
    but the principle remains the same. In xUnit, a static class, **Assert** , holds
    various types of assertions that can be used during testing. For example, an assertion
    that something is null or not null is represented via **Assert.Null()** and **Assert.NotNull()**
    , respectively. Likewise, we can assert that a statement is true with **Assert.True()**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to assert that the expected result of **Sum()** is equal to the actual
    result. For this, we can use **Assert.Equal()** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running this test is as simple as right-clicking the method signature and selecting
    **Run Tests** . The test will run, and the test result will be shown by Visual
    Studio in Test Explorer. You should see a green circle next to the test to indicate
    success.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: The Test Explorer screen, showing available tests and their
    results](img/B20968_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The Test Explorer screen, showing available tests and their results'
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach to writing tests can be taken for integration tests, the
    main difference being the scope of the test. For this example, a minimal API,
    a simple integration test’s scope could cover a whole endpoint. Let’s put this
    into practice by writing an integration test for the **/sumintegers** API endpoint
    that checks the resulting status code.
  prefs: []
  type: TYPE_NORMAL
- en: To run this test, we will need to be able to access an **HttpClient** object
    and run **WebApplication** in the test project, because the test needs to make
    a request against an endpoint. To make this possible, you can make your test class
    implement **IClassFixture** of type **WebApplicationFactory** .
  prefs: []
  type: TYPE_NORMAL
- en: IClassFixture usage in a test class
  prefs: []
  type: TYPE_NORMAL
- en: '**IClassFixture** is an interface that allows objects to share scope across
    a class. In this case, we want to share the scope of a **WebApplicationFactory**
    object so that an **HttpClient** instance can be created for tests within the
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because **WebApplicationFactory** needs **Microsoft.AspNetCore.Mvc.Testing**
    to be installed, use the NuGet package manager console to install this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the **CalculatorTests** class so that it implements **IClassFixture**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will require you to add a constructor for the class, in which you can
    inject **WebApplicationFactory** . You can also use this **WebApplicationFactory**
    to create a new **HttpClient** for use during tests. Let’s store this in a **readonly**
    field so that we can keep things clean by not reinitializing it after the constructor
    has run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write our tests. Let’s *arrange* our test data by creating
    the required parameters as an array of integers and then serializing them to a
    JSON string so that they can be added to the body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can *act* by making the POST request to the target endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can *assert* that the response code is the one we were expecting,
    in this case, **200 OK** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also assert that the result is the expected one by checking the response
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This integration test may look pretty similar to the original unit test we wrote
    earlier in this chapter, but it differs in the sense that it has a wider scope.
  prefs: []
  type: TYPE_NORMAL
- en: By calling this test, we not only make a request to the target endpoint, but
    we also cover the testing of the encapsulated **CalculatorService** .
  prefs: []
  type: TYPE_NORMAL
- en: In both of these examples, integration and unit testing were conducted on pre-existing
    logic. If we were to adopt **Test-Driven Development** ( **TDD** ), we would augment
    our practices by writing the tests before any logic. Obviously, we expect the
    tests to fail initially, but our goal is to write code that allows the tests to
    pass. Assuming your tests make the same assertions as your acceptance criteria
    from an API requirements perspective, TDD is widely considered the optimal way
    to apply automated testing to a code base.
  prefs: []
  type: TYPE_NORMAL
- en: TDD or not, however you approach unit and integration testing, having test coverage
    will help to increase the quality of your minimal API code, and hopefully reduce
    the number of reported bugs post-release.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the quality and stability of an API, testing the code’s logic
    is one aspect; but before moving to deployment, there is another aspect to be
    considered: that of compatibility. Let’s explore compatibility, with a particular
    focus on the latest version of .NET at the time of writing – . NET 9.'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility and migrating minimal APIs to .NET 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that you have already created a minimal API project, but the .NET
    version is not the latest. You wish to deploy the API, but before you do so, you
    intend to bring the code base to the latest .NET version, which at the time of
    writing this book is 9. What factors do we need to consider to be confident that
    our application will run efficiently on this new version, and how can we migrate
    to it?
  prefs: []
  type: TYPE_NORMAL
- en: Before any .NET migration, it is critical that you consult Microsoft’s documentation,
    where any known breaking changes are outlined.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET breaking changes fall into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary incompatible** : Existing binaries may fail to load and may need to
    be recompiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source incompatible** : Code may require change in order to compile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral change** : Code and binaries may behave differently after update,
    meaning code changes would be required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Microsoft is usually pretty effective in avoiding major breaking changes,
    checking the documentation at [https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0](https://learn.microsoft.com/en-us/dotnet/core/compatibility/9.0)
    ahead of time will provide valuable insight into any potential issues you may
    face. On top of this, if a breaking change does find its way into the minimal
    API post-update, unit and integration tests will increase the chances of the breaking
    changes being caught.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft outlines breaking changes for different areas of .NET. For minimal
    APIs, you will be most concerned with changes in the area of ASP.NET, but ensure
    you review other areas, such as core .NET libraries, deployment, networking, SDK,
    MSBuild, and serialization, as these are secondary areas that are all relevant
    to minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there are only two breaking changes outlined in ASP.NET
    for .NET 9, which are summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DefaultKeyResolution.ShouldGenerateNewKey** : There is a different meaning
    behind Boolean (true/false) result returned in previous versions. This breaking
    change is caused by a redefinition of the **true/false** result returned by **ShouldGenerateNewKey**
    . Let’s delve into this in more detail:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When managing keys in your minimal API, if you’re using ASP.NET’s default implementation
    to generate the key, there is a Boolean that is provided to tell you whether a
    new key should be generated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, the result of the Boolean was produced based on whether the default
    key was within two days of expiration.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It was decided that “within two days” of expiration was not appropriate on its
    own, as there are other factors that could influence whether the key should be
    regenerated. Now, the result of **ShouldGenerateNewKey** is based on several factors
    related to **IdefaultKeyResolver** as well as whether or not a default key exists
    in the first place, rather than an arbitrary meaning based on whether the key
    is two days away from expiry.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a minimal API application starts, you can specify in **UseDefaultServiceProvider**
    whether validation should be run on registered services and service scopes. Previously,
    validation was always turned off by default. Let’s break down this change a little
    further to see whether it affects your existing code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation of services ensures that all services can be created at startup.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation of scopes checks that scoped services are not resolved from the
    root provider, which would violate their scope.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this meant that no validation was performed by default. You had to
    turn on the previous validation for it to be executed when the application is
    loaded. However, validation is now performed by default.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, there are no major breaking changes when moving a minimal API
    to .NET 9 (at least where ASP.NET Core is concerned). However, it is still important
    to be prepared for any potential change. With that in mind, how would we mitigate
    these changes?
  prefs: []
  type: TYPE_NORMAL
- en: For **DefaultKeyResolution.ShouldGenerateNewKey** affecting key resolution,
    you only really need to act if you have written logic that is now redundant thanks
    to the way .NET 9 checks for an expired key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if previously you were checking that a default key exists, you
    no longer need to do this, because .NET 9 does this for you. The impact of this
    change is therefore fairly minimal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For **UseDefaultServiceProvider** , the required changes are simple. If by updating
    your minimal API to .NET 9 you start to see errors on startup owing to the fact
    that validation of services and scope is now enabled by default, you must address
    the outputted validation errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most basic scenarios, it is unlikely that your minimal API is configured
    in such a way that services could not be resolved or scoped services are being
    incorrectly resolved from the root provider, but it is still important to be aware
    of these factors.
  prefs: []
  type: TYPE_NORMAL
- en: Accuracy at the time of writing and other affected areas of .NET
  prefs: []
  type: TYPE_NORMAL
- en: It is important to emphasize that these changes were reported before the release
    of .NET 9, during its preview. Developers must consult Microsoft’s documentation
    before any migration to see whether any further breaking changes have been reported.
    Moreover, the summary provided in this book is only targeting ASP.NET Core, which
    is the main area we are concerned with when writing minimal APIs. However, other
    areas mentioned, such as the .NET SDK, networking, and serialization, could all
    affect minimal API projects depending on the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored the potential compatibility issues we face when publishing
    a minimal API application to .NET 9, let’s look at the various methods of deployment
    we have at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to deploy a minimal API project, and exploring
    them all would be way out of the scope of this book. However, we can look at some
    of the most common deployment targets.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Microsoft Azure App Service (cloud deployment)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying to Azure App Service is very straightforward and can be achieved using
    a publish profile in Visual Studio. A publish profile is a configuration object
    that specifies how a project should be deployed. It contains metadata about the
    type of runtime in play, the target architecture (x86, ARM, etc.), and the target
    host, which in this example will be Azure.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this example, I’m assuming that an Azure App Service instance
    exists in your Azure subscription, to which you are allowed to deploy. If an App
    Service instance does not exist in Azure, you will need to create one.
  prefs: []
  type: TYPE_NORMAL
- en: The pricing for Azure app services can be calculated via Microsoft’s pricing
    calculator at https://azure.microsoft.com/en-gb/pricing/calculator/. At the time
    of writing, there is a free tier that allows for basic testing which will probably
    be suitable for most people reading this book to practice their deployment. A
    basic tier app service currently costs approx $55-60 per month, but this can increase
    depending on the use case and the required specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of an App Service instance is out of the scope of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, right-click on the project you wish to deploy in **Solution Explorer**
    in Visual Studio and then click **Publish…** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6: Publishing from Solution Explorer in Visual Studio](img/B20968_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Publishing from Solution Explorer in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have any publish profiles already set up, you will see the **Publish**
    dialog. If you don’t see this, it’s because you do already have a publish profile
    for another deployment. You can select **Add a publish profile** to open the **Publish**
    dialog if this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you see the **Publish** dialog, select **Azure** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7: Selecting a publish target in Visual Studio](img/B20968_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Selecting a publish target in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Then select **Azure App Service** , ensuring that you select the correct operating
    system running on the target App Service in Azure (Windows or Linux).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen will then request that you choose your Azure subscription. If
    you’re not already logged in to Azure, you can connect using the option at the
    top right of the dialog.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once connected, you should see your Azure subscription in the dropdown, along
    with the available App Service instances to deploy to. Select the service you
    wish to target and click **Next** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8: Choosing the target Azure App Service resource](img/B20968_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Choosing the target Azure App Service resource'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will be asked whether you wish to publish using a **.pubxml** file
    or via GitHub Actions. We won’t be covering continuous integration/continuous
    delivery pipelines such as GitHub Actions in this book, so select **Publish**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9: Choosing the publish output type](img/B20968_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Choosing the publish output type'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is complete, the dialog will close and your new publish profile is
    created. From there you can see and change the publish settings, such as what
    configuration you will be publishing (almost always **Release** ), the framework
    which in our example is .NET9, the deployment mode, which is either **Framework
    - dependent** or **Self - contained** (More on that below) and the target runtime
    which in my example is **64bit Linux** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: The newly created publish profile](img/B20968_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: The newly created publish profile'
  prefs: []
  type: TYPE_NORMAL
- en: Do this and your application will be built before being deployed to the target
    App Service. Once completed, Visual Studio will automatically open a browser window
    and navigate to the minimal API’s URL.
  prefs: []
  type: TYPE_NORMAL
- en: Framework-dependent versus self-contained deployment modes
  prefs: []
  type: TYPE_NORMAL
- en: You have two choices of deployment mode. **Framework-dependent** requires that
    .NET 9 (or whichever version you are using) is installed on the target machine.
    **Self-contained** will package the runtime with the application. The former produces
    a smaller set of output files but has the drawback of requiring the specific .NET
    version to be installed on the target machine, whereas the latter has a larger
    output but has fewer prerequisites for the target machine for the application
    to run, making it more portable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s move on to deploying to a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to a Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET and .NET Core are already well positioned to offer cross-platform functionality,
    but there are still subtle differences in configuration depending on the host
    operating system. Containerizing your minimal API application with Docker can
    make it agnostic, meaning that it doesn’t care what operating system it’s running
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you must ensure that Docker is installed on your system. Documentation
    outlining this is available at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    . For Windows, you will need to install Docker Desktop, documentation for which
    can be found here at [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)
    , whereas for Linux, simply running Docker Engine should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed the install, you need to create a Dockerfile, which
    will describe how your minimal API project should be packaged into a Docker container
    as well as how it should run on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create this file within your project as a new item in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the button at the top left of **Solution Explorer** to change the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.11: Changing view options in Solution Explorer](img/B20968_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Changing view options in Solution Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Folder View** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.12: Switching to Folder View](img/B20968_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: Switching to Folder View'
  prefs: []
  type: TYPE_NORMAL
- en: Then, right-click your project folder and select **Add** | **New File** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.13: Creating a new file in the project within Folder View](img/B20968_14_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Creating a new file in the project within Folder View'
  prefs: []
  type: TYPE_NORMAL
- en: A Docker file has no name, just an extension of **.dockerfile** . Create this
    file. It should then open as a tab in Visual Studio. (There are reports of issues
    with Docker files not working unless they are called **Dockerfile** , so you can
    try this if you are having similar issues.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can write the Docker file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to specify a base image to be used for the runtime environment
    of the minimal API application. We can pull the official .NET 9 ASP.NET runtime
    image from Microsoft’s container registry like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can tell Docker that we want to set the working directory inside the
    container to **/app** , so that any subsequent commands will be executed relative
    to this directory. We will also specify that we wish to expose port **80** on
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add a section that downloads the .NET 9 SDK, which will be required
    as the full runtime necessary for compiling the minimal API application. We then
    set the working directory again, this time to a folder of our choice; we’ll choose
    **/src** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, the entire content of the current directory is copied into
    the **/src** directory inside the container so that it can be built, **dotnet
    restore** is executed to add any NuGet packages required as dependencies, and
    the app is compiled in release mode to the **/** **app** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point in the execution, the container will have been built. Finally,
    we can add a section to the Docker file that runs the built container by copying
    the container assemblies and running from the DLL output by .NET after compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have specified how the image for the container should be built,
    but we haven’t yet triggered the build. To do this, open a terminal or command
    prompt window running from your project directory and run the following command,
    replacing **MYAPINAME** with a suitable image name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this command, we are creating a tag for the image being built with the given
    name, and then we use **.** to indicate that the build context for the image is
    the current directory where the Docker file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once built, you can run the container to start the app, which should be available
    to receive requests on a port of your choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this command, we have told Docker Engine to run the container with **-d**
    (detached mode), which allows it to run in the background. We then used **-p**
    to specify that port **80** on the container should be mapped to port **8080**
    on the host machine. This means your minimal API will be available at **http://localhost:8080**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is one other method you can use that is extremely simple: deploying
    to the built-in Kestrel web server.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on-premises with Kestrel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you simply want to host your minimal API as an ASP.NET Core application on
    a Windows machine, you can create a new publish profile and then follow the publish
    profile wizard in Visual Studio outlined earlier in this chapter. However, instead
    of choosing Azure as the target, choose **Folder** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14: Choosing Folder as the publish target](img/B20968_14_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Choosing Folder as the publish target'
  prefs: []
  type: TYPE_NORMAL
- en: On selection, the wizard will ask you to specify a target folder to deploy to.
    This folder can be local, or it can be a network path on a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Once published, the resulting **.EXE** file can be double-clicked and the application
    will run using the Kestrel web server, which listens on port **5000** by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to change the port, you can do so via the **appsettings.json**
    file in your project by adding the following (e.g., change to port **8080** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ve explored a high-level overview of how we can prepare our minimal APIs
    for their inevitable deployment and consumption by end users. Now, we’re nearing
    the end of our journey. Let’s summarize what we’ve learned in this final chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve navigated through the crucial steps required to prepare
    minimal APIs for production, focusing on testing, compatibility with .NET 9, and
    deployment strategies. Each of these aspects plays a pivotal role in ensuring
    that your APIs are robust, compatible, and seamlessly delivered to end users.
  prefs: []
  type: TYPE_NORMAL
- en: We explored unit testing, which isolates and validates individual components,
    and integration testing, which ensures that different parts of the system work
    together correctly. Through practical examples with xUnit, we demonstrated how
    to set up and execute these tests to validate functionality and performance. The
    key takeaway is that thorough testing—whether through unit tests or integration
    tests—helps catch potential issues early, reducing the likelihood of bugs slipping
    into production and ensuring that your API meets its acceptance criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility with .NET 9 is crucial for maintaining the longevity and efficiency
    of your minimal APIs. We discussed the importance of understanding breaking changes
    and adapting your code base accordingly. By keeping abreast of Microsoft’s documentation
    on .NET 9 changes, and leveraging unit and integration tests, you can mitigate
    the impact of any breaking changes. This proactive approach ensures that your
    APIs continue to function correctly with the latest .NET version and provides
    a smoother transition during migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment encompasses several methods tailored to different environments and
    needs. We covered deployment to Microsoft Azure App Service, which offers a straightforward,
    scalable solution for cloud environments. We also explored containerization with
    Docker, providing a portable, cross-platform deployment option. For on-premises
    deployments, running minimal APIs directly with Kestrel offers a simple and effective
    approach. Each deployment method has its own set of configurations and considerations,
    such as choosing between framework-dependent and self-contained deployments or
    managing container ports and environment settings.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that your minimal APIs are well tested, compatible with the latest
    .NET versions, and deployed using the most suitable method empowers you to deliver
    high-quality, reliable software. By applying the practices outlined in this chapter,
    you set a solid foundation for successful deployment and long-term maintenance
    of your APIs, contributing to both immediate operational success and future scalability.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now at the end of our minimal API journey, and as the book ends, I hope
    you’ve gained a solid understanding of how to create minimal APIs in various use
    cases and that you’ve found the experience enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: The book has been a joy for me to write as someone who is passionate about the
    use of minimal APIs in varying use cases and contexts. APIs are critical to nearly
    all modern software systems, and I think a good knowledge of minimal APIs and
    their advantages will give any .NET developer an edge in their programming career.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading. Now go and build some more minimal APIs!
  prefs: []
  type: TYPE_NORMAL
