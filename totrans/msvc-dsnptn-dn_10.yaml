- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Performing Health Checks on Your Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对您的服务执行健康检查
- en: Maintaining maximum uptime is an important aspect of any system. In the previous
    chapter, we saw where we can write code in a fault-tolerant manner that will reduce
    the prevalence of outages in our infrastructure and network. This, however, is
    not a long-term solution, and things fail regardless of these measures. It then
    leads to the notion that we need to know when there are failures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 维护最大正常运行时间是任何系统的一个重要方面。在前一章中，我们看到了我们可以以容错的方式编写代码，这将减少我们基础设施和网络中故障的发生频率。然而，这并不是一个长期解决方案，事情无论采取这些措施与否都会失败。这导致了一个观点，即我们需要知道何时出现故障。
- en: This is where we start thinking about health checks. Health checks exist as
    a mechanism to inform us of outages in our services and supporting databases and
    connections in our application. Generally, this can be accomplished with a simple
    ping request to a resource. The resource is available and operating as expected
    if we get a response. In the absence of a response, we assume that the resource
    is down and trigger an alert.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始考虑健康检查的地方。健康检查作为一种机制，可以通知我们服务的故障以及我们应用程序中支持数据库和连接的故障。通常，这可以通过对资源发送一个简单的
    ping 请求来完成。如果收到响应，则表示资源可用且按预期运行。如果没有响应，我们假设资源已关闭并触发警报。
- en: There are statuses between the service’s up and down status, and we will discover
    those options in this chapter. We will also explore some of the functionality
    that .NET Core provides to implement these checks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的上线和下线状态之间存在状态，我们将在本章中探讨这些选项。我们还将探索 .NET Core 提供的一些功能，以实现这些检查。
- en: In this chapter, we will look at various scenarios and countermeasures that
    we can implement when navigating possible failures in our microservices architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在导航我们微服务架构中可能出现的故障时，我们可以实施的各种场景和应对措施。
- en: 'After reading this chapter, we will be able to do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，我们将能够做到以下几点：
- en: Understand why health checks are necessary
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为什么健康检查是必要的
- en: Understand how to implement health checks in ASP.NET Core
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在 ASP.NET Core 中实现健康检查
- en: Understand how orchestrators monitor and respond to failures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解编排器如何监控和响应故障
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at this URL: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在项目仓库中找到，该仓库托管在 GitHub 上，网址为：[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10)。
- en: Health checks and microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查与微服务
- en: A health check allows us to monitor the health of our services. Frankly, another
    service or resource that exposes an HTTP endpoint becomes a capable candidate
    for health checks. We can simply make a request to this endpoint and hope for
    a response that indicates a successful response. The simplest form of a health
    check can come from implementing a simple `GET` request, which returns a `200OK`
    HTTP response. We can add further intelligence to such an endpoint, check connectivity
    to other key services, and use those to influence the response code returned.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查使我们能够监控我们服务的健康状况。坦白说，任何暴露 HTTP 端点的另一个服务或资源都成为健康检查的有能力候选人。我们可以简单地向该端点发送请求，并希望得到一个表示成功响应的响应。最简单的健康检查形式可以来自实现一个简单的
    `GET` 请求，它返回一个 `200OK` HTTP 响应。我们可以向这样的端点添加更多智能，检查与其他关键服务的连接性，并使用这些信息来影响返回的响应代码。
- en: Health checks are useful mechanisms for both monolithic and microservices applications.
    In the context of microservices, however, we have an increased challenge of monitoring
    and maintaining several services. Even more so if they are configured to scale
    on individual levels. Health checks can be used to monitor the health and uptime
    of interdependent services and carry out some form of corrective action when a
    service is down.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查对于单体和微服务应用程序都是有用的机制。然而，在微服务的情况下，我们面临着一个更大的挑战，那就是监控和维护多个服务。尤其是如果它们被配置为在单个级别上进行扩展。健康检查可以用来监控相互依赖服务的健康和正常运行时间，并在服务出现故障时执行某种形式的纠正操作。
- en: Using .NET Core, we can return a successful response and include additional
    information that gives some details on the health of the service. In this case,
    we cannot simply go by the `200OK` response, but we need to interrogate the actual
    response body to check whether the service is healthy, degraded, or unhealthy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Core，我们可以返回一个成功的响应，并包含一些关于服务健康状况的详细信息。在这种情况下，我们不能仅仅根据 `200OK` 响应来判断，我们需要检查实际的响应体以确定服务是否健康、降级或不健康。
- en: '*Figure 10.1* shows a typical health check:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1* 展示了一个典型的健康检查：'
- en: '![Figure 10.1 – Shows a health check request and healthy response after verifying
    that all services are available](img/Figure_10.1_B19100.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 展示了在确认所有服务都可用后的健康检查请求和健康响应](img/Figure_10.1_B19100.jpg)'
- en: Figure 10.1 – Shows a health check request and healthy response after verifying
    that all services are available
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 展示了在确认所有服务都可用后的健康检查请求和健康响应
- en: 'Let’s break down what each state entails:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解每个状态的含义：
- en: '**Healthy**: This indicates that the service is healthy and the application
    is operating as expected'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：这表示服务是健康的，并且应用程序正在按预期运行'
- en: '**Degraded**: This indicates that the service is live, but some functionality
    may be unavailable'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降级**：这表示服务正在运行，但某些功能可能不可用'
- en: '**Unhealthy**: This indicates that the service is failing and is not operating
    as expected'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不健康**：这表示服务正在失败，并且没有按预期运行'
- en: '*Figure 10.2* shows a failed health check:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.2* 展示了一个失败的健康检查：'
- en: '![Figure 10.2 – Shows a health check that sent a failure response since one
    of the services was not available](img/Figure_10.2_B19100.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 展示了一个由于某个服务不可用而发送了失败响应的健康检查](img/Figure_10.2_B19100.jpg)'
- en: Figure 10.2 – Shows a health check that sent a failure response since one of
    the services was not available
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 展示了一个由于某个服务不可用而发送了失败响应的健康检查
- en: The health of a service depends on several things, including correct configuration,
    access to keys and dependencies, the status of the hosting platform and infrastructure,
    and the connection to the database. They may also be used for external application
    monitoring and overall application health.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的健康状态取决于多个因素，包括正确的配置、访问密钥和依赖项、托管平台和基础设施的状态，以及与数据库的连接。它们还可以用于外部应用程序监控和整体应用程序健康。
- en: A common deployment model for microservices is using container orchestrators,
    such as *Kubernetes*, to deploy and run our services in production. Most orchestrators
    perform periodical *liveness health checks* on their pods during runtime and *readiness
    health checks* during deployments. Health checks help the orchestrator determine
    which pods are in a ready state and are capable of handling traffic. It is important
    to understand the differences between the liveness health check and the readiness
    health check and when which one is most suitable. The easier one to implement
    is the liveness health check; we will discuss this next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一种常见部署模式是使用容器编排器，如 *Kubernetes*，在生产环境中部署和运行我们的服务。大多数编排器在运行时会对它们的 pod 进行定期的
    *活跃性健康检查*，并在部署期间进行 *就绪性健康检查*。健康检查有助于编排器确定哪些 pod 处于就绪状态，并且能够处理流量。了解活跃性健康检查和就绪性健康检查之间的区别以及何时使用哪一个非常重要。最容易实现的是活跃性健康检查；我们将在下一节讨论这个问题。
- en: The liveness health check
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃性健康检查
- en: The liveness health check endpoint is a specific endpoint that is implemented
    for the sole purpose of the health check. In this health probe, the service is
    considered healthy when it responds to the *liveness health check*. A failure
    to respond to this endpoint indicates a serious issue with the application. This
    issue could be caused by a range of reasons, such as a crash or unplanned application
    restart. For this reason, restarting an application that has failed this check
    is a common course of action.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃性健康检查端点是专门为实现健康检查目的而实现的特定端点。在这个健康探测中，当服务响应 *活跃性健康检查* 时，我们认为它是健康的。无法响应此端点表明应用程序存在严重问题。这个问题可能是由于多种原因造成的，例如崩溃或计划外应用程序重启。因此，重启未通过此检查的应用程序是一种常见的做法。
- en: Applications that monitor the infrastructure, such as *Kubernetes* monitoring
    Docker containers, use *liveness health checks* to determine the health of pods
    and trigger restarts as needed. Cloud providers also offer health probe functionality
    with load balancers, which can check the availability of the deployed application
    by periodically sending a request to the liveness check endpoint. This approach
    is generally sufficient for web applications and services as we do not need a
    complicated liveness check endpoint. If the service can accept the request and
    return a response, then we consider it healthy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 监控基础设施的应用程序，例如监控Docker容器的*Kubernetes*，使用*存活健康检查*来确定Pod的健康状况并在需要时触发重启。云提供商还提供了与负载均衡器一起的健康探测功能，可以通过定期向存活检查端点发送请求来检查已部署应用程序的可用性。这种方法通常对于Web应用程序和服务来说是足够的，因为我们不需要复杂的存活检查端点。如果服务可以接受请求并返回响应，那么我们将其视为健康状态。
- en: Checking whether the application or services is alive is simple enough, but
    we may also need to mitigate false positives after application deployments and/or
    upgrades. This can occur when the application might not be completely ready for
    usage, yet we are getting positive responses from the liveness checks. At this
    point, we need to consider implementing *readiness health checks*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 检查应用程序或服务是否存活很简单，但在应用程序部署和/或升级后，我们也可能需要减轻误报。这可能会发生在应用程序可能尚未完全准备好使用时，而我们却收到了来自存活检查的积极响应。在这种情况下，我们需要考虑实施*就绪健康检查*。
- en: Readiness health checks
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就绪健康检查
- en: '*Readiness health checks* are used in situations where we need to verify more
    than just an HTTP response. An application with several third-party dependencies
    might take longer to be ready for use. So, while it is operational and able to
    respond to a simple HTTP request, the databases or message bus services, for instance,
    might not yet be ready. We want to ensure that we have a full picture of the status
    of the application from a startup perspective before proceeding to use it or continuing
    with the deployment activity.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*就绪健康检查*用于需要验证不仅仅是HTTP响应的情况。具有多个第三方依赖的应用程序可能需要更长的时间才能准备好使用。因此，尽管它能够运行并能响应简单的HTTP请求，但数据库或消息总线服务等可能尚未就绪。我们希望在继续使用它或继续部署活动之前，确保我们对应用程序从启动角度的状态有一个全面的了解。'
- en: A *readiness health check* will generally only return a healthy status once
    the startup task has been completed. These checks will then take a bit longer
    to return a healthy status than a *liveness health check* will. With readiness
    health checks in place, an orchestrator will not attempt to restart the application,
    but it will not route request traffic. *Kubernetes* can perform readiness probes
    periodically during the application’s runtime, but it can also be configured to
    only perform this probe during the startup of the application. Once the application
    reports that it is healthy, then this probe will not be executed again for the
    lifetime of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*就绪健康检查*通常只有在启动任务完成后才会返回健康状态。这些检查将比*存活健康检查*需要更长的时间来返回健康状态。就绪健康检查到位后，编排器不会尝试重启应用程序，但也不会路由请求流量。*Kubernetes*可以在应用程序的运行时定期执行就绪探测，但它也可以配置为仅在应用程序启动时执行此探测。一旦应用程序报告其健康，则此探测在整个应用程序的生命周期内将不再执行。
- en: This *readiness health check* is best used for applications where there are
    long-running tasks that must finish before the application can be considered ready
    and operational. Recall that with microservices, we introduce several additional
    infrastructure dependencies, and we need to monitor and confirm the overall health
    of the system to ensure that only the healthiest pods get traffic directed to
    them. Therefore, properly configuring health checks is essential to ensuring that
    we have the best representation of our application’s health.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*就绪健康检查*最适合用于那些在应用程序被认为就绪和可操作之前必须完成的长时间运行任务的应用程序。回想一下，在微服务中，我们引入了几个额外的基础设施依赖项，我们需要监控和确认系统的整体健康状况，以确保只有最健康的Pod才会被分配流量。因此，正确配置健康检查对于确保我们有我们应用程序健康状况的最佳表示至关重要。
- en: Now that we have explored how health checks work and how orchestrators and monitoring
    systems use them, we can explore implementing health checks in our ASP.NET Core
    API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了健康检查的工作原理以及编排器和监控系统如何使用它们，我们可以探索在我们的ASP.NET Core API中实现健康检查。
- en: Implementing ASP.NET Core health checks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ASP.NET Core健康检查
- en: ASP.NET Core has a built-in health check middleware that allows us to natively
    implement very robust health checks. This middleware is not limited to API projects,
    and it comes in handy to help us to monitor the health of our application. Both
    readiness and liveness health checks can be created natively, and there is support
    for a UI dashboard. Using the liveness health check, which is relatively simple
    to implement, we can implement a simple API endpoint that returns a simple response,
    as expected. We can also check on the health of the dependencies of the app using
    a more comprehensive readiness health check.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 有一个内置的健康检查中间件，允许我们原生实现非常健壮的健康检查。此中间件不仅限于 API 项目，而且对我们监控应用程序的健康状况非常有用。原生创建就绪性和存活性健康检查，并支持
    UI 仪表板。使用相对简单的存活性健康检查，我们可以实现一个简单的 API 端点，返回预期的简单响应。我们还可以使用更全面的就绪性健康检查来检查应用程序的依赖项的健康状况。
- en: For this example, we will be adding liveness and readiness health checks to
    our appointment booking service. This service has several dependencies and is
    integral to several operations in our application. We need to ensure that it is
    always healthy and react quickly if it degrades.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将向我们的预约预订服务添加存活性和就绪性健康检查。此服务有多个依赖项，并且对我们应用程序中的几个操作至关重要。我们需要确保它始终保持健康状态，并在它降级时快速响应。
- en: Let us start off by exploring how we can outfit an ASP.NET Core API with a liveness
    health check.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先探讨如何为 ASP.NET Core API 配置一个存活性健康检查。
- en: Adding liveness health checks
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加存活性健康检查
- en: As discussed, a liveness check is the most basic health check that can be implemented.
    The basic configuration needed for this in our ASP.NET Core application is to
    register the `AddHealthChecks` service and the addition of the health check middleware,
    where we define a URL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，存活性检查是可以实现的最基本的健康检查。在我们的 ASP.NET Core 应用程序中，为此所需的基本配置是注册 `AddHealthChecks`
    服务和添加健康检查中间件，其中我们定义了一个 URL。
- en: 'We make the following changes to the `Program.cs` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `Program.cs` 文件进行了以下修改：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any attempt to navigate to the `/healthcheck` endpoint will yield a simple plain
    text response as `HealthStatus`. The possible `HealthStatus` values are `HealthStatus.Healthy`,
    `HealthStatus.Degraded`, or `HealthStatus.Unhealthy`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试导航到 `/healthcheck` 端点的操作都将返回一个简单的纯文本响应，作为 `HealthStatus`。可能的 `HealthStatus`
    值有 `HealthStatus.Healthy`、`HealthStatus.Degraded` 或 `HealthStatus.Unhealthy`。
- en: 'Health checks are created using the `IHeathCheck` interface. This interface
    allows us to extend the default health checks and add more logic to our health
    check and further customize the possible response values. We can create a health
    check extension using the following code block:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是通过 `IHeathCheck` 接口创建的。此接口允许我们扩展默认的健康检查，并为我们的健康检查添加更多逻辑，进一步自定义可能的响应值。我们可以使用以下代码块创建一个健康检查扩展：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This inheriting from `IHeathCheck` forces us to implement the `CheckHealthAsync`
    method. This method gets called when a health check is triggered, and we can include
    additional code to check other factors and determine whether we deem our application
    to be healthy or not. Based on the value of `healthy`, we can return a custom
    message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `IHeathCheck` 继承迫使我们必须实现 `CheckHealthAsync` 方法。当健康检查被触发时，此方法会被调用，我们可以包含额外的代码来检查其他因素，并确定我们是否认为我们的应用程序是健康的。根据
    `healthy` 的值，我们可以返回一个自定义消息。
- en: 'Now to add `HealthCheack` to our services, we modify the `AddHealthChecks`
    service registration like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要将 `HealthCheack` 添加到我们的服务中，我们修改 `AddHealthChecks` 服务注册如下：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we add our new health check logic and give it a name for a specific reference
    in other parts of the application. This `AddCheck` method allows us to define
    a name for the health check, a default failure status value, tags to map to custom
    health check endpoints, and a default timeout value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了新的健康检查逻辑，并为它在应用程序的其他部分提供了一个特定的名称作为参考。此 `AddCheck` 方法允许我们为健康检查定义一个名称、默认失败状态值、映射到自定义健康检查端点的标签以及默认超时值。
- en: 'Now building on the notion that our orchestrators and load balancers that are
    performing health checks will also prefer to see appropriate responses relative
    to the health status, we can extend the `app.MapHealthChecks` middleware code
    to return a specific HTTP response relative to the health status. While we are
    at it, we can also disable cached responses:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基于我们的编排器和负载均衡器在执行健康检查时也倾向于看到与健康状况相关的适当响应这一概念，我们可以扩展 `app.MapHealthChecks`
    中间件代码，以返回与健康状况相关的特定 HTTP 响应。在此过程中，我们还可以禁用缓存响应：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next thing we may want to investigate is returning details in our response.
    As it stands, we are only returning the plain text response with the status. We
    can use methods found in the `System.Text.Json` library to create a custom delegate
    method that can be implemented as follows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来可能想要调查的是在我们的响应中返回详细信息。目前，我们只返回带有状态的纯文本响应。我们可以使用`System.Text.Json`库中的方法创建一个自定义委托方法，如下所示。
- en: 'We first need to indicate to the middleware that we have a custom `ResponseWriter`
    called `WriteJsonResponse`. We need to add this to the list of `HealthCheckOptions`,
    using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要向中间件指示我们有一个名为`WriteJsonResponse`的自定义`ResponseWriter`。我们需要将其添加到`HealthCheckOptions`列表中，使用以下方式：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then define the `WriteJsonResponse` writer with the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下方式定义`WriteJsonResponse`写入器：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 10.3* shows the results of a health check:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.3*显示了健康检查的结果：'
- en: '![Figure 10.3 – Shows a health check response where both the service and database
    are available and in good health](img/Figure_10.3_B19100.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 显示了服务和数据库都可用且状态良好的健康检查响应](img/Figure_10.3_B19100.jpg)'
- en: Figure 10.3 – Shows a health check response where both the service and database
    are available and in good health
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 显示了服务和数据库都可用且状态良好的健康检查响应
- en: Now we can include details about the health status if the API reports an unhealthy
    or degraded status. Furthermore, when we add more health checks, the content of
    this JSON response will be populated with each check’s details.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以包括有关API报告不健康或降级状态的健康状态的详细信息。此外，当我们添加更多健康检查时，此JSON响应的内容将用每个检查的详细信息填充。
- en: '*Figure 10.4* shows the results of an unhealthy check:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.4*显示了不健康检查的结果：'
- en: '![Figure 10.4 – Shows a health check response where the database is not available](img/Figure_10.4_B19100.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 显示了数据库不可用的健康检查响应](img/Figure_10.4_B19100.jpg)'
- en: Figure 10.4 – Shows a health check response where the database is not available
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 显示了数据库不可用的健康检查响应
- en: 'Now that we have more detailed responses, we can add more detailed checks,
    such as a database probe. This will serve as a check to verify that the API can
    communicate with the database through the configured database. By extension, since
    we are using Entity Framework for this connection, we can implement a `DbContext`
    check. We start with the `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    NuGet package. We then modify the `AddHealthChecks` method registration using
    the following piece of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更详细的响应，我们可以添加更详细的检查，例如数据库探测。这将作为检查以验证API可以通过配置的数据库与数据库通信。由于我们使用Entity
    Framework进行此连接，我们可以实现一个`DbContext`检查。我们从`Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    NuGet包开始。然后我们使用以下代码片段修改`AddHealthChecks`方法注册：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This context health calls Entity Framework Core’s built-in `CanConnectAsync`
    method and uses that response to infer the database connectivity health.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此上下文健康调用Entity Framework Core的内置`CanConnectAsync`方法，并使用该响应来推断数据库连接健康。
- en: Now that we can check on the health of our service and its connectivity to our
    database let us configure it for readiness checks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查我们服务的健康状态及其与数据库的连接性，让我们为就绪性检查进行配置。
- en: Adding readiness health checks
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加就绪性健康检查
- en: As we have discussed, the readiness check indicates when the application and
    its dependencies have started successfully and are ready to begin receiving requests.
    We can define a separate endpoint for the readiness check and further customize
    the checks that should be performed based on the URL used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，就绪性检查指示应用程序及其依赖项是否已成功启动并准备好开始接收请求。我们可以为就绪性检查定义一个单独的端点，并根据使用的URL进一步自定义应执行的检查。
- en: 'To implement liveness and readiness checks on different URLs, we can add a
    `tags` parameter to the extensions to the `AddHealthChecks` method. This allows
    us to pass in an array of tag names. We can tag our health checks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的URL上实现活动性和就绪性检查，我们可以在`AddHealthChecks`方法的扩展中添加一个`tags`参数。这允许我们传入一个标签名称数组。我们可以这样标记我们的健康检查：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have tagged our health checks, we can proceed to create our specific
    check endpoints and associate them with the tags:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经标记了我们的健康检查，我们可以继续创建我们的特定检查端点并将它们与标签关联：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this new code, the `/healthcheck/ready` endpoint will filter only health
    checks that are tagged as `ready`. In the `/health/live` endpoint, we set the
    predicate value to `false` to ignore all tags and conduct all health checks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段新代码，`/healthcheck/ready`端点将仅过滤标记为`ready`的健康检查。在`/health/live`端点中，我们将谓词值设置为`false`以忽略所有标签并执行所有健康检查。
- en: While we will not be exploring Kubernetes or other orchestrators in detail,
    we want to look at how orchestrators interact with our health check endpoints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细探讨Kubernetes或其他编排器，但我们想看看编排器如何与我们的健康检查端点交互。
- en: Configuring health probes in orchestrators
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编排器中配置健康探针
- en: Monitoring is not unique to orchestrators, as we have already established. There
    are services that offer monitoring services for our applications and allow us
    to configure probes into our applications. These services generally allow us to
    add alerts and configure response time thresholds. These alerts can come in handy
    in helping us to respond to failures or situations of concern based on our configured
    thresholds.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 监控并非仅限于编排器，正如我们之前已经确立的。有一些服务为我们提供监控服务，并允许我们将探针配置到我们的应用程序中。这些服务通常允许我们添加警报并配置响应时间阈值。这些警报在帮助我们根据配置的阈值响应故障或关注的情况时非常有用。
- en: In a microservices application, we need a way of monitoring many services as
    efficiently as possible. The fewer unique configurations we need to do, the better.
    We have several deployment models that can be used, and most predominantly, containers
    managed by orchestrators. Microsoft Azure has several web application deployment
    models, including **Web App for Containers** (**WAC**), **Azure Container Instances**
    (**ACI**), and **Azure Kubernetes Service** (**AKS**).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务应用程序中，我们需要一种尽可能高效地监控许多服务的方法。我们需要做的唯一配置越少，越好。我们有几种部署模型可以使用，其中最突出的是由编排器管理的容器。Microsoft
    Azure有几种Web应用程序部署模型，包括**容器Web应用程序**（**WAC**）、**Azure容器实例**（**ACI**）和**Azure Kubernetes服务**（**AKS**）。
- en: WAC is a part of App Service, so the health check works the same way as it would
    for an Azure web app. It allows you to specify a health check endpoint that will
    return a response within the 2xx and 3xx HTTP response range. It should also return
    this health check response within a minute for the service to be considered healthy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: WAC是App Service的一部分，因此健康检查的工作方式与Azure Web应用程序相同。它允许你指定一个健康检查端点，该端点将在2xx和3xx
    HTTP响应范围内返回响应。它还应在1分钟内返回此健康检查响应，以便服务被认为是健康的。
- en: The next option is the ACI, where health checks are called health probes. These
    probes are configured with a check period, which determines the frequency with
    which checks are made. When the health check is completed successfully, then the
    container is considered healthy, and if not, then it is unhealthy or just unavailable.
    With the ACI, we can configure both liveness and readiness health checks. Our
    probes can either execute a command on the container or perform an HTTP `GET`
    request. When we perform a liveness probe, we verify that our container is healthy,
    and if not, the ACI might proceed to shut down the container and spin up a new
    instance. The readiness probe is designed to confirm whether a container is available
    for request processing, which, as we discussed, is more important during the application
    startup process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是ACI，其中健康检查被称为健康探针。这些探针配置了检查周期，它决定了检查的频率。当健康检查成功完成时，容器被认为是健康的；如果不成功，则容器是不健康的或只是不可用。使用ACI，我们可以配置存活和就绪健康检查。我们的探针可以在容器上执行命令或执行HTTP
    `GET`请求。当我们执行存活探针时，我们验证容器是否健康；如果不健康，ACI可能会关闭容器并启动一个新的实例。就绪探针旨在确认容器是否可用于请求处理，正如我们之前讨论的，在应用程序启动过程中这一点更为重要。
- en: In the Azure Kubernetes Service of AKS, we have a very similar approach to health
    checks and probes, as we saw in the ACI. Out of the box, Kubernetes supports both
    liveness and readiness probes; as seen before, the major difference is that Kubernetes
    suggests that you have a separate probe for checking the application’s health
    at startup, separate from the readiness probe that is continuous during the application
    runtime. We can also implement HTTP `GET` request probes as well as TCP probes
    to check on our containers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Kubernetes 服务（AKS）中，我们有一个与 ACI 中非常相似的健康检查和探针方法。开箱即用，Kubernetes 支持存活和就绪探针；如之前所见，主要区别是
    Kubernetes 建议您为检查应用程序启动时的健康状态有一个单独的探针，这个探针与在应用程序运行期间持续进行的就绪探针是分开的。我们还可以实现 HTTP
    `GET` 请求探针以及 TCP 探针来检查我们的容器。
- en: Kubernetes is configured using a markup language called `spec.template` field
    of the YAML configuration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用一种名为 `spec.template` 字段的标记语言进行配置。
- en: 'The following is an example of a YAML configuration that creates a deployment
    object that performs startup, liveness, and readiness health checks on a container:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 YAML 配置，它创建了一个执行容器启动、存活和就绪健康检查的部署对象：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The sections of the YAML file that outline the health checks are `livenessProbe`,
    `startupProbe`, and `readinessProbe`. The probe definition with the major difference
    is the readiness probe, which executes a command as opposed to making a call to
    an endpoint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 描述健康检查的 YAML 文件部分是 `livenessProbe`、`startupProbe` 和 `readinessProbe`。与其它探针定义相比，就绪探针的主要区别在于它执行一个命令，而不是调用一个端点。
- en: With this, we have gained some fundamental knowledge of health checks, how they
    work, and why we need them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们获得了一些关于健康检查的基本知识，了解它们是如何工作的，以及为什么我们需要它们。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Health checks are simple yet powerful constructs that aid us in ensuring that
    our applications are running at maximum efficiency. We see where it is important
    for us to not only monitor and report on the uptime of the service but also the
    dependencies, such as the database and other services that may be needed for the
    application to operate properly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是简单而强大的结构，帮助我们确保应用程序以最大效率运行。我们认识到，对于我们来说，不仅要监控和报告服务的正常运行时间，还要监控和报告依赖项，例如数据库和其他可能需要应用程序正常运行的其它服务。
- en: Using ASP.NET Core, we have access to a built-in health check mechanism that
    can be customized and extended to implement specific checks and associate them
    with different endpoints. This is especially useful when we need to separate the
    types of tests that are conducted relative to the endpoint being called.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core，我们可以访问一个内置的健康检查机制，该机制可以自定义和扩展以实现特定的检查，并将它们与不同的端点关联。这在我们需要区分针对被调用端点的测试类型时特别有用。
- en: We have also explored how orchestrators can be configured to poll our health
    check endpoints. Orchestrators make monitoring and responding to failures easier
    since they will handle the routing of traffic to healthy instances and restart
    instances as needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何配置编排器以轮询我们的健康检查端点。编排器使得监控和响应故障变得更容易，因为它们将处理将流量路由到健康实例，并在需要时重启实例。
- en: Health checks help us not only monitor the target web service, but we can also
    configure health checks to report on downstream services as well. This will come
    in handy, especially when we implement dependencies between our microservices
    through patterns like the API gateway pattern. We will investigate implementing
    this pattern in the next chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查不仅帮助我们监控目标网络服务，我们还可以配置健康检查来报告下游服务。这在我们将微服务通过如 API 网关模式等模式实现依赖关系时特别有用。我们将在下一章中探讨实现此模式的方法。
