<html><head></head><body>
		<div><p><a id="_idTextAnchor173"/><a id="_idTextAnchor174"/></p>
			<h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor175"/>Chapter 3</em>: Introducing C# 10</h1>
			<p>C# is an elegant and type-safe object-oriented programming language that allows developers to build a wide range of secure and robust applications that run in the .NET ecosystem and is in the top 5 of the popular programming languages list published by GitHub.</p>
			<p>C# was initially developed by Anders Hejlsberg at Microsoft as part of the .NET initiative. Since its first release in January 2002, there have been new features added consistently to the language to improve performance and productivity.</p>
			<p>C# 10 released with .NET 6 comes with some cool new language features along with enhancements to the features released in earlier versions, which improve developer productivity. In this chapter, we will explore some of the new C# language features:</p>
			<ul>
				<li>Simplification of the using directives</li>
				<li>The record structs</li>
				<li>Improvements to the Lambda expressions</li>
				<li>Enhancements to interpolated strings</li>
				<li>Extended property patterns</li>
				<li>Additions to the caller argument attributes</li>
			</ul>
			<p>By end of this chapter, you'll be familiar with the major new additions to C# 10. Also, this chapter will help us to upskill ourselves to build our next enterprise application in C#.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>Technical requirements</h1>
			<p>You will need the following to understand the concepts of this chapter:</p>
			<ul>
				<li>Visual Studio 2022 version 17.0 Community Edition with the .NET 6.0 runtime</li>
				<li>A basic understanding of Microsoft .NET</li>
			</ul>
			<p>The code used in this chapter can be found at <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/>Simplification of the using directives</h1>
			<p>A top-level statement is a new feature introduced in C# 9.0, which makes it easy for developers to <a id="_idIndexMarker163"/>remove the ceremony code. The project templates that come with Visual Studio 2022 embrace the language changes introduced in C# such as top-level statements. For example, if you create a <code>Console</code> application, you will see the <code>Program.cs</code> file contains the code shown in the following snippet:</p>
			<pre class="source-code">// See https://aka.ms/new-console-template for more //information</pre>
			<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
			<p>The preceding code came with a <code>console</code> application template that did not have the ceremony code such as class definition and the <code>main</code> method. This simplified the number of lines we could write by removing the redundant code.</p>
			<p>The concepts of the <code>implicit</code> using directives and <code>global</code> using directives introduced in C# 10 reduce the repetition of the <code>using</code> statements in each CS file. </p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor180"/>The global using directives</h2>
			<p>With the <code>global</code> <code>using</code> <a id="_idIndexMarker164"/>directives, we do not repeat the namespace <code>using</code> statements in all the <code>.cs</code> files. The <code>global</code> keyword is used to mark a <code>global</code> <code>using</code> directive as shown in the following code snippet:</p>
			<pre class="source-code">global using System.Threading;</pre>
			<p>In the preceding code, we marked <code>System.Threading</code> as <code>global</code>. Now, we can reference the types under <code>System.Threading</code> by having the <code>using</code> directive at the start of the <code>.cs</code> file.</p>
			<p>We can also create <code>global</code> aliases to the namespaces to resolve the namespace conflicts, as shown in the following code snippet:</p>
			<pre class="source-code">global using SRS = System.Runtime.Serialization;</pre>
			<p>By defining this, we can refer to all the classes defined under <code>System.Runtime.Serialization</code> using the alias name, <code>SRS</code>. We can also define a <code>global using static</code> directive as shown here:</p>
			<pre class="source-code">global using static System.Console;</pre>
			<p>With this, we can use all the <code>static</code> functions defined in the <code>System.Console</code> class directly <a id="_idIndexMarker165"/>without referring to the class name. For example, to write a line to the console, we can just call the <code>WriteLine</code> method without referring to the <code>Console</code> class name, as shown here:</p>
			<pre class="source-code">WriteLine("Hello C# 10");</pre>
			<p>We can specify <code>global</code> <code>using</code> directives in any <code>.cs</code> file of the project. The only constraint is they should appear before any regular file-scoped using directives. The common practice seen among the developers is to create a <code>.cs</code> with the name <code>GlobalUsings.cs</code> and add the <code>global</code> <code>using</code> directive in that file. This will help to restrict the change to a single file when we need to add or remove a <code>global</code> <code>using</code> directive. The scope of the <code>global</code> <code>using</code> directives is the complication unit that is the current project.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor181"/>The implicit using directives</h2>
			<p>In C#, we find a few framework namespaces, such as <code>System</code> and <code>System.Linq</code>, are present in <a id="_idIndexMarker166"/>almost all the classes. With C# 10, these commonly-used namespaces are implicitly added as <code>global</code> using directives. The namespaces added implicitly are based on the project target SDK and are documented here: https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives.</p>
			<p>In addition to these, if we wish to include any other namespace to be part of these implicit directives or remove any of the predefined namespaces, we can do so by adding <code>ItemGroup</code> to the <code>.csproj</code> file, as shown here:</p>
			<pre class="source-code">&lt;ItemGroup&gt;</pre>
			<pre class="source-code">  &lt;Using Include="System.Threading" /&gt;</pre>
			<pre class="source-code">  &lt;Using Remove="System.IO" /&gt;</pre>
			<pre class="source-code">&lt;/ItemGroup&gt;</pre>
			<p>In the previous snippet, we are including <code>System.Threading</code> and removing <code>System.IO</code> from the <code>implicit</code> <code>using</code> directives.</p>
			<p>To completely remove the <code>implicit</code> <code>using</code> directives, we can uncheck the <code>ImplicitUsings</code> flag in the <code>.csproj</code> file as shown here:</p>
			<pre class="source-code">&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;</pre>
			<p>The simplification <a id="_idIndexMarker167"/>of <code>using</code> directives is another step toward removing the redundant ceremony code and making the content in the <code>.cs</code> files concise.</p>
			<p>In the next section, we will explore the <code>record</code> structs introduced with C# 10.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor182"/>The record structs</h1>
			<p>The <em class="italic">record types</em> introduced in C# 9 provide type declaration to create immutable reference types <a id="_idIndexMarker168"/>with synthesized methods for equality check and <code>ToString</code>. C# 10 brings us the <em class="italic">record structs</em>. In this section, we will see what <code>record struct</code> is and how it is different from <code>record class</code>. </p>
			<p>We use the <code>record</code> keyword to declare <code>record class</code>, and we use the same <code>record</code> keyword to declare <code>record struct</code>, as shown in the following code: </p>
			<pre class="source-code">public <strong class="bold">record</strong> struct Employee(string Name);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">In C# 9, to declare a <code>record</code> class, we don't explicitly use the <code>class</code> keyword. We simply specify <code>record</code> to declare it as shown here: <code>public</code> record <code>Shape(string Name);</code></p>
			<p class="callout">Simply using the <code>record</code> keyword will continue to work in C# 10 to declare a <code>record</code> class, but it is recommended to specify <code>class</code> or <code>struct</code> explicitly for better readability.</p>
			<p><code>record struct</code> offers similar benefits to what <code>record class</code> offers, such as the following:</p>
			<ul>
				<li>Simplified declaration syntax</li>
				<li>Value equality</li>
				<li>Reference semantics</li>
				<li>Deconstruction</li>
				<li>Meaningful <code>ToString</code> output </li>
			</ul>
			<p>Let's understand <a id="_idIndexMarker169"/>these by creating a sample <code>Console</code> application and defining an <code>EmployeeRecord</code> record struct. Add the following code to the <code>Program.cs</code> file, which is using the <code>EmployeeRecord</code> record struct defined in the previous code snippet:</p>
			<pre class="source-code">using static System.Console;</pre>
			<pre class="source-code"> public <strong class="bold">record</strong> struct EmployeeRecord(string Name);</pre>
			<pre class="source-code">Employee employee1 = new EmployeeRecord("Suneel", "Kunani");</pre>
			<pre class="source-code">Employee employee2 = new EmployeeRecord("Suneel", "Kunani");</pre>
			<pre class="source-code">WriteLine(employee1.ToString());</pre>
			<pre class="source-code">WriteLine($"HashCode of s1 is :{ employee1.GetHashCode()}");</pre>
			<pre class="source-code">WriteLine($"HashCode of s2 is :{ employee2.GetHashCode()}");</pre>
			<pre class="source-code">WriteLine($"Is s1 equals s2 : { employee1 == employee2}");</pre>
			<pre class="source-code">//deconstruct the fields from the employee object</pre>
			<pre class="source-code">string firstName;</pre>
			<pre class="source-code"> (firstname, var lastname) = employee1;</pre>
			<pre class="source-code">Console.WriteLine($"firstname: {firstname}, lastname:{lastname}");</pre>
			<p>In the preceding code, we are creating two instances of the <code>EmployeeRecord</code> record struct with name field values using the simplified declaration syntax, then printing the hash code of the instance objects, and then checking the equality. Here, we are also deconstructing the fields from the <code>employee</code> object.</p>
			<p>When we run the code, we see the output as shown in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.1_B18507.jpg" alt="Figure 3.1 – Output of record struct example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Output of record struct example</p>
			<p>When we look at the output, we observe that <code>ToString</code> is overridden to include the contents of <a id="_idIndexMarker170"/>the instance. As expected, the hash code of both instances is the same, as the field values are the same. In a regular struct, the hash code of the object is generated based on the first non-nullable field. In the <code>record</code> struct, the <code>GetHashCode</code> method is also overridden to include all the fields to generate the hash code. </p>
			<p>The <code>record</code> struct synthesizes the implementation of the <code>IEquatable&lt;T&gt;</code> interface. It also implements the <code>==</code> and <code>!=</code> operators. The regular struct does not have these operators implemented by default. The regular struct has the <code>Equals</code> method inherited from <code>ValueType</code>, which uses reflection to do the equality check. So, the synthesized equality check in the <code>record</code> struct is more performant. The <code>record</code> struct also synthesizes the <code>Deconstruct</code> method to populate the fields out of the object. If you take a closer look at the deconstruction code, you will notice the mixed declaration of the variables. We have <code>lastName</code> being declared during deconstruction, whereas <code>firstName</code> was declared in the preceding statement. This mixed declaration of variables is only possible in C#10 and above.</p>
			<p>When we disassemble the code in a disassembler tool such as ILSpy or Reflector, we see the generated code as shown in the following figure:</p>
			<div><div><img src="img/Figure_3.2_B18507.jpg" alt="Figure 3.2 – Generated code of the Employee class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Generated code of the Employee class</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can <a id="_idIndexMarker171"/>install ILSpy from <a href="https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy">https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy</a>.</p>
			<p>If we look <a id="_idIndexMarker172"/>closely at the <code>Employee</code> type definition, we can see all the plumbing synthesized by the C# compiler for the <code>record struct</code> type. From this, we can understand that the <code>record</code> struct is basically a struct that implements the <code>IEquatable</code> interface and overrides the <code>GetHashCode</code> and <code>ToString</code> methods. You can overwrite the <code>ToString</code> method to create your own string representation for the record type. Beginning with C# 10, you can also mark the <code>ToString</code> override as sealed, which prevents the compiler from synthesizing a <code>ToString</code> method or derived types from overriding it. Sealing the <code>ToString</code> method in the base record type ensures that the string representation is consistent across all derived types. The compiler also provides the <code>Deconstruct</code> method, which is used to deconstruct the <code>record</code> struct into its component properties. Unlike <code>record</code> classes, the <code>record</code> structs are mutable. To make a <code>record</code> struct immutable, we can add a <code>readonly</code> modifier to the declaration:</p>
			<pre class="source-code">public readonly <strong class="bold">record</strong> struct Employee(string Name);</pre>
			<p>To change <a id="_idIndexMarker173"/>the fields of the <code>readonly record</code> struct, we can use the operator as shown here like with the <code>record</code> class:</p>
			<pre class="source-code">Employee employee2 = employee1 with { LastName = string.Empty };</pre>
			<p>In this section, we have learned about the <code>record</code> struct introduced in C# 10 and how it compares with the <code>record</code> class and regular struct. In the next section, let's learn about improvements to Lambda expressions.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor183"/>Improvements to Lambda expressions</h1>
			<p>A Lambda expression is a way to represent an anonymous method. It allows us to define the method implementation inline.</p>
			<p>A delegate <a id="_idIndexMarker174"/>type may be created from any Lambda expression. The types of a Lambda expression's parameters and return value determine the delegate type to which it can be transformed. A Lambda expression can be changed to an <code>Action</code> delegate type if it doesn't return a value; otherwise, it can be converted to one of the <code>Func</code> delegate types. In this section, we will learn about the improvements C# 10 brings to Lambda expressions. </p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor184"/>Inferring the expression type </h2>
			<p>C# language <a id="_idIndexMarker175"/>compiler will now infer the expression type if the parameter's types are explicit and the return type can be inferred. For example, consider the following code snippet where we defined a Lambda expression to find the square of the given integer:</p>
			<pre class="source-code">Var Square = (int x) =&gt; x * x;</pre>
			<p>In the preceding code, the parameter <code>x</code> type is specified as <code>int</code> and the return type is inferred as <code>int</code> from the expression. If we mouse-hover on <code>var</code> in Visual Studio, we can see the inferred type of the <code>Square</code> Lambda expression, as shown in the next screenshot, which uses the <code>Func</code> delegate:</p>
			<div><div><img src="img/Figure_3.3_B18507.jpg" alt="Figure 3.3 – Inferred type of Square expression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Inferred type of Square expression</p>
			<p>For the code <a id="_idIndexMarker176"/>shown here, the compiler will use the <code>Action</code> delegate, as the expression return type is <code>void</code>:</p>
			<pre class="source-code">var SayHello = (string name) =&gt; Console.WriteLine($"Hello {name}");</pre>
			<p>The inferred type will use <code>Func</code> or <code>Action</code> delegates if it is suitable. Otherwise, the compiler will synthesize a delegate type, for example, if the Lambda expression is taking a <code>ref</code> type, as shown in the following code snippet:</p>
			<pre class="source-code">Var SayWelcome = (ref string name) =&gt; Console.WriteLine($"Welcome {name}");</pre>
			<p>The synthesized type for the previous expression will be an <code>anonymous</code> delegate type.</p>
			<p>The compiler will try to infer the return type based on the expression. Sometimes, it may not be possible to infer the type. We will get a compilation error if it is unable to infer the type information. </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor185"/>Return types for Lambda expressions</h2>
			<p>In situations <a id="_idIndexMarker177"/>where it is not possible for the compiler to infer the return type, we can specify explicitly in C# 10. Consider the following code snippet, where we have <code>record</code> classes of <code>Employee</code> and <code>Manager</code> inherited from a <code>Person</code> record class: </p>
			<pre class="source-code">public record class Person();</pre>
			<pre class="source-code">public record class Employee() : Person();</pre>
			<pre class="source-code">public record class Manager() : Person();</pre>
			<pre class="source-code">var createExpression = (bool condition) =&gt; condition ? new Employee() : new Manager();</pre>
			<p>The <code>createExpression</code> term in the preceding code snippet creates an instance of an <code>Employee</code> or <code>Manager</code> type based on the condition passed in. In this situation, the compiler cannot infer the return type, which will result in a compilation error. With C#10, we can <a id="_idIndexMarker178"/>now explicitly specify the return type for a Lambda expression as shown in the following code:</p>
			<pre class="source-code">var createEmployee = Person (bool hasReportees) =&gt; condition ? new Manager() : new Employee();</pre>
			<pre class="source-code">// Create the Person object based on condition</pre>
			<pre class="source-code">var manager = createEmployee(true);</pre>
			<p>The expression type inferred for the preceding code is <code>Func&lt;bool, Person&gt;</code>. </p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor186"/>Adding attributes to Lambda expressions</h2>
			<p>Starting from C# 10, we can add attributes to the Lambda expressions and their parameters <a id="_idIndexMarker179"/>and return types. The following code snippet defines a Lambda expression to retrieve employees for the given ID: </p>
			<pre class="source-code">var GetEmployeeById =  [Authorize] Employee ([FromRoute]int id) =&gt; { return new Employee { }; };</pre>
			<p>The <code>GetEmployeeeById</code> expression has the <code>[Authorize]</code> attribute and the <code>id</code> parameter is attributed with <code>[FromRoute]</code>. </p>
			<p>Attributes on Lambda expressions don't have any effect when they are invoked, as the invocation is via the underlying delegate type. The attributes defined on Lambda expressions can be discovered via reflection. </p>
			<p>The minimal API introduced with ASP.NET 6.0 is one of the driving factors behind these improvements. We will <a id="_idIndexMarker180"/>see the usage of this in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>. </p>
			<p>In this section, we have learned about the improvements to the Lambda expressions; in the next section, we will see improvements to interpolated strings.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor187"/>Enhancements to interpolated strings</h1>
			<p>Almost every application will have some sort of text processing. In .NET, there are many ways available <a id="_idIndexMarker181"/>for string manipulation, such as the <code>string</code> primitive type, <code>StringBuilder</code>, <code>ToString</code> overrides on types, String concatenation, and <code>string.Format</code>, which provides functionality to build a string from a composite format string. <code>String.Format</code> takes a format string and format items as input and generates the formatted string as depicted in the following code:</p>
			<pre class="source-code">string message = string.Format("{0}, {1}!", Greeting, Message);</pre>
			<p>In the previous code, the positions <code>{0}</code> and <code>{1}</code> in the format string will be filled with the <code>Greeting</code> and <code>Message</code> format items respectively passed in as arguments. To make it more friendly and readable, C# 6 added a new language syntax called <strong class="bold">interpolated strings</strong>, as shown in the following code snippet: </p>
			<pre class="source-code">string Greeting = "Hello";</pre>
			<pre class="source-code">string Language = "C#";</pre>
			<pre class="source-code">int version = 10;</pre>
			<pre class="source-code">string message = $"{Greeting}, {Language}!";</pre>
			<pre class="source-code">string messageWithVersion = $"{Greeting}, {Language} {version}!";</pre>
			<p>When interpolated strings syntax is used, the .NET compiler generates the code that is best suited for the interpolated string to produce the same result. </p>
			<p>Use a disassembler such as ILSpy or SharpLab to look at the generated code for the previous code snippet; it will look something like the following code snippet:</p>
			<pre class="source-code">String text = "Hello";</pre>
			<pre class="source-code">string text2 = "C#";</pre>
			<pre class="source-code">int num = 10;</pre>
			<pre class="source-code">string text3 = text + ", " + text2 + "!";</pre>
			<pre class="source-code">string text4 = string.Format("{0}, {1} {2}!", text, text2, num);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout"><a href="https://sharplab.io/">https://sharplab.io/</a> is a .NET code playground that shows the intermediate results of code compilation.</p>
			<p>For the <code>message</code> interpolated <a id="_idIndexMarker182"/>string, the code was generated using concatenation. For the second string, <code>messageWithVersion</code>, where a non-string literal is involved, the generated code uses <code>string.Format</code>. </p>
			<p>The compiler did what was intended, but it had a few issues where the code was generated using <code>string.Format</code>:</p>
			<ul>
				<li>The compiler parsed the interpolated string to generate code with <code>string.Format</code>. The same string must be parsed by the .NET runtime also to find the literal positions. </li>
				<li>The argument type of the literals in the <code>string.Format</code> method is <code>Object</code>. So, any value type used in <code>string.Format</code> involves boxing.</li>
				<li>The overload of <code>string.Format</code> takes a maximum of three arguments. Beyond three is served by the overload that takes <code>params object[]</code>. So, more than three arguments require the instantiation of an array.</li>
				<li>Since <code>string.Format</code> accepts only the <code>Object</code> type, we cannot use <code>ref struct</code> types such as <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;char&gt;</code>.</li>
				<li>Since <code>ToString</code> is called on the captured expression, multiple transient strings will be created.</li>
			</ul>
			<p>All the shortcomings mentioned here will be addressed with C# 10 by generating code with a series of appends to the string builder. For the same code that we discussed, if you look at the generated code in C# 10, it uses <code>DefaultInterpolatedStringHandler</code> as shown in the following code snippet:</p>
			<pre class="source-code">string Greeting = "Hello";</pre>
			<pre class="source-code">string Language = "C#";</pre>
			<pre class="source-code">int version = 10;</pre>
			<pre class="source-code">string message = Greeting + ", " +<a id="_idTextAnchor188"/> Language + "!";</pre>
			<pre class="source-code">DefaultInterpolatedStringHandler defaultInterpolatedStringHandler = new DefaultInterpolatedStringHandler(4, 3);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendFormatted(Greeting);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendLiteral(", ");</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendFormatted(Language);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendLiteral(" ");</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendFormatted(version);</pre>
			<pre class="source-code">defaultInterpolatedStringHandler.AppendLiteral("!");</pre>
			<pre class="source-code">string messageWithVersion = defaultInterpolatedStringHandler.ToStringAndClear();</pre>
			<p>For interpolated <a id="_idIndexMarker183"/>strings, instead of using <code>string.Format</code>, C# 10 compiler now uses <code>DefaultInterpolatedStringHandler</code>. In the previously-generated code, <code>DefaultInterpolatedStringHandler</code> is constructed by passing in the two arguments, the number of characters in the literal portion of the interpolated string, and the number of <a id="_idIndexMarker184"/>positions in the string to be filled. <code>AppendLiteral</code> or <code>AppendFormatted</code> are called to append the literal or to append the formatted string, respectively. With the introduction of interpolated string handlers, the concerns discussed previously were addressed.</p>
			<p>For the same interpolated string code written in earlier versions of C#, there will be an improvement in the performance in C# 10. We can also build our custom interpolated string handlers, which may be useful in situations when the data isn't going to be used as a string, or where conditional execution would be a logical fit for the target method.</p>
			<p>In this section, we have learned about the improvements to the interpolated string, which gives us better performance over earlier versions. In the next section, let's learn about the extended property patterns.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor189"/>Extended property patterns </h1>
			<p>Pattern matching is a way to check an object's value or the value of a property having a full or partial <a id="_idIndexMarker185"/>match to a sequence. This is supported in C# in the form of <code>if…else</code> and <code>switch…case</code> statements. In modern languages, especially in functional programming languages such as F#, there is advanced support for pattern matching. With C# 7.0, new pattern matching concepts were introduced. Pattern matching provides a different way to express conditions to have more human-readable code. Pattern matching is being extended with every major release of C# since its introduction in C# 7.</p>
			<p>In this section, let's learn about the extended property pattern introduced in C# 10.</p>
			<p>Consider the following code snippet:</p>
			<pre class="source-code">Product product = new Product</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Name ="Men's Shirt",</pre>
			<pre class="source-code">    Price =10.0m,</pre>
			<pre class="source-code">    Location = new Address</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        Country ="USA",</pre>
			<pre class="source-code">        State ="NY"</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">};</pre>
			<p>In this code snippet, we have an object of the <code>Product</code> type, which contains the location of the product origin. Prior to C# 10, if we wanted to check whether the country of origin of this product was the USA, we would do something similar to the following code snippet:</p>
			<pre class="source-code">if (product is Product { Location: { Country: "USA" } })</pre>
			<pre class="source-code">    Console.WriteLine("USA"); </pre>
			<p>With C# 10, we can access the extended properties to make it more readable, as shown in the following code snippet:</p>
			<pre class="source-code">if (product is Product { Location.Country : "USA"  })</pre>
			<pre class="source-code">    Console.WriteLine("USA");</pre>
			<p>In the <a id="_idIndexMarker186"/>preceding code, we are validating the <code>Country</code> property of <code>Location</code> using an extended property pattern.</p>
			<p>In this section, we have learned about extended property patterns. Let's learn about the new addition to <code>caller</code> argument attributes in the next section.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor190"/>Addition to the caller argument attributes</h1>
			<p>C# 5 first introduced <code>caller</code> argument attributes. They are <code>CallerMemberName</code>, <code>CallerFilePath</code>, and <code>CallerLineNumber</code>. These attributes make the compiler populate the <a id="_idIndexMarker187"/>method arguments in the generated code. They are used in various scenarios such as populating more data in the debug traces while firing an <code>OnNotifyPropertyChanged</code> event in the MVVM pattern. For example, consider the following code snippet, which defines a <code>Gift</code> model:</p>
			<pre class="source-code">public class Gift : INotifyPropertyChanged</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    private string _description;</pre>
			<pre class="source-code">    public string Description</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        get</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            return _description;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        set</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            _description = value;</pre>
			<pre class="source-code">            OnPropertyRaised();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public event PropertyChangedEventHandler </pre>
			<pre class="source-code">      PropertyChanged;</pre>
			<pre class="source-code">    private void OnPropertyRaised([CallerMemberName] string </pre>
			<pre class="source-code">      propertyname="")</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        if (PropertyChanged != null)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            PropertyChanged(this, new </pre>
			<pre class="source-code">              PropertyChangedEventArgs(propertyname));</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} </pre>
			<p>In the preceding <code>Gift</code> class definition, the <code>OnPropertyChanged</code> method is called every time <a id="_idIndexMarker188"/>the setter of the <code>Description</code> prop<a id="_idTextAnchor191"/>erty is called. In the <code>OnProperyChanged</code> method implementation, we have the <code>propertyName</code> argument attributed with <code>CallerMemberName</code>. This will make the compiler generate a setter as shown in the following code:</p>
			<pre class="source-code">public string Description</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    get { return _description;     }</pre>
			<pre class="source-code">    set</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        _description = value;</pre>
			<pre class="source-code">        OnPropertyRaised("Description");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this generated code, the argument to <code>OnProperyChanged</code> is auto-populated with the property name, <code>Description</code>, by the compiler. This is a handy feature for the developer that helps to write error-free code. The other two <code>caller</code> argument attributes, <code>CallerFilePath</code> and <code>CallerLineNumber</code>, populate the file path of the <code>caller</code> method and line number respectively.</p>
			<p><code>CallerArgumentExpression</code> is a new addition to these in C# 10. As the name suggests, the attribute makes the compiler auto-populate the argument expression. Let's build <a id="_idIndexMarker189"/>a simple argument validation helper class that does the <code>null</code> check for the parameters passed. Consider the following implementation of an <code>ArgumentValidation</code> class, which implements a helper method that throws <code>ArgumentException</code> if the argument value is <code>null</code>:</p>
			<pre class="source-code">public static class ArgumentValidation</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public static void ThrowIfNull&lt;T&gt;(T value,</pre>
			<pre class="source-code">    [CallerArgumentExpression("value")] string expression = </pre>
			<pre class="source-code">      null) where T : class</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        if (value == null)</pre>
			<pre class="source-code">            Throw(expression);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private static void Throw(string expression)</pre>
			<pre class="source-code">        =&gt; throw new ArgumentException($"Argument </pre>
			<pre class="source-code">           {expression} must not be null");</pre>
			<pre class="source-code">} </pre>
			<p>In the <code>ThrowIfNull</code> method, we are performing the <code>null</code> check and throwing <code>ArgumentException</code> with the details including the parameter name, which is picked from <code>CallerArgumentExpression</code>. We can use the preceding helper class to perform the <code>null</code> check on the arguments passed to a method. For example, consider the following <a id="_idIndexMarker190"/>method, which adds the passed-in product to the cart:</p>
			<pre class="source-code"><code>public async Task&lt;ProductDetailsViewModel&gt; AddProductAsync (ProductDetailsViewModel product)</code></pre>
			<pre class="source-code"><code>{</code></pre>
			<pre class="source-code"><code>    ArgumentValidation.ThrowIfNull(product);</code></pre>
			<pre class="source-code"><code>    // Implementation to add the product to cart</code></pre>
			<pre class="source-code"><code>}</code></pre>
			<p>In this method, we use the <code>ArgumentValidation</code> helper class to check the <code>null</code> condition of the <code>product</code> argument. The generated code for the call to the <code>ThrowIfNull</code> helper method will be <code>ArgumentValidation.ThrowIfNull(product, "product");</code>.</p>
			<p>The compiler auto-populated the parameter name in the string argument. Caller arguments will be useful where we want to add more details to the traces, which will help in tr<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/><a id="_idTextAnchor194"/><a id="_idTextAnchor195"/><a id="_idTextAnchor196"/><a id="_idTextAnchor197"/><a id="_idTextAnchor198"/><a id="_idTextAnchor199"/>oubleshooting the issue.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor200"/>Summary</h1>
			<p>In this chapter, we have learned about the major additions to the C# language features in version 10. We have seen how C# 10 simplifies the code written with <code>implicit</code> and <code>global</code> using directives. We have learned about <code>record</code> structs and how they compare with the <code>record</code> class introduced in C# 9. We have also learned about the improvements to Lambda expressions, expression type inference, and explicitly specifying the return type for the expression. We have also seen performance improvements in interpolated strings. We have also learned how to build throw helpers using the <code>CallerArgumentExpression</code> attribute.</p>
			<p>With this chapter, we have gained the skills to leverage these new features of C# 10 features in the enterprise e-commerce application that we are going to build in the coming chapters. In addition to these, there are a few more small enhancements. You can refer to the C# language documentation to learn more here: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10</a>. We will be highlighting the new features of C# 10 and .NET 6 throughout this book while implementing different features of our e-commerce application.</p>
			<p>In the upcoming part, we will learn about the cross-cutting concerns that form the building blocks of our<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/> e-commerce application.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor203"/>Questions</h1>
			<p>After reading the chapter, you should be able to answer the following questions:</p>
			<ol>
				<li>True or false? Record structs are mutable:</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="2">Which keyword should you use to make a record struct immutable?</li>
			</ol>
			<p>a. A record struct is immutable by default.</p>
			<p>b. <code>readonly</code>.</p>
			<p>c. <code>finally</code>.</p>
			<p>d. <code>sealed</code>.</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="3">True or false? A compiler will infer the type expressions in all the scenarios:</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">In which version of C# were caller argument attributes first introduced?</li>
			</ol>
			<p>a. C# 9</p>
			<p>b. C# 8</p>
			<p>c. C# 5</p>
			<p>d. C# 7</p>
			<p><strong class="bold">Answer: c</strong></p>
		</div>
	</body></html>