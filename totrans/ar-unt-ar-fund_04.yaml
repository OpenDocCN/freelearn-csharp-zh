- en: '*Chapter 3***: Improving the Developer Workflow**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing for **Augmented Reality** (**AR**), like any software development,
    it's important to understand your tools, learn how to troubleshoot when you get
    "stuck," and endeavor to make your overall developer workflow more efficient.
    In this chapter, we will consider some best practices, techniques, and advanced
    tools for troubleshooting and testing AR applications in development.
  prefs: []
  type: TYPE_NORMAL
- en: Unity is generally quite friendly for developing for mobile devices. For example,
    you will normally use the Editor Play-mode to preview your scene in the Editor,
    allowing rapid*develop-test-update-repeat* cycles. And with an *editor remote
    tool*, you can run and test on your target mobile device without having to do
    builds each time.
  prefs: []
  type: TYPE_NORMAL
- en: But Augmented Reality imposes unique challenges because it requires sensor input
    on the remote device, including a live camera feed and motion sensors. It also
    requires AR processing built into the mobile software (Android, iOS) that detects
    features in the environment (such as planes or faces) and tracks your physical
    device in the real world. Your app requires this data, but it's remote and not
    normally available to Unity in the Editor Play mode. In this chapter, we'll explore
    various techniques and tools to deal with this and improve AR development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting with log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with a debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with an editor remote tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating environments with the Unity project MARS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're impatient and want to begin developing an AR project right away, you
    may skip this chapter and jump into [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077),
    *Creating an AR User Framework*, where we start our first real project. If that's
    the case, go ahead but please plan to come back here as soon as you realize this
    chapter can help you.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter does not have special technical requirements other than a working
    development system with Unity installed, a project set up with the XR Plugin and
    the AR Foundation package, and the ability to successfully build and run on your
    target device, as given in [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*. The scripts and assets created in this chapter
    can be found in this book''s GitHub repository: [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).'
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting with log messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If (and when) an error occurs while developing or running your Unity project,
    the first thing you must do is consult the **Console** window for messages. The
    **Console** window is where you'll find all kinds of messages including asset
    import warnings, compiler errors, runtime errors in play mode, build problems
    when you **Build And Run**, and others. Compiler errors (such as coding syntax
    errors) may prevent the scene from running at all (and the **Play** button will
    become disabled).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three levels of console messages: **Info**, **Warning** (shown in
    orange), and **Error** (shown in red). You can filter the messages using the toggle
    buttons in the **Console** window toolbar, as highlighted in the following screen
    capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The Console window showing a null exception error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01-ConsoleNullExceptionError.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The Console window showing a null exception error
  prefs: []
  type: TYPE_NORMAL
- en: Runtime errors, such as the `null`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: "Warning" messages can be extraneous'
  prefs: []
  type: TYPE_NORMAL
- en: I generally ignore the warning messages in the Unity Editor's **Console** window,
    unless I'm deliberately looking for something, as they're often verbose, not relevant
    to my own problem solving, and thus become noise instead of information. You can
    hide warning messages by un-clicking the **Warning** button in the Console toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/` folder. In the preceding screenshot, *Figure 3.1*, the null
    exception error occurred on line 27 of the `MyScript.cs` file when it was calling
    the C# `System.Int32.Parse` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Read your Console messages carefully'
  prefs: []
  type: TYPE_NORMAL
- en: A common mistake I often see by novice and experienced developers alike is not
    reading error messages carefully. When you're in the flow of things, it's often
    too easy to assume you know what the message is saying and not really read it,
    missing key clues needed for troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: You can also write a message to the Console from your own scripts, using `Debug.Log`
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Using Debug.Log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing C# scripts, you can log your own messages to the Console using
    `Debug.Log()` function calls. This is the most common method of checking and understanding
    what is going on inside your code when it is running. `Debug.Log` messages appear
    as *Info* messages in the Console (you can also call `Debug.LogError()` to have
    them appear as *Error* messages instead).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose I''m trying to locate the root cause of an error in my
    project. And suppose there are several `MonoBehaviour` scripts that I''m developing
    related to this problem. I may place log statements at the entry of specific functions
    and other log statements to print out specific variables that I am suspicious
    of. Take the following code, for example, for a script named `MyScript.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In C# you can combine (concatenate) text strings using the plus (`+`) operator.
    In our example, the integer `number` is concatenated to the message string (in
    `Update`), and C# automatically converts the number to a string value first.
  prefs: []
  type: TYPE_NORMAL
- en: Add this script to your scene by creating an empty GameObject (**GameObject**
    | **Create Empty**) and dragging the script file from the **Project** window onto
    the GameObject. Then click **Play**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this code runs, what I see in the **Console** window is shown in the following
    screen capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Console messages about my Debug.Log statements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02-ConsoleDoSomething.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Console messages about my Debug.Log statements
  prefs: []
  type: TYPE_NORMAL
- en: This will reveal that `DoSomething` is only called once rather than 10 times
    as expected. Can you figure out why?
  prefs: []
  type: TYPE_NORMAL
- en: Studying the code in `Update` does not explain why `DoSomething` was only called
    once. From there I can re-examine the logic to determine why and when `number`
    prematurely becomes less than zero. You can see the bug is in the `DoSomething`
    function itself where it "accidentally" sets `number = -1`, causing the condition
    in `Update` to never call `DoSomething` after the first time. You may have been
    stumped while fixated on the `Update` code, but then discovered the bug actually
    occurs deeper in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Bug hunting? It''s probably not where you''re looking'
  prefs: []
  type: TYPE_NORMAL
- en: Here's a funny story. A man leaves a bar and sees a drunk guy walking around
    in circles near a lamppost, searching the sidewalk. "Hey pal, what's the matter?".
    The drunk replies, "I lost my keys." So together they keep looking. Finally, the
    man asks, "Are you sure you dropped them here?". The other responds, "Well, I
    dropped them over there. But the light's better here." Keep this in mind when
    you're trying to find a bug – it's often exactly *not* where you're looking, otherwise
    you probably would have found it already!
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've been using the **Console** window to log messages using the Unity
    Editor play mode. In fact, the Console is so useful for troubleshooting, you may
    also want to see your debug messages while running your project on your remote
    device. Next, let's consider how you can use the Console while running on a mobile
    device connected via USB.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Console with a mobile device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use Console logs while running your app on your mobile device, provided
    the app was built with **Development Mode** enabled, and the device is attached
    to the Unity Editor via a USB cable (or equivalent). To set this up, use the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Build Settings** window using **File** | **Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Development Mode** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Build And Run** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the app successfully builds, installs on the device, launches, and starts
    to run, any `Debug.Log` calls will appear in the Console if you attach it to the
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Unity **Console** window toolbar, select the **Editor** button and select
    the process running on your mobile device. For example, the following screenshot
    shows me attaching the **Editor Console** to my Android device:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Console window attached to an Android device'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_-ConsoleAndroid.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Console window attached to an Android device
  prefs: []
  type: TYPE_NORMAL
- en: It's that easy.
  prefs: []
  type: TYPE_NORMAL
- en: There are other kinds of logs provided by Unity and by your device's operating
    system. In the **Console** window, use the three-dot context menu at the top right
    to access the full Player logs and Editor logs files. On Android, you can also
    get more detailed messages from your Android device using *logcat*.
  prefs: []
  type: TYPE_NORMAL
- en: Using logcat with Android devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Android mobile devices you can monitor any and all log messages from Android
    itself and any apps running on the device (including your own Unity one) using
    a tool called **logcat**. You can install and use *logcat* directly inside the
    Unity Editor from the Package Manager with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use **Window** | **Package Manager** to open the **Package Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the filter select list at the top left, choose **Unity Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the search input field at the top right to look for `logcat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the package and click the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the package installs, open the **Logcat** window using **Window** | **Analysis**
    | **Android Logcat**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With *logcat* installed and its window open, you can run your app on your connected
    mobile device. It now does not require being built in **Development Mode** enabled
    nor attached to the Editor Console. You''ll discover there is a lot going on inside
    your device; messages may be streaming from all the running tasks, not just your
    own application! The **Android Logcat** window offers ways to filter the messages
    to show only those coming from your app, while your app is running on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the filter drop-down list and choose your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter search expressions to filter the message stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A screen capture of the **Android Logcat** window is shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Android Logcat window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04-LogcatWindow.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Android Logcat window
  prefs: []
  type: TYPE_NORMAL
- en: I realize the text in this screen capture is probably too small to read here!
    This screenshot is intended to give you a feel of what the window provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Info: Using the Android adb command-line tool'
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing for an Android device, I recommend you also install the
    Android **adb** (Android Debug Bridge) command-line tool. (This is what Unity
    uses internally for watching Console logs and running the Logcat window.) If you
    have installed the full *Android Studio* ([https://developer.android.com/studio](https://developer.android.com/studio)),
    it may already be present on your system. Otherwise, you can install just the
    command-line tools by navigating to [https://developer.android.com/studio#downloads](https://developer.android.com/studio#downloads)
    and scrolling down the page to the *Command line tools only* section to find the
    download link for your platform.
  prefs: []
  type: TYPE_NORMAL
- en: With adb installed (and in your command path), you can run a variety of device
    actions. For more details, see [https://developer.android.com/studio/command-line/adb](https://developer.android.com/studio/command-line/adb).
    For example, the `adb devices` command will list the Android device it presently
    sees connected to your computer. `adb logcat` will show the internal device logs.
    To filter the logs for only Unity-related messages, use the `adb logcat -v time
    -s Unity command`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Unity Editor `logcat` is great, but what can you do if you want to
    troubleshoot an app without the mobile device attached to your computer? This
    can certainly be the case with augmented reality applications that require moving
    within your environment. One solution is you could create a *virtual* console
    window, explained next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Info: Using the Xcode console for iOS devices'
  prefs: []
  type: TYPE_NORMAL
- en: If you're developing for iOS, there is no equivalent to logcat in Unity. However,
    you can view logs from your device using the Xcode log console. Open the console
    using **View** | **Debug Area** | **Activate Console**.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a Console window in your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A strategy for capturing console logs, even when your device is detached from
    the development computer, is to provide a "virtual console" window in your application.
    This window would be for development, not production. The idea is to replace `Debug.Log`
    calls with a wrapper function, which optionally outputs to a text object on an
    in-app text area when running a development build.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about Unity **Canvas** objects and UI components more in [*Chapter
    4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077), *Creating an AR User Framework*,
    so I offer the steps here with only limited explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the wrapper function, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `scripts/` folder (create one if you don't have one yet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* in the `scripts` folder, select `ScreenLog`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script for editing and replace the default code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We implement `ScreenLog` as a `public static ScreenLog Instance` variable),
    ensuring there will only be one instance of `ScreenLog` in the scene and providing
    the ability to address the `Log` function as a class method. (We'll discuss *class*
    versus *instance* methods and the *singleton pattern* more in the next chapter.)
    This way, you're able to call `ScreenLog.Log()` from anywhere in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add a text window to the app, and toggle its visibility with a
    *Debug* button in the UI. (As mentioned, we are going to cover the Unity UI in
    more detail in later chapters.) First, let''s assume your AR application will
    be used on a mobile device in portrait orientation with a screen space Canvas
    to contain the text area:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, create a new Canvas by selecting `Debug Canvas`. This will
    also add an **Event System** game object to the scene if one is not already present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To edit the *Screen Space* Canvas, let's switch the **Scene** window to a 2D
    view by clicking the **2D** button in the **Scene** window toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s also helpful to arrange the **Game** window and **Scene** window side
    by side. Because we''re developing for AR, set the **Game** window''s display
    to a fixed portrait aspect ratio, such as **2160x1080 Portrait** using the dimension
    select list in the **Game** window''s top toolbar. This layout can be seen in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The Scene and Game windows side by side with the portrait device
    view set up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05-SceneGameSidebyside.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The Scene and Game windows side by side with the portrait device
    view set up
  prefs: []
  type: TYPE_NORMAL
- en: (This screenshot was captured after all these steps were completed; your Canvas
    does not have the scrolling text area yet.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add a scrolling text area where we''ll write the log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select **Debug Canvas**. Then right-click, and
    select **UI** | **Scroll View**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize and place the `400`. The resulting `0, 0)`, `0`, `(0, 1)`, `(1, 1)`,
    and `(0.5, 1)`. The **Rect Transform** component and the location of the **Anchor
    Presets** menu button are shown in the following screenshot:![Figure 3.6 – The
    Rect Transform component with the Anchor Presets button highlighted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.06-RectTransform.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.6 – The Rect Transform component with the Anchor Presets button highlighted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Allow only vertical scrolling by un-checking the **Scroll Rect** | **Horizontal**
    checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then double-click **Debug Canvas** in **Hierarchy** to bring it into focus (you
    might need to double-click it twice).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Hierarchy**, unfold **Scroll View** (the triangle icon) and its **Viewport**.
    Select the child **Content** object and set its anchors and size by selecting
    **Rect Transform** | **Anchor Presets** | **Stretch-Stretch**, and *Shift* + *Alt*
    + click **Stretch-Stretch** to fill the Viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Inspector** window for **Scroll View** is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Scroll View property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07-ScrollViewInspector.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Scroll View property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can work on the text element itself:'
  prefs: []
  type: TYPE_NORMAL
- en: On the `Debug Text`. (Note, you may prefer to use *TextMesh Pro* text elements,
    which give you more control over the typography and padding without any performance
    costs—introduced in the next chapter.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Debug Text** game object selected, have it fill the **Content** area
    by using **Anchor Presets** | **Stretch-Stretch**, and *Shift* + *Alt* + click
    **Stretch-Stretch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For reference, enter a placeholder string in the `[Log message]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust `36`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Alignment** to **Bottom**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **Vertical Overflow** to **Overflow** (instead of **Truncate**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Personally, I like white text on a black background for the Console. If you
    agree, in `0` and `200`, and in `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting GameObject **Hierarchy** and **Inspector** settings for the **Debug
    Text** object are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Debug Canvas Hierarchy and Debug Text settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08-DebugTextInspector.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Debug Canvas Hierarchy and Debug Text settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add our script to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: With **Debug Canvas** selected in the **Hierarchy** window, locate the **ScreenLog**
    script in the **Project** window and drag the script file onto the **Debug Canvas**
    GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With **Debug Canvas** still selected, locate the **Debug Text** GameObject
    in the **Hierarchy** window, drag it into the **Inspector**, and drop it onto
    the **Log Text** slot on the **Screen Log** component, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Setting the Log Text reference to the Debug Text GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09-CanvasScreenLogText.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Setting the Log Text reference to the Debug Text GameObject
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a Debug button to the UI to toggle the text panel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on `Debug Button`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Size and place the button on your screen. For example, set its `175, 175`),
    and anchor it to the lower left of the screen using `30, 30`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Debug`. You can also adjust its font properties from here, such as setting
    `36`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the Debug button into a toggle button, replace the **Button** component
    with a **Toggle** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Hierarchy**, select the **Debug Button** object. In the **Inspector**,
    use the three-dot context menu icon on the **Button** component (or right-click
    on the component) and select **Remove Component**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then click `toggle`, and add a **Toggle** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we'll configure the toggle to handle On Value Changed events. In the **Toggle**
    | **On Value Changed** properties, click the small **+** icon at the bottom right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Scroll View** object from the **Hierarchy** window onto the on-click
    event's **None (Object)** slot. Then, in the **Function** selector, choose **Game
    Object** | **Dynamic Bool** | **SetActive**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Toggle** component now has the following settings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Debug Button set up with a Toggle component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_3.10-ButtonToggleInspector.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.10 – Debug Button set up with a Toggle component
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, save this rig as a prefab that you can reuse in other scenes. Drag `Prefabs/`
    folder in the `Prefabs` folder, create one first. The folder name is not required,
    it's by convention.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And remember, if you make new changes to this Canvas (or children) in **Hierarchy**,
    save those changes to the prefab asset using **Overrides** | **Apply All**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this setup, we can now use the `ScreenLog.Log()` function instead of `Debug.Log()`
    anywhere you want to add an info message in your code, as shown in the following
    screen capture from my phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Screenshot of my phone using the virtual console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11-VirtualConsoleOnPhone.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Screenshot of my phone using the virtual console
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of this approach is you can modify it to selectively provide a
    status message log even for end users, not just your own development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Info: Third-party virtual consoles'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from rolling your own as we do in this chapter, there are third-party
    virtual console packages you can find in the Asset Store, with a range of features
    and costs. The *Lunar Mobile Console – Free* asset, for example, is easy to install
    and use – see [https://assetstore.unity.com/packages/tools/gui/lunar-mobile-console-free-82881](https://assetstore.unity.com/packages/tools/gui/lunar-mobile-console-free-82881).
    These tend to be strictly for development purposes and are not appropriate for
    exposing log messages to end users.
  prefs: []
  type: TYPE_NORMAL
- en: To get a deeper insight into what their code is doing, many programmers like
    to use a debugger tool provided by **Integrated development environments** (**IDEs**)
    such as Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with a debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Professional software developers are familiar with code **debuggers**, used
    to test and debug programs by stopping the execution at specific lines of code
    and examining the state of the memory and other runtime conditions. In this section,
    I will give you an introduction to using the Visual Studio debugger with Unity
    projects. The debugger can be used in both the Unity Editor play mode, as well
    as in your builds running on the attached device.
  prefs: []
  type: TYPE_NORMAL
- en: With a debugger, you can set a **breakpoint** at a specific line of code, where
    the execution will stop at that line, allowing you to query the values of variables,
    and wait for you to step through or continue the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a debugger in the Editor play mode you do not need to make any special
    changes, provided you are already using Visual Studio for your code editor (or
    another supported **interactive development environment** (**IDE**) such as **VS
    Code** or **JetBrains Rider**). You can configure Unity for your preferred editor/debugger
    using **Edit** | **Preferences** | **External Tools**. For example, in the following
    screenshot, you can see my Unity install has **External Script Editor** set to
    a **Visual Studio Community** version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – You can set your default code editor in the Unity Preferences
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12-ExternalEditor.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – You can set your default code editor in the Unity Preferences
    window
  prefs: []
  type: TYPE_NORMAL
- en: 'With Visual Studio opened for your project (choose `MyScript.cs` script is
    open, and I''ve created a breakpoint on line 25, indicated in VS Code by a red
    dot on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Setting a breakpoint in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13-VSBreakpoint.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Setting a breakpoint in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach the debugger to your Unity Editor session, use the **Attach To Unity**
    button in the top toolbar. Back in Unity, if you have not yet enabled C# debugging,
    you will get a prompt like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Unity prompt to enable debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14-EnableDebuggingDialog.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Unity prompt to enable debugging
  prefs: []
  type: TYPE_NORMAL
- en: Click one of the **Enable** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Debug Mode can be toggled using the corresponding icon in the bottom-right
    corner of the Editor window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once debugging is enabled and you click **Play** in the Editor, if and when
    a breakpoint line is reached in your code, execution will stop, and Visual Studio
    will be given focus on your desktop. The current line of code will be highlighted
    in yellow on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Debugging a line of code in the Visual Studio debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15-VSDebugging.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Debugging a line of code in the Visual Studio debugger
  prefs: []
  type: TYPE_NORMAL
- en: There are also debugging windows where you can examine the current values of
    variables in the script, the current call stack, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'While debugging, the *debugger toolbar* is also active at the top of the window,
    depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The debugger toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16-DebuggerToolbar.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – The debugger toolbar
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Continue** button (1) will continue running from here until it reaches
    another breakpoint. The **Stop** button (2) will disable the debugger mode, and
    the step buttons (3) do the following: **Step Into** follows the code into the
    body of a function call, **Step Over** will run to the next line of code in the
    current file, and **Step Up** takes you up the call stack one level.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also run the debugger on code running on your attached mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging on a remote device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the debugger on your project running on your mobile device, you must
    first enable **Script Debugging** and **Development Build** in the project''s
    **Build Settings**. Use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Build Settings** window using **File** | **Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Development Build** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Script Debugging** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, check the **Wait For Managed Debugger** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you're ready, click **Build And Run**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the app is running on the device, attach your debugger to the remote process
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, select from the main menu **Debug** | **Attach Unity Debugger**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dialog box will appear with a list of potential processes, as depicted in
    the following screenshot. Choose the process that you want to attach and click
    **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_3.17-ChooseUnityProcess.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Attaching the Visual Studio debugger to a Unity process on a mobile
    phone
  prefs: []
  type: TYPE_NORMAL
- en: You can now set and examine breakpoints in the app running on your device. Note,
    once you close the app on your phone, the debugger also stops in Visual Studio
    and detaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Wait For Managed Debugger** build option is useful if you need to start
    the debugger before Unity starts running. Since Visual Studio needs a process
    to attach to, the app will start up, then wait for you to attach the debugger,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Prompt on phone waiting for a debugger to be attached'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18-AttachDebugger.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Prompt on phone waiting for a debugger to be attached
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we need this in our little example because the `Update` function in
    `MyScript` will likely be called before I get a chance to attach the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Info: Additional Unity debugging tools'
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides more windows and tools you can use to debug your projects and
    gain insight into what is going on under the hood. For troubleshooting Input System
    actions, see **Window** | **Analysis** | **Input Debugger**. For deep analysis
    and profiling, there is the **Profiler**, **Frame Debugger**, and **Physics Debugger**
    also under the **Window** | **Analysis** menu. For the UI, there's the **Immediate
    Mode GUI** (**IMGUI**) debugger at **Window** | **Analysis** | **IMGUI Debugger**,
    and when customizing the Unity Editor user interface, see the **Window** | **UI
    Toolkit** | **Debugger** (UI Toolkit is expected to be extended for use in your
    own apps in the future). There's even a **Window** | **Render Pipeline** | **Render
    Pipeline Debug** window.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it also be good if you could click **Play** to run the project on your
    mobile device without having to **Build And Run** every time? Let's look at *editor
    remote tools* next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with an editor remote tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers have been using Unity for many years to develop games and applications
    for iOS and Android devices. You want the ability to click **Play** in the Unity
    Editor and run the current scene remotely on your attached mobile device. Having
    an iterative *develop-test-update-repeat* cycle is key to more efficient and effective
    development.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this developer workflow, Unity provides an application called
    **Unity Remote 5** that you install on your phone and then connect to the Unity
    Editor. It is available for both Android ([https://play.google.com/store/apps/details?id=com.unity3d.mobileremote](https://play.google.com/store/apps/details?id=com.unity3d.mobileremote))
    and iOS ([https://apps.apple.com/us/app/unity-remote-4/id871767552](https://apps.apple.com/us/app/unity-remote-4/id871767552)).
    It allows you to use a mobile device to view and test your project live, inside
    the Unity Editor, without having to build each time. The device acts as a "remote
    control" for the scene running in the Editor Play-mode, including screen touch,
    accelerometer, gyroscope, and webcam input.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Remote 5 is not suitable for AR development. A remote tool from
    Unity compatible with AR Foundation has been long promised and is expected, but
    as I am writing this, it does not exist. Perhaps it will be available by the time
    you are reading this as a free core Unity feature, so try searching the Unity
    Forums ([https://forum.unity.com/?gq=AR%20Foundation%20Editor%20Play%20Mode](https://forum.unity.com/?gq=AR%20Foundation%20Editor%20Play%20Mode)).
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case in large developer communities, at least one talented individual
    has stepped up and produced a remote tool for AR Foundation, available on the
    Unity Asset Store. The *AR Foundation Editor Remote* tool by Kyrylo Kuzyk can
    be found at [https://assetstore.unity.com/packages/tools/utilities/ar-foundation-editor-remote-168773](https://assetstore.unity.com/packages/tools/utilities/ar-foundation-editor-remote-168773).
    It is not free and, at the present time, it does not support the new Input System,
    only the legacy Input Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to purchase the package, you can install it using the Package
    Manager as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Package Manager** using **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the list for **My Assets** using the select list at the top left of the
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **AR Foundation Editor Remote** package, click **Download** (if necessary),
    then click **Import**. And then in the **Import** dialog box, click the **Import**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package is installed in the `Plugins/ARFoundationRemoteInstaller/` folder.
    The installer should run automatically. Note there is a `Documentation` file as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the AR Foundation Editor Remote tool, take the following steps as outlined
    in the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Edit** | **Project Settings** | **XR Plug-in Management** | the **Desktop**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **AR Foundation Remote** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your project is targeting your mobile device platform in **File** | **Build
    Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Plugins/ARFoundationRemoteInstaller`, select the **Installer** asset,
    and view the **Inspector** window as shown in the following screenshot:![Figure
    3.19 – The AR Foundation Remote Installer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.19-ARRemoteInstaller.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.19 – The AR Foundation Remote Installer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Install AR Companion App** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let it build and install the companion app on your device.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Plugins/ARFoundationRemoteInstaller/Resources/` folder and select the
    **Settings** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the instructions on your phone screen and enter the given IP address
    in the **Settings** | **AR Companion App IP** field in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're now set up. When you want to use AR Foundation Remote, ensure the AR
    Companion app is running on your phone. Then, click **Play** to run your scene
    using the mobile device as a remote.
  prefs: []
  type: TYPE_NORMAL
- en: Using an editor remote tool lets you use the Unity Editor Play-mode with your
    mobile device. Camera and other sensing data is input into your **Game** window
    so you can test in your real-world environment without having to use **Build And
    Run**.
  prefs: []
  type: TYPE_NORMAL
- en: What if, instead of playing your app on your mobile device, we inverted this
    approach by bringing your real-world environment into the Unity Editor? Unity
    is pioneering this innovative approach with Unity MARS.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating with Unity MARS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unity MARS** (an acronym for *Mixed Augmented Reality Studio*) ([https://unity.com/products/unity-mars](https://unity.com/products/unity-mars))
    is a product solution from Unity Technologies that solves many of the issues with
    developing Augmented Reality applications discussed thus far in this chapter,
    and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: What is MARS? With MARS you can author and test complex AR applications within
    the Unity Editor with runtime logic for a range of target physical world environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this one scenario: You are developing an AR application for museum
    visitors, where they point their mobile device at an exhibit or artwork and the
    app recognizes it and delivers additional information and infotainment, providing
    a much-enhanced learning experience. But you are at your desk, in your office,
    across town, or in a different city. How do you develop and test your app? Rather
    than making travel plans, you could use MARS to bring the target physical space
    into the Unity Editor and *develop-test-update-repeat* from the comfort of your
    own desk.'
  prefs: []
  type: TYPE_NORMAL
- en: With MARS you can capture and assemble real-world assets such as locations,
    objects, and props, then drag and drop them into Unity to test them. It supports
    tracking planes, images, faces, and many other kinds of semantically meaningful
    data, or *traits*. The MARS documentation can be found at [https://docs.unity3d.com/Packages/com.unity.mars@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.mars@1.0/manual/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in this museum scenario may be to capture the museum''s physical
    environment sensor readings for use at your workstation. The MARS Companion app,
    described more in this section, can serve this purpose. Likewise, MARS includes
    a collection of sample environment templates you can use out of the box. The following
    image, for example, shows a **Simulation View** of a kitchen along with a **Device
    View** in the same space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – MARS Simulation and Device views'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20-MARSscreenshot.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – MARS Simulation and Device views
  prefs: []
  type: TYPE_NORMAL
- en: 'With MARS you have environment simulations that can run either in Edit-mode
    or Play-mode. You can preview the execution of a scene in Edit-mode, where proxy
    objects of the real world are copied into the **Simulation** scene view, which
    is separate from the normal project **Scene** view. You can also start and stop
    a *continuous* **Simulation** view that is more analogous to the normal Play-mode
    in Unity. The data fed into the simulation can be synthetic, recorded, or live
    data. You can then test your project against a wide variety of indoor and outdoor
    spaces. For a more complete explanation of how MARS simulation works, I recommend
    this article: [https://blogs.unity3d.com/2020/08/14/a-look-at-how-simulation-works-in-unity-mars](https://blogs.unity3d.com/2020/08/14/a-look-at-how-simulation-works-in-unity-mars).'
  prefs: []
  type: TYPE_NORMAL
- en: MARS provides additional high-level tools and intelligent components that address
    common challenges for AR developers. Physical environments are not always so predictable.
    The MARS procedural authoring framework simulates real-world objects, conditions,
    and actions including "fuzzy authoring" where you specify minimum and maximum
    measurements for physical features when the app is deciding where and when to
    let the user interact.
  prefs: []
  type: TYPE_NORMAL
- en: MARS is built on AR Foundation, so it works with all supported AR devices and
    platforms. Presently, there is a separate annual license fee to use Unity MARS
    after a trial period.
  prefs: []
  type: TYPE_NORMAL
- en: Using MARS you may still be faced with how to capture your target environment
    geometry and surface feature for use in simulations. That's where the MARS Companion
    app comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing with the MARS Companion app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MARS Companion app can be used to capture real-world data and bring it into
    the Unity Editor for use with Unity MARS.
  prefs: []
  type: TYPE_NORMAL
- en: Using the app, you can scan a room, take pictures, and record video, capturing
    and saving this data to the cloud. This data can then be made available to the
    Unity Editor using the MARS authoring studio.
  prefs: []
  type: TYPE_NORMAL
- en: The app also has limited authoring features that let you create content and
    layout assets on your device. This could be useful, for example, troubleshooting
    edge cases where lighting or environment features are ambiguous or difficult to
    scan.
  prefs: []
  type: TYPE_NORMAL
- en: At this time, the MARS Companion app is still in Beta ([https://forum.unity.com/threads/unity-mars-companion-app-open-beta-announcement.1037638/](https://forum.unity.com/threads/unity-mars-companion-app-open-beta-announcement.1037638/))
    and may eventually be decoupled from MARS for use as an editor remote tool (see
    the previous section in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Unity MARS is a powerful new framework for augmented reality development. It
    represents Unity's long-term commitment to the AR industry, users, developers,
    and device manufacturers. Like most Unity packages and modules, it can also be
    extended with custom behaviors, data extensions, queries, and other add-on modules.
  prefs: []
  type: TYPE_NORMAL
- en: I have not attempted to provide a tutorial for MARS in this chapter (it could
    be a whole separate book), and *we will not be using MARS in the projects in this
    book*. Nonetheless, you are more than welcome to improve your workflow using MARS
    with the projects in this book if you want.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By its nature, augmented reality mixes the physical and virtual worlds, and
    that presents unique challenges to AR developers. We develop on a desktop or laptop
    computer, but the target device for the application is an untethered mobile device.
    While running an app in Unity Play-mode, an AR scene still needs sensor inputs
    from the remote device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered a spectrum of tools and techniques that can help
    with developing and troubleshooting your augmented reality applications using
    Unity. We started with a basic, classic "print statement," using `Debug.Log()`
    where you can output log messages to the `ScreenLog.Log()` wrapper function to
    optionally let you view log messages on your device without being tethered to
    Unity at all.
  prefs: []
  type: TYPE_NORMAL
- en: For deeper understanding and to debug your applications, you can use a debugger
    like the one provided in Visual Studio. While debugging, you can set breakpoints,
    examine variable values, and step through the code. You can run the debugger both
    on Unity Play-mode and on applications built and running on your mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use an editor remote tool—an app that runs on the mobile device
    and connects to the Unity Editor so you can use the Play-mode and receive input
    data from the attached device.
  prefs: []
  type: TYPE_NORMAL
- en: Then we took a brief tour of Unity MARS. This AR development studio framework
    inverts the ordinary remote development paradigm. Rather than running your app
    on a remote device to capture environment sensor data, MARS lets you use environment
    sensor simulations directly in the Unity Editor. This provides the opportunity
    to greatly improve your development workflow and test your application for a wide
    range of physical environments without leaving your desk.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to get started building AR applications. In the next chapter,
    we develop a framework for controlling user interaction in AR projects. This framework
    will be saved and used as a template for building and managing the user interfaces
    in each of the projects in this book.
  prefs: []
  type: TYPE_NORMAL
