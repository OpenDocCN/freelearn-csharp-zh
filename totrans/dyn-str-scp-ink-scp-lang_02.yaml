- en: '*Chapter 1*: Text, Flow, Choices, and Weaves'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the core concepts of nonlinear storytelling by examining
    branching narratives and how ink supports creating them. Building on these concepts,
    this chapter also reviews using lines, text within them, and how to combine them.
  prefs: []
  type: TYPE_NORMAL
- en: As a central element of creating nonlinear, interactive narratives in ink, choices
    are explained and how best to use them. Weaves and collections of choices are
    discussed within the context of when a large branching structure might be needed
    and how to collapse these weaves into simpler parts using gathering points.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding branching narratives as a flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating choices and making weaves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disappearing and sticky choices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples used in this chapter, in `*.ink` files, can be found online on
    GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter1](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter1).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding branching narratives as a flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When holding a physical book, a reader moves through a story by turning its
    pages. The movement between pages is also a movement through the story. What is
    experienced by the reader is called a **narrative**. The story is the packaging
    of its content into different parts called **pages**. The reader's narrative,
    however, is the experience of the story across those pages.
  prefs: []
  type: TYPE_NORMAL
- en: In a digital setting, there are no physical pages. The words of a story could
    be stored as part of a simple text file or bundled together in something more
    complex. Parts of a digital story, which are the pages in a physical book, can
    also be arranged much more easily, and the reader might experience them in different
    configurations, creating new narratives from the same story content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where each sentence is a part of a story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When taken in order from the first sentence to the last one, there is a story
    where the major parts are the sun shining, the clouds coming in, but then the
    clouds leaving and the sun shining again. However, what happens if the parts are
    rearranged?
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With a different ordering, a new narrative is created for the reader. In this
    version, the progression begins with the sun emerging and shining. Next, the clouds
    move in and it begins to rain. In either case, only three events are used, but
    their order affects the narrative experience of the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinear storytelling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the second example, the story still makes sense. This time, however, the
    events start with the clouds, move into the sun shining, and end with the clouds
    returning. The second example, in moving around the events, is an example of **nonlinear
    storytelling**, where the events or parts of a story are experienced in a new
    or different way than created or originally written. The progression is not linear
    from one part to another as created in the story, but a cohesive narrative is
    still created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Mapping nonlinear storytelling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Mapping nonlinear storytelling
  prefs: []
  type: TYPE_NORMAL
- en: The structures created by navigating a nonlinear story are often compared to
    *trees*. They start with a trunk and then, as different parts are encountered
    over others, a *branching pattern* is created, with each **branch** representing
    a movement through parts of a story from one end to another. The narrative traversal
    through a nonlinear story creates a *branching narrative*, where different parts
    were or were not encountered. The map of the experienced narrative represents
    a particular branch of the overall tree of the story and its parts.
  prefs: []
  type: TYPE_NORMAL
- en: While nonlinear storytelling can be done with a printed book, it is often much
    more difficult. In a digital setting, where events can be broken up into different
    parts, rearranging them can often be as easy as selecting them and dragging them
    to a different part of the same document. This consequence of representing stories
    as data makes writing code to handle arranging the different parts easier too.
    This is known as *narrative scripting*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ink** is a *narrative scripting language*. It determines which part of the
    story comes next for the reader. As a user clicks or presses buttons, the code
    written in ink makes the decision between which branches they should visit and
    when. Based on rules written by an author, the code can even repeat the same part
    of the story with new values.'
  prefs: []
  type: TYPE_NORMAL
- en: Because ink is designed for the purpose of scripting narratives, it understands
    navigation through a story as a special concept called **flow**. As the reader
    moves through the different parts, they are creating their own experienced narrative,
    which ink calls the flow. In fact, one of the most common errors encountered by
    authors is where the flow *runs out* of a story. Even when writing a nonlinear
    story with different branches, the story must start and end somewhere. Even if
    all the parts between the start and end of a narrative change each time a user
    traverses the parts of a story, these two points define the range of possible
    branches.
  prefs: []
  type: TYPE_NORMAL
- en: Text flowing down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of flow also extends to how code is understood in ink. All movement
    across a story in ink moves *down from the top* of the code to the bottom unless
    told to navigate to a different part in the story.
  prefs: []
  type: TYPE_NORMAL
- en: The example stories shared earlier in this chapter are both also code examples.
    ink is designed to create branching narratives and supplies the ability to write
    code to create these structures. This means text or words written in a story without
    any other special characters or syntax are valid in ink.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spacing within a line of text is important in ink. Because the text is considered
    a form of code, ink assumes any use of spacing is a deliberate choice on the part
    of the author. For example, adding extra spaces between words is not removed in
    its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ink ignores any empty lines. It assumes each line of text is important and any
    spacing between them should be ignored as something unimportant to the story itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The smallest unit is a line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of three lines as part of a story when introducing nonlinear storytelling
    was not a mistake. The smallest unit within an ink story is a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because ink considers text to be a part of the code, a single line with only
    four words is a completely valid story. Adding more lines would also extend what
    would be presented to the reader, but a single line can be a story by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The use of the term *line* is important in ink. When reading a physical book,
    the smallest unit in a story is usually a sentence. This is often the smallest
    complete thought in a larger work. In a digital context, and specifically within
    ink, a line is the smallest unit. When ink loads a story, it moves through the
    story line by line. It treats each as equally important as the last.
  prefs: []
  type: TYPE_NORMAL
- en: As more complex code is introduced, the concept of a line will become more important
    as well. However, just like the single-line example, a story need not be complex
    to be important. To ink, a story is composed of lines. This could be one or potentially
    many more.
  prefs: []
  type: TYPE_NORMAL
- en: Gluing lines together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An author may need to use multiple lines of text as one "line" of code. For
    these situations, ink provides a concept called `<>`, are used together, they
    glue the content of one onto the next, creating one long line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Spacing when using glue is important. As with spacing within a single line,
    ink respects the choices of the author when presenting text in a single line.
    When using glue, these spaces are also respected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the spaces after each word, the use of glue in the previous example
    would glue all the words together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using comments as notes to authors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a scripting language, ink also provides the ability to include notes within
    the code of a story. Borrowing from a more general programming term, ink calls
    these notes **comments**. They begin with two slashes and then contain the content
    of the comment. Any part of the line is also considered part of the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When run, the text of the story would be treated as its code. However, any use
    of comments would not appear in the output of the story. Comments are only designed
    for human audiences and allow an author to explain the code to other audiences,
    or, more generally, as notes to themselves or other members of their team about
    how something works.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Inky
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help authors more quickly develop a story in ink, **Inkle Studios** has
    created a program called **Inky**. This editing tool allows an author to write
    code and see it run as a preview of its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Screenshot of the Inky editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Screenshot of the Inky editor
  prefs: []
  type: TYPE_NORMAL
- en: While initially developed by Inkle Studios, Inky is now an open source project
    and often sees dozens of commits by the community to fix small issues or add new
    functionality. A new minor version usually comes out every year.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Inky does not have a Windows installer but provides
    builds for macOS X and Linux systems. When running on Windows or Linux, the ZIP
    file needs to be unzipped to an existing folder and the `Inky.exe` (for Windows)
    or `Inky` (for Linux) file run to open the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Using Inky
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inky presents an interface with two panes:'
  prefs: []
  type: TYPE_NORMAL
- en: The left is where ink code is written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right shows a preview of the code while it is being developed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows users to quickly see how their code would produce different outputs
    depending on what code was used.
  prefs: []
  type: TYPE_NORMAL
- en: Inky's most useful function is the ability to "rewind" a story to an earlier
    point and try a different branch of the narrative. This allows authors to test
    branches of their story more quickly, without needing to restart the story each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The "Rewind a single choice" and "Restart story" buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – The "Rewind a single choice" and "Restart story" buttons
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This book will use screenshots from Inky to show the resulting output of different
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating choices and making weaves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While having code pick parts of a story to produce a new possible narrative
    for a user could be exciting, most users want some input on what happens next.
    They want an interactive story. In ink, interactivity is created by presenting
    the user with choices. Depending on which choice the reader makes, the narrative
    could then branch in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Making weaves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choices in ink are a part of another important concept, **weaves**. As a user
    creates a flow from one part to another, they often encounter intersections within
    a story where branches might be possible depending on what choice is made. This
    is what is known as a **weave** within ink. These are collections of choices where
    each one has the potential to branch the story in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choices are written in ink using an asterisk, `*`. What might appear as a list
    of things is, in ink, each a different choice within a single weave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, each line starting with an asterisk is a choice. It starts
    from the asterisk and extends to the end of the line. Everything that is part
    of the line becomes a part of the choice. Each asterisk on a new line creates
    a new choice within the weave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each choice in a weave has the potential to branch the narrative. In the previous
    code, there are two choices. However, after each choice is another line of code.
    When run, ink would understand each line following a choice as being the result
    of choosing the reader. To help to visually differentiate the result of the choice
    better, the line following a choice is often indented at its start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the previous code to use indentation would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Choices within choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choices can also appear inside other choices. These are sub-choices and use
    an additional asterisk to indicate that they are the result of a previous layer
    of a weave:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, there are two choices that each lead to their own choices,
    branching off the central set. This is an example of a **complex weave**. The
    first layer of the weave is the initial two choices. The result of either choice
    is then another weave, which then ends in text. Depending on the user's flow,
    they might only see part of the overall story when moving between these parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible branch within the complex weave could be the following output
    for the reader:'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A different series of branches within the story might also create the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Selective choice output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using choices, the text of the choice itself appears in its output. This
    can be changed by using a special concept with choices called **selective output**.
    By using open and closing square brackets around any text in the line of the choice,
    it will not appear as part of the output as a result of making the choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the output, regardless of the choice made by the reader,
    would be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the cases where the text of the choice is different from what is shown to
    the reader, the term **option** is used. A choice is created in ink using code.
    What is ultimately shown to the reader is an *option*.
  prefs: []
  type: TYPE_NORMAL
- en: In more advanced code examples, ink can generate choices dynamically. In these
    cases, as with selective output, it can be important to understand the use of
    a choice as something written by a developer and an option as selected by the
    reader. Often, these can be the same thing, but they do not have to be when writing
    code in ink.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selective output also allows creating more dynamic output by selectively showing
    text from an option in the output. An effect of using selective output is that
    the closing square bracket in a line signals an end to what is shown to the reader.
    Any additional text on the same line is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From the reader's perspective, the previous code would show three options. Each
    one would read `I cut the wire`. However, the use of selective output is telling
    ink to ignore the additional text of each color. After making a choice, the user
    would then see the result of the choice as a new line, with the use of square
    brackets excluding anything they enclose.
  prefs: []
  type: TYPE_NORMAL
- en: Selective output can often be useful to *hide* additional information behind
    a choice where the reader must pick an option and then see the additional text
    of a line.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each choice in a weave can potentially branch a narrative. However, sometimes
    there is a need to gather one or more branches back to where they began. Instead
    of leading off in a new direction, a gathering point can be used to collapse a
    more complex weave into a *central point*. In ink, *gathering points* are created
    using a single minus sign (`-`) on a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, there are two choices with two sub-choices each. However,
    at the bottom of the weave is a *gathering point*. No matter what branch is taken
    across the first weave and then into the next layer, the flow will always gather
    at the last line. This is the power of gathering points: they allow a complex
    weave with multiple layers to collapse into a single point.'
  prefs: []
  type: TYPE_NORMAL
- en: The placement of gathering points is important. In ink, stories flow down from
    the top to the bottom. If the gathering point appeared before the weave, it would
    be ignored. Without anything to gather, the gathering point does nothing. This
    also only affects weaves. Multiple gathering points in a story would do nothing
    without a weave *above* them to act as a point of collapsing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gathering points only work on a single weave at a time. As the last line of
    a weave, they act to *gather* the choices. However, they only apply to one branching
    structure at a time. A new gathering point is needed per weave to collapse those
    branches back together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, both selective output and gathering points are used to
    create the illusion of two weaves with two choices each. The outcome of each,
    because they are using gathering points, is the last line of each. Options are
    presented to the reader, but the code itself collapses any possible branching
    of each weave and flows the story from the first weave to the second layer.
  prefs: []
  type: TYPE_NORMAL
- en: Disappearing and sticky choices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default behavior of a weave is to direct the flow of a story along with
    one of the branches presented by its choices. When the reader makes a choice,
    the others *disappear*, and the branch chosen becomes the current flow of the
    story. Even when rewinding when using Inky to test a story, there appears to only
    be one valid branch of a weave at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anticipating situations where the reader might revisit a part of a story with
    choices the reader might not have seen before, ink uses the concept of sticky
    choices to present the same choices again to the reader. Using sticky choices,
    each remains *open* during a revisit and can be used again in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sticky choices are created using the plus sign (`+`). They can be thought of
    as the opposite of a gathering point. Instead of collapsing a weave, a sticky
    choice *keeps open* the option within a weave of using a different branch. Any
    sticky choice created as part of a weave is always *sticky*, even if it is the
    only one within the weave:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, there are two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is a sticky choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second would be removed upon a second visit to the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the example, `boulder` could be ignored once, but the next time the reader
    visited the part again, they would only see one option: `Push the boulder`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In examples where the story only flows down from top to bottom, sticky choices
    seem of little use. Upon making any choice, the story would flow along a branch
    and to the next lower part in the story regardless of the choice type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, there is a single weave with two sticky choices. When
    moving through the story from top to bottom, the weave would be visited once and
    either choice would branch out and then back together again at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The same example could be made with the other choice type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Where the two code examples are different is in their intention. In the first,
    the reader could, potentially, revisit the same part of the story and see the
    choices again. In the second, the choices are one-way. By making a choice within
    the weave, they cannot be revisited in a story. Once made, a basic choice is permanent.
    The only way to change this intention is to use sticky choices that *add* themselves
    back to the weave when used.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031),
    *Knots, Diverts, and Looping Patterns*, we move into examining loops and controlling
    the flow of a story across more complex structures. Loops will allow us to revisit
    the same section of a story multiple times. In these cases, sticky choices will
    become the default usage for creating options for the player. Because sticky choices
    remain open, they allow an author to create a weave where a player can select
    the same option multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided you with an explanation of the term story, content, and
    the narrative, what the reader might experience from its content. We examined
    nonlinear storytelling as how the parts of a story can be experienced in an order
    different than how they were written or originally composed. Next, we learned
    about branching narratives as a description of experiencing a nonlinear story
    where different sequences, branches, are explored over others. Through using code
    (scripting), we saw how different narratives can be created by controlling when
    the reader experiences story content.
  prefs: []
  type: TYPE_NORMAL
- en: ink is a narrative scripting language. We understand the movement through a
    story as a concept called flow. We discovered that each intersection, created
    by using different types of choices, is known as a weave. By using choices, we
    saw that different layers of a weave and more branching are possible. For situations
    where a weave is growing too complex, we can use a gathering point. This collapses
    a weave into a single point or line.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin to use knots, labeled sections of a story,
    and diverts, moving between these, to build on the concepts of nonlinear storytelling
    and branching narratives. We will start to use choices to move the reader to a
    particular knot or repeat the same weave again.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the story and the narrative?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does ink understand the concept of flow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can multiple lines of text be combined into one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a weave made of in ink?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of choices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can selective output be used to hide information from the reader in a choice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might a sticky choice be the preferred way to present options to the reader?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
