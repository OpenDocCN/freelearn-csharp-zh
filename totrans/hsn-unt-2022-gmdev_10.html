<html><head></head><body>
  <div id="_idContainer537" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-129" class="chapterTitle">Materials and Effects with URP and Shader Graph</h1>
    <p class="normal">Welcome to the first chapter of <em class="italic">Part 3</em>. Here, we will dive deep into the different graphics and audio systems of Unity to dramatically improve the look and feel of the game. We will start by discussing what a shader is and how to create our own to achieve several custom effects that couldn’t be accomplished using the default Unity Shaders. We will be creating a simple water animation effect using Shader Graph, a visual shader editor included in the Universal Render Pipeline. Also known as URP, this is one of the different rendering pipelines available in Unity, which provides rendering features oriented toward performance. We will be discussing some of its capabilities in this chapter.</p>
    <p class="normal">In this chapter, we will examine the following shader concepts: </p>
    <ul>
      <li class="bulletList">Introducing shaders and URP</li>
      <li class="bulletList">Creating shaders with Shader Graph</li>
    </ul>
    <h1 id="_idParaDest-130" class="heading-1">Introducing shaders and URP</h1>
    <p class="normal">We created <strong class="keyWord">Materials</strong> in <em class="italic">Part 1</em> of the book, but we never discussed how they internally work and why <a id="_idIndexMarker601"/>their <strong class="screenText">Shader</strong> property is important. In this first section of this chapter, we <a id="_idIndexMarker602"/>will be exploring the concept of a shader as a way to program the video card to achieve custom visual effects. We will also be discussing how URP works with those shaders, and the default shaders it provides.</p>
    <p class="normal">In this section, we will cover the following concepts related to shaders:</p>
    <ul>
      <li class="bulletList">Shader Pipeline</li>
      <li class="bulletList">Render Pipeline and URP</li>
      <li class="bulletList">URP built-in shaders</li>
    </ul>
    <p class="normal">Let’s start by discussing <a id="_idIndexMarker603"/>how a shader modifies the Shader Pipeline to achieve <a id="_idIndexMarker604"/>effects.</p>
    <h2 id="_idParaDest-131" class="heading-2">Shader Pipeline</h2>
    <p class="normal">Whenever a video card renders a 3D model, it needs different information to process, such as a <strong class="screenText">Mesh</strong>, <strong class="screenText">Textures</strong>, the <a id="_idIndexMarker605"/>transform of the object (position, rotation, and scale), and lights that affect that object. With that data, the video card must output the pixels of the object into the <strong class="keyWord">back-buffer</strong>, an image where the video card will be drawing our objects, but the user won’t see this yet. This is done to prevent the user from seeing unfinished results, given we can still be drawing at the time the monitor refreshes. That image will be shown when Unity finishes rendering all objects (and some effects) to display the finished scene, swapping the <strong class="keyWord">Back-buffer </strong>with the <strong class="keyWord">front-buffer</strong>, the image that the user actually sees. You can imagine this as having a page with an image that is being shown to the user while you draw a new image, and when you finish the new drawing, you just swap the pages and start drawing again on the page the user is not seeing, repeating this with every frame.</p>
    <p class="normal">That’s the usual way to render an object, but what happens between the input of the data and the output of the pixels can be handled in a myriad of different ways and techniques that depend on how you want your object to look; maybe you want it to be realistic or look like a hologram, maybe the object needs a disintegration effect or a toon effect—there are endless possibilities. The way to specify how our video card will handle the render of the object is through a shader.</p>
    <p class="normal">A <strong class="keyWord">shader</strong> is a program <a id="_idIndexMarker606"/>coded in specific video card languages, such as:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">HLSL</strong>: The DirectX shading <a id="_idIndexMarker607"/>language, DirectX being a graphics library.</li>
      <li class="bulletList"><strong class="keyWord">GLSL</strong>: The OpenGL <a id="_idIndexMarker608"/>shading language, OpenGL also being a graphics library.</li>
      <li class="bulletList"><strong class="keyWord">CG</strong>: A language that can output either HLSL or GLSL, depending on which graphics library we use in our game.</li>
      <li class="bulletList"><strong class="keyWord">Shader Graph</strong>: A visual language <a id="_idIndexMarker609"/>that will be automatically converted into one of the previously mentioned languages according to our needs. This is the one we will be using given its simplicity (more on that later).</li>
    </ul>
    <p class="normal">Any of those languages can be used to configure different stages of the render process necessary to render a <a id="_idIndexMarker610"/>given object, sometimes not only configuring them but also replacing them with completely custom code to achieve the exact effect we want. All of the stages to render an object make up what we call the Shader Pipeline, a chain of modifications applied to the input data until it is transformed into pixels.</p>
    <p class="normal">Each stage of the <a id="_idIndexMarker611"/>pipeline is in charge of different modifications and depending on the video card shader model, this pipeline can vary a lot. In the next diagram, you can find a simplified Render Pipeline, skipping advanced/optional stages that are not important right now:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.1: Common Shader Pipeline</p>
    <p class="normal">Let’s discuss each of the stages:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Input Assembler</strong>: Here is <a id="_idIndexMarker612"/>where all of the mesh data, such as vertex position, UVs, and normals, is assembled to be prepared for the next stage.</li>
      <li class="bulletList"><strong class="keyWord">Vertex Shader</strong>: This stage used to be limited to applying the transformation of the object, the <a id="_idIndexMarker613"/>position and perspective of the camera, and simple lighting calculations. In modern GPUs, you are in charge of doing whatever you want. This stage receives each one of the vertexes of the object to render and outputs a modified one. You have the chance to modify the geometry of the object here. The usual code here is applying the transform of the object, but you can also apply several effects such as inflating the object along its normals to apply the old toon effect technique or apply distortion adding random offsets to each vertex to recreate a hologram. There’s also the opportunity to calculate data for the next stages.</li>
      <li class="bulletList"><strong class="keyWord">Culling</strong>: Most of the models you are going to render have the particularity that you will never <a id="_idIndexMarker614"/>see the back side of a model face. In a cube, there’s no way to look at its inner sides. Given that, rendering both sides of each face of the cube makes no sense, and this stage takes care of that. Culling will determine whether the face needs to be rendered based on the orientation of the face, saving lots of pixel calculation of <a id="_idIndexMarker615"/>occluded faces. You can change this to behave differently for specific cases; as an example, we can create a glass box that needs to be transparent to see all sides of the box.</li>
      <li class="bulletList"><strong class="keyWord">Rasterizer</strong>: Now that we have the modified and visible geometry of our model calculated, it’s <a id="_idIndexMarker616"/>time to convert it into pixels. The rasterizer creates all pixels for the triangles of our mesh. Lots of things happen here but again, we have very little control of that; the usual way to rasterize is just to create all pixels inside the edges of the mesh triangles. We have other modes that just render the pixels on the edges to see a wireframe effect, but this is usually used for debugging purposes:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18585_10_02.png" alt="Image result for rasterizer"/></figure>
    <p class="packt_figref">Figure 10.2: Example of figures being rasterized</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Fragment Shader</strong>: This is one of the most customizable stages of all. Its purpose is simple: just determine the color of each one of the fragments (pixels) that the <a id="_idIndexMarker617"/>rasterizer has generated. Here, lots of things can happen, from simply outputting a plain color or sampling a texture to applying complex lighting calculations such as normal mapping and PBR. Also, you can use this stage to create special effects such as water animations, holograms, distortions, disintegrations, and any special effects that require you to modify what the pixels look like. We will explore how we can use this stage in the next sections of this chapter.</li>
      <li class="bulletList"><strong class="keyWord">Depth Testing</strong>: Before showing a pixel on the screen, we need to check whether it can be seen. This stage checks whether the pixel’s depth is behind or in front <a id="_idIndexMarker618"/>of the previous pixel rendered in the same position, guaranteeing that regardless of the rendering order of the objects, the nearest pixels to the camera are always being drawn on top of others. Again, usually, this stage is left in its default state, prioritizing pixels that are nearer to the camera, but some effects require different behavior. Also, nowadays we have <strong class="keyWord">Early-Z testing</strong>, which does this same test but before the Fragment shader, but let’s keep things simple for now. As an example, in the next screenshot, you can see an effect that allows you to see objects that are behind other objects, like the one used in <em class="italic">Age of Empires</em> when a unit is behind a building:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18585_10_03.png" alt="Image result for occluded effect shader"/></figure>
    <p class="packt_figref">Figure 10.3: Rendering the occluded parts of the character</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Blending</strong>: Once the color of the pixel is determined and we are sure the pixel is not occluded <a id="_idIndexMarker619"/>by a previous pixel, the final step is to put it in the back-buffer (the frame or image you are drawing). Usually, we just override whatever pixel was in that position (because our pixel is nearer to the camera), but if you think about transparent objects, we need to combine our pixel with the previous one to make the transparent effect. Transparencies have other things to take into account aside from the blending, but the main idea is that blending controls exactly how the pixel will be combined with the previously rendered pixel in the back-buffer.</li>
    </ul>
    <p class="normal">Shader Pipelines is a subject that would require an entire book, but for the scope of this book, the previous <a id="_idIndexMarker620"/>description will give you a good idea of what a shader does, and the possible effects that it can achieve. Now that we have discussed how a shader renders a single object, it is worth discussing how Unity renders all of the objects using Render Pipelines.</p>
    <h2 id="_idParaDest-132" class="heading-2">Render Pipeline and URP</h2>
    <p class="normal">We have covered how the video card renders an object, but Unity is in charge of asking the video card to execute its Shader Pipeline per object. To do so, Unity needs to do lots of preparations and calculations to determine exactly how and when each shader needs to be executed. The responsibility of doing this is with what Unity calls the Render Pipeline.</p>
    <p class="normal">A Render Pipeline is a way to draw the objects of the scene. At first, it sounds like there should be just one simple <a id="_idIndexMarker621"/>way of doing this, for example, iterating over all objects in <a id="_idIndexMarker622"/>the scene and executing the Shader Pipeline with the shader specified in each object’s Material, but it can be more complex than that. </p>
    <p class="normal">Usually, the main difference between one Render Pipeline and another is the way in which lighting and some advanced effects are calculated, but they can differ in other ways. </p>
    <p class="normal">In previous Unity versions, there was just one single Render Pipeline, which is now called the <strong class="keyWord">Built-in Renderer Pipeline</strong> (also known as <strong class="keyWord">BIRP</strong>). It was a pipeline that had all of the possible <a id="_idIndexMarker623"/>features you would need for all kinds of projects, from mobile 2D graphics and simple 3D to cutting-edge 3D like the ones you can find in consoles or high-end PCs. This sounds ideal, but actually, it isn’t. Having one single giant renderer that needs to be highly customizable to adapt to all possible scenarios generates lots of overhead and limitations that cause more headaches than <a id="_idIndexMarker624"/>creating a custom Render Pipeline. Luckily, the last versions of Unity introduced <strong class="keyWord">Scriptable Render Pipeline</strong> (<strong class="keyWord">SRP</strong>), a way to create Render Pipeline adapted for your project. </p>
    <p class="normal">Luckily, Unity doesn’t want you to create your own Render Pipeline for each project (which is a complex task), so <a id="_idIndexMarker625"/>it has created two custom pipelines for you that are ready to use: <strong class="keyWord">URP</strong> (formerly called LWRP), which stands for <strong class="keyWord">Universal Render Pipeline</strong>, and <strong class="keyWord">HDRP</strong>, which stands for <strong class="keyWord">High Definition Render Pipeline</strong>. The idea is that you must choose one or the other based on your project’s requirements (unless you really need to create your own).</p>
    <p class="normal">URP, the one we selected when creating the project for our game, is a Render Pipeline suitable for most games that don’t require lots of advanced graphics features, such as mobile games or <a id="_idIndexMarker626"/>simple PC games, while HDRP is packed with lots of <a id="_idIndexMarker627"/>advanced rendering features for high-quality games. The latter requires high-end hardware to run, while URP runs in almost every relevant target device. It is worth mentioning that you can swap between Built-in Renderer, HDRP, and URP whenever you want, including after creating the project (but this is not recommended):</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.4: Project wizard showing HDRP and URP templates</p>
    <p class="normal">We can discuss how each one is implemented and the differences between each, but again, this could fill entire chapters; right now, the idea of this section is for you to know why we picked URP when we created our project because it has some restrictions we will encounter throughout this book that we will need to take into account, so it is good to know why we accepted those limitations (to run our game on every relevant hardware). </p>
    <p class="normal">Also, we need to know that we have chosen URP because it has support for Shader Graph, the Unity tool that we will be using in this chapter to create custom effects. Previous Unity built-in pipelines didn’t provide us with such a tool (aside from third-party plugins). Finally, another reason to introduce the concept of URP is that it comes with lots of built-in shaders that we will need to know about before creating our own to prevent reinventing the wheel. This will allow us to get used to those shaders, because if you came from previous versions of Unity, the shaders you already know won’t work here; actually, this is <a id="_idIndexMarker628"/>exactly what we are going to discuss in the next s<a id="_idIndexMarker629"/>ection of this chapter: the difference between the different URP built-in shaders.</p>
    <h2 id="_idParaDest-133" class="heading-2">URP built-in shaders</h2>
    <p class="normal">Now that we know the difference between URP and other pipelines, let’s discuss which shaders come <a id="_idIndexMarker630"/>integrated into URP. Let’s briefly describe the three most important shaders in this pipeline:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Lit</strong>: This is the replacement of the old Standard Shader. This shader is useful for creating all kinds of realistic physics materials such as wood, rubber, metal, skin, and combinations of them (such as a character with skin and metal armor). It supports features like Normal Mapping, Occlusion, different lighting workflows like Metallic and Specular, and transparencies.</li>
      <li class="bulletList"><strong class="keyWord">Simple Lit</strong>: This is the replacement of the old Mobile/Diffuse Shader. As the name suggests, this shader is a simpler version of Lit, meaning that its lighting calculations are simpler approximations of how light works, getting fewer features than its counterpart. Basically, when you have simple graphics without realistic lighting effects, this is the best choice.</li>
      <li class="bulletList"><strong class="keyWord">Unlit</strong>: This is the replacement of the old Unlit/Texture Shader. Sometimes, you need objects with no lighting whatsoever, and in that case, this is the shader for you. No lighting doesn’t mean an absence of light or complete darkness; it actually means that the object has no shadows at all, and it’s fully visible without any shade. Some simplistic graphics can work with this, relying on shadowing being baked in the texture, meaning that the texture comes with the shadow. </li>
    </ul>
    <p class="bulletList">This is extremely performant, especially for low-end devices such as mobile phones. Also, you have other cases such as light tubes or screens, objects <a id="_idIndexMarker631"/>that can’t receive shadows because they emit light, so they will be seen at their full color even in complete darkness. In the following screenshot, you can see a 3D model using an Unlit Shader. It looks like it’s being lit, but it’s just the texture of the model that applied lighter and darker colors in different parts of the object:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.5: Pod using an Unlit effect to simulate cheap lighting</p>
    <p class="normal">Let’s do an interesting <a id="_idIndexMarker632"/>disintegration effect with the Simple Lit Shader to demonstrate its capabilities. You must do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Download and import a <strong class="screenText">Cloud Noise</strong> texture from any search engine:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_06.png" alt="Image result for cloud noise texture"/></figure>
    <p class="packt_figref">Figure 10.6: Noise texture</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Select the recently imported texture in the <strong class="screenText">Project</strong> panel.</li>
      <li class="numberedList">In the Inspector, set the <strong class="screenText">Alpha Source</strong> property to <strong class="screenText">From Gray Scale</strong>. This will make the alpha channel of the texture be calculated based on the grayscale of the image:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.7: Generate Alpha From Gray Scale texture setting</p>
    <div class="note">
      <p class="normal">The Alpha channel of a color is often associated with transparency, but you will notice that our object won’t be transparent. The Alpha channel is extra color data that can be used for several purposes when creating effects. In this case, we will use it to determine which pixels are being disintegrated first.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Click the <strong class="screenText">+</strong> icon in the Project view and select <strong class="screenText">Material</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.8: Material creation button</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Create a <a id="_idIndexMarker633"/>cube by going to <strong class="screenText">GameObject | 3D Object | Cube</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.9: Cube primitive creation</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Drag the Material from the Project window to the cube in the Scene window.</li>
      <li class="numberedList">Click in the drop-down menu at the right of the <strong class="screenText">Shader</strong> property in the Inspector and look for the <strong class="screenText">Universal Render Pipeline | Simple Lit</strong> option. We could also work with the default shader (<strong class="screenText">Lit</strong>), but <strong class="screenText">Simple Lit</strong> is going to be easier on performance and we won’t use the advanced features of Lit:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.10: Simple Lit Shader selection</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Select <a id="_idIndexMarker634"/>the <strong class="screenText">Material</strong> and drag the downloaded cloud Texture to the rectangle at the left of <strong class="screenText">Base Map</strong>.</li>
      <li class="numberedList">Check the <strong class="screenText">Alpha Clipping</strong> checkbox and set the <strong class="screenText">Threshold</strong> slider to <code class="inlineCode">0.5</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.11: Alpha Clipping Threshold Material slider</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">As you move the <strong class="screenText">Threshold</strong> slider, the object will start to disintegrate. <strong class="screenText">Alpha Clipping</strong> discards pixels that have less Alpha intensity than the <strong class="screenText">Threshold</strong> value:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.12: Disintegration effect with Alpha Clipping</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Finally, set <strong class="screenText">Render Face</strong> to <strong class="screenText">Both</strong> to see both sides of the cube’s faces:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.13: Double-sided render face</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="12">Take into account that <a id="_idIndexMarker635"/>the artist that creates the texture can configure the Alpha channel manually instead of calculating it from the grayscale, just to control exactly how the disintegration effect must look regardless of the texture’s color distribution:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.14: Double-sided Alpha Clipping</p>
    <p class="normal">The idea of this section is not to give a comprehensive guide of all of the properties of all URP shaders, but to give you an idea of what a shader can do when properly configured and when to <a id="_idIndexMarker636"/>use each one of the integrated shaders. Sometimes, you can achieve the effect you need just by using existing shaders, probably in 99% of cases in simple games, so try to stick to them as much as you can. But if you really need to create a custom shader to create a very specific effect, the next section will teach you how to use the URP tool called Shader Graph.</p>
    <h1 id="_idParaDest-134" class="heading-1">Creating shaders with Shader Graph</h1>
    <p class="normal">Now that we know how shaders work and the existing shaders in URP, we have a basic notion of <a id="_idIndexMarker637"/>when it is necessary to create a custom shader and when it is not necessary. In case you really need to create one, this section will cover the basics of effects creation with Shader Graph, a tool to create effects using a visual node-based editor. This is an easy tool to use when you are not used to coding.</p>
    <p class="normal">In this section, we will discuss the following concepts of the Shader Graph:</p>
    <ul>
      <li class="bulletList">Creating our first Shader Graph</li>
      <li class="bulletList">Using textures</li>
      <li class="bulletList">Combining textures</li>
      <li class="bulletList">Applying transparency</li>
      <li class="bulletList">Creating Vertex effects</li>
    </ul>
    <p class="normal">Let’s start by seeing how we can create and use a Shader Graph.</p>
    <h2 id="_idParaDest-135" class="heading-2">Creating our first Shader Graph</h2>
    <p class="normal">Shader Graph is a tool that <a id="_idIndexMarker638"/>allows us to create custom effects using a <a id="_idIndexMarker639"/>node-based system. An effect in the Shader Graph can look like in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.15: Shader Graph with nodes to create a custom effect</p>
    <p class="normal">We will discuss later what those nodes do and we will be creating an example effect step by step, but in the screenshot, you can see how the author created and connected several nodes—the interconnected boxes—with each one executing a specific process to achieve the effect. The idea of creating effects with Shader Graph is to learn which specific nodes you need and how to connect them properly. This is similar to the way we code the gameplay of the game, but this Shader Graph is adapted and simplified just for effect purposes.</p>
    <p class="normal">To create and edit our first Shader Graph, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the Project window, click the <strong class="screenText">+</strong> icon and find the <strong class="screenText">Shader Graph | URP | Lit Shader Graph</strong> option. This will create a Shader Graph using the PBR mode, meaning that this shader will support lighting effects (unlike Unlit Graphs):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.16: PBR Shader Graph creation</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Name it <code class="inlineCode">Water</code>. If you want the opportunity to rename the asset, remember that you can select the asset, right-click, and select <strong class="screenText">Rename</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.17: Shader Graph Asset</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create a new Material called <code class="inlineCode">WaterMaterial</code> and set <strong class="screenText">Shader</strong> to <strong class="screenText">Shader Graphs/Water</strong>. If for <a id="_idIndexMarker640"/>some reason Unity doesn’t allow you to do that, try right-clicking on the <strong class="screenText">Water Graph</strong> and clicking <strong class="screenText">Reimport</strong>. As you can see, the created Shader Graph now appears as a shader in the Material:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.18: Setting a Shader Graph as a Material Shader</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Create a plane with the <strong class="screenText">GameObject | 3D Object | Plane </strong>option.</li>
      <li class="numberedList">Drag the <strong class="screenText">Material</strong> to the <strong class="screenText">Plane</strong> to apply it.</li>
    </ol>
    <p class="normal">Now, you have created your first custom shader and applied it to a Material. So far, it doesn’t look interesting at all—it’s just a gray effect—but now it’s time to edit the graph to unlock its full potential. As the name of the graph suggests, we will be creating a water effect in this chapter to illustrate several nodes of the Shader Graph toolset and how to connect them, so let’s start by discussing the Master node.</p>
    <p class="normal">When you open the <a id="_idIndexMarker641"/>graph by double-clicking the shader asset, you will see the following:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.19: Master node with all of the properties needed to calculate object appearance</p>
    <p class="normal">All nodes will have input pins, the data needed to work, and output pins, the results of its process. As an example, in a sum operation, we will have two input numbers and an output number, the result of the sum. In this case, you can see that the Master node only contains inputs, and that’s because all data that enters the Master node will be used by Unity to calculate the rendering and lighting of the object, things such as the desired object color or texture (<strong class="screenText">Base Color</strong> input pin), how smooth it is (<strong class="screenText">Smoothness</strong> input pin), or how much metal it contains (<strong class="screenText">Metallic </strong>input pin), properties that will affect how the lighting will be applied to the object.</p>
    <p class="normal">You can see that the Master node is split between a <strong class="screenText">Vertex</strong> section and a <strong class="screenText">Fragment</strong> section. The first is capable of changing the mesh of the object we are modifying to deform it, animate it, etc., while the latter will change how it will look, which textures to use, how it will be illuminated, etc. Let’s start exploring how we can change that data in the <strong class="screenText">Fragment</strong> section by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Double-click the <strong class="screenText">Shader Graph</strong> asset in Project View to open its editor.</li>
      <li class="numberedList">Click in the gray rectangle at the left of the <strong class="screenText">Base Color</strong> input pin:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.20: Base Color node input pin</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In the color <a id="_idIndexMarker642"/>picker, select a light blue color, like water. Select the bluish part of the circle and then a shade of that color in the middle rectangle:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.21: Color picker</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Set <strong class="screenText">Smoothness</strong> to <code class="inlineCode">0.9</code>, which will make the object almost completely smooth (90% of the total smoothness possible). This will make our water reflect the sky almost completely:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.22: Smoothness PBR Master node input pin</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Click the <strong class="screenText">Save Asset</strong> button at the top left of the window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.23: Shader Graph saving options</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Go back to the Scene View and check the plane is light blue with the sun reflected on it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.24: Initial Shader Graph results</p>
    <p class="normal">As you can see, the behavior of the shader varies according to the properties you set in the <strong class="screenText">Master</strong> node, but so far, doing this is no different than creating an Unlit Shader and setting up its <a id="_idIndexMarker643"/>properties; the real power of Shader Graph is when you use nodes that do specific calculations as inputs of the Master node. We will start looking at the texturing nodes, which allow us to apply Textures to our model.</p>
    <h1 id="_idParaDest-136" class="heading-1">Using Textures</h1>
    <p class="normal">The idea of using Textures is <a id="_idIndexMarker644"/>to have an image applied to the model in a way that we <a id="_idIndexMarker645"/>can paint different parts of the models with different colors. Remember that the model has a UV map, which allows Unity to know which part of the Texture will be applied to which part of the model:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.25: On the left, a face Texture; on the right, the same texture applied to a face mesh</p>
    <p class="normal">We have several nodes to do this task, one of them being Sample Texture 2D, a node that has two main inputs. First, it asks us for the texture to sample or apply to the model, and then for the UV. You can see it in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.26: Sample Texture 2D node</p>
    <p class="normal">As you can see, the default value of the <strong class="screenText">Texture</strong> input node is <strong class="screenText">None</strong>, so there’s no texture by default, and <a id="_idIndexMarker646"/>we need to manually specify that. For <strong class="screenText">UV</strong>, the default value is <code class="inlineCode">UV0</code>, meaning <a id="_idIndexMarker647"/>that, by default, the node will use the main UV channel of the model, and yes, a model can have several UVs set. For now, we will stick with the main one. If you are not sure what that means, UV0 is the safest option. Let’s try this node, doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Download and import a <strong class="screenText">tileable water texture</strong> from the internet:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_27.png" alt="Image result for tileable water texture"/></figure>
    <p class="packt_figref">Figure 10.27: Water tileable Texture</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Select the Texture and be sure that the <strong class="screenText">Wrap Mode</strong> property of the Texture is set to <strong class="screenText">Repeat</strong>, which will allow us to repeat the Texture as we did in the terrain because the idea is to use this shader to cover large water areas:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.28: Texture Repeat mode</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In the <strong class="screenText">Water Shader Graph</strong>, right-click in an empty area of the <strong class="screenText">Shader Graph</strong> and select <strong class="screenText">Create Node</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.29: Shader Graph Create Node option</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In the <strong class="screenText">Search</strong> box, write <code class="inlineCode">Sample texture</code> and all of the sampler nodes will show up. Double-click <strong class="screenText">Sample Texture 2D</strong>. If for some reason you can’t double-click <a id="_idIndexMarker648"/>the option, right-click on it first and then try again. There is a <a id="_idIndexMarker649"/>known bug on this tool and this is the workaround:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.30: Sample texture node search</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Click in the circle to the left of the <strong class="screenText">Texture</strong> input pin of the <strong class="screenText">Sample Texture 2D</strong> node. It will allow us to pick a Texture to sample—just select the water one. You can see that the Texture can be previewed in the bottom part of the node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.31: Sample Texture node with a Texture in its input pin</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Drag the <a id="_idIndexMarker650"/>output pin <strong class="screenText">RGBA</strong> from the <strong class="screenText">Sample Texture 2D</strong> node to the <strong class="screenText">Base Color</strong> input pin <a id="_idIndexMarker651"/>of the Master node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.32: Connecting the results of a Texture sampling with the Base Color pin of the Master node</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Click the <strong class="screenText">Save Asset</strong> button at the top-left part of the Shader Graph editor and see the changes in the Scene view:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.33: Results of applying a Texture in our Shader Graph</p>
    <p class="normal">As you can see, the <a id="_idIndexMarker652"/>Texture is properly applied to the model, but if you take into account <a id="_idIndexMarker653"/>that the default plane has a size of 10x10 meters, the ripples of the water seem too big. So, let’s tile the Texture!</p>
    <p class="normal">To do this, we need to change the UVs of the model, making them bigger. You may imagine that bigger UVs mean the Texture should also get bigger, but take into account that we are not making the object bigger; we are just modifying the UV. </p>
    <p class="normal">In the same object area, we will display more of the texture area, meaning that in the bigger texture sample area (achieved by bigger UVs), repetitions of the texture may appear. To do so, follow the next steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Right-click in any empty space and click <strong class="screenText">New Node</strong> to search for the UV node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.34: Searching for the UV node</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Using the <a id="_idIndexMarker654"/>same method, create a <strong class="screenText">Multiply</strong> node.</li>
      <li class="numberedList">Drag the <strong class="screenText">Out</strong> pin <a id="_idIndexMarker655"/>of the UV node to the <strong class="screenText">A</strong> pin of the <strong class="screenText">Multiply</strong> node to connect them.</li>
      <li class="numberedList">Set the <strong class="screenText">B</strong> pin input value of <strong class="screenText">Multiply</strong> to <code class="inlineCode">4</code>,<code class="inlineCode">4</code>,<code class="inlineCode">4</code>,<code class="inlineCode">4</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.35: Multiplying the UVs by 4</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Drag the <strong class="screenText">Out</strong> pin of the <strong class="screenText">Multiply</strong> node to the <strong class="screenText">UV</strong> of the <strong class="screenText">Sample Texture 2D</strong> node to connect them:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.36: Using the multiplied UVs to sample the Texture</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">If you save the graph and go back to the Scene view, you can see that now the ripples are smaller, because we have tiled the UVs of our model. You can also see that in the preview of the <strong class="screenText">Sampler Texture 2D</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_37.png" alt=""/> </figure>
    <p class="packt_figref">Figure 10.37: Results of the model’s UV multiplication</p>
    <p class="normal">Another interesting <a id="_idIndexMarker656"/>effect we can do now is to apply an offset to the Texture to move it. The idea <a id="_idIndexMarker657"/>is that even if the plane is not actually moving, we will simulate the flow of the water through it, moving just the Texture. Remember, the responsibility of determining the part of the Texture to apply to each part of the model belongs to the UV, so if we add values to the UV coordinates, we will be moving them, generating a Texture sliding effect. To do so, let’s do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an <strong class="screenText">Add</strong> node to the right of the <strong class="screenText">UV</strong> node.</li>
      <li class="numberedList">Connect the <strong class="screenText">Out</strong> pin of the <strong class="screenText">UV</strong> to the <strong class="screenText">A</strong> pin of the <strong class="screenText">Add</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.38: Adding values to the UVs</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create <a id="_idIndexMarker658"/>a <strong class="screenText">Time</strong> node at the left of the <strong class="screenText">Add</strong> node.</li>
      <li class="numberedList">Connect <a id="_idIndexMarker659"/>the <strong class="screenText">Time</strong> node to the <strong class="screenText">B</strong> pin of the <strong class="screenText">Add</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.39: Adding time to the UVs</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Connect the <strong class="screenText">Out</strong> pin of the <strong class="screenText">Add</strong> node to the <strong class="screenText">A</strong> input pin of the <strong class="screenText">Multiply</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.40: Added and multiplied UVs as an input of the sample Texture</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Save and see the <a id="_idIndexMarker660"/>water moving in the Scene view. If you <a id="_idIndexMarker661"/>don’t see it moving, click the layers icon in the top bar of the scene and check <strong class="screenText">Always Refresh</strong>: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.41: Enabling Always Refresh to preview the effect</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">If you feel the water is moving too fast, try using the multiplication node to make the time a smaller value. I recommend you try it by yourself before looking at the next screenshot, which has the answer:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.42: Multiplication of time to move the texture slower</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">If you feel the <a id="_idIndexMarker662"/>graph is too big, try to hide some of the <a id="_idIndexMarker663"/>node previews by clicking on the <strong class="screenText">up</strong> (<strong class="screenText">^</strong>) arrow that appears on the preview when you move the mouse over it: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.43: Hiding the preview from the graph nodes</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Also, you can hide unused pins by selecting the node and clicking the arrow at its top right:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.44: Hiding unused pins from the graph nodes</p>
    <p class="normal">So, to recap, first we added the time to the UV to move it and then multiplied the result of the moved UV to make <a id="_idIndexMarker664"/>it bigger to tile the Texture. It is worth <a id="_idIndexMarker665"/>mentioning that there’s a <strong class="screenText">Tiling and Offset</strong> node that does all of this process for us, but I wanted to show you how a simple multiplication to scale the UV and an add operation to move it generates a nice effect; you can’t imagine all of the possible effects you can achieve with other simple mathematical nodes! Actually, let’s explore other usages of mathematical nodes to combine Textures in the next section.</p>
    <h1 id="_idParaDest-137" class="heading-1">Combining Textures</h1>
    <p class="normal">Even though we have used nodes, we haven’t created anything that can’t be created using regular shaders, but <a id="_idIndexMarker666"/>that’s about to change. So far, we can see the water <a id="_idIndexMarker667"/>moving but it stills look static, and that’s because the ripples are always the same. We have several techniques to generate ripples, and the simplest one would be to combine two water Textures moving in different directions to mix their ripples, and actually, we can simply use the same Texture just flipped to save some memory. To combine the Textures, we will sum them and then divide them by 2, so basically, we are calculating the average of the textures! Let’s do that by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select all of the nodes between <strong class="screenText">Time</strong> and <strong class="screenText">Sampler 2D</strong> (including them) creating a selection rectangle by clicking in any empty space in the graph, holding and dragging the click, and then releasing when all target nodes are covered:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.45: Selecting several nodes</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Right-click <a id="_idIndexMarker668"/>and select <strong class="screenText">Copy</strong>, and then again right-click and select <strong class="screenText">Paste</strong>, or use the classic <em class="italic">Ctrl</em> + <em class="italic">C</em>, <em class="italic">Ctrl</em> + <em class="italic">V</em> commands (<em class="italic">Command </em>+ <em class="italic">C</em>, <em class="italic">Command </em>+ <em class="italic">V</em> on Mac).</li>
      <li class="numberedList">Move the <a id="_idIndexMarker669"/>copied nodes below the original ones:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_46.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.46: Duplication of nodes</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">For the copied nodes, set the <strong class="screenText">B</strong> pin of the <strong class="screenText">Multiply</strong> node connected to <strong class="screenText">Sample Texture 2D</strong> to <code class="inlineCode">-4</code>,<code class="inlineCode">-4</code>,<code class="inlineCode">-4</code>,<code class="inlineCode">-4</code>. You can see that that flipped the texture.</li>
      <li class="numberedList">Also, set the <strong class="screenText">B</strong> pin of the <strong class="screenText">Multiply</strong> node connected to the <strong class="screenText">Time</strong> node to <code class="inlineCode">-0.1</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_47.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.47: Multiplication of values</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Create an <strong class="screenText">Add</strong> node <a id="_idIndexMarker670"/>at the right of both <strong class="screenText">Sampler Texture 2D</strong> nodes and <a id="_idIndexMarker671"/>connect the outputs of those nodes to the <strong class="screenText">A</strong> and <strong class="screenText">B</strong> input pins of the <strong class="screenText">Add</strong> node:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_48.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.48: Adding two Textures</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">You can see that the resulting combination is too bright because we have summed up the intensity of both textures, so let’s fix that by multiplying the <strong class="screenText">Out</strong> of the <strong class="screenText">Add</strong> node by <code class="inlineCode">0.5,0.5,0.5,0.5</code>, which will divide each resulting color channel by 2, averaging the color. You can also experiment with what happens when you set different values to each channel if you want, but for our purposes, <code class="inlineCode">0.5</code> is the proper value for each channel:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_49.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.49: Dividing the sum of two Textures to get the average</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Connect the <strong class="screenText">Out</strong> pin of the <strong class="screenText">Multiply</strong> node to the <strong class="screenText">Base Color</strong> pin of the <strong class="screenText">Master</strong> node to <a id="_idIndexMarker672"/>apply all of those calculations to the color <a id="_idIndexMarker673"/>of the object.</li>
      <li class="numberedList">Save the <strong class="screenText">Asset</strong> and see the results in the Scene view:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_50.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.50: Results of texture blending</p>
    <p class="normal">You can keep adding nodes to make the effect more diverse, such as using <strong class="keyWord">Sine</strong> nodes (which will execute the trigonometry sine operation) to apply non-linear movements and so on, but I will let <a id="_idIndexMarker674"/>you learn that by experimenting with this by yourself. For now, we <a id="_idIndexMarker675"/>will stop here. As always, this topic deserves a full book, and the intention of this chapter is to give you a small taste of this powerful Unity tool. I recommend you look for other Shader Graph examples on the internet to learn other usages of the same nodes and, of course, new nodes. One thing to consider here is that everything we just did is basically applied to the Fragment Shader stage of the Shader Pipeline we discussed earlier. Now, let’s use the Blending Shader stage to apply some transparency to the water.</p>
    <h1 id="_idParaDest-138" class="heading-1">Applying transparency</h1>
    <p class="normal">Before declaring our <a id="_idIndexMarker676"/>effect finished, a little addition we can do <a id="_idIndexMarker677"/>is to make the water a little bit transparent. Remember that the Shader Pipeline has a blending stage, which has the responsibility of blending each pixel of our model into the image being rendered in this frame. The idea is to make our Shader Graph modify that stage to apply <strong class="keyWord">Alpha Blending</strong>, a blending mode that combines our model and the previously rendered models based on the Alpha value of our model. </p>
    <p class="normal">To get that effect, take the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Look for the <strong class="screenText">Graph Inspector</strong> window floating around. If you don’t see it, click the <strong class="screenText">Graph Inspector</strong> button at the top-right part of the Shader Graph editor.</li>
      <li class="numberedList">Click the <strong class="screenText">Graph Settings</strong> tab.</li>
      <li class="numberedList">Set the <strong class="screenText">Surface Type</strong> property to <strong class="screenText">Transparent</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Blending Mode</strong> property to <strong class="screenText">Alpha</strong> if it isn’t already at that value:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_51.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.51: Graph Inspector Transparency settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Set the <strong class="screenText">Alpha</strong> input pin of the <strong class="screenText">Master</strong> to <code class="inlineCode">0.5</code>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_52.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.52: Setting Alpha of the Master node</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Save the Shader <a id="_idIndexMarker678"/>Graph and see the transparency <a id="_idIndexMarker679"/>being applied in the Scene view. If you can’t see the effect, just put a cube into the water to make the effect more evident:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_53.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.53: Shadows from the water being applied to a cube</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">You can see the shadows that the water is casting on our cube because Unity doesn’t know <a id="_idIndexMarker680"/>the object is transparent and hence <a id="_idIndexMarker681"/>casts shadows. Click on the water plane and look for the Mesh Renderer component in the Inspector. If you don’t see the shadow, click the lightbulb at the top of the Scene view.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_54.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.54: Enabling lights in the Scene View</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">In the <strong class="screenText">Lighting</strong> section, set <strong class="screenText">Cast Shadows</strong> to <strong class="screenText">Off</strong>; this will disable shadow casting from the plane on the parts of the cube that are underwater:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_10_55.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.55: Disabling shadow casting</p>
    <p class="normal">Adding transparency is a simple process but it has its caveats, like the shadow problem, and in more complex scenarios, it can have other problems, like increasing overdraw, meaning the same <a id="_idIndexMarker682"/>pixel needs to be drawn several times (the pixel belonging to the transparent object, and one of the objects behind). I would <a id="_idIndexMarker683"/>suggest you avoid using transparency unless it is necessary. Actually, our water can live without transparency, especially when we apply this water to the river basin around the base because we don’t need to see the part under the water, but the idea is for you to know all of your options. In the next screenshot, you can see how we have put a giant plane with this effect below our base, big enough to cover the entire basin:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_56.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.56: Using our water in the main scene</p>
    <p class="normal">Now that we have modified how the object looks through the <strong class="screenText">Fragment</strong> node section, let’s discuss how to use the Vertex section to apply a mesh animation to our water.</p>
    <h1 id="_idParaDest-139" class="heading-1">Creating Vertex Effects</h1>
    <p class="normal">So far, we have applied water textures to our water, but it’s still a flat plane. We can go further than that <a id="_idIndexMarker684"/>and make the ripples not only via textures but also <a id="_idIndexMarker685"/>by animating the mesh. To do so, we will apply the noise texture we used at the beginning of the chapter in the shader, but instead of using it as another color to add to the <strong class="screenText">Base Color</strong> of the shader, we will instead use it to offset the <strong class="screenText">Y</strong> position of the vertexes of our plane. </p>
    <p class="normal">Due to the chaotic nature of the noise texture, the idea is that we will apply a vertical offset to different parts of the model, so we can emulate the ripples:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_57.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.57: Default plane mesh subdivided into a grid of 10x10 with no offset</p>
    <p class="normal">To accomplish <a id="_idIndexMarker686"/>something like this, you can modify the <strong class="screenText">Vertex</strong> section <a id="_idIndexMarker687"/>of your shader to look like the following:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_58.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.58: Ripples vertex effect</p>
    <p class="normal">In the graph, you can see how we are creating a <strong class="screenText">Vector</strong> whose <em class="italic">y</em> axis depends on the noise Texture we downloaded at the beginning of the chapter. The idea behind that is to create a <strong class="screenText">Vector</strong> pointing upward whose length is proportional to the grayscale factor of the texture; the whiter the pixel of the texture, the longer the offset. This texture has an irregular yet smooth pattern so it can emulate the behavior of the tide. </p>
    <div class="note">
      <p class="normal">Please notice that here we used <strong class="screenText">Sample Texture 2D LOD</strong> instead of <strong class="screenText">Sample Texture 2D</strong>; the latter does not work in the <strong class="screenText">Vertex</strong> section, so keep that in mind.</p>
    </div>
    <p class="normal">Then we multiply the result by <em class="italic">0.3</em> to reduce the height of the offset to add, and then we add the result to <a id="_idIndexMarker688"/>the <strong class="screenText">Position</strong> node.See that the <strong class="screenText">Space</strong> property <a id="_idIndexMarker689"/>of the <strong class="screenText">Position</strong> node is set to <strong class="screenText">Object</strong> mode. We need that mode to work with the <strong class="screenText">Vertex</strong> section of the Shader Graph (we discussed World and Local spaces before in <em class="chapterRef">Chapter 2</em>, <em class="italic">Editing Scenes and GameObjects</em> but you can also search <code class="inlineCode">Object vs World Space</code> on the internet for more info about this). Finally, the result is connected to the <strong class="screenText">Position</strong> node of the <strong class="screenText">Vertex</strong> section.</p>
    <p class="normal">If you save, you will see something like the following image:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_59.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.59: Ripples vertex effect applied</p>
    <p class="normal">Of course, in this case, the ripples are static because we didn’t add any time offset to the UV as we did before. In the following screenshot, you can see how to add that, but before looking at it I recommend you try to resolve it first by yourself as a personal challenge:</p>
    <figure class="mediaobject"><img src="../Images/B18585_10_60.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.60: Animated ripples vertex effect graph</p>
    <p class="normal">As you can see, we are <a id="_idIndexMarker690"/>again taking the original UV and adding the <a id="_idIndexMarker691"/>time multiplied by any factor so it will slowly move, the same as we did previously with our water texture. You can keep playing around with this, changing how this looks with different textures, multiplying the offset to increase or reduce the height of the ripples, applying interesting math functions like sine, and so much more, but for now, let’s finish with this.</p>
    <h1 id="_idParaDest-140" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed how a shader works in the GPU and how to create our first simple shader to achieve a nice water effect. Working with shaders is a complex and interesting job, and in a team, there is usually one or more people in charge of creating all of these effects, in a position called Technical Artist; so, as you can see, this topic can expand up to a whole career. Remember, the intention of this book is to give you a small taste of all the possible roles you can take in the industry, so if you really liked this role, I suggest you start reading shader-exclusive books. You have a long but super interesting road in front of you.</p>
    <p class="normal">Enough shaders for now! In the next chapter, we will look at how to improve our graphics and create visual effects with particle systems!</p>
  </div>
</body></html>