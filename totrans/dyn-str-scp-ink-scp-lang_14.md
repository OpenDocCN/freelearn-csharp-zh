# *第11章*：任务跟踪和分支叙事

在本章中，我们将回顾如何创建任务的ink模板，根据此模板跟踪多个任务，并显示玩家跨任务变量的值。在第一部分，我们将创建ink模板及其所需的部分。接下来，我们将改进ink模板并创建一个`Quest`类来跟踪多个独立进展的任务。最后，我们将向玩家展示任务进展的结果并查看在此进展过程中的变化值。

许多大型或以叙事为重点的视频游戏由玩家需要完成的独立任务组成。本章将提供一个在ink中创建任务的模板，并展示如何在使用Unity中访问和操作此模板。通过使用多个任务，允许玩家分别通过每个任务进行进展，正如本章所解释的那样。

在本章中，我们将涵盖以下主题：

+   让任务有意义

+   跨多个任务跟踪进展

+   显示和奖励玩家进展

    重要

    本章的每个主题都有一个独立的、完成的Unity项目。每个主题都包含说明，说明项目的名称以及如何找到它。

# 技术要求

本章的示例已按项目划分文件夹，可在GitHub上找到：[https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11)。

# 让任务有意义

从叙事的角度来看，**任务**是一系列与故事中某个角色相关的事件。在视频游戏中，任务是由玩家体验的一系列相关事件。在角色扮演游戏中，一个任务可能包括解锁武器、营救王子或击败某个大恶势力。沿途的每个点都是任务的**步骤**。从故事和代码的角度来看，任务可以被视为一系列步骤，其中每个步骤的解决都会解锁下一个步骤。

ink支持在更大的整体中包含较小部分的模式，就像绳结中的线头。这样想，任务的每个步骤都可以成为代码中的自己的线头，每个线头的结局能够移动到更大的结构中的下一个位置。在ink中使用`LIST`也允许我们通过名称定义我们想要的步骤，有一个特殊的结将玩家从任务结构中的一个线头推进到下一个线头。

在本节中，我们将学习如何在ink中设计任务模板并访问其在Unity中单个项目中的值，每个部分都是在前一个部分的基础上构建的：

+   在第一部分，*在ink中创建任务模板*，我们将回顾如何使用此模式以及通过使用现有的Ink函数可用的内置自动化。

+   在第二部分，*在Unity中选择特定的节点*，我们将从Ink转向Unity。在这里，我们将检查如何在Ink中运行模板，以及在使用某些Story API方法时需要注意的一些潜在问题。

    提醒

    本节的完成项目可以在[*第11章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)中找到，GitHub文件夹下的示例，名称为`Chapter11,QuestProgression`。只会展示与该主题各部分探讨的概念相关的代码部分。

现在我们来了解下一个主题，我们将创建一个任务模板。

## 在ink中创建一个任务模板

ink故事由不同的部分组成。在[*第1章*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014)中，*文本流、选择和编织*，我们学习了ink如何将代码分解为不同的部分，称为ink中的`VAR`和`LIST`关键字，我们在[*第4章*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062)中，*变量、列表和函数*，我们可以创建一个由一系列步骤组成的任务：

[PRE0]

这段代码在Ink中创建了一个名为`steps`的列表，一个名为`step`的变量和一个名为`end`的变量。这三个值跟踪*任务的进度*。任务中每个步骤的名称都被添加到列表中，第一个被用作`stage`变量的值：

[PRE1]

玩家将看到他们的第一个选项：“当然”和“今天不”。如果选择第一个，流程将进入`quest`节点。如果选择第二个，流程将移动到`quest`节点内的一个名为`stop`的针脚：

[PRE2]

选择*quest*和*stop*这两个名称是经过特别考虑的。使用*quest*这个词有助于理解代码作为其他任务模板的一部分。正如下一节将要概述的，*跨多个任务跟踪进度*，在Unity中可以同时存在多个`Story`对象。在这种情况下，这个词被用来展示模式。

`quest`节点包含这个模式的中心逻辑。因为ink中`LIST`的条目是布尔值（要么是`true`要么是`false`），所以使用多行比较，顺序很重要。名为`steps`的列表包含三个条目，每个条目最初都设置为`true`。当第一次遇到`quest`节点时，它将流程移动到名为`first`的针脚：

[PRE3]

第一个针脚包含一个不寻常的结尾。在Ink中，使用`DONE`关键字通常表示故事以墨水结束。然而，在这种情况下，`DONE`关键字被用来表示步骤已完成。故事并没有转向`quest`节点或另一个部分，而是看似停止了。进度是通过结合`LIST_MIN()`函数和Ink中列表的减法（`-`）操作来实现的：

[PRE4]

在`progress`节点中，每个条目都会被移除（减去），而顶部（最小）值则作为`step`变量的一个部分。每次使用此节点都会通过从列表中移除一个步骤并使用剩余的最高值来推进任务。然而，节点本身并不是直接访问的。相反，它通过Unity外部使用。

在本节中，我们学习了如何将每个步骤作为名为`quest`的节点的一部分进行细分。通过使用ink中的`LIST`和不同的变量，可以在整个任务中跟踪进度。在下一节中，我们将学习如何将ink模板用作一系列步骤，以在Unity中外部访问`progress`节点。

## 在Unity中选择特定的节点

ink-Unity集成插件提供的Story API的不同方法和属性在[*第7章*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106)，“Unity API – Making Choices and Story Progression”和[*第8章*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123)，“Story API – Accessing ink Variables and Functions”中都有涉及。然而，那些章节中没有涵盖的一个有用但可能非常危险的方法名为`ChoosePathString()`。在本节中，我们将探讨如何安全地使用此方法的一个示例。

在ink运行时内部，术语“路径字符串”用于描述故事中任何作为部分的节点。当加载时，可以通过使用`ChoosePathString()`方法来访问这些路径，该方法强制将故事移动到该部分。在大多数情况下，这种行为是不受欢迎的，因为它的使用将忽略任何现有的隧道或线程。它可以被看作是*撕裂*流动从它所在的位置并丢弃到新的位置。

作为ink运行时的一部分，变量是全局的。这意味着虽然它们的值可能会作为故事流程的一部分而改变，但它们存在于故事之外。变量的值在`ChoosePathString()`方法的使用过程中得到保持。换句话说，通过仔细避免任何可能被其使用所破坏的结构，可以在项目中谨慎地使用`ChoosePathString()`方法。

在上一节中，介绍了ink的`progress`节点。要使用`ChoosePathString()`方法在Unity中选择此路径字符串，只需要它的名称：

[PRE5]

当使用`progress` ink节点与`ChoosePathString()`方法时，它确实会中断保存在`InkStory` C#变量中的故事流程。然而，正如我们所学的，由于它们的全局性质，变量的值在整个故事中保持不变。使用`progress` ink节点通过每次更新变量来推进任务到其下一个步骤。

代码还包括对两个其他方法的调用：`FlipProgress()`和`UpdateContent()`。第一个方法使用Unity中的`SetActive()`方法将Unity中的`Button`游戏对象设置为非活动状态。当游戏对象在Unity中被关闭（设置为非活动状态）时，它不会出现在屏幕上。此代码有效地将游戏对象设置为按需显示，并在玩家选择对话选项时消失：

[PRE6]

第二个方法`UpdateContent()`遵循我们在[*第7章*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106)中首次介绍的模式，即*Unity API – Making Choices and Story Progression*，其中使用`Prefab`动态创建所需的`Button`游戏对象：

[PRE7]

在本节中，我们学习了如何在ink中创建任务模板。使用节点和每个步骤的单独线迹，部分被分为不同的部分。接下来，我们看了`progress` ink节点。之后，我们看了Unity和`ChoosePathString()`方法。虽然在使用更高级技术的较大项目中可能存在潜在危险，但在ink任务模板中使用变量有助于保持它们的值。最后，在本节的最后，Unity中的`ChoosePathString()`方法与ink中的`progress`节点配对。通过使用此节点，Unity代码可以*推进*任务，ink更新其内部变量。

在下一节中，我们将继续在本节中查看的模式，通过扩展ink中的部分任务模板并创建C#中的`Quest`和`Dialogue`类。这将允许我们同时跟踪多个任务。

# 跨多个任务跟踪进度

在上一节中，我们为任务创建了一个ink模板，然后进入Unity创建用户界面，使用`ChoosePathString()`方法推进任务。这迫使ink中的流程移动到特定位置。在本节中，我们超越了单个任务，并开始同时跟踪多个任务。为此，ink模板需要额外的变量。为此，我们需要C#中的`Quest`和`Dialogue`类。我们还将停止使用单个ink文件，并开始使用多个文件。对于每个任务，我们将创建一个单独的文件，并使用`Quest`类在Unity中跟踪每个任务的进度，`Dialogue`类则负责在任务的每个步骤中为玩家创建选择选项。

首先，我们将使用Unity中稍后要访问的新变量更新墨迹模板。然后，我们将在Unity中创建`Quest`和`Dialogue`类。之后，我们将访问Unity中的多个ink文件，以展示包含多个任务的界面。最后，我们将允许用户在任务之间切换，并独立推进每个任务。

提示

本节完成的项目的示例可以在 GitHub 的 [*第 11 章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159) *示例* 文件夹中找到，名称为 *Chapter11-MultipleQuests*。只会展示与该主题章节中探讨的概念相关的代码部分。

## 基于 ink 任务模板构建

正如我们在 [*第 8 章*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123) 中看到的，*Story API – Accessing ink Variables and Functions*，我们可以使用 Unity 中的 `variablesState` 属性访问使用 `VAR` 关键字创建的 ink 变量。这允许我们根据变量的名称检索变量的值。考虑到这一点，现有的 ink 模板可以扩展以包括每个任务的新的变量 – 它的 `name`。

通过理解编译后的墨迹文件将在 Unity 中操作，我们可以预测我们在任务中可能需要的某些需求。例如，一个任务通常有一个*名称*。然后我们可以在 Ink 中定义这个变量，并与其现有的值一起：

[PRE8]

一旦我们知道 ink 中的 `name` 变量存在，我们就可以在 Unity 中读取它。然而，与之前章节中展示的不同，我们还需要观察 `end` ink 变量：

[PRE9]

这些小的变化可能看起来并不重要，但通过建立一个模式，其中某些变量存在（`name` 和 `end`），并且所有包含任务的文件也将有一个名为 `progress` 的节点（如前一小节中定义的），如果这些部分保持不变，我们就可以编写任何我们想要的任务。

一旦这些变量已经准备好，我们就可以开始创建 `Quest` 和 `Dialogue` 类，这些类将持有我们在 ink 中定义的值并在 Unity 中读取它们。

## 在 Unity 中创建 Quest 和 Dialogue 类

在前一小节中，我们将对话选项的简单展示与推进单个任务的值和方法结合起来。在本节中，我们将将该功能拆分为 Unity 中的两个新类：`Quest` 和 `Dialogue`。

大部分的 `Quest` 类在前一小节中已经展示。然而，它的目的是持有 `Story` 对象，并公开一个名为 `Progress()` 的方法，该方法内部调用 `ChoosePathString()` 方法：

[PRE10]

`Quest` 类很小，因为它被其他类使用。它的唯一目的是包含任务（ink 故事）并提供一种推进任务的方式（通过 `Progress()` 方法）。

新的类 `Dialogue` 执行创建所需的 `Button` 游戏对象的大部分工作，并记住最后一条对话内容，作为对玩家的提醒。它的 `UpdateContent()` 方法看起来像在 [*第 7 章*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106) 中首次展示的示例代码，*Unity API – Making Choices and Story Progression*，除了使用新的 `Quest` 类：

[PRE11]

在第一节的更新墨迹模板和本节中引入 `Quest` 和 `Dialogue` 类的基础上，还需要两个部分：

+   任务需要基于编译后的 JSON 文件

+   玩家需要能够切换他们正在进行的任务

在下一节中，我们将从学习如何读取文件和为每个找到的文件创建一个新的`Quest`类开始。

## 组织多个任务文件

在本书的前例中，每个项目使用了一个ink文件。本节将打破这种模式。为了跟踪多个任务，我们将为每个任务定义一个单独的文件，然后读取编译后的JSON文件。我们在上一节中查看的`Quest`类将包含内容并暴露每个文件中的某些值。`Dialogue`类将根据`Quest`类的值创建玩家将看到的选项。然而，首先我们需要读取文件。

本书遵循Unity文件夹的推荐命名约定，并将所有Ink文件放置在一个名为`Ink`的文件夹中。使用**项目设置**窗口中的**自动编译所有Ink**选项，每个创建的ink文件也将包含一个JSON文件：

![图11.1 – Ink文件夹中的编译JSON文件

](img/Figure_11.1_B17597.jpg)

图11.1 – Ink文件夹中的编译JSON文件

由于Unity可以在许多不同的操作系统上运行，它暴露了`Assets`文件夹（如`Application.dataPath`所示。这是数据的*路径*，作为当前运行应用程序的一部分。基于此值，可以找到任何额外的文件夹，并访问它们的文件：

[PRE12]

通过使用`Application.dataPath`属性，每个编译的ink文件（JSON文件）都可以被读取，并基于`Quest`类创建一个新的对象。这不仅允许每个任务通过它们的任务进度独立运行，而且还暴露了`Dialogue`类可以使用以向玩家展示不同选项的值。

在下一节和最后一节中，我们将编写一些代码，允许玩家在哪个任务对他们来说是活动的之间切换，并看到`Quest`和`Dialogue`类的实际应用。

## 切换任务

在Unity中，`Toggle`游戏对象允许用户在多个项目中选择一个。对于本节中该项目的使用，必须创建一个`Toggle`预制件。就像`Button`游戏对象的使用一样，这些是按需创建的。由于每个`Toggle`游戏对象基于使用`Quest`类的对象，这意味着首先运行了上一节中显示的`GetFiles()`方法（*组织多个任务文件*），然后使用生成的任务来创建`Toggle`游戏对象：

[PRE13]

`CreateQuestToggles()`方法引用了一个名为`ToggleScript`的组件。这是一个`Script`组件，它是每个`Toggle`预制件的一部分。每次创建时，它的值都会被设置：

[PRE14]

这个过程，从`GetFiles()`方法开始，首先基于`Quest`类创建对象。接下来，创建`Toggle`预制体，并将值传递给其`Script`组件。内部，`Toggle`预制体基于`Dialogue`类创建了一个额外的`Script`组件：

[PRE15]

这种基于`Quest`类创建对象的多步骤过程，然后引导到`Dialogue`类的原因是允许每个`Toggle`预制体控制向玩家显示的内容：

![图11.2 – 显示给玩家的探索选择和选项

](img/Figure_11.2_B17597.jpg)

图11.2 – 显示给玩家的探索选择和选项

当点击一个`Toggle`预制体时，根据`Dialogue`类，其对象会启用，向玩家显示当前文本和选项。这些选项反过来又基于`Quest`类的值，这些值传递给了`Dialogue`类。

代码的综合效果是创建独立的探索。根据每个由玩家选择的`Toggle`预制体确定的哪个是活动的，玩家将看到不同的对话选项，并在每个步骤结束时独立于其他探索展示出推进每个探索的能力。这结合了我们第一部分创建的ink模板和本节展示的多个探索方法，使用多个文件并增加了跨独立探索推进的能力。

在下一节中，我们将探讨如何通过在探索之间传递信息来奖励玩家的进度。这将基于本节创建的项目和第一部分的概念。

# 显示和奖励玩家进度

在编程中，有两种方法可以从一个系统访问另一个系统的值：**轮询**和**基于事件**。要么检查一个值是否已更改（*轮询*），要么一个系统等待来自另一个系统的消息（*事件*）来指示值已更改。由于第二个系统必须等待事件发生，这通常被称为**观察者模式**，因为第二个系统正在*观察*事件。

在第一部分，我们看到了一个投票动作的例子。每当探索的步骤结束时，Unity代码会检查（*轮询*）墨水值，以确定是否应该显示一个`Button`游戏对象并允许玩家推进探索。在第二部分，我们更接近基于事件的方法，其中在`Quest`类中使用`ObserveVariable()`方法。在第二个项目中，每当`end`墨水变量改变时，它会更新Unity中`Quest`类的`End`属性。由于这个值（`End`属性）被用作确定探索是否可以推进的一部分，这使得第二个项目比第一个项目更动态。

为了奖励玩家完成一个任务或作为另一个任务的一部分实现某些结果，需要在它们之间传递信息。由于墨迹运行时已经通过其名为 `ObserveVariable()` 和 `ObserveVariables()` 的命名方法支持基于事件的访问方式，这使得这个过程稍微容易一些。然而，正如我们在上一节中介绍的，使用 `Quest` 类意味着每个墨迹故事现在都是相互独立的。

在本节中，我们将首先创建一种方式，让每个 `Quest` 类在玩家进行任务时共享变化。我们将以学习如何向玩家展示他们在完成不同任务时获得的信息结束。

提醒

本节完成的项目的示例可以在 GitHub 的 [*第11章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159) *示例文件夹下找到，名称为 *Chapter11-TrackingQuests*。只会展示与该主题各部分中检查的概念相关的代码部分。

## 跟踪任务值

`Story` 类方法 `ObserveVariables()` 可以根据其名称跟踪不同的变量。然而，现有的墨迹模板包含了它用于跟踪进度的变量。这意味着跟踪任务值的第一个步骤是创建一个变量列表，排除作为扩展 `Quest` 类一部分的跟踪：

[PRE16]

接下来，需要跟踪 `variablesState` 属性中包含的所有变量，除了用于跟踪任务进度的创建列表中的那些变量。这意味着对于每个变量，它可以被添加到一个单独的列表中，以便传递给名为 `ObserveVariables()` 的 `Story` 方法。这可以是 `ObserveVariables()` 方法的部分，也可以是 `Quest` 方法的部分，以便与 `Story` 类上的对应方法相匹配：

[PRE17]

添加到 `Quest` 类的新 `ObserveVariables()` 方法接受一个单一参数，`Story.VariableObserver`。内部，`Story` 类定义了一个名为 `delegate` 的方法，称为 `VariableObserver`。使用相同类型的新方法允许其他方法通过 `Quest` 方法传递到同名的 `Story` 方法。换句话说，新方法与现有方法的工作方式相同，但它将排除特定的一组变量名称。

在观察变量时，还需要有一种方法，在其中一个变量的值发生变化时，更新所有任务中变量的值。使用现有的 `variablesState` 属性，可以向 `Quest` 类添加一个名为 `UpdateVariable()` 的新方法：

[PRE18]

在`UpdateVariable()`方法中包含两个重要的检查。第一个使用`GlobalVariableExistsWithName()`方法。此方法检查变量是否存在。如果没有这个检查，如果一个任务添加了一个变量而另一个没有，整个项目可能会崩溃。第二个检查验证要更新的变量是否已经具有相同的值。如果没有这个第二个检查，更新变量将触发其他任何任务中的变量更改，这将触发另一个更新。这最终会导致崩溃，因为任务将尝试在无限循环中相互更新。

在两个新方法`ObserveVariables()`和`UpdateVariable()`之间，还需要一个额外的部分：这两个方法必须结合使用。基于第二部分的工程，*跨多个任务跟踪进度*，`InkStoryScript`代码是添加这个组合的最佳位置。这样做的原因是因为这将允许每个任务作为现有循环的一部分进行配置：

[PRE19]

这段新代码引用了一个额外的函数，`UpdateAllQuests()`。当传入一个变量的名称及其值时，这个新函数会遍历现有的任务，并通过为每个任务调用`UpdateVariable()`来更新它们的值：

[PRE20]

在本节中，我们定义了多个新方法。我们向`Quest`类添加了两个名为`ObserveVariables()`和`UpdateVariable()`的方法。这些方法使用事件方法来检测更改。ink将在某个任务中的变量更改时向Unity发出信号。我们还通过使用名为`UpdateAllQuests()`的新方法在`InkStoryScript`中添加了代码，这个方法将更新其他任务中的相同变量。

在下一节中，我们将完成这个项目。检测更改并更新其他任务有助于在发生更改时保持所有任务更新。接下来，我们需要在发生更改时向玩家展示数据。

## 展示玩家进度

在上一节中，我们创建了必要的代码来保持跨任务使用的所有变量更新。为了向玩家展示这些数据，我们必须添加一个新的游戏对象名为`StatisticsText`。接下来，我们需要在C#中使用一个特殊的关键字：`static`。

在C#中，使用`static`关键字的方法存在于类的任何实例之外。这意味着属性可以在项目的任何地方被访问或方法可以被调用。然而，这也带来一个主要的限制：任何`static`方法只能访问`static`属性。为了允许另一个类（`Dialogue`）能够调用`InkStoryScript`（其中包含所有任务）中的`static`方法，现有的`quests`和新`StatisticsText`变量都必须使用`static`关键字：

[PRE21]

使用`quests`和`StatisticsText`属性，它们可以通过一个名为`ShowStatistics()`的新方法被访问：

[PRE22]

新的`ShowStatistics()`方法使用`Dictionary<string, object>`。这结合了变量的名称（`string`）和其值（`object`）。然而，C#中的`Dictionary`存在一个障碍：它只能包含唯一的键。在`ShowStatistics()`方法中，使用`ContainsKey()`方法防止了这个问题。

为了设置一个可以被其他类调用的方法，新的`ShowStatistics()`代码必须放置在`Dialogue`类中，作为其`UpdateContent()`方法的一部分，在基于当前选择的创建`Button`游戏对象之后：

[PRE23]

新的代码将始终显示变量的最新值，因为值被更新。由于每个任务都根据基于事件的方法来处理其变量的更新，任何用户动作，如做出选择或选择任务，都将更新项目跟踪的所有值，并不断显示玩家进度。

在本节中，我们通过向玩家展示更新的值来奖励玩家的进度。我们首先添加了上一节的一些代码，以不断更新所有任务中具有相同名称的变量。这保持了所有任务的连接。然后，我们创建了一个`ShowStatistics()`方法来显示这些值，并更新了一个`Text`游戏对象，以显示它们的名称和值。

# 摘要

我们通过创建墨迹模板来开始本章。通过在墨迹中定义变量和一个`progress`节点，我们可以像更大节点中的单个线迹一样，在任务的各个部分之间移动。接下来，我们研究了`ChoosePathString()`方法，它可以强制将故事移动到新的部分。

在第二部分，我们摆脱了单个文件，并开发了一个`Quest`类。基于`Quest`类的每个对象都包含一个基于不同文件的ink`Story`对象和一个名为`Progress()`的方法，该方法内部调用`ChoosePathString()`方法。作为本部分的一部分，我们学习了`Quest`和`Dialogue`类如何帮助将功能组织到不同的类中。

最后，我们显示了变量的名称和值。首先，我们添加了新的方法，使用基于事件的方法来检测任何任务中的变量变化。这触发了其他任务中具有相同名称的其他变量的值更新。然后，我们添加了`ShowStatistics()`方法来显示这些更新的值。

在下一章，[*第12章*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174)，*使用ink进行程序化叙事*，我们将回顾程序化组织不同故事部分和内容的基本知识。在查看两种方法时，即直接在ink中编码值或动态将数据加载到ink中，我们将研究在特定情况下哪种方法可能更好。

# 问答

1.  什么是任务？

1.  用于根据本章中显示的墨迹模板推进任务的节点的名称是什么？

1.  `ChoosePathString()`方法是如何工作的？

1.  Unity记录应用程序数据路径的全局属性叫什么名字？

1.  轮询和基于事件的两种方法有什么区别？
