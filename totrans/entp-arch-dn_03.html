<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor069"/>3</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor070"/>Reaching Business Alignment</h1>
<p>Following the first chapter explaining the problems information systems globally face and the second one on the general theory of industrialization, it’s time for some actual battle-proved methods! Though we will not get our hands on the code or deploy software before <em class="italic">Part 2</em> of the book, this third chapter is much more applied and will show the principle of what is called business/IT alignment. The idea behind this principle is that the software system should reflect the structure of the business domain it aims to automate as much as possible. In a way, this is applying <strong class="bold">Conway’s law</strong> (which will be explained) backward, using it to obtain the desired result. In practice, it is important to know the map to rule on the ground, so we will be using an information system mapping <a id="_idIndexMarker097"/>technique based on the four-layer diagram pushed forward by <strong class="bold">CIGREF</strong> (short for <strong class="bold">Club Informatique des Grandes Entreprises Françaises</strong>), among other organizations.</p>
<p>In this chapter, we’ll cover these topics:</p>
<ul>
<li>Software for business and the principle of alignment</li>
<li>Conway’s law applied to application and systems</li>
<li>Introducing the CIGREF diagram</li>
<li>Using the four-layer diagram</li>
<li>Patterns and antipatterns of alignment</li>
</ul>
<p>After describing the method and drawing similarities with the <strong class="bold">TOGAF</strong> (short for <strong class="bold">The Open Group Architecture Framework</strong>) framework<a id="_idIndexMarker098"/> or other methods, we will apply it to a sample IT system so that you really can benefit from it as soon as you have finished this chapter. Finally, we will see best practices, but also anti-patterns in business alignment. Just like any other method, business/IT alignment using the four-layer approach has its advantages and its limits. It is especially important to know them to apply the method as efficiently as possible and also to know how to use it to determine when and where there are alignment problems in the information system under study<a id="_idTextAnchor071"/>.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor072"/>Technical requirements</h1>
<p>As said in the introduction, this chapter will be more practical than the two previous, theoretical, ones. This means a reading prerequisite—since we will talk about methods of analyzing information systems, you should have previous analytical contact with them at least. Sure, everyone uses them nowadays, but you will need a bit more than just experience using them, in particular some knowledge about the different parts they are made of. Nothing fancy here, but you need to understand the difference between software and hardware and that information systems are generally there to automate business processes, which are sets of human and computer-based tasks organized toward reaching a goal. You will also need to be able to recognize the different parts of such a system. If we call them systems instead of simply software applications, this is because they are more complex and made of several modules. You need to understand this and be able to tell which parts the system is made of.</p>
<p>You will also need to be able to classify these parts of the system. Are they classified by function or by some more concrete, IT-related criteria, such as their position on the on-premises servers versus in the cloud? Are they autonomous or do they communicate a lot with other functions, and if so, with which interfaces and protocols? This is certainly just general knowledge or common sense for most of us, but this is something you will need to be able to read this chapter nonetheless. This will help you to point out critical questions. For example, when talking about interactions between parts of the systems, are we talking about business dependencies or concrete, IT-related streams of data? To give you a better understanding of the difference, let’s go over some illustrations. An example of business dependency is when the ordering system depends on the customer’s list. Indeed, we can record a company with our orders, but it does not make much sense to record an order without knowing the customer who buys the products listed in it. On the other hand, an example of IT-related data streams is when the ordering system accesses the customer’s database to propose an existing record<a id="_idTextAnchor073"/>.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor074"/>Software for business and the principle of alignment</h1>
<p>At this point of the book, it should already be quite clear, but it does not harm us to recall that we are only talking about professional information systems. In short, we put ourselves in a case where software really means business: applications that are mission-critical for companies, information systems that help production for a commercial company or a non-profit organization, etc. All recommendations that follow would not make any sense on small systems and would be way too complicated if applied to a simple piece of software application.</p>
<p>This being said, the hypothesis is that, since there is a business, there is good knowledge of it; we know who the participants in the business are, what the stakes and objectives of the business are, which strategy is being conducted (even if it is not 100% clearly defined, as happens in a lot of companies), etc. This last one is of utmost importance; there is no need to design an information system if the strategic direction has not been defined.</p>
<p class="callout-heading">Important note</p>
<p class="callout">It should be emphasized that the definition (even if not completely precise) of the business strategy is an absolute prerequisite to an analysis of enterprise architecture and the mapping of the information system. As an analyst with many years of experience with information systems, I always refuse a project if I realize in the first meetings that there is no company-level strategy, and I recommend anyone to do the same. If you are reading this chapter thinking about how you are going to define an information system and realize there is no business-defined strategy, you are better off stopping reading right now and coming back when this essential information becomes clearer. Trust me on this one—if you realize the upcoming steps before the vision of the objectives of the information systems is (at least globally) clear, you are going to waste a lot of your time and do more harm than good.</p>
<p>Why is all this so important? Because you are going to use the definition of your target business to design the information system to be aligned with it. Technology should always be at the service of the users, so knowing the business beforehand is what is going to drive the design of the information system (again, there is no need for a perfectly detailed strategy, but at least a vision or a direction). This is what is called business/IT alignment or, in the context of this book, simply alignment. We will see that this is the only stable method you need to obtain a sound and future-proof information system, free from the problems that have been described in the first chapter. But before we dive more into the method of achieving business/IT alignment, let’s just take a look at other methods that are not business-related but technically driven and learn where they apply and what their limits are when designing complex information systems<a id="_idTextAnchor075"/>.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor076"/>The jungle of technical recommendations</h2>
<p>If you are a <a id="_idIndexMarker099"/>true software professional and worry about the quality of your deliverables, you most certainly have read a lot about technical methods that help in addressing the issue and improving your software skills. You have heard <a id="_idIndexMarker100"/>about <strong class="bold">V-cycle</strong>; <strong class="bold">Agile methods</strong> to <a id="_idIndexMarker101"/>organize software teams; <strong class="bold">extreme programming</strong>; <strong class="bold">test-driven development</strong>; <strong class="bold">behavior-driven development</strong> for <a id="_idIndexMarker102"/>practices; programming <a id="_idIndexMarker103"/>patterns to improve code<a id="_idIndexMarker104"/> structure; development-specific <strong class="bold">key performance indicators</strong> to follow <a id="_idIndexMarker105"/>the quality of code; and so many more that a complete chapter would not be enough to describe them all.</p>
<p>Though there is interest and things to learn from most of them, their sheer number shows the limits of such methods: they are only true in given contexts (otherwise, due to the number, some would oppose others) and, sadly, most of the people writing about them often forget to define this perimeter because they are interested in explaining the technique itself. The more the technique has helped them to lift a given obstacle, the more they will tend to present it as an essential, go-to recommendation. In extreme cases, the person recommending the practice does not realize the small size of the context operated and will consider this practice as universal, encouraging others to use it without limit.</p>
<p>This is of course where the critical thinking of the reader is expected, but at the same time, the reader should logically be someone who knows less about the domain of expertise of the writer, and it may be difficult for him/her to spot the limits of the content. “A little knowledge is a dangerous thing”, and the internet is polluted with people who just learned a new trick and will gladly expose it to the community as the solution to everything. This enthusiasm is understandable, and I have certainly done this in my blogs or general training activities, but that does not mean there is no solution and, again, the way forward is to improve the critical thinking of the<a id="_idTextAnchor077"/> reader.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor078"/>An example with KISS, DRY, and WET</h2>
<p>Let’s take an<a id="_idIndexMarker106"/> example of some practices that you have certainly heard of: <strong class="bold">KISS</strong> (<strong class="bold">keep it simple, stupid</strong>) and <strong class="bold">DRY</strong> (<strong class="bold">don’t repeat yourself</strong>). The <a id="_idIndexMarker107"/>first one states that simplicity should always prevail when creating a software implementation. This is particularly true in Agile methods since additional features or feedback from the users will certainly force the rewriting of the code. The second one implies that code should never be repeated and that similar blocks of code should be put into a unique function called from the different places in the code where the same function is needed.</p>
<p>Before any <a id="_idIndexMarker108"/>further analysis, we should note that there seems to be a similarity, or at least quite a strong link, between the two recommendations. After all, if we reduce the code repetition, we make things simpler (or at least they may appear so, but this is the subject of the following). We may thus question the use of the two approaches, but again, software engineering is not an industry yet, so every craftsmanship has its own tools and uses. Fair enough…</p>
<p>But the real point <a id="_idIndexMarker109"/>of analysis of these two methods is their context of application. As with most technical best practices, they do not blindly apply to everything and their use should be carefully pondered. Sure, it makes sense to unify a simple function to display a warning when you find it many times in the same class, but how about the same situation with two classes in distinct software applications where the warning label slightly differs? If the text is not the same, maybe this is because the warning is on a situation that is not the same, so we should analyze the condition on which they are called. However, as the software modules are not the same, the variables will not necessarily be the same, so it is going to be difficult to analyze the similarity of the situations prompting the warning dialog display. And how about coupling? If we decide to keep only one code, which application module should have it? Or should we make another module that stores the code of the dialog box? And in this case, what about the fact that the life cycle of two applications now influences the versions of this common library, which could certainly become an issue? Sometimes, unifying code can do more harm than good.</p>
<p>This kind of <a id="_idIndexMarker110"/>discussion has brought lots of reflections, and a new good practice has been proposed by the acronym <strong class="bold">WET</strong> (opposite to DRY), standing for <strong class="bold">write everything three times</strong>. Indeed, the hesitations exposed mean that, to find the right decision, it is beneficial to wait and gather some more clues on the actual similarity of the contexts of use, and the creator of the method proposes to write the code three times before thinking about unifying it. This is a sound approach, as it avoids the “black or white” approach of the DRY principle and opens a whole domain of a gray area corresponding to the actual truth: it depends on the context. Writing the code, writing it a second time and observing the similarities, then writing it a third time and analyzing the return on the investment of unification certainly is a sound approach... but does this make it a law that every programmer should obey? Of course, no—again, critical thinking applies, and the three times may not apply to you. Maybe you will need five, maybe you will decide the limit will be time-based and not based on the number of occurrences (wait for one year of maintenance, for example). It is up to you, and I suspect<a id="_idIndexMarker111"/> three times was chosen partly because it made for quite a humorous opposition to the DRY principle.</p>
<p>All this is to say that lots of technical, code-related methods that are used in software development are sometimes presented as hard truth or generally applicable best practices, but, most of the time, they are just principles that apply to a given context, and can (and must) be bent <a id="_idTextAnchor079"/>to fit others.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor080"/>The particular case of internal toolboxes/frameworks</h2>
<p>Before we <a id="_idIndexMarker112"/>switch to solutions on the issue just explained (and do not worry, there are some), a most-observed example of how best practices applied without a thorough context analysis can lead to bad situations is the development of bespoke company frameworks. During the writing of this chapter, I stumbled upon a great article from Aaron Stannard (<a href="https://aaronstannard.com/dry-gone-bad-bespoke-company-framework/">https://aaronstannard.com/dry-gone-bad-bespoke-company-framework/</a>) that happens to perfectly reflect my own analysis on frameworks after 25 years of programming with or without them, creating some and cursing myself to have done so, adoring some others and realizing they brought a huge value to the software I was responsible for, etc.</p>
<p>Aaron Stannard explains in this article how the DRY principle applied too strongly has harsh consequences on teams that develop specialized frameworks to unify coding and, in the end, they obtain results that were the opposite of those that were expected in terms of boilerplate code reduction, scale capacity, and quality of code.</p>
<p>Some frameworks<a id="_idIndexMarker113"/> bring huge value to software applications and information systems, and you will easily locate them:</p>
<ul>
<li>Everyone knows them and is happy to use them</li>
<li>Newcomers consider the framework helpful in making them more productive and quicker</li>
<li>All users can describe in very few sentences what the framework does</li>
<li>The framework has very little dependencies and can be used easily</li>
<li>It is so important that developers will go as far as doing the thing they hate to keep it going: documenting it</li>
</ul>
<p>On the opposite side, there are frameworks in code that hinder the programming process:</p>
<ul>
<li>They have been created by a few experts and the rest of the team does not use them</li>
<li>Newcomers tend to write the equivalent code directly and question the fact that the framework would have helped them be more productive</li>
<li>They sometimes do so many things that none of their features are stable</li>
<li>They bring some other constraints (operating on just one type of database, requiring script modules, elevation of privileges, etc.)</li>
<li>Their functioning is in the mind of the experts (often, a single person, which is dangerous for the company), and training their colleagues on the use of it is somewhat of a challenge.</li>
</ul>
<p>The <a id="_idIndexMarker114"/>difficulty <a id="_idIndexMarker115"/>in knowing where you are between these two ends of the spectrum is linked to the fact that the creators of the framework will, of course, be biased about their “baby”. They would always overestimate the time saved by using it or forget or overestimate the time to maintain it, the time to teach it to others in the team, the risk that the company is taking by putting an important dependency in the hands of one person, and so on. If you have to evaluate the use of a framework, you should put all these factors in a spreadsheet and coldly evaluate the return on investment in the short, middle, and long term.</p>
<p>Finally, the modern programming platform has now brought so many tools that the very existence of frameworks can <a id="_idIndexMarker116"/>be questioned. For example, <strong class="bold">.NET Core framework</strong> version 8.0 has such a large ecosystem and <strong class="bold">Base Class Library</strong> that<a id="_idIndexMarker117"/> all purposes for which frameworks were created ten years ago have simply disappeared:</p>
<ul>
<li>Object/relational mapping is taken charge of <a id="_idIndexMarker118"/>by <strong class="bold">Entity Framework</strong></li>
<li>API request/response with mapping to objects is handled by <strong class="bold">ASP.NET Web API</strong> and<a id="_idIndexMarker119"/> integrated <strong class="bold">JSON</strong>/<strong class="bold">XML</strong> serialization</li>
<li>Monitoring is taken care of by the logging stacks that can be plugged into any third-party listeners</li>
<li>The consistent page description is done<a id="_idIndexMarker120"/> with <strong class="bold">Blazor</strong>, with style handling included</li>
<li>Deployment on mobile applications is realized <a id="_idIndexMarker121"/>through <strong class="bold">Multi-platform App UI</strong> (<strong class="bold">MAUI</strong>), which also unifies with the Windows frontend, and so on</li>
</ul>
<p>So my advice on<a id="_idIndexMarker122"/> this <a id="_idIndexMarker123"/>question of the frameworks is to wait as much as possible before creating a framework and trying to avoid it as much as possible (most of the time, admit it, you want to create the framework not because it is good for your business, but because it is fun to code). If it has to come, it will do so, and this is where emerging code architecture (we will come back to this notion soon if you have not he<a id="_idTextAnchor081"/>ard about it) makes sense.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor082"/>The only stable guide: aligning to your users’ business</h2>
<p>After this long<a id="_idIndexMarker124"/> digression, we come back to our initial consideration of the difficulty of knowing when to apply best practices and so-called “principles” in software. Yet, we desperately need guidance for the architecture of information systems because the stakes are too high and we have seen how bad the impact can be on business if we fail at this. So how do we know? Is there a sound and stable way that always applies? Some actual laws that we will be indeed able to truly rely on when designing something as essential for a company’s future as the structure of an information system? Yes, there is, and it is not a technical rule, but a method for technical decisions: always relate them to the business of the information system. This is the root of business/IT alignment.</p>
<p>In this chapter, I am going to repeat this rule and explain it in many different ways, as it is so important for a correct information system architecture—what drives the design of the information systems is the structure of the business. This is particularly true for the concepts, and creating a successful software backbone for a company always starts with a perfect understanding of the business. What is a customer? What products do we sell? What are the main processes of the company that ought to be computerized? Most of these questions sound trivial, but they are only so because human brains can adapt to the background context.</p>
<p>Let’s take the very first question: what is a customer? This is so obvious for anyone in the company that the question is rarely asked, and it would sound quite ridiculous if any employee questioned it. “Customers are companies we do business with”. All right, but how about individuals? Yes, sometimes we also deal with individuals; this is the difference between B2B and B2C. And what if we question the term “doing business with”? What frequency and volumes are we talking about? Sure, any volume may be taken into account, and a person buying a simple bolt from you may be considered a customer in the exact same way as a company acquiring thousands of them a month. But how about time? Would you consider someone who has bought a product from you twenty years ago still a customer? No, certainly not. How about one year ago? Yes, of course... In this case, where is the limit? Ten years? Five? Decisions, decisions, decisions!</p>
<p>About this<a id="_idIndexMarker125"/> previous example, you may find companies where managers do not agree on the exact definition of a customer between marketing and commerce... So, how would you expect a dumb computer to decide this? The hard truth is that, if you want to replace some tasks with software and data streams, you will have to make everything absolutely crystal clear for it to work. This is where most of the information systems fail—they have not been designed with a perfectly accurate view of the business, leaving some details to the implementation or use of the system by humans. It may work for some time when humans compensate for the missing knowledge in the computer, but sooner or later, there will be trouble. In the best case, the system will never be as efficient as expected. In the worst case, people leaving the company with their compensating knowledge will cause the system to come to a halt.</p>
<p>What does this example show us? First, one should be extremely clear with the business definitions when it comes to making a software information system deal with them. The second is that, very often, these concepts are business rules, which means they are not perfectly stable but depend on how the business is run. The definition of the customer may change in time if your boss decides one day that the list of customers should not present the ones that have not bought anything from you in the last three years, where this duration previously was five years. If this situation is bound to happen from time to time, it is of course of utmost importance that its impact on the information system is limited. Putting this logic in a unified line of code or, even better, in a parameter is a great move in this case.</p>
<p>On the contrary, storing the list of customers and their definitions in a single table will cause great coupling because the definition (name, address, contacts, etc.) will not change when the “customer status” does. If removing a company from the customers’ list means you have to delete the entry from your databases, there may be an impact on other functions that still need this data (for example, guarantee management, accountants, etc.). We will come back to this example in <em class="italic">Chapter 9</em> with some more details on how to model it correctly, but for now, please remember that business thinking must always guide how your software concepts will work. Alignment is not something that <a id="_idIndexMarker126"/>arises from nothing or goes both ways—it is driven by functions, and the software should blindly follow the business domain ontology.</p>
<p>In fact—and this will be the last bit in this section—sticking to the business domain reality should even go one step further and in particular stick with it <em class="italic">in time</em>. This means that your model should always accommodate time since the business always varies. Change is the only constant in life; businesses cannot escape this and rather are highly dependent on it. With ever-changing business rules, more and more complex organizations, and higher functional sophistication, the information system must be designed from the beginning to accommodate change. Management of time is so important that the next chapter will b<a id="_idTextAnchor083"/>e completely dedicated to it.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor084"/>Digression on the digital transformation of companies</h2>
<p>While we are talking<a id="_idIndexMarker127"/> about software representation of the business domains, we might as well expand on this and observe how software has “eaten the world” (<em class="italic">Why Software Is Eating The World</em>, Marc Andreessen, 2011) and why this active digital transformation relates to the business alignment concepts talked about previously. A schema is worth a thousand words, and <em class="italic">Figures 3.1</em> and <em class="italic">3.2</em> should explain the main difference digital transformation makes to how we operate.</p>
<p>Before the digital transformation, the human operator was at the center of the business operations and operated both in the real world and on the computerized vision of the business (or parts of it, as we saw earlier):</p>
<div><div><img alt="Figure 3.1 – Schema for when the human operator was at the center of business operations" src="img/B21293_03_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Schema for when the human operator was at the center of business operations</p>
<p>The<a id="_idIndexMarker128"/> digital transformation brings a whole new approach where software becomes the main tool of operation for the human and operates in the real world on behalf of the human user. The hardware and software systems receive orders and signals from the human interfaces and the sensors, translate them, and send them back to the human operator (through graphical user interfaces) as well as on the concrete reality (through mechanical operators or other ways):</p>
<div><div><img alt="Figure 3.2 – Schema for digital transformation" src="img/B21293_03_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Schema for digital transformation</p>
<p>This has a <a id="_idIndexMarker129"/>particular consequence that IT is now at the center of the picture, interacting both with the real world and with humans. Depending on your point of view, computers helped humans to not get their hands dirty with direct interactions, or they took us away from direct interactions with the world and all the risks associated with potential bias and the wrong representation of reality. Social networks are the paramount manifestation of these negative impacts and, as software engineers, you should always be aware of this kind of risk and design systems accordingly, as their impact on the real world is now well established and people working in the field should keep a moral, responsible approach.</p>
<p>I hope this made the digital transformation and the interaction between humans and computers clearer. Let’s now concentrate on how humans can impact the way software is organized and talk about <a id="_idTextAnchor085"/>something called Conway’s law.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor086"/>Conway’s law applied to application and systems</h1>
<p>We talked <a id="_idIndexMarker130"/>a lot about the limits of so-called “laws of software” in the first section of this chapter, so you may wonder why I will now spend several paragraphs talking about something that, at first sight, may seem similar. Nothing could be more different... Conway’s law is a true, stable guide for information systems design, as it does not state a recommendation but draws a theory from multiple observations and lets one decide its own conclusion on the subject.</p>
<p>Melvin Conway<a id="_idIndexMarker131"/> stated in 1967 that “any organization that designs a system will produce a design whose structure is a copy of the organization’s communication structure”. In our case study, which is information systems, this means that the architecture of the resulting system will reflect the structural organization of the team defining it, and this would imply the following:</p>
<ul>
<li>A team with a strong separation between frontend and backend will produce a system where these two software functions are indeed independent</li>
<li>A team where people are grouped depending on their business domain knowledge will produce an information system with clear-cut business-aligned services</li>
<li>A team of only one person would give birth to a very cohesive, monolith-like system</li>
<li>A team with no or low communication between its parts would create a system where modules do not correctly interoperate with each other</li>
</ul>
<p>This last example may look like an extreme, but, sadly, this is the case with most information systems because the teams are generally composed with a single piece of software in mind, resulting in many applications composing the system without the interoperation having been thought out in advance. Thus, links are established in an upon-needed, point-to-point manner, resulting in brittle links and inefficient systems.</p>
<p>Since this initial empirical observation from Conway, the eponym law has been verified many times and, though it cannot be demonstrated like a mathematical law can, it is nowadays considered something largely reliable. It is considered such a strong law that system designers <a id="_idIndexMarker132"/>have started using the law to structure teams in ways that would bring a desired shape to the resulting system. In this approach, the law is not only seen as a consequence but as a helping tool to shape the system as needed. What I am talking about comes from my own experience but also has been formalized under the name of the <strong class="bold">inverse Conway maneuver</strong> since <a id="_idIndexMarker133"/>many other software engineers have had the same approach. Martin Fowler, for example, puts this law forward (<a href="https://martinfowler.com/bliki/ConwaysLaw.html">https://martinfowler.com/bliki/ConwaysLaw.html</a>) and even draws a relationship with <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>). This<a id="_idIndexMarker134"/> will be further explained in an upcoming chapter specifically aimed at explaining the importance of semantics—related to the concept of ubiquitous language in DDD—in designing the parts of an information system.</p>
<p>Using the inverse Conway maneuver, one can influence the resulting design of a system by working on the communication and structure of the teams working on designing it. This is a great way to achieve the much-desired business alignment that we have talked about since the beginning of the chapter. By defining the teams alongside the business domains and giving them business-related concepts to talk about with each other, the resulting system will be made of modules with clear-cut functional responsibilities and well-structured interoperations between modules, favoring the long-time evolution of the resulting system.</p>
<p>Influencing the alignment of a system is great, but, most of the time, one will be exposed to an existing one, with the only possibility of understanding its state. This is where we need a way to analyze the existing alignment, and this is where a dedicat<a id="_idTextAnchor087"/>ed method of diagramming is useful.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor088"/>Introducing the CIGREF diagram</h1>
<p>As we have seen, business <a id="_idIndexMarker135"/>alignment has much to see with vocabulary and the right expression of concepts that are related to the functional domains. For those of us who are more comfortable with schemas, there exists a more graphical way to visualize this alignment, and it is called <a id="_idIndexMarker136"/>the <strong class="bold">four-layer diagram</strong>.</p>
<p>In France (where I am from), it has been popularized by the Club Informatique des Grandes Entreprises Françaises (a large French company club for software architecture), but this is a very <a id="_idIndexMarker137"/>widespread way of thinking and no ownership has been <a id="_idIndexMarker138"/>claimed on this idea, at least that I know of. The concept is quite simple and is about separating the different levels of an information system, each using the levels I will present to work. At the top of the diagram, one will find the business processes that the system serves, and one level down are the business functions that are needed for this. These two layers are purely functional and are not even related to software; some tasks and functions could be realized by humans without any impact. The two technical layers at the bottom are respectively software and hardware, the former using the latter. This way of specifying a system (or rather its outermost structure) can be schematized as follows:</p>
<div><div><img alt="Figure 3.﻿3 – Four-layer diagram" src="img/B21293_03_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Four-layer diagram</p>
<p>Let’s dive a bit deeper<a id="_idIndexMarker139"/> into each of the levels in the following sections, and in particular show how each level’s content is represented in detail, as this schema is only symbolic and does not contain the actual contents of each layer.</p>
<p class="callout-heading">Important note</p>
<p class="callout">In the rest of the chapter (and in subsequent parts of the book), we will refer often to these four layers or levels by their number, starting from the top (<strong class="bold">Level 1</strong>, <strong class="bold">Level 2</strong>, <strong class="bold">Level 3</strong>, and <strong class="bold">Level 4</strong>). The n<a id="_idTextAnchor089"/>ext section details <strong class="bold">Level 1</strong>, and so on…</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor090"/>Process level</h2>
<p>A business <a id="_idIndexMarker140"/>process is a series of tasks organized toward reaching a defined objective. Since we talk about IT, at least some of them will of course be automated, but there can be man-activated tasks as well. Processes are used to structure a business or <a id="_idIndexMarker141"/>any organization’s activities, and <strong class="bold">business process modeling</strong> (this is the accepted name) is about representing these to document, better comprehend, and improve the efficiency of the entity.</p>
<p>There is a standard <a id="_idIndexMarker142"/>for business process representation, namely <strong class="bold">BPMN</strong>, which stands for <strong class="bold">Business Process Modeling and Notation</strong>. This standard currently is in version 2.0. You certainly have already seen this kind of diagram, which reads itself:</p>
<div><div><img alt="Figure 3.4 – BPMN example" src="img/B21293_03_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – BPMN example</p>
<p>In this very short and <a id="_idIndexMarker143"/>undetailed example of a new process in a company, you will find the most used components of the<a id="_idIndexMarker144"/> BPMN standard:</p>
<ul>
<li>Tasks are boxes, generally filled with text starting with a verb describing the activity represented. Icons inside the task may specify whether it is automated, has user inputs, is entirely manual, etc.</li>
<li>Arrows between tasks indicate the flow of information in the process and, as a consequence, the order in which the tasks are processed.</li>
<li>Diamond-shaped boxes intervene in this stream of information to incorporate complexities such as choices or parallel activities.</li>
<li>Events are <a id="_idIndexMarker145"/>represented by circles. A process will always have a start and one or more ends. It can also have intermediate events and all those can reflect types of events, such as time-based, message-based, etc.</li>
</ul>
<p class="callout-heading">Tip</p>
<p class="callout">For more<a id="_idIndexMarker146"/> information about BPMN, I strongly recommend studying the BPMN poster available at <a href="http://www.bpmb.de/index.php/BPMNPoster">http://www.bpmb.de/index.php/BPMNPoster</a>.</p>
<p>Though Layer 1 of<a id="_idIndexMarker147"/> the CIGREF diagram is mostly based on BPMN diagrams, as they are the standard for business processes representation and the main subject of this layer, one can also find in this layer some additional information that goes together. For example, business domain-related rules can be specified<a id="_idIndexMarker148"/> as <strong class="bold">DMN</strong> (<strong class="bold">Decision Modeling Notation</strong>) and are added to this first level, as they have impacts on the business processes themselves. DMN is, by the way, a “sub-norm” included in the BPMN standard.</p>
<p>Depending on what one tries to obtain, the layer one map may be very coarse and with few details. This is an example from an animal genetics company I advised, which already had a complete ISO-9001 diagramming of its processes and simply needed to know which parts of the information system related to which business process (intentionally blurred for confidentiality reasons):</p>
<div><div><img alt="Figure 3.5 – Example of a processes map" src="img/B21293_03_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Example of a processes map</p>
<p>Since this customer of mine did not have any problem with the processes themselves, their representation<a id="_idIndexMarker149"/> remained very light during the whole alignment project. The only subtlety in this was that operational processes had been separated from support processes and piloting ones.</p>
<p>Contrarily, the following diagram is only one of many processes in layer 1 of a map I created for another customer, this time an organization where IT problems mainly came from a lack of definition in the processes (and, of course, when objectives are not clear, it is hard to have an efficient IT system). In the following diagram, the readability of the text is not intended, as I only want you to look at the overall process diagram:</p>
<div><div><img alt="Figure 3.6 – Detailed process" src="img/B21293_03_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Detailed process</p>
<p>Layer 1 is of <a id="_idIndexMarker150"/>course the most important level of the map of your information system because nothing depends on it. All other levels depend on the one above, but the processes layer has to be designed from scratch, purely based on the business domain knowledge. And, as explained, if processes are not clear or badly designed, this will of course affect the software and, in time, the efficiency of the whole information.</p>
<p>It is hard to <a id="_idIndexMarker151"/>stress enough how important this layer is. This does not mean that it has to be drawn with many details; these are only necessary once someone spots a problem in the process and needs to know it in depth to improve or correct it. But the first layer has got to be correct an<a id="_idTextAnchor091"/>d cover the whole perimeter of the organization.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor092"/>Functional level</h2>
<p>The <a id="_idIndexMarker152"/>second level of the CIGREF map indicates what functions can be used by the tasks of the processes above to realize them. This is still a functional layer, but this time, the organization is different as the atoms of this layer are about who can do what.</p>
<p>There are indeed functions that do not vary with processes. Business processes must be able to change according to strategy, but some things remain stable. In our example shown in <em class="italic">Figure 3</em><em class="italic">.3</em>, to welcome a newcomer to a company, one of the tasks was to take his or her picture. This may be useful for other things in other processes, but the very act of taking a picture is a function of the organization, may be realized by a given person, and necessitates dedicated materials such as a camera. It is thus a function and has to be registered in this second layer. Many processes may point to it, but the function will remain in one place on the second-level map, together with its stable attributes.</p>
<p>Some of the most important of these attributes are linked to the organization of the functions inside the organization. Things may vary, and there is no fixed standard for this, but there is at least a good metaphor that has been used for decades and bears good results, which consists of creating a parallelism between information systems and cities’ organizations (in France, this approach is called “urbanization”). This metaphor leads to decomposing the second layer of the CIGERF map in three levels of depth:</p>
<ol>
<li><strong class="bold">Zones/areas</strong> are the<a id="_idIndexMarker153"/> larger groups in the layer. They correspond to how the whole system (or city, in our metaphor) is organized. In a city, one will find commercial, industrial, and living areas that are generally clearly separated; one should find the same in the functional layer.</li>
<li><strong class="bold">Quarters/neighborhoods</strong> are a<a id="_idIndexMarker154"/> finer subdivision corresponding to the local organization of a system, with people, businesses, or, in our case, IT functions potentially talking to each other.</li>
<li><strong class="bold">Blocks/islands</strong> are <a id="_idIndexMarker155"/>the fine divisions inside which people know each other and interact often. In the corresponding IT definition, these contain functions that are closely related because they use the same tool or because the same team operates them.</li>
</ol>
<p>I am often <a id="_idIndexMarker156"/>asked what kind of decomposition should be used, at least for the<a id="_idIndexMarker157"/> top-most level. This is a difficult one, as the <strong class="bold">business capability map</strong> (<strong class="bold">BCM</strong>) (as this second layer of the CIGREF map is often called) is most of the time simply non-existent in companies. Lots of them have a clear view of their processes due to ISO 9001 certification and the relative standardization of the approach. Companies can also track down their software layer, at least for the biggest blocks for which they are billed. But in the middle, this BCM is quite often forgotten, and we will see a bit further that this is the source of loss of misalignments in the systems.</p>
<p>The fact that this layer is forgotten is in itself a big part of the problem in many information systems, as leaders may favor the process layer (the objectives) and put less effort into the BCM (how to realize them). Yet, a vision without a plan is just a wish, as the proverb says, and a well-crafted functional organization of the system is a great step forward to success.</p>
<p>In this metaphor with urban development, the business capability map is cut in the same way that <a id="_idIndexMarker158"/>would be associated with the composition of a large city; just like there are industrial, commercial, and living areas in a city, there will be a global organization in an information system, often in the following five areas:</p>
<ol>
<li><strong class="bold">Master data management</strong> is where the most important data of the information<a id="_idIndexMarker159"/> system is managed (customers, products, etc.). This data will be used by many parts and actors of the system. As such, it deserves dedicated governance (a clear definition of who is in charge, with what practices and tools, etc.) and to have its own dedicated zone in the second layer of the map. When governance is not clear on such important data, it often happens that different groups will duplicate them, which is not only costly but can bring complicated problems when exchanges need to be realized.</li>
<li><strong class="bold">Shared tools</strong> are <a id="_idIndexMarker160"/>not data but still commonly used functions that one will refer to in many other parts of the information system and most processes’ tasks. They are often classified in a dedicated zone, where one will find office automation tools, content management software, identity and authorization management, and so on.</li>
<li><strong class="bold">Externally oriented functions</strong> (sometimes called “collaborative”) are for all functions that <a id="_idIndexMarker161"/>are about interoperation or exchange with functions that are outside the scope of the information system itself. This is typically where one will find an extranet or commercial websites, connections with partners, etc.</li>
<li><strong class="bold">Governance/piloting</strong> is <a id="_idIndexMarker162"/>the zone where functions used to supervise the system itself will be found. Reporting functions will be placed there, as well as key performance indicators, high-management functions, and so on.</li>
<li><strong class="bold">Business-oriented functions</strong> are the last, but not least, area. This is where a company will <a id="_idIndexMarker163"/>organize all the functions corresponding<a id="_idIndexMarker164"/> to its core value and operational domain. If you are a company that builds mechanical parts, you will find there all the functions associated with engineering, production, stocks, selling, maintenance, and installation. If you work in e-business, there will be buying and selling functions, logistics, web operation, security, etc. There will also be some groups of functions that support the core business, such as human resources, legal, and administrative functions, which are general to most companies. When the entity is well organized, it is evident (and proof of good alignment) that the quarters in this zone correspond to the different directions in the organizational chart. Conversely, if it is hard for you to tell whether a given function is under such a direction or service, this may be a sign of a lack of alignment.</li>
</ol>
<p>The next figure <a id="_idIndexMarker165"/>is an example of a BCM that follows the five zones principle, with the main one decomposed following the organizational chart directions. Again, this is just a commonly observed pattern and not a recommendation whatsoever. One should adjust the BCM decomposition as one sees fit to obtain alignment. Again, in terms of the text readability of the following diagram, the text content is not important but only the structure:</p>
<div><div><img alt="Figure 3.7 – BCM example" src="img/B21293_03_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – BCM example</p>
<p>For the anecdote, these<a id="_idIndexMarker166"/> five areas are also found in the French government’s information system BCM, with the four supporting areas surrounding and the business-oriented functions in the middle, which are, in this context, separated by the different ministries the French government is composed of. I’ve highlighted the separations with black lines, as that is what I intended to show you (the readability of text is not intended):</p>
<div><div><img alt="Figure 3.8 – French government BCM" src="img/B21293_03_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – French government BCM</p>
<p>We will <a id="_idIndexMarker167"/>come back to the importance of this second layer of the<a id="_idIndexMarker168"/> CIGREF. As stated, the first one indicates the vision and what value brings the company to the market, but the second is about how to operationally implement this vision, and this is where things are lacking in disorganized information systems. In the dozens of information systems I have been able to watch or help refine, the BCM is <em class="italic">always</em> the least-controlled layer. This absence of correct handling of it is th<a id="_idTextAnchor093"/>e root cause of the information system not giving satisfaction.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor094"/>Software layer</h2>
<p>With the next two <a id="_idIndexMarker169"/>layers of the CIGREF map, we enter the realm of technology. For now, processes and functions were purely business-related and one could very well use them for a computer-free information system. But this is not what we have today, and the subject of analysis in this book. We will work on computer-based, at least partially automated systems here, and the two technical layers that the top ones rely on are about implementing the function with computers. Their separation is extremely easy: the third layer is everything that is “soft”, which means immaterial, virtual, and non-concrete, whereas the fourth layer groups everything that is concrete. To say<a id="_idIndexMarker170"/> it as simply as possible: if you can touch it (computer, network cables, appliances, data centers —even if the walls do not belong to you), it will go to the next layer that we will cover a bit later. If it is technical but not “touchable”, such as a software application, a database, a stream of information, an API implementation, etc., it belongs in the third level in the CIGREF map, which we will detail right now.</p>
<p>This third level is in general quite easy for the companies to create in its first implementation: looking at bills and asking people what software they use is generally enough to find out the 80% most important uses of software in your system. But, even if exhaustive referencing is not the goal, this may not be enough for two reasons.</p>
<p>First, there may be<a id="_idIndexMarker171"/> some “hidden” software that has been bought by a service without the company knowing (this is called <strong class="bold">shadow IT</strong> and can be a problem where maintenance or strong ownership is needed). There is a risk that they will not appear on the map if they are strategic, and this might become a problem also if people using them suddenly leave and the associated functions collapse without anyone understanding why. If you have heard stories of a company having software problems after a key person retired, this is what we are talking about.</p>
<p>The second problem is that software is not only applications but also data, and data is usually harder to locate and follow in a system. Sure, you can locate databases with their commercial licenses or the IP and port they use. But you will find data in so many other places, such as dreaded Excel worksheets. Again, who has not heard of an Excel workbook that was so important for the company that everyone knew about it? In one of the companies I accompanied in business/IT alignment, there was “Serge’s Excel file”, which everyone kept telling me about when I was trying to figure out where the source of truth was for the articles and prices for the company. It turned out that, in this company of almost a thousand employees, there was no governance at all on product information management, and this person called Serge, at some point when he desperately needed the information, took the job of collecting the data from commerce, administration, and engineering and putting it together in an Excel workbook, trying his best to follow the changes, new products, end-of-life dates, changes in price, etc. As this was not his primary job, he had little time to do so and the content of the file was neither complete nor free from errors. But since this was the only source of data available, everybody quickly copied Serge’s file or referred to it with server links. The managers never considered the fragility of this approach to a hugely important source of data (maybe even the primary referential of a commercial company together with the list of customers), and guess what happened when Serge eventually left the company? The system slowly decayed because it was nobody’s job to maintain the one-person, non-documented work. Information became dirtier, orders started to be false, prices could not be adjusted because most people using the information in the file or in the connectors that had been created on it had no clue where the data was coming from, etc.</p>
<p>One may <a id="_idIndexMarker172"/>object that what I am talking about is not part of the third layer but relates to the second one, and indeed, master data management and data governance and ownership have to be detailed on the second level. But in this case, I wanted to show that a poor technical implementation (which definitely belongs to the third layer) and a lack of understanding about where the data in its software form stands were the root of the problem that went right up to the first level of the map and derailed two of the main processes of the company, namely production, and sales.</p>
<p>Categorizing the content of this third layer really depends on a lot of factors. Some companies with strong internal IT and programming capacities will tend to have the applications and data grouped by the technical team that operates on it. I have seen others grouping the software layer by technology, as their main concern was to operate the technologies internally even though they were—for the most part—bought on the shelf. In some cases, software can be sorted by editors. And there are many other ways to sort it. In the next example (once again blurred for confidentiality reasons), the cutting has been done using functional domains, as the company was quite big and the software application and data’s responsibility had been affected by the business directions and services (which is quite a good practice, as software should always <a id="_idTextAnchor095"/>be at the service of the functions):</p>
<div><div><img alt="Figure 3.9 – Software layer" src="img/B21293_03_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Software layer</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor096"/>Hardware layer</h2>
<p>As explained <a id="_idIndexMarker173"/>before, the hardware layer lists and organizes everything from the information system that is concrete. After all, the important bits of computerized systems are data and virtual functions that dramatically accelerate the processes, but we should never forget that, even though in a remote cloud location nobody really cares, all this is realized by electrons flowing in electronic chips and board, with power supplies, cabling, hard disks, and screens somewhere.</p>
<p>This layer is nowadays very standardized and under control and, in dozens of information systems where I have analyzed shortcomings in alignment and performance, virtually none of them exposed this limitation due to a hardware problem. In fact, it is so rare that in most of the CIGREF maps I have done, the fourth layer is very thin, with almost no details, or sometimes it’s not even represented at all. For example, if we take the big picture of the different layers I have shown you as samples, it so happens that nothing was represented for the hardware layer:</p>
<div><div><img alt="﻿Figure 3.10 – Three layers only (the readability of the text is not intended)" src="img/B21293_03_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Three layers only (the readability of the text is not intended)</p>
<p>Luckily, something<a id="_idIndexMarker174"/> that company owners know very well will always remind us of the existence of this layer, namely their costs. And even if the machines are more and more virtualized and made invisible, the financial costs are still there. With time, the ecological impact of information systems and data centers eventually also becomes a part of the equation, making this layer more visible as well.</p>
<p>If you have to draw a hardware layer, you will find lots of excellent diagramming systems that distinguish between server types, can provide dedicated icons and metadata so you can list hardware atoms separately, etc. All in all, again, this is a very controlled and standardized layer, which certainly explains why we rarely have to work on it when <a id="_idIndexMarker175"/>talking about IT alignment, other than referring to it to complete the software costs and balancing the sum to the benefits expected from the first two layers.</p>
<p>To provide an example of a hardware layer, here is a chronological series of such a layer diagram in a company that progressively externalized its IT (the orange bits were servers operated directly by the IT service):</p>
<div><div><img alt="Figure 3.11 – Hardware layer" src="img/B21293_03_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Hardware layer</p>
<p>Due to the relatively low importance of the representation of this layer (and not of the layer itself, of course), we will not go deeper into descriptions of how to use the diagram to map a hardware layer. The groupings, also, are quite obvious; most of the time, they are based on data centers with the physical location on the top, separate physical servers, then virtual machines, etc. Networks are also represented with sta<a id="_idTextAnchor097"/>ndard symbols and, all in all, diagrams are generic for this layer.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor098"/>Using the four-layer diagram</h1>
<p>The principles of<a id="_idIndexMarker176"/> the CIGREF mapping should now be clear, so we can see how to use this technique to improve alignment and, thus, the efficiency of the information systems. As said, the first action to take when taking control of a system is to create a map of it. Otherwise, there is simply no way to be comfortable with handling such complex sets. This means of course that creating the map for the existing state of the information system is the very first action to take, and a CIGREF map is great for that. But lots of questions still remain on how to do so. This section contains a few battle-proven pieces of advice on how to use the mapping technique.</p>
<p>As an important <a id="_idIndexMarker177"/>note, do not worry if you do not know precisely how to use the CIGREF method by the end of this chapter. For now, I will just show you how to draw it and how to spot problems of business/IT alignment in it, but the rest of the book will present lots of other examples of the CIGREF map in action for many different purposes. This means it will hopefully become clearer how powerful it is in analyzing and structuring an information system and you should not feel concerned if <a id="_idTextAnchor099"/>you do not know yet precisely how it is going to be used in practice.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor100"/>What should we map?</h2>
<p>First of all, one<a id="_idIndexMarker178"/> should never map the entire system in detail. It is, of course, essential to have a coarse map covering the whole perimeter of it to understand what we are dealing with, but only the parts of the system that need attention should be mapped in detail. That may sound obvious, but there have been so many times with teams I’ve advised where I realized, a few weeks after explaining the method, that they had diagrammed absolutely everything in the information system. Thus, this advice needs to be put forward.</p>
<p>It just seems like a natural reaction, in particular for teams with heavy problems in their system, to map everything, as it gives a sensation of recovering a bit of control. Sadly, this is not only a waste of time during the creation of the map, but also a waste of time afterward, when people will try and adjust the diagram following the evolution of the system. This is not what system diagramming is for. The map is used to anticipate evolution and force it as much as possible in the direction we have decided. Thus, it should only be done in detail on parts of the system that we are working on. Diagramming in advance is a waste because we will have to do it again once we get to work on this portion of the system in most cases. Mapping everything is a waste of time for the same reason, and even more, because there are (hopefully) parts of the system we will never work on, simply because they work fine already!</p>
<p>Again, that may sound obvious when explained but, when one starts mapping an information system, there seems to be some kind of frenzy mapping happening and I have seen many times well-educated and experienced people realizing that they had worked for nothing (the best example I have is an organization with thousands of employees where the IT team had diagrammed a process for establishing badges to access the internal restaurant; this diagram was of course never used and certainly not even read by anyone else than its creators).</p>
<p>The following schema visually explains how a map should evolve in time, with parts of a system being detailed only when needed:</p>
<div><div><img alt="Figure 3.12 – Mapping evolution" src="img/B21293_03_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Mapping evolution</p>
<p>One of the<a id="_idIndexMarker179"/> other consequences of this—and more subtle—is that the parts of the information system that have been diagrammed in detail should, after the diagram has been used to improve them, not be updated anymore. In Figure 3.12, this is what happens to the quarter that had been refined in the second step. In the fourth step, it is not detailed anymore. That may sound counterintuitive; indeed, once the effort has been made to detail this quarter, why just abandon it? The same reason applies: if this quarter is now well organized and alignment has been reached between business and IT, there is a chance that either we will not come back to it or, <a id="_idTextAnchor101"/>if we do, the map will have changed. So why bother wasting time on it?</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor102"/>How to start drawing a four-layer diagram</h2>
<p>Starting <a id="_idIndexMarker180"/>with an empty sheet is always difficult; it is even more difficult when the IT problems are such that the activity of the company is impacted. To ease starting the mapping activity, it is sometimes easier to use paper or a whiteboard to give a first view of the system. I like showing the following “first draft” of an information system I have been called to analyze because of the anecdote that comes with it:</p>
<div><div><img alt="Figure 3.13 – Using CIGREF" src="img/B21293_01_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Using CIGREF</p>
<p>This industrial <a id="_idIndexMarker181"/>company had difficulties in stabilizing the streams of data for scientific analyses and communication of the results to their customers. We (the IT team and myself) started spending a few hours drawing the four main processes, the incomplete but close enough BCM, and the applications involved in them together with the stream of data. At that point, we were about to evaluate the frequency of the exchanges that were drawn to determine the weakness. Then, the director of the company came by and, looking for a few seconds at what we had done, pointed his finger at two of the Post-it notes representing applications and said “Well, the problem is apparently here”. This person did not have any technical or IT background whatsoever but, seeing that lots of streams would go in and out of these two entities, he immediately understood that they were holding back the efficiency of the system and, in particular, its ability to evolve. It turned out after additional analysis that one of the applications was obsolete and the second one had a complexity problem. The system was thus redesigned to improve and the main steps were to integrate a new application for the first one and to create a superset of APIs exposing the legacy functionalities in a cleaner way for the second one.</p>
<p>This shows the power of good information system mapping, as it helps all actors—and not only technical-savvy ones—understand what is going on<a id="_idTextAnchor103"/> in their IT, which now is, almost everywhere, their main working tool.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor104"/>A generic difficulty when aligning information systems</h2>
<p>One of the<a id="_idIndexMarker182"/> problems that almost always happens in the system and has an impact on its map is that confusion is frequent between the processes in layer 1 and the dependencies in layer 3. Most functional people tend to think that their IT system implements processes exactly like they have been designed; how naive of them... Software is not necessarily made in-house and, when bought on the shelf, there is almost no chance that it perfectly fits the company’s process. Of course, everyone at the beginning of a new software project will swear that they will abide by the editor’s logic and adjust their process to keep the solution generic and avoid costly specific customizations. But the reality in most of these situations is that IT will end up integrating the software hammering circles in square holes and the result will not be clean.</p>
<p>This lack of distinction also happens when functional people express themselves in technical terms without fully understanding the consequences of what they say on the system. Come on, we’ve all at some point had managers or big bosses talk about ESB or ETL as if they were able to write the Camel route themselves in XML! This overconfidence in IT’s simplicity also brings interesting statements of project duration once a BPMN is drawn and functional authors are convinced that it can simply be executed, just like it was a WS-BPEL schema with endpoints already existing.</p>
<p>Let’s take an example and imagine you have been provided with a BPMN schema such as this (the French labels do not matter; simply observe the structure of the diagram and the fact that all tasks are manual):</p>
<div><div><img alt="Figure 3.14 – Manual process" src="img/B21293_03_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Manual process</p>
<p>Now imagine<a id="_idIndexMarker183"/> that the diagram of data streams corresponding to the realization of this process, as given by the IT, is something like this:</p>
<div><div><img alt="Figure 3.15 – Process in software" src="img/B21293_03_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Process in software</p>
<p>It does not need any technical expertise to realize that there is no relationship whatsoever between the tasks in the process and the streams of data that have been created between the software applications and databases. So, a fair part of the job of mapping the information system will be about drawing relationships between the tasks and the corresponding streams of data. In the end, you may realize that some of these streams are incomplete, needing others to compensate for the lack of data. You may find streams that bring too much data into software that should not even have the authorization to see it. You may even find streams of data that simply serve no known purpose anymore.</p>
<p>To relate the<a id="_idIndexMarker184"/> two layers, you will have to create a strong business capability map, as layer 2 will be used as an indirection between the processes and their software implementation. This is why BCM is so important and, if you operate on information systems, you will realize that this is often missing, simply because it is lesser known than processes and software/hardware. Yet, BCM is essential to reduce coupling and favor the evolution of the system by providing a way to create dependencies without being stuck by technical implementations that are hard to change once set in place or having to change the IT because a process has been modified in the way the company operates. The BCM, in this case, acts as an indirection layer that makes possible the evolution of layer 1 with limited impact on layer 3 and vice-versa.</p>
<p>The following schema sums this up, and, by the way, I often tell my students that if they only remember one slide from my course on I<a id="_idTextAnchor105"/>T alignment, it should be this one:</p>
<div><div><img alt="Figure 3.16 – Coupling done well" src="img/B21293_03_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – Coupling done well</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor106"/>Evolving the information system in time</h2>
<p>Of course, after <a id="_idIndexMarker185"/>mapping the existing state of the information system, the next step is to improve it, and this calls for a strategy with multiple steps to make it more realistic. Again, the CIGREF map is here to help by explaining clearly what needs to be adjusted at each step and showing how the dependencies need to be taken care of. If one changes a function by plugging it into a new and improved software application, all tasks depending on this function will need to evolve to take advantage of this, except of course if there is 100% compatibility, and in this case, we can consider that the function itself does not change.</p>
<p>The goal at the end of these steps is to reach a state as close to (and cost-effective) a realistic and nicely aligned system as possible, which could be schematized as the following:</p>
<div><div><img alt="Figure 3.17 – Ideal alignment" src="img/B21293_03_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Ideal alignment</p>
<p>Of course, this may sound ideal, and, most of the time, we will never reach alignment for the complete system. But local alignment can be reached, as shown in the next schema, which I exported from one of my customers who managed to align one of their most important support processes (namely, handling newcomers, as this was a company with high structural turnover) in such a way that the efforts needed would drop by an estimated factor of ten and the duration of the process would reduce to a third of the initial measured time. This was achieved via the automation of some of the tasks, but the alignment made this automation possible, as the process was entirely manual beforehand due to a clear lack of structure in the IT (the company was in a non-technical <a id="_idIndexMarker186"/>business and put a limited budget in its IT, only realizing after it reached an almost desperate state how important it had become for their activities). The following diagram is blurred for confidentiality reasons; we intended to showcase only the flow of the process:</p>
<div><div><img alt="Figure 3.18 – Applied alignment" src="img/B21293_03_18_(replacement).jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Applied alignment</p>
<p>We will come back in the next chapter to the evolution of the information system in time. For now, just keep in mind that the CIGREF map has to be used to establish the actual situation but can also be used to model a desired future situation and every step in between.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor107"/>The four-layer diagram method for service providers</h2>
<p>You may <a id="_idIndexMarker187"/>wonder about the use of the CIGREF map when buying software as a service and whether it means that we do not draw anything in the hardware layer. The answer comes back to the use you want to have of your map, as you do not map for the pleasure of having something complete but because your use case needs you to be precisely aware of how your information system is working in its details. This means that, if your interest is in software alignment functions, you have absolutely no use in knowing where the servers are physically, and, in this case, there is no use in drawing anything in the fourth layer; you will simply leave it empty. On the other hand, suppose one of your concerns is about the locality of your data because your board has a constraint on data sovereignty. In this case, you will indicate the precise region in which the data centers supporting the software are located in the fourth layer. This way, it will be easy to spot something that is outside the allowed regions.</p>
<p>This comes <a id="_idIndexMarker188"/>back to a very important piece of advice: only map what you really need. It is very easy to get carried away and map lots of things that you actually do not really care about. In particular, the hardware layer is generally quite easy to map because automatic network exploration applications can help and good system administrators often have agents on every machine deployed for security and software inventory. So, people tend to have a very precise drawing of the fourth layer, even when their problem is about function to software alignment. In this case, you’d be better off replacing the whole hardware layer with a few general blocks—typically the data centers used, including your own server room—and labeling them with the associated cost, as this is (in this case) the only information that will help you.</p>
<p>Talking about services, an equivalent question can be asked the other way around, namely about the CIGREF representation for a software editor or integrator that would provide a software service to its customers. How should we represent this? Is the cloud used for the customers a part of the information system of the editor? Should it be drawn in a particular way?</p>
<p>Again, the notion of the usefulness of the map should drive our response to this. Imagine the problem at hand—and thus the reason why you establish a map—is that you have a problem of coupling between your internal functions and your offer for your customers. This can be a security problem because ransomware on one side could easily propagate to the other. This may also come from the accounting team, which does not know which machines and services should be billed to customers and which costs should remain internal. It could also come from system management difficulties, such as the fact that shutting down a supposedly internal server eventually had an impact on your production. In this case, the right approach would be to draw the current, unique information system and then to draw the target map, which is composed of two distinct information systems and a precise representation of the interactions remaining between them (for example, sending the usage data from the production information system to the internal information system so that accounting can establish billing for the different tenants).</p>
<p>This is typically<a id="_idIndexMarker189"/> where you would use the zone for “externally oriented functions” of your business capability map (layer 2 of the CIGREF representation). In the production information system, you would find in this zone the function for “reporting data usage per tenant” or “sending total API calls per tenant”. And in the internal information system, you would find, of course, in the “business” zone/“accounting” quarter, the function to handle this data and calculate the bill for the tenant. Another example would be functions such as “request tenant access blocking” or “archive tenant” that you would find in the “externally oriented functions” zone. They would typically be called by the internal information system to instruct the production information system that a customer has not paid the bill and should be at least blocked, and maybe later, completely removed.</p>
<p>Another example of a link between the two systems is, of course, when the internal software-production workflow has produced a validated, complete new release of the software sold to the customers (this is the main role of the software editing company). There has to be a link somewhere since the information system exposing this software to customer tenants will use this deliverable to update its services at some point. One of the best ways to establish this link while keeping very low coupling is to create a container registry that will be filled with images coming from the first system (with the right tags, of course) and consumed by the second information system by pulling the images it needs to expose in the tenants.</p>
<p>The only remaining question is where the registry should be placed, and the answer—if you need a very stable one—is to have one on each side: a registry that centralizes all the production from your continuous integration as a software editing company on one side and another registry that serves as an image cache on the other side. This makes it easier for your continuous deployment as an integrating company to keep on creating tenants even if the first registry is not accessible anymore. This clean separation can even be used to implement some high-level rules, such as “only contained images with the STABLE tag should be put into production”, by caching only those in the second Docker registry.</p>
<p>One might argue that, since there are calls between the two systems in this case, that might mean they are a single system and should be represented as so. Again, the map is not here to reflect the full reality of the world but to help you carry out your duty in information management. If the orientation you wish to have is a good separation of concerns (and for security reasons, it should be), then your map should represent your goal, as it will help you in doing everything that is needed to reach this objective.</p>
<p>Finally, another <a id="_idIndexMarker190"/>argument could be opposed to this vision, by stating that, today, every information system on the planet has some kind of connection together, may it only be by the internet network, that covers almost every local system. Also, when companies buy others, they connect their information systems, sometimes in such a tightly knitted way that they become a single system in the end. Again, this only depends on<a id="_idTextAnchor108"/> your strategy, so the CIGREF map should simply be aligned with the vision.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor109"/>Patterns and antipatterns of alignment</h1>
<p>Several years <a id="_idIndexMarker191"/>of consulting on information systems have led me to observe that most problems relate to a few misalignments in the system, themselves belonging to only a few patterns. Having worked for quite some time in a limited business domain, it was a surprise to realize after a few years when I started working with agricultural cooperatives, chemical risk analysis companies, lawyers societies, and other companies within very different fields, that these patterns (or rather, antipatterns since they cause problems) were the same everywhere.</p>
<p>Dalila Tamzalit, who<a id="_idIndexMarker192"/> is a researcher at French CNRS, took up with me to classify these antipatterns and document a method to find them and exploit information to better align information systems that suffer from them. This led to an article published in the International Conference on Information Systems Development in 2021 (available at <a href="https://aisel.aisnet.org/isd2014/proceedings2021/managingdevops/3/">https://aisel.aisnet.org/isd2014/proceedings2021/managingdevops/3/</a>). You will find in the next section a summa<a id="_idTextAnchor110"/>ry of some of the information that could help in managing business alignment.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor111"/>The sad reality of alignment</h2>
<p>First, it should<a id="_idIndexMarker193"/> be known that most information systems, as was explained in <a href="B21293_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, suffer from basic problems that limit their efficiency. In terms of a four-layer diagram, these problems can be summarized as this:</p>
<div><div><img alt="Figure 3.19 – Common problems" src="img/B21293_03_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – Common problems</p>
<p>Processes may<a id="_idIndexMarker194"/> be well understood, since there is rarely any BCM, but the corresponding realization of the processes is often done with point-to-point ad hoc interop that quickly brings the system to a “<a id="_idTextAnchor112"/>spaghetti dish lookalike” where streams of data happen in an uncontrolled way.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor113"/>What we can aim for</h2>
<p>It was already stated, and it may sound logical, but we do not aim for a completely aligned system. A well-designed system for two business processes may be as simple as the following, where a bit more than ten well-adjusted streams of data implemented the full business needs with the same amount of applications (the majority of them already exist, in this example, and being simply correctly plugged) and almost no additional hardware:</p>
<div><div><img alt="F﻿igure 3.20 – Good alignment (the text is blurred for confidentiality reasons)" src="img/B21293_03_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">F<a id="_idTextAnchor114"/>igure 3.20 – Good alignment (the text is blurred for confidentiality reasons)</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor115"/>The main antipatterns in alignment</h2>
<p>Now the <a id="_idIndexMarker195"/>goal is clear, let’s come back to our alignment antipatterns and present the main four of them (we only explain what they are, and how th<a id="_idTextAnchor116"/>ey can be fought against and reduced will be covered in the rest of the book):</p>
<ol>
<li><strong class="bold">Purely technical integration</strong> happens when a process is not designed in the first layer <a id="_idIndexMarker196"/>but directly implemented into the software. The consequence is that any change in company strategy, domain-based rules, or even simple optimization of the process will lead to a change in software. This is the root cause of hearing “We do not evolve quickly enough, as we are dragged down by IT” or “It is not possible to have this business function due to software limitations” (and its variant “adding this new data attribute in the whole software chain, from interface to reporting, will take six months and need a new release of four applications”).<p class="list-inset">The symbolic representation of this antipattern is the following:</p></li>
</ol>
<div><div><img alt="Figure 3.21 – Antipattern number 1: Pure Technical Integration" src="img/B21293_03_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – Antipattern number 1: Pure Technical Integration</p>
<ol>
<li value="2"><strong class="bold">Applicative silos</strong> appear<a id="_idIndexMarker197"/> when two parts of <a id="_idIndexMarker198"/>the organization have worked on their IT needs without talking to each other. The resulting system shows the result of this as two independent systems in the diagram. There may be some cases where complete isolation is thought to be important (human resources, finance, other highly confidential zones), but, from experience, there always comes a time when links have to be established between the different zones. This may come as a harsh reality in these cases, as data has been completely duplicated, uses different formats, or uses technologies that have not been chosen to ease interoperation, etc. The main risk in this case is that data sources are simply opened to the other area, which will cause major authorization problems. In one of the worst cases I have seen, full HR data had been made available to the ERP by a trainee to implement the reimbursement of travel fees, which was of course a major breach of confidentiality and exposed the company to potential GDPR issues until it was corrected.<p class="list-inset">The symbolic representation<a id="_idIndexMarker199"/> of this antipattern is the following:</p></li>
</ol>
<div><div><img alt="Figure 3.22 – Antipattern number 2: Silos" src="img/B21293_03_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – Antipattern number 2: Silos</p>
<ol>
<li value="3"><strong class="bold">Monoliths</strong> are applications<a id="_idIndexMarker200"/> that <a id="_idIndexMarker201"/>concentrate a lot of functions. This in itself is not necessarily a problem, as a given application may implement everything that is used by a business domain. The problem arises because these applications also implement functions that should be shared or already exist in other parts of the system. Data duplication is a huge problem in information systems, as they never correspond from one side to the other, which makes it hard to know which source is the closest to the truth, resulting in bad decisions or false computations.<p class="list-inset">The symbolic representation of this antipattern is the following:</p></li>
</ol>
<div><div><img alt="Figure 3.23 – Antipattern number 3: Monolith" src="img/B21293_03_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – Antipattern number 3: Monolith</p>
<ol>
<li value="4"><strong class="bold">Functional multiple implementations</strong> are a problem because the different implementations<a id="_idIndexMarker202"/> have almost no chance of working in a compatible way. One can easily understand that, if a financial budget summary is computed in a given way in an <a id="_idIndexMarker203"/>application and in a different way in a second application that is supposed to do the same thing, it is difficult to take intelligent actions to manage the company. One such case I witnessed at a newspaper company showed a different number of readers depending on which application was queried, with deltas that were so large that, in some situations, the newspaper could not know without additional calculation whether they were gaining or losing readers.<p class="list-inset">The symbo<a id="_idTextAnchor117"/>lic representation of this antipattern is the following:</p></li>
</ol>
<div><div><img alt="Figure 3.24 – Antipattern number 4: Functional Multiple Implementations" src="img/B21293_03_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24 – Antipattern number 4: Functional Multiple Implementations</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor118"/>Some other antipatterns and a proposed classification</h2>
<p>Only the four<a id="_idIndexMarker204"/> most<a id="_idIndexMarker205"/> important antipatterns have been shown, and the whole set <a id="_idIndexMarker206"/>of <strong class="bold">business/IT alignment antipatterns</strong> (<strong class="bold">BITA</strong>, in its proposed short form) is the following:</p>
<div><div><img alt="Figure 3.25 – Antipatterns classification" src="img/B21293_03_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25 – Antipatterns classification</p>
<p>To use this<a id="_idIndexMarker207"/> classification to improve alignment in the existing information system, each of them comes with a structured identity card with the following information:</p>
<div><div><img alt="Figure 3.26 – ID card for an antipattern" src="img/B21293_03_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26 – ID card for an antipattern</p>
<p>A full <a id="_idIndexMarker208"/>explanation of how the antipatterns appear and—more importantly—the standard actions to correct them can also be found in the complete article cited before.</p>
<p>You can view the full article on GitHub, which will show you the amount of such information available on the first BITA: <a href="https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Business-IT%20Alignment%20Anti-Patterns%20A%20Thought%20from%20an%20Empirical.pdf">https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Business-IT%20Alignment%20Anti-Patterns%20A%20Thought%20from%20an%20Empirical.pdf</a></p>
<p>This <a id="_idIndexMarker209"/>taxonomy, coming from experience, has led us to propose a structured way to improve information alignment that can be summarized in the following BPMN diagram:</p>
<div><div><img alt="Figure 3.27 – Proposed method to detect antipatterns in an Information System" src="img/B21293_03_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27 – Proposed method to detect antipatterns in an Information System</p>
<p>I encourage <a id="_idIndexMarker210"/>you to try and apply this method to your information systems of study and send feedback. This <a id="_idTextAnchor119"/>will be useful to the academic community and hopefully for the other readers as well.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor120"/>Summary</h1>
<p>This quite long chapter showed how a formalized diagramming technique can be used to obtain a better understanding of an information system and also document the evolutions it will have to follow. A map is a prerequisite to control a given ground, and a schema is worth a thousand words, which makes this step a must in any information system architecture activity.</p>
<p>Since IT is quite a specific context, we needed a dedicated way of drawing a map of an information system, and this is what the CIGREF map is about. Its four-layer arrangement helps separate the business-oriented aspects (processes and atomic functions) from the technical aspects (software and hardware).</p>
<p>This way of representing an information system also helps in visualizing its alignment, by checking that the third layer (the software bits) is well adjusted to the second layer (the business capability map) it implements. The business/IT alignment is the most important measure of quality and capacity to evolve for complex information systems and a feature that must be sought.</p>
<p>The next chapter will extend the present one by taking into account the dimension of time. We have quickly talked about this in a previous section, explaining that the CIGREF map could be used to document the actual state of an information system, but also the desired future states it should progressively reach (the Big Bang approach is never a practical alternative). But, as you will see, time appears in many other aspects of information systems and can be quite a difficult parameter to handle.</p>
</div>
</body></html>