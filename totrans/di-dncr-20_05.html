<html><head></head><body>
        

                            
                    <h1 class="header-title">Object Composition</h1>
                
            
            
                
<p>In <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core</em>, we got an insight into Dependency Injection with .NET Core and ASP.NET Core with default DI Container. We explored how to apply DI to different components of the application like controllers and views. Now it's time to deep dive into the actual fundamentals behind Dependency Injection.</p>
<p class="mce-root">Before moving forward with the main topic, we need to first understand why do we even care to read about this topic. The programming world is surrounded with objects and their interactions. We achieve certain solutions or build features getting help from classes that we generate for two basic reasons that are <strong>code reuse</strong> and <strong>maintainability</strong>.</p>
<p class="mce-root">Now you might ask me why create classes at all! Yes, I second you, unless you ask me to alter code after some days. Then, even I can't help you because that will be a nightmare for me. And you know why? That is because I might have to repeat the codes (you have already written) in my new classes.</p>
<p class="mce-root">Suppose you have a class named <kbd>Customer</kbd> with the properties <kbd>CustomerId</kbd>, <kbd>FirstName</kbd>, <kbd>LastName</kbd>, <kbd>Email</kbd>, <kbd>MobileNumber</kbd>, <kbd>Address1</kbd>, <kbd>Address2</kbd>, <kbd>City</kbd> and so on. I come in and start working on another entity named as <kbd>Seller</kbd> with the properties <kbd>SellerId</kbd>, <kbd>FirstName</kbd>, <kbd>LastName</kbd>, <kbd>Email</kbd>, <kbd>MobileNumber</kbd>, <kbd>Address1</kbd>, <kbd>Address2</kbd>, <kbd>City</kbd> and so on.</p>
<p class="mce-root">I think you are smart enough to identify the problem. We can see the properties which are <em>italicised</em> are getting repeated. One solution to this problem would be to create another class, something named <kbd>User</kbd> with all those common properties. Then, the <kbd>Customer</kbd> and <kbd>Seller</kbd> classes become its children. Thus, we will achieve a simple design to deal with future entities as well. I can easily reuse the <kbd>User</kbd> class to create some other child class, which would inherit the common properties if needed.</p>
<p>Therefore, this chapter plays an important role in helping you grab these relationships. Designing a complex class with smaller flexible and reusable classes is an essential part of a software project, which will be the focused of this chapter. The following are the key topics that we will cover:</p>
<ul>
<li>Relationships</li>
<li>Composition</li>
<li>Aggregation</li>
<li>Association</li>
<li>Inheritance</li>
<li>Composition over Inheritance</li>
<li>The importance of Object Composition in Dependency Injection</li>
<li>Object Composition in .NET Core 2.0 Console and MVC Apps</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding object relationships</h1>
                
            
            
                
<p>Let's try to understand object relationships by first considering human relationships. The examples may not be the aptest but if we want to learn about object relationships, then why not look into it?</p>
<ul>
<li>You depend on your parents till you get a job</li>
<li>You have a wife and two children</li>
<li>Trees have blossom and leaves on them</li>
<li>A motherboard is part of a computer</li>
</ul>
<p>All these relationships possess unique characteristics. Let me simplify my statement. You depend on your parents. However, if they become jobless, you are not going to die. You will find some way to deal with the situation. On the contrary, if a tree dies, its blossom and leaves will die eventually. The relationship between the tree and its parts are tightly coupled. After the tree gets a life (instantiated), within a short period of time, its parts come to life as well. A motherboard without a computer is useless. It comes into play when it becomes a component of a computer.</p>
<p>Let's consider the following code snippet to understand the relationship between classes:</p>
<pre>    class Organisation<br/>    {<br/>      public Organisation() { }<br/>      public string Name { get; set; }<br/>      public string OfficialFacebookLink { get; set; }<br/>    }<br/><br/>    class Packt : Organisation<br/>    {<br/>      public Packt() { }<br/>      public int TotalBooksPublished { get; set; }<br/><br/>      public void PrintPacktInfo()<br/>      {<br/>        Console.WriteLine($"This is {Name}!\n" +<br/>            $"Our official facebook page link is <br/>              {OfficialFacebookLink}.\n" +<br/>            $"We have published {TotalBooksPublished} books.\n");<br/><br/>        <strong>Account account = new Account();</strong><br/>        <strong>account.PrintAcountInfo(1, "Packt Account");</strong><br/>      }<br/>    }<br/><br/>    public class Account<br/>    {<br/>      public int AccountId { get; set; }<br/>      public string AccountName { get; set; }<br/><br/>      public void PrintAcountInfo(int accId, string accName) <br/>      {<br/>        Console.WriteLine("Account Id: " + accId + "<br/>            and Account Name: " + accName);<br/>      }<br/>    }</pre>
<p>We have one <kbd>Organisation</kbd> class and <kbd>Packt</kbd>, being an organization, derives the parent class <kbd>Organisation</kbd>. This relationship is denoted as <em>is a</em> relationship because <kbd>Packt</kbd> is an organization. <kbd>Account</kbd> is a class, which can become <em>a part of</em> a <kbd>Packt</kbd> class. Thus, there is another relationship between <kbd>Packt</kbd> and <kbd>Account</kbd>. The name of the relationship is <em>a part of</em><strong>.</strong></p>
<p>Notice the method <kbd>PrintPacktInfo()</kbd> inside <kbd>Packt</kbd> class, which prints all information regarding <kbd>Packt</kbd>. However, that is not all, because you can see there is an <kbd>Account</kbd> class instance generated inside the method by which we are able to print the account information of <kbd>Packt</kbd>.</p>
<p>The <kbd>Main</kbd> method looks as follows, where we create an instance of <kbd>Packt</kbd> and provide any necessary details through properties and then call <kbd>PrintPacktInfo()</kbd>:</p>
<pre>    static void Main(string[] args)<br/>    {<br/>      Packt packt = new Packt<br/>      {<br/>         Name = "Packt Publications",<br/>         OfficialFacebookLink = "https://www.facebook.com/PacktPub/",<br/>         TotalBooksPublished = 5000<br/>      };<br/><br/>      <strong>packt</strong><strong>.PrintPacktInfo(); // Prints the Account information.</strong><br/>      Console.ReadKey();<br/>    }</pre>
<p>The code produces the following output:</p>
<div><img src="img/c1e32247-cae9-4cf4-9e49-f75a0129a769.png"/></div>
<p>The important thing to take away from this example is the way the <kbd>Packt</kbd> class depends on the <kbd>Account</kbd> class. <kbd>Dependency</kbd> is generated inside the <kbd>Packt</kbd> class.</p>
<p class="mce-root">Like the preceding one, we can find patterns, relationships, and hierarchies in programming. Let's investigate these in more detail and learn how to improve code reusability and elasticity of classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object Composition</h1>
                
            
            
                
<p>When I searched for the word composition in Google, the first thing I saw was:</p>
<p>the nature of something's ingredients or constituents; the way in which a whole or mixture is made up.</p>
<p>Now it's very simple to guess what Object Composition would be. Objects collectively mix themselves to constitute (be a part of) complex objects.</p>
<p>A simple real life example would be a car whose whole body consists of different types of components like engine, break, gear, battery, door, etc. Thus, these parts are actually the building blocks of the car and are composed in a very innovative way by the maker of the car.</p>
<p>Likewise, as we discussed, the <kbd>Account</kbd> class reference inside the <kbd>Packt</kbd> class method in the last section, which generates a relationship among them. We can consider that as a dependency too, as we can't execute the method of the <kbd>Packt</kbd> class without an instance of <kbd>Account</kbd> class. Clearly, we can say that the <kbd>Packt</kbd> object composes itself with the help of the <kbd>Account</kbd> instance.</p>
<p>Did you notice the bracketed phrase in the first paragraph <em>be</em> <em>a part of</em>? Confused! Let's discuss again and get hold of this phrase. In other words, this phrase can also be represented as <em>has a,</em> if I form the sentence from the complex object point of view. Refer the lines below.</p>
<ul>
<li>A computer <em>has a</em> keyboard. (Keyboard <em>is a part of</em> computer)</li>
<li>A car <em>has an</em> engine. (Engine <em>is a part of</em> car)</li>
</ul>
<p>It's pretty clear now, as you can see how these complex objects are made up of small objects conceptualizing Object Composition.</p>
<p>As you already know, different fundamental data types like <kbd>int</kbd>, <kbd>string</kbd>, boolean, and so on, or other class types, can be packaged into one structure or another class type, therefore, classes are often considered composite types.</p>
<p>The most important benefit of applying this concept to your projects is to get more easily manageable parts. Not only does it reduces the complexity of the application, but it also helps us to write code faster. Another noticeable advantage is code reuse, which leads to fewer errors as you will be using codes which have already been verified after testing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of Object Composition</h1>
                
            
            
                
<p>There are two subtypes of Object Composition, <strong>Composition</strong> and <strong>aggregation</strong>. Let's discuss one by one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Composition</h1>
                
            
            
                
<p>A Composition is a way through which you can bind objects together. One object can contain another object of the same/another class as a building block.</p>
<p>In other words, in our last example, <kbd>Packt</kbd> was dependent upon the <kbd>Account</kbd> class for its operation. The instance is created by the <kbd>Packt</kbd> class, giving life to it and then operated some function with the instance. You can add another class like <kbd>Packt</kbd> and do the same using an <kbd>Account</kbd> instance. Thus, you are trying to compose the objects to form a more complex one, which enables us to execute behavior (methods) of all composed/part objects with one composite object.</p>
<p>The following are the relationships, which is satisfied by the object and it's member or part, qualify as a Composition.</p>
<ul>
<li><strong>The part</strong> <strong>(member) is a component of the object (class)</strong>: As we have already discussed, the part or smaller class should be a part of the bigger complex class. For example, your kidney is a part of your body.</li>
<li><strong>The part (member) can only belong to one object (class) at a time</strong>: If the smaller class is referred to the complex class at a certain period, then it can't be a part of other classes at the same time. For example, your kidney, which is a part of your body, can't be a part of someone else's body at the same time.</li>
<li><strong>The part (member) has its existence managed by the object (class)</strong>: The object is responsible for the existence of the parts in a Composition relationship. In simple words, the part is created when the object is created and destroyed when the object is destroyed. This means the object manages the part's lifetime in such a way that the user of the object does not need to get involved. For example, when a body is created, the kidney is created too. When a person's body is destroyed, their kidney is destroyed too. Because of this, the Composition is sometimes called a <strong>Death Relationship</strong>.</li>
<li><strong>The part (member) does not know about the existence of the object (class):</strong> A particular part in a Composition doesn't know about the existence of the whole object. Your kidney is unaware that it is part of a larger structure but works as expected. This is called a <strong>Unidirectional Relationship</strong>. For example, the body knows about the kidney, but not the other way around.</li>
</ul>
<p>If you are thinking that as body parts can be transferable, why not member classes, then you are assuming right. Member classes can also be transferred. Thus, the new larger class is now the owner of the member class and the member class is no more related to the previous owner unless that is transferred again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consider an example</h1>
                
            
            
                
<p>Our favorite <kbd>Student</kbd> class:</p>
<pre class="mce-root">    public class Student
    {
      private int Id { get; set; }
      private string Name { get; set; }
      private DateTime Dob { get; set; }
      private Address Address { get; set; }
      private ICollection&lt;Book&gt; Books { get; set; }<br/><br/>      public void PrintStudent()<br/>      {<br/>        Console.WriteLine("Student: " + Name);<br/>        Console.WriteLine("City: " + Address.City + "");<br/>        Console.WriteLine("-----------------------");<br/>      }
    }</pre>
<p>Come on, don't be so surprised and please don't scold me now. I know this looks like a very basic class, but that is what Composition is all about, in short. Don't believe me? Alright, allow me to match those relationships with this <kbd>Student</kbd> class:</p>
<ul>
<li><strong>Rule 1: Part of a complex class</strong>: You can see the class members which are of different types such as <kbd>Integer</kbd>, <kbd>string</kbd>, <kbd>DateTime</kbd>, <kbd>Class</kbd> and <kbd>List&lt;Class&gt;</kbd> type. <kbd>Integer</kbd>, <kbd>string</kbd>, and <kbd>DateTime</kbd> are the data types already defined inside the <kbd>System</kbd> namespace of .NET Framework, whereas the <kbd>Address</kbd> and <kbd>Book</kbd> classes are user-defined classes. All are part of a complex class <kbd>Student</kbd>. Thus, the first condition is satisfied.</li>
<li><strong>Rule 2: Members should belong to one object</strong>: If I create an instance of the <kbd>Student</kbd> class, with a constructor, the members will only belong to the student object at that time. It can't be a member of another instance. Moreover, the members are private, which prevents them being used by any other class.</li>
</ul>
<pre>        Student student = new Student(1, "Bhagirathi Panda", <br/>          new DateTime(1990, 4, 23));</pre>
<p style="padding-left: 60px">The constructor will look like the following:</p>
<pre>        public Student(int id, string name, DateTime dob)
        {
          Id = id;
          Name = name;
          Dob = dob;
        }</pre>
<ul>
<li><strong>Rule 3: Members gets a life by the complex class (Death Relationship)</strong>: As you can see, members don't have any existence until we instantiate the <kbd>Student</kbd> class and they get destroyed when the object is dead; proving our rule 3.</li>
<li><strong>Rule 4: Members are unaware of the existence of the complex object (Unidirectional Relationship):</strong> The members are very obedient. They just store whatever value is assigned to them and don't even bother about who is assigning them for what reasons. The complex instance is their parent but these members behave like orphans and don't recognize it. Likewise, we don't mind what they are doing because our rule 4 is proved.</li>
</ul>
<p>Another important thing to note here is that the complex class can have a multiplicative member like <kbd>List&lt;Book&gt; Books</kbd>.</p>
<div><p>Do you know the shortcut to create a constructor? Just type <strong>ctor</strong> at the line where you want the constructor and then hit the <em>Tab</em> key two times. You will see an empty constructor block available for you. Moreover, Visual Studio tooltip tells you how to handle the command:</p>
<p><img src="img/211734ba-9e84-4120-bcf5-997859ff6c4a.png"/></p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Contrasting features of Composition</h1>
                
            
            
                
<p>The parts are created with the composite class's creation. That means the composite class is responsible for the creation. Also, the destruction of the part depends upon the destruction of their creator composite class. However, rules are meant to be broken and that happens in the case of Composition too.</p>
<p>Consider the following scenarios:</p>
<ul>
<li>The creation of a part is postponed till it is actually used. For instance, our <kbd>Student</kbd> class doesn't create the list of books until the user or any other method assigns some data to it.</li>
<li>A Composition assigns the responsibility of destructing the part to some other object. We are already aware of such routine named <strong>Garbage Collector</strong>, who manages the destruction of unused objects from time to time.</li>
</ul>
<p>Composition acts like a guardian, where all care of the members is taken by the composite class. Creation, assignment, and destruction; all are mostly managed by the composite class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why are subclasses inside Composition?</h1>
                
            
            
                
<p>There is always a decision you need to take while you program. If you closely analyze our <kbd>Student</kbd> class, you will realize a few things. The properties of the <kbd>Address</kbd> class be can directly be declared inside the <kbd>Student</kbd> class instead of declared as a different entity.</p>
<p>So, instead of the following:</p>
<pre>    public class Student
    {
      // Other properties.

      int AddressId {get; set;}
      string City {get; set;}
      string State {get; set;}
      string Country {get; set;}
    }</pre>
<p class="mce-root">We did this. Basically, we just separated out the address properties in a container class named <kbd>Address</kbd>. The following code block shows how we can extract out <kbd>Address</kbd> class:</p>
<pre>    public class Student
    {
      // Other properties.
      private Address Address { get; set; }
    }
    public class Address
    {
      public int AddressId { get; set; }
      public string City { get; set; }
      public string State { get; set; }
      public string Country { get; set; }<br/><br/>      // Constructor. Just initialising City for now.<br/>      public Address(string city)<br/>      {<br/>        City = city;<br/>      }
    }</pre>
<p class="mce-root">These are some of the advantages of doing a subclass instead of directly adding them to the composite class:</p>
<ul>
<li>The subclass is independent and simplifies the architecture. The code seems very easy to understand. The actual benefit you get out of it is when you try to do something extra on it, in the future. Suppose, I tell you to include another member Street for <kbd>Address</kbd>. If you have designed address properties directly inside composite classes, then you have to manually go to each class and add another member. However, in the case of the subclass, you just need to add that to the subclass and all composite classes using that will get the access automatically.</li>
<li>The more you break down the classes into subclasses, the more you make them be reusable. The address class, for instance, can be reused in some other class as well. It is no more tightly coupled with the Composition.</li>
<li>Due to the introduction of subclasses, the composite class is not complex anymore. Moreover, the subclasses can have methods defined in them which makes the life of the composite object easy. That is because the subclass can define it's related functions which can be called by the composite class. For example, if we want to get the full address, we can easily have a method inside the <kbd>Address</kbd> class, which will return a string using all those address properties. Thus, the composite class does not need to do anything on <kbd>Address</kbd> related stuff.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Important notes</h1>
                
            
            
                
<p>Thinking of a better design, such that it distributes responsibilities among different entities, is tough. But it is not impossible. When we start building the app, we don't always have full specifications or realize what could happen next. Eventually, when more specifications come in, we face problems as we ignore building subclasses for a certain common usage. Therefore, you will also see bad and repeated codes in many classes which can be packaged in a subclass and could easily be reused.</p>
<p>Composite or main classes should be responsible for what it is designed. A <kbd>Student</kbd> class is responsible for managing student information. There is no doubt that the address of the student is something it should handle. But, what if we get another entity like <kbd>Teacher</kbd> who also has an address? We have to repeat the same set of properties inside the <kbd>Teacher</kbd> class to achieve this. Code smell isn't it! That is when you should decide to separate <kbd>Address</kbd>--related information to another class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aggregation</h1>
                
            
            
                
<p>Aggregation is another type of object Composition. Let's explore this in details.</p>
<p>It is the process by which you bring existing objects together to form a new object. At first, it looks similar to Composition. But in reality, it has differences. To qualify as an aggregation, the complex object and its parts must satisfy the following relationships:</p>
<ul>
<li><strong>The part (member) is a component of the object (class)</strong>: It is similar to Composition. That means the smaller object is a part of the complex object. For example, a person has a Google Drive folder.</li>
<li><strong>The part (member) can belong to more than one object (class) at a time</strong>: Unlike Composition, here the member is independent of the class. It might be referenced by other classes as well at the same time. For example, a Drive folder can be shared by many users at the same time.</li>
<li><strong>The part (member) does not have its existence managed by the object (class):</strong> As the last point states the member is not tied to the complex class, so it's creation and destruction is not managed by it. For example, all those people with whom the folder is shared have not created it. Unless they are provided with admin rights, they can't delete the folder.</li>
<li><strong>The part (member) does not know about the existence of the object (class):</strong> The member does not know whether the complex object exists or not, same as Composition. For example, a person does not know if the Drive folder exists or not.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Consider an example</h1>
                
            
            
                
<p>Now, we will try to alter the <kbd>Student</kbd> class which was illustrated in the Composition lesson. I am doing it because we have an <kbd>Address</kbd> property there. See how the constructor is updated to have the address as an argument:</p>
<pre>    public Student(int id, string name, DateTime dob, Address address)
    {
        Id = id;
        Name = name;
        Dob = dob;
        Address = address;
    }</pre>
<p class="mce-root">This is not new to you. Let's try to elaborate it. We are simply passing the <kbd>Address</kbd> object into the constructor, which is then assigned to the <kbd>Address</kbd> property of the composite class <kbd>Student</kbd>.</p>
<p>The next confusion is what is the difference then? Let me explain. The <kbd>Address</kbd> property is declared inside the composite class gets created/destroyed like other members. But inside the constructor, we are assigning an external <kbd>Address</kbd> object to it. That means the composite class does not have any control over that incoming external object.</p>
<p>The <kbd>Student</kbd> class initialization will also be altered as follows:</p>
<pre>    static void Main(string[] args)
    {
      Address add = new Address("Dhenkanal");
      Student pallu = new Student(1, "Pallavi Praharaj", <br/>        new DateTime(1990, 6, 12), add);
    }</pre>
<p>Let's analyze how this change can be considered as an Aggregation.</p>
<ul>
<li><strong>Rule 1: The part (member) is a component of the object (class)</strong>: The <kbd>Address</kbd> property is referenced inside the <kbd>Student</kbd> class. Thus, it becomes a part.</li>
<li><strong>Rule 2: The part (member) can belong to more than one object (class) at a time</strong>: I passed an <kbd>Address</kbd> object into the constructor, which is used inside the composite class, for further operation. However, the object <kbd>add</kbd> is pretty much independent as it is created by the routine (<kbd>Main</kbd>, as shown in the preceding code). Let me allow it to be used by another <kbd>Student</kbd> as well:</li>
</ul>
<pre>        static void Main(string[] args)
        {
          Address add = new Address("Nayagarh");
          Student rinu = new Student(1, "Jayashree Satapathy", <br/>            new DateTime(1995, 11, 14), add);    <br/>          Student gudy = new Student(2, "Lipsa Rath", <br/>            new DateTime(1995, 4, 23), add);<br/><br/>         rinu.PrintStudent();<br/>         gudy.PrintStudent();<br/>         Console.ReadKey();
       }</pre>
<p>I know you might have some reservations about whether this will work or not. Here is the output for you:</p>
<div><img height="109" width="365" src="img/d96c6715-c721-4cfb-8a68-133bc34fff36.png"/></div>
<p>Straightforward, isn't it! The <kbd>Main</kbd> method is the creator, so it can be used inside the scope anywhere till it is destroyed by it or by Garbage Collector. The <kbd>add</kbd> object is passed as a reference to both of the students. From these facts, we can infer that <kbd>Jayashree</kbd> and <kbd>Lipsa</kbd> and are two students who stay at the same address.</p>
<ul>
<li><strong>Rule 3: The part (member) does not have its existence managed by the object (class)</strong>: Since it is wrapped inside the <kbd>Main</kbd> method, the composite object can't destroy it. By the way, it did not create it either. It was <kbd>Main</kbd> who gave birth to that.</li>
<li><strong>Rule 4: The part (member) does not know about the existence of the object (class)</strong>: The <kbd>Address</kbd> object does not have any idea about these student objects. It is autonomous inside the <kbd>Main</kbd> block.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Composition versus Aggregation</h1>
                
            
            
                
<p>Now that we have explored both types of Object Composition, let's look at the differences:</p>
<table>
<tbody>
<tr>
<td>
<div><strong>Composition</strong></div>
</td>
<td>
<div><strong>Aggregation</strong></div>
</td>
</tr>
<tr>
<td>
<p>Generally, contains built-in type member variables</p>
<p>Manages member's creation and destruction</p>
</td>
<td>
<p>Generally contains reference variables which live out of the scope of the composite class</p>
<p>Does not manage member's creation and destruction</p>
</td>
</tr>
</tbody>
</table>
<p>While these concepts have such tiny but important differences, they can still be mixed up in a composite class. That means a <kbd>Student</kbd> class having simple parts like <kbd>Id</kbd>, <kbd>Name</kbd>, <kbd>Address</kbd>, and so on as an Aggregation will be treated as a mix of both these concepts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages and disadvantages</h1>
                
            
            
                
<p>In case of Composition, you have the control to manage those members as you like. However, they are not independent and you can't use them in other places.</p>
<p>Whereas in Aggregation, there is no control of the member's life and if you forget to destroy the member after creation, it will be a culprit of memory leaks.</p>
<p>While both of them have their own pros and cons, it is just a matter of deciding which one to use where, according to the scenario. Moreover, you can mix them up and do amazing things. For example, some properties like <kbd>Id</kbd>, <kbd>Name</kbd>, etc. are used exclusively inside the class, so ideally we won't reuse these properties anywhere in the application. Therefore, if you build another class with all these properties and reference (aggregate) in the first class, that becomes unnecessary because the other class has no such usage outside the first class.</p>
<p>On the other hand, when you identify that some properties that can be packed up as a subclass (<kbd>AddressId</kbd>, <kbd>Address</kbd>, <kbd>State</kbd>, <kbd>City</kbd>, <kbd>Country</kbd>, and so on), you might have a requirement in future to refer to that new subclass somewhere in the code. Better to aggregate that. Let the caller manage its lifetime. Just get that into your composite class and use as required and forget it's management.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other important relationships</h1>
                
            
            
                
<p>There are a few other relationships which you should be aware of. Unless you know these, you won't be able to visualize how objects typically work with each other.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Association</h1>
                
            
            
                
<p>So far we have completed two types of Object Composition, Composition, and Aggregation. Just to confirm that we are on the same page, Object Composition is used to package relationships into a complex object that is from one or more simpler objects (parts/members).</p>
<p>Now, we'll take a look at a type of relationship between two otherwise unrelated objects, called an <strong>Association</strong>. An Association is a bonding between two unrelated objects and they must satisfy the following conditions:</p>
<ul>
<li><strong>Object (member) associated is unrelated to the other object (class):</strong> Here the objects, which are going to be associated, are not related to the object. Rather than being a part of a complex object as in a composition or aggregation, it is totally independent in nature. For example, a <kbd>Teacher</kbd> and <kbd>Student</kbd> are two independent objects, but not contained in each other. These entities get associated with each other while in a class for lessons.</li>
<li><strong>Object (member) associated can belong to more than one object (class) at a time:</strong> Like aggregation, the associated object can belong to multiple objects at the same time. For example, a <kbd>Student</kbd> can be associated with many teachers and vice versa.</li>
<li><strong>Object (member) associated does not have its existence managed by the other object (class)</strong>: All aggregated objects are independent here. Everyone manages themselves. For example, neither <kbd>Teacher</kbd> is going to decide what a <kbd>Student</kbd> will do nor does the <kbd>Student</kbd> decides what the actions of the <kbd>Teacher</kbd> should be.</li>
<li><strong>Object (member) associated may or may not know about the existence of the object (class)</strong>: Association relationships might be unidirectional or bidirectional. That means the two associated objects may or may not know each other. We will get more clarification on this once we see the code snippet. For example, a <kbd>Student</kbd> may or may not recognize a <kbd>Teacher</kbd>.</li>
</ul>
<p>Association can be defined as <em>uses...a</em> relationship. The <kbd>Teacher</kbd> <em>uses</em> the <kbd>Student</kbd> to teach the lessons. The <kbd>Student</kbd> uses the <kbd>Teacher</kbd> to clarify doubts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Example</h1>
                
            
            
                
<p>Let's take an example of a cricket player and bat. Consider the following:</p>
<pre>    public class CricketPlayer
    {
      public string PlayerName { get; set; }

      public CricketPlayer(string name)
      {
        PlayerName = name;
      }

      public void Play(Bat bat)
      {
        bat.StartPlay(this);
      }

      public string GetPlayerName()
      {
        return PlayerName;
      }
    }

    public class Bat
    {
      public string BrandName { get; set; }

      public void StartPlay(CricketPlayer player)
      {
        // Do something with the player.
        Console.WriteLine("Player Named as " + player.PlayerName<br/>           + " is playing.");
        Console.ReadLine();
      }

      public string GetBrandName()
      {
        return "Some Brand Name";
      }
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Explanation of the preceding code</h1>
                
            
            
                
<p>We have two different classes, <kbd>CricketPlayer</kbd> and <kbd>Bat</kbd>. Now let me create the objects as follows:</p>
<pre>    var cPlayer = new CricketPlayer("Hardik Pandya");
    Bat bat = new Bat();

    cPlayer.Play(bat);
    bat.StartPlay(cPlayer);</pre>
<p>The output is as shown in the following screenshot:</p>
<div><img height="83" width="404" src="img/366514c2-bb00-4a94-9786-07d076c94e2b.png"/></div>
<p>The methods <kbd>Play</kbd> inside the <kbd>CricketPlayer</kbd> class and <kbd>StartPlay</kbd> inside the <kbd>Bat</kbd> class are the ones, which you should be concentrating on at this point. Both are taking a reference param pointing to the other class's object. The whole point of this type of relationship between the player and bat is the common cause of starting t0 play.</p>
<p>Let's look at the rules which this relationship follows.</p>
<ul>
<li><strong>Rule 1: Object (member) associated is unrelated to the other object (class)</strong>: Neither the bat relates to the player nor the player relates to the bat. But we will gradually see how they get associated.</li>
<li><strong>Rule 2: Object (member) associated can belong to more than one object (class) at a time:</strong> The bat can be used by many other players in the team, not just by one.</li>
<li><strong>Rule 3: Object (member) associated does not have its existence managed by the other object (class)</strong>: The player is not responsible for managing the bat. It is created even before the player comes to the team. Likewise, the bat is not going to give birth to or be the cause of death of a player unless the player hits himself with the bat, which is not going to happen.</li>
<li><strong>Rule 4: Object (member) associated may or may not know about the existence of the object (class)</strong>: The player knows about the bat as the bat is passed as an argument in the <kbd>Play</kbd> method. Similarly, the bat knows about the player as that got passed to the <kbd>StartPlay</kbd> method.</li>
</ul>
<p>If you understand cricket a little bit, you must know that a player uses a bat to bat. That means it depends on the bat object. The bat object, however, can be used by any batsman in the team, which leads to a <kbd>StartPlay</kbd> method in the <kbd>Bat</kbd> class. Obviously, the bat object needs to get associated with a player, which eventually commences the game.</p>
<p>Both of the objects depend on each other in order to start the game. They still exist as independent objects. Suppose, you don't call the <kbd>Play</kbd> and <kbd>StartPlay</kbd> method, nothing will change. The code will compile. That defines the association with each other for a common cause:</p>
<pre>    CricketPlayer cPlayer = new CricketPlayer("Hardik Pandya");
    Bat bat = new Bat();

    //cPlayer.Play(bat);
    //bat.StartPlay(cPlayer);
<br/>    Console.WriteLine($"Name of the Player is: { <br/>        cPlayer.GetPlayerName() }");<br/>    Console.WriteLine($"Brand of Bat is: { bat.GetBrandName() }");</pre>
<p>Here, I just commented out codes for play. That did not have any impact on the objects and they still exist. Then I used them to call other methods like <kbd>GetPlayerName</kbd> and <kbd>GetBrandName</kbd>.</p>
<div><img height="88" width="424" src="img/788af1ce-221c-4b96-8f6e-9ff2a7beb171.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of Association</h1>
                
            
            
                
<p>We have learned a bit about Association. However, there are different types and it would be handy for us to know about them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reflexive Association</h1>
                
            
            
                
<p class="mce-root">When two objects of the same type get associated, that association is called as <strong>Reflexive Association</strong>. Let's consider the class <kbd>Medicine</kbd>:</p>
<pre>    public class Medicine
    {
      public string Name { get; set; }
      public Medicine AlternateMedicine { get; set; }

      public Medicine(string name, Medicine altMedicine)
      {
        Name = name;
        AlternateMedicine = altMedicine;
      }   
    }</pre>
<p class="mce-root">This is very useful in many scenarios when we have dependencies of the same entity. We know that a medicine might have one alternate medicine, which again might have another alternate and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Indirect Association</h1>
                
            
            
                
<p>Association, when formed by other means and not directly between two objects, is called an <strong>Indirect Association</strong>. We will try to grasp this concept with the help of the following example:</p>
<pre>    public class SoftwareEngineer
    {
        public string Name { get; set; }
        public int LaptopId { get; set; }

        public SoftwareEngineer(string name, int laptopId)
        {
                Name = name;
                LaptopId = laptopId;
        }
     }

     public class Laptop
     {
        public int LaptopId { get; set; }
        public string LaptopName { get; set; }

        public Laptop(int id, string name)
        {
           LaptopId = id;
           LaptopName = name;
        }
      }

      public class AvailableLaptops
      {
        public static List&lt;Laptop&gt; Laptops { get; set; }
        static AvailableLaptops()
        {
          Laptops = new List&lt;Laptop&gt;
          {
            new Laptop(1, "Laptop1"),
            new Laptop(2, "Laptop2"),
            new Laptop(3, "Laptop3"),
            new Laptop(4, "Laptop4"),
          };
        }

        public static Laptop GetLaptop(int id)
        {
          return Laptops.Find(l =&gt; l.LaptopId == id);
        }
      }
      static void Main(string[] args)
      {
        SoftwareEngineer softEng = new SoftwareEngineer("Tworit Dash", 3);
        // Get the Laptop object from AvailableLaptops class by id.
        Laptop usedLaptop = AvailableLaptops.GetLaptop(3);
        Console.WriteLine(softEng.Name + " is using " + <br/>          usedLaptop.LaptopName);
        Console.ReadLine();
      }</pre>
<p>We have two classes named <kbd>SoftwareEngineer</kbd> and <kbd>Laptop</kbd> which are meant to be associated with each other. In this case, we are trying to relate them indirectly via a static class <kbd>AvailableLaptops</kbd> which has a list of <kbd>Laptop</kbd> objects containing their <kbd>Id</kbd> and <kbd>Name</kbd>.</p>
<p>Let's focus on the <kbd>Main</kbd> method now. A <kbd>SoftwareEngineer</kbd> is instantiated (<kbd>Name Tworit Dash</kbd> with a <kbd>LaptopId 3</kbd>). We need to print his name and the laptop name he is using. We have the <kbd>LaptopId</kbd>. If you closely look at the <kbd>AvailableLaptops</kbd> class, there is a static method <kbd>GetLaptop</kbd> which takes <kbd>laptopId</kbd> as an argument and then finds the laptop from the list it already has.</p>
<p>So, <kbd>Laptop usedLaptop = AvailableLaptops.GetLaptop(3);</kbd> would get us the required <kbd>Laptop</kbd> object which has ID <kbd>3</kbd> and <kbd>Name Laptop3</kbd>. Now, it is just a matter of printing the engineer's name and the name of the laptop returned by the static class:</p>
<div><img height="85" width="377" src="img/234d4192-1dbf-46a9-aca4-3b138a01321d.png"/></div>
<p>This is called <strong>Indirect Association</strong> because the association is established with the help of another class which can interact with a class and returns the results to another class requesting any data from the first class.</p>
<p>To summarise the relationships, let's do a quick recap.</p>
<p><strong>Composition:</strong></p>
<ul>
<li>Part of a complex class.</li>
<li>Members can't be a part of multiple classes.</li>
<li>Members are created and destroyed by a complex class.</li>
<li>Unidirectional: Members do not know about the complex object.</li>
<li><em>A part of</em> relationship</li>
</ul>
<p><strong>Aggregation:</strong></p>
<ul>
<li>Part of a complex class</li>
<li>Members can be a part of multiple classes</li>
<li>Members are neither created nor destroyed by a complex class</li>
<li>Unidirectional: Members do not know about the complex object</li>
<li><em>Has a</em> relationship</li>
</ul>
<p><strong>Association:</strong></p>
<ul>
<li>Classes are not related but require each other when needed</li>
<li>Associated members or objects can be used by multiple objects</li>
<li>Members are neither created or destroyed by a complex class</li>
<li>Unidirectional or Bidirectional: Objects may or may not know each other</li>
<li><em>Uses a</em> relationship</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Composition over Inheritance</h1>
                
            
            
                
<p>This topic is very interesting and is discussed online in many websites and blogs. As the topic headline says <strong>Composition is preferred over Inheritance</strong>, we need to understand why it is so important by identifying the problems. The better the design from the beginning of your software development, the better the maintainability and reuse.</p>
<p>Inheritance and Composition are two pillars of OOPs concepts. Unless they are used wisely according to your architecture, they will create problems in the future when you start adding complexity to your application.</p>
<p>We have already discussed Composition, now, let's discuss Inheritance before we move towards the main topic of discussion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inheritance</h1>
                
            
            
                
<p>As the name suggests, the act of acquiring or deriving some behavior from someone is called <strong>Inheritance</strong>. In the programming world, when a certain class is inherited from another class, it creates an Inheritance. Some basic examples are written as follows:</p>
<ul>
<li>A car <em>is a</em> vehicle. The vehicle has a certain behavior which the car acquires when it is built.</li>
<li>A rectangle <em>is a</em> shape.</li>
<li>An <kbd>HourlyEmployee</kbd> <em>is an</em> employee. A <kbd>MonthlyEmployee</kbd> <em>is an</em> employee too.</li>
<li>Chicken curry <em>is a</em> dish.</li>
</ul>
<p>Notice, they all have something in common. That is the phrase <em>is a</em>. Inheritance is defined as an <em>is a</em> relationship.</p>
<p>The car is a vehicle, but it might have a music system as well, which is not a common behavior of a vehicle. Thus, the derived or child classes can have their own behavior as well. <kbd>HourlyEmployee</kbd> and <kbd>MonthlyEmployee</kbd> are employees of a certain company who share many benefits from the company. However, their salary is not the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Example on User class</h1>
                
            
            
                
<p>Let's see how we can implement Inheritance.</p>
<pre>    public abstract class User
    {
        public int Id { get; set; }
        public int RoleId { get; set; }
        public string Name { get; set; }
        public string EmailId { get; set; }
        public string MobileNumber { get; set; }

        public int SaveUser(int userId)
        {
           // Database operation to save the user.
           return userId;
        }
      }

      public class Admin : User
      {
        public string CompanyDepartment { get; set; }
        public Admin()
        {
          RoleId = 1;
        }
      }

      public class Manager : User
      {
        public List&lt;TeamLead&gt; TeamLeads { get; set; }
        public Manager()
        {
          RoleId = 2;
        }
      }

      public class TeamLead : User
      {
        public List&lt;string&gt; Projects { get; set; }
        public TeamLead()
        {
          RoleId = 3;
        }
      }</pre>
<p>We have different types of users in our company such as <kbd>Admin</kbd>, <kbd>Manager</kbd>, <kbd>TeamLeads</kbd>, <kbd>HR</kbd>, and more. Although these entities are different, they have some properties in common. They must have an <kbd>Id</kbd>, <kbd>RoleId</kbd>, <kbd>Name</kbd>, <kbd>EmailId</kbd>, <kbd>MobileNumber</kbd>, and so on.</p>
<p>As they have common properties and behavior we make an abstract base class <kbd>User</kbd> which has all those declared inside it. We won't be instantiating this class, so it is restricted by using an abstract keyword. Every type of user is going to have some operation. The simplest operation is <kbd>SaveUser()</kbd>, which is defined inside the base class so that it will be available for all child classes.</p>
<p>In this example, we have different properties declared inside child classes as well.</p>
<p>Consider the following:</p>
<ul>
<li>Admin--<kbd>public string CompanyDepartment { get; set; }</kbd></li>
<li>Manager--<kbd>public List&lt;TeamLead&gt; TeamLeads { get; set; }</kbd></li>
<li>TeamLead--<kbd>public List&lt;string&gt; Projects { get; set; }</kbd></li>
</ul>
<p>We can also define different methods specific to them inside these child classes. When we try to create objects, or in other words, create an <kbd>Admin</kbd> and <kbd>Manager</kbd>, it will look something like as follows:</p>
<pre>    static void Main(string[] args)
    {
        Admin admin = new Admin()
        {
          Id = 12
        };
        admin.SaveUser(admin.Id);

        Manager manager = new Manager
        {
          Id = 13
        };
        manager.SaveUser(manager.Id);
         Console.WriteLine("Admin (Role Id: {0}) with UserId {1} <br/>            is saved", admin.RoleId, admin.Id);
        Console.WriteLine("Manager (Role Id: {0}) with UserId {1}<br/>            is saved", manager.RoleId, manager.Id);
    }</pre>
<p>You can see we are creating each type of user and then sending their IDs to the save method for further database processing. <kbd>RoleId</kbd> is assigned inside the constructors of each type of <kbd>User</kbd> class. This produces output as follows:</p>
<div><img height="86" width="440" src="img/095ed841-57ce-4638-903f-e14c08a99c8b.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">New User Type</h1>
                
            
            
                
<p>The company decides to have a new type of employee named  Delivery Manager, who will be having certain privileges, but not all. This role will take partial responsibilities from <kbd>Manager</kbd> as well as from <kbd>TeamLead</kbd>.</p>
<p>A Delivery Manager can <kbd>CreateProject</kbd> (like a TeamLead) and  ;<kbd>AssignProjectToTeamLead</kbd> (like a <kbd>Manager</kbd>). Also while doing all these, he/she can <kbd>SendNotificationToCto</kbd> which is a new method. So, those two methods will have additional codes which are not an exact copy from the  <kbd>Manager</kbd> and <kbd>TeamLead</kbd> classes:</p>
<div><img height="125" width="496" src="img/e6bad7a4-a498-4945-95b5-7839807fdeef.png"/></div>
<div><strong>Multiple Inheritance</strong> is a language-specific feature which enables a class to inherit features of more than one parent class. This feature can introduce complexities in the design and the supported languages have their own way of handling such scenarios. C#, Java, Swift etc. does not support Multiple Inheritance, but they allow implementing multiple protocols which are named <strong>Interfaces</strong>. I just wanted to show you that we have to go with some alternative approach to solve the problem in hand instead of inheriting from multiple classes as shown above, which is anyway not supported by C#.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Problem which we come across</h1>
                
            
            
                
<p>Visual Studio complains to me that I can't code like this, which is actually termed Multiple Inheritance. Moreover, when a company introduces more roles, the system gets complex to manage when we have responsibilities (methods) defined in each class. Because when we have to mix responsibilities for a certain user role, we will have to create duplicate codes that would have been already written in some class.</p>
<p>To explain what I'm saying, imagine a <kbd>Car</kbd> class, which gets inherited by classes like <kbd>Toyota</kbd>, <kbd>BMW</kbd>, <kbd>Volkswagen</kbd>, and more. For some reason, I got mad and brought both <kbd>Toyota</kbd> and <kbd>Volkswagen</kbd> to my workshop and then built a new brand out of them. I will name it VolksTaditToy. Please don't kill me for this name.</p>
<p>VolksTaditToy now has a combination of functions from both of these cars. But there is no way to deal with them in my program. Don't be so surprised, if you see more of such cars on the road because there is no scarcity of such fools in this world. Gradually your program will be in a situation where there is no escape.</p>
<p>How can we write this class with the concept of inheritance? Impossible right! Let's make that possible for our initial <kbd>User</kbd> problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The solution to the problem</h1>
                
            
            
                
<p>The composition is our savior here. Let's see how we can solve this problem using this relationship. We will introduce a <kbd>Role</kbd> class. Obvious right! <kbd>Manager</kbd>, <kbd>TeamLead</kbd>, and <kbd>DeliveryManager</kbd> are different roles played by employees:</p>
<pre>    public class Role
    {
        public int RoleId { get; set; }
        public string RoleName { get; set; }
    }</pre>
<p class="mce-root">Now every other user type class will derive from this class:</p>
<pre>    public class Admin : Role
    {
        public string CompanyDepartment { get; set; }
        public Admin()
        {
          RoleId = 1;
        }
    }

    public class Manager : Role
    {
        public List&lt;TeamLead&gt; TeamLeads { get; set; }
        public Manager()
        {
          RoleId = 2;
        }
    }
    public class TeamLead : Role
    {
        public List&lt;string&gt; Projects { get; set; }
        public TeamLead()
        {
          RoleId = 3;
        }
    }
    public class DeliveryHead : Role
    {
       public DeliveryHead()
        {
          RoleId = 4;
        }
    }</pre>
<p>Alright, what is the next step? The remaining class is <kbd>User</kbd>. We need to do a couple of modifications in that, shown as follows:</p>
<pre>    public class User
    {
        public int Id { get; set; }
        public List&lt;Role&gt; RoleIds { get; set; }
        public string Name { get; set; }
        public string EmailId { get; set; }
        public string MobileNumber { get; set; }

        public int SaveUser(int userId)
        {
           // Database operation to save the user.
           return userId;
        }
    }</pre>
<p class="mce-root">The first modification is to remove the abstract keyword because we will now create objects of this class. Next is to have a property <kbd>public List&lt;Role&gt; RoleIds { get; set; }</kbd> instead of <kbd>public int RoleId { get; set; }</kbd>. We did this to allow assigning multiple roles to a user/employee.</p>
<p>Observe, how we can create a user with multiple roles in the following main method:</p>
<pre>    static void Main(string[] args)
    {
        User deliveryManager = new User()
        {
            RoleIds = new List&lt;Role&gt;
            {
               new Manager(),
               new TeamLead()
            }
        };
        Console.WriteLine(string.Format("User has Roles:\n\n\t- <br/>           {0}", string.Join("\n\t- ", deliveryManager.RoleIds)));
    }</pre>
<p>While creating a <kbd>DeliveryManager</kbd> type of <kbd>User</kbd>, we are assigning multiple roles to the user by creating a list of <kbd>Manager</kbd> and <kbd>TeamLead</kbd> types. As they inherit from <kbd>Role</kbd> base class, so <kbd>RoleIds</kbd> recognize these types.</p>
<p class="mce-root">This piece of code produces the following output:</p>
<div><img height="137" width="415" src="img/5707a7e8-fbbb-4fbe-8ef6-3838aa1269af.png"/></div>
<p>We conclude that Composition takes over Inheritance in many of such cases. That means you need to be very careful when you start designing the classes. Otherwise, the situation will get worse in the future when your system grows as you will create a mess. You should definitely avoid duplicate codes. When you see that you are writing something which has already been written before, stop and think before you proceed. Try to normalize as much as possible at that moment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Role of Object Composition in Dependency Injection</h1>
                
            
            
                
<p>Now that we understand the concept of Object Composition, let's analyze an actual software project problem and how that can be trapped using Object Composition. In the process, we will find out the importance of this concept in a DI context:</p>
<pre>    class Mail
    {
      protected bool SendMail(string mailId, string message)
      {   
         // Logic to send an email
         return true;
      }
    }
    class Notification : Mail
    {
       void SendNotification(string mailId, string message)
       {
          SendMail(mailId, message);
       }
    }</pre>
<p>So, the <kbd>Notification</kbd> class is inheriting the <kbd>Mail</kbd> class, so that it can call <kbd>SendMail()</kbd>. This structure is not wrong, but it will create complications going forward.</p>
<p>Imagine another class for <kbd>Sms</kbd>, where we can have a method something like <kbd>SendSms()</kbd>. There is no way here for the <kbd>Notification</kbd> class to call that method as multiple inheritances is not possible.</p>
<p>To solve this problem, we can easily use Object Composition along with Dependency Injection. Let's alter the code first. This is shown as follows:</p>
<pre>    interface IMail
    {
        bool SendMail(string mailId, string message);
    }

    interface ISms
    {
        bool SendSms(string mobile, string message);
    }

    public class Mail : IMail
    {
       public bool SendMail(string mailId, string message)
       {
          // Logic to send an email
          Console.WriteLine("SendMail Called");
          return true;
       }
     }

     public class Sms : ISms
     {
        public bool SendSms(string mailId, string message)
        {
          // Logic to send a Sms
          Console.WriteLine("SendSms Called");
          return true;
        }
      }

      class Notification
      {
         private readonly IMail _mail;
         private readonly ISms _sms;

         public Notification(IMail mail, ISms sms)
         {
           _mail = mail;
           _sms = sms;
         }

        public void SendNotification(string mailId, string mobile,<br/>           string message)
        {
           _mail.SendMail(mailId, message);
           _sms.SendSms(mobile, message);
        }
      }</pre>
<p><kbd>IEmail</kbd> and <kbd>ISms</kbd> are interfaces which have <kbd>SendMail()</kbd> and <kbd>SendSms()</kbd> methods respectively. The next thing is to implement these interfaces in classes <kbd>Mail</kbd> and <kbd>Sms</kbd>. We will write our sending logic inside the methods implemented in these classes.</p>
<p>Notice the <kbd>Notification</kbd> class, which is not inheriting any class, rather it is referencing new interfaces. Then inside a parameterized constructor, we have <kbd>IMail</kbd> and <kbd>ISms</kbd> as arguments. The <kbd>SendNotification()</kbd> method now takes the necessary details like <kbd>mailId</kbd>, <kbd>mobile</kbd> and <kbd>message</kbd> to call the methods using the interfaces.</p>
<p>What's the advantage then? We wrote more code, didn't we? The point here is very interesting. If you look at the code to instantiate <kbd>Notification</kbd> class, you will get some hint. Let's look at that:</p>
<pre>    static void Main(string[] args)
    {
        Notification notify = new Notification(new Mail(),<br/>           new Sms());
        notify.SendNotification("taditdash@gmail.com", <br/>          "9132994288", "Hello Tadit!");
        Console.ReadLine();
    }</pre>
<p>Got the hint? Let me explain. We injected the <kbd>Mail</kbd> and <kbd>Sms</kbd> class instances into the <kbd>Notification</kbd> constructor which is assigned to the properties <kbd>_mail</kbd> and <kbd>_sms</kbd>. It would automatically call the methods inside <kbd>Mail</kbd> and <kbd>Sms</kbd> classes. So, we composed <kbd>Notification</kbd> class with <kbd>IMail</kbd> and <kbd>ISms</kbd> references. This is where Object Composition came into the picture along with Dependency Injection.</p>
<p>Suppose at some point in time you want to include another class for mail sending (something like <kbd>SmtpMail</kbd>). You just need to write that class implementing the same <kbd>IMail</kbd> interface and define the <kbd>SendMail</kbd> method. Bang, it's done. No need to make the <kbd>Notification</kbd> class dirty anymore. It will work as expected.</p>
<pre>    public class SmtpMail : IMail
    {
       public bool SendMail(string mailId, string message)
       {
          // Logic to send an email
          Console.WriteLine("SmtpMail Called");
          return true;
       }
    }
    static void Main(string[] args)
    {
        Notification notify = new Notification(new SmtpMail(),<br/>            new Sms());
        notify.SendNotification("taditdash@gmail.com", <br/>           "9132994288", "Hello Tadit!");
        Console.ReadLine();
    }</pre>
<p>As you can see, I just declared the new class and injected the object like <kbd>new SmtpMail()</kbd> instead of <kbd>new Mail()</kbd>. That is the only change. The rest will work as expected because I have injected the object instead of directly referencing it inside the <kbd>Notification</kbd> class.</p>
<p>To summarise, the following is what we achieved:</p>
<ul>
<li>We introduced flexibility through interfaces for concrete dependencies.</li>
<li>We can easily plug in new concrete class dependency just by implementing the interface abstraction.</li>
<li>We composed <kbd>Notification</kbd> object with the dependency objects just with one go.</li>
<li>We moved all initialization code to one place inside the <kbd>Main</kbd> method</li>
</ul>
<p>When I said we moved the initialization code to one place, that location is denoted as the <strong>Composition Root</strong> of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Composition Root</h1>
                
            
            
                
<p>Composition Root composes all the independent modules of the application. During runtime, Object Composition is the first thing that happens before any other operations. As soon as the object graph is wired up with dependencies, Object Composition is finished, then the components related to the application can take over. Object Composition should happen as close as possible to the application's entry point.</p>
<p>The entry points in .NET Core 2.0 Console App and ASP.NET Core 2.0 MVC app are the same and that is inside the <kbd>Main</kbd> method of the <kbd>Program.cs</kbd> class. .NET Core 2.0 Console App's <kbd>Main</kbd> method is clean, but on the other hand, ASP.NET Core 2.0 MVC has some bootstrapping codes inside the <kbd>Main</kbd> method. However, we usually write composition codes inside a <kbd>ConfigureServices</kbd> method which can be called inside the <kbd>Main</kbd> method.</p>
<p>When you do a File | New | Project | .NET Core | Console App (.NET Core) in Visual Studio 2017, you will see the following in the <kbd>Main</kbd> method:</p>
<pre>    namespace PacktConsoleApp<br/>    {<br/>      class Program<br/>      {<br/>        static void Main(string[] args)<br/>        {<br/><strong>          // We will do all Object Composition here directly or <br/>              calling a ConfigureServices method.</strong><br/>          Console.WriteLine("Hello World!");<br/>        }<br/>      }<br/>    }</pre>
<p>In the case of ASP.NET Core 2.0 MVC App, when you select  File | New | Project | Web | ASP.NET Core Web Application (in the next screen, select appropriate template), the template for Web Application generates the <kbd>Main</kbd> method in the <kbd>Program</kbd> class and <kbd>Startup</kbd> would look like the following:</p>
<div><img src="img/b43a5769-7a5c-4917-b9c0-ffc24875d597.png"/></div>
<p>The way we composed the <kbd>Notification</kbd> object in the last section is known as <strong>Poor Man's DI</strong>. Instead of doing that, we should apply DI Containers to compose and manage objects in that location.</p>
<p>Object Composition is the fundamental building block of DI and the easiest one to understand because we already know how to compose objects with many examples. Now it's time to learn what are the challenges we would face composing objects for DI due to the framework capabilities. The issues are related to a framework and nothing to do with the Object Composition concept. Let's find out in the upcoming sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Composing .NET Core 2.0 Console application</h1>
                
            
            
                
<p>Inside the <kbd>Main</kbd> method, we can easily compose objects with built-in DI Container. If you remember, we have already discussed that from container initialization, registration of objects to the container, resolving dependencies and then release the components from the container, everything should happen inside the Composition Root, which is considered as the <kbd>Main</kbd> method here.</p>
<p>Consider an example of the <kbd>Main</kbd> method inside a console application:</p>
<pre class="mce-root">    static void Main(string[] args)<br/>    {<br/>      // Setup container and register dependencies.<br/>      var serviceProvider = new ServiceCollection()<br/>      .AddTransient&lt;IEmployeeService, EmployeeService&gt;()<br/>      .BuildServiceProvider();<br/><br/>      // Get the service instance from the container and <br/>      do actual operation.<br/>      var emp = serviceProvider.GetService&lt;IEmployeeService&gt;();<br/>      emp.HelloEmployee();<br/><br/>      Console.ReadKey();<br/>    }</pre>
<p>This is simple code which leverages the extension method available, <kbd>Add***</kbd>, to register the dependency with the container. Then we used the <kbd>GetService</kbd> method to get the implemented type by the interface. With the instance, we then can do everything we want further in the application.</p>
<p>Recall that Composition Root is the place where we should do all operations related to Dependency Management. It's not recommended to use the <kbd>serviceProvider</kbd> outside the Composition Root or <kbd>Main</kbd> method to be specific. The same rule applies to ASP.NET Core MVC as well. We are going to explore that in a while.</p>
<p>You can, of course, introduce another method and you can name it <kbd>ConfigureServices</kbd> (shown as follows) for a cleaner code structure. You can give any name to the method, but this name resembles the name of the method specially dedicated in ASP.NET Core MVC app for dependency injection configurations as we saw in the picture in the last section. This new method added is shown in the following code snippet:</p>
<pre>    static void Main(string[] args)<br/>    {<br/><strong>      ConfigureServices(new ServiceCollection());</strong><br/>      Console.ReadKey();<br/>    }<br/><br/>    public static void ConfigureServices(IServiceCollection <br/>      serviceCollection)<br/>    {<br/>      // Setup container and register dependencies.<br/>      var serviceProvider = serviceCollection<br/>      .AddTransient&lt;IEmployeeService, EmployeeService&gt;()<br/>      .BuildServiceProvider();<br/><br/>      // Get the service instance from the container and<br/>         do actual operation.<br/>      var emp = serviceProvider.GetService&lt;IEmployeeService&gt;();<br/>      emp.HelloEmployee();<br/>    }</pre>
<p>Notice that we are not manually releasing the objects or the container. The reason is that release is automatically handled by the DI Container according to the life style you decide. <kbd>AddTransient</kbd>, <kbd>AddSingleton</kbd> and <kbd>AddScoped</kbd> are readily available methods which helps to perform different types of lifetime for the objects. We will explore more about Object Lifetime in <a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank">Chapter 6</a>, <em>Object Lifetime</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object Composition in ASP.NET Core MVC 2.0</h1>
                
            
            
                
<p>Like Console Application, we can follow the same procedure to deal with dependencies inside ASP.NET Core MVC 2.0 apps. Unlike the console app, the <kbd>Main</kbd> method inside the <kbd>Program.cs</kbd>, in this case, is populated with default codes to initiate the MVC App with required configurations. It is that location from which it instructs the framework to load the Startup class. The <kbd>host</kbd> inside the <kbd>Main</kbd> method executes the <kbd>Startup</kbd> class <kbd>ConfigureServices</kbd> method.</p>
<p>ASP.NET Core MVC is designed to be DI-friendly. But it does not force you to apply DI always. To deal with dependencies in ASP.NET MVC, we can take the Poor Man's DI approach to manually manage them or leverage built-in/third party DI Container's technique to register, resolve, and release dependencies. Let's dive a little deep into the controller initiation process and see if we find anything useful.</p>
<p>The heart of MVC lies in controllers. Controllers handle requests, process them, and return the response back to the client. Thus, the controllers should delegate their responsibility to the other modules as required. That means the controller will refer to other classes for certain tasks. It will use the <kbd>new</kbd> keyword for the dependency object creation inside the action methods, which we can easily avoid as we are using DI Container. With the dependency injection technique, we should be able to inject dependencies into the controllers with Constructor Injection.</p>
<p><kbd>IControllerFactory</kbd> is an interface inside <kbd>Microsoft.AspNetCore.Mvc.Controllers</kbd> namespace which enables us to create and release controllers. The interface contains two methods, shown as follows:</p>
<pre>    namespace Microsoft.AspNetCore.Mvc.Controllers<br/>    {<br/>      /// &lt;summary&gt;<br/>      /// Provides methods for creation and disposal of controllers.<br/>      /// &lt;/summary&gt;<br/>      public interface IControllerFactory<br/>      {<br/>        object <strong>CreateController</strong>(ControllerContext context);<br/>        void <strong>ReleaseController</strong>(ControllerContext context,<br/>         object controller);<br/>      }<br/>    }</pre>
<p>ASP.NET Core MVC 2.0 ships with a <kbd>DefaultControlFactory</kbd> which implements this interface. Let's have a look at the source code:</p>
<pre>    namespace Microsoft.AspNetCore.Mvc.Controllers<br/>    {<br/>      /// &lt;summary&gt;<br/>      /// Default implementation for &lt;see cref="IControllerFactory"/&gt;.<br/>      /// &lt;/summary&gt;<br/>      public class DefaultControllerFactory : IControllerFactory<br/>      {<br/>        private readonly IControllerActivator _controllerActivator;<br/>        private readonly IControllerPropertyActivator[]<br/>            _propertyActivators;<br/><strong>        public DefaultControllerFactory(</strong><br/><strong>            IControllerActivator controllerActivator,</strong><br/><strong>            IEnumerable&lt;IControllerPropertyActivator&gt; propertyActivators)</strong><br/>            {<br/>              if (controllerActivator == null)<br/>              {<br/>                throw new ArgumentNullException(nameof(<br/>                 controllerActivator));<br/>              }<br/><br/>              if (propertyActivators == null)<br/>               {<br/>                throw <br/>                  new ArgumentNullException(nameof(propertyActivators));<br/>               }<br/><br/>               _controllerActivator = controllerActivator;<br/>               _propertyActivators = propertyActivators.ToArray();<br/>            }<br/>            public virtual object CreateController<br/>              (ControllerContext context)<br/>            {<br/>               // Codes removed just for book.<br/>                   You can find codes in Github.<br/>             }<br/><br/>             public virtual void ReleaseController(ControllerContext<br/>               context, object controller)<br/>            {<br/>              // Codes removed just for book. You can<br/>                  find codes in Github.<br/>            }<br/>      }<br/>    }</pre>
<p><kbd>DefaultControllerFactory</kbd> has a constructor injection with the required dependencies for the <kbd>ControllerActivator</kbd> and <kbd>PropertyActivators</kbd>. Thus, this factory is composed of activators. Like a factory, there is an interface for <kbd>Activator</kbd> also named <kbd>IControllerActivator</kbd>. There are providers for Factory and Activators named <kbd>ControllerFactoryProvider</kbd> and <kbd>ControllerActivatorProvider</kbd> respectively.</p>
<p>Now, the most important part. The Object Composition of these factories is actually done inside the <kbd>AddMvcCore()</kbd> method of class <kbd>MvcServiceCollectionExtensions</kbd> which stays inside <kbd>namespace</kbd> <kbd>Microsoft.Extensions.DependencyInjection</kbd>. The <kbd>namespace</kbd> name contains <kbd>DependencyInjection</kbd>, which itself gives us a hint that we are going to do some injection for sure to initiate these activators and factories. Let's see a snapshot of the <kbd>AddMvcCoreServices()</kbd> method ( which is another method called from <kbd>AddMvcCore()</kbd>) responsible for composing all required dependencies for controller activation and initialization:</p>
<div><img src="img/e5e5e48a-e6fa-4263-8628-a0a148146ea7.png"/></div>
<p>You can see how the interfaces are registered as the concrete classes. This method contains many other service registrations for all the background work needed for the controller process. But we got an idea about how Object Composition is implemented inside the framework itself.</p>
<p>If we want to design our own custom controller factory, we can do that as well by registering the required factory and provider inside this method for initiation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter touched upon important relationships between objects in programming. We created very basic classes and tried to grasp the concepts. Then we moved our focus to Object Composition, and it's types, Composition, and Aggregation.</p>
<p>Moreover, we discussed Association. With code examples and outputs, we saw how these relationships matter a lot while coding.</p>
<p>Finally, we were introduced to Inheritance with an example. Once we completed all these, we moved towards a very important saying <em>Composition over Inheritance</em>. This is a real-time issue which developers face while applying new requirements to existing class structures.</p>
<p>Then, we discussed the important role played by Object Composition in Dependency Injection. Also, we saw how this pattern is followed in ASP.NET Core MVC 2.0.</p>
<p>It's time to see how objects are created, how they live and are then destroyed in <a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank">Chapter 6</a>, <em>Object Lifetime</em>. We will relate the object lifetime with what we already know from this chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>