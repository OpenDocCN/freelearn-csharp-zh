- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Managing Application Settings
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序设置
- en: In the dynamic world of web applications, the ability to adapt to different
    environments and requirements is crucial. ASP.NET Core 9 provides a robust configuration
    system that allows developers to manage settings and behavior effectively. This
    chapter will explore the importance of application settings, how to manage them
    using the configuration system, and how to make your applications adaptable at
    runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态的Web应用程序世界中，适应不同环境和要求的能力至关重要。ASP.NET Core 9提供了一个健壮的配置系统，允许开发者有效地管理设置和行为。本章将探讨应用程序设置的重要性，如何使用配置系统来管理它们，以及如何使应用程序在运行时具有适应性。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Understanding **IConfiguration** concepts and abstractions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**IConfiguration**概念和抽象
- en: Working with configuration providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与配置提供者一起工作
- en: Learning about the Options pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Options模式
- en: Working with dynamic configurations and behaviors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与动态配置和行为一起工作
- en: ASP.NET Core 9 provides a robust configuration system that allows developers
    to effectively manage configurations and behaviors. This chapter will explore
    the importance of application configurations, how to manage them using the configuration
    system, and how to make your applications adaptive at runtime.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9提供了一个健壮的配置系统，允许开发者有效地管理配置和行为。本章将探讨应用程序配置的重要性，如何使用配置系统来管理它们，以及如何使应用程序在运行时具有适应性。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持本章的学习，以下工具必须存在于您的开发环境中：
- en: '**Docker** : The Docker engine must be installed on your operating system and
    have a SQL Server container running. You can find more details about Docker and
    SQL Server containers in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：必须在您的操作系统上安装Docker引擎，并运行一个SQL Server容器。您可以在[*第5章*](B21788_05.xhtml#_idTextAnchor078)中找到有关Docker和SQL
    Server容器的更多详细信息。'
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：此工具将用于执行对开发应用程序API的请求。'
- en: '**Redis Insight** : This tool is used to connect to a Redis server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis Insight**：此工具用于连接到Redis服务器数据库（[https://redis.io/insight/](https://redis.io/insight/)）。'
- en: You will also need access to an Azure subscription.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要访问Azure订阅。
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码示例可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09)
- en: Understanding IConfiguration concepts and abstractions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解IConfiguration概念和抽象
- en: In the dynamic world of web applications, the ability to adapt to different
    environments and requirements is crucial, in addition to security requirements
    that have become increasingly essential in applications that run on different
    cloud providers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态的Web应用程序世界中，适应不同环境和要求的能力至关重要，除了在运行在不同云提供商上的应用程序中越来越重要的安全要求之外。
- en: Most web applications have some type of configuration managed in files or classes,
    in order to centralize parameters that are used throughout the application flow.
    With each change in configurations or even application behaviors, a new version
    of the software must be generated. Furthermore, when working with remote teams,
    it is essential to maintain the correct management of configurations and sensitive
    data and not keep these parameters versioned in the application version control.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序都会在文件或类中管理某种类型的配置，以便集中管理整个应用程序流程中使用的参数。随着配置或甚至应用程序行为的每次更改，都必须生成新的软件版本。此外，当与远程团队合作时，维护配置和敏感数据的正确管理至关重要，并且不要将这些参数版本化在应用程序版本控制中。
- en: ASP.NET Core 9 provides powerful ways to manage application configurations in
    addition to enabling the use of other features, such as changing application behaviors
    without the need to generate new versions of the software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9提供了强大的方式来管理应用程序配置，除了启用使用其他功能外，例如，无需生成新版本的软件即可更改应用程序行为。
- en: We will start learning about these resources via the fundamentals of configuration
    management through the **IConfiguration** interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过**IConfiguration**接口配置管理的基础知识来开始学习这些资源。
- en: IConfiguration interface
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IConfiguration接口
- en: ASP.NET Core 9 has the **IConfiguration** interface, which aims to provide a
    mechanism for managing application settings and configurations in a unified manner,
    allowing access to diverse configuration sources such as JSON files, environment
    variables, and arguments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9拥有**IConfiguration**接口，旨在提供一种以统一方式管理应用程序设置和配置的机制，允许访问诸如JSON文件、环境变量和参数等不同的配置来源。
- en: 'Among the main concepts regarding the **IConfiguration** interface, we have
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于**IConfiguration**接口的主要概念中，我们有以下几点：
- en: '**Configuration sources** : Support multiple configuration sources, which can
    be combined and layered. Common sources include JSON files (such as **appsettings.json**
    ), environment variables, command-line arguments, and user secrets.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置来源**：支持多个配置来源，可以组合和分层。常见的来源包括JSON文件（如**appsettings.json**）、环境变量、命令行参数和用户密钥。'
- en: '**Hierarchical configuration** : Configuration settings are organized in a
    hierarchical structure. This means that settings can be nested into sections,
    making complex settings easier to manage.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层配置**：配置设置以分层结构组织。这意味着设置可以嵌套到部分中，使得复杂的设置更容易管理。'
- en: '**Options pattern** : The Options pattern uses **IConfiguration** to bind configuration
    settings to strongly typed objects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Options模式**：Options模式使用**IConfiguration**将配置设置绑定到强类型对象。'
- en: 'In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we used the **appsettings.json**
    file to manage the connection string with the SQL Server database and retrieved
    the value of this configuration through the **IConfiguration** interface, in the
    **Program.cs** class. This practice brings several benefits, such as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B21788_05.xhtml#_idTextAnchor078)中，我们使用了**appsettings.json**文件来管理与SQL
    Server数据库的连接字符串，并通过**IConfiguration**接口在**Program.cs**类中检索了该配置的值。这种做法带来了以下好处：
- en: '**Flexibility** : **IConfiguration** allows you to extract configuration values
    from multiple sources, offering flexibility in how you manage configurations across
    different environments (development, test, production)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：**IConfiguration**允许您从多个来源提取配置值，在如何管理不同环境（开发、测试、生产）中的配置方面提供了灵活性'
- en: '**Centralized management** : Centralizes configuration management, making it
    easier to maintain and update settings without spreading them across the application'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中管理**：集中配置管理，使得在不分散到整个应用程序的情况下维护和更新设置变得更加容易'
- en: '**Environment-specific settings** : Supports environment-specific configuration,
    allowing you to customize settings based on the environment in which the application
    is running'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境特定设置**：支持环境特定配置，允许您根据应用程序运行的环境自定义设置'
- en: '**Strongly typed configuration** : Through the Options pattern, it supports
    configuration settings linked to strongly typed classes, improving type safety
    and reducing errors'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强类型配置**：通过Options模式，它支持与强类型类链接的配置设置，提高类型安全并减少错误'
- en: 'The following code examples demonstrate a configuration defined in the **appsettings.json**
    file; this value is then retrieved through the **IConfiguration** interface, in
    the **Program.cs** file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了在**appsettings.json**文件中定义的配置；然后通过**Program.cs**文件中的**IConfiguration**接口检索此值：
- en: 'The following is the content of the **appsettings.json** file:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为**appsettings.json**文件的内容：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the content of the **Program.cs** file:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为**Program.cs**文件的内容：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in the highlighted line of the previous code snippet, the connection
    string is obtained from the **appsettings.json** file using the **IConfiguration**
    interface, using the **GetConnectionString** method and informing the configuration
    name or key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码片段中突出显示的行所示，连接字符串是通过**IConfiguration**接口使用**GetConnectionString**方法从**appsettings.json**文件中获取的，并告知配置名称或键。
- en: As the **IConfiguration** lifecycle considers the application lifecycle, all
    the complexity of obtaining settings through files such as **appsettings.json**
    or other data sources is abstracted, simply using the methods available in the
    interface to obtain the desired parameters throughout the ASP.NET Core 9 application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **IConfiguration** 生命周期考虑了应用程序生命周期，因此通过诸如 **appsettings.json** 或其他数据源之类的文件获取设置的复杂性都被抽象化，只需使用接口中可用的方法在整个
    ASP.NET Core 9 应用程序中获取所需的参数即可。
- en: The **IConfiguration** interface is also available in the **dependency injection
    container** ( **DIC** ), allowing you to reference it in the constructor of any
    application class that will have its dependencies resolved dynamically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**IConfiguration** 接口也存在于 **依赖注入容器**（**DIC**）中，允许您在任何将动态解决其依赖关系的应用程序类的构造函数中引用它。'
- en: IConfiguration methods
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: IConfiguration 方法
- en: 'The **IConfiguration** interface provides several extension methods that offer
    different ways to obtain configuration data in ASP.NET Core 9 applications. See
    the following link for more details: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0)
    .'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**IConfiguration** 接口提供了几个扩展方法，这些方法以不同的方式在 ASP.NET Core 9 应用程序中获取配置数据。有关更多详细信息，请参阅以下链接：[https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0)。'
- en: The process of obtaining configurations in JSON files is a standard model for
    use in ASP.NET Core 9 applications. However, there are other ways of managing
    configurations, and for this possibility, there is the concept of providers, which
    we will explore in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 文件中获取配置的过程是 ASP.NET Core 9 应用程序中使用的标准模型。然而，还有其他管理配置的方法，为此可能性，存在提供程序的概念，我们将在下一节中探讨。
- en: Working with configuration providers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与配置提供程序一起工作
- en: Configuration providers allow configurations to be obtained from various sources,
    such as JSON files, environment variables, and more.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 配置提供程序允许从各种来源获取配置，例如 JSON 文件、环境变量等。
- en: Through configuration providers, we have greater flexibility and the ability
    to prepare our applications to run in different environments (such as development,
    test, or production) in an appropriate way without the need to implement string
    replacement logic in JSON files, in addition to bringing greater reliability and
    security.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置提供程序，我们获得了更大的灵活性，并且能够以适当的方式准备我们的应用程序在不同的环境中（如开发、测试或生产）运行，无需在 JSON 文件中实现字符串替换逻辑，这除了带来更高的可靠性和安全性之外。
- en: Next, we will understand how to add other configuration providers to our ASP.NET
    Core 9 applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何将其他配置提供程序添加到我们的 ASP.NET Core 9 应用程序中。
- en: Adding configuration providers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加配置提供程序
- en: Configuration providers are used to read configuration data from various sources.
    This flexibility allows you to manage your application’s configuration settings
    in a consistent and centralized manner.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 配置提供程序用于从各种来源读取配置数据。这种灵活性允许您以一致和集中的方式管理应用程序的配置设置。
- en: This makes it possible to use configuration sources such as databases and even
    cloud services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用数据库甚至云服务等配置源成为可能。
- en: 'In ASP.NET Core 9, there are already some configuration providers integrated
    by default, such as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中，已经集成了某些配置提供程序，例如以下内容：
- en: '**JSON configuration provider** : Reads configuration data from JSON files
    such as **appsettings.json**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON 配置提供程序**：从类似于 **appsettings.json** 的 JSON 文件中读取配置数据。'
- en: '**Environment variable configuration provider** : Reads configuration data
    from environment variables'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量配置提供程序**：从环境变量中读取配置数据。'
- en: '**Command-line configuration provider** : Reads configuration data from command-line
    arguments'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行配置提供程序**：从命令行参数中读取配置数据。'
- en: '**Memory configuration provider** : Allows you to add in-memory configuration
    data, useful for unit testing'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存配置提供程序**：允许您添加内存中的配置数据，这对于单元测试非常有用。'
- en: 'During the implementation of example applications in this book, we have constantly
    used the following method in the **Program.cs** file: **WebApplication.CreateBuilder(args);**
    .'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中实现示例应用程序的过程中，我们一直在 **Program.cs** 文件中使用以下方法：**WebApplication.CreateBuilder(args);**。
- en: This method creates an instance of a **Builder** object, which represents a
    web application and allows us to add features such as services, middleware, and
    configurations. It creates a web application builder with some default parameters,
    so there is no need to define the provider configuration to obtain configuration
    data from the **appsettings.json** file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建了一个 **Builder** 对象的实例，它代表一个 Web 应用程序，并允许我们添加诸如服务、中间件和配置等功能。它创建了一个具有一些默认参数的
    Web 应用程序构建器，因此无需定义提供程序配置即可从 **appsettings.json** 文件中获取配置数据。
- en: Default builder settings
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构建器设置
- en: 'The **CreateBuilder** method defines some standardized parameters for the builder
    that will be created. You can learn more about these parameters by accessing the
    following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings)
    .'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreateBuilder** 方法定义了将要创建的构建器的一些标准化参数。您可以通过访问以下网址了解这些参数的更多信息：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings)。'
- en: 'However, observe the following code example from the **Program.cs** file where
    configuration providers are explicitly added:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意以下来自 **Program.cs** 文件的代码示例，其中显式添加了配置提供程序：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code uses two extension methods, **AddEnvironmentVariables** and
    **AddCommandLine** , allowing the application to obtain configurations from different
    providers. These extension methods are natively part of ASP.NET Core 9 applications.
    For other types of providers, it may be necessary to add NuGet packages to have
    access to extension methods for registering providers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了两个扩展方法，**AddEnvironmentVariables** 和 **AddCommandLine**，允许应用程序从不同的提供程序中获取配置。这些扩展方法是
    ASP.NET Core 9 应用程序的原生部分。对于其他类型的提供程序，可能需要添加 NuGet 包以访问用于注册提供程序的扩展方法。
- en: Built-in ASP.NET Core 9 configuration providers
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 ASP.NET Core 9 配置提供程序
- en: 'ASP.NET Core 9 offers several types of providers natively, as presented in
    the documentation: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers)
    .'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 提供了多种类型的提供程序，如文档中所示：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers)。
- en: In the *Working with dynamic configurations and behaviors* section, we will
    use a provider to connect to a cloud resource that allows the management of configurations
    and behaviors in a dynamic and secure way. For now, let’s understand some important
    fundamentals, such as creating custom providers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用动态配置和行为* 部分，我们将使用提供程序连接到一个允许以动态和安全方式管理配置和行为的云资源。现在，让我们了解一些重要基础，例如创建自定义提供程序。
- en: Creating a custom configuration provider
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义配置提供程序
- en: Creating a custom configuration provider in ASP.NET Core 9 allows you to load
    configuration data from sources not natively supported by the framework. This
    can be useful for integrating with custom configuration stores, third-party services,
    or even proprietary formats.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中创建自定义配置提供程序允许您从框架未原生支持的源加载配置数据。这对于与自定义配置存储、第三方服务或甚至专有格式集成非常有用。
- en: We already understand configuration management in native provisions in ASP.NET
    Core 9; now, we will create our first custom provider.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了 ASP.NET Core 9 中原生配置管理；现在，我们将创建我们的第一个自定义提供程序。
- en: 'To create a custom provider, you need to create two classes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个自定义提供程序，您需要创建两个类：
- en: '**ConfigurationSource** : The **IConfigurationSource** interface represents
    a source of configuration data. It is responsible for creating an instance of
    **IConfigurationProvider** , which will actually load the data. Separating the
    source and provider interfaces allows for a clear delineation between where configuration
    data comes from and how it is loaded. Through this approach, we benefit from encapsulating
    data source configurations and implementing best practices through the **Factory**
    pattern.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConfigurationSource**：**IConfigurationSource** 接口代表配置数据的来源。它负责创建一个 **IConfigurationProvider**
    实例，该实例将实际加载数据。将源接口和提供者接口分离，可以明确区分配置数据的来源和加载方式。通过这种方法，我们可以从封装数据源配置和通过 **Factory**
    模式实现最佳实践中受益。'
- en: '**ConfigurationProvider** : The **ConfigurationProvider** class is an abstract
    base class that implements **IConfigurationProvider** . It is responsible for
    the actual loading and providing of configuration data. This class allows you
    to define how data is read, cached, and accessed.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConfigurationProvider**：**ConfigurationProvider** 类是一个实现 **IConfigurationProvider**
    的抽象基类。它负责实际加载数据和提供配置数据。这个类允许你定义如何读取、缓存和访问数据。'
- en: 'We will start creating a custom provider through the class responsible for
    creating a custom provider instance:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过负责创建自定义提供者实例的类开始创建自定义提供者：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **IConfigurationSource** interface has only one method, **Build()** , which
    is responsible for returning a custom provider instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**IConfigurationSource** 接口只有一个方法，**Build()**，它负责返回一个自定义提供者实例。'
- en: Despite being simple, this class allows for better separation of responsibilities,
    with the sole objective of providing an instance of the provider that will have
    all the necessary mechanisms for interacting with another data source.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个类很简单，但它允许更好地分离职责，其唯一目标是提供一个提供者实例，该实例将具有与另一个数据源交互所需的所有必要机制。
- en: 'Now, let’s look at the **CustomConfigurationProvider** class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 **CustomConfigurationProvider** 类：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The custom provider implemented in the preceding code has an inheritance from
    the abstract **ConfigurationProvider** class, which already has some utility implementations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中实现的自定义提供者继承自抽象的 **ConfigurationProvider** 类，该类已经有一些实用实现。
- en: For this provider, we are creating two configurations that will be managed by
    an object of type **Dictionary<string, string>** , allowing us to create configurations
    based on key and value in memory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个提供者，我们正在创建两个将由 **Dictionary<string, string>** 类型的对象管理的配置，允许我们根据键和值在内存中创建配置。
- en: The logic for managing provided information must be implemented by overriding
    the **Load** method, inherited from the **ConfigurationProvider** class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 管理提供信息的逻辑必须通过覆盖从 **ConfigurationProvider** 类继承的 **Load** 方法来实现。
- en: At the end of the **Load** method, it is necessary to set the value of the **Data**
    property, also inherited from the **ConfigurationProvider** class. The data type
    of the **Data** property is **Dictionary<string, string?>** ; that is, representing
    a key-value pair. Settings are persisted or serialized in string format. However,
    even with this feature, it is possible to create strongly typed configurations.
    We will cover this approach in the *Learning the Options* *pattern* section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Load** 方法的末尾，有必要设置从 **ConfigurationProvider** 类继承的 **Data** 属性的值。**Data**
    属性的数据类型是 **Dictionary<string, string?>**；即表示键值对。设置以字符串格式持久化或序列化。然而，即使有这个功能，也可以创建强类型配置。我们将在
    *学习选项* *模式* 部分介绍这种方法。
- en: Of course, this is a simple and didactic example. However, we can easily connect
    the custom provider to a SQL Server database, a storage account, or any other
    persistence resource. In the book’s code repository, the link to which is in the
    *Technical requirements* section, you can analyze another version of a custom
    provider where the data is persisted in a database. However, the implementation
    principles are the same as those demonstrated in the previous code snippets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简单且具有教育意义的例子。然而，我们可以轻松地将自定义提供者连接到 SQL Server 数据库、存储账户或任何其他持久化资源。在本书的代码仓库中，其链接位于
    *技术要求* 部分，你可以分析另一个自定义提供者的版本，其中数据在数据库中持久化。然而，实现原则与之前代码片段中演示的相同。
- en: 'For the new provider to be used, simply add the following code to the **Program.cs**
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新的提供者，只需将以下代码添加到 **Program.cs** 文件中：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also use the extension method creation technique learned in [*Chapter
    8*](B21788_08.xhtml#_idTextAnchor132) .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用在[*第8章*](B21788_08.xhtml#_idTextAnchor132)中学到的扩展方法创建技术。
- en: 'To obtain the settings through the new provider, simply use **Configuration**
    property methods, such as the **GetValue<T>** method, and rename the desired configuration,
    as demonstrated in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过新的提供者获取设置，只需使用**Configuration**属性方法，例如**GetValue<T>**方法，并将所需的配置重命名，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the creation of a custom provider does not change the development
    model already available in ASP.NET Core 9, bringing greater flexibility and possibilities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，创建自定义提供者不会改变ASP.NET Core 9中已有的开发模型，带来了更大的灵活性和可能性。
- en: Providers are an excellent abstraction for configuration management. However,
    ASP.NET Core 9 provides other types, such as the Options pattern, which we will
    discuss in the next section, making the configuration management model in our
    applications even more powerful.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者是配置管理的优秀抽象。然而，ASP.NET Core 9提供了其他类型，例如选项模式，我们将在下一节中讨论，这使得我们应用程序中的配置管理模型更加强大。
- en: Learning the Options pattern
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习选项模式
- en: ASP.NET Core 9 offers a good way to handle application configurations through
    the use of the Options pattern. This pattern provides a robust mechanism for managing
    and accessing configuration settings in a strongly typed manner, improving the
    maintainability and testability of your code and organizing configuration settings
    into classes. In this section, we will understand what the Options pattern is
    and how to implement it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9通过使用选项模式提供了一种处理应用程序配置的好方法。此模式提供了一种强大的机制，以强类型方式管理和访问配置设置，提高代码的可维护性和可测试性，并将配置设置组织到类中。在本节中，我们将了解选项模式是什么以及如何实现它。
- en: What is the Options pattern?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项模式是什么？
- en: Every application must interact with some type of configuration, and in the
    previous chapters, we used the **IConfiguration** interface to obtain continuous
    information in the **appsettings.json** file. However, this is not the only way
    to interact with configurations in ASP.NET Core 9, which offers an implementation
    of the Options pattern.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都必须与某种类型的配置进行交互，在前面的章节中，我们使用了**IConfiguration**接口从**appsettings.json**文件中获取连续信息。然而，这并不是在ASP.NET
    Core 9中与配置交互的唯一方式，它提供了一个选项模式的实现。
- en: The Options pattern is a design pattern that uses classes to represent groups
    of related configurations, allowing you to link configuration sections from various
    configuration sources (such as JSON files, environment variables, and so on) to
    these classes, allowing access to configuration settings, type-safe configuration,
    leveraging IntelliSense, and compile-time checking.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 选项模式是一种设计模式，它使用类来表示相关配置的组，允许您将来自各种配置源（如JSON文件、环境变量等）的配置部分链接到这些类，从而允许访问配置设置、类型安全的配置、利用IntelliSense和编译时检查。
- en: 'In ASP.NET Core 9, the Options pattern has the following class hierarchy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 9中，选项模式具有以下类层次结构：
- en: '![Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9](img/B21788_09_01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – ASP.NET Core 9中主选项模式抽象](img/B21788_09_01.jpg)'
- en: Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – ASP.NET Core 9中主选项模式抽象
- en: 'As we can see in *Figure 9* *.1* , there are several interfaces for abstracting
    the Options pattern, in addition to their respective implementations. Let’s briefly
    understand the purpose of each of the interfaces represented in *Figure 9* *.1*
    :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9.1*所示，除了它们各自的实现之外，还有几个接口用于抽象选项模式。让我们简要了解*图9.1*中展示的每个接口的目的：
- en: '**IOptions<T>** : The basic interface used to retrieve configured options.
    **IOptions<T>** types are registered as singletons. Then, when starting the application,
    the configurations are loaded into memory and made available throughout the application
    using **dependency injection** ( **DI** ). However, if any changes are made to
    the application so that they can be reflected, the application must be restarted.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IOptions<T>**：用于检索配置选项的基本接口。**IOptions<T>**类型注册为单例。然后，当启动应用程序时，配置被加载到内存中，并通过**依赖注入**（**DI**）在整个应用程序中提供。但是，如果对应用程序进行了任何更改，以便它们可以反映出来，则必须重新启动应用程序。'
- en: '**IOptionsSnapshot<T>** : A variation of **IOptions<T>** that provides a mechanism
    that updates configurations with each request. This interface allows application
    settings to be updated in real time. The lifecycle of this class is scoped; that
    is, the configurations are loaded with each request.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IOptionsSnapshot<T>**：**IOptions<T>**的一个变体，它提供了一种机制，可以在每次请求时更新配置。此接口允许实时更新应用程序设置。此类的生命周期是作用域的；也就是说，配置是在每次请求时加载的。'
- en: '**IOptionsMonitor<T>:** An interface that allows you to monitor option changes
    and provides a way to receive notifications when options are updated. The lifecycle
    of this interface is singleton, available when the application is initialized.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IOptionsMonitor<T>**：一个接口，允许您监控选项更改，并提供在选项更新时接收通知的方式。此接口的生命周期是单例的，在应用程序初始化时可用。'
- en: Classes that do not have the “ **I** ” prefix represent the concrete implementation
    of each interface.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有带有“**I**”前缀的类代表每个接口的具体实现。
- en: The Options pattern offers an excellent option for manipulating configurations
    without the need to call strings but by creating strongly typed configurations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 选项模式提供了一个优秀的选项，可以在不调用字符串的情况下操作配置，通过创建强类型配置。
- en: Let’s understand how the Options pattern is implemented.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解选项模式是如何实现的。
- en: Implementing the Options pattern
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现选项模式
- en: As we learned throughout the book’s chapters, it is a good practice to centrally
    manage configuration information, and in most of the code available in this book,
    we use basic configurations, such as a database connection string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本书的章节中所学，集中管理配置信息是一个好的实践，在这本书中大部分的代码中，我们使用基本的配置，例如数据库连接字符串。
- en: Although the **IConfiguration** interface provides us with mechanisms for obtaining
    configurations, in some cases, this can affect the management and responsibilities
    of each class, which must know exactly the strings it wants to obtain from the
    configuration file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**IConfiguration**接口为我们提供了获取配置的机制，但在某些情况下，这可能会影响每个类的管理和职责，每个类必须确切知道它想要从配置文件中获取的字符串。
- en: There are practices such as the use of constants; however, working with strongly
    typed classes to aggregate a set of information can be a powerful resource.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些做法，例如使用常量；然而，使用强类型类来聚合一组信息可以是一种强大的资源。
- en: 'Let’s imagine the following context:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象以下上下文：
- en: 'Imagine an e-commerce application, where we have different services and resources
    such as payment and shipping. These resources have a set of distinct settings.
    In this example, we would have approximately the following configurations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个电子商务应用程序，其中我们拥有不同的服务和资源，如支付和运输。这些资源有一套独特的设置。在这个例子中，我们可能会有以下配置：
- en: '**PaymentGatewayURL** : URL of the gateway responsible for processing the payment'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaymentGatewayURL**：处理支付的网关的URL'
- en: '**APIKey** : API key for using the payment gateway'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APIKey**：用于使用支付网关的API密钥'
- en: '**Timeout** : Timeout configuration'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Timeout**：超时配置'
- en: '**DefaultCarrier** : Default carrier for delivering orders'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefaultCarrier**：交付订单的默认承运人'
- en: '**FreeShippingThreshold** : Free shipping threshold setting'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FreeShippingThreshold**：免费运输阈值设置'
- en: 'When developing the e-commerce application, for each configuration, it would
    be necessary to use the **IConfiguration** class to obtain data from the **appsettings.json**
    file, for example. Let’s look at the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发电子商务应用程序时，对于每个配置，可能需要使用**IConfiguration**类从**appsettings.json**文件中获取数据，例如。让我们看看以下代码：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding settings would be available in the **appsettings.json** file
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述设置在**appsettings.json**文件中的表示如下：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The implementation of the settings recovery code demonstrated is correct. However,
    in more complex scenarios, it may be difficult to manage different types of configurations;
    there may be code duplications, which makes maintenance difficult, and if there
    is a typing error in the configuration key, for example, this problem will only
    be detected at runtime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的设置恢复代码实现是正确的。然而，在更复杂的场景中，可能难以管理不同类型的配置；可能会有代码重复，这使得维护变得困难，如果在配置键中存在类型错误，例如，这个问题只有在运行时才会被发现。
- en: Fortunately, through the abstraction of the Options pattern in ASP.NET Core
    9, we have the possibility of grouping configurations in a simple way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过ASP.NET Core 9中选项模式的抽象，我们可以以简单的方式对配置进行分组。
- en: 'Based on the preceding example, we basically have two types of information:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的例子，我们基本上有两种类型的信息：
- en: '**PaymentSettings**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaymentSettings**'
- en: '**PaymentGatewayURL**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaymentGatewayURL**'
- en: '**APIKey**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APIKey**'
- en: '**Timeout**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Timeout**'
- en: '**ShipmentSettings**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ShipmentSettings**'
- en: '**DefaultCarrier**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefaultCarrier**'
- en: '**FreeShippingThreshold**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FreeShippingThreshold**'
- en: 'This way, we could group the configurations into two distinct classes, as shown
    in *Figure 9* *.2* :'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以将配置分组到两个不同的类中，如图 *图 9.2* 所示：
- en: '![Figure 9.2 – Grouping configurations](img/B21788_09_02.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 分组配置](img/B21788_09_02.jpg)'
- en: Figure 9.2 – Grouping configurations
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 分组配置
- en: 'The preceding classes only have the properties that will reference the respective
    configurations in a grouped manner. With this, we will have the following code
    defining **PaymentSettings** and **ShipingmentSettings** classes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类仅具有将分别以分组方式引用相应配置的属性。有了这个，我们将有如下代码来定义 **PaymentSettings** 和 **ShipingmentSettings**
    类：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The classes represented in the preceding code only aim to abstract a set of
    configurations, not having any types of implemented behaviors, but there may be
    methods if necessary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中代表的类仅旨在抽象化一组配置，没有实现任何类型的操作行为，但在必要时可能会有方法。
- en: 'However, the classes that will be used in the Options pattern must follow the
    following rules:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将在 Options 模式中使用的类必须遵循以下规则：
- en: Being non-abstract
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非抽象
- en: Having public read-and-write properties
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有公共读写属性
- en: Fields are disregarded during binding
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定时忽略字段
- en: 'For this example, we will just keep the properties. Additionally, we will change
    the **appsettings.json** file, which will have the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们只保留属性。此外，我们还将修改 **appsettings.json** 文件，它将包含以下代码：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see in the preceding code that the settings are grouped by **PaymentSettings**
    and **ShippingSettings** , which are exactly the names of the classes, and respectively,
    the properties also have the same names.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的代码中看到，设置是通过 **PaymentSettings** 和 **ShippingSettings** 分组的，这些名称正好是类的名称，相应的属性也具有相同的名称。
- en: The Options pattern uses this convention to bind the settings with the class
    that will abstract this information in the application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Options 模式使用此约定将设置与将在应用程序中抽象此信息的类绑定。
- en: 'Now, let’s look at the **Program.cs** file with the changes made to use the
    Options pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看经过修改以使用 Options 模式的 **Program.cs** 文件：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see in the highlighted code lines in the preceding code block, the
    **GetSection** method is used from the **IConfiguration** interface, accessed
    through the **Configuration** extension method. The **GetSection** method is a
    generic implementation, where the type entered determines the return type. The
    name of the section is entered as a parameter, which, in this case, is the desired
    configuration group.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码块中高亮显示的代码行所示，这里使用了来自 **IConfiguration** 接口的 **GetSection** 方法，通过 **Configuration**
    扩展方法进行访问。**GetSection** 方法是一个泛型实现，其中输入的类型决定了返回的类型。章节名称作为参数输入，在这个例子中，是期望的配置组。
- en: Extension methods
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法
- en: In the preceding code example, to facilitate understanding, we are registering
    the configuration classes using the Options pattern directly in the **Program.cs**
    file. However, it is good practice to create an extension method for registering
    classes that use the Options pattern.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，为了便于理解，我们直接在 **Program.cs** 文件中使用 Options 模式注册配置类。然而，创建一个用于注册使用 Options
    模式的类的扩展方法是一种良好的实践。
- en: When executing these methods, the settings will be loaded into a **PaymentSettings**
    or **ShipmentSettings** object and these will be instantiated as a singleton and
    available in every application through the DIC.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这些方法时，设置将被加载到 **PaymentSettings** 或 **ShipmentSettings** 对象中，并且这些对象将作为单例实例化，并在每个应用程序中通过
    DIC 可用。
- en: 'The following is an example of code where the configurations depend on a given
    service class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例显示了配置依赖于给定的服务类：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we noted in the **OrderService** implementation, we just injected an **IOptions**
    interface for the **PaymentSettings** type. With this, the dependency is resolved
    by the ASP.NET Core 9 DIC.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 **OrderService** 实现中注意到的，我们只是注入了 **IOptions** 接口用于 **PaymentSettings**
    类型。通过这种方式，依赖关系由 ASP.NET Core 9 DIC 解决。
- en: Adopting the Options pattern offers several benefits, such as allowing the organization
    of configuration settings, grouping them into dedicated classes, and the use of
    strongly typed configuration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 Options 模式提供了几个好处，例如允许组织配置设置，将它们分组到专用类中，并使用强类型配置。
- en: In addition to improving maintenance and implementation quality, errors can
    also be detected during compilation time. You can also benefit from using unit
    tests, which is an excellent practice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提高维护和实施质量外，在编译时也可以检测到错误。您还可以从使用单元测试中受益，这是一个非常好的实践。
- en: The Options pattern in ASP.NET Core 9 is a powerful and flexible way to manage
    configuration settings, supporting environment-specific configurations and making
    it easier to manage configurations for different deployment environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9中的选项模式是一种强大且灵活的方式来管理配置设置，支持特定环境的配置，并使管理不同部署环境的配置变得更加容易。
- en: Now that we have learned how to use the Options pattern to properly deal with
    application configurations, it is time to understand how to manage these configurations
    securely in a cloud environment, in addition to learning how to dynamically manipulate
    behaviors in our applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用选项模式来正确处理应用程序配置，现在是时候了解如何在云环境中安全地管理这些配置，以及学习如何在我们的应用程序中动态地操作行为。
- en: Working with dynamic configurations and behaviors
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与动态配置和行为一起工作
- en: In the ever-evolving landscape of web applications, maintaining flexibility
    and responsiveness is crucial. As developers, we must ensure that our applications
    can adapt to changes quickly and securely. Dynamic configurations and behavior
    management are key strategies that allow us to achieve this flexibility. By managing
    configurations dynamically, we can update them without redeploying our applications.
    Additionally, by implementing application behavior management using techniques
    such as **feature toggles** , we can control resource availability in real time,
    giving us the ability to effortlessly test, deploy, or roll back features.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断发展的Web应用程序领域，保持灵活性和响应性至关重要。作为开发者，我们必须确保我们的应用程序能够快速且安全地适应变化。动态配置和行为管理是允许我们实现这种灵活性的关键策略。通过动态管理配置，我们可以更新它们而无需重新部署我们的应用程序。此外，通过使用**功能开关**等技术实现应用程序行为管理，我们可以实时控制资源可用性，从而轻松测试、部署或回滚功能。
- en: Feature toggles
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关
- en: Feature toggles or feature flags are a software development technique used to
    enable or disable specific functionality in a software application at runtime,
    facilitating **continuous integration and delivery** ( **CI/CD** ) by allowing
    code changes to be merged into the main code base without immediately exposing
    new functionality to all users. This technique helps in mitigating risks, conducting
    A/B testing, performing canary releases, and rolling back features without redeploying
    the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关或功能标志是一种软件开发技术，用于在运行时启用或禁用软件应用程序中的特定功能，通过允许代码更改合并到主代码库而不立即向所有用户暴露新功能，从而促进**持续集成和交付**（**CI/CD**）。这项技术有助于降低风险、进行A/B测试、执行金丝雀发布以及在不重新部署代码的情况下回滚功能。
- en: 'Access the following article to learn more about the technique: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下文章了解更多关于这项技术的信息：[https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)
- en: Let’s delve into the details of dynamic configuration management and implement
    a practical example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解动态配置管理的细节，并实现一个实际示例。
- en: Working with dynamic settings
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与动态设置一起工作
- en: Dynamic settings refer to the ability to modify application configurations at
    runtime without the need for redeployment. This capability is essential for maintaining
    application uptime, ensuring quick responses to changes in requirements, and enhancing
    security by allowing rapid adjustments to sensitive configurations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 动态设置指的是在运行时修改应用程序配置的能力，无需重新部署。这种能力对于保持应用程序正常运行、确保对需求变化的快速响应以及通过允许对敏感配置的快速调整来增强安全性至关重要。
- en: 'Modern applications must have dynamic configuration management mechanisms to
    guarantee the quality of the solution, in addition to benefits such as the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序必须具备动态配置管理机制，以确保解决方案的质量，以及以下好处：
- en: '**Zero downtime** : Update configurations without redeploying the application,
    ensuring continuous availability. This is an important feature that allows us
    to bring reliability and a better experience to users.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机时间**：在不重新部署应用程序的情况下更新配置，确保持续可用。这是一个重要的功能，使我们能够为用户提供可靠性和更好的体验。'
- en: '**Security** : Quickly update security settings and credentials in response
    to threats.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：快速更新安全设置和凭据以应对威胁。'
- en: '**Flexibility** : Adjust settings in real time to accommodate changing business
    requirements.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：实时调整设置以适应不断变化的企业需求。'
- en: '**Simplified deployments** : Reduce the complexity and risk associated with
    application deployments by decoupling configuration changes from code changes.
    In scenarios with many environments, such as development, testing, and production,
    the application will have different configurations based on the resources of each
    environment. Having the ability to abstract the management of application configurations
    improves quality, segregates responsibilities, and maintains continuous delivery
    flow.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化部署**：通过将配置更改与代码更改解耦，减少与应用程序部署相关的复杂性和风险。在具有许多环境（如开发、测试和生产）的场景中，应用程序将根据每个环境的资源具有不同的配置。能够抽象管理应用程序配置的能力可以提高质量、分离责任并保持持续交付流程。'
- en: Several options are available to dynamically manage configurations in ASP.NET
    Core 9, including configuration files, environment variables, and cloud-based
    services such as **Azure App Configuration** . Azure App Configuration stands
    out for its robust features and seamless integration with other Azure services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中，有几种选项可以动态管理配置，包括配置文件、环境变量和基于云的服务，如 **Azure App Configuration**。Azure
    App Configuration 以其强大的功能和与其他 Azure 服务的无缝集成而脱颖而出。
- en: Azure App Configuration is a service that provides a centralized way to manage
    configuration settings and feature flags. It allows applications to dynamically
    adjust their behavior without redeployment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Configuration 是一种提供集中式管理配置设置和功能标志的服务。它允许应用程序在不重新部署的情况下动态调整其行为。
- en: Azure App Configuration
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Configuration
- en: Azure App Configuration is a powerful feature available in Microsoft Azure that
    allows us to manage configurations and feature toggles securely, supporting the
    deployment of cloud-native applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Configuration 是 Microsoft Azure 中的一项强大功能，允许我们安全地管理配置和功能开关，支持云原生应用程序的部署。
- en: 'For more details about Azure App Configuration, I suggest reading the rich
    documentation about the resource: [https://learn.microsoft.com/en-us/azure/azure-app-configuration/](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)
    .'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Azure App Configuration 的更多详细信息，我建议阅读关于该资源的丰富文档：[https://learn.microsoft.com/en-us/azure/azure-app-configuration/](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)。
- en: We won’t cover all the details of setting up and using Azure App Configuration
    in this book. For now, we will use the main resources to exemplify the use of
    dynamic configurations in our applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会涵盖设置和使用 Azure App Configuration 的所有细节。目前，我们将使用主要资源来举例说明在我们的应用程序中使用动态配置。
- en: Let’s create an application that interacts with Azure App Configuration and
    uses some patterns already learned in this chapter, such as the Options pattern.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个与 Azure App Configuration 交互并使用本章已学到的某些模式（如 Options 模式）的应用程序。
- en: Setting up Azure App Configuration
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Azure App Configuration
- en: Azure App Configuration is a cloud-based service that provides a centralized
    repository for application configurations, enabling dynamic configuration management.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Configuration 是一种基于云的服务，为应用程序配置提供集中式存储库，实现动态配置管理。
- en: Let’s create an Azure App Configuration resource before creating an application.
    You will need access to an Azure subscription, as described in the *Technical*
    *requirements* section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序之前，让我们创建一个 Azure App Configuration 资源。您需要访问 Azure 订阅，如 *技术要求* 部分所述。
- en: 'With access to the Azure subscription, follow these steps to create an Azure
    App Configuration resource:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问 Azure 订阅后，按照以下步骤创建 Azure App Configuration 资源：
- en: 'Navigate to the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ), and in the search field, in the top bar, type **App Configuration** and click
    on the icon, as highlighted in *Figure 9* *.3* :'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Azure 门户（[https://portal.azure.com](https://portal.azure.com)），在顶部栏的搜索字段中输入
    **App Configuration** 并点击图标，如图 *图 9* *.3* 所示：
- en: '![Figure 9.3 – Accessing the App Configuration service](img/B21788_09_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 访问 App Configuration 服务](img/B21788_09_03.jpg)'
- en: Figure 9.3 – Accessing the App Configuration service
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 访问 App Configuration 服务
- en: 'On the next screen, click on the **+ Create** option to add the new resource,
    as shown in *Figure 9* *.4* :'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，点击 **+ 创建** 选项以添加新资源，如图 *图 9* *.4* 所示：
- en: '![Figure 9.4 – Creating a new App Configuration resource](img/B21788_09_04.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 创建新的应用配置资源](img/B21788_09_04.jpg)'
- en: Figure 9.4 – Creating a new App Configuration resource
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 创建新的应用配置资源
- en: 'On the next screen, we must configure the parameters of the new resource. We
    will keep the default settings. Use the following parameter suggestions as a reference:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，我们必须配置新资源的参数。我们将保持默认设置。以下参数建议仅供参考：
- en: '**Resource group** : **rg-aspnetcore8** . Be sure to click the **Create new**
    button below the **Resource group** field to create the new resource group.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源组**：**rg-aspnetcore8**。务必点击**资源组**字段下方的**创建新**按钮以创建新的资源组。'
- en: '**Location** : **East** **US 2**'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：**东** **US 2**'
- en: '**Resource name** : **<Your** **Last Name>-configuration**'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源名称**：**<您的** **姓氏>-配置**'
- en: '**Pricing** **tier** : **Standard**'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价层**：**标准**'
- en: Leave the **Create replicas** option unchecked.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不勾选**创建副本**选项。
- en: Click on the **Review + Create** button then the **Create** button, and wait
    for the resource to be created.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**审阅 + 创建**按钮然后点击**创建**按钮，等待资源创建完成。
- en: 'When you finish creating the new resource, click the **Go to resource** button,
    as shown in *Figure 9* *.5* , or access the **App Configuration** list, as described
    in *step 1* , and click on the created resource:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成创建新资源后，点击**转到资源**按钮，如图*图9* *.5*所示，或者按照*步骤1*所述访问**应用配置**列表，然后点击创建的资源：
- en: '![Figure 9.5 – New App Configuration creation status](img/B21788_09_05.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 新应用配置创建状态](img/B21788_09_05.jpg)'
- en: Figure 9.5 – New App Configuration creation status
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 新应用配置创建状态
- en: Now that we have the configuration management resource created, it’s time to
    create and configure our application to interact with Azure App Configuration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了配置管理资源，是时候创建和配置我们的应用程序以与Azure应用配置交互了。
- en: Creating and connecting an application in Azure App Configuration
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Azure应用配置中创建和连接应用程序
- en: For this example, an ASP.NET Core 9 MVC application will be created and connected
    to the Azure App Configuration service created previously.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，将创建一个ASP.NET Core 9 MVC应用程序，并将其连接到之前创建的Azure应用配置服务。
- en: 'Follow these steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Open the terminal, and in a folder of your choice, create a directory named
    **DynamicConfiguration** :'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并在您选择的文件夹中创建一个名为**DynamicConfiguration**的目录：
- en: '[PRE13]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, access the directory with the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令访问目录：
- en: '[PRE14]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the following command to create the application:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建应用程序：
- en: '[PRE15]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous command creates an MVC application with the name **DynamicConfiguration**
    , defined with the **-n** parameter and in the current directory, determined by
    the **–o .** parameter.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个名为**DynamicConfiguration**的MVC应用程序，使用**-n**参数定义，并在当前目录中，由**–o .**参数确定。
- en: 'With the application created, we will simply prepare it to integrate with Azure
    App Configuration. To do this, run the following command in the application directory
    to open Visual Studio Code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建后，我们将简单地准备它以集成到Azure应用配置中。为此，在应用程序目录中运行以下命令以打开Visual Studio Code：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, in the root of the project, create an **Options** folder and then create
    a file called **GlobalOptions.cs** . This file must contain the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录下创建一个**Options**文件夹，然后创建一个名为**GlobalOptions.cs**的文件。此文件必须包含以下代码：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The **GlobalOptions** class has only one property called **Title** that will
    be obtained through Azure App Configuration.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**GlobalOptions**类只有一个名为**Title**的属性，它将通过Azure应用配置获取。'
- en: When the application starts, it loads the settings as we learned previously,
    using files such as **appsettings.json** and environment variables, among other
    providers that can be configured. However, for our classes, the details of obtaining
    the configurations are abstracted by ASP.NET Core 9, and, in this case, whatever
    the provider, when using the Options pattern, we will have the correct separation
    of responsibility, maintainability, flexibility, and extensibility.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它会加载我们之前学到的设置，使用诸如**appsettings.json**和环境变量等文件，以及其他可以配置的提供者。然而，对于我们的类，获取配置的细节被ASP.NET
    Core 9抽象化，在这种情况下，无论提供者如何，当使用Options模式时，我们将拥有正确的职责分离、可维护性、灵活性和可扩展性。
- en: 'Let’s change the code of the **HomeController** class, in the **Controllers**
    folder, and add the settings previously created using the Options pattern. The
    **HomeController** class code will look like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改**HomeController**类在**Controllers**文件夹中的代码，并添加之前使用 Options 模式创建的设置。**HomeController**类的代码将如下所示：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Simple changes were made to the class. Let’s understand each of them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对类进行了简单的更改。让我们了解每个更改：
- en: '**GlobalOptions field** : A new field was created for the class that is of
    type **GlobalOptions** , created previously'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GlobalOptions 字段**：为类创建了一个新字段，该字段类型为之前创建的**GlobalOptions**。'
- en: '**Change in the constructor** : Configurations will be injected through the
    ASP.NET Core 9 DIC, and that is why we added a parameter of type **IOptionsSnapshot<GlobalSettings>**
    . The purpose of using the **IOptionsSnapshot<>** interface is to allow you to
    obtain configurations dynamically, as we learned in the *What is the Options pattern?*
    section. If another interface is used, such as **IOptions<>** , the parameters
    will be loaded, but not dynamically.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数中的更改**：配置将通过 ASP.NET Core 9 依赖注入容器（DIC）注入，这就是为什么我们添加了一个类型为**IOptionsSnapshot<GlobalSettings>**的参数。使用**IOptionsSnapshot<>**接口的目的是允许你动态地获取配置，正如我们在*什么是
    Options 模式？*部分中学到的。如果使用其他接口，例如**IOptions<>**，参数将被加载，但不是动态的。'
- en: '**Changing the Index action** : We change the **Index** action where we set
    the value of the **Title** property in the **ViewData** dictionary with the value
    of the configuration of the **Title** property of the **_globalOptions** object.
    The **ViewData["Title"]** dictionary is used in the **Views/Home/Index.cshtml**
    file to display the page title.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改 Index 动作**：我们更改**Index**动作，在该动作中，我们使用**_globalOptions**对象的**Title**属性的配置值设置**ViewData**字典中**Title**属性的值。**ViewData["Title"]**字典在**Views/Home/Index.cshtml**文件中使用，用于显示页面标题。'
- en: 'Now, let’s change the code on the **Views/Home/Index.cshtml** page to display
    the title in the body of the page:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将**Views/Home/Index.cshtml**页面的代码进行更改，以便在页面主体中显示标题：
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As can be seen in the highlighted code, we are only rendering the value contained
    in the **ViewData["Title"]** dictionary.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如高亮代码所示，我们只渲染**ViewData["Title"]**字典中包含的值。
- en: The application is prepared to render data obtained through configuration. Now,
    it’s time to connect the application to Azure App Configuration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已准备好通过配置渲染数据。现在，是时候将应用程序连接到 Azure App Configuration 了。
- en: 'First, open the terminal in the application directory and run the following
    command to add the NuGet package that contains the necessary SDK:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在应用程序目录中打开终端，并运行以下命令以添加包含必要 SDK 的 NuGet 包：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you will need to get the connection string containing the resource from
    Azure App Configuration. Let’s execute the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要从 Azure App Configuration 获取包含资源的连接字符串。让我们执行以下步骤：
- en: Access the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Azure 门户（[https://portal.azure.com](https://portal.azure.com)）。
- en: In the search field, in the top bar of the portal, type **App Configuration**
    and click on the option.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在门户顶部的搜索字段中，输入**App Configuration**并单击该选项。
- en: Then, in the list of configuration resources, click on the previously created
    resource with the name **<Your** **Last Name>-configuration** .
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在配置资源列表中，单击之前创建的名为**<Your** **Last Name>-configuration**的资源。
- en: 'In the side menu, look for the **Access settings** option and copy the connection
    string as shown in *Figure 9* *.6* :'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边菜单中，查找**访问设置**选项，并复制如*图 9* *.6* 所示的连接字符串：
- en: '![Figure 9.6 – Getting the connection string from App Configuration](img/B21788_09_06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 从 App Configuration 获取连接字符串](img/B21788_09_06.jpg)'
- en: Figure 9.6 – Getting the connection string from App Configuration
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 从 App Configuration 获取连接字符串
- en: 'Now, run the following command in the terminal, in the application directory.
    The command uses a secret manager to store a secret named **ConnectionStrings:AppConfig**
    , which stores the connection string for your App Configuration store. Replace
    the **<your_connection_string>** placeholder with your App Configuration store’s
    connection string. This is a good practice to prevent sensitive data, such as
    connection strings that are credentials or have passwords, from being persisted
    in version control, bringing vulnerabilities to your application:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中运行以下命令，在应用程序目录下。该命令使用密钥管理器存储一个名为**ConnectionStrings:AppConfig**的密钥，该密钥存储
    App Configuration 存储的连接字符串。将**<your_connection_string>**占位符替换为您的 App Configuration
    存储的连接字符串。这是一种良好的做法，可以防止敏感数据，如包含凭据或密码的连接字符串，在版本控制中持久化，从而给应用程序带来漏洞：
- en: '[PRE21]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the definition of the secret that contains the App Configuration connection
    string, we will change the **Program.cs** file to add the necessary services and
    middleware. Let’s look at the changed **Program.cs** code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义包含 App Configuration 连接字符串的密钥后，我们将修改**Program.cs**文件以添加必要的服务和中间件。让我们看看修改后的**Program.cs**代码：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The App Configuration SDK has excellent abstraction and is simple to integrate
    into the application. Let’s understand the changes made to the preceding code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: App Configuration SDK 具有出色的抽象性，并且易于集成到应用程序中。让我们了解对前面代码所做的更改：
- en: '**builder.Services.AddAzureAppConfiguration()** : This method registers the
    necessary services for Azure App Configuration to work within your ASP.NET Core
    9 application.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Services.AddAzureAppConfiguration()**：此方法注册了 Azure App Configuration
    在您的 ASP.NET Core 9 应用程序中工作所需的服务。'
- en: '**builder.Configuration.GetConnectionString("AppConfig")** : This line of code
    gets the Azure Application Configuration connection string, previously obtained
    from the Azure portal and added to the application via a secret. Note that getting
    the connection string is identical to getting it from **the appsettings.json**
    file. The big difference in managing configurations through secrets is that they
    are only kept on the local machine.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Configuration.GetConnectionString("AppConfig")**：这一行代码获取 Azure 应用程序配置连接字符串，之前从
    Azure 门户获取并通过密钥添加到应用程序中。请注意，获取连接字符串与从**appsettings.json**文件获取相同。通过密钥管理配置的主要区别在于，它们仅在本地计算机上保留。'
- en: '**builder.Configuration.AddAzureAppConfiguration** : This extension method
    adds Azure App Configuration as a configuration provider to your application.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Configuration.AddAzureAppConfiguration**：这个扩展方法将 Azure App Configuration
    添加为应用程序的配置提供者。'
- en: '**options.Connect(connectionString)** : Connects to the Azure application configuration
    instance using the previously obtained connection string.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options.Connect(connectionString)**：使用之前获得的连接字符串连接到 Azure 应用配置实例。'
- en: '**.Select("Dynamic Configuration:*", LabelFilter.Null)** : Specifies that all
    keys with the **DynamicConfiguration:** prefix should be selected. The **LabelFilter.Null**
    parameter indicates that only unlabeled configurations are retrieved.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.Select("Dynamic Configuration:*", LabelFilter.Null)**：指定选择所有以**DynamicConfiguration:**前缀开头的键。**LabelFilter.Null**参数表示只检索未标记的配置。'
- en: '**.ConfigureRefresh** : The **ConfigureRefresh** method registers keys that
    you want to monitor for changes in your application configuration store.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.ConfigureRefresh**：**ConfigureRefresh**方法注册了您想要监控其更改的应用程序配置存储中的键。'
- en: '**refreshOptions.Register("Dynamic Configuration", updateAll: true)** : Registers
    a sentinel key ( **DynamicConfiguration:Sentinel** ) that triggers an update.
    When the value of this key changes, all settings will be updated ( **refreshAll:
    true** ).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refreshOptions.Register("Dynamic Configuration", updateAll: true)**：注册一个哨兵键（**DynamicConfiguration:Sentinel**），它将触发更新。当此键的值发生变化时，所有设置都将更新（**refreshAll:
    true**）。'
- en: '**builder.Services.Configure<GlobalOptions>(builder.Configuration.GetSection("DynamicConfiguration:
    GlobalOptions"))** : This line of code binds the configuration created in Azure
    App Configuration and the **GlobalOptions** class created previously. With this,
    it will be possible to obtain the configuration through the DIC using the Options
    pattern.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Services.Configure<GlobalOptions>(builder.Configuration.GetSection("DynamicConfiguration:
    GlobalOptions"))**：这一行代码将之前在 Azure App Configuration 中创建的配置与之前创建的**GlobalOptions**类绑定。通过这种方式，可以使用
    Options 模式通过依赖注入容器（DIC）获取配置。'
- en: '**UseAzureAppConfiguration** : Allows your application to use the application
    configuration middleware to update configuration automatically.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UseAzureAppConfiguration**：允许应用程序使用应用程序配置中间件自动更新配置。'
- en: In summary, the previous configurations, added to the **Program.cs** file, allow
    the application to connect to Azure App Configuration via the connection string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，之前添加到 **Program.cs** 文件中的配置允许应用程序通过连接字符串连接到 Azure App Configuration。
- en: The App Configuration SDK works with the concept of pooling. In this case, when
    obtaining the configurations, a cache is made in the application’s memory, to
    avoid constant requests to the Azure service and optimize the application’s functioning.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 应用配置 SDK 与池化概念一起工作。在这种情况下，在获取配置时，在应用程序的内存中创建一个缓存，以避免不断请求 Azure 服务并优化应用程序的功能。
- en: By default, the time the application queries Azure App Configuration for updates
    is 30 seconds. It is possible to specify the refresh call time using the **refreshOptions.SetCacheExpiration**
    method. A **Sentinel** parameter was also configured, responsible for determining
    whether there were changes to the settings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，应用程序查询 Azure App Configuration 以获取更新的时间是 30 秒。可以使用 **refreshOptions.SetCacheExpiration**
    方法指定刷新调用时间。还配置了一个 **Sentinel** 参数，负责确定设置是否发生变化。
- en: It is important as it prevents the SDK from analyzing each configuration individually,
    and if **Sentinel** has been changed, all configurations will be updated.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为它防止 SDK 逐个分析每个配置，并且如果 **Sentinel** 已更改，所有配置都将更新。
- en: 'Now that we’ve learned how Azure App Configuration settings work, let’s create
    configuration keys in the Azure portal:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Azure App Configuration 设置的工作原理，让我们在 Azure 门户中创建配置键：
- en: 'In the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ), in the App Configuration resource created previously, select the **Configuration
    explorer** option, as shown in *Figure 9* *.7* :'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 门户（[https://portal.azure.com](https://portal.azure.com)）中，选择之前创建的应用配置资源，选择**配置资源管理器**选项，如图*图
    9* *.7* 所示：
- en: '![Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration](img/B21788_09_07.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 访问 Azure App Configuration 的配置资源管理器选项](img/B21788_09_07.jpg)'
- en: Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 访问 Azure App Configuration 的配置资源管理器选项
- en: 'Then, click on the **Create** | **Key-value** option, as shown in *Figure 9*
    *.8* :'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**创建** | **键值**选项，如图*图 9* *.8* 所示：
- en: '![Figure 9.8 – Adding a new configuration on Azure App Configuration](img/B21788_09_08.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 在 Azure App Configuration 中添加新的配置](img/B21788_09_08.jpg)'
- en: Figure 9.8 – Adding a new configuration on Azure App Configuration
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 在 Azure App Configuration 中添加新的配置
- en: 'A form will be displayed where we will enter the following parameters:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个表单，我们将输入以下参数：
- en: '**Key** : **DynamicConfiguration:Sentinel**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**：**DynamicConfiguration:Sentinel**'
- en: '**Value** : **1**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：**1**'
- en: Leave the rest of the parameters at their defaults.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其余参数保留为默认值。
- en: Click **Apply** .
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**。
- en: 'Repeat *step 2* and add another key with the following configuration:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 2* 并添加另一个具有以下配置的键：
- en: '**Key** : **DynamicConfiguration:GlobalOptions:Title**'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**：**DynamicConfiguration:GlobalOptions:Title**'
- en: '**Value** : **ASP.NET** **Core 9**'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：**ASP.NET** **Core 9**'
- en: Note the **DynamicConfiguration:GlobalOptions:Title** key. This key represents
    a hierarchy following the pattern **<Group Settings>:<Section>** . In this case,
    it is the name of the previously created settings class, configuration, or desired
    property of the configuration class format.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 **DynamicConfiguration:GlobalOptions:Title** 键。此键代表一个遵循 **<Group Settings>:<Section>**
    模式的层次结构。在这种情况下，它是之前创建的设置类、配置或配置类的期望属性的名称。
- en: Labels in Azure App Configuration
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Azure App Configuration 中的标签
- en: The **Label** parameter in Azure Application Configuration is used to differentiate
    configuration settings based on different contexts or environments.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 应用配置中的**标签**参数用于根据不同的上下文或环境区分配置设置。
- en: Labels allow you to separate configurations for different environments (for
    example, development, staging, production).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 标签允许您根据不同的环境（例如，开发、测试、生产）分离配置。
- en: 'This approach brings benefits, such as the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了以下好处：
- en: '**• Flexibility** : Easily switch between different sets of configurations'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**• 灵活性**：轻松地在不同的配置集之间切换'
- en: '**• Isolation** : Keep settings for different environments or scenarios isolated
    and organized'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**• 隔离**：保持不同环境或场景的设置隔离和组织'
- en: '**• Testing** : Safely test new configurations without affecting other environments'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**• 测试**：安全地测试新配置，而不会影响其他环境'
- en: Settings that do not have a **Label** parameter will be treated as default settings.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 没有设置**标签**参数的设置将被视为默认设置。
- en: 'To learn more about labels, visit the following URL: [https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core](https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core)
    .'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于标签的信息，请访问以下网址：[https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core](https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core)。
- en: 'Now that the application is integrated with Azure App Configuration, open the
    terminal and access the application directory. Then, run the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序已集成到 Azure App Configuration，打开终端并访问应用程序目录。然后，运行以下命令：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, access the application URL available on your terminal via the following
    URL: **http://localhost:<port>** . In the example shown in *Figure 9* *.9* , the
    URL is **http://localhost:5295** . We can also see in *Figure 9* *.9* a welcome
    message with the value defined in the App Configuration resource:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过以下网址访问您终端上的应用程序 URL：**http://localhost:<port>**。在如图 *图9* *.9* 所示的示例中，URL
    是 **http://localhost:5295**。我们还可以在 *图9* *.9* 中看到一个带有在 App Configuration 资源中定义的值的欢迎消息：
- en: '![Figure 9.9 – Application getting settings from Azure App Configuration](img/B21788_09_09.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 应用程序从 Azure App Configuration 获取设置](img/B21788_09_09.jpg)'
- en: Figure 9.9 – Application getting settings from Azure App Configuration
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 应用程序从 Azure App Configuration 获取设置
- en: As we can see, the configurations are being loaded directly from the Azure resource.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，配置是直接从 Azure 资源加载的。
- en: With the application still running, access the Azure portal ( [http://portal.azure.com](http://portal.azure.com)
    ) and the Azure App Configuration resource.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序仍在运行的情况下，访问 Azure 门户（[http://portal.azure.com](http://portal.azure.com)）和
    Azure App Configuration 资源。
- en: Then, access the **Configuration explorer** option. We will change the settings.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，访问 **配置资源管理器**选项。我们将更改设置。
- en: 'To do this, in the settings display grid, click on the three dots ( **...**
    ) as shown in *Figure 9* *.10* and click **Edit** :'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个操作，在设置显示网格中，点击如图 *图9* *.10* 所示的三个点（**...**），然后点击 **编辑**：
- en: '![Figure 9.10 – Editing configurations](img/B21788_09_10.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 编辑配置](img/B21788_09_10.jpg)'
- en: Figure 9.10 – Editing configurations
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 编辑配置
- en: 'Provide the following settings:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 提供以下设置：
- en: '**DynamicConfiguration:GlobalOptions:Title** : **ASP.NET Core 9 With** **Dynamic
    config**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DynamicConfiguration:GlobalOptions:Title** : **ASP.NET Core 9 With** **Dynamic
    config**'
- en: '**DynamicConfiguration:Sentinel** : **2**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DynamicConfiguration:Sentinel** : **2**'
- en: 'Wait a few seconds, access the application again, and refresh the page. The
    page body message was changed, as shown in *Figure 9* *.11* :'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，再次访问应用程序，并刷新页面。页面正文消息已更改，如图 *图9* *.11* 所示：
- en: '![Figure 9.11 – Application obtaining configurations dynamically](img/B21788_09_11.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 应用程序动态获取配置](img/B21788_09_11.jpg)'
- en: Figure 9.11 – Application obtaining configurations dynamically
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 应用程序动态获取配置
- en: Despite being a simple implementation example, using a config server is a good
    practice in cloud-native applications, as suggested in The Twelve-Factor App methodology
    ( [https://12factor.net](https://12factor.net) ), and ASP.NET Core 9 provides
    several extensibility mechanisms, such as the one we use when integrating with
    Azure’s App Configuration feature.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的实现示例，但使用配置服务器是云原生应用程序中的良好实践，如十二要素应用方法（[https://12factor.net](https://12factor.net)）中建议的，并且
    ASP.NET Core 9 提供了几个扩展机制，例如我们在与 Azure 的 App Configuration 功能集成时使用的机制。
- en: This approach in large application scenarios in production environments can
    bring several benefits by offering an immediate response to certain changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境的大型应用程序场景中，这种方法可以通过对某些更改提供即时响应来带来几个好处。
- en: The Twelve-Factor App methodology
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用方法
- en: 'The Twelve-Factor App methodology is a methodology used as a reference in creating
    **SaaS** ( **Software as a Service** ) application and has 12 factors, technology
    agnostic, that offer best practices for developing cloud-native solutions. One
    of the factors is related to configuration management, related to what we learned
    in this chapter, and you can learn more about this factor through the following
    URL: [https://12factor.net/config](https://12factor.net/config) .'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用方法是一种在创建 **SaaS**（**软件即服务**）应用时作为参考的方法，它有12个因素，与技术无关，提供了开发云原生解决方案的最佳实践。其中一个因素与配置管理相关，与我们本章所学的内容相关，您可以通过以下网址了解更多关于这个因素的信息：[https://12factor.net/config](https://12factor.net/config)。
- en: Managing configurations on a server such as Azure App Configuration brings several
    benefits, the most important being security. With the easy integration with ASP.NET
    Core 9 applications, we can allow our applications to change settings dynamically
    and even segregate them by environment. This approach is very important in a CI/CD
    process. We will talk more about CI/CD in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162)
    .
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上管理配置，如Azure应用配置，带来了许多好处，其中最重要的是安全性。与ASP.NET Core 9应用程序的轻松集成使我们能够允许我们的应用程序动态更改设置，甚至根据环境进行隔离。这种方法在CI/CD流程中非常重要。我们将在[第10章](B21788_10.xhtml#_idTextAnchor162)中更多地讨论CI/CD。
- en: Another approach that can be used to bring greater capacity to our applications
    in addition to improving user experience, among other benefits, is real-time behavior
    management, which we will learn about in the next section.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提高用户体验等好处外，另一种可以为我们带来更大容量并改进应用程序的方法是实时行为管理，我们将在下一节中了解。
- en: Connecting an ASP.NET Core 9 application to Azure App Configuration
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ASP.NET Core 9应用程序连接到Azure应用配置
- en: Surely at some point, you have already used a mechanism that dynamically changes
    the behavior of an application. Imagine a scenario where you install, for example,
    a messaging app that allows users to send videos, photos, and audio.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一定在某个时刻，你已经使用过一种动态更改应用程序行为的机制。想象一下，例如，你安装了一个允许用户发送视频、照片和音频的消息应用程序的场景。
- en: These media are automatically downloaded when you receive messages, which requires
    data consumption on your smartphone. In general, the first action we would take
    would be to disable the automatic media download option. This setting is found
    in a settings menu; however, this setting completely changes, in real time, the
    way the application will behave.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到消息时，这些媒体会自动下载，这需要在你的智能手机上消耗数据。通常，我们首先采取的行动将是禁用自动媒体下载选项。此设置位于设置菜单中；然而，此设置会实时完全改变应用程序的行为方式。
- en: 'The aforementioned example is a simple concept of changing the behavior of
    applications in real time. Likewise, at some point, web applications may have
    their behavior dynamically managed, and their use brings several benefits, such
    as the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是实时更改应用程序行为的一个简单概念。同样，在某个时刻，Web应用程序可能对其行为进行动态管理，并且其使用带来了以下好处：
- en: '**Controlled releases** : Gradually release features to a subset of users to
    monitor performance and user feedback'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受控发布**：逐步向用户子集发布功能，以监控性能和用户反馈'
- en: '**A/B testing** : Conduct experiments by rotating features for different groups
    of users to determine the best approach'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A/B测试**：通过为不同用户组轮换功能来开展实验，以确定最佳方法'
- en: '**Instant rollbacks** : Quickly disable a feature if it causes problems, without
    redeploying the application'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时回滚**：如果功能出现问题，可以快速禁用它，而无需重新部署应用程序'
- en: The technique that allows changing the behavior of applications in real time
    is called feature toggles or feature flags .
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在实时更改应用程序行为的技巧被称为功能开关或功能标志。
- en: Feature toggles, also known as feature flags, are a software development technique
    that allows you to enable or disable features in an application at runtime without
    deploying new code, bringing flexibility for better risk management and improving
    the deployment process, enabling teams to release resources to specific users
    or environments, and improving overall development and operational efficiency.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关，也称为功能标志，是一种软件开发技术，允许你在不部署新代码的情况下，在应用程序运行时启用或禁用功能，从而为更好的风险管理提供灵活性，并改进部署过程，使团队能够向特定用户或环境释放资源，并提高整体开发和运营效率。
- en: 'In terms of coding, a feature toggle can be represented as shown in *Figure
    9* *.12* :'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码方面，功能开关可以表示如图9.12所示：
- en: '![Figure 9.12 – Representation of the feature toggle concept](img/B21788_09_12.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 功能开关概念表示](img/B21788_09_12.jpg)'
- en: Figure 9.12 – Representation of the feature toggle concept
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 功能开关概念表示
- en: As we can see in *Figure 9* *.12* , the feature toggle is basically a decision
    point in the application’s source code. This decision point checks whether a certain
    value, called a toggle, is activated. To check if a toggle is activated, we can
    obtain this value through a configuration file, environment variables, and even
    on a remote server, which is the most recommended way.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 *图 9* *.12* 中所见，功能切换基本上是应用程序源代码中的一个决策点。这个决策点检查一个称为切换的特定值是否被激活。要检查切换是否被激活，我们可以通过配置文件、环境变量，甚至远程服务器（这是最推荐的方式）来获取这个值。
- en: Single Responsibility Principle
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Implementing feature toggles in ASP.NET Core 9 should follow best practices
    to make your code cleaner, easier to maintain, and more scalable. When using feature
    toggles, it is bad practice to lump multiple behaviors into a single class, such
    as handling different features or switching between old and new logic within a
    service. This approach can lead to code that is difficult to understand and modify.
    A good practice is to follow the **Single Responsibility Principle** ( **SRP**
    ), which means that each class should handle only one responsibility or feature.
    By keeping each class focused on one task, you reduce complexity and make your
    application easier to maintain and extend.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 9 中实现功能切换应遵循最佳实践，以使您的代码更干净、更容易维护和更易于扩展。在使用功能切换时，将多个行为合并到一个类中，例如处理不同的功能或在一个服务中切换新旧逻辑，是不良的做法。一种好的做法是遵循**单一职责原则**（**SRP**），这意味着每个类应该只处理一个职责或功能。通过保持每个类专注于一项任务，您可以减少复杂性并使应用程序更容易维护和扩展。
- en: 'Additionally, using factory methods with DI in ASP.NET Core 9 allows you to
    easily swap out different implementations based on feature toggles without breaking
    the SRP. If you need to add a new feature, you can simply create a new class for
    that feature, isolating the existing logic. To learn more about the SRP, access
    the following URL: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility)
    .'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 ASP.NET Core 9 中使用依赖注入（DI）的工厂方法允许您根据功能切换轻松地交换不同的实现，而不会破坏 SRP。如果您需要添加新功能，您可以简单地为该功能创建一个新类，隔离现有逻辑。要了解更多关于
    SRP 的信息，请访问以下网址：[https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility)。
- en: All the details surrounding the use of the feature toggle technique and its
    respective benefits not only for development teams but also for management and
    complexity aspects go beyond the scope of this book.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 关于功能切换技术及其相应的好处，不仅限于开发团队，还包括管理和复杂性方面，超出了本书的范围。
- en: We already have a basic knowledge of using this technique, and now, it’s time
    to use it in an ASP.NET Core 9 application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了使用这项技术的基本知识，现在，是时候在 ASP.NET Core 9 应用程序中使用它了。
- en: Managing feature toggles with Azure App Configuration
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Azure App Configuration 管理功能切换
- en: In the previous topic, we used the Azure App Configuration feature for configuration
    management; however, this service also includes feature flags, which you can use
    to enable or disable a feature. Through the UI in the Azure portal, we can create
    and manage the feature flags of our applications.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们使用了 Azure App Configuration 功能进行配置管理；然而，这项服务还包括功能标志，您可以使用它来启用或禁用功能。通过
    Azure 门户中的 UI，我们可以创建和管理我们应用程序的功能标志。
- en: 'Let’s make some changes to the **DynamicConfiguration** project code, created
    previously, and add feature toggles:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对之前创建的 **DynamicConfiguration** 项目代码进行一些修改，并添加功能切换：
- en: 'Open the terminal and go to the application directory. Then, run the following
    commands:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并转到应用程序目录。然后，运行以下命令：
- en: '[PRE24]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These packages are necessary to incorporate the SDK for managing toggles in
    the application.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些包是必要的，以将管理应用程序切换的 SDK 集成到应用程序中。
- en: 'Open the application in Visual Studio Code, then we will edit the **Program.cs**
    file, which will have the following updated code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开应用程序，然后我们将编辑 **Program.cs** 文件，该文件将包含以下更新后的代码：
- en: '[PRE25]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Basically, we make three changes to the **Program.cs** file:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基本上，我们对 **Program.cs** 文件进行了三项更改：
- en: '**using Microsoft.FeatureManagement** : Adding the namespaces necessary to
    add the SDK’s toggle management features.'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**using Microsoft.FeatureManagement**：添加添加 SDK 的切换管理功能的必要命名空间。'
- en: '**builder.Services.AddFeatureManagement()** : Adding services to the application’s
    DIC.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**builder.Services.AddFeatureManagement()**：向应用程序的依赖注入容器中添加服务。'
- en: '**.UseFeatureFlags** : We changed the connection settings with Azure App Configuration,
    informing us that the toggle management feature will be used. Additionally, a
    5-second cache was defined using the **featureFlagsOptions.CacheExpirationInterval**
    standard.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.UseFeatureFlags**：我们更改了与 Azure App Configuration 的连接设置，告知我们将使用切换管理功能。此外，使用**featureFlagsOptions.CacheExpirationInterval**标准定义了5秒的缓存。'
- en: As part of the Azure App Configuration SDK, we can work with toggles directly
    in the code of controllers or services, using the **IFeatureManager** interface,
    the **FeatureGate** attribute, or a **tag helper** directly in views. For this
    example, we will use a tag helper.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Azure App Configuration SDK 的一部分，我们可以直接在控制器或服务的代码中使用切换，使用**IFeatureManager**接口、**FeatureGate**属性或直接在视图中使用**标签助手**。对于此示例，我们将使用标签助手。
- en: Using IFeatureManagement and the FeatureGate attribute
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IFeatureManagement 和 FeatureGate 属性
- en: 'In some cases, we can analyze whether a toggle is activated or not through
    the **IFeatureManagement** interface, which is injected into a class and provides
    us with methods to test the values, such as the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以通过**IFeatureManagement**接口分析切换是否已激活，该接口注入到类中，并提供测试值的方法，如下所示：
- en: '**public class MyController :** **Controller**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**public class MyController :** **Controller**'
- en: '**{**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**private readonly** **IFeatureManager _featureManager;**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**private readonly** **IFeatureManager _featureManager;**'
- en: '**public** **MyController(IFeatureManager featureManager)**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**public** **MyController(IFeatureManager featureManager)**'
- en: '**{**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**_featureManager =** **featureManager;**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**_featureManager =** **featureManager;**'
- en: '**}**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**private async** **Task MyMethod()**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**private async** **Task MyMethod()**'
- en: '**{**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**if (await** **_featureManager**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**if (await** **_featureManager**'
- en: '**.** **IsEnableAsync("FeatureToggleName"))**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**.** **IsEnableAsync("FeatureToggleName"))**'
- en: '**{**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**Console.WriteLine("New Approach");**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**Console.WriteLine("New Approach");**'
- en: '**}**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**else**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**else**'
- en: '**{**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**Console.WriteLine("Legacy Approach");**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**Console.WriteLine("Legacy Approach");**'
- en: '**}**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: 'In the same way, it is possible to annotate an action or controller with the
    **FeatureGate** attribute:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，可以通过**FeatureGate**属性注释操作或控制器：
- en: '**using Microsoft.FeatureManagement.Mvc;**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**using Microsoft.FeatureManagement.Mvc;**'
- en: '**[** **FeatureGate("FeatureToggleName)]**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**[** **FeatureGate("FeatureToggleName)]**'
- en: '**public class MyController :** **Controller**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**public class MyController :** **Controller**'
- en: '**{**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**// ....**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**// ....**'
- en: '**}**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: This way, it is possible to benefit from the use of toggle management with different
    implementations but the same concept.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就可以从使用具有不同实现但相同概念的切换管理中受益。
- en: 'Let’s change the application to use a tag helper, which will use the feature
    toggle. Follow the next steps:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将应用程序更改为使用标签助手，该助手将使用功能切换。按照以下步骤操作：
- en: 'In Visual Studio Code, edit the **Views/_ViewImports.cshtml** file and add
    the following code to the file, below the existing code:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，编辑**视图/_ViewImports.cshtml**文件，并在现有代码下方添加以下代码：
- en: '[PRE26]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code adds a tag helper from the Azure App Configuration SDK.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码添加了来自 Azure App Configuration SDK 的标签助手。
- en: 'Then, open the **Views/Home/Index.cstml** file and use the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开**视图/首页/Index.cstml**文件，并使用以下代码：
- en: '[PRE27]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the use of the feature tag, which will basically obtain information on
    whether a toggle is enabled. If yes, the new **div** tag will be displayed on
    the screen.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意功能标签的使用，它将基本上获取有关切换是否启用的信息。如果是，新的**div**标签将显示在屏幕上。
- en: Now that everything is configured in the application, let’s add the feature
    toggle in Azure App Configuration.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在应用程序中已经配置了一切，让我们在 Azure App Configuration 中添加功能切换。
- en: Open the Azure portal ( [https://portal.azure.com](https://portal.azure.com)
    ) and access the App Configuration resource created in the previous section.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Azure 门户（[https://portal.azure.com](https://portal.azure.com)）并访问上一节中创建的应用配置资源。
- en: 'Then, click on the **Feature manager** menu, **Create** | **Feature flag**
    , as shown in *Figure 9* *.13* :'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**功能管理器**菜单，**创建** | **功能标志**，如图*图 9* *.13* 所示：
- en: '![Figure 9.13 – Adding a new feature flag](img/B21788_09_13.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 9.13 – 添加新的功能标志](img/B21788_09_13.jpg)'
- en: Figure 9.13 – Adding a new feature flag
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 添加新的功能标志
- en: On the next screen, set the **New feature flag** field to the **NewFeature**
    value and leave the rest at their default values.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，将**新功能标志**字段设置为**NewFeature**值，其余保持默认值。
- en: Click on the **Apply** button.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**按钮。
- en: 'A new feature flag will be created and disabled, as shown in *Figure 9* *.14*
    :'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将创建一个新的功能标志并将其禁用，如图*图9.14*所示：
- en: '![Figure 9.14 – Application using a disabled feature flag](img/B21788_09_14.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 使用禁用功能标志的应用程序](img/B21788_09_14.jpg)'
- en: Figure 9.14 – Application using a disabled feature flag
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 使用禁用功能标志的应用程序
- en: We did this configuration on purpose. Now, run the application again using the
    **dotnet run** command, executed through the terminal in the application directory
    and you’ll see there is no changes on the application. The reason the new **Div**
    tag was not displayed is that we created the toggle as **Enabled= false** .
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意这样做配置。现在，再次使用**dotnet run**命令运行应用程序，通过应用程序目录中的终端执行，你会看到应用程序没有变化。新**Div**标签没有显示的原因是我们将切换创建为**Enabled=false**。
- en: 'Keep the application running, access the Azure portal again, and enable the
    toggle by clicking on the **Enabled** column in the grid, as shown in *Figure
    9* *.15* :'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持应用程序运行，再次访问Azure门户，通过在网格中点击**启用**列来启用切换，如图*图9.15*所示：
- en: '![Figure 9.15 – Enabling the feature flag](img/B21788_09_15.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 启用功能标志](img/B21788_09_15.jpg)'
- en: Figure 9.15 – Enabling the feature flag
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 启用功能标志
- en: 'Access the application again, and we can see in *Figure 9* *.16* that a new
    HTML element has been added to the page:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问应用程序，我们可以在*图9.16*中看到页面上已添加了一个新的HTML元素：
- en: '![Figure 9.16 – Application behavior changed at runtime](img/B21788_09_16.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 应用程序在运行时行为改变](img/B21788_09_16.jpg)'
- en: Figure 9.16 – Application behavior changed at runtime
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 应用程序在运行时行为改变
- en: By understanding and implementing dynamic configurations and feature toggles,
    we can create robust, flexible, and responsive ASP.NET Core 9 applications.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解和实现动态配置和功能切换，我们可以创建健壮、灵活和响应式的ASP.NET Core 9应用程序。
- en: In this chapter, we have used Azure App Configuration as a feature flag manager.
    However, ASP.NET Core 9 has integrations with several other types of toggle management
    servers using the same techniques learned in this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已使用Azure App Configuration作为功能标志管理器。然而，ASP.NET Core 9与本章学习的技术相同，与其他类型的切换管理服务器有集成。
- en: The combination of configuration management techniques and feature flags is
    very powerful for different application contexts, mainly interacting with cloud
    resources in a scenario of continuous delivery of value through automated mechanisms.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理技术和功能标志的组合对于不同的应用程序上下文非常强大，主要是在通过自动化机制持续交付价值的情况下与云资源交互。
- en: We will discuss how to host our applications in cloud environments using automated
    processes in the next chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论如何使用自动化流程在云环境中托管我们的应用程序。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into good practices for managing application configurations
    by understanding the concepts and abstractions of the IConfiguration interface.
    We also worked with concepts related to the ASP.NET Core 9 configuration provider,
    along with the implementation of the Options pattern. Finally, we worked with
    changing application configurations and behavior in real time using Microsoft
    Azure’s Azure App Configurator to implement the concept of feature flags or feature
    toggles. Working with cloud resources is an important premise for Software Engineers
    and in the next chapter, we will explore how to deploy applications in a Cloud
    environment.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了通过理解IConfiguration接口的概念和抽象来管理应用程序配置的良好实践。我们还与ASP.NET Core 9配置提供程序相关的概念一起工作，以及实现选项模式。最后，我们使用Microsoft
    Azure的Azure App Configurator实时更改应用程序配置和行为，以实现功能标志或功能切换的概念。与云资源一起工作是软件工程师的重要前提，在下一章中，我们将探讨如何在云环境中部署应用程序。
- en: 'Part 4: Hosting, Deploying, and Preparing to the Cloud'
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：托管、部署和准备云环境
- en: Modern applications are dynamic, and as software engineers, our work doesn’t
    end after synchronizing the latest code developed. In a scenario where the market
    is constantly changing, it is necessary for applications to be dynamic enough
    to meet constant market demands. Therefore, development teams must adapt to the
    new topics surrounding the modern development model. ASP.NET Core 9 is prepared
    to provide high-quality solutions, suitable for cloud environments. In this part,
    we will learn about aspects involving the continuous delivery of solutions through
    the understanding and implementation of application publishing flows in a cloud
    environment with the support of automated pipelines such as **Continuous Integration**
    ( **CI** ) and **Continuous Delivery** ( **CD** ), processes associated with the
    DevOps culture. We will understand what a cloud-native mindset is and how to direct
    our solutions to a constantly changing market.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用是动态的，作为软件工程师，我们的工作并不仅仅在同步最新开发的代码后结束。在市场不断变化的场景中，应用需要足够动态，以满足不断的市场需求。因此，开发团队必须适应围绕现代开发模型的新主题。ASP.NET
    Core 9 准备提供适合云环境的高质量解决方案。在本部分，我们将通过理解和实施在云环境中支持自动化管道（如**持续集成**（**CI**）和**持续交付**（**CD**））的应用发布流程，了解涉及解决方案持续交付的各个方面。我们将了解云原生思维是什么，以及如何将我们的解决方案引导至不断变化的市场。
- en: 'This part has the following chapters:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) *, Deploying and Hosting Applications*'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21788_10.xhtml#_idTextAnchor162) ，*部署和托管应用*'
- en: '[*Chapter 11*](B21788_11.xhtml#_idTextAnchor183) *, Cloud-Native Development
    with* *ASP.NET Core 9*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21788_11.xhtml#_idTextAnchor183) ，*使用* *ASP.NET Core 9* *进行云原生开发*'
