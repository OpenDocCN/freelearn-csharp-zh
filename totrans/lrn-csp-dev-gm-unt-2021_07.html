<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer263">&#13;
    <h1 class="chapterNumber">7</h1>&#13;
    <h1 id="_idParaDest-154" class="chapterTitle">Movement, Camera Controls, and Collisions</h1>&#13;
    <p class="normal">One of the first things a player does when starting a new game is to try out character movement (if, of course, the game has a moveable character) and camera controls. Not only is this exciting, but it lets your player know what kind of gameplay they can expect. The character in <em class="italic">Hero Born</em> will be a capsule object that can be moved and rotated using the <kbd class="keyStroke">W</kbd>, <kbd class="keyStroke">A</kbd>, <kbd class="keyStroke">S</kbd>, <kbd class="keyStroke">D</kbd>, or arrow keys, respectively.</p>&#13;
    <p class="normal">We'll start by learning how to manipulate the player object's <code class="Code-In-Text--PACKT-">Transform</code> component and then replicate the same player control scheme using applied force. This produces a more realistic movement effect. When we move the player, the camera will follow along from a position that is slightly behind and above the player, making aiming easier when we implement the shooting mechanic. Finally, we'll explore how collisions and physical interactions are handled by Unity's physics system by working with our item pickup Prefab. </p>&#13;
    <p class="normal">All of this will come together at a playable level, albeit without any shooting mechanics just yet. It's also going to give us our first taste of C# being used to program game features by tying together the following topics:</p>&#13;
    <ul>&#13;
      <li class="bullet">Managing player movement</li>&#13;
      <li class="bullet">Moving the player with the <code class="Code-In-Text--PACKT-">Transform</code> component</li>&#13;
      <li class="bullet">Scripting camera behavior</li>&#13;
      <li class="bullet">Working with the Unity physics system</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-155" class="title">Managing player movement</h1>&#13;
    <p class="normal">When you're <a id="_idIndexMarker442"/>deciding on how best to move your player character around your virtual world, consider what's going to look the most realistic and not run your game into the ground with expensive computations. This is somewhat of a trade-off in most cases, and Unity is no different. </p>&#13;
    <p class="normal">The three most<a id="_idIndexMarker443"/> common ways of moving a <code class="Code-In-Text--PACKT-">GameObject</code> and their results are as follows:</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="keyword">Option A</strong>: Use a <code class="Code-In-Text--PACKT-">GameObject</code>'s <code class="Code-In-Text--PACKT-">Transform</code> component for movement and rotation. This is the easiest solution and the one we'll be working with first.</li>&#13;
      <li class="bullet"><strong class="keyword">Option B</strong>: Use real-world physics by attaching<a id="_idIndexMarker444"/> a <strong class="keyword">Rigidbody</strong> component to a <code class="Code-In-Text--PACKT-">GameObject</code> and apply force in code. <code class="Code-In-Text--PACKT-">Rigidbody</code> components add simulated real-world physics to any <code class="Code-In-Text--PACKT-">GameObject</code> they are attached to. This solution relies on Unity's physics system to do the heavy lifting, delivering a far more realistic effect. We'll update our code to use this approach later on in this chapter to get a feel for both methods.&#13;
   &#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Unity suggests sticking to a consistent approach when moving or rotating a <code class="Code-In-Text--PACKT-">GameObject</code>; either manipulate an object's <code class="Code-In-Text--PACKT-">Transform</code> or <code class="Code-In-Text--PACKT-">Rigidbody</code> component, but never both at the same time.</p>&#13;
    </div></li>&#13;
   &#13;
      <li class="bullet"><strong class="keyword">Option C</strong>: Attach a ready-made Unity component or Prefab, such as Character Controller or First Person Controller. This cuts out the boilerplate code and still delivers a realistic effect while speeding up the prototyping time.</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">You can find more information<a id="_idIndexMarker445"/> on the Character Controller component and its uses at <a href="https://docs.unity3d.com/ScriptReference/CharacterController.html"><span class="url">https://docs.unity3d.com/ScriptReference/CharacterController.html</span></a>.</p>&#13;
      <p class="Information-Box-Within-Bullet--PACKT-">The First Person Controller Prefab is available from the Standard Assets package, which you can <a id="_idIndexMarker446"/>download from <a href="https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351"><span class="url">https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">Since you're just getting started with player movement in Unity, you'll start off using the player Transform component in the next section, and then move on to <code class="Code-In-Text--PACKT-">Rigidbody</code> physics later in the chapter.</p>&#13;
    <h1 id="_idParaDest-156" class="title">Moving the player with the Transform component</h1>&#13;
    <p class="normal">We want a<a id="_idIndexMarker447"/> third-person adventure setup for <em class="italic">Hero Born</em>, so we'll start with a capsule that can be controlled with keyboard input and a camera to follow the capsule as it moves. Even though these two GameObjects will work together in the game, we'll keep them and their scripts separate for better control. </p>&#13;
    <p class="normal">Before we <a id="_idIndexMarker448"/>can do any scripting, you'll need to add a player capsule to the scene, which is your next task.</p>&#13;
    <p class="normal">We can create a nice player capsule in just a few steps:</p>&#13;
    <ol>&#13;
      <li class="numbered">Click on <strong class="screenText">+</strong> | <strong class="screenText">3D Object</strong> | <strong class="screenText">Capsule</strong> from the <strong class="screenText">Hierarchy</strong> panel and name it <code class="Code-In-Text--PACKT-">Player</code>.</li>&#13;
      <li class="numbered">Select the <code class="Code-In-Text--PACKT-">Player</code> GameObject and click on <strong class="screenText">Add Component</strong> at the bottom of the <strong class="screenText">Inspector</strong> tab. Search for <strong class="screenText">Rigidbody</strong> and hit <kbd class="keyStroke">Enter</kbd> to add it. We won't use this component until later, but it's good to set things up properly at the beginning.</li>&#13;
      <li class="numbered">Expand the <strong class="screenText">Constraints</strong> property at the bottom of the <strong class="screenText">Rigidbody</strong> component:<ul>&#13;
          <li class="bullet-l2">Check the boxes for <strong class="screenText">Freeze Rotation</strong> on the <strong class="screenText">X</strong>, <strong class="screenText">Y</strong>, and <strong class="screenText">Z</strong> axes so the player can't be rotated in any way other than through the code we'll write later on:</li>&#13;
        </ul>&#13;
        <figure class="mediaobject"><img src="Images/B17573_07_01.png" alt="" width="750" height="471"/></figure>&#13;
        <p class="packt_figref">Figure 7.1: Rigidbody component</p>&#13;
      </li>&#13;
      <li class="numbered">Select<a id="_idIndexMarker449"/> the <code class="Code-In-Text--PACKT-">Materials</code> folder in the <strong class="screenText">Project</strong> panel and click on <strong class="screenText">Create</strong> | <strong class="screenText">Material</strong>. Name it <code class="Code-In-Text--PACKT-">Player_Mat</code>.</li>&#13;
      <li class="numbered">Select <code class="Code-In-Text--PACKT-">Player_Mat</code> in <a id="_idIndexMarker450"/>the <strong class="screenText">Hierarchy</strong>, then change the <strong class="screenText">Albedo</strong> property in the <strong class="screenText">Inspector</strong> to a bright green and drag the material to the <strong class="screenText">Player</strong> object in the <strong class="screenText">Hierarchy</strong> panel:<figure class="mediaobject"><img src="Images/B17573_07_02.png" alt="" width="750" height="326"/></figure>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="packt_figref">Figure 7.2: Player material attached to capsule</p>&#13;
    <p class="normal">You've <a id="_idIndexMarker451"/>created the <strong class="screenText">Player</strong> object out of a capsule primitive, a Rigidbody component, and a new bright green material. Don't worry about <a id="_idIndexMarker452"/>what the Rigidbody component is just yet—all you need to know right now is that it allows our capsule to interact with the physics system. We'll go into more detail at the end of this chapter when we discuss how Unity's physics system works. Before we get to that, we need to talk about a very important subject in 3D space: vectors.</p>&#13;
    <h2 id="_idParaDest-157" class="title">Understanding vectors</h2>&#13;
    <p class="normal">Now that we<a id="_idIndexMarker453"/> have a player capsule and camera set up, we can start looking at how to move and rotate a GameObject using its <code class="Code-In-Text--PACKT-">Transform</code> component. The <code class="Code-In-Text--PACKT-">Translate</code> and <code class="Code-In-Text--PACKT-">Rotate</code> methods are part of the <code class="Code-In-Text--PACKT-">Transform</code> class that Unity provides, and each needs a vector parameter to perform its given function.</p>&#13;
    <p class="normal">In Unity, vectors are used to hold position and direction data in 2D and 3D spaces, which is why they come in two varieties—<code class="Code-In-Text--PACKT-">Vector2</code> and <code class="Code-In-Text--PACKT-">Vector3</code>. These can be used like any other variable type we've seen; they just hold different information. Since our game is in 3D, we'll be using <code class="Code-In-Text--PACKT-">Vector3</code> objects, which means we'll need to construct them using <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> values. </p>&#13;
    <p class="normal">For 2D vectors, only the <em class="italic">x</em> and <em class="italic">y</em> positions are required. Remember, the most up-to-date orientation in your 3D scene will be displayed in the upper-right graphic that we discussed in the previous chapter, <em class="chapterRef">Chapter 6</em>, <em class="italic">Getting Your Hands Dirty with Unity</em>:</p>&#13;
    <figure class="mediaobject"><img src="Images/B17573_07_03.png" alt="" width="828" height="392"/></figure>&#13;
    <p class="packt_figref">Figure 7.3: Vector gizmos in Unity editor</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">If you would like more<a id="_idIndexMarker454"/> information about vectors in Unity, refer to the documentation and scripting reference at <a href="https://docs.unity3d.com/ScriptReference/Vector3.html"><span class="url">https://docs.unity3d.com/ScriptReference/Vector3.html</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">For instance, if we <a id="_idIndexMarker455"/>wanted to create a new vector to hold the origin position of our scene, we could use the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Vector3 Origin = <span class="hljs-keyword">new</span> Vector(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>);&#13;
</code></pre>&#13;
    <p class="normal">All we've done here is created a new <code class="Code-In-Text--PACKT-">Vector3</code> variable and initialized it with a <code class="Code-In-Text--PACKT-">0</code> for the <em class="italic">x</em> position, <code class="Code-In-Text--PACKT-">0</code> for the <em class="italic">y</em> position, and <code class="Code-In-Text--PACKT-">0</code> for the <em class="italic">z</em> position, in that order. This spawns the player at the origin of the game arena. <code class="Code-In-Text--PACKT-">Float</code> values can be written with or without a decimal, but they always need to end with a lowercase <code class="Code-In-Text--PACKT-">f</code>.</p>&#13;
    <p class="normal">We can also create directional vectors by using the <code class="Code-In-Text--PACKT-">Vector2</code> or <code class="Code-In-Text--PACKT-">Vector3</code> class properties:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Vector3 ForwardDirection = Vector3.forward;&#13;
</code></pre>&#13;
    <p class="normal">Instead of holding a position, <code class="Code-In-Text--PACKT-">ForwardDirection</code> references the forward direction in our scene along the <em class="italic">z</em> axis in the 3D space. The neat thing about using the Vector3 direction is that no matter which way we make the player look, our code will always know which way is forward. We'll look at using vectors later in this chapter, but for now just get used to thinking about 3D movement <a id="_idIndexMarker456"/>in terms of <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> positions and directions.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Don't worry if the concept of vectors is new to you—it's a complicated topic. Unity's vector cookbook is a great place to start: <a href="https://docs.unity3d.com/Manual/VectorCookbook.html"><span class="url">https://docs.unity3d.com/Manual/VectorCookbook.html</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">Now that you understand vectors a bit more, you can start implementing the basics of moving the player capsule. For that, you'll need to gather player input from the keyboard, which is the topic of the following section.</p>&#13;
    <h2 id="_idParaDest-158" class="title">Getting player input</h2>&#13;
    <p class="normal">Positions and directions <a id="_idIndexMarker457"/>are useful in themselves, but they can't generate movement without input from the player. This is where the <code class="Code-In-Text--PACKT-">Input</code> class comes in, which handles everything from keystrokes and mouse position to acceleration and gyroscopic data. </p>&#13;
    <p class="normal">We're going to be using the <kbd class="keyStroke">W</kbd>, <kbd class="keyStroke">A</kbd>, <kbd class="keyStroke">S</kbd>, <kbd class="keyStroke">D</kbd>, and arrow keys for movement in <em class="italic">Hero Born</em>, coupled with a script that allows the camera to follow where the player points the mouse. To do that, we'll need to understand how input axes work.</p>&#13;
    <p class="normal">First, go to <strong class="screenText">Edit</strong> | <strong class="screenText">Project Settings</strong> | <strong class="screenText">Input Manager</strong> to open up the <strong class="screenText">Input Manager</strong> tab shown in the following screenshot:</p>&#13;
    <figure class="mediaobject"><img src="Images/B17573_07_04.png" alt="" width="774" height="503"/></figure>&#13;
    <p class="packt_figref">Figure 7.4: Input Manager window</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Unity 2021 has a new input system that removes a lot of the coding work, making it easier to set up inputs as actions in the editor. Since this is a programming book, we're going to do things from scratch. However, if you want to see how the new <a id="_idIndexMarker458"/>input system works, check out this great tutorial: <a href="https://learn.unity.com/project/using-the-input-system-in-unity"><span class="url">https://learn.unity.com/project/using-the-input-system-in-unity</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">You'll see <a id="_idIndexMarker459"/>a long list of Unity's default inputs already configured, but let's take the <strong class="screenText">Horizontal</strong> axis as an example. You can see that the <strong class="screenText">Horizontal</strong> input axis has the <strong class="screenText">Positive</strong> and <strong class="screenText">Negative</strong> buttons set to <code class="Code-In-Text--PACKT-">left</code> and <code class="Code-In-Text--PACKT-">right</code>, and the <strong class="screenText">Alt</strong> <strong class="screenText">Negative</strong> and <strong class="screenText">Alt Positive</strong> buttons set to the <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">d</code> keys.</p>&#13;
    <p class="normal">Whenever an input axis is queried from the code, its value will be between -1 and 1. For example, when the left arrow or <kbd class="keyStroke">A</kbd> key is pushed down, the horizontal axis registers a -1 value. When those keys are released, the value returns to 0. Likewise, when the right arrow or <kbd class="keyStroke">D</kbd> keys are used, the horizontal axis registers a value of 1. This allows us to capture four different inputs for a single axis with only one line of code, as opposed to writing out a long <code class="Code-In-Text--PACKT-">if-else</code> statement chain for each. </p>&#13;
    <p class="normal">Capturing input axes is <a id="_idIndexMarker460"/>as simple as calling <code class="Code-In-Text--PACKT-">Input.GetAxis()</code> and specifying the axis we want by name, which is what we'll do with the <code class="Code-In-Text--PACKT-">Horizontal</code> and <code class="Code-In-Text--PACKT-">Vertical</code> inputs in the following sections. As a side benefit, Unity applies a smoothing filter, which makes the input frame rate independent. </p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Default inputs can be modified in any way you need, but you can also create custom axes by increasing the <code class="Code-In-Text--PACKT-">Size</code> property in the input manager and renaming the copy that's been created for you. You have to increase the <code class="Code-In-Text--PACKT-">Size</code> property in order to add a custom input.</p>&#13;
    </div>&#13;
    <p class="normal">Let's start getting our player moving using Unity's input system and a custom locomotion script of our own.</p>&#13;
    <h2 id="_idParaDest-159" class="title">Moving the player</h2>&#13;
    <p class="normal">Before you<a id="_idIndexMarker461"/> get the player moving, you'll need to attach a script to the player capsule:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder, name it <code class="Code-In-Text--PACKT-">PlayerBehavior</code>, and drag it onto the <strong class="screenText">Player </strong>capsule in the <strong class="screenText">Hierarchy </strong>panel.</li>&#13;
      <li class="numbered">Add the following code and save:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine; &#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerBehavior</span> : <span class="hljs-title">MonoBehaviour</span> &#13;
{&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 1</strong></span>&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MoveSpeed = <span class="hljs-number">10f</span>;&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> RotateSpeed = <span class="hljs-number">75f</span>;&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 2</strong></span>&#13;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _vInput;&#13;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _hInput;&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Update</span><span class="hljs-function">()</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 3</strong></span>&#13;
        _vInput = Input.GetAxis(<span class="hljs-string">"Vertical"</span>) * MoveSpeed;&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 4</strong></span>&#13;
        _hInput = Input.GetAxis(<span class="hljs-string">"Horizontal"</span>) * RotateSpeed;&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 5</strong></span>&#13;
        <span class="hljs-keyword">this</span>.transform.Translate(Vector3.forward * _vInput * &#13;
        Time.deltaTime);&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 6</strong></span>&#13;
        <span class="hljs-keyword">this</span>.transform.Rotate(Vector3.up * _hInput * &#13;
        Time.deltaTime);&#13;
    }&#13;
} &#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Using the <code class="Code-In-Text--PACKT-">this</code> keyword is optional. Visual Studio 2019 may suggest that you remove it to simplify the code, but I prefer leaving it in for clarity. When you have empty methods, such as <code class="Code-In-Text--PACKT-">Start</code>, in this case, it's common to delete them for clarity.</p>&#13;
    </div>&#13;
    <p class="normal">Here's a <a id="_idIndexMarker462"/>breakdown of the preceding code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Declares two public variables to be used as multipliers:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">MoveSpeed</code> for how fast we want the Player to go forward and backward</li>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">RotateSpeed</code> for how fast we want the Player to rotate left and right</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Declares two private variables to hold inputs from the player; initially set with no value:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">_vInput</code> will store the vertical axis input.</li>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">_hInput</code> will store the horizontal axis input.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered"><code class="Code-In-Text--PACKT-">Input.GetAxis("Vertical")</code> detects when the up arrow, down arrow, <kbd class="keyStroke">W</kbd>, or <kbd class="keyStroke">S</kbd> keys are pressed and multiplies that value by <code class="Code-In-Text--PACKT-">MoveSpeed</code>:<ul>&#13;
          <li class="bullet-l2">The up arrow and <kbd class="keyStroke">W</kbd> keys return a value of 1, which will move the player in the forward (positive) direction.</li>&#13;
          <li class="bullet-l2">The down arrow and <kbd class="keyStroke">S</kbd> keys return -1, which moves the player backward in the negative direction.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered"><code class="Code-In-Text--PACKT-">Input.GetAxis("Horizontal")</code> detects when the left arrow, right arrow, <kbd class="keyStroke">A</kbd>, and <kbd class="keyStroke">D</kbd> keys are pressed and multiplies that value by <code class="Code-In-Text--PACKT-">RotateSpeed</code>:<ul>&#13;
          <li class="bullet-l2">The right arrow and <kbd class="keyStroke">D</kbd> keys return a value of 1, which will rotate the capsule to the right.</li>&#13;
          <li class="bullet-l2">The left arrow and <kbd class="keyStroke">A</kbd> keys return -1, rotating the capsule to the left.&#13;
   &#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">If you're wondering whether it's possible to do all the movement calculations on one line, the simple answer is yes. However, it's better to have your code broken down, even if you're the only one reading it.</p>&#13;
    </div></li>&#13;
        </ul>&#13;
      </li>&#13;
   &#13;
      <li class="numbered" value="5">Uses<a id="_idIndexMarker463"/> the <code class="Code-In-Text--PACKT-">Translate</code> method, which takes in a <code class="Code-In-Text--PACKT-">Vector3</code> parameter, to move the capsule's Transform component:<ul>&#13;
          <li class="bullet-l2">Remember that the <code class="Code-In-Text--PACKT-">this</code> keyword specifies the GameObject the current script is attached to, which, in this case, is the player capsule. </li>&#13;
          <li class="bullet-l2"> <code class="Code-In-Text--PACKT-">Vector3.forward</code> multiplied by <code class="Code-In-Text--PACKT-">_vInput</code> and <code class="Code-In-Text--PACKT-">Time.deltaTime</code> supplies the direction and speed the capsule needs to move forward or back along the <em class="italic">z</em> axis at the speed we've calculated.</li>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">Time.deltaTime</code> will always return the value in seconds since the last frame of the game was executed. It's commonly used to smooth values that are captured or run in the <code class="Code-In-Text--PACKT-">Update</code> method instead of letting it be determined by a device's frame rate.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Uses the <code class="Code-In-Text--PACKT-">Rotate</code> method to rotate the capsule's Transform component relative to the vector we pass in as a parameter:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">Vector3.up</code> multiplied by <code class="Code-In-Text--PACKT-">_hInput</code> and <code class="Code-In-Text--PACKT-">Time.deltaTime</code> gives us the left/right rotation axis we want.</li>&#13;
          <li class="bullet-l2">We use the <code class="Code-In-Text--PACKT-">this</code> keyword and <code class="Code-In-Text--PACKT-">Time.deltaTime</code> here for the same reasons.</li>&#13;
        </ul>&#13;
      </li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">As we discussed earlier, using direction vectors in the <code class="Code-In-Text--PACKT-">Translate</code> and <code class="Code-In-Text--PACKT-">Rotate</code> functions is only one way to go about this. We could have created new Vector3 variables from our axis inputs and used them as parameters just as easily.</p>&#13;
    </div>&#13;
    <p class="normal">When you click play, you'll be able to move the capsule forward and backward using the up/down arrow keys and the <kbd class="keyStroke">W</kbd>/<kbd class="keyStroke">S</kbd> keys, while rotating or turning with the left/right arrow keys and the <kbd class="keyStroke">A</kbd>/<kbd class="keyStroke">D</kbd> keys. </p>&#13;
    <p class="normal">With these few lines of code, you've set up two separate controls that are frame rate independent <a id="_idIndexMarker464"/>and easily modified. However, our camera doesn't follow the capsule as it moves around, so let's fix that in the following section.</p>&#13;
    <h1 id="_idParaDest-160" class="title">Scripting camera behavior</h1>&#13;
    <p class="normal">The easiest<a id="_idIndexMarker465"/> way to get one GameObject to follow another is to make one of them a child of the other. When an object is a child of another, the child object's position and rotation are relative to the parent. This means that any child object will move and rotate with the parent object. </p>&#13;
    <p class="normal">However, this approach means that any kind of movement or rotation that happens to the player capsule also affects the camera, which is something we don't necessarily want. We always want the camera to be positioned a set distance behind our player and always rotate to look at it, no matter what. Luckily, we can easily set the position and rotation of the camera relative to the capsule with methods from the <code class="Code-In-Text--PACKT-">Transform</code> class. It's your task to script out the camera logic in the next challenge.</p>&#13;
    <p class="normal">Since we want the camera behavior to be entirely separate from how the player moves, we'll be controlling where the camera is positioned relative to a target we can set from the <strong class="screenText">Inspector</strong> tab:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder, name it <code class="Code-In-Text--PACKT-">CameraBehavior</code>, and drag it into <strong class="screenText">Main Camera</strong> in the <strong class="screenText">Hierarchy</strong> panel.</li>&#13;
      <li class="numbered">Add the following code and save it:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine; &#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraBehavior</span> : <span class="hljs-title">MonoBehaviour</span> &#13;
{&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 1</strong></span>&#13;
    <span class="hljs-keyword">public</span> Vector3 CamOffset= <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0f</span>, <span class="hljs-number">1.2f</span>, <span class="hljs-number">-2.6f</span>);&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 2</strong></span>&#13;
    <span class="hljs-keyword">private</span> Transform _target;&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Start</span><span class="hljs-function">()</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 3</strong></span>&#13;
        _target = GameObject.Find(<span class="hljs-string">"Player"</span>).transform;&#13;
    }&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 4</strong></span>&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">LateUpdate</span><span class="hljs-function">()</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 5</strong></span>&#13;
        <span class="hljs-keyword">this</span>.transform.position = _target.TransformPoint(CamOffset);&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 6</strong></span>&#13;
        <span class="hljs-keyword">this</span>.transform.LookAt(_target);&#13;
    } &#13;
} &#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Here's a <a id="_idIndexMarker466"/>breakdown of the preceding code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Declares a <code class="Code-In-Text--PACKT-">Vector3</code> variable to store the distance we want between the <strong class="screenText">Main Camera</strong> and the <strong class="screenText">Player</strong> capsule:<ul>&#13;
          <li class="bullet-l2">We'll be able to manually set the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> positions of the camera offset in the <strong class="screenText">Inspector</strong> because it's <code class="Code-In-Text--PACKT-">public</code>.</li>&#13;
          <li class="bullet-l2">These default values are what I think looks best, but feel free to experiment.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Creates a variable to hold the player capsule's Transform information:<ul>&#13;
          <li class="bullet-l2">This will give us access to its position, rotation, and scale.</li>&#13;
          <li class="bullet-l2">We don't want any other script to be able to change the camera's target, which is why it's <code class="Code-In-Text--PACKT-">private</code>.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Uses <code class="Code-In-Text--PACKT-">GameObject.Find</code> to locate the capsule by name and retrieve its Transform property from the scene:<ul>&#13;
          <li class="bullet-l2">This means the capsule's <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> positions are updated and stored in the <code class="Code-In-Text--PACKT-">_target</code> variable every frame.</li>&#13;
          <li class="bullet-l2">Finding objects in the scene is a computationally expensive task, so it's good practice to only do it once in the <code class="Code-In-Text--PACKT-">Start</code> method and store the reference. Never use <code class="Code-In-Text--PACKT-">GameObject.Find</code> in the <code class="Code-In-Text--PACKT-">Update</code> method, as that will try to continually find the object you're looking for and potentially crash the game.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered"><code class="Code-In-Text--PACKT-">LateUpdate</code> is a <code class="Code-In-Text--PACKT-">MonoBehavior</code> method, like <code class="Code-In-Text--PACKT-">Start</code> or <code class="Code-In-Text--PACKT-">Update</code>, that executes after <code class="Code-In-Text--PACKT-">Update</code>:<ul>&#13;
          <li class="bullet-l2">Since our <code class="Code-In-Text--PACKT-">PlayerBehavior</code> script moves the capsule in its <code class="Code-In-Text--PACKT-">Update</code> method, we want the code in <code class="Code-In-Text--PACKT-">CameraBehavior</code> to run after the movement happens; this guarantees that <code class="Code-In-Text--PACKT-">_target</code> has the most up-to-date position to reference.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Sets the camera's position to <code class="Code-In-Text--PACKT-">_target.TransformPoint(CamOffset)</code> for every frame, which creates the following effect:<ul>&#13;
          <li class="bullet-l2">The <code class="Code-In-Text--PACKT-">TransformPoint</code> method calculates and returns a relative position in the world space.</li>&#13;
          <li class="bullet-l2">In this case, it returns the position of the <code class="Code-In-Text--PACKT-">target</code> (our capsule) offset by <code class="Code-In-Text--PACKT-">0</code> in the <em class="italic">x</em> axis, <code class="Code-In-Text--PACKT-">1.2</code> in <em class="italic">the</em> y axis (putting the camera above the capsule), and <code class="Code-In-Text--PACKT-">-2.6</code> in the <em class="italic">z</em> axis (putting the camera slightly behind the capsule).</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">The <code class="Code-In-Text--PACKT-">LookAt</code> method <a id="_idIndexMarker467"/>updates the capsule's rotation every frame, focusing on the Transform parameter we pass in, which, in this case, is <code class="Code-In-Text--PACKT-">_target</code>:<figure class="mediaobject"><img src="Images/B17573_07_05.png" alt="" width="748" height="247"/></figure>&#13;
    <p class="packt_figref">Figure 7.5: Capsule and following camera in Play mode</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">This was a lot to take in, but it's easier to process if you break it down into its chronological steps:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">We created an offset position for the camera.</li>&#13;
      <li class="numbered">We found and stored the player capsule's position.</li>&#13;
      <li class="numbered">We manually updated its position and rotation every frame so that it's always following at a set distance and looking at the player.</li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">When using class methods that deliver platform-specific functionality, always remember to break things down to their most basic steps. This will help you to stay above water in new programming environments.</p>&#13;
    </div>&#13;
    <p class="normal">While the code you've written to manage player movement is perfectly functional, you might have <a id="_idIndexMarker468"/>noticed that it's a little jerky in places. To create a smoother, more realistic movement effect, you'll need to understand the basics of the Unity physics system, which you'll dive into next. </p>&#13;
    <h1 id="_idParaDest-161" class="title">Working with the Unity physics system</h1>&#13;
    <p class="normal">Up to this point, we <a id="_idIndexMarker469"/>haven't talked about how the Unity engine works, or how it manages to create lifelike interactions and movement in a virtual space. We'll spend the rest of this chapter learning the basics of Unity's physics system.</p>&#13;
    <p class="normal">The two main components that<a id="_idIndexMarker470"/> power Unity's NVIDIA PhysX engine are as follows:</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="screenText">Rigidbody</strong> components, which <a id="_idIndexMarker471"/>allow <a id="_idIndexMarker472"/>GameObjects to be affected by gravity and add properties such as <strong class="screenText">Mass</strong> and <strong class="screenText">Drag</strong>. Rigidbody components can also be affected by an applied force if they have a Collider component attached, which generates more realistic movement:<figure class="mediaobject"><img src="Images/B17573_07_06.png" alt="" width="751" height="389"/></figure>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="packt_figref">Figure 7.6: Rigidbody component in the Inspector pane</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="screenText">Collider</strong> components, which<a id="_idIndexMarker473"/> determine <a id="_idIndexMarker474"/>how and when GameObjects enter and exit each other's physical space or simply collide and bounce away. While there should only be one Rigidbody component attached to a given GameObject, there can be several Collider components if you need different shapes or interactions. This is commonly referred to as a compound Collider setup:<figure class="mediaobject"><img src="Images/B17573_07_07.png" alt="" width="750" height="264"/></figure>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="packt_figref">Figure 7.7: Box collider component in the Inspector pane</p>&#13;
    <p class="normal">When<a id="_idIndexMarker475"/> two Collider components interact with each other, the Rigidbody properties determine the resulting interaction. For example, if one GameObject's mass is higher than the other, the lighter GameObject will bounce away with more force, just like in real life. These two components are responsible for all physical interactions and simulated movement in Unity.</p>&#13;
    <p class="normal">There are some caveats to using these components, which are best understood in terms of the types of movement Unity allows:</p>&#13;
    <ul>&#13;
      <li class="bullet"><em class="italic">Kinematic</em> movement<a id="_idIndexMarker476"/> happens when a<a id="_idIndexMarker477"/> Rigidbody component is attached to a GameObject, but it doesn't register to the physics system in the scene. In other words, kinematic objects have physics interactions but don't react to them, like a wall in real life. This is only used in certain cases and can be enabled by checking the <strong class="screenText">Is Kinematic</strong> property of a Rigidbody component. Since we want our capsule to interact with the physics system, we won't be using this kind of motion.</li>&#13;
      <li class="bullet"><em class="italic">Non-kinematic</em> movement is <a id="_idIndexMarker478"/>when a Rigidbody <a id="_idIndexMarker479"/>component is moved or rotated by applying force rather than manually changing a GameObject's Transform properties. Our goal for this section is to update the <code class="Code-In-Text--PACKT-">PlayerBehavior</code> script to implement this type of motion.</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">The setup we have now, that is, manipulating the capsule's Transform component while using a Rigidbody component to interact with the physics system, was meant to get you thinking about movement and rotation in a 3D space. However, it's not meant for production and Unity suggests avoiding a mix of kinematic and non-kinematic movement in your code.</p>&#13;
    </div>&#13;
    <p class="normal">Your next task is to use applied force to convert the current movement system into a more realistic locomotion experience.</p>&#13;
    <h2 id="_idParaDest-162" class="title">Rigidbody components in motion</h2>&#13;
    <p class="normal">Since our player<a id="_idIndexMarker480"/> has a Rigidbody component attached, we should let the physics engine control our movement instead of manually translating and rotating the Transform. There are two options when it comes to applying force:</p>&#13;
    <ul>&#13;
      <li class="bullet">You can do it directly by using Rigidbody class methods such as <code class="Code-In-Text--PACKT-">AddForce</code> and <code class="Code-In-Text--PACKT-">AddTorque</code> to move and rotate an object, respectively. This approach has its drawbacks and often requires additional code to compensate for unexpected physics behavior such as unwanted torque or applied force during collisions.</li>&#13;
      <li class="bullet">Alternatively, you can use other Rigidbody class methods such as <code class="Code-In-Text--PACKT-">MovePosition</code> and <code class="Code-In-Text--PACKT-">MoveRotation</code>, which still use applied force. </li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">We'll take the second route in the next section so that Unity takes care of the applied physics for us, but if you're curious about manually applying force and torque to your<a id="_idIndexMarker481"/> GameObjects, then start here: <a href="https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html"><span class="url">https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">Either of these will give the player a more lifelike feel and allow us to add in jumping and dashing mechanics in <em class="chapterRef">Chapter 8</em>, <em class="italic">Scripting Game Mechanics</em>.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">If you're curious about what happens when a moving object without a Rigidbody component interacts with pieces of the environment that have them equipped, remove the component from the Player and run around the arena. Congratulations—you're a ghost and can walk through walls! Don't forget to add the Rigidbody component back, though!</p>&#13;
    </div>&#13;
    <p class="normal">The player <a id="_idIndexMarker482"/>capsule already has a Rigidbody component attached, which means that you can access and modify its properties. First, though, you'll need to find and store the component, which is your next challenge.</p>&#13;
    <p class="normal">You'll need to access and store the Rigidbody component on our player capsule before modifying it. Update <code class="Code-In-Text--PACKT-">PlayerBehavior</code> with the following changes:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine;&#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerBehavior</span> : <span class="hljs-title">MonoBehaviour</span> &#13;
{&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MoveSpeed = <span class="hljs-number">10f</span>;&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> RotateSpeed = <span class="hljs-number">75f</span>;&#13;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _vInput;&#13;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _hInput;&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 1</strong></span>&#13;
    <span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> Rigidbody _rb;</strong></span>&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 2</strong></span>&#13;
    <span class="code-highlight"><strong class="hljs-keyword-slc">void</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Start</strong><strong class="hljs-function-slc">()</strong></span>&#13;
    <span class="code-highlight"><strong class="hljs-slc">{</strong></span>&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 3</strong></span>&#13;
        <span class="code-highlight"><strong class="hljs-slc">_rb = GetComponent&lt;Rigidbody&gt;();</strong></span>&#13;
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Update</span><span class="hljs-function">()</span>&#13;
    {&#13;
      _vInput = Input.GetAxis(<span class="hljs-string">"Vertical"</span>) * MoveSpeed;&#13;
      _hInput = Input.GetAxis(<span class="hljs-string">"Horizontal"</span>) * RotateSpeed;&#13;
      <span class="code-highlight"><strong class="hljs-comment-slc">/*</strong></span>&#13;
<span class="hljs-comment">      this.transform.Translate(Vector3.forward * _vInput * </span>&#13;
<span class="hljs-comment">      Time.deltaTime);</span>&#13;
<span class="hljs-comment">      this.transform.Rotate(Vector3.up * _hInput * Time.deltaTime);</span>&#13;
<span class="hljs-comment">      </span><span class="code-highlight"><strong class="hljs-comment-slc">*/</strong></span>&#13;
    }&#13;
} &#13;
</code></pre>&#13;
    <p class="normal">Here's a breakdown of the preceding code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Adds a private variable of type <code class="Code-In-Text--PACKT-">Rigidbody</code> that will contain a reference to the capsule's Rigidbody component.</li>&#13;
      <li class="numbered">The <code class="Code-In-Text--PACKT-">Start</code> method fires when a script is initialized in a scene, which happens when you click on play, and should be used any time variables need to be set at the beginning of a class.</li>&#13;
      <li class="numbered">The <code class="Code-In-Text--PACKT-">GetComponent</code> method checks whether the component type we're looking for, in this case, <code class="Code-In-Text--PACKT-">Rigidbody</code>, exists on the GameObject the script is attached to and returns it:<ul>&#13;
          <li class="bullet-l2">If the component isn't attached to the GameObject, the method will return <code class="Code-In-Text--PACKT-">null</code>, but since we know there's one on the player, we won't worry about error checking right now.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Comments out the <code class="Code-In-Text--PACKT-">Transform</code> and <code class="Code-In-Text--PACKT-">Rotate</code> method calls in the <code class="Code-In-Text--PACKT-">Update</code> function so that we won't be running two different kinds of player controls:<ul>&#13;
          <li class="bullet-l2">We want to keep our code that captures player input so that we can still use it later on.</li>&#13;
        </ul>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">You've<a id="_idIndexMarker483"/> initialized and stored the Rigidbody component on the player capsule and commented out the obsolete <code class="Code-In-Text--PACKT-">Transform</code> code to set the stage for physics-based movement. The character is now ready for the next challenge, which is to add force.</p>&#13;
    <p class="normal">Use the following steps to move and rotate the Rigidbody component. Add in the following code to <code class="Code-In-Text--PACKT-">PlayerBehavior</code> underneath the <code class="Code-In-Text--PACKT-">Update</code> method, and then save the file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 1</span>&#13;
<span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">FixedUpdate</span><span class="hljs-function">()</span>&#13;
{&#13;
    <span class="hljs-comment">// 2</span>&#13;
    Vector3 rotation = Vector3.up * _hInput;&#13;
    <span class="hljs-comment">// 3</span>&#13;
    Quaternion angleRot = Quaternion.Euler(rotation *&#13;
        Time.fixedDeltaTime);&#13;
    <span class="hljs-comment">// 4</span>&#13;
    _rb.MovePosition(<span class="hljs-keyword">this</span>.transform.position +&#13;
        <span class="hljs-keyword">this</span>.transform.forward * _vInput * Time.fixedDeltaTime);&#13;
     <span class="hljs-comment">// 5</span>&#13;
     _rb.MoveRotation(_rb.rotation * angleRot);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Here's a <a id="_idIndexMarker484"/>breakdown of the preceding code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Any physics- or Rigidbody-related code always goes inside the <code class="Code-In-Text--PACKT-">FixedUpdate</code> method, rather than <code class="Code-In-Text--PACKT-">Update</code> or the other <code class="Code-In-Text--PACKT-">MonoBehavior</code> methods:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">FixedUpdate</code> is frame rate independent and is used for all physics code. </li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Creates a new <code class="Code-In-Text--PACKT-">Vector3</code> variable to store our left and right rotation:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">Vector3.up * _hInput</code> is the same rotation vector we used with the <code class="Code-In-Text--PACKT-">Rotate</code> method in the previous example.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered"><code class="Code-In-Text--PACKT-">Quaternion.Euler</code> takes a <code class="Code-In-Text--PACKT-">Vector3</code> parameter and returns a rotation value in Euler angles:<ul>&#13;
          <li class="bullet-l2">We need a <code class="Code-In-Text--PACKT-">Quaternion</code> value instead of a <code class="Code-In-Text--PACKT-">Vector3</code> parameter to use the <code class="Code-In-Text--PACKT-">MoveRotation</code> method. This is just a conversion to the rotation type that Unity prefers.</li>&#13;
          <li class="bullet-l2">We multiply by <code class="Code-In-Text--PACKT-">Time.fixedDeltaTime</code> for the same reason we used <code class="Code-In-Text--PACKT-">Time.deltaTime</code> in <code class="Code-In-Text--PACKT-">Update</code>.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Calls <code class="Code-In-Text--PACKT-">MovePosition</code> on our <code class="Code-In-Text--PACKT-">_rb</code> component, which takes in a <code class="Code-In-Text--PACKT-">Vector3</code> parameter and applies force accordingly:<ul>&#13;
          <li class="bullet-l2">The vector that's used can be broken down as follows: the capsule's <code class="Code-In-Text--PACKT-">Transform</code> position in the forward direction, multiplied by the vertical inputs and <code class="Code-In-Text--PACKT-">Time.fixedDeltaTime</code>.</li>&#13;
          <li class="bullet-l2">The Rigidbody component takes care of applying movement force to satisfy our vector parameter.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Calls the <code class="Code-In-Text--PACKT-">MoveRotation</code> method on the <code class="Code-In-Text--PACKT-">_rb</code> component, which also takes in a <code class="Code-In-Text--PACKT-">Vector3</code> parameter and applies the corresponding forces under the hood:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">angleRot</code> already has the horizontal inputs from the keyboard, so all we need to do is multiply the current Rigidbody rotation by <code class="Code-In-Text--PACKT-">angleRot</code> to get the same left and right rotation.</li>&#13;
        </ul>&#13;
      </li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Be aware that <code class="Code-In-Text--PACKT-">MovePosition</code> and <code class="Code-In-Text--PACKT-">MoveRotation</code> work differently for non-kinematic game objects. You can find more information in the Rigidbody scripting <a id="_idIndexMarker485"/>reference at <a href="https://docs.unity3d.com/ScriptReference/Rigidbody.html"><span class="url">https://docs.unity3d.com/ScriptReference/Rigidbody.html</span></a>. </p>&#13;
    </div>&#13;
    <p class="normal">If you<a id="_idIndexMarker486"/> click on play now, you'll be able to move forward and backward in the direction you're looking, as well as rotate around the <em class="italic">y </em>axis. </p>&#13;
    <p class="normal">Applied force produces stronger effects than translating and rotating a Transform component, so you may need to fine-tune the <code class="Code-In-Text--PACKT-">MoveSpeed</code> and <code class="Code-In-Text--PACKT-">RotateSpeed</code> variables in the <strong class="screenText">Inspector</strong> pane. You've now recreated the same type of movement scheme as before, just with more realistic physics.</p>&#13;
    <p class="normal">If you run up a ramp or drop off the central platform, you might see the player launch into the air, or slowly drop to the ground. Even though the Rigidbody component is set to use gravity, it's fairly weak. We'll tackle applying our gravity to the player in the next chapter when we implement the jump mechanic. For now, your job is to get comfortable with how Collider components handle collisions in Unity.</p>&#13;
    <h2 id="_idParaDest-163" class="title">Colliders and collisions</h2>&#13;
    <p class="normal">Collider components <a id="_idIndexMarker487"/>not only allow GameObjects to be recognized by Unity's physics system, but they also make interactions and <a id="_idIndexMarker488"/>collisions possible. Think of colliders as invisible force fields that surround GameObjects; they can be passed through or bumped into depending on their settings, and they come with a host of methods that execute during different interactions.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Unity's physics system works differently for 2D and 3D games, so we will only be covering the 3D topics in this book. If you're interested in making 2D games, refer to <a id="_idIndexMarker489"/>the <code class="Code-In-Text--PACKT-">Rigidbody2D</code> component at <a href="https://docs.unity3d.com/Manual/class-Rigidbody2D.html"><span class="url">https://docs.unity3d.com/Manual/class-Rigidbody2D.html</span></a> and the list of available<a id="_idIndexMarker490"/> 2D colliders at <a href="https://docs.unity3d.com/Manual/Collider2D.html"><span class="url">https://docs.unity3d.com/Manual/Collider2D.html</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">Take a look at the following screenshot of the <strong class="screenText">Capsule</strong> in the <strong class="screenText">Health_Pickup</strong> object. If you want to see the <strong class="screenText">Capsule Collider</strong> a little better, increase the <strong class="screenText">Radius</strong> property:</p>&#13;
    <figure class="mediaobject"><img src="Images/B17573_07_08.png" alt="" width="824" height="225"/></figure>&#13;
    <p class="packt_figref">Figure 7.8: Capsule collider component attached to pickup item</p>&#13;
    <p class="normal">The green <a id="_idIndexMarker491"/>shape around the object is the <strong class="screenText">Capsule Collider</strong>, which can be moved and scaled using the <strong class="screenText">Center</strong>, <strong class="screenText">Radius</strong>, and <strong class="screenText">Height </strong>properties. </p>&#13;
    <p class="normal">When a primitive is created, the Collider matches the primitive's shape by default; since we created a capsule primitive, it comes with a Capsule Collider.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Colliders also come in <strong class="screenText">Box</strong>, <strong class="screenText">Sphere</strong>, and <strong class="screenText">Mesh</strong> shapes and can be manually added from the <strong class="screenText">Component</strong> | <strong class="screenText">Physics</strong> menu or from the <strong class="screenText">Add Component</strong> button in the <strong class="screenText">Inspector</strong>.</p>&#13;
    </div>&#13;
    <p class="normal">When a Collider comes into contact with other components, it sends out what's called a message, or broadcast. Any script that adds one or more of those methods will receive a notification when the Collider sends out a message. This is <a id="_idIndexMarker492"/>called an <em class="italic">event</em>, which is a topic that we'll cover in more detail in <em class="chapterRef">Chapter 14</em>, <em class="italic">The Journey Continues</em>.</p>&#13;
    <p class="normal">For example, when two GameObjects with colliders come into contact, both objects register an <code class="Code-In-Text--PACKT-">OnCollisionEnter</code> event, complete with a reference to the object they ran into. Think of an event like a message being sent out – if you choose to listen for it you'll get notified when a collision happens in this case. This information can be used to track a variety of interactive events, but the simplest one is picking up an item. For cases where you want objects to be able to pass through others, you can use collision triggers, which we'll talk about in the next section.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">A complete list <a id="_idIndexMarker493"/>of Collider notifications can be found here underneath the <strong class="screenText">Messages</strong> header at <a href="https://docs.unity3d.com/ScriptReference/Collider.html"><span class="url">https://docs.unity3d.com/ScriptReference/Collider.html</span></a>.</p>&#13;
      <p class="Information-Box--PACKT-">Collision and trigger events are only sent out when the colliding objects belong to a specific combination of Collider, Trigger, and RigidBody components and kinematic or non-kinematic motion. You can find details <a id="_idIndexMarker494"/>under the <strong class="screenText">Collision action matrix</strong> section at <a href="https://docs.unity3d.com/Manual/CollidersOverview.html"><span class="url">https://docs.unity3d.com/Manual/CollidersOverview.html</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">The health <a id="_idIndexMarker495"/>item you previously created is a perfect place to test out how collisions work. You'll tackle that in the next challenge.</p>&#13;
    <h3 id="_idParaDest-164" class="title">Picking up an item</h3>&#13;
    <p class="normal">To update<a id="_idIndexMarker496"/> the <code class="Code-In-Text--PACKT-">Health_Pickup</code> object using collision logic, you need to do the following:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder, name it <code class="Code-In-Text--PACKT-">ItemBehavior</code>, and then drag it onto the <code class="Code-In-Text--PACKT-">Health_Pickup</code> object in the <strong class="screenText">Hierarchy</strong> panel:<ul>&#13;
          <li class="bullet-l2">Any script that uses collision detection <em class="italic">must</em> be attached to a GameObject with a Collider component, even if it's the child of a Prefab.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Select <code class="Code-In-Text--PACKT-">Health_Pickup</code> in the <strong class="screenText">Hierarchy panel</strong>, click the three vertical dots icon in the <strong class="screenText">Inspector </strong>to the right of the <strong class="screenText">Item Behavior (Script) </strong>component, and choose <strong class="screenText">Added Component</strong> | <strong class="screenText">Apply to Prefab 'Health_Pickup'</strong>:<figure class="mediaobject"><img src="Images/B17573_07_09.png" alt="" width="496" height="293"/></figure>&#13;
        <p class="packt_figref">Figure 7.9: Applying Prefab changes to pickup item</p>&#13;
      </li>&#13;
      <li class="numbered">Replace <a id="_idIndexMarker497"/>the default code in <code class="Code-In-Text--PACKT-">ItemBehavior</code> with the following, and then save it:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine;&#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemBehavior</span> : <span class="hljs-title">MonoBehaviour</span> &#13;
{&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 1</strong></span>&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnCollisionEnter</span><span class="hljs-function">(</span><span class="hljs-params">Collision collision</span><span class="hljs-function">)</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 2</strong></span>&#13;
        <span class="hljs-keyword">if</span>(collision.gameObject.name == <span class="hljs-string">"Player"</span>)&#13;
        {&#13;
            <span class="code-highlight"><strong class="hljs-comment-slc">// 3</strong></span>&#13;
            Destroy(<span class="hljs-keyword">this</span>.transform.gameObject);&#13;
            <span class="code-highlight"><strong class="hljs-comment-slc">// 4</strong></span>&#13;
            Debug.Log(<span class="hljs-string">"Item collected!"</span>);&#13;
        }&#13;
    }&#13;
} &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Click on play and move the player over the capsule to pick it up!</li>&#13;
    </ol>&#13;
    <p class="normal">Here's a breakdown of the preceding code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">When another object runs into the <code class="Code-In-Text--PACKT-">Item</code> Prefab, Unity automatically calls the <code class="Code-In-Text--PACKT-">OnCollisionEnter</code> method:<ul>&#13;
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">OnCollisionEnter</code> comes with a parameter that stores a reference to the Collider that ran into it.</li>&#13;
          <li class="bullet-l2">Notice that the collision is of type <code class="Code-In-Text--PACKT-">Collision</code>, not <code class="Code-In-Text--PACKT-">Collider</code>.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">The <code class="Code-In-Text--PACKT-">Collision</code> class has a property, called <code class="Code-In-Text--PACKT-">gameObject</code>, which holds a reference to the colliding GameObject's Collider:<ul>&#13;
          <li class="bullet-l2">We can use this property to get the GameObject's name and use an <code class="Code-In-Text--PACKT-">if</code> statement to check whether the colliding object is the player.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">If the colliding object is the player, we'll call the <code class="Code-In-Text--PACKT-">Destroy()</code> method, which takes in a GameObject parameter and removes the object from the scene.</li>&#13;
      <li class="numbered">It then prints out a simple log to the console that we have collected an item:<figure class="mediaobject"><img src="Images/B17573_07_10.png" alt="" width="751" height="290"/></figure>&#13;
    <p class="packt_figref">Figure 7.10: Example of game objects being deleted from a scene</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">We've set<a id="_idIndexMarker498"/> up <code class="Code-In-Text--PACKT-">ItemBehavior</code> to essentially listen for any collisions with the <code class="Code-In-Text--PACKT-">Health_Pickup</code> object Prefab. Whenever a collision occurs, <code class="Code-In-Text--PACKT-">ItemBehavior</code> uses <code class="Code-In-Text--PACKT-">OnCollisionEnter()</code> and checks whether the colliding object is the player and, if so, destroys (or collects) the item.</p>&#13;
    <p class="normal">If you're feeling lost, think of the collision code we wrote as a receiver for notifications from the <code class="Code-In-Text--PACKT-">Health_Pickup</code>; any time it's hit, the code fires. </p>&#13;
    <p class="normal">It's also important to understand that we could have created a similar script with an <code class="Code-In-Text--PACKT-">OnCollisionEnter()</code> method, attached it to the player, and then checked whether the colliding object was a<code class="Code-In-Text--PACKT-"> Health_Pickup</code> Prefab. Collision logic depends on the perspective of the object being collided with. </p>&#13;
    <p class="normal">Now the question is, how would you set up a collision without stopping the colliding objects from moving through each other? We'll tackle that in the next section.</p>&#13;
    <h2 id="_idParaDest-165" class="title">Using Collider triggers</h2>&#13;
    <p class="normal">By default, Colliders <a id="_idIndexMarker499"/>are set with the <code class="Code-In-Text--PACKT-">isTrigger</code> property <a id="_idIndexMarker500"/>unchecked, meaning that the physics system treats them as solid objects and will raise a Collision event on impact. However, in some cases, you'll want to be able to pass through a Collider component without it stopping your GameObject. This is where triggers come in. With <code class="Code-In-Text--PACKT-">isTrigger</code> checked, a GameObject can pass through it, but the Collider will send out the <code class="Code-In-Text--PACKT-">OnTriggerEnter</code>, <code class="Code-In-Text--PACKT-">OnTriggerExit</code>, and <code class="Code-In-Text--PACKT-">OnTriggerStay</code> notifications instead.</p>&#13;
    <p class="normal">Triggers are most useful when you need to detect when a GameObject enters a certain area or passes a certain point. We'll use this to set up the areas around our enemies; if the player walks <a id="_idIndexMarker501"/>into the trigger zone, the <a id="_idIndexMarker502"/>enemies will be alerted, and, later on, attack the player. For now, you're going to focus just on the enemy logic in the following challenge.</p>&#13;
    <h3 id="_idParaDest-166" class="title">Creating an enemy</h3>&#13;
    <p class="normal">Use the<a id="_idIndexMarker503"/> following<a id="_idIndexMarker504"/> steps to create an enemy:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a new primitive using <strong class="screenText">+</strong> | <strong class="screenText">3D Object</strong> | <strong class="screenText">Capsule</strong> in the <strong class="screenText">Hierarchy</strong> panel and name it <code class="Code-In-Text--PACKT-">Enemy</code>.</li>&#13;
      <li class="numbered">Inside the <code class="Code-In-Text--PACKT-">Materials</code> folder, use <strong class="screenText">+</strong> | <strong class="screenText">Material</strong>, name it <code class="Code-In-Text--PACKT-">Enemy_Mat</code>, and set its <strong class="screenText">Albedo</strong> property to a bright red:<ul>&#13;
          <li class="bullet-l2">Drag and drop <code class="Code-In-Text--PACKT-">Enemy_Mat</code> into the <code class="Code-In-Text--PACKT-">Enemy</code> GameObject.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">With <code class="Code-In-Text--PACKT-">Enemy</code> selected, click on <strong class="screenText">Add Component</strong>, search for <strong class="screenText">Sphere Collider</strong>, and hit <kbd class="keyStroke">Enter</kbd> to add it:<ul>&#13;
          <li class="bullet-l2">Check the <strong class="screenText">isTrigger </strong>property box and change the <strong class="screenText">Radius</strong> to <code class="Code-In-Text--PACKT-">8</code>:</li>&#13;
        </ul>&#13;
        <figure class="mediaobject"><img src="Images/B17573_07_11.png" alt="" width="752" height="246"/></figure>&#13;
    <p class="packt_figref">Figure 7.11: Sphere collider component attached to an enemy object</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">Our new <strong class="screenText">Enemy</strong> primitive is now surrounded by an 8-unit trigger radius shaped like a sphere. Any time another object enters, stays inside, or exits that area, Unity will send out notifications that we can capture, just like we did with collisions. Your next challenge will be to capture that notification and act on it in code.</p>&#13;
    <p class="normal">To capture trigger events, you'll need to create a new script by following these steps:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a new C# script in the <code class="Code-In-Text--PACKT-">Scripts</code> folder, name it <code class="Code-In-Text--PACKT-">EnemyBehavior</code>, and then drag it into <strong class="screenText">Enemy</strong>.</li>&#13;
      <li class="numbered">Add the<a id="_idIndexMarker505"/> following code and save the file:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine;&#13;
       &#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnemyBehavior</span> : <span class="hljs-title">MonoBehaviour</span> &#13;
{&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 1</strong></span>&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnTriggerEnter</span><span class="hljs-function">(</span><span class="hljs-params">Collider other</span><span class="hljs-function">)</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">//2</strong></span><span class="hljs-comment"> </span>&#13;
        <span class="hljs-keyword">if</span>(other.name == <span class="hljs-string">"Player"</span>)&#13;
        {&#13;
            Debug.Log(<span class="hljs-string">"Player detected - attack!"</span>);&#13;
        }&#13;
    }&#13;
    <span class="code-highlight"><strong class="hljs-comment-slc">// 3</strong></span>&#13;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnTriggerExit</span><span class="hljs-function">(</span><span class="hljs-params">Collider other</span><span class="hljs-function">)</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-comment-slc">// 4</strong></span>&#13;
        <span class="hljs-keyword">if</span>(other.name == <span class="hljs-string">"Player"</span>)&#13;
        {&#13;
            Debug.Log(<span class="hljs-string">"Player out of range, resume patrol"</span>);&#13;
        }&#13;
    }&#13;
} &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Click play and walk over to the Enemy to set off the first notification, then walk away from the Enemy to set off the second notification.</li>&#13;
    </ol>&#13;
    <p class="normal">Here's a <a id="_idIndexMarker506"/>breakdown of the preceding code:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1"><code class="Code-In-Text--PACKT-">OnTriggerEnter()</code> is fired whenever an object enters the Enemy Sphere Collider radius:<ul>&#13;
          <li class="bullet-l2">Similar to <code class="Code-In-Text--PACKT-">OnCollisionEnter()</code>, <code class="Code-In-Text--PACKT-">OnTriggerEnter()</code> stores a reference to the trespassing object's Collider component.</li>&#13;
          <li class="bullet-l2">Note that <code class="Code-In-Text--PACKT-">other</code> is of type <code class="Code-In-Text--PACKT-">Collider</code>, not <code class="Code-In-Text--PACKT-">Collision</code>.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">We can <a id="_idIndexMarker507"/>use <code class="Code-In-Text--PACKT-">other</code> to access the name of the colliding GameObject, and check whether it's the <code class="Code-In-Text--PACKT-">Player</code> with an <code class="Code-In-Text--PACKT-">if</code> statement. If it is, the console prints out a log that <a id="_idIndexMarker508"/>the <code class="Code-In-Text--PACKT-">Player</code> is in the danger zone.<figure class="mediaobject"><img src="Images/B17573_07_12.png" alt="" width="750" height="541"/></figure>&#13;
        <p class="packt_figref">Figure 7.12: Collision detection between player and enemy objects</p>&#13;
      </li>&#13;
      <li class="numbered"><code class="Code-In-Text--PACKT-">OnTriggerExit()</code> is fired when an object leaves the Enemy Sphere Collider radius:<ul>&#13;
          <li class="bullet-l2">This method also has a reference to the colliding object's Collider component:</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">We check the object leaving the Sphere Collider radius by name using another <code class="Code-In-Text--PACKT-">if</code> statement:<ul>&#13;
          <li class="bullet-l2">If it's <code class="Code-In-Text--PACKT-">Player</code>, we print out another log to the console saying that they're safe:</li>&#13;
        </ul>&#13;
        <figure class="mediaobject"><img src="Images/B17573_07_13.png" alt="" width="751" height="601"/></figure>&#13;
    <p class="packt_figref">Figure 7.13: Example of collision triggers</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">The Sphere Collider <a id="_idIndexMarker509"/>on our Enemy sends out notifications <a id="_idIndexMarker510"/>when its area is invaded, and the <code class="Code-In-Text--PACKT-">EnemyBehavior</code> script captures two of those events. Whenever the player enters or exits the collision radius, a debug log appears in the console to let us know that the code is working. We'll continue to build on this in <em class="chapterRef">Chapter 9</em>, <em class="italic">Basic AI and Enemy Behavior</em>.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Unity makes use of something called the Component design pattern. Without going into too much detail, that's a fancy way of saying objects (and, by extension, their classes) should be responsible for their behavior as opposed to having all the code in one huge file. This is why we put separate collision scripts on the pickup item and enemy instead of having a single class handle everything. We'll discuss this further in <em class="chapterRef">Chapter 14</em>, <em class="italic">The Journey Continues</em>.</p>&#13;
    </div>&#13;
    <p class="normal">Since this <a id="_idIndexMarker511"/>book is <a id="_idIndexMarker512"/>all about instilling as many good programming habits as possible, your last task for the chapter is to make sure all your core objects are converted into Prefabs.</p>&#13;
    <h3 id="_idParaDest-167" class="title">Hero's trial – all the Prefabs!</h3>&#13;
    <p class="normal">To get the <a id="_idIndexMarker513"/>project ready for the next chapter, go ahead and drag the <code class="Code-In-Text--PACKT-">Player</code> and <code class="Code-In-Text--PACKT-">Enemy</code> objects into the <strong class="screenText">Prefabs </strong>folder. Remember, from now on you always need to right-click on the Prefab in the <strong class="screenText">Hierarchy</strong> panel and choose <strong class="screenText">Added Component</strong> | <strong class="screenText">Apply to Prefab</strong> to solidify any changes you make to these GameObjects.</p>&#13;
    <p class="normal">With that done, continue to the <em class="italic">Physics roundup</em> section and make sure that you've internalized all the major topics we've covered before moving on.</p>&#13;
    <h2 id="_idParaDest-168" class="title">Physics roundup</h2>&#13;
    <p class="normal">Before we wrap up the chapter, here <a id="_idIndexMarker514"/>are a few high-level concepts to cement what we've learned so far:</p>&#13;
    <ul>&#13;
      <li class="bullet">Rigidbody components add simulated real-world physics to GameObjects they are attached to.</li>&#13;
      <li class="bullet">Collider components interact with each other, as well as objects, using Rigidbody components:<ul>&#13;
          <li class="bullet-l2">If a Collider component is not a trigger, it acts as a solid object.</li>&#13;
          <li class="bullet-l2">If a Collider component is a trigger, it can be walked through.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bullet">An object is <em class="italic">kinematic</em> if it uses a Rigidbody component and has <strong class="screenText">Is Kinematic</strong> checked, telling the physics system to ignore it.</li>&#13;
      <li class="bullet">An object is <em class="italic">non-kinematic</em> if it uses a Rigidbody component and applied force or torque to power its movement and rotation.</li>&#13;
      <li class="bullet">Colliders send out notifications based on their interactions. These notifications depend on whether the Collider component is set to be triggered or not. Notifications can be received from either colliding party, and they come with reference variables that hold an object's collision information.</li>&#13;
    </ul>&#13;
    <p class="normal">Remember, a topic as broad and complex as the Unity physics system isn't learned in a day. Use what you've learned here as a springboard to launch yourself into more intricate topics!</p>&#13;
    <h1 id="_idParaDest-169" class="title">Summary</h1>&#13;
    <p class="normal">This wraps up your first experience of creating independent gameplay behaviors and tying them all together into a cohesive, albeit simple, game prototype. You've used vectors and basic vector math to determine positions and angles in a 3D space, and you're familiar with player input and the two main methods of moving and rotating GameObjects. You've even gone down into the bowels of the Unity physics system to get comfortable with Rigidbody physics, collisions, triggers, and event notifications. All in all, <em class="italic">Hero Born</em> is off to a great start.</p>&#13;
    <p class="normal">In the next chapter, we'll start tackling more game mechanics, including jumping, dashing, shooting projectiles, and interacting with parts of the environment. This will give you more hands-on experience of using force with Rigidbody components, gathering player input, and executing logic based on the desired scenario.</p>&#13;
    <h1 id="_idParaDest-170" class="title">Pop quiz – player controls and physics</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">What data type would you use to store 3D movement and rotation information?</li>&#13;
      <li class="numbered">What built-in Unity component allows you to track and modify player controls?</li>&#13;
      <li class="numbered">Which component adds real-world physics to a GameObject?</li>&#13;
      <li class="numbered">What method does Unity suggest using to execute physics-related code on GameObjects?</li>&#13;
    </ol>&#13;
    <h1 class="heading-1">JOIN us on Discord!</h1>&#13;
    <p class="normal">Read this book alongside other users, Unity/C# experts, and Harrison Ferrone. Ask questions, provide solutions to other readers, chat with the author via <em class="italic">Ask Me Anything sessions</em> and much more.</p>&#13;
<p class="normal">Join Now! </p>&#13;
    <p class="normal"><a href="https://packt.link/csharpunity2021"><span class="url">https://packt.link/csharpunity2021</span></a></p>&#13;
    <p class="normal"><span class="url"><img style="height: 8em; width: auto;" src="Images/QR_Code_9781801813945.png" alt="" width="354" height="354"/></span></p>&#13;
  </div>&#13;
</div></body></html>