- en: Chapter 5.  Algebraic Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章  代数数据类型
- en: 'In this chapter, I turn to the F# features that are (almost) missing among
    mainstream programming languages, such as C#, that are collectively referred to
    in computer science as **algebraic data types** ([https://en.wikipedia.org/wiki/Algebraic_data_type](https://en.wikipedia.org/wiki/Algebraic_data_type)
    ). They advance primitive data types to the higher type level with the help of
    the composition of other types (primitive or in-turn composite) which are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将转向 F# 的特性，这些特性在主流编程语言（如 C#）中几乎缺失，在计算机科学中统称为**代数数据类型**([https://en.wikipedia.org/wiki/Algebraic_data_type](https://en.wikipedia.org/wiki/Algebraic_data_type)
    )。它们通过组合其他类型（原始或进一步组合）将原始数据类型提升到更高的类型级别，如下所示：
- en: '**Tuples** and **records** that represent *product algebraic data types*'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**和**记录**代表**产品代数数据类型**'
- en: '**Discriminated unions** that represent *sum algebraic types*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表**求和代数类型**的**区分联合**
- en: 'I''ll cover the same facets for each of these composite types as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将像下面这样为这些复合类型的每个方面进行覆盖：
- en: Type composition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型组合
- en: Type equality and comparison
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型相等性和比较
- en: Type decomposition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型分解
- en: Type augmentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型增强
- en: I will revisit the pattern matching as a type decomposition facility that can
    often be applied outside of the `match` construction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我将重新探讨模式匹配作为一种类型分解工具，它通常可以应用于 `match` 构造之外。
- en: Combining data with algebraic data types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据与代数数据类型结合
- en: Usually a conventional programmer considers the matter of data composition through
    the prism of the object-oriented paradigm.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，传统程序员会通过面向对象范式来考虑数据组合的问题。
- en: 'Everyone usually intuitively understands that **primitive data types** are
    basic, built-in types supported by a compiler or library: `int64` , `string` ,
    `bigint` (although if viewed with a rigor, `string` may be considered as `char`
    array, and `bigint` as a **record** ).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人通常都会直观地理解**原始数据类型**是基本、内置的类型，由编译器或库支持：`int64`、`string`、`bigint`（尽管如果严格来看，`string`可能被视为`char`数组，而`bigint`则被视为**记录**）。
- en: The next thing programmers learn is that instances of primitive types can be
    aggregated into collections such as **arrays** or **lists** . However, these collections
    are monomorphic. That is, the type of all collection members must be the same.
    Pretty limiting, huh?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员接下来学到的是，原始类型的实例可以聚合到集合中，如**数组**或**列表**。然而，这些集合是单态的。也就是说，所有集合成员的类型必须相同。这相当有限，不是吗？
- en: The object-oriented paradigm extends primitive types with **classes** . The
    class just represents a custom type that hides the details of the data composition
    with the help of encapsulation and offers visibility to just the public properties.
    Typically, .NET libraries offer plenty of such composite types, for example, `System.DateTime`
    .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象范式通过**类**扩展了原始类型。类仅代表一个自定义类型，它通过封装隐藏了数据组合的细节，并仅向公共属性提供可见性。通常，.NET 库提供了大量的此类复合类型，例如，`System.DateTime`。
- en: F# certainly supports this way of constructing composite data types as well.
    However, following the cumbersome and error-prone venue of **Plain ** **Old **
    **C ** **Objects** ( **POCO** ) each time when a composite type is required is
    not in line with the F# promise of succinct and error-free code. What would be
    the way out? Welcome to algebraic data types!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: F# 当然也支持以这种方式构造复合数据类型。然而，每次需要复合类型时都遵循繁琐且容易出错的**纯旧C**（**POCO**）方式，这与 F# 简洁且无错误的代码承诺不符。出路在哪里？欢迎来到代数数据类型！
- en: Product algebraic data types
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品代数数据类型
- en: In the simplest case, consider that I use the analogy of *set product* to combine
    types `A` and `B` ; the result would be a set of data pairs where the first pair
    constituent is of type `A` , the second constituent is of type `B` , and the whole
    combination is a Cartesian product of A and B.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，考虑我使用**集合积**的类比来组合类型 `A` 和 `B`；结果将是一个数据对集合，其中第一个对成员是类型 `A`，第二个成员是类型
    `B`，整个组合是 A 和 B 的笛卡尔积。
- en: F# offers two product algebraic data types, that is, **tuples** and **records**
    .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供了两种产品代数数据类型，即**元组**和**记录**。
- en: Tuples
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: I have already touched tuples in previous chapters; now I'll go deeper into
    this subject.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在之前的章节中提到了元组；现在我将更深入地探讨这个主题。
- en: Tuple composition
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组组合
- en: 'A tuple is a combination of two or more values of any type. The tuple value
    element type can be of anything: primitive types, other tuples, custom classes,
    and functions. For example, take a look at the following code line (`Ch5_1.fsx`
    ):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是由两个或更多任意类型的值组合而成的。元组值元素的类型可以是任何类型：原始类型、其他元组、自定义类和函数。例如，看看以下代码行（`Ch5_1.fsx`）：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This represents a tuple assembled from three elements of type `int* string *
    (unit -> int)` .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示由三个元素组成的元组，其类型为 `int* string * (unit -> int)`。
- en: In order to belong to the same type of tuple, two tuple values must have the
    same number of elements with the similar types in the order of occurrence.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了属于同一类型的元组，两个元组值必须具有相同数量的元素，并且这些元素在出现顺序上具有相似的类型。
- en: Tuple equality and comparison
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组的等价性和比较
- en: 'F# automatically implements the structural equality for tuples if each element
    type supports the equality constraint. Tuples are equal if all their elements
    are equal pairwise as shown in the following code (`Ch5_1.fsx` ):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个元素类型都支持等价约束，F# 会自动实现元组的结构等价。元组相等当且仅当它们的元素成对相等，如下面的代码所示（`Ch5_1.fsx`）：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding equality expression value is `true` . However, for the value
    of `tuple` bound above the following expression does not compile (`Ch5_1.fsx`
    ):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的等式表达式值为 `true`。然而，对于绑定在 `tuple` 上的以下表达式的值，编译器会报错（`Ch5_1.fsx`）：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The compiler complains that the `(unit -> int)` type, which is the function
    forming the third element of the tuple, does not support the `'equality'` constraint.
    The equality relationship is not defined for the F# function values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会抱怨 `(unit -> int)` 类型，它是构成元组第三个元素的函数，不支持 `'equality'` 约束。F# 函数值没有定义等价关系。
- en: 'Structural comparison for tuples is similarly provided by F# out of the box
    and is based on pairwise comparisons of elements in a lexicographical order from
    left to right given that all element types fulfill the `''comparison''` constraint
    as shown in the following code (`Ch5_1.fsx` ):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: F# 默认提供了元组的结构比较，它基于从左到右的字典序元素对之间的比较，前提是所有元素类型都满足 `'comparison'` 约束，如下面的代码所示（`Ch5_1.fsx`）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding expression value is `true` .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式值为 `true`。
- en: Tuple decomposition with pattern matching
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模式匹配进行元组分解
- en: 'This chapter is the perfect place to keep the promise I made in [Chapter 4](text00039.html#page
    "Chapter 4.  Basic Pattern Matching") , *Basic Pattern Matching* regarding pattern
    matching in the capacity of the data structure disassembling tool. The following
    code snippet demonstrates how value binding can carry the functionality of pattern
    matching outside of the `match` construction (`Ch5_1.fsx` ):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是履行我在[第4章](text00039.html#page "第4章。基本模式匹配")中关于数据结构解构工具中模式匹配的承诺的完美地方，即*基本模式匹配*。以下代码片段演示了如何将值绑定功能从
    `match` 构造中提取出来（`Ch5_1.fsx`）：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `elem1` and `elem2` effectively acquire values of the first and second
    elements of tuple `a` , which is reflected by the `(1,car)` output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`elem1` 和 `elem2` 实际上获取了元组 `a` 的第一个和第二个元素的值，这通过 `(1,car)` 输出得到了反映。
- en: 'Elements of a tuple that are of no interest within a particular tuple disassemble
    pattern may be omitted using the familiar match-all `_` template, as shown in
    the following code (`Ch5_1.fsx` ):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的元组解构模式中不感兴趣的元组元素可以使用熟悉的 `match-all `_` 模板省略，如下面的代码（`Ch5_1.fsx`）所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This snippet highlights how to obtain and invoke a function extracted from the
    third element of the tuple value; the first two tuple elements are simply ignored
    with the help of the `_` template.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段突出了如何从元组值中的第三个元素获取并调用一个函数；前两个元组元素通过 `_` 模板简单地被忽略。
- en: Tuple augmentation
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组扩展
- en: The tuple type does not have an explicit name. This fact effectively makes normal
    F# type augmentation impossible. Nevertheless, there is still some space left
    for a good hack. This one exploits the need to have interop with other .NET languages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型没有显式的名称。这一事实实际上使得正常的 F# 类型扩展变得不可能。尽管如此，仍然有一些空间可以进行一些巧妙的操作。这个操作利用了与其他 .NET
    语言进行互操作的需求。
- en: '**Documentation** ([https://msdn.microsoft.com/en-us/library/dd233200.aspx](https://msdn.microsoft.com/en-us/library/dd233200.aspx)
    ) states that the compiled form of a tuple represents the corresponding overload
    of class **Tuple** ([https://msdn.microsoft.com/en-us/library/system.tuple.aspx](https://msdn.microsoft.com/en-us/library/system.tuple.aspx)
    ). Given this fact, I can augment the compiled presentation and apply the augmented
    method using the cast, as shown in the following code (`Ch5_1.fsx` ):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档** ([https://msdn.microsoft.com/en-us/library/dd233200.aspx](https://msdn.microsoft.com/en-us/library/dd233200.aspx)
    ) 指出，元组的编译形式表示类 **Tuple** ([https://msdn.microsoft.com/en-us/library/system.tuple.aspx](https://msdn.microsoft.com/en-us/library/system.tuple.aspx)
    ) 的相应重载。鉴于这一事实，我可以增强编译表示，并使用增强方法通过类型转换来实现，如下面的代码所示（`Ch5_1.fsx`）：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, I have augmented a tuple of two generic elements that have type `System.Tuple<'T1,'T2>
    with` the `AsString` instance method, which allows a very distinctive presentation
    of the tuple value. Then, given the instance of the `int*string` tuple, I have
    upcasted it to `obj` type with the `box` function and then immediately downcasted
    it with `:?>` operator to `System.Tuple<int,string>` type, followed by calling
    the `AsString` augmented method on the deceivingly constructed `System.Tuple<int,string>`
    class instance, getting the expected result, that is, `[[1]:["car"]]` .
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我增强了一个具有类型 `System.Tuple<'T1,'T2>` 的两个泛型元素的元组，并添加了 `AsString` 实例方法，这允许以非常独特的方式呈现元组值。然后，给定
    `int*string` 元组的实例，我使用 `box` 函数将其提升到 `obj` 类型，然后立即使用 `:?>` 操作符将其下转换为 `System.Tuple<int,string>`
    类型，随后在欺骗性构建的 `System.Tuple<int,string>` 类实例上调用 `AsString` 增强方法，得到预期的结果，即 `[[1]:["car"]]`。
- en: Wrapping it up, I can conclude that tuples represent a simple algebraic data
    type that fits simple designs well. Using tuples instead of custom types for data
    composition is archetypal for idiomatic F# usage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我可以得出结论，元组代表了一种简单的代数数据类型，非常适合简单的设计。在数据组合中使用元组而不是自定义类型是 F# 习惯用法的一个典型例子。
- en: Records
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: Records represent the other F# native product algebraic data type. It addresses
    the matter that exceptional simplicity of tuples causing some deficiencies. The
    most unfavorable feature of tuples is the lack of binding of a tuple to a concrete
    kind of otherwise structurally similar tuple type. For the F# compiler, there
    is no difference between `(1,"car")` and `(10,"whiskey")` , which puts the burden
    of distinguishing the instance type upon the programmer. Would it be nice to supply
    structurally similar but semantically different types with explicit names? Also
    it would be helpful to label tuple constituents with unique names in order to
    stop relying just on the element position? Sure, welcome to F# **records** !
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代表了 F# 另一个原生的产品代数数据类型。它解决了元组异常简单导致的一些缺陷。元组最不利的特性是元组与结构上相似的另一种具体元组类型的绑定缺失。对于
    F# 编译器来说，`(1,"car")` 和 `(10,"whiskey")` 没有区别，这把区分实例类型的负担放在了程序员身上。如果能够为结构相似但语义不同的类型提供显式名称，那会很好。同时，为了停止仅仅依赖于元素位置，给元组元素添加唯一名称也会很有帮助。当然，欢迎来到
    F# **记录**！
- en: Record composition
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录组合
- en: 'F# records may be considered as the tuples of explicitly named types with labeled
    elements. Referring to the tuple sample given in the preceding script `Ch5_1.fsx`
    , it can be rewritten as follows (`Ch5_2.fsx` ):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: F# 记录可以被视为具有显式命名类型和标签元素的元组。参考前面脚本 `Ch5_1.fsx` 中给出的元组示例，它可以重写如下（`Ch5_2.fsx`）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After placing the preceding snippet into FSI, you get the result shown in the
    following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码片段放入 FSI 后，你会得到以下截图所示的结果：
- en: '![Record composition](img/Image00021.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![记录组合](img/Image00021.jpg)'
- en: Defining the F# record type and instance
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 F# 记录类型和实例
- en: The preceding screenshot visually demonstrates the benefits of records over
    tuples when it comes to the unambiguous labeling of the whole and its parts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图直观地展示了在明确标注整体及其部分时，记录相对于元组的优势。
- en: 'Interestingly, the naming of record fields makes it unnecessary to stick to
    a certain order of field listing as shown in the following code (`Ch5_2.fsx` ):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，记录字段的命名使得不需要坚持某种特定的字段列表顺序，如下面的代码所示（`Ch5_2.fsx`）：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Without any problems, value `b` is recognized as a binding of type `transport`
    .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何问题，值 `b` 被识别为类型 `transport` 的绑定。
- en: 'After being constructed, F# records are genuinely immutable, similar to tuples.
    The language provides just another form of record construction off the existing
    instance using the `with` modifier as shown in the following code (`Ch5_2.fsx`
    ):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '在构造之后，F# 记录实际上是不可变的，类似于元组。语言提供了使用 `with` 修饰符从现有实例创建记录的另一种形式，如下面的代码所示 (`Ch5_2.fsx`
    ):'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This translates into an instance of `transport { code = 2; name = "plane" }`
    . Note the use of the "fully qualified" field name, `transport.name` . I put it
    this way in order to highlight how it can be possible to resolve ambiguity as
    different record types may have similarly named fields.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换为 `transport { code = 2; name = "plane" }` 的实例。注意使用了“完全限定”的字段名，`transport.name`。我这样写是为了突出如何解决歧义，因为不同的记录类型可能有同名字段。
- en: Record equality and comparison
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录的等价性和比较
- en: No surprises here. F#, by default, provides structural equality and comparison
    for records in a manner similar to tuples. However, having an explicit type declaration
    allows more flexibility in this matter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜。F# 默认情况下，为记录提供类似于元组的结构等价性和比较，但显式类型声明在此方面提供了更多的灵活性。
- en: 'For example, if structural equality is not desired and reference equality is
    required for any reason, it is not a problem for records, which type definition
    may be decorated with `[<ReferenceEquality>]` attribute as shown in the following
    code snippet (`Ch5_2.fsx` ):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果不需要结构等价性而需要引用等价性，对于记录来说这不是问题，其类型定义可以装饰有 `[<ReferenceEquality>]` 属性，如下面的代码片段所示
    (`Ch5_2.fsx` ):'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot illustrates what happens if running this code in FSI:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图说明了如果在 FSI 中运行此代码会发生什么：
- en: '![Record equality and comparison](img/Image00021.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![记录的等价性和比较](img/Image00021.jpg)'
- en: Referential equality for F# records
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: F# 记录的引用等价性
- en: Note that after decorating the `Transport` type with the `ReferenceEquality`
    attribute, two structurally equal records, `x` and `y` , are not considered equal
    anymore.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在用 `ReferenceEquality` 属性装饰 `Transport` 类型之后，两个结构上相等的记录 `x` 和 `y` 将不再被认为是相等的。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noting that decorating a record type with the `[<CLIMutable>]` attribute
    makes the underlying record a standard mutable .NET CLI type for interoperability
    scenarios; in particular providing additionally a default parameterless constructor
    and elements mutability. See **Core.CLIMutableAttribute Class (F#)** ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D)
    ) for further details.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用 `[<CLIMutable>]` 属性装饰记录类型使底层记录成为标准可变 .NET CLI 类型，用于互操作性场景；特别是还提供了默认的无参数构造函数和元素可变性。有关更多详细信息，请参阅
    **Core.CLIMutableAttribute 类 (F#)** ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D)
    )。
- en: Record decomposition with pattern matching
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模式匹配进行记录分解
- en: 'Disassembling records with pattern matching is similar to the disassembling
    tuples and may work with or without the `match` construction. The latter case
    is preferable from the standpoint of succinctness as shown in the following code
    (`Ch5_2.fsx` ):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '使用模式匹配解构记录类似于解构元组，并且可以与或不与 `match` 构造一起工作。从简洁性的角度来看，后者更可取，如下面的代码所示 (`Ch5_2.fsx`
    ):'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This discards the `code` field of `a` as not interesting and binds its `name`
    field with the `aName` value. The same effect can be achieved with even shorter
    code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将丢弃 `a` 的 `code` 字段，因为它不感兴趣，并将它的 `name` 字段与 `aName` 值绑定。同样的效果可以用更短的代码实现：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If a single field value is required, then simple `let` `aName' = a.name` works
    too.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要单个字段值，那么简单的 `let aName' = a.name` 也可以。
- en: Record augmentation
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录增强
- en: 'Having an explicit type declaration for F# records allows a great deal of augmenting
    around. A nice example of augmenting a record type in order to implement a thread
    safe mutable **singleton** property can be found in the **SqlClient Type provider
    code** ([https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87](https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87)
    ). A distilled snippet is represented as follows (`Ch5_3.fsx` ):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为F#记录显式声明类型允许大量扩展。一个实现线程安全可变**单例**属性的记录类型扩展的示例可以在**SqlClient类型提供程序代码**中找到（[https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87](https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87)）。一个精炼的片段如下所示（`Ch5_3.fsx`）：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `Database` and `RetryCount` are kept as fields of the F# record that is
    placed as a thread safe static property backed by the `singleton` private reference.
    The beauty of the pattern is that at any moment, configuration can be changed
    programmatically at the same time keeping the singleton thread safe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Database`和`RetryCount`被保留为F#记录的字段，该记录作为一个线程安全的静态属性，由`singleton`私有引用支持。这种模式的美丽之处在于，在任何时刻，都可以通过编程方式更改配置，同时保持单例线程安全。
- en: Sum algebraic data types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求和代数数据类型
- en: In contrast to the product algebraic data types covered earlier, sum algebraic
    data types use the *set sum* operation for the composition of new types. The easiest
    case for this type is an *enumeration* composed of just a bunch of individual
    values. A more generic case is a type that groups a bunch of different types called
    *variants* . Each variant contributes a set of its possible values, which are
    created with the help of the *variant constructor* . All possible values of all
    variants combined with a set sum (union) constitute the sum type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前覆盖的乘积代数数据类型相比，求和代数数据类型使用*集合求和*操作来组合新类型。这种类型的最简单情况是一个由一些单个值组成的*枚举*。更通用的情况是，一个将许多不同类型称为*变体*的类型。每个变体贡献一组可能的值，这些值是通过*变体构造函数*创建的。所有变体的所有可能值与集合求和（并集）结合构成求和类型。
- en: Another contrast with product types is that of all possible variants, only a
    *single* one can be a value for an instance of the sum type, while *all* fields
    constitute the value of a product type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与乘积类型相比的另一个对比是，在所有可能的变体中，只有一个可以是求和类型实例的值，而**所有**字段构成了乘积类型的值。
- en: This may sound complicated, but the concept is quite simple. Let's dive in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但概念相当简单。让我们深入探讨。
- en: Discriminated unions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分联合
- en: Sum algebraic data types were introduced in F# by the native data type named
    *discriminated union* ( **DU** ). The utter flexibility of discriminated unions
    makes them handy to represent pretty much anything in the world. For this particular
    reason, F# programmers use discriminated unions to build the domain-specific languages
    they come up with when approaching solutions for miscellaneous problems. The ability
    of discriminated unions to provide meaningful naming to entities of arbitrary
    complexity, along with the benefits of static typing, is indispensable for clarity
    in representing problems of any scale.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 求和代数数据类型是在F#中通过名为*区分联合*（**DU**）的本地数据类型引入的。区分联合的极致灵活性使它们能够方便地表示世界上几乎所有的事物。正因为这个原因，F#程序员使用区分联合来构建他们在解决各种问题时提出的特定领域语言。区分联合为任意复杂度的实体提供有意义的命名，以及静态类型的好处，对于清晰表示任何规模的问题都是必不可少的。
- en: Discriminated union composition
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分联合组成
- en: 'The manner of discriminated union composition follows its most natural presentation:
    it is a list of variant cases called *constructors* , separated from each other
    by the OR sign (`|` ). Each case reflects the single variant (case). For example,
    take a look at the following definition (`Ch5_4.fsx` ):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合组成的方式遵循其最自然的呈现方式：它是一系列称为*构造函数*的变体案例列表，彼此之间由OR符号（`|`）分隔。每个案例反映单个变体（案例）。例如，看看以下定义（`Ch5_4.fsx`）：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can serve as a natural reflection of the payment processing domain part
    that is concerned with the performing charge of a credit card. `ChargeAttempt`
    can be represented by a discriminated union that has two cases: `Original` , reflecting
    that the credit card was successfully charged on the first attempt, and `Retry`
    , reflecting that the charge had some unsuccessful attempts first and then eventually
    passed through. `Retry` reflects the overall amount of charge attempts, for example,
    `Retry 4` as shown in the following code (`Ch5_4.fsx` ):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以自然地反映与信用卡执行收费相关的支付处理领域部分。`ChargeAttempt` 可以用一个具有两种情况的区分联合来表示：`Original`，表示信用卡在第一次尝试时成功收费，以及
    `Retry`，表示在最终成功之前有几次不成功的尝试。`Retry` 反映了总的收费尝试次数，例如，以下代码（`Ch5_4.fsx`）中的 `Retry 4`：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, `cco` is a value of type `ChargeAttempt` that has
    the `Original` case value; `ccr` is a value of type `ChargeAttempt` too, but it
    has the case value of `Retry 4` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`cco` 是一个类型为 `ChargeAttempt` 的值，具有 `Original` 情况值；`ccr` 也是一个类型为 `ChargeAttempt`
    的值，但它具有 `Retry 4` 的情况值。
- en: The empty constructor case
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空构造函数情况
- en: The *empty constructor* case variant represents the simplest case form. It is
    just a pure label without any kind of associated extra type. We already have used
    this case variant in the preceding code, it stands behind the solitary label `Original`
    .
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*空构造函数*情况变体代表最简单的案例形式。它只是一个纯标签，没有任何关联的额外类型。我们已经在前面的代码中使用了这种情况变体，它位于单独的标签 `Original`
    之后。'
- en: The single constructor case
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单构造函数情况
- en: 'The *single constructor* case represents a discriminated union that has only
    one case. This is a very useful ubiquitous pattern that structures the underlying
    problem''s domain and promotes type safety. For example, I need to represent an
    electric bulb that has characteristics such as electric voltage and optical brightness.
    Using single constructor cases, this can be achieved as follows (`Ch5_4.fsx` ):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*单构造函数*情况代表一个只有一个情况的区分联合。这是一个非常有用且普遍的模式，它结构化了底层问题的领域，并促进了类型安全。例如，我需要表示一个具有电电压和光亮度等特性的电灯泡。使用单构造函数情况，可以这样实现（`Ch5_4.fsx`）：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A person reading the preceding code instantaneously gets introduced to the key
    entities to operate with. Also, having the preceding numeric values wrapped into
    a discriminated union single constructor case creates an extra layer of type safety.
    That is, number `2500` wrapped into constructor `Brightness(2500)` can be used
    only for the `brightness` field of the `Brightness` type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 读取前面代码的人会立即接触到需要操作的关键实体。此外，将前面的数值值包装到区分联合的单构造函数情况中，创建了一个额外的类型安全层。也就是说，数字 `2500`
    被包装到构造函数 `Brightness(2500)` 中，只能用于 `Brightness` 类型的 `brightness` 字段。
- en: Discriminated union equality and comparison
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分联合的相等性和比较
- en: 'Discriminated unions provide structural equality and comparison out of the
    box as shown in the following code (`Ch5_4.fsx` ):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示（`Ch5_4.fsx`），区分联合提供了结构化相等性和比较，无需额外操作：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Discriminated union decomposition with pattern matching
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带模式匹配的区分联合分解
- en: 'Discriminated unions are aligned exceptionally well with pattern matching,
    so decomposing discriminated unions with the help of pattern matching is a breeze
    as shown in the following code (`Ch5_4.fsx` ):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合与模式匹配非常匹配，因此使用模式匹配分解区分联合非常容易，如下所示（`Ch5_4.fsx`）：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discriminated union augmentation
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分联合增强
- en: 'Similarly to F# records, discriminated unions can be seriously augmented. Let''s
    consider the following real-life augmentation example. In the electronic payments
    world, the payment amount may be discounted depending upon the chosen payment
    instrument. The quantity of the discount may be preset as follows (the whole setup
    and concrete numbers below are fictitious):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 F# 记录类似，区分联合可以严重增强。让我们考虑以下现实生活中的增强示例。在电子支付领域，支付金额可能会根据选择的支付工具而打折。折扣的数量可能预先设置为以下（以下整个设置和具体数字都是虚构的）：
- en: For a credit card, the discount is zero
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于信用卡，折扣为零
- en: For a debit card, the discount is $0.35
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于借记卡，折扣是 $0.35
- en: For ACH, the discount is $0.75
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 ACH，折扣是 $0.75
- en: Discounts are a part of the payment service configuration and may change from
    one marketing campaign to another.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 折扣是支付服务配置的一部分，可能因一次营销活动而异。
- en: 'Discount application depending upon the payment instrument can be achieved
    via the discriminated union augmentation as follows (`Ch5_5.fsx` ):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '根据支付工具应用折扣可以通过以下区分联合增强实现 (`Ch5_5.fsx`):'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the particular discount amount is tied to each payment instrument case
    via the discriminated union case constructor: `CreditCard` , `DebitCard` , or
    `ACH` . Along with the distinct cases, the type shares the `ApplyDiscount` single
    instance method, which calculates the discounted amount for an original payment
    amount based on the current discount for the selected payment instrument. The
    results of running the preceding script in FSI are shown in the following figure,
    where discounted payment amounts are shown for a payment of $20.23 for each of
    the covered payment instruments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，特定的折扣金额通过区分联合案例构造函数与每个支付工具案例相关联：`CreditCard`（信用卡）、`DebitCard`（借记卡）或`ACH`（自动清算所）。除了不同的案例，该类型还共享`ApplyDiscount`单例方法，该方法根据所选支付工具的当前折扣计算原始支付金额的折扣金额。以下图显示了在FSI中运行前面的脚本的结果，其中显示了每种覆盖支付工具的$20.23支付金额的折扣支付金额：
- en: '![Discriminated union augmentation](img/Image00022.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![区分联合增强](img/Image00022.jpg)'
- en: Augmenting F# discriminated union
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 增强F#区分联合
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter you get familiar with extremely important F# features that represent
    algebraic data types. For each of the types, the topics of composition, decomposition,
    standard and custom equality and comparison, and augmentation are covered. In
    the end, you are expected to understand the reasons behind the superiority of
    F# data composition with native algebraic data types over custom POCOs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将熟悉极其重要的F#特性，这些特性代表代数数据类型。对于每种类型，涵盖了组合、分解、标准自定义等性和比较以及增强等主题。最后，你应理解为什么F#与原生代数数据类型的组合优于自定义POCO。
- en: In the next chapter, I'll turn to the exciting subject of F# sequences that
    represent data and calculation dualism.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将转向代表数据和计算二元性的激动人心的F#序列主题。
