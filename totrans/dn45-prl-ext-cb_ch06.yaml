- en: Chapter 6. Synchronization Primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mutual exclusion lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `SpinLock` for synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interlocked operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing multiple tasks with a Barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ReaderWriterLockSlim`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `WaitHandles` with Mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for multiple threads with `CountdownEvent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ManualResetEventSlim` to spin and wait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `SemaphoreSlim` to limit access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about coordinating the work that is performed by parallel tasks.
  prefs: []
  type: TYPE_NORMAL
- en: When concurrent tasks read from and write to variables without an appropriate
    synchronization mechanism, a **race condition** has the potential to appear. Race
    conditions can produce inconsistent results in your program, and can be very difficult
    to detect and correct.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a second to understand what a race condition is. Consider a scenario
    that has two parallel tasks; task1 and task2\. Each task tries to read and increment
    the value of a public variable. Task1 reads the original value of the variable,
    let's say 10, and increments the value to 11\. At the same time task1 is reading
    the value of the variable but before it increments the value, task2 reads the
    same value of 10 and increments to 11\. The final value of the variable ends up
    being 11 instead of the correct value of 12.
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET framework 4.5** offers several new data structures for parallel programming
    that simplify complex synchronization problems. Knowledge of these synchronization
    primitives will enable you to implement more complex algorithms and solve many
    of the issues associated with multithreaded programming. It is important to learn
    the various alternatives so that you can choose the most appropriate one for scenarios
    that require communication and synchronization among multiple tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Using monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A monitor, like the lock statement, is a mechanism for ensuring that only one
    thread at a time may be running in a critical section of code. A monitor has a
    lock, and only one thread at a time may acquire it. To run in a critical section
    of code, a thread must have acquired the monitor. While a thread owns the lock
    for an object, no other thread can acquire that lock.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we are going to create an application that uses a `ConsoleWriter`
    class with a `WriteNumbers` method to write some numbers out to the Console. Three
    parallel tasks will each be trying to write some numbers to the Console, and we
    will use monitor to control access to the critical section of code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `MonitorExample` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class to your project and name the class `ConsoleWriter.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using the directives to the top of your `ConsoleWriter`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, inside the declaration of your `ConsoleWriter` class, create a private
    member variable of type object which we will use as our lock object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a method of the `ConsoleWriter` class called `WriteNumbersUnprotected`.
    This is a simple method that executes a `for` loop. Each iteration of the loop
    will write the number of the loop index to the Console. As you might have guessed
    by the method name, we will not use monitor to lock the critical section of this
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a method on the `ConsoleWriter` class named `WriteNumbers`.
    This method will have the same functionality as the previous method we created.
    However, this method will use monitor to ensure that only a single thread can
    enter the critical section of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s go back to the `Program` class. Add the following code snippet using
    directives to the top of the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, start by creating, and instantiating
    an instance of `ConsoleWriter`. Also create a list of tasks which we will use
    to hold a reference to our tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `for` loop that creates and starts three tasks. The task
    will each call the `WriteNumbersUnprotected` method of the shared `ConsoleWriter`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `Main` method of the `Program` class by waiting on the tasks to
    complete and waiting on user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in Visual Studio 2012, press *F5* to run the project. You will probably
    see some pretty ugly output because more than one thread is calling the method
    at a time. Have look at the following screenshot:![How to do it…](img/0225OT_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's fix this by going back to our tasks in the `Main` method of the `Program`
    class and change them now to call the `WriteNumbers` method which protects the
    critical section of code with monitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's press *F5* again to run the project. This time you should see more orderly
    output because only one thread at a time can be in the critical section. This
    is shown in the following screenshot:![How to do it…](img/0225OT_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lock and monitor are very similar. In fact, the `lock` keyword is implemented
    using the `Monitor` class. When using `Monitor`, the developer has to be a bit
    more careful to explicitly remove the lock using `exit`. Lock calls `Enter` and
    `Exit` implicitly, but when using `Monitor` they have to be called by the developer.
    It is best practice to call `exit` in a `finally` block to ensure the lock will
    be released in the event of an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using `lock` is generally preferred over using `Monitor` directly. This is because
    lock is more concise and lock ensures that the underlying monitor is released,
    even if the protected code throws an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `lock` keyword isn't quite as fully-featured as the `Monitor` class.
    For example, `Monitor` has a `TryEnter` method that can wait for a `lock` for
    a specified period of time instead of waiting infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Using a mutual exclusion lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locking is essential in parallel programs. It restricts code from being executed
    by more than one thread at the same time. Exclusive locking is used to ensure
    that only one thread can enter a particular section of code at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to use synchronization in c# is with the `lock` keyword. The
    `lock` keyword works by marking a block of code as a critical section by obtaining
    a mutual exclusion lock for an object running a statement and then releasing the
    lock.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a class that represents a bank account.
    An object of this class will be shared by a couple of parallel tasks that will
    be making a series of withdrawals for random amounts. The critical section of
    code in the `Withdraw` method that updates the balance of the shared account object
    will be protected by a `lock` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go to Visual Studio 2012 and take a look at the following steps on how
    to use mutual exclusion locks:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `LockExample` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class to the project and name the class `Account.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Account`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a private field of type `double` to the `Account` class to store the balance
    of the account and a private object that will be used for locking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next let's add a constructor to the `Account` class. This constructor should
    accept a parameter of type `double` and should initialize the `balance` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `Withdraw` method for the account. If the account has a negative
    balance, the `Withdraw` method should throw an error. Otherwise, the `Withdraw`
    method should obtain a mutual exclusion lock on the `Account` object and deduct
    the requested amount from the balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s go back to our `Program` class. Make sure to add the following code
    snippet using directives that are at the top of the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a static `DoTransactions` method for the `Program` class. The `DoTransactions`
    method should loop ten times doing a withdrawal of a random amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, in the `Main` method of the `Program` class, let's create a shared
    account object and two tasks that will concurrently execute the withdrawals. Finish
    up by waiting for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `lock` keyword is a c# language shortcut for using the `System.Threading`.`Monitor`
    class. Basically, the `lock` keyword ensures that threads cannot enter a critical
    section of code while another thread is in the critical section; the following
    is the code contained in the scope of the `lock` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A critical section is simply a piece of code that accesses a shared resource
    that must not be concurrently accessed by more than one thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If a thread tries to enter a locked section of code, it will block and wait
    until the locked object is released. The lock will be released when the locking
    thread exits the scope of the lock. The `lock` keyword calls `System.Threading.Monitor.Enter`
    at the start of the scope and `System.Threading.Monitor.Exit` at the end of the
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we created a private lockable object to lock on instead of locking
    on the instance of the `Account` class. This is the best practice. In general,
    you should avoid locking on a public type or on instances of objects that are
    beyond your code's control. If another programmer locks your class to synchronize
    their data, a deadlock can occur. A deadlock is a situation in which two or more
    competing threads are waiting for each other to finish their work and release
    a lock, and thus neither one ever does. Note also that locks can only be obtained
    on reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Using SpinLock for synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SpinLock** is a special purpose lock that should only be used when lock contention
    is relatively rare and when lock-hold times are always very short. Unlike monitor
    and other lock types that work by using what is essentially a wait event; SpinLock
    sits in a loop and repeatedly checks until the lock becomes available. The SpinLock
    can be faster than a monitor lock because it reduces thread context switches.
    However, because the thread is spinning in a loop, a SpinLock can cause high CPU
    usage if locks are held for a long time.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to revisit our bank account solution which will
    have a shared bank account object that will be updated by multiple tasks in parallel.
    Each of the tasks will have access to the shared account object and will manage
    concurrency using SpinLock.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new Console Application and see how to use SpinLock for synchronization,
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `SpinBasedLocking` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `Program` class, but inside the `SpinBasedLocking` namespace, create
    a very simple definition for an `Account` class. This class only needs to have
    a single `public integer` field for the balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method of the `Program` class, let's start by creating the
    shared account object, a `SpinLock`, and a list to hold our tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's add a `for` loop to the `Main` method that creates five tasks. Each
    task will loop several times updating the balance and using `SpinLock` to manage
    concurrent access. The `SpinLock` should be acquired in a `try` block and released
    in a `finally` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `Main` method by waiting for all of our tasks to complete and
    wait for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output,
    similar to the following screenshot:![How to do it…](img/0225OT_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A SpinLock can be useful to avoid blocking in our applications, but if we expect
    a large amount of blocking, we probably shouldn't use SpinLock, as excessive spinning
    could make the situation much worse. However, if the critical section performs
    a very minimal amount of work and the wait times for the lock are minimal, then
    spin locking could be a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: The `enter` method of `SpinLock` takes a `Boolean` parameter that indicates
    if the lock was successfully taken. Even in the case of an `Exception`, we can
    examine the `Boolean` parameter to reliably determine if the lock was successfully
    taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `SpinLock` should be exited in a `finally` block to ensure that the locked
    is released. You should also use the `Boolean` parameter to check if the lock
    is actually held before exiting because calling `exit` on a lock that isn't held
    will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: Interlocked operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locking is fairly safe in most of the cases but there are cases when locking
    may not be the safe solution. Some of these cases are incrementing or decrementing
    the value of a variable, adding to, or subtracting from a variable, and exchanging
    two variables with each other. These operations seem like atomic operations, but
    actually are not.
  prefs: []
  type: TYPE_NORMAL
- en: For example, increment and decrement operations include three steps. The first
    is loading the value of from the variable to a register, the second is incrementing
    the value of variable, and the third is storing the incremented value back in
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that a thread can be pre-empted after the first two steps and
    another thread can start execution before the incremented value of the variable
    is saved back in the variable from the register. In the meantime, a second thread
    can go ahead and execute all three steps. After that, the first thread executes
    the third step and overwrites the value of the counter variable. Now the operation
    that was executed by the second thread is lost.
  prefs: []
  type: TYPE_NORMAL
- en: So how do can we avoid this scenario? This is where interlocking comes in. The
    `Interlock` class provides members that can be used to increment/decrement values,
    and exchange data between two variables. The `Interlock` class provides atomic
    operations in variables that are shared among multiple concurrent threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create an application that has a bank account
    object that will be updated by multiple tasks in parallel. Each of the tasks will
    have access to the shared account object, which has only a public field for the
    balance. The tasks will use `Interlocked.Add` to update the account balance as
    an atomic operation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following steps on how to use interlocked in
    a Console Application:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `InterlockedExample` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `InterlockedExample`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `Program` class, but inside the `InterlockedExample` namespace, create
    a very simple definition for an `Account` class. This class only needs to have
    a single `public integer` field for the balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method of the `Program` class, let's start by creating the
    shared account object and a list of `Task` to hold our tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's add a `for` loop to the `Main` method that creates five tasks. Each
    task will loop several times and use `Interlocked.Add` to increase the balance
    of the `Account` object as an atomic operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `Main` method by waiting for all of our tasks to complete and
    wait for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see an output
    similar to the following screenshot:![How to do it…](img/0225OT_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interlocked can be used instead of a locking mechanism to provide simpler and
    fast operations on shared variables.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of interlocked is very simple. You just use its `static` method to
    automatically, add to, subtract from, increment, decrement, or exchange values
    in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These `static` methods change the math operations to be atomic. This means no
    other operations can be performed on the value during the call, and the operation
    won't be affected by context switching between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing multiple tasks with a Barrier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need some tasks to perform a series of parallel phases, and each phase
    needs to start, after all other tasks complete the previous phase, you can synchronize
    and coordinate this work using a barrier. In short, a barrier prevents individual
    tasks from continuing until all tasks reach the barrier.
  prefs: []
  type: TYPE_NORMAL
- en: Each task in the group is referred to as a participant, and signals that it
    has reached the barrier in each phase and is waiting for all the other participants
    to signal their arrival at the barrier before continuing. Optionally, you can
    also specify a time out to avoid the deadlock that will occur if one task fails
    to reach the barrier.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a Console Application that has four participant
    tasks that execute a method with a `for` loop. Each iteration of the loop is a
    phase controlled by the barrier. The tasks will signal when they have reached
    the barrier and wait for all of the other tasks before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new Console Application and take a look at the following steps
    on how to synchronize tasks with Barrier:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `Barrier` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Program` class, let's use a `static` method called `OperationWithBarrier`
    that accepts a parameter of a `Barrier` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the body of the `OperationWithBarrier` method, let's create a `for`
    loop that loops three times. In each loop, get the `threadId` of the executing
    thread and then signal that the thread has reached the barrier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in the `Main` method of the `Program` class, let's create a `Barrier` object
    that has four participants and a post-phase action that writes to the Console
    when each barrier phase is reached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's start four new tasks, each of which runs `OperationWithBarrier` passing
    in the `Barrier` object we just created at the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's wait for all of our tasks to complete and wait for user input
    before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a `Barrier`, specify the number of participants; in our case
    four. The `Barrier` constructor also has an overload that allows you to specify
    a post phase action of type `Action<Barrier>`. This action will fire after all
    the four tasks signal have reached the barrier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each of the four tasks signals reach the barrier and wait for the other tasks
    by calling the `Barrier.SignalAndWait` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A deadlock will occur if one participant's task fails to reach the barrier because
    the tasks that reach the barrier will wait indefinitely for the fourth call to
    `Barrier.SignalAndWait`. To avoid these deadlocks, we used one of the overloads
    of the `SignalAndWait` method that specifies a time out. After the time out the
    remaining tasks are free to continue to the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: Using ReaderWriterLockSlim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ReaderWriterLockSlim` class is used to protect a resource that is read
    by multiple threads and written to by one thread at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReaderWriterLockSlim` allows a thread to enter one of the following three
    modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read mode**: Allows multiple threads to enter the lock as long as there is
    no thread currently holding a write lock or waiting to acquire a write lock. If
    there are any threads that are holding or waiting for a write lock, the threads
    waiting to enter in read mode are blocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgradeable mode**: Intended for cases where a thread usually performs reads
    and might also occasionally perform writes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write mode**: Only one thread can be in write mode at a time. A thread waiting
    to enter the lock in write mode will block if there is a thread currently holding
    a lock in write mode or waiting to enter write mode. If there are threads in read
    mode, the thread that is upgrading to write mode will block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we are going to build a Console Application that creates a writer
    task to write numeric values to an array. The application will also start up three
    reader tasks that read the values that were written to the array and append the
    values to a string using `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s see how to use `ReaderWriterLockSlim` by having a look at the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `ReaderWriter` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a `static` method on the `Program` class which our writer
    task will call to write values to an array. The `write` method will ask to enter
    the lock in write mode and will loop a few times writing the square of the loop
    index to the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create another `static` method on the `Program` class called `Read`
    that our reader tasks will use to read the values from the array and append the
    values to a string using `StringBuilder`. The `Write` method will request a reader
    lock and loop through the values of the array, writing the values to the output
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, at the top of the `Program` class, let's create a constant for the maximum
    number of values and a couple of static fields for the array and the lock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create the `Main` method of our `program` class. The `Main` method
    will have a list of tasks that we can use to wait. We will need to create a single
    writer task that calls the `write` method and will do a loop to create three reader
    tasks which will call the `reader` method. Finish up by waiting for the user input
    before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Notice the ordered results
    in the following screenshot:![How to do it…](img/0225OT_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ReaderWriterLockSlim` allows multiple threads to be in read mode; allows one
    thread to be in write mode with an exclusive ownership of the lock, and allows
    one thread that has read access to be in upgradeable read mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A thread can enter the lock in three modes: read mode, write mode, and upgradeable
    read mode. In our Console Application, the `Write` method requests to enter the
    lock in write mode by calling the `EnterWriteLock` method and the `Read` method
    enters the read mode by calling the `EnterReadLock` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Only one thread can be in write mode at any time. When a thread is in write
    mode, no other thread can enter the lock in any mode. So, any of our reader tasks
    will block if a writer lock is currently held. Once our writer task releases the
    write lock by calling the `ExitWriteLock` method, multiple reader tasks will be
    able to obtain a read lock and enter the critical section.
  prefs: []
  type: TYPE_NORMAL
- en: Using WaitHandles with Mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Mutex** is like a lock, but it can work across multiple processes. A Mutex
    is a synchronization primitive that can also be used for inter-process synchronization.
    When two or more threads need to access a shared resource at the same time, the
    system needs a synchronization mechanism to ensure that only one thread at a time
    uses the resource. Mutex is a synchronization primitive that grants exclusive
    access to the shared resource to only one thread. If a thread acquires a Mutex,
    the second thread that wants to acquire that Mutex is suspended until the first
    thread releases the Mutex.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to return to our bank account example and build
    a Console Application that creates several tasks to update the balance on a shared
    bank account object. The tasks will use a Mutex to provide access to the balance
    for a single task at a time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new Console Application and see how to use Mutex by having
    a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `MutexExample` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `Program` class, but inside the `MutexExample` namespace, create a
    very simple definition for an `Account` class. This class only needs to have a
    single `public integer` field for the balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method of the `Program` class, let's start by creating the
    shared account object, a `Mutex`, and a list of `Task` to hold our tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's add a `for` loop to the `Main` method that creates five tasks. Each
    task will loop several times updating the balance and using `Mutex` to manage
    concurrent access. The `Mutex` should be acquired in a `try` block and released
    in a `finally` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `Main` method by waiting for all of our tasks to complete and
    wait for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically, a Mutex is a mechanism that acts as a flag to prevent two threads
    from performing one or more actions simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: With a `Mutex` class, you call the `WaitHandle.WaitOne` method to lock. The
    `WaitOne` method takes a `Boolean` parameter that indicates if the lock was successfully
    taken. Even in the case of an `Exception`, you can examine the `Boolean` parameter
    to reliably determine if the lock was successfully taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Closing or disposing a `Mutex` automatically releases it. Just as with the lock
    statement, a Mutex can be released only from the same thread that obtained it.
    The `Mutex` should be released in a `finally` block to ensure that the locked
    is released. You should also use the `Boolean` parameter to check if the `Mutex`
    is actually held before exiting because calling `ReleaseMutex` on a `Mutex` that
    isn't held will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for multiple threads with CountdownEvent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common asynchronous pattern is the pattern known as fork/join parallelism.
    This typically manifests by starting a number of pieces of work and later joining
    with that work.
  prefs: []
  type: TYPE_NORMAL
- en: A `CountdownEvent` is initialized with a count. Threads can block waiting on
    the event until the count reaches `0`, at which point the `CountdownEvent` will
    be set and the threads can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a Console Application that performs some simulated
    work in a loop. We will initialize a `CountdownEvent` to a small number of tasks,
    and then start simulating the work with the specified number of tasks. Each task
    will decrement the `CountDownEvent`. When the `CountDownEvent` reaches `0` and
    is signaled, we will reset the `CountDownEvent` with a higher count and start
    over until we reach the maximum number of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at using `CoundownEven`t to wait for multiple threads.
    Have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `ForkAndJoin` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the beginning of your `Program` class, start by creating a static variable
    for the `CountdownEvent` and a couple of constants for the number of tasks we
    want to start with and the number of tasks we want to finish with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the bottom of the `Program` class, after the `Main` method, create a new
    `static` method called `SimulateWork`. This method will take an `integer` parameter
    which represents the number of tasks to create. The method will then loop to create
    the number of tasks specified. The tasks will just sleep for a bit and write a
    message to the Console. When the tasks are finished executing, to call the `Signal`
    method of the `CountdownEvent` to decrement the count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of your `Program` class, start with instantiating the `CountdownEvent`
    object. Pass in the `Begin_Tasks` constant to the `CountdownEvent` constructor
    so that the event will be signaled after two tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, in the `Main` method, create a task that executes a `for` loop. Each iteration
    of the loop should reset the `CountdownEvent` to the number of tasks we want to
    wait for. Then the task will call the `SimulateWork` method and wait for the tasks
    to finish by calling the `Wait` method of `CountdownEvent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `Main` method by waiting for the previous task to complete in
    a `try` block and disposing of the `CountdownEvent` in a `finally` block. Wait
    for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main feature of `CoutndownEvent`, as you have already seen, is that it can
    be used to signal when several tasks have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for `CountDownEvent` accepts an `integer` parameter to specify
    the initial count of signals that we want to wait for before triggering the event.
    In our case, we passed in a constant value that is equal to two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The number of events we are waiting for can be reset by calling the `Reset`
    method as we have done in our `for` loop. Each iteration of the `for` loop increases
    the number of events we are waiting for, up to the maximum number which we specified
    in another constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: After calling the `SimulateWork` method with the desired number of tasks to
    spin up, we wait for the tasks to complete by calling the `WaitMethod` on the
    `CountdownEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `SimulateWork` method, each task indicates that it has completed
    and decrements the count of the signals we are waiting for by calling the `Signal`
    method of `CountDownEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Using ManualResetEventSlim to spin and wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ManualResetEventSlim`, a light-weight synchronization primitive that was introduced
    in .NET Framework 4.0, allows threads to communicate with each other by signaling.'
  prefs: []
  type: TYPE_NORMAL
- en: When a task begins an activity that it must complete before other tasks proceed,
    it calls `Reset` to put `ManualResetEventSlim` in the non-signaled state. This
    thread can be thought of as controlling the reset event. Tasks that call the `Wait`
    method of `ManualResetEventSlim` will block, awaiting the signal. When the controlling
    thread completes the activity, it calls `Set` to signal that the waiting threads
    can proceed. All waiting threads are then released.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the main application thread will create a `ManualResetEventSlim`
    to coordinate five tasks that it spins up. The tasks will call the `Wait` method
    of the reset event and wait for the event to be signaled. After sleeping for a
    bit, the main thread will wake up and call the `Set` method of the reset event
    to release all of the other tasks to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how to use `ManualResetEventSlim` by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `SpinAndWait` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create a `static` method on the `Program` class that will use a
    `for` loop to create and start five tasks. Each task will sleep for two seconds,
    write a message to the Console, and wait for the main thread to set the `ManualResetEventSlim`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method, create a `ManualResetEventSlim` object, and call
    the `StartTasks` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, put the main thread to sleep for a second and then call the `Set` method
    of the reset event object to the tasks that are waiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, sleep the main thread for `500` ms and then call the `Reset` method of
    the reset event object to stop any more tasks from continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, sleep the main thread for another second, the call the `Set` method
    of the reset event to release the waiting tasks. Wait for the user input before
    exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ManualResetEventSlim` functions like a gate. When you call the `Set` method,
    you open the up the gate, allowing any tasks that have called the `Wait` method
    to start running. Calling `Reset` closes the gate and any task that calls `Wait`
    will block, waiting for the event to be set. When the gate is next opened, they
    will all be released again at once.'
  prefs: []
  type: TYPE_NORMAL
- en: The code is pretty simple. We create five tasks and each of the tasks call the
    `Wait` method of the reset event object and block, waiting for the event to be
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The main thread then goes to sleep for a second, releasing the currently blocking
    tasks to run. Then we sleep for a bit more, reset, and set the event again, releasing
    the remaining tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '`ManualResetEventSlim` is optimized for short waiting times and has the ability
    to opt into spinning for a set number of iterations. It also has a more efficiently
    managed implementation and allows a `Wait` to be cancelled via a `CancellationToken`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using SemaphoreSlim to limit access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A semaphore works by keeping a counter. Each time a thread obtains the semaphore,
    the counter is reduced and each time the thread returns the semaphore, it is increased.
  prefs: []
  type: TYPE_NORMAL
- en: '`SemaphoreSlim` is a lightweight semophore that limits the number of threads
    that can access a resource or resources concurrently. A task that calls the `Wait`
    method of a `SemaphoreSlim` object will block until the semaphore counter is below
    the number of requests the semaphore can grant, which is specified in the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the main application thread will use a `for` loop to create
    five tasks. Each of the tasks call a method that waits in a `SemaphoreSlim` object
    before allowing access to a simulated shared resource.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s finish up the chapter by seeing how to use `SemaphoreSlim` to limit
    access to a shared resource. Have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `SemaphoreSlimExample` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code snippet using directives to the top of your program
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create a `static` method on the `Program` class that each of our
    threads will call in order to access a simulated shared resource. This method
    will call the `Wait` method of a `SemaphoreSlim` object, which will only grant
    access to three tasks at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, previously to the `Main` method, create a static `SemaphoreSlim` object
    field on the `Program` class that will grant three access requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Main` method just needs to create and start five tasks in a `for` loop.
    The tasks only need to call the `Enter` method. Now, wait for the user input before
    exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A semaphore is an enforcement of access limitation to a shared resource. Once
    it's full, no more tasks can enter the semaphore until one or more tasks complete
    and get terminated. A queue builds up outside for other tasks. Then, for each
    task that leaves the semaphore, another enters from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Using `SemaphoreSlim` is an easy two-step process. First you need to create
    a `SemaphoreSlim` object that all of your threads have visibility to. Use the
    constructor to specify the number of requests the semaphore can grant concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Before accessing a shared resource, call the `Wait` method on the semaphore
    method. Execution will continue into the shared resource for the specified number
    of tasks. All other tasks will block until one of the current tasks exits. Exiting
    tasks release the semaphore and decrement the request count by calling the `Release`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
