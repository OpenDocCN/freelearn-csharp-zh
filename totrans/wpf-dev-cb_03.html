<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Layouts and Panels
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Building a UI layout using a Grid</li>
<li>Placing elements in uniform cells</li>
<li>Automatically repositioning controls using a <kbd>WrapPanel</kbd></li>
<li>Placing controls in a Stack</li>
<li>Positioning controls inside a Canvas</li>
<li>Wrapping UI elements using a Border</li>
<li>Creating a scrollable panel</li>
<li>Docking controls using a DockPanel</li>
<li>Rescaling UI elements using a <kbd>ViewBox</kbd></li>
<li>Creating a tabbed layout</li>
<li>Dynamically adding/removing elements in a panel</li>
<li>Implementing the drag and drop feature</li>
</ul>
<h1 id="uuid-8b3c9c1e-6dd3-4ad4-a3c4-82167645cab4">Introduction</h1>
<p>WPF provides a proper layout and positioning to provide interactive, user-friendly applications with a suitable container element that helps you to position the child UI elements. The parent container is usually the contents of a window. You can place child level containers and elements with proper margins, paddings, and alignments.</p>
<p>In WPF, <kbd>Panel</kbd> is the base class that provides layout support. There are plenty of derived panels in WPF that help you to create simple to complex layouts and all of them are defined in the <kbd>System.Windows.Controls</kbd> namespace.</p>
<p>All <kbd>Panel</kbd> elements support sizing and positioning defined by the <kbd>FrameworkElement</kbd>. You can set the <kbd>Height</kbd>, <kbd>Width</kbd>, <kbd>Margin</kbd>, <kbd>Padding</kbd>, <kbd>HorizontalAlignment</kbd>, and <kbd>VerticalAlignment</kbd> properties to design your UI. The following diagram describes these important properties, which you will use everywhere:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f8802f6b-9d70-42ba-b124-6dd86ceb6af1.png" style=""/></div>
<p>A panel also exposes other properties such as <kbd>Background</kbd>, <kbd>Children</kbd>, <kbd>ZIndex</kbd>, and more. Since a window can contain only one child, a panel is often used to divide the space to hold another control or a panel. Picking the right panel is important to create the layout. In this chapter, we will learn various recipes to design your application layout using various panels.</p>
<h1 id="uuid-99f68da9-1f1a-47a8-a0a7-5e9cdcdaa82c">Building a UI layout using a Grid</h1>
<p>A <kbd>Grid</kbd> panel enables you to arrange child elements in tabular format, represented by cells in rows and columns. This is the default panel that you will see when you create a new WPF project and navigate to the <kbd>MainWindow.xaml</kbd> file. Visual Studio automatically adds this as the first container inside every window.</p>
<p>It is often useful when you want to represent data in a tabular or matrix form. It is also useful when creating a form layout.</p>
<p>In this recipe, we will discuss the <kbd>Grid</kbd> panel in detail, so that you can properly use it while designing your application layout.</p>
<h2 id="uuid-2dbbfb4e-8e07-4241-9c22-97b6cf51b461">Getting ready</h2>
<p>Let's start with <kbd>Grid</kbd> as a layout panel, by creating a new project. Open Visual Studio and create a new project named <kbd>CH03.GridDemo</kbd>, by selecting the WPF application template.</p>
<h2 id="uuid-8c09ff59-d1aa-4cc8-88de-88d2ed27f412">How to do it...</h2>
<p>Perform the following steps to create a sample <kbd>Grid</kbd> layout to host a few rectangles in each cell:</p>
<ol>
<li>Inside <span class="packt_screen">Solution Explorer</span>, open your <kbd>MainWindow.xaml</kbd> page.</li>
<li>Create a few rows and columns inside the default <kbd>Grid</kbd> panel, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">    &lt;Grid.RowDefinitions&gt; 
        &lt;RowDefinition Height="*" /&gt; 
        &lt;RowDefinition Height="*" /&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
        &lt;ColumnDefinition Width="*" /&gt; 
        &lt;ColumnDefinition Width="*" /&gt; 
        &lt;ColumnDefinition Width="*" /&gt; 
    &lt;/Grid.ColumnDefinitions&gt; </pre>
<ol start="3">
<li>Add six rectangles inside the <kbd>Grid</kbd>, and place them properly by using the <kbd>Grid.Row</kbd> and <kbd>Grid.Column</kbd> attached properties. You can refer to the following sample code:</li>
</ol>
<pre style="padding-left: 60px">    &lt;Rectangle Width="100" Height="60" 
               Fill="OrangeRed"  
               Grid.Row="0" Grid.Column="0"/&gt; 
    &lt;Rectangle Width="100" Height="60" 
               Fill="OrangeRed"  
               Grid.Row="0" Grid.Column="1"/&gt; 
    &lt;Rectangle Width="100" Height="60" 
               Fill="OrangeRed"  
               Grid.Row="0" Grid.Column="2"/&gt; 
    &lt;Rectangle Width="100" Height="60" 
               Fill="OrangeRed"  
               Grid.Row="1" Grid.Column="0"/&gt; 
    &lt;Rectangle Width="100" Height="60" 
               Fill="OrangeRed"  
               Grid.Row="1" Grid.Column="1"/&gt; 
    &lt;Rectangle Width="100" Height="60" 
               Fill="OrangeRed"  
               Grid.Row="1" Grid.Column="2"/&gt; </pre>
<ol start="4">
<li>Now run the application and you will see the following UI on the screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a3dd41a5-1f08-41b6-8c66-9b6afe6ebf4e.png" style=""/></div>
<h2 id="uuid-7eb65ec5-ec06-40ac-beab-d61fcebb6409">How it works...</h2>
<p><kbd>Grid</kbd> works in cells, by creating the rows and columns. <kbd>&lt;Grid.RowDefinitions&gt;</kbd> and <kbd>&lt;Grid.ColumnDefinitions&gt;</kbd> define the structure of the <kbd>Grid</kbd>. It contains a collection of rows and columns, respectively. Here we have created two rows and three columns (<kbd>2x3</kbd> matrix) using <kbd>RowDefinition</kbd> and <kbd>ColumnDefinition</kbd>.</p>
<p>When we placed the rectangles inside the <kbd>Grid</kbd>, we positioned them in cells by specifying the row and column number by using the attached properties, <kbd>Grid.Row</kbd> and <kbd>Grid.Column</kbd>. As the index position starts at <kbd>0</kbd> (zero), the first rectangle placed in the first cell has row index = <kbd>0</kbd> and column index = <kbd>0</kbd>. Similarly, the sixth/last rectangle has the position <kbd>Row=1</kbd> and <kbd>Column=2</kbd>.</p>
<p>You can set the <kbd>Height</kbd> of a <kbd>RowDefinition</kbd> and the <kbd>Width</kbd> of a <kbd>ColumnDefinition</kbd> by specifying an absolute value, a percentage value (star sizing), or an automatic sizing. In the preceding example, we used star sizing to define the row and column dimensions.</p>
<p>An absolute value takes an integer to define fixed height/width. Star sizing is a relative based factor, that works like percentage value. When you mark the height/width as <kbd>*</kbd>, it takes as much space as possible after filling all other fixed and auto sized rows/columns. When you specify <kbd>Auto</kbd>, it takes as much space as required by the contained control.</p>
<h2 id="uuid-89d047ad-2a98-4497-b1b5-c09e093451ff">There's more...</h2>
<p>There's more to know about the star sized value. When there are two rows or two columns having height/width defined as <kbd>*</kbd>, they will occupy the available space by dividing it proportionally. Thus, in the preceding example, each of the two rows occupied 50% of the available space. Similarly, the three columns equally occupied a total of 100% of the available space.</p>
<p>You can also define them using <kbd>n*</kbd>. For example, if a <kbd>Grid</kbd> contains two rows, and among them, one of the rows has a height defined as <kbd>2*</kbd> and the other as <kbd>8*</kbd>, they will occupy 20% and 80% of the available space. Let's see this with a simple example.</p>
<p>Create a <kbd>Grid</kbd> inside a window and set its <kbd>ShowGridLines</kbd> property to <kbd>True</kbd>, so that the grid lines are visible on screen. By default, it is set to <kbd>False</kbd>. Now divide the entire <kbd>Grid</kbd> into five columns. Consider the following XAML code:</p>
<pre style="padding-left: 30px">&lt;Grid ShowGridLines="True"&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
        &lt;ColumnDefinition Width="2*"/&gt; 
        &lt;ColumnDefinition Width="Auto" MinWidth="5"/&gt; 
        &lt;ColumnDefinition Width="*"/&gt; 
        &lt;ColumnDefinition Width="3*"/&gt; 
        &lt;ColumnDefinition Width="40"/&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
&lt;/Grid&gt; </pre>
<p>The width of the second column is set to <kbd>Auto</kbd>, which means it will take as much space as the width of the containing element. When the said column does not contain any element inside it, this will have <kbd>0</kbd> (zero) width. You can specify <kbd>MinWidth</kbd> to provide a minimum value.</p>
<p>The fifth column has a fixed width of <kbd>40</kbd>. Both the second column and fourth column width will be calculated first, as they contain auto width and fixed width, respectively.</p>
<p>The other three columns, in the preceding example, will be calculated now based on the available space and will be calculated in the ratio of <kbd>2:1:3</kbd>. The third column in the example will take one-sixth of the space. The first and fourth columns will take <kbd>2x</kbd> and <kbd>3x</kbd> width, based on the width of the third column.</p>
<p>Once you run this UI, you will see the following output. Now resize the window to see how the resizing happens dynamically based on the given inputs:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0acaa53b-2f8d-4a0b-ba57-999fe4ad9ddd.png" style=""/></div>
<h3 id="uuid-cb9b6204-15a6-47e7-97c2-bcf8cdb7947c">Creating a resizable Grid</h3>
<p>It is possible to create a resizable <kbd>Grid</kbd> in WPF. You can use the <kbd>&lt;GridSplitter/&gt;</kbd> tag to create a <kbd>splitter</kbd> control, which can be used by the user to resize a specific column. Let's consider the following XAML code:</p>
<pre style="padding-left: 30px">&lt;Grid ShowGridLines="True"&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
        &lt;ColumnDefinition Width="2*"/&gt; 
        &lt;ColumnDefinition Width="Auto"/&gt; 
        &lt;ColumnDefinition Width="*"/&gt; 
        &lt;ColumnDefinition Width="3*"/&gt; 
        &lt;ColumnDefinition Width="40"/&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
    &lt;GridSplitter Grid.Column="1" Width="5"/&gt; 
&lt;/Grid&gt; </pre>
<p>In this example, the <kbd>GridSplitter</kbd> control has been placed in the second column. When you run the application, you will see a vertical line inside the second column that you can drag to resize the grid column, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/b73206bc-99f9-42fb-8f4e-b8f6492c52dc.png" style=""/></div>
<h3 id="uuid-53d424eb-b8d5-44f0-b90b-a4b544b5ef54">Spanning elements across multiple rows and/or columns</h3>
<p>It's not mandatory to place an item in a single cell only. You can span it across multiple rows and/or columns. The attached property <kbd>Grid.RowSpan</kbd> allows you to span the element across two or more grid row cells. Similarly, <kbd>Grid.ColumnSpan</kbd> allows you to span the element across two or more grid columns. You can use either or both.</p>
<p>Consider the following code snippet, where the rectangle is spanned across two rows and two columns, starting at the (<kbd>0,0</kbd>) cell position:</p>
<pre>    &lt;Rectangle Fill="OrangeRed"  
               Grid.Row="0" Grid.Column="0" 
               Grid.RowSpan="2" Grid.ColumnSpan="2" /&gt; </pre>
<p>When you run this, you will see the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/789cd6df-57ac-4702-9d4d-0524e281899c.png" style=""/></div>
<h1 id="uuid-f6219fcd-64a6-4bc9-8abc-bf906a8498b6">Placing elements in uniform cells</h1>
<p>Just like the <kbd>Grid</kbd> layout system in Windows Presentation Foundation, the <kbd>UniformGrid</kbd> control also provides the similar layout system, but only with a difference that the rows and columns are of same size. It equally divides the layout into cells, of the same size, based on the number of rows and columns. Thus, you will not have the choice to modify the height and width of the rows and columns explicitly.</p>
<p>In this recipe, we will learn about the <kbd>UniformGrid</kbd> layout with a simple example.</p>
<h2 id="uuid-90cf76d0-f78f-46dd-8e81-1b56a253112c">Getting ready</h2>
<p>Let's create a sample application to demonstrate the <kbd>UniformGrid</kbd> control. Open your Visual Studio IDE and create a new WPF application project named <kbd>CH03.UniformGridDemo</kbd>.</p>
<h2 id="uuid-01aaf848-f01c-477e-8736-964cc168cc21">How to do it...</h2>
<p>Now perform the following steps:</p>
<ol>
<li>From <span class="packt_screen">Solution Explorer</span>, open the <kbd>MainWindow.xaml</kbd> page.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with the following XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;UniformGrid&gt; 
    &lt;Label Content="Cell 1" Background="Yellow" /&gt; 
    &lt;Label Content="Cell 2" Background="YellowGreen" /&gt; 
    &lt;Label Content="Cell 3" Background="Orange" /&gt; 
    &lt;Label Content="Cell 4" Background="OrangeRed" /&gt; 
&lt;/UniformGrid&gt; </pre>
<ol start="3">
<li>Build the project and run the application. You will see the following output on the screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d119589-b749-454d-a5ad-efbd4230cbb7.png" style=""/></div>
<ol start="4">
<li>Now close the application and add a few more <kbd>Label</kbd> controls in the same <kbd>UniformGrid</kbd> as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Label Content="Cell 5" Background="Violet" /&gt; 
&lt;Label Content="Cell 6" Background="DeepSkyBlue" /&gt; 
&lt;Label Content="Cell 7" Background="SkyBlue" /&gt;</pre>
<ol start="5">
<li>Run the application once again and you will see that the row and column count automatically changed to accommodate the new elements, as seen in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/29bb33aa-4a75-4b69-8f5b-a2f1eacaaec2.png" style=""/></div>
<h2 id="uuid-e6908a48-e451-4889-982e-1b907e47bbee">How it works...</h2>
<p>When you start placing controls inside an <kbd>UniformGrid</kbd> control, it automatically calculates the number of cells required to accommodate placing of the added controls. Based on that, it divides the available space into rows and columns to position the child elements sequentially.</p>
<p>When there is a need to place more controls, it again breaks the space into an additional number of equal rows and columns, as shown in the second example.</p>
<h2 id="uuid-ca3293f2-dcfe-4eea-82de-a6fd78b51625">There's more...</h2>
<p>There are many properties that <kbd>UniformGrid</kbd> provides us with, to customize the UI. We are now going to discuss some of the most important properties.</p>
<h3 id="uuid-08b2c3b5-4398-41ec-811e-5e708efecb28">Setting the row and column count</h3>
<p><kbd>UniformGrid</kbd> does not have any restriction on setting the number of rows and columns. You can set the numbers by assigning the <kbd>Rows</kbd> and <kbd>Columns</kbd> properties. For example, the following XAML will render the elements in a single row only, as we assigned <kbd>Rows="1"</kbd>:</p>
<pre style="padding-left: 30px">&lt;UniformGrid Rows="1"&gt; 
    &lt;Label Content="Cell 1" Background="Yellow" /&gt; 
    &lt;Label Content="Cell 2" Background="YellowGreen" /&gt; 
    &lt;Label Content="Cell 3" Background="Orange" /&gt; 
    &lt;Label Content="Cell 4" Background="OrangeRed" /&gt; 
    &lt;Label Content="Cell 5" Background="Violet" /&gt; 
    &lt;Label Content="Cell 6" Background="DeepSkyBlue" /&gt; 
    &lt;Label Content="Cell 7" Background="SkyBlue" /&gt; 
&lt;/UniformGrid&gt; </pre>
<p>The preceding example will have the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/bf9498e7-e1db-4c1a-b1e9-3d4f0c6951f5.png" style=""/></div>
<p>If you set <kbd>Columns="2"</kbd>, all the elements will reposition themselves into two columns, but in multiple rows. You can also combine both the properties.</p>
<h3 id="uuid-79bca827-90d7-4ac2-9398-c8aa499c137d">Defining the first cell of the UniformGrid</h3>
<p>It's a default nature of the <kbd>UniformGrid</kbd> panel to place the first element at the first cell (Row=<kbd>0</kbd>, Column=<kbd>0</kbd>), but it also offers to set the cell position explicitly. The first cell location must be in the first row, starting the index at <kbd>0</kbd> (zero).</p>
<p>The following example demonstrates how you can set the first element position by assigning the <kbd>FirstColumn</kbd> property:</p>
<pre>&lt;UniformGrid Columns="4" FirstColumn="2"&gt; 
    &lt;Label Content="Cell 1" Background="Yellow" /&gt; 
    &lt;Label Content="Cell 2" Background="YellowGreen" /&gt; 
    &lt;Label Content="Cell 3" Background="Orange" /&gt; 
    &lt;Label Content="Cell 4" Background="OrangeRed" /&gt; 
    &lt;Label Content="Cell 5" Background="Violet" /&gt; 
    &lt;Label Content="Cell 6" Background="DeepSkyBlue" /&gt; 
    &lt;Label Content="Cell 7" Background="SkyBlue" /&gt; 
&lt;/UniformGrid&gt; </pre>
<p>When you run the preceding example, you will see the following output on the screen, where the <span class="packt_screen">Cell 1</span> label is positioned at the third column (index position is <kbd>2</kbd>):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/98108e82-9c82-4133-a5da-f7505e833213.png" style=""/></div>
<h3 id="uuid-3b8f7146-ab69-4ae3-aed5-749dfcec132d">Filling elements from right to left</h3>
<p>The default behavior of filling elements in <kbd>UniformGrid</kbd> is <em>left to right</em>. But you can fill them in <em>right to left</em> fashion. To do this, set the <kbd>FlowDirection</kbd> property to <kbd>RightToLeft</kbd> (the default is <kbd>LeftToRight</kbd>), as shown in the following snippet:</p>
<pre style="padding-left: 60px">&lt;UniformGrid FlowDirection="RightToLeft"&gt; 
    &lt;Label Content="Cell 1" Background="Yellow" /&gt; 
    &lt;Label Content="Cell 2" Background="YellowGreen" /&gt; 
    &lt;Label Content="Cell 3" Background="Orange" /&gt; 
    &lt;Label Content="Cell 4" Background="OrangeRed" /&gt; 
    &lt;Label Content="Cell 5" Background="Violet" /&gt; 
    &lt;Label Content="Cell 6" Background="DeepSkyBlue" /&gt; 
    &lt;Label Content="Cell 7" Background="SkyBlue" /&gt; 
&lt;/UniformGrid&gt; </pre>
<p>When you run the preceding code, you will see a UI similar to the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f95a1b11-7f8c-43b3-9139-538464936562.png" style=""/></div>
<h1 id="uuid-e1a8a5bc-cdf0-4814-90a3-1a7c0ba3e65d">Automatically repositioning controls using WrapPanel</h1>
<p> <kbd>WrapPanel</kbd> in WPF is similar to <kbd>StackPanel</kbd>, but it does not stack the items in a single line; rather it wraps the items to a new line based on the available space. It also looks like a <kbd>UniformGrid</kbd> control, but it has odd cell size depending on the item dimension.</p>
<p>In this recipe, we will cover more about <kbd>WrapPanel</kbd> and how to reposition controls using it.</p>
<h2 id="uuid-c9b30f83-1cc5-4a96-b247-55912e84b25c">Getting ready</h2>
<p>To get started, open Visual Studio IDE and create a new project named <kbd>CH03.WrapPanelDemo</kbd>. Make sure to select the WPF app template while creating the project.</p>
<h2 id="uuid-3ee2bee4-8cf7-47c7-b1fb-83fdf9d4dea4">How to do it...</h2>
<p>Let's look at a simple example to add a few buttons in <kbd>WrapPanel</kbd>. Perform the following steps to design the UI:</p>
<ol>
<li>From the Visual Studio <span class="packt_screen">Solution Explorer</span>, open the <kbd>MainWindow.xaml</kbd> page.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with a <kbd>WrapPanel</kbd> control and set its <kbd>Orientation</kbd> property to <kbd>Horizontal</kbd>.</li>
<li>Add a few button controls of diverse sizes. The entire XAML inside the window will look like the following code:</li>
</ol>
<pre style="padding-left: 90px">&lt;WrapPanel Orientation="Horizontal"&gt; 
    &lt;Button Content="Button 1" Margin="4" 
            Width="100" Height="30"/&gt; 
    &lt;Button Content="Button 2" Margin="4" 
            Width="100" Height="30"/&gt; 
    &lt;Button Content="Button 3" Margin="4" 
            Width="100" Height="30"/&gt; 
    &lt;Button Content="Button 4" Margin="4" 
            Width="208" Height="30"/&gt; 
    &lt;Button Content="Button 5" Margin="4" 
            Width="100" Height="30"/&gt; 
    &lt;Button Content="Button 6" Margin="4" 
            Width="60" Height="30"/&gt; 
    &lt;Button Content="Button 7" Margin="4" 
            Width="60" Height="30"/&gt; 
    &lt;Button Content="Button 8" Margin="4" 
            Width="180" Height="30"/&gt; 
&lt;/WrapPanel&gt; </pre>
<ol start="4">
<li>Now build the project and run the application. You will see the following output on the screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6ca7843f-6fdd-4bb3-a0b0-4db1d7612e6d.png" style=""/></div>
<ol start="5">
<li>Resize the application UI to see how the buttons are placed within the screen.</li>
</ol>
<h2 id="uuid-205289dc-19c5-4333-995c-2b33bbae8b56">How it works...</h2>
<p><kbd>WrapPanel</kbd> works by stacking child elements in a line. Once the line is full and can't hold to add more elements, it wraps there, and adds the new element in the next line and continues. Unlike <kbd>UniformGrid</kbd>, the <kbd>WrapPanel</kbd> does not have any fixed width for columns. So, items can be placed based on the available space.</p>
<p>The button controls, which we added as child elements of the <kbd>WrapPanel</kbd>, get added in stack in the first row. When it's unable to accommodate within the same line, it wraps to the next line to give room for the next elements.</p>
<p>The <kbd>Orientation</kbd> property of the <kbd>WrapPanel</kbd> decides whether you want to stack them horizontally or vertically.</p>
<h2 id="uuid-1b9d0a09-1119-47ef-9bed-4cb717f15a19">There's more...</h2>
<p>In the preceding example, we have seen that the items inside the <kbd>WrapPanel</kbd> have their individual size mentioned along with them. You can also set the size for all the items to a specific value by setting the <kbd>ItemWidth</kbd> and <kbd>ItemHeight</kbd> properties, as shown in the following code snippet:</p>
<pre style="padding-left: 30px">&lt;WrapPanel Orientation="Vertical" 
  ItemWidth="100" ItemHeight="30"&gt; 
    &lt;Button Content="Button 1" Margin="4" /&gt; 
    &lt;Button Content="Button 2" Margin="4" /&gt; 
    &lt;Button Content="Button 3" Margin="4" /&gt; 
    &lt;Button Content="Button 4" Margin="4" /&gt; 
    &lt;Button Content="Button 5" Margin="4" /&gt; 
    &lt;Button Content="Button 6" Margin="4" /&gt; 
&lt;/WrapPanel&gt; </pre>
<p>In this case, you won't need to specify the size individually to each child element. When you run the preceding code, you will see the output similar to the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e1efc6d5-a819-41ac-a7c4-d492fdf6949d.png" style=""/></div>
<h1 id="uuid-993a8860-9062-4097-99df-6350fca90187">Placing controls in a Stack</h1>
<p>Another simple and useful layout panel in WPF is a <kbd>StackPanel</kbd>. It works almost like a <kbd>WrapPanel</kbd>, but with a difference that it can't wrap the child elements to a new line. All items added inside it either get placed in horizontal or vertical stacks.</p>
<div class="packt_infobox">The <kbd>StackPanel</kbd> measures its children using either native or relative sizing, keeping the arrangement pass simple by laying out the items in order.<br/>
<br/>
However, the <kbd>Grid</kbd> uses complex combinations of child elements when proportional sizing or auto sizing is used. Thus, it makes the <kbd>Grid</kbd> layout have a slow to medium performance for the measure pass and the arrangement pass to execute.<br/>
Therefore, wherever possible, the <kbd>StackPanel</kbd> preferable to over the <kbd>Grid</kbd> panel to reduce the rendering overhead.</div>
<p>In this recipe, we will learn how the <kbd>StackPanel</kbd> works, by using a very simple example.</p>
<h2 id="uuid-4af867bd-c720-42cb-a5c0-02b052b16734">Getting ready</h2>
<p>To get started, let's open Visual Studio and create a new WPF application project named <kbd>CH03.StackPanelDemo</kbd>.</p>
<h2 id="uuid-ee07ab95-2a04-40d4-abe5-7fcbf61460ec">How to do it...</h2>
<p>Inside <span class="packt_screen">Solution Explorer</span>, navigate to the project and perform the following steps to create the sample UI with <kbd>StackPanel</kbd> containing a few button controls:</p>
<ol>
<li>First, open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Inside the <kbd>Window</kbd> tag, replace the default <kbd>Grid</kbd> with the following XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel&gt; 
    &lt;StackPanel Orientation="Horizontal"&gt; 
        &lt;Button Content="Button 1" Margin="4" /&gt; 
        &lt;Button Content="Button 2" Margin="4" /&gt; 
        &lt;Button Content="Button 3" Margin="4" /&gt; 
        &lt;Button Content="Button 4" Margin="4" /&gt; 
    &lt;/StackPanel&gt; 
    &lt;StackPanel Orientation="Vertical"&gt; 
        &lt;Button Content="Button 5" Margin="4" /&gt; 
        &lt;Button Content="Button 6" Margin="4" /&gt; 
        &lt;Button Content="Button 7" Margin="4" /&gt; 
        &lt;Button Content="Button 8" Margin="4" /&gt; 
    &lt;/StackPanel&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="3">
<li>Let's build and run the application. You will see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae4d9d3d-f585-448a-bf85-810c5200049e.png" style=""/></div>
<h2 id="uuid-9579f143-61a8-4b45-9441-40d3e1b29274">How it works...</h2>
<p>The first <kbd>StackPanel</kbd> is used to hold the multiple inner <kbd>StackPanel</kbd>, stacked vertically by default. The first inner <kbd>StackPanel</kbd> control holds <span class="packt_screen">Button 1</span> - <span class="packt_screen">Button 4</span>. These will be stacked horizontally, as we set the <kbd>Orientation</kbd> property of the panel to <kbd>Horizontal</kbd>.</p>
<p>The second inner <kbd>StackPanel</kbd> holds <span class="packt_screen">Button 5</span> - <span class="packt_screen">Button 8</span>, stacked vertically, as we set the <kbd>Orientation</kbd> property to <kbd>Vertical</kbd>.</p>
<div class="packt_infobox">Unlike <kbd>WrapPanel</kbd>, where the default orientation is <kbd>Horizontal</kbd>, <kbd>StackPanel</kbd> has its default orientation set to <kbd>Vertical</kbd>.</div>
<h2 id="uuid-69b61378-8e11-4cf8-8959-db45f16805d9">There's more...</h2>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft"><kbd>StackPanel</kbd> stretches its child elements by default, but you can take control of how it will stretch. On a vertically oriented <kbd>StackPanel</kbd>, you can assign the <kbd>HorizontalAlignment</kbd> property of the child elements to <kbd>Left</kbd>, <kbd>Center</kbd>, <kbd>Right</kbd>, or <kbd>Stretch</kbd>, as shown in the following code:</p>
<pre style="padding-left: 60px">&lt;StackPanel Orientation="Vertical"&gt; 
    &lt;Button Content="Button (Left)" Margin="4" 
            HorizontalAlignment="Left"/&gt; 
    &lt;Button Content="Button (Center)" Margin="4" 
            HorizontalAlignment="Center"/&gt; 
    &lt;Button Content="Button (Right)" Margin="4" 
            HorizontalAlignment="Right"/&gt; 
    &lt;Button Content="Button (Stretch)" Margin="4" 
            HorizontalAlignment="Stretch" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>The preceding code example will give you the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/fb5e1fbf-9f38-42c3-bae7-9874149398c1.png" style=""/></div>
<p>Similarly, you can assign the <kbd>VerticalAlignment</kbd> property of the child elements, placed in a horizontally oriented <kbd>StackPanel</kbd>. This property contains the following values—<kbd>Top</kbd>, <kbd>Center</kbd>, <kbd>Bottom</kbd>, and <kbd>Stretch</kbd>.</p>
<h1 id="uuid-598054bb-ab45-4f12-8782-046404550195">Positioning controls inside a Canvas</h1>
<p>A <kbd>Canvas</kbd> is another simple panel in WPF, which allows you to place child elements at a specific coordinate position relative to the <kbd>Canvas</kbd>. It exposes four attached properties: <kbd>Left</kbd>, <kbd>Right</kbd>, <kbd>Top</kbd>, and <kbd>Bottom</kbd>, to handle the positioning of controls.</p>
<p>This recipe will help you to understand the positioning of child elements in a <kbd>Canvas</kbd> panel.</p>
<h2 id="uuid-6e188021-f1f0-4424-b56e-e3d25da33633">Getting ready</h2>
<p>Let's open the Visual Studio instance and create a new WPF application project named <kbd>CH03.CanvasDemo</kbd>.</p>
<h2 id="uuid-7702d8b5-6ee0-4332-9e00-e8f9ff4a40ab">How to do it...</h2>
<p>Perform the following steps to create a simple <kbd>Canvas</kbd> panel with a few label controls in it and position them to specific coordinate positions:</p>
<ol>
<li>Open <span class="packt_screen">Solution Explorer</span> and navigate to the project.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> file and replace the default <kbd>Grid</kbd> with the following lines:</li>
</ol>
<pre style="padding-left: 90px">&lt;Canvas&gt; 
    &lt;Label Width="100" Height="60" 
           Background="GreenYellow"  
           Canvas.Left="70" Canvas.Top="40" 
           Content="(70, 40)" 
           FontSize="20" FontWeight="Bold"/&gt; 
    &lt;Label Width="100" Height="60" 
           Background="YellowGreen"  
           Canvas.Left="220" Canvas.Top="90" 
           Content="(220, 90)" 
           FontSize="20" FontWeight="Bold"/&gt; 
&lt;/Canvas&gt; </pre>
<ol start="3">
<li>Build and run the application. It will show the following screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d46eeb27-e86e-4134-88a3-63e280ab2e8a.png" style=""/></div>
<ol start="4">
<li>Now resize the window and observe the positioning of the labels.</li>
</ol>
<h2 id="uuid-ab4876af-507f-4b4c-8413-0c2572611e42">How it works...</h2>
<p>The <kbd>Canvas.Left</kbd> property allows you to assign a value indicating the distance of the child element from the left edge of the <kbd>Canvas</kbd>. The <kbd>Canvas.Top</kbd> property allows you to assign a value indicating the distance of the child element from the top.</p>
<p>Similarly, the <kbd>Canvas.Right</kbd> and <kbd>Canvas.Bottom</kbd> properties allow you to assign the relative position from right and bottom, respectively.</p>
<p>As you can see in the preceding example, the first label is placed at the coordinate position (<kbd>70, 40</kbd>), whereas the second element is placed at the coordinate position (<kbd>220, 90</kbd>). If you resize the window, the position of the child elements will not change.</p>
<div class="packt_infobox">Points to note are that the vertical and horizontal alignments on child elements do not work. Also, if you set the <kbd>Left</kbd> property, the <kbd>Right</kbd> property does not work. Similarly, if you set the <kbd>Top</kbd> property, the <kbd>Bottom</kbd> property does not work.</div>
<h2 id="uuid-a5d77534-eddc-445f-900a-e603b96a5451">There's more...</h2>
<p>The <em>Z</em>-order of a control, placed in a <kbd>Canvas</kbd> panel, determines whether the control is in front of or behind another overlapping control. You can use the <kbd>Canvas.ZIndex</kbd> property to play with the positioning of the <em>Z</em>-order.</p>
<p>By default, the <kbd>ZIndex</kbd> of the first element starts with <kbd>0</kbd> (zero) and gradually increases by <kbd>1</kbd> whenever you add a new element on the canvas. But in special cases, when you want to bring an overlapped control to the top, set its <kbd>ZIndex</kbd> higher than the <kbd>ZIndex</kbd> of the last element that is overlapping it.</p>
<h1 id="uuid-c36a7dae-5fe2-45b7-87d1-afbaa0c4d50f">Wrapping UI elements using a Border</h1>
<p>The <kbd>Border</kbd> control in WPF is used as a <kbd>Decorator</kbd>, which you can use to draw a border around another control. As the WPF panels do not support adding a border around its edges, the <kbd>Border</kbd> control is used to achieve the same.</p>
<p>This recipe will guide you to add a border to a control. You can also use the same concept to decorate a group of controls placed inside a panel, by wrapping the panel with a <kbd>Border</kbd>.</p>
<h2 id="uuid-a164f74f-20f0-4fa0-a2de-468470f5faa5">Getting ready</h2>
<p>To begin with an example, let's first create a new project. Open Visual Studio and create a WPF application project named <kbd>CH03.BorderDemo</kbd>.</p>
<h2 id="uuid-e2d4b03f-5fed-4e09-aeee-2bec9a13e391">How to do it...</h2>
<p>Perform the following simple steps to add a border around <kbd>TextBlock</kbd>:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file of your WPF project.</li>
<li>Now replace the default <kbd>Grid</kbd> with a <kbd>StackPanel</kbd>.</li>
<li>Add a few TextBlocks inside it, wrapped by a Border. Here's the complete XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Margin="10"&gt; 
    &lt;Border BorderBrush="OrangeRed" 
            BorderThickness="2" 
            Margin="10 4" Padding="10"&gt; 
        &lt;TextBlock Text="Text surrounded by border"/&gt; 
    &lt;/Border&gt; 
    &lt;Border BorderBrush="OrangeRed" 
            BorderThickness="2" 
            CornerRadius="20" 
            Margin="10 4" Padding="10"&gt; 
        &lt;TextBlock Text="Text surrounded by border,<br/>        having corner radius = 20"/&gt; 
    &lt;/Border&gt; 
    &lt;Border BorderBrush="OrangeRed" 
            BorderThickness="2" 
            CornerRadius="5" 
            Background="Yellow" 
            Margin="10 4" Padding="10"&gt; 
        &lt;TextBlock Text="Text surrounded by border, <br/>        having a Yellow background and rounded border"  
        TextWrapping="Wrap"/&gt; 
    &lt;/Border&gt; 
    &lt;Border BorderBrush="OrangeRed" 
            BorderThickness="4 0" 
            CornerRadius="5" 
            Margin="10 4" Padding="10"&gt; 
        &lt;TextBlock Text="Text surrounded by two-side border"/&gt; 
    &lt;/Border&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="4">
<li>Let's run the application. You will see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca3cfdbe-b597-41ef-a460-3e298795d48f.png" style=""/></div>
<h2 id="uuid-2aab3d3b-e446-4d6c-8034-cad6ff879ba3">How it works...</h2>
<p>The <kbd>BorderThickness</kbd> property accepts an integer value to draw a border around the control. The property <kbd>BorderBrush</kbd> adds a color to it. You can use <kbd>SolidColorBrush</kbd>, <kbd>GradientColorBrush</kbd>, or any other brush type. The first <kbd>Border</kbd> control adds a thin <kbd>2px</kbd> border around the text.</p>
<p>In the second example, the <kbd>CornerRadius</kbd> property has been set to <kbd>20</kbd> to add a 20-degree curve around the corners of the <kbd>Border</kbd> control.</p>
<p>The third example has a border with a background brush to wrap the <kbd>TextBlock</kbd> control. You can club both the <kbd>BorderThickness</kbd>, <kbd>BorderBrush</kbd>, and <kbd>Background</kbd> properties together to give such a look. Notice the small corner radius of <kbd>5</kbd> degrees!</p>
<p>In the fourth example, we have provided a border to two sides of the text. The value of <kbd>BorderThickness</kbd> can have <kbd>1</kbd>, <kbd>2</kbd>, or <kbd>4</kbd> double values. The four doubles (<kbd>BorderThickness="5, 3, 5, 4"</kbd> or <kbd>BorderThickness="5 3 5 4"</kbd>) describes the <kbd>Left</kbd>, <kbd>Top</kbd>, <kbd>Right</kbd>, and <kbd>Bottom</kbd> sides in the same order.</p>
<p>When you provide two double values (<kbd>BorderThickness="5, 3"</kbd> or <kbd>BorderThickness="5 3"</kbd>), the first value describes <kbd>Left</kbd> and <kbd>Right</kbd>; the second value describes <kbd>Top</kbd> and <kbd>Bottom</kbd>, respectively. To provide thickness of the same amount in all the sides, assign only one double to the property (<kbd>BorderThickness="5"</kbd>).</p>
<h1 id="uuid-149c193a-96f6-40fb-ae60-40ae1fd2ede7">Creating a scrollable panel</h1>
<p>The <kbd>ScrollViewer</kbd> controls enable scrolling functionality in a WPF application and help you to host other controls. When there are more contents available to show, but the viewable area is smaller than that, <kbd>ScrollViewer</kbd> is used to help the user to scroll through the content.</p>
<p>In this recipe, we will learn how to use a <kbd>ScrollViewer</kbd> inside a WPF application.</p>
<h2 id="uuid-66cb63fb-aa23-4dad-859d-5c4dc42dd67f">Getting ready</h2>
<p>Let's open Visual Studio and create a project named <kbd>CH03.ScrollViewerDemo</kbd>. Be sure to create the project based on the WPF application template.</p>
<h2 id="uuid-8a450518-167e-464c-a134-196733fd11bb">How to do it...</h2>
<p>It's a quick step to surround a panel or control using the <kbd>ScrollViewer</kbd>. Perform the following steps to add a scrolling functionality to an <kbd>image</kbd> control:</p>
<ol>
<li>Inside the project, add an image named <kbd>demoImage.jpg</kbd>.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> file from <span class="packt_screen">Solution Explorer</span>.</li>
<li>Now replace the existing <kbd>Grid</kbd> with a <kbd>ScrollViewer</kbd>.</li>
<li>Add an image pointing to the <kbd>demoImage.jpg</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;ScrollViewer HorizontalScrollBarVisibility="Auto" 
              VerticalScrollBarVisibility="Auto"&gt; 
    &lt;Image Source="demoImage.jpg" /&gt; 
&lt;/ScrollViewer&gt;</pre>
<ol start="5">
<li>Run the application and you will see the following window with an image inside a <kbd>ScrollViewer</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/76ee6fd0-f232-488f-8bc9-a263dfb40e82.png" style=""/></div>
<ol start="6">
<li>Use the scroll bars to scroll left-right and/or up-down to see the entire image.</li>
</ol>
<h2 id="uuid-c9f0c074-89a3-4375-8378-32043b02983e">How it works...</h2>
<p><kbd>ScrollViewer</kbd> exposes two major properties—<kbd>HorizontalScrollBarVisibility</kbd> and <kbd>VerticalScrollBarVisibility</kbd>. Both represent an enumeration named <kbd>ScrollBarVisibility</kbd>, having four values:</p>
<ul>
<li><strong>Visible</strong>: When the property is set to <kbd>ScrollBarVisibility.Visible</kbd>, the scroll bar will be visible all the time.</li>
<li><strong>Hidden</strong>: When the property is set to <kbd>ScrollBarVisibility.Hidden</kbd>, the scrollbar will not be visible on screen and the user will not be able to scroll to see the complete content.</li>
<li><strong>Disabled</strong>: When it is set to <kbd>ScrollBarVisibility.Disabled</kbd>, the scrollbars will be disabled.</li>
<li><strong>Auto</strong>: This is often used to make the scrolling thumbs visible only when they are needed. For this, set the property to <kbd>ScrollBarVisibility.Auto</kbd>.</li>
</ul>
<h1 id="uuid-a919d9ca-1dc6-4ced-80bf-f7206aebb5e6">Docking controls using the DockPanel</h1>
<p><kbd>DockPanel</kbd> makes it easier to dock UI elements in the left, right, top, or bottom of the screen. This is often useful, mainly when you want to divide the window into specific areas. For example, a status bar is always kept at the bottom of the window, whereas a menu or a toolbar resides at the topmost position of the window.</p>
<p>This recipe will help you to learn how to dock child elements in an application window.</p>
<h2 id="uuid-6c8005c7-8115-44b7-88c1-82ecb6418077">Getting ready</h2>
<p>Let's begin with a new project. Open Visual Studio and create a project named <kbd>CH03.DockPanelDemo</kbd>, based on the available WPF application template.</p>
<h2 id="uuid-1037673b-bae0-4277-bdf3-2ad5bd1dea55">How to do it...</h2>
<p>Perform the following steps to add a <kbd>DockPanel</kbd> with a few labels docked into it:</p>
<ol>
<li>From <span class="packt_screen">Solution Explorer</span>, navigate to the project and open <kbd>MainWindow.xaml</kbd>.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with a <kbd>DockPanel</kbd> control.</li>
<li>Now add five labels inside it and dock them in various sides of the window.</li>
<li>Here's the complete XAML code for reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;DockPanel&gt; 
    &lt;Label Content="Button (DockPanel.Dock='Right')" 
           Background="YellowGreen" 
           Margin="4" Padding="4" 
           DockPanel.Dock="Right"/&gt; 
    &lt;Label Content="Button (DockPanel.Dock='Top')" 
           Background="GreenYellow" 
           Margin="4" Padding="4" 
           DockPanel.Dock="Top"/&gt; 
    &lt;Label Content="Button (DockPanel.Dock='Bottom')" 
           Background="SkyBlue" 
           Margin="4" Padding="4" 
           DockPanel.Dock="Bottom"/&gt; 
    &lt;Label Content="Button (DockPanel.Dock='Left')" 
           Background="Orange" 
           Margin="4" Padding="4" 
           DockPanel.Dock="Left"/&gt; 
    &lt;Label Content="Button (None)" 
           Background="Pink" 
           Margin="4" Padding="4"/&gt; 
&lt;/DockPanel&gt; </pre>
<ol start="5">
<li>Let's run the application. You will see that the labels are positioned in different sides of the window, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48aef2dc-b808-4a7c-b163-6952a4cf25f7.png" style=""/></div>
<h2 id="uuid-1fe63992-a3ce-4153-b8c6-107111b41002">How it works...</h2>
<p>The <kbd>DockPanel.Dock</kbd> property determines the position of the element, based on the relative order. The property is of type <kbd>Dock</kbd> enumeration and it accepts the following values—<kbd>Dock.Left</kbd>, <kbd>Dock.Right</kbd>, <kbd>Dock.Top</kbd>, and <kbd>Dock.Bottom</kbd>. If you don't specify the property, by default, the first element will be docked to the left and the other elements will take the remaining space.</p>
<p>In the preceding example, the labels are added inside the <kbd>DockPanel</kbd> in the following order, having the <kbd>DockPanel.Dock</kbd> property set to <kbd>Right</kbd>, <kbd>Top</kbd>, <kbd>Bottom</kbd>, and <kbd>Left</kbd>, respectively. The last label does not specify any <kbd>Dock</kbd> property and hence it takes the remaining space to accommodate itself inside it.</p>
<h2 id="uuid-f1639b7a-a145-43cb-a1bf-6e9ce36dae75">There's more...</h2>
<p>In a <kbd>DockPanel</kbd>, ordering of dock matters most. If you change the order of the example that we have created previously, you will notice how the <kbd>DockPanel</kbd> changes the position of the added labels.</p>
<h1 id="uuid-639f001c-774a-4ec4-9a92-0d724f622013">Rescaling UI elements using a ViewBox</h1>
<p>When you are building an application, you don't know the screen resolution of the system where the application will be running. If you design the UI considering small or standard resolution in mind, the UI controls will look very small in a high-resolution monitor. If you do the reverse, with big screens in mind, the user won't see the parts of the screen, if executed on a low-resolution monitor.</p>
<p>Hence, there is a need to create an auto-scaling mechanism, which will take care of different screen resolutions. <kbd>ViewBox</kbd> is a very popular control in WPF, which helps you to scale the content to fit the available space based on the size. When you resize the parent, it automatically transforms the content to scale in proportion.</p>
<p>Let's learn how it works, with a simple example, in this recipe.</p>
<h2 id="uuid-dd0bbe99-5203-4ad2-86ff-af8c26a8ff1c">Getting ready</h2>
<p>Open your Visual Studio IDE and create a new WPF application project named <kbd>CH03.ViewBoxDemo</kbd>.</p>
<h2 id="uuid-8995229f-fa77-4bf5-aef5-0ba53280ab46">How to do it...</h2>
<p>Please perform the following steps:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file from <span class="packt_screen">Solution Explorer</span>.</li>
<li>Set a smaller size of the <kbd>Window</kbd>. Let's set its height to <kbd>120</kbd> and width to <kbd>400</kbd>.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with a <kbd>ViewBox</kbd>.</li>
<li>Add text inside it, using the <kbd>TextBlock</kbd> control as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Viewbox&gt; 
    &lt;TextBlock Text="This is a text, inside a ViewBox" 
               Margin="10"/&gt; 
&lt;/Viewbox&gt;</pre>
<ol start="5">
<li>Run the application. You will see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/305ea6a9-d82d-4433-98c9-38a4b91de736.png"/></div>
<ol start="6">
<li>Now resize the window and you will see that the text is automatically scaled based on the size of the window:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/885a9906-7323-411e-9373-76f0a27d5dbc.png" style=""/></div>
<h2 id="uuid-065af1a0-92d9-418f-a55c-09e9205cdb46">How it works...</h2>
<p>The <kbd>ViewBox</kbd> provides you with a way to adjust the content of a window automatically, based on the resolution of the screen. When you resize the <kbd>ViewBox</kbd>, it automatically adjusts the size and the relative position of the contents to fit on the screen.</p>
<p>In the preceding example, the size of the window is set to <kbd>400x120</kbd>. The window has a <kbd>TextBlock</kbd> control with a text string, wrapped in a <kbd>ViewBox</kbd>. When you resize the window, the content also resizes by applying scale transform.</p>
<p>But if the aspect ratio of the <kbd>ViewBox</kbd> window does not fit in proportion, you will see a white space either at the left and right or top and bottom of the content.</p>
<h2 id="uuid-1c05d0b4-2a86-47a0-824a-e3bc5d19c660">There's more...</h2>
<p>The <kbd>ViewBox</kbd> control provides two properties to stretch the content. Those are <kbd>Stretch</kbd> and <kbd>StretchDirection</kbd>. When you don't specify the <kbd>Stretch</kbd> property to a <kbd>ViewBox</kbd>, it uses the default value for <kbd>Stretch</kbd>, which is <kbd>Uniform</kbd>.</p>
<p>When the <kbd>Stretch</kbd> property is set to <kbd>Uniform</kbd>, and the <kbd>ViewBox</kbd> does not match the aspect ratio of the content, it adds a white margin to it. It can be either at the top and bottom or at the left and right sides:</p>
<pre style="padding-left: 60px">&lt;Viewbox Stretch="Uniform"&gt; 
    &lt;TextBlock Text="This is a text, inside a ViewBox" 
     Margin="10"/&gt; 
&lt;/Viewbox&gt; </pre>
<p>When it is set to <kbd>Fill</kbd>, it causes the content to completely fill the space without obeying the aspect ratio. Thus, you may see a distortion in the UI:</p>
<pre style="padding-left: 60px">&lt;Viewbox Stretch="Fill"&gt; 
    &lt;TextBlock Text="This is a text, inside a ViewBox" 
     Margin="10"/&gt; 
&lt;/Viewbox&gt; </pre>
<p>When you set the <kbd>Stretch</kbd> property to <kbd>UniformToFill</kbd>, it maintains the original aspect ratio and fills the window completely. You will not see any distortion in the UI:</p>
<pre style="padding-left: 60px">&lt;Viewbox Stretch="UniformToFill"&gt; 
    &lt;TextBlock Text="This is a text, inside a ViewBox" 
     Margin="10"/&gt; 
&lt;/Viewbox&gt; </pre>
<p>If you don't want to resize the content, set the <kbd>Stretch</kbd> property to <kbd>None</kbd>. When you set it as <kbd>None</kbd>, and resize the window to enlarge, the content will not scale and will remain in its original state surrounded by white space:</p>
<pre style="padding-left: 60px">&lt;Viewbox Stretch="None"&gt; 
    &lt;TextBlock Text="This is a text, inside a ViewBox" 
     Margin="10"/&gt; 
&lt;/Viewbox&gt; </pre>
<p>The <kbd>StretchDirection</kbd> property of the <kbd>ViewBox</kbd> is used to tell the <kbd>ViewBox</kbd> to stretch the content based on the <kbd>Stretch</kbd> property. When the <kbd>Stretch</kbd> property is set to <kbd>None</kbd>, the <kbd>StretchDirection</kbd> property has no effect.</p>
<p>When <kbd>StretchDirection</kbd> is set to <kbd>UpOnly</kbd> or <kbd>DownOnly</kbd>, the content will be resized upward or downward, based on the <kbd>ViewBox</kbd> size. When it is set to <kbd>Both</kbd>, the content will be resized in both directions.</p>
<h1 id="uuid-cd7146ba-2c2d-4394-9b0a-9ae24dfb2a67">Creating a tabbed layout</h1>
<p>To accommodate more content in a window layout, tabbed user interfaces are mostly used. They allow users to open multiple pages in a single window. For example, most of the recent internet browsers use tabbed interface to let the user open multiple web pages simultaneously in a single window.</p>
<p>WPF provides <kbd>TabControl</kbd> to create the tabbed layout. In this recipe, we will learn the basics of tab interfaces, with a simple example to let you understand how it works.</p>
<h2 id="uuid-02e61289-5b85-4e27-beea-285f5c2dc8af">Getting ready</h2>
<p>To get started, make sure that you have opened Visual Studio IDE. Now create a new project named <kbd>CH03.TabControlDemo</kbd>, based on the available WPF application project template.</p>
<h2 id="uuid-22cd4e3c-3fd2-4973-a5ff-f43883e1f631">How to do it...</h2>
<p>Let's create the UI interface to host a very basic tab control with a few tab items inside it. Perform the following steps:</p>
<ol>
<li>From the <span class="packt_screen">Solution Explorer</span> window, open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Inside the default <kbd>Grid</kbd> panel, add the <kbd>TabControl</kbd> with two <kbd>TabItem</kbd> controls as shown in the following code:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;TabControl&gt; 
        &lt;TabItem Header="Tab 1"&gt; 
            &lt;TextBlock Text="You have selected 'Tab 1'" 
             FontSize="30" Margin="4"/&gt; 
        &lt;/TabItem&gt; 
        &lt;TabItem Header="Tab 2"&gt; 
            &lt;TextBlock Text="You have selected 'Tab 2'" 
             FontSize="30" Margin="4"/&gt; 
        &lt;/TabItem&gt; 
    &lt;/TabControl&gt; 
&lt;/Grid&gt;</pre>
<ol start="3">
<li>Now run this application and you will see the following UI, which contains two tabs inside it:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d186bf82-0091-458c-a8c8-98f2b96f7640.png" style=""/></div>
</li>
<li>Close the application and return to the XAML editor to add another <kbd>TabItem</kbd> inside the <kbd>TabControl</kbd>. Let's change the template of the header to contain UI elements other than the plain text. Copy the following XAML after the second tab:</li>
</ol>
<pre style="padding-left: 90px">&lt;TabItem&gt; 
    &lt;TabItem.Header&gt; 
        &lt;StackPanel Orientation="Horizontal"&gt; 
            &lt;Ellipse Width="10" Height="10" 
              Fill="Green" Margin="0 1 8 0"/&gt; 
            &lt;TextBlock Text="Tab 3"/&gt; 
        &lt;/StackPanel&gt; 
    &lt;/TabItem.Header&gt; 
    &lt;Border Background="ForestGreen" 
            Margin="4"&gt; 
        &lt;TextBlock Text="You have selected 'Tab 3'" 
             FontSize="30" Foreground="White"/&gt; 
    &lt;/Border&gt; 
&lt;/TabItem&gt; </pre>
<ol start="5">
<li>Now run the application once again and navigate to the third tab. You will see the following UI in the screen:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/43db2427-acaf-4df5-92fc-5a7ac4af14ea.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-71209466-094f-4dea-b43f-e89fc2b487f4">How it works...</h2>
<p>The <kbd>TabControl</kbd> derives from <kbd>Selector</kbd> to provide you an <kbd>ItemsControl</kbd> to host elements inside it. You can host only <kbd>TabItem</kbd> controls, which are actually <kbd>HeaderedContentControl</kbd> to provide a <kbd>Header</kbd> to each of the items.</p>
<p>The <kbd>Header</kbd> property is of type object, which will allow you to put any content inside it, be it a plain text or a different UI element.</p>
<p>In the preceding example, the first two <kbd>TabItem</kbd> controls contain plain text as headers, whereas the third <kbd>TabItem</kbd> contains many different <kbd>UIElement</kbd> to give its header a customized look. When you switch from one tab to another, you will see its associated content, which you can programmatically access through its <kbd>Content</kbd> property.</p>
<h1 id="uuid-2c73916e-1527-4407-bc90-898588d3fda7">Dynamically adding/removing elements in a panel</h1>
<p>So far, we have seen how to add static elements/contents in a <kbd>Panel</kbd> control. But it's not always useful, mainly when you are retrieving data from the backend and populating in the UI or dynamically based on the user interaction.</p>
<p>This recipe will discuss this topic. As all the panels perform similarly to add/remove elements, with a slight difference on the positioning, we will be demonstrating it with a simple <kbd>Canvas</kbd>.</p>
<h2 id="uuid-1bccb12e-7536-44d4-bcda-fb4055726116">Getting ready</h2>
<p>To begin with the coding, let's create a WPF application project first. Open Visual Studio and create a new project named <kbd>CH03.DynamicPanelDemo</kbd>.</p>
<h2 id="uuid-56b55173-be29-44bf-934c-93d28d2e674f">How to do it...</h2>
<p>Let's add a <kbd>Canvas</kbd> panel inside the window, and dynamically add squares at the current cursor position when the user clicks the <kbd>Canvas</kbd> panel. Perform the following steps:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> page and replace the default <kbd>Grid</kbd> panel with a <kbd>Canvas</kbd>.</li>
<li>Give it a name. In our example, let's give the name as <kbd>canvasPanel</kbd>.</li>
<li>Set a background to the canvas panel and register a <kbd>MouseLeftButtonDown</kbd> event to it. Here's the complete XAML code, for reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH03.DynamicPanelDemo.MainWindow" 
   xmlns=<br/>        "http://schemas.microsoft.com/winfx/<br/>        2006/xaml/presentation" 
         
        Title="Dynamic Panel Demo"  
        Height="300" Width="500"&gt; 
    &lt;Canvas x:Name="canvasPanel"  
            Background="LightGoldenrodYellow" 
            MouseLeftButtonDown="OnMouseLeftButtonDown"/&gt; 
&lt;/Window&gt; </pre>
<ol start="4">
<li>Now open its associated code-behind file <kbd>MainWindow.xaml.cs</kbd> and implement the event. Alternatively, you can place the cursor on top of the event name and press <em><span class="KeyPACKT">F12</span></em> to generate the event and navigate to it directly.</li>
<li>Inside the <kbd>OnMouseLeftButtonDown</kbd> event implementation, retrieve the current cursor position and place the element at the same position on the canvas, where the user clicked. Here's the code implementation:</li>
</ol>
<pre style="padding-left: 90px">private void OnMouseLeftButtonDown(object sender,  
 MouseButtonEventArgs e) 
{ 
    var mousePosition = e.GetPosition(canvasPanel); 
    var square = new Rectangle 
    { 
        Width = 50, 
        Height = 50, 
        Fill = new SolidColorBrush(Colors.Green), 
        Opacity = new Random().NextDouble() 
    }; 
 
    // set the position of the element 
    Canvas.SetLeft(square,  
     mousePosition.X - square.Width / 2); 
    Canvas.SetTop(square,  
     mousePosition.Y - square.Height / 2); 
 
    // add the element on the Canvas 
    canvasPanel.Children.Add(square); 
} </pre>
<ol start="6">
<li>Let's run the application. You will see a blank window with the same background color that we have set on the <kbd>Canvas</kbd>.</li>
<li>Randomly click on the <kbd>Canvas</kbd> area and you will see the squares popping up on the screen, at the same place where you are left-clicking on the <kbd>Canvas</kbd>. The UI will look as follows:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2e7e78d9-50c9-4c44-a724-31a49809c12f.png" style=""/></div>
</li>
<li>To remove the elements from the square, let's register a <kbd>MouseRightButtonDown</kbd> event in the <kbd>Canvas</kbd> panel present in the XAML. Close the running application and replace the entire content of the <kbd>MainWindow.xaml</kbd> page with the following one:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH03.DynamicPanelDemo.MainWindow" 
  xmlns=<br/>   "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
     
    Title="Dynamic Panel Demo"  
    Height="300" Width="500"&gt; 
    &lt;Canvas x:Name="canvasPanel"  
            Background="LightGoldenrodYellow" 
            MouseLeftButtonDown="OnMouseLeftButtonDown" 
            MouseRightButtonDown="OnMouseRightButtonDown"/&gt; 
&lt;/Window&gt; </pre>
<ol start="9">
<li>Now navigate to the <kbd>MainWindow.xaml.cs</kbd> file to add the associated event implementation. Add the following snippet inside the class:</li>
</ol>
<pre style="padding-left: 90px">private void OnMouseRightButtonDown(object sender,  
 MouseButtonEventArgs e) 
{ 
    if (e.Source is UIElement square) 
    { 
        canvasPanel.Children.Remove(square); 
    } 
} </pre>
<ol start="10">
<li>Run the application once again and randomly click inside the <kbd>Canvas</kbd> to add the squares inside it.</li>
<li>Once the squares are in place, right-click on them to see the clicked ones disappear from the panel.</li>
</ol>
<h2 id="uuid-81d09405-e815-4fd6-8fba-0d6617728201">How it works...</h2>
<p>Every panel exposes a property named <kbd>Children</kbd> to hold a collection of <kbd>UIElement</kbd> as <kbd>UIElementCollection</kbd>. To dynamically add an element to <kbd>UIElementCollection</kbd>, use its <kbd>Add</kbd> method; and to remove an element, pass the element to its <kbd>Remove</kbd> method.</p>
<p>In the preceding example, when the user left-clicks on the <kbd>Canvas</kbd>, the <kbd>e.GetPosition</kbd> method provides the coordinate position (<kbd>X</kbd>, <kbd>Y</kbd>) of the click, relative to the panel where it was clicked. The <kbd>Canvas.SetLeft</kbd> and <kbd>Canvas.SetTop</kbd> methods are used to position the created element relative to the panel and then are added to it.</p>
<p>Similarly, to delete the element from the panel, the <kbd>e.Source</kbd> property is used to retrieve the element where the user right-clicked. If it is not <kbd>null</kbd>, remove it from the <kbd>Canvas</kbd> by calling the <kbd>Remove</kbd> method.</p>
<h2 id="uuid-fb8c9bee-9f4e-4cc7-95e8-bcea74799127">There's more...</h2>
<p>The coordinate positions are used to place elements in a <kbd>Canvas</kbd> panel. When you want to place an item in a <kbd>Grid</kbd>, set the <kbd>Row</kbd> and <kbd>Column</kbd> while placing it. For <kbd>StackPanel</kbd>, <kbd>WrapPanel</kbd>, and <kbd>UniformGrid</kbd> panels, you won't need to specify any other property as those will be stacked automatically.</p>
<p>The following example shows you how to dynamically add an element in a <kbd>Grid</kbd>, at a specific cell position, specified by the <kbd>Row</kbd> and <kbd>Column</kbd> index:</p>
<pre style="padding-left: 60px">// set the Row and Column to place the element 
Grid.SetRow(element, rowIndex); 
Grid.SetColumn(element, columnIndex); 
 
// add the element to the Grid 
gridPanel.Children.Add(element); </pre>
<p>If you want to span the element to multiple rows and multiple columns, you can do so by calling the <kbd>Grid.SetRowSpan</kbd> and <kbd>Grid.SetColumnSpan</kbd> methods, as shown in the following code:</p>
<pre style="padding-left: 60px">Grid.SetRowSpan(element, noOfRowsToSpan); 
Grid.SetColumnSpan(element, noOfColumnsToSpan); </pre>
<h1 id="uuid-27541c99-fe81-4e00-918e-65be04645bc0">Implementing the drag and drop feature</h1>
<p>When you want to provide a rich experience to the user, you may want to use the dragging and dropping feature. You may also want to add a drag and drop feature in your application to access a local resource to upload it to the server.</p>
<p>In this recipe, we will learn the basics of drag and drop implementation in WPF by using a simple example.</p>
<h2 id="uuid-d71c1821-bf7e-4dbe-ba1a-572a6b6a6ad4">Getting ready</h2>
<p>Open Visual Studio and create a new WPF application named <kbd>CH03.DragAndDropDemo</kbd>.</p>
<h2 id="uuid-d6863f3a-aa91-4c96-9d8c-86cd4996611a">How to do it...</h2>
<p>Let's perform the following steps to create a few elements inside a window and provide the option to drag and drop from one panel to the other:</p>
<ol>
<li>First, open <kbd>MainWindow.xaml</kbd> and replace the existing <kbd>Grid</kbd> with a <kbd>StackPanel</kbd>. Set its <kbd>Orientation</kbd> property to <kbd>Horizontal</kbd>.</li>
<li>Add two <kbd>WrapPanel</kbd> inside it and set their <kbd>Width</kbd>, <kbd>Margin</kbd>, <kbd>ItemHeight</kbd>, and <kbd>ItemWidth</kbd> properties.</li>
<li>Give a name to both panels. Let's name the first wrap panel <kbd>sourcePanel</kbd> and the second wrap panel <kbd>targetPanel</kbd>. We will be using these name later from the code, while accessing them.</li>
<li>Add a few labels to the first wrap panel. Set their <kbd>Content</kbd>, <kbd>Background</kbd>, and other text formatting properties. Here's the complete markup code:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal"&gt; 
    &lt;WrapPanel x:Name="sourcePanel" 
               ItemHeight="60" ItemWidth="100" 
               Width="200" Margin="4" 
               Background="LightGoldenrodYellow"&gt; 
        &lt;Label Content="Item 1" 
               Background="Olive" Margin="4" 
               Foreground="White" FontSize="22" /&gt; 
        &lt;Label Content="Item 2" 
               Background="Olive" Margin="4" 
               Foreground="White" FontSize="22" /&gt; 
        &lt;Label Content="Item 3" 
               Background="Olive" Margin="4" 
               Foreground="White" FontSize="22" /&gt; 
        &lt;Label Content="Item 4" 
               Background="Olive" Margin="4" 
               Foreground="White" FontSize="22" /&gt; 
        &lt;Label Content="Item 5" 
               Background="Olive" Margin="4" 
               Foreground="White" FontSize="22" /&gt; 
    &lt;/WrapPanel&gt; 
    &lt;WrapPanel x:Name="targetPanel" 
               ItemHeight="60" ItemWidth="100" 
               Width="200" Margin="4" 
               Background="OldLace"&gt; 
    &lt;/WrapPanel&gt; 
&lt;/StackPanel&gt;</pre>
<ol start="5">
<li>If you run this application, you will see two panels on the screen. As shown in the following screenshot, one of them will have five labels (<span class="packt_screen">Item 1</span> - <span class="packt_screen">Item 5</span>) and the other will be empty:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ea19316b-0c08-4765-8c26-05fc2d86e577.png" style=""/></div>
</li>
</ol>
<p style="padding-left: 90px">If you now drag any element from the left panel and try to drop it to the right panel, you will see that it won't work. We have not yet added the drag and drop support.</p>
<ol start="6">
<li>To add the dragging support to the first wrap panel (<kbd>sourcePanel</kbd>), register its <kbd>MouseLeftButtonDown</kbd> event property in the XAML as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;WrapPanel x:Name="sourcePanel" 
           ItemHeight="60" ItemWidth="100" 
           Width="200" Margin="4" 
           Background="LightGoldenrodYellow" 
           MouseLeftButtonDown="OnDrag"&gt; </pre>
<ol start="7">
<li>An <kbd>OnDrag</kbd> event, registered in XAML, needs to be implemented in the code behind the file. Open <kbd>MainWindow.xaml.cs</kbd> and add the following event implementation, which will add the dragging support to the <kbd>sourcePanel</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private void OnDrag(object sender, MouseButtonEventArgs e) 
{ 
    if (e.Source is UIElement draggedItem) 
    { 
        DragDrop.DoDragDrop(draggedItem,  
                            draggedItem,  
                            DragDropEffects.Move); 
    } 
}</pre>
<ol start="8">
<li>Now we need to enable the second wrap panel (<kbd>targetPanel</kbd>) as a droppable target and set its <kbd>AllowDrop</kbd> property to <kbd>True</kbd>.</li>
<li>Also register its <kbd>Drop</kbd> event property, so that we can perform the <kbd>drop</kbd> operation. Here's the entire mark-up for the second panel:</li>
</ol>
<pre style="padding-left: 90px">&lt;WrapPanel x:Name="targetPanel" 
            ItemHeight="60" ItemWidth="100" 
            Width="200" Margin="4" 
            Background="OldLace" 
            AllowDrop="True" 
            Drop="OnDrop"&gt; 
    &lt;!-- This is the DROP Target --&gt; 
&lt;/WrapPanel&gt; </pre>
<ol start="10">
<li>Now we need to implement the body of the <kbd>OnDrop</kbd> event to perform the desired <kbd>drop</kbd> operation. Navigate to <kbd>MainWindow.xaml.cs</kbd> once again and add the following code:</li>
</ol>
<pre style="padding-left: 90px">private void OnDrop(object sender, DragEventArgs e) 
{ 
    var draggedData = e.Data; 
    if (draggedData.GetData(draggedData.GetFormats()[0]) 
                            is UIElement droppedItem) 
    { 
        sourcePanel.Children.Remove(droppedItem); 
        targetPanel.Children.Add(droppedItem); 
    } 
} </pre>
<ol start="11">
<li>Let's run the application now. The same screen will appear with two panels. The first panel (left) will have a few elements in it. Position your cursor on one of them, click it to drag it to the other panel (right), and release it there. You will see that the item will be removed from the first and added to the right panel, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9f443bef-960e-452f-8cac-74c8cbce75c0.png" style=""/></div>
<h2 id="uuid-ed7e5217-4451-49b4-955f-633fa02da0c4">How it works...</h2>
<p>The <kbd>AllowDrop="True"</kbd> property prepares the panel as drop enabled. When you start a drag by clicking on the element, the <kbd>DragDrop.DoDragDrop</kbd> method written in the <kbd>OnDrag</kbd> event initiates the drag and drop operation. It takes the first parameter as a reference to the dependency object, that is, the source of the data being dragged. The second parameter is the data object that contains the data being dragged. And the last parameter is a value that specifies the final effect (<kbd>DragDropEffects</kbd>) of the operation.</p>
<p>In the preceding example, when the element is dropped to the drop target, the dragged data retrieved from the <kbd>DragEventArgs</kbd> parameter value is first removed from the source and  then added to the drop target.</p>
<h2 id="uuid-36a93f58-4b60-4b7f-831b-c321df3f06b9">There's more...</h2>
<p>Based on your drag-and-drop requirement, you can change the effects by specifying the proper enum value of the <kbd>DragDropEffects</kbd>. The effects can be of six types:</p>
<ul>
<li><strong>None</strong>: When specified, the drop target will not accept any data and the cursor will change to an unavailable icon:
<div class="CDPAlignCenter CDPAlign"><span class="IconPACKT"><span class="IconPACKT"><img src="assets/5f7bfa5a-264d-49f6-b391-8298c304bfd9.png"/></span></span></div>
</li>
<li>
<p><strong>Copy</strong>: When specified, the data is copied to the drop target and during the <kbd>drop</kbd> operation on the target, the cursor will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><span class="IconPACKT"><img src="assets/30eaf1fe-8751-4564-9f16-88719032c8de.png"/></span></div>
</li>
<li>
<p><strong>Move</strong>: When specified, the data from the source is moved to the drop target. During the <kbd>drop</kbd> operation, the cursor will change to the following:</p>
<div class="CDPAlignCenter CDPAlign"><span class="IconPACKT"><img src="assets/51a204dc-58fa-4089-a752-ea568d19e36a.png"/></span></div>
</li>
<li>
<p><strong>Link</strong>: When specified, the data from the source is linked to the drop target. During the <kbd>drop</kbd> operation on the target, the cursor will change to the following:</p>
<div class="CDPAlignCenter CDPAlign"><span class="IconPACKT"><img src="assets/087a2a06-f58f-4c4a-9922-45f4e19b25d2.png"/></span></div>
</li>
<li>
<p><strong>Scroll</strong>: When specified, it defines whether the scrolling is about to start or currently happening on the drop target.</p>
</li>
<li>
<p><strong>All</strong>: When specified, the data is copied and scrolled to the drop target after being removed from the source.</p>
</li>
</ul>


            </article>

            
        </section>
    </body></html>