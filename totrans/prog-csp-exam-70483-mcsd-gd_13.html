<html><head></head><body>
        

                            
                    <h1 class="header-title">Managing Assemblies and Debugging Applications</h1>
                
            
            
                
<p class="mce-root">In the last chapter, we learned about cryptography and how we can encrypt and decrypt using different techniques available in C#. In this chapter, we will focus on how we can manage .NET assemblies, debugging applications, and how to do tracing. Writing a .NET application appears to be relatively simple; however, it is important to make sure your program serves its purpose, maintains quality standards, doesn't crash on exceptions, and behaves properly in all circumstances. To achieve such a quality output, it is important to test your application and check the input source and values generated at runtime, which are used in the application logic for further processing and so on.</p>
<p>Assemblies are the fundamental units of .NET application deployment. They maintain the version, type, resources required, scope, and security details. We will discuss this in more detail in the upcoming sections.</p>
<p>Debugging is the process of stepping through each and every line of code that seems to be problematic or code that you believe will throw errors. During this process, we can observe the values in the variables and parameters and whether the program is running as expected.</p>
<p>It is also important to understand whether we are creating a library or an independent application to distribute to clients. Based on this, we can decide what type (<kbd>.exe</kbd> or <kbd>.dll</kbd>) of application needs to be created.</p>
<p>Tracing allows you to track through each and every line of code while it is executing.</p>
<p>After reading this chapter, you will be able to understand assemblies in .NET and how we can manage them, as well as versioning and signing. We will also look at a number of ways to debug an application and how to write trace messages when an exception occurs. In this chapter, we will cover the following topics:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>Assemblies</li>
<li>Debugging a C# application</li>
<li>Tracing</li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>You can practice the exercises from this chapter using Visual Studio 2012 or later with .NET Framework 2.0 or later. However, any new C# features from C# 7.0 and later require you to have Visual Studio 2017.</p>
<p>If you don't have a license for any of these products, you can download the Community version of Visual Studio 2017 from <a href="https://visualstudio.microsoft.com/downloads/" target="_blank">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>The sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter13">https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter13.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Assemblies</h1>
                
            
            
                
<p>Assemblies in the .NET Framework can be of two types, <kbd>.exe</kbd> or <kbd>.dll</kbd>, and are termed as the building blocks of a .NET application.</p>
<p>These assemblies form the basic units of an application and allow a programmer to maintain versions, security, scope of usage, and reuse. Since an assembly contains all the information required to execute your application, it provides the runtime with information about what .NET types are used and what features of runtime are required to execute the application.</p>
<p>When you create an application in .NET using Visual Studio, it creates source code files (<kbd>.cs</kbd> files), properties of an assembly (<kbd>AssemblyInfo.cs</kbd>):</p>
<p class="mce-root"/>
<div><img src="img/f9e5d21d-413c-4dfb-8eb0-a04b89d516fe.png" style=""/></div>
<p>These projects allow programmers to associate other assemblies, which, in turn, allows them to create and maintain larger projects for multiple users to work on each project. When work on individual projects is completed, these projects can be created as one assembly unit to release for the customer.</p>
<p>When an assembly is created, each assembly creates a manifest file that details information about the following:</p>
<ul>
<li>Each file that has been used in creating this assembly</li>
<li>If there are any references that have been used</li>
<li>The version of the assembly with a unique name</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Assembly contents and manifest</h1>
                
            
            
                
<p>An assembly in the .NET Framework contains the following four elements:</p>
<ul>
<li>Assembly manifest</li>
<li>Metadata</li>
<li>MSIL code</li>
<li>Resources</li>
</ul>
<p class="mce-root"/>
<p>These elements can be grouped into one assembly, as shown in the following screenshot. Here, the runtime requires manifest information in order to get the type information, the dependent assembly information, the version, and the unique name of the assembly in order to execute:</p>
<div><img src="img/d38c91ad-6f14-43d1-8ebb-82e3ef688f7c.png" style=""/></div>
<p>The .NET Framework also allows us to group the four elements of the assemblies into multiple modules and create an assembly to refer them while executing the program block. When you refer such modules in an assembly, it is the manifest file that maintains all the links required to refer to these resources:</p>
<div><img src="img/783be34c-df17-4984-9e8f-3d8d000411fe.png" style=""/></div>
<p>An assembly manifest contains the name of the assembly, the version of the assembly, which culture is used to build the assembly, the strong name information (that is, public key), the type information, a list of files and how they are associated with each other and the assembly, and, finally, a list of referenced assemblies and their versions. We can add more information by updating the <kbd>AssemblyInfo.cs</kbd> file.</p>
<p>A manifest file can be part of the <strong>portable executable</strong> (<strong>PE</strong>) file along with MSIL or a standalone PE file. Each assembly file contains all the files that are required for an assembly; it governs how the mapping between these files, resources, and assemblies are maintained, and it also contains referenced assemblies.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Target .NET Framework</h1>
                
            
            
                
<p>When you create a C# application, you can specify which .NET Framework you want to target your application to. In a real-world scenario, not every customer updates their servers with the latest versions when new versions of the Framework are released. Additionally, when a new version is released, some of the old features might be deprecated and newer versions of the existing features are added. In these situations, your application should not fail. So, the .NET Framework allows you to target your application to a specific version of the .NET Framework.</p>
<p class="mce-root">You can target the .NET Framework version while creating a new project using Visual Studio, or change the target framework using the property pages of the project:</p>
<div><img src="img/4ec18630-b493-42d5-a3a4-859dd0886f99.png"/></div>
<p class="mce-root"/>
<p>Alternatively, to change the target framework version using the property pages, select an existing project, right-click on it, and then navigate to Properties:</p>
<div><img src="img/c06ae7e5-26ca-4308-b509-0e6e9a78cc07.png" style=""/></div>
<p class="mce-root"/>
<p>In the Target framework drop-down menu, select your required version:</p>
<div><img src="img/18409511-c029-4f79-8589-9f4c7032e293.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Signing assemblies</h1>
                
            
            
                
<p>Creating a unique identity for an assembly is referred to as signing or strong-naming an assembly. Providing a unique identity for an assembly avoids assembly conflicts. Each assembly maintains hashes of the modules, resources, and file information in its manifest. When you sign an assembly, the following is captured:</p>
<ul>
<li>The name of the assembly</li>
<li>The version number of the assembly</li>
<li>If available, the culture (also called <em>locale</em> for code development) of the assembly</li>
<li>The public key that is used to sign the assembly to the assembly manifest</li>
</ul>
<p class="mce-root"/>
<p>Signing an assembly provides the following benefits:</p>
<ol>
<li>It allows us to give a friend access to other signed assemblies.</li>
<li>It allows us to run different versions of the same assembly side by side.</li>
<li>It allows us to deploy our assembly into the GAC. This allows other applications to use our assembly as well.</li>
</ol>
<p>You can sign an assembly in two ways: the first is by using Visual Studio, and the second is by using the command-line tool. Visual Studio makes it simple to sign the assembly.</p>
<p>Here, we will demonstrate how to sign an assembly using Visual Studio:</p>
<ol>
<li>Navigate to Project Properties.</li>
<li>Navigate to the Signing* tab on the left side:</li>
</ol>
<div><img src="img/71acc81d-2c4f-49e6-b573-ef151d920e96.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Select the Sign the assembly checkbox.</li>
<li>Choose &lt;New...&gt; in the drop-down menu, and then choose a strong key filename:</li>
</ol>
<div><img src="img/7ae0ae8b-23f2-4248-9896-4a6334c79a7f.png"/></div>
<ol start="5">
<li>Give a key filename in the pop-up window.</li>
<li>Visual Studio allows you to choose an algorithm and provide a password for the key file.</li>
<li>The password is optional; an algorithm can be changed as per your requirements from the available list.</li>
</ol>
<p>Alternatively, we can sign an assembly using Command Prompt and Visual Studio tools that come with the following installation steps:</p>
<ol>
<li>Click the Windows button on your system.</li>
<li>Navigate through the installed programs.</li>
<li>Find the Visual Studio 20xx installation folder.</li>
<li>Select Developer Command Prompt for Visual Studio 20xx.</li>
</ol>
<p> </p>
<ol start="5">
<li>Use <kbd>sn.exe</kbd> to generate a strong name pair into a <kbd>.snk</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>sn -k keyPair.snk</strong></pre>
<ol start="6">
<li>Once the key file is created, you can now use Visual Studio to sign the assembly or use the <kbd>al.exe</kbd> tool.</li>
<li>Use <kbd>al.exe</kbd> to link the assembly and key pair generated in the preceding steps:</li>
</ol>
<pre style="padding-left: 60px">al /out:chapter12.dll MyModule.netmodule /keyfile:keyPair.snk</pre>
<p>More information about these commands is available on MSDN (<a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool">https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Versioning assemblies</h1>
                
            
            
                
<p>When you are ready with an assembly and have signed it, you can version it. When you version an assembly, the current assembly and all the dependent assembly versions are maintained in the assembly manifest. When a versioned assembly is deployed into an environment, then that becomes the default version of your application and the system throws an assembly manifest mismatch error when either the current assembly or dependent assemblies do not match the default version. There is a way to override this using a configuration file, which tells the runtime to use a specific version instead of the default version.</p>
<p>When an assembly is executed at runtime, it performs multiple steps to resolve assembly binding:</p>
<ol>
<li>It checks the current assembly for the version information and a unique name.</li>
<li>It checks for configuration files to see whether any version override policies are defined.</li>
<li>In the case of any policy changes, the runtime identifies and loads the redirected assembly as per the policy.</li>
<li>It checks the GAC, or the path specified in configuration files, then the application directory, subdirectories, and serves the assembly binding request.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Version number</h1>
                
            
            
                
<p>Every assembly maintains version information in two forms, identity and informational. The version number, name, and culture of the assembly form the identity of the assembly and the informational version is provided in a string format specified in the assembly info file and is for informational purposes.</p>
<p>The version number of an assembly is represented as a four-part string:</p>
<pre>&lt;Major version&gt;.&lt;Minor Version&gt;.&lt;Build number&gt;.&lt;revision&gt;</pre>
<p>For example, if an assembly version is set to 2.1.1234.2, this indicates that the major version of the assembly is 2, the minor version is 1, the build number is 1234, and the revision number is 2. When this version is created or updated, it is maintained in the manifest file along with a snapshot of all resources and dependent assembly files and their versions. In addition to this, versioning checks are applicable only when the assembly is signed.</p>
<p>One important thing to understand from a real-world scenario is that, when you build a product and release your assemblies for customers and later upgrade your assembly, then you have to maintain the previous versions. So, when a new version of an assembly is released, clients can still use the old version as long as it is supported.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging the C# application</h1>
                
            
            
                
<p>When you build a C# application, you will have two options, debug mode and release mode. Debug mode helps you to step through each and every line of your code to check for errors and fix them if required. Release mode doesn't allow us to step into code. Visual Studio makes it easy for developers by providing more tools, which allows us to <kbd>Step-in</kbd>, <kbd>Step-Over</kbd>, and <kbd>Step-Out</kbd> when a debug point is hit by the runtime. These tools are highlighted in a blue box in the following screenshot:</p>
<div><img src="img/a8cf1510-0044-4384-8068-5794adbb58c4.png"/></div>
<p class="mce-root"/>
<p>Apart from these tools, Visual Studio also allows us to view stack trace, inspect variables, and much more. Let's explore this further in order to understand more about debugging.</p>
<p>Let's start with the basics. To place a breakpoint, just click on the left margin next to the line of code you want to debug or place your cursor on the line and press the <em>F9</em> key on the keyboard. Another way to place a breakpoint is to select the Debug menu option and select a new breakpoint.</p>
<p>When you set a breakpoint, the entire line of code is highlighted in the color brown. When the program starts the execution with breakpoints, the control halts at the breakpoint and highlights the line in yellow, which means the highlighted line is set to execute next:</p>
<div><img src="img/5e62e947-ea7b-4de0-a6be-15db19645440.png"/></div>
<p>Observe the preceding screenshot; we have a breakpoint at line 13. When you start the program, the control halted at line 13 where the breakpoint is placed. When we step-over, the output is printed on the screen but the control stays at line 14 as shown in the following screenshot:</p>
<div><img src="img/0b12e200-d1f1-42ff-a118-ecd226d3906e.png"/></div>
<p class="mce-root"/>
<p>When a breakpoint is hit, though the application execution is halted, all the variables, functions, and objects remain in memory, allowing us to validate the values. When you want to debug an application, you build it in debug mode, which generates a <kbd>.pdb</kbd> file; this file is key for debugging. The <kbd>.pdb</kbd> file contains symbols (or source) that get loaded into memory to allow us to debug. If these symbols were not loaded, then you might see an error message stating that the symbols were not found. It is also important to maintain the versions of these <kbd>pdb</kbd> files, as any version mismatch between your assembly and the <kbd>.pdb</kbd> file will result in an assembly version mismatch error.</p>
<p>Let's jump into an example code and examine the different actions we can perform while debugging, as well as the features that Visual Studio provides us with.</p>
<p>The following is an example program that accepts two numbers and calculates the addition and subtraction of those numbers, and then invokes another method where 10 is added to the result. Let's debug this application by placing a couple of breakpoints in the code block:</p>
<pre>internal void Method2()<br/>{<br/>    Console.WriteLine("Enter a numeric value");<br/>    int number1 = Convert.ToInt32(Console.ReadLine());<br/><br/>    Console.WriteLine("Enter another numeric value");<br/>    int number2 = Convert.ToInt32(Console.ReadLine());<br/><br/>    int number3 = number1 + number2;<br/>    int number4 = number1 - number2;<br/>    int number5 = Method3(number4);<br/><br/>}<br/><br/>internal int Method3(int number4)<br/>{<br/>    return number4+10;<br/>}</pre>
<p class="mce-root"/>
<p>Here, two breakpoints were placed on lines 18 and 21. When the program starts executing, it stops at line 18 for user input and when you select continue program execution, the control stops at line 21. One of the important things to observe in the following screenshot is that when the control stops at line 21, you can view the value of the <kbd>number1</kbd> variable by just hovering the cursor over it. You can see that the <kbd>number1</kbd> variable has a value of 23:</p>
<div><img src="img/6b5d47b8-2511-42dc-9542-64f4d53e0155.png" style=""/></div>
<p class="mce-root"/>
<p>Visual Studio debugging tools allow us to watch a variable while the program is being executed in debug mode. You can right-click on a variable and select <kbd>Add Watch</kbd> to add the variable to the watch window. As you see can see at the bottom of the screen, there is a watch window where variable <kbd>number3</kbd> has been added, and we can see the value of 43, which is the output of the sum of <kbd>number1</kbd> and <kbd>number2</kbd>. The watch window allows you to view the values after the line of code executes. This comes in really handy when your application logic is performing complex calculations:</p>
<div><img src="img/a8246f05-0ac9-4632-9ea7-4eb4254c8cb9.png" style=""/></div>
<p class="mce-root"/>
<p>Another window that comes in handy with debugging is Immediate Window (<em>Ctrl</em> + <em>Alt</em> + <em>I</em>), which can be opened by using the keyboard shortcut or the Debug menu. In contrast to the watch window, this window helps you to perform operations before executing the line of code. As you can see in the following screenshot, the control is at line 25 where the breakpoint was hit; however, if you look down, the Immediate Window was open where we performed the <kbd>number1 - number2</kbd> operation to check the value before executing the line:</p>
<div><img src="img/2e22f179-f671-4a0e-bd35-d05dfea5167c.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root">When you place a breakpoint and hover your cursor over the breakpoint in the left margin, the system displays a cogwheel, which allows you to add conditions to your breakpoint; for example, your program has a <kbd>for</kbd> loop, but you want your breakpoint to hit when the loop variable is, say, 5:</p>
<div><img src="img/77f9d984-84ff-4937-9843-cb3194be2e4c.png"/></div>
<p>When you click on the cogwheel, you will be presented with the condition wizard where you can configure the condition of when the breakpoint should hit. By default, the condition is set to true, which can be changed by the developer. In the following screenshot, we selected <kbd>number4=3</kbd>, which means that this breakpoint will be hit when the number 4 value is equal to 3:</p>
<div><img src="img/2f513cd1-b8eb-4c1b-99ac-8f40c5123818.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Another important feature to understand while debugging is that certain types of projects in Visual Studio allow you to change the variable values at runtime while debugging the application. When the following program was executed, we entered <kbd>60</kbd> as a numeric value to variable <kbd>number2</kbd>. You can see the value of variable 2 as follows:</p>
<div><img src="img/89927d5a-4ed2-4e35-97fd-838ba6cdd89e.png" style=""/></div>
<p>Now, when you select the displayed value, the system allows you to change it (we changed it to 40), and then continue the execution of the block with the modified value. Please remember that not every project type will allow you to change values at runtime:</p>
<div><img src="img/827276d3-68e8-4aec-89fc-4528e6c844d2.png"/></div>
<p class="mce-root"/>
<p>As discussed earlier, there are many tools available while debugging a C# application using Visual Studio and some of them are highlighted in the following screenshot. The Continue and Stop Debugging buttons enable the developer to continue executing once a breakpoint is hit, or to stop the execution.</p>
<p>There are buttons to Step Into, Step Out, and Step Over. These buttons allow you to step into each and every line of code once a breakpoint is hit, or skip the execution of a method and continue the execution in the same context, or step into an external method.</p>
<p>Once you debug your program block and fix all the issues you found, you can disable or delete all the breakpoints at once by using the Delete All Breakpoints or Disable All Breakpoints option in the Debug menu:</p>
<div><img src="img/e89d54cf-518b-4b89-aaf3-8ece2e141ef5.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>A few more options are highlighted in the following screenshot, such as Attach to Process, QuickWatch..., Save Dump As..., Parallel Stacks, Immediate, and Watch windows, Call Stack, and many more:</p>
<div><img src="img/bd92a1b4-55c0-4080-bd4f-a9104f8ff016.png"/></div>
<p>We structure our project in such a way that multiple assemblies are created, be it a helper or a dependent assembly. While debugging, it is important to load the symbols by attaching the process running those assemblies to the current debugging process using the Attach to Process... command. Otherwise, the system prompts that the source code is not available, so control cannot step into the code block.</p>
<p>In a real-project scenario, sometimes your application crashes suddenly; in such scenarios, you can save the memory dump and analyze the memory registers on what's happening. This might require you to have special skills to read and understand such dumps.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We read about parallel tasks and multithreading in previous chapters; when your code block is running a multithreaded application of parallel tasks, the Debug menu can help you understand the parallel stack and tasks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tracing</h1>
                
            
            
                
<p>Tracing enables us to monitor an application while it is executing. When a program is executed, the runtime allows us to write messages to monitor the control flow of the program. This will enable us to identify any incorrect behavior of the application logic. In the case of exceptions, we can identify where exactly the code failed and what variable values caused issues in smooth execution. These messages can be created by the <kbd>System.Diagnostics.Debug</kbd> class. When such messages are created, by default, these messages are displayed in the output window of Visual Studio.</p>
<p>Apart from creating these messages, you can redirect these messages to a file or database using the <kbd>System.Diagnostics.Trace</kbd> class. You can register listeners using the trace class, which allows you to redirect your messages. Here, your debug class or trace class acts as the publisher and the listener class acts as a subscriber. We hope you remember <a href="66c957f7-4032-461e-91e4-00da1eb6a517.xhtml">Chapter 5</a>, <em>Creating and Implementing Events and Callbacks</em>, where we learned about the publisher and subscriber model.</p>
<p>Let's take a look at an example to understand how we can use debug messages. In the following program, we are trying to accept two input parameters and perform actions such as addition and subtraction on those numbers. However, we added a few extra lines to monitor messages that record what's happening:</p>
<pre>internal void Method4()<br/>{<br/>    Console.WriteLine("Enter a numeric value");<br/>    int number1 = Convert.ToInt32(Console.ReadLine());<br/>    Debug.WriteLine($"Entered number 1 is: {number1}");<br/><br/>    Console.WriteLine("Enter another numeric value");<br/>    int number2 = Convert.ToInt32(Console.ReadLine());<br/>    Debug.WriteLine($"Entered number 2 is: {number2}");<br/><br/>    int number3 = number1 + number2;<br/>    Debug.WriteLineIf(number3&gt;10, $"Sum of number1 &amp; number 2 is : {number3}");<br/>    int number4 = number1 - number2;<br/>    Debug.WriteLineIf(number4 &lt; 10, $"Difference of number1 &amp; number 2 is : {number4}");<br/>}</pre>
<p class="mce-root"/>
<p>Because we used <kbd>Debug.WriteLine</kbd> to record the messages, these values are written in the output window. Observe the following output window where all <kbd>Debug.WriteLine</kbd> messages are written:</p>
<div><img src="img/7a6ff62f-d20c-41e9-861b-15be1758cad5.png" style=""/></div>
<p>In the preceding code block, you can see the last two <kbd>Debug.WriteLine</kbd> statements in the program block, where <kbd>Debug.WriteLineIf</kbd> is used. The system checks the condition that we provided, and, if it returns true, the system writes the message to the output window.</p>
<p>Now, let's go a step further and see how we can use tracing listeners to redirect your message to different channels.</p>
<p class="mce-root"/>
<p>We are going to use the same program with five extra lines, where we add <kbd>Console.Out</kbd> and a <kbd>logfile.txt</kbd> file as two different trace listeners, and then attach these two listeners to the debug object. The last line is <kbd>Debug.Flush</kbd>, which pushes all messages from the object to the log file:</p>
<pre>internal void Method5()<br/>{<br/>    TextWriterTraceListener listener1 = new TextWriterTraceListener(Console.Out);<br/>    Debug.Listeners.Add(listener1);<br/><br/>    TextWriterTraceListener listener2 = new TextWriterTraceListener(File.CreateText("logfile.txt"));<br/>    Debug.Listeners.Add(listener2);<br/><br/>    Console.WriteLine("Enter a numeric value");<br/>    int number1 = Convert.ToInt32(Console.ReadLine());<br/>    Debug.WriteLine($"Entered number 1 is: {number1}");<br/><br/>    Console.WriteLine("Enter another numeric value");<br/>    int number2 = Convert.ToInt32(Console.ReadLine());<br/>    Debug.WriteLine($"Entered number 2 is: {number2}");<br/><br/>    int number3 = number1 + number2;<br/>    Debug.WriteLineIf(number3 &gt; 10, $"Sum of number1 &amp; number 2 is : {number3}");<br/>    int number4 = number1 - number2;<br/>    Debug.WriteLineIf(number4 &lt; 10, $"Difference of number1 &amp; number 2 is : {number4}");<br/>    Debug.Flush();<br/>}</pre>
<p>Because we added <kbd>Console.Out</kbd> as one of the listeners, <kbd>Debug.WriteLine</kbd> messages are now written on the screen when we execute the program:</p>
<div><img src="img/e21a96aa-f660-4150-ae0b-bb2a2ab61805.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Additionally, as we added <kbd>logfile.txt</kbd> as one of the listeners, a new text file gets created in the program executing folder where <kbd>Debug.WriteLine</kbd> messages are written:</p>
<div><img src="img/a740c00a-e4a4-4ad6-b061-02ea315c39f7.png" style=""/></div>
<p>These listeners are not limited to text files and console. Based on the project requirement, you can add XML, database listeners, which might require some extra coding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how a C# assembly can be managed, how to debug an assembly or a program block, what features Visual Studio gives us in performing these actions, and how to use tracing.</p>
<p>In the next chapter, we will look at the different functionalities provided in C# to access and utilize the data present in file objects and external web services, focusing on performing I/O operations on file objects and the different helper classes available in the <kbd>System.Net</kbd> namespace, which helps us with I/O operations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What does the version number of an assembly represent?
<ol>
<li>Major version, minor version, build number, and revision.</li>
<li>Major build, major version, assembly number, and date.</li>
<li>Major build, major version, assembly number, and revision.</li>
<li>All of the above.</li>
</ol>
</li>
<li>What is the important benefit of strong naming an assembly?
<ol>
<li>It allows you to share your assembly.</li>
<li>It allows you to run more than two assemblies at the same time.</li>
<li>It allows you to get it installed in GAC.</li>
<li>All of the above.</li>
</ol>
</li>
<li>What is the easiest way to log debug messages in a text file?
<ol>
<li>Create a file and use a text stream object to write messages.</li>
<li>Create a trace listener and attached it to the debug object.</li>
<li>Use a third-party logging assembly.</li>
<li>All of the above.</li>
</ol>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Answers</h1>
                
            
            
                
<ol>
<li><strong>Major version, minor version, build number, and revision</strong></li>
<li><strong>All of the above</strong></li>
<li><strong>Create a trace listener and attached it to the debug object</strong></li>
</ol>


            

            
        
    </body></html>