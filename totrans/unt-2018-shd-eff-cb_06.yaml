- en: Vertex Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term shader originates from the fact that Cg has been used mainly to simulate
    realistic lighting conditions (shadows) on 3D models. Despite this, shaders are
    now much more than that. They not only define the way the objects are going to
    look, they can also redefine their shapes entirely. If you want to learn how to
    manipulate the geometry of a 3D object via shaders, this is the chapter for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a vertex color in a Surface Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating vertices in a Surface Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extruding your models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a snow shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a volumetric explosion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader*, we explained that 3D models are not just a collection of triangles.
    Each vertex can contain data that is essential to render the model itself correctly.
    This chapter will explore how to access this information in order to use it in
    a shader. We will also explore in detail how the geometry of an object can be
    deformed simply using Cg code.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a vertex color in a Surface Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin this chapter by taking a look at how we can access the information
    of a model's vertex using the vertex function in a Surface Shader. This will arm
    us with the knowledge to start utilizing the elements contained within a model's vertex in
    order to create really useful and visually appealing effects.
  prefs: []
  type: TYPE_NORMAL
- en: A vertex in a vertex function can return information about itself that we need
    to be aware of. You can actually retrieve the vertices' normal directions as a
    float3 value and the position of the vertex as float3, and you can even store
    color values in each vertex and return that color as float4\. This is what we
    will take a look at in this recipe. We need to see how to store color information
    and retrieve this stored color information inside each vertex of a Surface Shader.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write this shader, we need to prepare a few assets.
  prefs: []
  type: TYPE_NORMAL
- en: In order to view the colors of a vertex, we need to have a model that has had
    color applied to its vertices. While you could use Unity to apply colors, you
    would have to write a tool to allow an individual to apply the colors or write
    some scripts to achieve the color application.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this recipe, you can use a 3D modeling tool such as Maya or Blender to
    apply the colors to our model. There is a model available in the example code
    provided with the book in the `Chapter 06 `| `Models` folder (`VertexColorObject.fbx`)
    that you can obtain at the book's *Support* page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will set us up to create this Vertex Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and place the imported model (`VertexColorObject`) in the
    scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Shader (`SimpleVertexColor`) and Material (`SimpleVertexColorMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When completed, assign the shader to the material and then the material to the
    imported model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your scene should now look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our scene, shader, and material created and ready to go, we can begin
    to write the code for our shader. Launch the shader by double-clicking on it in
    the Project tab in the Unity editor. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are creating a very simple shader, we will not need to include any properties
    in our `Properties` block. We will still include a `Global Color Tint`, just to
    stay consistent with the other shaders in this book. Enter the following code
    in the `Properties` block of your shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This next step tells Unity that we will be including a vertex function in our
    shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, if we have included properties in our `Properties` block, we must
    make sure to create a corresponding variable in our `CGPROGRAM` statement. Enter
    the following code just below the `#pragma` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now turn our attention to the `Input struct`. We need to add a new variable
    in order for our `surf()` function to access the data given to us by our `vert()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write our simple `vert()` function to gain access to the colors
    stored in each vertex of our mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the vertex color data from our `Input struct` to be assigned
    to the `o.Albedo` parameters in the built-in `SurfaceOutput` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With our code completed, we can now re-enter the Unity editor and let the shader
    compile. If all goes well, you should see something similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides us with a way to access the vertex information of the model to
    which a shader is attached. This gives us the power to modify things such as the
    vertices' position and color. With this recipe, we have imported a mesh from Maya
    (though just about any 3D software application can be used), where vertex colors
    were added to `Verts`. You'll notice that by importing the model, the default
    material will not display the vertex colors. We actually have to write a shader
    to extract the vertex color and display it on the surface of the model. Unity
    provides us with a lot of built-in functionality when using Surface Shaders, which
    makes the process of extracting this vertex information quick and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to tell Unity that we will be using a vertex function when
    creating our shader. We do this by adding the `vertex:vert` parameter to the `#pragma`
    statement of `CGPROGRAM`. This automatically makes Unity look for a vertex function
    named `vert()` when it goes to compile the shader. If it doesn't find one, Unity
    will throw a compiling error and ask you to add a `vert()` function to your shader.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to our next step. We have to actually code the `vert()` function,
    as seen in *step 5*. We first use a built-in macro to make sure that the `0` variable
    is initialized to 0 if it doesn't have anything that is a requirement if you are
    targeting DirectX 11 or above.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the macro, as well as all of the other macros that ShaderLab
    has to offer, check out: [https://docs.unity3d.com/Manual/SL-BuiltinMacros.html](https://docs.unity3d.com/Manual/SL-BuiltinMacros.html).
  prefs: []
  type: TYPE_NORMAL
- en: By having this function, we can access the built-in data struct called `appdata_full`.
    This built-in struct is where the vertex information is stored. So, we then extract
    the vertex color information by passing it to our `Input struct` by adding the
    code, `o.vertColor = v.color`.
  prefs: []
  type: TYPE_NORMAL
- en: The `o` variable represents our `Input struct` and the v variable is our `appdata_full
    vertex` data. In this case, we are simply taking the color information from the
    `appdata_full` struct and putting it in our `Input struct`. Once the vertex color
    is in our Input struct, we can use it in our `surf()` function. In the case of
    this recipe, we simply apply the color to the o.Albedo parameter to the built-in
    `SurfaceOutput` struct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also access the fourth component from the `vert` color data. If you
    notice, the `vertColor` variable we declared in the `Input struct` is of the `float4`
    type. This means that we are also passing the alpha value of the vertex colors.
    Knowing this, you can use it to your advantage for the purpose of storing a fourth
    vertex color to perform effects such as transparency or giving yourself one more
    mask to blend two textures. It's really up to you and your production to determine
    if you really need to use the fourth component, but it is worth mentioning here.
  prefs: []
  type: TYPE_NORMAL
- en: Animating vertices in a Surface Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to access data on a per-vertex basis, let's expand our
    knowledge set to include other types of data and the position of a vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Using a vertex function, we can access the position of each vertex in a mesh.
    This allows us to actually modify each individual vertex while the shader does
    the processing.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a shader that will allow us to modify the positions
    of each vertex on a mesh with a sine wave. This technique can be used to create
    animations for objects such as flags or waves on an ocean.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s gather our assets together so that we can create the code for our Vertex
    Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and place a plane mesh in the center of the scene (GameObject | 3D
    Objects | Plane).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Plane` object created may seem to be a single quad but, in fact, has 121
    verts, which we are going to be moving. Using a quad would provide unexpected
    results. To check for yourself, select the `Plane` object and, under the Plane
    (Mesh Filter) component, double-click on the Mesh property.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader (`VertexAnimation`) and material (`VertexAnimationMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, assign the shader to the material and the material to the plane mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your scene should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our scene ready to go, let''s double-click on our newly created shader
    to open it in the code editor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with our shader and populate the `Properties` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to tell Unity that we are going to be using a vertex function by
    adding the following to the `#pragma` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access the values that have been given to us by our properties,
    we need to declare a corresponding variable in our `CGPROGRAM` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the vertex position modification as a `vert` color as well.
    This will allow us to tint our object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can perform our vertex modification using a sine wave and
    vertex function. Enter the following code after the `Input struct`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we complete our shader by performing a `lerp()` function between two
    colors so that we can tint the peaks and valleys of our new mesh, modified by
    our vertex function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After completing the code for your shader, switch back to Unity and let the
    shader compile. Once compiled, select the Material and assign the Base (RGB) Texture
    to the `UV Checker` material that is included in `Chapter 6 `| `Textures` folder
    of this book's example code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, assign Color A and Color B to different colors. After the changes, you
    should see something similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This particular shader uses the same concept from the last recipe, except that
    this time, we are modifying the positions of the vertices in the mesh. This is
    really useful if you don't want to rig up simple objects, such as a flag, and
    then animate them using a skeleton structure or hierarchy of transforms.
  prefs: []
  type: TYPE_NORMAL
- en: We simply create a sine wave value using the `sin()` function that is built
    into the Cg language. After calculating this value, we add it to the *y* value
    of each vertex position, creating a wave-like effect.
  prefs: []
  type: TYPE_NORMAL
- en: We also modified the normal on the mesh just to give it more realistic shading
    based on the sine wave value.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how easy it is to perform more complex vertex effects by utilizing
    the built-in vertex parameters that Surface Shaders give us.
  prefs: []
  type: TYPE_NORMAL
- en: Extruding your models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest problems in games is repetition. Creating new content is
    a time-consuming task, and when you have to face thousands of enemies, chances
    are that they will all look the same. A relatively cheap technique to add variation
    to your models is using a shader that alters its basic geometry. This recipe will
    show you a technique called **normal extrusion**, which can be used to create
    a chubbier or skinnier version of a model, as shown in the following screenshot
    of a soldier from the Unity camp demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For ease of use, I have provided a prefab of the solider in the example code
    for this book under the `Chapter 6 `| `Prefabs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, you need to have access to the shader used by the model that
    you want to alter. Once you have it, we duplicate it so that we can edit it safely.
    It can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the shader your model is using and, once selected, duplicate it by pressing
    *Ctrl *+ *D*. If it is just using the Standard Shader, as in this example, it
    is also possible to just create a new Standard Material such as normal, and the
    Albedo map will automatically transfer over. Either way, rename this new shader `NormalExtrusion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the original material of the model and assign the cloned shader to
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the new material to your model (`NormalExtrusionMat`) and start editing
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for this effect to work, your model should have **normals**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create this effect, start by modifying the duplicated shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a property to our shader, which will be used to modulate
    its extrusion. The range presented here goes from `-0.0001` to `0.0001`, but you
    might have to adjust this according to your own needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Couple the property with its respective variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `#pragma` directive so that it now uses a vertex modifier. You can
    do this by adding `vertex:function_name` at the end of it. In our case, we have
    called the `vert:` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following vertex modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The shader is now ready; you can use the Extrusion Amount slider in the material''s
    Inspector tab to make your model skinnier or chubbier. Also, feel free to create
    a clone of the material in order to have different extrusion amounts for each
    character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Surface Shaders work in two steps. In all the previous chapters, we only explored
    its last one: the surface function. There is another function that can be used:
    the vertex modifier. It takes the data structure of a vertex (which is usually
    called `appdata_full`) and applies a transformation to it. This gives us the freedom
    to do virtually anything with the geometry of our model. We signal to the GPU that
    such a function exists by adding `vertex:vert` to the `#pragma` directive of the
    Surface Shader. You can refer to [Chapter 7](part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08),
    *Fragment Shaders and Grab Passes*, to learn how vertex modifiers can be defined
    in a Vertex and Fragment Shader instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most simple yet effective techniques that can be used to alter the
    geometry of a model is called normal extrusion. It works by projecting a vertex
    along its normal direction. This is done by the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The position of a vertex is displaced by `_Amount` units toward the vertex normal.
    If `_Amount` gets too high, the results can be quite unpleasant. With smaller
    values, however, you can add a lot of variation to your models.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have multiple enemies and want each one to have its own weight, you
    have to create a different material for each one of them. This is necessary as
    materials are normally shared between models and changing one will change all
    of them. There are several ways in which you can do this; the quickest one is
    to create a script that automatically does it for you. The following script, once
    attached to an object with a `Renderer`, will duplicate its first material and
    set the `_Amount` property automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding extrusion maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This technique can actually be improved even further. We can add an extra texture
    (or use the alpha channel of the main one) to indicate the amount of extrusion.
    This allows for much better control over which parts are raised or lowered. The
    following code shows you how it is possible to achieve such an effect (the main
    difference from what we''ve done before is in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The red channel of `_ExtrusionTex` is used as a multiplying coefficient for
    normal extrusion. A value of `0.5` leaves the model unaffected; darker or lighter
    shades are used to extrude vertices inward or outward, respectively. You should
    note that in order to sample a texture within a vertex modifier, `tex2Dlod` should
    be used instead of `tex2D`.
  prefs: []
  type: TYPE_NORMAL
- en: In shaders, color channels go from zero to one, although sometimes you need
    to represent negative values as well (such as inward extrusion). When this is
    the case, treat `0.5` as zero; consider having smaller values as negative and
    higher values as positive. This is exactly what happens with normals, which are
    usually encoded in RGB textures. The `UnpackNormal()` function is used to map
    a value in the range (0,1) on the range (-1,+1). Mathematically speaking, this
    is equivalent to `tex.r * 2 -1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extrusion maps are perfect for zombifying characters by shrinking the skin
    to highlight the shape of the bones underneath. The following screenshot shows
    you how a healthy soldier can be transformed into a corpse using just a shader
    and extrusion map. Compared to the previous example, you may notice how the clothing
    is unaffected. The shader used in the following screenshot also darkens the extruded
    regions to give an even more emaciated look to the soldier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a snow shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simulation of snow has always been a challenge in games. The vast majority
    of games simply include snow directly in the model's texture so that their tops
    look white. However, what if one of these objects starts rotating? Snow is not
    just a lick of paint on a surface; it is a proper accumulation of material and
    should be treated as such. This recipe shows you how to give a snowy look to your
    models using just a shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'This effect is achieved in two steps. First, white is used for all the triangles
    facing the sky. Second, their vertices are extruded to simulate the effect of
    snow accumulation. You can see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that this recipe does not aim to create a photorealistic snow effect.
    It provides a good starting point, but it is up to the artist to create the right
    textures and find the right parameters to make it fit your game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This effect is purely based on shaders. We will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader for the snow effect (`SnowShader`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material for the shader (`SnowMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the newly created material to the object that you want to be snowy and
    assign a color so it''s easier to tell where the snow is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a snowy effect, open your shader and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the properties of the shader with the following ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Complete them with their relative variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `Input` structure with the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the surface function with the following one. It will color the snowy
    parts of the model white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the `#pragma` directive so that it uses vertex modifiers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following vertex modifiers, which extrude the vertices covered in snow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the material''s Inspector tab to select how much of your model
    is going to be covered and how thick the snow should be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shader works in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Coloring the surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering the geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring the surface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step alters the color of the triangles that are facing the sky. It
    affects all the triangles with a normal direction similar to `_SnowDirection`.
    As seen before in [Chapter 3](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08),
    *Understanding Lighting Models*, comparing unit vectors can be done using the
    **dot product**. When two vectors are orthogonal, their dot product is zero; it
    is one (or minus one) when they are parallel to each other. The `_Snow` property
    is used to decide how aligned they should be in order to be considered as facing
    the sky.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely at the surface function, you can see that we are not dotting
    the normal and snow direction directly. This is because they are usually defined
    in a different space. The snow direction is expressed in world coordinates, while
    the object normals are usually relative to the model itself. If we rotate the
    model, its normals will not change, which is not what we want. To fix this, we
    need to convert the normals from their object coordinates to world coordinates.
    This is done with the `WorldNormalVector()` function, as seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This shader simply colors the model white; a more advanced one should initialize
    the `SurfaceOutputStandard` structure with textures and parameters from a realistic
    snow material.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second effect of this shader alters the geometry to simulate the accumulation
    of snow. Firstly, we identify which triangles have been colored white by testing
    the same condition used in the surface function. This time, unfortunately, we
    cannot rely on `WorldNormalVector()` as the `SurfaceOutputStandard` structure
    is not yet initialized in the vertex modifier. We use this other method instead,
    which converts `_SnowDirection` to object coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can extrude the geometry to simulate the accumulation of snow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this is a very basic effect. You could use a texture map to control
    the accumulation of snow more precisely or give a peculiar, uneven look.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need high-quality snow effects and props for your game, you can also
    check these resources on the Unity Asset Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Winter Suite ($30)**: A much more sophisticated version of the snow shader
    presented in this recipe can be found at [https://www.assetstore.unity3d.com/en/#!/content/13927](https://www.assetstore.unity3d.com/en/#!/content/13927).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Winter Pack ($60)**: A very realistic set of props and materials for snowy
    environments can be found at [https://www.assetstore.unity3d.com/en/#!/content/13316](https://www.assetstore.unity3d.com/en/#!/content/13316).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a volumetric explosion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The art of game development is a clever trade-off between realism and efficiency.
    This is particularly true for explosions; they are at the heart of many games,
    yet the physics behind them is often beyond the computational power of modern
    machines. Explosions are, essentially, nothing more than very hot balls of gas;
    hence, the only way to correctly simulate them is by integrating a fluid simulation
    into your game. As you can imagine, this is unfeasible for a runtime application,
    and many games simulate them simply with particles. When an object explodes, it
    is common to simply instantiate fire, smoke, and debris particles so that, together,
    they can achieve believable results. This approach, unfortunately, is not very
    realistic and is easy to spot. There is an intermediate technique that can be
    used to achieve a much more realistic effect: volumetric explosions. The idea
    behind this concept is that explosions are not treated like a bunch of particles;
    they are evolving 3D objects, not just flat 2D textures.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Complete this recipe with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader for this effect (`VolumetricExplosion`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material to host the shader (`VolumetricExplosionMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the material to a sphere. You can create one directly from the editor,
    navigating to GameObject | 3D Object | Sphere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This recipe works well with the standard Unity Sphere, but if you need big explosions,
    you might need to use a high-poly sphere. In fact, a vertex function can only
    modify the vertices of a mesh. All the other points will be interpolated using
    the positions of the nearby vertices. Fewer vertices means a lower resolution
    for your explosions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, you will also need a ramp texture that has, in a gradient,
    all the colors your explosions will have. You can create a texture like the following
    screenshot using GIMP or Photoshop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can find this image (`explosionRamp`) in `Chapter 6 `| `Textures` folder
    in the example code provided with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the picture, import it to Unity. Then, from its Inspector, make
    sure that Filter Mode is set to Bilinear and the Wrap Mode to Clamp. These two
    settings make sure that the ramp texture is sampled smoothly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, you will need a noisy texture. You can search on the internet for freely
    available noise textures. The most commonly used ones are generated using Perlin
    noise. I have included an example in `Chapter 6 `| `Textures` folder for your
    use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This effect works in two steps: a vertex function to change the geometry, and
    a surface function to give it the right color. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the current properties and add the following properties to the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add their relative variables so that the Cg code of the shader can actually
    access them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `Input` structure so that it receives the UV data of the ramp texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following vertex function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following surface function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the vertex function in the `#pragma` directive, adding the `nolightmap`
    parameter to prevent Unity from adding realistic lighting to our explosion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is selecting the material and, from its Inspector, attaching
    the two textures in the relative slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is animated material, meaning that it evolves over time. You can watch
    the material changing in the editor by clicking on Animated Materials from the
    Scene window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are reading this recipe, you should already be familiar with how Surface
    Shaders and vertex modifiers work. The main idea behind this effect is to alter
    the geometry of the sphere in a seemingly chaotic way, exactly as it happens in
    a real explosion. The following screenshot shows you what such an explosion will
    look like inside the editor. You can see that the original mesh has been heavily
    deformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The vertex function is a variant of the technique called normal extrusion introduced
    in the *Extruding your models* recipe of this chapter. The difference here is
    that the amount of extrusion is determined both by the time and noise texture.
  prefs: []
  type: TYPE_NORMAL
- en: When you need a random number in Unity, you can rely on the `Random.Range()`
    function. There is no standard way to get random numbers in a shader, so the easiest
    way is to sample a noise texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no standard way to do this, so take this as an example only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `_Time[3]` variable is used to get the current time from within
    the shader, and the red channel of the `disp.r` noise texture is used to make
    sure that each vertex moves independently. The `sin()` function makes the vertices
    go up and down, simulating the chaotic behavior of an explosion. Then, the normal
    extrusion takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You should play with these numbers and variables until you find a pattern of
    movement that you are happy with.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the effect is achieved by the surface function. Here, the noise
    texture is used to sample a random color from the ramp texture. However, there
    are two more aspects that are worth noting. The first one is the introduction
    of `_RampOffset`. Its usage forces the explosion to sample colors from the left
    or right side of the texture. With positive values, the surface of the explosion
    tends to show more grey tones—exactly what happens when it is dissolving. You
    can use `_RampOffset` to determine how much fire or smoke there should be in your
    explosion. The second aspect introduced in the surface function is the usage of
    `clip()`. What `clip()` does is it clips (removes) pixels from the rendering pipeline.
    When invoked with a negative value, the current pixel is not drawn. This effect
    is controlled by `_ClipRange`, which determines which pixels of the volumetric
    explosions are going to be transparent.
  prefs: []
  type: TYPE_NORMAL
- en: By controlling both `_RampOffset` and `_ClipRange`, you have full control and
    can determine how the explosion behaves and dissolves.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shader presented in this recipe makes a sphere look like an explosion. If
    you really want to use it, you should couple it with some scripts in order to
    get the most out of it. The best thing to do is to create an explosion object
    and make it into a prefab so that you can reuse it every time you need to. You
    can do this by dragging the sphere back into the Project window. Once it is done,
    you can create as many explosions as you want using the `Instantiate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noticing, however, that all the objects with the same material
    share the same look. If you have multiple explosions at the same time, they should
    not use the same material. When you are instantiating a new explosion, you should
    also duplicate its material. You can do this easily with this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, if you are going to use this shader in a realistic way, you should attach
    a script to it that changes its size, `_RampOffset`, and `_ClipRange` according
    to the type of explosion that you want to recreate.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much more can be done to make explosions realistic. The approach presented in
    this recipe only creates an empty shell; inside it, the explosion is actually
    empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easy trick to improve this is to create particles inside it. However, you
    can only go so far with this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The short movie, *The Butterfly Effect* ([http://unity3d.com/pages/butterfly](http://unity3d.com/pages/butterfly)),
    created by Unity Technologies in collaboration with Passion Pictures and Nvidia,
    is the perfect example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is based on the same concept of altering the geometry of a sphere, but it
    renders it with a technique called **volume ray casting**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a nutshell, it renders the geometry as if it''s full. You can see an example
    in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you are looking for high-quality explosions, check out Pyro Technix ([https://www.assetstore.unity3d.com/en/#!/content/16925](https://www.assetstore.unity3d.com/en/#!/content/16925))
    in the Asset Store. It includes volumetric explosions and couples them with realistic
    shockwaves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
