<html><head></head><body>
<div id="_idContainer064">
<h1 class="chapter-number" id="_idParaDest-147"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-148"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.2.1">C4 and Other Approaches</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we provided an initial idea of the business goal of the sample information system (and application software modules) that we are going to build as a practical exercise to follow the principles outlined in this book. </span><span class="koboSpan" id="kobo.3.2">Talking about principles, while introducing the demo system, we also explained how the most important principles in object-oriented programming would apply to the design of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Now that the high-level principles have been set, it is time to go a level deeper in understanding our sample information system, and we will take advantage of this to show a few different methods professionals use. </span><span class="koboSpan" id="kobo.5.2">There exist many architectural methods and software representations, as we are going to see, and many overlap in lots of ways. </span><span class="koboSpan" id="kobo.5.3">In fact, some of them are so close that they really are a way for their author to mark their individual approach, rather than bringing some additional value to the architectural tools. </span><span class="koboSpan" id="kobo.5.4">This is the same situation with the JavaScript ecosystem, where there are way too many frameworks. </span><span class="koboSpan" id="kobo.5.5">Furthermore, it becomes even worse every day, with a new team thinking they can solve a problem by proposing yet another one. </span><span class="koboSpan" id="kobo.5.6">The same thing happens with architectural methods, and we have recently been overwhelmed with </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">clean architecture</span></strong><span class="koboSpan" id="kobo.7.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">hexagonal architecture</span></strong><span class="koboSpan" id="kobo.9.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">onion architecture</span></strong><span class="koboSpan" id="kobo.11.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">As the choice of one method over the other is really not important, we will only quickly show these methods so that you can choose which one adapts better to your way of thinking, or simply mix some interesting bits from many methods, as these are merely sets of long-known best practices assembled in a new package name. </span><span class="koboSpan" id="kobo.13.2">In the case of our sample information system, the </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">C4 approach</span></strong><span class="koboSpan" id="kobo.15.1"> sounded </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.16.1">interesting to provide a first approach on how it is designed, so this is the method that I will focus on to provide more details about. </span><span class="koboSpan" id="kobo.16.2">The idea behind the C4 architectural framework is to focus on IT systems from a context level to a container level, then a component level, and finally, a code level. </span><span class="koboSpan" id="kobo.16.3">The four levels will be explained as we apply them to our </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">sample system.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">Just like with </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">SOLID principles</span></strong><span class="koboSpan" id="kobo.20.1"> in the previous chapter, my goal here is not to explain these methods in depth, as there would be no value in writing what is already available in more detail on freely available and quality resources. </span><span class="koboSpan" id="kobo.20.2">My intention is to extract how these methods can be useful to reach a business/IT alignment or at least help represent the questions that are related to this </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">same subject.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we will learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">C4 approach</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Clean architecture</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Hexagonal architecture</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Onion architecture</span></span><a id="_idTextAnchor250"/></li>
</ul>
<h1 id="_idParaDest-149"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.29.1">The C4 approach</span></h1>
<p><span class="koboSpan" id="kobo.30.1">The C4 approach </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.31.1">is about designing a system (or an application) with four different levels of granularity, moving from the context level in which the application is placed, to the container level that will show the different processes composing the application, to the component layer showing the different parts composing the process, and finally, to the code level, where we will find the classes and interfaces used to create the application. </span><span class="koboSpan" id="kobo.31.2">Here is the diagram for </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">this approach:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.33.1"><img alt="Figure 7.1 – The levels in the C4 approach" src="image/B21293_07_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.34.1">Figure 7.1 – The levels in the C4 approach</span></p>
<p><span class="koboSpan" id="kobo.35.1">Each level details</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.36.1"> the content of the previous level and gives a more detailed view of the application. </span><span class="koboSpan" id="kobo.36.2">The fact that units of the lower level always have to be related to one given unit of the upper layer also helps to correctly share responsibilities and maintain a low level </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">of coupling.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">In the following sections, we will draw the four levels for our sample system and software modules to show the methods; at the same time, we will start designing our demo a bit further than the business requirements in the previous chapter allowed us to do. </span><span class="koboSpan" id="kobo.38.2">Note that the following diagrams will not necessarily be the exact ones that correspond to the system created at the end of the book; I really wanted to show the complete and realistic process of design, so I am drawing these at the same time as I design the sample application for the book. </span><span class="koboSpan" id="kobo.38.3">Drawing the schemas after I got a clear and complete view of the final result would – in my opinion – not be as pedagogical and, in some way, I would have felt </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">like cheating</span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.41.1">The context level</span></h2>
<p><span class="koboSpan" id="kobo.42.1">On the </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">context level</span></strong><span class="koboSpan" id="kobo.44.1">, our </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.45.1">system will be used by the three user profiles that were detailed before, namely the editors, the salespersons, and the director of DemoEditor. </span><span class="koboSpan" id="kobo.45.2">We will consider that the list of users is already present in the information system as an Active Directory or something equivalent. </span><span class="koboSpan" id="kobo.45.3">The same goes for a content management system, which will be considered to already exist for binary document management. </span><span class="koboSpan" id="kobo.45.4">Finally, we will consider that a module responsible for the emission of electronic mail is also available in the overall system. </span><span class="koboSpan" id="kobo.45.5">It is used to send emails to actors of the system, either to validate some data or to inform them of something. </span><span class="koboSpan" id="kobo.45.6">Of course, the authors will be represented in the context, even if they do not use the internal information system directly. </span><span class="koboSpan" id="kobo.45.7">Here is a diagram of the </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">context level:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.47.1"><img alt="Figure 7.2 – A context-level diagram" src="image/Figure_7.2_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.48.1">Figure 7.2 – A context-level diagram</span></p>
<p><span class="koboSpan" id="kobo.49.1">We could be</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.50.1"> more detailed on the content of the arrows, but for now, the diagram is self-explanatory, and the functions used by the different roles were explained in the previous chapter. </span><span class="koboSpan" id="kobo.50.2">Our most important center of interest in this diagram is the </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Demo Editor System</span></strong><span class="koboSpan" id="kobo.52.1"> box, and this is the one that we will detail in the next level of the </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">C4 architectur</span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.54.1">e.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.55.1">The container level</span></h2>
<p><span class="koboSpan" id="kobo.56.1">At the </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">container level</span></strong><span class="koboSpan" id="kobo.58.1">, we </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.59.1">show what the system uses in terms of building blocks. </span><span class="koboSpan" id="kobo.59.2">Most of the time, these blocks are separated processes. </span><span class="koboSpan" id="kobo.59.3">In our case, since we have decided to have completely independent services, we will have as many containers as API exposition servers. </span><span class="koboSpan" id="kobo.59.4">I anticipate a bit on the technical chapters of the book, but we will deploy the system as Docker containers, so there is a complete match between “containers” in the C4 architecture and “containers” in terms of the units of deployment used in Docker or other </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">such technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">In the following diagram, the boxes inside the dotted rectangle represent the details of the higher-level box corresponding to the Demo Editor system. </span><span class="koboSpan" id="kobo.61.2">We can still represent the other parts of the Context level, but it’s best practice not to detail them, as they are outside the scope of our study. </span><span class="koboSpan" id="kobo.61.3">We can detail the stream that goes to them (as we did for the </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">Users directory</span></strong><span class="koboSpan" id="kobo.63.1"> arrow, pointing from </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">Single Page Application</span></strong><span class="koboSpan" id="kobo.65.1">), but this is not mandatory, and we can also keep arrows that simply point from the system as a whole if we do</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.66.1"> not want to be precise about these streams of data yet (this is what has been done for the mail sender and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">CMS subsystems).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.68.1"><img alt="Figure 7.3 – The container level" src="image/Figure_7.3_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.69.1">Figure 7.3 – The container level</span></p>
<p><span class="koboSpan" id="kobo.70.1">By the way, at this level of reflection, we start considering what the content of the streams of data could be, and in this particular case, I realized that instead of a CMS, electronic document management could possibly be more appropriate. </span><span class="koboSpan" id="kobo.70.2">If we consider that this is an external system and not part of the one we are designing, we would, in reality, not have the ability to change it. </span><span class="koboSpan" id="kobo.70.3">However, since there is an interoperation with it, we might be able to influence the protocol used to communicate with it, and this is what our analysis is about. </span><span class="koboSpan" id="kobo.70.4">From a practical point of view, I do not know yet, at the time of writing (remember, I want to be as realistic as possible and I have not finished the exercise before writing the chapters), whether there will be an Alfresco container, an Azure Storage, or a SharePoint 365 site to implement this subsystem. </span><span class="koboSpan" id="kobo.70.5">All I know is that I will need to pass </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.71.1">binary documents and retrieve them, which means something such as </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Content Management Interoperability Services</span></strong><span class="koboSpan" id="kobo.73.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.74.1">CMIS</span></strong><span class="koboSpan" id="kobo.75.1">) streams will certainly be indicated (CMIS is an interoperability standard for </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">electronic documents).</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">For now, we have not </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.78.1">expressed what is inside each of the boxes. </span><span class="koboSpan" id="kobo.78.2">We only know that each of them will have its own life cycle as a software application and represent a process and a Docker container (a good practice is, indeed, to have one process per container only so that all things align well). </span><span class="koboSpan" id="kobo.78.3">If we go a bit into the development details, it would then be in the right alignment to have a continuous integration pipeline for each of these containers and, logically, a git repository for each of them as well. </span><span class="koboSpan" id="kobo.78.4">But I am anticipating the “hands-on” part of the book. </span><span class="koboSpan" id="kobo.78.5">For now, let’s dive deeper into one of the boxes, namely </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Books repository</span></strong><span class="koboSpan" id="kobo.80.1">, and show what it will be composed with, using the third level of the C4 approach, namely the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">component dia</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.82.1">gram.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.83.1">The component level</span></h2>
<p><span class="koboSpan" id="kobo.84.1">At the </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">component level</span></strong><span class="koboSpan" id="kobo.86.1">, we</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.87.1"> show the different modules and libraries that the executable container will use to accomplish its business requirements. </span><span class="koboSpan" id="kobo.87.2">As our books repository will expose two contract APIs, we will need a web server to support the controllers, a client to call the persistence system, maybe together with a repository pattern, a cache component to keep some data locally, and so on. </span><span class="koboSpan" id="kobo.87.3">This is what is drawn in the following diagram that corresponds to the third level in the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">C4 architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 7.4 – The component level" src="image/Figure_7.4_B21293_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 7.4 – The component level</span></p>
<p><span class="koboSpan" id="kobo.91.1">A component may correspond to different names of artifacts, depending on the platform that is going to be used. </span><span class="koboSpan" id="kobo.91.2">In .NET, components may be assemblies, while in Java, they will be JAR archives. </span><span class="koboSpan" id="kobo.91.3">Anyhow, this decomposition in components exists in basically all programming </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.92.1">platforms, even if it appears in different forms. </span><span class="koboSpan" id="kobo.92.2">For example, in some platforms, components will correspond to separate files, while in others, they will be more abstract, through the use of namespaces, for example. </span><span class="koboSpan" id="kobo.92.3">In any case, there will be ways to group code-level content into coherent groups, while still with a lower granularity than the higher level of containers, which correspond to entire processes made with </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">several compo</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.94.1">nents.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.95.1">The code level</span></h2>
<p><span class="koboSpan" id="kobo.96.1">As the </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.97.1">reference documentation of the C4 method (available at </span><a href="https://c4model.com/"><span class="koboSpan" id="kobo.98.1">https://c4model.com/</span></a><span class="koboSpan" id="kobo.99.1">) states, it is important to use diagrams only if they add value. </span><span class="koboSpan" id="kobo.99.2">This is something I also stressed when </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.100.1">presenting the </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">CIGREF method</span></strong><span class="koboSpan" id="kobo.102.1"> to map the information systems. </span><span class="koboSpan" id="kobo.102.2">It is a common reflex for beginners in diagramming to try and map everything in the system as if it were the goal in itself to have a map. </span><span class="koboSpan" id="kobo.102.3">The goal is to go somewhere, and the map is just a tool to make it easier. </span><span class="koboSpan" id="kobo.102.4">It is of utmost importance to understand this and to only map what is useful. </span><span class="koboSpan" id="kobo.102.5">This is why I will jump on this opportunity to demonstrate this and not draw anything at the code level; at this point of the application design, I don’t have a clear idea yet of how the classes will be organized. </span><span class="koboSpan" id="kobo.102.6">I am sure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">IDbRepository</span></strong><span class="koboSpan" id="kobo.104.1"> pattern will be used and maybe a </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">UnitOfWork</span></strong><span class="koboSpan" id="kobo.106.1"> pattern, but the class organization is not clear yet, so there is no use in trying to draw the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">diagram yet.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Also, even if it was for pedagogical reasons, drawing such a diagram would not bring much value, since the fourth level of the C4 approach is simply</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.109.1"> the same as a class diagram from </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">UML</span></strong><span class="koboSpan" id="kobo.111.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Unified Modeling Language</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">We will use these detailed diagrams if we need to in the following chapters, once we progress into the actual making of the system. </span><span class="koboSpan" id="kobo.113.3">In the meantime, we are done with the C4 method used to explain the sample system we want to create, and we will now briefly discuss the alternative software architectural design methods, using them to better express our context </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">under </span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.115.1">analysis.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.116.1">Clean architecture, hexagonal architecture, and other frameworks</span></h1>
<p><span class="koboSpan" id="kobo.117.1">What comes next </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.118.1">may be a surprise for you in the context of software architecture – the choice of an architecture method does not matter much, as long as you have </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.119.1">a method (or several methods used together, by the way, if you maintain control of their interactions and know when to choose one over another). </span><span class="koboSpan" id="kobo.119.2">Of course, that does not mean you do not need to apply some method when designing the architecture of an information system. </span><span class="koboSpan" id="kobo.119.3">My point of view after many years of experience in the field is that you should find and apply </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.120.1">your</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Also, if you try many different existing methods such as hexagonal architecture, clean architecture, onion architecture, and other domain-centric approaches, you will quickly realize that they offer little more than a different visual approach to the same basic principles, which are highly related to the business/IT alignment we discussed at the beginning of this book and the principles that have been extracted from the SOLID approach, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.124.1">The business model (</span><em class="italic"><span class="koboSpan" id="kobo.125.1">data structures representing functional concepts</span></em><span class="koboSpan" id="kobo.126.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.127.1">business rules translated into code</span></em><span class="koboSpan" id="kobo.128.1">) should be at the core of the architecture. </span><span class="koboSpan" id="kobo.128.2">This way, it does not depend on anything, which allows easy changes, fast automated testing, a lack of external versioning constraints, and lots of other advantages. </span><span class="koboSpan" id="kobo.128.3">Most importantly, it enables the concentration of the team on the most important thing – </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">business alignment.</span></span></li>
<li><span class="koboSpan" id="kobo.130.1">Everything surrounding this business-aligned core should use some kind of indirection to introduce low-coupling and make the evolution of any module of the system easier. </span><span class="koboSpan" id="kobo.130.2">Everything depends on the business core module, which itself depends on nothing else. </span><span class="koboSpan" id="kobo.130.3">In addition, these dependencies are easy to modify </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">if</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.132.1"> necessary.</span></span></li>
</ul>
<h2 id="_idParaDest-155"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.133.1">Technical architecture patterns</span></h2>
<p><span class="koboSpan" id="kobo.134.1">One last thing </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.135.1">before we dive into the details of the methods – here, I will only discuss the architectural methods that can apply to the design of an entire information system. </span><span class="koboSpan" id="kobo.135.2">There are lots of methods that deal with the technical architecture of a single application, how it should be structured, how its source code and information flow should be organized, what technical layers should be present, and even, in some cases, recommendations on how to </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">name things.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">For example, the </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">N-tier architectures</span></strong><span class="koboSpan" id="kobo.139.1"> (also called </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">layer-based</span></strong><span class="koboSpan" id="kobo.141.1">) will describe how each set of source</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.142.1"> code should call another set, from the GUI to the service to the application to the database. </span><span class="koboSpan" id="kobo.142.2">MVC, MVP, and MVVM architectures are slightly less linear and describe how each group of source code would talk to only some of them, to ease the evolution and maintenance of the application (with generally an emphasis on their </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">visual part).</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">These architectures can, theoretically, be used at the level of the entire information system, but that does not mean much more than applying them to all applications that constitute the information system, since they do not say much about how the applications should work together. </span><span class="koboSpan" id="kobo.144.2">N-tier architecture recommends that software blocks should talk to each other using the application layer, but since it does not enforce it, lots of old applications interop at the database level, which is a catastrophic coupling in most cases and certainly one of the major reasons why a vast majority of legacy systems are nowadays unable to evolve. </span><span class="koboSpan" id="kobo.144.3">MVC is supposed to be applicable at a higher level than just the visual interface, but despite this, it does not reach the level of the entire information system. </span><span class="koboSpan" id="kobo.144.4">It may be just a question of semantics, but I personally tend to classify these methods as patterns rather than architectures, since they come from experience rather than pure reflection (and there is absolutely no value judgment in this – we need both experimental and intellectual approaches to </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">be complete).</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Since this book is about the architecture of a whole information system, I have focused on the purpose of architectural methods that naturally are applicable at such levels. </span><span class="koboSpan" id="kobo.146.2">It happens that domain-centric methods typically respond to this because they convey the very notion of a business domain, which has to be the very first (and unique) way to decompose an information system if you want to get a result that is aligned with a business. </span><span class="koboSpan" id="kobo.146.3">All technical approaches can work on the software and hardware layers, but what we need is methods that work at the business capability </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">map level.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.148.1">Onion architecture</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.149.1">Onion architecture</span></strong><span class="koboSpan" id="kobo.150.1"> pictures</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.151.1"> a software unit as several concentric circles containing, right at the center, the business </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">domain model</span></strong><span class="koboSpan" id="kobo.153.1">! </span><span class="koboSpan" id="kobo.153.2">And around it, you will find services (persistence, etc.) and then presentation (a GUI, external interfaces, </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">tests, etc.):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.155.1"><img alt="Figure 7.5 – Onion architecture" src="image/Figure_7.5_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Figure 7.5 – Onion architecture</span></p>
<p><span class="koboSpan" id="kobo.157.1">One of the main rules in onion architecture is that all dependencies should go from the outer side to the inner layers. </span><span class="koboSpan" id="kobo.157.2">This way, again, the core business model does not depend on anything, which makes it easy to evolve, while outer circles can be changed provided that they do not impact the business (which is generally much easier than the reverse – imagine basing your entire business model on a proprietary relational database procedures language and trying to change to another </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">database engine).</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">While this method does not insist on levels of indirection, the principle of dependency inversion (see the previous chapter for an explanation), together with the rule just cited, makes it obvious that interfaces are necessary to implement functions such as persistence. </span><span class="koboSpan" id="kobo.159.2">And the same goes, of course, for one</span><a id="_idTextAnchor265"/> <span class="No-Break"><span class="koboSpan" id="kobo.160.1">layer above.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.161.1">Hexagonal architecture</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.162.1">Hexagonal architecture</span></strong><span class="koboSpan" id="kobo.163.1"> represents </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.164.1">a software unit in a hexagonal shape, hence its name, with the left part of the hexagon containing interfaces consuming the inside (such as a GUI or automated tests), the right part containing adapters to functional dependencies (such as persistence, notification service, etc.), and right in the middle of it, as you may have guessed, the core, containing the business entities and </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">business rules!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.166.1"><img alt="Figure 7.6 – Hexagonal architecture" src="image/Figure_7.6_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Figure 7.6 – Hexagonal architecture</span></p>
<p><span class="koboSpan" id="kobo.168.1">Hexagonal architecture insists on ports and adapters to organize the communication between the different parts of the application, but this is also a rule in the onion architecture even if it is not displayed in the same way. </span><span class="koboSpan" id="kobo.168.2">This helps us remember that interfaces and contracts should always be applied for the dependencies not to evolve into hard coupling, which makes it difficult to evolve </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">As far as the “</span><em class="italic"><span class="koboSpan" id="kobo.171.1">hexagonal</span></em><span class="koboSpan" id="kobo.172.1">” shape goes, it is pure clutter! </span><span class="koboSpan" id="kobo.172.2">I intended to draw three “clients” of the business domain to stress the point that there is absolutely no relationship between the name of the method and a given technical constraint or a particular advantage of the technique. </span><span class="koboSpan" id="kobo.172.3">In fact, it is explained in the method that the hexagonal shape is simply used to preserve enough space to display shapes around the central one. </span><span class="koboSpan" id="kobo.172.4">How would this be different from circles (used by the other approaches cited previously), ovals, or squares? </span><span class="koboSpan" id="kobo.172.5">If the hexagonal shape does not bring anything conceptually enriching, my personal opinion is that it should not be declared in the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the method.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">This may sound like</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.175.1"> a useless rant against methods, but this is only to make it clear that their value really lies in what they have in common and not their differences. </span><span class="koboSpan" id="kobo.175.2">What really matters is the centrality of the core domain, aligned to the business, and the control of the dependencies, but all of this is already there in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">SOL</span><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.177.1">ID principles.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.178.1">Clean architecture</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.179.1">Clean architecture</span></strong><span class="koboSpan" id="kobo.180.1"> involves </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.181.1">basically joining the two approaches presented previously while proposing some additional rules. </span><span class="koboSpan" id="kobo.181.2">Graphically, it appears very similar to the onion architecture, in concentric circles with the business entities in the middle, and several layers organized around in the core, evolving to the outside in the same direction as </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">dependencies apply.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">In this method, you will find almost everything that has already been explained previously in the two other methods, including the fact that the domain model must be clean of any technical dependencies, to address its utmost importance in the system and to bring all kinds of other benefits such </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">as testability.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Inversion of dependency is also recommended, as the separation of concerns. </span><span class="koboSpan" id="kobo.185.2">The vocabulary slightly differs, but a quick search on the internet will show lots of blog articles about the extreme similarities between the three architectures. </span><span class="koboSpan" id="kobo.185.3">Clean architecture may be a bit more “guiding” than the others, but it is impossible – at the time of writing – to find a documented analysis proving one better, or even widely different in results, than </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">My personal opinion is that these three approaches (onion, hexagonal, and clean architecture) are so close to each other in the way they work and in their recommendations that you can use one or another without making any real difference in the quality of the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">architecture produced.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">What will bring quality is the profound understanding of why these methods exist and, in particular, the capacity to create modules that are cleanly separated and where you keep control of the dependencies. </span><span class="koboSpan" id="kobo.189.2">Cutting concerns and responsibilities without strict rules on their relationship will end up in a </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">spaghetti-like system.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">Conversely, following strict principles where the business domain (the most important part) does not have any dependencies and where everything technical is interfaced around it, with an indirection layer in between, is what really matters. </span><span class="koboSpan" id="kobo.191.2">And all three approaches have this in common. </span><span class="koboSpan" id="kobo.191.3">The rest is pure details, and if you consider, for example, that the</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.192.1"> hexagonal shape does not bring anything to the method, as explained previously, the existence of several methods really gives the impression that some of them are there just because their author wanted to have t</span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.193.1">heir </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">own method.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.195.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.196.1">The C4 approach was used in this chapter to detail our demo application from four points of view, namely the context in which it is used, the containers it uses, and the components and code that it is made of. </span><span class="koboSpan" id="kobo.196.2">Diagrams following this approach have helped us explain what the sample information system we will create is about. </span><span class="koboSpan" id="kobo.196.3">We also learned that it is not necessary to create a diagram that completely covers the domain of study, but only for the bits these diagrams </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">have value.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Also, lots of architectural methods have emerged in the past decades. </span><span class="koboSpan" id="kobo.198.2">Although they clearly have value in the design of software applications, and thus in information systems, they resemble very much each other in the sense that most recent methods are domain-centric; as such, their value can basically be summarized by the two principles that we already know, SOLID and business alignment principles, namely putting the business functions model first and applying a method to reduce the coupling to dependencies. </span><span class="koboSpan" id="kobo.198.3">Both of these make the evolution of a system easier. </span><span class="koboSpan" id="kobo.198.4">I do not have any doubt that these methods may have additional value for software organization, and they certainly help you to take a step further than purely technically oriented architecture patterns. </span><span class="koboSpan" id="kobo.198.5">However, as far as entire systems are concerned, the C4 approach explored at the beginning of the chapter should – in my opinion – be applied first in a top-down approach, leaving the domain-centric approaches as a way of organizing the third level (the components) of the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">C4 method.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">In </span><a href="B21293_08.xhtml#_idTextAnchor271"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.201.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.202.1">, we will start defining more precisely the API on which our demonstration system will be based, as these entities are definitely the most important technical aspects if you want a freely evolving application. </span><span class="koboSpan" id="kobo.202.2">In the upcoming chapter, we will start by explaining the concept of service orientation and its relation to APIs. </span><span class="koboSpan" id="kobo.202.3">In </span><a href="B21293_09.xhtml#_idTextAnchor318"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.203.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.204.1">, we will use a semantics-based approach to define the business domains of our sample application and translate them into actual API contracts. </span><span class="koboSpan" id="kobo.204.2">We have talked a lot about business domains – in the next two chapters, they will be defined, as well as their interactions, for our </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">demonstration system.</span></span></p>
</div>
</body></html>