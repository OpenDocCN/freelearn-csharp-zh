- en: Developing the Let's Chat Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we got the requirements and high level design of the
    Let''s Chat web application. We got started with the Let''s Chat web application
    by setting up project. We learned about the fundamental concepts of ASP.NET Core
    in the process. In this chapter, we will develop the Let''s Chat web application
    and learn about a few more concepts of ASP.NET Core. We will cover the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0 fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication through Facebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0 fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a continuation of our journey of learning ASP.NET Core 2.0 fundamentals
    that we started in the previous chapter. We will (re)visit the fundamentals, so
    that we can use them correctly while coding the app. In this section, we will
    take a quick lap around MVC and we will further discuss routing, filters, error
    handling, and so on. Let's start with MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Quick lap around MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MVC** stands for **Model**-**View**-**Controller**. The intent of this pattern
    is to achieve separation of concerns. In general terms, we can draw an analogy
    of MVC with "***Division of labour**"*. In this architectural pattern, the application
    is divided into three distinct components: the Model, the View, and the Controller.
    When a user requests a resource in the server, it is routed to a Controller which
    works with the Model to perform user actions and/or CRUD (**Create**, **Read**,
    **Update**, **Delete**) operations. The Controller then chooses the View to display
    the user interface to the user, and provides it with the required Model data.
    The following diagram displays the three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6550793-3861-4a57-bb96-ce5695c89cd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that in the diagram, both the View and the Controller depend on the
    Model. However, the Model depends on neither of them. This is one of the key benefits
    of the pattern and also the golden rule for correct implementation of MVC. Using
    this separation, we can build and test the Model independently of the visual presentation.
    The **S** of the **SOLID** design principle, **single responsibility principle**
    (**SRP**), is at the heart of MVC. It also reiterates the **don''t repeat yourself**
    (**DRY**) principle. MVC is all about the separation of concerns to have better
    test-ability and maintainability. The responsibility of each of the components
    is clearly laid out:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model** is the central component of this architectural pattern and represents
    the data. It maintains the data of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View** is the visual component and is the user interface for the model; that
    is, it displays the data of the model to the end user and also enables them to
    edit the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller** is the controller of the request; that is, the request handler.
    Typically, users interact with the View for displaying, editing, adding, and deleting
    the data. This raises a corresponding URL request. This request is handled by
    a Controller. The Controller renders the appropriate View with the Model data
    as a response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1a244219-e9fb-4ed4-be81-87f1db484713.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram sums up the general working of the MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a request, which is routed to a **CONTROLLER**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CONTROLLER** uses the **MODEL** to perform some *business* operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **MODEL** returns the result of the operations back to the **CONTROLLER**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CONTROLLER** decides which **VIEW** is to be rendered and sends it the
    model (data) that must be rendered
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **VIEW** renders the output and sends the response back to the client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see an analogy of MVC in the real world, so that the new users of MVC
    find it link-able. Let''s think about a magazine. If I were to *loosely* fit a
    magazine cover in the MVC pattern, it would be as follows: the user sees the magazine.
    What we see as the cover of the magazine is the **View** (user interface). We
    see some text and an image; for example, a fashion model or a sports star in the
    View. This is the **Model** (data), and the photographer/editor would be the **Controller**
    as they have manipulated the data and displayed it in the cover. This hopefully
    demonstrates the gist of MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of trivia questions. When was MVC invented? The answer roughly would
    be 1979 (December 10). Who invented it? A Smalltalk programmer, named Trygve Reenskaug
    (read about him at: [https://en.wikipedia.org/wiki/Trygve_Reenskaug](https://en.wikipedia.org/wiki/Trygve_Reenskaug)),
    who maintains a web page to explain the history of MVC in his own words at: [http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html).
    It''s worth a read!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have discussed MVC as an architectural pattern. Since we are learning
    ASP.NET Core, let''s talk about the ASP.NET Core MVC framework. The ASP.NET Core
    MVC is a lightweight, open source, and highly testable presentation framework,
    that has been tailor-made for use with ASP.NET Core. It gives full control over
    the generated HTML markup and follows the latest web standards. To use it is pretty
    simple as well. We just need to add MVC in a services container, by writing `AddMVC`
    in the `ConfigureServices` method of `Startup.cs`, and then configure the pipeline
    to start using it by writing `UseMVC`, as shown in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`UseMvc` has two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseMvc()`: This works only with attribute-based routes, which we will visit
    in a while.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseMvc(Action<IRouteBuilder> configureRoutes)`: This works with both conventional
    and attribute- based routes. It has a `callback` method to configure the routes.
    We have used this overload in the preceding sample.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be seen from the documentation of the API, which defines the `UseMvc`
    extension methods. The code can be seen at GitHub at: [https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs](https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs).[](https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: There is one more extension method, `UseMvcWithDefaultRoute`, which can be used
    to configure MVC to work with a default route named `default` and `template` as
    `'{controller=Home}/{action=Index}/{id?}'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using any of the preceding extension methods to use MVC middleware, we can
    start leveraging the goodness of ASP.NET Core MVC. Recall that by doing so, we
    are entering the last middleware/section of the request pipeline, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3e9e282-a282-4411-95e7-87434e492097.png)'
  prefs: []
  type: TYPE_IMG
- en: We saw this diagram in the previous chapter as well. However, the clarification
    of this section, other middleware in the pipeline blurred out to indicate we are
    focusing on MVC middleware. Let's have a look at this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The middleware resides in the `Microsoft.AspNetCore.Builder` namespace in the
    `Microsoft.AspNetCore.Mvc.Core` assembly. Let''s look at the code map diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd3c9f8-028b-4b7d-a684-49ccb07e4861.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, there is so much that we can''t even see the association and
    inheritance relationships between the different components. Don''t worry about
    this complexity; it''s already baked in the framework and we just need to learn
    and use things of interest. ASP.NET Core MVC is rich in features and includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core MVC is a powerful URL-mapping software component as it stands on
    top of ASP.NET Core routing. As a result, we can build apps that have easily understandable
    and searchable URLs. This way, we can define our app's URL naming patterns that
    work well for **search engine optimization** (**SEO**) and link generation, without
    having to worry about how the files are physically organized in the server. In
    the ASP.NET Core MVC framework, routing is defined in the `Microsoft.AspNetCore.Mvc.Routing`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code map diagram for routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/459bbd68-f5a2-4208-8134-ae8d20685d16.png)'
  prefs: []
  type: TYPE_IMG
- en: We see `HttpMethodAtribute`, which has the properties `Name`, `Template`, `HttpMethods,`and
    `Order` apart from the constructor. We see `UrlHelperFactory`, `UrlHelper`, `RouteValueAttribute`,
    and `KnownRouteValueConstraint` with their properties, constructors, and methods.
    Routing is the mechanism through which incoming requests are mapped to controllers
    and actions, that is, the controller and action can be deduced from the request
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the request URL as `http://localhost:9596/packt/Books/Index`.
  prefs: []
  type: TYPE_NORMAL
- en: This maps to the books controller and index action. This mapping of controller
    and action from the request URL is the job of routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already discussed that MVC is itself injected as a middleware in the request
    pipeline. The routing middleware makes use of routing templates to do the mapping.
    An example of a simple routing template is shown in the following code: `packt/{controller=Home}/{action=Index}/{id?}`.
    Routing templates use literals and tokens. Literals are matched exactly to the
    text in URL, whereas tokens are replaced when matching a route. Tokens are enclosed
    in `{}`. In the preceding example, we have three tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller token:** `{controller=Home}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action token:** `{action=Index}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID token:** `{id?}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And `packt` is the literal which would be matched with the requested URL.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a template requires a controller token and action token, as this is
    the key information routing middleware needs to locate the controller and action.
    Other tokens in the URL are mapped to the parameters of action methods using model
    binding, which we will see later. When adding a route mapping, default values
    can be provided for tokens. In the preceding example, `Home` is the default value
    of the controller token and `Index` is the value of the action token. Templates
    can also provide optional tokens for action parameters, such as `{id?}`. `?`,
    which here indicates that it is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose a client requests the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL would match the preceding template and would invoke the `Index` action
    with the `id` value as `2` on the `Books` controller. So, the code of `BooksController`
    would be roughly like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following client requests would also be served:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:9596/packt/Books/Index`: The `id` parameter is optional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:9596/packt/Books`: The default value of the `Index` would
    be used for the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:9596/packt`: The default value of the `Home` would be used
    for the controller and the `Index` for the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were all happy path scenarios, but what if the URL is `http://localhost:9596/packt/Books/Index/.NETCore2.0ByExample?`
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the controller would resolve to `BooksController`, and the action
    would resolve to `Index`. However, the last parameter is defined as `int`, which
    is not what we want. To ensure that `id` is always an integer for the mapping,
    we can use route constraint, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that the route maps to action only if `id` is specified as an
    optional `int`; otherwise, the URL would not map to this route. There are lots
    of constraints that can be used, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:guid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:length(min,max)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comprehensive list of constraints can be seen in Microsoft route constraint
    reference at: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference).[](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference)
  prefs: []
  type: TYPE_NORMAL
- en: The URL strings are case-insensitive, so `packt` and `Packt` are treated the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code map diagram of `RouterMiddleware` and the extensions
    to use for this middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18685ea8-8c87-4c17-ba3d-66ed2b10e534.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we know about routing middleware and how the routing template works,
    let''s look at the types of routing. Broadly speaking, there are the following
    types of routing:'
  prefs: []
  type: TYPE_NORMAL
- en: Convention-based routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed routing; that is, a combination of the preceding two types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convention-based routing** enables us to define the URL formats, which are
    understood by the application. Convention-based routing also lets us define how
    each of the URL formats maps to a specific action method on a controller. Once
    a request is received, the routing engine parses the URL and matches it to one
    of the defined URL formats. Based on the url format, the controller and action
    method is mapped and invoked by the routing engine. The code example that can
    be used in the `UseMvc` method that takes the `routeBuilder` action as a parameter
    in the `Configure` method of Startup.cs is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method adds a route named `"default"`. We can specify multiple
    named routes and templates, and these would be executed in the order in which
    they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MapRoute` method has several overloads. These can be seen in the following
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Attribute routing** can be used to describe routing information by decorating
    the attributes on the controller and actions. This means that the route definitions
    of the controller are placed adjacent to the controller and action tokens with
    which they''re associated. This is done by using the `Route` attribute, which
    contains the route of the `controller`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use any of the `Http` verbs, such as `HttpGet`, `HttpPut`, `HttpPost`,
    `HttpDelete`, and so on, to specify the attribute-based routes. The following
    code snippet illustrates the route specified for the `Index` action. Also note
    that we have multiple `HttpGet` attributes applied to the action, showing that
    multiple routes can map to a single action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These `HttpGet` attributes with routes are referring to the following URL path.
    For example, if we are passing a blank inside `HttpGet`, it is taking us to the `http://localhost:9596/packt/Books`
    path and if we are passing `HttpGet("index")`, it will refer until the index page:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[HttpGet("index")]` matches `http://localhost:9596/packt/Books/index`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpGet("")]` matches `http://localhost:9596/packt/Books`; that is, the default
    `action` of `controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpGet("~/")]` matches `http://localhost:9596/packt/Books`; that is, the
    default `action` of `controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we can have multiple routes, ordering can be applied to the route attributes
    to execute a general route or specific route as needed. The framework would look
    at the `Order` property and execute the routes in ascending order. The default
    `Order` of `0` would execute, followed by the route that is immediately higher
    than it, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mixed routing** is a perfectly valid scenario as based on the requirements;
    we may have convention-based routing in some controllers and actions and attribute
    routing for others. However, we cannot have both for the same action. If an action
    uses attribute routing, no convention-based routes can map to that action. Placing
    a route attribute on the controller or the action makes it attribute routed. Actions
    that define attribute routes cannot be reached through the conventional routes
    and vice-versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Next in the pipeline, after the request is routed, it maps to a controller action.
    We will close our discussion on routing here. The next hop on the request pipeline
    diagram is the authorization filter. We will skip it for now and discuss it when
    we discuss filters later in the chapter. Let's discuss model binding now, which
    comes into the picture after the authorization filter.
  prefs: []
  type: TYPE_NORMAL
- en: The request may be a `PUT`, `POST`, `DELETE`, or `GET` operation and, based
    on the operation it is meant to handle, the action may have parameters, which
    need to be populated by the framework from the client request data. The component
    that does this conversion is called the model binder. Let's have a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Model binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed, model binding maps the data from HTTP requests to action method
    parameters. These parameters, like any other C# method, can be simple types, such
    as `int`, `long`, `decimal`, `string`, or the complex classes. ASP.NET Core MVC
    has abstracted this logic away from the developers so that they need not worry
    about this request data to parameter conversion. This conversion is done by the
    framework in a predefined order. Let''s look at how the framework does this. The
    following is the code map diagram of the model binding subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57145395-eb03-4383-b1bc-91726772f010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Important things to notice in the diagram are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParameterBinder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueProvider` factories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The framework tries to bind the request data to the action parameters by name.
    To do so, it looks at the values for each parameter using the parameter name and
    the names of its public settable properties. In the preceding `GetBook` request
    URL example, the only action parameter was named `id`, which the framework binds
    to the value with the same name in the route values. The ASP.NET Core MVC framework uses
    three primary value providers or data sources to map HTTP request data to action
    parameters, in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Form values** **(using** `FormValueProvider`**)**: The values in the form
    that came in the HTTP request body. These would generally be in `HttpPost` or
    `HttpPut`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Route values (using** `RouteValueProvider`**)**: The values provided by the
    routing subsystem, which executes just before model binding is used'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Query string (using** `QueryStringValueProvider`**)**: The values found in
    the request URL query string are used'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the preceding data is stored in name value pairs in corresponding dictionaries.
    If, after performing this exercise, the model binding fails for some reason, it
    does not throw an exception; it just sets the `IsValid` property of `ModelState`
    to `false`. It's up to the action method to handle such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the default model binding, the framework also provides a customized
    way to accomplish model binding by using attributes that we noted in the preceding
    code map diagram. We can use these attributes to alter the binding behavior of
    the property of a complex object, which is used as an action parameter, or to
    the parameter itself directly. Let''s look at these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[BindNever]`: This tells the model binder to ignore this parameter from binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[BindRequired]`: This attribute adds a model state error if the binding fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromBody]`: This tells the model binder to bind the data from the request
    body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromForm]`: This tells the model binder that the value should be fetched
    through the form data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromHeader]`: This tells the model binder that value should be fetched through
    a header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromQuery]`: This tells the model binder that the value should be fetched
    through a query string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromRoute]`: This tells the model binder that the value should be fetched
    through the route data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromServices]`: This tells the model binder that dependency injection should
    be used to bind the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ModelBinder]`: This attribute is used to override the default model binder,
    binding the source and name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next hop of the request is validation, so let's have a look at validation.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Validation is one of the key operations for any app working with data. Before
    we persist the data to the persistent store (database/filesystem), we should ensure
    the sanctity of the data, its format, type, size, and check if it complies to
    our rules and doesn''t pose any potential security threat. This is ensured through
    validation. This can be done at both the client and server side. I am a firm believer
    that validation should be performed at both the client and server side. The validation
    has been abstracted from the developers into validation attributes, which reduces
    the amount of code needed to perform the validation. Validation attributes are
    C# attributes that derive from `ValidationAttribute`. Most of the commonly used
    validation attributes can be found in the `System.ComponentModel.DataAnnotations`
    namespace. In case the already provided attribute does not suffice our needs,
    we can do either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new custom validation attribute that derives from `ValidationAttribute`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the interface `IValidatableObject` in our model class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code map diagram illustrates both the `ValidationAttribute` as
    well as the `IValidatableObject` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b24d3896-f861-4c5c-96cb-ee1ac49a9333.png)'
  prefs: []
  type: TYPE_IMG
- en: '`IValidatableObject` is a simple interface with just the`Validate` method,
    while `ValidationAttribute` has a lot more to offer for customization and has
    `IsValid`, `Validate`, and `GetValidationResult` methods along with properties
    to meet the validation needs. We also see that there are numerous attributes already
    defined and derived from `ValidationAttribute`. Some of the most important ones
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UrlAttribute`: Validates that the property has a valid URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhoneAttribute`: Validates that the property has a telephone format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileExtensionsAttribute`: Validates that the file extensions are valid as
    per the predefined set of file extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailAddressAttribute`: Validates that the property has a valid email format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreditCardAttribute`: Validates that the property has a credit card format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataTypeAttribute`: Validates that the property has a valid data type, as
    specified by passing the `DataType` enumeration value. The `DataType` enumeration
    value can be seen at the top part of the preceding image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeAttribute`: Validates that the property value falls within the specified
    range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularExpressionAttribute`: Validates that the property value matches the
    given regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequiredAttribute`: Makes a property mandatory and hence the user would always
    have to provide its value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompareAttribute`: Validates two properties in a model match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringLengthAttribute`: Validates that the string property value length does
    not exceed the maximum length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applying only validation attributes to the model properties is not sufficient
    to perform the validation; we should ensure that on the server side in our action
    method, we also perform the `ModelState.IsValid` check to ensure that the input
    data validation passed or failed and act accordingly for pass and failed cases.
    The ASP.NET MVC Core framework sets the `ModelState` dictionary with errors after
    it performs the model binding from the HTTP request; if the validation does not
    pass, `ModelState.IsValid` would be false even if there is one validation error.
    This happens before the action execution starts, so we have the validation result
    available as soon as we enter the action method code. The framework, by default,
    continues validating properties until it reaches a maximum count of `200`. This
    number is configurable though by writing the following code in the `ConfigureServices`
    method of the `Startup.cs` method, which sets the maximum count to `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In case we wish to perform some validations after the model binding and validations
    are completed, we can do so by manually invoking the validation using: `TryValidateModel(<<model
    to validate>>)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this time, what we saw was the server-side validation, which involves a
    round trip to the server and hence takes time, so to do an additional validation
    in the client side makes sense so that if the validation fails, we do not even
    send the request to the server. We will have a quick discussion about client-side
    validation when we look at the Views, later in the chapter. Now that we have the
    concept and theory in mind, let''s do a quick implementation of the validation.
    Suppose we want to validate the book information, such as name, author, description,
    publisher, pages, release date, price, and so on, before saving the book information
    to the database. To do so, let''s create a model and controller. The model would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the controller would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are two paths in the `SaveBookInfo` method. If `ModelState.IsValid` is
    true, the data is valid and the data can be saved to the persistent storage; otherwise,
    we return to the same `View`. Generally, the `View` would have a validation summary
    that would display the validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! It is this easy to implement server-side validation. This concludes
    our discussion on validation. Let's move on to filters.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filters in ASP.NET Core MVC are the places where we can run the code before
    or after the action execution in the request processing pipeline. Filters run
    within the MVC action invocation pipeline, also known as **filter pipeline**.
    This pipeline comes into View after the framework chooses the action to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list view code map diagram illustrates the actors involved in
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7710e46c-b1fc-406b-9794-93343b071a91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the right, we have attributes defined, which are abstract classes. On the
    left, there are abstractions and context classes. The filters execute at different
    stages in the action execution pipeline, based on the type of filter, which can
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization filters**: These are the implementation of `IAuthorizationFilter`/`IAsyncAuthorizationFilter`
    and are run first to determine if the current user is authorized or not. They
    can short circuit the pipeline if the user in unauthorized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource filters**: These are the implementation of `IResourceFilter`/`IAsyncResourceFilter`
    and are run immediately after the authorization filters. When these filters execute,
    model binding has not taken place in the pipeline so they can be used to alter
    the model binding. The most common use of these filters is that of caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action filters**: These filters are the implementation of `IActionFilter` / `IAsyncActionFilter`
    or `ActionFilterAttribute` and are run immediately before and after an action
    execution. Due to their location in the pipeline, they are well-suited for any
    manipulation to action method parameters as well as to returned results from the
    action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception filters**: These filters are the implementation of `IExceptionFilter`
    / `IAsyncExceptionFilter` or `ExceptionFilterAttribute` and are used to apply
    exception handling to the code before the response is written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result filters**: These are the implementation of `IResultFilter` / `IAsyncResultFilter`
    or `ResultFilterAttribute` and are run immediately before and after the execution
    of individual action results. They are run only if the action method successfully
    executes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we look closely, we can notice that there are multiple ways to implement
    the filter. There is filter interface, then there is async filter interface, and
    we have abstract attribute classes that we can implement. The framework first
    checks if the filter implements an async interface. If it does, it calls the async
    methods of the filter. If not, it calls the non-async methods, so either an async
    or synchronous interface should be implemented. If we implement both, only the
    async implementation would be called. This is also the case when we implement
    the abstract class. To summarize, the following is what the filter pipeline looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/070d624a-8144-444e-b977-1debf8274afb.png)'
  prefs: []
  type: TYPE_IMG
- en: We should write our custom filters based on the preceding flow, so that the
    desired operation code can be written at the right place in the filter pipeline.
    Next, we will see an implementation of the sample filter and different ways to
    implement a filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derive from `Attribute` and implement `IActionFilter`—filters are implemented
    as attributes and hence we need to derive from `Attribute` and implement `IActionFilter`
    for the class to be treated as a filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Derive from `ActionFilterAttribute`—the `ActionFilterAttribute` class already
    derives from the `Attribute` class and implements `IActionFilter` and hence we
    can directly derive from `ActionFilterAttribute` and create a filter attribute.
    So, the preceding code would remain the same apart from the base class and interface
    with which we need to derive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are few other ways to define the action filters, but we will not discuss
    them here. They can be seen from the reference link shared towards the end of
    the section. Likewise, Exception filters can be created by deriving from `ExceptionFilterAttribute`,
    `ResultFilter` by deriving from `ResultFilterAttribute`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For consuming the filters, they can be registered globally in the `ConfigureServices`
    method in the `Startup.cs` or by decorating the filter attribute in the controller
    or action, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the filters can be registered both globally and at action level also,
    a definite question comes to mind, which is: in what order do they execute? The
    answer is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: The action executing method of global filters runs first, then of action executing
    methods of filters registered at controller runs, and finally action executing
    methods of filters registered at action level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While returning from action, the order is the other way round. The action executed
    method of filter registered at action level runs first, then action executed method
    of filter registered at controller level, and finally the action executed method
    of filter registered globally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is also referred to as Nesting Doll or Russian Doll model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the default behaviour. ASP.NET Core provides a way to override the default
    order of execution by implementing `IOrderedFilter`, which exposes an `Order`
    property, specifying which can override the default order of execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a detailed and thorough discussion on filters, please read the documentation
    of filter at: [https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this note, we will move on to our next topic: Controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Broadly speaking, a controller is a class with a group of methods called actions.
    An action, also known as an action method, is a method that handles the request.
    As per the convention used by the ASP.NET Core MVC framework, a controller is
    a class that:'
  prefs: []
  type: TYPE_NORMAL
- en: Is instantiable; that is, an instance of that class can be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resides in the project's root-level folder, named `Controllers`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherits from an abstract class, `Microsoft.AspNetCore.Mvc.Controller`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The framework is flexible and would also treat an instantiable class as a controller
    if any one or more of the following holds good:'
  prefs: []
  type: TYPE_NORMAL
- en: The class is decorated with the `[Controller]` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name is suffixed with `Controller`, such as `HomeController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class derives from a class, whose name ends with `Controller`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important thing to note here is that we have a controller defined, even
    if we do not derive our controller from the `Controller` class. As discussed earlier,
    the role of a controller is to validate the request data and return the result
    in the form of a View or data. In the ASP.NET Core MVC project structure, we can
    see a `Controllers` folder at the project root level, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1351f77d-3710-4989-ad96-98ae345c4d60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the code map diagram of the `Controller` class to understand
    it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23bfd90e-9b99-4e1c-8433-d7b3d455d99e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The diagram reveals that the `Controller` class itself derives from the `ControllerBase`
    class, by which it gets access to `HttpContext` and `ControllerContext` properties.
    It has properties for `TempData`, `ViewData`, and `ViewBag`, which we will discuss
    when we discuss the Views in the next chapter. The class contains a bunch of methods,
    mostly for returning action results and executing action filters. Let''s have
    a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PartialView`: Creates a `Microsoft.AspNetCore.Mvc.PartialViewResult` object
    that renders a partial View to the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View`: Creates a `Microsoft.AspNetCore.Mvc.ViewResult` object that renders
    a View to the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Json`: Creates a `Microsoft.AspNetCore.Mvc.JsonResult` object that serializes
    the data to JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewComponent`: Creates a `Microsoft.AspNetCore.Mvc.ViewComponentResult` by
    specifying the name of a View component to render'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActionExecuting`: Called before the action method is invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActionExecuted`: Called after the action method is invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActionExecutionAsync`: Called before the action method is invoked in an
    async implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all methods defined in the `Controller` class are actions. Only `public`
    methods which are not decorated with the `[NonAction]` attribute are actions.
    An action method can return anything, but generally, we will see them return an
    instance of `IActionResult` (or `Task<IActionResult>` for `async` methods). An
    action method decides the kind of response it would return; it may be a View or
    formatted response data, such as JSON, or anything else.
  prefs: []
  type: TYPE_NORMAL
- en: With the intent of separation of concerns and loose coupling, the `Controller`
    class should always have the dependencies injected to it, rather than creating
    the instance of it. If a type or service is required for only one action method,
    we can use the injection of a service directly in the action by using the `[FromServices]`
    attribute that we saw earlier; otherwise, the construction injection should be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: We will end our lap around MVC with an overview of error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is a particularly important piece in any reliable and stable
    software application, and ASP.NET Core applications are no different. The error
    handling strategy differs while the app is under development and when it is deployed.
    While developing, the developer wants to see highly detailed error messages so
    that he/she can go to the crux of the issue and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: However, such a level of detailing would not be great in production as the end
    user would not understand any of that and it would give hackers too much information,
    which they could utilize to compromise your app. Also, the end user would rather
    appreciate a user-friendly message than some stack trace, which would be Greek
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: So, we display a developer exception page in the development environment and
    a more user-friendly error screen in the production environment. The old school
    ASP.NET programmers may be able to link this to the custom errors flag in the
    ancient versions of ASP.NET. Let's see how we can configure these pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure an app to display an error page to display the detailed exception,
    we need to have the `Microsoft.AspNetCore.Diagnostics` namespace. We need to add
    the following code in our `Configure` method of `Startup.cs`. Notice that this
    should be added before adding any other middleware, so that all the exceptions
    from the subsequently executed middleware are caught:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of an exception in the development environment, the developer exception
    page would be displayed, as shown in the following screenshot. I used the classical
    and easiest code to simulate the exception here—`divide by zero`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c58bfc06-3678-4b93-992f-3bc29c8a79b3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that it has four tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stack: Displays the stack trace of the error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Query: Displays the query string of the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cookies: Displays the cookies associated with a request, if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Headers: Displays the header of the request, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0d46657e-c83a-44bb-9b13-d0b64c59e32a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a non-development environment, we will see a generic error page, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8afb44-70f1-431a-98be-b1c8693d1359.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please note, an error in an error page can also throw an exception, which, if
    not properly handled, can crash your app. So, we should try and keep the error
    page content static.
  prefs: []
  type: TYPE_NORMAL
- en: If any exceptions occur during the app startup, they can only be handled in
    the hosting layer. When the error occurs after the host address / port binding,
    hosting can only show an error page for such captured startup errors. If any port/address
    binding fails for any reason, such as the address/port is already in use, the
    hosting layer logs a critical exception, the dotnet process crashes, and no error
    page is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: MVC error handling continues to work as it does, by using exception filters
    for exceptions and Model validations for validation failures. We have already
    seen these in our quick lap around MVC. We have one more important component of
    MVC, the visual element, Views, to discuss. We will discuss this when we do the
    implementation of our chat UI and Chat hub in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our quick lap around MVC. With all the fundamentals in place,
    we are now ready to dive into coding. We will begin by implementing authentication
    in our application, which we will do in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication through Facebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enough of the theory and samples. Time for us to convert the requirements into
    reality. We will start with the authentication module first. Recall that based
    on our discussion in the last chapter, this module needs to support a secure login,
    a forgotten password, as well as register user functionality. Once we are done
    with it, we will have completed a substantial part of our app, as per the following
    flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1bb9f70-958e-48a4-8d49-ac00b2986611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to leverage Facebook authentication to implement this module of
    our system. We could have used any of the other providers as well, such as Twitter,
    Google, Microsoft, and so on, but since it''s a fun chat app, Facebook is most
    appropriate. In [Chapter 7](ch07.html), *To the Cloud*, we will see how we can
    support multiple authentication providers and let the user decide which provider
    they wish to use for authentication. To code this module, we will perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate Facebook with our app, we first need to create a Facebook App
    ID. So, go to [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)
    and click on Add a New App button. Please note, this requires us to sign in to
    our Facebook account, so you need to have a Facebook account to do this activity.
    If you don''t have a Facebook account, please create one. On clicking the button,
    the following screen will display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5797887-6ce3-4378-9f47-cd93290de721.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter Display Name and Contact Email, and click on the Create App ID button.
    It will display a **Completely Automated Public Turing Test to tell Computers
    and Humans A****part** (**CAPTCHA**) verification page. On successful verification,
    the App ID will get created and a products page will be displayed, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94a8758d-0f66-4af1-b495-ce8420df401d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to choose Facebook Login, so click on the Setup button, which will
    display when we hover over Facebook Login. On clicking Setup, Facebook will display
    a select platform page, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/32ddd279-1c18-4a19-b3d6-6fde3fad3225.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose Web and then enter the website URL in the next screen. This is the URL
    of your web app. Once we run our app using Visual Studio or `dotnet run`, we can
    see the URL (or we will directly see `launchSettings.json` or project properties).
    Copy the URL and paste it in the Site URL field, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e84a9ec-d148-4705-907d-5c90748a1590.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Save button. Now, click on the Facebook Login on the left navigation
    panel in the PRODUCTS section and make the following selections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47716981-1afa-46c3-b5dd-5f725ed1763f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'OAuth redirect URIs should be correct; otherwise, the flow will not work. There
    is no point in putting the lock on the door and keeping the key alongside, similarly,
    there is no point in using authentication and using an HTTP protocol for OAuth.
    The URI should be using an HTTPS protocol. This is a demo app, so I have used
    the HTTP protocol. However, for any non-demo app, we should always use HTTPS.
    We can provide multiple URLs in the OAuth redirect URIs, so once we publish the
    app to Azure, we would need to add one more URL here. With this, our Facebook
    app is set up. We need an App ID and App Secret, which we will copy by navigating
    to the Dashboard of the app we just created. This can be done by clicking on the
    Dashboard in the left-hand side navigation. Copy the App ID and App Secret in
    a notepad for our use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd67a454-4d6b-4556-ad14-06feff1934cd.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with the app setup in Facebook. We will come back to
    the portal again when we make our app public and publish it to Azure. For now,
    we will start coding. As discussed earlier, we will make use of middleware to
    perform authentication. The pattern to use middleware is also very simple. First,
    add the middleware in the `ConfigureServices` method and then use it in the `Configure`
    method of `Startup.cs`. The framework takes care of most of the heavy lifting,
    so the coding part is quite simple as well, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Facebook and cookie authentication. To use them, we add the following
    using directives in `Startup.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the App ID and App Secret to integrate Facebook authentication
    with our web app. To do so, we need to read the values of the App ID and App Secret.
    This can be done through reading from the `appsettings.json` or from the User
    Secret Manager tool in development. Essentially, these secrets should be kept
    way from the application code and real apps deployed on Azure should be fetched
    from the Azure Key-vault. We will use the User Secret Manager tool as well as
    Key-vault in [Chapter 7](ch07.html), *To the Cloud*. For the sake of simplicity,
    in this demo, we will make use of `asppsettings.json` to read these values (though
    its not recommended for actual systems), as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ConfigureServices` method of `Startup.cs`, we will write the following
    lines of code to add the authentication middleware and read the App ID and App
    Secret from configuration, by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The comments make it very clear that we would challenge the user through Facebook
    and sign in using cookie authentication. We have configured Facebook to use the
    App ID and App Secret from the `appsettings` and also added cookie authentication.
    Also, to keep the application secure, it''s highly recommended that we always
    enforce SSL; that is, use HTTPS. We can do so with the following line of code,
    while adding MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Configure` method of `Startup.cs`, write the following code between
    `app.UseStaticFiles` and `app.UseMvc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This ordering is important and will ensure that static resources, such as `js`,
    `css`, and `image` files, will not have to go through authentication. They would
    be served without authentication, while before any other page access request or
    authentication can kick in. If we run the app now, the authentication would still
    not kick in. We need to decorate the controller/controller action(s) with the `[Authorize]`
    attribute, which we only want the authenticated user to access. We can also configure
    this at the global level. We saw the sample for this in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will decorate the `Index` action of `HomeController` with the `[Authorize]`
    attribute, so that we can challenge the user if he/she is not logged in, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the app and we have followed all the steps correctly so far,
    we will see the Facebook login page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/941efabe-d5a8-4496-95d9-01bd8da0e2ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will also ask for permission to use the user profile, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/548325e0-2d3b-4a35-8756-75389b3231ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Continue as `<your name>` and we will be navigated to the `Index` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not a scaleable model to put `[Authorize]` on every controller as it
    is susceptible to mistakes. New developers adding a new controller may forget
    to do so and it may not be caught unless someone browses the URL for that controller,
    so it is recommended that we configure authentication in the `ConfigureServices`
    method of `Startup.cs`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After applying this policy, wherever we need non-authenticated access, we can
    insert the `[AllowAnonymous]` attribute. This is safer from a security perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a working login, with the option to register a user as well the
    provision to reset the password, if the user forgot it, without doing any custom
    coding. We can safely rely on Facebook to take care of this stuff. We will wrap
    up this module by seeing how we can do an explicit sign in and sign out, so that
    if we wish to sign out or sign in explicitly by clicking on a link or button,
    we can handle it. To do so, we will add a new controller called `AuthenticationController`
    with two actions, `SignIn` and `SignOut`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is simple but an explanation is important, as we have used a lot of
    things here:'
  prefs: []
  type: TYPE_NORMAL
- en: We have used attribute routing at the controller level, by using the `[Route("authentication")]`
    attribute. This may seem unnecessary as its name is the same as that of the controller,
    but the intent is to demonstrate how the `Route` attribute is used at a controller
    level. Had we used `[Route("auth")]`, all requests to `/auth/` would redirect
    to this controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we see that the `AuthenticationController` derives from the `Controller`
    class. This is mandatory when we create any controller; it should derive from
    the `Controller` class. We can have it derive from some other class, say `BaseController`,
    but then `BaseController` should derive from the `Controller` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we see we have a field of type `ILogger<AuthenticationController>` called
    `logger`, which would be used to do the logging with the `AuthenticationController`
    as the category.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have the constructor for the `AuthenticationController`. This takes
    in a dependency of `ILogger<AuthenticationController>`, which is injected by default
    by the framework. This demonstrates DI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an action created with the name `SignIn`. Note that it also uses attribute
    routing, as it's decorated with `[Route("signin")]`. The return type of this action
    is `IActionResult`. As is evident, the first line of action is for logging the
    information. The important thing in this action is that its returns a `ChallengeResult`,
    taking in the `AuthenticationProperties` as the parameter. It's important to set
    the `RedirectUri` as it is responsible for redirecting the page to the appropriate
    page after authentication. `ChallengeResult` would use the configured challenge
    scheme, Facebook, in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last action is `SignOut`. Again, it uses attributebased routing. It would
    be served when a `POST` request comes as it is decorated with the `[HttpPost]`
    attribute. We also note the `async` keyword to demonstrate that we can have `async`
    controller actions. It uses the `SignOutAsync` method of `HttpContext` and signs
    out using the cookie authentication scheme. Post sign out, it redirects the user
    to the `Index` action of the `Home` controller. If the `Index` action of the `Home`
    controller has the `[Authorize]` attribute applied, it may take the user to the
    login screen and if cookies are not cleared from the browser, you may have the
    user logged back in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the View, we will do the following. If the user is not signed in, show him
    the `Sign In` button, or show him the `Sign Out` button. This can be done easily
    in the `_Layout.cshtml` by the writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By doing this in `_Layout.cshtml`, we ensure this functionality is common across
    all the pages. The `@prefix` on Razor tells the RazorEngine that it is C# code.
    We first check if the user is authenticated; if yes, `User.Identity.IsAuthenticated`
    would be `true`. Inside this condition, we display the `Sign Out` button inside
    a `form` tag. The `form` tag is important, as we are doing a submit action on
    the `Sign Out` button, so on clicking it, the form would be posted to the server.
    This call should never ever be `HttpGet`. The `form` tag uses the `post` method
    and uses tag helpers to specify the controller and action as `Authentication`
    and `SignOut`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP method definitions ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html))
    recommend the usage of `HttpPost` methods over `HttpGet` methods for security
    reasons ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)),
    when the data is being submitted to the server, as per the following excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: If your of services use the HTTP protocol, then you **SHOULD NOT** use `GET`-based
    forms for the submission of sensitive data. Otherwise, this will cause the data
    to be encoded in the Request-URI. The request URI will be logged somewhere by
    existing servers, proxies, and user agents, and it might be accessible to third
    parties. Servers can use `POST`-based form submission instead.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our authentication module, and we are ready to develop the SignalR
    Chat hub module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we brushed up on the fundamentals of MVC and looked at the
    features of ASP.NET Core MVC. Post learning the fundamentals, we developed the
    authentication module for our Let's Chat app using Facebook. We checked that we
    can log in, sign out, register a new user, as well as reset the password, using
    the work already done by Facebook, with minimal lines of code in our ASP.NET Core
    2.0 app. In the next chapter, we will develop the SignalR Chat hub module and
    complete the Let's Chat web app. We will also learn about unit testing and deployment
    for the ASP.NET Core 2.0 app.
  prefs: []
  type: TYPE_NORMAL
