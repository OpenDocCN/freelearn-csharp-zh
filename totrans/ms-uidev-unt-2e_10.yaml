- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Event System and Programming for UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of the Unity UI system is the ability to easily program
    how the UI elements receive interactions from the player via events. The **Event
    System** is a robust system that allows you to create and manage events.
  prefs: []
  type: TYPE_NORMAL
- en: Once you learn how to take advantage of the Event System, you will be able to
    create interactable UI as well as UI that responds to events in your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to access UI elements and their properties via code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the Event System is and how to work with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to customize input axes with the Input Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What an Input Module is, and which ones are provided by Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Event Trigger component to receive events on UI objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Raycasters are and what types of Raycasters are provided by Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to show and hide pop-up Panels using keyboard inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to pause the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a drag and drop inventory system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use mouse or multi-touch input to pan and zoom the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing UI elements in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the UI elements can be accessed and manipulated in code like other GameObjects.
    To access a UI element in code, you must include the `UnityEngine.UI` namespace
    and the correct variable type. Let’s look at the `UnityEngine.UI` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: UnityEngine.UI namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `using` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all new C# scripts include the `System.Collections`, `System.Collections.Generic`
    and `UnityEngine` namespaces. To access the properties of UI elements via code,
    you must first use the `UnityEngine.UI` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, at the top of your C# script, you will need to include the following
    line to signify that you want to use the `UnityEngine.UI` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Without using the namespace, any variable type related to UI elements will be
    colored red in your code editor, and you will be given a compiler error. Once
    you include the namespace, the variable type will change to the blue-colored text,
    signifying that it is an available variable type, and the compiler error will
    disappear.
  prefs: []
  type: TYPE_NORMAL
- en: UI variable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each variable type is a class within the `UnityEngine.UI` namespace. Therefore,
    each of these variable types, in turn, has its own set of variables and functions
    that can be accessed. We’ll discuss each variable type more thoroughly in future
    sections and chapters, but for now, let’s just look at the standard template for
    accessing a property of a UI element in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find within the source files a Unity package named `Chapter 08``.unitypackage`.
    Importing it will bring in a scene named `Chapter8.unity` and various code files.
    Import the items from the package and open the scene. In the `Chapter8` scene,
    you will see a UI Image named `UI Variables Example`. It does not have a sprite
    assigned to it and appears as a white square. The following script, `AddSprite.cs`,
    is attached to the UI Image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The UI-specific pieces of code are highlighted in the preceding code. Note that
    the `UnityEngine.UI` namespace is included at the top of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two public variables defined in the class: `theImage`, which is an
    `Image` type, and `theSprite`, which is a `Sprite` type. The `theImage` variable
    is referencing the UI Image in the scene and the `theSprite` variable is referencing
    the sprite that will become the source image of the UI Image.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Image` variable type is within the `UnityEngine.UI` namespace and represents
    UI Image GameObject. The `Sprite` variable type is not a UI element and is included
    in the `UnityEngine` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Start()` function, the properties of the `Image` component on `theImage`
    are referenced by typing a period and then the property after the variable name.
    You can access any property that appears in a UI element’s corresponding component
    in this way. You can also access properties that are not listed in the component
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddSprite` script attached to `UI Variables Example (Image)` appears in
    the inspector, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The AddSprite script and its properties](img/B18327_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The AddSprite script and its properties'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the scene is played, the sprite will change from a blank white square
    to an image of a banana with its aspect ratio preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the Event System, which will allow us to interact with our UI.
  prefs: []
  type: TYPE_NORMAL
- en: The Event System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), we learned that when the
    first Canvas is added to a scene, a GameObject named `EventSystem` is automatically
    added to the Hierarchy. The Event System allows you to easily receive player interactions
    and send those interactions to objects in your scene through events. Note that
    I said, *objects in your scene* and not *UI objects*. The Event System allows
    you to send events to non-UI items, too!
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, I’d like to note my use of `EventSystem` (one word) and Event
    System (two words), because I will be switching back and forth between the two.
    I want you to know that I am doing it deliberately and am not just randomly deciding
    that sometimes I hate the spacebar.
  prefs: []
  type: TYPE_NORMAL
- en: I will use `EventSystem` (one word) to reference the actual GameObject that
    appears in the Hierarchy of your scene and Event System (two words) to reference
    the system that handles events.
  prefs: []
  type: TYPE_NORMAL
- en: The Event System does quite a few things for you other than just sending events
    to objects. It also keeps track of the currently selected GameObject, the Input
    Modules, and Raycasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The EventSystem GameObject initializes, by default, with three components:
    the **Transform**, **Event System** Manager, and **Standalone Input Module**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: The EventSystem GameObject and its components](img/B18327_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The EventSystem GameObject and its components'
  prefs: []
  type: TYPE_NORMAL
- en: Since `EventSystem` is a GameObject, it physically exists within the scene (even
    though it has no renderable component making it visible) and therefore has a **Transform**
    component like all other GameObjects. You should be familiar with the **Transform**
    component by now, so we won’t discuss it further. However, the other two components
    do merit further discussion. Let’s look at the **Event System** component more
    closely now. We’ll also discuss the **Standalone Input Module** component in the
    *Input Modules* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot have more than that one `EventSystem` GameObject in your scene. If
    you try to add a new one in the scene via **+** | **UI** | **Event System**, a
    new one will not be added, and the one currently in the scene will be selected
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you manage to add a second **EventSystem** to your scene (by perhaps using
    *Ctrl* + *D* to duplicate the existing one), you will see a warning message on
    your **Console**.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than one **EventSystem** GameObject in your scene, only the
    first one added will actually do anything. Any additional **EventSystems** will
    be non-functional.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the **Event System** Manager next.
  prefs: []
  type: TYPE_NORMAL
- en: Event System Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Event System** Manager is the component that actually does all the tracking
    and managing of the various **Event** **System** elements.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to work with the `EventSystem` GameObject will not be automatically
    created for you. You can add an **Event System** Manager to a GameObject by selecting
    **Add Component** | **Event** | **Event System** on the object’s Inspector. Let’s
    talk about the properties under the **Event** **System** Manager.
  prefs: []
  type: TYPE_NORMAL
- en: First Selected
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You know when you start up a game and the **Start Game** button is highlighted
    for you so that hitting *Enter* will start the game without you having to use
    your mouse? That’s what the **First Selected** property does for you. It selects
    a UI element in the scene for you automatically when it starts up.
  prefs: []
  type: TYPE_NORMAL
- en: You can drag and drop any intractable UI element into this slot to make it the
    first selected UI item in your scene. This is particularly helpful for games that
    do not use a mouse or touchscreen but rely solely on a gamepad, joystick, or keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Send Navigation Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Send Navigation Events** property can be toggled on and off. When this
    property is enabled, you can navigate between UI elements via a gamepad, joystick,
    or keyboard. The following navigation events can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Move**: You can select the various UI elements via arrow keys on the keyboard
    or the control stick on a gamepad (or whichever keys/buttons you have designated
    as the movement keys). Movement will start at the UI item designated **First Selected**.
    We will discuss how to specify the order in which UI items are selected using
    movement in [*Chapter 10*](B18327_10.xhtml#_idTextAnchor236).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Submit**: Commit to the UI item selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel**: Cancel the selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag Threshold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Drag Threshold** property represents the number of pixels a UI object
    can be moved before it is considered being *dragged*. People don’t have perfectly
    steady hands, so when they are trying to click or tap a UI item, their mouse or
    finger may move slightly. This **Drag Threshold** allows the player to move their
    input slightly (or a lot if you make this number high) before the item they are
    selecting is *dragged* rather than *clicked*.
  prefs: []
  type: TYPE_NORMAL
- en: Input Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss the next component of the **Event System** Manager, I want
    to discuss the Input Manager. The Input Manager is where you define the axes in
    your game by assigning them to the buttons on your mouse, keyboard, or joystick
    (gamepad). This also allows you to use the axis name when coding to easily reference
    all inputs that you want to perform in an action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, as we discussed in [*Chapter 5*](B18327_05.xhtml#_idTextAnchor072),
    there are actually two systems that will allow you to handle input in your game:
    the Input Manager and the new Input System. This chapter will focus on the Input
    Manager. We will discuss the new Input System in a future chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: To open the **Input Manager**, select **Edit** | **Project Settings** | **Input
    Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the arrow next to **Axes**, you will see the default list of
    axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: The Input Manager and all its pre-defined axes](img/B18327_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: The Input Manager and all its pre-defined axes'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 30 total axes by default. Changing the number next to **Size** will
    give you more or less axes. Expanding the individual axes will reveal the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: The first Horizontal input axis](img/B18327_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The first Horizontal input axis'
  prefs: []
  type: TYPE_NORMAL
- en: The word entered in the **Name** slot is what will appear next to the expandable
    arrow. In the preceding screenshot, all the keys that allow for horizontal movement
    have been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the left and right arrows, along with the *A* and *D* keys of a keyboard,
    are defaulted to the **Horizontal** movement.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a second **Horizontal** axis further down the list. It is configured
    to work with a joystick or a gamepad.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The second Horizontal input axis](img/B18327_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The second Horizontal input axis'
  prefs: []
  type: TYPE_NORMAL
- en: As there are two `"``Horizontal"` label.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To view a list of the keywords for each keyboard key as well as a description
    for each of the properties of an axis input, visit [https://docs.unity3d.com/Manual/class-InputManager.xhtml](https://docs.unity3d.com/Manual/class-InputManager.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: This will allow you to reference all these buttons and joysticks together as
    a group. This is much simpler than having to write code that gets each of the
    individual keyboard keys along the individual joysticks.
  prefs: []
  type: TYPE_NORMAL
- en: You can delete any of these 30 default axes you want by right-clicking on them
    and selecting **Delete** **Array Element**.
  prefs: []
  type: TYPE_NORMAL
- en: However, be careful when you delete them. You need at least one **Submit** axis
    and one **Cancel** axis to be able to use the **Standalone Input Manager** (unless
    you change the **Submit Button** and **Cancel Button** in the **Standalone Input
    Manager**). For more information, refer to the *Standalone Input Manager* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the Input Manager, we can review the various input
    functions for buttons and key presses.
  prefs: []
  type: TYPE_NORMAL
- en: Input functions for buttons and key presses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are quite a few ways to access key and button presses via code. How you
    do this depends on whether you have the key specified as an axis in the **Input
    Manager** and whether you want the key to register once or continuously. I’ll
    discuss a few in this text, but you can find a full list of the functions at [https://docs.unity3d.com/ScriptReference/Input.xhtml](https://docs.unity3d.com/ScriptReference/Input.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: A script named `KeyPresses.cs` is attached to the `Main Camera` in the `Chapter8`
    example scene we were reviewing earlier in this chapter. The `KeyPresses.cs` script
    contains all the code demonstrated in this section if you’d like to play around
    with key presses.
  prefs: []
  type: TYPE_NORMAL
- en: GetButton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a button defined as an axis in the `GetButton()`, `GetButtonDown()`,
    and `GetButtonUp()` to determine when a button has been pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetButton()` returns `true` while the button is being held, `GetButtonDown()`
    returns `true` only once, on the frame that the button is initially pressed, and
    `GetButtonUp()` returns `true` only once, on the frame that the button is released.'
  prefs: []
  type: TYPE_NORMAL
- en: Within each of the functions, you place the axis name from the `Update()` function
    of a script so that they can be triggered at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if you wanted to check whether the *Enter* key is being pressed,
    since it is assigned to a **Positive Button** for the **Submit** axis, you can
    write the following code to trigger when the *Enter* key is pressed down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this will not just trigger with the *Enter* key, as the **Submit**
    axis has a few keys assigned to the **Positive Button** and **Alt** **Positive
    Button**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that if you play the **Chapter8** scene and want to watch
    these button and key presses fire the console log messages, you must first click
    within the **Game View** so that the inputs will register in the game.
  prefs: []
  type: TYPE_NORMAL
- en: GetAxis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re looking for a function that will trigger continuously without any
    breaks between firing, you want to use `GetAxis()` rather than `GetButton()`.
    `GetButton()` is good for buttons you want to hold down but want a slight pause
    between events firing (think of holding down a fire button, and the gun shoots
    bullets with breaks in between them). `GetAxis()` works better for events involving
    movement because of this continuous frame-rate independent execution.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetAxis()` works a bit differently, as it returns a `float` value rather than
    a `bool`, such as `GetButton()`. It is also best suited within an `Update()` function.
    So, for example, you can check whether the horizontal movement is occurring as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: GetKey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to get a keyboard key press that is not assigned to an axis, you
    can use `GetKey()`, `GetKeyDown()`, or `GetKeyUp()` to reference keyboard keys
    via their `KeyCode`.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetKey()` functions work pretty similar to the `GetButton()` functions.
    `GetKey()` returns `true` while the key is being held down; `GetKeyDown()` returns
    `true` only once, on the frame that the key is initially pressed; and `GetKeyUp()`
    returns `true` only once, on the frame that the key is released.
  prefs: []
  type: TYPE_NORMAL
- en: Each key has its own `KeyCode` that needs to be referenced in the parentheses
    of the `GetKey()` functions. You can find a list of all the keyboard `KeyCode`
    values at [https://docs.unity3d.com/ScriptReference/KeyCode.xhtml](https://docs.unity3d.com/ScriptReference/KeyCode.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if you wanted to check whether the *8* key from the alphanumeric
    keyboard is being pressed, you could write the following code to trigger when
    the *8* key is pressed down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: GetMouseButton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as with `GetButton()` and `GetKey()`, there are three functions for checking
    when a mouse button has been pressed: `GetMouseButton()`, `GetMouseButtonDown()`,
    and `GetMouseButtonUp()`. They return `true` in the same way that the `GetButton()`
    and `GetKey()` functions do.'
  prefs: []
  type: TYPE_NORMAL
- en: You’d place these functions within the `Update()` function as well. Within the
    parentheses, you check to see which button is being pressed; `0` represents a
    left-click, `1` represents a right-click, and `2` represents a middle-click.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if you wanted to check that the middle mouse button was clicked,
    you could write the following code to trigger when the middle mouse button is
    pressed down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve reviewed the input function for buttons and key presses, let’s
    review the Input Modules.
  prefs: []
  type: TYPE_NORMAL
- en: Input Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input Modules describe how the Event System will handle the inputs to the game
    via the mouse, keyboard, touchscreen, gamepad, and so on. You can think of them
    as the bridge between the hardware and events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three input modules provided by Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone Input Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base Input Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer Input Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To utilize these input modules, you attach them as components to your `EventSystem`
    GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: You are not restricted to using these three input modules and can create your
    own, so if you have an input device that is not covered by one of those three,
    you’d create your own input module script and then attach it to the Event System.
  prefs: []
  type: TYPE_NORMAL
- en: There is another input module called Touch Input Module, which used to be necessary
    for touchscreen inputs. However, this module has been deprecated and its functionality
    is now lumped into the Standalone Input Module. Since this input module has been
    deprecated, it will not be discussed in this text.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the three input modules provided by Unity in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone Input Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Standalone Input Module** is a pretty robust input module that will work
    with most of your input devices. It works with a mouse, keyboard, touchscreen,
    and gamepad.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventSystem` GameObject when it is created. However, you can attach the
    **Standalone Input Module** as a component using **Add Component** | **Event**
    | **Standalone Input Module** on the object’s **Inspector**. You could do this
    if you wanted to add a second one, previously deleted it, and want to re-attach
    it, or want to add the **Standalone Input Module** to another GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: The Standalone Input Module component](img/B18327_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The Standalone Input Module component'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see that the first four properties of the **Standalone Input Module**
    are **Horizontal Axis**, **Vertical Axis**, **Submit Button**, and **Cancel Button**.
    These properties are the reason I wanted to discuss the Input Manager before discussing
    the Input Modules. The default properties assigned to these slots are **Horizontal**,
    **Vertical**, **Submit**, and **Cancel**. These assignments are referencing the
    axes assignments from the Input Manager.
  prefs: []
  type: TYPE_NORMAL
- en: The `10`. This means that there will be a tenth of a second delay after an input
    action before the next input action is registered. The **Repeat Delay** property
    is the amount of time, in seconds, before **Input Actions Per** **Second** occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the **Force Module Active** property to true will make this **Standalone
    Input** **Module** active.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Standalone Input Module at the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml](mailto:https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml](https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: BaseInputModule/PointerInputModule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BaseInputModule` and `PointerInputModule` are modules that are only accessible
    via code.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to create your own Input Module, you will create it by extending
    from the `BaseInputModule`. You can view a full list of the variables, functions,
    and messages that can be utilized by extending the `BaseInputModule` at [https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The `PointerInputModule` is a `BaseInputModule` that is used by the Standalone
    Input Module described earlier. It can also be used to write custom Input Modules.
    You can view a full list of the variables, functions, and messages that can be
    utilized by extending the `PointerInputModule` at [https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how we can access multi-touch input on mobile and touchscreen
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Input for multi-touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing multi-touch is pretty easy. You access touches with `Input.GetTouch(index)`,
    where the index represents the index of the touch, with the first touch occurring
    at index `0`. From there, you can access information pretty much in the same way
    as accessing information about a mouse. You can also find out how many total touches
    are occurring with `Input.touchCount`. See the *Examples* section of this chapter
    for an example of how to access multi-touch input.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile devices also have accelerometers and gyroscopes providing input to the
    device. Let’s look at how you can access those inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Input for accelerometer and gyroscope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access data from the device’s accelerometer using the `Vector3 Input.acceleration`
    property. The coordinates of `Input.acceleration` line up with the scene based
    on the rotation of the device, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: The world axes based on screen rotation](img/B18327_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The world axes based on screen rotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple examples of this involve moving an object around a scene when the device
    is moved, using something like the following within an `Update()` function on
    the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The gyroscope uses more complicated mathematics to get a more precise movement
    of the screen using the `Gyroscope` class. Remember, the gyroscope is not supported
    on many devices, so it’s best to use the accelerometer when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how to use the gyroscope on an iOS device can be found here:
    [https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml](https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the various input modules, let’s review Event Triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Event Trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `onClick` event. However, if you’d like to add an event to an object that
    either isn’t already set up to receive events or you want it to receive different
    events, you can attach an **Event Trigger** component to the GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: You can attach an **Event Trigger** component by selecting **Add Component**
    | **Event** | **Event Trigger**.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat of using the **Event Trigger** component is that the object it is
    attached to receives all the events, not just the ones you added. So, even if
    you don’t tell the object what to do with the specified event, it will receive
    that event and acknowledge that the event occurred—it just won’t do anything in
    response. This can slow the performance of your game. If you are worried about
    performance, you will want to write your own script that attaches only the events
    you want to use to your component. The next section, *Event Inputs*, discusses
    how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: If you use an **Event Trigger** component on an object other than a UI element,
    the object must also have a collider component, and you must include a raycaster
    on the camera within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Which collider and raycaster you use depends on whether you are working in 2D
    or 3D.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working in 2D, you can add a 2D collider to the object with **Add
    Component** | **Physics 2D** and then select the appropriate 2D collider from
    within the object’s **Inspector**. You can then add a raycaster to the camera
    by selecting **Add Component** | **Event** | **Physics 2D Raycaster** from within
    the camera’s **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working in 3D, you can add a 3D collider to the object with **Add
    Component** | **Physics** and then select the appropriate 3D collider from within
    the object’s **Inspector**. You can then add a raycaster to the camera by selecting
    **Add Component** | **Event** | **Physics Raycaster** from within the camera’s
    **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the various event types that the Event Trigger can receive.
  prefs: []
  type: TYPE_NORMAL
- en: Event types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can tell the object which type of input event you want to receive by selecting
    **Add New** **Event Type**.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these events are tied to the bounding region of the object. The bounding
    region of a UI object is represented by the area of the Rect Transform. For a
    non-UI object, the bounding region is represented by a 2D or 3D collider.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pointer events can be called by the pointer in a **Standalone Input Module**.
    Remember that a pointer is not exclusively a mouse. The pointer in a **Standalone
    Input Module** can be a mouse, finger touch, or a reticle tied to gamepad movement.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the event types are related to the position of the pointer in relation
    to the object’s bounding box region. The **PointerEnter** event is called when
    the pointer enters the bounding box of the object and **PointerExit** is called
    when the pointer exits the bound box area.
  prefs: []
  type: TYPE_NORMAL
- en: There are three events related to clicking on the object. The **PointerDown**
    event is called when the pointer is pressed down within the bounding region of
    the object, and **PointerUp** is called when the pointer is released within the
    bounding region of the object. It’s important to note that with **PointerUp**,
    the pointer can be pressed outside of the object, held down, and then released
    inside the object for the **PointerUp** event to trigger. The **PointerClick**
    event is called when the pointer is pressed and then released within the bounding
    region of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and Drop events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with the various drag and drop events, it’s important to differentiate
    between the object being dragged and the object on which the dragged object is
    dropped.
  prefs: []
  type: TYPE_NORMAL
- en: The **InitializePotentialDrag** event is called whenever a drag object is found,
    but before an object is actually being dragged.
  prefs: []
  type: TYPE_NORMAL
- en: The **Drag** event is called on the object being dragged when it is being dragged.
    A **Drag** event occurs when a pointer is pressed within the bounding box of an
    object and then moved without releasing. It’s ended by releasing the pointer.
    The **BeginDrag** event is called from the object being dragged when its drag
    begins, and the **EndDrag** event is called when its drag ends.
  prefs: []
  type: TYPE_NORMAL
- en: The **Drop** event is different from the **EndDrag** event. The **EndDrag**
    event is called on the object that was just being dragged. The **Drop** event
    is called by the object on which the dragged object was dropped. Therefore, the
    **Drop** event is called by the object touching the dragged object when the dragged
    object stops dragging. So, if you were making a drag and drop menu, you’d add
    the **Drag** event to the objects you want to drag and the **Drop** event to the
    slots they will be dropped into.
  prefs: []
  type: TYPE_NORMAL
- en: Selection events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Select** event is called when the object is considered the selected object
    and **Deselect** is called when the object is no longer considered selected. Each
    of these events only fires once—the moment the object is considered selected or
    deselected. If you want an event that will trigger continuously while the object
    is selected, you can use the **UpdateSelected** event. The **UpdateSelected**
    event is called every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Other events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other events are called based on assignments in the Input Manager. Remember
    that you can assign buttons, keys, and such to axes that define movement, submit,
    and cancel. Let’s talk about a few of these events.
  prefs: []
  type: TYPE_NORMAL
- en: The **Scroll** event is called when the mouse wheel scrolls and the **Move**
    event is called when a movement happens. When the button assigned to the **Submit**
    axis is pressed, the **Submit** event is called and when the button assigned to
    the **Cancel** axis is pressed, the **Cancel** event is called.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an action to the event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have actually selected an event type, you must specify what will happen
    when that event type triggers. The following screenshot shows the results of selecting
    **Pointer Enter** as an event type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: The Event Trigger component](img/B18327_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: The Event Trigger component'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that an event type of **Pointer Enter** has been
    selected, but what happens when the pointer enters the object’s bounding area
    is yet to be defined. To define what happens when the event triggers, you must
    select the **+** sign at the bottom-right corner of the event’s box. You can add
    multiple actions when the event triggers by selecting the **+** sign multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Once an event type has been added to the **Event Trigger** component, it cannot
    be added a second time and will be grayed out in the **Add New Event** **Type**
    list.
  prefs: []
  type: TYPE_NORMAL
- en: To remove an event type from the **Event Trigger** component, select the **–**
    sign at the top-right corner of the event type’s box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the plus sign is selected, the event type should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: The Event Trigger component with a Pointer Enter event](img/B18327_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: The Event Trigger component with a Pointer Enter event'
  prefs: []
  type: TYPE_NORMAL
- en: The first setting on this event is a dropdown menu with the **Runtime Only**
    (by default), **Editor and Runtime**, and **Off** options. This is where we specify
    when the event can be triggered. Setting this to **Off** will make the event never
    trigger. Setting this to **Runtime Only** will have the event trigger when the
    game is being played. Setting this to **Editor and Runtime** will make events
    trigger when the game is being played, but it also accepts the triggers in the
    Editor when the game is not in play mode. Most of the time, **Runtime Only** is
    sufficient for what you will be doing and hence it is the default.
  prefs: []
  type: TYPE_NORMAL
- en: Below that dropdown menu is a slot with **None (Object)** in it. You are to
    drag from the Hierarchy whichever item the function you want to run is attached
    to into this slot. Once that is assigned, a list of all the available components
    and scripts attached to that object will display in the second dropdown menu.
    You can drag and drop the object the **Event Trigger** is attached to in this
    slot and are not restricted to only using other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows an `Image` GameObject with an `foodSpriteSheet_1`
    sprite when the pointer enters its **Rect Transform**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: The Event Trigger component with a Pointer Enter event that
    swaps a sprite](img/B18327_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: The Event Trigger component with a Pointer Enter event that swaps
    a sprite'
  prefs: []
  type: TYPE_NORMAL
- en: To see this `Chapter8` scene. Hover your mouse over the image. It will initially
    look like a potion bottle but will change to a triangle when your mouse hovers
    over it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run functions within scripts attached to objects. For example,
    the next screenshot shows the same image but now with a `Main Camera` has a script
    attached to it called `HelloWorld.cs` with a function called `HeyThere()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: The Event Trigger component with Pointer Click event that triggers
    a method](img/B18327_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The Event Trigger component with Pointer Click event that triggers
    a method'
  prefs: []
  type: TYPE_NORMAL
- en: The `HeyThere()` function simply prints `Hello world! This is main camera speaking!`
    in the **Console** whenever the image to the right is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: To run a function from the **Event Trigger** component, it must be public, have
    a return type of void, and have no more than one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s review how we can write code that performs similarly to the Event
    Trigger component through the use of event inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Event inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the *Event Trigger* section, you may not want to use an **Event
    Trigger** component because the **Event Trigger** component causes the object
    on which it is attached to receive all the events listed in the *Event Trigger*
    section. So, if you are worried about performance issues, you will want an alternate
    way to receive events on an object.
  prefs: []
  type: TYPE_NORMAL
- en: All event types that were available to add in the *Event Trigger* section can
    also be added to an object via code without using the **Event Trigger** component.
    To use an event without the **Event Trigger** component, you must derive your
    script from the appropriate interface and know the type of event data class that
    the event uses.
  prefs: []
  type: TYPE_NORMAL
- en: An **interface** is a template that defines all the required functionality that
    a class can implement. So, by using an interface, you can then use any of the
    methods or functions that have been defined within that interface. I’ll show you
    some examples of how to do this, but first, let’s look at the available events
    and their required interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three classes that the event data can be derived from, which are
    `PointerEventData`, `AxisEventData`, and `BaseEventData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PointerEventData` is the class that contains events associated with the pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AxisEventData` contains events associated with the keyboard and gamepad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseEventData` contains events that are used by all event types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a fourth event data class, `AbstractEventData`. It is the class from
    which the other three inherit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of events available for a `StandaloneInputModule` along with their
    required interfaces and event data class are provided in the following chart.
    The events are listed in the same order they are listed within the Event Trigger
    component for continuity purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Interface** | **Event** **Data Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `OnPointerEnter` | `IPointerEnterHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnPointerExit` | `IPointerExitHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnPointerDown` | `IPointerDownHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnPointerUp` | `IPointerUpHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnPointerClick` | `IPointerClickHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnDrag` | `IdragHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnDrop` | `IdropHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnScroll` | `IscrollHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnUpdateSelected` | `IUpdateSelectedHandler` | `BaseEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnSelect` | `IselectHandler` | `BaseEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnDeselect` | `IdeselectHandler` | `BaseEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnMove` | `IMoveHandler` | `AxisEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnInitializePotentialDrag` | `IInitializePotentialDragHandler` | `PointerEventData`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OnBeginDrag` | `IbeginDragHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnEndDrag` | `IEndDragHandler` | `PointerEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnSubmit` | `ISubmitHandler` | `BaseEventData` |'
  prefs: []
  type: TYPE_TB
- en: '| `OnCancel` | `ICancelHandler` | `BaseEventData` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Interfaces and event data types for the various events'
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a class with one of these events, you will use the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The items highlighted in the preceding code will be replaced by the items within
    the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you wanted to implement an `OnPointerEnter` event, the code
    would look as follows after the highlighted code has been replaced with an appropriate
    event, interface, and event data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You must include the `UnityEngine.EventSystems` namespace to write code with
    event data. The `UnityEngine.UI` namespace is optional and is only required if
    you will also be writing your events for UI objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed various ways to send and receive events, let’s look
    at raycasters.
  prefs: []
  type: TYPE_NORMAL
- en: Raycasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the Event System keeps track of raycasting along with all the
    other things we have discussed. Raycasting is used to determine which UI elements
    are being interacted with by projecting a ray from the user’s pointer into the
    scene. This ray is considered to originate at the camera’s plane and then proceed
    forward through the scene. Whatever this ray hits receives an interaction. You
    can have the ray continue through the first UI element it hits or stop at the
    first UI element it hits. To get a ray to stop at the first UI element it hits,
    the object must block raycasting. This will stop items behind it from being interacted
    with. Next, we’ll discuss the types of raycasters.
  prefs: []
  type: TYPE_NORMAL
- en: Graphic Raycaster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a Canvas is added to the scene, it is automatically given a **Graphic**
    **Raycaster** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the raycasting system that will allow you to interact with all UI objects
    that are children of that Canvas. It has three properties: **Ignore Reversed Graphics**,
    **Blocking Objects**, and **Blocking Mask**.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Ignore Reversed Graphics** toggle determines whether or not graphical
    objects within the Canvas can be interacted with if they are facing backward (in
    relation to the raycaster). The **Blocking Objects** and **Blocking Mask** properties
    allow you to assign the types of objects that are in front of the Canvas (between
    the camera and the Canvas) that can block raycasting to the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Other Raycasters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, if you want to use the Event System with a non-UI object,
    you must attach a Raycaster component to a camera within the scene. You can add
    either a **Physics 2D Raycaster** or a **Physics Raycaster** (or both) to your
    camera based on whether you are using 2D or 3D.
  prefs: []
  type: TYPE_NORMAL
- en: From within the camera’s inspector, you can add the **Physics 2D Raycaster**
    by selecting **Add Component** | **Event** | **Physics 2D Raycaster** and the
    **Physics Raycaster** by selecting **Add Component** | **Event** | **Physics Raycaster**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two components appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: The two types of Physics Raycasters](img/B18327_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: The two types of Physics Raycasters'
  prefs: []
  type: TYPE_NORMAL
- en: The **Event Mask** property determines which types of objects can receive raycasting.
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to add either of these components to a non-camera GameObject,
    a **Camera** component will automatically be attached to the GameObject as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the various systems that we can use to program interactions
    for our UI, let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue to work on the UI we have been building for the last two chapters.
    To help organize the project, duplicate the `Chapter7` scene that you created
    in the last chapter; it will automatically be named `Chapter8`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you did not work through the examples for [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085),
    and [*Chapter 7*](B18327_07.xhtml#_idTextAnchor106), but would like to work through
    the examples in this chapter, you can import the package labeled **Chapter 08**
    **– Examples 1 - Start**. You can also view the completed examples in the **Chapter
    08** **– Examples 1 –** **End** package.
  prefs: []
  type: TYPE_NORMAL
- en: Showing and hiding pop-up menus with keypress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have made two Panels that we plan on turning into popups: the `Pause
    Panel` from [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), and the `Inventory
    Panel` from [*Chapter 7*](B18327_07.xhtml#_idTextAnchor106). Right now, they are
    both visible in the scene (even though `Pause Panel` is hidden behind the `Inventory
    Panel`). We want them to pop up when we press *P* and *I* on the keyboard. For
    demonstration purposes, we’ll access the keyboard keys differently for each Panel.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that both of these Panels have Canvas Group components on them. These
    components will allow us to easily access the Panels’ alpha, intractable, and
    blocks raycasts properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using KeyCode with the Inventory Panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s begin with the `Inventory Panel`. We want the Panel to pop up and close
    when the *I* key is pressed on the keyboard. To make the `Inventory Panel` appear
    and disappear with the *I* key, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Assets/Scripts` folder by right-clicking within
    the **Project** view of the folder and selecting **Create** | **C# Script** from
    the pop-up Panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the script `ShowHidePanels.cs`, and then double-click on it to open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s use a `public CanvasGroup` variable called `inventoryPanel` to represent
    the Panel. We use a `CanvasGroup` variable type to reference the Panel since we
    want to access the properties of the `ShowHidePanels` script to include the following
    highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CanvasGroup` variable type, even though it is used with UI elements, is
    not in the `UnityEngine.UI` namespace, but the `UnityEngine` namespace, so we
    do not need to include the `UnityEngine.UI` namespace in our script at the moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create another variable that will keep track of whether or not the `Inventory
    Panel` is visible. Add the following code to the next line of the script to initialize
    the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will be toggling the Panels on and off by adjusting their `alpha`, `interactable`,
    and `blocksRaycasts` properties. When the Panel is hidden, it should also not
    accept interactions or block raycasts. So, let’s create a method that we can call
    to perform the toggle. Add the following namespace to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to your script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the method has two parameters. The first parameter is a `CanvasGroup`
    called `Panel` and the second parameter is a Boolean called `show`. It will set
    the `alpha` property to `0` when `show` is `false` and `1` when `show` is `true`.
    It will also set the `interactable` and `blocksRaycasts` properties to `false`
    when `show` is `false` and `true` when `show` is `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We want `Inventory Panel` to be hidden when the scene starts playing. So, update
    the `Start()` function to include the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to write code that triggers whenever the *I* key on the keyboard
    is pressed down. We will use the `Input.GetKeyDown()` function in a way that the
    function is called the moment the key is pressed down. We will also use `KeyCode.I`
    to reference the *I* key on the keyboard. Add the following code to your `Update`
    function to check whether the *I* key is pressed down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want this key to disable and enable the Panel, so we will change the value
    of `inventoryUp` to whatever the opposite of its current value is. That is, if
    it is `true`, we will set it to `false`, if it is `false`, we will set it to `true`.
    Then, we will call the `TogglePanel()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to your `Update()` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, for this code to work, we need to attach it to a GameObject within our
    scene. It really doesn’t matter what GameObject we attach it to, since we used
    a public variable to access our `Inventory Panel`, we can assign that via the
    Inspector. However, since we are planning on using this script to affect both
    Panels, I want to add it to `Main Camera`. Drag and drop the `ShowHidePanels`
    script into the `Main Camera`. You should now see the following as a component
    on your `Main Camera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13: The ShowHidePanel.cs script component](img/B18327_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: The ShowHidePanel.cs script component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to assign the `Inventory Panel` GameObject to the slot labeled
    **Inventory Panel**. Drag and drop the **Inventory Panel** from the Hierarchy
    into this slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component](img/B18327_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game to ensure that the code is working correctly. You should see the
    inventory Panel start out invisible and then turn on and off as you press the
    *I* key on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve completed the work needed to show and hide the `Inventory Panel`,
    we can move on to the `Pause Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Input Manager with the Pause Panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s do the same thing for the `Pause Panel`. We’ll do this slightly differently
    than the `Inventory Panel`. To make sure that you can see how to access a key
    with the Input Manager, we’ll use the Input Manager instead of a `KeyCode`. We
    also need to actually pause the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the `Pause Panel` using the *P* key and pause the game, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up the Input Manager to include a `Pause` axis. Open the
    Input Manager with **Edit** | **Project Settings** | **Input Manager** and expand
    the axes by selecting the arrow next to the word **Axes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, your project has 30 axes. You can replace one of these with the
    new `Pause` axis if you aren’t planning on using them, but we might as well just
    go ahead and make a new one. Definitely don’t delete the `31`. This will duplicate
    the last axis in the list, **Debug Horizontal**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.15: The Input Manager with an extra axis](img/B18327_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: The Input Manager with an extra axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the second `Debug Horizontal` axis to a `Pause` axis by changing the
    `Pause`, the `p`, and changing the rest of the properties to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16: The Pause axis added to the Input Manager](img/B18327_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: The Pause axis added to the Input Manager'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `Pause` axis set up, we can start writing our code. Let’s
    define some variables to use with the `Pause Panel` similar to the way we defined
    variables for `Inventory Panel`. Add the following variable definitions at the
    top of your class under your previous variable definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the `Start()` function and make the `Pause Panel` invisible
    at start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we added the `Pause` axis to our Input Manager, we can use `Input.GetButtonDown()`
    instead of `Input.GetKeyDown()`, like we did with `Inventory Panel`. We want to
    use `GetButtonDown()` rather than `GetAxis()` because we want a function that
    will return `true` once, not continuously. If it returned continuously (using
    `GetAxis()`), the Panel would flicker in and out while the *P* key was being pressed.
    Add the following code at the end of your `Update()` function. Note that it’s
    very similar to the code we used for Inventory Panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve added new public variables to our script, it should be showing
    up in the `Main Camera`. Drag and drop the `Pause Panel` from the Hierarchy to
    the **Pause** **Panel** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added](img/B18327_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added'
  prefs: []
  type: TYPE_NORMAL
- en: Now, play the game and watch the `Pause Panel` become visible and invisible
    when you press the *P* key on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we’ll learn about pausing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game doesn’t actually pause right now. If we had animations or events running
    in the scene, they would continue to run even with the `Pause Panel` up. A really
    easy way to pause a game is to manipulate the time scale of the game. If the time
    scale is set to `1`, time will run as it normally does. If the time scale is set
    to `0`, the time within the game will pause.
  prefs: []
  type: TYPE_NORMAL
- en: Also, our current setup doesn’t quite work as a pause menu would be expected
    to. `Inventory Panel` and `Pause Panel` can be displayed at the same time. If
    `Inventory Panel` is up, the `Pause Panel` is covered up by it since it is rendering
    behind it. Also, the `Inventory Panel` can be activated when the game is *paused*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need to pause the time scale of our game, change the order that our Panels
    render, and disable functionality when the game is paused to have a `Pause Panel`
    that functions properly. To create a properly functioning `Pause Panel`, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the `Update()` function to the `ShowHidePanels` script
    to pause the time in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s deal with the fact that `Pause Panel` is behind the `Inventory Panel`.
    This is an easy fix. Simply change their order in the Hierarchy by dragging the
    `Pause Panel` below the `Inventory Panel`. The items that are listed lower in
    the Hierarchy render on top of the ones listed above it within the scene. Now,
    the `Pause Panel` will be above the `Inventory Panel` in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.18: The children of the Popup Canvas](img/B18327_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: The children of the Popup Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is to disable the ability of the `Inventory Panel`
    to appear and disappear if the `Pause Panel` is up. Adjust the `if` statement
    that checks for the *I* key being pressed to also check whether `pauseUp` is false,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s important to remember that when you have a `Pause Panel`, other events
    need to be turned off. Setting the timescale to `0` does not stop the ability
    for other events to occur; it only really stops animations and any clocks you
    may have displayed that use the time scale. So, we will need to ensure that any
    other event we program is turned off when the game is paused.
  prefs: []
  type: TYPE_NORMAL
- en: Dragging and dropping inventory items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an `Inventory Panel` that can be displayed and hidden and a HUD inventory.
    I want to be able to drag objects from my larger `Inventory Panel` to my smaller
    HUD inventory called `Bottom Right Panel` that we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a little easier for ourselves, let’s disable the `ShowHidePanels`
    script that we added to the `Main Camera` earlier in this chapter. You can do
    this by deselecting the checkbox next to the script’s component on the `Main Camera`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Disabling the ShowHidePanel.cs script component](img/B18327_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Disabling the ShowHidePanel.cs script component'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also disable `Pause Panel` so that it will not be in our way. Do this
    by deselecting the checkbox next to the name of the `Pause Panel` in its Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our Panel will stay visible, making it easier for us to debug the code
    we’re about to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few different ways to make a drag and drop mechanic. To ensure
    that this chapter provides an example of how to use the `Inventory Panel` and
    `Bottom Right Panel`, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Assets/Scripts` folder called `DragAndDrop.cs`
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be referencing UI elements in this script, so add the `UnityEngine.UI`
    namespace to the top of the script with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We only need to add two variables to this script: one will represent the GameObject
    being dragged, and the other represents the Canvas that the items will be dragged
    on. Add the following public variables to the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we write any more code, let’s go back to the Editor and do a bit more
    prep work. Drag the `DragAndDrop.cs` script to the `Main Camera` to attach it
    as a component:![Figure 8.20: The components of the Main Camera](img/B18327_08_20.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.20: The components of the Main Camera'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I’ve chosen to create a script that attaches to the `Main Camera` rather than
    the individual inventory items to reduce the need to duplicate this script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, create a new UI Canvas by selecting `Drag Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `HUD Canvas` and copy its **Canvas Scalar** component by selecting the
    settings three dots (aka “the kabob”) in its top-right corner and selecting **Copy**
    **Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reselect `Drag Canvas` and paste the copied **Canvas Scaler** properties to
    its **Canvas Scalar** component by selecting the three dots in its top-right corner
    and selecting **Paste** **Component Values**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once that is done, it should have the following values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.21: The Canvas Scaler component on the Drag Canvas](img/B18327_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: The Canvas Scaler component on the Drag Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `Drag Canvas`’ Canvas component to `1`. This will cause anything that
    is on the `Drag Canvas` to render in front of all other Canvases since the other
    Canvases have a `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component](img/B18327_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag and drop the `Drag Canvas` from the Hierarchy into the `DragAndDrop` script
    component on the `Main Camera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.23: The Drag and Drop component](img/B18327_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.23: The Drag and Drop component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen the `DragAndDrop` script. Create a new function called `StartDrag()`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will be called when a drag begins. It accepts a GameObject as
    a parameter and then creates a new instance of it at the position of the mouse.
    It then moves it so that it is a child of `dragCanvas`. Lastly, it sets the size
    of the sprite on the Image component to native size. This resets the scale of
    the Image’s Rect Transform to its sprite’s original pixel size. (Refer to [*Chapter
    12*](B18327_12.xhtml#_idTextAnchor328) for more on **Set Native Size**). The last
    line makes the image 10% bigger than its native size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: After we hook up our **BeginDrag** and **Drag** events, if you comment out the
    line of code that sets the size to native, you›ll see that the Image does not
    actually render in the scene, because its scale is «wacky» from the original GameObject
    being within a **Layout Group**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new function called `Drag()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will be called when an object is being dragged. While the object
    is dragged, it will keep position with the mouse.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Return to the Editor. We will just hook the events to the first object in the
    `Inventory Panel` for now. Select the first `Food` image in the `Inventory Panel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.24: Selecting the Food GameObject](img/B18327_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.24: Selecting the Food GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new Event Trigger component to the `Food` Image by selecting **Add Component**
    | **Event** | **Event Trigger** within its **Inspector**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.25: The Food GameObject with the Event Trigger component](img/B18327_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.25: The Food GameObject with the Event Trigger component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a **Begin Drag** event type and a **Drag** event type to the **Event
    Trigger** list by selecting **Add New Event Type** | **BeginDrag** and **Add New
    Event Type** | **Drag**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.26: The Event Trigger component with two events](img/B18327_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.26: The Event Trigger component with two events'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add an action to the **Begin Drag** list by selecting the plus
    sign at the bottom-right corner of the **Begin** **Drag** area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.27: Adding a Begin Drag event](img/B18327_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.27: Adding a Begin Drag event'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the `Main Camera` into the object slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.28: Updating the Begin Drag event with the camera](img/B18327_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.28: Updating the Begin Drag event with the camera'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function dropdown list is now intractable. Expand the function dropdown
    list to see the list of functions, components, and such attached to the `Main
    Camera`. Find the **DragAndDrop** script and then the **StartDrag (****GameObject)**
    function:![Figure 8.29: Adding the StartDrag method](img/B18327_08_29.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.29: Adding the StartDrag method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have done so, you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.30: Adding the StartDrag method](img/B18327_08_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.30: Adding the StartDrag method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we need to assign the GameObject parameter. Drag and drop the `Food` Image
    that this **Event Trigger** component is attached to into the parameter slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.31: Updating the StartDrag method](img/B18327_08_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.31: Updating the StartDrag method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, set up the **Drag** event list similarly so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.32: Adding the Drag method](img/B18327_08_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.32: Adding the Drag method'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play the game, you should now be able to drag the orange in the first
    slot out of its slot.![Figure 8.33: Dragging the orange from the inventory](img/B18327_08_33.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.33: Dragging the orange from the inventory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’ll see, in the Hierarchy, there is a new GameObject called `Food(Clone)`
    that is a child of the `Drag Canvas`. This is the orange that gets created when
    you begin dragging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.34: The item being dragged in the Drag Canvas](img/B18327_08_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.34: The item being dragged in the Drag Canvas'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, you can actually make as many of these clones as you want. In
    a moment, however, we will make it so that there is only one clone in the `Drag
    Canvas` at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the `DragAndDrop` script and create a new function called `StopDrag()`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will destroy the `Food(Clone)` GameObject once it is no longer being
    dragged.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the Editor and reselect the `Food` Image in `Inventory Panel`. Give
    its `EndDrag` event type by selecting `Drag()` function from the `DragAndDrop`
    script to this event since that was the last selected function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.35: The End Drag event with the Drag method](img/B18327_08_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.35: The End Drag event with the Drag method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `Drag()` function in the function dropdown with the `StopDrag()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.36: The End Drag event with the StopDrag method](img/B18327_08_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.36: The End Drag event with the StopDrag method'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game, and you will see that the orange can now be dragged out of its
    slot, and when you release the mouse, it is destroyed. This stops you from being
    able to drag a bunch of oranges from this slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the `DragAndDrop` script and create a new function called `Drop()`,
    as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function accepts an `Image` as a parameter. This Image will be the Image
    component of the slot that will receive a drop. The first line of the function
    finds the first child of the `dragCanvas` (at position `0`) and then assigns its
    Image’s sprite to the sprite of the `dropSlot`. Since we have set up the `StopDrag()`
    function to destroy the object being dragged once it stops dragging, we don’t
    have to worry about there being more than one child of the `Drag Canvas` GameObject,
    making this the easiest way to find the object being dragged.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the Editor and select the second `Food` Image in the `Bottom` `Right
    Panel`:![Figure 8.37: Selecting the correct Food item](img/B18327_08_37.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.37: Selecting the correct Food item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’re using the second `Food` Image, rather than the first, because the first
    already has an orange in it, and it will be hard to tell that our script worked
    in that slot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a new `Food` Image by selecting **Add Component** | **Event** | **Event
    Trigger** within its Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Drop` event type to the **Event Trigger** component by selecting **Add
    New Event Type** | **Drop**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.38: The Drop event](img/B18327_08_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.38: The Drop event'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new action to the list with the **+** sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag `Main Camera` to the object slot and select the `Drop()` function from
    the `DragAndDrop` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.39: The Drop event with its method populated](img/B18327_08_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.39: The Drop event with its method populated'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag the `Food` Image that this **Event Trigger** component is attached
    to into the parameter slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.40: The Drop event with the correct parameter](img/B18327_08_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.40: The Drop event with the correct parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play the game and when you drag the orange into the slot over the banana, the
    `Drop()` function doesn’t appear to trigger. This is because the orange being
    dragged is blocking the raycasting from reaching the banana, so the banana never
    thinks anything is dropped on it. This is an easy fix. Add the following line
    of code to the end of the `StartDrag()` function in the `DragAndDrop` script so
    that the raycast won’t be blocked by the orange anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Play the game, and you should now be able to drag the orange from the first
    slot of the `Inventory Panel` to the second slot of `Bottom` `Right Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The functionality of drag and drop is now complete; we just need to add the
    functionality to the other slots. Let’s add the drag events to the other `Inventory
    Panel` items first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Food` Item in the `Inventory Panel` that we hook the events up to,
    using the three dots in the component’s top-right corner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select all the other `Food` Images in the `Inventory Panel` by clicking on them
    while holding *Ctrl*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, with all eight `Food` Images still selected, click on the three dots on
    the `Food` Images should now have the **Event Trigger** component with all the
    appropriate events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re not done with these other inventory items yet. We need to select each
    one and drag it into the parameter of the `BeginDrag` event type for its component.
    Otherwise, each of these other eight `Food` items will drag out oranges instead
    of the appropriate `Food` item, because the original orange is assigned to that
    slot. Do so now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before continuing, play the game and ensure that each inventory item in `Inventory
    Panel` drags out the appropriate image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will copy the drop events from the second `Food` Image image in the
    `Bottom Right Panel` to all the other `Food` Images within the Panel. Copy the
    `Food` Image in the `Bottom` `Right Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the other four `Food` Images in the `Bottom Right Panel` while holding
    down *Ctrl*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With each of the `Food` Images shown in the preceding screenshot still selected,
    paste the component as new in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select each of the new `Food` Images and assign each to the parameter slot
    within their **Event** **Trigger** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game and ensure that the correct image slot is changed when a food
    item is dropped into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the drag and drop code is done, re-enable the `ShowHidePanels` script
    on the `Main Camera` and re-enable the `Pause Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it for the drag and drop code. Currently, the `Pause Panel` blocks the
    raycast on the items within the `Inventory Panel`, so you don’t have to worry
    about disabling these events when the game is paused. However, if you end up changing
    the layout, you will want to do so by checking whether the `pauseUp` variable
    in `ShowHidePanels` is `false` before performing the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to allow the objects to go back and forth (drag from both Panels
    and drop in both Panels), all you have to do is copy the appropriate component
    to the opposite Panels!
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to make the repeated UI elements prefabs so that you can
    save yourself some time during development or instantiate them programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: There are so many more examples I would love to cover in this chapter, but I
    can’t make this chapter take up the entire page count of the book! You’ll see
    more examples of how to use the Event System in the upcoming chapters, so don’t
    worry; this isn’t the last code example you will see.
  prefs: []
  type: TYPE_NORMAL
- en: Pan and zoom with mouse and multi-touch input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last example I want to cover in this chapter is how to pan the camera with
    a two-finger touch and pinch to zoom. We will also implement a left-click pan
    and scroll wheel zoom so that you can easily test it on your computer (when you
    don’t have multi-touch input). The following image shows what we will be implementing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.41: Demonstration of the pan and zoom code working](img/B18327_08_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.41: Demonstration of the pan and zoom code working'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a pan and zoom on the camera, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: So that I can actually see the effects of the pan and zoom, I want to populate
    some items in the scene. Let’s start by creating a prefab that we will place multiple
    times in the background. Create a `Prefabs` folder in your project by right-clicking
    on the `Assets` folder and selecting `Prefabs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a sprite to the scene. I chose the first gem in the `foodSpriteSheet` called
    `foodSpriteSheet_1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Transform** component of the sprite is positioned at the origin.
    If it is not, select the three dots in the top-right corner of the component and
    then select **Reset**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the sprite `Tile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag the sprite from the Hierarchy into your `Prefabs` folder. This will
    create a prefab called `Tile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We no longer need the prefab in the scene so go ahead and delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty GameObject by selecting **+** | **Create Empty** in the Hierarchy.
    We will use this to hold the code that instantiates our tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this empty GameObject to `Tile Maker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the book’s source files, you will find three scripts called `Tile.cs`, `TileMaker.cs`,
    and `CameraHandle.cs`. Import them into the `Scripts` folder of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `Tile.cs` script to the `Tile` prefab. This script will be used to
    make any instantiated `Tile` prefab have a random sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the `Tile.cs` script is not really essential to the example, I won’t review
    the code, but I will point out that the `possibleSprites` list contains all the
    sprites that the tile can change to. Add all the sprites that look like gems to
    this list. You should see something like the following
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.42: The possible sprites for the tile](img/B18327_08_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.42: The possible sprites for the tile'
  prefs: []
  type: TYPE_NORMAL
- en: Now attach the `TileMaker.cs` script to the `Tile` `Maker` GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `Tile` prefab into the **Tile Prefab** slot and set the other values
    as follows:![Figure 8.43: The TileMaker.cs script component](img/B18327_08_43.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.43: The TileMaker.cs script component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will make a total of `500` tiles instantiate in `25` columns and `20` rows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Play the game and you should see a bunch of random gems appear in your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.44: The gems in the scene](img/B18327_08_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.44: The gems in the scene'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s hook up the pan and zoom script. Attach the `CameraHandler.cs` script
    to the `Main Camera`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we review the code, let’s add the correct variables to the component.
    Adjust the values to the following:![Figure 8.45: The CameraHandler.cs script
    component](img/B18327_08_45.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.45: The CameraHandler.cs script component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The various properties add bounds to how far the camera can pan, how much it
    can zoom, and how quickly it pans and zooms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s review the code. The code handles pan and zoom in two ways: one
    is with mouse input and the other with touch input. You’ll see that it also has
    special conditions for when a touch device is being played remotely via the Unity
    Editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A large portion of this code is vector math, and I will leave that for you
    to review on your own. The parts of this code I want to focus on are the parts
    relative to this chapter, specifically the parts involving `Input` and `Touch`.
    First, let’s look at the `HandleMouse()` method. I’ve highlighted the relevant
    parts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that it uses `Input.GetMouseButtonDown(0)` to see if the left mouse button
    is currently held down, `Input.GetMouseButton(0)` to see if the mouse button has
    been clicked, and `Input.mousePosition` to find where the mouse is located.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s look at how input is handled with touch in the `HandleTouch()` method.
    First, it looks to see how many fingers are touching the screen with the following
    `switch` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a single finger is touching the screen, the camera can pan. It first must
    get the position of the finger. It does so with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, I have highlighted the relevant code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When two fingers are touching the screen, it will get the position of the fingers
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next piece of code that I want to focus on is the following line within
    the `PanCamera()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.46: The Event Trigger on the Background Canvas](img/B18327_08_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.46: The Event Trigger on the Background Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve reviewed the code, play the game again to see the pan and zoom
    functions in action. If you can, I recommend also plugging a mobile device into
    your computer and running the game via Unity Remote. You can view information
    about how to use Unity Remote here: [https://docs.unity3d.com/Manual/UnityRemote5.xhtml](https://docs.unity3d.com/Manual/UnityRemote5.xhtml).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don’t want the game to pan and zoom when it’s paused and the inventory Panel
    is up! So, let’s update the `ShowHidePanels.cs` script to call the `TurnOffPanAndZoom()`
    and `TurnOnPanAndZoom()` methods, which toggle the `canPan` and `canZoom` Boolean
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following variable to the `ShowHidePanels.cs` class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to initialize the `cameraHandler` variable. Add an `Awake()` method
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following to the `TogglePanel()` method. This will call the `TurnOffPanAndZoom()`
    method whenever the game is paused or showing the inventory and call `TurnOnPanAndZoom()`
    whenever neither of the Panels is visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now have a fully functional pan and zoom that are disabled when menus
    are visible!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is almost the exact code I used in my game Barkeology, which you can find
    on the iOS app store: [https://apps.apple.com/kn/app/barkeology/id1500348850](https://apps.apple.com/kn/app/barkeology/id1500348850)
    So, if you do not have the ability to test your code on your mobile device, but
    would like to see it in action, you can view it there.'
  prefs: []
  type: TYPE_NORMAL
- en: While this marks the end of the chapter, we will continue to work in the Event
    System throughout this text, so you will see plenty more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to utilize the Event System and program for UI elements,
    we can start making interactive and visual UI elements. We can also create UI
    that has its various properties change when events occur.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a lot in this chapter! We discussed how to access the properties
    of UI elements and how to work with the Event System. We also discussed how to
    use the Input Module. Now, you can create UI that responds to user inputs as well
    as UI that responds to events within your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will look at the other input system provided by Unity:
    the New Input System (yeah, that’s its actual name).'
  prefs: []
  type: TYPE_NORMAL
