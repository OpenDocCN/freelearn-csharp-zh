<html><head></head><body><div><div><h1 id="_idParaDest-127"><em class="italic"><a id="_idTextAnchor136"/>Chapter 6</em>: Gallery: Building an AR App</h1>
			<p>In this chapter, we will begin building a full <strong class="bold">Augmented Reality</strong> (<strong class="bold">AR</strong>) app, an AR <em class="italic">art gallery</em> that lets you hang virtual framed photos on your real-world walls. </p>
			<p>First, we'll define the goals of the project and discuss the importance of project planning and <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>) design. When the user presses the <strong class="bold">Add</strong> button in the main menu, they'll see a <strong class="bold">Select Image</strong> menu. When they pick one, they'll be prompted to place a framed copy of the image on their real-world wall.</p>
			<p>To implement the project, we will start with the AR user framework scene template that we created earlier in this book. We'll build a Select Image UI panel and interaction mode, and define the image data used by the app.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Specifying a new project and UX design</li>
				<li>Using data structures and arrays, and passing data between objects</li>
				<li>Creating a detailed UI menu panel with a grid of buttons</li>
				<li>Creating prefabs for instantiating in an AR scene</li>
				<li>Implementing a complete scenario based on a given user story</li>
			</ul>
			<p>By the end of the chapter, you'll have a working prototype of the app that implements one scenario: placing pictures on the wall. Then we'll continue to build and improve the project in the next chapter.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor137"/>Technical requirements</h1>
			<p>To implement the project in this chapter, you need Unity installed on your development computer, connected to a mobile device that supports AR applications (see <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up for AR Development</em>, for instructions). We also assume that you have the <code>ARFramework</code> template and its prerequisites installed; see <a href="B15145_05_Final_SB_epub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Using the AR User Framework</em>. The completed project can be found in this book's GitHub repository, <a href="https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation">https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation</a>.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor138"/>Specifying the Art Gallery project UX</h1>
			<p>An <a id="_idIndexMarker468"/>important step before beginning any new project is to do some design and specifications ahead of time. This often entails writing it down in a document. For games, this <a id="_idIndexMarker469"/>may be referred to as the <strong class="bold">Game Design Document</strong> (<strong class="bold">GDD</strong>). For applications, it may be a <strong class="bold">Software Design Document</strong> (<strong class="bold">SDD</strong>). Whatever<a id="_idIndexMarker470"/> you call it, the purpose is to put into writing a blueprint of the project before development begins. A thorough design document for a Unity AR project might include details such as the following:</p>
			<ul>
				<li><em class="italic">Project overview</em>: Summarize <a id="_idIndexMarker471"/>the concept and purpose of the project, identify the primary audience, and perhaps include some background on why the project exists and how and why it will be successful.</li>
				<li><em class="italic">Use cases</em>: Identify <a id="_idIndexMarker472"/>the real-life problems the product <a id="_idIndexMarker473"/>will solve. It's often effective to define separate user <strong class="bold">personas</strong> (with real or fictitious names) representing types of users of the application, their main goals, and how they'll use the app to achieve these objectives.</li>
				<li><em class="italic">Key features</em>: Identify the <a id="_idIndexMarker474"/>discrete areas of functionality that deliver value to your users, perhaps with an emphasis on what distinguishes it from other similar solutions.</li>
			</ul>
			<ul>
				<li><em class="italic">UX design</em>: The <strong class="bold">user experience (UX)</strong> design may include a variety of user scenarios that detail specific <a id="_idIndexMarker475"/>workflows, often<a id="_idIndexMarker476"/> presented as a <strong class="bold">storyboard</strong> using abstract pencil or wireframe sketches. In lieu of drawing skills, photo captures of a whiteboard session and sticky notes may be sufficient. <p>Separately, you may also include UI graphic designs that define actual style guides and graphics, for example, color schemes, typography, button graphics, and so on.</p></li>
				<li><em class="italic">Assets</em>: Collect and<a id="_idIndexMarker477"/> categorize the graphic assets you anticipate needing, including concept art, 3D models, effects, and audio.</li>
				<li><em class="italic">Technical plan</em>: This <a id="_idIndexMarker478"/>includes software architecture and design patterns that will be used, development tools (such as Unity, Visual Studio, and GitHub), the Unity version, third-party packages (for example, via Package Manager), plus Unity Services and other cloud services (such as advertising, networking, and data storage).</li>
				<li><em class="italic">Project plan</em>: The <a id="_idIndexMarker479"/>implementation plan may show the anticipated project phases, production, and release schedules. This could involve the use of tools such as Jira or Trello.</li>
				<li><em class="italic">Business plan</em>: Non-technical<a id="_idIndexMarker480"/> planning may include plans for project management, marketing, funding, monetization, user acquisition, and community-building.</li>
			</ul>
			<p>For very large projects, these sections could be separate documents. For small projects, the entire thing may only be a few pages long with bullet points. Just keep in mind that the main purpose is to think through your plans before committing to code. That said, don't over-design. Keep in mind one of my favorite quotes from Albert Einstein:</p>
			<p class="author-quote">"Make everything as simple as possible, but not simpler."</p>
			<p>Assume things can and will change as the project progresses. Rapid iteration, frequent feedback from stakeholders, and engaging real users may reaffirm your plans. Or it may expose serious shortcomings with an original design and can take a project in new, better directions. As I tell my clients and students:</p>
			<p class="author-quote">"The time you know least about a project is at the beginning!" </p>
			<p>In this book, I'll provide an abbreviated design plan at the beginning of each project that tries to capture the most important points without going into a lot of detail. Let's start with this AR Gallery project, and spec out the project objective, use cases, a UX design, and a set of user stories that define the key features of the project.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor139"/>Project objectives</h2>
			<p>We are going to build an AR art<a id="_idIndexMarker481"/> gallery project that allows users to place their favorite photos on walls of their home or office as virtual framed images using AR. </p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor140"/>Use cases</h2>
			<p><em class="italic">Persona: Jack</em>. Jack <a id="_idIndexMarker482"/>works from home and doesn't have time to decorate his drab apartment. Jack wants to spruce up the walls by adding some nice pictures on the wall. But his landlord doesn't allow putting nails in the walls. John also wants to be able to change his hung pictures frequently. Jack spends many hours per day using his mobile phone, so looking at the walls through his phone is satisfying.</p>
			<p><em class="italic">Persona: Jill.</em> Jill has a large collection of favorite photos. She would like to hang them on the walls of her office but it's not very appropriate for a work environment. Also, she is a bit obsessive and thus would like to frequently rearrange the photos and swap the pictures.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor141"/>UX design</h2>
			<p>The <strong class="bold">user experience</strong> (<strong class="bold">UX)</strong> for this <a id="_idIndexMarker483"/>application must include the following requirements and scenarios:</p>
			<ul>
				<li>When the user wants to place a photo on the wall, they select an image from a menu and then tap the screen, indicating where to place the photo.</li>
				<li>When the user wants to modify a photo already placed on the wall, they can tap the photo to enable editing. Then the user can drag to move, pinch to resize, choose a different photo or frame, or swipe to remove the photo.</li>
				<li>When the framed photo is rendered, it matches the current room lighting conditions and casts shadows on real-world surfaces.</li>
				<li>When the user exits and re-opens the app, all the photos they placed in the room will be saved and restored in their locations.</li>
			</ul>
			<p>I asked a <a id="_idIndexMarker484"/>professional UX designer (and friend of mine) Kirk Membry (<a href="https://kirkmembry.com/">https://kirkmembry.com/</a>) to prepare UX wireframe sketches specifically for this book's project. The following image shows a few frames of a full storyboard:</p>
			<div><div><img src="img/Figure_6.01-ux-design-example.jpg" alt="Figure 6.1 – UX design wireframe sketches&#13;&#10;" width="1203" height="782"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – UX design wireframe sketches</p>
			<p>The leftmost frame shows the image gallery menu that appears when the user has chosen to add a new photo into the scene. The middle frame depicts the user choosing a location to hang the photo on a wall. And the rightmost frame shows the user editing an existing picture, including finger gestures to move and resize, and a menu of other edit options on the bottom of the screen.</p>
			<p>Storyboards like this can be used to communicate the design intent to graphic designers, coders, and stakeholders alike. It can form the basis of discussion for ironing out kinks in the user workflow and inconsistencies in the user interface. It can go a long way to make the project <a id="_idIndexMarker485"/>management more efficient by preventing unnecessary rework when it's most costly – after features have been implemented.</p>
			<p>With enough of the design drafted, we can now select some of the assets we'll use while building the project.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor142"/>User stories</h2>
			<p>It is useful to break up <a id="_idIndexMarker486"/>the features into a set of "user stories" or bite-sized features that can be implemented incrementally, building up the project a piece at a time. In an agile-managed project, the team may choose a specific set of stories to accomplish in one- or two-week <em class="italic">sprints</em>. And these stories could be managed and tracked on a shared project board <a id="_idIndexMarker487"/>such as Trello (<a href="https://trello.com/">https://trello.com/</a>) or <a id="_idIndexMarker488"/>Jira (<a href="https://www.atlassian.com/software/jira">https://www.atlassian.com/software/jira</a>). Here are a set of stories for this project:</p>
			<ul>
				<li>When the app starts, I am prompted to scan the room while the device detects and tracks vertical walls in the environment.</li>
				<li>After tracking is established, I see a main menu with an <strong class="bold">Add</strong> button.</li>
				<li>When I press the <strong class="bold">Add </strong>button, I am presented with a selection of photos.</li>
				<li>When I choose a photo from the selection, I see the tracked vertical planes and I am prompted to tap to hang a framed photo (picture) on a wall.</li>
				<li>When the picture is instantiated, it hangs squarely upright and flush against the wall plane.</li>
				<li>When I tap on an existing virtual picture to begin editing the picture.</li>
				<li>When editing a picture, I see an edit menu with options to change the photo, change the frame, or remove the framed picture.</li>
				<li>When editing a picture, I can drag the picture to a new location.</li>
				<li>When editing a picture, I can pinch (using two fingers) to resize it. </li>
			</ul>
			<p>That seems like a good set of features. We'll try to get through the first half of them in this chapter and complete it in the next chapter. Let's get started.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor143"/>Getting started</h1>
			<p>To begin, we'll create a new<a id="_idIndexMarker489"/> scene named <code>ARGallery</code> using the <code>ARFramework</code> scene template, with the following steps:</p>
			<ol>
				<li>Select <strong class="bold">File | New Scene</strong>.</li>
				<li>In the <strong class="bold">New Scene</strong> dialog box, select the <strong class="bold">ARFramework</strong> template.</li>
				<li>Select <strong class="bold">Create</strong>.</li>
				<li>Select <code>Scenes/</code> folder in your project's <code>Assets</code> folder, give it the name <code>ARGallery</code>, and select <strong class="bold">Save</strong>. </li>
			</ol>
			<p>The new AR scene<a id="_idIndexMarker490"/> already has the following objects:</p>
			<ul>
				<li>An <strong class="bold">AR Session</strong> game object.</li>
				<li>An <strong class="bold">AR Session Origin</strong> rig with raycast manager and plane manager components. </li>
				<li><strong class="bold">UI Canvas</strong> is a screen space canvas with child panels Startup UI, Scan UI, Main UI, and NonAR UI. It has the UI Controller component script that we wrote.</li>
				<li><strong class="bold">Interaction Controller</strong> is a game object with the Interaction Controller component script we wrote that helps the app switch between interaction modes, including Startup, Scan, Main, and NonAR modes. It also has a <strong class="bold">Player Input</strong> component configured with the <strong class="bold">AR Input Actions</strong> asset we created previously.</li>
				<li>An <strong class="bold">OnboardingUX</strong> prefab from the AR Foundation Demos project that provides AR session status and feature detection status messages, and animated onboarding graphics prompts.</li>
			</ul>
			<p>We now have a plan for the AR gallery project, including a statement of objectives, use cases, and a UX design with some user stories to implement. With this scene, we're ready to go. Let's find a collection of photos we can work with and add them to the project.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor144"/>Collecting image data</h1>
			<p>In Unity, images can be <a id="_idIndexMarker491"/>imported for use in a variety of purposes. Textures are images that can be used for texturing the materials for rendering the surface of 3D objects. The UI uses images as sprites for button and panel graphics. For our framed photos, we're going to use images as… images.</p>
			<p>The most basic approach to using images in your application is to import them into your <code>Assets</code> folder and reference them as Unity textures. A more advanced solution would be to dynamically find and load them at runtime. In this chapter, we'll use the former technique and build the list of images into the application. Let's start by importing the photos you want to use.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor145"/>Importing photos to use</h2>
			<p>Go ahead and choose <a id="_idIndexMarker492"/>some images for your gallery from your favorites. Or you can use the images included with the files in this book's GitHub repository, containing a collection of freely usable nature photos found on Unsplash.com (<a href="https://unsplash.com/">https://unsplash.com/</a>) that I found, along with a photo of my own named <code>WinterBarn.jpg</code>. </p>
			<p>To import images into your project, use the following steps:</p>
			<ol>
				<li value="1">In the <code>Photos</code> by right-clicking, then selecting <strong class="bold">Create | Folder</strong>.</li>
				<li>From your Windows Explorer or OSX Finder, locate an image you want to use. Then drag the image file into Unity, dropping it in your <code>Photos/</code> folder. </li>
				<li>In the <strong class="bold">Inspector</strong> window, you can check the size of the imported image. Because we're using it in AR and on a relatively low-resolution mobile device, let's limit the max size to 1,024 pixels. Note that Unity requires textures be imported into a size that is a power of 2 for best compression and runtime optimization. In <a id="_idIndexMarker493"/>the <strong class="bold">Inspector</strong>, ensure the <strong class="bold">Default</strong> tab is selected and choose <strong class="bold">Max Size | 1024</strong>.</li>
			</ol>
			<p>Now we'll add a way to reference your images in the scene.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor146"/>Adding image data to the scene</h2>
			<p>To add the image data to <a id="_idIndexMarker494"/>the scene, we'll create an empty GameObject with an <code>ImagesData</code> script that contains a list of images. First, create a new C# script in <a id="_idIndexMarker495"/>your project's <code>Scripts/</code> folder, name it <code>ImagesData</code>, and write it as follows:</p>
			<pre>using UnityEngine;
[System.Serializable]
public struct ImageInfo
{
    public Texture texture;
    public int width;
    public int height;
}
public class ImagesData : MonoBehaviour
{
    public ImageInfo[] images;
}</pre>
			<p>The script starts by defining an <code>ImageInfo</code> data structure containing the image <code>Texture</code> and the pixel dimensions of the image. It is <code>public</code> so it can be referenced from other scripts. Then the <code>ImagesData</code> class declares an array of this data in the <code>images</code> variable. The <code>ImageInfo</code> structure requires a <code>[System.Serializable]</code> directive so it will appear in the Unity Inspector.</p>
			<p>Now we can add the<a id="_idIndexMarker496"/> image data to the scene, using the following steps:</p>
			<ol>
				<li value="1">From the <a id="_idIndexMarker497"/>main menu, select <code>Images Data</code> (reset its <strong class="bold">Transform</strong> for tidiness, using the 3-dot context menu and <strong class="bold">Reset</strong>).</li>
				<li>Drag the <strong class="bold">ImagesData</strong> script onto the <strong class="bold">Images Data</strong> object, making it a component.</li>
				<li>To populate the <code>images</code> array, in the <strong class="bold">Inspector</strong>, enter the number of images you plan to use, or simply press the <strong class="bold">+</strong> button in the bottom right to incrementally add elements to the array.</li>
				<li>Add your imported image files one at a time by unfolding an <strong class="bold">Element</strong> from the <strong class="bold">Images</strong> list, then drag an image file from the <strong class="bold">Project</strong> window onto the <strong class="bold">Texture</strong> slot for the element. Please also enter the <strong class="bold">Width</strong> and <strong class="bold">Height</strong> in pixels of each image.<p>My <strong class="bold">Images Data</strong> looks like this in the <strong class="bold">Inspector</strong>:</p></li>
			</ol>
			<div><div><img src="img/Figure_6.02-ImagesData-inspector.jpg" alt="Figure 6.2 – Images Data component with a list of images&#13;&#10;" width="704" height="591"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Images Data component with a list of images</p>
			<p class="callout-heading">Using ScriptableObjects</p>
			<p class="callout">A different, and <a id="_idIndexMarker498"/>probably better, approach to providing the list of images is to use ScriptableObjects instead of GameObjects. ScriptableObjects are data container objects that live in your <code>Assets/</code> folder rather than in the scene hierarchy. You can learn more about <a id="_idIndexMarker499"/>ScriptableObjects at <a href="https://docs.unity3d.com/Manual/class-ScriptableObject.html">https://docs.unity3d.com/Manual/class-ScriptableObject.html</a> and <a href="https://learn.unity.com/tutorial/introduction-to-scriptable-objects">https://learn.unity.com/tutorial/introduction-to-scriptable-objects</a>.</p>
			<p>It is a little<a id="_idIndexMarker500"/> tedious having to manually enter the pixel dimensions of <a id="_idIndexMarker501"/>each image. It would be nice if there were a better way because that's not very easy.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor147"/>Obtaining the pixel dimensions of an image</h2>
			<p>Unfortunately, when Unity<a id="_idIndexMarker502"/> imports an image as a texture, it resizes it to <a id="_idIndexMarker503"/>a power of two to optimize runtime performance and compression, and the original dimension data is not preserved. There are several ways around this, none of which are very pretty:</p>
			<ul>
				<li>Require the developer to specify the pixel dimensions manually for each image. This is the approach we are taking here.</li>
				<li>Tell Unity to not resize the image when it is imported. For this, select an image asset, and in its <code>Texture.width</code> and <code>Texture.height</code>.</li>
				<li>Take the first method but automatically determine the pixel size using an Editor script. Unity allows you to write scripts that only run in the Editor, not runtime. The Editor has access to the original image file in your <strong class="bold">Assets</strong> folder before it has been imported as a texture. So it's possible to read and query this information, either using system I/O functions, or possibly (undocumented) the Unity API (see <a href="https://forum.unity.com/threads/getting-original-size-of-texture-asset-in-pixels.165295/">https://forum.unity.com/threads/getting-original-size-of-texture-asset-in-pixels.165295/</a>). </li>
			</ul>
			<p>Given that, we'll stick with the manual approach in this chapter, and you can explore the other options on your own.</p>
			<p>Perhaps you're also wondering, what if I don't want to build the images into my project and want to find and load them at runtime?</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor148"/>Loading the pictures list at runtime</h2>
			<p>Loading assets at runtime<a id="_idIndexMarker504"/> from outside your build is an advanced topic and outside the scope of this chapter. There are several different approaches that I will briefly describe, and I will point you to more information:</p>
			<ul>
				<li><strong class="bold">Including images in Asset Bundles</strong>: In Unity, you have the option of bundling assets into an Asset Bundle <a id="_idIndexMarker505"/>that the application can download after the user has installed the app, as <strong class="bold">downloadable content</strong> (<strong class="bold">DLC</strong>). See <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html">https://docs.unity3d.com/Manual/AssetBundlesIntro.html</a>.</li>
				<li><strong class="bold">Downloading images from a web URL</strong>: If you have the web address of an image file, you can <a id="_idIndexMarker506"/>download the image at runtime using a web request and use it as a texture in the app. See <a href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequestTexture.GetTexture.html">https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequestTexture.GetTexture.html</a>.</li>
				<li><strong class="bold">Getting images from the device's photos app</strong>: For an application such as our Gallery, it's natural to want to get photos from the user's own photos app. To access data from other apps on the mobile device you need a library with native access. It may also require your app to obtain additional permissions from the user. Search the Unity Asset Store for packages.</li>
			</ul>
			<p>If you want to implement these features, I'll leave that up to you.</p>
			<p>We have now imported the photos we plan to use, created a C# <code>ImageInfo</code> data structure including the pixel dimensions of each image, and populated this image data in the scene. Let's create a framed photo prefab containing a default image and a picture frame that we can place on a wall plane.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor149"/>Creating a framed photo prefab</h1>
			<p>The user will be placing a<a id="_idIndexMarker507"/> framed photo on their walls. So, we need to create a prefab game object that will be instantiated. We want to make it easy to change images and frames, as well as resize them for various orientations (landscape versus portrait) and image aspect ratios. For the default frame, we'll create a simple block from a flattened 3D cube and mount the photo on the face of it. For the default image, you may choose your own or use one that's included with the files for this chapter in the GitHub repository.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor150"/>Creating the prefab hierarchy</h2>
			<p>First, create an <a id="_idIndexMarker508"/>empty prefab named <code>FramedPhoto</code> in your project's <code>Assets/</code> folder. Follow these steps:</p>
			<ol>
				<li value="1">In the <code>Prefabs/</code> folder (create one if needed). Then <em class="italic">right-click</em> in the folder and select <strong class="bold">Create | Prefab</strong>. </li>
				<li>Rename the new prefab <code>FramedPhoto</code>.</li>
				<li><em class="italic">Double-click</em> the <strong class="bold">FramedPhoto</strong> asset (or click its <strong class="bold">Open Prefab</strong> button in the <strong class="bold">Inspector</strong> window).<p>We're now editing the empty prefab.</p></li>
				<li>Add a child <code>AspectScaler</code>.</li>
				<li>Let's create a modern-looking rectangular black frame using a flattened cube. With the <code>Frame</code>.</li>
				<li>Give the frame some thickness. In the frame's <code>0.05</code> (that's in meters).</li>
				<li>Likewise, offset it from the wall by setting <code>-0.025</code>.</li>
				<li>To give this frame a black finish, create and add a new material as follows.<p>In the <code>Materials/</code> folder (create one if needed). Then <em class="italic">right-click</em> in the folder and select <code>Black Frame Material</code>.</p></li>
				<li>Set its <strong class="bold">Base Map</strong> color to a charcoal black color.</li>
				<li>Then, in the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Default Frame</strong> object and drag the <strong class="bold">Black Frame Material</strong> onto it.</li>
			</ol>
			<p>The current frame <a id="_idIndexMarker509"/>properties are shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.03-FrameProperties.jpg" alt="Figure 6.3 – The FramedPhoto's frame properties&#13;&#10;" width="577" height="520"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The FramedPhoto's frame properties</p>
			<p>Next, we'll add a default image to the <code>WinterBarn.jpg</code> that is included with the files for this book. Use the following steps to create an image object with a material that uses this photo as its texture image:</p>
			<ol>
				<li value="1">With the <code>Image</code>. A <strong class="bold">quad</strong> is the simplest Unity 3D primitive object, a flat quadrilateral plane with only four edges and facing in a single direction.</li>
				<li>To add your image as a texture on the quad, we need to create a material. In the <code>Materials/</code> folder, <em class="italic">right-click</em> in the folder and select <code>Image Material</code>.</li>
				<li>Drag your image file (<code>WinterBarn.jpg</code>) from the <strong class="bold">Project</strong> window into the <strong class="bold">Inspector</strong> window, dropping it onto the little square "chip" slot on the left side of the <strong class="bold">Base Map</strong> property.</li>
				<li>Drag the <strong class="bold">Image Material</strong> onto the <strong class="bold">Image</strong> game object.</li>
				<li>Offset the <a id="_idIndexMarker510"/>image quad so it's slightly in front of the frame cube's plane. Set its <code>-0.06</code>.</li>
				<li>You should be able to see the image now. But the frame is hidden because the image quad is scaled to the same size as the frame. Shrink the image by setting its <code>0.9</code>.</li>
			</ol>
			<p>The prefab hierarchy now looks like the following screenshot, where the image is currently selected and visible in the <strong class="bold">Inspector</strong>:</p>
			<div><div><img src="img/Figure_6.04-FramedPhoto-prefab.jpg" alt="Figure 6.4 – The FramedPhoto prefab&#13;&#10;" width="1147" height="546"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The FramedPhoto prefab</p>
			<p>Next, let's add a simple <a id="_idIndexMarker511"/>script that will help our other code set the image of a <strong class="bold">FramedPhoto</strong> object.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor151"/>Writing a FramedPhoto script</h2>
			<p>We are going to need to set<a id="_idIndexMarker512"/> various properties of each instance of the <code>SetImage</code> function for this that gets the image data for this picture.</p>
			<p>Create a new C# script named <code>FramedPhoto</code>, open it for editing, and write the script as follows::</p>
			<pre>using UnityEngine;
public class FramedPhoto : MonoBehaviour
{
    [SerializeField] Transform scalerObject;
    [SerializeField] GameObject imageObject;
    ImageInfo imageInfo;
    public void SetImage(ImageInfo image)
    {
        imageInfo = image;
        Renderer renderer =             imageObject.GetComponent&lt;Renderer&gt;();
        Material material = renderer.material;
        material.SetTexture("_BaseMap", imageInfo.texture);
    }
}</pre>
			<p>At the top of the <code>FramedPhoto</code> class, we declare two properties. The <code>imageObject</code> is a reference to the child <code>scalerObject</code> is a reference to the <strong class="bold">AspectScaler</strong> for when the script needs to change its aspect ratio (we do this at the end of this chapter).</p>
			<p>When a <code>SetImage</code> to change the <code>Renderer</code>, then gets its <code>Material</code>, and then sets its base texture.</p>
			<p>We can now add this script to the prefab as follows:</p>
			<ol>
				<li value="1">With the <strong class="bold">FramedPhoto</strong> prefab opened for editing, drag the <strong class="bold">FramedPhoto</strong> script onto the <strong class="bold">FramedPhoto</strong> root object to make it a component.</li>
				<li>From the <strong class="bold">Hierarchy</strong>, drag the <strong class="bold">AspectScaler</strong> object into the <strong class="bold">Inspector</strong> and drop it onto the <strong class="bold">Framed Photo | Scaler Object</strong> slot.</li>
				<li>From the <strong class="bold">Hierarchy</strong>, drag <a id="_idIndexMarker514"/>the <strong class="bold">Image</strong> object onto the <strong class="bold">Framed Photo | Image Object</strong> slot.</li>
			</ol>
			<p>Our prefab is now almost ready to be used. Of course, the picture we're using isn't really supposed to be square, so let's scale it.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor152"/>Scaling the picture's shape</h2>
			<p>The photo I'm using <a id="_idIndexMarker515"/>by default is landscape orientation, but our frame is square, so it looks squished. To fix it, we need to get the original pixel size of the image and calculate its aspect ratio. For example, the <code>WinterBarn.jpg</code> image included on GitHub for this book is 4,032x3,024 (width x height), or 3:4 (<code>height:width</code> landscape ratio). Let's scale it now for the image's aspect ratio (<code>0.75</code>). Follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Scaler</strong> object.</li>
				<li>Set its <code>0.75</code> (if your image is portrait, scale the <code>1.0</code>).<p>The properly scaled prefab now looks like the following:</p><div><img src="img/Figure_6.05-FramedPhoto-aspect.jpg" alt="Figure 6.5 – FramedPhoto prefab with corrected 3:4 landscape aspect ratio&#13;&#10;" width="567" height="438"/></div><p class="figure-caption">Figure 6.5 – FramedPhoto prefab with corrected 3:4 landscape aspect ratio</p></li>
				<li>Save the prefab by clicking the <strong class="bold">Save</strong> button in the top-right of the <strong class="bold">Scene</strong> window.</li>
				<li>Return to the<a id="_idIndexMarker516"/> scene editor using the <strong class="bold">&lt;</strong> button in the top-left of the <strong class="bold">Hierarchy</strong> window. </li>
				<li>Setting up the <code>1, 1, 1</code>) regardless of the aspect ratio of the photo within it or the thickness of the frame. This will help with the user interface for placing and scaling the framed photo in the scene.</li><li>The <code>0.75</code> height for the 3:4 aspect ratio.</li><li>The <code>0.05</code> size border, so the <code>0.9</code>.</li><li>The front-back offset of the image will also depend on the frame's model. In this case, I moved it closer, <code>-0.06</code> versus <code>-0.025</code> units, so it sits slightly in front of the frame's surface.</li></ul></li>
			</ol>
			<p>When assembling a prefab, thinking through how it can head off gotchas later.</p>
			<p>In this section, we<a id="_idIndexMarker517"/> created a scalable <code>Assets</code> folder so copies can be instantiated in the scene when the user places a picture on a wall. The prefab includes a <code>FramedPhoto</code> script that manages some aspects of the behavior of the prefab, including setting its image texture. This script will be expanded later in the chapter. We now have a <strong class="bold">FramedPhoto</strong> prefab with a frame. We're ready to add the user interaction for placing pictures on your walls.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor153"/>Hanging a virtual photo on your wall</h1>
			<p>For this project, the app<a id="_idIndexMarker518"/> scans the environment for vertical planes. When the user wants to hang a picture on the wall, we'll show a UI panel that instructs the user to tap to place the object, using an animated graphic. Once the user taps the screen, the <strong class="bold">AddPicture</strong> mode instantiates a <strong class="bold">FramedPhoto</strong> prefab, so it appears to hang on the wall, upright and flush against the wall plane. Many of these steps are similar to what we did in <a href="B15145_05_Final_SB_epub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Using the AR User Framework</em>, so I'll offer a little less explanation here. We'll start with a similar script and then enhance it.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor154"/>Detecting vertical planes</h2>
			<p>Given the AR Session Origin <a id="_idIndexMarker519"/>already has an AR Plane Manager component (provided in the default <code>ARFramework</code> template), use the following steps to set up the scene to scan for vertical planes (instead of horizontal ones):</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> object.</li>
				<li>In its <strong class="bold">Inspector</strong> window, set the <strong class="bold">AR Plane Manager | Detection Mode</strong> to <strong class="bold">Vertical</strong> by first selecting <strong class="bold">Nothing</strong> (clearing all the selections) and then selecting <strong class="bold">Vertical</strong>.</li>
			</ol>
			<p>Now let's create the <strong class="bold">AddPicture</strong> UI panel that prompts the user to tap a vertical plane to place a new picture.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor155"/>Creating the AddPicture UI panel</h2>
			<p>The <strong class="bold">AddPicture UI</strong> panel is <a id="_idIndexMarker520"/>similar to the <strong class="bold">Scan UI</strong> one included with the scene template, so we can duplicate and modify it as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong>.</li>
				<li><em class="italic">Right-click</em> the <code>AddPicture UI</code>.</li>
				<li>Unfold <strong class="bold">AddPicture UI</strong> and select its child, <strong class="bold">Animated Prompt</strong>.</li>
				<li>In the <strong class="bold">Inspector</strong>, set the <strong class="bold">Animated Prompt | Instruction</strong> to <strong class="bold">Tap To Place</strong>.</li>
				<li>To add the panel to the UI Controller, in the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">UI Canvas</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, at the bottom-right of the <strong class="bold">UI Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the UI Panels dictionary.</li>
				<li>Enter <code>AddPicture</code> in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">AddPicture UI</strong> game object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Value</strong> slot.</li>
			</ol>
			<p>We added an <a id="_idIndexMarker521"/>instructional user prompt for the <strong class="bold">AddPicture</strong> UI. When the user chooses to add a picture to the scene, we'll go into <strong class="bold">AddPicture</strong> mode, and this panel will be displayed. Let's create the <strong class="bold">AddPicture</strong> mode now.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor156"/>Writing the initial AddPictureMode script</h2>
			<p>To add a mode to the <a id="_idIndexMarker522"/>framework, we create a child GameObject under the <strong class="bold">Interaction Controller</strong> and write a mode script. The mode script will show the mode's UI, handle any user interactions, and then transition to another mode when it is done. For AddPicture mode, it will display the <strong class="bold">AddPicture UI</strong> panel, wait for the user to tap the screen, instantiate the prefab object, and then return to main mode. </p>
			<p>The script starts out like the <code>PlaceObjectMode</code> script we wrote in <a href="B15145_05_Final_SB_epub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Using the AR User Framework</em>. Then we'll enhance it to ensure the framed picture object is aligned with the wall plane, facing into the room, and hanging straight.</p>
			<p>Let's write the <code>AddPictureMode</code> script, as follows:</p>
			<ol>
				<li value="1">Begin by creating a new script in your project's <code>Scripts/</code> folder by right-clicking and selecting <code>AddPictureMode</code>.</li>
				<li><em class="italic">Double-click</em> the file to open it for editing. Paste the following code, which is the same as the <strong class="bold">PlaceObjectMode</strong> script you may already have to hand, with differences highlighted. The first half of the script is as follows:<pre>using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;
public class <strong class="bold">AddPictureMode</strong> : MonoBehaviour
{
    [SerializeField] ARRaycastManager raycaster;
    <strong class="bold">[SerializeField]</strong> GameObject placedPrefab;
    List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();
    void OnEnable()
    {
        UIController.ShowUI("<strong class="bold">AddPicture</strong>");
    }</pre></li>
				<li>The second<a id="_idIndexMarker523"/> part of the script is actually unchanged from the <code>PlaceObjectMode</code> script:<pre>    public void OnPlaceObject(InputValue value)
    {
        Vector2 touchPosition = value.Get&lt;Vector2&gt;();
        PlaceObject(touchPosition);
    }
    void PlaceObject(Vector2 touchPosition)
    {
        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))
        {
            Pose hitPose = hits[0].pose;
            Instantiate(placedPrefab, hitPose.position,                hitPose.rotation);
            InteractionController.EnableMode("Main");
        }
    }
}</pre></li>
			</ol>
			<p>At the top of <code>AddPictureMode</code>, we declare a <code>placedPrefab</code> variable that will reference the <code>ARRaycastManager</code> and a private list of <code>ARRaycaseHit hits</code> that we'll use in <a id="_idIndexMarker524"/>the <code>PlaceObject</code> function.</p>
			<p>When the mode is enabled, we show the <code>AddPicture</code> UI panel. Then, when there's an <code>OnPlaceObject</code> user input action event, <code>PlaceObject</code> does a <code>Raycast</code> on the trackable planes. If there's a hit, it instantiates a copy of the <strong class="bold">FramedPhoto</strong> into the scene, and then goes back to main mode.</p>
			<p>Let's go with this initial script for now and fix any problems we discover later. The next step is to add the AddPicture mode to the app.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor157"/>Creating the AddPicture Mode object</h2>
			<p>We can now add <a id="_idIndexMarker525"/>the AddPicture mode to the scene by creating an <strong class="bold">AddPicture Mode</strong> object under the <strong class="bold">Interaction Controller</strong>, as follows:</p>
			<ol>
				<li value="1">In the <code>AddPicture Mode</code>.</li>
				<li>Drag the <code>AddPictureMode</code> script from the <strong class="bold">Project</strong> window onto the <strong class="bold">AddPicture Mode</strong> object, adding it as a component.</li>
				<li>Drag the <strong class="bold">AR Session Origin</strong> object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Add Picture Mode | Raycaster</strong> slot.</li>
				<li>Locate your <strong class="bold">FramedPhoto Prefab</strong> asset in the <strong class="bold">Project</strong> window and drag it onto the <strong class="bold">Add Picture Mode | Placed Prefab</strong> slot. The <strong class="bold">AddPicture Mode</strong> component now looks like the following (note that this screenshot also shows two more parameters, <strong class="bold">Image Data</strong> and <strong class="bold">Default Scale</strong>, that we add to the script at the end of this chapter):<div><img src="img/Figure_6.06-addpicturemode-insp.jpg" alt="Figure 6.6 – AddPicture Mode added to the scene&#13;&#10;" width="857" height="312"/></div><p class="figure-caption">Figure 6.6 – AddPicture Mode added to the scene</p></li>
				<li>Now we'll add<a id="_idIndexMarker526"/> the mode to the <strong class="bold">Interaction Controller</strong>. In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Interaction Controller</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, at the bottom-right of the <strong class="bold">Interaction Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the <strong class="bold">Interaction Modes</strong> dictionary.</li>
				<li>Enter <code>AddPicture</code> in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">AddPicture Mode</strong> game object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Value</strong> slot. The Interaction Controller component now looks like the following:</li>
			</ol>
			<div><div><img src="img/Figure_6.07-interactioncont-addpicture.jpg" alt="Figure 6.7 – Interaction Controller with AddPicture Mode added to the Interaction Modes dictionary&#13;&#10;" width="592" height="355"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Interaction Controller with AddPicture Mode added to the Interaction Modes dictionary</p>
			<p>We now have<a id="_idIndexMarker527"/> an <strong class="bold">AddPicture</strong> mode that will be enabled from <strong class="bold">Main</strong> mode when the user clicks an <strong class="bold">Add</strong> button. Let's create this button now.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor158"/>Creating a main menu Add button</h2>
			<p>When the app is in<a id="_idIndexMarker528"/> Main mode, the <strong class="bold">Main UI</strong> panel is displayed. On this panel, we'll have an <strong class="bold">Add</strong> button for the user to press when they want to place a new picture in the scene. I'll use a large plus sign as its icon, with the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong> object, and unfold its child <strong class="bold">Main UI</strong> object.</li>
				<li>The default child text in the panel is a temporary placeholder; we can remove it. <em class="italic">Right-click</em> the child <strong class="bold">Text</strong> object and select <strong class="bold">Delete</strong>.</li>
				<li>Now we add a button.<em class="italic"> Right-click</em> the <code>Add Button</code>.</li>
				<li>With the <strong class="bold">Add Button</strong> selected, in its <strong class="bold">Inspector</strong> window use the <em class="italic">anchor menu</em> (upper-left) to select a <strong class="bold">Bottom-Right</strong> anchor. Then press <em class="italic">Shift + Alt +</em> click <strong class="bold">Bottom-Right</strong> to also set its <strong class="bold">Pivot</strong> and <strong class="bold">Position</strong> in that corner.</li>
				<li>Adjust the button size and position, either using the <em class="italic">Rect Tool</em> from the <code>175, 175</code>), and<code>-30, 30</code>), as shown in the<a id="_idIndexMarker529"/> following screenshot:<div><img src="img/Figure_6.08-Addbutton-recttransform-insp.jpg" alt="Figure 6.8 – The Add button Rect Transform settings&#13;&#10;" width="844" height="322"/></div><p class="figure-caption">Figure 6.8 – The Add button Rect Transform settings</p></li>
				<li>In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">Add Button</strong> by clicking its <em class="italic">triangle-icon</em> and select its child object, <strong class="bold">Text (TMP)</strong>. </li>
				<li>Set its <code>+</code> and set its <code>192</code>.</li>
				<li>You can add another text element to label the button. <em class="italic">Right-click</em> the <code>Add</code>, <code>24</code>, <code>55</code>.<p>Our button now looks like the following:</p><div><img src="img/Figure_6.09-AddButton-view.jpg" alt="Figure 6.9 – The Add button&#13;&#10;" width="482" height="212"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 6.9 – The Add button</p></li>
				<li>To set up the<a id="_idIndexMarker530"/> button to enable <strong class="bold">PlacePicture Mode</strong>, select the <strong class="bold">Add Button</strong> in the <strong class="bold">Hierarchy</strong>. In its <strong class="bold">Inspector</strong>, in the <strong class="bold">OnClick</strong> section of the <strong class="bold">Button</strong> component, press the <strong class="bold">+</strong> button on the bottom-right to add an event action.</li>
				<li>Drag the <strong class="bold">Interaction Controller</strong> from the <strong class="bold">Hierarchy</strong> and drop it onto the <strong class="bold">Object</strong> slot of the <strong class="bold">OnClick</strong> action.</li>
				<li>In the <strong class="bold">Function</strong> select list, choose <strong class="bold">InteractionController | EnableMode</strong>.</li>
				<li>In its string parameter field, enter the text <code>AddPicture</code>.</li>
			</ol>
			<p>The <strong class="bold">On Click</strong> property of now looks like this:</p>
			<div><div><img src="img/Figure_6.10-Addbutton-onclick.jpg" alt="Figure 6.10 – When the Add button is clicked, it calls EnableMode(&quot;AddPicture&quot;)&#13;&#10;" width="493" height="115"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – When the Add button is clicked, it calls EnableMode("AddPicture")</p>
			<p>We have now added <strong class="bold">AddPicture Mode</strong> to our framework. It will be enabled by the Interaction Controller when the <strong class="bold">Add</strong> button is clicked. When enabled, the script shows the <strong class="bold">AddPicture</strong> instructional UI, then waits for a <strong class="bold">PlaceObject</strong> input action event. Then it uses Raycast to<a id="_idIndexMarker531"/> determine where in 3D space the user wants to place the object, instantiates the prefab, and then returns to Main mode. Let's try it out.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor159"/>Build And Run</h2>
			<p>Save the scene. If you<a id="_idIndexMarker532"/> want to try and see how it looks, you can now <strong class="bold">Build And Run</strong>, as follows:</p>
			<ol>
				<li value="1">Select <strong class="bold">File | Build Settings</strong>.</li>
				<li>Click the <code>ARGallery</code>) is not already in the <strong class="bold">Scenes In Build</strong> list.</li>
				<li>Ensure that the <code>ARGallery</code> scene is the only one checked in the <strong class="bold">Scenes In Build</strong> list.</li>
				<li>Click <strong class="bold">Build And Run</strong> to build the project.</li>
			</ol>
			<p>The app will start and prompt you to scan the room. Slowly move your device around to scan the room, concentrating on the general area of the walls where you want to place the photos. </p>
			<p class="callout-heading">What makes for good plane detection?</p>
			<p class="callout">When AR plane detection uses the<a id="_idIndexMarker533"/> device's built-in white light camera for scanning the 3D environment, it relies on good visual fidelity of the camera image. The room should be well lit. The surfaces being scanned should have distinctive and random textures to assist the detection software. For example, our AR Gallery project may have difficulty detecting vertical planes if your walls are too smooth. (Newer devices may include other sensors, such as laser-based <strong class="bold">LIDAR</strong> depth sensors<a id="_idIndexMarker534"/> that don't suffer from these limitations). If your device has trouble detecting vertical wall planes, try strategically adding some sticky notes or other markers on the walls to make the surfaces more distinctive to the software.</p>
			<p>When at least one vertical plane is detected, the scan prompt will disappear, and you'll see the Main UI <strong class="bold">Add</strong> button. Tapping the <strong class="bold">Add</strong> button will enable <strong class="bold">AddPicture Mode</strong>, showing the <strong class="bold">AddPicture</strong> UI panel with its tap-to-place instructional graphic. When you tap a tracked plane, the <strong class="bold">FramedPhoto</strong> prefab will be instantiated in the scene. Here's what mine looks like, on<a id="_idIndexMarker535"/> the left side:</p>
			<div><div><img src="img/Figure_6.11-PlaceOnWall.jpg" alt="Figure 6.11 – Placing an object on the wall (left) and correcting for surface normal and upright (right)&#13;&#10;" width="1036" height="1013"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Placing an object on the wall (left) and correcting for surface normal and upright (right)</p>
			<p>Oops! The picture is sticking out of the wall perpendicularly, as shown in the preceding screenshot (on the left side). We want it to hang like a picture on the wall like in the right-hand image. Let's update the script to take care of this.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor160"/>Completing the AddPictureMode script</h2>
			<p>There are a number of <a id="_idIndexMarker536"/>improvements we need to implement to complete the <code>AddPictureMode</code> script, including the following:</p>
			<ul>
				<li>Rotate the picture so it is upright and flat against the wall plane.</li>
				<li>Tell the picture which image to show in its frame.</li>
				<li>Include a default scale when the picture is first placed on a wall.</li>
			</ul>
			<p>The <code>AddPictureMode</code> script contains the following line in the code that sets the rotation to <code>hitPose.rotation</code>:</p>
			<pre>Instantiate(placedPrefab, hitPose.position, hitPose.rotation);</pre>
			<p>As you can see in the previous screenshot, the "up" direction of a tracked plane is perpendicular to the surface of the plane, so with this code the picture appears to be sticking out of the wall. It makes sense to instantiate a placed object using this default up direction for horizontal planes, where you want your object standing up on the floor or a table. But in this project, we don't want to do that. We want the picture to be facing in the same direction as the wall. And we want it hanging straight up/down.</p>
			<p>Instead of using <a id="_idIndexMarker537"/>the <code>hit.pose.rotation</code>, we should calculate the rotation using the plane's normal vector (<code>pose.up</code>). Then we call the <code>Quaternion.LookRotation</code> function to create a rotation with the specified forward and upward directions (see <a href="https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html">https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html</a>). </p>
			<p class="callout-heading">Quaternions</p>
			<p class="callout">A quaternion<a id="_idIndexMarker538"/> is a mathematical construct that can be used to represent rotations in computer graphics. As a Unity developer, you simply need to know that rotations in Transforms <a id="_idIndexMarker539"/>use the <code>Quaternion</code> class. See <a href="https://docs.unity3d.com/ScriptReference/Quaternion.html">https://docs.unity3d.com/ScriptReference/Quaternion.html</a>. However, if you'd like an explanation of the underlying math, check out the great videos by <em class="italic">3Blue1Brown</em> such as <em class="italic">Quaternions and 3D rotation, explained interactively</em> at <a href="https://www.youtube.com/watch?v=zjMuIxRvygQ">https://www.youtube.com/watch?v=zjMuIxRvygQ</a>.  </p>
			<p>Another thing we need is the ability to tell the FramedPhoto which image to display. We'll add a public variable for the <code>imageInfo</code> that will be set by the Image Select menu (developed in the next section of this chapter).</p>
			<p>Also, we will add a <code>defaultScale</code> property that scales the picture when it's instantiated. If you recall, we defined our prefab as normalized to 1 unit max size, which would make it 1 meter wide on the wall unless we scale it. We're only scaling the X and Y axes, leaving the Z at <code>1.0</code> so that the frame's depth is not scaled too. I'll set the default scale<a id="_idIndexMarker540"/> to <code>0.5</code>, but you can change it later in the Inspector.</p>
			<p>Modify the <code>AddPictureMode</code> script as follows:</p>
			<ol>
				<li value="1">Add the following declarations at the top of the class:<pre>    public ImageInfo imageInfo;
    [SerializeField] float defaultScale = 0.5f;</pre></li>
				<li>Replace the <code>PlaceObject</code> function with the following:<pre>    void PlaceObject(Vector2 touchPosition)
    {
        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))
        {
            ARRaycastHit hit = hits[0];
            Vector3 position = hit.pose.position;
            Vector3 normal = -hit.pose.up;
            Quaternion rotation = Quaternion.LookRotation                 (normal, Vector3.up);
            GameObject spawned = Instantiate(placedPrefab,                position, rotation);
            FramedPhoto picture =                 spawned.GetComponent&lt;FramedPhoto&gt;();
            picture.SetImage(imageInfo);
            spawned.transform.localScale = new                Vector3(defaultScale, defaultScale, 1.0f);
            InteractionController.EnableMode("Main");
        }
    }</pre></li>
				<li>Save the script and return to Unity.</li>
			</ol>
			<p>Note that I had to<a id="_idIndexMarker541"/> negate the wall plane normal vector (<code>-hit.pose.up</code>), because when we created our prefab, by convention, the picture is facing in the minus-Z direction.</p>
			<p>When you place a picture, it should now hang properly upright and be flush against the wall, as shown in right-hand panel of the screenshot at the top of this section.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor161"/>Showing tracked planes in AddPicture mode</h2>
			<p>Another <a id="_idIndexMarker542"/>enhancement might be to hide the tracked planes while in Main mode and show them while in <code>AddPicture</code> mode. This would allow the user to enjoy their image gallery without that distraction. Take a look at how we did that in the <em class="italic">Hiding tracked object when not needed</em> topic of <a href="B15145_05_Final_SB_epub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Using the AR User Framework</em>. At that time, we wrote a script, <code>ShowTrackablesOnEnable</code>, that we can use now too. Follow these steps:</p>
			<ol>
				<li value="1">With the <strong class="bold">AddPicture Mode</strong> game object selected in the <strong class="bold">Hierarchy</strong> (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>In the <code>ShowTrackablesOnEnable</code> script and drag it onto the <strong class="bold">AddPicture Mode</strong> object.</li>
				<li>From the <strong class="bold">Hierarchy</strong>, drag the <strong class="bold">AR Session Origin</strong> object into the <strong class="bold">Inspector</strong> and drop it onto the <strong class="bold">Show Trackables On Enable | Session Origin</strong> slot.</li>
			</ol>
			<p>That is all we need to implement this feature. </p>
			<p>To recap, we<a id="_idIndexMarker543"/> configured the scene to detect and track vertical planes, for the walls of your room. Then we created an <code>AddPictureMode</code> script. The script instantiates a copy of the <strong class="bold">FramedPhoto</strong> prefab when the user taps on a vertical plane. Then we improved the script by ensuring the picture is oriented flat on the wall and upright. The script also lets us change the image in the frame and its scale. Lastly, we display the trackable planes when in AddPicture mode and hide them when we return to Main mode.</p>
			<p>The next step is to give the user a choice to select an image before hanging a new picture on the wall. We can now go ahead and create an image select menu for the user to pick one to use.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor162"/>Selecting an image to use</h1>
			<p>The next thing we want to do is <a id="_idIndexMarker544"/>create an image select menu containing image buttons for the user to choose a photo before adding it to the scene. When the <code>ImageButtons</code> script that builds the menu using the <strong class="bold">Images</strong> list you've already added to the project (the <strong class="bold">Image Data</strong> game object). And then we'll insert the <strong class="bold">SelectImage</strong> mode before <strong class="bold">AddPicture</strong> mode, so the selected image is the one placed on the wall. Let's define the <strong class="bold">SelectImage</strong> mode first.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor163"/>Creating the SelectImage mode</h2>
			<p>When <code>SelectImage</code> mode is<a id="_idIndexMarker545"/> enabled by the user, all we need to do is display the SelectImage UI menu panel with buttons for the user to pick which image to use. Clicking a button will notify the mode script by calling the public function, <code>SetSelectedImage</code>, that in turn tells the <code>AddPictureMode</code> which image to use.</p>
			<p>Create a new C# script named <code>SelectImageMode</code> and write it as follows:</p>
			<pre>using UnityEngine;
public class SelectImageMode : MonoBehaviour
{
    void OnEnable()
    {
        UIController.ShowUI("SelectImage");
    }
}</pre>
			<p>Simple. When <code>SelectImageMode</code> is enabled, we display the <strong class="bold">SelectImage UI </strong>panel (containing the buttons menu).</p>
			<p>Now we can<a id="_idIndexMarker546"/> add it to the <strong class="bold">Interaction Controller</strong> as follows:</p>
			<ol>
				<li value="1">In the <code>SelectImage Mode</code>.</li>
				<li>Drag the <code>SelectImageMode</code> script from the <strong class="bold">Project</strong> window onto the <strong class="bold">SelectImage Mode</strong> object adding it as a component.</li>
				<li>Now we'll add the mode to the <strong class="bold">Interaction Controller</strong>. In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Interaction Controller</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, at the bottom-right of the <strong class="bold">Interaction Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the <strong class="bold">Interaction Modes</strong> dictionary.</li>
				<li>Enter <code>SelectImage</code> in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">SelectImage Mode</strong> game object <a id="_idIndexMarker547"/>from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Value</strong> slot. The <strong class="bold">Interaction Controller</strong> component now looks like the following:</li>
			</ol>
			<div><div><img src="img/Figure_6.12_(new).jpg" alt="Figure 6.12 – Interaction Controller with SelectImage Mode added&#13;&#10;" width="716" height="501"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Interaction Controller with SelectImage Mode added</p>
			<p>Next, we'll add the UI for this mode.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor164"/>Creating the Select Image UI panel</h2>
			<p>To <a id="_idIndexMarker548"/>create the <strong class="bold">SelectImage UI</strong> panel, we'll duplicate the existing <strong class="bold">Main UI</strong> and adapt it. The panel will include a Header title and <strong class="bold">Cancel</strong> button. Follow these steps:</p>
			<ol>
				<li value="1">In the <code>SelectImage UI</code>. Delete any child objects, including <strong class="bold">Add Button</strong>, using <em class="italic">right-click</em> <strong class="bold">Delete</strong>.</li>
				<li>Make the panel size a little smaller than fullscreen so it looks like a modal popup. In its <code>50</code>. Set the <code>150</code> to leave room for the app title.</li>
				<li>We want this panel to have a solid background so on its <strong class="bold">Image</strong> component, select <strong class="bold">Component | UI | Image</strong> from the main menu. </li>
				<li>Create a menu header sub-panel. In the <code>Header</code>.</li>
				<li>Position and stretch the <code>100</code>.</li>
				<li><em class="italic">Right-click</em> the <code>Header Text</code>.</li>
				<li>On the <code>Select Image</code>, <code>48</code>, <strong class="bold">Alignment</strong> to <strong class="bold">Center</strong> and <strong class="bold">Middle</strong>, and <strong class="bold">Anchor Presets</strong> to <strong class="bold">Stretch-Stretch</strong>. Also, <em class="italic">Alt + Shift +</em> click <strong class="bold">Stretch-Stretch</strong>.</li>
				<li>We'll also add a <code>Cancel Button</code>.</li>
				<li>Set the Cancel button's <code>80</code> and <code>-20</code>. Also set its <strong class="bold">Image | Color</strong> to a light gray color.</li>
				<li>For the <code>X</code> and <code>48</code>.</li>
				<li>With the <strong class="bold">Cancel Button</strong> selected in <strong class="bold">Hierarchy</strong>, in its <strong class="bold">Inspector</strong> click the <strong class="bold">+</strong> button<a id="_idIndexMarker549"/> on the bottom-right of the <strong class="bold">Button | OnClick</strong> actions.</li>
				<li>Drag the <strong class="bold">Interaction Controller</strong> game object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">OnClick</strong> <strong class="bold">Object</strong> slot.</li>
				<li>From the <code>Main</code> in the text parameter field. The <strong class="bold">X</strong> cancel button will now send you back to Main mode.</li>
			</ol>
			<p>The header of the <strong class="bold">SelectImage</strong> UI panel is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.13-SelectImageHeader.jpg" alt="Figure 6.13 – The header panel of the SelectImage UI&#13;&#10;" width="213" height="61"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – The header panel of the SelectImage UI</p>
			<p>Next, we'll add a panel to contain the image buttons that will display photos for the user to pick. These will be laid out in a grid. Use the following steps:</p>
			<ol>
				<li value="1">In the <code>Image Buttons</code>.</li>
				<li>On the <strong class="bold">Image Buttons</strong> panel, uncheck its <strong class="bold">Image</strong> component or remove it. We don't need a separate background.</li>
				<li>Its <code>100</code>.</li>
				<li>Select <code>layout</code> and add a <strong class="bold">Grid Layout Group</strong> component.</li>
				<li>On the <code>20, 20, 20, 20</code>, set <code>200, 200</code>, and set <code>20, 20</code>. Set <strong class="bold">Child Alignment</strong> to <strong class="bold">Upper Center</strong>.</li>
			</ol>
			<p>We now have an <strong class="bold">ImageSelect UI</strong> panel with a header and a container for the image buttons. Parts of the<a id="_idIndexMarker550"/> current hierarchy are shown in the following screenshot:</p>
			<div><div><img src="img/Figure_6.14-uicanvas-selectimage-hier.jpg" alt="Figure 6.14 –UI Canvas with SelectImage UI, and Interaction Controller with SelectImage Mode&#13;&#10;" width="218" height="330"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 –UI Canvas with SelectImage UI, and Interaction Controller with SelectImage Mode</p>
			<p>Lastly, we need to add the panel to the UI Controller as follows:</p>
			<ol>
				<li value="1">To add the panel to the UI Controller, in the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">UI Canvas</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, at the bottom-right of the <strong class="bold">UI Controller</strong> component, click the <strong class="bold">+</strong> button to add an item to the <strong class="bold">UI Panels</strong> dictionary.</li>
				<li>Enter <code>SelectImage</code> in the <strong class="bold">Id</strong> field.</li>
				<li>Drag the <strong class="bold">SelectImage UI</strong> game object from the <strong class="bold">Hierarchy</strong> onto the <strong class="bold">Value</strong> slot.</li>
			</ol>
			<p>We now have a UI <a id="_idIndexMarker551"/>panel with a container for the image buttons. To make the buttons, we'll create a prefab and then write a script to populate the <strong class="bold">Image Buttons</strong> panel. </p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor165"/>Creating an Image Button prefab</h2>
			<p>We will <a id="_idIndexMarker552"/>define an <strong class="bold">Image Button</strong> as a prefab so it can be duplicated for each image that we want to provide to the user in the selection menu. Create the button as follows:</p>
			<ol>
				<li value="1">In the <code>Image Button</code>.</li>
				<li>Under the <strong class="bold">Image Button</strong>, delete its child <strong class="bold">Text</strong> element.</li>
				<li>On the <strong class="bold">Image Button</strong>, remove its <strong class="bold">Image</strong> component (using <em class="italic">right-click</em> and <strong class="bold">Remove Component</strong>) and then press <strong class="bold">Add Component</strong>. Search and add a <strong class="bold">Raw Image</strong> component instead.</li>
				<li>Its <strong class="bold">Button</strong> component needs a reference to its graphic that we just replaced. In the <strong class="bold">Inspector</strong>, drag the <strong class="bold">Raw Image</strong> component onto <strong class="bold">Button | Target Graphic</strong> slot.</li>
				<li>Now drag your default image texture, such as the <code>WinterBarn</code> asset, from the <code>Photos/</code> folder into the <strong class="bold">Inspector</strong> and drop it onto the <strong class="bold">Raw Image | Texture</strong> slot.<p class="callout-heading">UI Image versus Raw Image</p><p class="callout">An <strong class="bold">Image</strong> component takes an image sprite for its graphic. A <strong class="bold">Raw Image</strong> component takes a texture for its graphic. Sprites are small, highly efficient, preprocessed images used for UI and 2D applications. Textures tend to be larger with more pixel depth and fidelity used for 3D rendering and photographic images. You can change an imported image between these and other type using the image file's Inspector properties. To use the same photo asset (PNG files) for both the FramedPhoto prefab and the button, we're using a Raw Image component on the buttons.</p></li>
				<li>Let's save <a id="_idIndexMarker553"/>the <code>Prefabs/</code> folder. This creates a prefab asset and changes its color in the <strong class="bold">Hierarchy</strong> to blue, indicating it's a prefab instance.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, <em class="italic">right-click</em> the <strong class="bold">Image Button</strong> object, select <strong class="bold">Duplicate</strong> (or press <em class="italic">Ctrl/Option + D</em> on the keyboard), and make several copies. Because the buttons are parented by the <strong class="bold">Image Buttons</strong> panel that has a <strong class="bold">Grid Layout Group</strong>, they are rendered in a grid, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_6.15-SelectImageGrid.jpg" alt="" width="455" height="351"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Select image panel with Image Buttons in a grid layout</p>
			<p>Next, we'll write a script to populate the buttons with actual images we want to use.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor166"/>Writing an ImageButtons script</h2>
			<p>The <code>ImageButtons</code> script will <a id="_idIndexMarker554"/>be a component on the <code>ImageButtons</code>, open it for editing, and write it as follows:</p>
			<pre>using UnityEngine;
using UnityEngine.UI;
public class ImageButtons : MonoBehaviour
{
    [SerializeField] GameObject imageButtonPrefab;
    [SerializeField] ImagesData imagesData;
    [SerializeField] AddPictureMode addPicture;
    void Start()
    {
        for (int i = transform.childCount - 1; i &gt;= 0; i--)
        {
            GameObject.Destroy(                transform.GetChild(i).gameObject);
        }
        foreach (ImageInfo image in imagesData.images)
        {
            GameObject obj =                 Instantiate(imageButtonPrefab,transform);
            RawImage rawimage = obj.GetComponent&lt;RawImage&gt;();
            rawimage.texture = image.texture;
            Button button = obj.GetComponent&lt;Button&gt;();
            button.onClick.AddListener(() =&gt; OnClick(image));
        }
    }
    void OnClick(ImageInfo image)
    {
        addPicture.imageInfo = image;
        InteractionController.EnableMode("AddPicture");
    } 
}</pre>
			<p>Let's go through this script. At <a id="_idIndexMarker555"/>the top of the class, we declare three variables. <code>imageButtonPrefab</code> will be a reference to the <code>imagesData</code> is a reference to the object containing our list of images. And <code>addPicture</code> is a reference to <code>AddPictureMode</code> for each button to tell which image has been selected.</p>
			<p>The first thing <code>Start()</code> does is clear out any child objects in the buttons panel. For example, we created a number of duplicates of the button to help us develop and visualize the panel, and they'll still be in the scene when it runs unless we remove them first.</p>
			<p>Then, <code>Start</code> loops through each of the images, and for each one, creates an <code>onClick</code> events.</p>
			<p>When one of the buttons is clicked, our <code>OnClick</code> function will be called, with that button's <code>image</code> as a parameter. We pass this <code>image</code> data to the <code>AddPictureMode</code> that will be used when <strong class="bold">AddPictureMode</strong> instantiates a new <strong class="bold">FramedPhoto</strong> object.</p>
			<p>Add the script to the scene as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Image Buttons</strong> object (under <strong class="bold">UI Canvas/Select Image Panel</strong>).</li>
				<li>Drag the <strong class="bold">ImageButtons</strong> script onto the <strong class="bold">Image Buttons</strong> object, making it a component.</li>
				<li>From the <strong class="bold">Project</strong> window, drag the <strong class="bold">Image Button</strong> prefab into the <strong class="bold">Inspector</strong> and drop it onto the <strong class="bold">Image Buttons | Image Button Prefab</strong> slot.</li>
				<li>From the <strong class="bold">Hierarchy</strong>, drag the <strong class="bold">AddPicture Mode</strong> object into the <strong class="bold">Inspector</strong> and drop it onto the <strong class="bold">Image Buttons | Add Picture</strong> slot.</li>
				<li>Also from the <strong class="bold">Hierarchy</strong>, drag the <strong class="bold">Images Data</strong> object and drop it onto the <strong class="bold">Image Buttons | Images Data</strong> slot.</li>
			</ol>
			<p>The <strong class="bold">Image Buttons</strong> component now <a id="_idIndexMarker556"/>looks like the following screenshot:</p>
			<div><div><img src="img/Figure_6.16-imagebuttons-insp.jpg" alt="Figure 6.16 – Image buttons panel with the ImageButtons script that builds the menu at runtime&#13;&#10;" width="973" height="722"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Image buttons panel with the ImageButtons script that builds the menu at runtime</p>
			<p>OK. When the app starts up, the <code>AddPictureMode</code> which image was selected, and then enabled AddPicture mode.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor167"/>Reroute the Add button</h2>
			<p>There is just one last step <a id="_idIndexMarker557"/>before we can try it out. Currently, the main menu's Add button enables AddPicture mode directly. We need to change it to call <strong class="bold">SelectImage</strong> instead, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Add</strong> button (located in <strong class="bold">UI Canvas</strong> / <strong class="bold">Main UI</strong>).</li>
				<li>In the <strong class="bold">Inspector</strong>, in the <strong class="bold">Button | On Click</strong> action list, change the <strong class="bold">EnableMode</strong> parameter from <strong class="bold">AddPicture</strong> to <strong class="bold">SelectImage</strong>.</li>
				<li>Save the scene.</li>
			</ol>
			<p>If you got all this right, you should be able to <strong class="bold">Build and Run</strong> the scene and run through the complete scenario: pressing the <strong class="bold">Add</strong> button will present a <strong class="bold">Select Image</strong> menu. Tapping an image, the select panel is replaced with a prompt to tap to place the image, with its frame, on a wall. The following screenshots from my phone show, on the left, the <strong class="bold">Select Image</strong> menu. After selecting an image and placing it on the wall, the result is shown on the right. Then the app returns to the main menu:</p>
			<div><div><img src="img/Figure_6.17-PlaceImageRun.jpg" alt="Figure 6.17 – Pressing the Add button, I see an image menu (left), and the result after placing (right)&#13;&#10;" width="957" height="939"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.17 – Pressing the Add button, I see an image menu (left), and the result after placing (right)</p>
			<p>To summarize, in this section we added the <code>ImageButtons</code> script that instantiates buttons for each image we want to include in the app. Clicking <a id="_idIndexMarker558"/>one of the buttons will pass the selected image data to <strong class="bold">AddPicture</strong> mode. When the user taps to place and a <strong class="bold">FramedPhoto</strong> is instantiated, we set the image to the one the user has selected. We also included a <strong class="bold">Cancel</strong> button in the menu so the user can cancel the add operation.</p>
			<p>This is looking good so far. One problem we have is all the pictures are rendered in the same sized landscape frame and thus may look distorted. Let's fix that.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor168"/>Adjusting for image aspect ratio</h1>
			<p>Currently, we're<a id="_idIndexMarker559"/> ignoring the actual size of the images and making them all fit into a landscape orientation with a 3:4 aspect ratio. Fortunately, we've included the actual (original) pixel dimensions of the image with our <code>ImageInfo</code>. We can use that now to scale the picture accordingly. We can make this change to the <code>FramedPhoto</code> script that's on the <strong class="bold">FramedPhoto</strong> prefab.</p>
			<p>The algorithm for calculating the aspect ratio can be separated as a utility function in the <code>ImagesData</code> script. Open the <code>ImagesData</code> script and add the following code:</p>
			<pre>    public static Vector2 AspectRatio(float width, float         height)
    {
        Vector2 scale = Vector2.one;
        if (width == 0 || height == 0) 
            return scale;
        if (width &gt; height)
        {
            scale.x = 1f;
            scale.y = height / width;
        }
        else
        {
            scale.x = width / height;
            scale.y = 1f;
        }
        return scale;
    }</pre>
			<p>When the <code>width</code> is larger than <code>height</code>, the image is landscape, so we'll keep the X scale at <code>1.0</code> and scale down Y. When the <code>height</code> is larger than the <code>width</code>, it is portrait, so we'll keep the Y scale at <code>1.0</code> and scale down X. If they're the same or zero, we return <code>(1,1)</code>. The function is declared <code>static</code> so it can be called using the <code>ImagesData</code> class name.</p>
			<p>Open the <code>FramedPhoto</code> script for<a id="_idIndexMarker560"/> editing and make the changes highlighted in the following:</p>
			<pre>    public void SetImage(ImageData image)
    {
        imageData = image;
        Renderer renderer =             imageObject.GetComponent&lt;Renderer&gt;();
        Material material = renderer.material;
        material.SetTexture("_BaseMap", imageData.texture);
        <strong class="bold">AdjustScale();</strong>
    }
<strong class="bold">    public void AdjustScale()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        Vector2 scale = ImagesData.AspectRatio(imageInfo.width,            imageInfo.height);</strong>
<strong class="bold">        scalerObject.localScale = new Vector3(scale.x, scale.y,            1f);</strong>
<strong class="bold">    }</strong></pre>
			<p>If you recall, the <code>SetImage</code> function is called by <code>AddPictureMode</code> immediately after a <code>ImageData.AspectRatio</code> to get the new local scale and updates the <code>scalerObject</code> transform.</p>
			<p>You may notice that the frame width is slightly different on the horizontal versus vertical sides when the picture is not square. Fixing this requires an additional adjustment to the <code>1.0 – 0.01/aspectratio</code>.  I'll leave that implementation up to you.</p>
			<p>When you run the project <a id="_idIndexMarker561"/>again and place a picture on your wall, it'll be the correct aspect ratio according to the photo you picked. One improvement you could add is to scale the images on the <strong class="bold">Select Image Panel</strong> buttons so they too are not squished. I'll leave that exercise up to you.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor169"/>Summary</h1>
			<p>At the beginning of this chapter, I gave you the requirements and a plan for this AR gallery project, including a statement of the project objectives, use cases, UX design, and user stories. You started the implementation using the <strong class="bold">ARFramework</strong> template created in <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">, Creating an AR User Framework</em>, and built upon it to implement new features for placing a framed photo on your walls.</p>
			<p>To implement this feature, you created a <code>ImageButton</code> prefab you created. Clicking an image, you're prompted to tap an AR tracked wall, and a new framed photo of that image is placed on the wall, correctly scaled to the image's aspect ratio.</p>
			<p>We now have a fine start to an interesting project. There is a lot more that can be done. For example, presently pictures can be placed on top of one another, which would be a mistake. Also, it would be good to be able to move, resize, and remove pictures. We'll add that functionality in the next chapter.</p>
		</div>
	</div></body></html>