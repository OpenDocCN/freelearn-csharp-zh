- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evaluating and Benchmarking the Performance of Minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this chapter is to understand one of the motivations for which
    the minimal APIs framework was created.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide some obvious data and examples of how you can measure
    the performance of an ASP.NET 6 application using the traditional approach as
    well as how you can measure the performance of an ASP.NET application using the
    minimal API approach.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is key to any functioning application; however, very often it takes
    a back seat.
  prefs: []
  type: TYPE_NORMAL
- en: A performant and scalable application depends not only on our code but also
    on the development stack. Today, we have moved on from the .NET full framework
    and .NET Core to .NET and can start to appreciate the performance that the new
    .NET has achieved, version after version – not only with the introduction of new
    features and the clarity of the framework but also primarily because the framework
    has been completely rewritten and improved with many features that have made it
    fast and very competitive compared to other languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will evaluate the performance of the minimal API by comparing
    its code with identical code that has been developed traditionally. We’ll understand
    how to evaluate the performance of a web application, taking advantage of the
    **BenchmarkDotNet** framework, which can be useful in other application scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: With minimal APIs, we have a new simplified framework that helps improve performance
    by leaving out some components that we take for granted with ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'The themes we will touch on in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Improvements with minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring performance with load tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking minimal APIs with BenchmarkDotNet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many systems can help us test the performance of a framework.
  prefs: []
  type: TYPE_NORMAL
- en: We can measure how many requests per second one application can handle compared
    to another, assuming equal application load. In this case, we are talking about
    load testing.
  prefs: []
  type: TYPE_NORMAL
- en: To put the minimal APIs on the test bench, we need to install **k6**, the framework
    we will use for conducting our tests.
  prefs: []
  type: TYPE_NORMAL
- en: We will launch load testing on a Windows machine with only .NET applications
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install k6, you can do either one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using the *Chocolatey package manager* ([https://chocolatey.org/](https://chocolatey.org/)),
    you can install the unofficial k6 package with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you’re using *Windows Package Manager* ([https://github.com/microsoft/winget-cli](https://github.com/microsoft/winget-cli)),
    you can install the official package from the k6 manifests with this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also test your application published on the internet with Docker:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or as we did, we installed k6 on the Windows machine and launched everything
    from the command line. You can download k6 from this link: [https://dl.k6.io/msi/k6-latest-amd64.msi](https://dl.k6.io/msi/k6-latest-amd64.msi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the final part of the chapter, we’ll measure the duration of the HTTP method
    for making calls to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll stand at the end of the system as if the API were a black box and measure
    the reaction time. BenchmarkDotNet is the tool we’ll be using – to include it
    in our project, we need to reference its **NuGet** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code samples in this chapter can be found in the GitHub repository
    for this book at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter10](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter10)'
  prefs: []
  type: TYPE_NORMAL
- en: Improvements with minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minimal APIs were designed not only to improve the performance of APIs but also
    for better code convenience and similarity to other languages to bring developers
    from other platforms closer. Performance has increased both from the point of
    view of the .NET framework, as each version has incredible improvements, as well
    as from the point of view of the simplification of the application pipeline. Let’s
    see in detail what has not been ported and what improves the performance of this
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal APIs execution pipeline omits the following features, which makes
    the framework lighter:'
  prefs: []
  type: TYPE_NORMAL
- en: Filters, such as `IAsyncAuthorizationFilter`, `IAsyncActionFilter`, `IAsyncExceptionFilter`,
    `IAsyncResultFilter`, and `IasyncResourceFilter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding for forms, such as `IFormFile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JsonPatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OData
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance Improvements in .NET 6
  prefs: []
  type: TYPE_NORMAL
- en: 'Version after version, .NET improves its performance. In the latest version
    of the framework, improvements made over previous versions have been reported.
    Here’s where you can find a complete summary of what’s new in .NET 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring performance with load tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to estimate the performance of minimal APIs? There are many points of view
    to consider and in this chapter, we will try to address them from the point of
    view of the load they can support. We decided to adopt a tool – k6 – that performs
    load tests on a web application and tells us how many requests per second can
    a minimal API handle.
  prefs: []
  type: TYPE_NORMAL
- en: As described by its creators, k6 is an open source load testing tool that makes
    performance testing easy and productive for engineering teams. The tool is free,
    developer-centric, and extensible. Using k6, you can test the reliability and
    performance of your systems and catch performance regressions and problems earlier.
    This tool will help you to build resilient and performant applications that scale.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we would like to use the tool for performance evaluation and not
    for load testing. Many parameters should be considered during load testing, but
    we will only focus on the `http_reqs` index, which indicates how many requests
    have been handled correctly by the system.
  prefs: []
  type: TYPE_NORMAL
- en: We agree with the creators of k6 about the purpose of our test, namely *performance*
    and *synthetic monitoring*.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'k6 users are typically developers, QA engineers, SDETs, and SREs. They use
    k6 for testing the performance and reliability of APIs, microservices, and websites.
    Common k6 use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load testing**: k6 is optimized for minimal resource consumption and designed
    for running high load tests (spike, stress, and soak tests).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and synthetic monitoring**: With k6, you can run tests with a
    small load to continuously validate the performance and availability of your production
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaos and reliability testing**: k6 provides an extensible architecture.
    You can use k6 to simulate traffic as part of your chaos experiments or trigger
    them from your k6 tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we have to make several assumptions if we want to evaluate the application
    from the point of view just described. When a load test is performed, it is usually
    much more complex than the ones we will perform in this section. When an application
    is bombarded with requests, not all of them will be successful. We can say that
    the test passed successfully if a very small percentage of the responses failed.
    In particular, we usually consider 95 or 98 percentiles of outcomes as the statistic
    on which to derive the test numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this background, we can perform stepwise load testing as follows: in ramp
    up, the system will be concerned with running the **virtual user** (**VU**) load
    from 0 to 50 for about 15 seconds. Then, we will keep the number of users stable
    for 60 seconds, and finally, ramp down the load to zero virtual users for another
    15 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Each newly written stage of the test is expressed in the JavaScript file in
    the *stages* section. Testing is therefore conducted under a simple empirical
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create three types of responses, both for the ASP.NET Web API and
    minimal API:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Plain-text*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very small *JSON* data against a call – the data is static and always the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third response, we send JSON data with an HTTP `POST` method to the API.
    For the Web API, we check the *validation* of the object, and for the minimal
    API, since there is no validation, we return the object as received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code will be used to compare the performance between the minimal
    API and the traditional approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimal API
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Traditional Approach
  prefs: []
  type: TYPE_NORMAL
- en: 'For the traditional approach, three distinct controllers have been designed
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will define an `options` object, where we are going
    to define the execution ramp described here. We define all clauses to consider
    the test satisfied. As the last step, we write the real test, which does nothing
    but call the HTTP endpoint using `GET` or `POST`, depending on the test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing k6 tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a test for each case scenario that we described in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding JavaScript file, we wrote the test using k6 syntax. We have
    defined the options, such as the evaluation threshold of the test, the parameters
    to be measured, and the stages that the test should simulate. Once we have defined
    the options of the test, we just have to write the code to call the APIs that
    interest us – in our case, we have defined three tests to call the three endpoints
    that we want to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Running a k6 performance test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have written the code to test the performance, let’s run the test
    and generate the statistics of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will report all the general statistics of the collected tests:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to start the web applications to run the load test. Let’s start
    with both the ASP.NET Web API application and the minimal API application. We
    expose the URLs, both the HTTPS and HTTP protocols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the shell to the root folder and run the following two commands in two
    different shells:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we just have to run the three test files for each project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This one is for the controller-based Web API:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'This one is for the minimal API:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here are the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test in traditional development mode with a `plain-text` content type,
    the number of requests served per second is 1,547:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The load test for a controller-based API and plain text ](img/Figure_10.1_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The load test for a controller-based API and plain text
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test in traditional development mode with a `json` content type, the
    number of requests served per second is 1,614:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The load test for a controller-based API and JSON result ](img/Figure_10.2_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The load test for a controller-based API and JSON result
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test in traditional development mode with a `json` content type and
    model validation, the number of requests served per second is 1,602:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The load test for a controller-based API and validation payload
    ](img/Figure_10.3_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The load test for a controller-based API and validation payload
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test in minimal API development mode with a `plain-text` content type,
    the number of requests served per second is 2,285:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The load test for a minimal API and plain text ](img/Figure_10.4_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The load test for a minimal API and plain text
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test in minimal API development mode with a `json` content type, the
    number of requests served per second is 2,030:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The load test for a minimal API and JSON result ](img/Figure_10.5_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The load test for a minimal API and JSON result
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test in minimal API development mode with a `json` content type with
    model validation, the number of requests served per second is 2,070:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The load test for a minimal API and no validation payload ](img/Figure_10.6_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The load test for a minimal API and no validation payload
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, we show a comparison of the three tested functionalities,
    reporting the number of requests served with the same functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The performance results ](img/Figure_10.7_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – The performance results
  prefs: []
  type: TYPE_NORMAL
- en: As we might have expected, minimal APIs are much faster than controller-based
    web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is approximately 30%, and that’s no small feat.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, as previously mentioned, minimal APIs have features missing in order
    to optimize performance, the most striking being data validation.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the payload is very small, and the differences are not very
    noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: As the payload and validation rules grow, the difference in speed between the
    two frameworks will only increase.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to measure performance with a load testing tool and then evaluate
    how many requests it can serve per second with the same number of machines and
    users connected.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use other tools to understand how minimal APIs have had a strong
    positive impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking minimal APIs with BenchmarkDotNet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BenchmarkDotNet is a framework that allows you to measure written code and compare
    performance between libraries written in different versions or compiled with different
    .NET frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: This tool is used for calculating the time taken for the execution of a task,
    the memory used, and many other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Our case is a very simple scenario. We want to compare the response times of
    two applications written to the same version of the .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: How do we perform this comparison? We take an `HttpClient` object and start
    calling the methods that we have also defined for the load testing case.
  prefs: []
  type: TYPE_NORMAL
- en: We will therefore obtain a comparison between two methods that exploit the same
    `HttpClient` object and recall methods with the same functionality, but one is
    written with the ASP.NET Web API and the traditional controllers, while the other
    is written using minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet helps you to transform methods into benchmarks, track their
    performance, and share reproducible measurement experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, it performs a lot of magic that guarantees reliable and precise
    results thanks to the perfolizer statistical engine. BenchmarkDotNet protects
    you from popular benchmarking mistakes and warns you if something is wrong with
    your benchmark design or obtained measurements. The library has been adopted by
    over 6,800 projects, including .NET Runtime, and is supported by the .NET Foundation
    ([https://benchmarkdotnet.org/](https://benchmarkdotnet.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Running BenchmarkDotNet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write a class that represents all the methods for calling the APIs
    of the two web applications. Let’s make the most of the startup feature and prepare
    the objects we will send via `POST`. The function marked as `[GlobalSetup]` is
    not computed during runtime, and this helps us calculate exactly how long it takes
    between the call and the response from the web application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register all the classes in `Program.cs` that implement BenchmarkDotNet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we have registered the current assembly that implements
    all the functions that will be needed to be evaluated in the performance calculation.
    The methods marked with `[Benchmark]` will be executed over and over again to
    establish the average execution time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application must be compiled on release and possibly within the production
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before launching the benchmark application, launch the web applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minimal API application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Controller-based application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By launching these applications, various steps will be performed and a summary
    report will be extracted with the timelines that we report here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For each method performed, the average value or the average execution time is
    reported.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 – Benchmark HTTP requests for minimal APIs and controllers ](img/B17902_10_Table1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 10.1 – Benchmark HTTP requests for minimal APIs and controllers
  prefs: []
  type: TYPE_NORMAL
- en: In the following table, **Error** denotes how much the average value may vary
    due to a measurement error. Finally, the standard deviation (**StdDev**) indicates
    the deviation from the mean value. The times are given in **μs** and are therefore
    very small to measure empirically if not with instruments with that just exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapter, we compared the performance of minimal APIs with that of the
    traditional approach by using two very different methods.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs were not designed for performance alone and evaluating them solely
    on that basis is a poor starting point.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 10.1* indicates that there are a lot of differences between the responses
    of minimal APIs and that of traditional ASP.NET Web API applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The tests were conducted on the same machine with the same resources. We found
    that minimal APIs performed about 30% better than the traditional framework.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about how to measure the speed of our applications – this can
    be useful for understanding whether the application will hold the load and what
    response time it can offer. We can also leverage this on small portions of critical
    code.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, the applications tested were practically bare bones. The validation
    part that should be evaluated in the ASP.NET Web API application is almost irrelevant
    since there are only two fields to consider. The gap between the two frameworks
    increases as the number of components that have been eliminated in the minimal
    APIs that we have already described increases.
  prefs: []
  type: TYPE_NORMAL
