- en: Optimizations for Virtual and Augmented Reality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two whole new entertainment mediums have entered the world stage in the forms
    of **virtual reality** (**VR**), where users are transported into a virtual space
    through the use of a **head-mounted device** (**HMD**), and **augmented reality**
    (**AR**), where virtual elements are superimposed on top of a display showing
    the real world. For the sake of brevity, these two terms are often combined into
    the singular term – **extended reality** (**XR**). There is also **Mixed Reality**
    (**MR**) (also known as **Hybrid Reality** (**HR**)), where an application mixes
    the real and virtual worlds together; this encompasses all of the previously mentioned
    formats, while also including AR, where real-world objects are scanned and superimposed
    inside a mostly virtual world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The markets for these media formats have sprung up very fast and are continuing
    to grow rapidly, with huge investments from the technology industry's biggest
    players. Naturally, game engines such as Unity jumped on the bandwagon quickly,
    providing ample support for most of the top contending platforms, such as Google's
    Cardboard, HTC's VIVE, Oculus Rift, Microsoft's HoloLens, and Samsung's Gear VR
    platforms, as well as the more recent entries, such as Apple's ARKit, Google's
    ARCore, Microsoft's Windows Mixed Reality platform, PTC's (originally Qualcomm's)
    Vuforia, and Sony's PlayStation VR.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Overview of XR technology
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XR offers a whole new realm for developers and creatives to explore. This includes
    entertainment products such as games and 360-degree videos (or 360 video for short),
    where a series of cameras are bundled together, each facing a different direction—the
    various captures from those cameras are stitched together and later played back
    like a movie in a VR headset, with visibility in all directions. Creative industry
    tools are also common in XR, such as 3D-modeling software, workflow visualizations,
    and quality-of-life gadgets. There are very few rules that have been set in stone,
    so there are plenty of opportunities to innovate, contribute to this new wave
    of technology, and become the one to create those rules. This has led to a lot
    of buzz and excitement as people explore what is possible and try to make their
    mark on the future of entertainment and interactive experiences.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, almost every new and budding technology goes through the **Hype
    Cycle** (from the Gartner Hype Cycle, which you can see at [https://www.gartner.com/technology/research/methodologies/hype-cycle.jsp](https://www.gartner.com/technology/research/methodologies/hype-cycle.jsp)).
    The Hype Cycle starts with its honeymoon period of excessive hype, where early
    adopters will evangelize its benefits. Later, there is an eventual cooling of
    emotions as it enters the trough of disillusionment since it hasn''t quite hit
    the mainstream, and its benefits are not taking hold just yet*.* This continues until
    either the technology fails to capture hearts and minds, thereby falling out of
    existence, or takes a firm hold and continues steady adoption. The following diagram
    shows the essentials of the Gartner Hype Cycle:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，几乎每一种新技术都会经历**炒作周期**（来自Gartner炒作周期，您可以在[https://www.gartner.com/technology/research/methodologies/hype-cycle.jsp](https://www.gartner.com/technology/research/methodologies/hype-cycle.jsp)查看）。炒作周期始于过度炒作的蜜月期，早期采用者会宣扬其好处。随后，随着它进入幻灭的低谷，情绪最终会冷却，因为它还没有完全进入主流，其好处尚未得到充分认可*.*
    这种情况会持续，直到技术要么未能赢得人心，从而消失，要么稳固地占据市场并持续稳定地被采用。以下图表展示了Gartner炒作周期的关键要素：
- en: '![](img/45d26bb2-2e3b-4d15-bef9-61dc1b20923d.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45d26bb2-2e3b-4d15-bef9-61dc1b20923d.png)'
- en: 'Arguably, XR has recently been passing through this final phase and is starting
    to enjoy much better support and much higher quality experiences than it did during
    the early days, although it is true that the adoption rate of XR has been slower
    than initially predicted. It remains to be seen whether XR will grow into a multibillion
    dollar industry or fade into a niche market of gadgets. Consequently, developing
    within this new medium is not without its risks, and we can find industry analysts
    who will agree with our opinions, regardless of where we stand on the future of
    XR. One thing is for certain, though: every time someone experiences firsthand
    what VR and AR are capable of, they''re blown away by the level of immersion and
    the medium''s ability to convincingly transport them into another world. This
    level of immersion and interactivity is unparalleled and teases many more possibilities
    as support for the platforms matures and technology continues to advance.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 争议性地，XR最近可能正在经历这个最终阶段，并开始享受到比早期更好的支持和更高品质的体验，尽管XR的采用率确实比最初预测的要慢。是否XR将成长为一个数十亿美元的行业，或者仅仅消失在利基市场中，还有待观察。因此，在这个新媒介中开发并非没有风险，我们可以找到同意我们观点的行业分析师，无论我们对XR的未来持何种立场。有一点是肯定的：每当有人亲身体验VR和AR的能力时，他们都会被沉浸感和该媒介将他们成功地带入另一个世界的说服力所震撼。这种沉浸感和互动性是无与伦比的，并且随着平台的支持成熟和技术持续进步，预示着更多的可能性。
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The concerns to keep in mind when developing VR or AR projects in Unity and
    what must be avoided
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中开发VR或AR项目时需要考虑的担忧以及必须避免的事项
- en: Performance enhancements specific to the XR medium
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门针对XR媒介的性能提升
- en: Developing XR products
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发XR产品
- en: Developing an XR product in Unity involves importing one of several XR **software
    development kits** (**SDKs**) into our Unity project and making some specialized
    API calls to configure and use the platform at runtime. Each SDK is different
    in its own way and offers a different set of features. For instance, the Oculus
    Rift and HTC VIVE SDKs provide APIs to control VR HMDs and their respective controllers,
    whereas Apple's ARKit provides utilities to determine spatial positioning and
    superimpose objects on the display. Unity Technologies have been working hard
    to create APIs that support all of these variations, so the APIs for XR development
    in Unity have changed a lot over the past few years.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中开发XR产品涉及将几个XR **软件开发工具包**（**SDKs**）之一导入我们的Unity项目中，并在运行时通过一些专门的API调用配置和使用该平台。每个SDK都有其独特之处，并提供不同的功能集。例如，Oculus
    Rift和HTC VIVE SDKs提供了控制VR头戴式显示器及其相应控制器的API，而苹果的ARKit提供了确定空间定位和在显示上叠加对象的实用工具。Unity
    Technologies一直在努力创建支持所有这些变化的API，因此Unity中XR开发的API在过去几年中发生了很大变化。
- en: The early days of Unity VR development meant dropping native plugins into our
    Unity projects, importing SDKs directly from an external developer portal (involving
    all kinds of annoying grunt work in the setup), and applying updates manually. Since
    then, however, Unity has incorporated several of these SDKs directly into the
    editor. In addition, since AR has become more popular recently, the main API has
    been renamed from `UnityEngine.VR` to `UnityEngine.XR` in Unity 2017.2.0 and later,
    and modified so that it can work with several AR SDKs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity VR开发的早期意味着将原生插件直接放入我们的Unity项目中，直接从外部开发者门户导入SDK（涉及设置中的各种令人烦恼的繁琐工作），并手动应用更新。然而，从那时起，Unity已经将这些SDK直接集成到编辑器中。此外，由于AR最近变得更加流行，主API在Unity
    2017.2.0及以后的版本中已被重命名为`UnityEngine.VR`到`UnityEngine.XR`，并进行了修改，以便它可以与多个AR SDK一起工作。
- en: The Unity XR system is currently transitioning from the legacy model to a new
    package-based model. By default, Unity supports a limited set of XR platforms.
    To import other XR SDKs and to configure them (such as ARKit or the Hololens),
    you need first to install them using Package Manager by going to Window | Package
    Manager.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity XR系统目前正在从传统模式过渡到新的基于包的模式。默认情况下，Unity支持有限的XR平台。要导入其他XR SDK并对其进行配置（例如ARKit或Hololens），您需要首先通过前往Window
    | Package Manager使用包管理器来安装它们。
- en: The development experience of working on XR products is a bit of a mixed bag
    right now. It involves working on some top-of-the-line hardware and software,
    which means that there are constant changes, redesigns, breakages, patches, bugs,
    crashes, compatibility issues, performance problems, rendering artifacts, a lack
    of feature parity between platforms, and so on. All of these problems serve to
    slow down our progress, which makes gaining a competitive advantage extraordinarily
    difficult in the XR field. On the bright side, pretty much everyone is having
    the same issues, so they get a lot of attention from their developers, making
    them easier to develop with all the time. Lessons are learned, APIs are cleaned
    up, and new features, tools, and optimizations are made available with every passing
    update.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在XR产品上的开发体验有点好坏参半。这涉及到使用一些顶级的硬件和软件，这意味着会有不断的变更、重新设计、故障、补丁、错误、兼容性问题、性能问题、渲染伪影、平台之间功能不匹配等问题。所有这些问题都旨在减缓我们的进度，这使得在XR领域获得竞争优势变得格外困难。从积极的一面来看，几乎每个人都在遇到同样的问题，因此它们得到了开发者的很多关注，这使得它们更容易开发。随着每一次更新的进行，我们都会学到经验教训，API会得到清理，新的功能、工具和优化也会被提供。
- en: 'Performance problems limit an XR product''s success, perhaps more so than non-XR
    projects because of the current state of the medium. Let''s take a look at a few
    of these performance problems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题限制了XR产品的成功，可能比非XR项目更为严重，因为当前媒体的状态。让我们看看其中的一些性能问题：
- en: Firstly, our users will be spending significant amounts of money to purchase
    VR HMDs and sensor equipment or AR-capable hardware. Both of these platforms can
    be very resource intensive, requiring similarly expensive graphics hardware to
    support them. This typically leads users to expect a much higher level of quality
    compared to typical games so that the investment feels worthwhile. To put it another
    way, this makes poor user experiences understandably less forgivable due to the
    monetary investment required by the user.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们的用户将花费大量金钱购买VR头戴式显示器和传感器设备或AR兼容的硬件。这两个平台都非常资源密集，需要类似昂贵的图形硬件来支持它们。这通常导致用户期望与典型游戏相比的质量水平要高得多，这样投资才感觉值得。换句话说，这就使得由于用户需要投入的金钱，不良的用户体验变得可以理解地难以原谅。
- en: Secondly, perhaps more so for VR projects than AR ones, poor application performance
    can lead to serious physical user discomfort, quickly turning even the staunchest
    advocate into a detractor. In particular, if the frame rate of the XR application
    is not enough, there will be a discrepancy between the motion the players feel
    (for example, by rotating the head) and what they see (we will learn about this
    in more detail later). This leads to the common issue of motion sickness that,
    in some cases, can last for hours*. *
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，对于VR项目来说可能比AR项目更为重要，糟糕的应用程序性能可能导致严重的物理用户不适，迅速将最坚定的支持者转变为反对者。特别是，如果XR应用程序的帧率不足，玩家感受到的运动（例如，通过旋转头部）与他们看到的内容之间将存在差异（我们将在稍后详细了解这一点）。这导致常见的运动病问题，在某些情况下，可能持续数小时*。*
- en: Thirdly, the XR platform's primary draw is its immersiveness, and nothing breaks
    that faster than frame drops, flickering, or any kind of application breakdown
    that forces the user to remove their headset or reboot the app.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, we must be prepared to profile our XR applications early to make
    sure we aren't exceeding our runtime budget, as it will be stretched thin by the
    complex and resource-intensive nature of the technology behind these media.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: User comfort
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike typical games and apps, VR apps need to consider user comfort as a metric
    to use to optimize themselves. Dizziness, motion sickness, eye strain, headaches,
    and even physical injuries from loss of balance have unfortunately been all too
    common for early VR adopters, and the onus is on us to limit these negative effects
    for users. In essence, content is just as important to user comfort as the hardware
    is, and we need to take the matter seriously if we are building for the medium.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Not everyone experiences these issues, and there are a lucky few who have experienced
    none of them; however, the overwhelming majority of users have reported these
    problems at one point or another. Also, just because our game doesn't trigger
    these problems in ourselves when we're testing them doesn't mean they won't trigger
    them in someone else. In fact, we will be the most biased test subject for our
    game due to familiarity. Without realizing it, we might start to predict our way
    around the most nauseating behavior our app generates, making it an unfair test
    compared to a new user experiencing the same situation. This, unfortunately, raises
    the costs of VR app development further, as a lot of testing with different unbiased
    individuals is required if we want to figure out whether our experience will cause
    discomfort, which may be needed each time we make significant changes that affect
    motion and frame rate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: There are several things that users can do to improve their VR comfort, such
    as starting with small sessions and working their way up to get practice in balancing
    and training their brain to expect the mismatched motion. A more drastic option
    is to take motion sickness medication or drink a little ginger tea beforehand
    to settle the stomach. However, we will hardly convince users to try our app if
    we promise it'll only take a few sessions of motion sickness before it starts
    to get enjoyable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main kinds of discomfort that users can experience in VR:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Motion sickness**: The first problem, nausea caused by motion sickness, typically
    happens when there is a sensory disconnect between where the user''s eyes think
    the horizon is and what their other senses are telling their brain, such as the
    inner ear''s sense of balance.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eye strain**: The second problem, eye strain, comes from the fact that the
    user is staring at a screen mere inches from their eyes, which tends to lead to
    a lot of eye strain and, ultimately, headaches after prolonged use.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disorientation**: Finally, disorientation typically occurs because a user
    in VR is sometimes standing within a confined space, so if a game features any
    kind of acceleration-based motion, the user will instinctively try to offset that
    acceleration by adjusting their balance, which can lead to disorientation, falling
    over, and the user hurting themselves if we are not careful in ensuring that the
    user experiences smooth and predictable motion.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迷失方向**：最后，迷失方向通常是因为VR用户有时站在一个封闭的空间内，所以如果一款游戏包含任何基于加速度的运动，用户会本能地试图通过调整平衡来抵消这种加速度，这可能导致迷失方向、跌倒，如果我们在确保用户体验平滑和可预测的运动方面不够小心，用户可能会受伤。'
- en: Note that the term **acceleration** is used intentionally since it is a vector,
    which means it has both magnitude and direction. Any kind of acceleration can
    cause disorientation, which includes not only accelerating forward, backward,
    and sideways, but also an acceleration in a rotational fashion (turning around),
    falling, jumping, and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，术语**加速度**是故意这样使用的，因为它是一个矢量，这意味着它既有大小也有方向。任何类型的加速度都可能引起迷失方向，这包括不仅向前、向后和侧向加速，还包括旋转形式的加速度（转身）、坠落、跳跃等等。
- en: Another potential problem for VR apps is the possibility of invoking seizures.
    VR is in the unique position of being able to blast images into the user's eyes
    at a close range, which opens up some risks that we might unintentionally trigger
    seizures in vulnerable users if rendering behavior breaks down and starts flickering.
    These are all things we need to keep in mind during development that need to be
    tested for and fixed sooner rather than later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: VR应用可能面临的另一个潜在问题是引发癫痫发作的可能性。VR能够将图像以近距离投射到用户的眼睛中，这带来了一些风险，如果我们渲染行为崩溃并开始闪烁，我们可能会无意中触发易感用户的癫痫发作。这些都是我们在开发过程中需要牢记的事情，需要尽早测试和修复。
- en: Perhaps the most important performance metric to reach in a VR app is having
    a high number of **frames-per-second** (**FPS**), preferably 90 FPS or more, as
    this will generate a smooth viewing experience since there will be a very small
    disconnection between the user's head motion and the motion of the world. Any
    period of extended frame drops or having an FPS value consistently below this
    value is likely to cause a lot of problems for our users, making it critical that
    our application performs well at all times. Also, we should be very careful about
    how we control the user's viewpoint. We should avoid changing an HMD's field of
    view ourselves (let the user dictate the direction they are facing), generating
    acceleration over long periods, or causing uncontrolled world rotation and horizon
    motion, since these are extremely likely to trigger motion sickness and balance
    problems for the user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR应用中，可能最重要的性能指标是拥有高帧率（**帧每秒**，**FPS**），最好是90 FPS或更高，因为这将产生平滑的观看体验，因为用户头部运动和世界运动之间的脱节将非常小。任何长时间的帧率下降或帧率值持续低于这个值都可能给我们的用户带来很多问题，因此，我们的应用程序必须始终表现良好。此外，我们还应该非常小心地控制用户的视角。我们应该避免自己改变HMD的视野（让用户决定他们面向的方向），在长时间内产生加速度，或者引起不受控制的全球旋转和地平线运动，因为这些极有可能触发用户的运动病和平衡问题。
- en: A strict rule that is not up for debate is that we should never apply any kind
    of gain, multiplier effect, or acceleration effect to the positional tracking
    of an HMD in the final build of our product. Doing so for the sake of testing
    is fine, but if a real user moves their head two inches to the side, then it should
    feel like it moved the same relative distance inside the application and should
    stop the moment their head stops. Doing otherwise is not only going to cause a
    disconnect between where the player's head feels like it should be and where it
    is, but may also cause some serious discomfort if the camera becomes offset with
    respect to the player's orientation and the angle of their neck.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不容置疑的严格规则是，我们绝对不应该在我们的产品最终构建中对HMD（头戴式显示器）的位置跟踪应用任何类型的增益、乘数效应或加速效应。这样做是为了测试是可以的，但如果真实用户将头部向侧面移动两英寸，那么它应该感觉就像在应用程序内部移动了相同的相对距离，并且应该在他们的头部停止时立即停止。否则，不仅会导致玩家感觉头部应该所在的位置和实际位置之间的脱节，而且如果摄像头相对于玩家的朝向和颈部角度发生偏移，还可能引起一些严重的不适。
- en: It is possible to use acceleration for the motion of the player character, but
    it should be incredibly short and rapid before the user starts to self-adjust
    too quickly. It would be wisest to stick to motion that relies on constant velocities
    and/or teleportation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Placing banked turns in racing games seems to improve user comfort a great deal
    since the user naturally tilts their head and adjusts their balance to match the
    turn.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: All of the previous rules apply just as well to 360 video content as they do
    to VR games. Frankly, there has been an embarrassing number of 360 videos released
    to the market that are not taking the aforementioned points into account—they
    feature too many jerking movements, a lack of camera stabilization, manual viewport
    rotation, and so on. These hacks are often used to ensure the user is facing in
    the direction we intend; however, we must spend more effort on doing this without
    hacking to avoid nausea-inducing behavior. Humans are naturally very curious about
    things that move. If they notice something moving in the corner of their eye,
    then they will most likely turn to face it. This can be used to great effect to
    keep the user facing in the direction we intend as they watch the video.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Laziness is not the way to go when generating VR content. Don't just slap a
    360 camera on top of a dirt rally car and hack an unexpected camera rotation into
    the video to keep the action in the center. The motion needs to be smooth and
    predictable. During production, we need to constantly keep in mind where we expect
    the user to be looking so that we capture action shots correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, for the 360 video format, it seems as though industry-standard
    frame rates, such as 24 FPS or 29.97 FPS, do not have a disastrous effect on user
    comfort, but note that this frame rate applies to video playback only. Our rendering
    FPS is a separate FPS value and dictates how smooth positional head tracking will
    be. The rendering FPS must always be very high to avoid discomfort (ideally, 90
    FPS).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Other problems arise when building VR apps—different HMDs and controllers support
    different inputs and behavior, making feature-parity across VR platforms difficult.
    A problem called **stereo fighting** can occur if we try to merge 2D and 3D content
    together, where 2D objects appear to be rendering deep inside 3D objects since
    the eyes can't distinguish the distance correctly. This is typically a big problem
    for the user interface of VR applications and 360 video playback, which tends
    to be a series of flat panels superimposed over a 3D background. Stereo fighting
    does not usually lead to nausea, but it can cause additional eye strain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Although the effects of discomfort are not quite as pronounced in the AR platform,
    it's still important not to ignore it. Since AR apps tend to consume a lot of
    resources, low frame rate applications can cause some discomfort. This is especially
    true if an AR app makes use of superimposing objects onto a camera image (which
    is the majority of them), where there will probably be a disconnect in the frame
    rate between the background camera image and the objects we're superimposing over
    it. We should try to synchronize these frame rates to limit that disconnect.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不适感在AR平台上的影响并不那么明显，但仍然很重要，不要忽视它。由于AR应用倾向于消耗大量资源，低帧率的应用可能会引起一些不适。这尤其适用于AR应用将对象叠加到相机图像上（这占大多数），其中背景相机图像和叠加其上的物体之间可能会出现帧率不匹配。我们应该尝试同步这些帧率，以限制这种不匹配。
- en: Performance enhancements in XR
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XR中的性能提升
- en: That's enough talk about the industry and XR development. In the next section,
    we will cover some performance enhancements that can be applied to XR projects,
    such as choosing between the different kinds of stereo rendering algorithms and
    how to apply antialiasing and other effects to VR games
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于行业和XR开发的讨论就到这里。在下一节中，我们将介绍一些可以应用于XR项目的性能提升方法，例如选择不同类型的立体渲染算法，以及如何将抗锯齿和其他效果应用于VR游戏。
- en: The kitchen sink
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 厨房水槽
- en: Since AR and VR apps are built using the same engine, the same subsystems, assets,
    tools, and utilities as any other Unity game, literally every other performance
    enhancement mentioned in this book, can help VR and AR apps in some fashion, and
    we should try them all before getting too in-depth with XR-specific enhancements.
    This is reassuring, as there are a lot of potential performance enhancements we
    could apply. The downside is that we may need to apply many of them to reach the
    level of performance we need for our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AR和VR应用是使用与任何其他Unity游戏相同的引擎、子系统、资产、工具和实用程序构建的，因此本书中提到的几乎所有其他性能提升都可以以某种方式帮助VR和AR应用，我们应该在深入研究XR特定增强之前尝试它们所有。这令人欣慰，因为我们可以应用许多潜在的性能提升。缺点是我们可能需要应用许多它们才能达到我们应用所需的性能水平。
- en: The biggest threat to a VR app's performance is the GPU fill rate, which is
    already one of the more likely bottlenecks in any other game, but significantly
    more so for VR, since we will always be trying to render a high-resolution image
    to a much larger frame buffer (since we're effectively rendering the scene twice—once
    for each eye). AR apps are typically going to find extreme consumption in both
    the CPU and the GPU since AR platforms make heavy use of the GPU's parallel pipeline
    to resolve the spatial locality of objects and perform tasks such as image recognition,
    as well as requiring a lot of draw calls to support those activities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: VR应用性能的最大威胁是GPU填充率，这已经是任何其他游戏中更可能的瓶颈之一，但对于VR来说，影响更大，因为我们始终试图将高分辨率图像渲染到更大的帧缓冲区（因为我们实际上是在为每个眼睛渲染场景两次）。AR应用通常会在CPU和GPU上发现极端消耗，因为AR平台大量使用GPU的并行管道来解决对象的空间局部性，执行图像识别等任务，以及需要大量的绘制调用来支持这些活动。
- en: Of course, certain performance-enhancing techniques are not going to be particularly
    effective in XR. **Occlusion Culling** in a VR app may be difficult to set up
    since the user can look under, around, and sometimes through objects in the scene
    (although it can still be enormously beneficial). Meanwhile, AR apps normally
    render objects at reachable distances; LOD enhancements – that is, using simpler
    meshes for objects far away – may be fairly pointless to set up.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，某些性能提升技术在XR中可能不会特别有效。在VR应用中实施**遮挡剔除**可能很困难，因为用户可以查看场景中的物体下方、周围，有时甚至能透过物体（尽管它仍然可能带来巨大的好处）。与此同时，AR应用通常在可触及的距离渲染物体；LOD增强——即使用更简单的网格为远处的物体建模——可能设置起来相当没有意义。
- en: We must use our better judgment to determine whether a performance optimization
    technique is worth implementing before we start implementing it, since many of
    them take a lot of time to implement and support.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开始实施之前必须运用更好的判断力来确定一项性能优化技术是否值得实施，因为其中许多都需要花费大量时间来实施和支持。
- en: Single Pass versus Multi Pass Stereo rendering
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单次遍历与多次遍历立体渲染
- en: 'For VR apps, Unity provides three rendering modes: Multi Pass, Single Pass,
    and Single Pass Instanced. This can be configured under Edit | Project Settings
    | Player | XR Settings | Stereo Rendering Method (note that the checkbox of Virtual
    Reality Supported must be enabled for this to show up):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b8a87d9-d916-4d80-a272-4cd90b725ad8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: Multi Pass rendering will render the scene to two different images, which are
    displayed separately for each eye. Single Pass Stereo rendering combines both
    images into a single double-width render texture, where only the relevant half
    is displayed to each eye.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Note that XR Settings are enabled only for the legacy system. If you installed
    a new experimental **XR Managment** package, you will find the rendering modes
    by going to Edit | Project Settings | XR Plugin Management.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Multi Pass Stereo rendering is the default case. The advantage of Single Pass
    rendering is that it provides significant savings in the CPU work in the main
    thread (by reducing draw call setup) and in the GPU since less texture swapping
    needs to occur. Of course, the GPU will need to work just as hard to render the
    objects since each object is still rendered twice from two different perspectives
    (there are no freebies here). The disadvantage is that this effect can currently
    only be used when using OpenGL ES3.0 or higher, and so it is not available on
    all platforms.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, its effects on the rendering pipeline require extra care and effort,
    particularly surrounding any shaders that are making use of screen-space effects
    (effects that only use data already drawn to the framebuffer). With Single Pass
    Stereo rendering enabled, shader code can no longer make the same assumptions
    about the incoming screen space information. The following image shows how screen
    space coordinates vary between **Multi-Pass S****tereo Rendering** and **Single-Pass
    Stereo Rendering**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b3e23a2-0307-4d87-8b17-03a82c06f16e.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: The shader is always informed of the screen space coordinates relative to the
    entire output render texture rather than just the portion it is interested in—for
    example, we would normally expect an **x** value of **0.5** to correspond to the
    horizontal halfway point of the screen, which would be the case when we use **Multi-Pass
    Stereo Rendering**; however, if we use **Single-Pass Stereo Rendering**, then
    an **x** value of **0.5** would correspond to the halfway point between the rendering
    of both eyes (the right edge of the left eye or the left edge of the right eye).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides some useful helper methods for screen space conversion for shaders,
    which can be found at [https://docs.unity3d.com/Manual/SinglePassStereoRendering.html](https://docs.unity3d.com/Manual/SinglePassStereoRendering.html).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Another problem to worry about is post-processing effects. We essentially always
    pay double the cost for any post-processing effect applied to the scene in VR
    since it needs to be evaluated once for each eye. Single Pass Stereo rendering
    can reduce the draw calls needed to set up our effect, but we can't blindly apply
    a post-processing effect to both images simultaneously. Consequently, the post-processing
    effect shaders must also be adjusted to ensure that they render to the correct
    half of the output render texture. Without doing this, a post-processing effect
    will be stretched over both eyes twice, which might look incredibly bizarre for
    effects such as lens flares.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要担心的问题是后期处理效果。在VR场景中，我们实际上总是为任何应用的后期处理效果支付双倍的成本，因为它需要为每只眼睛评估一次。单次渲染立体渲染可以减少设置效果所需的绘制调用，但我们不能盲目地将后期处理效果同时应用于两张图像。因此，后期处理效果着色器也必须进行调整，以确保它们渲染到正确的输出渲染纹理的一半。如果不这样做，后期处理效果将被拉伸到两只眼睛上两次，对于如镜头光晕等效果可能会显得非常奇怪。
- en: '**Single-Pass instancing **(also known as **stereo instancing**), on the other
    hand, is an experimental rendering mode that has some advantages over the standard
    single pass. Instead of doubling draw calls by rendering the same object for the
    right and the left eye, single-pass instances makes heavy use of **GPU instancing**.
    In short, GPU instancing allows Unity to issue a single draw call to the GPU,
    but with the instruction that the mesh must be drawn in two different positions.
    Therefore, single-pass instances can offer a dramatic improvement compared with
    CPU performances; however, custom shaders need to be ready for GPU instantiation:
    this involves adding a position parameter to the shader (so that the GPU knows
    how to move the mesh) and several Unity utility functions.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**单次渲染实例化**（也称为**立体实例化**），另一方面，是一种实验性的渲染模式，它相对于标准单次渲染有一些优势。它不是通过为左右眼渲染相同对象来加倍绘制调用，而是大量使用**GPU实例化**。简而言之，GPU实例化允许Unity向GPU发出单个绘制调用，但要求网格必须在两个不同的位置绘制。因此，单次渲染实例化可以与CPU性能相比提供显著的改进；然而，自定义着色器需要为GPU实例化做好准备：这涉及到向着色器添加一个位置参数（以便GPU知道如何移动网格）和几个Unity实用函数。'
- en: Enabling GPU instancing on a custom shader is a hard task, and it is not recommended
    unless you already have some experience with the Unity shading language. If you
    have, then the right place to start is [https://docs.unity3d.com/Manual/SinglePassInstancing.html](https://docs.unity3d.com/Manual/SinglePassInstancing.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义着色器上启用GPU实例化是一项艰巨的任务，除非你已经对Unity着色语言有一些经验，否则不建议这样做。如果你有经验，那么开始的地方是[https://docs.unity3d.com/Manual/SinglePassInstancing.html](https://docs.unity3d.com/Manual/SinglePassInstancing.html)。
- en: The single-pass rendering (both traditional and instanced) feature is not supported for
    all platforms. We can expect it to be rolled out to more platforms eventually,
    but for platforms supporting it, we will need to perform some profiling and sensible
    sanity checks on our screen space shaders to ensure that we are making positive
    gains from enabling this option.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单次渲染（包括传统和实例化）功能并不适用于所有平台。我们预计它最终将推广到更多平台，但对于支持该功能的平台，我们需要对我们的屏幕空间着色器进行一些性能分析和合理的合理性检查，以确保我们通过启用此选项获得积极的收益。
- en: Applying antialiasing
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用抗锯齿
- en: Applying antialiasing is less of a performance enhancement and more of a requirement.
    Antialiasing significantly improves the fidelity of XR projects since objects
    will blend better and appear less pixelated, improving immersion, which can cost
    a lot of fill-rate. We should enable this feature early and try to reach our performance
    goals with the assumption that it is simply always there, only disabling it as
    an absolute last resort.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用抗锯齿更多的是一种需求，而不是性能提升。抗锯齿显著提高了XR项目的保真度，因为对象将更好地融合，看起来更少像素化，从而提高沉浸感，这可能会消耗大量的填充率。我们应该尽早启用此功能，并假设它始终存在，只在绝对最后关头禁用它，以尝试达到我们的性能目标。
- en: Using forward rendering
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用前向渲染
- en: The advantage of deferred rendering is the ability to resolve many light sources
    with minimal draw calls. Unfortunately, if we follow the preceding advice and
    apply antialiasing effects, then this must be done as a post-processing screen
    space shader when deferred rendering is used. This can cost a considerable amount
    of performance compared to how the same technique is applied as a multisampling
    effect in forward rendering, potentially making forward rendering the more performant
    of the two options.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟渲染的优势在于能够以最少的绘制调用解决许多光源。不幸的是，如果我们遵循前面的建议并应用抗锯齿效果，那么在采用延迟渲染时，这必须作为一个后处理屏幕空间着色器来完成。与在正向渲染中作为多采样效果应用相同技术相比，这可能会造成相当大的性能损失，从而使得正向渲染成为两种选项中性能更优的一种。
- en: Applying image effects in VR
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR中应用图像效果
- en: The effects applied by normal maps tend to break down easily in VR, where the
    texture appears painted on to the surface instead of giving the illusion of depth.
    Normal maps normally break down very quickly with viewing angles that are very
    oblique (shallow) with the surface, which is not particularly common in a typical
    game; however, in VR, since most HMDs allow users to move their heads around in
    a 3D space via positional tracking (which, granted, not all of them do), they
    will quickly find positions that break the effect for any objects close to the
    camera. Normal maps have been known to improve the quality of high polygon count
    objects in VR, but it rarely provides a benefit for those with a low polygon count,
    so we should perform a little testing to make sure that any visual improvement
    is worth the costs in memory bandwidth.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图应用的效果在VR中很容易崩溃，纹理看起来是画在表面上的，而不是给人一种深度错觉。法线贴图通常在非常斜（浅）的观察角度下迅速崩溃，这与典型游戏中的情况不太常见；然而，在VR中，由于大多数头戴式显示器允许用户通过位置跟踪在3D空间中移动他们的头部（尽管并非所有设备都这样做），他们很快就会找到任何靠近摄像机的物体效果崩溃的位置。已知法线贴图可以改善VR中高多边形对象的质量，但很少为低多边形对象提供好处，因此我们应该进行一些测试，以确保任何视觉改进都值得在内存带宽上的成本。
- en: Ultimately, we cannot rely on normal mapping to provide a quick and cheap increase
    in graphical fidelity for low polygon count objects that we might expect from
    a non-VR scene, so testing is required to establish whether the illusion is working
    as intended. Displacement maps, tessellation, and/or parallax mapping should be
    used instead to create a more believable appearance of depth. Unfortunately, all
    of these techniques are more expensive than a typical normal map, but it is a
    burden we must suffer in order to achieve good graphical quality in VR.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们不能依赖法线贴图来为低多边形对象提供快速且经济的图形保真度提升，这些对象是我们从非VR场景中可能期望得到的。因此，需要进行测试以确定这种错觉是否按预期工作。应使用位移贴图、细分或视差贴图来创建更逼真的深度外观。不幸的是，所有这些技术都比典型的法线贴图成本更高，但这是我们在VR中实现良好图形质量必须承受的负担。
- en: Other post-processing effects, such as depth of field, blurring, and lens flares,
    are effects that look good in a typical 3D game, but are generally not effects
    we witness in the real world, and will seem out of place in VR (at least until
    eye-tracking support is available), and so should generally be avoided.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其他后处理效果，如景深、模糊和镜头光晕，在典型的3D游戏中看起来很好，但通常不是我们在现实世界中看到的效果，在VR中（至少在眼动追踪支持可用之前）会显得格格不入，因此应该一般避免。
- en: Backface culling
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反面裁剪
- en: Backface culling (removing faces from objects that will never be visible) can
    be tricky for VR and AR projects since the player's viewing angle could potentially
    come from any direction for objects near the camera. Assets near the camera should
    be a fully closed shape if we want to avoid immersion-breaking viewpoints. We
    should also think carefully about applying backface culling for distant objects,
    particularly if the user travels by teleportation since it can be tricky to restrict
    a user's location completely. Ensure that you test your game world's bounding
    volumes to ensure that the user cannot escape.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 反面裁剪（从永远不会可见的对象中移除面）对于VR和AR项目来说可能很棘手，因为玩家的观察角度可能来自任何方向。如果我们想避免破坏沉浸感的角度，靠近摄像机的资产应该是完全封闭的形状。我们还应该仔细考虑对远程对象应用反面裁剪，尤其是如果用户通过传送移动，因为这可能很难完全限制用户的位置。确保您测试游戏世界的边界体积，以确保用户无法逃脱。
- en: Spatialized audio
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间化音频
- en: The audio industry is abuzz with new techniques to present audio experiences
    for VR (or, more accurately, old techniques that have finally found a good use)
    in the form of spatial audio. Audio data for these formats no longer represents
    audio data from specific channels, but instead contains data for certain audio
    harmonics that are merged at runtime to create a more believable audio experience
    depending on the current camera viewport, particularly vertical orientations.
    The key word from the previous sentence is runtime, meaning that this effect has
    a continuous nontrivial cost associated with it. These techniques will require
    CPU activity, but may also use GPU acceleration to generate their effects, so
    we should double-check the behavior of both devices if we're experiencing performance
    problems when we're making use of spatial audio.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 音频行业正充满对VR（或更准确地说，是终于找到了良好用途的旧技术）的新技术，以空间音频的形式呈现音频体验。这些格式的音频数据不再代表特定通道的音频数据，而是包含某些音频谐波数据，这些数据在运行时合并以创建更逼真的音频体验，这取决于当前的相机视口，尤其是垂直方向。前一句话中的关键词是运行时，这意味着这种效果与它相关的连续非平凡成本。这些技术将需要CPU活动，但也可能使用GPU加速来生成它们的效果，因此如果我们在使用空间音频时遇到性能问题，我们应该双重检查这两个设备的行为。
- en: Avoiding camera physics collisions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免相机物理碰撞
- en: In VR and AR, the user can move the camera through objects, which can break
    their immersion. Although it may be tempting to add physics colliders to such
    surfaces to prevent the camera from moving through them, this will cause disorientation
    in VR since the camera will not move in unison with the user's movements. This
    could also break the positional-tracking calibration of an AR app. A better approach
    is to either allow the user to see into objects or to maintain a safe buffer zone
    between the camera and such surfaces. If we don't allow the player to teleport
    too close to them in the first place, then there's no risk of sticking their head
    through walls.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR和AR中，用户可以穿过物体移动相机，这可能会破坏他们的沉浸感。虽然添加物理碰撞器到这些表面以防止相机穿过它们可能很有吸引力，但这将在VR中导致方向混乱，因为相机不会与用户的移动同步。这也可能破坏AR应用的定位跟踪校准。更好的方法是允许用户看到物体内部，或者保持相机和这些表面之间的安全缓冲区。如果我们一开始就不允许玩家太靠近它们，那么就没有将头部穿过墙壁的风险。
- en: This will save on performance because of a reduced number of colliders, but
    should be followed as more of a quality-of-life issue. We shouldn't be too concerned
    about risking immersion-breaking behavior by doing this, as research has shown
    that users tend to avoid looking into objects once they realize they can do it.
    They may experience a moment of confusion or hilarity when it happens initially,
    but fortunately, people tend to want to remain in the immersive experience we've
    created and will tend to avoid putting their heads through walls. However, the
    ability to do so provides the gameplay advantage of seeing through a wall to observe
    where enemies are about to come from, so we should develop our scenes with that
    in mind.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于减少了碰撞器的数量，这将节省性能，但应更多地将其视为一个生活质量问题。我们不应该过于担心通过这种方式冒险破坏沉浸感，因为研究表明，一旦用户意识到他们可以这样做，他们往往会避免看向物体。当这种情况首次发生时，他们可能会经历片刻的困惑或欢笑，但幸运的是，人们往往希望留在我们创造的沉浸式体验中，并且会倾向于避免将头部穿过墙壁。然而，能够这样做提供了游戏玩法上的优势，即能够透过墙壁观察敌人即将从哪里出现，因此我们应该考虑到这一点来开发我们的场景。
- en: Avoiding Euler angles
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用欧拉角
- en: Avoid using Euler angles for any kind of orientation behavior. Quaternions are
    designed to be much better for representing angles (the only downside is that
    they are more abstract and harder to visualize when debugging) and maintaining
    accuracy whenever there are changes, while also avoiding the dreaded gimbal lock.
    Using Euler angles for calculations could eventually lead to inaccuracies after
    there are a lot of rotation changes, which is incredibly likely since the user's
    viewpoint will change by tiny amounts many times per second in both VR and AR.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在任意类型的方向行为中使用欧拉角。四元数被设计得在表示角度方面要好得多（唯一的缺点是它们更抽象，在调试时更难可视化），并且当有变化时，它们可以保持准确性，同时避免可怕的陀螺仪锁定。在计算中使用欧拉角可能会导致大量旋转变化后的不准确，这在VR和AR中是极其可能的，因为用户的视点会每秒以微小的量多次改变。
- en: Gimbal lock is a problem that can occur with Euler angles. Since Euler angles
    represent orientation via three axes, and there are overlaps when one of these
    axes is rotated 90 degrees, we could accidentally lock them together, becoming
    mathematically inseparable and causing future orientation changes to affect both
    axes simultaneously. Of course, a human being can figure out how to rotate the
    object to solve this problem, but gimbal lock is a purely mathematical problem.
    The classic example is the orientation bubble in a fighter jet. The pilot never
    has problems with gimbal lock, but the orientation instruments in their heads-up
    display could become inaccurate because of it. Quaternions solve this problem
    by including a fourth value that effectively allows overlapping axes to still be distinguishable
    from one another.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉角可能会出现陀螺仪锁定的问题。由于欧拉角通过三个轴来表示方向，当其中一个轴旋转 90 度时，会出现重叠，我们可能会意外地将它们锁定在一起，变得在数学上无法分离，并导致未来的方向变化同时影响两个轴。当然，人类可以想出如何旋转对象来解决这个问题，但陀螺仪锁定是一个纯粹数学上的问题。经典的例子是战斗机中的方向气泡。飞行员永远不会遇到陀螺仪锁定的问题，但他们的抬头显示仪中的方向仪器可能会因为陀螺仪锁定而变得不准确。四元数通过包含一个第四个值来解决这个问题，这个值有效地允许重叠的轴仍然可以相互区分。
- en: Exercise restraint
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习节制
- en: Performance targets for VR apps are very difficult to reach. It is, therefore,
    important to recognize when we are simply trying to cram too much quality into
    our app than is tolerable for the current generation of XR devices and typical
    user hardware. The last resort is always to cull objects from our scenes until
    we reach our performance goals. We should be more willing to do so for an XR app
    than a non-XR one since the costs of poor performance often far outweigh the gains
    of higher quality. We must refrain from adding more detail to our scenes if it
    has become apparent that the rendering budget has been exhausted. This can be
    difficult to admit with immersive VR content, where we want to create as much
    compelling immersion as we can, but until the technology catches up with our ambition,
    we need to remain frugal.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: VR 应用的性能目标非常难以达到。因此，当我们试图将过多的质量塞入我们的应用中，超出了当前一代 XR 设备和典型用户硬件的容忍度时，认识到这一点非常重要。最后的手段总是从场景中剔除对象，直到我们达到性能目标。对于
    XR 应用，我们应该比非 XR 应用更愿意这样做，因为性能不佳的成本往往远超过高质量带来的收益。如果已经明显看出渲染预算已经耗尽，我们就应该避免在场景中添加更多细节。这在沉浸式
    VR 内容中可能很难承认，因为我们希望创造尽可能多的引人入胜的沉浸感，但直到技术赶上我们的野心，我们仍需要保持节俭。
- en: Keeping up to date with the latest developments
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪最新发展
- en: Unity provides a list of useful articles and tutorials containing VR design
    and optimization tips, which will likely get updated as the medium and market
    matures and new techniques are discovered. This list can be kept more up to date
    than this book ever could be, so check them out from time to time to catch the
    latest tips. As usual, the articles and tutorials in question can be found at [https://learn.unity.com](https://learn.unity.com).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一系列包含 VR 设计和优化技巧的有用文章和教程，随着媒体和市场的成熟以及新技术的发现，这些内容可能会得到更新。这个列表可能比这本书更新得更快，所以请时不时地查看它们，以获取最新的技巧。通常，相关的文章和教程可以在
    [https://learn.unity.com](https://learn.unity.com) 找到。
- en: We should also keep an eye on Unity blogs to make sure that we don't miss anything
    important with regard to XR API changes, performance enhancements, and performance
    suggestions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该关注 Unity 博客，以确保我们不会错过关于 XR API 变更、性能增强和性能建议的重要信息。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hopefully, this brief guide will help you improve the performance of your XR
    applications. The reassuring news is that you have many performance optimization
    options to choose from since Unity XR apps are built on the same underlying platform
    we've been exploring throughout this book. Less reassuring is the fact that we
    might have to test and implement all of them in order to stand a chance of reaching
    our quality goals. We can expect hardware to get more powerful over time, prices
    to come down, and adoption to increase as a result; however, until then, we need
    to pull out all the stops if we're going to compete in the tech world's latest
    craze.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这份简短的指南能帮助您提升您的XR应用性能。令人欣慰的消息是，您有许多性能优化选项可供选择，因为Unity XR应用是基于我们在整本书中一直在探索的相同底层平台构建的。不那么令人欣慰的是，我们可能必须测试和实施所有这些选项，才有可能达到我们的质量目标。我们可以预期硬件会随着时间的推移变得更加强大，价格会下降，采用率也会提高；然而，在此之前，如果我们想在科技世界的最新热潮中竞争，我们就必须全力以赴。
- en: In the next chapter, we'll dig into Unity's underlying engine, along with the
    various frameworks, layers, and languages that it is built from. In essence, we
    will take a more in-depth look at our script code and investigate some methods
    to improve our CPU and memory management across the board.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨Unity的底层引擎，以及它所构建的各种框架、层和语言。本质上，我们将更深入地查看我们的脚本代码，并研究一些方法来全面提升我们的CPU和内存管理。
