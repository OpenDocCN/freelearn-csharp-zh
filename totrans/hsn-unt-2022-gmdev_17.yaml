- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Creating Animations with Animator, Cinemachine, and Timeline
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Animator、Cinemachine和Timeline创建动画
- en: Sometimes, we need to move objects in a predetermined way, such as with cutscenes,
    or specific character animations, such as jumping, running, and so on. In this
    chapter, we will go over several Unity animation systems to create all the possible
    movements of objects we can get without scripting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要以预定的方式移动对象，例如在场景中，或者特定的角色动画，如跳跃、奔跑等。在本章中，我们将介绍几个Unity动画系统，以创建我们可以通过脚本获得的所有可能的物体运动。
- en: 'In this chapter, we will examine the following animation concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下动画概念：
- en: Using Skinning Animation with Animator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Animator进行皮肤动画
- en: Scripting animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本动画
- en: Creating dynamic cameras with Cinemachine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cinemachine创建动态相机
- en: Creating cutscenes with Timeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Timeline创建场景
- en: By the end of this chapter, you will be able to create cutscenes to tell the
    history of your game or highlight specific areas of your level, as well as create
    dynamic cameras that are capable of giving an accurate look to your game, regardless
    of the situation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建场景来讲述你游戏的历史或突出你关卡中的特定区域，以及创建能够根据情况提供准确外观的动态相机。
- en: Using Skinning Animation with Animator
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Animator进行皮肤动画
- en: So far, we have used what are called static meshes, which are solid three-dimensional
    models that are not supposed to bend or animate in any way (aside from moving
    separately, like the doors of a car).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是所谓的静态网格，它们是固体三维模型，不应该以任何方式弯曲或动画化（除了像汽车门那样单独移动）。
- en: We also have another kind of mesh, called skinned meshes, which are meshes that
    have the ability to bend based on a skeleton, so they can emulate the muscle movements
    of the human body. We are going to explore how to integrate animated humanoid
    characters into our project to create enemy and player movements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一种另一种网格，称为皮肤网格，它具有根据骨骼弯曲的能力，因此可以模拟人体肌肉运动。我们将探讨如何将动画化的类人角色集成到我们的项目中，以创建敌人和玩家的动作。
- en: 'In this section, we will examine the following skeletal mesh concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下骨骼网格概念：
- en: Understanding skinning
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解皮肤
- en: Importing skinned meshes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入皮肤网格
- en: Integration using Animator Controllers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Animator控制器进行集成
- en: Using Avatar Masks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Avatar面具
- en: We are going to explore the concept of skinning and how it allows you to animate
    characters. Then, we are going to bring animated meshes into our project to finally
    apply animations to them. Let’s start by discussing how to bring skeletal animations
    into our project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨皮肤的概念以及它如何让你对角色进行动画化。然后，我们将把动画网格带入我们的项目，最终对它们应用动画。让我们先讨论如何将骨骼动画带入我们的项目。
- en: Understanding skinning
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解皮肤
- en: 'In order to get an animated mesh, we need to have four pieces, starting with
    the mesh that will be animated, which is created the same way as any other mesh.
    Then, we need the skeleton, which is a set of bones that will match the desired
    mesh topology, such as the arms, fingers, feet, and so on. In *Figure 17.1*, you
    can see an example of a set of bones aligned with our target mesh:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一个动画网格，我们需要四个部分，首先是将要动画化的网格，其创建方式与其他网格相同。然后，我们需要骨骼，它是一组骨头，将匹配所需的网格拓扑结构，例如手臂、手指、脚等。在*图17.1*中，你可以看到一个与我们的目标网格对齐的骨头集合示例：
- en: '![](img/B18585_17_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_01.png)'
- en: 'Figure 17.1: A ninja mesh with a skeleton matching its default pose'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：一个与默认姿势匹配的骨骼忍者网格
- en: 'Once the artist has created the model and its bones, the next step is to do
    skinning, which is the act of associating every vertex of the model to one or
    more bones. This way, when you move a bone, the associated vertices will move
    with it. In *Figure 17.2*, you can see the triangles of a mesh being painted according
    to the color of the bone that affects it as a way to visualize the influence of
    the bones. You will notice blending between colors, meaning that those vertexes
    are affected differently by different bones to allow the vertexes near an articulation
    to bend nicely. Also, *Figure 17.2* illustrates an example of a two-dimensional
    mesh used for two-dimensional games, but the concept is the same:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦艺术家创建了模型及其骨骼，下一步就是进行皮肤绑定，这是将模型每个顶点关联到一个或多个骨骼的行为。这样，当你移动一个骨骼时，相关的顶点会随着它移动。在*图17.2*中，你可以看到网格的三角形根据影响它的骨骼颜色进行绘制，作为可视化骨骼影响的一种方式。你会注意到颜色之间的混合，这意味着那些顶点受到不同骨骼的影响，以便使接近关节的顶点能够弯曲得很好。此外，*图17.2*还展示了用于二维游戏的二维网格的示例，但概念是相同的：
- en: '![](img/B18585_17_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_02.png)'
- en: 'Figure 17.2: Mesh skinning weights visually represented as colors'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：网格皮肤权重以颜色形式直观表示
- en: Finally, the last piece you need is the actual animation, which will simply
    consist of a blending of different poses of the mesh bones. The artist will create
    keyframes in an animation, determining which pose the model needs to have at different
    moments, and then the animation system will simply interpolate between them. Basically,
    the artist will animate the bones, and the skinning system will apply this animation
    to the whole mesh.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要的是实际的动画，它将简单地由网格骨骼的不同姿势的混合组成。艺术家将在动画中创建关键帧，确定模型在不同时刻需要具有的姿势，然后动画系统将简单地在这之间进行插值。基本上，艺术家将动画化骨骼，而皮肤系统将应用此动画到整个网格上。
- en: In order to get the four parts, we need to get the proper assets containing
    them. The usual format in this scenario is **Filmbox** (**FBX**), which we used
    previously to import 3D models. This format can contain every piece we need—the
    model, the skeleton with the skinning, and the animations—but usually those pieces
    will come split into several files to be re-utilized.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这四个部分，我们需要获取包含它们的适当资产。在这种情况下，通常的格式是**Filmbox**（**FBX**），我们之前用它来导入3D模型。此格式可以包含我们需要的每一部分——模型、带有皮肤骨骼和动画——但通常这些部分将分成几个文件以供重新利用。
- en: 'Imagine a city simulator game where we have several citizen meshes with different
    aspects and all of them must be animated. If we have a single FBX per citizen
    containing the mesh, the skinning, and the animation, it will cause each model
    to have its own animation, or at least a clone of the same one, repeating them.
    When we need to change that animation, we will need to update all the mesh citizens,
    which is a time-consuming process. Instead of this, we can have one FBX per citizen,
    containing the mesh and the bones with the proper skinning based on that mesh,
    as well as a separate FBX for each animation, containing the same bones that all
    the citizens have with the proper animation, but without the mesh. This will allow
    us to mix and match the citizen FBX with the animation’s FBX files. You may be
    wondering why both the model FBX and the animation FBX must have the mesh. This
    is because they need to match in order to make both files compatible. In *Figure
    17.3*, you can see how the files should look:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个城市模拟器游戏，其中我们拥有几个具有不同特征的市民网格，并且所有这些网格都必须是动态的。如果我们为每个市民创建一个包含网格、皮肤和动画的单个FBX文件，那么每个模型都将拥有自己的动画，或者至少是相同动画的克隆，重复播放。当我们需要更改该动画时，我们需要更新所有网格市民，这是一个耗时的工作。相反，我们可以为每个市民创建一个包含网格和基于该网格适当皮肤骨骼的FBX文件，以及每个动画一个单独的FBX文件，包含所有市民都有的相同骨骼和适当的动画，但不包含网格。这将使我们能够混合和匹配市民FBX文件和动画FBX文件。你可能想知道为什么模型FBX和动画FBX都必须包含网格。这是因为它们需要匹配，以便使两个文件兼容。在*图17.3*中，你可以看到文件应该如何看起来：
- en: '![](img/B18585_17_03.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_03.png)'
- en: 'Figure 17.3: The animation and model FBX files of the package we will use in
    our project'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：我们将用于项目的动画和模型FBX文件包
- en: Also, it is worth mentioning a concept called retargeting. As we said before,
    in order to mix a model and an animation file, we need them to have the same bone
    structure, which means the same number of bones, hierarchy, and names.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得一提的是一个称为重定位的概念。正如我们之前所说，为了混合模型和动画文件，我们需要它们具有相同的骨骼结构，这意味着相同的骨骼数量、层次结构和名称。
- en: Sometimes, this is not possible, especially when we mix custom models created
    by our artist with external animation files that you can record from an actor
    using motion-capture techniques, or just by buying a mocap (motion-capture) library,
    a set of animations captured on real humans using specific mocap hardware. In
    such cases, it is highly likely that you will encounter different bone structures
    between the one in the mocap library and your character model, so here is where
    retargeting kicks in. This technique allows Unity to create a generic mapping
    between two different humanoid-only bone structures to make them compatible. In
    the next section, *Importing skeletal animations*, we will see how to enable this
    feature.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，这是不可能的，尤其是在我们将我们艺术家创建的定制模型与使用动作捕捉技术从演员那里记录的外部动画文件混合时，或者只是通过购买一个动作捕捉（动作捕捉）库，一组使用特定动作捕捉硬件在真实人类上捕捉的动画。在这种情况下，你很可能会在动作捕捉库和你的角色模型之间遇到不同的骨骼结构，这就是重定向发挥作用的地方。这项技术允许Unity在两个不同的人形骨骼结构之间创建一个通用的映射，使它们兼容。在下一节*导入骨骼动画*中，我们将看到如何启用此功能。
- en: Now that we understand the basics behind skinned meshes, let’s see how we can
    get the model’s assets with bones and animations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了着色网格背后的基础知识，让我们看看我们如何获取带有骨骼和动画的模型资产。
- en: Importing skeletal animations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入骨骼动画
- en: We can download a character model by searching for it in the Asset Store, under
    the **3D** | **Characters** | **Humanoids** section. You can also use external
    sites, such as the website called Mixamo, to download them. Note that sometimes
    you will need to download several packages because sometimes packages come only
    with the skinned model, and others with animation only. Luckily the one we downloaded
    already contains the skinned meshes and the animations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在资产商店的**3D** | **角色** | **人类**部分搜索来下载一个角色模型。你也可以使用外部网站，例如名为Mixamo的网站来下载它们。请注意，有时你可能需要下载几个包，因为有时包只包含着色模型，而其他包只包含动画。幸运的是，我们下载的这个已经包含了着色网格和动画。
- en: In my package content, I can find the animation’s FBX files in the `Animations`
    folder and the FBX file of my model called `Polyart_Mesh` in the `Mesh` folder.
    Remember that sometimes you won’t have them separated like this, and the animations
    may be located in the same FBX as the model, if any animations are present at
    all. Now that we have the required files, let’s discuss how to properly configure
    them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的包内容中，我可以在`Animations`文件夹中找到动画的FBX文件，以及我在`Mesh`文件夹中的模型`Polyart_Mesh`的FBX文件。记住，有时它们不会像这样分开，如果存在任何动画，动画可能位于与模型相同的FBX文件中。现在我们已经有了所需的文件，让我们讨论如何正确配置它们。
- en: 'Let’s start selecting the **Model** file and checking the **Rig** tab. Within
    this tab, you will find a setting called **Animation Type**, as shown in *Figure
    17.4*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选择**模型**文件并检查**绑定**标签开始。在这个标签中，你会找到一个名为**动画类型**的设置，如图*图17.4*所示：
- en: '![](img/B18585_17_04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图17.4](img/B18585_17_04.png)'
- en: 'Figure 17.4: The Rig properties'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：绑定属性
- en: 'This property contains the following options:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性包含以下选项：
- en: '**None**: Mode for non-animated models; every static mesh in your game will
    use this mode.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：用于非动画模型的模式；你的游戏中的每个静态网格都将使用此模式。'
- en: '**Legacy**: The mode to be used in old Unity Projects and models; do not use
    this in new projects.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旧版**：用于旧Unity项目和模型的模式；不要在新项目中使用。'
- en: '**Generic**: A new animation system that can be used in all kinds of models
    but is commonly used in non-humanoid models, such as horses, octopuses, and so
    on. If you use this mode, both the model and animation FBX files must have the
    exact same bone names and structure, thereby reducing the possibility of combining
    animation from external sources.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**：一种可用于所有类型模型的全新动画系统，但通常用于非人类模型，如马、章鱼等。如果你使用此模式，模型和动画FBX文件必须具有完全相同的骨骼名称和结构，从而减少了从外部来源组合动画的可能性。'
- en: '**Humanoid**: New animation systems designed to be used in humanoid models.
    It enables features such as retargeting and **Inverse Kinematics** (**IK**). This
    allows you to combine models with different bones than the animation because Unity
    will create a mapping between those structures and a generic one, called the avatar.
    Take into account that sometimes the automatic mapping can fail, and you will
    need to correct it manually; so, if your generic model has everything you need,
    I recommend you stick to **Generic** if that’s the default configuration of the
    FBX.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人类**：为人类模型设计的新动画系统。它启用了诸如重定位和**逆运动学**（**IK**）等功能。这允许你将具有不同骨骼的模型与动画结合，因为 Unity
    将创建这些结构与通用结构之间的映射，称为化身。请注意，有时自动映射可能会失败，你需要手动进行更正；因此，如果你的通用模型包含你需要的一切，我建议如果你是 FBX
    的默认配置，就坚持使用**通用**。'
- en: In my case, the FBX files in my package have the modes set to **Humanoid**,
    so that’s good, but remember, only switch to other modes if it is absolutely necessary
    (for example, if you need to combine different models and animations). Now that
    we have discussed the **Rig** settings, let’s talk about the **Animation** settings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况中，我的包中的 FBX 文件模式设置为**人类**，这是好的，但请记住，只有当绝对必要时才切换到其他模式（例如，如果您需要组合不同的模型和动画）。现在我们已经讨论了**绑定**设置，让我们谈谈**动画**设置。
- en: 'In order to do this, select any animation FBX file and look for the **Animation**
    tab in the Inspector window. You will find several settings, such as the **Import
    Animation** checkbox, which must be marked if the file has an animation (not the
    model files), and the **Clips** list, where you will find all the animations in
    the file. In the following screenshot, you can see the **Clips** list for one
    of our animation files:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，选择任何动画 FBX 文件，并在检查器窗口中查找**动画**选项卡。你将找到几个设置，例如，如果文件包含动画（不是模型文件），则必须勾选**导入动画**复选框，以及**片段**列表，其中包含文件中的所有动画。在下面的屏幕截图中，你可以看到我们的动画文件之一的**片段**列表：
- en: '![](img/B18585_17_05.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_05.png)'
- en: 'Figure 17.5: A Clips list in the Animation settings'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5：动画设置中的片段列表
- en: 'An FBX file with animations usually contains a single large animation track,
    which can contain one or several animations. Either way, by default, Unity will
    create a single animation based on that track, but if that track contains several
    animations, you will need to split them manually. In our case, our FBX contains
    a single animation, but in order to learn how to split it in other cases, do the
    following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 带有动画的 FBX 文件通常包含一个单独的大动画轨道，该轨道可以包含一个或多个动画。无论如何，默认情况下，Unity 将根据该轨道创建一个动画，但如果该轨道包含多个动画，你需要手动拆分它们。在我们的案例中，我们的
    FBX 包含一个单独的动画，但为了了解如何在其他情况下拆分它，请按照以下步骤操作：
- en: From the **Clips** list, select any animation that you want to recreate; in
    my case, I will choose `Run_guard_AR`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**片段**列表中选择任何你想要重新创建的动画；以我的情况为例，我将选择`Run_guard_AR`。
- en: 'Take a look at the **Start** and **End** values below the animation timeline
    and remember them; we will use them to recreate this clip:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看动画时间线下的**开始**和**结束**值，并记住它们；我们将使用它们来重新创建这个片段：
- en: '![](img/B18585_17_06.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_06.png)'
- en: 'Figure 17.6: The clip settings'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6：片段设置
- en: Use the **+** button to create a new clip and select it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**按钮创建一个新的片段并选择它。
- en: Rename it to something similar to the original using the input field that currently
    says something like `Take 001`. In my case, I will name it `Run`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入框当前显示的类似`Take 001`的内容将其重命名为与原始名称相似的内容。以我的情况为例，我将命名为`Run`。
- en: Set the **End** and **Start** properties with the values we needed to remember
    in *step 2*. In my case, I have `20` for **End** and `0` for **Start**. This information
    usually comes from the artist that made the animation, but you can just try the
    number that works best or simply drag the blue markers in the timeline on top
    of these properties.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用步骤 2 中记住的值设置**结束**和**开始**属性。以我的情况为例，我将**结束**设置为`20`，**开始**设置为`0`。这些信息通常来自制作动画的艺术家，但你可以尝试最适合的数字，或者简单地拖动时间线上的蓝色标记到这些属性上。
- en: 'If an animation needs to loop, check the **Loop Time** checkbox to guarantee
    that. This will make the animation repeat constantly, which is required in most
    animations like **Walk** or **Run**. If not, the animation will play once and
    never repeat:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果动画需要循环播放，请勾选**循环时间**复选框以确保这一点。这将使动画不断重复，这在大多数动画如**行走**或**跑步**中是必需的。如果不勾选，动画将只播放一次，不会重复：
- en: '![](img/B18585_17_07.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_07.png)'
- en: 'Figure 17.7: Looping the animation'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7：循环动画
- en: 'Preview the clip by clicking on the bar titled for your animation (**Run**,
    in my case) at the very bottom of the Inspector window and click on the **Play**
    button. You can see the default Unity model in some cases, but you can see your
    own by dragging the model file to the preview window because it is important to
    check whether our models are properly configured. If the animation does not play,
    you will need to check whether the **Animation Type** setting matches the animation
    file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击检查器窗口底部为你的动画命名的栏（在我的例子中是**运行**）并点击**播放**按钮来预览剪辑。在某些情况下，你可以看到默认的Unity模型，但你可以通过将模型文件拖到预览窗口中看到自己的模型，因为检查我们的模型是否正确配置非常重要。如果动画没有播放，你需要检查**动画类型**设置是否与动画文件匹配：
- en: '![](img/B18585_17_08.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_08.png)'
- en: 'Figure 17.8: Animation preview'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8：动画预览
- en: 'Open the animation asset (the FBX) by clicking the arrow on its left, and check
    the sub-assets. You will see that there is an asset with the same title as your
    animation:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击其左侧的箭头打开动画资产（FBX），并检查子资产。你会看到有一个与你的动画同名资产：
- en: '![](img/B18585_17_09.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_09.png)'
- en: 'Figure 17.9: Generated animation clips'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9：生成的动画剪辑
- en: Remember that there are plenty of other settings aside from the **Init** frame,
    **End** frame, and **Loop Time**. The character I downloaded required other settings
    like **Root Transform Rotation**, **Root Transform Position**, and **Mask** to
    make it work, and the mileage may vary between character packages. If you are
    recreating an existing animation, consider copying all settings as they were,
    or just use the default one. These mentioned settings are beyond the scope of
    the book, but you can always consult them in the Unity documentation at [https://docs.unity3d.com/Manual/class-AnimationClip.html](https://docs.unity3d.com/Manual/class-AnimationClip.html).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，除了**初始化**帧、**结束**帧和**循环时间**之外，还有很多其他设置。我下载的角色需要其他设置，如**根变换旋转**、**根变换位置**和**遮罩**才能正常工作，不同角色包之间的差异可能很大。如果你正在重新创建现有的动画，考虑复制所有设置，或者只使用默认设置。这些提到的设置超出了本书的范围，但你可以在Unity文档中查阅它们，网址为[https://docs.unity3d.com/Manual/class-AnimationClip.html](https://docs.unity3d.com/Manual/class-AnimationClip.html)。
- en: Now that we have covered the basic configuration, let’s learn how to integrate
    animations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本配置，让我们学习如何集成动画。
- en: Integration using Animation Controllers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动画控制器进行集成
- en: When adding animations to our characters, we need to think about the flow of
    the animations, which means thinking about which animations must be played, when
    each animation must be active, and how transitions between animations should happen.
    In previous Unity versions, you needed to code that manually, generating complicated
    scripts of C# code to handle complex scenarios; but now, we have **Animation Controllers**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当向我们的角色添加动画时，我们需要考虑动画的流程，这意味着思考哪些动画必须播放，每个动画何时必须处于活动状态，以及动画之间的转换应该如何发生。在之前的Unity版本中，你需要手动编写代码，生成复杂的C#脚本以处理复杂场景；但现在，我们有**动画控制器**。
- en: Animation Controllers are a state machine-based asset where we can diagram the
    transition logic between animations with a visual editor called **Animator**.
    The idea is that each animation is a state and our model will have several of
    them. Only one state can be active at a time, so we need to create transitions
    in order to change them, which will have conditions that must be met in order
    to trigger the transition process. Conditions are comparisons of data about the
    character to be animated, such as its velocity, whether it’s shooting or crouched,
    and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器是一种基于状态机的资产，我们可以使用名为**Animator**的可视化编辑器来绘制动画之间的转换逻辑。其理念是每个动画都是一个状态，我们的模型将包含多个状态。一次只能有一个状态处于活动状态，因此我们需要创建转换来改变它们，这些转换将具有必须满足的条件才能触发转换过程。条件是对要动画化的角色数据的比较，例如其速度、是否在射击或蹲下等。
- en: 'So, basically, an Animation Controller or state machine is a set of animations
    with transition rules that will dictate which animation should be active. Let’s
    start creating a simple Animation Controller by doing the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，动画控制器或状态机是一组具有转换规则的动画，它将决定哪个动画应该处于活动状态。让我们通过以下步骤开始创建一个简单的动画控制器：
- en: Click the **+** button under the **Project** view, click on **Animator Controller**,
    and call it `Player`. Remember to locate your asset within a folder for proper
    organization; I will call mine `Animations`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图下点击**+**按钮，点击**动画控制器**，并将其命名为`Player`。请记住，将您的资产定位在文件夹中以进行适当的组织；我将我的命名为`Animations`。
- en: Double-click on the asset to open the **Animator** window. Don’t confuse this
    window with the **Animation** window; the **Animation** window serves to create
    new Animations, but for now, we will stick with the downloaded ones.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击资产以打开**动画器**窗口。不要将此窗口与**动画**窗口混淆；**动画**窗口用于创建新的动画，但到目前为止，我们将坚持使用下载的动画。
- en: 'Search for the **Idle** animation clip of your character in the **Animations**
    folder of your characters package and drag it into the **Animator** window. In
    my case it was called **Idle_guard_ar**. Remember to drag the sub-asset, not the
    entire file. This will create a box in the Controller representing the animation
    that will be connected to the entry point of the Controller, indicating that the
    animation will be the default one because it is the first one that we dragged.
    If you don’t have an **Idle** animation, I encourage you to download one from
    the Asset Store, maybe searching in other characters’ packages. We will need at
    least one **Idle** and one **walking**/**running** animation clip:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你角色的动画包的**动画**文件夹中搜索你角色的**空闲**动画片段，并将其拖入**动画器**窗口。在我的例子中，它被命名为**Idle_guard_ar**。请记住，拖动子资产，而不是整个文件。这将在控制器中创建一个代表动画的框，该框将连接到控制器的入口点，表示该动画将是默认的，因为它是我们首先拖动的。如果你没有**空闲**动画，我鼓励你从资产商店下载一个，也许可以在其他角色的包中搜索。我们需要至少一个**空闲**和一个**行走**/**跑步**动画片段：
- en: '![](img/B18585_17_10.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_10.png)'
- en: 'Figure 17.10: Dragging an animation clip from an FBX asset into an Animator
    Controller'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10：将动画片段从FBX资产拖动到动画控制器
- en: Drag the running animation in the same way, which is **Run_guard_AR** in my
    case.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式拖动跑步动画，在我的例子中是**Run_guard_AR**。
- en: Right-click on the **Idle** animation box in the **Animator** window, select
    **Make Transition**, and left-click on the **Run** animation. This will create
    a transition between **Idle** and **Run**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**动画器**窗口中的**空闲**动画框，选择**创建过渡**，然后左键点击**跑**动画。这将创建**空闲**和**跑**之间的过渡。
- en: 'Create another transition from **Run** to **Idle** in the same way:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式从**跑**到**空闲**创建另一个过渡：
- en: '![](img/B18585_17_11.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_11.png)'
- en: 'Figure 17.11: Transitions between two animations'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.11：两个动画之间的过渡
- en: 'Transitions must have conditions in order to prevent animations from swapping
    constantly, but in order to create conditions, we need data to make comparisons.
    We will add properties to our Controller, which will represent data used by the
    transitions. Later, in the *Scripting Animations* section of this chapter, we
    will set that data to match the current state of our object. But for now, let’s
    create the data and test how the Controller reacts to different values. In order
    to create conditions based on properties, do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡必须具有条件，以防止动画不断交换，但为了创建条件，我们需要用于比较的数据。我们将向我们的控制器添加属性，这些属性将代表过渡使用的数据。稍后，在本章的*脚本动画*部分，我们将设置这些数据以匹配我们对象当前的状态。但到目前为止，让我们创建数据并测试控制器对不同值的反应。为了根据属性创建条件，请执行以下操作：
- en: Click on the **Parameters** tab in the top-left part of the **Animator** window.
    If you don’t see it, click on the button that looks like an eye crossed by a line
    to display the tabs. The icon will change to an uncrossed eye.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**窗口的左上角点击**参数**选项卡。如果您看不到它，请点击看起来像被一条线交叉的眼睛的按钮以显示选项卡。图标将变为未交叉的眼睛。
- en: 'Click on the **+** button and select **Float** to create a number that will
    represent the velocity of our character, naming it `Velocity`. If you missed the
    renaming part, just left-click on the variable and rename it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**按钮并选择**浮点数**来创建一个代表我们角色速度的数字，命名为`Velocity`。如果您错过了重命名部分，只需左键点击变量并重命名它：
- en: '![](img/B18585_17_12.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_12.png)'
- en: 'Figure 17.12: The Parameters tab with a float Velocity property'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.12：带有浮点速度属性的参数选项卡
- en: Click on the **Idle to Run** transition (the white line with an arrow in the
    middle) and look at the Conditions property in the Inspector window.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**空闲到跑**过渡（中间有箭头的白色线条）并查看检查器窗口中的条件属性。
- en: 'Click on the **+** button at the bottom of the list, which will create a condition
    that will rule the transition. The default setting will take the first parameter
    of our animator (in this case, it is **Velocity**) and will set the default comparer,
    in this case, **Greater**, to a value of `0`. This tells us that the transition
    will execute from **Idle** to **Run** if **Idle** is the current animation and
    the velocity of the Player is greater than `0`. I recommend you set a slightly
    higher value, such as `0.01`, to prevent any float rounding errors (a common CPU
    issue). Also, remember that the actual value of **Velocity** needs to be set manually
    via scripting, which we will do in this chapter’s *Scripting animations* section:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击列表底部的**+**按钮，这将创建一个将控制转换的条件。默认设置将取我们动画器的第一个参数（在这种情况下，它是**速度**），并将默认比较器设置为**大于**，值为`0`。这告诉我们，如果**空闲**是当前动画且玩家的速度大于`0`，则转换将从**空闲**到**跑动**执行。我建议您设置一个稍高一点的值，例如`0.01`，以防止任何浮点舍入错误（一个常见的CPU问题）。此外，请记住，**速度**的实际值需要通过脚本手动设置，我们将在本章的*脚本动画*部分进行操作：
- en: '![](img/B18585_17_13.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_13.png)'
- en: 'Figure 17.13: Condition to check whether the velocity is greater than 0.01'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.13：检查速度是否大于0.01的条件
- en: 'Do the same to the **Run** to **Idle** transition, but this time, change **Greater**
    to **Less** and again set the value to `0.01`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**跑动**到**空闲**的转换也做同样的操作，但这次将**大于**改为**小于**，并将值设置为`0.01`：
- en: '![](img/B18585_17_14.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_14.png)'
- en: 'Figure 17.14: Condition to check whether a value is less than 0.01'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.14：检查值是否小于0.01的条件
- en: 'Now that we have our first Animator Controller set up, it’s time to apply it
    to an object. In order to do that, we will need a series of components. First,
    when we have an animated character, rather than a regular Mesh Renderer, we use
    the **Skinned Mesh Renderer**. If you select your player or enemy characters and
    view their children, GameObjects, you will see the Skinned Mesh Renderer in one
    or more of them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了第一个动画控制器，是时候将其应用到对象上了。为了做到这一点，我们需要一系列组件。首先，当我们有一个动画角色时，而不是常规的网格渲染器，我们使用**皮肤网格渲染器**。如果您选择您的玩家或敌人角色并查看它们的子对象，GameObject，您将看到皮肤网格渲染器在它们中的一个或多个中：
- en: '![](img/B18585_17_15.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_15.png)'
- en: 'Figure 17.15: A Skinned Mesh Renderer component'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.15：皮肤网格渲染器组件
- en: 'This component will be in charge of applying the bones’ movements to the mesh.
    If you search the children of the model, you will find some bones; you can try
    rotating, moving, and scaling them to see the effect, as shown in the following
    screenshot. Bear in mind that your bone hierarchy might be different from mine
    if you downloaded another package from the Asset Store:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将负责将骨骼的运动应用到网格上。如果您搜索模型的子对象，您将找到一些骨骼；您可以尝试旋转、移动和缩放它们以查看效果，如下面的截图所示。请注意，如果从资产商店下载了另一个包，您的骨骼层次结构可能与我不同：
- en: '![](img/B18585_17_16.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_16.png)'
- en: 'Figure 17.16: Rotating the neckbone'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.16：旋转颈骨
- en: 'The other component that we need is **Animator**, which is automatically added
    to the skinned meshes at its root GameObject. This component will be in charge
    of applying the state machine that we created in the Animator Controller if the
    animation FBX files are properly configured, as we mentioned earlier. In order
    to apply the Animator Controller, do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的另一个组件是**动画器**，它将自动添加到根GameObject的皮肤网格中。如果动画FBX文件配置正确，该组件将负责应用我们在动画控制器中创建的状态机，正如我们之前提到的。为了应用动画控制器，请执行以下操作：
- en: Select the player in the **Hierarchy** and locate the **Animator** component
    in the root GameObject.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择玩家，并在根GameObject中定位**动画器**组件。
- en: Click on the circle to the right of the **Controller** property and select the
    **Player** controller we created earlier. You can also just drag it from the **Project**
    window.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**控制器**属性右侧的圆圈，并选择我们之前创建的**玩家**控制器。您也可以直接从**项目**窗口拖动它。
- en: 'Make sure that the **Avatar** property is set to the avatar inside the FBX
    model of the character (`Polyart_Mesh` being the FBX model in our example project);
    this will tell the animator that we will use that skeleton. You can identify the
    avatar asset by its icon of a person, as shown in the following screenshot. Usually,
    this property is correctly set automatically when you drag the FBX model to the
    scene:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将 **Avatar** 属性设置为角色 FBX 模型内部的头像（在我们的示例项目中，`Polyart_Mesh` 是 FBX 模型）；这将告诉动画师我们将使用该骨架。您可以通过以下截图所示的人形图标识别头像资产。通常，当您将
    FBX 模型拖动到场景中时，此属性会自动正确设置：
- en: '![](img/B18585_17_17.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.17](img/B18585_17_17.png)'
- en: 'Figure 17.17: Animator using the Player controller and the robot avatar'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.17：使用 Player 控制器和机器人角色头像的动画师
- en: 'Without stopping the game, open the Animator Controller asset again by double-clicking
    it and selecting the character in the **Hierarchy** pane. By doing this, you should
    see the current state of the animation being played by that character, using a
    bar to represent the current part of the animation:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不停止游戏的情况下，通过双击它并选择 **Hierarchy** 窗格中的角色来再次打开 Animator 控制器资产。通过这样做，您应该看到该角色正在播放的当前动画状态，使用条形图表示动画的当前部分：
- en: '![](img/B18585_17_18.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.18](img/B18585_17_18.png)'
- en: 'Figure 17.18: The Animator Controller in Play mode while an object is selected,
    showing the current animation and its progress'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.18：在 Play 模式下选择对象时，Animator 控制器显示当前动画及其进度
- en: 'Using the **Animator** window, change the value of **Velocity** to `1.0` and
    see how the transition will execute. Feel free to disable the **WaveSpawners**
    to test this, given they will probably kill the player before we can safely do
    so:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Animator** 窗口，将 **Velocity** 的值更改为 `1.0` 并观察过渡如何执行。如果您想测试，可以禁用 **WaveSpawners**，因为它们可能会在我们安全执行之前杀死玩家：
- en: '![](img/B18585_17_19.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.19](img/B18585_17_19.png)'
- en: 'Figure 17.19: Setting the velocity of the Controller to trigger a transition'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.19：设置控制器的速度以触发过渡
- en: Depending on how the **Run** animation was set, your character might start to
    move instead of executing the animation in place. This is caused by root motion,
    a feature that will move the character based on the animation movement. Sometimes,
    this is useful, but due to the fact that we will fully move our character using
    scripting, we want that feature to be turned off. You can do that by unchecking
    the **Apply Root Motion** checkbox in the **Animator** component of the **Character**
    object, as seen in *Figure 17.17*.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据如何设置 **Run** 动画，您的角色可能会开始移动而不是在原地执行动画。这是由根运动引起的，这是一个基于动画运动移动角色的功能。有时这很有用，但由于我们将完全使用脚本移动我们的角色，我们希望关闭此功能。您可以通过在
    **Character** 对象的 **Animator** 组件中取消选中 **Apply Root Motion** 复选框来实现这一点，如图 *17.17*
    所示。
- en: 'You will also notice a delay between changing the Velocity value and the start
    of the animation transition. That’s because, by default, Unity will wait for the
    original animation to end before executing a transition, but in this scenario,
    we don’t want that. We need the transition to start immediately. In order to do
    this, select each transition of the Controller, and in the Inspector window, uncheck
    the **Has Exit Time** checkbox. When this property is checked, a hidden condition
    for the transition to execute is waiting for the animation to end. But with this
    unchecked, the transition can execute at any moment during the animation, which
    we want, given that we don’t want any delay between the player being idle and
    running:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还会注意到在更改 Velocity 值和动画过渡开始之间有一个延迟。这是因为默认情况下，Unity 将等待原始动画结束后再执行过渡，但在这个场景中，我们不想这样。我们需要过渡立即开始。为了做到这一点，选择控制器的每个过渡，并在检查器窗口中取消选中
    **Has Exit Time** 复选框。当此属性被选中时，过渡执行的隐藏条件是等待动画结束。但取消选中后，过渡可以在动画的任何时刻执行，这正是我们想要的，因为我们不希望在玩家空闲和跑步之间有任何延迟：
- en: '![](img/B18585_17_20.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.20](img/B18585_17_20.png)'
- en: 'Figure 17.20: Disabling the Has Exit Time checkbox to execute the transition
    immediately'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.20：取消选中“具有退出时间”复选框以立即执行过渡
- en: You can start dragging other animations into the Controller and create complex
    animation logic, such as adding jump, fall, or crouched animations. I invite you
    to try other parameter types, such as a Boolean, that use checkboxes instead of
    numbers. Also, as you develop your game further, your Controller will grow in
    its number of animations. To manage that, there are other features worth researching,
    such as **Blend Trees** and sub-state machines, but that’s beyond the scope of
    this book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其他动画拖入控制器，并创建复杂的动画逻辑，例如添加跳跃、跌倒或蹲下动画。我邀请你尝试其他参数类型，例如布尔值，它使用复选框而不是数字。此外，随着你游戏的进一步开发，你的控制器中的动画数量将会增加。为了管理这一点，有一些其他值得研究的功能，例如**混合树**和子状态机，但这超出了本书的范围。
- en: In this section, we learned how to integrate animation clips into our character
    through Animator Controllers. We added all needed animations and created the necessary
    transitions between them to react to the game circumstances, like the character
    velocity changes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过Animator Controllers将动画剪辑集成到我们的角色中。我们添加了所有需要的动画，并创建了它们之间的必要过渡，以应对游戏情况，如角色速度变化。
- en: Now that we have integrated the idle and run animations, let’s integrate the
    shoot animation, which requires us to use **Avatar Masks**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经集成了空闲和跑步动画，让我们集成射击动画，这需要我们使用**Avatar Masks**。
- en: Using Avatar Masks
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Avatar Masks
- en: 'At first, this case seems as simple as dragging a shoot animation and making
    transitions that use the `Shooting` Boolean parameter as a condition. Consider,
    however, that we can shoot while walking and while running, so that leads to two
    shooting animations, **Walking Shooting** and **Idle Shooting**. If you follow
    this logic, you can think of shooting while falling, jumping, etc., which leads
    to a greater number of animation combinations. Imagine having different shooting
    animations for different weapons! Luckily, we have a better solution: a way to
    combine several animations, using Avatar Masks.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个案例看起来就像拖动一个射击动画并创建使用`Shooting`布尔参数作为条件的过渡那么简单。然而，考虑到我们可以在行走和跑步时射击，这导致有两个射击动画，**行走射击**和**空闲射击**。如果你遵循这个逻辑，你可以想到在跌倒、跳跃等情况下射击，这会导致更多的动画组合。想象一下为不同的武器拥有不同的射击动画！幸运的是，我们有一个更好的解决方案：使用Avatar
    Masks结合多个动画的方法。
- en: The animations state machine we created in the Animator Controller is what is
    called a **layer**, and an Animator Controller can have several layers. This means
    that we can have more than one state machine in an Animator Controller. There
    are several reasons to use this, but the common one is to combine layers with
    Avatar Masks, an asset that allows us to make a specific Animator Controller layer
    or state machine to affect certain bones, so we can set different state machines
    for different parts of the body.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Animator Controller中创建的动画状态机被称为**层**，一个Animator Controller可以有多个层。这意味着我们可以在Animator
    Controller中拥有多个状态机。使用这种方法有几个原因，但常见的一个是将层与Avatar Masks结合，这是一个允许我们使特定的Animator Controller层或状态机影响某些骨骼的资产，因此我们可以为身体的不同部分设置不同的状态机。
- en: We can use this to solve the shooting scenario we discussed previously, splitting
    our player animation logic into two parts, the upper part of the body, and the
    lower part. The idea is that the lower part will switch between idle and running
    animations, while the upper part can switch between idle, running, and shooting.
    This allows us to have scenarios where the lower part is running while the upper
    part is shooting, or the lower part is idle and the upper part also, or any combination
    we can imagine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个方法来解决之前讨论过的射击场景，将我们的玩家动画逻辑分成两部分，上半身和下半身。想法是下半身将在空闲和跑步动画之间切换，而上半身可以在空闲、跑步和射击之间切换。这允许我们拥有下半身跑步而上半身射击的场景，或者下半身空闲而上半身也空闲，或者任何我们可以想象到的组合。
- en: 'Let’s start by creating the second layer by doing the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第二个层开始，按照以下步骤操作：
- en: Download a shooting animation from the internet or the Asset Store if you don’t
    have one already. In our case we already have several shooting animations, and
    we are going to pick the one called `Idle_Shoot_ar`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有射击动画，可以从互联网或Asset Store下载一个。在我们的例子中，我们已经有了一些射击动画，我们将选择一个叫做`Idle_Shoot_ar`的动画。
- en: 'In the Animator Controller, do a single click in **Base Layer** and rename
    it **LowerBody**. If you don’t see the layers list, click the **Layers** button
    at the top-left part of the **Animator** window:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画控制器中，在**基本层**上单击一次，并将其重命名为**下半身**。如果您看不到层列表，请点击**动画**窗口左上角的**层**按钮：
- en: '![](img/B18585_17_21.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_21.png)'
- en: 'Figure 17.21: Renaming the base layer'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.21：重命名基本层
- en: Add a second layer to the Controller using the **+** button and rename it `UpperBody`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**按钮在控制器中添加第二个层，并将其重命名为`UpperBody`。
- en: 'Select the layer and add the **Idle**, **Run**s, and **Shoot** animations to
    it, connecting the states with transitions. Remember to uncheck **Has Exit Time**
    in each transition:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择层，并添加**空闲**、**奔跑**和**射击**动画到它，通过转换连接状态。记得在每个转换中取消勾选**有退出时间**：
- en: '![](img/B18585_17_22.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_22.png)'
- en: 'Figure 17.22: UpperBody state machine'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.22：上半身状态机
- en: Add the same transition logic between **Idle** and **Run** used before, using
    **Velocity** as the parameter for the conditions, as before.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前相同的转换逻辑在**空闲**和**奔跑**之间添加，使用**速度**作为条件参数，如之前所述。
- en: 'For the shooting transitions, create a Boolean parameter called **Shooting**:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于射击转换，创建一个名为**射击**的布尔参数：
- en: '![](img/B18585_17_23.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_23.png)'
- en: 'Figure 17.23: Shooting Boolean'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.23：射击布尔值
- en: Make both transitions to shooting (**Idle** to **Shoot** and **Run** to **Shoot**)
    execute when the **Shooting** Boolean is **true**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**射击**布尔值为**真**时，使两个射击转换（**空闲**到**射击**和**奔跑**到**射击**）执行。
- en: 'Make the return transition from **Shoot** to **Idle** when the **Shooting**
    Boolean is false and **Velocity** is less than `0.01`, and the return from **Shoot**
    to **Run** when **Shooting** is **true** and **Velocity** is greater than `0.01`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**射击**布尔值为假且**速度**小于`0.01`时，从**射击**状态过渡到**空闲**状态，当**射击**为真且**速度**大于`0.01`时，从**射击**状态过渡到**奔跑**状态：
- en: '![](img/B18585_17_24.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_24.png)'
- en: 'Figure 17.24: The Shoot to Idle transition at the top, the Shoot to Run transition
    in the middle, and both the Idle to Shoot and Run to Shoot transitions at the
    bottom'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.24：顶部的射击到空闲转换，中间的射击到奔跑转换，以及底部的空闲到射击和奔跑到射击转换
- en: 'Now that we have the layers created, let’s apply the Avatar Masks to them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了层，让我们将这些Avatar Masks应用到它们上：
- en: Create an Avatar Mask using the **+** button in the **Project View**, and name
    the first one `UpperBodyMask`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**项目视图**中的**+**按钮创建一个Avatar Mask，并将其命名为`UpperBodyMask`。
- en: Select the `UpperBodyMask` asset in the **Inspector** and click the arrow on
    the left where it says **Humanoid to expand this section**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中选择`UpperBodyMask`资产，并点击左侧显示**人类到扩展此部分**的箭头。
- en: 'Click the lower parts of the body displayed in the **Inspector** until they
    become red:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示在**检查器**中的身体下部的部分，直到它们变成红色：
- en: '![](img/B18585_17_25.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_25.png)'
- en: 'Figure 17.25: UpperBodyMask asset configs'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.25：UpperBodyMask资产配置
- en: In the Animator Controller, select the **UpperBody** layer and click on the
    wheel to its right to display some options.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画控制器中，选择**上半身**层，并点击其右侧的轮子以显示一些选项。
- en: Click at the circle at the right of the **Mask** property and select the **UpperBodyMask**
    asset in the window that appears.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**遮罩**属性的右侧圆圈，并在出现的窗口中选择**UpperBodyMask**资产。
- en: 'Click again at the wheel of the **UpperBody** layer and set its **Weight**
    to `1`. Since the two layers are affecting different parts of the body, both of
    them have the same priority. In scenarios where two layers affect the same bones,
    the weight is used to calculate which one has more influence:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**上半身**层的轮子，并将其**权重**设置为`1`。由于两个层影响身体的不同的部分，它们都有相同的优先级。在两个层影响相同骨骼的情况下，权重用于计算哪个层有更大的影响：
- en: '![](img/B18585_17_26.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_26.png)'
- en: 'Figure 17.26: Setting the Weight and the Mask of a layer'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.26：设置层的权重和遮罩
- en: Click again on the wheel and observe how the **Blending** parameter is set to
    **Override**, meaning that the bones that this layer affects (driven by the Avatar
    Mask) will override whatever animation the base layer has—the base layer, in this
    case, being **LowerBody**. That’s how this layer takes ownership of the upper
    part of the body.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击轮子，并观察**混合**参数是否设置为**覆盖**，这意味着此层影响的骨骼（由Avatar Mask驱动）将覆盖基本层（在这种情况下为**下半身**）的任何动画。这就是这个层如何接管身体的上半部分。
- en: Test this again, changing the values of the parameters while in **Play** mode.
    For example, try checking **Shooting** and then set **Velocity** to `1`, and then
    to `0`, to finally uncheck **Shooting**, and see how the transitions execute.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**播放**模式下更改参数的值，再次进行测试。例如，尝试勾选**射击**，然后将**速度**设置为`1`，然后设置为`0`，最后取消勾选**射击**，看看过渡是如何执行的。
- en: 'You might notice that our character might not be pointing in the right direction
    when shooting. This is because the orientation of the character is modified for
    this **Shoot** animation compared to **Idle** and **Run**, but the **Base Layer**
    still has ownership of that. We can make the **UpperBodyMask** control the orientation
    by clicking the circle at the bottom of the human figure in the **Humanoid** section
    of the Avatar Mask until it becomes green:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会注意到，当射击时，我们的角色可能不会指向正确的方向。这是因为与**空闲**和**跑**相比，角色的方向被修改了，但**基础层**仍然拥有这个权限。我们可以通过点击**人类**部分中人物底部的圆圈来使**UpperBodyMask**控制方向，直到它变成绿色：
- en: '![](img/B18585_17_27.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_27.png)'
- en: 'Figure 17.27: Giving the mask authority over the player orientation'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.27：赋予面具对玩家方向的权限
- en: The issue here is that you will now see the character moving the feet sideways
    when running and shooting. There’s no easy solution here other than to modify
    the original animations. In this case, this character has Idle, Idle Shooting,
    Run and Run Shooting animations, so it clearly has been created without having
    Avatar Masks in mind, instead just having all possible animation combinations.
    An alternative is to find another package that works better with Avatar Masks.
    For learning purposes, we will stick with this, but note that Avatar Masks are
    not a must; you might be good to go just using all possible animation permutations
    in a single Animator Controller state machine with all the needed transitions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，你现在会看到角色在跑步和射击时将脚向侧面移动。除了修改原始动画之外，这里没有简单的解决方案。在这种情况下，这个角色有Idle、Idle Shooting、Run和Run
    Shooting动画，所以很明显，它是在没有考虑到Avatar Masks的情况下创建的，而是只考虑了所有可能的动画组合。一个替代方案是找到另一个与Avatar
    Masks配合得更好的包。为了学习目的，我们将坚持使用这个，但请注意，Avatar Masks不是必需的；你可能只需要使用单个动画控制器状态机中的所有可能的动画排列，并包含所有需要的过渡，就可以很好地进行。
- en: 'Another issue you might notice when firing when the Shoot animation is playing
    is that the muzzle effect will stay in the original position of the weapon. Since
    the weapon mesh is affected by the skinning animation but not its Transform position,
    the muzzle cannot follow it. In order to solve this, you can reparent the Muzzle
    Effect to one of the bones of the weapons—in this case, the GameObject called
    Trigger_Right, one of the children of the Hips GameObject. Not all animations
    will have bones for the weapons, so this is one of the possible scenarios you
    could face:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当射击动画正在播放时，你可能注意到的一个问题是，枪口效果会停留在武器的原始位置。由于武器网格受到皮肤动画的影响，但不受其变换位置的影响，因此枪口无法跟随它。为了解决这个问题，你可以将枪口效果重新父级化到武器的一个骨骼上——在这个例子中，是名为Trigger_Right的GameObject，它是Hips
    GameObject的一个子对象。并非所有动画都会有武器的骨骼，所以这是你可能遇到的可能场景之一：
- en: '![](img/B18585_17_28.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_28.png)'
- en: 'Figure 17.28: Reparenting the Muzzle Effect to one of the weapon’s bones'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.28：将枪口效果重新父级化到武器的一个骨骼
- en: Remember to apply the same changes we made to our player to the enemy, which
    means adding and setting the Player Animator Controller to its **Animator** component
    and changing the `Muzzle effect` parent.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得将我们对玩家所做的相同更改应用到敌人身上，这意味着将玩家动画控制器添加并设置到其**动画器**组件中，并更改`枪口效果`父级。
- en: Now that we have a fully functional Animator Controller, let’s make it reflect
    the player movement through scripting.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个完全功能的动画控制器，让我们通过脚本让它反映玩家的移动。
- en: Scripting animations
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化动画
- en: 'With our player’s Animator ready, it is time to do some scripting to make these
    parameters be affected by the actual behavior of the player and match the player’s.
    In this section we will do the following to achieve this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的玩家动画器准备好了，现在是时候进行一些脚本编写，让这些参数受到玩家实际行为的影响，并与玩家的行为相匹配。在本节中，我们将执行以下操作以实现这一点：
- en: Script shooting animations
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本化射击动画
- en: Script movement animations
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本化移动动画
- en: Let’s start making our characters execute the **Shoot** animation when necessary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始制作我们的角色在必要时执行**射击**动画。
- en: Scripting player shooting animations
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化玩家射击动画
- en: So far, we have created a behavior to shoot each time we press a key, but the
    animation is prepared for sustained fire. We can make our `PlayerShooting` script
    shoot a bullet every X number of seconds while we keep the **Fire** key pressed
    to match the animation, instead of having to press the key repeatedly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个在每次按下键时射击的行为，但动画是为持续射击准备的。我们可以使我们的`PlayerShooting`脚本在保持**Fire**键按下的同时，每X秒发射一颗子弹，以匹配动画，而不是需要重复按键。
- en: 'Let’s see how to do this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做这件事：
- en: In the **PlayerShooting** script, add a public float field called **fireRate**,
    which will measure the seconds between bullet spawns. Remember to set this value
    in the **Inspector** of the player.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**PlayerShooting**脚本中，添加一个名为**fireRate**的公共float字段，该字段将测量子弹生成的秒数。请记住在玩家的**Inspector**中设置此值。
- en: 'Change the **OnFire** method to the code seen in *Figure 17.29*. The idea is
    to start a repeating action when we press the key and stop it when we release
    the key. We are using **InvokeRepeating** to repeatedly execute a function called
    **Shoot,** which we will be creating in the next step. The rate of execution will
    be controlled by the **fireRate** field we created in *step 1*:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**OnFire**方法更改为如图17.29所示的代码。我们的想法是在按下键时启动重复动作，并在释放键时停止它。我们正在使用**InvokeRepeating**来重复执行名为**Shoot**的函数，我们将在下一步创建它。执行速率将由我们在*步骤1*中创建的**fireRate**字段控制：
- en: '![](img/B18585_17_29.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_29.png)'
- en: 'Figure 17.29: OnFire changes needed for sustained fire'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.29：持续射击所需的OnFire更改
- en: 'Add the **Shoot** method as seen in *Figure 17.30* to our **PlayerShooting**
    script. This is essentially the same code we had before in the **OnFire** method
    but separated in a function, so we can execute it several times with the **InvokeRepeating**
    function:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将如图17.30所示的**Shoot**方法添加到我们的**PlayerShooting**脚本中。这基本上与我们在**OnFire**方法中之前拥有的代码相同，但已分离成一个函数，因此我们可以使用**InvokeRepeating**函数多次执行它：
- en: '![](img/B18585_17_30.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_30.png)'
- en: 'Figure 17.30: OnFire changes needed for sustained fire'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.30：持续射击所需的OnFire更改
- en: 'If you try these changes now, you will notice the bullets will never stop shooting
    once we click the **Fire** button. Even worse, as we press repeatedly, more and
    more bullets will be shot. With some debugging or educated guessing, you might
    figure out that the **CancelInvoke** method is not being executed. The reason
    behind this is that the **Fire** input mapping is not configured by default to
    inform us about the release of keys, just when they were pressed. Luckily the
    solution is pretty simple:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试这些更改，你会注意到一旦我们点击**Fire**按钮，子弹就不会停止射击。更糟糕的是，随着我们反复按下，发射的子弹会越来越多。通过一些调试或合理的猜测，你可能会发现**CancelInvoke**方法没有被执行。背后的原因是**Fire**输入映射默认没有配置来通知我们键的释放，只是在它们被按下时。幸运的是，解决方案相当简单：
- en: Double-click the **SuperShooter** inputs asset, the one we created in *Chapter
    6*,*Implementing Movement and Spawning*, that contains all the inputs our game
    supports.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**SuperShooter**输入资产，这是我们创建在*第6章*，*实现移动和生成*中，包含我们游戏支持的所有输入的那个。
- en: Select the **Fire** action in the **Actions** list (the middle column).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Actions**列表（中间列）中选择**Fire**动作。
- en: Click the **+** button at the right of the **Interactions** section and click
    **Press**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Interactions**部分右侧的**+**按钮，然后点击**Press**。
- en: 'Set the **Trigger Behavior** of the **Press** section to **Press And Release**:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Press**部分的**Trigger Behavior**设置为**Press And Release**：
- en: '![](img/B18585_17_31.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_31.png)'
- en: 'Figure 17.31: OnFire changes needed for sustained fire'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.31：持续射击所需的OnFire更改
- en: With this we have configured the Input to not only tell us when the key was
    pressed but also when it was released, making our **CancelInvoke** method execute
    now.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经配置了输入，不仅告诉我们键何时被按下，还告诉我们何时被释放，使我们的**CancelInvoke**方法现在执行。
- en: 'Now that we have our constant fire behavior, we can do the following to make
    the animation reflect this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了恒定的射击行为，我们可以做以下操作来使动画反映这一点：
- en: 'Add a reference to Animator using **GetComponent** in **Awake** and cache it
    in a field, as seen in *Figure 17.32*:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Awake**中使用**GetComponent**添加Animator的引用，并在字段中缓存，如图17.32所示：
- en: '![](img/B18585_17_32.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_32.png)'
- en: 'Figure 17.32: Caching the Animator reference'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.32：缓存Animator引用
- en: 'Add the line `animator.SetBool("Shooting", value.isPressed);` at the beginning
    of the **OnFire** method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**OnFire**方法的开头添加`animator.SetBool("Shooting", value.isPressed);`这一行。
- en: '![](img/B18585_17_33.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_33.png)'
- en: 'Figure 17.33: Setting the Shooting animation parameter to reflect input'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.33：设置射击动画参数以反映输入
- en: The idea behind this change is to make sure the **Shooting** animation parameter
    reflects the state of the fire key, meaning that the `Shoot` animation will play
    as long as the **Fire** button is pressed, and will stop when we release it.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个变更背后的想法是确保**射击**动画参数反映了开火键的状态，这意味着只要按下**开火**按钮，**射击**动画就会播放，当我们释放它时就会停止。
- en: 'One thing you will notice is that the bullets are still being shot from the
    player’s chest because our **ShootPoint** GameObject, the one that defines the
    shooting position, is not positioned in front of the weapon. Just re-parent the
    **ShootPoint** to the weapon bone (**Trigger_Right** in our case) and position
    it to be in front of the weapon. Remember to make the forward vector (the blue
    arrow in the **Scene** view) point along the weapon:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到的一个问题是子弹仍然是从玩家的胸部发射出来的，因为我们的**ShootPoint**游戏对象，即定义射击位置的物体，并没有位于武器的前方。只需将**ShootPoint**重新设置为武器的骨骼（在我们的例子中是**Trigger_Right**）并将其定位在武器前方。记住要使前向向量（**场景**视图中的蓝色箭头）沿着武器方向：
- en: '![](img/B18585_17_34.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_34.png)'
- en: 'Figure 17.34: Adapting the ShootPoint to follow the animation'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.34：使射击点跟随动画
- en: 'For the Visual Scripting version, in order to make the bullet get shot constantly,
    you should change the **Input** nodes of **PlayerShooting** like in *Figure 17.35*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视觉脚本版本，为了使子弹持续发射，你应该像图17.35中那样更改**PlayerShooting**的**Input**节点：
- en: '![](img/B18585_17_35.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_35.png)'
- en: 'Figure 17.35: Creating a shoot loop'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.35：创建射击循环
- en: As you can see, we used a new node called **Timer**. The idea of **Timer** is
    similar to the **Wait For Seconds** node we used before, because it allows us
    to delay the execution of one action. One of the main differences is that it allows
    us to cancel the timer before it executes again, meaning we can start the timer
    when we press the **Fire** key, and stop it when we release it. We did that by
    connecting the **InputSystemEventButton** node that has the **OnPressed** mode
    to the **Start** pin of the **Timer**, and the one with the **OnReleased** mode
    to the **Pause** pin. Also, we created a new variable called **fireRate** and
    connected it to the **Duration** pin of the **Timer**, so we need to specify how
    much time the **Timer** will wait before instantiating our bullets. See how we
    connected the **Completed** pin of the **Timer** to the **If** node that checks
    if we have enough bullets to instantiate; we used to connect to the input node
    here before.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了一个名为**计时器**的新节点。**计时器**的想法与之前使用的**等待几秒**节点类似，因为它允许我们延迟执行一个动作。主要区别在于它允许我们在再次执行之前取消计时器，这意味着我们可以在按下**开火**键时启动计时器，并在释放它时停止。我们通过将具有**OnPressed**模式的**InputSystemEventButton**节点连接到**计时器**的**Start**引脚，将具有**OnReleased**模式的节点连接到**Pause**引脚来实现这一点。此外，我们创建了一个名为**fireRate**的新变量，并将其连接到**计时器**的**Duration**引脚，因此我们需要指定**计时器**在实例化子弹之前将等待多长时间。看看我们是如何将**计时器**的**Completed**引脚连接到检查我们是否有足够子弹实例化的**If**节点的；我们之前在这里连接到输入节点。
- en: 'One little missing detail here is that when we press a key, time will pass
    (**fireRate**) and then a bullet will be instantiated, but then nothing else.
    We need to connect the end of the **Bullet** shoot sequence (the **AudioSource:
    Play** node in this case) of nodes again to the **Start** pin of the **Timer**
    to create a spawn loop. That loop will be interrupted when we release the key,
    to prevent it from being executed forever:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一点小细节遗漏，那就是当我们按下键时，时间会流逝（**fireRate**），然后实例化一颗子弹，但之后就没有其他动作了。我们需要再次将节点序列的末尾（在这种情况下是**AudioSource:
    Play**节点）连接到**计时器**的**Start**引脚，以创建一个生成循环。当释放键时，这个循环将被中断，以防止它无限执行：'
- en: '![](img/B18585_17_36.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_36.png)'
- en: 'Figure 17.36: Completing the shoot loop'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.36：完成射击循环
- en: 'Finally, we need to add the proper `Animator: SetBool(Name, Value)` node to
    the Input nodes to turn on and off the Boolean and trigger the animation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们需要在输入节点中添加适当的`Animator: SetBool(Name, Value)`节点来开启和关闭布尔值并触发动画：'
- en: '![](img/B18585_17_37.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_37.png)'
- en: 'Figure 17.37: Executing the Shoot animation'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.37：执行射击动画
- en: 'Now that we have handled the **Shoot** animations of the player, let’s handle
    the one of the enemy by doing the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了玩家的**射击**动画，接下来我们通过以下步骤来处理敌人的动画：
- en: 'Cache a reference to the parent animator in the **EnemyFSM** script using **GetComponentInParent**
    as we did with the **NavMeshAgent**:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EnemyFSM**脚本中使用**GetComponentInParent**方法缓存父级动画器的引用，就像我们之前对**NavMeshAgent**所做的那样：
- en: '![](img/B18585_17_38.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_38.png)'
- en: 'Figure 17.38: Accessing the parent’s Animator reference'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.38：访问父级的Animator引用
- en: 'Turn on the **Shooting** animator parameter inside the **Shoot** function to
    make sure that every time we shoot, that parameter is set to **true** (checked):'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Shoot**函数中打开**Shooting**动画参数，以确保每次射击时该参数都设置为**true**（选中）：
- en: '![](img/B18585_17_39.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_39.png)'
- en: 'Figure 17.39: Turning on the shooting animation'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.39：打开射击动画
- en: 'Turn off the `Shooting` parameter in all non-shooting states, such as **GoToBase**
    and **ChasePlayer**:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有非射击状态（如**GoToBase**和**ChasePlayer**）中关闭`Shooting`参数：
- en: '![](img/B18585_17_40.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_40.png)'
- en: 'Figure 17.40: Turning off the shooting animation'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.40：关闭射击动画
- en: 'Regarding the Visual Scripting version, the **GoToBase** state in the **EnemyFSM**
    will look like this:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，**EnemyFSM**中的**GoToBase**状态将如下所示：
- en: '![](img/B18585_17_41.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_41.png)'
- en: 'Figure 17.41: GoToBase state'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.41：GoToBase状态
- en: 'Note that we needed again the **GetParent** node to access the enemy’s parent
    **Transform** (the **root**), which we connected to the **Animator: SetBool**
    node in order to access the Animator in the enemy’s root. Then the **ChasePlayer**
    state actions will look like this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '注意，我们再次需要**GetParent**节点来访问敌人的父**Transform**（即**根**），我们将它与**Animator: SetBool**节点连接起来，以便访问敌人根部的动画器。然后，**ChasePlayer**状态的动作将如下所示：'
- en: '![](img/B18585_17_42.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_42.png)'
- en: 'Figure 17.42: ChasePlayer state'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.42：追逐玩家状态
- en: 'Then both the **AttackBase** and **AttackPlayer** initial actions will look
    like this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，**AttackBase**和**AttackPlayer**的初始动作将如下所示：
- en: '![](img/B18585_17_43.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_43.png)'
- en: 'Figure 17.43: Attack Base state'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.43：攻击基础状态
- en: With this, both our player and enemies have a constant shooting behavior and
    a **Shoot** animation to reflect this. Now let’s handle the movement animations
    for both.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们的玩家和敌人都有了恒定的射击行为和**射击**动画来反映这一点。现在让我们处理两者的移动动画。
- en: Scripting movement animations
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写移动动画脚本
- en: 'For the animator controller’s **Velocity** parameter, we can detect the magnitude
    of the velocity vector of **Rigidbody**, the velocity in meters per second, and
    set that as the current value. This can be perfectly separated from the **PlayerMovement**
    script, so we can reuse this if necessary, in other scenarios. So, we need to
    create a script such as the one in the following image, which just connects the
    **Rigidbody** component’s velocity with the animator **Velocity** parameter, and
    adds it to the **Player** GameObject:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动画控制器中的**速度**参数，我们可以检测**刚体**的速度向量的幅度，即每秒米数，并将其设置为当前值。这可以完美地与**PlayerMovement**脚本分离，因此如果需要，我们可以在其他场景中重用这个脚本。因此，我们需要创建一个如图所示的脚本，它只是将**刚体**组件的速度与动画器的**速度**参数连接起来，并将其添加到**Player**游戏对象中：
- en: '![](img/B18585_17_44.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_44.png)'
- en: 'Figure 17.44: Setting VelocityAnimator variables'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.44：设置VelocityAnimator变量
- en: 'And regarding the Visual Scripting version, this is what it would look like:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，它看起来是这样的：
- en: '![](img/B18585_17_45.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_45.png)'
- en: 'Figure 17.45: Setting Velocity Animator variables in Visual Scripting'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.45：在视觉脚本中设置Velocity Animator变量
- en: You may need to increase the `0.01` transitions threshold used so far in the
    conditions of the transitions of the animator controller because **Rigidbody**
    keeps moving after releasing the keys. Using `1` worked perfectly for me. Another
    option would be to increase the drag and the velocity of the player to make the
    character stop faster. Pick whatever method works best for you. Remember the transitions
    of both layers (**UpperBody** and **LowerBody**).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要增加到目前为止在动画控制器转换条件中使用的`0.01`转换阈值，因为**刚体**在释放按键后仍然在移动。对我来说，使用`1`效果很好。另一种选择是增加阻力和玩家的速度，使角色更快地停止。选择最适合您的方法。记住两层（**UpperBody**和**LowerBody**）的转换。
- en: 'Now we can add the movement animations to the enemy. Create and add a script
    to the Enemy prefab called **NavMeshAnimator**, which will take the current velocity
    of its **NavMeshAgent** and will set it to the Animator Controller. This will
    work similarly to the **VelocityAnimator** script but this time checking the velocity
    of the **NavMeshAgent**. We didn’t use **VelocityAnimator** here because our AI
    doesn’t use **Rigidbody** to move, so it won’t work:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将移动动画添加到敌人身上。为敌人预制件创建并添加一个名为**NavMeshAnimator**的脚本，它将获取其**NavMeshAgent**的当前速度并将其设置为动画控制器。这将与**VelocityAnimator**脚本类似，但这次检查的是**NavMeshAgent**的速度。我们没有使用**VelocityAnimator**，因为我们的AI不使用**刚体**来移动，所以它不起作用：
- en: '![](img/B18585_17_46.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_46.png)'
- en: 'Figure 17.46: Connecting the NavMeshAgent to our Animator Controller'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.46：将NavMeshAgent连接到我们的Animator Controller
- en: 'The Visual Scripting version will look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可视脚本版本将如下所示：
- en: '![](img/B18585_17_47.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_47.png)'
- en: 'Figure 17.47: Setting the animator velocity parameter the same as our NavMeshAgent'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.47：将动画器速度参数设置为与我们的NavMeshAgent相同
- en: Notice here we don’t need the **GetParent** node, given that this graph is located
    at the Enemy’s root object alongside the **Animator** and the **NavMeshAgent**.
    With that, we have scripted our Player and Enemies animations. We are ready to
    keep learning about animations using Cinemachine to create cutscene cameras and
    much more.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于此图位于敌人的根对象旁边，与**Animator**和**NavMeshAgent**一起，所以我们不需要**GetParent**节点。有了这个，我们就已经编写了玩家和敌人的动画脚本。我们现在可以继续学习使用Cinemachine创建过场相机和其他更多内容。
- en: Creating dynamic cameras with Cinemachine
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cinemachine创建动态相机
- en: Cameras are a very important subject in video games. They allow the player to
    see their surroundings to make decisions based on what they see. The game designer
    usually defines how it behaves to get the exact gameplay experience they want,
    and that’s no easy task. A lot of behaviors must be layered to get the exact feeling.
    Also, for cutscenes, it is important to control the path that the camera will
    be traversing during it and where the camera is looking to focus the action during
    those constantly moving scenes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，相机是一个非常重要的主题。它们允许玩家看到他们的周围环境，并根据他们所看到的内容做出决策。游戏设计师通常定义其行为以获得他们想要的精确游戏体验，这并不容易。必须分层很多行为才能获得精确的感觉。此外，对于过场动画，控制相机在动画期间将要穿越的路径以及相机在那些不断移动的场景中聚焦的动作也很重要。
- en: In this chapter, we will use the `Cinemachine` package to create both the dynamic
    cameras that will follow the player’s movements, which we will code in *Part 3*,
    and also, the cameras to be used during cutscenes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Cinemachine`包来创建两种相机：一种将跟随玩家动作的动态相机，我们将在第3部分中编写代码；另一种将在过场动画中使用的相机。
- en: 'In this section, we will examine the following Cinemachine concepts:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下Cinemachine概念：
- en: Creating camera behaviors
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建相机行为
- en: Creating dolly tracks
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建轨道推车
- en: Let’s start by discussing how to create a Cinemachine-controlled camera and
    configure behaviors in it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何创建由Cinemachine控制的相机并配置其中的行为。
- en: Creating camera behaviors
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建相机行为
- en: Cinemachine is a tech library containing a collection of different behaviors
    that can be used in a camera, which when properly combined can generate all kinds
    of common camera types in video games, including following the player from behind,
    first-person cameras, top-down cameras, and so on. In order to use these behaviors,
    we need to understand the concept of brains and virtual cameras.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine是一个技术库，包含了一系列可用于相机的不同行为，当正确组合时，可以生成视频游戏中所有常见的相机类型，包括从背后跟随玩家、第一人称相机、俯视相机等等。为了使用这些行为，我们需要理解大脑和虚拟相机的概念。
- en: In Cinemachine, we will only keep one main camera, as we have done so far, and
    that camera will be controlled by virtual cameras, separated GameObjects that
    have the aforementioned behaviors. We can have several virtual cameras and swap
    between them at will, but the active virtual camera will be the only one that
    will control our main camera. This is useful for switching cameras at different
    points of the game, such as switching between our player’s third-person camera
    and a cutscene camera. In order to control the main camera with the virtual cameras,
    it must have a **Brain** component, which will monitor all active virtual cameras
    and pick the proper position to use them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cinemachine中，我们只会保留一个主相机，就像我们迄今为止所做的那样，而这个相机将由虚拟相机控制，这些虚拟相机是具有上述行为的独立GameObject。我们可以有多个虚拟相机，并且可以随意在它们之间切换，但活动的虚拟相机将是唯一一个将控制我们的主相机。这在游戏的不同点切换相机很有用，例如在玩家的第三人称相机和过场相机之间切换。为了使用虚拟相机控制主相机，它必须有一个**Brain**组件，该组件将监控所有活动的虚拟相机并选择适当的位姿来使用它们。
- en: 'To start using Cinemachine, first, we need to check if it is installed in the
    Package Manager, as we did previously with other packages. If you don’t remember
    how to do this, just do the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Cinemachine，首先，我们需要检查它是否已安装在包管理器中，就像我们之前在其他包中做的那样。如果你不记得如何做，只需按照以下步骤操作：
- en: Go to **Window | Package Manager**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口 | 包管理器**。
- en: 'Ensure that the **Packages** option in the top-left part of the window is set
    to **Unity Registry**:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保窗口左上角的**Packages**选项设置为**Unity Registry**：
- en: '![](img/B18585_17_48.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_48.png)'
- en: 'Figure 17.48: The Packages filter mode'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.48：包过滤器模式
- en: Wait a moment for the left panel to populate all packages from the servers (the
    internet is required).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待左侧面板从服务器（需要互联网）填充所有包。
- en: Look for the **Cinemachine** package from the list and select it. At the moment
    of writing this book the latest available version is 2.8.6, but you can use newer
    versions if you prefer, always ensuring that the following steps work as expected;
    if not, you can always install the closest version to ours.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中查找**Cinemachine**包并选择它。在撰写本书时，最新可用的版本是 2.8.6，但如果你愿意，可以使用更新的版本，始终确保以下步骤按预期工作；如果不按预期工作，你始终可以安装与我们最接近的版本。
- en: If you see the **Install** button in the bottom-right corner of the screen it
    means it is not installed. Just click that button.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到屏幕右下角的**安装**按钮，这意味着它尚未安装。只需点击该按钮即可。
- en: 'Now that we have it installed, we can start creating a virtual camera to follow
    the player. So far, we just simply parented the camera to the player for it to
    follow them, but now we will unparent the camera and let Cinemachine handle it
    to learn how to use this tool:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了它，我们可以开始创建一个虚拟摄像机来跟随玩家。到目前为止，我们只是简单地将摄像机设置为玩家的子对象以便跟随，但现在我们将取消父化摄像机，让
    Cinemachine 处理它，以学习如何使用此工具：
- en: Select the **MainCamera** inside the player and unparent it (drag it outside
    the player) in such a way that it becomes a root object of our scene, having no
    parent at all.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家内部选择**MainCamera**并取消父化它（将其拖出玩家），使其成为场景的根对象，没有任何父对象。
- en: 'Click **GameObject | Cinemachine | Virtual Camera**. This will create a new
    object called `CM vcam1`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**GameObject | Cinemachine | Virtual Camera**。这将创建一个名为 `CM vcam1` 的新对象：
- en: '![](img/B18585_17_49.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_49.png)'
- en: 'Figure 17.49: Virtual camera creation'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.49：虚拟摄像机创建
- en: 'If you select the main camera from the **Hierarchy** pane, you will also notice
    that a `CinemachineBrain` component has been automatically added to it, making
    our main camera follow the virtual camera. Try to move the created virtual camera,
    and you will see how the main camera follows it:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你从**Hierarchy**面板中选择主摄像机，你也会注意到一个`CinemachineBrain`组件已自动添加到它上，使我们的主摄像机跟随虚拟摄像机。尝试移动创建的虚拟摄像机，你会看到主摄像机是如何跟随它的：
- en: '![](img/B18585_17_50.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_50.png)'
- en: 'Figure 17.50: The CinemachineBrain component'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.50：CinemachineBrain 组件
- en: 'Select the virtual camera (`CM vcam1`) and drag the character to the **Follow**
    and **Look At** properties of the **CinemachineVirtualCamera** component. This
    will make the movement and looking behaviors use that object to do their jobs:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择虚拟摄像机（`CM vcam1`）并将角色拖到**CinemachineVirtualCamera**组件的**Follow**和**Look At**属性。这将使移动和查看行为使用该对象来完成它们的工作：
- en: '![](img/B18585_17_51.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_51.png)'
- en: 'Figure 17.51: Setting the target of our camera'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.51：设置摄像机的目标
- en: 'You can see how the **Body** property of the virtual camera is set to **Transposer**,
    which will move the camera relative to the target set at the **Follow** property—in
    our case, the character. You can open the **Body** options (the arrow to its left),
    change the **Follow Offset** property, and set it to the desired distance you
    want the camera to have from the target. In my case, I used the `0`, `3`, and
    `-3` values:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到虚拟摄像机的**Body**属性设置为**Transposer**，这将使摄像机相对于在**Follow**属性中设置的目标移动——在我们的例子中，是角色。你可以打开**Body**选项（其左侧的箭头），更改**Follow
    Offset**属性，并将其设置为摄像机与目标之间的所需距离。在我的情况下，我使用了`0`、`3`和`-3`的值：
- en: '![](img/B18585_17_52.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_52.png)'
- en: 'Figure 17.52: The camera following the character from behind'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.52：从背后跟随角色的摄像机
- en: '*Figure 17.50* shows the **Game** view; you can see a small, yellow rectangle
    indicating the target position to look at the character, and it’s currently pointing
    at the pivot of the character—its feet. If you don’t see it open the **Aim** section
    of the virtual camera in the Inspector by clicking the arrow to its left.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图 17.50* 显示了**Game**视图；你可以看到一个表示要观察的角色目标位置的小黄色矩形，它目前指向角色的基点——其脚部。如果你看不到它，请通过点击其左侧的箭头打开虚拟摄像机的**Aim**部分。'
- en: 'We can apply an offset in the **Tracked Object Offset** property of the **Aim**
    section of the virtual camera. In my case, a value of `0`, `1.8`, and `0` worked
    well to make the camera look at the head instead:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在虚拟摄像机的 **Aim** 部分的 **Tracked Object Offset** 属性中应用偏移。在我的案例中，`0`、`1.8` 和
    `0` 的值工作得很好，使摄像机看向头部：
- en: '![](img/B18585_17_53.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_53.png)'
- en: 'Figure 17.53: Changing the Aim offset'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.53：更改目标偏移量
- en: 'As you can see, using Cinemachine is pretty simple, and in our case, the default
    settings were mostly enough for the kind of behavior we needed. However, if you
    explore the other **Body** and **Aim** modes, you will find that you can create
    any type of camera for any type of game. We won’t cover the other modes in this
    book, but I strongly recommend you look at the documentation for Cinemachine to
    check what the other modes do. To open the documentation, follow these steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 Cinemachine 非常简单，在我们的案例中，默认设置大多数情况下已经足够满足我们需要的行为了。然而，如果您探索其他 **Body**
    和 **Aim** 模式，您会发现您可以为任何类型的游戏创建任何类型的摄像机。本书中不会涵盖其他模式，但我强烈建议您查看 Cinemachine 的文档以了解其他模式的功能。要打开文档，请按照以下步骤操作：
- en: Open the **Package Manager** by going to **Window | Package Manager**.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 **Window | Package Manager** 打开 **包管理器**。
- en: Find **Cinemachine** in the left-hand side list. Wait a moment if it doesn’t
    show up. Remember that you need an internet connection for it to work.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中找到 **Cinemachine**。如果它没有显示出来，请稍等片刻。请记住，你需要一个互联网连接才能使其工作。
- en: 'Once **Cinemachine** is selected, scroll down in the right panel until you
    see the **View documentation** link in blue. Click on it:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择 **Cinemachine**，在右侧面板中向下滚动，直到您看到蓝色的 **查看文档** 链接。点击它：
- en: '![](img/B18585_17_54.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_54.png)'
- en: 'Figure 17.54: The Cinemachine documentation link'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.54：Cinemachine 文档链接
- en: 'You can explore the documentation using the navigation menu on the left:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用左侧的导航菜单探索文档：
- en: '![](img/B18585_17_55.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_55.png)'
- en: 'Figure 17.55: The Cinemachine documentation'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.55：Cinemachine 文档
- en: As you did with Cinemachine, you can find other packages’ documentation in the
    same way. Now that we have achieved the basic camera behavior that we need, let’s
    explore how we can use Cinemachine to create a camera for our intro cutscene.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Cinemachine 一样，您可以用相同的方式找到其他包的文档。现在我们已经实现了我们需要的相机基本行为，让我们探索如何使用 Cinemachine
    为我们的开场剪辑创建一个相机。
- en: Creating dolly tracks
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建摇臂轨道
- en: When the player starts the level, we want a little cutscene with a pan over
    our scene and the base before entering the battle. This will require the camera
    to follow a fixed path, and that’s exactly what Cinemachine’s dolly camera does.
    It creates a path where we can attach a virtual camera so that it will follow
    it. We can set Cinemachine to move automatically through the track or follow a
    target to the closest point to the track; in our case, we will use the first option.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始关卡时，我们想要一个简短的场景，在进入战斗之前，摄像机在场景和基地上移动。这将需要摄像机跟随一个固定路径，这正是 Cinemachine 的摇臂摄像机所做的事情。它创建了一个路径，我们可以将其虚拟摄像机附加到它，使其跟随。我们可以设置
    Cinemachine 自动通过轨道移动或跟随目标到轨道最近的点；在我们的案例中，我们将使用第一个选项。
- en: 'In order to create a dolly camera, follow these steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建摇臂摄像机，请按照以下步骤操作：
- en: 'Let’s start creating the track with a cart, which is a little object that will
    move along the track, which will be the target to follow the camera. To do this,
    click on **GameObject | Cinemachine | Dolly Track with Cart**:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个带有摇臂的轨道开始创建，这是一个沿着轨道移动的小对象，它将是跟随摄像机的目标。为此，点击 **GameObject | Cinemachine
    | 带有摇臂的轨道**：
- en: '![](img/B18585_17_56.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_56.png)'
- en: 'Figure 17.56: A dolly camera with a default straight path'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.56：一个默认直线路径的摇臂摄像机
- en: If you select the `DollyTrack1` object, you can see two circles with the numbers
    `0` and `1` in the **Scene** view. These are the control points of the track.
    Select one of them and move it as you move other objects, using the arrows of
    the translation gizmo. If you don’t see them press the *W* key to enable the **Translation**
    gizmo.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您选择 `DollyTrack1` 对象，您可以在 **场景** 视图中看到两个带有数字 `0` 和 `1` 的圆圈。这些是轨道的控制点。选择其中一个，并使用变换工具的箭头移动它，就像您移动其他对象一样。如果您看不到它们，请按
    *W* 键以启用 **变换** 工具。
- en: 'You can create more control points by clicking the **+** button at the bottom
    of the **Waypoints** list of the `CinemachineSmoothPath` component of the `DollyTrack1`
    object:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过点击 `DollyTrack1` 对象的 `CinemachineSmoothPath` 组件的 **Waypoints** 列表底部的 **+**
    按钮来创建更多的控制点：
- en: '![](img/B18585_17_57.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_57.png)'
- en: 'Figure 17.57: Adding a path control point'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.57：添加路径控制点
- en: 'Create as many waypoints as you need to create a path that will traverse the
    areas you want the camera to oversee in the intro cutscene. Remember, you can
    move the waypoints by clicking on them and using the translation gizmo:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您需要的航点数量，以创建一个路径，该路径将遍历您希望在开场剪辑场景中摄像机监督的区域。记住，您可以通过单击它们并使用平移辅助工具来移动航点：
- en: '![](img/B18585_17_58.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_58.png)'
- en: 'Figure 17.58: A dolly track for our scene. It ends right behind the character'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.58：我们场景的轨道车轨道。它正好在角色后面结束
- en: Create a new virtual camera. If you go to the **Game** view after creating it,
    you will notice that the character camera will be active. In order to test how
    the new camera looks, select the previous one (**CM vcam1**) and temporarily disable
    it by clicking the checkbox to the left of the GameObject’s name in the Inspector.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟摄像机。在创建后，如果您转到 **游戏** 视图，您会注意到角色摄像机将是激活的。为了测试新摄像机的效果，选择之前的摄像机（**CM vcam1**），并通过在检查器中单击
    GameObject 名称左侧的复选框暂时禁用它。
- en: Set the **Follow** target this time to the `DollyCart1` object that we previously
    created with the track.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次将 **跟随** 目标设置为之前创建的带有轨道的 `DollyCart1` 对象。
- en: Set **Follow Offset** of the **Body** section to `0`, `0`, and `0` to keep the
    camera in the same position as the cart.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **身体** 部分的 **跟随偏移** 设置为 `0`，`0`，和 `0` 以保持摄像机与车的同一位置。
- en: 'Set **Aim** to **Same As Follow Target** to make the camera look in the same
    direction as the cart, which will follow the track curves:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **目标** 设置为 **与跟随目标相同**，使摄像机朝与车相同的方向看，这将跟随轨道曲线：
- en: '![](img/B18585_17_59.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_59.png)'
- en: 'Figure 17.59: Configuration to make the virtual camera follow the dolly track'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.59：配置使虚拟摄像机跟随轨道车的设置
- en: 'Select the **DollyCart1** object and change the **Position** value to see how
    the cart moves along the track. Do this while the game window is focused and **CM
    vcam2** is in solo mode to see how the camera will look:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **DollyCart1** 对象，并更改 **位置** 值以查看车如何在轨道上移动。在游戏窗口聚焦且 **CM vcam2** 处于独奏模式时进行此操作，以查看摄像机的效果：
- en: '![](img/B18585_17_60.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_60.png)'
- en: 'Figure 17.60: The dolly cart component'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.60：轨道车组件
- en: Re-enable `CM vcam1`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用 `CM vcam1`。
- en: With the dolly track properly set, we can create our cutscene using **Timeline**
    to sequence it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置轨道车后，我们可以使用 **Timeline** 来创建我们的剪辑场景，并对其进行排序。
- en: Creating cutscenes with Timeline
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Timeline 创建剪辑场景
- en: We have our intro camera, but that’s not enough to create a cutscene. A proper
    cutscene is a sequence of actions happening at the exact moment that they should
    happen, coordinating several objects to act as intended. We can have actions such
    as enabling and disabling objects, switching cameras, playing sounds, moving objects,
    and so on. To do this, Unity offers **Timeline**, which is a sequencer of actions
    to coordinate those kinds of cutscenes. We will use **Timeline** to create an
    intro cutscene for our scene, showing the level before starting the game.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的开场摄像机，但这不足以创建一个剪辑场景。一个合适的剪辑场景是一系列在它们应该发生的确切时刻发生的动作，协调多个对象以实现预期行为。我们可以有诸如启用和禁用对象、切换摄像机、播放声音、移动对象等动作。为此，Unity
    提供了 **Timeline**，这是一个动作序列器，用于协调这类剪辑场景。我们将使用 **Timeline** 为我们的场景创建一个开场剪辑场景，展示游戏开始前的关卡。
- en: 'In this section, we will examine the following Timeline concepts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下 Timeline 概念：
- en: Creating animation clips
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: Sequencing our intro cutscene
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序我们的开场剪辑场景
- en: We are going to see how to create our own animation clips in Unity to animate
    our GameObjects and then place them inside a cutscene to coordinate their activation,
    using the Timeline sequencer tool. Let’s start by creating a camera animation
    to use later in Timeline.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何在 Unity 中创建自己的动画剪辑来动画化我们的 GameObject，然后将它们放置在剪辑场景中，以使用 Timeline 序列器工具协调它们的激活。让我们先创建一个摄像机动画，稍后将在
    Timeline 中使用。
- en: Creating animation clips
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: This is actually not a Timeline-specific feature but rather a Unity feature
    that works great with Timeline. When we downloaded the character, it came with
    animation clips that were created using external software, but you can create
    custom animation clips using Unity’s **Animation** window. Don’t confuse it with
    the **Animator** window, which allows us to create animation transitions that
    react to the game situation. This is useful to create small object-specific animations
    that you will coordinate later in Timeline with other objects’ animations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个Timeline特定的功能，而是一个Unity功能，它与Timeline配合得很好。当我们下载角色时，它附带了一些使用外部软件创建的动画剪辑，但你也可以使用Unity的**Animation**窗口创建自定义动画剪辑。不要将其与允许我们创建对游戏情况做出反应的动画转换的**Animator**窗口混淆。这有助于创建小对象特定的动画，你将在Timeline中稍后与其他对象的动画进行协调。
- en: 'These animations can control any value of an object’s component properties,
    such as the positions, colors, and so on. In our case, we want to animate the
    dolly track’s **Position** property to make it go from start to finish in a given
    time. In order to do this, do the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动画可以控制对象组件属性的任何值，例如位置、颜色等。在我们的例子中，我们想要动画化娃娃轨道的**Position**属性，使其在给定时间内从起点到终点移动。为了做到这一点，请执行以下操作：
- en: Select the `DollyCart1` object.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DollyCart1`对象。
- en: Open the **Animation** (not **Animator**) window by going to **Window | Animation
    | Animation**.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**Window | Animation | Animation**进入**Animation**（不是**Animator**）窗口。
- en: 'Click on the **Create** button at the center of the **Animation** window. Remember
    to do this while the dolly cart (not track) is selected:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Animation**窗口中央的**Create**按钮。记住，在选中娃娃车（而不是轨道）时进行此操作：
- en: '![](img/B18585_17_61.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_61.png)'
- en: 'Figure 17.61: Creating a custom animation clip'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.61：创建自定义动画剪辑
- en: After doing this, you will be prompted to save the animation clip somewhere.
    I recommend you create an `Animations` folder in the project (inside the `Assets`
    folder) and call it `IntroDollyTrack`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个操作后，你会被提示将动画剪辑保存到某个地方。我建议你在项目（在`Assets`文件夹内）中创建一个`Animations`文件夹，并将其命名为`IntroDollyTrack`。
- en: If you pay attention, the dolly cart now has an **Animator** component with
    an Animator Controller created, which contains the animation we just created.
    As with any animation clip, you need to apply it to your object with an Animator
    Controller; custom animations are no exception. So, the **Animation** window created
    them for you.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意的话，现在的娃娃车现在有一个**Animator**组件，并且创建了一个Animator Controller，其中包含了我们刚刚创建的动画。就像任何动画剪辑一样，你需要使用Animator
    Controller将其应用到你的对象上；自定义动画也不例外。所以，**Animation**窗口为您创建了它们。
- en: Animating in this window consists of specifying the value of its properties
    at given moments. In our case, we want Position to have a value of 0 at the beginning
    of the animation, at 0 seconds on the timeline, and have a value of 254 at the
    end of the animation, at 5 seconds. I chose 254 because that’s the last possible
    position in my cart, but that depends on the length of your dolly track. Just
    test which is the last possible position in yours. Also, I chose `5` seconds because
    that’s what I feel is the correct length for the animation, but feel free to change
    it as you wish. Now, whatever happens between the animation’s 0 and 5 seconds
    is an interpolation of the 0 and 254 values, meaning that in 2.5 seconds, the
    value of Position will be 127\. Animating always consists of interpolating different
    states of our object at different moments.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口中动画制作包括指定其属性在给定时刻的值。在我们的例子中，我们希望动画开始时在时间轴上的0秒，Position的值为0，在动画结束时在5秒，值为254。我选择254是因为那是我的车上的最后一个可能的位置，但这取决于你的娃娃轨道的长度。只需测试一下你的最后一个可能的位置。此外，我选择`5`秒，因为这是我认为动画的正确长度，但你可以随意更改它。现在，动画的0到5秒之间发生的事情是0和254值之间的插值，这意味着在2.5秒时，Position的值将是127。动画总是由不同时刻我们对象的不同状态之间的插值组成。
- en: 'In order to do this, follow these steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: In the **Animation** window, click on the record button (the red circle in the
    top-left section). This will make Unity detect any changes in our object and save
    them to the animation. Remember to do this while you have selected the dolly cart.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Animation**窗口中，点击记录按钮（左上角的部分中的红色圆圈）。这将使Unity检测我们对象中的任何变化并将它们保存到动画中。记住，在选中娃娃车时进行此操作。
- en: Set the **Position** setting of the dolly cart to `1` and then `0`. Changing
    this to any value and then to `0` again will create a keyframe, which is a point
    in the animation that says that at `0` seconds, we want the **Position** value
    to be `0`. We need to set it first to any other value if the value is already
    at `0`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将轨道车的**位置**设置更改为`1`然后`0`。将此值更改为任何值然后再次更改为`0`将创建一个关键帧，这是一个动画中的点，表示在`0`秒时，我们希望**位置**值为`0`。如果值已经为`0`，我们需要首先将其设置为任何其他值。
- en: 'You will notice that the **Position** property has been added to the animation:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到**位置**属性已经被添加到动画中：
- en: '![](img/B18585_17_62.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_62.png)'
- en: 'Figure 17.62: The animation in Record mode after changing the Position value
    to 0'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.62：将位置值更改为0后的记录模式动画
- en: 'Using the mouse scroll wheel, zoom out the timeline to the right of the **Animation**
    window until you see **5:00** seconds in the top bar:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标滚轮，将**动画**窗口右侧的时间轴放大，直到你在顶部栏中看到**5:00**秒：
- en: '![](img/B18585_17_63.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_63.png)'
- en: 'Figure 17.63: The timeline of the Animation window seeing 5 seconds'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.63：动画窗口的时间轴显示5秒
- en: Click on the **5:00**-second label in the top bar of the timeline to position
    the playback header at that moment. This will locate the next change we do at
    that moment.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击时间轴顶部栏的**5:00**秒标签，将播放头定位在那个时刻。这将定位我们接下来在那个时刻所做的更改。
- en: 'Set the **Position** value of the dolly track to the highest value you can
    get; in my case, this is `240`. Remember to have the **Animation** window in **Record**
    mode:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将轨道的**位置**值设置为你可以得到的最高值；在我的情况下，这是`240`。请记住，将**动画**窗口置于**记录**模式：
- en: '![](img/B18585_17_64.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_64.png)'
- en: 'Figure 17.64: Creating a keyframe with the 240 value 5 seconds into the animation'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.64：在动画5秒处创建具有240值的帧
- en: Hit the play button in the top-left section of the **Animation** window to see
    the animation playing. Remember to view it in the **Game** view while `CM vcam1`
    is disabled.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**动画**窗口左上角的播放按钮以查看动画播放。请记住，在`CM vcam1`禁用的情况下，在**游戏**视图中查看。
- en: 'Now, if we hit **Play**, the animation will start playing, but that’s something
    we don’t want. In this scenario, the idea is to give control of the cutscene to
    the cutscene system, Timeline, because this animation won’t be the only thing
    that needs to be sequenced in our cutscene. One way to prevent the **Animator**
    component from automatically playing the animation we created is to create an
    empty animation state in the Controller and set it as the default state by following
    these steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击**播放**，动画将开始播放，但这不是我们想要的。在这种情况下，我们的想法是将场景的控制权交给场景系统，即时间轴，因为我们的场景中需要排序的不仅仅是这个动画。防止**动画器**组件自动播放我们创建的动画的一种方法是在控制器中创建一个空动画状态，并按照以下步骤将其设置为默认状态：
- en: Search the Animator Controller that we created at the same time as the animation
    and open it. If you can’t find it, just select the dolly cart and double-click
    on the **Controller** property of the **Animator** component on our GameObject
    to open the asset.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索我们创建动画时同时创建的动画控制器，并打开它。如果你找不到，只需选择轨道车，并在我们的GameObject上的**动画器**组件的**控制器**属性上双击以打开资产。
- en: 'Right-click on an empty state in the Controller and select **Create State**
    | **Empty**. This will create a new state in the state machine as if we created
    a new animation, but it is empty this time:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中右键单击一个空状态，然后选择**创建状态** | **空**。这将像创建一个新动画一样在状态机中创建一个新的状态，但这次它是空的：
- en: '![](img/B18585_17_65.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_65.png)'
- en: 'Figure 17.65: Creating an empty state in the Animator Controller'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.65：在动画控制器中创建空状态
- en: 'Right-click on **New State** and click on **Set as Layer Default State**. The
    state should become orange:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**新状态**，然后点击**设置为层默认状态**。状态应该变为橙色：
- en: '![](img/B18585_17_66.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_66.png)'
- en: 'Figure 17.66: Changing the default animation of the Controller to an empty
    state'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.66：将控制器的默认动画更改为空状态
- en: Now, if you hit **Play**, no animation will play as the default state of our
    dolly cart is empty. No transition will be required in this case.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击**播放**，由于我们的轨道车默认状态为空，将不会播放任何动画。在这种情况下不需要过渡。
- en: Now that we have created our camera animation, let’s start creating a cutscene
    that switches from the intro cutscene camera to the player camera by using Timeline.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的摄像机动画，让我们开始创建一个场景切换，从开场场景摄像机切换到玩家摄像机，通过使用时间轴来实现。
- en: Sequencing our intro cutscene
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序我们的开场场景
- en: Timeline is already installed in your project, but if you go to the Package
    Manager of Timeline, you may see an **Update** button to get the latest version
    if you need some of the new features. In our case, we will keep the default version
    included in our project (1.5.2, at the time of writing this book).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴已安装到您的项目中，但如果您进入时间轴的包管理器，您可能会看到一个**更新**按钮，如果您需要一些新功能，可以获取最新版本。在我们的例子中，我们将保持项目中包含的默认版本（1.5.2，本书编写时）。
- en: 'The first thing we will do is create a cutscene asset and an object in the
    scene responsible for playing it. To do this, follow these steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个场景资产和一个负责播放它的场景对象。为此，请按照以下步骤操作：
- en: Create an empty GameObject using the **GameObject | Create Empty** option.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject | 创建空对象**选项创建一个空GameObject。
- en: Select the empty object and call it `Director`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择空对象并将其命名为`Director`。
- en: Go to **Window | Sequencing | Timeline** to open the **Timeline** editor.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**窗口 | 序列 | 时间轴**以打开**时间轴**编辑器。
- en: Click the **Create** button in the middle of the **Timeline** window while the
    **Director** object is selected to convert that object into the cutscene player
    (or director).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**导演**对象被选中时，点击**时间轴**窗口中间的**创建**按钮，将那个对象转换为场景播放器（或导演）。
- en: After doing this, a window will pop up asking you to save a file. This file
    will be the cutscene or timeline; each cutscene will be saved in its own file.
    Save it in a `Cutscenes` folder in your project (the `Assets` folder).
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，将弹出一个窗口，要求您保存文件。此文件将是场景或时间轴；每个场景都将保存在自己的文件中。将其保存在您项目中的`Cutscenes`文件夹（`Assets`文件夹）中。
- en: 'Now, you can see that the **Director** object has a **Playable Director** component
    with the **Intro** cutscene asset saved in the previous step set for the **Playable**
    property, meaning this cutscene will be played by the Director:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以看到**导演**对象具有一个**可播放导演**组件，其中包含在上一步骤中保存的**Intro**场景资产设置为**可播放**属性，这意味着此场景将由导演播放：
- en: '![](img/B18585_17_67.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_67.png)'
- en: 'Figure 17.67: Playable Director prepared to play the Intro Timeline asset'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.67：准备播放Intro时间轴资产的可播放导演
- en: Now that we have the Timeline asset ready to work with, let’s make it sequence
    actions. To start, we need to sequence two things—first, the cart position animation
    we did in the last step and then the camera swap between the dolly track camera
    (`CM vcam2`) and the player cameras (`CM vcam1`). As we said before, a cutscene
    is a sequence of actions executing at given moments, and in order to schedule
    actions, you will need tracks. In Timeline, we have different kinds of tracks,
    each one allowing you to execute certain actions on certain objects. We will start
    with the animation track.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备工作的时间轴资产，让我们制作序列动作。首先，我们需要序列化两件事——首先，我们在上一步中完成的摇臂车位置动画，然后是摇臂轨道相机（`CM
    vcam2`）和玩家相机（`CM vcam1`）之间的相机交换。正如我们之前所说的，场景是一系列在给定时刻执行的动作，为了安排动作，您将需要轨道。在时间轴中，我们有不同类型的轨道，每种轨道都允许您在特定对象上执行某些动作。我们将从动画轨道开始。
- en: 'The animation track will control which animation a specific object will play;
    we need one track per object to animate. In our case, we want the dolly track
    to play the **Intro** animation that we created, so let’s do that by following
    these steps:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 动画轨道将控制特定对象将播放哪个动画；我们需要为每个对象创建一个轨道来动画化。在我们的例子中，我们希望摇臂轨道播放我们创建的**Intro**动画，所以让我们按照以下步骤操作：
- en: 'Add an Animation track by clicking **the plus button (+)** and then **Animation
    Track**:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**加号按钮 (+)**然后选择**动画轨道**来添加一个动画轨道：
- en: '![](img/B18585_17_68.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_68.png)'
- en: 'Figure 17.68: Creating an animation track'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.68：创建动画轨道
- en: Select the **Director** object and check the **Bindings** list of the **Playable
    Director** component in the **Inspector** window.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**导演**对象，并在**检查器**窗口中检查**可播放导演**组件的**绑定**列表。
- en: 'Drag the **Cart** object to specify that we want the animation track to control
    its animation:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Cart**对象拖动以指定我们想要动画轨道控制其动画：
- en: '![](img/B18585_17_69.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_69.png)'
- en: 'Figure 17.69: Making the animation track control the dolly cart animation in
    this Director'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.69：使动画轨道控制本导演中的摇臂车动画
- en: Timeline is a generic asset that can be applied to any scene, but as the tracks
    control specific objects, you need to manually bind them in every scene. In our
    case, we have an animation track that expects to control a single animator, so
    in every scene, if we want to apply this cutscene, we need to drag the specific
    animator to control it in the **Bindings** list.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴是一个通用的资产，可以应用于任何场景，但由于轨道控制特定的对象，您需要手动在每个场景中绑定它们。在我们的例子中，我们有一个动画轨道，它期望控制单个动画师，因此在每个场景中，如果我们想应用这个场景，我们需要将特定的动画师拖动到**绑定**列表中控制它。
- en: 'Drag the **Intro** animation asset that we created to the animation track in
    the **Timeline** window. This will create a clip in the track showing when and
    for how long the animation will play. You can drag as many animations as possible
    that the cart can play into the track to sequence different animations at different
    moments, but right now, we want just that one:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们创建的**Intro**动画资产拖动到**时间轴**窗口中的动画轨道。这将在轨道中创建一个剪辑，显示动画何时以及播放多长时间。您可以将尽可能多的动画拖动到轨道中，以便在不同的时刻播放不同的动画，但现在我们只想播放一个：
- en: '![](img/B18585_17_70.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_70.png)'
- en: 'Figure 17.70: Making the animator track play the intro clip'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.70：使动画师轨道播放intro剪辑
- en: You can drag the animation to change the exact moment you want it to play. Drag
    it to the beginning of the track.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将动画拖动以更改它播放的确切时刻。将其拖动到轨道的开始位置。
- en: 'Hit the **Play** button in the top-left part of the **Timeline** window to
    see it in action. You can also manually drag the white arrow in the **Timeline**
    window to view the cutscene at different moments. If that doesn’t work try playing
    the game and then stopping:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**时间轴**窗口的右上角点击**播放**按钮以查看其效果。您还可以手动在**时间轴**窗口中拖动白色箭头，以在不同的时刻查看场景。如果不起作用，请尝试玩游戏然后停止：
- en: '![](img/B18585_17_71.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_71.png)'
- en: 'Figure 17.71: Playing a timeline and dragging the playback header'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.71：播放时间轴并拖动播放头
- en: 'Now, we will make our **Intro** timeline asset tell the `CinemachineBrain`
    component (the main camera) which camera will be active during each part of the
    cutscene, switching to the player camera once the camera animation is over. We
    will create a second track—a Cinemachine track—which is specialized in making
    a specific `CinemachineBrain` component to switch between different virtual cameras.
    To do this, follow these steps:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使我们的**Intro**时间轴资产告诉`CinemachineBrain`组件（主摄像头）在场景的每个部分中哪个摄像头将是活动的，摄像头动画结束后切换到玩家摄像头。我们将创建第二个轨道——一个Cinemachine轨道，它专门用于在特定的`CinemachineBrain`组件之间切换不同的虚拟摄像头。为此，请按照以下步骤操作：
- en: 'Click the **+** button again and click on **Cinemachine Track**. Note that
    you can install Timeline without **Cinemachine**, but this kind of track won’t
    show up in that case:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**+**按钮，然后点击**Cinemachine轨道**。请注意，您可以在不安装**Cinemachine**的情况下安装时间轴，但那种情况下此类轨道将不会显示：
- en: '![](img/B18585_17_72.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_72.png)'
- en: 'Figure 17.72: Creating a new Cinemachine track'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.72：创建新的Cinemachine轨道
- en: 'In the **Playable Director** component’s **Bindings** list, drag the main camera
    to **Cinemachine Track** to make that track control which virtual camera will
    control the main camera at different moments of the cutscene:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**可播放导演**组件的**绑定**列表中，将主摄像头拖动到**Cinemachine轨道**，以便该轨道控制在不同时刻的场景中哪个虚拟摄像头将控制主摄像头：
- en: '![](img/B18585_17_73.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_73.png)'
- en: 'Figure 17.73: Binding the main camera to the Cinemachine track'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.73：将主摄像头绑定到Cinemachine轨道
- en: 'The next step indicates which virtual camera will be active during specific
    moments of the timeline. To do so, our Cinemachine track allows us to drag virtual
    cameras to it, which will create virtual camera clips. Drag both **CM vcam2**
    and **CM vcam1**, in that order, to the Cinemachine track:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步指示在时间轴的特定时刻哪个虚拟摄像头将是活动的。为此，我们的Cinemachine轨道允许我们将虚拟摄像头拖动到它上面，这将创建虚拟摄像头剪辑。按照顺序，将**CM
    vcam2**和**CM vcam1**拖动到Cinemachine轨道：
- en: '![](img/B18585_17_74.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_17_74.png)'
- en: 'Figure 17.74: Dragging virtual cameras to the Cinemachine track'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.74：将虚拟摄像头拖动到Cinemachine轨道
- en: If you hit the **Play** button or just drag the **Timeline Playback** header,
    you can see how the active virtual camera changes when the playback header reaches
    the second virtual camera clip. Remember to view this in the **Game** view.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击**播放**按钮或只是拖动**时间轴播放**头，您可以看到当播放头到达第二个虚拟摄像头剪辑时，活动虚拟摄像头如何变化。请记住在**游戏**视图中查看。
- en: If you place the mouse near the ends of the clips, a resize cursor will show
    up. If you drag them, you can resize the clips to specify their duration. In our
    case, we will need to match the length of the `CM vcam2` clip to the **Cart**
    animation clip and then put `CM vcam1` at the end of it by dragging it so that
    the camera will be active when the dolly cart animation ends. In my case, they
    were already the same length, but just try to change it anyway to practice. Also,
    you can make the `CM vcam1` clip shorter; we just need to play it for a few moments
    to execute the camera swap.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将鼠标放在剪辑的末端附近，会出现一个调整大小光标。如果您拖动它们，可以调整剪辑的大小以指定它们的持续时间。在我们的例子中，我们需要将`CM vcam2`剪辑的长度与**Cart**动画剪辑匹配，然后通过拖动将其放在末尾，这样当推车动画结束时，摄像机就会处于活动状态。在我的情况下，它们的长度已经相同，但还是要尝试改变它以练习。此外，您还可以使`CM
    vcam1`剪辑更短；我们只需要播放几秒钟来执行摄像机切换。
- en: 'You can also overlap the clips a little bit to make a smooth transition between
    the two cameras, instead of a hard switch, which will look odd:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以稍微重叠一下剪辑，以便在两个摄像机之间实现平滑过渡，而不是生硬切换，这样看起来会比较奇怪：
- en: '![](img/B18585_17_75.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_75.png)'
- en: 'Figure 17.75: Resizing and overlapping clips to interpolate them'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.75：调整大小和重叠剪辑以进行插值
- en: Increase the **Start Time** property of the **WaveSpawners** to prevent the
    enemies from being spawned before the cutscene begins.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**WaveSpawners**的**开始时间**属性增加，以防止在剪辑场景开始之前生成敌人。
- en: 'If you wait for the full cutscene to end, you will notice how at the very end,
    `CM vcam2` becomes active again. You can configure how Timeline will deal with
    the end of the cutscene, as by default, it does nothing. This can cause different
    behavior according to the type of track–in our case, again giving control to pick
    the virtual camera to the `CinemachineBrain` component, which will pick the virtual
    camera with the highest **Priority** value. We can change the **Priority** property
    of the virtual cameras to be sure that **CM vcam1** (the player camera) is always
    the more important one, or set **Wrap Mode** of the **Playable Director** component
    to **Hold**, which will keep everything as the last frame of the timeline specifies.
    In our case, we will use the latter option to test the Timeline-specific features:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您等待整个剪辑场景结束，您会注意到在最后，`CM vcam2`再次变得活跃。您可以配置Timeline如何处理剪辑场景的结束，默认情况下，它什么都不做。这可能会导致根据轨道类型的不同而出现不同的行为——在我们的例子中，再次将选择虚拟摄像机的控制权交给`CinemachineBrain`组件，该组件将选择具有最高**优先级**值的虚拟摄像机。我们可以更改虚拟摄像机的**优先级**属性，以确保**CM
    vcam1**（玩家摄像机）始终是更重要的一方，或者将**可播放导演**组件的**包裹模式**设置为**保持**，这将保持一切如时间轴的最后一帧所指定。在我们的例子中，我们将使用后者选项来测试Timeline特定的功能：
- en: '![](img/B18585_17_76.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_17_76.png)'
- en: 'Figure 17.76: Wrap Mode set to Hold mode'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.76：包裹模式设置为保持模式
- en: Most of the different kinds of tracks work under the same logic; each one will
    control a specific aspect of a specific object using clips that will execute during
    a set time. I encourage you to test different tracks to see what they do, such
    as **Activation**, which enables and disables objects during the cutscene. Remember,
    you can check out the documentation of the Timeline package in the Package Manager.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不同类型的轨道都遵循相同的逻辑；每个轨道都会使用在特定时间内执行的剪辑来控制特定对象的特定方面。我鼓励您测试不同的轨道，看看它们的作用，例如**激活**，它可以在剪辑场景中启用和禁用对象。记住，您可以在包管理器中查看Timeline包的文档。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the different animation systems that Unity provides
    for different requirements. We discussed importing character animations and controlling
    them with Animation Controllers. We also saw how to make cameras that can react
    to the game’s current situation, such as the player’s position, or that can be
    used during cutscenes. Finally, we looked at Timeline and the animation system
    to create an intro cutscene for our game. These tools are useful for making the
    animators in our team work directly in Unity without the hassle of integrating
    external assets (except for character animations) and also preventing the programmer
    from creating repetitive scripts to create animations, wasting time in the process.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Unity为不同需求提供的不同动画系统。我们讨论了导入角色动画以及使用动画控制器来控制它们。我们还看到了如何制作能够对游戏当前情况进行反应的摄像机，例如玩家的位置，或者可以在剪辑场景中使用。最后，我们探讨了Timeline和动画系统，为我们的游戏创建了一个开场剪辑场景。这些工具对于让我们的团队动画师直接在Unity中工作非常有用，无需整合外部资产（除了角色动画）的麻烦，同时也防止程序员创建重复的脚本来创建动画，从而节省时间。
- en: Now, you are able to import and create animation clips in Unity, as well as
    apply them to GameObjects to make them move according to the clips. Also, you
    can place them in the Timeline sequencer to coordinate them and create cutscenes
    for your game. Finally, you can create dynamic cameras to use in-game or in cutscenes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在Unity中导入和创建动画片段，并将它们应用到GameObject上，使它们根据片段移动。此外，你还可以将它们放置在Timeline序列编辑器中，以协调它们并为你的游戏创建场景。最后，你可以创建动态相机，用于游戏或场景中。
- en: With this, we end *Part 2*, where we learned about different Unity Systems to
    improve several artistic aspects of our game. In the next chapter, the first chapter
    of *Part 3*, we will wrap up the development of our game, seeing how to build
    and optimize our game, and also provide a quick intro to augmented reality applications.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了**第二部分**，在这一部分中，我们学习了不同的Unity系统，以提升我们游戏的艺术表现力。在下一章，即**第三部分**的第一章中，我们将总结我们游戏的发展，了解如何构建和优化我们的游戏，并提供增强现实应用的快速介绍。
