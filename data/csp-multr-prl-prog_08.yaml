- en: Chapter 8. Debugging Multithreaded Applications with Visual Studio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Visual Studio调试多线程应用程序
- en: Multithreaded applications present their own set of challenges to develop as
    we have seen so far in this book, but they also have a unique set of challenges
    to debug. Visual Studio, starting with Visual Studio 2010, has developed additions
    to the debugger to assist with debugging tasks and the `Parallel` library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书所见，多线程应用程序在开发上具有自己的挑战，但它们在调试上也有独特的挑战。从Visual Studio 2010开始，Visual Studio为调试任务和`Parallel`库开发了调试器的附加功能。
- en: Visual Studio has had the **Threads** window in their debugger since 2003 to
    assist with debugging threads. However, starting with Visual Studio 2010, they
    have added the **Parallel Stacks** window, **Parallel Watch** window, and the
    **Tasks** window to aid in debugging applications using the **Task Parallel Library**
    (**TPL**). In this chapter, we will examine all of these windows and demonstrate
    how to step through a multithreaded and multitask application to find program
    flow issues and race/lock conditions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自2003年以来，Visual Studio在其调试器中就有**线程**窗口，以帮助调试线程。然而，从Visual Studio 2010开始，他们增加了**并行堆栈**窗口、**并行监视**窗口和**任务**窗口，以帮助使用**任务并行库**（**TPL**）调试应用程序。在本章中，我们将检查所有这些窗口，并演示如何逐步执行多线程和多任务应用程序以查找程序流程问题和竞态/锁定条件。
- en: A **race condition** is a type of error that occurs when multiple threads interfere
    with each other and is based on the timing and execution of the different threads.
    Because of this, the condition does not happen every time the application executes.
    It takes a certain timing of the execution of the different threads.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**竞态条件**是一种错误类型，当多个线程相互干扰时发生，并基于不同线程的时机和执行。因此，这种条件并不在每次应用程序执行时都发生。它需要不同线程执行的一定时机。'
- en: A race condition happens when two or more threads access a data variable and
    try to modify it at approximately the same time. Since the OS scheduler can switch
    between threads at any time, you cannot predict the order in which the threads
    will access the data. The result of the change in data is dependent on the OS
    scheduling algorithm. Both the threads are "racing" to access the data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程几乎同时访问一个数据变量并尝试修改它时，会发生**竞态条件**。由于操作系统调度器可以在任何时候在线程之间切换，因此您无法预测线程访问数据的顺序。数据变化的结果取决于操作系统调度算法。这两个线程都在“竞速”以访问数据。
- en: Problems can happen when one thread examines the contents of a variable and
    performs an action but another thread changes the contents of the same variable
    during the time the first thread examines it and then acts on it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程检查一个变量的内容并执行一个动作，而另一个线程在第一个线程检查和执行动作的过程中改变了同一变量的内容时，可能会出现问题。
- en: A **lock condition** occurs when two or more threads are waiting on a resource
    that is locked by another thread. So, if thread 1 is waiting on a resource locked
    by thread 2 and thread 2 is waiting on a resource locked by thread 1, then both
    threads will remain "hung" forever waiting on each other to free up a resource.
    This is a type of a lock condition called a **deadlock**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程等待另一个线程锁定的资源时，会发生**锁定条件**。因此，如果线程1正在等待由线程2锁定的资源，而线程2正在等待由线程1锁定的资源，那么这两个线程将永远“挂起”，永远等待对方释放资源。这是一种称为**死锁**的锁定条件。
- en: 'In this chapter, you will learn the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Using the **Threads** window in the debugger
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器中的**线程**窗口
- en: Using the **Tasks** window in the debugger
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器中的**任务**窗口
- en: Accessing the **Parallel Stacks** and **Parallel Watch** windows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问**并行堆栈**和**并行监视**窗口
- en: Stepping through an application with more than one thread and more than one
    task
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有多个线程和多个任务的程序中逐步执行
- en: Detecting a deadlock condition
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测死锁条件
- en: Considerations for debugging multithreaded applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试多线程应用程序的注意事项
- en: There are several things to consider when debugging a parallel application.
    The first thing is probably the most obvious—there are multiple things happening
    at once. If you have an application with five threads, then all five threads can
    be executing at the same time depending on how many cores your machine has. If
    you step through a particular thread, the other threads are not just waiting on
    you unless there are breakpoints or they are waiting on a resource locked by the
    thread you are stepping through. You need to understand how your parallel application
    is designed and how it executes so you know what is happening in parallel—especially
    what is happening in threads other than the one you may by stepping through.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试并行应用程序时，有几个因素需要考虑。首先，可能最明显的一点是，同时发生多个事件。如果你有一个包含五个线程的应用程序，那么这五个线程可以同时执行，这取决于你的机器有多少个核心。如果你逐步执行一个特定的线程，其他线程并不会只是等待你，除非有断点或者它们正在等待你逐步执行的线程所锁定的资源。你需要了解你的并行应用程序是如何设计和执行的，这样你才知道并行中发生了什么——特别是除了你可能逐步执行的线程之外的其他线程发生了什么。
- en: Secondly, debugging a concurrent application takes a lot of information. When
    using the debugger on a TPL application, you can have the **Local**, **Immediate**,
    **Threads**, **Task**, **Parallel Stack**, **Parallel Task**, **Process Explorer**,
    **Source Code**, and **Object Explorer** windows all open at the same time. This
    either takes a lot of screen real estate or requires constantly moving windows
    around to see the information that you need. I highly recommend doing this on
    a dual monitor setup. You can never have too much screen room when debugging a
    parallel application. There are few things more frustrating than not being able
    to easily see all the information you need as you step through an application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，调试并发应用程序需要大量的信息。当在TPL应用程序上使用调试器时，你可以同时打开**本地**、**立即**、**线程**、**任务**、**并行堆栈**、**并行任务**、**进程资源管理器**、**源代码**和**对象资源管理器**窗口。这要么需要大量的屏幕空间，要么需要不断移动窗口以查看所需的信息。我强烈建议在双显示器设置上这样做。在调试并行应用程序时，屏幕空间永远都不嫌多。没有比在逐步执行应用程序时无法轻松查看所有所需信息更令人沮丧的事情了。
- en: Using the Threads window
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程窗口
- en: The **Threads** window in the Visual Studio debugger allows you to view details
    of all of the threads in an application and work with them. You can view the stack
    of each thread. You can freeze or thaw a thread, and view all of the details concerning
    a thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio调试器中的**线程**窗口允许你查看应用程序中所有线程的详细信息，并与之交互。你可以查看每个线程的堆栈。你可以冻结或解冻一个线程，并查看有关线程的所有详细信息。
- en: 'If you start the debugger in an application and then go to **Debug** | **Windows**,
    you can select the **Threads** window. If you do this, you should see something
    like the following; this is the **Threads** window for the thread''s version of
    the `OldStarFinder` program we did in [Chapter 7](ch07.html "Chapter 7. Data Parallelism"),
    *Data Parallelism*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个应用程序中启动调试器，然后转到**调试** | **窗口**，你可以选择**线程**窗口。如果你这样做，你应该看到以下内容；这是我们在[第7章](ch07.html
    "第7章。数据并行")中做的`OldStarFinder`程序线程版本的**线程**窗口，*数据并行*：
- en: '![Using the Threads window](img/8321EN_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![使用线程窗口](img/8321EN_08_01.jpg)'
- en: 'Let''s take a look at this window and examine it in detail. It contains the
    following columns:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个窗口，并详细检查它。它包含以下列：
- en: '**Flag**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flag**'
- en: '**Active**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Active**'
- en: '**ID**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**'
- en: '**Managed ID**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Managed ID**'
- en: '**Category**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Category**'
- en: '**Name**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**'
- en: '**Location**'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location**'
- en: '**Priority**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Priority**'
- en: '**Affinity Mask**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Affinity Mask**'
- en: '**Suspended Count**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Suspended Count**'
- en: '**Process Name**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Process Name**'
- en: '**Process ID**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Process ID**'
- en: '**Transport Qualifier**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transport Qualifier**'
- en: The **Flag** column allows you to designate a thread as one that you want to
    watch. If you right-click on a thread in this window, you can mark or unmark it
    as a flagged thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flag**列允许你指定一个线程为你想要监视的线程。如果你在这个窗口中右键单击一个线程，你可以标记或取消标记它为标记线程。'
- en: The **Active** column indicates which thread is the currently active thread.
    A yellow arrow designates the active thread in the debugger. It is also important
    to note that when stepping through a thread, other threads continue their operation
    unless a breakpoint is set. All of the threads do not block while you are stepping
    through a particular thread.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Active**列指示哪个线程是当前活动的线程。黄色箭头在调试器中指定活动线程。值得注意的是，当你逐步执行一个线程时，其他线程会继续它们的操作，除非设置了断点。所有线程在你逐步执行特定线程时都不会阻塞。'
- en: The **ID** column shows a thread's ID number in Windows, which is different
    from the .NET Managed ID.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**ID**列显示Windows中线程的ID号，这与.NET托管ID不同。'
- en: The **Managed ID** column shows the managed ID number of a thread. A **managed
    thread** is different from a Windows thread. A managed thread, in this context,
    is a thread managed in .NET by the CLR and the threadpool. A managed thread can
    execute in one or more Windows threads. A .NET managed thread is created using
    the .NET `Threads` class. Also, remember when using `Tasks` that a task is not
    a thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管ID**列显示线程的托管ID号。**托管线程**与Windows线程不同。在这个上下文中，**托管线程**是由CLR和线程池在.NET中管理的线程。托管线程可以在一个或多个Windows线程中执行。.NET托管线程是通过使用.NET
    `Threads`类创建的。此外，记住在使用`Tasks`时，任务不是线程。'
- en: The **Category** column displays the thread's classification as either the main
    thread, a user interface thread, a remote procedure handler thread, or a worker
    thread.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别**列显示线程的分类，可以是主线程、用户界面线程、远程过程调用处理线程或工作线程。'
- en: The **Name** column displays the thread's **Name** property if it is set, or
    otherwise displays **<No Name>**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**列显示线程的**名称**属性，如果已设置，否则显示**<无名称>**。'
- en: The **Location** column shows what method the thread is currently executing.
    By double-clicking on a row in this column, you can see the thread's full stack.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置**列显示线程当前正在执行的方法。通过双击此列中的某一行，你可以看到线程的完整堆栈。'
- en: The **Priority** column shows the Windows priority for the thread.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级**列显示线程的Windows优先级。'
- en: The **Affinity Mask** column shows this mask for each thread. The affinity is
    a bitwise mask indicating which processors a thread is eligible to execute on.
    In our example, we have a four-processor system and all but one of the threads
    has a mask that ends with `1111`. These are the four bits representing our four
    processors. This indicates that these threads can execute on any of the processors.
    There are methods in the `Threads` class that allow you to programmatically set
    which processors a thread can run on if you wish.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**亲和掩码**列显示每个线程的此掩码。亲和性是一个位掩码，指示线程可以执行哪些处理器。在我们的例子中，我们有一个四处理器系统，除了一个线程外，所有线程的掩码都以`1111`结尾。这四个位代表我们的四个处理器。这表明这些线程可以在任何处理器上执行。`Threads`类中有方法允许你通过编程方式设置线程可以运行的处理器，如果你愿意的话。'
- en: The **Suspended Count** column is a count manipulated by freezing and thawing
    threads. If you freeze a thread in managed code, then the thread will not run
    even if it is able to, and the suspended count will be `1`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂起计数**列是由冻结和解冻线程所操作的计数。如果你在托管代码中冻结一个线程，那么即使该线程能够运行，它也不会运行，挂起计数将为`1`。'
- en: The **Process Name** column displays the Windows process that the thread is
    associated with. Since we are running our application through the Visual Studio
    debugger, you will see that our threads have **OldStarsFinder.vshost.exe** as
    the process. You can also run the Task Manager in Windows and see this process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程名称**列显示与线程关联的Windows进程。由于我们是通过Visual Studio调试器运行我们的应用程序，你会看到我们的线程的进程是**OldStarsFinder.vshost.exe**。你还可以在Windows中运行任务管理器并看到此进程。'
- en: Now that we have gone through all of the information the **Threads** window
    supplies, what are some of the functions you can do with it? You can show or hide
    columns in the display by clicking on the **Columns** dropdown in the header of
    this window; you can also do a Group By operation of the threads to group them
    for better management. We already saw how you can double-click on a row in the
    **Location** column and see a thread's call stack. You can also make any thread
    the **Active** thread by right-clicking on it and selecting **Switch To Thread**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了**线程**窗口提供的信息，你可以用它做些什么呢？你可以通过点击此窗口标题栏中的**列**下拉菜单来显示或隐藏显示中的列；你还可以对线程执行分组操作以更好地管理它们。我们已经看到了如何通过双击**位置**列中的一行来查看线程的调用堆栈。你也可以通过右键单击任何线程并选择**切换到线程**来将其设置为**活动**线程。
- en: Next, let's examine the **Tasks** window.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来检查**任务**窗口。
- en: Using the Tasks window
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务窗口
- en: 'The **Tasks** window was added to the Visual Studio debugger in the 2010 version
    when the TPL was added to .NET in Version 4.0\. It is similar to the **Threads**
    window and shows information about each task in your application. Tasks are created
    using the `System.Threading.Tasks.Task` class or by using the `async` and `await`
    keywords. The `async` and `await` keywords were introduced in Version 4.5 of .NET
    and will be covered in [Chapter 11](ch11.html "Chapter 11. The Asynchronous Programming
    Model"), *The Asynchronous Programming Model*. Like the **Threads** window, it
    can be accessed from the debugger in Visual Studio by navigating to **Debug**
    | **Windows**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务**窗口是在2010版本的Visual Studio调试器中添加的，当时在.NET 4.0版本中将TPL添加到.NET中。它与**线程**窗口类似，显示您应用程序中每个任务的信息。任务是通过使用`System.Threading.Tasks.Task`类或使用`async`和`await`关键字创建的。`async`和`await`关键字是在.NET
    4.5版本中引入的，将在[第11章](ch11.html "第11章。异步编程模型") *异步编程模型*中介绍。像**线程**窗口一样，可以通过在Visual
    Studio的调试器中导航到**调试** | **窗口**来访问它：'
- en: '![Using the Tasks window](img/8321EN_08_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用任务窗口](img/8321EN_08_02.jpg)'
- en: 'Let''s examine the information and functions you can use the **Tasks** window
    for:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查您可以使用**任务**窗口进行的信息和功能：
- en: '**Flags**: This column shows the tasks that you have flagged or unflagged.
    By clicking on this column for a task, you can flag the threads in this task.
    You can flag several tasks and then sort or use the Group By function to show
    the flagged tasks at the top. You can also filter the **Parallel Stacks** window
    by flagged tasks so you only see the parallel stacks of the tasks you are interested
    in.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: 此列显示您已标记或取消标记的任务。通过单击此列中的任务，您可以标记此任务中的线程。您可以标记多个任务，然后通过排序或使用分组功能来显示标记的任务。您还可以通过标记的任务来过滤**并行堆栈**窗口，以便您只能看到您感兴趣的任务的并行堆栈。'
- en: '**Icons**: This column shows which is the current task present on the current
    thread. This is shown by a yellow arrow. A white arrow indicates that the current
    task is at a breakpoint in the debugger. A pause symbol indicates that a task
    has been frozen.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**: 此列显示当前线程上当前任务的状态。这通过一个黄色箭头表示。一个白色箭头表示当前任务在调试器的断点处。一个暂停符号表示任务已被冻结。'
- en: '**ID**: This column is a Windows-generated identification number for a task.
    In our example, I have entered `8` into the **Number of bitmaps to divide into
    for processing** textbox and then set a breakpoint after the `Parallel.ForEach`
    loop. You can see that we have created eight tasks that are all running an anonymous
    method, and that it is initiated from the **Find Old Stars** button''s click event
    handler. Their IDs are numbers 1 through 8.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**: 此列是Windows为任务生成的识别号。在我们的示例中，我已经将`8`输入到**用于处理的位图数量**文本框中，然后在`Parallel.ForEach`循环之后设置了一个断点。您可以看到我们创建了八个任务，这些任务都在运行匿名方法，并且它们是从**查找旧恒星**按钮的点击事件处理器中启动的。它们的ID是1到8的数字。'
- en: '**Status**: This column shows the task''s state, which can be any of the following:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**: 此列显示任务的状态，可以是以下任何一种：'
- en: '**Active**: The task is currently active on the stack'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动**: 任务当前在堆栈上处于活动状态'
- en: '**Deadlocked**: The task is currently deadlocked waiting on a resource'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**: 任务当前处于死锁状态，正在等待资源'
- en: '**Waiting**: The task is currently waiting on CPU allocation'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待**: 任务当前正在等待CPU分配'
- en: '**Scheduled**: The task is scheduled to start executing when a thread in the
    threadpool is available'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已计划**: 任务计划在线程池中的线程可用时开始执行'
- en: '**Completed**: The task has completed its execution'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**: 任务已完成其执行'
- en: A task is considered in a deadlock state if its thread is in a lock condition
    with another thread in the application. A task is considered waiting if it is
    waiting on a lock to be freed or another task to complete.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个任务的线程与应用程序中的另一个线程处于锁定状态，则认为该任务处于死锁状态。如果一个任务正在等待释放锁或另一个任务完成，则认为它正在等待。
- en: '**Location**: This column displays the call stack for that particular task.
    Unlike the **Threads** window, to see the whole call stack, you need to hover
    over this column instead of double-clicking on it. Also, if a task has not started
    but is scheduled, then this column will not be populated yet.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**: 此列显示特定任务的调用堆栈。与**线程**窗口不同，要查看整个调用堆栈，您需要将鼠标悬停在此列上，而不是双击它。此外，如果一个任务尚未开始但已计划，则此列可能尚未填充。'
- en: '**Parent**: This column displays the ID of the task that created it.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父任务**: 此列显示创建该任务的任务的ID。'
- en: '**Thread Assignment**: This column displays the thread ID and thread name of
    the thread the task is executing on. In our example, you can see we used a number
    to name the thread of our tasks in this line of code:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程分配**：此列显示任务正在执行的线程的线程ID和线程名称。在我们的示例中，你可以看到我们在这行代码中使用了数字来命名我们的任务线程：'
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We pass in a random number between 1 and 1,000 as the second parameter of the
    `ThreadOldStarsFinder` method and then use the following line to set the thread
    name for the corresponding task:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将1到1,000之间的随机数作为`ThreadOldStarsFinder`方法的第二个参数传入，然后使用以下行来设置对应任务的线程名称：
- en: '[PRE1]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**APPDomain**: This column shows the application domain the task is running
    inside. The **Process** column displays the Windows ID of the Windows process
    the task is executing inside.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APPDomain**：此列显示任务正在运行的应用程序域。**进程**列显示任务正在执行的Windows进程的Windows ID。'
- en: '**AsyncState**: This column, if using the `async` or `await` keywords to run
    a task from a method call, shows the async state of the task.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AsyncState**：如果使用`async`或`await`关键字从方法调用中运行任务，此列显示任务的异步状态。'
- en: When debugging TPL applications, this window is very helpful in getting an overview
    of all of the tasks your code has generated, which are active, and the call stack
    and thread information of each of them. Combining this with the **Threads** window
    will give you a good look at all of the entities running in your application and
    where they are in their execution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试TPL应用程序时，此窗口非常有帮助，可以让你总体了解代码生成的所有任务，包括哪些是活跃的，以及每个任务调用的堆栈和线程信息。结合**线程**窗口，你可以很好地查看应用程序中运行的所有实体及其执行状态。
- en: The **Tasks** window is really only useful in debugging multithreaded applications
    if you are using the TPL. If you are using threads or the `BackgroundWorker` component,
    this window will not be helpful.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务**窗口在调试使用TPL的多线程应用程序时非常有用。如果你使用线程或`BackgroundWorker`组件，此窗口将不会有所帮助。'
- en: Using the Parallel Stacks window
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel Stacks窗口
- en: The **Parallel Stacks** window is very helpful in debugging parallel applications
    because it shows you task and thread information in a graphical view almost like
    a flowchart. It shows a lot of the same information as the **Threads** and **Tasks**
    windows but in a different format and it shows relationships between the threads
    and tasks, which is very helpful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parallel Stacks**窗口在调试并行应用程序时非常有帮助，因为它以图形视图几乎像流程图的方式显示任务和线程信息。它显示了与**线程**和**任务**窗口相同的大量信息，但格式不同，并且显示了线程和任务之间的关系，这非常有帮助。'
- en: The **Threads** and **Tasks** windows are a good tabular way to view all of
    the entities of your multithreaded application but they do not do a real good
    job of showing relationship and program flow information.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**和**任务**窗口是查看你的多线程应用程序所有实体的良好表格方式，但它们并不擅长展示关系和程序流程信息。'
- en: The **Parallel Stacks** information has a **Threads** view and a **Tasks** view.
    Each of these views can also be toggled to a **Method** view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parallel Stacks**信息有一个**线程**视图和一个**任务**视图。这些视图也可以切换到**方法**视图。'
- en: 'The following is the **Threads** view of our `OldStarsFinder` application after
    the `Parallel.ForEach` command executes and the bitmap is divided into eight sections:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在执行`Parallel.ForEach`命令并将位图分成八个部分后，我们的`OldStarsFinder`应用程序的**线程**视图：
- en: '![Using the Parallel Stacks window](img/8321EN_08_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用Parallel Stacks窗口](img/8321EN_08_03.jpg)'
- en: 'The following is the **Tasks** view of our `OldStarsFinder` application after
    the `Parallel.ForEach` command executes and the bitmap is divided into eight sections:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在执行`Parallel.ForEach`命令并将位图分成八个部分后，我们的`OldStarsFinder`应用程序的**任务**视图：
- en: '![Using the Parallel Stacks window](img/8321EN_08_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用Parallel Stacks窗口](img/8321EN_08_04.jpg)'
- en: 'The following is the **Threads** view toggled to the **Method** view of our
    `OldStarsFinder` application after the `Parallel.ForEach` command executes and
    the bitmap is divided into eight sections:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在执行`Parallel.ForEach`命令并将位图分成八个部分后，我们的`OldStarsFinder`应用程序的**线程**视图切换到**方法**视图：
- en: '![Using the Parallel Stacks window](img/8321EN_08_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用Parallel Stacks窗口](img/8321EN_08_05.jpg)'
- en: 'The following screenshot shows the **Tasks** view toggled to **Method** view
    of our `OldStarsFinder` application after the `Parallel.ForEach` command executes
    and the bitmap is divided into eight sections:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了执行`Parallel.ForEach`命令并将位图分成八个部分后，我们的`OldStarsFinder`应用程序的**任务**视图切换到**方法**视图：
- en: '![Using the Parallel Stacks window](img/8321EN_08_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用并行堆栈窗口](img/8321EN_08_06.jpg)'
- en: There are several items to note about this window. First is the toolbar. It
    allows you to select either **Threads** or **Tasks** from the drop-down menu.
    It also allows you to show only flagged threads in the window. Next, it allows
    you to toggle to the **Method** view, and also to zoom in on an area.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此窗口有几个需要注意的事项。首先是工具栏。它允许你从下拉菜单中选择**线程**或**任务**。它还允许你只显示窗口中的标记线程。接下来，它允许你切换到**方法**视图，并且还可以放大某个区域。
- en: In the **Threads** and **Tasks** views, the call path of the current thread
    is highlighted in blue. That is why you can see more than one box highlighted.
    The arrows connected to the boxes show the call path of the task or thread, and
    each box in the diagram represents a call stack. Also, if you hover over a box's
    (also known as a node) header or a row in a node, you get a tooltip. The tooltip
    of the node header shows the thread ID and name of all the threads in the call
    path leading to this node. In the row or method tooltip, you'll see the stack
    of the method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在**线程**和**任务**视图中，当前线程的调用路径以蓝色突出显示。这就是为什么你可以看到多个框被突出显示的原因。连接到框的箭头显示任务或线程的调用路径，图中的每个框代表一个调用堆栈。此外，如果你将鼠标悬停在框的标题（也称为节点）或节点中的行上，你会看到一个工具提示。节点标题的工具提示显示导致此节点的调用路径中所有线程的线程ID和名称。在行或方法工具提示中，你会看到方法的堆栈。
- en: The yellow arrow in a node indicates the active frame of the currently active
    thread. Also, the method name in all the nodes of the active thread's current
    stack frame are styled in bold. If you right-click on a method row in a stack
    frame, you will get a menu that allows you to go to that task or thread, or to
    the source code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 节点中的黄色箭头表示当前活动线程的活动帧。此外，活动线程当前堆栈帧中所有节点的方程序式都以粗体显示。如果你在堆栈帧中的方法行上右键单击，你将获得一个菜单，允许你转到该任务或线程，或转到源代码。
- en: The **Method** view we showed earlier shows all methods that either call or
    are called by the current method. The current method is shown in the middle with
    the methods that call it below and the methods it calls above. This is a nice
    way to get a current runtime view of the Visual Studio function, **Find All References**.
    It is not exactly the same but is similar.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的**方法**视图显示了所有调用或被当前方法调用的方法。当前方法显示在中间，调用它的方法显示在下方，它调用的方法显示在上方。这是获取Visual
    Studio函数当前运行时视图的一个好方法，即**查找所有引用**。它并不完全相同，但很相似。
- en: The **Parallel Stacks** window is probably where you will spend most of your
    time in the debug mode except for actually stepping through the code. Typically,
    you will have the **Threads** and **Tasks** windows up for a tabular reference,
    the code up to set breakpoints and step through lines, and the **Parallel Stacks**
    window to follow all of the threads, tasks, and their relations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行堆栈**窗口可能是你在调试模式中除了实际执行代码之外花费时间最多的地方。通常，你将打开**线程**和**任务**窗口以供表格参考，将代码打开以设置断点和逐行执行，以及使用**并行堆栈**窗口来跟踪所有线程、任务及其关系。'
- en: Using the Parallel Watch window
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行监视窗口
- en: The **Parallel Watch** window allows you to display the values of an expression
    that is held on multiple threads. You can see it running a parallel application
    and select **Parallel Watch** by navigating to **Window** | **Debug**. As you
    see in the following screenshot, the **Parallel Watch** window is empty until
    you add a watch statement. Each row shows a thread that has a method call that
    matches the method on the current stack frame.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行监视**窗口允许你显示多个线程上持有的表达式的值。你可以看到它运行一个并行应用程序，并通过导航到**窗口** | **调试**来选择**并行监视**。正如你在下面的屏幕截图中所看到的，**并行监视**窗口在添加监视语句之前是空的。每一行显示一个具有与当前堆栈帧中方法匹配的方法调用的线程。'
- en: 'If you click on the **<Add Watch>** bar, you can type in an expression to watch.
    This allows you to see the value of the same expression in multiple threads. You
    can show up to four **Parallel Watch** windows just like the regular **Watch**
    window if you would like to watch more than one expression. You can also filter
    the watch list by using the **Filter by Boolean Expression** box in the top-right
    corner of the window. If you type in an expression there, it will only show the
    threads in which that expression is true:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**<添加监视>**栏，你可以输入一个要监视的表达式。这允许你查看多个线程中相同表达式的值。如果你想监视多个表达式，你可以像常规的**监视**窗口一样显示多达四个**并行监视**窗口。你还可以通过在窗口右上角的**通过布尔表达式筛选**框中筛选监视列表。如果你在那里输入一个表达式，它将只显示包含该表达式的线程：
- en: '![Using the Parallel Watch window](img/8321EN_08_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用并行监视窗口](img/8321EN_08_07.jpg)'
- en: The **Parallel Watch** window is really just the **Watch** window but it allows
    you to watch the same expression on all the threads in your application. Any C#
    expression is valid in this window.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行监视**窗口实际上只是**监视**窗口，但它允许你在应用程序的所有线程上监视相同的表达式。在这个窗口中，任何C#表达式都是有效的。'
- en: 'In the following example, we took the previously used example and added a watch
    on a variable. We are watching the `Thread.Name` value of the thread each task
    is assigned. Here is the same window after we have completed the `Parallel.ForEach`
    command. You can see only one of the tasks has executed but the others are scheduled.
    The one that has started has executed the first line of its delegate, which is
    to set the thread name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们添加了一个监视变量到之前使用的示例。我们正在监视每个任务分配的线程的`Thread.Name`值。这是我们在完成`Parallel.ForEach`命令后的相同窗口。你可以看到只有一个任务已经执行，但其他任务已安排。已经开始的任务已经执行了其委托的第一行，即设置线程名称：
- en: '![Using the Parallel Watch window](img/8321EN_08_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用并行监视窗口](img/8321EN_08_08.jpg)'
- en: This window is a very good way in a `Parallel.For` or `Parallel.ForEach` loop
    that is executing the same delegate multiple times in multiple tasks to view the
    value of an expression in the delegate. It allows you to see the current value
    each task has at that moment of execution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`Parallel.For`或`Parallel.ForEach`循环中，这个窗口是一个非常有效的方法，该循环在多个任务中多次执行相同的委托。它允许你查看每个任务在执行那一刻的当前值。
- en: Debugging an entire application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试整个应用程序
- en: Now that we have examined all of the windows that the Visual Studio debugger
    provides for debugging multithreaded applications let's go through a real example.
    We will use the `OldStarsFinder` application that uses tasks and the TPL that
    we finished in [Chapter 7](ch07.html "Chapter 7. Data Parallelism"), *Data Parallelism*.
    Remember that this application takes a user-entered number and then divides a
    large bitmap file by that number into an equal number of smaller bitmap files.
    Then, using a parallel `ForEach` loop, it processes each bitmap to try and find
    old stars in the image. It keeps a track of how many old stars are found. When
    it finishes, it reassembles the pieces and displays the large bitmap with each
    old star colored blue. It also displays the final number of old stars it found.
    Let's get started.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了Visual Studio调试器为调试多线程应用程序提供的所有窗口，让我们通过一个真实示例来操作。我们将使用在[第7章](ch07.html
    "第7章。数据并行")中完成的`OldStarsFinder`应用程序，该应用程序使用任务和TPL。请记住，这个应用程序接受用户输入的数字，然后将大位图文件按该数字分割成相等数量的较小位图文件。然后，使用并行`ForEach`循环，它处理每个位图以尝试在图像中找到旧星。它跟踪找到的旧星数量。完成时，它重新组装碎片并显示带有每个旧星蓝色的位图。它还显示它找到的旧星总数。让我们开始吧。
- en: How to do it
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'First, let''s open our `OldStarsFinder` application in Visual Studio and set
    some breakpoints to help us get started. Then perform the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在Visual Studio中打开我们的`OldStarsFinder`应用程序并设置一些断点以帮助我们开始。然后执行以下步骤：
- en: Put a breakpoint on the line of code that contains the `Parallel.ForEach` command
    as shown here:![How to do it](img/8321EN_08_09.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含`Parallel.ForEach`命令的代码行上设置断点，如图所示：![如何操作](img/8321EN_08_09.jpg)
- en: Now let's place a second break in the `ThreadOldStarsFinder` method that each
    of the parallel tasks are executing. We will place it early in the method where
    we set the thread name using the random number that we pass in from the `Parallel.ForEach`
    command:![How to do it](img/8321EN_08_10.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`ThreadOldStarsFinder`方法中放置第二个断点，该断点每个并行任务都在执行。我们将在方法中放置它，在那里我们使用从`Parallel.ForEach`命令传递的随机数设置线程名称：![如何操作](img/8321EN_08_10.jpg)
- en: Now, let's start the application in the debugger and enter `6` in the textbox
    for how many bitmaps to divide the large image into:![How to do it](img/8321EN_08_11.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在调试器中启动应用程序，并在文本框中输入`6`，以将大图像分割成多少个位图：![如何操作](img/8321EN_08_11.jpg)
- en: Next, let's click on the **Old Star Finder** button. We will see that the code
    enters the button's click event handler and comes to the first breakpoint that
    we set at the `Parallel.ForEach` command. The following screenshot shows how the
    debugger looks along with the **Thread**, **Tasks**, **Parallel Stacks**, and
    **Parallel Watch** windows:![How to do it](img/8321EN_08_12.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们点击**旧星寻找器**按钮。我们会看到代码进入按钮的点击事件处理程序，并到达我们在`Parallel.ForEach`命令处设置的第一个断点。下面的截图显示了调试器以及**线程**、**任务**、**并行堆栈**和**并行监视**窗口的外观：![如何操作](img/8321EN_08_12.jpg)
- en: 'Right before we step over the `Parallel.ForEach` command, you can see that
    there are no tasks yet:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们执行`Parallel.ForEach`命令之前，你可以看到还没有任何任务：
- en: '![How to do it](img/8321EN_08_13.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_08_13.jpg)'
- en: 'You will also see that there are no extra threads for these tasks because we
    have not executed the parallel data loop yet:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还会看到，这些任务没有额外的线程，因为我们还没有执行并行数据循环：
- en: '![How to do it](img/8321EN_08_14.jpg)![How to do it](img/8321EN_08_15.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_08_14.jpg)![如何操作](img/8321EN_08_15.jpg)'
- en: 'And looking at the **Parallel Stacks** window you only see the main thread
    of the application:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看着**并行堆栈**窗口，你只能看到应用程序的主线程：
- en: '![How to do it](img/8321EN_08_16.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_08_16.jpg)'
- en: Now, let's step over the `Parallel.ForEach` command and look at these same windows
    while we are at a breakpoint in the delegate:![How to do it](img/8321EN_08_17.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在委托中的断点处执行`Parallel.ForEach`命令，并查看这些相同的窗口：![如何操作](img/8321EN_08_17.jpg)
- en: Now, if you hover over the line in the **Parallel Stacks** window with the yellow
    arrow, you will see the line of code each thread is executing. This is using the
    **Threads** view of the **Parallel Stacks** window:![How to do it](img/8321EN_08_18.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你将鼠标悬停在**并行堆栈**窗口中带有黄色箭头的行上，你会看到每个线程正在执行的代码行。这是使用**并行堆栈**窗口的**线程**视图：![如何操作](img/8321EN_08_18.jpg)
- en: Now, let's examine the same thing using the **Tasks** view of the **Parallel
    Stacks** window:![How to do it](img/8321EN_08_19.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用**并行堆栈**窗口的**任务**视图来检查相同的内容：![如何操作](img/8321EN_08_19.jpg)
- en: Also, at the same time, let's examine our **Parallel Watch** window:![How to
    do it](img/8321EN_08_20.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，同时，让我们检查我们的**并行监视**窗口：![如何操作](img/8321EN_08_20.jpg)
- en: Next, let's step over the current line in the `ThreadOldStarsFinder` delegate
    method and take another look at our windows:![How to do it](img/8321EN_08_21.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`ThreadOldStarsFinder`委托方法中的当前行上执行单步跳过，并再次查看我们的窗口：![如何操作](img/8321EN_08_21.jpg)
- en: Then start stepping through the delegate and notice what happens. Here is a
    view from our example:![How to do it](img/8321EN_08_22.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后开始逐步执行委托，注意发生了什么。以下是我们的示例视图：![如何操作](img/8321EN_08_22.jpg)
- en: Notice how the information changes in the windows as you start to step through
    the delegate of one task on one thread. You will notice all of the tasks are,
    or can be, on different lines after you step over one line in this one thread.
    Also, the **Parallel Watch** window will show different values of the expression
    as you step through.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，当你开始逐步执行一个线程上一个任务的委托时，窗口中的信息是如何变化的。你会在执行这个线程的一行之后注意到所有任务都在或可以位于不同的行上。此外，**并行监视**窗口会显示你在逐步执行表达式时的不同值。
- en: Now, let the program run until it has completed the parallel loop and it is
    ready to reassemble the pieces.![How to do it](img/8321EN_08_23.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让程序运行，直到它完成并行循环并准备好重新组装碎片。![如何操作](img/8321EN_08_23.jpg)
- en: As you can see, we still have multiple threads running in our application but
    no tasks. This indicates that all of the tasks we created in the `Parallel.ForEach`
    loop have completed their delegate functions and the tasks are no longer on the
    threadpool. But the application still has threads it is using and some it needs
    to clean up.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们的应用程序中仍然有多个线程在运行，但没有任务。这表明我们在`Parallel.ForEach`循环中创建的所有任务都已经完成了它们的委托函数，任务不再在线程池中。但是，应用程序仍然在使用一些线程，并且需要清理一些线程。
- en: Now we have seen how to open all of the various windows in the debugger for
    parallel debugging and stepped through our multithreaded TPL-based application.
    Let's talk about what just happened and what we saw.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在调试器中打开所有各种窗口进行并行调试，并逐步执行了基于TPL的多线程应用程序。让我们谈谈刚刚发生的事情以及我们所看到的。
- en: How it works
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: 'You can see from our previous example that before we enter the `Parallel.ForEach`
    command, there are no tasks shown in our **Tasks** window or **Parallel Stacks**
    window in the **Tasks** view; this is shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从我们之前的例子中看到，在我们进入`Parallel.ForEach`命令之前，我们的**任务**窗口或**并行堆栈**窗口在**任务**视图中没有显示任何任务；这在上面的屏幕截图中显示：
- en: '![How it works](img/8321EN_08_24.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_24.jpg)'
- en: There are no tasks yet because we have not created any. But the application
    has several threads already. There is one for the main thread and it is the one
    we have a breakpoint on, one to handle .NET system events, and one for the visual
    studio debugger our application is running inside.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有任务，因为我们还没有创建任何任务。但是应用程序已经有了几个线程。有一个是主线程，这是我们设置断点的线程，有一个用于处理.NET系统事件，还有一个用于我们应用程序运行的Visual
    Studio调试器。
- en: 'Let''s switch our **Parallel Stacks** window to **Threads** view:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的**并行堆栈**窗口切换到**线程**视图：
- en: '![How it works](img/8321EN_08_25.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_25.jpg)'
- en: Now, you can see that the yellow arrow is in the **Old Stars Finder** button's
    click event handler on line **139** right where our breakpoint is. The `prsOldStarsCount`
    variable is set to `0` because that is how we initialized it, and none of the
    versions of the delegate have run yet to update it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到黄色箭头位于**旧星查找器**按钮的点击事件处理程序的第**139**行，正好是我们的断点所在位置。`prsOldStarsCount`变量被设置为`0`，因为这是我们初始化它的方式，而且代表者的任何版本都还没有运行来更新它。
- en: 'Now, I have stepped through the delegate line twice to let two of the parallel
    tasks get started. Let''s look at the results so far:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经跳过了委托行两次，让两个并行任务开始。让我们看看到目前为止的结果：
- en: '![How it works](img/8321EN_08_26.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_26.jpg)'
- en: Remember that when we step over a line in one thread, the other threads continue
    to operate until the thread we step over completes and the control is returned
    back to the debugger. So, a lot of other things can happen while we execute one
    line in one thread. As we see here, we are currently in a task numbered **3**
    at line **49**. We can also see that task **1** is currently waiting on line **57**.
    We also notice in the **Parallel Watch** window that both tasks show the value
    of **369** in the variable, `prsOldStarsCount`. What does this tell us?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们在一个线程中跳过一行时，其他线程将继续运行，直到我们跳过的线程完成并且控制权返回给调试器。所以，在我们执行一个线程中的一行代码时，可能会发生很多事情。正如我们所看到的，我们目前位于编号为**3**的任务的第**49**行。我们还可以看到任务**1**目前正在等待第**57**行。我们还在**并行监视**窗口中注意到，两个任务在变量`prsOldStarsCount`中都显示了**369**的值。这告诉我们什么？
- en: 'This tells us that while we are still on one of the first lines in the delegate
    method in task **3** and it has not begun any real processing yet, other tasks
    have already found **369** old stars. You''ll also notice that both tasks in the
    **Parallel Watch** window show the same value for `prsOldStarsCount`. This is
    because this is a global variable and all tasks are looking at and updating the
    same copy. Now, let''s step over one line of code in the task **3** delegate and
    see what happens:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，当我们仍然在任务**3**的委托方法中的第一行，并且还没有开始任何实际处理时，其他任务已经找到了**369**颗旧星。你也会注意到，**并行监视**窗口中的两个任务都显示`prsOldStarsCount`的相同值。这是因为这是一个全局变量，所有任务都在查看和更新相同的副本。现在，让我们在任务**3**的委托中跳过一行代码，看看会发生什么：
- en: '![How it works](img/8321EN_08_27.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_27.jpg)'
- en: Now, we are on line **49** in the task numbered **4** and the value of `prsOldStarsCount`
    is **605**. What just happened? We stepped over one line in task **3** and ended
    up in task **4** on the same line.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们位于编号为**4**的任务的第**49**行，`prsOldStarsCount`的值是**605**。发生了什么？我们在任务**3**中跳过了一行代码，最终在任务**4**的同一行。
- en: Remember we have a breakpoint set in the delegate method of each of the six
    tasks that our `Parallel.ForEach` loop created. When you step over a line or continue
    in the debugger, it stops at the next break point that is encountered. Also, remember
    that when we step over a line, all of our threads and tasks can run during that
    time. So, when we stepped over the line in task **3**, the next breakpoint the
    debugger came to was that same line in task **4**. You can see several things
    from our window. Tasks **2**, **3**, and **4** are all on line **49** and haven't
    gotten to line **51** (the next executable line). This tells us that when we stepped
    over line **49** in task **3** the debugger encountered a break at line **49**
    in task **4** before the execution of line **49** in task **3** got completed.
    We also see that in the time it took to reach this next break point, our tasks
    have now counted **605** old stars, up from **369**. Since task **1** is the only
    task we see past line **49**, we can surmise that it is the one that has counted
    all of these stars.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们在六个任务中每个任务的委托方法中设置了断点。当你跨过一行或继续在调试器中时，它会停在遇到的下一个断点上。此外，记住当我们跨过一行时，所有线程和任务都可以在那个时间运行。所以，当我们跨过任务**3**中的行时，调试器到达的下一个断点是任务**4**中相同的行。你可以从我们的窗口中看到一些东西。任务**2**、**3**和**4**都在第**49**行，还没有到达第**51**行（下一行可执行代码）。这告诉我们，当我们跨过任务**3**中的第**49**行时，调试器在任务**4**的第**49**行遇到了断点，在任务**3**的第**49**行执行完成之前。我们还看到，在达到下一个断点所需的时间内，我们的任务已经计数了**605**颗旧星，比**369**颗多。由于任务**1**是唯一一个我们看到超过第**49**行的任务，我们可以推断出它是计数所有这些星星的任务。
- en: 'Now, let''s step over this line and see what happens next:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跨过这条线，看看接下来会发生什么：
- en: '![How it works](img/8321EN_08_28.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_28.jpg)'
- en: 'This time we moved to line **49** of task **2** and no more old stars have
    been counted. Let''s step over one more line and examine:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们移动到了任务**2**的第**49**行，没有再计数任何旧星。让我们再跨过一行并检查：
- en: '![How it works](img/8321EN_08_29.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_29.jpg)'
- en: 'Now we have stopped on line **49** of task **5**. You can also see that both
    tasks **1** and **3** are now past line **49** and we have now counted **869**
    old stars. Let''s step over one more line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经停在任务**5**的第**49**行。你还可以看到任务**1**和**3**现在都已经超过了第**49**行，我们现在已经计数了**869**颗旧星。让我们再跨过一行：
- en: '![How it works](img/8321EN_08_30.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_30.jpg)'
- en: Now you can see we have started all six tasks that we asked for in our `Parallel.ForEach`
    loop and are already up to **1331** old stars. But even with **1331** old stars
    already found, we have not moved past line **49** in three of our six tasks. Let's
    step over one more line. Since we have reached this breakpoint line in all six
    tasks, we should now step through the current task we are on, which is task **6**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，我们已经启动了我们`Parallel.ForEach`循环中请求的所有六个任务，并且已经达到了**1331**颗旧星。但是，即使已经找到了**1331**颗旧星，我们也没有在六个任务中的三个任务中超过第**49**行。让我们再跨过一行。由于我们已经在这六个任务中都达到了这个断点行，我们现在应该逐步执行我们当前的任务，即任务**6**。
- en: 'But as we do so, the other tasks can all run. That being said, the machine
    we are running on has four processing cores, so not all of them can get CPU time
    at once, as shown:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们这样做的时候，其他任务都可以运行。也就是说，我们运行的机器有四个处理核心，所以并不是所有的核心都能同时获得CPU时间，如下所示：
- en: '![How it works](img/8321EN_08_31.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_08_31.jpg)'
- en: As you can see, we now can start to step through the current task without stopping
    because the delegate that all of the tasks are running has no more breakpoints
    that can interfere. You can also see that in the time it took to execute this
    one line in task **6**, we have now counted **1686** old stars and moved a couple
    of lines in a few other tasks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在可以开始逐步执行当前任务，而无需停止，因为所有任务都在运行的委托没有更多的断点可以干扰。你还可以看到，在执行任务**6**中这一行所需的时间内，我们现在已经计数了**1686**颗旧星，并在几个其他任务中移动了几行。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also note that when you see **[External code]** in the stack frame, this is
    referring to .NET code and not your own source code. You can set your debugger
    to show the stack of external code, but usually this provides you with too much
    information when you are mostly concerned with the flow and debugging of your
    own source code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当你看到**[外部代码]**在堆栈帧中时，这指的是.NET代码，而不是你自己的源代码。你可以设置调试器以显示外部代码的堆栈，但通常当你主要关注自己源代码的流程和调试时，这会提供太多信息。
- en: At this point, keep stepping through and see what happens; then stop your application
    and redo the exercise. Each time you run the application in the debugger, you
    should see slightly different results because we have multiple threads running
    and competing for processing time. Each time you step through the code, different
    threads will get different amounts of CPU time depending on availability and other
    competing processes running on your machine. Remember your application and debugging
    is not the only thing running in your Windows machine.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，继续逐步执行并观察会发生什么；然后停止应用程序并重新做这个练习。每次你在调试器中运行应用程序时，你应该看到略有不同的结果，因为我们有多个线程在运行并竞争处理时间。每次你逐步执行代码时，不同的线程将根据可用性和你机器上运行的其他竞争进程获得不同数量的CPU时间。记住，你的应用程序和调试并不是Windows机器上唯一运行的事情。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have examined all of the functionality that Visual Studio
    provides multithreaded and parallel application developers to help them troubleshoot
    and debug their source code. We have examined the **Threads** window, **Tasks**
    window, **Parallel Tasks** window in **Threads** mode, the **Parallel Stacks**
    window in **Tasks** mode, and the **Parallel Stacks** window. We have also examined
    our `OldStarsFinder` application using these windows and then stepped through
    its execution.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们检查了Visual Studio为多线程和并行应用程序开发者提供的所有功能，以帮助他们调试和排查源代码中的问题。我们检查了**线程**窗口、**任务**窗口、**线程模式下的并行任务**窗口、**任务模式下的并行堆栈**窗口以及**并行堆栈**窗口。我们还使用这些窗口检查了我们的`OldStarsFinder`应用程序，并逐步执行了它的执行过程。
- en: 'You have learned how to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何：
- en: Examine all threads of your application as it runs
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序运行时的所有线程
- en: Examine all tasks your application creates using the TPL
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TPL检查应用程序创建的所有任务
- en: Step through an application with multiple tasks and threads running
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步执行具有多个任务和线程运行的应用程序
- en: View the stack of any thread or task in your application
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看应用程序中任何线程或任务的堆栈
- en: Set watch expressions and view them across all the threads
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置监视表达式并在所有线程中查看它们
- en: In the next chapter, we will discuss some popular design patterns for parallel
    applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些并行应用程序的流行设计模式。
