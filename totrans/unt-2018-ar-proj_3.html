<html><head></head><body>
        

                            
                    <h1 class="header-title">Censored - Various Sensor Data and Plugins</h1>
                
            
            
                
<p>I hope you'll excuse the cheeky pun in the title. In this chapter, we will discuss the various sensors that we can access through the various SDKs provided to us. This includes ARKit, Vuforia, ARCore, Swift API, and the Java API. Now, the reason we will be going with this route is because there are some things in the core APIs that are not exposed in the SDKs provided to Unity but that we can leverage using native plugins with wrapper calls in C#. To break this up, to be a little more succinct without going outside of the bounds of this book, I will not be teaching the syntax of the Java or Swift programming languages; there are already some fantastic books that have been written by other Packt authors that cover this material, such as <em>Beginning Swift</em> (<a href="https://www.packtpub.com/application-development/beginning-swift">https://www.packtpub.com/application-development/beginning-swift</a>) and <em>Java Programming for Beginners (</em><a href="https://www.packtpub.com/application-development/java-programming-beginners">https://www.packtpub.com/application-development/java-programming-beginners</a>).</p>
<p>This chapter will be broken down into several main sections, as follows:</p>
<ul>
<li>Leveraging sensors with Plugins</li>
<li>Writing Unity Plugins</li>
<li>C# Language Plugin</li>
<li>C++ Language Plugin</li>
<li>Swift Language Plugin</li>
<li>Objective-C Language Plugin</li>
<li>Java Language Plugin</li>
</ul>
<p>By breaking the chapter down into these distinct sections, we can make it much easier for you to find the specific section you want.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Project overview</h1>
                
            
            
                
<p>We will create basic plugins in C#, C++, Swift, Objective-C, and Java. Each one will be an implementation of a basic mathematical return value. Writing the plugins in their native code should take no more than 10 minutes to complete for each native code snippet. You must have a working test in Unity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>When dealing with AR Applications and games, there are bound to be prerequisites, and with this book this will be no different.</p>
<p>The following are the requirements for an Apple Mac computer:</p>
<ul>
<li>macOS 11</li>
<li>Xcode 9</li>
<li>Mono Framework <strong>5.14.0</strong></li>
<li>Unity 2017</li>
<li>ARKit</li>
</ul>
<p>It is suggested that you have a 2013 or later model Mac computer, as older versions do not support the Metal API for graphics.</p>
<p>When you install Unity on a Mac, it will install Visual Studio for Mac as well; the catch is it requires Mono Framework to run, so be sure to download and install everything.</p>
<p>Here are the requirements for a Windows computer:</p>
<ul>
<li>Windows 10</li>
<li>8 GB of RAM or more</li>
<li>Unity</li>
<li>ARCore</li>
<li>JDK 8 or higher</li>
<li>Visual Studio</li>
<li>Android Studio</li>
</ul>
<p>For more information, click on these links:<br/>
<br/>
<a href="https://store.unity.com/">https://store.unity.com/</a><br/>
<a href="https://developer.apple.com/arkit/">https://developer.apple.com/arkit/</a><br/>
<a href="http://www.mono-project.com/download/stable/#download-mac">http://www.mono-project.com/download/stable/#download-mac</a><br/>
<a href="https://www.visualstudio.com/">https://www.visualstudio.com/</a><br/>
<a href="https://developer.android.com/studio/">https://developer.Android.com/studio/</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sensors</h1>
                
            
            
                
<p>First things first, we need to get a good grasp of what sensors are and what they can be used for, before we get into the various mini projects that will coincide with each of the SDKs we will be using. This list of sensors is by no means a complete list and are some of the most common ones that we can leverage in AR applications and games:</p>
<ul>
<li>Fingerprint Sensor</li>
<li>Radiation Sensor</li>
<li>Heart Rate Monitor</li>
<li>Pedometer</li>
<li>Air Humidity Sensor</li>
<li>Thermometer</li>
<li>Barometer</li>
<li>Light Sensor</li>
<li>Proximity Sensor</li>
<li>Magnetometer</li>
<li>Gyroscope</li>
<li>Accelerometer</li>
<li>Ambient Light Sensor</li>
<li>Iris Scanner</li>
<li>IR Blaster</li>
<li>Touch Sensor</li>
<li>Microphone</li>
<li>Camera</li>
<li>GNSS</li>
<li>NFC</li>
<li>Laser</li>
<li>Air Gesture Sensor</li>
<li>Signal Receiver</li>
<li>LiFi</li>
<li>Clock</li>
</ul>
<p>In this section, we will describe what each of these sensors is and what they can be used for, besides their native functions.</p>
<p><strong>Proximity Sensor</strong>: The proximity sensor can detect when the cellphone is within a certain range of objects and manipulate software or hardware to react in a certain way, once the sensor’s trigger has been tripped. It is generally used to reduce the total amount of battery consumption by dimming the backlight of the cellphone when it reaches a certain range of the user’s ear or pocket. Theoretical usage in AR games and applications requires a little bit of thinking outside the box. We know that a proximity sensor can’t detect the difference between objects, so what we could do is detect whether there are multiple objects near the device and register an event based on that.</p>
<p><strong>Gyroscope</strong>: The gyroscope is a sensor designed to read and output the direction of a cellphone or device with the sensor installed. It is generally used to power apps and detect the orientation of the device to determine whether the UI should be displayed in landscape or portrait mode. Theoretical usage in AR games and applications could be to use the device to act as a compass for traversing the game world.</p>
<p><strong>Fingerprint scanner sensor</strong>: The fingerprint scanner sensor is a sensor designed to detect whether pressure has been added to a special plate and to read the input data from the plate.<br/>
It is generally used to add an additional layer of security over a login password. It is much more secure and harder to bypass than most standard passwords, even with AES encryption with salting.</p>
<p><strong>Camera</strong>: The camera is itself a sensor. It is able to able to digitize waves of light and the electromagnetic radiation emitted so that a device can interpret the information and display it in a way that is understandable to the user. It is generally used to take pictures to store and retrieve.</p>
<p><strong>Barometer</strong>: The barometer sensor is designed to detect changes in the atmospheric pressure, which in turn means it can effectively act as a means of forecasting the weather.<br/>
It is generally used to determine the weather in the general vicinity where the user is located.</p>
<p><strong>Thermometer</strong>: The thermometer sensor is a sensor used to detect changes in temperature and store/send that information to be displayed or acted upon. It is generally used to keep track of and measure the temperature of sensitive components in the device.</p>
<p class="mce-root"/>
<p><strong>Accelerometer</strong>: The accelerometer is a sensor designed to detect the momentum of the device, and, by extension, detect the momentum of the user. It is generally used to determine the speed in which the user is travelling while in possession of the device.</p>
<p><strong>Pedometer</strong>: The pedometer is a sensor that is designed to take the user’s momentum within the confines of human speed limits and convert it into steps walked. It is generally used to calculate the user’s daily step count and display it at a specific time for the user to review.</p>
<p><strong>Touch sensor</strong>: The touch sensor is designed to detect when a user’s finger touches the device’s screen and return the position and length of time the finger was in that location.<br/>
It is generally used to activate and manipulate all the basic and advanced usage for the device.</p>
<p><strong>Microphone</strong>: The microphone is a sensor designed to detect sound waves and convert them into digital information that the device can understand and store. It is generally used to pick up the sound waves during a phone call and transmit that data to a connected device remotely.</p>
<p><strong>Ambient light sensor</strong>: The ambient light sensor is designed to react to a variety of light conditions in such a way that it mimics how the human eyes would perceive and react to those different light scenarios. It is generally used for power saving by adjusting the backlight intensity levels (lighten or darken the screen), based on the lighting of the area around the device.</p>
<p><strong>Iris Scanner sensor</strong>: The iris scanner sensor is designed to create high-resolution images of the eye. It is used mainly for security purposes. It is considered a form of biometric security, as it will only accept data from a specific eye for unlocking the device.</p>
<p><strong>Air gesture sensor</strong>: The air gesture sensor is able to detect via infrared sensors — movements from hands in front of the device’s screen. It is generally used to add basic control of the device without needing to use the touch screen, for example, activating the screen or applications.</p>
<p><strong>Heart rate monitor sensor</strong>: The heart rate monitor sensor is a sensor designed to be able to track someone's heartbeat using a combination of algorithms, green LEDs, and the accelerometer to measure blood flow, and store this information. It is generally used to accurately measure your heartbeat during exercise.</p>
<p><strong>Air Humidity Sensor</strong>: The air humidity sensor is a thermal conductivity sensor that utilizes aspects of the temperature sensor to be able to detect humidity.</p>
<p class="mce-root"/>
<p><strong>Light sensor</strong>: There are many different types of light sensors that could be photoresistors, photodiodes, or even phototransistors. They are designed to detect whether there is light in a given area and, if so, how much light is available. A light sensor generally works in tandem with the ambient light sensor to give accurate light assessment for taking pictures.</p>
<p><strong>Magnetometer</strong>: The magnetometer is a sensor designed for measuring magnetic forces. Magnetometers are generally used for treasure-finder apps.</p>
<p><strong>IR Blaster sensor</strong>: The IR Blaster sensor is a sensor designed to emulate an infrared remote control. It is generally used to create a universal remote control app for a variety of devices.</p>
<p><strong>GNSS</strong> (<strong>Global Navigation Satellite System</strong>): GNSS is a sensor designed to pick up signals from multiple satellites for better accuracy, availability, and redundant data collection.<br/>
It is generally used to poll for a user's location in order to give more accurate results in a GPS app.</p>
<p><strong>NFC</strong> (<strong>Near-Field Communication</strong>): NFC sensors are designed to be wireless data transferers for proximity-based communication. They are generally used for using services such as Apple Pay and Apple Wallet payments.</p>
<p><strong>Signal receiver sensor</strong>: The signal receiver sensor is a sensor designed to receive radio waves and convert them into a digital form that the device can understand. It is generally used for telephone calls or for playing music from the radio.</p>
<p><strong>LiFi sensor</strong>: LiFi sensors, also known as <em>Light Fidelity Sensors,</em> use <strong>Light-emitting diodes</strong>  (<strong>LEDs</strong>) to transmit data. They are generally used for areas that cannot use Wi-Fi, such as power plants, to send and receive data.</p>
<p><strong>Clock</strong>: The <strong>Real-Time Clock</strong> or <strong>RTC</strong> is designed to accurately keep track of the time.<br/>
It is a clock that shows the exact time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Leveraging sensors with plugins</h1>
                
            
            
                
<p>As previously stated, we can access the information provided by any exposed piece of hardware and send that information to our applications and/or games we create within Unity. The catch is that if there isn’t an implementation within Unity or the SDKs we are using for AR applications, we will need to create a plugin with a wrapper to access that sensor.</p>
<p class="mce-root"/>
<p>This is also heavily dependent on which devices we want to target and whether we want to target both iOS and Android-based devices without any implementations done for us. If so, then we need to create the plugin ourselves. We can’t just write a plugin in C#, though; we would need native plugins to call upon these sensors to do our bidding. This means that we will need to utilize the Java and Swift languages for their respective operating systems. For Android, the native-level code would be Java or C++, and for iOS, the native-level code would be Swift, Objective-C, or C++.</p>
<p>It is extremely important that we first understand how the sensor values are returned to us from the JDK and Apple SDKs. The JDK breaks all of the sensors down into specific categories. The accelerometer, the gyroscope, and the pedometer are all in the motion sensors category; the temperature sensor is located within the environment sensors category.</p>
<p>There is an imperative distinction to be made between the categories that need to be fully understood. The environment sensors category returns a single sensor value for each sensor event; meanwhile, the motion sensors category will return a multi-dimensional array of each sensor event that occurs. With this tidbit of information out of the way, let's move on to the next section, where we will learn how to write and dissect basic plugins for Unity in C++, C#, Java, Swift, and Objective-C.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing unity plugins</h1>
                
            
            
                
<p>The first thing we need to do is gain an understanding of what a plugin is for Unity before we can create and dissect a very simple plugin for Unity.</p>
<p><strong>What is a plugin?</strong></p>
<p>A <em>plugin</em> is a dll file that stores code written in a different programming language that is a base implementation of some event that needs to be executed or in the same language that gives the base implementation of core code that functions as a library or non-changeable event.</p>
<p>Now, this is a very simplistic definition, but we can do better by explaining what they can do for the developer, or a developer who wants to utilize code you have written. Plugins allow a developer to extend existing code without having to trudge through the source library by accessing methods and properties that are made public to them, which adds new features to the game engine that is not natively present, separates operating system-specific code, and they can reduce the size of an application.</p>
<p class="mce-root"/>
<p>For Unity specifically, plugins allow us to directly interface with native calls and use them as we wish in our application or games. Many developers tend to create plugins with native system calls to extend the render pipeline or for enhancing shaders.</p>
<p>It is important to note that there are two very distinct plugin types available to use in Unity. Those two types are <strong>Native Plugins</strong> and <strong>Managed Plugins</strong>. A very simplified explanation of the difference between native and managed plugins is that native plugins are for low-level calls, and managed plugins are an easy way to hide source code.</p>
<p>There is, however, a more nuanced differentiation between them than this old adage.</p>
<p>A managed plugin can and will easily hide source code from prying eyes when a developer wants to sell something in the asset store. It can also be used to include libraries and frameworks that are not otherwise readily available to Unity. For example, a developer could import the Entity Framework dll files into Unity and utilize the Entity Framework to create, manage, and handle database code with Unity. The final thing that a managed plugin can do is allow a developer to utilize some .NET languages and compilers that are not supported by Unity, such as F#, JScript, IronPython, ClosureCLR, or even Powershell. For example, a developer could create a plugin for Unity that allows for scripting in IronPython, or they could write game code using IronPython and import it as a plugin and use it without issues.</p>
<p>A native plugin, on the other hand, is profoundly more powerful. A native plugin normally consists of using Java, Swift, Objective-C, or C++ to access the direct hardware of their respective devices and provide functionality that a developer could otherwise not have access to within Unity. Let’s say a developer is working with a device that connects to a smartphone that is not normally present in smartphones; in this case, we will go with the <strong>BACtrack Mobile Pro</strong> as our example.</p>
<p>The BACtrack Mobile pro is a police-grade breathalyzer that can check a user’s blood alcohol content and send that information to a device via Bluetooth connections. This developer wants to make a drinking-style AR game, and they want to make the game harder, the higher the end user’s BAC level is. This developer would need to use a native plugin to gain access to the BACtrack device’s sensors' results.</p>
<p>Now that a firm understanding should have been gained from this explanation, we can finally start looking at the structure of a plugin for C++, Swift, C#, and Java. What we will do is create a very simple plugin that will simply add two numbers together. This is to keep things simple and allow for the flow of steps for the overall workflow to be much more easy to follow.</p>
<p class="mce-root"/>
<p>There is a list of file types that Unity will automatically recognize as plugins. It is very important that we familiarize ourselves with these file formats:</p>
<ul>
<li><kbd>.dll</kbd></li>
<li><kbd>.winmd</kbd></li>
<li><kbd>.so</kbd></li>
<li><kbd>.JAR</kbd></li>
<li><kbd>.aar</kbd></li>
<li><kbd>.xex</kbd></li>
<li><kbd>.def</kbd></li>
<li><kbd>.suprx</kbd></li>
<li><kbd>.prx</kbd></li>
<li><kbd>.sprx</kbd></li>
<li><kbd>.rpl</kbd></li>
<li><kbd>.cpp</kbd></li>
<li><kbd>.cc</kbd></li>
<li><kbd>.c</kbd></li>
<li><kbd>.h</kbd></li>
<li><kbd>.jslib</kbd></li>
<li><kbd>.jspre</kbd></li>
<li><kbd>.bc</kbd></li>
<li><kbd>.a</kbd></li>
<li><kbd>.m</kbd></li>
<li><kbd>.mm</kbd></li>
<li><kbd>.swift</kbd></li>
<li><kbd>.xib</kbd></li>
</ul>
<p>Then there are also folder types that are treated as single plugins; they are as follows:</p>
<ul>
<li><kbd>.framework</kbd></li>
<li><kbd>.bundle</kbd></li>
<li><kbd><kbd>.plugin</kbd></kbd></li>
</ul>
<p>With native plugins for Unity, you can run into C linkage issues that will cause a phenomenon called <strong>Name Mangling</strong>. Name mangling is also called <em>name decoration,</em> which is essentially a process that gives each function in a program a unique name; this is so that the linkers can separate common names in the language. The issue comes from the fact that there is no standard for this, and they typically don’t work well with C compilers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">C# language plugin</h1>
                
            
            
                
<p>Let’s get started by creating our first plugin with C#:</p>
<ol>
<li>We need to begin by opening Visual Studio and creating a new project. This new project type will be inside the Windows Desktop subfolder of Visual C# and will need to be a Class Library (.NET Framework):</li>
</ol>
<div><img src="img/3d0e6c5b-eeb5-4b97-90f3-0c1d4d3188f5.png"/></div>
<p>Project type</p>
<ol start="2">
<li>The project name will be <kbd>CSharpManagedPlugin</kbd>, and the Framework version will be <kbd>.NET Framework 3.5</kbd>. Select the OK button:</li>
</ol>
<div><img src="img/e8779b8f-379e-45ae-ba88-5d9b4cbb622f.png"/></div>
<p>Project setup</p>
<p>Making sure to change the Framework version to 3.5 is extremely important, as we need to make sure that Unity can utilize our plugin without experimental support.</p>
<ol start="3">
<li>Now that we have created our solution, we can change the class name from <kbd>Class1</kbd> to <kbd>Addition</kbd>. Now, add an integer method called <kbd>addify</kbd> with the parameters of <kbd>a</kbd> and <kbd>b</kbd>, and then return <kbd>a</kbd> plus <kbd>b</kbd>. Your code should look as follows:</li>
</ol>
<pre style="padding-left: 60px">namespace CSharpManagedPlugin<br/>{<br/>    public class Addition<br/>    {<br/>        public int Addify(int a, int b)<br/>        {<br/>            return a + b;<br/>        }<br/>    }<br/>}</pre>
<p>We can now build the solution that will generate the dll file we need. We can now open Unity and see how we can utilize this plugin with Unity:</p>
<ol>
<li>Load Unity, and let’s begin by creating a new project. The project will be of type 3D, and the name I will give it is <kbd>Packtpub</kbd>. I will start by creating two folders; the first one will be called <kbd>Plugins</kbd><em>,</em> and the other will be called <kbd>PluginWrappers</kbd>. This will allow us to keep our project organized:</li>
</ol>
<div><img src="img/8392a826-8df7-46e9-9a41-b37f86176cf1.png"/></div>
<p>Project setup</p>
<ol start="2">
<li>We will start by taking the C# dll file we created and dragging it into the <kbd>Plugins</kbd> folder. I named my dll file <kbd>CSharpManagedPlugin</kbd> to make it a bit easier to differentiate between the different plugins we have at the end:</li>
</ol>
<div><img src="img/43972a9a-fd7a-4f2e-9601-37de0e59e1cd.png" style="width:20.42em;height:14.00em;"/></div>
<p>Plugin added</p>
<ol start="3">
<li>If you click on the <kbd>CSharpManagedPlugin</kbd>, in the inspector, you will see more information:</li>
</ol>
<div><img src="img/36356fdf-ce23-4dcd-870d-53efdbaaef10.png" style="width:22.08em;height:30.42em;"/></div>
<p>Inspector</p>
<ol start="4">
<li>As long as the target version of .NET is the same or lower than that of Unity, you should receive no errors and should be able to use it in the editor, standalone, in WebGL, Linux, Windows, and Mac OS.</li>
<li>What we can do now is move over to our <kbd>PluginWrappers</kbd> folder and get this bad boy up and running.</li>
<li>Create a new script; mine will be called <kbd>CSharpWrapper</kbd>. We can now open the script in Visual Studio:</li>
</ol>
<div><br/>
<img src="img/ee6e760c-e9ac-4fa7-a322-314c89947dd0.png"/><br/>
Script</div>
<ol start="7">
<li>Managed plugins are the easiest, and all we need to do is call our plugin directly, just as if it were a non-monobehavior script. Your code should look as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>public class CSharpWrapper : MonoBehaviour<br/>{<br/>    private void Start()<br/>    {<br/>        var addition = new CSharpManagedPlugin.Addition();<br/>        var add = addition.Addify(5, 2);<br/>        print(add);<br/>    }<br/> }</pre>
<p>As you can see, we called our plugin as if it were just another namespace in the assembly. We can now attach this Unity class to a GameObject, and we will see the results of step 7 appear in the console window of the Unity Editor.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">C++ language plugin</h1>
                
            
            
                
<p>Moving on to C++, we will use Visual Studio once more to create this project:</p>
<ol>
<li>This project type will be in Visual C++ | Windows Desktop | Dynamic-Link Library (DLL):</li>
</ol>
<div><img src="img/3e4de19e-d199-4a64-98b3-b6a522ea0c5b.png" style="width:58.33em;height:40.33em;"/></div>
<ol start="2">
<li>The name of this project will be <kbd>NativeWindowsPlugin</kbd>, and C++ will be slightly different than the managed plugins, due to name mangling, which we will learn how to avoid next.</li>
<li>So, to get around this problem of name mangling, we need to create a header and cpp file. Take a look at this code:</li>
</ol>
<pre style="padding-left: 60px">The header will have the extern c and a preprocessor win32 define along with __declspec, dllexport functions to make sure that name mangling does not occur. Again, we will define our public function of addify, which will be our addition function. Your header should look like this.<br/> <br/> #pragma once<br/>extern "C" {<br/>#if (defined(WIN32) || defined(__WIN32__))<br/>       __declspec(dllexport) int addify(int a, int b);<br/>#else<br/>       int addify(int a, int b);<br/>#endif<br/>}</pre>
<ol start="4">
<li>Essentially, what is happening when we use the <kbd>__declspec, dllexport</kbd> call is that we are avoiding the usage of a <kbd>.def</kbd> file.</li>
<li>Now that our header has been created, we need to fill out the information in our cpp file.</li>
<li>Make sure to include the header for the native windows plugin, and fill out the function details of <kbd>addify</kbd> here. Your code should look as follows:</li>
</ol>
<pre style="padding-left: 60px">#include "stdafx.h"<br/>#include "NativeWindowsPlugin.h"<br/>int addify(int a, int b)<br/>{<br/>       return a + b;<br/>}</pre>
<ol start="7">
<li>Click on Build Solution<em>,</em> and we will be ready to jump into Unity.</li>
</ol>
<p>Load Unity, and let’s open our <kbd>Packtpub</kbd> project:</p>
<ol>
<li>Like we did previously, we will be using our <kbd>Plugins</kbd> and <kbd>PluginWrappers</kbd> folders for keeping things organized. Copy the <kbd>CPlusPlusPlugin</kbd> into the <kbd>Plugins</kbd> folder:</li>
</ol>
<div><img src="img/42a685f6-75bd-4e2c-b74b-b37048bfb1d1.png" style="width:33.00em;height:15.00em;"/></div>
<p>Folder structure</p>
<p>If you take a look at the plugin in the inspector, you will notice that it is only available for Windows. That is because we only had our if directive set for Windows and no other operating system. This is something you should keep in mind when wanting to work with multiple operating systems with C++.</p>
<ol start="2">
<li>Now, we can create a new C# class in the <kbd>PluginWrappers</kbd> folder called <kbd>CPlusPlusWrapper</kbd>:</li>
</ol>
<div><img src="img/4983c9bb-ad1a-4789-996d-58249dba21e5.png" style="width:23.83em;height:14.58em;"/></div>
<p>CPlusPlusWrapper</p>
<ol start="3">
<li>The code here will be different than what we used for the native plugin. We will need to import the dll file using a very special attribute called <kbd>DllImport</kbd>. This attribute requires the string name of the plugin we used and then underneath the attribute, we need to make sure it is a <strong>Public Static Extern Method</strong>.</li>
<li>Public static extern method types designate that the method call we want to use will be static, public, and loaded from an external assembly. To use the DLL Import attribute, we need to use the System.Runtime.InteropServices namespace. Your code should look as follows:</li>
</ol>
<pre style="padding-left: 60px">using System.Runtime.InteropServices;<br/>using UnityEngine;<br/>public class CPlusPlusWrapper : MonoBehaviour {<br/>    [DllImport("CPlusPlusUnManagedPlugin")]<br/>    public static extern int Addify(int a, int b);<br/>    private void Start()<br/>    {<br/>        var add = Addify(2, 4);<br/>        print(add);<br/>}<br/> }</pre>
<p>After we do that, the call is essentially the same from there on out. It is a little bit different, and a little more involved, but, overall, it is very easy once you understand how it works. You can now attach this C# script to a GameObject and run it to test the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Swift language plugin</h1>
                
            
            
                
<p><strong>Swift Language Plugins</strong> have the extension of .swift and have a completely different structure than C#, Java, and C++, which is to be expected, as Swift is only available on macOS devices. The language itself has elements from a variety of sources, and while I will not go into greater details of the finer points of the language, I will say that I like the methodologies they incorporated into the language structure.</p>
<p>Swift and Objective-C require the usage of Xcode, and while the basic setup is very similar, there are some key differences. Swift plugins require you to utilize both Objective-C and Swift to create a plugin that boils down to the implementation in Swift and you call that Swift code in Objective-C. This exceeds the parameters of this section, as the nuances of both languages need to be explored further.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Objective-C language plugin</h1>
                
            
            
                
<p>Objective-C plugins are similar in some ways to Swift plugins and many of the basic steps are the same. Objective-C has been around for quite a long time and was Apple's version of the C language family. While Swift has been designed to be Objective-C's successor, Apple has not depreciated the language and is still a powerful tool to use and know:</p>
<ol>
<li>To start, open Xcode, and get ready to have some fun:</li>
</ol>
<div><img src="img/02cf291a-2b58-4b98-b851-abbf323b0d58.png" style="width:28.67em;height:26.75em;"/></div>
<ol start="2">
<li>Click on Create a new Xcode project and we'll have a big list of items to choose from.</li>
<li>Go over to macOS and select Library.</li>
</ol>
<p>Although the Library is not available with iOS projects, you can also go with Bundle or Cocoa Framework Library types as well for this.</p>
<ol start="4">
<li>Select Library and click Next:</li>
</ol>
<div><img src="img/cdfc05e8-8ae9-422f-bed8-e43e2bb8fe4e.png" style="width:46.50em;height:33.00em;"/></div>
<ol start="5">
<li>Set the product name to <kbd>ObjectiveCPlugin</kbd>; this keeps us in line with how the projects have been developed thus far:</li>
</ol>
<div><img src="img/f9bf4e6a-1cc1-4df3-898d-cc0a7d5c57a2.png" style="width:48.75em;height:34.17em;"/></div>
<ol start="6">
<li>Now, before we continue, let's look at the various Frameworks that are available for us in the drop-down menu:</li>
</ol>
<div><img src="img/8629d8ad-3026-4712-a912-90dff864ff40.png" style="width:26.25em;height:5.58em;"/></div>
<p>We have Cocoa, STL, and None. Cocoa gives us what we need for Objective C and Swift, <strong>STL</strong> is the <strong>Standard Template Library</strong> for C++, and None is a blank C++ and C project, with no Standard Libraries attached to it. We will stick with Cocoa.</p>
<p>Next, we should take a look at what is available to us with Type:</p>
<div><img src="img/819fa5cb-25f7-42a4-b1f2-3df4cf0d13ff.png" style="width:26.50em;height:5.50em;"/></div>
<p>Type gives us the choice between Dynamic and Static, which would be a <strong>Dynamic Library</strong> or a <strong>Static Library</strong>. A static library is a library that is resolved at compile time and copied into a target application that produces an object file and an executable. A dynamic library is the opposite. It is resolved at runtime and only produces the header and source file that can be called in another application or program. We will stick with dynamic here:</p>
<div><img src="img/658e962e-05f8-46be-abc2-dd556684fd2e.png" style="width:15.75em;height:9.58em;"/></div>
<ol>
<li>Our base Library file has a <kbd>.h</kbd> and <kbd>.m</kbd> file already created for us, so all we have to do is fill in the code that is needed. Let's go ahead and fill in the header file. Look at this code:</li>
</ol>
<pre style="padding-left: 60px">#import &lt;Foundation/Foundation.h&gt;<br/>@interface ObjectiveCPlugin : NSObject<br/>int Addition(int a, int b);<br/>@end</pre>
<ol start="2">
<li>Right away, we can see that it looks very similar to C++, with the slight difference of syntax. Next up, let's take a look at the <kbd>.m</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#import "ObjectiveCPlugin.h"<br/>@implementation ObjectiveCPlugin<br/>int Addition(int a, int b)<br/>{<br/> return a + b;<br/>}<br/>@end</pre>
<ol start="3">
<li>And, again, it's pretty much the same as C++, where we just fill in what the method actually does. We can now build the project and get ready to import it into Unity:</li>
</ol>
<div><img src="img/6f427f6e-f87c-4f8b-863a-c1b534d2e344.png" style="width:10.42em;height:17.58em;"/></div>
<ol start="4">
<li>Now, we can open Unity after the project has been built and get ready for the fun part. Inside the <kbd>Plugins</kbd> folder that we previously created, create a new folder called <kbd>iOS</kbd>:</li>
</ol>
<div><img src="img/48f0b748-900e-4ff9-a52e-d363d170ff1f.png" style="width:27.67em;height:11.33em;"/></div>
<ol start="5">
<li>Inside the <kbd>iOS</kbd> folder, copy the <kbd>.h</kbd> and <kbd>.m</kbd> files that were created:</li>
</ol>
<div><img src="img/4855414b-c518-409b-9d80-ceccecf3b430.png" style="width:21.50em;height:16.42em;"/></div>
<ol start="6">
<li>Now, go over to the <kbd>PluginWrappers</kbd> folder and create a new script called <kbd>ObjectiveCWrapper</kbd>:</li>
</ol>
<div><img src="img/fb37579b-135c-4c58-9cad-1bd1b4e5a0c3.png" style="width:32.08em;height:14.75em;"/></div>
<ol start="7">
<li>We can now open the class in C# and add our code:</li>
</ol>
<pre style="padding-left: 60px">using System.Collections;<br/>using System.Collections.Generic;<br/>using System.Runtime.InteropServices;<br/>using UnityEngine;<br/>using UnityEngine.UI;<br/>public class ObjectiveCWrapper : MonoBehaviour<br/>{<br/> private Text text;<br/>#if UNITY_IOS &amp;&amp; !UNITYEDITOR</pre>
<pre style="padding-left: 60px"><br/> [DllImport("__Internal")]<br/> public static extern int Addition(int a, int b);<br/>#else <br/> [DllImport("ObjectiveCPlugin")]<br/> public static extern int Addition(int a, int b);<br/> #endif<br/>private void Start()<br/> {<br/> text = GetComponent&lt;Text&gt;();<br/> text.text = Addition(1,5).ToString();<br/> }<br/>}</pre>
<p>The nice thing about Objective-C is that it does not have the name mangling issues that C++ has, so we don't need to worry about doing the <kbd>extern</kbd> method before. Instead, due to the way code is compiled for iOS devices, we have to call <kbd>__internal</kbd>, instead of the name of the plugin.</p>
<p>To finish, we would have to build this for iOS and open it in Xcode to finish the compile process and either run it on an iPhone or the iPhone Simulator to test the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java language plugin</h1>
                
            
            
                
<p>For the Java language plugin, we have two choices that work just fine. We have the Java Library, which compiles to a JAR file, and the Android Library, which compiles to AAR format. To access Android-specific functions, we need to create the Android Library, and for pure Java language usage, we would create the Java library.</p>
<p>There is a major distinction between the two, and this should be discussed. Consider the following:</p>
<ul>
<li>Android Library projects contain native and Java code along with resource files and an Android Manifest. They will include the <kbd>.class</kbd> files and <kbd>.jar</kbd> files that need to be precompiled into the Android Studio project, before being imported into Unity.</li>
<li>Java Library projects are built directly to be JAR files, and they can be imported into Unity.</li>
</ul>
<p>Both of these plugins need to be run on an Android device; this means you cannot test them in the editor; you must build and run on an emulator or on an actual device. If you want to get the best from plugins, using the Java Language. Android Library projects offer the most bang for your buck.</p>
<p>With that being said, let’s open Android Studio and create our basic library:</p>
<ol>
<li>Click on File, highlight New, and locate New Module. The Module options window will open in a new window:</li>
</ol>
<div><img src="img/03dda026-b9fa-43d8-b119-3674436d52b6.png"/></div>
<p>Android Studio</p>
<ol start="2">
<li>Here, we have the option of selecting a Java Library or Android Library. As discussed previously, it is much more advantageous to use the Android Library, so select that one and click Next:</li>
</ol>
<div><img src="img/96588a2f-a48a-44b1-b671-aca0e05ea9c3.png" style="width:51.75em;height:54.17em;"/></div>
<p>Library choices</p>
<ol start="3">
<li>Now, we can name and configure our module. I will set the library name to be <kbd>AndroidLibrary</kbd>; the module name will automatically be made to be the name of the library in lowercase.</li>
<li>The package name will be changed to <kbd>com.packtpub.Androidlibrary</kbd>, and the Minimum SDK version will be <kbd>API 21: Android 5.0 (Lolipop)</kbd>:</li>
</ol>
<div><img src="img/9c04678d-5647-4b02-870c-a00d50d17d11.png" style="width:58.00em;height:42.25em;"/></div>
<p>Module setup</p>
<ol start="5">
<li>Once that has been set up, click Finish.</li>
<li>On the left-hand side of the Android Studio Editor, we can see the layout of the project:</li>
</ol>
<div><img src="img/fe0571f2-5362-4b6d-bfd4-b15ef6710f20.png" style="width:30.42em;height:35.92em;"/></div>
<p>Layout</p>
<ol start="7">
<li>The main area we want to focus on is the <kbd>java</kbd> folder with the name of <kbd>com.packtpub.Androidlibrary</kbd>. We need to right-click on this specific one and add a new Java class to it. This will open a brand-new window to set up the class:</li>
</ol>
<div><img src="img/a388bc86-6e29-444e-b764-b0e52068f1c1.png" style="width:70.42em;height:39.08em;"/></div>
<p>New class</p>
<ol start="8">
<li>I will name the class <kbd>Additions</kbd> to specify that we are just making a simple math library and then select the OK button.</li>
<li>The procedure is the same for C#: we will just add a public <kbd>int</kbd> with the name of <kbd>AddMe</kbd> with the parameters of <kbd>int a</kbd> and <kbd>int b</kbd>, with the return being <kbd>a + b</kbd>. Your code should look as follows:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.Androidlibrary;<br/>public class Additions {<br/>    public int AddMe(int a, int b)<br/>    {<br/>        return a + b;<br/>    }<br/>}</pre>
<ol start="10">
<li>Click on the Build button at the top of the editor window, and click on Make Project. This will build the project for us.</li>
<li>Let’s take a quick look at the output folder of the project:</li>
</ol>
<div><img src="img/51ffa1e3-1328-44f0-bd68-eecfac0893a8.png" style="width:40.67em;height:24.25em;"/></div>
<p>Building the project folder</p>
<p>We can see here that we have quite a few folders and other miscellaneous files. The AAR file we need is located in the <kbd>AndroidLibrary</kbd> folder. The exact location would be Android library, Build, Outputs, AAR.</p>
<p>The AAR file is technically a zip file, so you can unzip and look at its contents by using "7zip"; however, this is the exact file we need to use in Unity. Now, it is time to open Unity and see how we can get Unity to interact with this file.</p>
<p>Load up Unity, and let’s open our <kbd>Packtpub</kbd> project:</p>
<ol>
<li>Like we did previously, we will be using our <kbd>Plugins</kbd> and <kbd>PluginWrappers</kbd> folders for keeping things organized. Copy the AAR file into the <kbd>Plugins</kbd> folder:</li>
</ol>
<div><img src="img/ea9c9eb2-8d3c-41f2-8db2-2e896f677935.png" style="width:30.50em;height:15.67em;"/></div>
<p>Plugins folder</p>
<ol start="2">
<li>In the <kbd>PluginWrappers</kbd> folder, create a C# class called <kbd>JavaWrapper</kbd>, and then open it in Visual Studio.</li>
<li>The code is slightly different than the C# and other native implementations. We will need a preprocessor directive to check whether this code is being executed in Android.</li>
<li>Then, we will create a new Android Java Object with the string name of the class we created in Java.</li>
<li>We will follow that up with a call of that class with the string value of the method we want, followed by the parameters. Your code should look as follows:</li>
</ol>
<pre style="padding-left: 60px">using System.Collections;<br/>using System.Collections.Generic;<br/>using UnityEngine;<br/>public class JavaWrapper : MonoBehaviour<br/>{<br/>       // Use this for initialization<br/>       void Start () {<br/>#if UNITY_Android &amp;&amp; !UNITY_EDITOR<br/>        var javaClass = new AndroidJavaObject("Addition");<br/>        javaClass.Call("Addification", 2, 9);<br/>#endif<br/>}<br/> }</pre>
<p>Now, we can’t test this code in the Unity Editor, but we can build the project out and test it on an Android device, after attaching it to a game object to run.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a sensor driver in Java</h1>
                
            
            
                
<p>Now, what if we wanted to implement our own sensor from the hardware provided? As it turns out, Google has already thought of that and has a very in-depth tutorial on creating and registering your own driver which can be viewed at <a href="https://developer.android.com/things/sdk/drivers/location">https://developer.Android.com/things/sdk/drivers/location</a>. I will go over a few of the items specified, but it is best to read what they wrote.<br/>
<br/>
In short, we will just look at the sample code provided that will make it so that we can convert GPS data as a plugin. The basic structure is exactly the same as the one we used to create our basic plugin in Java. The next step will be to write our code so that it returns the data so that it can be passed from the native plugin to Unity. Take a look at this:</p>
<pre>// Convert latitude from DMS to decimal format<br/>private float parseLatitude(String latString, String hemisphere) {<br/> float lat = Float.parseFloat(latString.substring(2))/60.0f;<br/> lat += Float.parseFloat(latString.substring(0, 2));<br/> if (hemisphere.contains("S")) {<br/> lat *= -1;<br/> }<br/> return lat;<br/>}</pre>
<pre class="mce-root">// Convert longitude from DMS to decimal format<br/>private float parseLongitude(String longString, String hemisphere) {<br/> float lat = Float.parseFloat(longString.substring(3))/60.0f;<br/> lat += Float.parseFloat(longString.substring(0, 3));<br/> if (hemisphere.contains("W")) {<br/> lat *= -1;<br/> }<br/> return lat;<br/>}</pre>
<pre class="mce-root">// Return a location from an NMEA GPRMC string<br/>public Location parseLocationFromString(String rawData) {<br/> // Tokenize the string input<br/> String[] nmea = rawData.split(",");</pre>
<pre class="mce-root">Location result = new Location(LocationManager.GPS_PROVIDER);<br/> // Create timestamp from the date + time tokens<br/> SimpleDateFormat format = new SimpleDateFormat("ddMMyyhhmmss.ss");<br/> format.setTimeZone(TimeZone.getTimeZone("UTC"));<br/> try {<br/> Date date = format.parse(nmea[9] + nmea[1]);<br/> result.setTime(date.getTime());<br/> } catch (ParseException e) {<br/> return null;<br/> }</pre>
<pre class="mce-root">// Parse the fix information tokens<br/> result.setLatitude(parseLatitude(nmea[3], nmea[4]));<br/> result.setLongitude(parseLongitude(nmea[5], nmea[6]));<br/> result.setSpeed(Float.parseFloat(nmea[7]));</pre>
<pre class="mce-root">return result;<br/>}</pre>
<p>Now, all you need to do is compile the plugin as specified in the previous section and add it to Unity in exactly the same way. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have discussed various sensors that are generally available to us from mobile market devices. We have discussed how to create a basic plugin in the major languages for the different platforms at our disposal, and we now have all of the basic knowledge we need to get started making AR applications and games with Unity. <br/>
<br/>
In the next chapter, we will take what we have learned so far and create a prototype project that will allow us to incorporate sound as the basis for an AR application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Have a go hero</h1>
                
            
            
                
<p>Before continuing to the next chapter, I would suggest taking the time to read some of the references I have provided in the further reading section that will give you insights on how to access various sensors for Android and Apple devices.</p>
<p>This will be extremely instrumental in you being able to solve the coding challenges presented in the following:</p>
<ul>
<li>Create a simple C++ plugin that works with Linux, Windows, and Mac desktop environments</li>
<li>Create a plugin in Java that will allow the device to actively read the temperature for 10 seconds and display it on your device's screen</li>
<li>Create a C# plugin that can access your web camera on your laptop, and send that information to the Unity Editor</li>
</ul>
<p>The following set of challenges are for those that have access to a Mac computer (if you don't, you can modify these to be for Windows or Android):</p>
<ul>
<li>Create a Swift plugin that will read a finger press on the screen and log the exact location of the finger press either via text or via display colors on the screen</li>
<li>Create an Objective-C plugin that takes the information from the camera sensor and logs it in a text file in binary format</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Unity is able to utilize plugins from C++:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="2">
<li>You create your own implementations for handling sensors to inject into Unity via plugins:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="3">
<li> You can use ARKit to create an Objective-C plugin for Unity:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="4">
<li>You can build Java plugins to be used with Unity that are targeted at iOS devices:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="5">
<li>Swift plugins are easier to develop than Objective-C plugins for Unity:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="6">
<li>The Fingerprint sensor is only available on Android devices:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="7">
<li>A camera is technically a sensor:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="8">
<li>A gyroscope is used all the time in iOS and Android devices:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="9">
<li>A thermometer sensor is used to keep track of and measure the temperature of sensitive components:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>
<ol start="10">
<li>An accelerometer is not a sensor designed to detect the momentum of the device:</li>
</ol>
<p style="padding-left: 90px">A.) True<br/>
B.) False</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>The official documentation is always the best place to learn more about the sensors. Check out the following link for more information:</p>
<ul>
<li><a href="https://developer.android.com/guide/topics/sensors/sensors_overview">https://developer.Android.com/guide/topics/sensors/sensors_overview</a></li>
<li><a href="https://developer.apple.com/documentation/coremotion">https://developer.apple.com/documentation/coremotion</a></li>
<li><a href="https://developer.apple.com/documentation/coremotion/cmsensorrecorder">https://developer.apple.com/documentation/coremotion/cmsensorrecorder</a></li>
</ul>


            

            
        
    </body></html>