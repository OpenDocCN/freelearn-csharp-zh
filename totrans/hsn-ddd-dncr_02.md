# 语言与语境

在上一章中，我们简要讨论了语言的重要性。在软件行业中，我们形成了这样的天真观念：只有编程语言才是重要的。这就是为什么我们经常说一些完全不知所云的话，而来自其他部门的同事或我们的客户很难理解我们试图表达的意思。这个问题是相互的，因为许多业务部门都发展了自己的行话，其他人可能不完全理解。

在本章中，我们将深入探讨语言的重要性，并分析几个原型和代码的示例。我们还将探讨语言在特定环境中的概念，并介绍**领域驱动设计**（**DDD**）中最关键的部分之一：通用语言。

在本章中，我们将深入探讨以下主题：

+   通用语言

+   为什么语言很重要

+   将隐含的变为显性的

+   上下文中的语言

+   表达行为

# 通用语言

埃里克·埃文斯的网站（他是原始 DDD 书籍的作者）位于[`domainlanguage.com`](http://domainlanguage.com)。DDD 的基本概念，如通用语言和边界上下文，都是基于语言的理念。对于那些没有多年软件开发经验的人来说，这听起来可能有些奇怪，因为对于经验不足的开发者来说，唯一重要的语言是编程语言。我们通常通过学习一些概念并将它们应用于使用一种编程语言的实践中来学习编程。我们认为我们可以将人类语言翻译成编程语言，这是我们工作的本质。确实，这里有一些真理。然而，这远非开发者日常工作的本质部分。

只有当两个人能够使用同一种语言进行交流时，他们才能相互理解。这不一定需要是口头语言；它也可能是手语或音乐语言。但双方交流者必须共享对这种通用语言的相同理解。否则，就会出现问题。他们不仅需要说同一种语言，而且这种语言必须处于一个特定的语境中。有一本名为《美国和英国英语：被共同语言分隔？》的书，作者是保罗·贝克，书中描述了同一语言在经过足够长时间的海洋分隔后变得多么不同。

在本节中，我们将更深入地探讨语言的重要性以及这些概念在成功软件项目中至关重要的语境。

# 领域语言

几乎每个行业都发展了一种只有该行业的人才能完全理解的语言。其中一些词汇已经传播到世界各地，比如汽车行业，它用术语如变速箱、点火、内燃机和甚至车身修理店丰富了我们的语言。最后一个术语在领域之外看时是模糊的。但一旦指定了领域，它就变得清晰了，我们不是指美容产品精品店，也不是指软件外包公司，而是一个在事故后对车身进行修理的地方。

当然，汽车行业在这个意义上并不是独一无二的。其他行业也发展了自己的术语，并且它们的语言可能对外行人来说更为陌生和晦涩。

这样的行业例子之一当然是软件行业。当两个程序员讨论一些相对复杂的系统的实现细节时，周围的非程序员对这次对话的理解很少，通常都会感到无聊。缺乏理解总是导致缺乏兴趣：

![](img/5486bbce-882b-4615-b491-8138cd1743d5.png)

程序员眼中的世界（基于 Manu Cornet 的原始作品）

在某种程度上，软件行业是独特的，因为它倾向于为其他行业中的各种商业问题提供服务。今天几乎每件事都需要或希望有一定程度的自动化，这意味着软件。这也意味着来自商业领域的人会找到他们的开发者或外部软件公司，并试图用他们的语言表达他们的问题。当这种语言没有被正确理解时，问题就会出现。

由既不是商业人士也不是软件开发者专门撰写的功能需求，曾经被视为成功软件的圣杯。每次软件交付给不满意的客户后，我们都会归咎于需求。我们说——下次，我们会写出更好的需求，更详细的规范，并解释开发者需要做到的每一个细节。当每个人都互相指责，没有人愿意承担责任时，这很快就会变成一场指责游戏。

除了我们在第一章中讨论的点，*为什么是领域驱动设计？*（在*需求出了什么问题？*部分），还有一个额外的方面值得在此提及。那就是语言。需求不仅关注解决方案并隐藏问题，而且需求还倾向于将商业语言翻译成更技术性的语言，这被视为**开发者友好**。实际上，这更像是一个断线电话。在传输线上添加的翻译层级越多，到达接收者的相关信息就越少，而且信息在传递过程中被严重干扰，以至于无法辨认。

这种“翻译”的另一个方面是它减缓了沟通。如果开发者需要从业务中获得更多信息，但无法理解业务人士说话时的含义，那么翻译者的介入变得不可避免。通常，这些人就是编写需求的人，但并不总是如此。我听到过足够多的例子，只有像企业架构师这样的人才被允许与客户交谈；然后，他们将他们的理解翻译成业务分析，然后把这些需求扔给可怜的开发者，而这些需求在翻译过程中实际上已经丢失了。

正因如此，对于致力于为真实商业问题创造良好解决方案的人来说，理解业务非常重要。能够理解业务并且无需翻译和翻译者进行沟通不仅缩短了沟通时间，而且极大地提高了沟通质量。

同时，我们都知道，作为我们创建的系统客户的商业人士，他们通常比我们希望的要少得多可用。你可能会只有几次与真正掌握你必须获取以使系统按预期工作的重要信息的会议。有时他们甚至不愿意与开发者进行讨论。这可能与某些个人问题、过去的负面经历或无意识地害怕在众多技术宅面前显得愚蠢有关。

在这种情况下，有一个受业务信任并且能说他们语言的人是非常有帮助的。我们的目标是要确保这个人也受到开发团队的信任。你可以称这个角色为业务分析师或产品所有者，这并不重要。我所知道在这个角色中做得最好的人能够用他们的语言与所有人交谈，就像那些在幕后与世界领导人一起工作的顶级翻译者一样，能够将一种语言翻译成另一种语言而不丢失事物的含义。同时，最好的方法仍然是完全避免这种翻译。

例如，伦敦市银行家因雇佣那些已经接触过银行业并且理想情况下在伦敦市工作过的发展者而闻名。他们重视时间，希望缩短沟通和讨论所花费的时间。因此，那些了解他们的语言并且对他们的业务和语言有相当理解的人比那些可能更优秀但需要在开始实际工作前接受培训和了解语言的人更受重视。

行业术语通常对外行人来说很难理解，因为所使用的词汇通常是日常用语，但它们有着完全不同的含义。以下是一些来自上述金融领域的例子：

+   **看涨期权**：简称**看涨期权**，这是对借出或未偿还资本支付的要求

+   **安全**：为了证明信用、财产权或与可交易衍生品相关的股票或债券的所有权，此证书被使用

+   **掉期**：在两个借款人之间，如果他们中的每一个都能获得所需的资金，或者固定利率被改为浮动利率，这被视为掉期

学习领域语言对于在领域专家和开发者之间建立有效的沟通至关重要。

# 样例应用领域

在整本书中，我们将开发一个样例应用来练习我们获得的知识和技能。在本节中，你将了解业务领域，更多细节将在本书的后续部分添加。

我们将要工作的领域是为个人在线销售物品。我们将构建一个发布分类广告的应用程序以及可能支持此类活动所需的一些东西。

如果你对术语不熟悉，想想你储藏室或地下室里的一堆东西，你可能会很高兴把它们清理掉。你可以在网上发布一个小广告，其他人可能会购买你不再需要的东西。你也可以免费赠送物品。这类服务的例子包括 eBay、Craigslist、Gumtree、Marktplaats（荷兰）和 FINN.no（挪威）等网站。

# 将隐含的显式化

当我们开始开发一个新系统时，我们需要学习很多东西。我们在第一章，“为什么是领域驱动设计？”中讨论了无知悖论，你可能还记得，无知程度最高、知识水平最低的时候是我们对未来的系统做出很多决策的时候。

我们不仅缺乏对我们试图解决问题的业务领域的知识，我们还被迫在一个高度不确定的环境中工作。在我们学习领域语言之前，我们使用我们的理解，这通常基于假设。

想象一下，在项目开始时，你与领域专家开会的情况。他们试图解释他们的问题，而你开始慢慢地学习他们的语言，在某个时刻，你认为你理解了这个想法，大致知道该怎么做。在这里，重要的是要记住我们在上一章讨论认知偏差及其对决策影响时所经历的情况。第一个也是最明显的风险是**你所看到的即是全部**（WYSIATI），或者说是可用性启发式。你将你有限的知识应用于过去的经验，然后产生理解的感觉。在这个时候，我们通常会被要求做出估计，从逻辑上讲，我们会失败，因为偏见在我们的脑海中玩弄了我们，并给了我们理解的错觉。

在这样的会议上，我们经常达成一致。然后，每个人都离开房间再次开会，可能几周后讨论一些规范或甚至原型。时间过去了，我们还在同一个房间里，没有人满意，因为我们共同的不满，我们发现我们达成了一致，但完全不同的事情。每个人都有一幅图，而这些图都是不同的。

![](img/da7b2f76-711c-4ca2-a43d-6e035e46b02e.jpg)

如果我们不可视化，我们就会就不同的事情达成一致

人们花费数小时争论他们认为不同但实际上相同的事情。人们也会就他们没有共同理解的事情达成一致，这从来都不会顺利。

为了解决这个问题，我们需要去除假设。我们需要将*隐含*的东西*明确*出来。

看一下这个来自现实生活中的 HR 管理系统的样本表格。在这里，员工可以申请病假：

![](img/6ab13797-43ea-4757-af5b-b75123d1362b.png)

病假登记表

在这里，我们可以看到由程序员创建的典型结构。我们甚至可以想象一个 SQL 表，其中存储了输入到这个表格中的数据。它很可能有`StartDate`、`EndDate`和`HalfDay`列以及员工的`id`。注意，这里也有一个保存按钮，这在类似这样的表格中非常常见。

尽管这个表格看起来可能没问题，但让我们再稍微思考一下我们在这里看到的东西。在花了一些时间分析这个表格之后，我们可以看到以下问题：

+   开始日期是不明确的。它可能是登记病假的日子，也可能是员工因为生病而没有上班的那天。

+   结束日期甚至更加不明确，因为它可能代表病假的最后一天，也可能是员工回来上班的那天。

+   半天可能适用于这两个领域，但没有明确的说明它意味着什么。

+   最后，保存按钮没有给我们任何关于接下来会发生什么的线索。可能只是在表中记录了一条记录，我们需要告诉某人查看它，或者可能有一个自动启动的审批流程。填写完这个表格后，员工需要打电话或发送电子邮件给直线经理吗？

正如你所见，即使在这样一个只有两个字段、一个复选框和两个按钮的小表格中，也有很多隐含的东西。如果我们想象一下这个表格背后的代码，所有那些隐含和模糊的概念也都会在那里被发现。我已经提到了一个表格，它有代表表格中那些字段的列。在领域模型类、数据模型对象和其他代码工件中的所有属性都是同样隐含的。那里的一切都需要解释，比如 *这个日期意味着员工回来上班的那一天*，如果没有这样的解释，像报告这样的东西可能会完全错误。

将它与另一个例子进行比较，这个例子也来自现实生活中的 HR 管理系统，由一个竞争对手制作：

![图片](img/8dfa5910-680a-4721-a05f-101c827b3ffa.png)

那个有意义的病假登记表

在这个表格中，对于不需要解决谜题或阅读帮助来理解这些字段应输入什么内容的普通人来说，字段的意义更加明确。在第一个示例中是隐含的，在这里则是显式的。从命名单个字段到行动呼吁，每一项都有更好的意义。我们也可以想象，在这个表格背后，我们可以找到如下代码：

```cs
SickLeaveApplication.Handle(new SendSickLeaveForApproval
{
    EmployeeId = context.User.EmployeeId,
    DateRegistered = request.DateRegistered,
    FirstDayNotAtWork = request.FirstDayNotAtWork,
    LeftDuringWorkday = request.LeftDuringWorkday,
    CameBackToWork = request.CameBackToWork,
    CameBackAfterLunch = request.CameBackAfterLunch
});
```

这段代码表达了与用户界面相同的含义和术语。因此，不仅最终用户填写这个表格会很容易，而且其他开发者也会很高兴阅读这段代码，因为意图表达得非常清楚，所有概念都是显式的。

将隐含的变为显性的另一个方面是创建在代码中可见的领域概念。在前面的代码中，`SendSickLeaveForApproval`命令在代码中展示了精确的领域概念。

# 分类广告的领域语言

我们的开发者在讨论发布分类广告的流程。他们经历了创建过程，并到达用户点击“发布”按钮的点。与领域专家一起，他们发现广告不能立即发布，因为广告可能包含恶意内容。他们决定添加一个审批流程，这个流程应该在用户点击“发布”并且广告在网站上可见之后进行。

开发者迅速决定为他们的领域类`ClassifiedAd`创建一个名为`Status`的属性。它应该是一个枚举类型，表示审查和发布过程的各个阶段。它也可以在以后用于尚未知的其他状态。由于他们希望在领域模型中拥有行为，所以他们向类中添加了`UpdateStatus`方法，其代码如下：

```cs
public class ClassifiedAd
{
    private ClassifiedAdStatus _status;

    public void UpdateStatus(ClassifiedAdStatus newStatus)
    {
        _status = newStatus;
        DomainEvents.Publish(
            new ClassifiedAdStatusUpdated(_id, newStatus));
    }
}
```

现在这个方法也发布了一个领域事件，系统的其他部分可以订阅这个事件并执行一些其他重要的操作。

我们将在本书的后面部分花更多的时间讨论领域事件和命令。目前，示例代码使用领域事件在代码中紧密地模拟我们在事件风暴章节中使用的事件和命令。

因此，在用户点击“发布”后，以下情况会发生：

```cs
ad.UpdateStatus(ClassifiedAdStatus.Published);
```

审查完成后，广告将被激活，如下所示：

```cs
ad.UpdateStatus(ClassifiedAdStatus.Activated);
```

这可能看起来是可以接受的。我们的`ClassifiedAd`类是一个状态机，这个类的实例在广告的生命周期中从一个状态移动到另一个状态。然而，我们已经失去了意图。我们的语言变得奇怪——我们不是说要*发布*公告，而是*更新状态*。我们不是*激活*广告，而是再次*更新状态*！

即使在系统添加更多行为之后一切似乎都正常工作，这样的代码也将开始出现：

```cs
public void UpdateStatus(ClassifiedAdStatus newStatus)
{
    if (newStatus == ClassifiedAdStatus.Published
        && (string.IsNullOrEmpty(_title)
            || _price == 0 || string.IsNullOrEmpty(_text))
        throw new DomainException(
            "Ad can't be activated because some mandatory fields are empty");

    if (newStatus == ClassifiedAdStatus.Activated 
        && _status == ClassifiedAdStatus.ViolationReported)
        throw new DomainException("Reported ads can't be activated");

    if (newStatus == ClassifiedAdStatus.Deactivated
        && _status != ClassifiedAdStatus.ViolationReported)
        throw new DomainException("Only a reported ad can be deactivated");

    _status = newStatus;
    DomainEvents.Publish(new AdStatusUpdated(newStatus));
}
```

这并不是我们期望在这样一个简单方法中看到的代码。它承担了太多的责任，而这个方法中的逻辑块几乎相互之间没有关联。但当涉及到领域事件处理时，情况变得更糟：

```cs
public void Handle(ClassifiedAdStatusUpdated @event)
{
    // controlling the ad visibility based on it's reported status
    if (_status == ClassifiedAdStatus.ViolationReported
        && @event.Status == ClassifiedAdStatus.MaliciousContentDetected)
        CommandDispatcher.Send(
            new UpdateAdVisibility(@event.Id, false));
}
```

流程控制操作符的数量正在增加，现在大部分行为都是由状态更新驱动的，最初这被认为是对领域对象单个属性进行的小而简洁的操作。这个更新操作的意图已经消失，每次调用都需要仔细控制副作用。在添加新功能时，损害现有行为的风险现在是真实的。

与领域专家的讨论也失去了一些意义。不再是使用诸如“如果检测到恶意内容，我们隐藏广告并通知我们的审核小组”这样的短语，而是变成了“然后我们查询所有状态等于`MaliciousContentDetected`的广告，并使用通知服务向所有拥有审核权限的用户发送消息”。语言的含义在技术术语的混乱中丢失，混合了诸如**状态**和**消息**这样的通用词汇。

团队决定重构代码，并使用适当的领域语言。因此，这是他们提出的方案：

```cs
public class ClassifiedAd
{
    private ClassifiedAdStatus _status;

    public void Publish()
    {
        _status = ClassifiedAdStatus.Published;
        DomainEvents.Publish(new ClassifiedAdPublished(_id));
    }
}
```

现在，我们也可以将领域事件处理重构为如下所示：

```cs
public void Handle(ClassifiedAdPublished @event) =>
    CommandDispatcher.Send(new ShowClassifiedAd(@event.Id));
```

然后，为了处理包含恶意内容的情况，我们可以编写新的事件处理器：

```cs
public void ReportViolation(User reportedBy, string reason)
{
    _violationReports.Add(reportedBy, reason);
    DomainEvents.Publish(new ViolationReported(reportedBy, reason));
}

public void Handle(ViolationReported @even) =>
    CommandDispatcher.Send(new InformModerators(@event.Id, @event.Reason));

public void Handle(MalicionsAdDetected @event) =>
    CommandDispatcher.Send(new InformModerators(@event.Id, @event.Reason));
```

我们的小例子也表明，领域语言不能仅仅通过制作一个名词列表的词汇表来构建。关于收集大量名词并称之为领域语言的误解确实存在。但这并不是一条幸福的路径，通常它会导致所谓的贫血模型，这被认为是一种反模式。贫血模型中的类只有属性，属性总是用名词命名。但每个领域的一个重要部分是行为。名词表达领域操作的内容，但动词描述正在执行的动作。没有动词，我们的领域在属性值改变时往往变成了一组没有特定原因的魔法动作。但我们的前述代码通过引入动词作为领域语言的一部分，清楚地表达了领域行为。这些动词是精确的，显示了意图，并描述了动作。它们既用于命令式风格的活动中，也用于描述我们发布领域事件时的历史，使用过去时。 

在前面的例子中，我们不仅改进了代码，并更好地理解了它的功能和其中存在哪些概念，而且还发现了我们的领域模型将从中受益的一些新术语和概念。我们可以开始在与领域专家交谈时使用这些术语，看看他们是否理解。有时，他们可能会对开发者投来奇怪的目光，试图理解他们的兴奋，因为他们已经知道这个**新**概念了——它是他们**语言**的一部分，只是从未在业务和开发人员之间的对话中表达过。这样的突破不仅使代码更好，更接近实际的商业模型，而且也改善了开发者和领域专家之间的沟通。

通过将隐含的事物明确化，我们不仅发现了代码中缺失的概念，而且还将它们纳入我们的领域模型中。这部分是至关重要的，因为这种语言被用于整个模型范围——商业和心智模型、概念和视觉模型，以及图表和代码中的领域模型。在系统的多个模型级别上使用相同的概念和，一般来说，相同的语言的模式被称为**通用语言**。

# 语言与语境

在本章的引言中，我们已经提到了同一语言中的语言差异问题。如果一种语言被某种边界所分割，无论是地理的、国家的还是专业的，它就开始分裂。我们之前以英国英语和美国英语为例，但当然还有更多类似的例子。在比利时使用的荷兰语甚至经常被称作一种单独的语言，弗拉芒语，因为它听起来不同，但主要是因为在日常物体和动作中，使用了不同的词汇。同样的情况也适用于在专业群体中发展的语言，其中人们形成了行话，我们也已经看到了一些这样的例子。

这些例子被提出是为了说明定义词语的精确含义是多么重要。避免混淆确实是找到和识别通用语言的目标之一。

重要的是要认识到通用语言仅在特定语境内有效。不同的语境由不同的语言定义。有一种误解认为通用语言被称为**通用**是因为它是整个商业、组织或领域的单一语言。事实并非如此。它不是在水平方向上通用，而是在垂直方向上通用。每个语境可能都有自己的语言，但在这个语境中的所有层级都共享一种通用语言——与业务、模型、代码、测试、UI 概念、数据结构等的会议。

让我们来看一个经典的例子，即术语**产品**在电子商务领域的不同语境中的应用：

![](img/e5a1c911-2b91-4b71-803c-17884a3d0a61.png)

不同语境中的产品

尽管我们在同一领域运营，但很明显，**产品**这个术语在每个已识别的上下文中的含义都有所不同：

+   **销售**：对于销售人员来说，产品意味着销售价格和可能的利润。这是公司赚钱的地方，产品的其他属性并不那么重要。

+   **采购**：如果我们购买产品进行转售，我们主要关注的是购买价格，供应商有多少库存的特定产品，以及他们能多快交付。

+   **库存**：我们主要关注的是我们有多少库存商品。如果某个特定商品缺货，这个上下文可以保持估计的补货日期。在这里，我们可能还会定义一些产品的内部属性，例如商品编号。

+   **仓库**：它需要管理存储产品所需的空间，因此在这个上下文中的人需要知道产品批次何时到达，客户发货何时进行，产品如何包装，以及它们存储在哪里。

如您所见，尽管我们有一个流行的术语，比如**产品**，但同一领域或组织中的不同部门实际上很少有共同兴趣，并且对某物（否则可能被视为同一对象）的属性子集有更深入的了解。

另一个很好的例子是保险领域的术语**政策**。对于不在保险行业工作的人来说，它可能不太为人所知，但一般来说，我们理解卖给我们保险的人主要对金钱和获取新客户感兴趣。因此，对他们来说，**政策**意味着新的销售和金钱。当涉及到审批时，如果我们以车辆保险为例，政策意味着风险。即使政策已经售出，风险评估部门仍有可能要求额外的文件，并在一些内部检查后拒绝该政策。最后，当涉及到处理现有政策的索赔时，对于索赔处理部门来说，它是一个**成本**，因为保险公司会损失金钱。

这两个例子都表明，即使在同一领域，语言也会在不同的上下文中发生变化，有时变化还相当显著。如果我们继续在上下文中使用相同的词义，会发生什么？嗯，事情会变得不那么明确。随着我们未能识别和区分的新上下文的增加，歧义程度也在增加。这导致模型不明确，结果就是代码晦涩难懂，我们需要在用这个词或那个词时明确我们到底想表达什么。

在一个工作环境中混合不同的上下文也会导致所谓的**上下文切换**。在《质量软件管理：系统思维》一书中，Gerald Weinberg 指出，一个人负责的项目数量越来越多会导致由于上下文切换而造成的显著生产力损失：

![图片](img/fd0a33da-1a7f-4740-8a6f-308456ec8392.png)

由于上下文切换造成的生产力损失

在当前任务中添加一个新项目意味着 20%的生产力损失。因此，当上下文数量达到五个时，实际工作花费的时间变得极其低。大多数时间都花在试图弄清楚当前任务属于哪个上下文中。

这不仅适用于项目。你可能从经验中知道，对于泛化胜过精确性和明确性的大型项目，上下文切换现象对性能的影响同样巨大。在我们的**产品**示例中，如果我们把产品不同逻辑视图的所有属性都放在一个地方，那么处理这样一个对象将涉及一些额外的努力，试图理解我们目前正在处理产品的哪个部分。因此，尽管这仍然是一件事，但隐藏的上下文切换和生产率会受到影响。

假设集中化和泛化是好事，许多软件系统创建了所谓的神级类，例如`Customer`或`Product`，这些类包含了所有可能的属性，以适应物理对象的所有可能视图。除了上下文切换之外，这种方法的缺点还有很多。

其中一个明显的问题是，在系统中的这样一个对象的生命周期中，并非所有属性都需要有值。例如，已经淘汰的产品没有任何与销售相关的特性。但由于我们有一个包含所有内容的类，我们必须为所有这些属性分配空值。这种做法导致高度混乱，因为我们几乎不明白为什么这些属性是空的——要么是系统中的错误，要么这只是由于对象状态而出现的典型情况。

另一个问题是不容忽视的，这样的类会吸引大量的依赖。你可能见过数据模型，有时它们模仿**领域模型**，整个复杂系统有一个大型的 SQL 数据库，其中表有很多交叉引用。我们可以想象，像`Product`这样的东西可以被`Order`、`ShoppingCart`、`Catalogue`、`Invoice`、`PurchaseInvoice`、`Return`、`CreditNote`等引用。模型变得错综复杂，难以维护。有时，情况变得更糟，因为引用依赖有时是明显错误的。例如，在某个过去的订单上显示更新的产品描述是不正确的。订单应该包含购买产品时的快照。

我们已经找到了足够的原因，让我们在寻求语言时对忘记上下文保持谨慎。通用语言总是明确、具体和上下文相关的。一旦你感觉到或观察到单词在不同系统部分之间的含义开始变化，这应该在你脑海中触发一个警报，表明你可能正在跨越上下文边界。

**在讨论用户时，上下文出现**。开发者喜欢将人们视为用户。这个术语如此含糊，几乎可以保证我们在谈论用户时会切换到不同的上下文。

回到我们的示例领域，团队成员讨论了他们的用户会如何评价他们的交易。他们认为，如果人们可以互相给出评价，这将有助于建立社区信任。在对话中，他们中的一些人注意到他们交替使用 *用户*、*卖家*、*销售者*、*买家* 和 *购买者* 这些词。当使用通用术语 *用户* 时，几乎总是需要澄清：这个用户在那个特定时刻扮演什么角色。同时，当他们将用户命名为 *买家* 和 *卖家* 时，没有模糊性，也不需要进一步的澄清。

注意到这一点后，该小组决定他们发现了普遍语言的新元素，并开始使用这些术语。这是一个很好的洞察力，在讨论模型和消除代码中的模糊性时，为他们节省了大量时间。

同时，在系统的授权部分将人们分为 *卖家* 和 *买家* 完全没有意义。这些人只是 *用户*，他们可以登录系统并执行一些操作，例如更新他们的个人资料，而无需明确区分他们是否会在网站上买卖。这是另一个当 *用户* 这个词没有歧义且明确的情况下。

后来，当他们为后台系统建模时，发现了用户之间的另一个区别。在那里，用户开始承担角色，再次出现了模糊性，直到他们确定了这些角色并开始使用诸如 *管理员*、*支持助理* 和 *审阅者* 等术语。发现了一个新的上下文，并为该上下文出现了一个新的模型，这个模型通过词语的意义与其他上下文区分开来。

# 摘要

在本章中，我们讨论了语言在系统设计中的重要性以及精确和无歧义术语如何带来清晰性。我们还就业务人员和开发人员对领域有共同的理解进行了探讨。我们还研究了不同行业如何使用相同的词语来表达不同的概念，以及这对领域建模有什么影响。

本章中的代码示例展示了不清晰的语言如何使实现变得更加复杂和难以理解。通过将更好的语言引入代码，我们使其更加清晰、简短和简洁。我们将一些隐含的概念变得更加明确，这有助于更好地理解业务并提高代码质量。我们还发现了许多成为语言一部分的动词，这对于名词的词汇表是一个重要的补充，而名词通常被视为领域模型唯一重要的部分。

本章介绍了由埃里克·埃文斯提出的术语*通用语言*。我们强调，语言的通用性不在于其广泛性，而在于其精确性，以及它被用于软件开发过程的全部工件——从最初的讨论，经过建模和设计，到代码和测试。

我们探讨了词语在不同语境中如何改变其含义，以及语境切换如何对生产力产生负面影响。使用我们的样本领域，我们回顾了在建模过程中以及开发者和领域专家之间的对话中，如何发现语境的几个例子。

在下一章中，我们将探讨领域建模中最受欢迎的技术之一，并介绍一些在领域专家和开发者之间组织有用研讨会时的实用技巧。
