<html><head></head><body>
		<div><h1 id="_idParaDest-239"><em class="italic"><a id="_idTextAnchor1531"/>Chapter 13</em>: Implementing Authorization in .NET 6</h1>
			<p>One of the important aspects of building secure applications is to ensure that users have access only to the resources that they need. In the real world, when you check in to a hotel, a front-desk employee validates your ID and credit card and assigns a key card to access your room. Based on the type of room you have chosen, you may have privileges, such as access to the lounge, pool, or gym, among others. Here, the validation of your ID and credit card and assigning a key card is called <strong class="bold">authentication</strong>, and permitting you to access the various resources is called <strong class="bold">authorization</strong>. So, to explain it further, using a key card, we cannot identify who you are but can determine what you can do.</p>
			<p>Authorization is a mechanism by which you determine what users can do and grant or deny access to a resource of your application. For instance, users of our e-commerce application should be able to browse products, add them to the cart, and check out to buy them, and only admin or back-office users should be able to add or update product information, update the price of products, and approve or reject orders.</p>
			<p>In this chapter, we will learn what authorization is and the various ways to implement authorization using the ASP.NET Core framework. The following topics are covered in this chapter:</p>
			<ul>
				<li>Understanding authorization in .NET 6</li>
				<li>Simple authorization</li>
				<li>Role-based authorization</li>
				<li>Claims-based authorization</li>
				<li>Policy-based authorization</li>
				<li>Custom authorization</li>
				<li>Authorization in client and server applications</li>
			</ul>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor1532"/><a id="_idTextAnchor1533"/>Technical requirements</h1>
			<p>For this chapter, you need basic knowledge of Azure, Azure AD B2C, C#, .NET Core, and Visual Studio 2022.</p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor1534"/><a id="_idTextAnchor1535"/>Back to a few basics</h1>
			<p>Before we dig<a id="_idIndexMarker1203"/> into <a id="_idIndexMarker1204"/>more details, let's understand the differences between authentication and authorization.</p>
			<p>Authenticatio<a id="_idTextAnchor1536"/>n and authorizati<a id="_idTextAnchor1537"/>on may look similar and be used interchangeably, but fundamentally they are different. The following table illustrate<a id="_idTextAnchor1538"/>s the differences:<a id="_idTextAnchor1539"/></p>
			<div><div><img src="img/Table_13.1.jpg" alt="Table 13.1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 13.1</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to <a href="B18507_12_Epub.xhtml#_idTextAnchor1389"><em class="italic">Chapter 12</em></a>,<em class="italic"> Understanding Authentication</em>, for more details on how authentication works in ASP.NET 6.</p>
			<p>To summarize this, authentication and authorization go hand in hand. Authorization works only after the identity of the user has been established, and an authentication challenge is triggered by authorization when a user tries to access a secure resource. In the upcoming sections of this chapter, we will understand how to implement authorization in ASP.NET 6 applications.<a id="_idTextAnchor1540"/><a id="_idTextAnchor1541"/></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor1542"/>Understanding authorization</h1>
			<p>Authorization<a id="_idTextAnchor1543"/><a id="_idIndexMarker1205"/> in ASP.NET Core is handled by a <strong class="bold">middleware</strong>. When your application receives the first request from an unauthenticated user to a secured resource, an authentication challenge is invoked by the middleware, and depending on the authentication scheme, the user is either redirected to log in or access is forbidden. Once the identity of the user has been established after authentication, the authorization middleware checks whether the user can access the resource or not. In subsequent requests, the authorization middleware uses the identity of the user to determine whether access is allowed or forbidden.</p>
			<p>To configure authorization middleware in your project, you need to invoke <code>UseAuthorization()</code> in <code>Program.cs</code>. It is mandatory to register authorization middleware only after authentication middleware, as authorization can be performed only after establishing the user's identity. Refer to the following code:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">..</pre>
			<pre class="source-code">var app = builder.Build();</pre>
			<pre class="source-code">a<a id="_idTextAnchor1544"/>pp.UseAuthentication();</pre>
			<pre class="source-code">app.<strong class="bold">UseAuthorization</strong>();</pre>
			<pre class="source-code">app.UseEndpoints(endpoints =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">endpoints.MapControllerRoute(</pre>
			<pre class="source-code">    name: "default",</pre>
			<pre class="source-code">    pattern: "{controller=Home}/{action=Index}/{id?}");</pre>
			<pre class="source-code">    endpoints.MapRazorPages();</pre>
			<pre class="source-code">});</pre>
			<p>In the preceding code block, you'll notice that <code>app.UseAuthorization()</code> is invoked after <code>app.UseAuthentication()</code> and before <code>app.UseEndpoints()</code>.</p>
			<p>ASP.NET 6 provides simple, declarative role- and claims-based authorization models and rich policy-based <a id="_idIndexMarker1206"/>models. In the following sections, we will learn more details about thes<a id="_idTextAnchor1545"/><a id="_idTextAnchor1546"/>e.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor1547"/>Simple authorization</h2>
			<p>In ASP.NET Core, authorizati<a id="_idTextAnchor1548"/>on is configured using <code>AuthorizationAttribute</code>. <a id="_idTextAnchor1549"/>You can apply the <code>[Authorize]</code> attribute on a controller, action, or Razor page. When you add this attri<a id="_idTextAnchor1550"/>bute, access to that component is restricted only to authenticated users. Refer to<a id="_idIndexMarker1207"/> the following code block:</p>
			<pre class="source-code">public class HomeController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">[<strong class="bold">Authorize</strong>]</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public IActionResult Privacy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, you'll notice that the <code>[Authorize]</code> attribute is added to the <code>Index</code> action. When a user tries to access <code>/Home/Index</code> from the browser, the middleware checks whether the user is authenticated or not. If not, the user is redirected to the login page.</p>
			<p>If we add the <code>[Authorize]</code> attribute to a controller, access to any action under that controller is restricted only to authenticated users. In the following code, you'll notice that the <code>[Authorize]</code> attribute is added to <code>HomeController</code>, making all actions under it secure:</p>
			<pre class="source-code">[<strong class="bold">Authorize</strong>]</pre>
			<pre class="source-code">public class HomeController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">[<strong class="bold">AllowAnonymous</strong>]</pre>
			<pre class="source-code">public IActionResult Privacy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>At times, you<a id="_idTextAnchor1551"/> may want to allow a few areas of your application<a id="_idTextAnchor1552"/> to be accessible to any user; for <a id="_idIndexMarker1208"/>example, the login or reset password page should be open to all, regardless of whether the user is authenticated or not. To meet such requirements, you can add the <code>[AllowAnonymous]</code> attribute to a controller or an action and make them available to unauthenticated users as well.</p>
			<p>In the preceding code, you'll notice that the <code>[AllowAnonymous]</code> attribute is added to the <code>Privacy</code> action, though we have the <code>[Authorize]</code> attribute on the controller. That requirement is overridden by the <code>[AllowAnonymous]</code> attribute on the action method and so the <code>Privacy</code> action is accessible by all users.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>[AllowAnonymous]</code> attribute overrides all authorization configurations. If you set <code>[AllowAnonymous]</code> on a controller, setting the <code>[Authorize]</code> attribute on any action methods under it will have no impact. In this case, the <code>Authorize</code> attribute on the action methods is completely ignored.</p>
			<p>So far, we have seen ho<a id="_idTextAnchor1553"/>w to secure a controller or an action method. In<a id="_idTextAnchor1554"/> the next section, we will <a id="_idIndexMarker1209"/>see how to enable authorization globally in an ASP.NET Core applica<a id="_idTextAnchor1555"/><a id="_idTextAnchor1556"/>tion.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor1557"/>Enabling authorization globally</h2>
			<p>So far, we have <a id="_idIndexMarker1210"/>seen<a id="_idTextAnchor1558"/> how to secure a controller or an action method using the <code>[Authorize]</code> attribute. Setting the <code>authorize</code> attribute on every controller or action is not sustainable in large projects; you may miss configuring it on newly added controllers or action methods, which can lead to a security vulnerability.</p>
			<p>ASP.NET Core allows you to enable authorization globally by adding a fallback policy in your application. You can define a fallback policy in <code>Program.cs</code>. The fallback policy will be applied to all requests where no explicit authorization requirement is defined:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">options.FallbackPolicy = new AuthorizationPolicyBuilder()</pre>
			<pre class="source-code">        .RequireAuthenticatedUser()</pre>
			<pre class="source-code">        .Build();</pre>
			<pre class="source-code">});</pre>
			<p>Adding a policy globally enforces users to be authenticated to access any action method in your application. This option is beneficial as you don't have to specify the <code>[Authorize]</code> attribute for every controller/action in your application.</p>
			<p>You can still set the <code>[AllowAnonymous]</code> attribute on a controller or action method to override the fallback behavior and make it anonymously accessible.</p>
			<p>Now that we understand how to implement simple authorization, in the next section, let's understand what role-based authorization is and how it simplifies implement<a id="_idTextAnchor1559"/><a id="_idTextAnchor1560"/>ation.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor1561"/>Role-based authorization</h1>
			<p>It is quite common<a id="_idIndexMarker1211"/> for certain a<a id="_idTextAnchor1562"/>reas of your application to be a<a id="_idTextAnchor1563"/>vailable to only certain users. Instead of granting access at the user level, general practice is to group users into roles and grant access to roles. Let's consider a typical e-commerce application, in which <em class="italic">users</em> can place orders, <em class="italic">support</em> staff can view, update, or cancel orders and resolve user queries, and the <em class="italic">admin</em> role approves or rejects orders, manages inventory, and so on.</p>
			<p>Role-based authorization can address such requirements. When you create a user, you may assign it to one or more roles, and when we configure the <code>[Authorize]</code> attribute, we can pass one or more role names to the <code>Roles</code> property of the <code>Authorize</code> attribute.</p>
			<p>The following code restricts access to all action methods under the <code>Admin</code> controller to users who belong to the <code>Admin</code> role:</p>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public class AdminController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, you can specify comma-separated role names in the <code>Roles</code> property of the <code>Authorize</code> attribute, so that users who belong to either of the configured roles will have access to the action methods under that controller.</p>
			<p>In the following code, you'll notice <code>User,Support</code> is supplied as a value of the <code>Roles</code> property of the <code>[Authorize]</code> attribute; users belonging to the <code>User</code> or <code>Supp<a id="_idTextAnchor1564"/>ort</code> roles ca<a id="_idTextAnchor1565"/>n access the action methods of <code>OrdersController</code>:</p>
			<pre class="source-code">[Authorize(Roles ="User,Support")]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can also specify multiple authorization attributes. If you do so, the user must be a member of all roles specified to access it.</p>
			<p>In the following code, multiple <code>[Authorize]</code> attributes are configured on <code>InventoryController</code> for the <code>InventoryManager</code> and <code>Admin</code> roles. To access the <code>Inventory</code> controller, a user<a id="_idIndexMarker1212"/> must have the <code>InventoryManager</code> and <code>Admin</code> roles:</p>
			<pre class="source-code">[Authorize(Roles ="InventoryManager")]</pre>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public class InventoryController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public IActionResult Approve()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can<a id="_idTextAnchor1566"/> further restrict access to the action methods under the <code>Inventory</code> controller by specifying authorization attributes. In the preceding cod<a id="_idTextAnchor1567"/>e, users must have the <code>InventoryManager</code> and <code>Admin</code> roles to acce<a id="_idTextAnchor1568"/>ss the <code>Approve</code> action.</p>
			<p>Programmatically, if you want to check whether a user belongs to a role, you can use the <code>IsInRole</code> method of <code>ClaimsPrinciple</code>. In the following example, you'll notice that <code>User.IsInRole</code> accepts <code>roleName</code> and, based on the user's role, it returns <code>true</code> or <code>false</code>:</p>
			<pre class="source-code">public ActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">if (User.IsInRole("Admin"))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    // Handle your logic</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">return View();</pre>
			<pre class="source-code">}</pre>
			<p>So far, we<a id="_idIndexMarker1213"/> have seen how to secure a controller or an action by specifying role names in an authorization attribute. In the next section, we will see how to centralize these configurations in one place using policy-based role autho<a id="_idTextAnchor1569"/><a id="_idTextAnchor1570"/>rization.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor1571"/>Policy-based role authorization</h2>
			<p>We can also <a id="_idIndexMarker1214"/>d<a id="_idTextAnchor1572"/>efine role requirements as policies in <code>Progr<a id="_idTextAnchor1573"/>am.cs</code>. This approach is quite useful, as you can create and manage your role-based access requirements in one place and use policy names instead of role names to control access. To define a policy-based role authorization, we need to register an authorization policy with one or more role requirements in <code>Program.cs</code> and provide a policy name to the <code>Policy</code> property of the <code>Authorize</code> attribute.</p>
			<p>In the following code, <code>AdminAccessPolicy</code> is created by adding a requirement with the <code>Admin</code> role:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    options.AddPolicy("AdminAccessPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.RequireRole("Admin"));</pre>
			<pre class="source-code">});</pre>
			<p>In your controller, you can specify the policy to be applied as follows, and access to <code>AdminController</code> is restricted<a id="_idIndexMarker1215"/> to users with the <code>Admin</code> role:</p>
			<pre class="source-code">[Authorize(<strong class="bold">Policy</strong> ="AdminAccessPolicy")]</pre>
			<pre class="source-code">public class AdminController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can specify multiple roles while defining a policy. Users belonging to any one of the roles can access resources when that policy is used to authorize users. For example, the following code will allow a user with the <code>User</code> or <code>Support</code> roles to access resources:</p>
			<pre class="source-code">options.AddPolicy("OrderAccessPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.RequireRole("User","Support"));</pre>
			<p>You can use an <code>OrderAccessPolicy</code> policy with the <code>Authorize</code> attribute either on the controll<a id="_idTextAnchor1574"/>er or action methods to control access.</p>
			<p>Now that we understand how to use role-based authorization, in the next section, we will create a simple application and configure it to use role-based aut<a id="_idTextAnchor1575"/><a id="_idTextAnchor1576"/>horization.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor1577"/>Implementing role-based authorization</h2>
			<p>Let'<a id="_idTextAnchor1578"/>s cre<a id="_idTextAnchor1579"/>ate a <a id="_idIndexMarker1216"/>sample application implementi<a id="_idTextAnchor1580"/>ng role-based authorization using ASP.NET Core Identity:</p>
			<ol>
				<li>Create a new ASP.NET Core project. You can use the following <code>dotnet</code> <code>Individual</code> accounts as the <code>Authentication</code> mode and <code>SQLite</code> as the database store:<pre><strong class="bold">dotnet new mvc --auth Individual -o AuthSample</strong></pre></li>
				<li>You need to enable role services by invoking <code>AddRoles&lt;IdentityRole&gt;()</code> in <code>Program.cs</code>. You can refer to the following code to enable it. You'll also notice <code>RequireConfirmedAccount</code> is set to <code>false</code>. This is required for this sample as we create users programmatically:<pre>{
var builder = WebApplication.CreateBuilder(args);
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
    options.UseSqlite(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
builder.Services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt;
    <strong class="bold">options.SignIn.RequireConfirmedAccount = false)</strong>
<strong class="bold">    .AddRoles&lt;IdentityRole&gt;()</strong>
    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();
builder.Services.AddControllersWithViews();   
}</pre></li>
				<li>Next, we need to create roles and users. For this, we will add two methods, <code>SetupRoles</code> and <code>SetupUsers</code>, to <code>Program.cs</code>. We can make use of the <code>RoleManager</code> and <code>UserManager</code> services to create roles and users. In the fol<a id="_idTextAnchor1581"/>lowing code, we create three roles. Using <code>IServiceProvider</code>, we get an instance of the <code>roleManager</code> serv<a id="_idTextAnchor1582"/>ice and then we make use of the <code>RoleExisysAsync</code> and <code>CreateAsync</code> methods<a id="_idIndexMarker1219"/> to create it:<pre>//Add this method to Program.cs
async Task SetupRoles(IServiceProvider serviceProvider)
{
var rolemanager = serviceProvider
    .GetRequiredService&lt;RoleManager&lt;IdentityRole&gt;&gt;();
string[] roles = { "Admin", "Support", "User" };
foreach (var role in roles)
{
    var roleExist = await rolemanager.RoleExistsAsync(role);
    if (!roleExist)
    {
        await rolemanager.CreateAsync(new 
          IdentityRole(role));
    }
   }<a id="_idTextAnchor1583"/>
}</pre></li>
				<li>Similarly, we create users and as<a id="_idTextAnchor1584"/>sign one of the roles using the <code>userManager</code> service. In the following code, we create two users – <code>admin@abc.com</code>, assigned<a id="_idIndexMarker1220"/> the <code>admin</code> role, and <code>support@abc.com</code>, assigned the <code>support</code> role:<pre>//Add this method to Program.cs
async Task SetupUsers(IServiceProvider serviceProvider)
{
var userManager = serviceProvider
    .GetRequiredService&lt;UserManager&lt;IdentityUser&gt;&gt;();
var adminUser = await userManager.<strong class="bold">FindByEmailAsync</strong>("admin@abc.com");
if (adminUser == null)
{
    var newAdminUser = new IdentityUser
    {
        UserName = "admin@abc.com",
        Email = "admin@abc.com",
    };
var result = await userManager
    .<strong class="bold">CreateAsync</strong>(newAdminUser, "Password@123");
if (result.Succeeded)
    await userManager.<strong class="bold">AddToRoleAsync</strong>(newAdminUser, 
      "Admin");
}
var supportUser = await userManager
    .<strong class="bold">FindByEmailAsync</strong>("support@abc.com");
if (supportUser == null)
{
    var newSupportUser = new IdentityUser
    {
        UserName = "support@abc.com",
        Email = "support@abc.com",
    };
var result = await userManager
    .<strong class="bold">CreateAsync</strong>(newSupportUser, "Password@123");
if (result.Succeeded)
    await userManager.<strong class="bold">AddToRoleAsync</strong>(newSupportUser, 
      "Support");
}
}</pre></li>
				<li>To <a id="_idTextAnchor1585"/>invoke these <a id="_idIndexMarker1221"/>two methods, we need an instance of <code>IserviceProvider</code>. The following code gets the instance to <code>IServiceProvider</code> to set up roles and users data:<pre>//
//
var app = builder.Build();
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    await SetupRoles(services);
    await SetupUsers(services);
}</pre></li>
				<li>Inside the <code>Home</code> controller, add the following code. To simplify the implementation, we are using the <code>Index</code> view. In a real-life scenario, you need to return the <a id="_idIndexMarker1222"/>view that is created for the respective action methods:<pre>[Authorize(Roles = "Admin")]
public IActionResult Admin()
{
return View("Index");
}
[Authorize(Roles = "Support")]
public IActionResult Support()
{
return View("Index");
}</pre></li>
				<li>Optionally, we can add logic to <code>Layout.cshtml</code> to display links to nav<a id="_idTextAnchor1586"/>igate based on the logged-in user's <a id="_idTextAnchor1587"/>role. The following sample makes use of <code>IsInRole</code> to check the user's role and display a link:<pre>&lt;li class="nav-item"&gt;
&lt;a class="nav-link text-dark" asp-area="" asp-controller="Home" asp-action="Index"&gt;Home&lt;/a&gt;
&lt;/li&gt;
@if (<strong class="bold">User.IsInRole("Admin"))</strong>
{
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link text-dark" asp-area="" asp-controller="Home" asp-action="Admin"&gt;Admin&lt;/a&gt;
&lt;/li&gt;
}
@if (<strong class="bold">User.IsInRole("Support"))</strong>
{
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link text-dark" asp-area="" asp-controller="Home" asp-action="Support"&gt;Support&lt;/a&gt;
&lt;/li&gt;
}<a id="_idTextAnchor1588"/></pre></li>
			</ol>
			<p>With the preceding <a id="_idIndexMarker1223"/>step, the sampl<a id="_idTextAnchor1589"/>e implementation is complete, and you can run the application to see how it works. </p>
			<p>Run the application, log in with <code>admin@abc.com</code>, and you will notice that the <strong class="bold">Admin</strong> menu item is visible and <strong class="bold">Support</strong> is hidden:</p>
			<div><div><img src="img/Figure_13.1_B18507.jpg" alt="Figure 13.1 – Admin user login view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Admin user login view</p>
			<p>When you log in with <code>support@abc.com</code>, you will notice the <strong class="bold">Support</strong> menu item is visible and the <strong class="bold">Admin</strong> item is hidden:</p>
			<div><div><img src="img/Figure_13.2_B18507.jpg" alt="Figure 13.2 – Support user login view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Support user login view</p>
			<p>In the next<a id="_idIndexMarker1224"/> section, we will see how to use claims <a id="_idTextAnchor1590"/><a id="_idTextAnchor1591"/>for authorization.</p>
			<h1 id="_idParaDest-248">Claims-based au<a id="_idTextAnchor1592"/>thorization</h1>
			<p>A <strong class="bold">claim</strong> is a key-value <a id="_idIndexMarker1225"/>pair associated with identity after successful authentication. A claim can be a date of birth, gender, or zip code, for example. One or more claims can be assigned to a user. Claims-based authorization uses the value of a claim and determines whether access to a resource can be granted or not. You can use two approaches to validate a claim; one way is to just check whether the claim exists or not and the other approach is to check whether the claim exists with a parti<a id="_idTextAnchor1593"/>cular value.</p>
			<p>To use claims-based authorization, we need to register a policy in <code>Program.cs</code>. You need t<a id="_idTextAnchor1594"/>o pass a claim name and optional values to the <code>RequireClaim</code> method to register. For example, the following code registers <code>PremiumContentPolicy</code> with the requirement of the<a id="_idTextAnchor1595"/> <code>PremiumUser</code> claim:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    options.AddPolicy("PremiumContentPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.<strong class="bold">RequireClaim</strong>("PremiumUser"));</pre>
			<pre class="source-code">});</pre>
			<p>In the following code, the <code>PremiumContentPolicy</code> authorization policy is used on <code>PremiumContentController</code>. It checks whether the <code>PremiumUser</code> claim exists in the user claims to authorize the user's request; it doesn't care what value is in the claim:</p>
			<pre class="source-code">[Authorize(Policy ="PremiumContentPolicy")]</pre>
			<pre class="source-code">public class PremiumContentController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        return View(<a id="_idTextAnchor1596"/>);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can also<a id="_idIndexMarker1226"/> specify a list of values while defining a claim. Th<a id="_idTextAnchor1597"/>ey will be validated to grant access to a resource. For example, as per the following code, the user request is authorized if the user has the <code>Country</code> claim with the values of <code>US</code>, <code>UK</code>, or <code>IN</code>:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    options.AddPolicy("ExpressShippingPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.<strong class="bold">RequireClaim</strong>(ClaimTypes.Country, </pre>
			<pre class="source-code">          "US", "UK", "IN"));</pre>
			<pre class="source-code">});</pre>
			<p>Programmatically, if you want to check whether a user has a claim, you use the <code>HasClaim</code> method of <code>ClaimsPrinciple</code> by specifying a match condition. </p>
			<p>To fetch a claim value, you can use the <code>FindFirst</code> method. The following code illustrates an example:</p>
			<pre class="source-code">@if (User.<strong class="bold">HasClaim</strong>(x =&gt; x.Type == "PremiumUser"))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    &lt;h1&gt;Yay, you are Premium User!!!, @User.<strong class="bold">FindFirst</strong>(x =&gt; </pre>
			<pre class="source-code">        x.Type == ClaimTypes.Country)?<a id="_idTextAnchor1598"/>.Value&lt;/h1&gt;</pre>
			<pre class="source-code">}</pre>
			<p>As seen in the <em class="italic">Implementing role-based authorization</em> section<a id="_idTextAnchor1599"/>, while adding a user to an application, you can also add a claim to the user using the <code>UserManager</code> service. In the following code, you'll <a id="_idIndexMarker1227"/>notice the <code>AddClaimAsync</code> method is invoked with <code>IdentityUser</code> and <code>Claim</code>:</p>
			<pre class="source-code">var user = await userManager.FindByEmailAsync("user@abc.com");</pre>
			<pre class="source-code">if (user == null)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">var newUser = new IdentityUser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    UserName = "user@abc.com",</pre>
			<pre class="source-code">    Email = "user@abc.com",</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">var result = await userManager.CreateAsync(newUser, "Password@123");</pre>
			<pre class="source-code">if (result.Succeeded)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">    .AddToRoleAsync(newUser, "User");</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">    .<strong class="bold">AddClaimAsync</strong>(newUser, new Claim("PremiumUser", </pre>
			<pre class="source-code">       "true"));</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">    .<strong class="bold">AddClaimAsync</strong>(newUser, new Claim(ClaimTypes.Country, </pre>
			<pre class="source-code">       "US"));</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">                .AddClaimAsync(newUser, new Claim(ClaimTypes.DateOfBirth, "1-<a id="_idTextAnchor1600"/>5-2003"));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding <a id="_idIndexMarker1228"/>code, you will notice two claims created a<a id="_idTextAnchor1601"/>nd associated with the user using the <code>AddClaimAsync</code> method. In the next section, we will see how to use polic<a id="_idTextAnchor1602"/><a id="_idTextAnchor1603"/>y-based authorization.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor1604"/>Policy-based authorization</h1>
			<p>Policy-bas<a id="_idTextAnchor1605"/>ed <a id="_idIndexMarker1229"/>authorization a<a id="_idTextAnchor1606"/>llows you to write your own logic to handle authorization requirements that suit your needs. For example, you have a requirement to verify a user's age and authorize the placing of an order only if the user is above 14 years of age. You can use the policy-based authorization model to handle such requirements.</p>
			<p>To configure policy-based authorization, we need to define a requirement and a handler, and then register<a id="_idIndexMarker1230"/> the policy with the requirement. Let's understand these components:</p>
			<ul>
				<li>A <strong class="bold">policy</strong> is defined with one or more requirements.</li>
				<li>A <strong class="bold">requirement</strong> is a collection of data parameters used by the policy to evaluate the user's identity.</li>
				<li>A <strong class="bold">handler</strong> is responsible for evaluating data from the requirement against the context and determining whether access can be granted or not.</li>
			</ul>
			<p>In the following section, we will see how to create a requirement and a handler, and register <a id="_idTextAnchor1607"/><a id="_idTextAnchor1608"/>an authorization policy.<a id="_idTextAnchor1609"/></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor1610"/>Requirements</h2>
			<p>To create a <a id="_idIndexMarker1231"/>requirement, you need to implement the <code>IAuthorizationRequirement</code> interface. This is a marker interface, so you don't have any members to implement. For example, the following code creates <code>MinimumAgeRequirement</code>, with <a id="_idTextAnchor1611"/><code>MinimumAge</code> as a data parameter:</p>
			<pre class="source-code">public class MinimumAgeRequirement: IAuthorizationRequirement</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public int MinimumAge { get; set; }</pre>
			<pre class="source-code">public MinimumAgeRequirement(int minimumAge)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    this.Min<a id="_idTextAnchor1612"/><a id="_idTextAnchor1613"/>imumAge = minimumAge;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<h2 id="_idParaDest-251">Require<a id="_idTextAnchor1614"/>ment handlers</h2>
			<p>Requirement <a id="_idIndexMarker1232"/>handlers encapsulate logic to allow or deny a request. They use requirement properties against <code>AuthorizationHandlerContext</code> to determine access. A handler may inherit <code>Authorizationhandler&lt;TRequirement&gt;</code>, where <code>TRequirement</code> is of the <code>IauthorizationRequirement</code> type, or implement <code>IAuthorizationHandler</code>.</p>
			<p>In the following example, <code>MinimumAgeAuthorizationHandler</code> is created by inheriting <code>AuthorizationHandler</code> with <code>MinimumAgeRequirement</code> as <code>TRequirement</code>. We need to override <code>HandleRequirementAsync</code> to write custom authorization logic where the user's age is calculated from the <code>DateOfBirth</code> claim. If the user's age is greater than or equal to <code>MinimumAge</code>, we invoke <code>context.Succeed</code> to grant access. If the claim is not present or doesn't meet the age criteria, access is forbidden:</p>
			<pre class="source-code">public class MinimumAgeAuthorizationHandler</pre>
			<pre class="source-code">: <a id="_idTextAnchor1615"/>AuthorizationHandler&lt;MinimumAgeRequirement&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">protected override Task HandleRequirementAsync(</pre>
			<pre class="source-code">AuthorizationHandlerContext context,</pre>
			<pre class="source-code">MinimumAgeRequirement requirement)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    if (context.User.HasClaim(</pre>
			<pre class="source-code">        c =&gt; c.Type == ClaimTypes.DateOfBirth))</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        var dateOfBirth = Convert.ToDateTime(</pre>
			<pre class="source-code">            context.User.FindFirst(x =&gt;</pre>
			<pre class="source-code">            x.Type == ClaimTypes.DateOfBirth).Value);</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        var age = DateTime.Today.Year - dateOfBirth.Year;</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        if (dateOfBirth &gt; DateTime.Today.AddYears(-age)) </pre>
			<pre class="source-code">          age--;</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        if (age &gt;= requirement.MinimumAge)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            context.Succeed(requirement);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">       else</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            context.Fail();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">            return Task.Co<a id="_idTextAnchor1616"/>mpletedTask;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>To mark a requirement as successful, you need to invoke <code>context.Succeed</code> by passing a requirement as a parameter. You don't have to handle failure, as another handler for the same<a id="_idIndexMarker1233"/> requirement may succeed. If you want to forbid a request, you can invoke <code>context.Fail</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Handlers must be registered for servic<a id="_idTextAnchor1617"/><a id="_idTextAnchor1618"/>e collection in <code>Program.cs</code>.</p>
			<h2 id="_idParaDest-252">Regi<a id="_idTextAnchor1619"/>stering a policy</h2>
			<p>A policy is <a id="_idIndexMarker1234"/>registered with a name and a requirement in <code>Program.cs</code>. You can register one or more requirements while defining a policy.</p>
			<p>In the following example, a policy with a requirement is created by invoking <code>policy.Requirements.Add()</code> and passing a new instance of <code>MinimumAgeRequirement</code>. You'll also notice <code>MinimumAgeAuthorizationHandler</code> is added to the service collection with a singleton scope:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">options.AddPolicy("Over14", policy =&gt;</pre>
			<pre class="source-code">    policy.Requirements.Add(new </pre>
			<pre class="source-code">      MinimumAgeRe<a id="_idTextAnchor1620"/>quirement(14)));</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">builder.Services.AddSingleton&lt;IAuthorizationHandler,</pre>
			<pre class="source-code">    MinimumAgeAuthorizationHandler&gt;();</pre>
			<p>We can then configure an authorization policy on the controller or action to restrict access based on the user's age:</p>
			<pre class="source-code">[Authorize(Policy ="Over14")]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        return <a id="_idTextAnchor1621"/>View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>If we register a policy with more than one requirement, then all requirements must be satisfied for<a id="_idIndexMarker1235"/> successful authorization.</p>
			<p>In the next section, we will learn how to fur<a id="_idTextAnchor1622"/><a id="_idTextAnchor1623"/>ther customize authorization<a id="_idTextAnchor1624"/>.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor1625"/>Custom authorization</h1>
			<p>In the previous <a id="_idIndexMarker1236"/>section, we <a id="_idTextAnchor1626"/>learned how to use policy-based authorization and implement custom logic to handle authorization requirements. But, it is not always possible to register authorization policies in <code>Program.cs</code> like that. In this section, we will see how to use <code>IAuthorizationPolicyProvider</code> to dynamically build policy configurations in your application.</p>
			<p>The <code>IAuthorizationPolicyProvider</code> interface has three methods to be implemented:</p>
			<ul>
				<li><code>GetDefaultPolicyAsync</code>: This method returns the default authorization policy to be used.</li>
				<li><code>GetFallbackPolicyAsync</code>: This method returns the fallback authorization policy. It is used when no explicit authorization requirement is defined.</li>
				<li><code>GetPolicyAsync</code>: This method is used to build and return an authorization policy for the provided policy name.</li>
			</ul>
			<p>Let's look into an example where you want to authorize a request to several controllers/actions based on different age criteria, say <code>Over14</code>, <code>Over18</code>, <code>Over21</code>, <code>Over60</code>, and so on. One way to implement it is to register all these requirements as policies and use them on your controllers or actions. But, using this approach, the code is less maintainable and not sustainable in a large application with many policies. Let's see how we can make use of the authorization policy provider.</p>
			<p>We need to create a class implementing <code>IAuthorizationPolicyProvider</code> and also implement <code>GetPolicy</code> and other methods.</p>
			<p>In the following example, the <code>MinimumAgePolicyProvider</code> class implements <code>GetPolicyAsync</code>. The input for this method is the policy name. Since our policy name is something<a id="_idIndexMarker1237"/> such as <code>Over14</code> or <code>Over18</code>, we can use string functions and e<a id="_idTextAnchor1627"/>xtract the age from them, and a requirement is initi<a id="_idTextAnchor1628"/>alized with the req<a id="_idTextAnchor1629"/>uired age and registered as a new policy:</p>
			<pre class="source-code">public class MinimumAgePolicyProvider : IAuthorizationPolicyProvider</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        const string PREFIX = "Over";</pre>
			<pre class="source-code">        public Task&lt;AuthorizationPolicy?&gt; </pre>
			<pre class="source-code">          GetPolicyAsync(string policyName)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            if (policyName.StartsWith(PREFIX, </pre>
			<pre class="source-code">              StringComparison.OrdinalIgnoreCase) &amp;&amp;</pre>
			<pre class="source-code">            int.TryParse(policyName.Substring(</pre>
			<pre class="source-code">              PREFIX.Length), out var age))</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                var policy = new </pre>
			<pre class="source-code">                  AuthorizationPolicyBuilder();</pre>
			<pre class="source-code">                policy.<strong class="bold">AddRequirements</strong>(new </pre>
			<pre class="source-code">                  <strong class="bold">MinimumAgeRequirement</strong>(<strong class="bold">age</strong>));</pre>
			<pre class="source-code">                return Task.FromResult </pre>
			<pre class="source-code">                  &lt;AuthorizationPolicy?&gt;(policy.Build());</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            return </pre>
			<pre class="source-code">              Task.FromResult&lt;AuthorizationPolicy?&gt;(null);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For the implementation of <code>MinimumAgeRequirement</code>, please refer to the <em class="italic">Policy-based aut<a id="_idTextAnchor1630"/>horization</em> section.</p>
			<p>ASP.NET Core <a id="_idIndexMarker1238"/>uses only one instance of <code>IAuthorizationPolicyProvider</code>. So, you should either customize a <code>Default</code> a<a id="_idTextAnchor1631"/>nd <code>Fallback</code> authorization policy or, alternatively, use a backup provider.</p>
			<p>In the following code, you'll see a sample implementation of the <code>GetDefaultPolicyAsync</code> and <code>GetFallbackPolicyAsync</code> methods in the <code>MinimumAgePolicyProvider</code> class.</p>
			<p><code>AuthorizationOptions</code> is injected into the constructor, and it is used to initialize <code>DefaultAuthorizationPolicyProvider</code>. The <code>BackupPolicyProvider</code> object is used to implement the <code>GetDefaultPolicyAsync</code> and <code>GetFallbackPolicyAsync</code> methods:</p>
			<pre class="source-code">public MinimumAgePolicyProvider(IOptions&lt;AuthorizationOptions&gt; options)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">this.<strong class="bold">BackupPolicyProvider</strong> =</pre>
			<pre class="source-code">    new <strong class="bold">DefaultAuthorizationPolicyProvider</strong>(options);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">Private DefaultAuthori<a id="_idTextAnchor1632"/>zationPolicyProvider BackupPolicyProvider { get; }</pre>
			<pre class="source-code">public Task&lt;AuthorizationPolicy&gt; GetDefaultPolicyAsync()</pre>
			<pre class="source-code">=&gt; this.BackupPolicyProvider.<strong class="bold">GetDefaultPolicyAsync</strong>();</pre>
			<pre class="source-code">public Task&lt;AuthorizationPolicy?&gt; GetFallbackPolicyAsync()</pre>
			<pre class="source-code">=&gt; this.BackupPolicyProvider.<strong class="bold">GetFallbackPolicyAsync</strong>();</pre>
			<p>This concludes<a id="_idIndexMarker1239"/> the implementation of <code>MinimumAgePolicyProvider</code>. You can now use the authorization policy on your controller or action methods. In the following code, you'll notice two policies are used, one with <code>Over14</code> on top of the controller and another with <code>Over18</code>, on the <code>Index</code> action method:</p>
			<pre class="source-code">[Authorize(Policy ="<strong class="bold">Over14</strong>")]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    [Authorize(Policy ="<strong class="bold">Over18</strong>")]</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        ret<a id="_idTextAnchor1633"/>urn View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>Users with an age above 14 will <a id="_idTextAnchor1634"/>have access to any action methods under <code>OrdersController</code>, and <a id="_idIndexMarker1240"/>users older than 18 will only have access to the <code>Index</code> action.</p>
			<p>In the next section, we will learn how to create and use<a id="_idTextAnchor1635"/><a id="_idTextAnchor1636"/> a custom authorization attribute.</p>
			<h2 id="_idParaDest-254">Custom author<a id="_idTextAnchor1637"/>ization attributes</h2>
			<p>In the previous <a id="_idIndexMarker1241"/>example, a policy name with an age was passed as a string, but the code is not clean that way. It would be good if you could pass <code>age</code> as a parameter to the authorization attribute. For this, you need to create a custom authorization attribute inheriting the <code>AuthorizeAttribute</code> class.</p>
			<p>In the following sample code, the <code>AuthorizeAgeOverAttribute</code> class is inherited from the <code>AuthorizeAttribute</code> class. The constructor of this class accepts <code>age</code> as input. In the setter, we construct and s<a id="_idTextAnchor1638"/>et a policy name by concatenating <code>PREFIX</code> and <code>Age</code>:</p>
			<pre class="source-code">public class AuthorizeAgeOverAttribute : AuthorizeAttribute</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">const string PREFIX = "Over";</pre>
			<pre class="source-code">public AuthorizeAgeOverAttribute(int age) =&gt; Age = age;</pre>
			<pre class="source-code">public int Age</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    get</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                if </pre>
			<pre class="source-code">            (int.TryParse(Policy.Substring(PREFIX.Length), </pre>
			<pre class="source-code">            out var age))</pre>
			<pre class="source-code">                {</pre>
			<pre class="source-code">                    return age;</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">                return default(int);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            set</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                Policy = $"{PREFIX}{value.ToString()}";</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>To use the <code>AuthorizeAgeOver</code> attribute, we must register the <code>AuthorizationHandler</code> and <code>AuthorizationPolicyProvider</code> services in <code>Program.cs</code>. In the following code, the <code>MinimumAgeAuthorizationHandler</code> and <code>MinimumAgePolicyProvider</code> types <a id="_idIndexMarker1242"/>are registered as <code>Singleton</code> for <code>IAuthorizationHandler</code> and <code>IauthorizationPolicyProvider</code>, respectively:</p>
			<pre class="source-code">builder.Services.AddSingleton&lt;IAuthorizationHandler,</pre>
			<pre class="source-code">        MinimumAgeAuthorizationHandler&gt;();</pre>
			<pre class="source-code">builder.Services.AddSingleton&lt;IAuthorizationPolicyProvider,</pre>
			<pre class="source-code">        MinimumAgePolicyProvider&gt;();</pre>
			<p>Now that the custom attribute implementation is complete, we can use it on controller or action methods. In the following example, you can see a<a id="_idTextAnchor1639"/> sample implementation<a id="_idTextAnchor1640"/>, where age is passed as a parameter to our custom authorization attribute, <code>AuthorizeAgeOver</code>:</p>
			<pre class="source-code">[<strong class="bold">AuthorizeAgeOver</strong>(14)]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">[<strong class="bold">AuthorizeAgeOver</strong>(18)]</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the next section, we will learn how to configure roles in an Azure AD applicatio<a id="_idTextAnchor1641"/><a id="_idTextAnchor1642"/>n and use role-based<a id="_idIndexMarker1243"/> authentication.</p>
			<h1 id="_idParaDest-255">Authorization<a id="_idTextAnchor1643"/> in client and server applications</h1>
			<p>In previous<a id="_idIndexMarker1244"/> chapters, we<a id="_idIndexMarker1245"/> learned how to<a id="_idIndexMarker1246"/> use <strong class="bold">Azure Active Directory</strong> (<strong class="bold">AAD</strong>) as an identity service to authenticate users, but to use role-based authorization, we need to make a few configuration changes in Azure AD. In this section, we will see how to enable and create custom roles in an Azure AD application and do so in our e-commerce application to authorize users.</p>
			<p>When a user logs in to an application, Azure AD adds assigned roles and claims to the user's identity.</p>
			<p class="callout-heading">Prerequisites</p>
			<p class="callout">You should already have Azure AD and an AD app set up. If you don't, you can refer to the <em class="italic">Introduction to Azure Active Directory</em> section of <a href="B18507_12_Epub.xhtml#_idTextAnchor1389"><em class="italic">Chapter 12</em></a>, <em class="italic">Understanding Authentic<a id="_idTextAnchor1644"/>ation</em>, to get set up.</p>
			<p>Let's look into the ste<a id="_idTextAnchor1645"/>ps that need to be performed on an Azure AD application to enable roles:</p>
			<ol>
				<li value="1">In the Azure portal, navigate to your <strong class="bold">Active Directory</strong> tenant.</li>
				<li>In the left menu, <a id="_idTextAnchor1646"/>under <strong class="bold">Manage</strong>, select <strong class="bold">App registrations</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_13.3_B18507.jpg" alt="Figure 13.3 – Azure AD application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Azure AD application</p>
			<ol>
				<li value="3">Search<a id="_idIndexMarker1247"/> and <a id="_idIndexMarker1248"/>select your AD application from the <strong class="bold">App registrations</strong> <a id="_idTextAnchor1647"/>page. Refer to the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_13.4_B18507.jpg" alt="Figure 13.4 – Azure AD application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Az<a id="_idTextAnchor1648"/>ure AD application</p>
			<ol>
				<li value="4">Click on <strong class="bold">Manifes<a id="_idTextAnchor1649"/>t</strong> from the <a id="_idIndexMarker1249"/>left <a id="_idIndexMarker1250"/>menu to edit<a id="_idTextAnchor1650"/> it, as shown in the previous screenshot.</li>
			</ol>
			<div><div><img src="img/Figure_13.5_B18507.jpg" alt="Figure 13.5 – Editing the manifest&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 <a id="_idTextAnchor1651"/>– Editing the manifest</p>
			<ol>
				<li value="5">Locate <code>appR<a id="_idTextAnchor1652"/>oles</code> to<a id="_idIndexMarker1251"/> configure<a id="_idIndexMarker1252"/> multiple roles. Refer to the following code to add a role:<pre>{
"allowedMemberTypes": [
        "User"
    ],
    "description": "Admin Users",
    "displayName": "Admin",
    "id": "6ef9b400-0219-463c-a542-5f4693c4e286",
    "isEnabled": true,
    "lang": null,
    "origin": "Application",
    "value": "Admin"
}</pre></li>
			</ol>
			<p>You need to provide values for <code>displayName</code>, <code>value</code>, <code>description</code>, and <code>id</code>. The value for <code>id</code> is <code>Guid</code>, and it must be unique for each role you add. Similarly, for <code>value</code>, you need to provide the role name that you refer to in your code, and it should be unique.</p>
			<ol>
				<li value="6">Save th<a id="_idTextAnchor1653"/>e manifest to complete it.</li>
			</ol>
			<p>Saving a manifest <a id="_idIndexMarker1253"/>with<a id="_idIndexMarker1254"/> th<a id="_idTextAnchor1654"/>e required details will enable custom roles in an Azure AD application. In the next section, we will lea<a id="_idTextAnchor1655"/><a id="_idTextAnchor1656"/>rn how to assign users to these custom roles.</p>
			<h2 id="_idParaDest-256">Assigning r<a id="_idTextAnchor1657"/>oles to users</h2>
			<p>The next <a id="_idIndexMarker1255"/>step is to assign roles to<a id="_idIndexMarker1256"/> use<a id="_idTextAnchor1658"/>rs. The assignment of roles to users can be done using the Azure portal or programmatically using the Graph API. In this section, we'll use the Azure portal to assign roles, and the same can also be achieved using theGraph API. For more information, you can refer to <a href="https://docs.microsoft.com/en-us/graph/azuread-identity-access-management-concept-overview">https://docs.microsoft.com/en-us/graph/azuread-identity-access-management-concept-overview</a>:</p>
			<ol>
				<li value="1">In the Azure portal, navigate to the <strong class="bold">Azure Active Directory</strong> tenant.</li>
				<li>Click on <strong class="bold">Enterprise applications</strong> from the left menu and search for and select your AD application.</li>
				<li>Go to <strong class="bold">Manage</strong> | <strong class="bold">Users and Groups</strong> | <strong class="bold">Add User</strong>.</li>
				<li>Search for and select the user, and click on <strong class="bold">Ok</strong>.</li>
				<li>Click on <strong class="bold">Select Role</strong> to choose the role you want to assign.</li>
				<li>Click <strong class="bold">Assign</strong> to save the selection.</li>
			</ol>
			<p>You can continue these steps to assign roles to multiple users.</p>
			<p>To secure controllers or actions, you can add an <code>Authorize</code> attribute along with the roles. In the following code, the <code>Admin</code> controller is accessible only to users with the <code>Admin</code> role:</p>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public class AdminController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult <a id="_idTextAnchor1659"/>Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>So far, we have learned how to<a id="_idTextAnchor1660"/> enable roles in Azure AD and use the role-based model for <a id="_idIndexMarker1257"/>authorization. In the next section, we<a id="_idIndexMarker1258"/> will see how to access rol<a id="_idTextAnchor1661"/><a id="_idTextAnchor1662"/>es and claims using the user's identity in vi<a id="_idTextAnchor1663"/>ews.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor1664"/>User identity in views</h2>
			<p>A user claim<a id="_idIndexMarker1259"/> principle can be used in views<a id="_idIndexMarker1260"/> to conditionally show or hide data as required. For example, the following code checks the <code>IsAuthenticated</code> property of the user identity to determine whether the user is authenticated or not. If the user is not authenticated, a link to <code>Sign in</code> is displayed; otherwise, the username with a <code>Sign out</code> link is displayed:</p>
			<pre class="source-code">&lt;ul class="navbar-nav"&gt;</pre>
			<pre class="source-code">    @if (User.Identity.<strong class="bold">IsAuthenticated</strong>)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        //// HTML code goes here</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  <a id="_idTextAnchor1665"/>  else</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        ////</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">&lt;/ul&gt;</pre>
			<p>Similarly, we can use <code>IsInRole</code> or <code>HasClaim</code> and write our logic to show content to or hide content from the user:</p>
			<pre class="source-code">@if (User.<strong class="bold">HasClaim</strong>(x =&gt; x.Type == "PremiumUser"))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    &lt;h1&gt;Yay, you are Premium User!!!, @User.<strong class="bold">FindFirst</strong>(x =&gt; x.Type == ClaimTypes.Country)?.Value&lt;/h1&gt;</pre>
			<pre class="source-code">}</pre>
			<p>For <a id="_idIndexMarker1261"/>more<a id="_idIndexMarker1262"/> details, you can refer to <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-add-app-roles-in-azure-ad-apps">https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-add-app-roles-in-azure-ad-apps</a>.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor1668"/>Summary</h1>
			<p>In this chapter, we learned what authorization is and the different ways to implement it using the ASP.NET Core framework. We learned how to restrict or anonymously allow users to access resources using simple, declarative role- and claims-based models, and we learned how to implement custom logic to authorize user requests using a rich policy-based authorization model.</p>
			<p>We learned how to dynamically add authorization policies using authorization policy providers and build custom authorized attributes. We also learned how to configure custom roles in Azure AD and use them in an ASP.NET Core application. Depending on your authorization requirements, you can use one or more authorization models to secure your applications.</p>
			<p>In the next chapter, we will learn how to monitor the h<a id="_idTextAnchor1669"/><a id="_idTextAnchor1670"/>ealth and performance of an ASP.NET Core application.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor1671"/>Questions</h1>
			<p>After reading the chapter, you should be able to answer the following questions:</p>
			<ol>
				<li value="1">Which of the following is the primary service that determines whether authorization is successful or not?</li>
			</ol>
			<p>a. <code>IAuthorizationHandler</code></p>
			<p>b. <code>IAuthorizationRequirement</code></p>
			<p>c. <code>IAuthorizationService</code></p>
			<p>d.<code>IAuthorizationPolicyProvider</code></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="2">In the following code, access to the <code>Support</code> action is restricted to only the <code>Support</code> role:<pre>[AllowAnonymous]
public class HomeController : Controller
{
      public IactionResult Index()
{
    return View();
}
[Authorize(Roles ="Support")]
public IactionResult Support()
{
        return View();
}
}</pre></li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor1672"/>Further reading</h1>
			<p>To learn more about authorization, you can refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/introduction?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/introduction?view=aspnetcore-6.0</a>.</p>
		</div>
	</body></html>