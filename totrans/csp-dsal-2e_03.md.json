["```cs\ntype[] name;\n```", "```cs\nnew operator, as shown here:\n\n```", "```cs\n\n Of course, you can combine a declaration and initialization in the same line, as follows:\n\n```", "```cs\n\n Unfortunately, all the elements currently have default values – that is, zeros in the case of integer values. Thus, you need to set the values of particular elements. You can do this using the `[]` operator and an index of an element, as shown in the following code:\n\n```", "```cs\n\n Moreover, you can combine a declaration and initialization of array elements to specific values using one of the following variants:\n\n```", "```cs\n\n Another approach involves using the **collection expression**, as follows:\n\n```", "```cs\nint middle = 2) from the numbers array and store it as a value of the middle variable.\nThe array has some properties that can be useful while developing applications. For example, the `Length` property makes it possible to get the size of the array, namely the number of elements stored within it. If you want to access the last item in the array, regardless of its size, you can use the following line of code:\n\n```", "```cs\n\n You can simplify this with the **index operator**, as follows:\n\n```", "```cs\nint rank = numbers.Array class, such as Exists, to check whether there is any element in the array that matches the given predicate. For example, you can easily verify whether the array contains any element whose value is greater than zero, as follows:\n\n```", "```cs\nbool noZeros = Array.Find method:\n\n```", "```cs\nint[] negatives = Array.IndexOf method, which returns an index of the first found occurrence of the value or -1, if not found:\n\n```", "```cs\nArray.ForEach(numbers, \n    e => Console.WriteLine(Math.Abs(e)));\n```", "```cs\nArray.Sort method has even more variants. In its simplest form, it sorts the whole array. After running the following line, you’ll get the array with the elements sorted from the smallest to the biggest:\n\n```", "```cs\nArray.Clear, which makes it possible to clear the whole array or a range of its elements. For example, you can fill the whole array with the default value of the integer type, namely zeros, using the following line of code:\n\n```", "```cs\nint[] subarray = new int[3];\nArray.Contains and Max.\nHave you ever heard about extension methods?\nIf not, think of them as methods that are “added” to a particular existing type (both built-in or user-defined) and can be called in the same way as when they are defined directly as instance methods. The declaration of an extension method requires you to specify it within a static class as a static method with the first parameter indicating the type to which you want to “add” this method with the `this` keyword.\nYou can use the `Contains` extension method to check whether the array contains an element passed as the parameter. As an example, let’s learn how to ensure that the `numbers` array contains `6` as one of its elements:\n\n```", "```cs\nbool noZeros = numbers.All(n => n != 0);\nbool anyPositive = numbers.Min and Max extension methods, as shown here:\n\n```", "```cs\ndouble avg = numbers.Average();\nint sum = numbers.Sum();\n```", "```cs\nusing System.Globalization;\nCultureInfo culture = new(\"en\");\nstring[] months = new string[12];\nfor (int month = 1; month <= 12; month++)\n{\n    DateTime firstDay = new(DateTime.Now.Year, month, 1);\n    string name = firstDay.ToString(\"MMMM\", culture);\n    months[month - 1] = name;\n}\nforeach (string m in months)\n{\n    Console.WriteLine(m);\n}\n```", "```cs\nJanuary\nFebruary (...)\nDecember\n```", "```cs\nint[,] numbers = new int[5, 3];\nnumbers[0, 0] = 9; (...)\n```", "```cs\nint[,] numbers = new int[,]\n{ \n    { 9, 5, -9 }, \n{ -11, 4, 0 }, \n{ 6, 115, 3 }, \n{ -12, -9, 71 }, \n    { 1, -6, -1 } \n};\n```", "```cs\nint number = numbers[2, 1];\nnumbers2) and second column (index equal to 1) is obtained (that is, 115) and set as a value of the number variable. The other line replaces -11 with 11 in the second row and the first column.\nNow that you’ve learned about one-dimensional and two-dimensional arrays, let’s proceed to three-dimensional ones. Do you know how to understand this structure?\nImagine a three-dimensional array\nIf you want to better imagine a three-dimensional array, launch a game in which you can create buildings from blocks. You place each of them in a specified location on the board, in *X* and *Y* coordinates. However, you can also build the next building floors, so you can specify the block’s *Z* coordinate as well. In such circumstances, you operate in a three-dimensional world with three-dimensional arrays!\nAn example three-dimensional array is presented in the following figure:\n![Figure 3.3 – Example of a three-dimensional array](img/B18069_03_03.jpg)\n\nFigure 3.3 – Example of a three-dimensional array\nIf you want to create a three-dimensional array, you can use the following code:\n\n```", "```cs\n\n The remaining operations can be performed similarly as in the case of arrays with a different number of dimensions. Of course, you need to specify three indices while accessing a particular element of the array.\nSo far, you’ve learned about one-, two-, and three-dimensional arrays. But is it possible to use four-dimensional arrays? Of course!\nImagine a four-dimensional array\nImagining a four-dimensional array is not very easy, but let’s try to do so! Once again, think about the three-dimensional game board we mentioned previously, but with content that changes depending on your level in the game. In this way, you can access a particular block in the three-dimensional world using *X*, *Y*, and *Z* coordinates. To get a target value, you need to use another dimension, namely by providing your current level. In this way, you will get different results depending on the fourth dimension. Not so difficult, right?\nYou can declare such an array using the following line of code:\n\n```", "```cs\n\n If you need more dimensions, you can apply them. However, please keep in mind that using more dimensions can be quite difficult to understand and your code can be more difficult to follow and maintain in the future.\nWith this introduction to the topic of multi-dimensional arrays out of the way, let’s proceed to some examples. They will show you how to use such data structures in the real world.\nExample – multiplication table\nThis first example shows basic operations being performed on a two-dimensional array to present a multiplication table. It stores the results of the multiplication of all integer values in the range from `1` to `10` in the array and present them in the console:\n\n```", "```cs\n\n Let’s take a look at the declaration and initialization of the array:\n\n```", "```cs\n\n Here, a two-dimensional array with `10` rows and `10` columns is created and its elements are initialized to default values – that is, to zeros. When the array is ready, you fill it with the results of the multiplication, as well as present the result in the console. Such a task can be performed using two `for` loops, as shown here:\n\n```", "```cs\n\n In the preceding code, you can see the `GetLength` method, which is called on the `results` array. This method returns the number of elements in a particular dimension – that is, the first (when passing `0` as the parameter) and the second (`1` as the parameter). In both cases, a value of `10` is returned, according to the values specified during the array’s initialization. Another important part of the code is the way of setting the value of an element. To do so, you must provide two indices.\nThe multiplication results, after converting them into `string` values, have different lengths, from one character (as in the case of `4` as a result of `2*2`) to three (`100` from `10*10`). To improve their presentation, you need to write each result in `4` characters. Therefore, if an integer value takes less space, leading spaces should be added. As an example, `1` will be shown with three leading spaces (`___1`, where `_` is a space), while `100` will be shown with only one space (`_100`). You can achieve this goal by using a proper composite format string (namely, `,4`) within the interpolated string.\nExample – game map\nAnother example is a program that presents a map of a game. This map is a rectangle with 6 rows and 8 columns. Each element of the array specifies a type of terrain as grass, sand, water, or brick (also referred to as wall). Each place on the map should be shown in a particular color (such as green for grass), as well as using a custom character that depicts the terrain type (such as `≈` for water), as shown in the following figure:\n![Figure 3.4 – ﻿Screenshot of the game map example](img/B18069_03_04.jpg)\n\nFigure 3.4 – Screenshot of the game map example\nLet’s start by creating two auxiliary methods that make it possible to get a particular color and character depending on the terrain’s type (`GetColor` and `GetChar`, respectively). The code for these methods is as follows:\n\n```", "```cs\n\n As you can see, the code of the `GetColor` method is self-explanatory. However, the `GetChar` method returns a proper Unicode character depending on the character’s value (`g`, `s`, `w`, or `b`). For example, in the case of water, the `'\\u2248'` value is returned, which is a representation of the `≈` character.\nLet’s take a look at the remaining part of the code. Here, you configure the map, as well as present it in the console. The code is as follows:\n\n```", "```cs\n\n This code should not require additional comments or explanations. Just keep in mind that to use Unicode values in the console output, don’t forget to choose the UTF-8 encoding by setting the `Encoding.UTF8` value for the `OutputEncoding` property. You can set the foreground color for the console using the `ForegroundColor` property. If you want to reset such a color to the default one, just call the `ResetColor` method, as presented in the last line.\nSo far, you’ve learned about both single- and multi-dimensional arrays, but one more variant remains to be presented in this book, namely jagged arrays. Let’s continue reading to learn more about them.\nJagged arrays\nThe last variant of arrays to be described in this book is **jagged arrays**, also referred to as an **array of arrays**. It sounds complicated, but fortunately, it is very simple. A jagged array can be understood as **a single-dimensional array, where each element is another array**. Of course, such inner arrays can have different lengths or they can even be not initialized.\nImagine a jagged array\nIf you want to better imagine a jagged array, stop reading this book for a moment, open your calendar, and switch its view so that it presents the whole year. It contains 365 or 366 boxes, depending on the year. For each day, you have a different number of meetings. On some days, you have three meetings, while on others, only one or even zero. Your holidays are marked in the calendar and blocked for meetings. You can easily imagine an application of a jagged array in this case. Each day box is an element of this array and it contains an array with data of meetings organized on a particular day. If this day is during your holidays, a related item is not initialized. This makes a jagged array much easier to visualize.\nAn example jagged array is presented in the following figure:\n![Figure 3.5 – Example of a jagged array](img/B18069_03_05.jpg)\n\nFigure 3.5 – Example of a jagged array\nThis jagged array contains four elements. The first has an array with two elements (`9` and `5`). The second element has an array with three elements (`0`, `-3`, and `12`). The third is not initialized (`null`), while the last one is an array with only one element (`54`).\nBefore proceeding to the example, it is worth mentioning the way of declaring and initializing a jagged array since it is a bit different from the arrays we’ve already described. Let’s take a look at the following code snippet:\n\n```", "```cs\n\n This code can be simplified with a collection expression, as follows:\n\n```", "```cs\nint[][] numbers =\n{\n    new int[] { 9, 5 },\n    new int[] { 0, -3, 12 },\n    null!,\n    new int[] { 54 }\n};\n```", "```cs\nint[][] numbers =\n[\n    [9, 5],\n    [0, -3, 12],\n    null!,\n    [54]\n];\n```", "```cs\nint number = numbers[1][2];\nnumbersnumber variable to 12 – that is, to the value of the third element (index equal to 2) from the array, which is the second element of the jagged array. The other line changes the value of the second element within the array, which is the second element of the jagged array, from -3 to 50.\nNow that we’ve introduced jagged arrays, let’s look at an example.\nExample – yearly transport plan\nIn this example, you’ll learn how to develop a program that creates a plan for your transportation for the whole year. For each day of each month, the application draws one of the available means of transport, such as by car, by bus, by subway, by bike, or simply on foot. In the end, the program presents the generated plan, as shown in the following screenshot:\n![Figure 3.6 – Screenshot of the yearly transport plan example](img/B18069_03_06.jpg)\n\nFigure 3.6 – Screenshot of the yearly transport plan example\nFirst, let’s declare the enumeration type with constants representing types of transport:\n\n```", "```cs\n\n The next part of the code is as follows:\n\n```", "```cs\n\n First, a new instance of the `Random` class is created. This will be used to draw a suitable means of transport from the available ones. In the next line, we get the number of available transport types. Then, the jagged array is created. It is assumed that it has `12` elements, representing all months in the current year.\nNext, a `for` loop is used to iterate through all the months within the year. In each iteration, the number of days is obtained using the `DaysInMonth` static method of `DateTime`. Each element of the jagged array is a single-dimensional array with `MeanEnum` values. The length of such an inner array depends on the number of days in a month. For instance, it is set to `31` elements for January and `30` elements for April.\nThe next `for` loop iterates through all the days of the month. Within this loop, you draw a transport type and set it as a value of a suitable element within an array that is an element of the jagged array.\nThe next part of the code is related to presenting the plan in the console:\n\n```", "```cs\n\n First, a single-dimensional array with month names is created using the `GetMonthNames` method, which will be presented and described later. Then, a value of the `nameLength` variable is set to the maximum necessary length of text for storing the month name. To do so, the `Max` extension method is used to find the maximum length of text from the collection with names of months. The obtained result is increased by `2` to reserve space for a colon and a space.\nA `for` loop is used to iterate through all the elements of the jagged array – that is, through all months. In each iteration, the month’s name is presented in the console. The next `for` loop is used to iterate through all the items of the current element of the jagged array – that is, through all the days of the month. For each day, proper colors are set (for the foreground and background), and a suitable character is shown. Both a color and a character are returned by the `Get` method, taking the `MeanEnum` value as a parameter. This method will be shown a bit later.\nNow, let’s take a look at the implementation of the `GetMonthNames` method:\n\n```", "```cs\n\n This code is self-explanatory, but let’s focus on the line where we call the `Range` method. It returns a collection of integer values from `1` to `12`. Therefore, we can use it together with the `foreach` loop, instead of a simple `for` loop iterating from `1` to `12`. Just think about it as an alternative way of solving the same problem.\nFinally, it is worth mentioning the `Get` method. It allows us to use one method instead of two, namely returning a character and a color for a given transport type. By returning data as a value tuple, the code is shorter and simpler, as shown here:\n\n```", "```cs\n\n Arrays are everywhere in this chapter! Now that we’ve learned about this data structure and its C# implementation-related topics, we can focus on some algorithms that are strictly related to arrays, namely sorting algorithms. Are you ready to get to know a few of them? If so, let’s proceed to the next section.\nSorting algorithms\nMany algorithms use arrays for a very broad range of applications. However, one of the most common tasks is **sorting an array to arrange its elements in the correct order, either ascending or descending**. Of course, you can sort data of various types, including numbers, strings, or even instances of user-defined classes. However, to keep things a bit simpler, here, we will only focus on sorting integer values.\nImagine a sorting algorithm\nYou benefit from the sorting procedure frequently in your daily life! For example, your inbox is sorted in a way to present the newest messages first (by sending date in descending order), your calendar presents a day plan sorted by hours (by event start date in ascending order), as well as your list of tasks shows entries from the most important to the least important (by priority in descending order). That’s not all – at work, you sort documents by their issue date, then you choose a suitable road to home from the variants sorted by time to reach the destination, and in the evening, you change programs on the TV using a remote control according to the predefined order of channels.\nSorting algorithms involve many approaches and are also a popular subject of research. There are a lot of sorting types, including selection sort, insertion sort, bubble sort, merge sort, Shell sort, quicksort, and heap sort. These will be explained in detail in this chapter. However, these are not all of the available approaches. Various types differ in their performance results, which is one of the most important aspects that you should take into account while choosing your sorting implementation. This topic will be analyzed at the end of this chapter to give you some tips in this area.\nWhere can you find more information?\nArray sorting is a popular topic that’s presented in various resources in books and research papers, as well as online. For example, you can read more about sorting algorithms presented in this chapter at Wikipedia, as well as you can take a look at some implementation codes at Wikibooks. You can browse for more information about the merge sort at [https://en.wikipedia.org/wiki/Merge_sort](https://en.wikipedia.org/wiki/Merge_sort) and [https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort), about Shell sort at [https://en.wikipedia.org/wiki/Shellsort](https://en.wikipedia.org/wiki/Shellsort) and [https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort), about quicksort at [https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort) and [https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort), and about heap sort at [https://en.wikipedia.org/wiki/Heapsort](https://en.wikipedia.org/wiki/Heapsort) and [https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort). In a similar way, you can find information about other sorting algorithms. Of course, Wikipedia, together with Wikibooks, is not the only available source of content regarding such algorithms. There are a huge number of websites dedicated to this subject. Some of them also contain animations that show how various algorithms operate. This can help you visualize how they work.\nSelection sort\nLet’s start with **selection sort**, which is one of the simplest sorting algorithms. **This algorithm divides the array into two parts, namely sorted and unsorted**. First, the sorted part is empty. In the following iterations, **the algorithm finds the smallest element in the unsorted part and exchanges it with the first element in the unsorted part**. Thus, the sorted part increases by one element. This sounds quite simple, doesn’t it?\nTo better understand the selection sort algorithm, let’s take a look at the following iterations for an array with nine elements (`-11`, `12`, `-42`, `0`, `1`, `90`, `68`, `6`, and `-9`), as shown in the following figure:\n![Figure 3.7 – Illustration of the selection sort algorithm](img/B18069_03_07.jpg)\n\nFigure 3.7 – Illustration of the selection sort algorithm\nBold lines are used to present the borders between the sorted and unsorted parts of the array. First (*Step 1*), the border is located just at the top of the array, which means that the sorted part is empty. Here, the algorithm finds the smallest value in the unsorted part (namely `-42`) and swaps it with the first element in this part (`-11`). The result is shown in *Step 2*, where the sorted part contains one element (`-42`), while the unsorted part consists of eight elements. In the next step, the algorithm finds `-11` as the smallest value in the unsorted part and swaps it with `12`, which is the first element in the unsorted part. As a result, the sorted part consists of two elements, namely `-42` and `-11`, while the unsorted part contains only seven elements, as shown in *Step 3*. The aforementioned steps are performed a few times until only one element is left in the unsorted part. The final result is shown in *Step 9*.\nWith that, you know how the selection sort algorithm works, but what role is performed by the `i` and `m` indicators shown on the left in the preceding diagram? They are related to the variables that are used in the implementation of this algorithm. So, it is time to see the code in the C# language!\nThe implementation is created within the `Sort` method, which takes the `a` array as the parameter and sorts it using selection sort:\n\n```", "```cs\n\n A `for` loop is used to iterate through the elements until only one item is left in the unsorted part. Thus, the number of iterations of the loop is equal to the length of the array minus one (`a.Length - 1`). In each iteration, another `for` loop is used to find the smallest value in the unsorted part (`minValue`, from the `i + 1` index until the end of the array), as well as to store an index of the smallest value (`minIndex`, referred to as the `m` indicator in the preceding diagram). Finally, the smallest element in the unsorted part (with an index equal to `minIndex`) is swapped with the first element in the unsorted part (the `i` index).\nThat’s all! Let’s use the following code to test the implementation of the selection sort algorithm:\n\n```", "```cs\n\n In the preceding code, an array is declared and initialized. Then, the `Sort` method is called, passing the `array` as a parameter. Finally, the `string` value is created by joining elements of the array, separated by `|`. The result is shown in the console:\n\n```", "```cs\n\n Since we’re talking about various algorithms, one of the most important topics is computational complexity, especially time complexity. In the case of selection sort, both `for` loops (one within the other), each iterating through many elements of the array, which contains *n* elements. For this reason, the complexity is indicated as *O(n*2*)*.\nA small reminder about computational complexity\nYou learned about computational complexity in the previous chapter. As a quick reminder, there are a few variants, such as for the worst or average case. This complexity can be interpreted as the number of basic operations that need to be performed by the algorithm, depending on the input size (*n*). The time complexity can be specified using Big O notation – for example, as *O(n)*, *O(n*2*)*, *O(n log(n))* or *O(1)*. As an example, the *O(n)* notation indicates that the number of operations increases linearly with the input size (*n*).\nWith that, you’ve learned about selection sort. If you are interested in another approach to sorting, proceed to the next section, where insertion sort is presented.\nInsertion sort\n**Insertion sort** is another algorithm that makes it possible to sort a single-dimensional array simply. Here, **the array is divided into two parts, namely sorted and unsorted**. However, at the beginning, the first element is included in the sorted part. In each iteration, **the algorithm takes the first element from the unsorted part and places it in a suitable location within the sorted part, to leave the sorted part in the correct order**. Such operations are repeated until the unsorted part is empty.\nAs an example, let’s take a look at an illustration of sorting an array with nine elements (`-11`, `12`, `-42`, `0`, `1`, `90`, `68`, `6`, and `-9`) using insertion sort:\n![Figure 3.8 – Illustration of the insertion sort algorithm](img/B18069_03_08.jpg)\n\nFigure 3.8 – Illustration of the insertion sort algorithm\nFirst, only one element (namely `-11`) is located in the sorted part (*Step 1*). Then, you take the first element from the unsorted part (`12`). In this case, the location of this element does not need to be changed, so the sorted part is increased to two elements, namely `-11` and `12`. Then, you take `-42` as the first element in the unsorted part and you move it to the correct location in the sorted part. To do so, you need to perform two swap operations, as shown in *Step 2*. Thus, the length of the sorted part is increased to three elements, namely `-42`, `-11`, and `12`. In *Step 3*, you take `0` as the first element from the unsorted part and perform one swap operation to place it in the correct position, just before `12`, as presented in *Step 4*. At the same time, the size of the sorted part is increased to four already sorted elements, namely `-42`, `-11`, `0`, and `12`. Such operations are repeated until the unsorted part is empty (*Step 9*).\nThe implementation code for the insertion sort algorithm is very simple:\n\n```", "```cs\n\n A `for` loop is used to iterate through all elements in the unsorted part. Thus, the initial value of the `i` variable is set to `1`, instead of `0`, because the unsorted part contains one element at the beginning. In each iteration of the `for` loop, a `while` loop is executed to move the first element from the unsorted part of the array (with the index equal to `i`) to the correct location within the sorted part, by swapping.\nFinally, it is worth mentioning the time complexity of the insertion sort algorithm. Similarly, as in the case of the selection sort, both `for` and `while`) placed one within the other, which could iterate multiple times, depending on the input size (*n*).\nBubble sort\nThe third sorting algorithm we’ll cover is **bubble sort**. Its way of operation is very simple. **The algorithm just iterates through the array and compares adjacent elements. If they are located in an incorrect order, they are swapped.** It sounds very easy, doesn’t it? Unfortunately, the algorithm is not efficient and its usage with large collections can cause performance-related problems.\nTo better understand how the algorithm works, let’s take a look at the following figure, which shows how the algorithm operates in the case of sorting a single-dimensional array with nine elements (`-11`, `12`, `-42`, `0`, `1`, `90`, `68`, `6`, and `-9`):\n![Figure 3.9 – Illustration of the bubble sort algorithm](img/B18069_03_09.jpg)\n\nFigure 3.9 – Illustration of the bubble sort algorithm\nIn each step, the algorithm compares two adjacent elements in the array and swaps them, if necessary. For example, in *Step 1*, `-11` and `12` are compared. They are placed in the correct order, so it is not necessary to swap such elements. In *Step 2*, the next adjacent elements are compared (namely `12` and `-42`). This time, such elements are not placed in the correct order, so they are swapped. The aforementioned operations are performed many times. Finally, the array is sorted, as shown in *Step 72*.\nThe algorithm seems to be very easy, but what about its implementation? Is it also simple? Fortunately, yes! You just need to use two loops, compare adjacent elements, and swap them if necessary. That’s all! Let's take a look at the following code snippet:\n\n```", "```cs\n\n Here, two `for` loops are used, together with a comparison and swapping. As mentioned previously, this algorithm is not efficient and its application can cause problems related to performance, especially in the case of large collections of data. However, it is possible to use a bit more efficient version of the bubble sort algorithm by introducing a simple modification. It is based on the assumption that **comparisons should be stopped when no changes are discovered during one iteration through the array**. The code is as follows:\n\n```", "```cs\n\n By introducing such a simple modification, the number of steps can decrease. In the preceding example, it decreases from 72 steps to 56 steps.\nBefore moving on to the next sorting algorithm, it is worth mentioning the time complexity of the bubble sort algorithm. As you may have already guessed, **both worst and average cases** are the same as in the case of the selection and insertion sort algorithms – that is, **O(n**2**)**.\nMerge sort\nThe fourth sorting algorithm operates in a significantly different way than the three already presented. This approach is named **merge sort**. **This algorithm recursively splits the array in half until the array contains only one element, which is sorted. Then, the algorithm merges the already sorted subarrays (starting with these with only one element) into the sorted array.** Finally, the whole array is sorted and the algorithm stops its operation.\nTo better understand the merge sort algorithm, let’s take a look at the following iterations for an array with six elements (`-11`, `12`, `-42`, `0`, `90`, and `-9`):\n![Figure 3.10 – Illustration of the merge sort algorithm](img/B18069_03_10.jpg)\n\nFigure 3.10 – Illustration of the merge sort algorithm\nFirst (*Step 1*), you have the whole unsorted array, which you split into two parts, namely (`-11`, `12`, `-42`) and (`0`, `90`, `-9`), as shown in *Step 2*. In the next step, each of these subarrays is further split into (`-11`), (`12`, `-42`), (`0`), and (`90`, `-9`). In *Step 4*, you have the whole array divided into the subarrays with only one element each, namely (`-11`), (`12`), (`-42`), (`0`), (`90`), and (`-9`). Next, you merge all of these subarrays, together with sorting. Thus, in *Step 5*, you have three subarrays – that is, (`-11`, `12`), (`-42`, `0`), and (`-9`, `90`). Please keep in mind that these subarrays are already sorted. In *Step 6*, you need to merge and sort them further into (`-42`, `-11`, `0`, `12`) and (`-9`, `90`). Finally, you have the whole array sorted, namely (`-42`, `-11`, `-9`, `0`, `12`, `90`).\nDoes this seem simpler than just reading the textual description of the algorithm?  If so, let’s proceed to its implementation:\n\n```", "```cs\n\n The `Sort` method is called `a`. To stop infinitely calling this method recursively, you must specify the stop condition at the beginning. It simply checks whether the size of the array is not greater than 1\\. It is related to the assumption that you cannot further divide an array with one element only, because it is already sorted.\nNext, you calculate an index of the middle element and store it as a value of `m`. In the following two lines, you call the auxiliary `GetSubarray` method, which creates a new array with only a part of elements, either from its left-hand side (with indices from `0` to `m-1`, stored as `left`) or the right-hand side (from `m` to the length of the array minus 1, stored as `right`). You will see its implementation after the explanation of the `Sort` method. Coming back to the explanation of the `Sort` method, you then recursively call the `Sort` method, passing the `left` and `right` subarrays.\nThe remaining part of the code is related to merging subarrays into the whole sorted array. Of course, this procedure is performed step by step, merging the subarrays into bigger and bigger subarrays until the whole array is sorted. You use a `while` loop to iterate through the `left` and `right` subarrays. You use three auxiliary variables, namely `i` as an index of the currently analyzed element from the `left` array, `j` from the `right` array, and `k` from the `a` array. Initially, all of them are set to `0`, so you keep an eye on the first element of the `left`, `right`, and `a` arrays.\nWithin the `while` loop, you check whether the current element from the `left` array (with the `i` index) is not greater than the current element from the `right` array (with the `j` index). If so, you place the current element from the `left` array as the first element in the `a` array. You also increase the `i` index, which means that the second element from the `left` array is the current one. If this condition is not met – that is, the current element from the `right` array is smaller than the current element from the `left` array – you use the current element from the `right` array as the first element in the `a` array and increase the `j` index. Finally, you increase the `k` index to keep an eye on the second element from the `a` array. The `while` loop ends when you are out of bounds of either the `left` or `right` array.\nWhat about when some elements haven’t been analyzed yet from the `left` or `right` arrays? To handle such cases, you use two additional `while` loops. These allow you to place the remaining elements from either the `left` or `right` array on the remaining places in the `a` array. As you can see, the `Sort` method is equipped with a very simple way of merging two arrays into one, together with their sorting.\nWhile explaining the algorithm’s implementation, the `GetSubarray` auxiliary method was mentioned. So, let’s show its code, together with a short explanation:\n\n```", "```cs\n\n This method uses the `Copy` static method of the `Array` class to copy a part of the source array (`a`) to the declared and initialized here destination array (`result`). To perform this task, you need to take the correct number of elements, namely `ei` `–` `si` `+` `1`. Here, `ei` stands for *end index* and `si` stands for *start index*. You need to copy elements between arrays starting with the `si` index in the source array (`a`) and store them starting from the `0` index in the destination array (`result`).\nOf course, you can fill a subarray in different ways, such as using a `for` loop, which iterates through elements and copies them accordingly. If you want, you can prepare the alternative implementation on your own and then compare it during the performance tests, which you will see later in this chapter.\nWhat about the time complexity? It’s not very easy to specify it in the case of the merge sort algorithm compared to the other sorting algorithms I’ve presented. However, its time complexity is much better and can be indicated as **O(n log(n))** **for both average and worst cases**. You will see what this means in practice while analyzing the performance results.\nHowever, you still have some algorithms to learn about, so let’s proceed to the next one.\nShell sort\nA different approach to sorting is used in the **Shell sort** algorithm, whose name comes from its author’s name. It is a variation of the already presented insertion sort. **The algorithm performs h-****sorting** **to sort virtual subarrays consisting of elements with a distance equal to h, using the insertion sort. At the beginning, h is set to half of the array’s length and is divided by 2 in each iteration, until it is equal to 1.** This description can seem a bit complicated, but it is a surprisingly efficient algorithm with a very simple implementation.\nFirst, let’s take a look at a figure that should make this topic much simpler and easier to understand than just the plain text:\n![Figure 3.11 – Illustration of the Shell sort algorithm](img/B18069_03_11.jpg)\n\nFigure 3.11 – Illustration of the Shell sort algorithm\nAs the source array contains 7 elements, the initial `h` value is set to `3`. So, now, it is time for `0`, `3`, `6`), (`1`, `4`), and (`2`, `5`). The first virtual subarray consists of (`-11`, `-15`, `-13`), so you sort it and receive (`-15`, `-13`, `-11`). The second is (`12`, `-4`) and forms (`-4`, `12`) after sorting. The last is (`13`, `-9`) and is sorted into (`-9`, `13`). When 3-sorting is completed, you calculate the next *h* value, simply by dividing the current value by 2\\. The result is 1 and it is also the last *h*-sorting iteration, namely **1-sorting**. Now, you perform a simple insertion sort.\nThe illustration and description look pretty simple, don’t they? Let's write some C# code to implement the Shell sort algorithm, as shown below:\n\n```", "```cs\nvoid Sort(int[] a)\n{\n    SortPart(a, 0, a.Length - 1);\n}\n```", "```cs\nvoid SortPart(int[] a, int l, int u)\n{\n    if (l >= u) { return; }\n    int pivot = a[u];\n    int j = l - 1;\n    for (int i = l; i < u; i++)\n    {\n        if (a[i] < pivot)\n        {\n            j++;\n            (a[j], a[i]) = (a[i], a[j]);\n        }\n    }\n    int p = j + 1;\n    (a[p], a[u]) = (a[u], a[p]);\n    SortPart(a, l, p - 1);\n    SortPart(a, p + 1, u);\n}\n```", "```cs\nvoid Sort(int[] a)\n{\n    for (int i = a.Length / 2 - 1; i >= 0; i--)\n    {\n        Heapify(a, a.Length, i);\n    }\n    for (int i = a.Length - 1; i > 0; i--)\n    {\n        (a[0], a[i]) = (a[i], a[0]);\n        Heapify(a, i, 0);\n    }\n}\n```", "```cs\nvoid Heapify(int[] a, int n, int i)\n{\n    int max = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    max = l < n && a[l] > a[max] ? l : max;\n    max = r < n && a[r] > a[max] ? r : max;\n    if (max != i)\n    {\n        (a[i], a[max]) = (a[max], a[i]);\n        Heapify(a, n, max);\n    }\n}\n```", "```cs\npublic abstract class AbstractSort\n{\n    public abstract void Sort(int[] a);\n}\n```", "```cs\npublic class SelectionSort\n    : AbstractSort\n{\n    public override void Sort(int[] a) { (...) }\n}\n```", "```cs\nList<AbstractSort> algorithms = new()\n{\n    new SelectionSort(),\n    new InsertionSort(),\n    new BubbleSort(),\n    new MergeSort(),\n    new ShellSort(),\nnew QuickSort(),\n    new HeapSort()\n};\n```", "```cs\nfor (int n = 0; n <= 100000; n += 10000)\n{\n    Console.WriteLine($\"\\nRunning tests for n = {n}:\");\n    List<(Type Type, long Ms)> milliseconds = [];\n    for (int i = 0; i < 5; i++)\n    {\n        int[] array = GetRandomArray(n);\n        int[] input = new int[n];\n        foreach (AbstractSort algorithm in algorithms)\n        {\n            array.CopyTo(input, 0);\n            Stopwatch stopwatch = Stopwatch.StartNew();\n            algorithm.Sort(input);\n            stopwatch.Stop();\n            Type type = algorithm.GetType();\n            long ms = stopwatch.ElapsedMilliseconds;\n            milliseconds.Add((type, ms));\n        }\n    }\n    List<(Type, double)> results = milliseconds\n        .GroupBy(r => r.Type)\n        .Select(r =>\n            (r.Key, r.Average(t => t.Ms))).ToList();\n    foreach ((Type type, double avg) in results)\n    {\n        Console.WriteLine($\"{type.Name}: {avg} ms\");\n    }\n}\n```", "```cs\nint[] GetRandomArray(long length)\n{\n    Random random = new();\n    int[] array = new int[length];\n    for (int i = 0; i < length; i++) \n    {\n        array[i] = random.Next(-100000, 100000);\n    }\n    return array;\n}\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```"]