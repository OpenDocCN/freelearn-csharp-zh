<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>Building Our First .NET Core Game &amp;#x2013; Tic-Tac-Toe</title>
    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building Our First .NET Core Game â€“ Tic-Tac-Toe</h1>
                </header>
            
            <article>
                
<p>Learning is more fun if we do it while playing games. With this thought, let's continue our quest to learn .NET Core 2.0 by writing our very first game in .NET Core 2.0, Tic-Tac-Toe. In this chapter, we will understand the anatomy of the ASP.NET Core 2.0 application that we created in <a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>, and understand each file and its purpose in the application. Then, we will quickly understand the basics of SignalR Core, which is the technology we will use to write the game in .NET Core 2.0. We will then proceed with the quick setup of SignalR Core, followed by the design and coding of the basic Tic-Tac-Toe game, in which players can specify their own images instead of conventional <em>X</em> and <em>O</em>.</p>
<p>Here are the topics that we will cover in this chapter:</p>
<ul>
<li>Anatomy of ASP.NET Core 2.0 application</li>
<li>Tic-Tac-Toe</li>
<li>Game design</li>
<li>SignalR Core</li>
<li>Solution</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Anatomy of an ASP.NET Core 2.0 application&#160;</h1>
                </header>
            
            <article>
                
<p>In this section, we will discuss the <em>who is who and what is what</em> of the ASP.NET Core 2.0 application that we created in the&#160;<em>Creating a simple</em> <em>running code</em>&#160;section of&#160;<a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>. The idea is to understand the purpose and use of each file that comes with the MVC template when creating the application, so that we can make the best possible use of them when needed.</p>
<p>The following screenshot shows what our application structure looks like:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="442" width="327" src="assets/e7b5942b-09e6-4867-b4b6-b688f2575575.png"/></div>
<p>For ease of understanding, the items are numbered from 1 to 12. We will walk through each item and understand what they bring to the table:</p>
<ol>
<li>
<p class="CDPAlignLeft CDPAlign"><span class="packt_screen">Connected Services</span>: This doesn't present itself as a physical file in the project template created by .NET Core 2.0 tooling, and is only visible when the project is opened from Visual Studio 2017 IDE; that is, it's a Visual Studio 2017 feature. The intent is to make it easier for developers to add connected services to their application. The services may be deployed on-premises or in the cloud. Earlier, this used be available as <span class="packt_screen">Add Connected Service</span> in the project's, right-click context menu; now it's available as a node in <span class="packt_screen">Solution Explorer</span> for web and mobile projects. One of the services that every ASP.NET Core web app can leverage is Application Insights. The entire comprehensive list of services can be found at <a href="https://docs.microsoft.com/en-us/azure/#pivot=services&amp;panel=all">https://docs.microsoft.com/en-us/azure/#pivot=services&amp;panel=all</a>. If we click on the <span class="packt_screen">Connected Services</span> node in <span class="packt_screen">Solution Explorer</span>, we will see a new full page window in Visual Studio which has three tabs:</p>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/39fb2154-050b-47ee-a0f8-0bedee914fe2.png"/></div>
<ol>
<li style="list-style-type: none">
<ol>
<li><span class="packt_screen">Overview</span>: This tab is in the <kbd>GettingStarted</kbd> section of the ASP.NET Core app. It lists Microsoft's official documentation links for ASP.NET Core app development, adding services, and deploying it to the cloud.</li>
<li><span class="packt_screen">Connected Services</span>: This is the section that enables us to add connected services to the application. R<span><span>ight-click on the <span class="packt_screen">Connected Services</span> node in <span class="packt_screen">Solution Explorer</span>; we see a context menu item, <span class="packt_screen">Add Connected Service</span>. If we click this item, it also navigates to the same place. We will add connected services in subsequent chapters, when we discuss Azure:</span></span></li>
</ol>
</li>
</ol>
<p class="mce-root"></p>
<div class="CDPAlignCenter CDPAlign"><span><img src="assets/4099ae78-3b92-493f-9931-31290397cd52.png"/><br/></span></div>
<ol>
<li style="list-style-type: none">
<ol start="3">
<li><span class="packt_screen">Publish</span>: To publish the web app in the cloud or on-premises. We will discuss this further in a later chapter, when we publish our app in Azure.</li>
</ol>
</li>
</ol>
<ul>
<li><span class="packt_screen">Dependencies</span>: This node has been around in Visual Studio for a while now. Again, this isn't present as a physical file in the system. There is a tooling update in Visual Studio 2017, which categorizes the dependencies and groups them into the following:
<ol>
<li><span class="packt_screen">Analyzers</span>: The analyzers are included in the project by default, as shown here:</li>
</ol>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ae41f65-6923-4332-91a7-58cfa08b921e.png"/></div>
<ol>
<li style="list-style-type: none">
<ol start="2">
<li><span class="packt_screen">NuGet</span>: The NuGet packages referred by the project are listed here. In the default ASP.NET Core 2.0 MVC template, we will see just one NuGet package called <kbd>Microsoft.AspNetCore.All</kbd> and that's awesome, as we no longer need to worry about versioning different packages and plumbing them to use in our app. <span><span><kbd>Microsoft.AspNetCore.All</kbd> is a metapackage; that is, it only references other packages. It references all ASP.NET Core packages and their dependencies, and all Entity Framework Core packages and their dependencies. The version of this package represents the ASP.NET Core and Entity Framework Core version. And the best part is that even though it's just one package, you can still go ahead and visualize all the packages that come with it alongside their dependencies:</span></span></li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/043d4ea3-3737-4dd4-ad95-b5430bb2b5eb.jpg"/></div>
<ol>
<li style="list-style-type: none">
<ol start="3">
<li><span class="packt_screen">SDK</span>: Displays the target SDK. For the default ASP.NET Core 2.0 app, it would be <span class="packt_screen">Microsoft.NETCore.App</span>.</li>
<li><span class="packt_screen">Bower</span>: This is the package manager for the web. It helps manage all the client-related stuff, such as HTML, CSS, JavaScript, fonts, and images. All the client-side packages are listed here. In the default project template, we can see stuff such as <span class="packt_screen">bootstrap</span>, <span class="packt_screen">jquery</span>, and so on.</li>
</ol>
</li>
</ol>
<p style="padding-left: 60px">These are the four types of dependency&#160;that come with the default ASP.NET Core 2.0 MVC template. But we are not limited to these dependencies alone. Based on the package manager of choice, we may also have <strong>node package manager</strong> (<strong>npm</strong>) or other package managers as the dependency listed here. In this chapter, we will use npm to install the SignalR client package, as it is available through npm.</p>
<div style="padding-left: 60px" class="packt_infobox">The immediate question that comes to mind is what is Node.js? Node.js is a platform built on Chrome's&#160;JavaScript&#160;runtime engine for easily building fast and scalable applications.&#160;It&#160;uses an event-driven, non-blocking, asynchronous I/O model, which makes it lightweight and efficient, perfect for data-intensive (and non-CPU-intensive) real-time applications. So,&#160;<span>npm is the package manager for JavaScript. To use npm, we need to install Node.js.</span></div>
<ol start="3">
<li><span class="packt_screen">Properties</span>: Double-clicking on the&#160;<span class="packt_screen">Properties</span> node of the project in <span class="packt_screen">Solution Explorer</span> takes us to the project properties page and, on expanding this, displays the <kbd>launchSettings.json</kbd> file, where all the launch/startup-related configurations are serialized and saved as JSON. The following is the default code:</li>
</ol>
<pre style="padding-left: 60px"> "iisSettings": {<br/>     "windowsAuthentication": false,<br/>     "anonymousAuthentication": true,<br/>     "iisExpress": {<br/>         "applicationUrl": "http://localhost:52845/",<br/>         "sslPort": 0<br/>     }<br/> },<br/> "profiles": {<br/>     "IIS Express": {<br/>     "commandName": "IISExpress",<br/>     "launchBrowser": true,<br/>     "environmentVariables": {<br/>     "ASPNETCORE_ENVIRONMENT": "Development"<br/>     }<br/> },<br/> "GettingStarted": {<br/>     "commandName": "Project",<br/>     "launchBrowser": true,<br/>     "environmentVariables": {<br/>         "ASPNETCORE_ENVIRONMENT": "Development"<br/>     },<br/>     "applicationUrl": "http://localhost:52846/"<br/>     }<br/>   }<br/>}</pre>
<p style="padding-left: 60px">It's evident that the values in the preceding code match the <span class="packt_screen">Debug</span> section of the properties page of the project:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a4228fb-5479-4c48-931a-d2362c3a13f8.png"/></div>
<ol start="4">
<li><span class="packt_screen">wwwroot</span>:&#160;<span>All client-side packages and images are part of this folder. Files in this folder are served as static content and can be bundled and minified to reduce payloads and page rendering by using <kbd>bundleconfig.json</kbd>. A few of the common folders are:</span>
<ul>
<li><kbd>css</kbd>: Contains cascading style sheets</li>
<li><kbd>images</kbd>: Contains the image assets that are needed in the app</li>
<li><kbd>js</kbd>: Contains JavaScript files</li>
<li><kbd>lib</kbd>: Contains the client-side packages</li>
</ul>
</li>
<li><span class="packt_screen">Controllers</span>: Contains the controllers as per the Model-View-Controller (MVC) architecture.</li>
<li><span class="packt_screen">Models</span>: Contains the models as per the MVC architecture.</li>
<li><span class="packt_screen">Views</span>: Contains the views as per the MVC architecture.</li>
</ol>
<ol start="8">
<li><kbd>appsettings.json</kbd>: The application settings for the application. It contains the key and value-based settings in JSON format. If you are an old school ASP.NET web developer, you can think of it as the <kbd>appSettings</kbd> section defined inside <kbd>web.config</kbd>. The following is the sample configuration for <kbd>Logging</kbd>, which comes with the default template:</li>
</ol>
<pre style="padding-left: 90px">  {<br/>     "Logging": {<br/>     "IncludeScopes": false,<br/>     "LogLevel": {<br/>     "Default": "Warning"<br/>     }<br/> }<br/>}</pre>
<ol start="9">
<li><kbd>bower.json</kbd>:<span>&#160;The Bower package manager is part of Visual Studio, as mentioned previously. This client-side package manager is one of the most widely-used package managers in the open source community for managing packages. <kbd>bower.json</kbd> is used by Bower to download and manage the client-side packages. This is very similar to the <kbd>packages.config</kbd> file that is used for managing NuGet packages. Just specify the package name that you want in the JSON file and Bower will do the rest. In case you do not see the packages, just right-click on the file in <span class="packt_screen">Solution Explorer</span> and click <span class="packt_screen">Restore Packages</span></span>. <span>The following is the code snippet from <kbd>bower.json</kbd>, which lists the dependencies as <kbd>bootstrap</kbd>, <kbd>jquery</kbd>, and so on:</span></li>
</ol>
<pre style="padding-left: 90px">{<br/> "name": "asp.net",<br/> "private": true,<br/> "dependencies": {<br/>     "bootstrap": "3.3.7",<br/>     "jquery": "2.2.0",<br/>     "jquery-validation": "1.14.0",<br/>     "jquery-validation-unobtrusive": "3.2.6"<br/>     }<br/>}</pre>
<p style="padding-left: 60px">In case you do not like this approach of adding the client-side dependency in the <kbd>bower.json</kbd> file, right-click on the <kbd>bower.json</kbd> file and click on <span class="packt_screen">Manage Bower Packages</span>. This has a very similar user interface to the NuGet package manager and can be used in the same way. Just search the package and click <span class="packt_screen">Install</span>. The following image shows the installed Bower packages in the project:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/b642db67-7851-48a4-9db6-19bcdc9d58f4.jpg"/></div>
<ol start="10">
<li><kbd>bundleconfig.json</kbd>: This JSON&#160;<span>file used to store the project bundling and minification configuration for the static content of the site, that is, scripts and styles. The following is what the default MVC project template, <kbd>bundleconfig.json</kbd>, looks like. The names and comments are intuitive to understand:</span></li>
</ol>
<pre style="padding-left: 60px">[<br/>     {<br/>        // The name and relative path of output minified css file.<br/>        "outputFileName": "wwwroot/css/site.min.css",<br/>         // An array of relative input file paths. Globbing patterns <br/>            supported<br/>         "inputFiles": [<br/>             "wwwroot/css/site.css"<br/>         ]<br/>     },<br/>     {<br/>         // The name and relative path of output minified JavaScript <br/>            file.<br/>         "outputFileName": "wwwroot/js/site.min.js",<br/>         // The array of relative input file paths.<br/>         "inputFiles": [<br/>             "wwwroot/js/site.js"<br/>         ],<br/>         // Optionally specify minification options<br/>         "minify": {<br/>             "enabled": true,<br/>             "renameLocals": true<br/>         },<br/>         // Optionally generate .map file<br/>         "sourceMap": false<br/>     }<br/> ]</pre>
<div class="packt_infobox"><span>Bundling and minification are techniques to improve request load time:</span>
<ul>
<li><span>Bundling improves load time by reducing the number of requests sent to the server by the client to fetch static content; that is, CSS, JavaScript. Most major modern browsers limit the number of simultaneous connections for each hostname to six; that is to say, if six requests are being processed, any additional requests from the client for assets on the same hostname would be queued by the browser. With bundling, this issue is avoided, as all CSS files can be bundled as one file and, likewise, one file for JavaScript. This improves the first-time load performance. For subsequent requests, it's not much of an improvement, as the browser caches the files.</span></li>
<li><span>Minification improves performance by reducing the size of&#160; the requested assets, that is, CSS and JavaScript, by removing unnecessary white spaces and comments, and &#160;shortening the variable names to one character. We have all seen the <kbd>jquery.min.js</kbd> file while doing web development. The <kbd>min</kbd> in the name is to help the user identify that it is the minified version of the file.</span></li>
</ul>
</div>
<ol start="11">
<li><kbd>Program.cs</kbd>: This is the main entry point to the ASP.NET Core 2.0 app. It has the minimum code needed to get the app up and running with the default configurations:</li>
</ol>
<pre style="padding-left: 60px">public class Program<br/>{<br/>     public static void Main(string[] args)<br/>     {<br/>         BuildWebHost(args).Run();<br/>     }<br/><br/>     public static IWebHost BuildWebHost(string[] args) =&gt; <br/>        WebHost.CreateDefaultBuilder(args)<br/>        .UseStartup&lt;Startup&gt;()<br/>        .Build();<br/>}</pre>
<p style="padding-left: 60px">As we can see, this looks more like a console application and, actually, that is what it isâ€”a console app. In its entry point <kbd>Main</kbd> method, it creates a web server, hosts the application, and starts listening to HTTP requests. Notice here that <kbd>BuildWebHost</kbd> is a method which returns an object that implements <kbd>IWebHost</kbd>, accepting a string array argument. This method is implemented as an expression bodied member, just to make the developers aware that the sole purpose of this method is to build the web host and no other code should be put here. The method follows the builder pattern to build the host. There are several methods that we can hook up, one after another, as needed, and they would be added to the object incrementally, one after the other. The <kbd>CreateDefaultBuilder</kbd> method builds the web host with the default configuration wired up from various configuration providers (such as JSON and environment variables, to name a few), sets the logging configuration, and sets up a Kestrel web server with IIS integration, which is good enough for the app to run. The <kbd>Build</kbd> method builds the object and returns. Notice the&#160;<kbd>UseStartup&lt;Startup&gt;</kbd> method call, which actually specifies the <kbd>Startup</kbd> class for the app. We will discuss this class next.</p>
<div class="packt_infobox">The <strong>Builder pattern</strong> is an object creation design pattern. It is one of the 23 well-known <span><strong>Gang of Four</strong> (</span><strong>GoF</strong>) design patterns. The intent behind this pattern is to separate the construction of a complex object from its representation, so that the same construction process can create different representations. To do so, this pattern builds a complex object using simple objects in a step-by-step approach.</div>
<ol start="12">
<li><kbd>Startup.cs</kbd>: This is the class, where we define the request handling pipeline and configure the services needed by the application. Let's look at the code and then discuss it in depth:</li>
</ol>
<pre style="padding-left: 60px"> public class Startup<br/> {<br/>    public Startup(IConfiguration configuration)<br/>    {<br/>        Configuration = configuration;<br/>    }<br/><br/>    public IConfiguration Configuration { get; }<br/><br/>    // This method gets called by the runtime. Use this method to  <br/>       add services to the container.<br/>    public void ConfigureServices(IServiceCollection services)<br/>    {<br/>        services.AddMvc();<br/>    }<br/><br/>    // This method gets called by the runtime. Use this method to <br/>       configure the HTTP request pipeline.<br/>    public void Configure(IApplicationBuilder app, <br/>    IHostingEnvironment env)<br/>    {<br/>        if (env.IsDevelopment())<br/>        {<br/>            app.UseDeveloperExceptionPage();<br/>            app.UseBrowserLink();<br/>        }<br/>        else<br/>        {<br/>            app.UseExceptionHandler("/Home/Error");<br/>        }<br/>        app.UseStaticFiles();<br/>        app.UseMvc(routes =&gt;<br/>        {<br/>            routes.MapRoute(<br/>                name: "default",<br/>                template: "{controller=Home}/{action=Index}/{id?}");<br/>        });<br/>    }<br/>}</pre>
<p>The key takeaways from the class code are:</p>
<ol>
<li>The class should be <kbd>public</kbd>.</li>
<li>The constructor has a dependency on <kbd>IConfiguration</kbd>, which is injected as the core service and assigned to the&#160;<kbd>public</kbd> property <kbd>Configuration</kbd> of type <kbd>IConfiguration</kbd>.</li>
<li>This makes <kbd>Configuration</kbd> a first class citizen of the ASP.NET Core application and can be easily used to read the <kbd>appSettings</kbd> value just by using this code:&#160;<kbd>Configuration["&lt;KeyName&gt;"]</kbd>.</li>
<li>There are only two public methods in the class:
<ul>
<li><kbd>ConfigureServices</kbd>: This method is called by the runtime. This method is the place to add services to the container, such as MVC, antiforgery, application insight telemetry, authentication, authorization, localization, identity, and so on. There is a huge list of services available, which can be seen through IntelliSense. In the preceding code, we are c files, such as css, js, images, HTjust adding the MVC service, so that we can leverage all the MVC goodness in our app.</li>
<li><kbd>Configure</kbd>: As the comment in the code explains, this method is called by the runtime and is used to configure the HTTP request pipeline. In this method, we have access to the application builder and the hosting environment, which is another first class citizen of the .NET Core 2.0 app and is available in the container for injection into the objects that we construct. In the preceding code, which comes with the default MVC template, we can see the following:
<ol start="1">
<li>First, it checks whether the environment is for development or not. This is determined by the environment variable,&#160;<kbd>ASPNETCORE_ENVIRONMENT</kbd>. If its value is <kbd>Development</kbd>, it will detect the host environment to be&#160;<kbd>Development</kbd>;&#160;otherwise, it will be <kbd>Production</kbd>. If this environment variable is not available, it defaults the environment to <kbd>Production</kbd>. The variable can be set in the project properties page in the <span class="packt_screen">Debug</span> section. The screenshot of the preceding properties section displays the <span class="packt_screen">Environment variable</span> clearly.&#160;</li>
<li>If the environment is <kbd>Development</kbd>, it tells the app to use the developer exception page by calling the&#160;<kbd>UseDeveloperExceptionPage()</kbd> method. The developer exception page gives a detailed error message with the exception stack trace to help the developer pinpoint the issue and resolve it. This should not be used in <kbd>Production</kbd>, as the exception information may be used by a hacker to attack your site. Also, your end user may not be a technical person, and may prefer to see a more user-friendly message than a .NET stack trace, so in production we use a custom error page, which is specified by calling the&#160;<kbd>UseExceptionHandler("/Home/Error");</kbd> method.</li>
<li>During the development phase, you may want to test your web app against multiple browsers, and hence may want to open multiple browsers and browse the page to check for compatibility issues and refresh them when you make a fix. The <kbd>UseBrowserLink()</kbd>&#160;method helps you do just that.&#160;<span><span><strong>Browser Link</strong> is a feature in Visual Studio that creates a communication channel between the <kbd>Development</kbd> environment and one or more web browsers. We can use Browser Link to refresh the web application in several browsers at once.</span></span></li>
<li>Static files, such as <kbd>css</kbd>, <kbd>js</kbd>, <kbd>images</kbd>, HTML, and so on, which are placed in the <kbd>wwwroot</kbd> folder, are not servable by default. To make them servable, we need to call the&#160;<kbd>UseStaticFiles()</kbd> method.</li>
<li>Finally, the last piece of the code configures the MVC service (added in the&#160;<kbd>Configure</kbd> method) by specifying the default route.</li>
<li>To sum up, in this method we just configure the HTTP request pipeline using middleware. We will look at middleware in the next chapter, but for the time being, just think of them as HTTP modules in the earlier versions of ASP.NET. We added the services and then configured them as per our requirements using middleware. We will find three types of middleware configuration in the code samples:
<ul>
<li><kbd>app.Run()</kbd>: The first&#160;<kbd>app.Run</kbd>&#160; delegate terminates the HTTP request pipeline. If you use <kbd>Run</kbd>, it expects the handler and hence the request is served back to the client. No further middleware will be called in the request path.</li>
<li><kbd>app.Map*</kbd>: This extension is used <span>as a convention for branching the pipeline. <kbd>Map</kbd>&#160;</span><span>branches the request pipeline based on matches of the given request path. If the request path starts with the given path, the branch is executed.</span></li>
<li><kbd>app.Use[Middleware]</kbd>: <kbd>Use</kbd> can be used to chain the middleware; that is, we can arrange them to execute one after another. <kbd>Use</kbd> can also be used to short-circuit the request pipeline as needed.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>If this sounds scary, don't worry! We will discuss middleware, dependency injection, and containers in detail in the next chapter while developing our Let's Chat application.&#160;</p>
<p>Last but not least, the <kbd>.csproj</kbd> file has major and long-anticipated enhancements. The <kbd>.xproj</kbd> from .NET Core 1.0 is now gone and we have our familiar <kbd>.csproj</kbd> back in business with ASP.NET Core 2.0. It's better than earlier, as it is lightweight and easier to manage. Visual Studio 2017 also has a tooling update, which enables us to edit the <kbd>.csproj</kbd> file without having to unload the project and edit. This is super awesome. Just right-click on the project in <span class="packt_screen">Solution Explorer</span> and then click <kbd>Edit &lt;Project Name&gt;.csproj</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa59f1c0-179b-43b8-8c3e-521d18fdf703.png"/></div>
<p>We will have the <kbd>.csproj</kbd> file opened as an XML file in the code editor, with the entire project still loaded. The following is the <kbd>.csproj</kbd> file code:</p>
<pre>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;<br/>     &lt;PropertyGroup&gt;<br/>         &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt; <br/>     &lt;/PropertyGroup&gt;<br/>     &lt;ItemGroup&gt;<br/>         &lt;PackageReference Include="Microsoft.AspNetCore.All" <br/>         Version="2.0.0" /&gt;<br/>     &lt;/ItemGroup&gt;<br/>     &lt;ItemGroup&gt;<br/>         &lt;DotNetCliToolReference <br/>         Include="Microsoft.VisualStudio.Web.CodeGeneration.Tools"  <br/>         Version="2.0.0"           /&gt;<br/>     &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;</pre>
<p>It's very lean, with just <kbd>TargetFramework</kbd>, which is <kbd>netcoreapp2.0</kbd>;&#160;<kbd>PackageReference</kbd>, which has just one metapackage,&#160;<kbd>Microsoft.AspNetCore.All</kbd>; and <kbd>DotNetCliToolReference</kbd> included as part of <kbd>ItemGroup</kbd>. This is much better than the conventional <kbd>.csproj</kbd> file, where we had different build configurations, property groups, all the projects, DLL, NuGet package references, and all the files and folders that need to be included in the project, making it really hard to manage.</p>
<p>This concludes our basic anatomy of an ASP.NET Core 2.0 app. Let's get started with our game development in ASP.NET Core 2.0.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tic-Tac-Toe&#160;</h1>
                </header>
            
            <article>
                
<p>Tic-Tac-Toe is a simple two-player game, traditionally with its marks as <em>X</em> and <em>O</em>. Each player places his/her mark in a space and alternate turns in a 3Ã—3 grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game.</p>
<p>This is what the pen and pencil game board looks like. In the following illustration, the player with the <strong>X</strong> marker is the winner:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="130" width="133" src="assets/7f525bff-8039-4463-aea2-65fbbb187873.png"/></div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Requirement specifications</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will create a two-player Tic-Tac-Toe game with the following basic requirements:</p>
<ol>
<li>As a player, I should be able to register with my name and display a picture</li>
<li>As a player, I should be able to find an opponent, that is, the second player to play against</li>
<li>The first two players to find opponents should be paired as opponents in the game</li>
<li>The decision as to which player gets the chance to make the first move should be <span>fair</span></li>
<li>As a player, I should be able to use my display picture as my mark, rather than the conventional <em>X</em> and <em>O</em></li>
<li>The decision as to who wins should be made fairly</li>
<li>In future, we want multiple players playing online simultaneously</li>
</ol>
<p>Now that we have the requirement specifications in place, let's see the activity flow of the game and come up with a flowchart. The following is a rough flowchart of the game workflow:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/284e8ca3-199a-4d6f-90ae-7fc433220db8.png"/></div>
<ol>
<li><strong>Start</strong>: This is the start of the flow. The player browses the game site URL. It is being conceptualized as a site, since in future we want to allow multiple players to play simultaneously online (requirement <em>Step 7</em>)<em>.</em></li>
<li><strong>Register with name and display picture</strong>: The player registers himself/herself with a name and display picture&#160;(requirement <em>Step 1</em>).</li>
<li><strong>Is Opponent available?:</strong>&#160;The player finds an opponent to play against. If an opponent is found, the game can start with a toss; otherwise, the player needs to wait for the opponent&#160;(requirement <em>Steps 2</em> and<em>&#160;3</em>).</li>
<li><strong>Wait for opponent</strong>: T<span>here may be a scenario where the player is alone and registered with no one to play against, so the player needs to wait until another player registers and looks for an opponent&#160;</span>(requirement <em>Steps 2</em>&#160;and&#160;<em>3</em>).</li>
<li><strong>Won toss?</strong>: Once the players are paired as opponents, the game starts and one of the players gets the opportunity to make the first move. To keep this fair, we will have a toss. The player may either win the toss or lose the toss&#160;(requirement <em>Step 4</em>).</li>
<li><strong>Make a move/Wait for opponent to make a move</strong>: The player winning the toss gets the first move, while their opponent would waits for the first player to make their move.</li>
<li><strong>Do we have a winner?</strong>: After every move, we check whether the win/draw criteria have been met and check whether we have a winner. If not, then the game continues with each player moving alternately until the game ends&#160;(requirement <em>Step 6</em>).</li>
<li><strong>Game Over</strong>: Finally, the players will either run out of moves or a player will win the game.</li>
</ol>
<p>As we can see, the game will be played only in <em>Steps 6</em> and <em>7</em> of the flowchart. The other steps are required only for setting up the game. Also, notice that this flow covers all our requirements.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing the game</h1>
                </header>
            
            <article>
                
<p>Looking at the preceding flow chart, which meets&#160;our requirements, we know we need to develop the following in the ASP.NET Core 2.0 application to constitute a basic two-player Tic-Tac-Toe game:</p>
<ol>
<li>A web page where players can go and register themselves with their name and display a picture</li>
<li>A module to find an opponent to play against</li>
</ol>
<ol start="3">
<li>A module to simulate a coin toss to ensure fairness in giving players the option of making the first move</li>
<li>The UI for the Tic-Tac-Toe game board in the web page, that is, a 3Ã—3 grid where players can place their image</li>
<li>Logic to indicate to the player whether it's their turn or the opponent's turn</li>
<li>A module to show the opponent and player the move that was made</li>
<li>A mechanism to ensure that the player and opponent's board are in sync with their moves</li>
<li>Logic to check whether the game is over</li>
<li>Logic to determine the winner</li>
</ol>
<p>Sounds simple enough! Let's see how we can design and implement each of the preceding points by using ASP.NET Core 2.0 goodness:</p>
<ol>
<li><strong>Web page for registration:</strong> We have multiple options available to code this. We can either use a static HTML page, or a regular <kbd>.cshtml</kbd> view of MVC, or the new Razor Pages introduced by ASP.NET Core 2.0. Since we will be working extensively with Razor Pages in the next chapter, we will use the <kbd>.cshtml</kbd>&#160;Razor view to create the UI of the game.</li>
<li><strong>Opponent-finding module:</strong> When a player registers, we can store his details somewhere on the server so the server knows how many players are registered to play. When a player finds an opponent, we can pair them as opponents based on their registration time. The problem with just relying on registered users, though, is when a player registers and closes the browser window knowingly or unknowingly, or decides not to play the game after registering. So, we need to ensure that we pair up only those players who are registered, are actively connected to the server, and are looking for an opponent to play the game with. If a player disconnects in the middle of the game, award the game to the opponent and inform them that the opponent has disconnected. We will need to do additional housekeeping to refresh the registered players in the server as new players join and existing players disconnect. To check whether a user is connected or not, we may need to perform additional housekeeping by writing additional code or making use of sessions.&#160;</li>
<li><strong>Simulate coin toss:</strong> There are many ways to simulate a coin toss, such as generating a random number between two numbers and seeing whether it's even or odd. In our case, to keep things simple, we will generate a random number, either <kbd>0</kbd>&#160;or&#160;<kbd>1</kbd>. If it's <kbd>0</kbd>, it's heads; otherwise, it's tails.</li>
</ol>
<ol start="4">
<li><strong>UI for game board:</strong> As already discussed, we will be using the standard MVC Razor view to create the registration form as well as the Tic-Tac-Toe game board user interface. Designing the game board for Tic-Tac-Toe is rather simple with CSS; we just need to get the correct box style and arrange the boxes in a 3Ã—3 grid. To place the player's image on the board, we pass the player image to each of the players and update the box background style to the image when the user clicks on that grid box. The challenge we can see here is how we will keep the game board of both the players in sync at any given time. Although the individual player and server know which player has a marker placed at which position, the opponent needs to have the same picture of the game board. This is something that the server needs to inform both players of after every turn.&#160;</li>
<li><strong>Logic to indicate whose turn it is:</strong>&#160;Although the server knows the toss result, it needs to inform one player to make a move and the other to wait for the other player to make a move. And after each turn, the server needs to inform both players (clients) about the turn, so the server has to push data to the clients after every move.</li>
<li><span><strong>Module to show the players the move that was made:</strong> Like the preceding point, it is again the server's responsibility to update the players about the last move and ensure both players have a game board view after each move.</span></li>
</ol>
<p>The last two modules are straightforward. We need to check whether the game is over and we have a winner. The interesting part of our discussion is that in <em>Steps 2</em>, <em>4</em>, <em>5</em>, and <em>6</em>, we came across scenarios where the server needs to push data to the client. This is something that has already been made incredibly easy by the ASP.NET team who developed a library called SignalR. So, we will use SignalR to cover these scenarios. Before we dive into coding, let's understand what SignalR is, how it works, and how it saves us from writing all this stuff ourselves.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SignalR</h1>
                </header>
            
            <article>
                
<p>SignalR is a library for ASP.NET developers for developing real-time web experiences. In traditional web applications, the client makes requests and the server responds. With SignalR, we have the ability to push the content from the&#160; server to the connected clients in real time.<span>&#160;</span><span>SignalR provides a simple API for creating server-to-client remote procedure calls that call JavaScript functions in client browsers (and other client platforms) from server-side .NET code.&#160;</span>Anywhere in an application, if we need to refresh the browser for fresh data or have polling code wriiten to refresh the data, SignalR may be a good candidate for this. Some real-world applications of SignalR are chat applications where multiple users can chat, dashboards for monitoring, stock ticker applications that update a stock price as and when it changes, and multiplayer games. Basically, for any app that needs to display live data, SignalR makes it incredibly simple to broadcast a message to all clients, a group of clients, or a specific client as needed.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SignalR transport mechanisms</h1>
                </header>
            
            <article>
                
<p>SignalR connects through WebSockets, Server-Sent Events, Forever Frames, and long polling. The following is a short description of each of these transport mechanisms:</p>
<ul>
<li><strong>WebSockets</strong>: WebSockets&#160;<span>is an advanced computer communication protocol that enables you to open an interactive communication session between the user's browser and a server with a lower overhead. With the advent of HTML5, WebSockets is supported by the latest version of all major browsers, such as Microsoft Edge, Microsoft Internet Explorer, Google Chrome, Firefox, Safari, and Opera. With WebSockets, we can send messages to a server and receive event-driven responses without having to poll the server for a reply. This is full-duplex communication.</span></li>
<li><strong>Server-Sent Eevents</strong>: Server-Sent Events are a technology that enables web pages to receive automatic updates from the server through a HTTP connection. The server can initiate the data transmission toward a client after an initial connection has been established. This is not supported by the current version of&#160;<span><span>Microsoft Edge and Microsoft Internet Explorer, but is available in Google Chrome, Mozilla Firefox, Safari, Opera, and others. This is simplex communication, as the server pushes the data to the client. This is part of the HTML5 specification.</span></span></li>
<li><strong>Forever Frame</strong>: Forever Frame is a Microsoft Internet Explorer concept and is not supported by any other browser. When a connection is established between a client web page and a server through Forever Frame, it creates a hidden IFrame in the client page. This IFrame makes a request to the server endpoint, which never completes; that is, it keeps the connection alive forever (hence the name, Forever Frame). Since the connection remains open, the server can use this connection to push scripts to the client, which are loaded and executed immediately in the client page, thus providing a real-time one-way communication from the server to the client. This is supported in old SignalR but removed from SignalR Core.</li>
<li><strong>Long polling</strong>:&#160;<span>Long polling is something that most web developers do in their regular web development without realizing it is actually long polling.&#160;Long polling does not create a persistent connection, but instead polls the server with a request that stays open until the server responds. This may introduce some latency while the connection resets. Long polling is basically an approach used for backward compatibility with old browsers and is definitely not a preferred method for client-server communication for the modern web.</span></li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SignalR Core</h1>
                </header>
            
            <article>
                
<p><span>SignalR Core is the complete rewrite of SignalR for ASP.NET Core 2.0 and, at the time of writing this chapter, is available as an alpha release for ASP.NET Core 2.0. As per the road-map, it is scheduled to be released in the fourth quarter of 2017 and will be shipped with ASP.NET Core 2.1. The current alpha release consists of a server component, .NET client, and</span> <span>JavaScript/TypeScript client.</span></p>
<p>We will be using SignalR Core for our game development as it will take care of all the heavy duty stuff <span>needed to push the content from the server to the client&#160;</span>and let us concentrate on the problem at hand. With the ASP.NET Core 2.0 and SignalR Core basics in place, and the design and approach finalized, let's get started with our implementation.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Solution</h1>
                </header>
            
            <article>
                
<p>In this section, we will develop the Tic-Tac-Toe game in the ASP.NET Core 2.0 web app, using SignalR Core. We will follow a step-by-step approach and use Visual Studio 2017 as the primary IDE, but will list the steps needed while using the Visual Studio Code editor as well. Let's do the project setup first and then we will dive into the coding.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p>Create a new ASP.NET Core 2.0 MVC app named <kbd>TicTacToeGame</kbd>, like we did in the <em>Creating a simple running code</em>&#160;section in <a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>.</p>
<p>With this, we will have a basic working ASP.NET Core 2.0 MVC app in place. However, to leverage SignalR Core in our app, we need to install SignalR Core NuGet and the client packages.</p>
<p>To install the SignalR Core NuGet package, we can perform one of the following two approaches in the Visual Studio IDE:</p>
<ul>
<li>In the context menu of the <kbd>TicTacToeGame</kbd> project, click on <span class="packt_screen">Manage NuGet Packages</span>. It will open the <span class="packt_screen">NuGet Package Manager</span> for the project. In the <span class="packt_screen">Browse</span> section, search for the <kbd>Microsoft.AspNetCore.SignalR</kbd> package and click <span class="packt_screen">Install</span>. This will install SignalR Core in the app. Please note that currently the package is in the preview stage and hence the pre-release checkbox has to be ticked:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a1ddd74-b570-4f6f-a64d-14735f0b2743.png"/></div>
<ul>
<li>Edit the <kbd>TicTacToeGame.csproj</kbd> file, add the following code snippet in the <kbd>ItemGroup</kbd> code containing package references, and click <span class="packt_screen">Save</span>. As soon as the file is saved, the tooling will take care of restoring the packages and in a while, the SignalR package will be installed. This approach can be used with Visual Studio Code as well. Although Visual Studio Code detects the unresolved dependencies and may prompt you to restore the package, it is recommended that immediately after editing and saving the file, you run the&#160;<kbd>dotnet restore</kbd>&#160;command in the terminal window at the location of the project:</li>
</ul>
<pre style="padding-left: 60px">&lt;ItemGroup&gt;<br/>     &lt;PackageReference Include="Microsoft.AspNetCore.All" <br/>     Version="2.0.0" /&gt;<br/>     <strong>&lt;PackageReference Include="Microsoft.AspNetCore.SignalR" <br/>     Version="1.0.0-alpha1-final" /&gt;</strong><br/> &lt;/ItemGroup&gt;</pre>
<p>Now we have server-side packages installed. We still need to install the client-side package of SignalR, which is available through npm. To do so, we need to first ascertain whether we have npm installed on the machine or not. If not, we need to install it. npm is distributed with Node.js, so we need to download and install Node.js from&#160;<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>. The installation is quite straightforward.&#160;</p>
<p>Once this installation is done, open a Command Prompt at the project location and run the following command:</p>
<pre><strong>npm install @aspnet/signalr-client</strong></pre>
<p>This will install the SignalR client package. Just go to the package location (npm creates a <kbd>node_modules</kbd> folder in the project directory). The relative path from the project directory would be&#160;<kbd>\node_modules\@aspnet\signalr-client\dist\browser</kbd>.</p>
<p>From this location, copy the <kbd>signalr-client<span>-1.0.0-alpha1-final</span>.js</kbd> file into the&#160;<kbd>wwwroot\js</kbd> folder. In the current version, the name is&#160;<kbd>signalr-client-1.0.0-alpha1-final.js</kbd>.</p>
<p>With this, we are done with the project setup and we are ready to use SignalR goodness as well. So let's dive into the coding.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Coding the game</h1>
                </header>
            
            <article>
                
<p>In this section, we will implement our gaming solution. The end output will be the working two-player Tic-Tac-Toe game. We will do the coding in steps for ease of understanding:</p>
<ol>
<li>&#160;In the <kbd>Startup</kbd> class, we modify the <kbd>ConfigureServices</kbd> method to add SignalR to the container, by writing the following code:</li>
</ol>
<pre style="padding-left: 90px"><strong>//// Adds SignalR to the services container.</strong><br/><strong> services.AddSignalR();</strong></pre>
<ol start="2">
<li>In the <kbd>Configure</kbd> method of the same class, we configure the pipeline to use SignalR and intercept and wire up the request containing <kbd>gameHub</kbd> to our SignalR hub that we will be creating with the following code:</li>
</ol>
<pre style="padding-left: 90px">//// Use - SignalR &amp; let it know to intercept and map any request having gameHub.<br/> app.UseSignalR(routes =&gt; <br/> {<br/>        routes.MapHub&lt;GameHub&gt;("gameHub");<br/> });</pre>
<p style="padding-left: 60px">The following is the code for both methods, for the sake of clarity and completion. Other methods and properties are removed for brevity:</p>
<pre style="padding-left: 60px"> // This method gets called by the run-time. Use this method to add <br/>    services to the container.<br/> public void ConfigureServices(IServiceCollection services)<br/> {<br/>     services.AddMvc();<br/>    <strong> //// Adds SignalR to the services container.</strong><br/><strong>     services.AddSignalR();</strong><br/> }<br/><br/> // This method gets called by the runtime. Use this method to <br/>    configure the HTTP request pipeline.<br/> public void Configure(IApplicationBuilder app, IHostingEnvironment <br/> env)<br/> {<br/>       if (env.IsDevelopment())<br/>       {<br/>            app.UseDeveloperExceptionPage();<br/>            app.UseBrowserLink();<br/>       }<br/>       else<br/>       {<br/>           app.UseExceptionHandler("/Home/Error");<br/>       }  <br/><br/>    app.UseStaticFiles();<br/>    app.UseMvc(routes =&gt;<br/>    {<br/>        routes.MapRoute(<br/>            name: "default",<br/>            template: "{controller=Home}/{action=Index}/{id?}");<br/>     });<br/><br/>   <strong>//// Use - SignalR &amp; let it know to intercept and map any request <br/>        having gameHub.</strong><br/><strong>   app.UseSignalR(routes =&gt; </strong><br/><strong>   {</strong><br/><strong>       routes.MapHub&lt;GameHub&gt;("gameHub");</strong><br/><strong>   });</strong></pre>
<p style="padding-left: 60px"></p>
<ol start="3">
<li>The previous two steps set up SignalR for us. Now, let's start with the coding of the player registration form. We want the player to be registered with a name and display the picture. Later, the server will also need to know whether the player is playing, waiting for a move, searching for an opponent, and so on. Let's create the <kbd>Player</kbd> model in the <kbd>Models</kbd> folder in the app. The code comments are self-explanatory:</li>
</ol>
<pre style="padding-left: 120px">/// &lt;summary&gt;<br/>/// The player class. Each player of Tic-Tac-Toe game would <br/>    be an instance of this class.<br/>/// &lt;/summary&gt;<br/>internal class Player<br/>{<br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the name of the player. This would be <br/>         set at the time user registers.<br/>     /// &lt;/summary&gt;<br/>     public string Name { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets the opponent player. The player <br/>        against whom the player would be playing.<br/>    /// This is determined/ set when the players click Find <br/>        Opponent Button in the UI.<br/>    /// &lt;/summary&gt;<br/>    public Player Opponent { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets a value indicating whether the player <br/>        is playing.<br/>    /// This is set when the player starts a game.<br/>    /// &lt;/summary&gt;<br/>    public bool IsPlaying { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets a value indicating whether the player <br/>        is waiting for opponent to make a move.<br/>    /// &lt;/summary&gt;<br/>    public bool WaitingForMove { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets a value indicating whether the player <br/>        is searching for opponent.<br/>    /// &lt;/summary&gt;<br/>    public bool IsSearchingOpponent { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets the time when the player registered.<br/>    /// &lt;/summary&gt;<br/>    public DateTime RegisterTime { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets the image of the player.<br/>    /// This would be set at the time of registration, if <br/>        the user selects the image.<br/>    /// &lt;/summary&gt;<br/>    public string Image { get; set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// Gets or sets the connection id of the player <br/>        connection with the gameHub.<br/>    /// &lt;/summary&gt;<br/>    public string ConnectionId { get; set; }<br/>}</pre>
<ol start="4">
<li>Now, we need to have a UI in place so that the player can fill in the form and register. We also need to show the image preview to the player when he/she browses the image. To do so, we will use the <kbd>Index.cshtml</kbd> view of the <kbd>HomeController</kbd>&#160;class that comes with the default MVC template. We will refer to the following two <kbd>.js</kbd> files in the <kbd>_Layout.cshtml</kbd> partial view so that they are available to all the views. Alternatively, you could add these in the <kbd>Index.cshtml</kbd> view as well, but its highly recommended that common scripts should be added in <kbd>_Layout.cshtml</kbd>. The version of the script file may be different in your case. These are the currently <span>available&#160;</span>latest versions. Although jQuery is not required to be the library of choice for us, we will use jQuery to keep the code clean, simple, and compact. With these references, we have jQuery and SignalR available to us on the client side:</li>
</ol>
<pre style="padding-left: 60px">&lt;script src="~/lib/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;!-- jQuery--&gt;<br/>&lt;script src="~/js/signalr-client-1.0.0-alpha1-final.js"&gt;&lt;/script&gt; &lt;!-- SignalR--&gt;</pre>
<ol start="4"></ol>
<p style="padding-left: 60px">After adding these references, create the simple HTML UI for the image preview and registration, as follows:</p>
<pre style="padding-left: 60px">&lt;div id="divPreviewImage"&gt; &lt;!-- To display the browsed image--&gt;<br/>        &lt;fieldset&gt;<br/>            &lt;div class="form-group"&gt; <br/>                &lt;div class="col-lg-2"&gt;<br/>                    &lt;image src="" id="previewImage" <br/>                    style="height:100px;width:100px;border:solid <br/>                    2px dotted; float:left" /&gt;<br/>                &lt;/div&gt;<br/>                &lt;div class="col-lg-10" id="divOpponentPlayer"&gt; &lt;!-- <br/>                To display image of opponent player--&gt;<br/>                    &lt;image src="" id="opponentImage" <br/>                    style="height:100px;width:100px;border:solid <br/>                    2px dotted; float:right;" /&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/fieldset&gt;<br/>    &lt;/div&gt; <br/><br/>&lt;div id="divRegister"&gt; &lt;!-- Our Registration form--&gt;<br/>     &lt;fieldset&gt;<br/>         &lt;legend&gt;Register&lt;/legend&gt;<br/>         &lt;div class="form-group"&gt;<br/>             &lt;label for="name" class="col-lg-2 control-<br/>             label"&gt;Name&lt;/label&gt;<br/>             &lt;div class="col-lg-10"&gt;<br/>                 &lt;input type="text" class="form-control" id="name" <br/>                 placeholder="Name"&gt;<br/>             &lt;/div&gt;<br/>         &lt;/div&gt;<br/>         &lt;div class="form-group"&gt;<br/>             &lt;label for="image" class="col-lg-2 control-<br/>             label"&gt;Avatar&lt;/label&gt;<br/>             &lt;div class="col-lg-10"&gt;<br/>                 &lt;input type="file" class="form-control" id="image" <br/>                 /&gt;<br/>             &lt;/div&gt;<br/>         &lt;/div&gt;<br/>         &lt;div class="form-group"&gt;<br/>             &lt;div class="col-lg-10 col-lg-offset-2"&gt;<br/>                 &lt;button type="button" class="btn btn-primary" <br/>                 id="btnRegister"&gt;Register&lt;/button&gt;<br/>             &lt;/div&gt;<br/>         &lt;/div&gt;<br/>     &lt;/fieldset&gt;<br/> &lt;/div&gt;</pre>
<ol start="5">
<li>When the player registers by clicking the <kbd>Register</kbd> button, the player's details need to be sent to the server. To do this, we will write the JavaScript to send details to our <kbd>gameHub</kbd>:</li>
</ol>
<pre style="padding-left: 60px"> let hubUrl = '/gameHub';<br/> let httpConnection = new signalR.HttpConnection(hubUrl);<br/> let hubConnection = new signalR.HubConnection(httpConnection);<br/> var playerName = "";<br/> var playerImage = "";<br/> var hash = "#";<br/> hubConnection.start();<br/><br/>$("#btnRegister").click(function () {  //// Fires on button click<br/>        playerName = $('#name').val();   //// Sets the player name <br/>        with the input name.<br/>        playerImage = $('#previewImage').attr('src'); //// Sets the <br/>        player image variable with specified image<br/>        var data = playerName.concat(hash, playerImage); //// The <br/>        registration data to be sent to server.<br/>        hubConnection.invoke('RegisterPlayer', data); //// Invoke <br/>        the "RegisterPlayer" method on gameHub.<br/>    });<br/><br/>$("#image").change(function () { //// Fires when image is changed.<br/>        readURL(this); //// HTML 5 way to read the image as data <br/>        url.<br/>    });<br/><br/>    function readURL(input) {<br/>        if (input.files &amp;&amp; input.files[0]) { //// Go in only if <br/>        image is specified.<br/>            var reader = new FileReader();<br/>            reader.onload = imageIsLoaded;<br/>            reader.readAsDataURL(input.files[0]);<br/>        }<br/>    }<br/><br/>    function imageIsLoaded(e) {<br/>        if (e.target.result) {<br/>            $('#previewImage').attr('src', e.target.result); //// <br/>            Sets the image source for preview.<br/>            $("#divPreviewImage").show();<br/>        }<br/>    };</pre>
<ol start="6">
<li>The player now has a UI to input the name and image, see the preview image, and click <kbd>Register</kbd>. On clicking the <kbd>Register</kbd> button, we are sending the concatenated name and image to the <kbd>gameHub</kbd> on the server through&#160;<kbd>hubConnection.invoke('RegisterPlayer', data);</kbd>&#160; So, it's quite simple for the client to make a call to the server. Initialize the <kbd>hubConnection</kbd> by specifying hub name as we did in the first three lines of the preceding code snippet. Start the connection by <kbd>hubConnection.start();</kbd>, and then invoke the server hub method by calling the <kbd>invoke</kbd> method, specifying the hub method name and the parameter it expects. We have not yet created the hub, so let's create the <kbd>GameHub</kbd> class on the server:</li>
</ol>
<pre style="padding-left: 90px">/// &lt;summary&gt;<br/>/// The Game Hub class derived from Hub<br/>/// &lt;/summary&gt;<br/>public class GameHub : Hub<br/>{<br/>     /// &lt;summary&gt;<br/>     /// To keep the list of all the connected players <br/>         registered with the game hub. We could have      <br/>     /// used normal list but used concurrent bag as its thread <br/>         safe.<br/>     /// &lt;/summary&gt;<br/>     private static readonly ConcurrentBag&lt;Player&gt; players = <br/>     new ConcurrentBag&lt;Player&gt;();<br/><br/>     /// &lt;summary&gt;<br/>     /// Registers the player with name and image.<br/>     /// &lt;/summary&gt;<br/>     /// &lt;param name="nameAndImageData"&gt;The name and image data <br/>         sent by the player.&lt;/param&gt;<br/>     public void RegisterPlayer(string nameAndImageData)<br/>     {<br/>         var splitData = nameAndImageData?.Split(new char[] { <br/>         '#' }, StringSplitOptions.None);<br/>         string name = splitData[0];<br/>         string image = splitData[1];<br/>         var player = players?.FirstOrDefault(x =&gt; <br/>         x.ConnectionId == Context.ConnectionId);<br/>         if (player == null)<br/>         {<br/>             player = new Player { ConnectionId = <br/>             Context.ConnectionId, Name = name, IsPlaying =                <br/>             false, IsSearchingOpponent = false, RegisterTime = <br/>             DateTime.UtcNow, Image = image };<br/>             if (!players.Any(j =&gt; j.Name == name))<br/>             {<br/>                 players.Add(player);<br/>             }<br/>         }<br/><br/>         this.OnRegisterationComplete(Context.ConnectionId);<br/>       }<br/><br/>       /// &lt;summary&gt;<br/>       /// Fires on completion of registration.<br/>       /// &lt;/summary&gt;<br/>       /// &lt;param name="connectionId"&gt;The connectionId of the <br/>           player which registered&lt;/param&gt;<br/>       public void OnRegisterationComplete(string connectionId)<br/>       {<br/>           //// Notify this connection id that the registration <br/>                is complete.<br/>           this.Clients.Client(connectionId).<br/>           InvokeAsync(Constants.RegistrationComplete);<br/>       }<br/>}</pre>
<p style="padding-left: 60px">The code comments make it self-explanatory. The class should derive from the SignalR <kbd>Hub</kbd> class for it to be recognized as <kbd>Hub.</kbd></p>
<p style="padding-left: 60px">There are two methods of interest which can be overridden. Notice that both the methods follow the async pattern and hence return <kbd>Task</kbd>:</p>
<ul>
<li><kbd>Task OnConnectedAsync()</kbd>: This method fires when a client/player connects to the hub.</li>
</ul>
<ul>
<li><kbd>Task OnDisconnectedAsync(Exception exception)</kbd>: This method fires when a client/player disconnects or looses the connection. We will override this method to handle the scenario where the player disconnects.</li>
</ul>
<p style="padding-left: 60px">There are also a few properties that the hub class exposes:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>Context</kbd>: This property is of type <kbd>HubCallerContext</kbd> and gives us access to the following properties:
<ul>
<li><kbd>Connection</kbd>: Gives access to the current connection</li>
<li><kbd>User</kbd>: Gives access to the <kbd>ClaimsPrincipal</kbd> of the user who is currently connected</li>
<li><kbd>ConnectionId</kbd>: Gives the current connection ID string</li>
</ul>
</li>
<li><kbd>Clients</kbd>: This property is of type&#160;<kbd>IHubClients</kbd> and gives us the way to communicate to all the clients via the client proxy</li>
<li><kbd>Groups</kbd>: This property is of type <kbd>IGroupManager</kbd> and provides a way to add and remove connections to the group asynchronously</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">To keep the things simple, we are not using a database to keep track of our registered players. Rather we will use an in-memory collection to keep the registered players. We could have used a normal list of players, such as <kbd>List&lt;Player&gt;</kbd>, but then we would need all the thread safety and use one of the thread safety primitives, such as&#160;<kbd>lock</kbd>, <kbd>monitor</kbd>, and so on, so we are going with <kbd>ConcurrentBag&lt;Player&gt;</kbd>, which is thread safe and reasonable for our game development. That explains the declaration of the players collection in the class. We will need to do some housekeeping to add players to this collection when they resister and remove them when they disconnect.</p>
<p style="padding-left: 60px">We saw in previous step that the client invoked the&#160;<kbd>RegisterPlayer</kbd> method of the hub on the server, passing in the name and image data. So we defined a <kbd>public</kbd> method in our hub, named <kbd>RegisterPlayer,</kbd> accepting the name and image data string concatenated through <kbd>#</kbd>. This is just one of the simple ways of accepting the client data for demonstration purposes, we can also use strongly typed parameters. In this method, we split the string on <kbd>#</kbd> and extract the name as the first part and the image as the second part. We then check if the player with the current connection ID already exists in our players collection. If it doesn't, we create a <kbd>Player</kbd> object with default values and add them to our players collection. We are distinguishing the player based on the name for demonstration purposes, but we can add an <kbd>Id</kbd> property in the&#160;<kbd>Player</kbd> class and make different players have the same name also. After the registration is complete, the server needs to update the player, that the registration is complete and the player can then look for the opponent. To do so, we make a call to the&#160;<kbd>OnRegistrationComplete</kbd> method which invokes a method called &#160;<kbd>registrationComplete</kbd> on the client with the current connection ID. Let's understand the code to invoke the method on the client:</p>
<pre style="padding-left: 60px">this.Clients.Client(connectionId).InvokeAsync(Constants.RegistrationComplete);</pre>
<p style="padding-left: 60px">On the <kbd>Clients</kbd> property, we can choose a client having a specific connection ID (in this case, the current connection ID from the <kbd>Context</kbd>) and then call <kbd>InvokeAsync</kbd> to invoke a method on the client specifying the method name and parameters as required. In the preceding case method, the name is <kbd>registrationComplete</kbd> with no parameters.</p>
<p style="padding-left: 60px">Now we know how to invoke a server method from the client and also how to invoke the client method from the server. We also know how to select a specific client and invoke a method there. We can invoke the client method from the server, for all the clients, a group of clients, or a specific client, so rest of the coding stuff would be just a repetition of these two concepts.</p>
<ol start="7">
<li>Next, we need to implement the&#160;<kbd>registrationComplete</kbd> method on the client. On registration completion, the registration form should be hidden and the player should be able to find an opponent to play against. To do so, we would write JavaScript code to hide the registration form and show the UI for finding the opponent. On clicking the <kbd>Find Opponent</kbd> button, we need the server to pair us against an opponent, so we need to invoke a hub method on server to find opponent.</li>
<li>The server can respond us with two outcomes:
<ul>
<li>It finds an opponent player to play against. In this case, the game can start so we need to simulate the coin toss, determine the player who can make the first move, and start the game. This would be a game board in the client-user interface.</li>
<li>It doesn't find an opponent and asks the player to wait for another player to register and search for an opponent. This would be a no opponent found screen in the client.</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">In both the cases, the server would do some processing and invoke a method on the client. Since we need a lot of different user interfaces for different scenarios, let's code the HTML markup inside <kbd>div</kbd> to make it easier to show and hide sections based on the server response. We will add the following code snippet in the body. The comments specify the purpose of each of the <kbd>div</kbd> elements and markup inside them:</p>
<pre style="padding-left: 60px">&lt;div id="divFindOpponentPlayer"&gt; &lt;!-- Section to display Find Opponent --&gt;<br/>     &lt;fieldset&gt;<br/>         &lt;legend&gt;Find a player to play against!&lt;/legend&gt;<br/>         &lt;div class="form-group"&gt;<br/>             &lt;input type="button" class="btn btn-primary" <br/>             id="btnFindOpponentPlayer" value="Find Opponent                 <br/>             Player" /&gt;<br/>         &lt;/div&gt;<br/>     &lt;/fieldset&gt;<br/> &lt;/div&gt;<br/>     &lt;div id="divFindingOpponentPlayer"&gt; &lt;!-- Section to display <br/>     opponent not found, wait --&gt;<br/>     &lt;fieldset&gt;<br/>         &lt;legend&gt;Its lonely here!&lt;/legend&gt;<br/>         &lt;div class="form-group"&gt;<br/>             Looking for an opponent player. Waiting for someone to <br/>             join!<br/>         &lt;/div&gt;<br/>     &lt;/fieldset&gt;<br/> &lt;/div&gt;<br/> &lt;div id="divGameInformation" class="form-group"&gt; &lt;!-- Section to <br/> display game information--&gt;<br/>     &lt;div class="form-group" id="divGameInfo"&gt;&lt;/div&gt;<br/>     &lt;div class="form-group" id="divInfo"&gt;&lt;/div&gt;<br/> &lt;/div&gt;<br/> &lt;div id="divGame" style="clear:both"&gt; &lt;!-- Section where the game <br/> board would be displayed --&gt;<br/>     &lt;fieldset&gt;<br/>         &lt;legend&gt;Game On&lt;/legend&gt;<br/>         &lt;div id="divGameBoard" style="width:380px"&gt;&lt;/div&gt;<br/>     &lt;/fieldset&gt;<br/> &lt;/div&gt;</pre>
<p style="padding-left: 60px">The following client-side code would take care of <em>Steps 7</em> and <em>8</em>. Though the comments are self-explanatory, we will quickly see what all stuff is that is going on here. We handle the <kbd>registartionComplete</kbd> method and display the <kbd>Find Opponent Player</kbd> section. This section has a button to find an opponent player called <kbd>btnFindOpponentPlayer</kbd>. We define the event handler of the button to invoke the&#160;<kbd>FindOpponent</kbd> method on the hub. We will see the hub method implementation later, but we know that the hub method would either find an opponent or would not find an opponent, so we have defined the methods <kbd>opponentFound</kbd> and <kbd>opponentNotFound</kbd>, respectively,&#160;<span>to handle these scenarios. In the <kbd>opponentNotFound</kbd> method, we just display a section in which we say, we do not have an opponent player. In the&#160;<kbd>opponentFound</kbd> method, we display the game section, game information section, opponent display picture section, and draw the Tic-Tac-Toe game board as a 3Ã—3 grid using CSS styling. All the other sections are hidden:</span></p>
<pre style="padding-left: 60px"> $("#btnFindOpponentPlayer").click(function () {<br/>        hubConnection.invoke('FindOpponent');<br/>    });<br/> <br/>hubConnection.on('registrationComplete', data =&gt; { //// Fires on registration complete. Invoked by server hub<br/>     $("#divRegister").hide();  // hide the registration div<br/>     $("#divFindOpponentPlayer").show(); // display find opponent <br/>     player div.<br/> });<br/>  <br/> hubConnection.on('opponentNotFound', data =&gt; { //// Fires when no opponent is found.<br/>        $('#divFindOpponentPlayer').hide(); //// hide the find <br/>        opponent player section.<br/>        $('#divFindingOpponentPlayer').show(); //// display the <br/>        finding opponent player div.<br/>    });<br/><br/>   hubConnection.on('opponentFound', (data, image) =&gt; { //// Fires <br/>   when opponent player is found.<br/>        $('#divFindOpponentPlayer').hide();   <br/>        $('#divFindingOpponentPlayer').hide();<br/>        $('#divGame').show();  //// Show game board section.<br/>        $('#divGameInformation').show(); //// Show game information<br/>        $('#divOpponentPlayer').show(); //// Show opponent player <br/>        image.<br/>        opponentImage = image;  //// sets the opponent player image <br/>        for display<br/>        $('#opponentImage').attr('src', opponentImage); //// Binds <br/>        the opponent player image<br/>        $('#divGameInfo').html("&lt;br/&gt;&lt;span&gt;&lt;strong&gt; Hey " + <br/>        playerName + "! You are playing against &lt;i&gt;" + data + "&lt;/i&gt;<br/>        &lt;/strong&gt;&lt;/span&gt;");  //// displays the information of <br/>        opponent that the player is playing against.<br/>        //// Draw the tic-tac-toe game board, A 3x3 grid :) by  <br/>        proper styling.<br/>        for (var i = 0; i &lt; 9; i++) {<br/>            $("#divGameBoard").append("&lt;span class='marker' id=" + i <br/>            + " style='display:block;border:2px solid <br/>           black;height:100px;width:100px;float:left;margin:10px;'&gt;" <br/>           + i + "&lt;/span&gt;");<br/>        }<br/>    });</pre>
<p style="padding-left: 60px">First we need to have a <kbd>Game</kbd> object to track a game, players involved, moves left, and check if there is a winner. We will have a <kbd>Game</kbd> class defined as per the following code. The comments detail the purpose of the methods and the properties defined:</p>
<pre style="padding-left: 60px">internal class Game<br/>{<br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the value indicating whether the <br/>         game is over.<br/>     /// &lt;/summary&gt;<br/>     public bool IsOver { get; private set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the value indicating whether the <br/>         game is draw.<br/>     /// &lt;/summary&gt;<br/>     public bool IsDraw { get; private set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// Gets or sets Player 1 of the game<br/>     /// &lt;/summary&gt;<br/>     public Player Player1 { get; set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// Gets or sets Player 2 of the game<br/>     /// &lt;/summary&gt;<br/>     public Player Player2 { get; set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// For internal housekeeping, To keep track of value in each <br/>         of the box in the grid.<br/>     /// &lt;/summary&gt;<br/>     private readonly int[] field = new int[9];<br/><br/>     /// &lt;summary&gt;<br/>     /// The number of moves left. We start the game with 9 moves <br/>         remaining in a 3x3 grid.<br/>     /// &lt;/summary&gt;<br/>     private int movesLeft = 9;<br/><br/>     /// &lt;summary&gt;<br/>     /// Initializes a new instance of the <br/>         &lt;see cref="Game"/&gt; class.<br/>     /// &lt;/summary&gt;<br/>     public Game()<br/>     {<br/>         //// Initialize the game<br/>         for (var i = 0; i &lt; field.Length; i++)<br/>         {<br/>             field[i] = -1;<br/>         }<br/>     }<br/>     /// &lt;summary&gt;<br/>     /// Place the player number at a given position for a player<br/>     /// &lt;/summary&gt;<br/>     /// &lt;param name="player"&gt;The player number would be 0 or    <br/>         1&lt;/param&gt;<br/>     /// &lt;param name="position"&gt;The position where player number  <br/>         would be placed, should be between 0 and        <br/>     ///8, both inclusive&lt;/param&gt;<br/>     /// &lt;returns&gt;Boolean true if game is over and <br/>         we have a winner.&lt;/returns&gt;<br/>     public bool Play(int player, int position)<br/>     {<br/>         if (this.IsOver)<br/>         {<br/>             return false;<br/>         }<br/>         //// Place the player number at the given position<br/>         this.PlacePlayerNumber(player, position);<br/>         //// Check if we have a winner. If this returns true, <br/>         //// game would be over and would have a winner, else game <br/>              would continue.<br/>         return this.CheckWinner();<br/>     }<br/> }</pre>
<p style="padding-left: 60px">Now we have the entire game mystery solved with the <kbd>Game</kbd> class. We know when the game is over, we have the method to place the player marker, and check the winner. The f<span>ollowing server side-code on the&#160;</span><kbd>GameHub</kbd><span>&#160;will handle <em>Steps 7</em> and <em>8</em>:</span></p>
<pre style="padding-left: 60px">/// &lt;summary&gt;<br/>/// The list of games going on.<br/>/// &lt;/summary&gt;<br/>private static readonly ConcurrentBag&lt;Game&gt; games = new ConcurrentBag&lt;Game&gt;();<br/><br/>/// &lt;summary&gt;<br/>/// To simulate the coin toss. Like heads and tails, 0 belongs to  <br/>    one player and 1 to opponent.<br/>/// &lt;/summary&gt;<br/>private static readonly Random toss = new Random();<br/><br/>/// &lt;summary&gt;<br/>/// Finds the opponent for the player and sets the Seraching for <br/>    Opponent property of player to true. <br/>/// We will use the connection id from context to identify the <br/>    current player.<br/>/// Once we have 2 players looking to play, we can pair them and <br/>    simulate coin toss to start the game.<br/>/// &lt;/summary&gt;<br/>public void FindOpponent()<br/>{<br/>    //// First fetch the player from our players collection having <br/>         current connection id<br/>    var player = players.FirstOrDefault(x =&gt; x.ConnectionId == <br/>    Context.ConnectionId);<br/>    if (player == null)<br/>    {<br/>        //// Since player would be registered before making this <br/>             call,<br/>        //// we should not reach here. If we are here, something <br/>             somewhere in the flow above is broken.<br/>        return;<br/>     }<br/><br/>     //// Set that player is seraching for opponent.<br/>     player.IsSearchingOpponent = true;<br/><br/>     //// We will follow a queue, so find a player who registered <br/>          earlier as opponent. <br/>     //// This would only be the case if more than 2 players are <br/>          looking for opponent.<br/>     var opponent = players.Where(x =&gt; x.ConnectionId != <br/>     Context.ConnectionId &amp;&amp; x.IsSearchingOpponent &amp;&amp; <br/>     !x.IsPlaying).OrderBy(x =&gt;x.RegisterTime).FirstOrDefault();<br/>     if (opponent == null)<br/>     {<br/>         //// Could not find any opponent, invoke opponentNotFound <br/>              method in the client.<br/>         Clients.Client(Context.ConnectionId)<br/>         .InvokeAsync(Constants.OpponentNotFound);<br/>         return;<br/>     }<br/><br/>     //// Set both players as playing.<br/>     player.IsPlaying = true;<br/>     player.IsSearchingOpponent = false; //// Make him unsearchable <br/>     for opponent search<br/><br/>     opponent.IsPlaying = true;<br/>     opponent.IsSearchingOpponent = false;<br/><br/>      //// Set each other as opponents.<br/>      player.Opponent = opponent;<br/>      opponent.Opponent = player;<br/><br/>      //// Notify both players that they can play by invoking <br/>           opponentFound method for both the players.<br/>      //// Also pass the opponent name and opoonet image, so that <br/>           they can visualize it.<br/>      //// Here we are directly using connection id, but group is a <br/>           good candidate and use here.<br/>      Clients.Client(Context.ConnectionId)<br/>      .InvokeAsync(Constants.OpponentFound, opponent.Name,    <br/>      opponent.Image);<br/>      Clients.Client(opponent.ConnectionId)<br/>      .InvokeAsync(Constants.OpponentFound, player.Name, <br/>      player.Image);<br/>      <br/>       //// Create a new game with these 2 player and add it to <br/>            games collection.<br/>       games.Add(new Game { Player1 = player, Player2 = opponent });<br/>  }</pre>
<p style="padding-left: 60px">Here, we have created a games collection to keep track of ongoing games and a&#160;<kbd>Random</kbd> field named toss to simulate the coin toss. How&#160;<kbd>FindOpponent</kbd>&#160;works is documented in the comments and is intuitive to understand.</p>
<ol start="9">
<li>Once the game starts, each player has to make a move and then wait for the opponent to make a move, until the game ends. The move is made by clicking on the available grid cells. Here, we need to ensure that cell position that is already marked by one of the players is not changed or marked. So, as soon as a valid cell is marked, we set its CSS class to&#160;<kbd>notAvailable</kbd>&#160;so we know that the cell is taken. While clicking on a cell, we will check whether the cell has&#160;<kbd>notAvailablestyle</kbd>. If yes, it cannot be marked. If not, the cell can be marked and we then send the marked position to the server hub. We also see the <kbd>waitingForMove</kbd>, <kbd>moveMade</kbd>, <kbd>gameOver</kbd>, and <kbd>opponentDisconnected</kbd> events invoked by the server based on the game state. The code is commented and is pretty straightforward. The <kbd>moveMade</kbd> method in the following code makes use of the&#160;<kbd>MoveInformation</kbd> class, which we will define at the server for sharing move information with both players:</li>
</ol>
<pre style="padding-left: 60px">//// Triggers on clicking the grid cell.<br/> $(document).on('click', '.marker', function () {<br/>     if ($(this).hasClass("notAvailable")) { //// Cell is already <br/>     taken.<br/>     return;<br/>     }<br/><br/><span>    hubConnection.invoke('MakeAMove', $(this)[0].id); //// Cell is <br/>    valid, send details to hub.</span><br/><span>});<br/><br/>//// Fires when player has to make a move.<br/>hubConnection.on('waitingForMove', data =&gt; {<br/>    $('#divInfo').html("&lt;br/&gt;&lt;span&gt;&lt;strong&gt; Your turn &lt;i&gt;" + <br/>    playerName + "&lt;/i&gt;! Make a winning move! &lt;/strong&gt;&lt;/span&gt;");<br/>});<br/><br/>//// Fires when move is made by either player.<br/>hubConnection.on('moveMade', data =&gt; { <br/>    if (data.Image == playerImage) { //// Move made by player.<br/>        $("#" + data.ImagePosition).addClass("notAvailable");<br/>        $("#" + data.ImagePosition).css('background-image', <br/>        'url(' + data.Image + ')'); <br/>        $('#divInfo').html("&lt;br/&gt;&lt;strong&gt;Waiting for &lt;i&gt;" + <br/>        data.OpponentName + "&lt;/i&gt; to make a move.            <br/>        &lt;/strong&gt;");<br/>    }<br/>    else {<br/>        $("#" + data.ImagePosition).addClass("notAvailable");<br/>        $("#" + data.ImagePosition).css('background-image', <br/>        'url(' + data.Image + ')');<br/>        $('#divInfo').html("&lt;br/&gt;&lt;strong&gt;Waiting for &lt;i&gt;" + <br/>        data.OpponentName + "&lt;/i&gt; to make a move.            <br/>        &lt;/strong&gt;");<br/>    }<br/>});<br/><br/>//// Fires when the game ends.<br/>hubConnection.on('gameOver', data =&gt; {<br/>    $('#divGame').hide();<br/>    $('#divInfo').html("&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Hey " + playerName + <br/>    "! " + data + " &lt;/strong&gt;&lt;/span&gt;");<br/>    $('#divGameBoard').html(" ");<br/>    $('#divGameInfo').html(" ");<br/>    $('#divOpponentPlayer').hide();<br/>});<br/><br/>//// Fires when the opponent disconnects.<br/>hubConnection.on('opponentDisconnected', data =&gt; {<br/>        $("#divRegister").hide();<br/>        $('#divGame').hide();<br/>        $('#divGameInfo').html(" ");<br/>        $('#divInfo').html("&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Hey " + playerName + <br/>        "! Your opponent disconnected or left     the battle! You <br/>        are the winner ! Hip Hip Hurray!!!&lt;/strong&gt;&lt;/span&gt;");<br/>    });<br/><br/></span></pre>
<p style="padding-left: 60px"><span>After every move, both players need to be updated by the server about the move made, so that both players' game boards are in sync. So, on the server side we will need an additional model called&#160;</span><kbd>MoveInformation</kbd><span>, which will contain information on the latest move made by the player and the server will send this model to both the clients to keep them in sync:&#160;</span></p>
<pre style="padding-left: 60px" class="mce-root"> /// &lt;summary&gt;<br/> /// While playing the game, players would make moves. This class <br/>     contains the information of those moves.<br/> /// &lt;/summary&gt;<br/> internal class MoveInformation<br/> {<br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the opponent name.<br/>     /// &lt;/summary&gt;<br/>     public string OpponentName { get; set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the player who made the move.<br/>     /// &lt;/summary&gt;<br/>     public string MoveMadeBy { get; set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the image position. The position in the game <br/>         board (0-8) where the player placed his         <br/>     /// image.<br/>     /// &lt;/summary&gt;<br/>     public int ImagePosition { get; set; }<br/><br/>     /// &lt;summary&gt;<br/>     /// Gets or sets the image. The image of the player that he <br/>         placed in the board (0-8)<br/>     /// &lt;/summary&gt;<br/>     public string Image { get; set; }<br/>  }</pre>
<p style="padding-left: 60px" class="mce-root">Finally, we will wire up the remaining methods in the <kbd>GameHub</kbd> class to complete the game coding. The&#160;<kbd>MakeAMove</kbd> method is called every time a player makes a move. Also, we have overidden the&#160;<kbd>OnDisconnectedAsync</kbd> method to inform&#160;a player when their opponent disconnects. In this method, we also keep our players and games list current.&#160;<span>The comments in the code explain the workings of the methods:</span></p>
<pre style="padding-left: 60px"> /// &lt;summary&gt;<br/> /// Invoked by the player to make a move on the board.<br/> /// &lt;/summary&gt;<br/> /// &lt;param name="position"&gt;The position to place <br/>     the player&lt;/param&gt;<br/> public void MakeAMove(int position)<br/> {<br/>        //// Lets find a game from our list of games where one of  <br/>             the player has the same connection Id as the current <br/>             connection has.<br/>            var game = games?.FirstOrDefault(x =&gt; <br/>            x.Player1.ConnectionId == Context.ConnectionId || <br/>            x.Player2.ConnectionId == Context.ConnectionId);<br/><br/>            if (game == null || game.IsOver)<br/>            {<br/>                //// No such game exist!<br/>                return;<br/>            }<br/><br/>            //// Designate 0 for player 1<br/>            int symbol = 0;<br/>                       <br/>            if (game.Player2.ConnectionId == Context.ConnectionId)<br/>            {<br/>                //// Designate 1 for player 2.<br/>                symbol = 1;<br/>            }<br/><br/>            var player = symbol == 0 ? game.Player1 : game.Player2;<br/>                        <br/>            if (player.WaitingForMove)<br/>            {<br/>                return;<br/>            }<br/>            <br/>            //// Update both the players that move is made.<br/>            Clients.Client(game.Player1.ConnectionId)<br/>            .InvokeAsync(Constants.MoveMade, new MoveInformation {  <br/>            OpponentName = player.Name, ImagePosition = position,   <br/>            Image = player.Image });<br/>            Clients.Client(game.Player2.ConnectionId)<br/>            .InvokeAsync(Constants.MoveMade, new MoveInformation {    <br/>            OpponentName = player.Name, ImagePosition = position, <br/>            Image = player.Image });<br/><br/>            //// Place the symbol and look for a winner after every <br/>                 move.<br/>            if (game.Play(symbol, position))<br/>            {<br/>                Remove&lt;Game&gt;(games, game);<br/>                Clients.Client(game.Player1.ConnectionId)<br/>                .InvokeAsync(Constants.GameOver, $"The winner is   <br/>                {player.Name}");<br/>                Clients.Client(game.Player2.ConnectionId)<br/>                .InvokeAsync(Constants.GameOver, $"The winner is    <br/>                {player.Name}");<br/>                player.IsPlaying = false;<br/>                player.Opponent.IsPlaying = false;<br/>                this.Clients.Client(player.ConnectionId)<br/>                .InvokeAsync(Constants.RegistrationComplete);<br/>                this.Clients.Client(player.Opponent.ConnectionId)<br/>                .InvokeAsync(Constants.RegistrationComplete);<br/>            }<br/><br/>            //// If no one won and its a tame draw, update the <br/>                 players that the game is over and let them <br/>                 look for new game to play.<br/>            if (game.IsOver &amp;&amp; game.IsDraw)<br/>            {<br/>                Remove&lt;Game&gt;(games, game);<br/>                Clients.Client(game.Player1.ConnectionId)<br/>                .InvokeAsync(Constants.GameOver, "Its a tame  <br/>                draw!!!");<br/>                Clients.Client(game.Player2.ConnectionId)<br/>                .InvokeAsync(Constants.GameOver, "Its a tame <br/>                draw!!!");<br/>                player.IsPlaying = false;<br/>                player.Opponent.IsPlaying = false;<br/>                this.Clients.Client(player.ConnectionId)<br/>                .InvokeAsync(Constants.RegistrationComplete);<br/>                this.Clients.Client(player.Opponent.ConnectionId)<br/>                .InvokeAsync(Constants.RegistrationComplete);<br/>            }<br/><br/>            if (!game.IsOver)<br/>            {<br/>                player.WaitingForMove = !player.WaitingForMove;<br/>                player.Opponent.WaitingForMove =    <br/>                !player.Opponent.WaitingForMove;<br/>                Clients.Client(player.Opponent.ConnectionId)<br/>                .InvokeAsync(Constants.WaitingForOpponent,   <br/>                player.Opponent.Name);<br/>                Clients.Client(player.ConnectionId)<br/>                .InvokeAsync(Constants.WaitingForOpponent, <br/>                player.Opponent.Name);<br/>            }<br/>        }</pre>
<p class="mce-root">With this, we are done with the coding of the game and are ready to run the game app. The detailed source code can be downloaded from&#160;<a href="https://github.com/PacktPublishing/.NET-Core-2.0-By-Example">https://github.com/PacktPublishing/.NET-Core-2.0-By-Example</a>.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Game demo</h1>
                </header>
            
            <article>
                
<p>Now that our app is ready, let's run it and enjoy the game. Press <em>F5</em> and the game should be launched in the browser. This will work for both Visual Studio 2017 IDE and Visual Studio Code. Also, since we are running it in our local machine, both players will need to play it on the same machine for the time being. Once we deploy this game in Azure, players can browse the URL from their individual machines. We will see how we can publish an ASP.NET Core 2.0 app to Azure in a later chapter.</p>
<p>This is what the game registration UI looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d7d77f3-fd57-4fac-ba66-85266a267634.png"/></div>
<p>On clicking <span class="packt_screen">Register</span>, the find opponent screen is displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="222" width="323" src="assets/cbb06037-597d-465c-a00c-ce70a3f9cb89.jpg"/></div>
<p>On clicking the <span class="packt_screen">Find Opponent Player</span> button, if a registered player exists, the game starts and this is what the two-player game looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="325" width="664" src="assets/f2383980-13ac-4ca6-ad52-33186d658fc5.jpg"/></div>
<p>If a player is not available, or you are the lone warrior registered to play, the following screen will be displayed:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/666153c2-cb46-449e-a440-9f2decb04729.jpg"/></div>
<p>We have developed a fully functional two-player Tic-Tac-Toe game, meeting all the requirement specifications. It's time to enjoy your very first ASP.NET Core 2.0 game powered by SignalR Core!</p>
<ol start="7"></ol>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the project structure of a typical ASP.NET Core 2.0 app and understood the importance and purpose of each and every file that comes with the default MVC template. We also learned about SignalR and SignalR Core, and developed our very first game, Tic-Tac-Toe, on ASP.NET Core 2.0 based on the given requirements.</p>
<p>In the next chapter, we will deep dive into learning and coding the features of ASP.NET Core 2.0 while developing a real-time chat application for multiple clients called Let's Chat.</p>


            </article>

            
        </section>
    </div>
</body>
</html>