- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Design Patterns and .NET 8 Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式与 .NET 8 实现
- en: Design patterns can be defined as ready-to-use architectural solutions for common
    problems you encounter during software development. They are essential for understanding
    the .NET architecture and useful for solving ordinary problems that we face when
    designing any piece of software. In this chapter, we will look at the implementation
    of some design patterns. It is worth mentioning that this book does not explain
    all the known patterns we can use. The focus here is to explain the importance
    of studying and applying them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式可以被定义为针对你在软件开发过程中遇到的常见问题的现成架构解决方案。它们对于理解 .NET 架构至关重要，并且对于解决我们在设计任何软件时面临的普通问题非常有用。在本章中，我们将探讨一些设计模式的实现。值得一提的是，这本书并没有解释我们可以使用的所有已知模式。这里的重点是解释研究和应用它们的重要性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding design patterns and their purpose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式及其目的
- en: Understanding the design patterns available in .NET
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 .NET 中可用的设计模式
- en: By the end of this chapter, you will have learned about some of the use cases
    that you can implement with design patterns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解一些可以使用设计模式实现的使用案例。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need the free Visual Studio 2022 Community
    Edition or better.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这一章，你需要免费的 Visual Studio 2022 Community Edition 或更高版本。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)/tree/main/ch06.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)/tree/main/ch06
    找到本章的示例代码。
- en: Understanding design patterns and their purpose
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式及其目的
- en: Deciding on the design of a system is challenging, and the responsibility associated
    with this task is enormous. As software architects, we must always keep in mind
    that features such as great reusability, good performance, and good maintainability
    are important for delivering a good solution. This is where design patterns help
    and accelerate the design process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 决定系统的设计是一项挑战，与之相关的责任也非常重大。作为软件架构师，我们必须始终牢记，诸如高度可重用性、良好性能和良好可维护性等特性对于提供良好的解决方案至关重要。这就是设计模式发挥作用并加速设计过程的地方。
- en: 'As we mentioned previously, design patterns are solutions that have already
    been discussed and defined so that they can solve common software architectural
    problems. This approach grew in popularity after the release of the book *Design
    Patterns – Elements of Reusable Object-Oriented Software*, where the **Gang of
    Four** (**GoF**) divided these patterns into three types: creational, structural,
    and behavioral.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，设计模式是已经被讨论和定义的解决方案，以便它们可以解决常见的软件架构问题。这种做法在《设计模式——可重用面向对象软件的元素》一书发布后变得流行起来，其中**四人帮**（**GoF**）将这些模式分为三种类型：创建型、结构型和行为型。
- en: 'A little bit later, Uncle Bob introduced the SOLID principles to the developer
    community, giving us the opportunity to efficaciously organize the functions and
    data structures of each system. The SOLID design principles indicate how the components
    of software should be designed and connected. It is worth mentioning that, compared
    to the design patterns presented by GoF, the SOLID principles do not deliver code
    recipes. Instead, they give you the basic principles to follow when you design
    your solutions, keeping the software’s structure strong and reliable. They can
    be defined as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点时间后，Uncle Bob 将 SOLID 原则引入了开发者社区，给了我们有效地组织每个系统的函数和数据结构的机会。SOLID 设计原则指出了软件组件应该如何设计和连接。值得一提的是，与
    GoF 提出的设计模式相比，SOLID 原则并不提供代码食谱。相反，它们在你设计解决方案时提供了遵循的基本原则，以保持软件结构的强大和可靠。它们可以被定义为如下：
- en: '**Single Responsibility**: A module or function should be responsible for a
    single purpose.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：一个模块或函数应该只负责单一目的。'
- en: '**Open-Closed**: A software artifact should be open for extension but closed
    for modification.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：一个软件工件应该对扩展开放，但对修改封闭。'
- en: '**Liskov Substitution**: The behavior of a program needs to remain unchanged
    when you substitute one of its components for another component that has been
    defined by a supertype of the primer object.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov 替换原则**：当你将程序的一个组件替换为另一个由原始对象的超类型定义的组件时，程序的行为需要保持不变。'
- en: '**Interface Segregation**: Depending on the way you create interfaces, you
    will promote dependencies that do not necessarily occur when you build their concrete
    objects, causing harm to the system architecture.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：根据你创建接口的方式，你将促进那些在构建它们的实际对象时可能不会发生的依赖，从而损害系统架构。'
- en: '**Dependency Inversion**: The most flexible systems are the ones where object
    dependencies only refer to abstractions.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置**：最灵活的系统是那些对象依赖仅指向抽象的系统。'
- en: 'As technologies and software problems change, more patterns are conceived.
    The advance of cloud computing has brought a bunch of them, and some can be found
    at [https://docs.microsoft.com/en-us/azure/architecture/patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns).
    The content is organized into three different challenge areas: Data Management,
    Design and Implementation, and Messaging. Many of them are described in the chapters
    of this book, as we can see in the list below:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术和软件问题的变化，更多的模式被构思出来。云计算的进步带来了一大批这样的模式，其中一些可以在 [https://docs.microsoft.com/en-us/azure/architecture/patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns)
    找到。内容被组织成三个不同的挑战领域：数据管理、设计和实现、以及消息传递。其中许多在本书的章节中都有描述，如下面的列表所示：
- en: '**Asynchronous Request-Reply**: This pattern is presented while discussing
    Azure Durable Functions in *Chapter 16*, *Working with Serverless - Azure Functions*;
    the orchestrator function for **async HTTP APIs** solves this pattern.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步请求-响应**：在讨论 Azure Durable Functions 时，这种模式在 *第 16 章*，*使用无服务器 - Azure Functions*
    中被提出；用于 **异步 HTTP API** 的编排函数解决了这个模式。'
- en: '**Bulkhead Isolation**: This pattern is presented while discussing microservices
    design principles in *Chapter 11*, *Applying a Microservice Architecture to Your
    Enterprise Application*.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离舱隔离**：在讨论 *第 11 章*，*将微服务架构应用于您的企业应用* 中的微服务设计原则时，提出了这个模式。'
- en: '**Cache-Aside**: Caching was presented in *Chapter 1*, *Understanding the Importance
    of Software Architecture*. Its usage with Azure Redis is also presented in *Chapter
    12*, *Choosing Your Data Storage in the Cloud*.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存旁路**：缓存在 *第 1 章*，*理解软件架构的重要性* 中被提出。它还展示了与 Azure Redis 一起使用的用法，在 *第 12 章*，*在云中选择您的数据存储*
    中也有介绍。'
- en: '**Circuit-Breaker**: The strategy necessary to implement this is presented
    in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：实现此策略的方法在 *第 11 章*，*将微服务架构应用于您的企业应用* 中被提出。'
- en: '**Command Query Responsibility Segregation** (**CQRS**): CQRS is described
    in *Chapter 7*, *Understanding the Different Domains in Software Solutions*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**（**CQRS**）：CQRS 在 *第 7 章*，*理解软件解决方案的不同领域* 中被描述。'
- en: '**Publisher/Subscriber**: This pattern will be explained in the subsections
    below and discussed in *Chapter 7*, *Understanding the Different Domains in Software
    Solutions*.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者/订阅者**：这个模式将在下面的子节中解释，并在 *第 7 章*，*理解软件解决方案的不同领域* 中进行讨论。'
- en: '**Retry**: The *resilient task execution* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*, shows how to use
    Polly, a general framework for applying retries.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**：*第 11 章*，*将微服务架构应用于您的企业应用* 中的 *弹性任务执行* 子节展示了如何使用 Polly，这是一个用于应用重试的通用框架。'
- en: '**Queue-Based Load Leveling**: The scenario presented in *Chapter 16*, *Working
    with Serverless – Azure Functions*, uses a queue that acts as a buffer between
    a task and a service.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于队列的负载均衡**：在 *第 16 章*，*使用无服务器 – Azure Functions* 中提出的场景使用了一个充当任务和服务之间缓冲区的队列。'
- en: The reason why new patterns emerge is related to the challenges we face when
    new solutions are developed. Today, availability, data management, messaging,
    monitoring, performance, scalability, resiliency, and security are aspects we
    must deal with when delivering cloud solutions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 新模式出现的原因与我们开发新解决方案时面临的挑战有关。今天，在交付云解决方案时，我们必须处理可用性、数据管理、消息传递、监控、性能、可伸缩性、弹性和安全性等方面。
- en: The reason why you should always consider using design patterns in development
    is quite simple—as a software architect, you cannot spend time reinventing the
    wheel. However, there is another great reason for using and understanding them—you
    will find many of these patterns already implemented in .NET.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终考虑在开发中使用设计模式的原因非常简单——作为一个软件架构师，您不能花时间重新发明轮子。然而，使用和理解它们还有一个很好的理由——您会发现许多这些模式已经在
    .NET 中实现了。
- en: In the next few subsections, we will cover some of the most well-known patterns.
    The idea of this chapter is just to let you know that they exist and need to be
    studied so that you can accelerate and simplify your projects. Moreover, each
    pattern will be presented with a C# code snippet so that you can implement it
    in your projects while always remembering that we are talking about samples, not
    code ready for production.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将介绍一些最著名的模式。本章的目的是让您知道它们的存在，并需要研究它们，以便您能够加速并简化您的项目。此外，每个模式都将通过一个
    C# 代码片段来展示，这样您就可以在项目中实现它，同时始终记住我们谈论的是样本，而不是准备生产的代码。
- en: Builder pattern
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建造者模式
- en: There are cases where you will have a complex object with different behaviors
    due to its configuration. Instead of setting this object up while using it, you
    may want to decouple its configuration from its usage, using a customized configuration
    that is already built. This way, you have different representations of the instances
    you are building. This is where you should use the Builder pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您将有一个具有不同行为的复杂对象，这是由于其配置造成的。在您使用它时设置此对象，您可能希望将其配置与其使用解耦，使用已经构建的定制配置。这样，您就有您正在构建的实例的不同表示。这就是您应该使用建造者模式的地方。
- en: The following class diagram shows the pattern that has been implemented for
    a scenario from this book’s use case, presented in *Chapter 21*, *Case Study*.
    The idea behind this design choice is to simplify the way rooms from WWTravelClub
    are described.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图展示了本书用例中实现的一个场景的模式，该场景在*第 21 章*，*案例研究*中呈现。这种设计选择背后的想法是简化 WWTravelClub 中房间的描述方式。
- en: The Fluent API implemented in the `Room` class enables us to have the construction
    of each kind of room defined in each builder (`SimpleRoomBuilder` and `FamilyRoomBuilder`)
    more simply.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Room` 类中实现的 Fluent API 使我们能够更简单地构建每个在各个建造者（`SimpleRoomBuilder` 和 `FamilyRoomBuilder`）中定义的房间类型。'
- en: '![Graphical user interface, application  Description automatically generated](img/B19280_06_01.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19280_06_01.png)'
- en: 'Figure 6.1: Builder pattern'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：建造者模式
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of this implementation is quite simple but clarifies the reason
    why you need to implement a pattern:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的成果相当简单，但阐明了您需要实现模式的原因：
- en: '![Text  Description automatically generated](img/B19280_06_02.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19280_06_02.png)'
- en: 'Figure 6.2: Builder pattern sample result'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：建造者模式示例结果
- en: As soon as you have the implementation, evolving this code becomes simpler.
    For example, if you need to build a different style of room, you can just create
    a new builder for that type of room, and you will be able to use it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了实现，代码的演进就变得简单。例如，如果您需要构建不同风格的房间，您只需为该类型的房间创建一个新的建造者，您就可以使用它。
- en: 'The reason why this implementation becomes quite simple is related to the usage
    of chaining methods, as we can see in the `Room` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现变得相当简单的原因与链式方法的用法有关，正如我们在 `Room` 类中看到的那样：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Fortunately, if you need to add the configuration settings for the product,
    all the concrete classes you used previously will be defined in the Builder interface
    and stored there so that you can update them with ease.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果您需要添加产品的配置设置，您之前使用的所有具体类都将定义在 Builder 接口中，并存储在那里，这样您可以轻松地更新它们。
- en: We will see a great implementation of the Builder pattern in .NET in the *Understanding
    the design patterns available in .NET* section. There, you will be able to understand
    how Generic Host was implemented using `HostBuilder`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*理解 .NET 中可用的设计模式*部分看到 .NET 中 Builder 模式的一个很好的实现。在那里，您将能够理解如何使用 `HostBuilder`
    实现了 Generic Host。
- en: Factory pattern
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The Factory pattern is useful in situations where you have multiple objects
    from the same abstraction, and you only know which one needs to be created at
    runtime. This means you will have to create the instance according to a certain
    configuration or according to where the software lives now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式在有多种来自同一抽象的对象且只在运行时知道需要创建哪个对象的情况下很有用。这意味着你将根据某种配置或根据软件当前所在的位置来创建实例。
- en: For instance, let us check out the WWTravelClub sample. Here, there is a user
    story that describes that this application will have customers from all over the
    world paying for their trips. However, in the real world, there are different
    payment services available for each country. The process of paying is similar
    for each country, but this system will have more than one payment service available.
    A good way to simplify this payment implementation is by using the Factory pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看WWTravelClub示例。在这里，有一个用户故事描述了该应用程序将拥有来自世界各地的客户支付他们的旅行费用。然而，在现实世界中，每个国家都有不同的支付服务可用。每个国家的支付过程相似，但这个系统将提供多个支付服务。简化这种支付实现的一个好方法是通过使用工厂模式。
- en: 'The following diagram shows the basic idea of its architectural implementation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了其架构实现的初步概念：
- en: '![](img/B19280_06_03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19280_06_03.png)'
- en: 'Figure 6.3: Factory pattern'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：工厂模式
- en: 'Notice that since you have an interface that describes what the payment service
    for the application is, you can use the Factory pattern to change the concrete
    class according to the services that are available:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于你有一个描述应用程序支付服务的接口，你可以使用工厂模式根据可用的服务来更改具体的类：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once again, the service’s usage has been simplified due to the implemented pattern.
    If you had to use this code in a real-world application, you would change the
    instance’s behavior by defining the service you needed in the Factory pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于实现了模式，服务的使用已经简化。如果你需要在现实世界的应用程序中使用此代码，你将通过在工厂模式中定义所需的服务的实例来更改实例的行为。
- en: Singleton pattern
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: When you implement Singleton in your application, you will have a single instance
    of the object implemented in the entire solution. This is one of the most used
    patterns in every application. The reason is simple—there are many use cases where
    you need some classes to have just one instance. Singletons solve this by providing
    a better solution than a global variable does.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在应用程序中实现单例时，你将在整个解决方案中实现该对象的单一实例。这是每个应用程序中最常用的模式之一。原因很简单——有许多用例需要某些类只有一个实例。单例通过提供比全局变量更好的解决方案来解决这个问题。
- en: 'In the Singleton pattern, the class is responsible for creating and delivering
    a single object that will be used by the application. In other words, the Singleton
    class creates a single instance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例模式中，类负责创建并传递一个将被应用程序使用的单一对象。换句话说，单例类创建一个单一实例：
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B19280_06_04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![包含图形用户界面的图片 描述自动生成](img/B19280_06_04.png)'
- en: 'Figure 6.4: Singleton pattern'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：单例模式
- en: To do so, the object that is created is `static` and delivered in a static property
    or method. The `??=` operator assigns the value of its right operand to its left
    one if its value is null.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，创建的对象是`静态`的，并通过静态属性或方法传递。`??=`运算符如果其右操作数的值为null，则将其值赋给左操作数。
- en: 'The following code implements the Singleton pattern, which has a `Message`
    property and a `Print()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了单例模式，它有一个`Message`属性和一个`Print()`方法：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Its usage is simple–you just need to call the static property every time you
    need to use the Singleton object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法很简单——每次你需要使用单例对象时，只需调用静态属性即可：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Be careful because the sample can have concurrency issues according to the usage
    defined! Please refer to *Chapter 2*, *Non-Functional Requirements*, to read a
    bit more about concurrency and multithreading.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据定义的使用方式，示例可能存在并发问题！请参阅*第2章*，*非功能性需求*，了解更多关于并发和多线程的信息。
- en: 'One of the situations where you can use this pattern is when you need to deliver
    the app configuration in a way that can be easily accessed from anywhere in the
    solution. For instance, let us say you have some configuration parameters that
    are stored in a table, which your app needs to query at several decision points.
    Although we have standard solutions like `appsettings.json` or `web.config`, where
    caching is out of the box, you may want to use this custom solution. In this case,
    instead of querying the configuration table directly, you can create a Singleton
    class to help you:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种模式的情况之一是，当你需要以易于从解决方案的任何位置访问的方式提供应用程序配置时。例如，假设你有一些存储在表中且应用程序需要在几个决策点查询的配置参数。尽管我们有像`appsettings.json`或`web.config`这样的标准解决方案，其中缓存是开箱即用的，但你可能想使用这个自定义解决方案。在这种情况下，你不必直接查询配置表，可以创建一个Singleton类来帮助你：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B19280_06_05.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息 描述自动生成](img/B19280_06_05.png)'
- en: 'Figure 6.5: Singleton pattern usage'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：Singleton模式使用
- en: 'Moreover, you will need to implement a cache in this Singleton, thus improving
    the performance of the system since you will be able to decide whether the system
    will check each configuration in the database every time it needs it or if the
    cache will be used. The following screenshot shows the implementation of the cache,
    where the configuration is loaded every 5 seconds. The parameter that is read
    in this case is just a random number:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要在这个Singleton中实现一个缓存，从而提高系统的性能，因为你可以决定系统是否每次需要时都会检查数据库中的每个配置，或者是否使用缓存。以下截图显示了缓存的实现，其中配置每5秒加载一次。在这种情况下读取的参数只是一个随机数：
- en: '![A picture containing calendar  Description automatically generated](img/B19280_06_06.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![包含日历的图片 描述自动生成](img/B19280_06_06.png)'
- en: 'Figure 6.6: Cache implementation inside the Singleton pattern'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：Singleton模式内的缓存实现
- en: This is great for the application’s performance. Besides, using parameters in
    several places in your code is simpler since you do not have to create configuration
    instances everywhere in the code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应用程序的性能大有裨益。此外，在代码的多个地方使用参数更简单，因为你不必在代码的每个地方都创建配置实例。
- en: It is worth mentioning that due to the dependency injection implementation in
    .NET, Singleton pattern usage has become less common since you can set dependency
    injection to handle your Singleton objects. We will cover dependency injection
    in .NET in later sections of this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于.NET中的依赖注入实现，Singleton模式的使用已经变得不那么常见，因为你可以设置依赖注入来处理你的Singleton对象。我们将在本章后面的部分介绍.NET中的依赖注入。
- en: Proxy pattern
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object. One of the biggest reasons why you should do this is related
    to the cost of creating the object that is being controlled. For instance, if
    the controlled object takes too long to be created or consumes too much memory,
    a proxy can be used to guarantee that the largest part of the object will only
    be created when it is required.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要提供一个控制对另一个对象访问的对象时，会使用代理模式。你应该这样做的一个最大的原因是与被控制对象的创建成本相关。例如，如果被控制的对象创建时间过长或消耗过多内存，可以使用代理来确保对象的大部分只有在需要时才会创建。
- en: 'The following class diagram is of a **Proxy** pattern implementation for loading
    pictures from **Room** (see *Figure 6.1*), but only when requested:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图是一个**代理**模式实现，用于从**Room**（参见*图6.1*）加载图片，但仅在请求时：
- en: '![Diagram  Description automatically generated](img/B19280_06_07.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B19280_06_07.png)'
- en: 'Figure 6.7: Proxy pattern implementation'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：代理模式实现
- en: The client of this proxy will request its creation. Here, the proxy will only
    gather basic information (`Id`, `FileName`, and `Tags`) from the real object and
    will not query `PictureData`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理的客户将请求其创建。在这里，代理将只从真实对象收集基本信息（`Id`、`FileName`和`Tags`），而不会查询`PictureData`。
- en: 'Only when `PictureData` is requested in the first call will the proxy load
    it, as we can confirm with the message Now the picture is loaded!. After that,
    in the second picture data request, the proxy will not load the `PictureData`
    again, which causes a better performance, as we can see in *Figure 6.8*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在第一次调用中请求 `PictureData` 时，代理才会加载它，正如我们可以通过消息“现在图片已加载！”来确认。之后，在第二次图片数据请求中，代理将不会再次加载
    `PictureData`，这会导致更好的性能，正如我们在 *图 6.8* 中可以看到：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If `PictureData` is requested again, since the image data is already in place,
    the proxy will guarantee that image reloading will not be repeated. The following
    screenshot shows the result of running the preceding code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次请求 `PictureData`，由于图像数据已经就绪，代理将保证不会重复重新加载图像。以下截图显示了运行前面代码的结果：
- en: '![Text  Description automatically generated](img/B19280_06_08.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19280_06_08.png)'
- en: 'Figure 6.8: Proxy pattern result'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：代理模式结果
- en: 'This technique can be referred to by another name: **lazy loading**. In fact,
    the Proxy pattern is a way of implementing lazy loading. Another approach for
    implementing lazy loading is the usage of the `Lazy<T>` type. For instance, in
    Entity Framework Core, as discussed in *Chapter 13*, *Interacting with Data in
    C# – Entity Framework Core*, you can turn on lazy loading using proxies. You can
    find out more about this at [https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也可以被称为 **延迟加载**。实际上，代理模式是实现延迟加载的一种方式。实现延迟加载的另一种方法是使用 `Lazy<T>` 类型。例如，在 Entity
    Framework Core 中，如 *第 13 章* 中所讨论的，*在 C# 中与数据交互 – Entity Framework Core*，你可以通过代理启用延迟加载。你可以在
    [https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading)
    上了解更多信息。
- en: Command pattern
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: There are many cases where you need to execute a **command** that will affect
    the behavior of an object. The Command pattern can help you with this by encapsulating
    this kind of request in an object. The pattern also describes how to handle undo/redo
    support for a request.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，你需要执行一个将影响对象行为的 **命令**。命令模式可以通过封装这种请求为一个对象来帮助你处理这种情况。该模式还描述了如何处理请求的撤销/重做支持。
- en: There is another design pattern called Memento that also has the purpose of
    implementing undo actions. However, the Command pattern focuses on encapsulating
    requests as objects, whereas Memento focuses on capturing and externalizing an
    object’s internal state for the purpose of restoring it later.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 Memento 的设计模式，它也有实现撤销动作的目的。然而，命令模式侧重于将请求封装为对象，而 Memento 侧重于捕获和外部化对象的内部状态，以便稍后恢复。
- en: For instance, let us imagine that, on the WWTravelClub website, users can evaluate
    packages by specifying whether they liked, disliked, or even loved their experience.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象在 WWTravelClub 网站上，用户可以通过指定他们是否喜欢、不喜欢，甚至热爱他们的体验来评估套餐。
- en: 'The following class diagram is an example of what can be implemented to create
    this rating system with the Command pattern:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图是一个示例，说明如何使用命令模式创建此评分系统：
- en: '![](img/B19280_06_09.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9：命令模式](img/B19280_06_09.png)'
- en: 'Figure 6.9: Command pattern'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9：命令模式
- en: Notice the way this pattern works – if you need a different command, such as
    `Hate`, you will only implement a new class based on the `ICommand` interface.
    You do not need to change the code from other action classes. The change in the
    `Package` class will not impact the commands already implemented. Besides that,
    if you want to implement the `Redo` method, it can be added in a similar way to
    the `Undo` method. The full code sample for this is available in this book’s GitHub
    repository.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个模式的工作方式——如果你需要一个不同的命令，比如 `Hate`，你只需基于 `ICommand` 接口实现一个新的类。你不需要更改其他动作类的代码。`Package`
    类中的更改不会影响已实现的命令。除此之外，如果你想实现 `Redo` 方法，它可以用类似的方式添加到 `Undo` 方法中。这个完整的代码示例可以在本书的
    GitHub 仓库中找到。
- en: It might also help to mention that ASP.NET Core MVC uses the Command pattern
    for its `IActionResult` hierarchy. The business operation described in *Chapter
    7*, *Understanding the Different Domains in Software Solutions*, will make use
    of this pattern to execute business rules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还可能有助于提到，ASP.NET Core MVC 使用命令模式来处理其 `IActionResult` 层次。*第 7 章* 中描述的业务操作，*理解软件解决方案中的不同领域*，将使用此模式来执行业务规则。
- en: Publisher/Subscriber pattern
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布者/订阅者模式
- en: Providing information from an object to a group of other objects is common in
    all applications. The Publisher/Subscriber pattern is almost mandatory when there
    is a large volume of components (subscribers) that will receive a message containing
    the information that was sent by the object (publisher).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有应用程序中，从对象向一组其他对象提供信息是很常见的。当有大量组件（订阅者）将接收包含由对象（发布者）发送的信息的消息时，发布者/订阅者模式几乎是强制性的。
- en: 'The concept here is quite simple to understand and is shown in the following
    diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的概念非常简单易懂，如下面的图所示：
- en: '![](img/B19280_06_10.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19280_06_10.png)'
- en: 'Figure 6.10: Publisher/Subscriber sample case'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：发布者/订阅者示例案例
- en: When you have an indefinite number of different possible subscribers, it is
    essential to decouple the component that broadcasts information from the components
    that consume it. The Publisher/Subscriber pattern does this for us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有不定数量的不同可能的订阅者时，将广播信息的组件与消费它的组件解耦是至关重要的。发布者/订阅者模式为我们做到了这一点。
- en: Implementing this pattern is complex since distributing environments is not
    a trivial task. Therefore, it is recommended that you consider pre-existing technologies
    for implementing the message broker that connects the input channel to the output
    channels instead of building it from scratch. Azure Service Bus is a reliable
    infrastructure component where you can find this pattern provided, so all you
    need to do is connect to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个模式很复杂，因为分布式环境不是一项简单任务。因此，建议您考虑使用现有的技术来实现连接输入通道和输出通道的消息代理，而不是从头开始构建。Azure
    Service Bus 是一个可靠的基础设施组件，您可以在其中找到提供的这个模式，所以您需要做的只是连接到它。
- en: RabbitMQ, which we mention in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, and in *Chapter 14*, *Implementing Microservices
    with .NET*, is another service that can be used to implement a message broker,
    but it is a lower-level infrastructure and requires several manual implementations,
    such as retries in errors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*，*将微服务架构应用于您的企业应用程序*和*第14章*，*使用.NET实现微服务*中提到的RabbitMQ，是另一个可以用来实现消息代理的服务，但它是一个更底层的基础设施，需要手动实现几个功能，如错误重试。
- en: Dependency Injection pattern
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: The Dependency Injection pattern is considered a good way to implement the Dependency
    Inversion principle, guiding you to implement this SOLID principle.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式被认为是实现依赖倒置原则的好方法，指导您实现这个SOLID原则。
- en: The concept is quite simple. Instead of creating instances of the objects that
    the component depends on, you just need to define their dependencies, declare
    their interfaces, and enable the reception of the objects by **injection**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常简单。您不需要创建组件所依赖的对象的实例，只需定义它们的依赖关系，声明它们的接口，并通过**注入**使对象能够接收。
- en: 'There are three ways to perform dependency injection:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种执行依赖注入的方法：
- en: Use the constructor of the class to receive the objects
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类的构造函数接收对象
- en: Tag some class properties to receive the objects
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一些类属性以接收对象
- en: Define an interface with a method to inject all the necessary components
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个带有注入所有必要组件的方法的接口
- en: 'The following diagram shows the implementation of the Dependency Injection
    pattern using the constructor of the class to receive the objects. In this case,
    it receives `UserAddress` and `DestinationAddress` classes, which can be completely
    different, but both of them implement the `IAddress` interface, which enables
    the **DistanceCalculator** to work:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了使用类构造函数接收对象的依赖注入模式的实现。在这种情况下，它接收`UserAddress`和`DestinationAddress`类，它们可以完全不同，但都实现了`IAddress`接口，这使得**距离计算器**能够工作：
- en: '![Graphical user interface  Description automatically generated](img/B19280_06_11.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B19280_06_11.png)'
- en: 'Figure 6.11: Dependency Injection pattern'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：依赖注入模式
- en: Apart from these three ways mentioned above, Dependency Injection can be used
    with an **Inversion of Control** (**IoC**) container. This container enables the
    automatic injection of dependencies whenever they are asked for. There are several
    IoC container frameworks available on the market, but with .NET 8, for most cases,
    there is no need to use third-party software since it contains a set of libraries
    to solve this in the `Microsoft.Extensions.DependencyInjection` namespace.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述三种方法之外，依赖注入还可以与**控制反转**（**IoC**）容器一起使用。这个容器使得在需要时自动注入依赖项成为可能。市场上有多款IoC容器框架可用，但使用.NET
    8，在大多数情况下，不需要使用第三方软件，因为它包含了一组在`Microsoft.Extensions.DependencyInjection`命名空间中解决此问题的库。
- en: 'This IoC container is responsible for creating and disposing of the objects
    that are requested. The implementation of Dependency Injection is based on constructor
    types. There are three options for the injected component’s lifetime:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此IoC容器负责创建和销毁请求的对象。依赖注入的实现基于构造函数类型。注入组件的生命周期有三种选择：
- en: '**Transient**: The objects are created each time they are requested.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**：每次请求时都会创建对象。'
- en: '**Scoped**: The objects are created for each scope defined in the application.
    In a web app, a **scope** is identified with a web request unless you create a
    custom scope. A good example where custom scope can be used is in multi-tenant
    applications. In this case, you may want to manage dependencies per tenant.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域内**：对象是为应用程序中定义的每个作用域创建的。在一个Web应用程序中，**作用域**与一个Web请求相关联，除非你创建了一个自定义作用域。一个可以使用自定义作用域的好例子是多租户应用程序。在这种情况下，你可能希望按租户管理依赖项。'
- en: '**Singleton**: Each object has the same application lifetime, so a single object
    is reused to serve all the requests for a given type. If your object contains
    state, you should not use this one unless it is thread-safe. Remember to refer
    to *Chapter 2*, *Non-Functional Requirements*, to learn more about multithreading.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：每个对象都有相同的应用程序生命周期，因此单个对象被重用来服务给定类型的所有请求。如果你的对象包含状态，除非它是线程安全的，否则不应使用此对象。记得参考第2章“非功能性需求”，以了解更多关于多线程的信息。'
- en: The way you use these options depends on the business rules of the project you
    are developing. It is also a matter of how you register the services of the application.
    You need to be careful in deciding on the correct one since the behavior of the
    application will change according to the type of object you are injecting.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用这些选项的方式取决于你正在开发的项目中的业务规则。这同样也是一个关于如何注册应用程序服务的问题。你需要小心地决定正确的选项，因为应用程序的行为将根据你注入的对象类型而改变。
- en: Understanding the design patterns available in .NET
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解.NET中可用的设计模式
- en: As we discovered in the previous sections, C# allows us to implement any of
    the patterns. .NET provides many implementations in its SDK that follow all the
    patterns we have discussed, such as Entity Framework Core proxy lazy loading.
    Another good example that has been available since .NET Core 2.1 is .NET Generic
    Host, which does not directly implement a specific pattern but combines many of
    them, providing a flexible and extensible host environment for .NET applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所发现的，C#允许我们实现任何模式。.NET在其SDK中提供了许多遵循我们讨论的所有模式的实现，例如Entity Framework
    Core代理懒加载。另一个自.NET Core 2.1以来就可用的好例子是.NET Generic Host，它并不直接实现特定的模式，而是结合了许多模式，为.NET应用程序提供了一个灵活且可扩展的主机环境。
- en: In *Chapter 17*, *Presenting ASP.NET Core MVC*, we will detail the hosting that’s
    available for web apps in .NET 8\. This web host helps us since the startup of
    the app and lifetime management are set up alongside it. The idea of .NET Generic
    Host is to enable this way of working for applications that do not need HTTP implementation.
    With this Generic Host, any .NET program can have a startup class where we can
    configure the dependency injection engine. This can be useful for creating multi-service
    apps, using Composite patterns as a basis for that.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17章“展示ASP.NET Core MVC”中，我们将详细介绍.NET 8中可用的Web应用程序的托管情况。这个Web宿主帮助我们，因为应用程序的启动和生命周期管理都是与其一起设置的。.NET
    Generic Host的思路是使这种方式适用于不需要HTTP实现的应用程序。使用这个Generic Host，任何.NET程序都可以有一个启动类，在那里我们可以配置依赖注入引擎。这对于创建多服务应用程序很有用，复合模式可以作为其基础。
- en: You can find out more about .NET Generic Host at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host),
    which contains some sample code and is the current recommendation from Microsoft.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)了解更多关于.NET通用宿主的信息，其中包含一些示例代码，并且这是微软的当前推荐。
- en: The code provided in the GitHub repository is simple, but it focuses on the
    creation of a console app that can run a service for monitoring. The great thing
    about this is the way the console app is set up to run, where the builder configures
    the services that will be provided by the application and the way logging will
    be managed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库中提供的代码很简单，但它专注于创建一个可以运行监控服务的控制台应用程序。令人兴奋的是，控制台应用程序的设置方式，其中构建器配置了应用程序将提供的服务以及日志管理的方式。
- en: 'This is shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码中有所体现：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code gives us an idea of how .NET uses design patterns. Using
    the Builder pattern, .NET Generic Host allows you to set the classes that will
    be injected as services. In addition to this, the Builder pattern helps you configure
    some other features, such as the way logs will be shown/stored. This configuration
    allows the services to inject `ILogger<outTCategoryName>` objects into any instance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码让我们了解了.NET是如何使用设计模式的。使用Builder模式，.NET通用宿主允许你设置将被注入为服务的类。除此之外，Builder模式还帮助你配置一些其他功能，例如日志的显示/存储方式。这种配置允许服务将`ILogger<outTCategoryName>`对象注入到任何实例中。
- en: 'Other examples of Generic Host usage are worker services, described in *Chapter
    14*, *Implementing Microservices with .NET*, and Blazor’s Generic Host, described
    in *Chapter 19, Client Frameworks: Blazor*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其他使用通用宿主的例子包括工作服务，这在*第14章*，*使用.NET实现微服务*中有所描述，以及Blazor的通用宿主，这在*第19章，客户端框架：Blazor*中有所描述。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood why design patterns help with the maintainability
    and reusability of the parts of the system you are building. We also looked at
    some typical use cases and code examples that you can consider in your projects,
    always remembering that they need to evolve to achieve professional delivery.
    Finally, we presented .NET Generic Host, which is a good example of how .NET uses
    design patterns to enable code reusability and enforce best practices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了为什么设计模式有助于提高你正在构建的系统部分的维护性和可重用性。我们还探讨了你在项目中可以考虑的一些典型用例和代码示例，始终记住它们需要进化以达到专业交付。最后，我们介绍了.NET通用宿主，这是.NET如何使用设计模式来实现代码重用和强制最佳实践的良例。
- en: All this content will help you while architecting new software or even maintaining
    something existing since design patterns are already-known solutions for some
    real-life problems in software development.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容都将帮助你进行新的软件架构或维护现有系统，因为设计模式是软件开发中一些现实生活问题的已知解决方案。
- en: In *Chapter 7*, *Understanding the Diﬀerent Domains in Software Solutions*,
    we will cover the domain-driven design approach. We will also learn how to use
    the SOLID design principles so that we can map different domains to our software
    solutions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*，*理解软件解决方案的不同领域*中，我们将介绍领域驱动设计方法。我们还将学习如何使用SOLID设计原则，以便我们可以将不同的领域映射到我们的软件解决方案中。
- en: Questions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are design patterns?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: What is the difference between design patterns and design principles?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计模式和设计原则之间的区别是什么？
- en: When is it a good idea to implement the Builder pattern?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现Builder模式是一个好主意？
- en: When is it a good idea to implement the Factory pattern?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现工厂模式是一个好主意？
- en: When is it a good idea to implement the Singleton pattern?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现单例模式是一个好主意？
- en: When is it a good idea to implement the Proxy pattern?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现代理模式是一个好主意？
- en: When is it a good idea to implement the Command pattern?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现命令模式是一个好主意？
- en: When is it a good idea to implement the Publisher/Subscriber pattern?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现发布/订阅模式是一个好主意？
- en: When is it a good idea to implement the Dependency Injection pattern?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现依赖注入模式是一个好主意？
- en: Further reading
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and websites where you can find out more about
    what was covered in this chapter:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些书籍和网站，你可以从中了解更多关于本章所涵盖内容的信息：
- en: '*Clean Architecture*: *A Craftsman’s Guide to Software Structure and Design*,
    Martin, Robert C., Pearson Education, 2018.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clean Architecture*：*软件结构和设计的工匠指南*，作者：罗伯特·C·马丁，Pearson Education，2018年。'
- en: '*Design Patterns*: *Elements of Reusable Object-Oriented Software*, Erich Gamma,
    et al., Addison-Wesley, 1994.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计模式*：*可复用面向对象软件的元素*，Erich Gamma 等著，Addison-Wesley，1994。'
- en: '*Design Principles and Design Patterns*, Martin, Robert C., 2000.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计原则与设计模式*，Martin, Robert C.，2000。'
- en: 'If you need to get more info about design patterns and architectural principles,
    please check out these links:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要获取更多关于设计模式和架构原则的信息，请查看以下链接：
- en: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles)'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles)'
- en: 'If you want to check specific cloud design patterns, you can find them at:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想检查特定的云设计模式，你可以在以下位置找到它们：
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)'
- en: 'If you want to better understand the idea of a Generic Host, follow this link:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想更好地理解通用宿主（Generic Host）的概念，请点击以下链接：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
- en: 'There is a very good explanation about Service Bus messaging at this link:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此链接中有一个关于服务总线（Service Bus）消息的非常好的解释：
- en: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions
    )'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions
    )'
- en: 'You can learn more about dependency injection by checking out these links:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过查看以下链接来了解更多关于依赖注入（dependency injection）的信息：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
- en: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
- en: Learn more on Discord
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code175081751210902046.png)'
