- en: Let's Chat Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an old saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A single conversation with a wise person is worth a month''s study of books*."'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this thought, let''s enable a conversation with our online friends by
    developing a chat application called Let''s Chat in ASP.NET Core 2.0\. Over the
    course of the next three chapters, we will be developing and deploying this chat
    app. While doing so, we will dive deep into ASP.NET Core 2.0 features, learn their
    intricacies, and learn how to unit test our ASP.NET Core 2.0 app. We will also
    learn about containers and deploy our app on the cloud. We will end these three
    chapters with a quick development and walkthrough of a Chatbot using the Microsoft
    Bot Framework, which can be easily created in a matter of minutes and can be added
    to any of your web apps and also integrated with social networks.  In this chapter,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's Chat web app requirement specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's Chat web app design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With reference to ASP.NET Core 2.0, we will also learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading configuration values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's Chat web app requirement specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the requirements for developing our Let's Chat
    web application in ASP.NET Core 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a user, I should be able to fulfill the following requirements for this
    chat room app:'
  prefs: []
  type: TYPE_NORMAL
- en: Register myself in the web app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the password in case I have forgotten the old one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See a list of all the currently logged in users in the chat room
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See a users joining or leaving the chat room
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the display pictures of logged in users, if they exist
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chat with all online users at the same time, just like a chat room
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the app from a browser over the internet and chat with any number of
    online users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To give an example, we are looking at a highly trimmed down version of something
    like [https://gitter.im/dotnet/cli](https://gitter.im/dotnet/cli), which is a
    chat room for .NET Core **command-line interface** (**CLI**) tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the requirement specifications in place, let''s see the activity
    flow of the app and come up with a flowchart. The following is a rough flowchart
    of the app workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8aeb145-101d-449f-8dde-6419c16c2cde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start**: This is the start of the flow. The user browses the chat URL. It
    is being conceptualized as a site, as we want to access it from the browser and
    chat with any number of online users (requirement *Steps 7* and *8*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is user logged in**?: At this point, the app checks whether the user is authenticated
    or not, that is, the user is logged in or not. If the user is logged in, he/she
    is redirected to the chat room page; otherwise, the user is redirected to the
    login page. There is also the provision to reset the password (requirement *Steps
    2* and *3*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is user registered?**: When the user is not logged in, he/she is redirected
    to the login page, where they need to provide a proper username and password to
    get authenticated and logged in. But this can happen only if the user has valid
    credentials, that is, the user is already registered (requirement *Step 1*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Register User**: If the user is not registered, the app should provide a
    provision to register the user (requirement *Step 1*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Login**: This is the landing screen for any unauthenticated user. Already
    authenticated users are directly navigated to the chat room page. This indicates
    to other online users that the user has joined the room (requirement *Step 2*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Chat Room**: Upon successful authentication, the user is redirected to the
    chat room, where he/she can see the list of online users and chat with all of
    them (requirements *Steps 4*, *5*, and *6*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Chat with other users**: Once the user is in the chat room, he/she can chat
    with all the online users and can also see their names and display pictures in
    the chat (requirements *Steps 6* and *7*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finish**: Once the user is done chatting with their friends, he /she can
    exit the page. This indicates to other online users that the user has left the
    room (requirement *Step 5*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see and infer from the flowchart, this is pretty much how every modern
    online app workflow happens. We also see that chatting happens only in *Steps
    6* and *7* of the flowchart. All the other steps are for authentication and setup.
    We also know that this flow covers all the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's Chat web app – high-level design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the flowchart that we created and we will
    come up with granular modules to constitute the app using ASP.NET Core 2.0\. We
    need to develop the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An authentication and authorization module that takes care of login and authentication
    of users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A registration module that takes care of user registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chat room page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module that keeps track of all the logged in users and notifies the client
    chat room pages about the user joining and leaving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user information module that keeps track of all the user information, such
    as display name, display picture, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chat hub module that enables a message to be broadcast from each user to the
    other online users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sounds easy? Let''s see how we can design and implement each of the preceding
    requirements using ASP.NET Core 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication and authorization module**: This is a core functionality and
    needed in most modern apps. It makes sense to use something that is already developed,
    tested, and secure, so that we do not waste our time and energy in rediscovering
    the wheel. There are a variety of ways by which we can achieve this, such as by
    creating and using a custom identity provider, or using Facebook, Twitter, Google,
    or Microsoft authentication providers. We will use Facebook authentication in
    our app, as it''s more likely for the user to have a profile picture in Facebook,
    which would give a good user experience while chatting. This is done through OAuth
    (pronounced *oh-auth*), which stands for open authorization and is an open standard
    for token-based authentication and authorization on the internet. We will discuss
    this in detail when we implement it in our app. This will take care of *Steps
    1* through *5* in our flowchart discussed in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chat hub module**: This module will be responsible for enabling real-time
    chat between all online users and will also track the users as they join and leave
    the room. The hub will receive messages from clients and then broadcast the received
    messages to all clients. This will be an implementation on top of the SignalR
    hub and will be responsible for handling user connections, disconnections, and
    all the real-time messaging functionality. We have already seen and coded the
    basics of SignalR in our last app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have high-level designs in place, let's deep dive into the details
    to implement these and learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start the development of the Let's Chat web app and
    learn all the required fundamentals and ASP.NET Core 2.0 features in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new ASP.NET Core 2.0 MVC app named Let's Chat, like we did in the *Creating
    a simple running code* section of [Chapter 1](ch01.html), *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: Since we need SignalR as well for all the real-time messaging, we need to install
    the SignalR package in our app. To do so, please follow the steps mentioned in
    the *Project setup* section of [Chapter 3](ch03.html), *Building Our First .NET
    Core Game - Tic* -*Tac-Toe.*
  prefs: []
  type: TYPE_NORMAL
- en: After installation of SignalR, we are ready to start coding the app. We will
    start with the authentication and authorization module first and then move on
    to the Chat hub module.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization are closely interlinked, but are quite different
    and are the fundamental concepts of security for distributed applications. It's
    imperative we understand these concepts so that we can develop a secure application.
    One of the most defining principles of security is *trust*. When we make our web
    app available on the internet, it's like keeping our resource in a public area,
    where hundreds and thousands of people can see it. Do you trust that your resource
    will be safe? There is a saying, *In God we trust, the rest must bring data* so,
    it's a big *NO*! Just like stuff left in a public area is not safe, the content
    we have made available on the internet is not safe and from this comes the need
    for authentication and authorization. Let's understand authentication and authorization,
    and then dig into coding the module.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication deals with the process of obtaining some sort of credentials
    from the users and validates the user's identity based on these credentials. Authorization
    is the process of specifying the privileges/access rights of the resources to
    the authenticated resources. Authentication always happens before authorization,
    even if the app allows anonymous access, as the app would identify the user as
    an anonymous user first and then grant access. Authorization generally works on
    the basis of the principle of least privilege.
  prefs: []
  type: TYPE_NORMAL
- en: 'In research, investigations, and journalism, the *Five Ws and How or 5W1H* methodology
    of questioning is known to be a highly effective way of gathering the information,
    so let''s use the same approach to understand authentication and authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Question** | **Authentication** | **Authorization** |'
  prefs: []
  type: TYPE_TB
- en: '| **What/who?** | As per the Oxford dictionary, the meaning of the word authentication
    in the computing world is *The process or action of verifying the identity of
    a user or process. It is meant to identify the user/process and whether it is
    valid.* | As per the Oxford dictionary, the literal meaning of the word authorization
    is *The action of authorizing.* |'
  prefs: []
  type: TYPE_TB
- en: '| **Why?** | To validate the identity of the user/process on the basis of credentials.
    | To control or restrict access to your devices/services/resources. |'
  prefs: []
  type: TYPE_TB
- en: '| **Where/when?** | Wherever/whenever I need to restrict or control access
    to devices/services. But security experts may differ in their answer and say everywhere
    and at all times. | Wherever/whenever I need to restrict or control access to
    devices/services. But security experts may differ in their answer and say everywhere
    and at all times. |'
  prefs: []
  type: TYPE_TB
- en: '| **How?** | Validate the supplied credentials against the stored credentials.
    | Check the role of the user/process and grant or refuse access to the resource.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Example** | Someone knocks at your door. You look out and check you know
    the person by identifying him/her. This is authentication. The question that comes
    to mind is *who are you?* | In the same example, after performing authentication
    (identifying the person), you either let him/her into your house if the person
    is your friend or relative, or you don''t if you don''t know them well. This is
    authorization. The question that comes to mind is *what privileges do you have?*
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram illustrates the authentication and authorization flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/388dd761-aaa8-4c49-ba1c-69852fbb1eff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Authentication and authorization are vast topics and if we go into details,
    there could be a book on them alone, so we will briefly look at the various different
    implementations and related buzzwords to get the gist of them. The enthusiastic
    reader may want to read more about authentication and authorization. A few great
    and reliable resources I can suggest are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/authorization/](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&ch9Search&lang-en=en](https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&ch9Search&lang-en=en)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There has been a variety of implementations for authentication in ASP.NET over
    the years. Some of the most well-known ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections discuss these further.
  prefs: []
  type: TYPE_NORMAL
- en: Windows authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This uses local Windows users and groups to authenticate. It can be sub-classified
    into:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic authentication:** Usernames and passwords are sent as Base64-encoded
    strings and hence can be easily cracked, so it''s a very weak form of authentication
    and should not be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digest authentication:** Issues with basic authentication are solved with
    digest authentication and the data sent is MD5 hashed. This hashed message is
    not easy to decipher. However, some browsers don''t support it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated authentication**: Kerberos authentication or **NT LAN Manager**
    (**NTLM**) authentication. This is the best of the lot, in terms or security as
    well as support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows authentication is still supported in ASP.NET Core 2.0, but since it
    is based on Windows, it won't be available on Linux or Macintosh. The app has
    to be hosted with IIS or HTTP.SYS (a web server for ASP.NET Core, which runs *only*
    on Windows). This is suited for intranet networks where the servers, clients,
    and users all belong to the same Windows domain.
  prefs: []
  type: TYPE_NORMAL
- en: Forms authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is cookie/URL-based authentication in which a username and password are
    stored on the client machine as cookies and are sent encrypted in the URL for
    every request if the user has turned off cookie support. We can implement this
    in ASP.NET Core 2.0 as cookie authentication, as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7291395-2811-4010-9d09-2f94150ef3db.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, once we have the auth-key set with the initial call to authenticate,
    we just pass the session ID/token from the cookie in every request. It can be
    used with ASP.NET Core Identity or without it. ASP.NET Core Identity is a membership
    system that allows us to add login functionality to our web app. Users can create
    an account and log in with username and password or they can use external social
    login providers, such as Facebook, Twitter, Google, Microsoft, and so on. We can
    use SQL Server or other persistence storage mechanisms to store the user details.
    Since this needs a very detailed understanding, you are advised to read about
    ASP.NET Identity from Microsoft's official documentation at [https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have worked with ASP.NET prior to ASP.NET Core, you will find out that
    the fundamental type `IPrincipal` is more or less the same. It used to be implemented
    as `user` on `HTTPContext`, which represented the user for a request. Now, we
    also have a property named `user`, but its type is `ClaimsPrincipal`, which in
    turn implements `IPrincipal`. This is the shift that ASP.NET Core 2.0 has taken
    from the previous version of ASP.NET: that is, it has moved to claims-based from
    a role-based model and claims is the superset of a role. So, the question arises,
    what is a claim?'
  prefs: []
  type: TYPE_NORMAL
- en: Claims are sets of information stored in key value pair form and are used to
    store user information such as name, address, email address, phone number, and
    so on. We can use claims as the replacement for roles as we can transfer the role
    to a claim. For example, I say "I am Rishabh Verma. I live in India. I am the
    author of this book", where I am claiming that my name is Rishabh Verma, I am
    claiming that I live in India, and I am claiming that I have the role of author
    of this book. This is what I mean when I say claims are the superset of roles,
    as in the preceding statement I have transformed my role of author into a claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should nicely explain claims, identity, and principal relations
    from the preceding statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fundamental concept behind a token-based authentication system is simple.
    It allows users to enter their username and password in order to obtain a token,
    and then use this token in every request to fetch a specific resource—without
    using their username and password again. Once the token has been obtained, the
    user can offer the token to access the resource for a time period, while the token
    is valid. This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fafb9d4f-52ca-48a2-b372-25f4994a90f7.png)'
  prefs: []
  type: TYPE_IMG
- en: It is stateless and scalable. The server need not store the token in a session
    or memory (stateless) and hence it is scalable. It is mobile application-ready,
    secure, and can be used to pass authentication to other systems. Due to the rise
    of **Single-Page Applications** (**SPAs**), **Internet of Things** (**IoT**),
    and web APIs, token-based authentication has gained importance. Although there
    are different ways to implement the tokens, the **JSON Web Token** (**JWT**) is
    more widely used. The JWT is an open standard and has become the de-facto standard
    token, which defines a compact and self-contained method for securely transmitting
    information between parties, encoded as a JSON object. The JWT has gained massive
    popularity due to its compactness, which allows tokens to be easily transmitted
    through query strings, header attributes, and within the body of requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JWT consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: Containing the type of the token and the hashing algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: Containing the claims of identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: Contains the string created using a secret and the combined
    header and payload. It is used to identify the integrity of the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is in the format `xxxxx.yyyyy.zzzzz` and a sample token may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can create the JWT from your data at  [https://jwt.io/](https://jwt.io/),
    and can also paste the JWT and check its data.
  prefs: []
  type: TYPE_NORMAL
- en: Let us wrap up our discussion on authentication with a quick discussion of OAuth
    and OpenID Connect.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth 2.0:** It is an open standard for authorization. It is commonly used
    to provide a way for users to log in to a website (say, our Let''s Chat app at [http://packtletschat.azurewebsites.net](http://packtletschat.azurewebsites.net))
    using a third-party account such as Facebook without having to provide the password
    of their Facebook account to the Let''s Chat app. While we will use it for authentication,
    it is actually an authorization protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenID Connect (OIDC)**: It is a HTTP-based protocol that uses identity providers
    to validate that the user is actually who they says they are. It is a very simple
    protocol and provides protection for passwords. It is a simple layer that works
    on top of OAuth 2.0 and adds additional security on top of the OAuth  protocol.
    Due to its simplicity, it has found widespread adoption. Google, Facebook, and
    Stack Exchange are a few of the best-known identity providers. It''s important
    to note that OIDC is a very different protocol to OpenID. The latter is an XML-based
    protocol that follows similar approaches and goals to OIDC, but in a less developer-friendly
    way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, authorization is orthogonal and independent from authentication.
    Let''s have a quick glance at the different types of authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Claim-based authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Simple authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have worked with ASP.NET MVC before, you may already be familiar with
    authorization. The `[Authorize]` and `[AllowAnonymous]` attributes are the inbuilt
    authorization components in the framework. At the simplest level, applying the
    `[Authorize]` attribute over a `Controller` or action restricts the access to
    the `Controller` or action to authenticated users only. If you apply the `[Authorize]`
    attribute to a `Controller`, it applies to all the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, only authenticated users have access to the `Login` action
    as well. This doesn't make sense as I want to log in when I am not logged in,
    and not when I am already logged in. So if you want it to be applied to only a
    few actions, then apply the attribute to those actions alone. The other way to
    prevent this situation is to use the `[AllowAnnonymous]` attribute on the `Login`
    action, and that makes it accessible to non-authenticated users as well.
  prefs: []
  type: TYPE_NORMAL
- en: Treat `[AllowAnonymous]` like a `0`,  and `[Authorize]` as `1`. So if you apply
    `[Authorize]` on the `Controller` and `[AllowAnonymous]` on an action, that action
    will be accessible anonymously (`1 x 0 = 0`), while other actions will require
    authentication. On the contrary, if you apply `[AllowAnonymous]` on the controller
    and `[Authorize]` on an action, all the actions will be accessible anonymously.
    The reason for this is that anything multiplied by `0` is `0`, so if you apply
    `[AllowAnonymous]` on the `Controller`, all other action level attributes are
    bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a `ClaimsPrincipal` object is created, like we did previously, there is
    a property called `IsInRole`. This property provides us access to the `Roles`
    of the user. Role-based authorization checks are declarative. They can be used
    in the same way, using the `[Authorize]` attribute that we have seen, by passing
    in the `Roles` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, all the actions of `UserAdministrationController`
    are accessible to authenticated users with either the `Adminsitrator` or `ITAdministrator`
    roles. So, we can provide multiple roles as comma-separated values in the `Roles`
    parameter and they will be treated as an *or* condition. You can further restrict
    access to only one of the roles by providing the attribute at the action level.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if I need to have an *and* condition between roles? The following snippet
    will ensure that actions are accessible only if the authenticated user has both
    `ITAdministrator` and `Administrator` roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the overloads of the `[Authorize]` attribute, there is an overload
    that accepts the following policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b645a68-54b9-4014-bd8c-b3a0650ee07d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Policy-based role checks are also supported and can be done at the `Startup`
    in the `ConfigureServices()` method while configuring authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Claims-based authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to authorize based on user claims, then we can use claims-based
    authorization. A real-world example would be when you are driving a vehicle and
    the traffic police stop you, suspecting you are younger than 18 years. Then, you
    take out your driving license and claim that you are a perfectly legal age to
    drive . The police accept your claim (since it is issued by a valid authority)
    and let you drive on. This is claims-based authorization. Claims-based authorization
    checks are also declarative and can be decorated on a controller or action. Claims
    requirements are policy-based, so like in the previous section, we need to register
    the policy at startup, expressing the claims requirement. In the preceding example,
    the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This discussion should have given you a pretty clear view of authentication
    and authorization, and you should now be able to dive deep into these topics and
    broaden and deepen your knowledge on these fundamental concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also notice that all authentication and authorization is implemented in
    the `ConfigureServices()` method of the `Startup` class where the pipeline is 
    configured and middleware is added. To complete the discussion, let''s quickly
    understand the ASP.NET Core pipeline, and how it serves the requests. The following
    diagram illustrates how the request is served by ASP.NET Core in a step-by-step
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73d351ed-4c3e-45bd-a18a-f41454504115.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The browser sends the HTTP request to the server. The request is received by
    the reverse proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request is forwarded by the reverse proxy to ASP.NET Core.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET Core web server receives the request and routes it through its pipeline,
    through middleware. After passing through middleware, the request is processed
    by the ASP.NET Core application, which generates the response and passes it back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET Core web server sends the response to the reverse proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP response is sent to the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A reverse proxy is a type of proxy server that retrieves resources on behalf
    of a client from one or more servers. It can be defined as a software component
    that is responsible for receiving requests and forwarding them on to the appropriate
    web server. The reverse proxy is exposed directly to the internet, whereas the
    underlying web server is exposed only to the proxy. This setup has several benefits,
    primarily security and performance for web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the details of *Step 3*, as it talks about the ASP.NET Core web
    server and its pipeline, which is our area of interest. First things first. What
    is middleware?
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per the ASP.NET Core documentation (available at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x)),
    middleware is a software that is assembled into an application pipeline to handle
    requests and responses. Each component:'
  prefs: []
  type: TYPE_NORMAL
- en: Chooses whether to pass the request to the next component in the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can perform work before and after the next component in the pipeline is invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request delegates are used to build the request pipeline. The request delegates
    handle each HTTP request. Request delegates are configured using the `Run`, `Map`,
    and `Use` extension methods. An individual request delegate can be specified inline
    as an anonymous method (called **inline middleware**), or it can be defined in
    a reusable class. These reusable classes and inline anonymous methods are *middleware*.
    Each middleware component in the request pipeline is responsible for invoking
    the next component in the pipeline, or short-circuiting the chain as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classical diagram of middleware in the pipeline, which is available at
    Microsoft''s official ASP.NET Core documentation site, is shown here, with the
    added detail of steps, which makes it extremely lucid. What happens in *Step 3* is
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d65abcc3-891e-47c6-a41d-10dd40a89e51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lets look at it in a step-by-step approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: The request is received by **Middleware 1**. The pseudo code of
    **Middleware 1** in the `Configure(IApplicationBuilder app, IHostingEnvironment
    env)` method of `Startup.cs` would be `UseMiddleware1();`, as it processes the
    request and invokes the next middleware. Recall that we discussed the `Use`, `Map`,
    and `Run` methods in brief in [Chapter 3](ch03.html), *Building Our First .NET
    Core Game Tic-Tac-Toe*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 2**: The code/logic of **Middleware 1** is executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 3**: `RequestDelegate`—`next();` is executed, which invokes the next
    middleware.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 4**: The code/logic of **Middleware 2** is executed. The pseudo code
    of **Middleware 2** in the `Configure(IApplicationBuilder app, IHostingEnvironment
    env)` method of `Startup.cs` would be `UseMiddleware2();`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 5**: `RequestDelegate`—`next(); ` is executed, which invokes the next
    middleware.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 6**: The code/logic of **Middleware 3** is executed. Based on this diagram,
    the request is handled here, but we can chain in as much middleware as we need. The
    pseudo code of **Middleware 3** in the `Configure(IApplicationBuilder app, IHostingEnvironment
    env)` method of `Startup.cs` can be either `UseMiddleware3();`, which doesn''t
    call `next();`, or it can simply be `RunMiddleware3();`, which short-circuits
    the pipeline. Normally, this would be the MVC `Routing` middleware, which would
    route the request to the MVC `Controller`, which processes the request and returns
    the response.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 7**: As the request is handled in the last step, the response is returned
    to **Middleware 2**, which can do further processing of the response and return
    it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Steps 8 and 9**: Likewise, the response is processed in **Middleware 2**
    and **Middleware 1**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 10**: The processed response from all middleware is returned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we look at the `Configure(IApplicationBuilder app, IHostingEnvironment env)`
    method in our `Startup.cs` class, we see the following code, which comes with
    the default MVC template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'They say that a picture is worth a thousand words, so to understand this code
    in the context of the pipeline, if we draw the diagram for a non-developer environment
    (that is, `env.IsDevelopment() == false;`), here is roughly what it would look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fec7bc6-63d4-44e4-b1b2-7ce058dee3bb.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that, based on the code for the `else` case, the request first goes
    through the exception middleware through `app.UseExceptionHandler("/Home/Error");`.This
    is done to ensure that if any part of the code encounters the exception in the
    pipeline, it is handled by the exception handler, so it's kept first. From the
    diagram, we can note that during the request processing, the middleware does nothing,
    but just invokes the next middleware in the chain. This can be seen from the ASP.NET
    Core source code, which is freely available for everyone to see and learn from
    GitHub ([https://github.com/aspnet](https://github.com/aspnet)). I would highly
    encourage readers to browse the code and see the implementation for a better understanding
    of the way things have been implemented by the ASP.NET Core team.
  prefs: []
  type: TYPE_NORMAL
- en: Next in line is the static file middleware, which serves static files such as
    `css`, `js`, `images`, and so on placed in the `wwwroot` folder. These should
    be served fast as it makes sense to keep this middleware early in the pipeline.
    If a request for a static file comes, the static file middleware serves the request
    and *short-circuits* the pipeline, so that other unnecessary code is not executed
    while serving the static file contents. This is configured through `app.UseStaticFiles();`.
    Then comes the MVC routing, which routes the incoming request to its desired controller
    action. We see that there are a number of items that are executed in this middleware.
    We will go into detail concerning each of these items in later sections and chapters,
    but the important stuff to note here is that the request is served from the controller
    action and then routed back through the same pipeline. The static file middleware
    has no role while a non-static file request is being served, and that becomes
    evident from the diagram. If there is an exception, it would be handled by the
    exception handler and the response is served back.
  prefs: []
  type: TYPE_NORMAL
- en: The first `app.Run` delegate terminates the pipeline. That is, after this, even
    if you add any further middleware or code, it will not be executed. Multiple request
    delegates or middleware can be chained using `app.Use`. The `next` parameter represents
    the next delegate in the pipeline. We can short-circuit the pipeline by not invoking
    the `next` action. Never call `next.Invoke` after the response has been sent to
    the client. Changes to `HttpResponse` after the response has started will throw
    an exception. The order in which middleware components are added in the `Configure`
    method defines the order in which they are invoked on the requests, and the reverse
    order for the response.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by now we have a relatively good understanding of the ASP.NET Core
    pipeline and middleware. Before we write middleware of our own and learn how to
    plug it into our pipeline, let's first learn about Dependency Injection, as it
    will be used extensively in whatever ASP.NET Core application that we write.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dependency Injection** (**DI**) is a software design pattern that enables
    us to develop loosely coupled code and is a great way to reduce tight coupling
    between software components. The **D** of the **SOLID** design principles stands
    for **Dependency Inversion Principle** (**DIP**), which states that "*high-level
    modules should not depend upon low-level modules. Both should depend on abstractions*".
    That is, it depends on abstractions, not on concrete implementations. If we speak
    in the language of the code, the class should not use new or static helper methods
    to populate its dependencies; it should rather have them injected. If you ever
    heard your architect or lead utter "*program to interfaces, not implementations*",
    it''s because he/she wants you to use DI. DI is the implementation of DIP**. **'
  prefs: []
  type: TYPE_NORMAL
- en: 'DI enables better:'
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I am not great at dishing out examples, but let me give it a try with a real-world
    scenario. Suppose there is a boy who wants to get married. To get married, he
    needs a girl, so he is dependent on a girl for marriage. The pseudo code for this
    scenario would be roughly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We notice that the `Boy` class has hard coupling with the `girl` class, as it
    gets a specific instance of the `girl` class in the `marriage` method and marries
    her. This hard coupling represents that the boy already has a girlfriend and so
    boy and girl are tightly linked. Well, most boys are not lucky (or unlucky, depending
    upon how you see it), enough to have a girlfriend. Also, the preceding code might
    not work for all scenarios, such as if the boy doesn't have a girlfriend or if
    the parents find a girl for the boy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way of implementing the preceding code would be to remove the hard-coupling
    of the girl by injecting the `girl` object from outside. With this, the `GetMarried`
    method is generic as it, removes the hard-coupling of the `girl` class, and will
    work for all boys, depending on the `girl` object passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest example of DI, in which rather than creating a new instance
    of a dependent object, we inject the dependency from outside. There are various
    ways in which dependency can be injected. We will discuss only a few here, with
    reference to classes and interfaces, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us suppose we have two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CoreClass` is the main class implementing the `ICore` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DependencyClass` is the class implementing the `IDependency` interface, so
    that `CoreClass` is dependent on `DependencyClass:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the preceding classes and interfaces as a reference, we can inject the
    dependency in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor injection**: In constructor injection, the dependency object
    is injected at the time of constructing the object, that is, in the constructor
    of the class. This way, the dependency is clearly spelled out at the time of the
    object''s creation. The disadvantages are that once the object is created, the
    dependency cannot be changed and since the dependency is injected in the constructor,
    the class doesn''t have a default parameterless constructor. The constructor-injected
    code for the preceding class would look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Property setter injection**: In property injection, the dependency object
    is injected as a property setter. This way, the default construction of the class
    continues to exist and the dependency can be changed, even after object''s creation,
    by just setting the property. The disadvantage is that since the dependency is
    not injected at the time of the object creation, the dependency to be set can
    be missed and hence may result in runtime errors. The property injected code would
    look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `CoreClass` class, there is a property named `Dependency` of
    type `IDependency` that is needed for the class to function correctly. However,
    if the developer just initializes `CoreClass` by creating a new instance of it
    and forgets to set the `Dependency` property, we may encounter a runtime exception.
    In contrast, in constructor injection, since the dependency is passed at the time
    of the object's creation, we are never at risk of such issues.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how dependencies can be injected. Imagine a system where we have
    numerous classes in which dependency needs to be injected. If we follow any one
    the preceding approaches for injection and create the objects at every place where
    they are needed, it will become spaghetti code or become completely messed up.
    It is therefore meaningful to have classes to create these classes and inject
    dependencies as needed. These classes are called containers, DI containers, **Inversion
    of Control** (**IoC**) containers. A container can be thought of as a factory
    that is responsible for providing instances of types that are requested from it.
    If a given type has declared that it has dependencies, and the container has been
    configured to provide the dependency types, it will create the dependencies as
    part of creating the requested instance. In this way, complex dependency graphs
    can be provided to classes without the need for any hardcoded object construction.
    In addition to creating objects with their dependencies, containers typically
    manage object lifetimes within the application.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core comes with a very simple built-in container (the `IServiceProvider`
    interface) that supports constructor injection by default. ASP.NET's container
    refers to the types it manages as services. These services can be injected into
    the container in the `ConfigureServices` method of the ASP.NET Core application's
    `Startup` class.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain facts about the inbuilt ASP.NET Core container that we need
    to be aware of to make correct use of DI in the app.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for the dependency that should be resolved must have a `public`
    access modifier.
  prefs: []
  type: TYPE_NORMAL
- en: There should be only one constructor that gets resolved with a given set of
    parameters. Constructor overloads are supported, but only one overload can exist,
    whose arguments can all be fulfilled by DI. If multiple constructors exist, you
    may encounter `InvalidOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the signature of the `ConfigureServices` method in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method exposes the `IServicesCollection`, where we can add our own services/types
    as needed. This can be done by the following extension methods in the `Microsoft.Extensions.DependencyInjection`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddTransient`: Use this extension method to instantiate types that should
    be created each time they are requested. This should be used for lightweight,
    stateless services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddScoped`: Use this extension method to instantiate types that should be
    created once per request. Types that are based on requests should be instantiated
    on a per-request basis and hence should be created by this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddSingleton`: Use this extension method to create types that should be instantiated only
    once and should be used throughout the life cycle of the application. A common
    example of this scenario is caching. One instance is good enough for the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My architect calls these *every time, sometimes, and one time*, respectively.
    Transients are created every time they are requested; scoped are created once
    per request, so sometimes. Singletons are created once in the lifetime of the
    application, so one time. Nice way to remember!
  prefs: []
  type: TYPE_NORMAL
- en: 'On a lighter note and to digest the concept: the **Prime Minister** (**PM**)
    of a nation can be a good example of a singleton. Irrespective of where and how
    many times he/she is needed, there is one and only one PM, so the PM is a singleton.
    Likewise, examples of transient and scoped can be formed. This is left as an exercise
    and teaser to readers to come up with real-world examples of transient and scoped.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these extension methods have seven or more overloads to provide flexibility
    and cater to different needs, such as passing the concrete instance or providing
    a factory method to create the object. Readers should have a good look at the
    overloads and make effective use of these methods. The easiest way to do so is
    either to use *F12* on one of these extension methods in Visual Studio and read
    the method documentation, or use the object browser of Visual Studio, or browse
    the source code on GitHub ([https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example)).
  prefs: []
  type: TYPE_NORMAL
- en: 'I will list a few of the ways by which we can inject the types/services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our discussion on DI. For a more detailed and extensive dive
    into DI in ASP.NET Core 2.0, please visit [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).
  prefs: []
  type: TYPE_NORMAL
- en: How do you write custom middleware?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is the right time to create simple middleware of our own and plug it into
    the pipeline, so that all this theory that we have gone through ends with a practical
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write either inline middleware or a neatly written class which can be
    configured at the startup. We will write both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest middleware that one can write. This is the `Run` middleware
    and short-circuits the pipeline  after execution, and just sends a response with
    the message `".NET Core 2.0 By Example"`. It has been plugged with this code into
    the `Configure` method of `Startup.cs/`.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen inline middleware, let's write the more serious middleware that
    you would write in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating a class called `MyFirstMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since middleware is just a request delegate that processes the request/response
    and then invokes the next one in the chain, the following is how we would create
    the class for middleware. Notice the next request delegate is expected to be resolved
    by DI. It''s a pretty simple class, consisting of:'
  prefs: []
  type: TYPE_NORMAL
- en: A `readonly` field to hold the reference to the next `RequestDelegate`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that expects the next `RequestDelegate` to be executed as the
    parameter. During construction, it sets the field with the reference of the next
    request delegate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Invoke` method that takes an `HttpContext` object to fiddle with and then
    passes it along to the next middleware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have our simple middleware code ready. However, we are yet to
    plug it into our app pipeline. To do so, we will create an extension method of
    `IApplicationBuilder`, which internally uses the `UseMiddleware&lt;T&gt;` method
    to register the middleware, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to plug it into our pipeline, go to the `Configure` method of the `Startup`
    class and add the middleware with a simple single line of code, `app.UseMyFirstMiddleware();`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have created our very first middleware and plugged it into our
    app pipeline. Sweet, short, and simple!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the configuration providers in ASP.NET Core and how we
    can read configuration and use it in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods in C# allow us to extend an existing type with new functionality,
    and add new methods to it, without having to derive or recompile the old type. Extension
    methods are a special kind of static method, but they are called as if they are
    instance methods on the extended type.  The most common extension methods are
    the `LINQ` standard query operators. ASP.NET Core makes extensive use of extension
    methods for registering services.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop ASP.NET Core web apps, we will quickly realize that we need
    to change a few settings at runtime. To give an example, consider a web application
    that makes API calls to the service. When you develop the web app, the service
    is deployed in some development server and when you deploy it in production, the
    service URL is different, so the URL should not be hardcoded in the application.
    Instead, it should be read from the configuration, so that it can be changed without
    having to recompile the code. Another often used example is that of database connection
    strings, if the app makes use of them. This section takes a look at how we can
    accomplish this in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASP.NET Core configuration model has three main constructs of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigurationProvider`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigurationRoot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigurationBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the map diagram is constructed from `Microsoft.Extensions.Configuration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f65ea3a-6b35-406a-8610-583dfe10861d.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ConfigurationProvider` is abstracted from the developer and hence we would
    not see it, but it''s good to know that there is support for multiple configuration
    providers. A few of the important ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON file**: Reads the JSON file in the app''s `Startup` folder and configures
    the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line arguments**: While launching the app, command-line arguments
    can be passed as a key value to configure the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variables**: Setting the environment variables, the provider
    reads the environment variable and takes care of configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Key Vault**: We will cover this in later chapters when we discuss Azure,
    but as the name suggests, it is a key vault.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So in a single app, we can choose to read a few configurations from the JSON
    file, a few from the command line, and so on. When we add multiple providers,
    it''s important to consider the order in which we add them, as that defines the
    order in which the configuration values are added to the underlying dictionary.
    Configuration values from later providers will overwrite values with the same
    key from earlier providers. Also, we can notice in the diagram that there is a
    `GetReloadToken` method in `ConfigurationProvider` and a `Reload` method in `ConfigurationRoot`
    as well. If we read the documentation (using *F12* in Visual Studio), we know
    that the configuration system supports reloading the configuration without having
    to restart the web app, which is fantastic. Let''s see how we can read the configuration. The
    default `Startup.cs` comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we already have the `IConfiguration` interface injected in the `Startup`
    constructor, which sets the `Configuration` property of the `Startup`. Also notice
    that when we create an app from the template, `appsettings.json` is included by
    default. Essentially, the default code has already wired up JSON-based configuration
    for us and we can leverage its goodness without having to code anything extra.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make effective use of the `Configuration` property, lets do *F12* (go to
    definition) on `IConfiguration` and check out its properties. The following is
    the code that comes up in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we see that we can get the value of a key through the indexer property,
    passing in the key to look up. We can get children, get a reload token, or get
    a specific section by giving the key. This documentation makes our task of using
    the configuration extremely easy. Let''s see an example. First, define the config
    that we want to read, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to read the values would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used a zero-based index to access the contents of an array. The
    rest of the keys are read  just by passing in the correct key to the `Configuration`
    indexer, as we have just seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We generally use different configuration settings for different environments.
    For example, Development, Test, Staging, and Production may all have different
    configuration settings. The `CreateDefaultBuilder` extension method in an ASP.NET
    Core 2.0 app adds configuration providers for reading JSON files and environment
    variables in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appsettings.json`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`appsettings.&lt;EnvironmentName&gt;.json`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, `appsettings.&lt;EnvironmentName&gt;.json` would overwrite the key values
    defined in `appsettings.json` and the environment variables would overwrite the
    key values defined before them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This didn''t need any code changes in our `Startup` class. However, if we wish
    to use any other named config file, then we will need the code to be changed.
    The following example uses `config.json` as the configuration file, followed by
    `config.Development.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A thoughtful programmer would say that in my `appsettings.json`, there may
    be a variety of sections for caching, database connection strings, service URLs,
    and so on. Why should I pass on all these values to every place? For example,
    what has caching to do with the database connection strings section or the service
    URL? Looks like there is no separation of concerns, and a clear violation of the **I**
    of **SOLID**: **Interface Segregation Principle**. Why should caching depend on
    `IConfiguration` when it needs just a subsection of it? To prevent these violations,
    it is *not* recommended to use the preceding way to access settings if configurations
    are to be read outside of `Startup.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should instead use what is called the `Options` pattern. Using it is simple:
    first create a simple **Plain Old CLR O****bject** (**POCO**) class and then use
    it by registering it as a service and consume it wherever we need. It''s a simple
    and dumb class with properties and no logic or smartness.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The POCO class for the preceding example would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To register it, we go to the `ConfigureServices` method in `Startup.cs` and
    add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`BookDetails` will be populated and added to the container. To use it in the
    controller, the following code would suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties can now be used from the strongly typed object, `details`. If
    you wish to overwrite certain properties after the configuration is bound, you
    can do the following in the `ConfigureService` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This changes the name of the book to `"Roslyn Via C#"`. This is a last-one-wins
    approach, in which what is done last prevails.
  prefs: []
  type: TYPE_NORMAL
- en: Another question that comes to mind is what if my configuration value changes,
    do I restart my app like in the old days when modifying the `web.config` used
    to restart the app? No, we have this covered in ASP.NET Core. For this, we need
    to use `IOptionsSnapshot`, which is designed to support the reloading of configuration
    data when the configuration file changes. Using `IOptionsSnapshot` with the `reloadOnChange`
    flag set to `true`, the options are bound to the configuration and reloaded when
    the file changes.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding sample, we just need to change `IOptions` to `IOptionsSnapshot`
    and add a flag, `reloadOnChange`, to `true` while adding the JSON file in the `AddJsonFile`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a step back and look at our `Program.cs`, which is the entry point
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateDefaultBuilder` loads optional configurations from `appsettings.json`, `appsettings.{Environment}.json`,
    User Secrets (in the Development environment), environment variables, and command-line
    arguments. The `CommandLine` configuration provider is called last. Calling the
    provider last allows the command-line arguments passed at runtime to override
    the configuration set by the other configuration providers called earlier, by
    the last-one-wins approach. Also, it is important to note that `reloadOnChange` is
    enabled for the `appsettings` file and so command-line arguments are overridden
    if a matching configuration value in an `appsetting*s*` file is changed after
    the app starts.
  prefs: []
  type: TYPE_NORMAL
- en: When we work in enterprise applications, we will realize that there are a variety
    of configuration settings, such as secrets, passwords, and so on, that should
    not be kept in configuration files and hence should be kept out of the application
    code. Also, as a best practice, we should not be using production secrets in our
    development environment. In production also, these should be read from Azure Key
    Vault, which we will look at in later chapters. In the development environment,
    we can use the Secret Manager tool to safeguard secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before seeing how to use User Secrets, a question comes to mind: is that why
    we don''t use environment variables to keep secrets away from the application,
    as it is supported by ASP.NET Core and is also there by default in the template
    code? Yes, we can use environment variables. However, environment variables are
    stored as plain text and can be accessed from any third-party code, so we can
    use them in local development but should not rely on them for production deployments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Secret Manager tool is just a fancy name given to store the secrets of
    a .NET Core project outside of the code base during development. The data stored
    is *not* encrypted. The only advantage this approach provides is that the secrets
    would not be part of the code and hence will not be checked in the source control,
    and so the secret will remain a secret during development. The secret is stored
    in a JSON file, which is kept in the user profile folder. To set up the User Secret
    tool, edit the `.csproj` file and add the following line in the `ItemGroup` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So the final code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Save the `.csproj` file. This will restore the package we just added. Now, right-click
    the project in the Solution Explorer and select Manage User Secrets. This will
    add a new node named `UserSecretId` in the `PropertyGroup`. Save the file. A file
    named `secrets.json` will open up in Visual Studio. Hover over it and see the
    path. It will be `%AppData%\microsoft\UserSecrets\&lt;userSecretsId&gt;\secrets.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add key value-pairs in the JSON file, just like we did for the configuration
    file. To read them, we need to add a couple of lines of code in our startup, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can access the secret, just like we access anything else from
    the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our configuration discussion. Let's check out how we can do logging.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core supports the logging API, which works with a wide variety of logging
    providers. We can write logs to one or more locations and we can also plug in
    third-party logging frameworks, such as NLog, Serilog, and so on. In this section,
    we will look at out-of-the box logging, as it is sufficient for the logging needs
    of most apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the architecture of the logging infrastructure. The code map diagram
    for logging is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea861236-f127-49cb-814c-50edc17cce06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, it consists of the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ILogger/ ILogger&lt;TCategoryName&gt;`: We will use this in our app to log
    messages. We can see it has the`IsEnabled()` method to check whether logging is
    enabled and `Log` to write the log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ILoggerFactory`: It has a method to add a provider and logger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ILoggerProvider`: It has a method to create the logger and it will control
    the output location of the log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also notice the `EventId`, `LogLevel` enumeration, and extensions for registering
    the logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure logging at the time of building the `WebHost` in the `Program.cs`
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This code configures the logging to read the logging configuration section
    provided in `appsettings.json` and adds console and debug logging. Alternatively,
    we can inject `ILoggerFactory` as a parameter in the `Configure` method of `Startup.cs`
    and configure `loggerFactory` , as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Like any other type or service in the ASP.NET Core application, the logger is
    also injected into a class or controller through DI.  Here we inject `ILogger&lt;T&gt;`,
    where `T` is the name of the class. The type parameter `T` is used to define the *category*
    as it follows the `ILogger&lt;TCategoryName&gt;` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to write a log message in an ASP.NET Core controller, `HomeController`,
    we would inject the `ILogger&lt;HomeController&gt;` and call one of the logging
    extension methods on `ILogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will write a log message to each output of the configured logging providers.
    The following is what it would look like in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d61c6be4-43d1-4d95-a8be-65da5cd28beb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'ASP.NET Core includes numerous logging providers out of the box, which we can
    use to write log messages to various locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console provider**: To write log messages to the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug provider**: To write log messages to the Debug window while debugging
    in Visual Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventSource provider**: To write log messages using Event Tracing for Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Log provider**: To write log messages to the Windows event log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is support for third-party structured logging as well, which is greatly
    useful, as it makes finding and diagnosing issues easier in production. Structured
    logging involves associating key-value pairs with each log entry, instead of a
    simple string of messages. We will not delve into this discussion, but it's good
    to know and the reader should take it up as an exercise to explore and implement
    structured logging with ASP.NET Core apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *category* is included with each log that is created. We specify the category
    while creating an `ILogger` object. The category may be any string, but the convention
    is to use the qualified name of the class from which the logs are written, like
    we did in our previous example. We can also specify the log level, which indicates
    the degree of severity or importance of the log. For example, typically we use
    an information log when a method executes normally, a warning log when a method
    returns a 404 return code, and an error log when an unexpected exception is caught. Log
    methods that include the level in the method name are extension methods for `ILogger` ,
    such as`LogError`,`LogWarning`, `LogInformation`, and `LogTrace`. Behind the scenes,
    these methods call the `Log` method whcih takes a `LogLevel` parameter. ASP.NET
    Core defines the following log levels, ordered here from least to highest severity.
    The documentation of the code makes it intuitive to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set minimum trace levels while configuring the logger as well, with
    the following code, which creates the `WebHost` in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do scope-based logging; that is, logging, on a logical group of
    operations within a scope in order to attach same data to each log. The `BeginScope`
    method is specifically made for this purpose and the following example shows the
    sample usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we conclude, let''s have a look at the configuration for `Logging` in
    the `appSettings.json` file. Consider the following `Logging` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration defines four logging filters. The following is
    the interpretation of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Scope-based logging is disabled, as we have `IncludeScopes` as `false`. One
    of the primary use cases of scope-based logging comes in transactional data access
    or operations, where you may want to attach the same identifier to all the operations
    that happen in the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default log level of the `Debug` log provider is `Information` for all categories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default log level of the `Console` log provider is `Information` for all
    categories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The log level of categories beginning with `Microsoft.AspNetCore.Mvc.Razor`
    is `Error` for the `Console` log provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default log level for all log providers for all categories is `Debug`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a detailed and deep dive into logging in ASP.NET Core 2.0, readers should
    visit [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x).[](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x)
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude our discussion of logging, and this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Let's Chat web application, its requirements
    and high-level design, and did the project setup to get started with coding. After
    doing the project setup, we learned about ASP.NET Core fundamentals, such as authentication,
    authorization, middleware, Dependency Injection, configuration, and logging.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will complete the fundamentals and then dive into coding
    the Let's Chat application.
  prefs: []
  type: TYPE_NORMAL
