<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-198">
    <a id="_idTextAnchor199">
    </a>
    
     15
    
   </h1>
   <h1 id="_idParaDest-199">
    <a id="_idTextAnchor200">
    </a>
    
     Creating and Publishing Powerful NuGet Packages for the Community
    
   </h1>
   <p>
    
     In this chapter, we’ll embark on a comprehensive journey into the world of NuGet and package management, an essential aspect of modern .NET development.
    
    
     Whether you’re a seasoned developer or not, understanding NuGet will elevate your ability to manage dependencies and streamline
    
    
     
      your workflow.
     
    
   </p>
   <p>
    
     We’ll begin by introducing the fundamentals of NuGet, covering what it is and why it’s a cornerstone in the .NET ecosystem.
    
    
     You’ll gain practical insights into creating your first NuGet package, including hands-on experience with setting up a project, packaging your code, and generating a
    
    <strong class="source-inline">
     
      .nupkg
     
    </strong>
    
     file.
    
    
     As we progress, we’ll master versioning and dependency management, which are crucial skills to ensure that your packages are compatible and up to date.
    
    
     Then, we’ll explore the process of publishing and distributing your packages, ensuring that our work reaches the right audience.
    
    
     Finally, we’ll dive into advanced features and best practices, from targeting specific platforms to incorporating
    
    
     
      pre-release versions.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing NuGet and
     
     
      
       package management
      
     
    </li>
    <li>
     
      Creating your first
     
     
      
       NuGet package
      
     
    </li>
    <li>
     
      Versioning and
     
     
      
       dependency management
      
     
    </li>
    <li>
     
      Publishing
     
     
      
       and distribution
      
     
    </li>
    <li>
     
      Advanced
     
     
      
       NuGet features
      
     
    </li>
   </ul>
   <p>
    
     By the end of this chapter, you’ll be equipped with the knowledge and skills to create, manage, and distribute NuGet packages effectively, empowering you to contribute to the broader .NET community
    
    
     
      with confidence.
     
    
   </p>
   <h1 id="_idParaDest-200">
    <a id="_idTextAnchor201">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     While writing this chapter, I used the following versions of
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio Enterprise 2022
     
     
      
       Version 17.12.0
      
     
    </li>
    <li>
     
      
       Preview 1.0
      
     
    </li>
   </ul>
   <p>
    
     The code files for this chapter can be found
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch15">
     
      
       https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch15
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-201">
    <a id="_idTextAnchor202">
    </a>
    
     Introduction to NuGet and package management
    
   </h1>
   <p>
    
     In this opening section, we’ll lay the groundwork for everything to come.
    
    
     We’ll explore what NuGet is, its importance in the .NET ecosystem, and how it revolutionizes the way developers share and
    
    
     
      reuse code.
     
    
   </p>
   <p>
    
     NuGet
    
    <a id="_idIndexMarker804">
    </a>
    
     is a free and open source package manager designed specifically for the Microsoft development platform, including .NET.
    
    
     At its core, NuGet serves as a mechanism for sharing code and speeding up the development process.
    
    
     It allows developers to create packages that encapsulate functionality, libraries, or frameworks and distribute them through
    
    
     
      NuGet repositories.
     
    
   </p>
   <p>
    
     NuGet’s importance lies in its ability to simplify the process of incorporating third-party libraries into your projects, manage dependencies, and keep them up to date.
    
    
     This approach significantly reduces the complexity associated with manual dependency management, which was once a common challenge in .
    
    
     
      NET development.
     
    
   </p>
   <p>
    
     The NuGet ecosystem is vast and dynamic.
    
    
     At its center is the official
    
    <a id="_idIndexMarker805">
    </a>
    
     NuGet Gallery (
    
    <a href="https://nuget.org">
     
      nuget.org
     
    </a>
    
     ), which hosts thousands of packages contributed by the community.
    
    
     However, NuGet isn’t limited to public repositories; it also supports private feeds, allowing organizations to control access to
    
    
     
      internal packages.
     
    
   </p>
   <p>
    
     One of the most significant advantages of NuGet is its ability to simplify dependency management.
    
    
     With NuGet, developers no longer need to manually download and install libraries.
    
    
     Instead, they can simply add a reference to the desired package in their project, and NuGet takes care of downloading and installing the
    
    
     
      correct version.
     
    
   </p>
   <p>
    
     To effectively
    
    <a id="_idIndexMarker806">
    </a>
    
     create and consume packages, it’s crucial to set up your development environment properly.
    
    
     We can access the general configuration of the package manager through the top-level toolbar –
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      NuGet Package Manager
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Package
     
    </strong>
    
     <strong class="bold">
      
       Manager Settings
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 15.1 – The NuGet package manager options" src="img/B22218_15_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 15.1 – The NuGet package manager options
    
   </p>
   <p>
    
     Here are some details about the
    
    
     
      options available:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Package Restore
      
     </strong>
     
      : Checking both the boxes under this allows us to ensure that NuGet packages are automatically restored when building a solution.
     
     
      This is important because it guarantees that all necessary packages are available, even if they were not included in the source control, thus avoiding missing package issues during
     
     
      
       build processes.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Binding Redirects
      
     </strong>
     
      : This is a mechanism used to address version conflicts between assemblies.
     
     
      When you’re working on a .NET project that references multiple libraries, it’s common to encounter situations where different libraries depend on different versions of the same assembly.
     
     
      This can lead to runtime errors due to version conflicts.
     
     
      You can choose to skip those libraries, but it’s particularly useful in scenarios where you cannot control the version dependencies of third-party libraries but need to ensure compatibility across
     
     
      
       your application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Package Management
      
     </strong>
     
      : Here, we can choose the default format of the package management file.
     
     
      We can also opt to select the format when installing the
     
     
      
       first package.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Clear All NuGet Storage
      
     </strong>
     
      : The global NuGet cache stores copies of packages that we have downloaded or installed.
     
     
      Clearing this cache ensures that our development environment starts fresh, without any potentially corrupted or outdated packages.
     
     
      This helps to troubleshoot package-related issues and ensures that we work with clean, up-to-date packages.
     
     
      One other way to achieve this is
     
     <a id="_idIndexMarker807">
     </a>
     
      by opening a Command Prompt as administrator and running the
     
     <strong class="source-inline">
      
       nuget locals all -
      
     </strong>
     
      <strong class="source-inline">
       
        clear
       
      </strong>
     
     
      
       command.
      
     
    </li>
   </ul>
   <p>
    
     Now that we’ve established the basics of NuGet and its significance, let’s move on to the practical side of things.
    
    
     It’s time to roll up our sleeves and start creating our very own
    
    
     
      NuGet package.
     
    
   </p>
   <h1 id="_idParaDest-202">
    <a id="_idTextAnchor203">
    </a>
    
     Creating your first NuGet package
    
   </h1>
   <p>
    
     Here, we will dive straight
    
    <a id="_idIndexMarker808">
    </a>
    
     into action.
    
    
     We’ll walk through the process of creating a simple NuGet package from scratch, covering every step from initial setup to publishing.
    
    
     This hands-on experience will help reinforce the concepts introduced in the previous section and prepare you for more advanced
    
    
     
      package creation.
     
    
   </p>
   <p>
    
     Let’s break this down further.
    
    
     First, we’ll create a new .NET Standard library project in Visual Studio.
    
    
     This type of project is ideal for creating NuGet packages because it’s compatible with multiple .NET frameworks.
    
    
     Let’s get started with
    
    
     
      the steps:
     
    
   </p>
   <ol>
    <li>
     
      Open Visual Studio and select
     
     
      <strong class="bold">
       
        New Project
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      For this example, choose
     
     <strong class="bold">
      
       .NET Standard
      
     </strong>
     
      under the
     
     
      <strong class="bold">
       
        C#
       
      </strong>
     
     
      
       section.
      
     
    </li>
    <li>
     
      Name the project (e.g.,
     
     <strong class="source-inline">
      
       MyFirstPackage
      
     </strong>
     
      ) and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        OK
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Next, we’ll write the
    
    <a id="_idIndexMarker809">
    </a>
    
     package content by adding some sample code to our project.
    
    
     For this example, let’s create a simple utility class that converts temperatures between Celsius
    
    
     
      and Fahrenheit:
     
    
   </p>
   <pre class="source-code">
using System;
namespace MyFirstPackage
{
    public static class TemperatureConverter
    {
        public static double ConvertCelsiusToFahrenheit(
            double celsius)
        {
            return (celsius * 9 / 5) + 32;
        }
        public static double ConvertFahrenheitToCelsius(
            double fahrenheit)
        {
            return (fahrenheit - 32) * 5 / 9;
        }
    }
}</pre>
   <p>
    
     Now that we have our code, we need to prepare it
    
    
     
      for packaging:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on the project in the
     
     <strong class="bold">
      
       Solution
      
     </strong>
     
      <strong class="bold">
       
        Explorer
       
      </strong>
     
     
      
       window.
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New Folder
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the
     
     
      
       folder
      
     
     
      <strong class="source-inline">
       
        lib
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Move the
     
     <strong class="source-inline">
      
       TemperatureConverter.cs
      
     </strong>
     
      file into
     
     
      
       this folder.
      
     
    </li>
   </ol>
   <p>
    
     With our project prepared, we can now create the
    
    
     
      NuGet package:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on the project in the
     
     <strong class="bold">
      
       Solution
      
     </strong>
     
      <strong class="bold">
       
        Explorer
       
      </strong>
     
     
      
       window.
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       Pack
      
     </strong>
     
      from the
     
     
      
       context menu.
      
     
    </li>
   </ol>
   <p>
    
     This will generate a
    
    <strong class="source-inline">
     
      .nupkg
     
    </strong>
    
     file in the
    
    
     <strong class="source-inline">
      
       bin/Debug
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p>
    
     Let’s verify that our package was
    
    
     
      created successfully:
     
    
   </p>
   <ol>
    <li>
     
      Locate the
     
     <strong class="source-inline">
      
       .nupkg
      
     </strong>
     
      file in the
     
     
      <strong class="source-inline">
       
        bin/Debug
       
      </strong>
     
     
      
       folder
      
     
    </li>
    <li>
     
      Double-click the file to view
     
     
      
       its contents.
      
     
    </li>
    <li>
     
      Check
     
     <a id="_idIndexMarker810">
     </a>
     
      that the package includes the
     
     <strong class="source-inline">
      
       lib
      
     </strong>
     
      folder containing our
     
     
      <strong class="source-inline">
       
        TemperatureConverter.cs
       
      </strong>
     
     
      
       file.
      
     
    </li>
   </ol>
   <p>
    
     Now that we’ve created our first NuGet package, let’s take a moment to reflect on what we’ve accomplished.
    
    
     We’ve gone from having no package to having a fully functional one that we could potentially share with others.
    
    
     Now that we have done that, there’s an important aspect we need to address – how do we ensure that our package remains stable and doesn’t cause issues in other
    
    
     
      people’s projects?
     
    
   </p>
   <h1 id="_idParaDest-203">
    <a id="_idTextAnchor204">
    </a>
    
     Versioning and dependency management
    
   </h1>
   <p>
    
     Versioning
    
    <a id="_idIndexMarker811">
    </a>
    
     is crucial for maintaining compatibility and responsibly managing updates.
    
    
     Properly handling dependencies between packages is equally important, as it ensures that your package works seamlessly with other packages in
    
    
     
      a project.
     
    
   </p>
   <p>
    
     Versioning is the process of assigning unique identifiers to different versions of our package.
    
    
     It’s a way to communicate to users how much your package has changed since the last release.
    
    
     There are two main approaches
    
    
     
      to versioning:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Semantic versioning
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Major version
        
       </strong>
       
        :
       
       
        
         Breaking
        
       
       
        <a id="_idIndexMarker812">
        </a>
       
       
        
         changes
        
       
      </li>
      <li>
       <strong class="bold">
        
         Minor version
        
       </strong>
       
        :
       
       
        
         New
        
       
       
        <a id="_idIndexMarker813">
        </a>
       
       
        
         features
        
       
      </li>
      <li>
       <strong class="bold">
        
         Patch version
        
       </strong>
       
        :
       
       
        
         Bug fixes
        
       
      </li>
     </ul>
     <p class="list-inset">
      
       An example is 1.0.0, 1.1.0, 1.2.0, and
      
      
       
        so on
       
      
     </p>
    </li>
    <li>
     
      <strong class="bold">
       
        Date-based versioning
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        Uses dates to indicate when a package
       
       
        
         was released
        
       
      </li>
     </ul>
     <p class="list-inset">
      
       An example
      
      
       
        is 2023.01.01.0
       
      
     </p>
    </li>
   </ul>
   <p>
    
     While
    
    <a id="_idIndexMarker814">
    </a>
    
     date-based versioning
    
    <a id="_idIndexMarker815">
    </a>
    
     is simpler, semantic versioning is generally preferred, as it provides more meaningful information about a
    
    
     
      package’s history.
     
    
   </p>
   <p>
    
     We can easily define the version
    
    <a id="_idIndexMarker816">
    </a>
    
     of our package by navigating to the properties of
    
    
     
      our project:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on the project in the
     
     <strong class="bold">
      
       Solution
      
     </strong>
     
      <strong class="bold">
       
        Explorer
       
      </strong>
     
     
      
       window,
      
     
    </li>
    <li>
     
      
       Select
      
     
     
      <strong class="bold">
       
        Properties
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Go to the
     
     
      <strong class="bold">
       
        Package
       
      </strong>
     
     
      
       tab.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 15.2 – Package Properties" src="img/B22218_15_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 15.2 – Package Properties
    
   </p>
   <p>
    
     Here, we
    
    <a id="_idIndexMarker817">
    </a>
    
     define version 1.0.1 of our package; if we pack the project again, it will generate a new
    
    <strong class="source-inline">
     
      .nupkg
     
    </strong>
    
     file with the newly
    
    
     
      defined version.
     
    
   </p>
   <p>
    
     Dependency management
    
    <a id="_idIndexMarker818">
    </a>
    
     involves specifying which other packages your package depends on.
    
    
     This is crucial for ensuring that our package functions correctly in
    
    
     
      various environments.
     
    
   </p>
   <p>
    
     There are two ways to
    
    <a id="_idIndexMarker819">
    </a>
    
     declare dependencies
    
    <a id="_idIndexMarker820">
    </a>
    
     in a
    
    
     
      NuGet package:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Direct dependencies
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        Specify the exact versions of packages you depend on.
       
       
        Here’s
       
       
        
         an example:
        
       
       <pre class="source-code">
&lt;dependencies&gt;
  &lt;group targetFramework="netstandard2.0"&gt;
    &lt;dependency
      id="System.Collections"
      version="4.3.0"
    /&gt;
  &lt;/group&gt;
&lt;/dependencies&gt;</pre>
      </li>
     </ul>
    </li>
    <li>
     
      <strong class="bold">
       
        Range dependencies
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        Specify a
       
       <a id="_idIndexMarker821">
       </a>
       
        range of acceptable versions.
       
       
        Here’s
       
       
        
         an example:
        
       
       <pre class="source-code">
&lt;dependencies&gt;
  &lt;group targetFramework="netstandard2.0"&gt;
    &lt;dependency
      id="Newtonsoft.Json"
      version="[12.0,13.0)"
    /&gt;
  &lt;/group&gt;
&lt;/dependencies&gt;</pre>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     Range dependencies
    
    <a id="_idIndexMarker822">
    </a>
    
     allow for flexibility while still maintaining some level of control over the
    
    
     
      versions used.
     
    
   </p>
   <p>
    
     Effective versioning
    
    <a id="_idIndexMarker823">
    </a>
    
     and
    
    <a id="_idIndexMarker824">
    </a>
    
     dependency management are essential practices in software development.
    
    
     It is crucial to maintain consistency by adhering to a chosen versioning strategy throughout the life cycle of
    
    
     
      a package.
     
    
   </p>
   <p>
    
     Clearly communicating this strategy, especially through documentation such as the
    
    <strong class="source-inline">
     
      README.md
     
    </strong>
    
     file, helps ensure that all stakeholders understand the approach.
    
    
     Keeping dependencies up to date is equally important, as regular updates to the packages you rely on can prevent compatibility issues and
    
    
     
      enhance security.
     
    
   </p>
   <p>
    
     Thorough testing against different versions of dependencies is necessary to identify potential conflicts early.
    
    
     Additionally, it is important to consider transitive dependencies – those indirect dependencies that may influence your package’s behavior – to maintain overall stability
    
    
     
      and reliability.
     
    
   </p>
   <p>
    
     Now that we’ve covered the essentials of versioning and dependency management, let’s turn our attention to the next crucial step in getting our package out to the world – publishing and distribution.
    
    
     This is where we make our hard work available to others and potentially become part of the rich ecosystem of .
    
    
     
      NET packages.
     
    
   </p>
   <h1 id="_idParaDest-204">
    <a id="_idTextAnchor205">
    </a>
    
     Publishing and distribution
    
   </h1>
   <p>
    
     Publishing your NuGet package
    
    <a id="_idIndexMarker825">
    </a>
    
     makes it accessible to the entire .NET community or your entire organization.
    
    
     This section guides you through the process of publishing your package to the official NuGet gallery, as well as alternative
    
    
     
      distribution methods.
     
    
   </p>
   <p>
    
     Let’s explore in detail how to publish to the official
    
    
     
      NuGet Gallery:
     
    
   </p>
   <ol>
    <li>
     
      Sign in to your account
     
     
      
       at
      
     
     <a href="https://www.nuget.org/">
      
       
        https://www.nuget.org/
       
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     
      Click on
     
     <strong class="bold">
      
       Create a new package
      
     </strong>
     
      and fill in the
     
     
      
       required details.
      
     
    </li>
    <li>
     
      Upload the
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        nupkg
       
      </strong>
     
     
      
       file.
      
     
    </li>
    <li>
     
      Fill in the package metadata (description, tags,
     
     
      
       etc.) .
      
     
    </li>
    <li>
     
      Review and submit
     
     
      
       the package.
      
     
    </li>
   </ol>
   <p>
    
     While the official gallery is the most widely recognized method for distributing packages, there are scenarios where alternative distribution methods may be more appropriate.
    
    
     For instance, private feeds are particularly useful for company-wide or team-specific packages.
    
    
     These feeds can be hosted on platforms such as Azure DevOps, GitHub, or even self-hosted servers, providing a secure and controlled environment for package distribution within an organization.
    
    
     Local feeds are another option, ideal for testing and development environments.
    
    
     These can be set up directly on your local machine or integrated within a CI/CD pipeline, offering a convenient way to manage packages during the development process.
    
    
     For those requiring even more control, custom servers allow for fine-grained management of package distribution, although they do come with the added responsibility of hosting infrastructure and
    
    
     
      ongoing maintenance.
     
    
   </p>
   <p>
    
     Private repositories offer a secure and controlled environment for hosting NuGet packages that are intended for internal use within an organization, or among a select group of developers.
    
    
     Unlike public repositories such as
    
    <a href="http://nuget.org">
     
      nuget.org
     
    </a>
    
     , which are accessible to anyone, private repositories restrict access to authorized users only.
    
    
     This is particularly useful for proprietary software components, beta versions, or when you need to comply with specific
    
    <a id="_idIndexMarker826">
    </a>
    
     
      security policies.
     
    
   </p>
   <p>
    <strong class="bold">
     
      JFrog Artifactory
     
    </strong>
    
     is one of the most
    
    <a id="_idIndexMarker827">
    </a>
    
     popular tools for managing binary repositories, including NuGet packages.
    
    
     It supports both public and private NuGet feeds, making it an excellent choice for organizations looking to establish their own NuGet
    
    
     
      repository infrastructure.
     
    
   </p>
   <p>
    
     Here are the details on how to set up a private NuGet Feed
    
    <a id="_idIndexMarker828">
    </a>
    
     
      in
     
    
    
     <a id="_idIndexMarker829">
     </a>
    
    
     
      Artifactory:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       Install Artifactory
      
     </strong>
     
      : First, you’ll need to install JFrog Artifactory on your server or cloud environment.
     
     
      Follow the official installation guide provided
     
     
      
       by JFrog.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Create a new repository
      
     </strong>
     
      : Once Artifactory is up and running, log in to the administration console.
     
     
      Navigate to the
     
     <strong class="bold">
      
       Repositories
      
     </strong>
     
      section and choose to create a new repository.
     
     
      Select
     
     <strong class="bold">
      
       NuGet
      
     </strong>
     
      as the
     
     
      
       package type.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Configure the repository settings
      
     </strong>
     
      : Specify the repository key, layout, and other settings according to your requirements.
     
     
      For a private feed, ensure that the repository is not
     
     
      
       publicly accessible.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Set up access control
      
     </strong>
     
      : Define who has access to your new NuGet repository.
     
     
      You can create groups for different teams or projects and assign
     
     
      
       appropriate permissions.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Publish packages
      
     </strong>
     
      : With your repository set up, you can now publish NuGet packages to it.
     
     
      Use the
     
     <strong class="source-inline">
      
       nuget push
      
     </strong>
     
      command or integrate with your CI/CD pipeline to automate
     
     
      
       the process.
      
     
    </li>
   </ol>
   <p>
    
     When working with private NuGet feeds, such as Artifactory and others, we must set up a NuGet source in Visual Studio that allows us to specify where NuGet packages should be retrieved from during the package restore process, or when adding new packages to
    
    
     
      our projects.
     
    
   </p>
   <p>
    
     Here’s how
    
    <a id="_idIndexMarker830">
    </a>
    
     we can set up a NuGet source
    
    <a id="_idIndexMarker831">
    </a>
    
     through
    
    
     
      Visual Studio:
     
    
   </p>
   <ol>
    <li>
     
      Go to
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       NuGet Package Manager
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Package
      
     </strong>
     
      <strong class="bold">
       
        Manager Settings
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       Package Sources
      
     </strong>
     
      from the left
     
     
      
       navigation menu.
      
     
     <p class="list-inset">
      
       To add a new package source, click on the green plus (
      
      <strong class="bold">
       
        +
       
      </strong>
      
       ) button at the top-right corner of the
      
      <strong class="bold">
       
        Package
       
      </strong>
      
       <strong class="bold">
        
         sources
        
       </strong>
      
      
       
        window.
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 15.3 – Adding a new package source" src="img/B22218_15_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 15.3 – Adding a new package source
    
   </p>
   <ol>
    <li value="3">
     
      Fill in the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Source
      
     </strong>
     
      textboxs to fit the desired NuGet feeds to
     
     
      
       be added.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 15.4 – Configuring a new package source" src="img/B22218_15_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 15.4 – Configuring a new package source
    
   </p>
   <ol>
    <li value="4">
     
      Then, validate
     
     <a id="_idIndexMarker832">
     </a>
     
      the source by clicking on
     
     <a id="_idIndexMarker833">
     </a>
     
      the
     
     
      <strong class="bold">
       
        Update
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <p>
    
     After adding and configuring your package source, you can verify that it’s working correctly by attempting to restore packages or searching for packages within Visual Studio.
    
    
     Go to
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      NuGet Package Manager
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Manage NuGet Packages for Solution…
     
    </strong>
    
     , and then you can select the package source you want to use with the selection box in the
    
    
     
      top-right corner.
     
    
   </p>
   <div><div><img alt="Figure 15.﻿5 – Choosing the package source" src="img/B22218_15_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 15.5 – Choosing the package source
    
   </p>
   <p>
    
     As we conclude our journey through the process of creating and publishing a NuGet package, it’s worth taking a moment to appreciate the power and flexibility of NuGet.
    
    
     From its humble beginnings as a simple package manager to its current status as a cornerstone of .NET development, NuGet continues to evolve
    
    
     
      and improve.
     
    
   </p>
   <h1 id="_idParaDest-205">
    <a id="_idTextAnchor206">
    </a>
    
     Advanced NuGet features
    
   </h1>
   <p>
    
     In this final section, we’ll explore some of the more advanced features of NuGet, such as target frameworks, pre-release versions, and custom scripts, and discuss the best practices for package development.
    
    
     This knowledge will help you create more robust, flexible, and
    
    
     
      maintainable packages.
     
    
   </p>
   <h2 id="_idParaDest-206">
    <a id="_idTextAnchor207">
    </a>
    
     Target frameworks
    
   </h2>
   <p>
    
     Target frameworks
    
    <a id="_idIndexMarker834">
    </a>
    
     allow us to
    
    <a id="_idIndexMarker835">
    </a>
    
     specify which .NET platforms your package supports, ensuring compatibility across various environments.
    
    
     This feature helps prevent compatibility issues by allowing only the installation of your package in projects that target
    
    
     
      supported frameworks.
     
    
   </p>
   <p>
    
     When creating a NuGet package, you can define multiple target frameworks within the
    
    <strong class="source-inline">
     
      .csproj
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      .nuspec
     
    </strong>
    
     file.
    
    
     This setup enables NuGet to pack separate binaries for each framework, ensuring that your package leverages platform-specific features
    
    
     
      when available.
     
    
   </p>
   <p>
    
     Here’s an example
    
    
     
      of configuration:
     
    
   </p>
   <pre class="source-code">
&lt;PropertyGroup&gt;
  &lt;TargetFrameworks&gt;net46;netstandard2.0&lt;/TargetFrameworks&gt;
&lt;/PropertyGroup&gt;</pre>
   <p>
    
     This
    
    <a id="_idIndexMarker836">
    </a>
    
     configuration indicates that the project targets
    
    <a id="_idIndexMarker837">
    </a>
    
     both .NET Framework 4.6 and .NET Standard 2.0, allowing optimal compatibility and functionality across
    
    
     
      different environments.
     
    
   </p>
   <h2 id="_idParaDest-207">
    <a id="_idTextAnchor208">
    </a>
    
     Pre-release versions
    
   </h2>
   <p>
    
     Pre-release versions
    
    <a id="_idIndexMarker838">
    </a>
    
     are a way to
    
    <a id="_idIndexMarker839">
    </a>
    
     distribute packages that are not yet ready for production use.
    
    
     These versions are typically used for beta testing, release candidates, or
    
    
     
      nightly builds.
     
    
   </p>
   <p>
    
     To allow package authors to distribute versions of their packages that are not considered stable or final, consumers can choose to install these pre-release versions to test new features or bug
    
    
     
      fixes early.
     
    
   </p>
   <p>
    
     Pre-release versions are denoted by appending a suffix to the version number, following a hyphen.
    
    
     Common suffixes include
    
    <strong class="source-inline">
     
      -alpha
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      -beta
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      -rc
     
    </strong>
    
     (
    
    <strong class="bold">
     
      release candidate
     
    </strong>
    
     ), and
    
    <strong class="source-inline">
     
      -preview
     
    </strong>
    
     .
    
    
     Consumers need to
    
    <a id="_idIndexMarker840">
    </a>
    
     explicitly opt in to receive pre-release packages, usually through a setting in their package
    
    
     
      manager client.
     
    
   </p>
   <p>
    
     Here’s an example of configuring a
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       beta
      
     </strong>
    
    
     
      version:
     
    
   </p>
   <pre class="source-code">
&lt;Version&gt;1.0.0-beta1&lt;/Version&gt;</pre>
   <p>
    
     This indicates that the package is a beta version of 1.0.0, suitable for testing but not recommended for
    
    
     
      production use.
     
    
   </p>
   <h2 id="_idParaDest-208">
    <a id="_idTextAnchor209">
    </a>
    
     Custom scripts
    
   </h2>
   <p>
    
     NuGet supports the execution of
    
    <a id="_idIndexMarker841">
    </a>
    
     PowerShell scripts during the installation or uninstallation of a package.
    
    
     This feature can be used for various purposes, such as modifying project files, registering
    
    <strong class="bold">
     
      Component Object Model (COM)
     
    </strong>
    
     components, or
    
    <a id="_idIndexMarker842">
    </a>
    
     performing other
    
    
     
      setup tasks.
     
    
   </p>
   <p>
    
     Custom scripts automate tasks that need to occur when a package is installed or uninstalled, reducing manual steps for the consumer and
    
    
     
      ensuring consistency.
     
    
   </p>
   <p>
    
     As Package authors, we can include PowerShell scripts in our packages that NuGet will execute at appropriate times.
    
    
     There are several types of scripts, including
    
    <strong class="source-inline">
     
      init.ps1
     
    </strong>
    
     (run once per solution),
    
    <strong class="source-inline">
     
      install.ps1
     
    </strong>
    
     (run every time the package is installed), and
    
    <strong class="source-inline">
     
      uninstall.ps1
     
    </strong>
    
     (run when the package
    
    
     
      is uninstalled):
     
    
   </p>
   <pre class="source-code">
&lt;packageTargetFallback
  Condition="'$(OS)' == 'Windows_NT'"&gt;
  win7-x64-msvc2015
&lt;/packageTargetFallback&gt;
&lt;script
  src="img/precompile.js"
  condition="$([MSBuild]::GetTargetPath(
    '$(ProjectDir)tools\precompile.js')) != ''"
/&gt;</pre>
   <p>
    
     This configuration specifies a fallback target framework and includes a custom script (
    
    <strong class="source-inline">
     
      precompile.js
     
    </strong>
    
     ) that will be executed under certain conditions.
    
    
     Note that custom scripts are less commonly used today, especially with the evolution of .NET Core and .NET Standard, but they remain supported for
    
    
     
      backward compatibility.
     
    
   </p>
   <p>
    
     By leveraging these advanced features of NuGet, we can create more sophisticated and flexible packages that better meet the needs of the users across different environments and stages
    
    
     
      of development.
     
    
   </p>
   <h1 id="_idParaDest-209">
    <a id="_idTextAnchor210">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we explored the essential aspects of NuGet and package management within the .NET ecosystem.
    
    
     We began by understanding what NuGet is and why it’s a critical tool for managing dependencies in modern development.
    
    
     We learned how to create our first NuGet package, including setting up a project, writing the necessary code, and packaging it into a
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       nupkg
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     We then delved into versioning and dependency management, highlighting the importance of semantic versioning and strategies to maintain compatibility across different versions.
    
    
     The chapter also covered the steps involved in publishing and distributing NuGet packages, both to the official NuGet gallery and through alternative methods, ensuring that your packages are accessible
    
    
     
      to others.
     
    
   </p>
   <p>
    
     Finally, we explored advanced features and best practices, such as targeting specific platforms, using pre-release versions, and incorporating custom scripts.
    
    
     Now, you have gained a comprehensive understanding of how to create, manage, and distribute NuGet packages, equipping you with the tools to enhance your .NET
    
    
     
      development practices.
     
    
   </p>
   <p>
    
     As we reach the conclusion of
    
    <em class="italic">
     
      Mastering Visual Studio
     
    </em>
    
     , we’ve journeyed through a wide array of advanced techniques, tools, and best practices that are essential for any serious developer working within the .NET and Visual Studio ecosystem.
    
    
     This book has equipped you with powerful skills and knowledge to become a more efficient, versatile, and innovative developer.
    
    
     Whether you’re building intelligent applications, optimizing performance, or contributing to the developer community, the skills you’ve gained will continue to drive your success in the world of
    
    
     
      software development.
     
    
   </p>
  </div>
 </body></html>