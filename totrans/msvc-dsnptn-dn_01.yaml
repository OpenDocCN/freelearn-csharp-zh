- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Microservices – the Big Picture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介——全景图
- en: Microservices are being featured in every avenue of software development. Microservices
    are a software development style that has been touted to increase development
    speed and efficiency while improving software scalability and delivery. This development
    technique is not unique to any stack and has become extremely popular in Java,
    .NET, and JavaScript (Node JS) development. While the use of microservices is
    seen as a pattern, there are several subpatterns that are employed to ensure that
    the code base is as effective as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务正在软件开发的各个方面得到应用。微服务是一种软件开发风格，被誉为可以加快开发速度和效率，同时提高软件的可扩展性和交付。这种开发技术并非任何堆栈所独有，并在Java、.NET和JavaScript（Node
    JS）开发中变得极为流行。虽然微服务的使用被视为一种模式，但还有几个子模式被采用，以确保代码库尽可能有效。
- en: This chapter is the first of this 15-chapter book, which will cover design patterns
    used in microservices. We will be focusing on implementing them using the .NET
    Core development stack, and you will learn how code can be written and deployed.
    You will learn about design and coding patterns, third-party tools and environments,
    and best practices for handling certain scenarios in application development with
    microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第一章是15章中的第一章，将涵盖微服务中使用的模式。我们将专注于使用.NET Core开发堆栈实现它们，你将了解代码的编写和部署方式。你将了解设计和编码模式、第三方工具和环境，以及处理应用程序开发中某些场景的最佳实践。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A deep dive into microservices and its key elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨微服务和其关键元素
- en: Assessing the business need for microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估微服务的业务需求
- en: Determining the feasibility of implementing microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实施微服务的可行性
- en: A deep dive into microservices and its key elements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨微服务和其关键元素
- en: Traditionally, in software development, applications have developed as a single
    unit or *monolith*. All of the components are tightly coupled, and a change to
    one component threatens to have rippling effects throughout the code base and
    functionality. This makes long-term maintenance a major concern and can hinder
    developers from rolling out updates quickly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在软件开发中，应用作为单一单元或**单体**进行开发。所有组件都紧密耦合，对任何一个组件的更改都可能对整个代码库和功能产生连锁反应。这使得长期维护成为一个主要问题，并可能阻碍开发者快速推出更新。
- en: Microservices will have you assess that monolith, break it into smaller and
    more perceivable applications. Each application will relate to a subsection of
    the larger project, which is a called *domain*. We will then develop and maintain
    the code base per application as independent units. Typically, microservices are
    developed as APIs and may or may not interact with each other to complete operations
    being carried by users through a unifying user interface. Typically, the microservice
    architecture comprises a suite of small independent services, which communicate
    via **HTTP** (**REST APIs**) or **gRPC** (**Google Remote Procedure Call**). The
    general notion is that each microservice is autonomous, has a limited scope, and
    aids in a collectively loosely coupled application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务将帮助你评估单体应用，将其分解成更小、更易感知的应用程序。每个应用程序都将与更大项目的一个子部分相关联，这被称为**领域**。然后我们将以独立单元的形式开发和维护每个应用程序的代码库。通常，微服务作为API开发，可能或可能不相互交互以完成用户通过统一用户界面执行的操作。通常，微服务架构由一系列小型独立服务组成，这些服务通过**HTTP**（**REST
    API**）或**gRPC**（**Google远程过程调用**）进行通信。一般概念是每个微服务都是自治的，具有有限的范围，并有助于集体松散耦合的应用程序。
- en: Building a monolith
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建单体应用
- en: 'Let’s imagine that we need to build a health facility management web application.
    We need to manage customer information, book appointments, generate invoices,
    and deliver test results to customers. If we were to itemize all the steps needed
    to build such an application, key development and scoping activities would include
    the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们需要构建一个健康设施管理网络应用程序。我们需要管理客户信息、预订预约、生成发票并向客户交付测试结果。如果我们列出构建此类应用程序所需的所有步骤，关键的开发和范围活动将包括以下内容：
- en: Model the application, and scope the requirements for our customer onboarding,
    user profiles, and basic documents.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟应用，并为我们的客户入职、用户资料和基本文档确定需求范围。
- en: Scope the requirements surrounding the process of booking an appointment with
    a particular doctor. Doctors have schedules and specialties, so we have to present
    the booking slots accordingly.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义与特定医生预约流程相关的需求。医生有日程安排和专长，因此我们必须相应地展示预约时间段。
- en: 'Create a process flow for when a match is found between a customer and a doctor.
    Once a match is found, we need to do the following:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户和医生之间找到匹配时，创建一个流程。一旦找到匹配，我们需要做以下事情：
- en: Book the doctor’s calendar slot
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预约医生的时间段
- en: Generate an invoice
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成发票
- en: Potentially collect a payment for the visit
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能收集访问的付款
- en: Send email notifications to the customer, doctor, and other relevant personnel
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向客户、医生和其他相关人员发送电子邮件通知
- en: Model a database (probably relational) to store all this information.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟一个数据库（可能是关系型）来存储所有这些信息。
- en: Create user interfaces for each screen that both customers and the medical staff
    will use.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为客户和医疗人员将使用的每个屏幕创建用户界面。
- en: 'All of this is developed as one application, with one frontend talking to one
    backend, one database, and one deployment environment. Additionally, we might
    throw in a few third-party API integrations for payment and email services. This
    can be load balanced and hosted across multiple servers to mitigate against downtime
    and increase responsiveness:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都作为一个应用程序开发，一个前端与一个后端、一个数据库和一个部署环境进行通信。此外，我们可能会添加一些第三方 API 集成，用于支付和电子邮件服务。这可以在多个服务器上进行负载均衡和托管，以减轻停机时间并提高响应速度：
- en: '![Figure 1.1 – Application building](img/Figure_1.1_B19100.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 应用构建](img/Figure_1.1_B19100.jpg)'
- en: Figure 1.1 – Application building
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 应用构建
- en: 'However, this monolithic architecture introduces a few challenges:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种单体架构引入了一些挑战：
- en: Attempts to extend functionality might have ripple effects through multiple
    modules and introduce new database and security needs.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试扩展功能可能会在多个模块中产生连锁反应，并引入新的数据库和安全需求。
- en: '*Potential solution*: Perform thorough unit and integration testing.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*潜在解决方案*：执行彻底的单元和集成测试。'
- en: The development team runs the risk of becoming very dependent on a particular
    stack, making it more difficult to keep the code base modern.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队面临的风险是过度依赖特定的栈，这使得保持代码库现代化变得更加困难。
- en: '*Potential solution*: Implement proper versioning strategies and increment
    them as the technology changes.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*潜在解决方案*：实施适当的版本控制策略，并在技术变化时进行增量更新。'
- en: As the code base expands, it becomes more difficult to account for all of the
    moving parts.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码库的扩展，更难对所有移动部件进行核算。
- en: '*Potential solution*: Use clean architectural methods to keep the code base
    loosely coupled and modular.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*潜在解决方案*：使用干净的架构方法保持代码库松散耦合和模块化。'
- en: The reality is that we can overcome some of these challenges with certain architectural
    decisions. This all-in-one architecture has been the de facto standard, and frankly,
    it works. This project architecture is simple, easy enough to scope and develop,
    and is supported by most, if not all, development stacks and databases. We have
    been building them for so long that perhaps we have become oblivious to the real
    challenges that prevail as we try to extend and maintain them in the long term.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以通过某些架构决策克服一些这些挑战。这种一站式架构已经成为事实上的标准，坦白说，它很有效。这个项目架构简单，足够容易定义和开发，并且得到了大多数，如果不是所有，的开发栈和数据库的支持。我们已经建造了很长时间，也许我们已经忽视了我们在长期扩展和维护它们时面临的真正挑战。
- en: '*Figure 1.2* shows the typical architecture of a monolithic application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.2* 展示了单体应用的典型架构：'
- en: '![Figure 1.2 – One user interface is served by an API or code library with
    business logic and is serviced by one database](img/Figure_1.2_B19100.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 一个用户界面由包含业务逻辑的 API 或代码库提供服务，并由一个数据库支持](img/Figure_1.2_B19100.jpg)'
- en: Figure 1.2 – One user interface is served by an API or code library with business
    logic and is serviced by one database
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 一个用户界面由包含业务逻辑的 API 或代码库提供服务，并由一个数据库支持
- en: Now that we have explored the monolithic approach and its potential flaws, let
    us review a similar application built using microservices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了单体方法及其潜在缺陷，让我们回顾一下使用微服务构建的类似应用程序。
- en: Building microservices
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建微服务
- en: 'Now, let us take the same application and conceptualize how it could be architected
    using microservices. During the design phase, we seek to identify the specific
    functionalities for each tranche of the application. This is where we identify
    our domains and subdomains; then, we begin to scope standalone services for each.
    For example, one domain could be customer management. This service will solely
    handle the user account and demographic information. Additionally, we could scope
    bookings and appointments, document management, and finally, payments. This then
    brings another issue to the foreground: we have dependencies between these three
    subdomains when we need service independence instead. Using *domain-driven design*,
    we then scope out where there are dependencies and identify where we might need
    to duplicate certain entities. For instance, a customer needs representation in
    the booking and appointments database as well as payments. This duplication is
    required if we are using separate databases per service (which is strongly encouraged).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以同样的应用为例，探讨如何使用微服务进行架构设计。在设计阶段，我们试图确定应用每个分块的特定功能。这就是我们识别我们的领域和子领域的地方；然后，我们开始为每个领域单独定义服务。例如，一个领域可能是客户管理。这个服务将仅处理用户账户和人口统计信息。此外，我们还可以定义预订和预约、文档管理，最后是支付。这又引出了另一个问题：当我们需要服务独立性时，这三个子领域之间存在依赖关系。使用*领域驱动设计*，我们确定依赖关系所在的位置，并识别可能需要重复某些实体的地方。例如，客户需要在预订和预约数据库以及支付中有所体现。如果我们为每个服务使用单独的数据库（这强烈推荐），这种重复是必要的。
- en: 'The microservices require us to properly scope the flow of operations that
    involve multiple services playing a part. For instance, when making a booking,
    we need to do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务要求我们正确界定涉及多个服务参与的作业流程。例如，在预订时，我们需要做以下几步：
- en: Retrieve the customer making the booking.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取进行预订的客户。
- en: Ensure that the preferred time slot is available.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保首选时间段可用。
- en: If available, generate an invoice.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可用，生成发票。
- en: Collect the payment.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集付款。
- en: Confirm the appointment.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认预约。
- en: That process alone has some back-and-forth processing between the services.
    Properly orchestrating these *service conversations* is very critical to having
    a seamless system and adequately replacing a monolithic approach. Therefore, we
    introduce various design patterns and approaches to implementing our code and
    infrastructure. Even though we break potentially complex operations and workflows
    into smaller and more perceivable chunks, we end up in the same position where
    the application needs to carry out a specific operation and carry out the original
    requirements as a whole.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 仅这个过程就在服务之间有一些来回处理。正确编排这些*服务对话*对于拥有无缝系统和充分替代单体方法至关重要。因此，我们引入了各种设计模式和实现代码及基础设施的方法。尽管我们将可能复杂的操作和工作流程分解成更小、更易感知的块，但我们最终处于同样的位置，即应用需要执行特定操作，并作为一个整体满足原始需求。
- en: '*Figure 1.3* shows the typical architecture of a microservices application:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.3*展示了微服务应用的典型架构：'
- en: '![Figure 1.3 – Each microservice is standalone and unifies in a single user
    interface for user interactions](img/Figure_1.3_B19100.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 每个微服务都是独立的，并在单个用户界面中统一，以实现用户交互](img/Figure_1.3_B19100.jpg)'
- en: Figure 1.3 – Each microservice is standalone and unifies in a single user interface
    for user interactions
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 每个微服务都是独立的，并在单个用户界面中统一，以实现用户交互
- en: Now that you are familiar with the differences between the monolithic and microservices
    approaches, we can explore the pros and cons of using the microservices design
    pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经熟悉了单体和微服务方法之间的区别，我们可以探讨使用微服务设计模式的优缺点。
- en: Assessing the business need for microservices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估微服务的业务需求
- en: As we have seen so far, microservices are not easy to author, and they come
    with many cross-cutting concerns and challenges. It is always important to ask
    yourself *Why?* and *Do I really need it?* before implementing any design patterns.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，微服务不易编写，并且伴随着许多横切关注点和挑战。在实施任何设计模式之前，始终问自己*为什么？*和*我真的需要它吗？*是非常重要的。
- en: 'At a high level, some benefits of this approach are listed as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，这种方法的一些好处如下：
- en: Scalability
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Availability
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Development speed
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发速度
- en: Improved data storage
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进数据存储
- en: Monitoring
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Deployment
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: In the following sections, we will dive into the details of each.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨每个细节。
- en: Scalability
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: In the monolithic approach, you scale all or nothing. In microservices, it is
    easier to scale individual parts of the application and address specific performance
    gaps as they arise. If a vaccine becomes widely available and customers are encouraged
    to book an appointment online, then we are sure to experience a large load during
    the first few weeks. Our customer microservice might not be too affected by that,
    but we will need to scale our booking and appointments and payments services.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体方法中，要么全部扩展，要么不扩展。在微服务中，更容易扩展应用程序的各个部分，并针对出现的特定性能差距进行处理。如果疫苗变得广泛可用，并且鼓励客户在线预约，那么在最初的几周内，我们肯定会经历大量负载。我们的客户微服务可能不会受到太大影响，但我们需要扩展我们的预订和预约以及支付服务。
- en: We can scale horizontally, which means that we can allocate more CPU and RAM
    when the load increases. Alternatively, we can scale vertically by spawning more
    instances of the service to be load balanced. The better method is relative to
    the service’s needs. Using the right hosting platforms and infrastructure allows
    us to automate this process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现横向扩展，这意味着当负载增加时，我们可以分配更多的CPU和RAM。或者，我们可以通过创建更多实例来垂直扩展服务以进行负载均衡。更好的方法取决于服务的需求。使用合适的托管平台和基础设施，我们可以自动化这一过程。
- en: Availability
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: Availability means the probability of a system being operational at a given
    time. This metric goes hand in hand with the ability to scale, but it also addresses
    the reliability of the underlying code base and hosting platform. The code base
    plays a big part in that, so we want to avoid, as much as possible, a single point
    of failure. A single point of failure affects the entire system if it fails at
    any point. For example, we will be exploring the *gateway pattern*, where we will
    aggregate all services behind one point of entry. For our distributed services
    to remain available, this gateway must be always online.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性意味着在特定时间系统处于操作状态的概率。这个指标与可扩展性能力密切相关，但也解决了底层代码库和托管平台的可靠性问题。代码库在这方面起着重要作用，所以我们希望尽可能避免单点故障。如果单点故障在任何时候失败，它将影响整个系统。例如，我们将探索*网关模式*，其中我们将所有服务聚合在一个入口点后面。为了确保我们的分布式服务保持可用，这个网关必须始终在线。
- en: This can be achieved by having vertical instances that balance the load and
    distribute the expected responsiveness of the gateway and, by extension, the underlying
    services.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过拥有垂直实例来实现，这些实例平衡负载并分配网关的预期响应性，以及由此产生的底层服务的响应性。
- en: Development speed
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发速度
- en: Given that the application has been broken into domains, developers can focus
    their efforts on ensuring that their set of features is being developed efficiently.
    This also contributes to how quickly features can be added, tested, and deployed.
    It will now become a practical approach to have one team per subdomain. Additionally,
    it becomes much easier to scope the requirements for a domain and focus on fewer
    functional requirements for a piece of work. Each team can now be independent
    and own the service from development to deployment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序已被划分为域，开发者可以集中精力确保他们的功能集被高效地开发。这也促进了功能的快速添加、测试和部署。现在，为每个子域设立一个团队将变得实际可行。此外，确定域的需求并专注于较少的功能需求变得更加容易。每个团队现在都可以独立，并从开发到部署拥有服务。
- en: This allows *Agile and DevOps* methodologies to be easier to implement, and
    it is easier to scope resource requirements per team. Of course, we have seen
    that services will still need to communicate, so we will still have to orchestrate
    the integration between the teams. So, while each team is independent, they will
    still need to make their code and documentation available and easy enough to access.
    Version control also becomes important since the services will be updated over
    time, but this must be a managed process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得*敏捷和DevOps*方法更容易实施，并且更容易为每个团队确定资源需求。当然，我们已经看到服务仍然需要通信，因此我们仍然需要在团队之间进行集成编排。所以，虽然每个团队都是独立的，但他们仍然需要使他们的代码和文档易于访问。版本控制也变得很重要，因为服务将随着时间的推移而更新，但这必须是一个管理过程。
- en: Improved data storage
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进数据存储
- en: Our monolithic application uses one database for the entire application. There
    are situations where you might end up using one database for multiple microservices,
    but this is generally discouraged, and a *database-per-service* approach is preferred.
    Services must be autonomous and independently developed, deployed, and scaled.
    This is best accomplished if each service has its own data storage. It makes even
    more sense when you consider that the type of data being stored might influence
    the type of data storage that is used. Each service might require a different
    type of data store, ranging from relational database storage such as **Microsoft
    SQL Server** to document-based database storage such as **Azure Cosmos DB**. We
    want to ensure that changes to a data store will only affect the associated microservice.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单体应用程序使用一个数据库来处理整个应用程序。有时你可能会使用一个数据库来处理多个微服务，但这通常是不被推荐的，并且更倾向于*每个服务一个数据库*的方法。服务必须是自治的，并且可以独立开发、部署和扩展。如果每个服务都有自己的数据存储，这将更有意义。考虑到存储的数据类型可能会影响所使用的数据存储类型，这一点尤其正确。每个服务可能需要不同类型的数据存储，从关系型数据库存储如**Microsoft
    SQL Server**到基于文档的数据库存储如**Azure Cosmos DB**。我们希望确保数据存储的更改只会影响相关的微服务。
- en: Of course, this will bring its own challenges where data will need to be synchronized
    across the services. In the monolith, we could wrap all steps inside one transaction,
    which might lead to performance issues for potentially long-running processes.
    With microservices, we face the challenge of orchestrating distributed transactions,
    which also introduces performance risks and threatens the immediate consistency
    of our data. At this point, we must turn to the concept of *eventual consistency*.
    This means that a service publishes an event when its data changes and subscribing
    services use that event as a signal to update their own data. This approach is
    made possible through event-sourcing patterns. We accept the risk that, for a
    period, data might be inconsistent across subdomains. Message queue systems such
    as **Kafka**, **RabbitMQ**, and **Azure Service Bus** are generally used to accomplish
    this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也会带来自己的挑战，因为需要在不同服务之间同步数据。在单体架构中，我们可以将所有步骤包裹在一个事务中，这可能会对可能长时间运行的过程造成性能问题。在微服务架构中，我们面临着编排分布式事务的挑战，这也引入了性能风险，并威胁到我们数据的即时一致性。在这种情况下，我们必须转向*最终一致性*的概念。这意味着当服务的数据发生变化时，它会发布一个事件，订阅服务使用该事件作为更新自身数据的信号。这种做法是通过事件溯源模式实现的。我们接受在一段时间内，数据可能在子域之间不一致的风险。通常使用**Kafka**、**RabbitMQ**和**Azure
    Service Bus**这样的消息队列系统来完成这项工作。
- en: Monitoring
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: One of the most important aspects of a distributed system is monitoring. This
    allows us to proactively ensure uptime and mitigate against failures. We need
    to be able to view the health of our service instances. We also begin to think
    about how we can centralize logs and performance metrics in a unified manner,
    sparing us the task of going to each environment manually. Tools such as **Kibana**,
    **Grafana**, or **Splunk** allow us to create a rich dashboard and visualize all
    sorts of information about our services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统最重要的方面之一是监控。这使我们能够主动确保正常运行时间并减轻故障。我们需要能够查看我们的服务实例的健康状况。我们也开始考虑如何以统一的方式集中日志和性能指标，从而避免手动访问每个环境。**Kibana**、**Grafana**或**Splunk**等工具允许我们创建丰富的仪表板，并可视化有关我们服务的各种信息。
- en: One very important bit of information is a *health check*. Sometimes, a microservice
    instance can be running but is failing to handle requests. For example, it might
    have run out of database connections. With health checks, we can see a quick snapshot
    of the service’s health and have that data point returned to the dashboard.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一项非常重要的信息是*健康检查*。有时，一个微服务实例可能正在运行，但无法处理请求。例如，它可能已经耗尽了数据库连接。通过健康检查，我们可以快速查看服务的健康状况，并将这些数据点返回到仪表板。
- en: Logging is also a crucial tool for monitoring and troubleshooting. Typically,
    each microservice would write its own logs to files in its environment. From these
    logs, we can see information about errors, warnings, information, and debug messages.
    However, this is not efficient for a distributed system. At this point, we use
    a log aggregator. This gives us a central area to search and analyze the logs
    from the dashboards. There are a few log aggregators you can choose from such
    as **LogStash**, **Splunk**, or **PaperTrail**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志也是监控和故障排除的关键工具。通常，每个微服务都会在其环境中将日志写入自己的文件。从这些日志中，我们可以看到有关错误、警告、信息和调试消息的信息。然而，这对于分布式系统来说并不高效。在这种情况下，我们使用日志聚合器。这为我们提供了一个中央区域，可以从仪表板中搜索和分析日志。您可以从几个日志聚合器中进行选择，例如
    **LogStash**、**Splunk** 或 **PaperTrail**。
- en: Deployment
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Each microservice needs to be independently deployable and scalable. This includes
    all the security, data storage, and additional assets that our services use. They
    must all live on physical or virtual servers, whether on-premises or in the cloud.
    Ideally, each physical server will have its own memory, network, processing, and
    storage. A virtual infrastructure might have the same physical server with the
    appropriate resource allocations per service. Here, the idea is that each microservice
    instance is isolated from the other and will not compete for resources.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都需要能够独立部署和扩展。这包括我们服务使用的所有安全、数据存储和附加资产。它们必须都存在于物理或虚拟服务器上，无论是在本地还是在云端。理想情况下，每个物理服务器都将拥有自己的内存、网络、处理和存储。虚拟基础设施可能具有相同的物理服务器，并为每个服务分配适当的资源。在这里，我们的想法是每个微服务实例与其他实例隔离，不会竞争资源。
- en: Now, each microservice will need its own set of packages and supporting libraries.
    This then becomes another challenge when provisioning different machines (physical
    or virtual) and their operating systems. We then seek to simplify this by packaging
    each microservice as a container image and deploying it as a container. The container
    will then encapsulate the details of the technology used to build a service and
    provide all the CPU, memory, and microservice dependencies needed for operation.
    This makes the microservice easy to move between testing and production environments
    and provides environment consistency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个微服务将需要其自己的包和支撑库集。当在不同的机器（物理或虚拟）及其操作系统上配置时，这又成为另一个挑战。我们通过将每个微服务打包为容器镜像并作为容器部署来简化这一点。容器将封装构建服务所使用的技术的细节，并提供操作所需的全部
    CPU、内存和微服务依赖项。这使得微服务易于在测试和生产环境之间迁移，并提供了环境一致性。
- en: '**Docker** is the go-to container management system and works hand in hand
    with container orchestration services. Orchestration becomes necessary to run
    multiple containers across multiple machines. We need to start the correct containers
    at the correct time, handle storage considerations, and address potential container
    failures. All of these tasks are not practical to handle manually, so we enlist
    the services of **Kubernetes**, **Docker Swarm**, and **Marathon** to automate
    these tasks. It is best to have all the deployment steps automated and be as cost-effective
    as possible.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker** 是首选的容器管理系统，与容器编排服务紧密协作。在多台机器上运行多个容器时，编排变得必要。我们需要在正确的时间启动正确的容器，处理存储考虑事项，并解决潜在的容器故障。所有这些任务都不适合手动处理，因此我们寻求
    **Kubernetes**、**Docker Swarm** 和 **Marathon** 的服务来自动化这些任务。最好将所有部署步骤自动化，并尽可能降低成本。'
- en: Then, we look to implement an integrated pipeline that can handle the continuous
    delivery of our services, with as minimal effort as possible, while maintaining
    the highest level of consistency possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们寻求实施一个集成的管道，以尽可能少的努力处理服务的持续交付，同时保持尽可能高的一致性水平。
- en: We have explored quite a bit in this section. We reviewed why we might consider
    using a microservices approach in our development efforts. Also, we investigated
    some of the most used technologies for this approach. Now, let us turn our attention
    to justifying our use of microservices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经探讨了相当多。我们回顾了为什么我们可能会考虑在我们的开发工作中使用微服务方法。我们还调查了一些最常用的技术。现在，让我们将注意力转向证明我们使用微服务的合理性。
- en: Determining the feasibility of implementing microservices
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定实施微服务的可行性
- en: As we explore the microservices approach, we see where it does address certain
    things, while introducing a few more concerns. The microservices approach is certainly
    not a savior for your architectural challenges, and it introduces quite a few
    complexities. These concerns and complexities are generally addressed using design
    patterns, and using these patterns can save time and energy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索微服务方法，我们看到它确实解决了某些问题，同时也引入了一些新的关注点。微服务方法当然不是解决你的架构挑战的救世主，它引入了许多复杂性。这些关注点和复杂性通常通过设计模式来解决，使用这些模式可以节省时间和精力。
- en: Throughout this book, we will explore the most common problems we face and look
    at the design pattern concepts that help us to address these concerns. These patterns
    can be categorized as follows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将探讨我们面临的最常见问题，并查看帮助我们解决这些关注点的设计模式概念。这些模式可以按以下方式分类。
- en: 'Let us explore what each pattern entails:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索每个模式包含的内容：
- en: '**Integration patterns**: We have already discussed that microservices will
    need to communicate. Integration patterns serve to bring consistency to how we
    accomplish this. Integration patterns govern the technology and techniques that
    we use to accomplish cross-service communications.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成模式**：我们已经讨论过，微服务需要相互通信。集成模式旨在统一我们完成这一目标的方式。集成模式管理我们用于实现跨服务通信的技术和技巧。'
- en: '**Database and storage design patterns**: We know that we are in for a challenge
    when it comes to managing data across our distributed services. Giving each service
    its own database seems easy until we need to ensure that data is kept consistent
    across the different data stores. There are certain patterns that are pivotal
    to us maintaining a level of confidence in what we see after each operation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库和存储设计模式**：我们知道，在管理分布式服务中的数据时，我们将面临挑战。为每个服务提供自己的数据库似乎很简单，直到我们需要确保数据在不同数据存储之间保持一致性。有一些模式对我们保持对每次操作后所看到内容的信心至关重要。'
- en: '**Resiliency, security, and infrastructure patterns**: These patterns seek
    to bring calm and comfort to a brewing storm. With all the moving parts that we
    have identified, it is important to ensure that as many things as possible are
    automated and consistent in the deployment. Additionally, we want to ensure that
    security is adequately balanced between the system needs and a good user experience.
    These patterns help us to ensure that our systems are always performing at peak
    efficiency.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性、安全和基础设施模式**：这些模式旨在为即将到来的风暴带来平静和安慰。鉴于我们已经确定的所有移动部件，确保尽可能多的自动化和部署一致性至关重要。此外，我们还想确保在系统需求和良好的用户体验之间平衡安全。这些模式帮助我们确保我们的系统始终以峰值效率运行。'
- en: Next, let us discuss using .NET Core as our development stack for microservices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论将.NET Core作为我们的微服务开发堆栈。
- en: Microservices and .NET Core
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务和.NET Core
- en: 'This book addresses implementing microservices and design patterns using .NET
    Core. We have mentioned that this architectural style is platform agnostic and
    has been implemented using several frameworks. Comparably, however, ASP.NET Core
    makes microservices development very easy and offers many benefits, including
    cloud integrations, rapid development, and cross-platform support:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论了使用.NET Core实现微服务和设计模式。我们已经提到，这种架构风格是平台无关的，并已使用多个框架实现。然而，相比之下，ASP.NET Core使微服务开发变得非常简单，并提供了许多好处，包括云集成、快速开发和跨平台支持：
- en: '`dotnet new webapi` on your computer. If you prefer the fully powered Visual
    Studio IDE, then you might be limited to Windows and macOS. You will have all
    the tools you need to be successful regardless of the operating system.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的电脑上运行`dotnet new webapi`。如果你更喜欢功能齐全的Visual Studio IDE，那么你可能仅限于Windows和macOS。无论操作系统如何，你都将拥有成功所需的所有工具。
- en: '**Stability**: At the time of writing this book, the latest stable version
    is *.NET 7*, with standard term support. The .NET development team is always pushing
    the envelope and ensuring that reverse compatibility is maintained with each major
    version release. This makes updating to the next version much less difficult,
    and you need not worry about too many breaking changes all at once.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性**：在撰写本书时，最新的稳定版本是*.NET 7*，具有标准支持期限。.NET开发团队始终在推动边界，并确保每个主要版本发布时保持向后兼容性。这使得升级到下一个版本变得更加容易，你不必担心一次性出现太多破坏性变化。'
- en: '**Containerization and scaling**: ASP.NET Core applications can easily be mounted
    on a *Docker* container, and while this is not necessarily new, we can all appreciate
    a guaranteed render speed and quality. We can also leverage Kubernetes and easily
    scale our microservices using all the features of K8s.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化和扩展**：ASP.NET Core应用程序可以轻松地安装在*Docker*容器上，虽然这并不一定是新的，但我们都能欣赏到保证的渲染速度和质量。我们还可以利用Kubernetes，并利用K8s的所有功能轻松扩展我们的微服务。'
- en: .NET development has come a long way, and these are exciting times to push the
    boundaries of what we can build, using their tools and services.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: .NET开发已经走得很远，现在是时候利用他们的工具和服务来推动我们能够构建的边界了。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, I hope you have a better idea of what microservices are, why you may
    or may not end up using this architectural style, and the importance of using
    design patterns. In each of the chapters of this book, we will explore how to
    use design patterns to develop a *solid* and reliable system based on microservices,
    using .NET Core and various supporting technologies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我希望你对微服务有了更好的理解，为什么你可能或可能不会最终使用这种架构风格，以及使用设计模式的重要性。在这本书的每一章中，我们将探讨如何使用设计模式，结合.NET
    Core和多种支持技术，开发一个**坚实**和可靠的基于微服务的系统。
- en: We will remain realistic and explore the pros and cons of each of our design
    decisions and explore how various technologies play integral parts in helping
    us to tie it all together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持现实态度，探讨每个设计决策的优缺点，并研究各种技术如何在我们整合所有内容中发挥关键作用。
- en: In this chapter, we explored the differences between designing a monolith and
    microservices, assessed the feasibility of building microservices, and explored
    why .NET Core is an excellent choice for building microservices
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了设计单体和微服务的区别，评估了构建微服务的可行性，并探讨了为什么.NET Core是构建微服务的优秀选择。
- en: In the next chapter, we will look at implementing the **Aggregator Pattern**
    in our microservices application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在我们的微服务应用程序中实现**聚合器模式**。
