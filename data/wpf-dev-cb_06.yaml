- en: Using Styles, Templates, and Triggers
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用样式、模板和触发器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Creating the `Style` of a control
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建控制的 `Style`
- en: Creating the `Style` of a control based on another `Style`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于另一个 `Style` 创建控制的 `Style`
- en: Applying `Style` to a control automatically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动应用 `Style` 到控件
- en: Editing the template of any control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑任何控件的模板
- en: Creating a property trigger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建属性触发器
- en: Creating a multi trigger
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多触发器
- en: Creating a data trigger
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据触发器
- en: Creating a multi data trigger
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多数据触发器
- en: Creating an event trigger
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事件触发器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When designing a user interface for an application, you need to ensure the consistency
    of the look and feel of the controls across the application. For example, if you
    are using buttons, they should look the same—similar colors, the same margins,
    and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当为应用程序设计用户界面时，你需要确保控件在应用程序中的外观和感觉的一致性。例如，如果你正在使用按钮，它们应该看起来相同——相似的颜色、相同的边距等等。
- en: '**Styles** are objects that hold the `Setter` properties to provide a bunch
    of settings to elements and controls. Style also provides control templates, which
    are used to customize the control template to have a distinctive look and feel.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式** 是包含 `Setter` 属性的对象，为元素和控件提供一系列设置。样式还提供控件模板，用于自定义控件模板以具有独特的外观和感觉。'
- en: In the Win32/WinForms model, the look and the behavior of the controls were
    tightly bundled; but in WPF world a control template is created in XAML using
    designer-oriented tools, and this applies styles to produce a similar look. You
    can also inherit a style from a different style.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Win32/WinForms 模型中，控件的外观和行为是紧密捆绑的；但在 WPF 世界中，控件模板是通过使用面向设计师的工具在 XAML 中创建的，并且这应用于样式以产生类似的外观。你也可以从不同的样式中继承样式。
- en: In this chapter, we will discuss styles, templates, triggers, and their relationships
    with the controls to which they are applied.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论样式、模板、触发器以及它们与所应用控件的关联。
- en: Creating the style of a control
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制样式
- en: Styles provide you with a convenient way to group a set of properties and triggers
    within a single object and apply it to the elements. You can do this selectively
    to a set of controls, or you can apply it to all the controls automatically, based
    on the control type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 样式为你提供了一个方便的方法，可以在单个对象内分组一组属性和触发器，并将其应用到元素上。你可以选择性地将其应用到一组控件，或者根据控件类型自动将其应用到所有控件。
- en: In this recipe, we'll begin with the default style of a button and set its various
    style properties to give it a new look. We will then apply it selectively to set
    the style of multiple button controls.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从按钮的默认样式开始，设置其各种样式属性以赋予它新的外观。然后我们将选择性地应用它以设置多个按钮控件的样式。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get started by creating a new project called `CH06.ControlStyleDemo`.
    Make sure you create the project based on the WPF application template.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `CH06.ControlStyleDemo` 的新项目开始。确保你基于 WPF 应用程序模板创建项目。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will get started by creating two buttons inside the application
    window. Then we will create a style for the button and apply it to both of the
    controls. Follow these steps to try it on your own:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从在应用程序窗口内创建两个按钮开始。然后我们将为按钮创建一个样式并将其应用到这两个控件上。按照以下步骤尝试自己操作：
- en: From the Solution Explorer, open the `MainWindow.xaml` and replace the existing
    `Grid` panel by a `StackPanel`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开 `MainWindow.xaml` 并将现有的 `Grid` 面板替换为 `StackPanel`。
- en: Set the `Orientation` property of the `StackPanel` to `Vertical`, so that we
    can stack the child controls vertically.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `StackPanel` 的 `Orientation` 属性设置为 `Vertical`，这样我们就可以垂直堆叠子控件。
- en: 'Now add a few buttons inside it and assign a content. Here''s our markup of
    the `StackPanel` with two buttons:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向其中添加几个按钮并分配内容。这是我们的包含两个按钮的 `StackPanel` 标记：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Build and run the application. You will see the following UI:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。你将看到以下 UI：
- en: '![](img/a831b4ec-c8eb-4cb0-9690-a04ea022b8c2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a831b4ec-c8eb-4cb0-9690-a04ea022b8c2.png)'
- en: Close the application and return to the `MainWindow.xaml` page. Inside the `Window`
    tag, add `<Window.Resources></Window.Resources>` to add the button style inside
    it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用程序并返回到 `MainWindow.xaml` 页面。在 `Window` 标签内添加 `<Window.Resources></Window.Resources>`
    以在其中添加按钮样式。
- en: 'Copy the following style inside the resources to define a style called `ButtonBaseStyle`,
    for our button controls:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下样式复制到资源中，以定义一个名为 `ButtonBaseStyle` 的样式，用于我们的按钮控件：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now apply the defined style to both of the buttons by adding the attribute
    `Style="{StaticResource ButtonBaseStyle}"`. Here''s the code, for your reference:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过添加属性`Style="{StaticResource ButtonBaseStyle}"`将定义的样式应用到两个按钮上。以下是代码，供您参考：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once this is done, build the project, and run the application again. You will
    see that the buttons are now shaped properly with some padding between the text
    and the edge. Also, the font size has increased, as defined in the style. Here''s
    how it looks now:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，构建项目，再次运行应用程序。你会看到按钮现在形状正确，文本和边缘之间有一些填充。此外，字体大小已增加，正如样式中所定义的。现在看起来是这样的：
- en: '![](img/3afa50e2-997c-4287-b784-8483fad8c59f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3afa50e2-997c-4287-b784-8483fad8c59f.png)'
- en: 'Let''s add a few additional `Setter` properties to the style. We will now define
    a `4px` margin, a hand cursor, and a border, as shared here:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在样式中添加一些额外的`Setter`属性。我们现在将定义一个`4px`的边距、一个手形光标和一个边框，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s the complete style that we have built up to this point:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是到目前为止我们构建的完整样式：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s compile the project and run the application again. You will now see
    a better UI with proper styling of the button controls, as shown in the following
    screenshot:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译项目并再次运行应用程序。现在您将看到一个更好的UI，按钮控件有适当的样式，如下面的截图所示：
- en: '![](img/c38304d6-8ff2-4878-be6e-e6f248512a51.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c38304d6-8ff2-4878-be6e-e6f248512a51.png)'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you create a `Style` object, you set a bunch of `Setter` objects to it
    to define various properties to change the look and feel of the control. This
    may include the height, width, positions, alignments, colors, fonts, control template,
    triggers, and more.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`Style`对象时，你设置了一组`Setter`对象到它上面，以定义各种属性来改变控件的外观和感觉。这可能包括高度、宽度、位置、对齐方式、颜色、字体、控件模板、触发器等等。
- en: The `FrameworkElement` class exposes a `Style` property that can be filled by
    a `Style` object. Styles are always built as resources, as you see them inside
    the `<Window.Resources>` tag in our example. It contains an `x:Key` property,
    which defines the name/key of the style. By using this `Key`, you can perform
    a binding from any other resources/controls within the scope. The `TargetType`
    property of a `Style` object is typically set, which makes the `Style` applicable
    to that type, which can be any type, even a type of a custom control.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameworkElement`类公开了一个`Style`属性，可以通过`Style`对象填充。样式始终作为资源构建，正如您在我们示例中的`<Window.Resources>`标签内看到的那样。它包含一个`x:Key`属性，该属性定义了样式的名称/键。通过使用此`Key`，您可以从作用域内的任何其他资源/控件执行绑定。`Style`对象的`TargetType`属性通常被设置，这使得`Style`适用于该类型，这可以是任何类型，甚至是自定义控件的类型。'
- en: In this example, the applied style works on `Button` objects. Trying to apply
    the same to some other element type will cause a runtime exception.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，应用样式作用于`Button`对象。尝试将其应用于其他元素类型将导致运行时异常。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can omit defining the `TargetType` of a `Style`, but, for that to work,
    you must define the property with a fully qualified name. For example, the preceding
    `Style` can be written as shown here to get the same result:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略定义`Style`的`TargetType`，但要使其工作，你必须使用完全限定名称来定义属性。例如，前面的`Style`可以像下面这样编写，以获得相同的结果：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As this makes the property name redundant, to define a qualified name people
    prefer to use the first one with a `TargetType` defined. Then, what is the use
    of the second type of declaration? Yes, the question is valid. With this type
    of styling, by specifying the fully qualified name of the property, you can define
    a style targeting various types of controls where the said properties are available.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这使得属性名称冗余，为了定义一个限定名称，人们更喜欢使用第一个带有`TargetType`定义的名称。那么，第二种声明类型有什么用呢？是的，这个问题是合理的。使用这种样式，通过指定属性的完全限定名称，你可以定义一个针对各种类型的控件（在这些控件中可用该属性）的样式。
- en: A point to note is that if you explicitly define a property to a control, it
    will override the property value defined in the `Style`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，如果你明确地为控件定义了一个属性，它将覆盖`Style`中定义的属性值。
- en: Creating the Style of a control based on another Style
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于另一个样式创建控件样式
- en: Styles support inheritance. That means, you can derive a `Style` from another
    `Style`. This can be done using the `BasedOn` property, which must point to another
    `Style` to inherit from. In this recipe, we will learn how to create a `Style`
    of a button control based on another `Style` of the same type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 样式支持继承。这意味着，你可以从一个`Style`派生出一个`Style`。这可以通过使用`BasedOn`属性来完成，该属性必须指向另一个要继承的`Style`。在本教程中，我们将学习如何根据另一个相同类型的`Style`创建一个按钮控制的`Style`。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get started by creating a project named `CH06.StyleInheritanceDemo`. To
    do this, open your Visual Studio instance and create a project based on the WPF
    application template.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `CH06.StyleInheritanceDemo` 的项目开始。为此，打开您的 Visual Studio 实例，并基于 WPF
    应用程序模板创建一个项目。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a base style for a button control and then derive
    it to create different button styles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个按钮控件的基样式，然后从中派生出不同的按钮样式：
- en: Open the `MainWindow.xaml` file and create a `<Window.Resources></Window.Resources>`
    section inside the `Window` tag.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件，并在 `Window` 标签内创建一个 `<Window.Resources></Window.Resources>`
    部分。
- en: 'Now, inside the window resources, add the following style definition, which
    we discussed in the previous recipe of this chapter:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在窗口资源内添加以下样式定义，这是我们之前在本章的另一个配方中讨论过的：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the default `Grid` to have the following `StackPanel` with four button
    controls, having the same style that we have created:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Grid` 替换为以下具有四个按钮控制的 `StackPanel`，这些按钮具有我们创建的相同样式：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build the project and run it. You will see the following UI has the same style
    applied to all the button controls:![](img/105afbf0-14bf-43ed-97fe-0dadbbe09bf0.png)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行它。您将看到以下 UI，其中所有按钮控件都应用了相同的样式！![图片](img/105afbf0-14bf-43ed-97fe-0dadbbe09bf0.png)
- en: To demonstrate the `Style` inheritance, let's create another `Style`, based
    on the base `Style`. Give it a new `Key` name, `RedButtonStyle`, set the `TargetType`
    to `Button`, and add a new attribute `BasedOn="{StaticResource ButtonBaseStyle}"`
    to create the inheritance.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示 `Style` 继承，让我们创建另一个基于基 `Style` 的 `Style`。给它一个新的 `Key` 名称，`RedButtonStyle`，将
    `TargetType` 设置为 `Button`，并添加一个新的属性 `BasedOn="{StaticResource ButtonBaseStyle}"`
    以创建继承。
- en: 'Add some additional `Setter` values to the newly created style to define its
    border, background, and foreground color. Here''s the markup for the `RedButtonStyle`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向新创建的样式添加一些额外的 `Setter` 值，以定义其边框、背景和前景颜色。以下是 `RedButtonStyle` 的标记：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now change the `Style` property of the `redButton` to point itself to `RedButtonStyle`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `redButton` 的 `Style` 属性更改为指向 `RedButtonStyle`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's run the application once again, which will have the following UI, where
    the second button will have a reddish background color and a white font color:![](img/2f2c67be-14ba-49e3-8600-0e05f817195e.png)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行应用程序，它将具有以下 UI，其中第二个按钮将具有红色背景和白色字体颜色！![图片](img/2f2c67be-14ba-49e3-8600-0e05f817195e.png)
- en: Now, add two more styles, based on the `ButtonBaseStyle`, and name them as `GreenButtonStyle`
    and `BlueButtonStyle`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加另外两个基于 `ButtonBaseStyle` 的样式，分别命名为 `GreenButtonStyle` 和 `BlueButtonStyle`。
- en: 'Set their `BorderBrush`, `Foreground`, and `Background` properties to have
    a greenish and bluish color, respectively. To do this, copy the following styles
    inside the `<Window.Resources>` tag:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们的 `BorderBrush`、`Foreground` 和 `Background` 属性分别设置为绿色和蓝色。为此，请在 `<Window.Resources>`
    标签内复制以下样式：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To apply the preceding styles, modify the `Style` property of the `greenButton`
    and the `blueButton` as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用前面的样式，按照以下方式修改 `greenButton` 和 `blueButton` 的 `Style` 属性：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the code snippet for the entire `StackPanel`, which will now have four
    buttons. Among which the first button is following the base style, whereas the
    other three buttons are following the new red, green, and blue button styles,
    respectively:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是整个 `StackPanel` 的代码片段，现在它将包含四个按钮。其中第一个按钮遵循基本样式，而其他三个按钮分别遵循新的红色、绿色和蓝色按钮样式：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Time to build the project and run the application. Now, when the application
    launches, it will have the following UI, but with unique styles. As mentioned
    earlier, the colors of the buttons will be as per the values we set to the different
    styles:![](img/47fe7d6e-c20f-43fb-8278-1573b5f5f37d.png)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候构建项目并运行应用程序了。现在，当应用程序启动时，它将具有以下 UI，但具有独特的样式。如前所述，按钮的颜色将根据我们为不同样式设置的值来设置！![图片](img/47fe7d6e-c20f-43fb-8278-1573b5f5f37d.png)
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An inherited style can have additional `Setter` properties to set, or it can
    provide a different value for a property that has been set by the base `Style`.
    In the preceding example, the `RedButtonStyle`, `GreenButtonStyle`, and `BlueButtonStyle`
    inherit from the first (`ButtonBaseStyle`), and add `BorderBrush`, `Foreground`,
    and `Background` setter properties to it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 继承样式可以具有额外的 `Setter` 属性来设置，或者它可以为已由基 `Style` 设置的属性提供不同的值。在上面的示例中，`RedButtonStyle`、`GreenButtonStyle`
    和 `BlueButtonStyle` 继承自第一个（`ButtonBaseStyle`），并向其添加了 `BorderBrush`、`Foreground`
    和 `Background` 设置器属性。
- en: Applying Style to a control automatically
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动应用样式到控件
- en: In the previous two recipes, we learned about creating styles and applying them
    to controls by using the `x:Key` name. It's not always feasible to manually assign
    the style to a set of huge controls within the same application. For this reason,
    we need to apply it automatically to all the elements within the scope of a specific
    window or the entire application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个菜谱中，我们学习了如何创建样式，并通过使用`x:Key`名称将它们应用到控件上。在同一个应用程序内手动为大量控件分配样式并不总是可行的。因此，我们需要将其自动应用到特定窗口作用域内的所有元素或整个应用程序中。
- en: For example, we may want all buttons within the same app to have the same look
    and feel. This makes creating new buttons easier, as the developer/designer doesn't
    have to know what style to apply. If the auto styling is configured, it will make
    the work far smoother.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望同一应用内的所有按钮都拥有相同的样式和感觉。这使得创建新的按钮更加容易，因为开发者/设计师不需要知道应用哪种样式。如果自动样式配置正确，它将使工作流程更加顺畅。
- en: Let's see how this can be done with a simple example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子看看这是如何实现的。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start this recipe, open your Visual Studio instance and create a new WPF
    application project called `CH06.StyleUsageDemo`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个菜谱，打开您的Visual Studio实例，创建一个名为`CH06.StyleUsageDemo`的新WPF应用程序项目。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create styles for button controls and apply them to controls
    within the same window, followed by applying them across the application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为按钮控件创建样式，并将它们应用到同一窗口内的控件上，然后跨整个应用程序应用：
- en: 'Open the `MainWindow.xaml` and replace the existing `Grid` with the following
    `StackPanel`, containing four button controls:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`，并将现有的`Grid`替换为以下`StackPanel`，其中包含四个按钮控件：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `<Window.Resources></Window.Resources>` section inside the `Window`
    tag and add the following style inside it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Window`标签内创建一个`<Window.Resources></Window.Resources>`部分，并在其中添加以下样式：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inside the Solution Explorer, right-click on the project. Follow the path Add
    | Window... from the context menu entry to open the Add New Item dialog window.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，右键单击项目。从上下文菜单中选择“添加 | 窗口...”，以打开添加新项对话框窗口。
- en: Enter the name as `SecondaryWindow` and click Add. This will create `SecondaryWindow.xaml`
    and `SecondaryWindow.xaml.cs` files inside the project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称为`SecondaryWindow`，然后点击添加。这将创建项目内的`SecondaryWindow.xaml`和`SecondaryWindow.xaml.cs`文件。
- en: 'Open the `SecondaryWindow.xaml` file and replace `Grid` with the same `StackPanel`
    to create the UI, having four buttons inside it. Here''s the markup that you need
    to copy:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SecondaryWindow.xaml`文件，将`Grid`替换为相同的`StackPanel`以创建UI，其中包含四个按钮。以下是您需要复制的标记：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, navigate to the `App.xaml` file and remove the `StartupUri="MainWindow.xaml"`
    attribute, as shown in the following screenshot:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到`App.xaml`文件，并删除如以下屏幕截图所示的`StartupUri="MainWindow.xaml"`属性。
- en: '![](img/2ebc7729-9eec-4a4a-830b-cf81e8a38ba4.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ebc7729-9eec-4a4a-830b-cf81e8a38ba4.png)'
- en: 'Now go to its code-behind file, that is, the `App.xaml.cs`, and insert the
    following code block inside the class implementation to create instances of both
    the `MainWindow` and the `SecondaryWindow` to show on the screen:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到其代码隐藏文件，即`App.xaml.cs`，并在类实现中插入以下代码块以创建`MainWindow`和`SecondaryWindow`的实例以显示在屏幕上：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once this is done, compile your project, and run the application.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，编译您的项目，并运行应用程序。
- en: 'As shown in the following screenshot, you will have two windows on the screen.
    One window (`MainWindow`) will have the styles applied to the button controls,
    whereas the other window (`SecondaryWindow`) will have the default look and feel:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，您将在屏幕上看到两个窗口。一个窗口（`MainWindow`）将应用按钮控件的样式，而另一个窗口（`SecondaryWindow`）将保持默认的样式和感觉：
- en: '![](img/629afc7a-0e57-4d87-b182-1759c55bbf38.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/629afc7a-0e57-4d87-b182-1759c55bbf38.png)'
- en: Now close the application and navigate to the `MainWindow.xaml` file. Copy the
    style that we have there and delete/comment the entire `Window.Resources` section.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关闭应用程序并导航到`MainWindow.xaml`文件。复制那里的样式，并删除/注释掉整个`Window.Resources`部分。
- en: 'Now open the `App.xaml` file and paste the copied content inside the `Application.Resources`
    tag, as shared here:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`App.xaml`文件，并将复制的内文粘贴到`Application.Resources`标签内，如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s build and run the application. You will now see that the styles are
    applied to both windows. Here''s a screenshot of the same:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序。您现在将看到样式被应用到两个窗口上。以下是相同的屏幕截图：
- en: '![](img/356c2a3a-0980-44bc-9058-9bedc498ec85.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/356c2a3a-0980-44bc-9058-9bedc498ec85.png)'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The automatic styling works when you create a style without specifying an `x:Key`
    value. Any element that does not set its style explicitly obtains it automatically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个未指定 `x:Key` 值的样式时，自动样式会起作用。任何未显式设置其样式的元素将自动获得它。
- en: In the preceding example, we had the buttons in both the windows (`MainWindow`
    and `SecondaryWindow`), and no `Style` was manually applied to any one of them,
    but still the controls in the `MainWindow` got the style of Red Button, as the
    `Style` within that window was created without specifying any key (`<Style TargetType="{x:Type
    Button}">`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在两个窗口（`MainWindow` 和 `SecondaryWindow`）中都有按钮，并且没有手动将任何样式应用到它们中，但 `MainWindow`
    中的控件仍然获得了红色按钮的样式，因为该窗口中的 `Style` 创建时没有指定任何键 (`<Style TargetType="{x:Type Button}">`）。
- en: For `SecondaryWindow`, we had no `Style` element defined, and, thus, it applied
    the default style of the button.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SecondaryWindow`，我们没有定义任何 `Style` 元素，因此它应用了按钮的默认样式。
- en: When we moved the `Style` definition to the `Application.Resources` tag in `App.xaml`,
    it registered the `Style` to the application level. Now, when you run the application,
    both the windows will receive the style from the application resource, and all
    controls of type `Button` will apply that style automatically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `Style` 定义移动到 `App.xaml` 中的 `Application.Resources` 标签时，它将 `Style` 注册到应用程序级别。现在，当您运行应用程序时，两个窗口都将从应用程序资源接收样式，并且所有类型的
    `Button` 控件将自动应用该样式。
- en: If an element wishes to revert to its default style, it can set its `Style`
    property to `null`. This is generally written as `{x:Null}` in XAML.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个元素希望恢复其默认样式，它可以将其 `Style` 属性设置为 `null`。这通常在 XAML 中写作 `{x:Null}`。
- en: Editing the template of any control
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑任何控件的模板
- en: WPF allows you to customize the template of any control. Using Visual Studio,
    you can easily edit any template to meet your requirements. In this recipe, we
    will discuss how to edit the template of a `ProgressBar` control.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 允许您自定义任何控件的模板。使用 Visual Studio，您可以轻松地编辑任何模板以满足您的需求。在本例中，我们将讨论如何编辑 `ProgressBar`
    控件的模板。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get started with creating a project called `CH06.ControlTemplateDemo`.
    Make sure you select the right WPF application template while creating the project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `CH06.ControlTemplateDemo` 的项目开始。确保在创建项目时选择正确的 WPF 应用程序模板。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to edit the progress bar template:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编辑进度条模板：
- en: Open the `MainWindow.xaml` file and replace the default `Grid` control with
    a vertical `StackPanel`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件，并将默认的 `Grid` 控件替换为垂直的 `StackPanel`。
- en: 'Add two `ProgressBar` controls inside the `StackPanel` and set their `Height`,
    `Width`, and `Value` properties, as shared here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StackPanel` 内添加两个 `ProgressBar` 控件，并设置它们的 `Height`、`Width` 和 `Value` 属性，如这里所示：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you run the application, you will see the application window contains two
    progress bar controls. Both the controls will have the default style applied to
    them. Here''s a screenshot of the same:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到应用程序窗口包含两个进度条控件。这两个控件都将应用默认样式。以下是相同截图：
- en: '![](img/50edd9c8-90a4-457c-9983-177c164513f1.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50edd9c8-90a4-457c-9983-177c164513f1.png)'
- en: Now, we will create a custom template for the `ProgressBar` control and apply
    it to the second progress bar. To do this, add the following markup inside the
    `Window` tag to define the template under the `Window.Resources`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为 `ProgressBar` 控件创建一个自定义模板并将其应用到第二个进度条上。为此，在 `Window` 标签内添加以下标记，以在 `Window.Resources`
    下定义模板。
- en: 'Make sure you set the proper `TargetType` and assign an `x:Key` name to it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您设置了正确的 `TargetType` 并为其分配一个 `x:Key` 名称：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now apply the template to the second control by adding the `Template="{StaticResource
    ProgressBarTemplate}"` attribute value. After doing this, the XAML will look as
    follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过添加 `Template="{StaticResource ProgressBarTemplate}"` 属性值将模板应用到第二个控件上。完成此操作后，XAML
    将如下所示：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s run the application once again. You will see the second control has
    our custom template applied to it, and it looks like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行应用程序。您将看到第二个控件应用了我们的自定义模板，看起来如下：
- en: '![](img/859213cc-daa4-42ce-8b5c-5d2dff6f8c44.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/859213cc-daa4-42ce-8b5c-5d2dff6f8c44.png)'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you assign the `Template="{StaticResource ProgressBarTemplate}"` to the
    control, it applies the template to the associated control. The progress bar control
    contains two major parts defined in its template, and they are, `PART_Track` and
    `PART_Indicator`. The first one is used to define the base track of the control,
    whereas the second one defines the progress indicator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将`Template="{StaticResource ProgressBarTemplate}"`分配给控件时，它将应用模板到相关控件。进度条控件包含在其模板中定义的两个主要部分，它们是`PART_Track`和`PART_Indicator`。第一个用于定义控件的基本轨道，而第二个用于定义进度指示器。
- en: 'In our template, we assigned a `LinearGradientBrush` as the `PART_Indicator`
    rectangle''s `Fill` color to design the progress indication in a bar format. `GradientStop`
    is used to define the `Offset` of the selected color, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，我们将`LinearGradientBrush`分配给`PART_Indicator`矩形的`Fill`颜色，以设计以条形格式显示的进度指示。使用`GradientStop`定义所选颜色的`Offset`，如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, when the application runs, because of its repeat behavior (`SpreadMethod="Repeat"`)
    of `LinearGradientBrush`, the stacked bars will spread across the control based
    on the value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当应用程序运行时，由于`LinearGradientBrush`的重复行为（`SpreadMethod="Repeat"`），堆叠的条形将根据值在控件中展开。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: It's not easy to remember the default template body of the controls. It is also
    not possible to remember each control part, defined as `PART_Name`. Visual Studio
    provides an effortless way to modify the template.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 记住控件默认模板的主体并不容易。也不可能记住每个定义为`PART_Name`的控件部分。Visual Studio提供了一个轻松修改模板的方法。
- en: 'To do this, right-click on the control and follow the context menu entry Edit
    Template | Edit a Copy..., as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，右键单击控件并遵循以下截图所示的上下文菜单条目编辑模板 | 编辑副本...：
- en: '![](img/e587592f-4a69-4706-81b1-89a93f545af7.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e587592f-4a69-4706-81b1-89a93f545af7.png)'
- en: This will open up a dialog window to specify the file where you want to create
    the style. If you select Application, it will be created under the `Application.Resources`
    tag and will be accessible throughout the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个对话框窗口，以指定您想要创建样式的文件。如果您选择应用程序，它将创建在`Application.Resources`标签下，并且可以在整个应用程序中访问。
- en: 'If you choose This document, it will get created under the `Window.Resources`
    tag:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择此文档，它将创建在`Window.Resources`标签下：
- en: '![](img/3dfa9257-3301-46b2-90cc-f71476f168bd.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dfa9257-3301-46b2-90cc-f71476f168bd.png)'
- en: From this screen, you also have an option of whether to create an implicit or
    explicit style. Select Apply to all to create an **implicit style**, and all controls
    of that type will get the same style within that scope. In another case, give
    it a **Key** name. Once you click OK, it will create the default template in the
    same XAML. You can customize it based on your requirements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕，您还可以选择创建隐式或显式样式。选择应用全部以创建**隐式样式**，该范围内的所有控件都将获得相同的样式。在另一种情况下，给它一个**键**名称。一旦您点击确定，它将在相同的XAML中创建默认模板。您可以根据需求进行自定义。
- en: Never remove any `PART` controls of a template, which is defined by `PART_`,
    as the controls internally need them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要移除任何由`PART_`定义的模板的`PART`控件，因为这些控件在内部需要它们。
- en: Creating a property trigger
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建属性触发器
- en: A trigger enables you to change property values when certain conditions are
    satisfied. It can also enable you to take actions based on property values by
    allowing you to dynamically change the appearance and/or the behavior of your
    control without writing additional codes in the code-behind classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器允许您在满足某些条件时更改属性值。它还可以通过允许您动态更改控件的外观和/或行为，而无需在代码后类中编写额外的代码，来根据属性值执行操作。
- en: The most common trigger is the **property trigger**, which can be simply defined
    in XAML with a `<Trigger>` element. It triggers when a specific property on the
    owner control changes to match a specified value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的触发器是**属性触发器**，它可以通过XAML中的`<Trigger>`元素简单地定义。当拥有控件的特定属性更改以匹配指定值时，它将触发。
- en: In this recipe, we will learn about property triggers with a suitable example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过合适的示例学习属性触发器。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio instance and create a new WPF application project called
    `CH06.PropertyTriggerDemo`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的Visual Studio实例，创建一个名为`CH06.PropertyTriggerDemo`的新WPF应用程序项目。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To work with the property trigger, we will use a `Label` control in this example
    and trigger the system to change its various properties on mouse hover. Follow
    these simple steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用属性触发器，我们将在这个示例中使用一个`Label`控件并触发系统在鼠标悬停时改变其各种属性。遵循以下简单步骤：
- en: 'Open the `MainWindow.xaml` page and add the following `Label` control inside
    the grid:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`页面并在网格内添加以下`Label`控件：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inside the `Window` tag, create a `Window.Resources` tag to hold the style of
    the `Label` control. Create a `Style` inside the resources and set its `TargetType`
    to `Button`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Window`标签内，创建一个`Window.Resources`标签来保存`Label`控件的风格。在资源内创建一个`Style`并将其`TargetType`设置为`Button`。
- en: 'Add the following trigger inside the style:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在样式内添加以下触发器：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s the complete style containing the trigger for the `Label` control,
    which will change the mentioned properties on mouse hover:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是包含对`Label`控件触发器的完整样式，当鼠标悬停时将改变所提到的属性：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, build the project and run it. You will see a Hover over the text label
    on the application window. Mouse hover on the text to see the effect on the screen,
    as shown here:![](img/51bb599a-dbed-474a-ab85-9df9b79004f4.png)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建项目并运行它。你将看到应用程序窗口上的文本标签上有一个悬停效果。将鼠标悬停在文本上以查看屏幕上的效果，如图所示：![](img/51bb599a-dbed-474a-ab85-9df9b79004f4.png)
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The style of the `Label` creates a `Trigger` that fires on mouse hover by checking
    the `IsMouseOver="True"` property value. When the condition satisfies, it sets
    the `Setter` properties as defined under it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`的样式创建了一个在鼠标悬停时触发的`Trigger`，通过检查`IsMouseOver="True"`属性值。当条件满足时，它将设置器属性设置为定义在其下的属性。'
- en: When the condition becomes `false`, the setters are logically removed, reverting
    the properties to their original values. This means that it is not required to
    provide an *opposite* trigger.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件变为`false`时，设置器逻辑上被移除，将属性还原到其原始值。这意味着不需要提供一个*相反*的触发器。
- en: Creating a multi trigger
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个多触发器
- en: It is not mandatory to use a trigger to perform only an action based on a single
    condition. Sometimes you need to create it with a composition of multiple conditions
    that activate the entire trigger, if all the conditions are met. This is what
    the **multi trigger** does. Let's see how to create a multi trigger.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并非必须使用触发器仅基于单一条件执行动作。有时你需要创建一个由多个条件组合而成的触发器，如果所有条件都满足，则激活整个触发器。这就是**多触发器**的作用。让我们看看如何创建一个多触发器。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE and create a new WPF application called `CH06.MultiTriggerDemo`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Visual Studio IDE并创建一个名为`CH06.MultiTriggerDemo`的新WPF应用程序。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we will build a simple application that will create
    and execute a multi trigger based on some conditions and change the `Foreground`
    and `Background` properties of the `TextBox` controls:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将构建一个简单的应用程序，它将创建并执行一个基于某些条件的多触发器，并改变`TextBox`控件的`Foreground`和`Background`属性：
- en: Open the `MainWindow.xaml` file.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件。
- en: Replace the default `Grid` panel with a vertical `StackPanel`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的`Grid`面板替换为垂直的`StackPanel`。
- en: 'Add two `TextBox` controls inside the panel and set their `Text` property to
    represent some text. Here''s the XAML that we will be using in this example:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板内添加两个`TextBox`控件并设置它们的`Text`属性以表示一些文本。以下是本例中我们将使用的XAML：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, under the window resources (`Window.Resources`), create a `Style` that
    targets a `TextBox`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在窗口资源（`Window.Resources`）下创建一个针对`TextBox`的`Style`：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a style trigger with `MultiTrigger`, based on one or more conditions,
    and apply the setters, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于一个或多个条件的`MultiTrigger`样式触发器，并应用设置器，如下所示：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s execute the application and focus on the `TextBox` controls to see the
    behavior:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们执行应用程序并关注`TextBox`控件以查看其行为：
- en: '![](img/947b0dfb-f63f-4b20-8d98-487926bd17db.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/947b0dfb-f63f-4b20-8d98-487926bd17db.png)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is almost like the **Property Trigger**, but here it is used to set an
    action on multiple property changes, and will execute it when all the conditions
    within the `MulitTrigger.Conditions` are satisfied. The `MultiTrigger` object
    hosts a collection of these `Condition` objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就像**属性触发器**，但在这里它用于在多个属性更改上设置动作，并在`MulitTrigger.Conditions`内的所有条件都满足时执行它。`MultiTrigger`对象包含这些`Condition`对象集合。
- en: Here, in this example, we have `MultiTrigger` associated with `TextBox` controls.
    When the control is enabled and gets keyboard focus, it changes its `Foreground`
    and `Background` properties. When either of them is `false`, it returns the property
    values to its original state.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个与`TextBox`控件关联的`MultiTrigger`。当控件启用并获得键盘焦点时，它更改其`Foreground`和`Background`属性。当其中任何一个为`false`时，它将属性值返回到其原始状态。
- en: Creating a data trigger
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据触发器
- en: As the name says, the **data trigger** applies property values to perform a
    set of actions on the `Data` that has been bound to the `UIElement`. This is represented
    by the `<DataTrigger>` element.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，**数据触发器**将属性值应用于对已绑定到`UIElement`的`Data`执行一系列操作。这由`<DataTrigger>`元素表示。
- en: In this recipe, we will learn how to create a trigger that acts on the underlying
    data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个对底层数据起作用的触发器。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get started with creating a new WPF project. Open the Visual Studio and
    create a project called `CH06.DataTriggerDemo`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的WPF项目开始。打开Visual Studio并创建一个名为`CH06.DataTriggerDemo`的项目。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these simple steps to create a data trigger that will act to change
    the `Background` and `Content` property of a `Label`, based on the radio button
    selection:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤创建一个数据触发器，该触发器将根据单选按钮的选择更改`Label`的`Background`和`Content`属性：
- en: From the Solution Explorer, open the `MainWindow.xaml` file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，打开`MainWindow.xaml`文件。
- en: 'Let''s divide the `Grid` panel into two columns:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`Grid`面板分为两列：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now insert a `Label` of `150` x `100` dimension at column `0` (zero) and set
    its `Foreground` property to `White`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在列`0`（零）插入一个`150` x `100`维度的`Label`，并将其`Foreground`属性设置为`White`：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Insert a vertical `StackPanel` at Column `1` and add three radio buttons inside
    it. Make sure you set their names and the `GroupName`. The `x:Name` property is
    used to define the name of the controls and the `GroupName="colors"` is used to
    define a single group for the radios. Here''s the complete XAML markup:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列`1`插入一个垂直的`StackPanel`，并在其中添加三个单选按钮。确保设置它们的名称和`GroupName`。`x:Name`属性用于定义控件名称，`GroupName="colors"`用于定义单选按钮的一个组。以下是完整的XAML标记：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside the `Window.Resources` tag of the window, create a `Style` that targets
    `Label` control:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的`Window.Resources`标签内，创建一个针对`Label`控件的`Style`：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Insert the following trigger inside the `Style`. The `<Style.Triggers>` contains
    three `DataTrigger` bound to the checkbox controls:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Style`内插入以下触发器。`<Style.Triggers>`包含三个绑定到复选框控件的`DataTrigger`：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As the trigger is ready, let''s build the project and run it. Change the radio
    button selection and observe how it works, as shown in the following screenshot:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当触发器准备就绪时，让我们构建项目并运行它。更改单选按钮选择并观察其工作情况，如图所示：
- en: '![](img/66d2c691-74a0-4542-bbd2-cc555473c59f.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66d2c691-74a0-4542-bbd2-cc555473c59f.png)'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you click on the first radio button (`rdoRed`), it triggers the first data
    trigger, as it satisfies the `IsChecked` property of `rdoRed` control and modifies
    the `Setter` properties—`Content` and `Background`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击第一个单选按钮（`rdoRed`）时，它触发第一个数据触发器，因为它满足`rdoRed`控件的`IsChecked`属性并修改`Setter`属性——`Content`和`Background`。
- en: Similarly, when you change the selection to the second or third radios, the
    respective `DataTrigger` will fire and update the `Label` control, according to
    the `Setter` properties.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你将选择更改为第二个或第三个单选按钮时，相应的`DataTrigger`将触发并更新`Label`控件，根据`Setter`属性。
- en: Creating a multi data trigger
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多数据触发器
- en: A **multi data trigger** is the same as the **data trigger**, with the only
    difference being that you can set property values based on multiple conditions
    defined in the `MultiDataTrigger.Conditions`. Property values are defined in the
    `MultiDataTrigger.Setters`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**多数据触发器**与**数据触发器**相同，唯一的区别在于你可以在`MultiDataTrigger.Conditions`中定义的多个条件下设置属性值。属性值在`MultiDataTrigger.Setters`中定义。'
- en: Let's learn about the multi data trigger usages in this recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解在这个菜谱中多数据触发的用法。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with the multi data trigger, let's start by creating a project
    called `CH06.MultiDataTriggerDemo`. Make sure you select the proper project template.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用多数据触发器，让我们首先创建一个名为`CH06.MultiDataTriggerDemo`的项目。确保选择正确的项目模板。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a UI with two checkboxes and a button, and then
    apply a multi data trigger to enable/disable the button, based on the check state:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个包含两个复选框和一个按钮的UI，然后根据复选状态应用多数据触发器来启用/禁用按钮：
- en: 'Let''s begin by replacing the `Grid` with a `StackPanel`, having two checkbox
    (`chkLicense` and `chkTerms`) controls and one button:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从用`StackPanel`替换`Grid`开始，其中包含两个复选框（`chkLicense`和`chkTerms`）控件和一个按钮：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, modify the `Button` to expose its style, as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改`Button`以公开其样式，如下所示：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following button style inside it, which contains a `MultiDataTrigger`
    to enable/disable the button:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加以下按钮样式，它包含一个`MultiDataTrigger`来启用/禁用按钮：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now run the application, which will have two checkboxes and a button on the
    screen. Change the selections of the checkbox controls to see the behavior:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序，屏幕上将有两个复选框和一个按钮。更改复选框控件的选择以查看行为：
- en: '![](img/96eee90e-16da-4ed0-9c5a-869aa7e2ef1d.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96eee90e-16da-4ed0-9c5a-869aa7e2ef1d.png)'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A multi data trigger works based on the conditions set to it, which acts on
    the underlying data. In our example, we have a `MultiDataTrigger` with two conditions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 多数据触发器基于设置给它的条件工作，它作用于底层数据。在我们的例子中，我们有一个包含两个条件的`MultiDataTrigger`。
- en: According to the conditions, if both the checkbox controls are checked, it will
    trigger and enable the button by setting the `IsEnabled` property to `True`. When
    any of the preceding conditions are not satisfied, it will automatically set the
    `IsEnabled` property to the previous value, which is `False` in our case.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据条件，如果两个复选框控件都被选中，它将触发并启用按钮，通过将`IsEnabled`属性设置为`True`。当任何前面的条件不满足时，它将自动将`IsEnabled`属性设置回上一个值，在我们的例子中是`False`。
- en: Creating an event trigger
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建事件触发器
- en: Till now, we have seen property triggers and data triggers, which work based
    on comparing a property to a value. In this recipe, we will learn about **event
    triggers** which fire when a routed event occurs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了属性触发器和数据触发器，它们基于比较属性与值来工作。在本例中，我们将学习**事件触发器**，它在发生路由事件时触发。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Inside your Visual Studio IDE, create a new project called `CH06.EventTriggerDemo`,
    based on the WPF application template.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Visual Studio IDE中，创建一个名为`CH06.EventTriggerDemo`的新项目，基于WPF应用程序模板。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a simple event trigger on a `TextBlock` control:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在`TextBlock`控件上创建一个简单的事件触发器：
- en: 'Open the `MainWindow.xaml` and add the following `TextBlock` inside the `Grid`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`并在`Grid`内添加以下`TextBlock`：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following style, containing `EventTrigger`, to the `TextBlock.Style`
    attribute:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下包含`EventTrigger`的样式添加到`TextBlock.Style`属性：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build the application and run it. Hover your mouse on top of the text and you
    will see that the font size of the text gradually increases, and the visibility
    becomes `100%`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并运行它。将鼠标悬停在文本上方，您会看到文本的字体大小逐渐增大，可见性变为`100%`：
- en: '![](img/0c94dd95-d8b6-4a53-a751-5dab07f5d1ff.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c94dd95-d8b6-4a53-a751-5dab07f5d1ff.png)'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The event triggers are generally used to perform actions when the **Routed Events**
    of the associated `FrameworkElement` raises. This is mainly used in animations
    to control the look and feel when a certain UI event is raised.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 事件触发器通常用于在关联的`FrameworkElement`的**路由事件**引发时执行操作。这主要用于动画，以控制在某个UI事件引发时的外观和感觉。
- en: In this example, when you hover over the mouse cursor on the `TextBlock` control,
    the `MouseEnter` event fires and that triggers `EventTrigger`, which we have defined
    in the XAML. It then animates the text to have a bigger font size and a higher
    opacity to give a bigger, better visible content.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，当您将鼠标悬停在`TextBlock`控件上时，`MouseEnter`事件会触发，并触发`EventTrigger`，这是我们已在XAML中定义的。然后它将文本动画化以具有更大的字体大小和更高的不透明度，以提供更大、更明显的可见内容。
- en: When the `MouseLeave` event fires, it reduces the size of the font and brings
    the control opacity to `20%`. More about the `Storyboard` animations will be discussed
    in *Chapter 8,* *Working with Animations*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MouseLeave`事件触发时，它会减小字体大小并将控件的不透明度降低到`20%`。关于`Storyboard`动画的更多内容将在*第8章*，*与动画一起工作*中讨论。
