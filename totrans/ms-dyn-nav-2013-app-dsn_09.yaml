- en: Chapter 9. Interfacing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the first version of Microsoft Dynamics NAV for Windows was released in
    1995, the system was very closed. It was possible to import and export data using
    flat text files and that was basically it. These flat text files were placed on
    a floppy disk and sent by postal mail. Internet and e-mail were just coming, large
    USB sticks were a dream, and when the previous version of this book was released
    in 2009, OneDrive and Azure where being invented.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, the world has changed tremendously. Internet, e-mail, SQL Server,
    .NET, and Azure changed the way we think about interfacing with applications and
    we are still changing. Today Microsoft Dynamics NAV 2013 has a completely open
    database and supports a wide range of interfacing possibilities, which we will
    learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.0 of Navision ran on Windows 95, which later became an industry standard
    and for more than a decade, Windows was the only serious platform. Today, business
    people use iPads and Android tablets. Microsoft Dynamics NAV 2013 is one of few
    ERP platforms that can run cross-platform on all devices, even supporting login
    using Google or Facebook credentials.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first discuss the available interfacing technologies
    and the interfaces available in the standard product. Then we will talk about
    interfacing methodology and how to create reliable interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will create some sample interfaces and see how
    the future will further improve interfacing.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a good understanding of what interfaces
    the product supports out of the box, what interfacing technologies to use, and
    how to design a solid business to business interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interface types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When discussing an interface, we usually start with the technology, but before
    that, some other basic questions need answering, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it need to import, export, or both?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it started manually or automatically?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the interface timer or event driven?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these questions.
  prefs: []
  type: TYPE_NORMAL
- en: Import and export
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first question is whether the interface should only export data from Microsoft
    Dynamics NAV or whether it would also import data to the system that then needs
    to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: When importing and exporting, the data process can be started manually by an
    end user using data pulling or data pushing. The interface can also be event-
    (real time) or timer-driven (asynchronous).
  prefs: []
  type: TYPE_NORMAL
- en: '![Import and export](img/0365EN_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manual
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an interface is manual, the first application has an export process and
    another application has an import process. The end user first manually starts
    the export process and then manually starts the import process in another application,
    usually saving the data to a flat file. This is a classic approach to interfacing.
  prefs: []
  type: TYPE_NORMAL
- en: An example of manual interfacing is exporting telebanking information from Microsoft
    Dynamics NAV or sending XBRL files to your accountant.
  prefs: []
  type: TYPE_NORMAL
- en: Data pulling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using data pulling to export data, the interface is started from an external
    application. This application will read the data from the database and process
    it.
  prefs: []
  type: TYPE_NORMAL
- en: When using data pulling to import data, the interface is started from the application,
    which reads and processes data from another application.
  prefs: []
  type: TYPE_NORMAL
- en: Data pushing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an interface uses data pushing, the exporting application writes the data
    to the other data source. This method is used when the data in the other application
    does not need further processing. A typical example is exporting data from Microsoft
    Dynamics NAV to Microsoft Office applications such as Word or Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven versus timer-driven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When data pushing or data pulling is combined with the use of events or timers,
    there is no longer a need for end user interference. The interface will then run
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss these methods in detail later in this chapter when we discuss
    interface methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV, there are a wide range of methods to interface. Each
    method is useful for certain types of interfacing and less useful for other types.
    We will discuss all available methods in the C/SIDE development platform.
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flat files and XML files are both supported by Microsoft Dynamics NAV. Flat
    files have been available since the introduction of the product in 1995 using
    data ports for the classic clients.
  prefs: []
  type: TYPE_NORMAL
- en: XML support was introduced in Version 3.60 as an extra option for data ports.
    Version 4.0 introduced the `XMLPort` object that replaced the data port for importing
    and exporting XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Currently in Microsoft Dynamics NAV 2013, `XMLPort` objects are used both for
    XML and flat files. Additionally, C/AL has a `FILE` object that can be used to
    access files directly without using `XMLPort` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Automation control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation for Microsoft COM and ActiveX in Microsoft Dynamics NAV is
    referred to as automation control.
  prefs: []
  type: TYPE_NORMAL
- en: Automation control or ActiveX allows software applications to be reused as an
    embedded part of another application. Most Microsoft applications support being
    used in such a way. Examples are Microsoft Office, Windows Scripting Host, and
    **ActiveX Data Objects** (**ADO**).
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV has support for automation control. Consuming automation
    control is done using interfaces exposing methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used and generic interface is iUnknown. This is also the only
    automation control interface supported by Microsoft Dynamics NAV. If the automation
    control uses other interfaces, a wrapper should be created in Visual Studio transforming
    the interface to iUnknown. We should also create a wrapper when the automation
    control needs to be embedded using a form control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the iUnknown interface and COM technology can be found
    at [http://en.wikipedia.org/wiki/IUnknown](http://en.wikipedia.org/wiki/IUnknown).
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most automation controls allow data to be pushed. Using events for automation
    control, it is also possible to start business logic in Microsoft Dynamics NAV
    when something happens in the other application.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV 2013, automation control can only be used from the
    client side. All code that runs on the server side cannot use automation control
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: DotNet interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The support of .NET was introduced as a replacement for automation control.
    It is possible to use a wide range of .NET objects directly in C/AL programming
    language. They can be used in both server side and client side.
  prefs: []
  type: TYPE_NORMAL
- en: Within the standard application, most automation interfaces are replaced with
    .NET interfaces such as the Excel interface, which we will discuss later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are limitations using .NET in Microsoft Dynamics NAV, which are typically
    solved by creating wrapper DLL objects in C#. The Excel interface is an example
    of that too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good place to start learning about .NET in C/AL is [www.vjeko.com](http://www.vjeko.com).
    The limitations are discussed at [http://vjeko.com/blog/top-10-things-i-miss-in-net-interoperability-in-nav-2013](http://vjeko.com/blog/top-10-things-i-miss-in-net-interoperability-in-nav-2013).
  prefs: []
  type: TYPE_NORMAL
- en: Client extensibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the page objects, the level of allowed creativity in the user interface
    is very limited since the page objects do not provide WYSIWYG capabilities or
    allow the developer to determine control positions. Each client determines how
    the UI is rendered and the developer has no control. This is solved using client
    extensibility. This technology allows using all UI capabilities that Visual Studio
    and .NET offer, however, when developing for cross-platform, JavaScript should
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [https://www.youtube.com/watch?v=WErBd1mlZFM](https://www.youtube.com/watch?v=WErBd1mlZFM)
    to learn how to get started with JavaScript add-ins for Microsoft Dynamics NAV.
  prefs: []
  type: TYPE_NORMAL
- en: Open Database Connectivity (ODBC)/ADO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Open Database Connectivity** (**ODBC**) was developed in 1992 with the goal
    of allowing all types of databases to exchange data in a unified way. ADO is the
    successor of ODBC and was developed in 1996.'
  prefs: []
  type: TYPE_NORMAL
- en: ADO and ODBC for Microsoft Dynamics NAV allows both reading and writing in the
    application database as well as reading and writing to other databases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using ADO and ODBC more advanced requires basic knowledge of T-SQL Statements.
    Refer to [http://www.differencebetween.com/difference-between-odbc-and-vs-ado/](http://www.differencebetween.com/difference-between-odbc-and-vs-ado/)
    for the differences between ADO and ODBC.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from Microsoft Dynamics NAV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To read data from the database, you only need to have a valid ODBC driver installed
    on the Windows machine that you are using and credentials to log in to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an example to import data from Microsoft Dynamics NAV using Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Open Microsoft Excel and select **Data** and then select **From SQL Server**
    form **From Other Sources**, as shown in the following screenshot:![Reading from
    Microsoft Dynamics NAV](img/0365EN_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From SQL Server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select a **Server name** and valid **Credentials**:![Reading from Microsoft
    Dynamics NAV](img/0365EN_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a database and the table that you want to view. In our example, we will
    select the **Customer** table. Then select **Finish** and **OK**.![Reading from
    Microsoft Dynamics NAV](img/0365EN_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the Microsoft Dynamics NAV Data in Excel.![Reading from Microsoft
    Dynamics NAV](img/0365EN_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Since flow fields are not actual fields in the SQL Server database, we cannot
    use them in ODBC/ADO.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Writing to Microsoft Dynamics NAV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Directly writing data to the Microsoft Dynamics NAV database using ODBC is not
    recommended as best practice. The reason for this is the missing business logic
    at this interface level.
  prefs: []
  type: TYPE_NORMAL
- en: When writing via ODBC, we directly address SQL Server without allowing the C/AL
    business logic to validate the data we create. The C/AL data normally ensures
    data integrity for the business rules we develop. The same applies when using
    the C/ODBC driver for the native database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work around this issue, the data can be saved in a special interface buffer
    table and processed by a C/AL transaction using an application server or started
    from the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Talking to other databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use ODBC to read and write data from Microsoft Dynamics NAV to other databases,
    it is recommended to use **ActiveX Data Objects** (**ADO**). ADO is a Microsoft
    technology that allows using an ActiveX interface to connect using ODBC. Using
    ADO allows us to both read and write to the database on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: We could even use ADO to connect to the Microsoft Dynamics NAV SQL Server database
    and run SQL Statements from C/AL code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use ADO in the interface methodology section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server interfacing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Microsoft Dynamics NAV runs on top of a SQL Server database, we can use
    all available technologies in SQL Server to get data in and out. This offers a
    wide range of options that go beyond the scope of this book, but let''s briefly
    discuss some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linked Servers**: In SQL Server, it is possible to set up linked servers.
    This allows us to send queries to other databases such as other SQL Servers, MS
    Access, or Oracle and create views based on this data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views**: A view in SQL Server is a saved query with a fixed result set that
    can be interpreted as a table. In C/Side, we can use a view as a data source for
    a table using the Linked Object property and create a page or report based on
    this data source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Server Integration Services**: This replaces DTS Packages as the primary
    component for SQL Server to integrate with other databases. Using SSIS requires
    good knowledge and skills of both SQL Server and Microsoft Dynamics NAV.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reporting Services**: This is a server-based reporting platform that can
    be integrated with SharePoint allowing users to design RDL reports based on T-SQL
    queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis Services**: This is Microsoft''s answer to the OLAP, BI, and data
    mining requirements of their customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Another SQL Server component we can use is the SQL Server Agent. This component
    allows us to schedule interface tasks that run directly on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Microsoft Message Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microsoft Message Queue** (**MSMQ**) allows applications to integrate that
    run asynchronously with an unreliable connection. This interfacing technology
    is very popular for websites that use information from Microsoft Dynamics NAV
    and send information back to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of .NET Interoperability made using MSMQ in combination with
    Microsoft Dynamics NAV much easier. Using `System.Messaging.MessageQueue` only
    a few lines of C/AL code are required to post a message on a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Application server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MSMQ is always combined with using an application server to handle the requests
    sent back by the website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application server](img/0365EN_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The web users can be employees from the company using a web solution for timesheet
    registration or a PDA or customers using a web shop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This blog entry at [http://mibuso.com/blogs/ara3n/2011/01/10/using-ado-on-rtc-in-nav/](http://mibuso.com/blogs/ara3n/2011/01/10/using-ado-on-rtc-in-nav/)
    explains how to get started with MSMQ using .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to real-time interfacing, web services is the first technology
    of choice. Web services allows you to use function libraries from applications
    inside other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV 2013 allows you to expose all C/AL code as a web service
    using SOAP and OData protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming web services is a lot more difficult than exposing one. There is no
    standard framework of doing so. The two most commonly used solutions are consuming
    using XMLDOM .NET interop objects or wrapping the web service inside a Visual
    Studio `.dll` using service references.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing a NAV web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV 2013, every `Page` object and most codeunits can be
    exposed as a web service. This can be done using the **Web Service Table (2000000076)**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing a NAV web service](img/0365EN_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To publish a web service, select the object type and object ID and find a unique
    service name. Then select the **Published** checkmark.
  prefs: []
  type: TYPE_NORMAL
- en: When publishing a web service, the URL is displayed making it easier to find
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a Microsoft Dynamics NAV web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To consume the web service, an address, `http://<Server>:<WebServicePort>/<ServerInstance>/WS/<CompanyName>/`,
    is generated that is called from the other application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming a Microsoft Dynamics NAV web service](img/0365EN_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SystemService` web service is always available and returns a list of available
    company names.
  prefs: []
  type: TYPE_NORMAL
- en: Standard application interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed all the available interface technologies for Microsoft Dynamics
    NAV. Let's have a look at how this has been implemented in the standard product.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will not explore each interface in depth since that would almost
    require another book. We will just briefly discuss where to find all technologies
    we discussed in the standard application and indicate where a white paper or website
    can be found.
  prefs: []
  type: TYPE_NORMAL
- en: An example of flat file is Exporting Contacts. Microsoft Dynamics NAV allows
    us to export our contacts using an **XMLPort**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **XMLPort** for this functionality has number (5050) and uses the Format
    Variable Text. Other options are **Xml** and **Fixed Text**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard application interfaces](img/0365EN_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**XMLPorts** have a node structure like pages. The **XMLPort** starts with
    integer table as the first data type followed by the **Contact table** fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about programming **XMLPorts** can be found in *Programming
    Dynamics NAV 2013*, *David A. Studebaker*, *Christopher D. Studebaker*, *Packt
    Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Office integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV and Microsoft Office are integrated to use with Word,
    Excel, and Outlook. We will first discuss the standard Word and Excel integration
    and discuss alternatives later. Lastly, we will briefly discuss the possibilities
    for Outlook integration.
  prefs: []
  type: TYPE_NORMAL
- en: Word and Excel integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV, each form or page can be exported to Word and Excel.
    This built-in technology is automatically provided by the user interface and requires
    no effort from developers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Word and Excel integration](img/0365EN_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default presence of Excel and Word
  prefs: []
  type: TYPE_NORMAL
- en: Style sheet tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be more flexible in the layout, Microsoft has released a style sheet tool
    for Microsoft Dynamics NAV and Word. This tool allows users to easily generate
    style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The style sheet tool Version 3.0 can be downloaded from [http://www.mibuso.com/dlinfo.asp?FileID=1543](http://www.mibuso.com/dlinfo.asp?FileID=1543).
  prefs: []
  type: TYPE_NORMAL
- en: '![Style sheet tool](img/0365EN_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The manual provided with the style sheet tool gives a good description about
    how to create the style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Style sheet tool](img/0365EN_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the action to the action designer (under the appropriate group) with the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnAction` trigger should contain the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `StyleSheetDataMgt` is a variable of type codeunit, 682 (Style Sheet Data
    Management).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When this action is done for one page, it can be easily copied and pasted to
    other pages. Make sure you change the page name.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Excel integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When exporting information to Excel that needs to be combined from different
    parts of the application, using style sheets is not the ideal way.
  prefs: []
  type: TYPE_NORMAL
- en: To support this, the **Excel Buffer** table (370) can be used. This table can
    be populated with data and then sent to Excel using a simple C/AL command.
  prefs: []
  type: TYPE_NORMAL
- en: This is used in several parts of the application, for example, to import and
    export the budgets we discussed in [Chapter 3](ch03.html "Chapter 3. Financial
    Management"), *Financial Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a sample codeunit that exports data to Excel using the Excel
    Buffer table:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new codeunit and define a global variable of type record Excel buffer.
    This needs to be a temporary variable. Also, define the other variables as displayed
    in the following screenshot:![Advanced Excel integration](img/0365EN_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Temporary record variables are not stored in the database; they're stored in
    the client memory. This allows multiple users to create the same records without
    blocking each other. It is also faster since all handling is done without the
    network and database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new `EnterCell` function with the parameters displayed in the following
    screenshot:![Advanced Excel integration](img/0365EN_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the C/AL code in place that will handle the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This C/AL code will browse the customers in the database and format the addresses
    using the Address Format (365) codeunit.
  prefs: []
  type: TYPE_NORMAL
- en: The **Customer No.** field and the result array `Addr[]` are saved in the Excel
    buffer table. Lastly, we start the C/AL functions to generate the Excel spreadsheet
    based on the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced Excel integration](img/0365EN_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: C/AL functions result
  prefs: []
  type: TYPE_NORMAL
- en: Outlook integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft Dynamics NAV 2013 allows different levels of interfacing with Microsoft
    Outlook:'
  prefs: []
  type: TYPE_NORMAL
- en: The Outlook part on the Role Center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending e-mails from pages using the `ExtendedDatatype` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Mail (397) or SMTP Mail (400) codeunits to send e-mails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronize contacts and to-do's using the Outlook integration web service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading e-mail from exchange using the **E-Ma****il – Logging** functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV 2013 R2 can be connected to Office 365.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outlook part
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a Role Center it is possible to activate the Outlook System Part. This allows
    users to see their e-mail, agenda, and tasks directly on the Role Center.
  prefs: []
  type: TYPE_NORMAL
- en: '![Outlook part](img/0365EN_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This functionality is built in the Windows client and cannot be changed using
    C/AL Code.
  prefs: []
  type: TYPE_NORMAL
- en: ExtendedDatatype property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a **Text** field in a table uses the `ExtendedDatatype` property, **E-Mail**
    the Windows client will automatically allow the users to directly send an e-mail
    to the address specified in the field.
  prefs: []
  type: TYPE_NORMAL
- en: '![ExtendedDatatype property](img/0365EN_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is also built-in functionality in the Windows client that cannot be influenced
    by C/AL code.
  prefs: []
  type: TYPE_NORMAL
- en: '![ExtendedDatatype property](img/0365EN_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mail and SMTP mail codeunits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before the introduction of the `ExtendedDatatype` property, the e-mails from
    Microsoft Dynamics NAV were sent using an Automation Control wrapper DLL to Microsoft
    Outlook. This is handled in codeunit 397 and can still be used to send e-mails
    directly From C/AL code.
  prefs: []
  type: TYPE_NORMAL
- en: Codeunit SMTP Mail (400) allows us to send e-mails directly to an SMTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Outlook synchronization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft Outlook can be used as an offline client for Microsoft Dynamics NAV.
    Every table can be synchronized to Microsoft Outlook when a connection with both
    systems is available. Using the Offline functionality in Outlook, users can view
    the data when they are on the road and even change the information or create new
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This is done using the Outlook Synchronization web service that we discussed
    earlier this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Outlook synchronization](img/0365EN_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The functionality is well documented by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Exchange integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To read incoming e-mails, Microsoft Dynamics NAV offers integration with Exchange
    Public folders. Information in these mailboxes can be read and used in Microsoft
    Dynamics NAV.
  prefs: []
  type: TYPE_NORMAL
- en: The handling of the interface is done using the Job Queue and the Application
    Server (NAS).
  prefs: []
  type: TYPE_NORMAL
- en: In the **Marketing Setup**, which we discussed in [Chapter 4](ch04.html "Chapter 4. Relationship
    Management"), *Relationship Management*, we can set up the parameters for the
    exchange integration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exchange integration](img/0365EN_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interaction log entries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each e-mail read from Microsoft Exchange is displayed in Microsoft Dynamics
    NAV as an interaction log entry.
  prefs: []
  type: TYPE_NORMAL
- en: Office 365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting from version 2013 R2, Microsoft Dynamics NAV can be integrated into
    Office 365\. This is a cosmetic integration, which means from an end-user perspective
    the applications are one and the same; however, the applications do not share
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV can be set up to accept the Office 365 credentials, which
    makes it very easy for users to log in only once and use both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Office 365](img/0365EN_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Login with the Office 365 credentials
  prefs: []
  type: TYPE_NORMAL
- en: SharePoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV 2013 RTM was shipped with a special SharePoint client.
    However, since this was directly discontinued in R2 we will not discuss this.
  prefs: []
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV 2013 R2, the web client is SharePoint-compliant. To
    use Microsoft Dynamics NAV 2013 R2 in combination with SharePoint, it is possible
    to add web parts that connect to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to connect to both the on premise version of SharePoint and SharePoint
    Online.
  prefs: []
  type: TYPE_NORMAL
- en: Client add-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV 2013 ships with one client add-in for Microsoft Connect.
    An example page object that uses the Connect control is Connect (9175).
  prefs: []
  type: TYPE_NORMAL
- en: '![Client add-ins](img/0365EN_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's have a look at how this done.
  prefs: []
  type: TYPE_NORMAL
- en: '![Client add-ins](img/0365EN_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The page type of this page is **CardPart** and it has no source table. The only
    control on the page is **Parameters**, which is a function with a Text (350) return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The `ControlAddIn` property points to the add-in that will be used when this
    page is started. This add-in will replace the original control on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Parameters` function, a string is created to feed information into
    the connect add-in enabling it to show information that is interesting for the
    current role. This is done using a combination of other C/AL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 7](ch07.html "Chapter 7. Storage and Logistics"), *Storage and Logistics*,
    Client Extensibility and Bing Maps are used to show the stops of a route on a
    map.
  prefs: []
  type: TYPE_NORMAL
- en: The available libraries are stored in the client add-in table (2000000069).
  prefs: []
  type: TYPE_NORMAL
- en: Interface methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now we have discussed interface types, interface technologies, and the built-in
    interfaces in Microsoft Dynamics NAV.
  prefs: []
  type: TYPE_NORMAL
- en: Let's design and develop a new business to business interface. We will use the
    objects from [Chapter 7](ch07.html "Chapter 7. Storage and Logistics"), *Storage
    and Logistics*, to create the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of our customers wants to e-mail the shipments from now on instead of faxing.
    The e-mail will contain an Excel file in a predefined format.
  prefs: []
  type: TYPE_NORMAL
- en: The design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's bring back the data model we designed for the logistics part of the solution
    in [Chapter 7](ch07.html "Chapter 7. Storage and Logistics"), *Storage and Logistics*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The design](img/0365EN_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The process starts in the registration table. From a registration, we generate
    shipments and shipments are combined into a Route with stops.
  prefs: []
  type: TYPE_NORMAL
- en: So we need to move the data from the Excel sheet to the registration table.
  prefs: []
  type: TYPE_NORMAL
- en: The mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a customer delivers us an Excel sheet with information, it seldom happens
    that they exactly use the same fields as our table. Therefore, we need to create
    a mapping. Each field in the Excel sheet needs to be mapped to a field and missing
    fields need to be identified and discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Excel Sheet we get from the customer looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The mapping](img/0365EN_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to map this information to our Logistics Registration Worksheet
    table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field number | Field name | Data type | Length | Mapped field |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Registration Batch | Code | 10 | - |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Line No. | Integer |   | - |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Shipment Date | Date |   | Date |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Product No. | Code | 20 | Goods Code |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Description | Text | 50 | Description |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Unit of Measure | Text | 10 | - |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | Quantity | Decimal |   | Pallets |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | Length | Decimal |   | Length |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | Width | Decimal |   | Width |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | Height | Decimal |   | Height |'
  prefs: []
  type: TYPE_TB
- en: '| 31 | Gross Weight | Decimal |   | - |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | Net Weight | Decimal |   | Weight |'
  prefs: []
  type: TYPE_TB
- en: '| 36 | Units per Parcel | Decimal |   | - |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | Unit Volume | Decimal |   | - |'
  prefs: []
  type: TYPE_TB
- en: '| 53 | Ship-to Name | Text | 50 | Delivery At |'
  prefs: []
  type: TYPE_TB
- en: '| 55 | Ship-to Address | Text | 50 | Address |'
  prefs: []
  type: TYPE_TB
- en: '| 57 | Ship-to City | Text | 30 | City |'
  prefs: []
  type: TYPE_TB
- en: '| 58 | Ship-to Contact | Text | 50 | - |'
  prefs: []
  type: TYPE_TB
- en: '| 59 | Ship-to Post Code | Code | 20 | Postal Code |'
  prefs: []
  type: TYPE_TB
- en: '| 60 | Ship-to County | Text | 30 | - |'
  prefs: []
  type: TYPE_TB
- en: '| 61 | Ship-to Country/Region Code | Code | 10 | - |'
  prefs: []
  type: TYPE_TB
- en: Most of the fields in the Excel sheet can be mapped to a field in our table.
  prefs: []
  type: TYPE_NORMAL
- en: The gaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some fields that are needed in NAV are not populated by the Excel sheet. For
    some fields this is okay, for example, the **Registration Batch** and **Line No.**
    fields are determined by the import.
  prefs: []
  type: TYPE_NORMAL
- en: Some other fields are more difficult. **Unit of Measure**, **Gross Weight**,
    **Units per Parcel**, and **Unit Volume** are left blank in the Excel sheet, but
    they are all needed in NAV.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these fields, we need to come to an agreement with the customer. They need
    to either specify these fields or tell us whether they have default values. Let''s
    look at our gaps and fill them in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit of Measure**: For this customer it is always "PALLET"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: This can be calculated using `Length x Width x Height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gross Weight**: We agree that this is equal to net weight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Units per Parcel**: This is always 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if it does not work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading the external data into the database is just one step in creating a reliable
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if the customer contacts us and says, "We sent you a file with
    10 lines and the shipment document shows 9 lines". When we check our database
    the shipment does show 9 lines, but there is no way to check whether we imported
    the original 10 lines. At this stage, the imported Registration lines are deleted
    and the shipments are generated.
  prefs: []
  type: TYPE_NORMAL
- en: If this happens, we need traceability. In a well-designed interface, we should
    always create a table that exactly matches the imported data. This allows us to
    first check whether everything matches.
  prefs: []
  type: TYPE_NORMAL
- en: The data from this table can be processed but should not be deleted from the
    database and periodically cleaned up. This allows us to check whether things go
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate this in a more advanced example.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of our storage and logistics add-on requires a real-time
    interface with a Radio Frequency application. The RF scanners are used for the
    pick process. The RF application uses its own database system with tables we should
    populate and read afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![The scenario](img/0365EN_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The RF application has three tables. Our interface needs to export data to the
    **Pick Lines** table, and it needs to import data from the two remaining tables,
    **Finished Picks** and **Exceptions**.
  prefs: []
  type: TYPE_NORMAL
- en: The interface type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an import and export interface that will use data pushing for the Pick
    Lines and data pulling for the Finished Picks and Exceptions. The interface will
    be timer-driven. Every minute we will poll for new data.
  prefs: []
  type: TYPE_NORMAL
- en: The interface technology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this interface, we will use a combination of technologies that we discussed
    in this chapter. The main technology is DotNet interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Active data objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Picking database runs on SQL Server so we will use ADO to connect to the
    database and send T-SQL Statements to read and write data.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this interface, we will enable two types of logging. The first log will be
    to duplicate the RF tables in Microsoft Dynamics NAV and use them as a buffer.
    A second log will be maintained where we will save a copy of all T-SQL statements
    we generate. This will enable us to see what we generated if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the design of the interface we will be developing for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The design pattern](img/0365EN_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The interface will be controlled from an **Application Server**. Each minute
    it will execute a codeunit that checks whether there are new **Storage Lines**
    that need to be exported. These lines will first be moved to the **RF Pick Lines**
    buffer table and then moved to the RF database using ADO and T-SQL. **New Finished
    Picks** and **Exceptions** from the RF database will be moved to Microsoft Dynamics
    NAV using the same technology and can then be processed.
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run the interface, we have created three codeunits and a table. The SQL Statement
    table is used to log each interface session.
  prefs: []
  type: TYPE_NORMAL
- en: '![The solution](img/0365EN_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **RF NAS Timer (123.456.730)** codeunit is started from the `NASHandler`
    function in codeunit `ApplicationManagement`. It uses an indefinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![The solution](img/0365EN_09_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the C/AL code that is required to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `SLEEP` function is used to make sure the interface only runs each minute.
    By breaking the `SLEEP` function into smaller intervals it is possible to stop
    the Windows Service that executes this C/AL code in between the `SLEEP` command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GETLASTERRORTEXT` is a C/AL function that returns the last error message that
    was generated by the system. It can be used in combination with `IF CODEUNIT.RUN`
    syntax to catch runtime errors.'
  prefs: []
  type: TYPE_NORMAL
- en: The RF Helper (123.456.732) codeunit is a wrapper codeunit that is used for
    error catching and maintaining readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'During each run of the interface we create a new SQL Statement ID, which we
    can filter on to trace any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then the three interface functions are triggered to synchronize the three required
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: COMMIT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After each command we execute the `COMMIT` statement. This will make sure that
    everything in the database is stored up to that point. This is necessary since
    the ADO statements we create are outside our transaction. If our interface run
    rolls back, it might synchronize data that is already synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **RF Interface (123.456.731)**. Here, the actual ADO synchronization is
    done in this codeunit. This codeunit is `SingleInstance`. This will keep the ADO
    connection alive during the NAS session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the interface we use three DotNet variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![COMMIT](img/0365EN_09_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the three DotNet variables in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLConnection`: This is used for the connection with the database and to execute
    the T-SQL statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLCommand`: The result sets of a `SELECT` statement can be read using this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLReader`: The reader is used to read the data and convert data types between
    ADO and C/Side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The RF application needs data from the Storage Line table. We first create a
    mapping to the RF application as we did with the Excel interface earlier in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mapping is saved in a buffer table for traceability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The actual data is moved to the RF database using an `INSERT` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid exporting the same data twice we need to keep track of what we exported.
    The simplest way to do this is to create a new field called Exported. Making this
    field a DateTime also enables the traceability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When reading data from the RF database, we also send a T-SQL SELECT query for
    the data. We use the `SQLReader.Read` to browse through the records that are in
    the result set.
  prefs: []
  type: TYPE_NORMAL
- en: For each record in the result set, we create a record in our buffer table, which
    we then can use to update the information in the Storage Lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading data we do not want to import the same data twice. To avoid this,
    we need to store a unique identifier in a table that enables us to remember where
    we left in the last run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In our example, this unique identifier is `Reference Entry No`.
  prefs: []
  type: TYPE_NORMAL
- en: Log, log, and log more
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although much of the logging is done using the buffer tables, we also want to
    store the general process of the interface each time it runs. This is done using
    the SQL Statement table. Both the SQL Statements as well as the other events are
    stored there.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `COMMIT` functionality, we can exactly see where it stopped by
    looking at the last record in this table. We can solve the problem that caused
    the interface to stop and restart the interface without losing data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never use the `COMMIT` statement unless there is a very good reason for it.
    C/SIDE will normally handle the transactions for you, enabling a full role back
    when things go wrong. Creating a `COMMIT` statement in a normal C/SIDE transaction
    will prevent C/SIDE from rolling back.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's test the interface we have just designed and developed. In order to do
    this, we need to have records in the Storage Line table and the RF database needs
    to exist somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The RF database
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test the objects we have created for this solution, the RF database should
    exist on your system. This database can be created using a T-SQL script and should
    be executed on a Microsoft SQL Server machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script RF `database.sql` is part of the object files downloaded for this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Open the script in SQL Server Management Studio and click on **Execute**.
  prefs: []
  type: TYPE_NORMAL
- en: '![The RF database](img/0365EN_09_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The test
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though the C/AL code can run in the Windows client, we will run the test
    in the classic client. The reason for this is that the interface will run in the
    NAS, which will execute the C/AL code the same way as the classic client. Another
    reason to use the classic client is that this is the interface for the DBA to
    perform all their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To start a test run, open page **RF Interface Setup** (123.456.780) from the
    Object Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the Database and Server are correct. The server should be the
    SQL Server instance where the SQL Script was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ADO connection uses the Windows Account NT `AUTHORITY\NETWORK SERVICE` with
    Trusted connection. This user should have enough rights to insert and read data
    from the RF database.
  prefs: []
  type: TYPE_NORMAL
- en: '![The test](img/0365EN_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To start a test run, click on the **Test** button.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If everything went well, the results should show both in the log and in the
    buffer tables and the RF database. Let's check them all.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SQL Statement log can be opened by either pushing the **Log** button on
    the **RF Interface Setup** form or opening the **SQL Statements** (123.456.781)
    form from the Object Designer.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL Statements](img/0365EN_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SQL statements
  prefs: []
  type: TYPE_NORMAL
- en: The information on the form shows us exactly what the interface did during this
    run.
  prefs: []
  type: TYPE_NORMAL
- en: The buffer tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we open the buffer tables from the Object Designer, we can see that the
    interface moved the data from the Storage Line table into the RF Pick Lines table.
  prefs: []
  type: TYPE_NORMAL
- en: '![The buffer tables](img/0365EN_09_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **RF Finished Pick** and **RF Exceptions** are also populated with the records
    from the RF database.
  prefs: []
  type: TYPE_NORMAL
- en: The RF database
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last thing to check is the data in the RF database. The data in both databases
    should now be exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![The RF database](img/0365EN_09_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This can be checked from the SQL Server Management Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing into the future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfacing will become more and more important in the future as technology
    evolves. Newer technologies and faster Internet connections will allow us to integrate
    our applications better but will also make it more accessible for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-enabled Microsoft Dynamics NAV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the release of version 2013 R2, Microsoft Dynamics NAV is now cloud-enabled.
    This means that the product is officially supported to run on the Microsoft Azure
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how Microsoft Dynamics NAV can interface with
    other applications.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the basics of interfacing, import versus export, and data pulling
    versus data pushing. An interface can be executed manually or by a timer or event.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Dynamics NAV supports a wide range of interfacing technologies, such
    as files, automation control, .NET, ODBC, ADO, and web services.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to integrate using SQL Server technologies. The Application
    Server (NAS) is often used for interfacing with other systems, for example, using
    Microsoft **Message Queuing** or **Active Data Objects** (**ADO**).
  prefs: []
  type: TYPE_NORMAL
- en: The wide range of interfaces that come with the product have been discussed
    including all interfaces with Microsoft Office, Exchange, and SharePoint.
  prefs: []
  type: TYPE_NORMAL
- en: We designed and developed two business-to-business interfaces; one to import
    data manually from Microsoft Excel and the other to automatically import and export
    data to another database using ADO and a timer.
  prefs: []
  type: TYPE_NORMAL
- en: When designing an interface, reliability and traceability are the key elements.
    In the next chapter, we will talk about application design methodologies and principles.
  prefs: []
  type: TYPE_NORMAL
