<html><head></head><body>
<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer092">
</div>
</div>
<div class="Content" id="_idContainer093">
<h1 id="_idParaDest-31"><a id="_idTextAnchor032"/>1. Hello C#</h1>
</div>
<div class="Content" id="_idContainer100">
<p class="callout-heading">Overview</p>
<p class="callout">This chapter introduces you to the basics of C#. You will start by learning about the basics of the .NET Command-Line Interface (CLI) and how to use Visual Studio Code (VS Code) as a basic Integrated Development Environment (IDE). You will then learn about the various C# data types and how to declare variables for these types, before moving on to a section about arithmetic and logical operators. By the end of the chapter, you will know how to handle exceptions and errors and be able to write simple programs in C#.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Introduction</h1>
<p>C# is a programming language created in the early 2000s by a team at Microsoft led by Anders Hejlsberg, who is also among the creators of some other popular languages, such as Delphi and Turbo Pascal, both widely used in the 1990s. Over the last 20 years, C# has grown and evolved, and today it is one of the most widely used programming languages globally, according to Stack Overflow's 2020 insights.</p>
<p>It has its reasons for holding such an honorable place in the tech community. C# allows you to write applications for a wide segment of markets and devices. From the banking industry, with its high-security standards, to e-commerce companies, which hold enormous volumes of transactions, it is a language trusted by companies that need both performance and reliability. Besides that, C# also makes it possible to write web, desktop, mobile, and even IoT applications, allowing you to develop for almost every kind of device.</p>
<p>C# was initially limited to work only on Windows; however, there have been concerted efforts by the C# team over the past few years to make it cross-platform compatible. Today, it can be used with all major OS distributions, namely, Windows, Linux, and macOS. The goal is simple: to develop, build, and run C# anywhere, letting each developer and team choose their most productive or favorite environment.</p>
<p>Another remarkable characteristic of C# is that it is a strongly typed programming language. You will dive into this more deeply in the upcoming sections, and you will see that strong typing enables better data security while programming.</p>
<p>Besides that, C# has become open source over the last few years, with Microsoft as its principal maintainer. This is highly advantageous, as it allows the language to receive continuous improvements from around the globe, with a solid backing company that both promotes and invests in it. C# is also a multi-paradigm language, meaning that you can use it to write software in many programming styles, in a beautiful, concise, and proper manner.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Running and Developing C# with the .NET CLI</h1>
<p>One term you'll hear a lot in the C# world is .NET. It is the foundation of C#, a framework that the language is built on top of. It has both a Software Development Kit (SDK) that allows the language to be developed and a runtime that allows the language to run.</p>
<p>That said, to start developing with C#, you only need to install the .NET SDK. This installation will provide both a compiler and the runtime on the development environment. In this section, you will cover the basic steps of preparing your environment for developing and running C# locally.</p>
<p class="callout-heading">Note</p>
<p class="callout">Please refer to the <em class="italic">Preface</em> of this book for step-by-step instructions on how to download the .NET 6.0 SDK and install it on your machine.</p>
<p>Once the installation of the .NET 6.0 SDK is completed, you will have something called the .NET CLI. This Command-Line Interface (CLI) allows you to create new projects, compile them, and run them with very simple commands that you can run directly from your terminal.</p>
<p>After the installation, run the following command on your favorite terminal:</p>
<p class="source-code">dotnet --list-sdks</p>
<p>You should see an output like this:</p>
<p class="source-code">6.0.100 [/usr/local/share/dotnet/sdk]</p>
<p>This output shows that you have the 6.0.100 version of the SDK installed on your computer. That means you are ready to start developing your applications. If you type <strong class="source-inline">dotnet -–help</strong>, you will notice that several commands will appear for you as options to run within the CLI. In this section, you will cover the most basic ones that you need to create and run applications: <strong class="source-inline">new</strong>, <strong class="source-inline">build</strong>, and <strong class="source-inline">run</strong>.</p>
<p>The <strong class="source-inline">dotnet new</strong> command allows you to create a bootstrap project to start developing. The CLI has several built-in templates, which are nothing more than basic bootstraps for various types of applications: web apps, desktop apps, and so on. You must specify two things in the <strong class="source-inline">dotnet new</strong> command:</p>
<ul>
<li>The template name</li>
<li>The project name</li>
</ul>
<p>The name is passed as an argument, which means you should specify it with a <strong class="source-inline">-n</strong> or <strong class="source-inline">–name</strong> flag. The command is as follows:</p>
<p class="source-code">dotnet new TYPE -n NAME</p>
<p>For instance, to create a new console application named <strong class="source-inline">MyConsoleApp</strong> you can simply type:</p>
<p class="source-code">dotnet new console -n MyConsoleApp</p>
<p>This will generate a new folder with a file named <strong class="source-inline">MyConsoleApp.csproj</strong>, which is the C# project file that contains all the metadata needed by the compiler to build your project, and some files needed for the application to be built and run.</p>
<p>Next, the <strong class="source-inline">dotnet build</strong> command allows you to build an application and make it ready to run. This command should be placed only in two locations:</p>
<ul>
<li>A project folder, containing a <strong class="source-inline">.csproj</strong> file.</li>
<li>A folder containing a <strong class="source-inline">.sln</strong> file.</li>
</ul>
<p>Solution (<strong class="source-inline">.sln</strong>) files are files that contain the metadata of one or more project files. They are used to organize multiple project files into single builds.</p>
<p>Finally, the third important command is dotnet <strong class="source-inline">run</strong>. This command allows you to properly run an application. It can be called without any arguments from the folder that contains the <strong class="source-inline">.csproj</strong> file of your .NET app, or without passing the project folder with the <strong class="source-inline">-–project</strong> flag on the CLI. The <strong class="source-inline">run</strong> command also automatically builds the application prior to the run.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Creating Programs with the CLI and VS Code</h2>
<p>While working through this book, you will use Visual Studio Code (VS Code) as your code editor. It works on all platforms, and you can download the version for your OS at https://code.visualstudio.com/. Although VS Code is not a complete Integrated Development Environment (IDE), it has a lot of extensions that make it a powerful tool to develop and do proper C# coding, regardless of the OS being used.</p>
<p>To properly develop C# code, you will primarily need to install the Microsoft C# extension. It equips VS Code with the ability to do code completion and identify errors and is available at <a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Before proceeding, it is recommended that you install VS Code and the Microsoft C# extension. You can find a step-by-step breakdown of the installation process in the <em class="italic">Preface</em> of this book.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Basic Anatomy of a C# Program</h2>
<p>In order to run, every C# program needs something called an entry point. In C#, the standard entry point for a program is the <strong class="source-inline">Main</strong> method. Regardless of your program type, whether it is a web application, desktop application, or even a simple console one, the <strong class="source-inline">Main</strong> method will be the <strong class="bold">entry point</strong> for your C# program. This means that each time an application runs, the runtime searches for this method within your code and executes the code blocks inside it.</p>
<p>This structure is created for you by the CLI, with the <strong class="source-inline">new</strong> command. A <strong class="source-inline">Program.cs</strong> file contains a class named <strong class="source-inline">Program</strong>, with a method named <strong class="source-inline">Main</strong>, which, in turn, contains a single instruction that will be executed after the program is built and running. You will learn more about methods and classes later, but for now, just know that a class is something that usually contains a set of data and that can perform actions on this data through these <strong class="bold">methods</strong>.</p>
<p>Another important thing to note regarding basic C# concepts is <strong class="bold">comments</strong>. Comments allow you to place free text inside C# code files, without affecting the compiler. A comment section should always start with <strong class="source-inline">//</strong>.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>Exercise 1.01: Creating a Console App that Says "Hello World"</h2>
<p>In this exercise, you will see the CLI commands you learned about in the previous section, as you build your first ever C# program. It will be a simple console app that will print <strong class="source-inline">Hello World</strong> to the console.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li>Open the VS Code integrated terminal and type the following:<p class="source-code">dotnet new console -n Exercise1_01 </p></li>
</ol>
<p>This command will create a new console application in the <strong class="source-inline">Exercise1_01</strong> folder.</p>
<ol>
<li value="2">On the command line, type the following:<p class="source-code">dotnet run --project Exercise1_01</p></li>
</ol>
<p>You should see the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 1.1: &quot;Hello World&quot; output on the console " height="618" src="image/B16835_01_01.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.1: "Hello World" output on the console</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/HErU6">https://packt.link/HErU6</a>.</p>
<p>In this exercise, you created the most basic program possible with C#, a console application that prints some text to the prompt. You also learned how to use .NET CLI, which is the mechanism built within the .NET SDK to create and manage .NET projects.</p>
<p>Now proceed to the next section to grasp how top-level statements are written.</p>
<h3 id="_idParaDest-37"><a id="_idTextAnchor038"/>Top-Level Statements</h3>
<p>You must have noticed in <em class="italic">Exercise 1.01</em> that, by default, when you create a console application, you have a <strong class="source-inline">Program.cs</strong> file that contains the following:</p>
<ul>
<li>A class named <strong class="source-inline">Program</strong>.</li>
<li>The static void <strong class="source-inline">Main</strong> keywords.</li>
</ul>
<p>You will learn about classes and methods in detail later, but for now, for the sake of simplicity, you do not need these resources to create and execute programs with C#. The latest version (.NET 6) introduced a feature that makes writing simple programs much easier and less verbose. For instance, consider the following:</p>
<p class="source-code">using System;</p>
<p class="source-code">namespace Exercise1_01</p>
<p class="source-code">{</p>
<p class="source-code">    class Program</p>
<p class="source-code">    {</p>
<p class="source-code">        static void Main(string[] args)</p>
<p class="source-code">        {</p>
<p class="source-code">            Console.WriteLine("Hello World!");</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>You can simply replace this snippet with two lines of code, as follows:</p>
<p class="source-code">using System;</p>
<p class="source-code">Console.WriteLine("Hello World!");</p>
<p>By using such top-level statements, you can write concise programs. You can simply put the statements to be executed at the top of the program. This is also useful for speeding up the learning curve with C#, as you need not worry about advanced concepts upfront. The only thing to look out for here is that the project can have only one file with top-level statements.</p>
<p>That is why in this chapter, you will find that all exercises will use this format, to make things as clear as possible.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>Declaring Variables</h2>
<p>You will now take your first steps in creating your own programs. This section will delve into the concept of variables—what they are and how to use them.</p>
<p>A variable is a name given to a computer memory location that holds some data that may vary. For a variable to exist, it first must be <strong class="bold">declared</strong> with a type and a name. It can also have a value assigned to it. The declaration of a variable can be achieved in a few different ways.</p>
<p>There are some basic considerations regarding naming conventions for variables in C#:</p>
<ul>
<li>The names must be unique, starting with a letter, and should contain only letters, digits, and the underscore character (<strong class="source-inline">_</strong>). The names can also begin with an underscore character.</li>
<li>The names are case-sensitive; thus, <strong class="source-inline">myVariable</strong> and <strong class="source-inline">MyVariable</strong> are different names.</li>
<li>Reserved keywords, such as <strong class="source-inline">int</strong> or <strong class="source-inline">string</strong>, cannot be used as names (this is a compiler restriction) unless you put an <strong class="source-inline">@</strong> symbol in front of the name, such as <strong class="source-inline">@int</strong> or <strong class="source-inline">@string</strong>.</li>
</ul>
<p>Variables can be declared in two ways: explicitly and implicitly. Both styles of the declaration have their pros and cons, which you will explore in the next section.</p>
<h3 id="_idParaDest-39"><a id="_idTextAnchor040"/>Declaring Variables Explicitly</h3>
<p>A variable can be declared explicitly by writing both its type and value. Suppose you want to create two variables, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, both containing integers. Doing so explicitly would look like this:</p>
<p class="source-code">int a = 0;</p>
<p class="source-code">int b = 0;</p>
<p>Before a variable is used, it must have a value assigned. Otherwise, the C# compiler will give an error while building your program. The following example illustrates that:</p>
<p class="source-code">int a;</p>
<p class="source-code">int b = a; // The compiler will prompt an error on this line: Use of unassigned local variable</p>
<p>It is also possible to declare multiple variables in the same line, like in the following snippet, where you are declaring three variables; two hold the value <strong class="source-inline">100</strong> and one holds the value <strong class="source-inline">10</strong>:</p>
<p class="source-code">int a, b = 100, c = 10;</p>
<h3 id="_idParaDest-40"><a id="_idTextAnchor041"/>Declaring Variables Implicitly</h3>
<p>Remember that C# is a strongly typed programming language; this means that a variable will always have a type associated with it. It does not matter whether the type is declared implicitly or explicitly. With the <strong class="source-inline">var</strong> keyword, the C# compiler will infer the variable type based on the value that has been assigned to it.</p>
<p>Consider that you want to create a variable that holds some text using this method. This can be done with the following statement:</p>
<p class="source-code">var name = "Elon Musk";</p>
<p>For storing text in a variable, you should start and end the text with double quotes (<strong class="source-inline">"</strong>). In the preceding example, by looking at the value that was assigned to <strong class="source-inline">name</strong>, C# knows that the type this variable holds is a string, even though the type is not mentioned in the statement.</p>
<h3 id="_idParaDest-41"><a id="_idTextAnchor042"/>Explicit versus Implicit Declaration</h3>
<p>Explicit declarations enhance readability with the type declared, and this is one of the main advantages of this technique. On the other hand, they tend to let the code become more verbose, especially when working with some data types (that you will see further ahead), such as <strong class="source-inline">Collections</strong>. </p>
<p>Essentially, deciding on the style of declaration depends on the personal preferences of the programmer, and may be influenced by the company's guidelines in some cases. In this journey of learning, it is recommended that you pick one that makes your learning path smoother, as there are few substantial differences from a purely technical standpoint.</p>
<p>In the next exercise, you will do this yourself by assigning variables to inputs that come from a user's interaction with a console application, where the user will be asked to input their name. To complete this exercise, you will make use of the following built-in methods that C# provides, which you will be using frequently in your C# journey:</p>
<ul>
<li><strong class="source-inline">Console.ReadLine()</strong>: This allows you to retrieve a value that the user prompted on the console.</li>
<li><strong class="source-inline">Console.WriteLine()</strong>: This writes the value passed as an argument as an output to the console.</li>
</ul>
<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Exercise 1.02: Assigning Variables to User Inputs</h2>
<p>In this exercise, you will create an interactive console application. The app should ask you for your name, and once provided, it should display a greeting with your name in it.</p>
<p>To complete this exercise, perform the following steps:</p>
<ol>
<li value="1">Open Command Prompt and type the following:<p class="source-code">dotnet new console -n Exercise1_02</p></li>
</ol>
<p>This command creates a new console application in the <strong class="source-inline">Exercise1_02</strong> folder.</p>
<ol>
<li value="2">Open the <strong class="source-inline">Program.cs</strong> file. Paste the following inside the <strong class="source-inline">Main</strong> method:<p class="source-code">Console.WriteLine("Hi! I'm your first Program. What is your name?");</p><p class="source-code">var name = Console.ReadLine();</p><p class="source-code">Console.WriteLine($"Hi {name}, it is very nice to meet you. We have a really fun journey ahead.");</p></li>
<li>Save the file. On the command line, type the following:<p class="source-code">dotnet run --project Exercise1_02</p></li>
</ol>
<p>This outputs the following:</p>
<p class="source-code">Hi! I'm your first Program. What is your name?</p>
<ol>
<li value="4">Now, type your name into the console and hit <strong class="source-inline">Enter</strong> on your keyboard. For example, if you type in <strong class="source-inline">Mateus</strong>, the following will be the output:<p class="source-code">Hi! I'm your first Program. What is your name?</p><p class="source-code">Mateus</p><p class="source-code">Hi Mateus, it is very nice to meet you. We have a really fun journey ahead.</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/1fbVH">https://packt.link/1fbVH</a>.</p></li>
</ol>
<p>You are more familiar with what variables are, how to declare them, and how to assign values to them. Now it is time to start talking about what data these variables can store and, more specifically, what types of data there are.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor044"/>Data Types</h1>
<p>In this section, you will talk about the main data types within C# and their functionalities.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Strings</h2>
<p>C# uses the <strong class="source-inline">string</strong> keyword to identify data that stores text as a sequence of characters. You can declare a string in several ways, as shown in the following snippet. However, when assigning some value to a string variable, you must place the content between a pair of double quotes, as you can see in the last two examples:</p>
<p class="source-code">// Declare without initializing.</p>
<p class="source-code">string message1;</p>
<p class="source-code">// Initialize to null.</p>
<p class="source-code">string message2 = null;</p>
<p class="source-code">// Initialize as an empty string</p>
<p class="source-code">string message3 = System.String.Empty;</p>
<p class="source-code">// Will have the same content as the above one</p>
<p class="source-code">string message4 = "";</p>
<p class="source-code">// With implicit declaration</p>
<p class="source-code">var message4 = "A random message"     ;</p>
<p>One simple but effective technique (that you used in the preceding <em class="italic">Exercise 1.02</em>) is one called string interpolation. With this technique, it is very simple to mix plain text values with variable values, so that the text is combined among these two. You can combine two or more strings by following these steps:</p>
<ol>
<li value="1">Before the initial quotes, insert a <strong class="source-inline">$</strong> symbol.</li>
<li>Now, inside the strings, place curly brackets and the name of the variable that you want to put into the string. In this case, this is done by putting <strong class="source-inline">{name}</strong> inside the initial string:<p class="source-code">$"Hi {name}, it is very nice to meet you. We have a really fun journey ahead.");</p></li>
</ol>
<p>Another important fact to remember about strings is that they are immutable. This means that a string object cannot be changed after its creation. This happens because strings in C# are an array of characters. Arrays are data structures that gather objects of the same type and have a fixed length. You will cover arrays in detail in an upcoming section.</p>
<p>In the next exercise, you will explore string immutability.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Exercise 1.03: Checking String Immutability</h2>
<p>In this exercise, you will use two strings to demonstrate that string references are always immutable. Perform the following steps to do so:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<p class="source-code">dotnet new console -n Exercise1_03</p></li>
<li>Open the <strong class="source-inline">Program.cs</strong> file and create a method with the <strong class="source-inline">void</strong> return type, which replaces part of a string like so:<p class="source-code">static void FormatString(string stringToFormat)</p><p class="source-code">{</p><p class="source-code">stringToFormat.Replace("World", "Mars");</p><p class="source-code">}</p></li>
</ol>
<p>In the preceding snippet, the <strong class="source-inline">Replace</strong> function is used to replace the first string (<strong class="source-inline">World</strong>, in this case) with the second one (<strong class="source-inline">Mars</strong>).</p>
<ol>
<li value="3">Now, create a method that does the same thing but returns the result instead:<p class="source-code">static string FormatReturningString(string stringToFormat)</p><p class="source-code">{</p><p class="source-code">return stringToFormat.Replace("Earth", "Mars");</p><p class="source-code">}</p></li>
<li>Now insert the following after the previous methods. Here, you create two string variables and observe their behavior after trying to modify them with the methods created previously:<p class="source-code">var greetings = "Hello World!";</p><p class="source-code">FormatString(greetings);</p><p class="source-code">Console.WriteLine(greetings);</p><p class="source-code">var anotherGreetings = "Good morning Earth!";</p><p class="source-code">Console.WriteLine(FormatReturningString(anotherGreetings));</p></li>
<li>Finally, call <strong class="source-inline">dotnet run --project Exercise1_03</strong> from the command line. You should see the following output on the console:<p class="source-code">dotnet run</p><p class="source-code">Hello World!</p><p class="source-code">Good morning Mars!</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/ZoNiw">https://packt.link/ZoNiw</a>.</p></li>
</ol>
<p>With this exercise, you saw the concept of string immutability in action. When you passed a string that was a reference type (<strong class="source-inline">Hello World!</strong>) as a method argument, it was not modified. That is what happens when you use the <strong class="source-inline">FormatString</strong> method, which returns <strong class="source-inline">void</strong>. Due to string immutability, a new string is created but not allocated to any variable, and the original string stays the same. With the second method, it returns a new string, and this string is then printed to the console.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>Comparing Strings</h2>
<p>Even though strings are reference values, when you use the <strong class="source-inline">.Equals()</strong> method, the equality operator (<strong class="source-inline">==</strong>), and other operators (such as <strong class="source-inline">!=</strong>), you are actually comparing the values of the strings, as can be seen in the following example:</p>
<p class="source-code">string first = "Hello.";</p>
<p class="source-code">string second = first;</p>
<p class="source-code">first = null;</p>
<p>Now you can compare these values and call <strong class="source-inline">Console.WriteLine()</strong> to output the result, like so:</p>
<p class="source-code">Console.WriteLine(first == second);</p>
<p class="source-code">Console.WriteLine(string.Equals(first, second));</p>
<p>Running the preceding code results in the following output:</p>
<p class="source-code">False</p>
<p class="source-code">False</p>
<p>You get this output because, even though strings are reference types, both the <strong class="source-inline">==</strong> and <strong class="source-inline">.Equals</strong> comparisons run against string values. Also, remember that strings are immutable. This means that when you assign <strong class="source-inline">second</strong> to <strong class="source-inline">first</strong> and set <strong class="source-inline">first</strong> as <strong class="source-inline">null</strong>, a new value is created for <strong class="source-inline">first</strong> and, therefore, the reference for <strong class="source-inline">second</strong> does not change.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>Numeric Types</h2>
<p>C# has its numeric types subdivided into two main categories—integral and floating-point type numbers. The integral number types are as follows:</p>
<ul>
<li><strong class="source-inline">sbyte</strong>: Holds values from -128 to 127</li>
<li><strong class="source-inline">short</strong>: Holds values from -32,768 to 32,767</li>
<li><strong class="source-inline">int</strong>: Holds values from -2,147,483,648 to 2,147,483,647</li>
<li><strong class="source-inline">long</strong>: Holds values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</li>
</ul>
<p>Deciding which type of integral type to use depends on the size of the values you want to store.</p>
<p>All these types are called signed values. This means that they can store both negative and positive numbers. There is also another range of types called unsigned types. Unsigned types are <strong class="source-inline">byte</strong>, <strong class="source-inline">ushort</strong>, <strong class="source-inline">uint</strong>, and <strong class="source-inline">ulong</strong>. The main difference between them is that signed types can store negative numbers and unsigned types can store only numbers greater than or equal to zero. You will use signed types most of the time, so do not worry about remembering this all at once.</p>
<p>The other category, namely, floating-point types, refers to the types used to store numbers with one or more decimal points. There are three floating-point types in C#:</p>
<ul>
<li><strong class="source-inline">float</strong>: This occupies four bytes and can store numbers from ± 1.5 x 10−45 to ± 3.4 x 1038 with a precision range of six to nine digits. To declare a float number using <strong class="source-inline">var</strong>, you can simply append <strong class="source-inline">f</strong> to the end of the number, like so:<p class="source-code">var myFloat = 10f;</p></li>
<li><strong class="source-inline">double</strong>: This occupies eight bytes and can store numbers from ± 5.0 × 10−324 to ± 1.7 × 1030 with a precision range of 15 to 17 digits. To declare a double number using var, you can append d to the end of the number, like so:<p class="source-code">var myDouble = 10d;</p></li>
<li><strong class="source-inline">decimal</strong>: This occupies 16 bytes and can store numbers from ± 1.0 x 10-28 to ± 7.9228 x 1028 with a precision range from 28 to 29 digits. To declare a decimal number using var, you must simply append m to the end of the number, like so:<p class="source-code">var myDecimal = 10m;</p></li>
</ul>
<p>Choosing the floating-point type depends mainly on the degree of precision required. For instance, <strong class="source-inline">decimal</strong> is mostly used for financial applications that need a very high degree of precision and cannot rely on rounding for accurate calculations. With GPS coordinates, <strong class="source-inline">double</strong> variables might be appropriate if you want to deal with sub-meter precisions that usually have 10 digits.</p>
<p>Another relevant point to consider when choosing numeric types is performance. The larger the memory space allocated to a variable, the less performant the operations with these variables are. Therefore, if high precision is not a requirement, <strong class="source-inline">float</strong> variables will be better performers than <strong class="source-inline">doubles</strong>, which, in turn, will be better performers than decimals.</p>
<p>Here you grasped what variables are and their main types. Now you will perform some basic calculations with them, such as addition, subtraction, and multiplication. This can be done using the arithmetic operators available in C#, such as <strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">/</strong>, and <strong class="source-inline">*</strong>. So, move on to the next exercise where you will create a basic calculator using these operators.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Exercise 1.04: Using the Basic Arithmetic Operators</h2>
<p>In this exercise, you will create a simple calculator that receives two inputs and shows the results between them, based on which arithmetic operation is selected.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<p class="source-code">dotnet new console -n Exercise1_04</p></li>
<li>Navigate to the project folder, open the <strong class="source-inline">Program.cs</strong> file, and inside the <strong class="source-inline">Main</strong> method, declare two variables that read the user input, like so:<p class="source-code">Console.WriteLine("Type a value for a: ");</p><p class="source-code">var a = int.Parse(Console.ReadLine());</p><p class="source-code">Console.WriteLine("Now type a value for b: ");</p><p class="source-code">var b = int.Parse(Console.ReadLine());</p></li>
</ol>
<p>The preceding snippet uses the <strong class="source-inline">.ReadLine</strong> method to read the input. This method, however, gives a <strong class="source-inline">string</strong>, and you need to evaluate a number. Therefore, the <strong class="source-inline">Parse</strong> method has been used here. All the numeric types have a method called Parse, which receives a string and converts it into a number.</p>
<ol>
<li value="3">Next, you need to write the output of these basic operators to the console. Add the following code to the <strong class="source-inline">Main</strong> method:<p class="source-code">Console.WriteLine($"The value for a is { a } and for b is { b }");</p><p class="source-code">Console.WriteLine($"Sum: { a + b}");</p><p class="source-code">Console.WriteLine($"Multiplication: { a * b}");</p><p class="source-code">Console.WriteLine($"Subtraction: { a - b}");</p><p class="source-code">Console.WriteLine($"Division: { a / b}"); </p></li>
<li>Run the program using the <strong class="source-inline">dotnet run</strong> command, and you should see the following output, if you input <strong class="source-inline">10</strong> and <strong class="source-inline">20</strong>, for instance:<p class="source-code">Type a value for a:</p><p class="source-code">10</p><p class="source-code">Now type a value for b:</p><p class="source-code">20</p><p class="source-code">The value for a is 10 and b is 20</p><p class="source-code">Sum: 30</p><p class="source-code">Multiplication: 200</p><p class="source-code">Subtraction: -10</p><p class="source-code">Division: 0</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/ldWVv">https://packt.link/ldWVv</a>.</p></li>
</ol>
<p>Thus, you have built a simple calculator app in C# using the arithmetic operators. You also learned about the concept of parsing, which is used to convert strings to numbers. In the next section, you will briefly cover the topic of classes, one of the core concepts of programming in C#.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Classes</h1>
<p>Classes are an integral part of coding in C# and will be covered comprehensively in <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>. This section touches upon the basics of classes so that you can begin using them in your programs.</p>
<p>The reserved <strong class="source-inline">class</strong> keyword within C# is used when you want to define the type of an object. An object, which can also be called an instance, is nothing more than a block of memory that has been allocated to store information. Given this definition, what a class does is act as a blueprint for an object by having some properties to describe this object and specifying the actions that this object can perform through methods.</p>
<p>For example, consider that you have a class named <strong class="source-inline">Person</strong>, with two properties, <strong class="source-inline">Name</strong> and <strong class="source-inline">Age</strong>, and a method that checks whether <strong class="source-inline">Person</strong> is a child. Methods are where logic can be placed to perform some action. They can return a value of a certain type or have the special <strong class="source-inline">void</strong> keyword, which indicates that they do not return anything but just execute some action. You can also have methods calling other methods:</p>
<p class="source-code">public class Person</p>
<p class="source-code">{</p>
<p class="source-code">	public Person() { }</p>
<p class="source-code">	public Person(string name, int age)</p>
<p class="source-code">{</p>
<p class="source-code">	Name = name;</p>
<p class="source-code">	Age = age;</p>
<p class="source-code">}</p>
<p class="source-code">	public string Name { get; set; }</p>
<p class="source-code">	public int Age { get; set; }</p>
<p class="source-code">	public void GetInfo()</p>
<p class="source-code">{</p>
<p class="source-code">	Console.WriteLine($"Name: {Name} – IsChild? {IsChild()}");</p>
<p class="source-code">}</p>
<p class="source-code">	public bool IsChild()</p>
<p class="source-code">{</p>
<p class="source-code">	return Age &lt; 12;</p>
<p class="source-code">}</p>
<p class="source-code">}</p>
<p>One question remains, though. Since classes act as blueprints (or definitions if you prefer), how do you actually allocate memory to store the information defined by a class? This is done through a process called instantiation. When you instantiate an object, you allocate some space in memory for it in a reserved area called the heap. When you assign a variable to an object, you are setting the variable to have the address of this memory space, so that each time you manipulate this variable, it points to and manipulates the data allocated at this memory space. The following is a simple example of instantiation:</p>
<p class="source-code">var person = new Person();</p>
<p>Note that <strong class="source-inline">Person</strong> has properties that have two magic keywords—<strong class="source-inline">get</strong> and <strong class="source-inline">set</strong>. Getters define that a property value can be retrieved, and setters define that a property value can be set.</p>
<p>Another important concept here is the concept of a constructor. A constructor is a method with no return type, usually present at the top level of the class for better readability. It specifies what is needed for an object to be created. By default, a class will always have a parameter-less constructor. If another constructor with parameters is defined, the class will be constrained to only this one. In that case, if you still want to have a parameter-less constructor, you must specify one. This is quite useful, as classes can have multiple constructors.</p>
<p>That said, you can assign values to an object property that has a setter in the following ways:</p>
<ul>
<li>At the time of creation, via its constructor:<p class="source-code">var person = new Person("John", 10);</p></li>
<li>At the time of creation, with direct variable assignment:<p class="source-code">var person = new Person() { Name = "John", Age = 10 };</p></li>
<li>After the object is created, as follows:<p class="source-code">var person = new Person();</p><p class="source-code">person.Name = "John";</p><p class="source-code">person.Age = 10;</p></li>
</ul>
<p>There is a lot more to classes that you will see further on. For now, the main ideas are as follows:</p>
<ul>
<li>Classes are blueprints of objects and can have both properties and methods that describe these objects.</li>
<li>Objects need to be instantiated so that you can perform operations with them.</li>
<li>Classes have one parameter-less constructor by default, but can have many customized ones as required.</li>
<li>Object variables are references that contain the memory address of a special memory space allocated to the object inside a dedicated memory section named the heap.</li>
</ul>
<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Dates</h1>
<p>A date can be represented in C# using the <strong class="source-inline">DateTime</strong> value type. It is a struct with two static properties called <strong class="source-inline">MinValue</strong>, which is January 1, 0001 00:00:00, and <strong class="source-inline">MaxValue</strong>, which is December 31, 9999 11:59:59 P.M. As the names suggest, both these values represent the minimum and maximum dates according to the Gregorian calendar date format. The default value for <strong class="source-inline">DateTime</strong> objects is <strong class="source-inline">MinValue</strong>.</p>
<p>It is possible to construct a <strong class="source-inline">DateTime</strong> variable in various ways. Some of the most common ways are as follows:</p>
<ul>
<li>Assigning the current time as follows:<p class="source-code">var now = DateTime.Now;</p></li>
</ul>
<p>This sets the variable to the current date and time on the calling computer, expressed as the local time.</p>
<p class="source-code">var now = DateTime.UtcNow;</p>
<p>This sets the variable to the current date and time on this computer, expressed as the Coordinated Universal Time (UTC).</p>
<ul>
<li>You can also use constructors for passing days, months, years, hours, minutes, and even seconds and milliseconds.</li>
<li>There is also a special property available for <strong class="source-inline">DateTime</strong> objects called <strong class="source-inline">Ticks</strong>. It is a measure of the number of 100 nanoseconds elapsed since <strong class="source-inline">DateTime.MinValue</strong>. Every time you have an object of this type, you can call the <strong class="source-inline">Ticks</strong> property to get such a value.</li>
<li>Another special type for dates is the <strong class="source-inline">TimeSpan</strong> struct. A <strong class="source-inline">TimeSpan</strong> object represents a time interval as days, hours, minutes, and seconds. It is useful when fetching intervals between dates. You will now see what this looks like in practice.</li>
</ul>
<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Exercise 1.05: Using Date Arithmetic</h2>
<p>In this exercise, you will use the <strong class="source-inline">TimeSpan</strong> method/struct to calculate the difference between your local time and the UTC time. To complete this exercise, perform the following steps:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<p class="source-code">dotnet new console -n Exercise1_05</p></li>
<li>Open the <strong class="source-inline">Program.cs</strong> file.</li>
<li>Paste the following inside the <strong class="source-inline">Main</strong> method and save the file:<p class="source-code">Console.WriteLine("Are the local and utc dates equal? {0}", DateTime.Now.Date == DateTime.UtcNow.Date);</p><p class="source-code">Console.WriteLine("\nIf the dates are equal, does it mean that there's no TimeSpan interval between them? {0}",</p><p class="source-code">(DateTime.Now.Date - DateTime.UtcNow.Date) == TimeSpan.Zero);</p><p class="source-code">DateTime localTime = DateTime.Now;</p><p class="source-code">DateTime utcTime = DateTime.UtcNow;</p><p class="source-code">TimeSpan interval = (localTime - utcTime);</p><p class="source-code">Console.WriteLine("\nDifference between the {0} Time and {1} Time: {2}:{3} hours",</p><p class="source-code">    localTime.Kind.ToString(),</p><p class="source-code">    utcTime.Kind.ToString(),</p><p class="source-code">    interval.Hours,</p><p class="source-code">    interval.Minutes);</p><p class="source-code">Console.Write("\nIf we jump two days to the future on {0} we'll be on {1}",</p><p class="source-code">    new DateTime(2020, 12, 31).ToShortDateString(),</p><p class="source-code">    new DateTime(2020, 12, 31).AddDays(2).ToShortDateString());</p></li>
</ol>
<p>In the preceding snippet, you first checked whether the current local date and UTC dates were equal. Then you checked for the interval between them, if any, using the <strong class="source-inline">TimeSpan</strong> method. Next, it printed the difference between the local and UTC time and printed the date two days ahead of the current one (<strong class="source-inline">31/12/ 2020</strong>, in this case).</p>
<ol>
<li value="4">Save the file. On the command line, type the following:<p class="source-code">dotnet run --project Exercise1_05</p></li>
</ol>
<p>You should see an output like the following:</p>
<p class="source-code">Are the local and utc dates equal? True</p>
<p class="source-code">If the dates are equal, does it mean there's no TimeSpan interval between them? True</p>
<p class="source-code">Difference between the Local Time and Utc Time: 0:0 hours</p>
<p class="source-code">If we jump two days to the future on 31/12/2020 we'll be on 02/01/2021</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/WIScZ">https://packt.link/WIScZ</a>.</p>
<p>Note that depending on your time zone, you will likely see different output.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Formatting Dates</h2>
<p>It is also possible to format <strong class="source-inline">DateTime</strong> values to localized strings. That means formatting a <strong class="source-inline">DateTime</strong> instance according to a special concept within the C# language called a culture, which is a representation of your local time. For instance, dates are represented differently in different countries. Now take a look at the following examples, where dates are outputted in both the format used in France and the format used in the United States:</p>
<p class="source-code">var frenchDate = new DateTime(2008, 3, 1, 7, 0, 0);</p>
<p class="source-code">Console.WriteLine(frenchDate.ToString(System.Globalization.CultureInfo.</p>
<p class="source-code">  CreateSpecificCulture("fr-FR")));</p>
<p class="source-code">// Displays 01/03/2008 07:00:00</p>
<p class="source-code">var usDate = new DateTime(2008, 3, 1, 7, 0, 0);</p>
<p class="source-code">Console.WriteLine(frenchDate.ToString(System.Globalization.CultureInfo.CreateSpecificCulture("en-US")));</p>
<p class="source-code">// For en-US culture, displays 3/1/2008 7:00:00 AM</p>
<p>It is also possible to explicitly define the format you want the date to be output in, as in the following example, where you pass the <strong class="source-inline">yyyyMMddTHH:mm:ss</strong> value to say that you want the date to be output as year, then month, then day, then hour, then minutes preceded by a colon, and finally, seconds, also preceded by a colon:</p>
<p class="source-code">var date1 = new DateTime(2008, 3, 1, 7, 0, 0);</p>
<p class="source-code">Console.WriteLine(date1.ToString("yyyyMMddTHH:mm:ss"));</p>
<p>The following output gets displayed:</p>
<p class="source-code">     20080301T07:00:00</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/>Logical Operators and Boolean Expressions</h1>
<p>You are already familiar with these. Recall that in the preceding exercise, you did the following comparison:</p>
<p class="source-code">var now = DateTime.Now.Date == DateTime.UtcNow.Date;</p>
<p>This output assigns the value <strong class="source-inline">true</strong> to <strong class="source-inline">now</strong> if the dates are equal. But as you know, they might not necessarily be the same. Therefore, if the dates are different, a <strong class="source-inline">false</strong> value will be assigned. These two values are the result of such Boolean expressions and are called Boolean values. That is why the <strong class="source-inline">now</strong> variable has the type of <strong class="source-inline">bool</strong>.</p>
<p>Boolean expressions are the base for every logical comparison in every program. Based on these comparisons, a computer can execute a certain behavior in a program. Here are some other examples of Boolean expressions and variable assignments:</p>
<ul>
<li>Assigning the result of a comparison that checks whether <strong class="source-inline">a</strong> is greater than <strong class="source-inline">b</strong>:<p class="source-code">var basicComparison = a &gt; b;</p></li>
<li>Assigning the result of a comparison that checks whether <strong class="source-inline">b</strong> is greater than or equal to <strong class="source-inline">a</strong>:<p class="source-code">bool anotherBasicComparison = b &gt;= a; </p></li>
<li>Checking whether two strings are equal and assigning the result of this comparison to a variable:<p class="source-code">var animal1 = "Leopard";</p><p class="source-code">var animal2 = "Lion";</p><p class="source-code">bool areTheseAnimalsSame = animal1 == animal2;</p></li>
</ul>
<p>Clearly, the result of the previous comparison would be <strong class="source-inline">false</strong> and this value will be assigned to the <strong class="source-inline">areTheseAnimalsSame</strong> variable.</p>
<p>Now that you have learned what Booleans are and how they work, it is time to look at some logical operators you can use to compare Boolean variables and expressions:</p>
<ul>
<li>The <strong class="source-inline">&amp;&amp;</strong> (AND) operator: This operator will perform an equality comparison. It will return <strong class="source-inline">true</strong> if both are equal and <strong class="source-inline">false</strong> if they are not. Consider the following example, where you check whether two strings have the length <strong class="source-inline">0</strong>:<p class="source-code">bool areTheseStringsWithZeroLength = "".Length == 0 &amp;&amp; " ".Length == 0; </p><p class="source-code">Console.WriteLine(areTheseStringsWithZeroLength);// will return false</p></li>
<li>The <strong class="source-inline">||</strong> (OR) operator: This operator will check whether either of the values being compared is <strong class="source-inline">true</strong>. For example, here you are checking whether at least one of the strings has zero length:<p class="source-code">bool isOneOfTheseStringsWithZeroLength = "".Length == 0 || " ".Length == 0;</p><p class="source-code">Console.WriteLine(isOneOfTheseStringsWithZeroLength); // will return true</p></li>
<li>The <strong class="source-inline">!</strong> (NOT) operator: This operator takes a Boolean expression or value and negates it; that is, it returns the opposite value. For example, consider the following example, where you negate the result of a comparison that checks whether one of the strings has zero length:<p class="source-code">bool isOneOfTheseStringsWithZeroLength = "".Length == 0 || " ".Length == 0; </p><p class="source-code">bool areYouReallySure = !isOneOfTheseStringsWithZeroLength;</p><p class="source-code">Console.WriteLine(areYouReallySure); // will return false</p></li>
</ul>
<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Using if-else Statements</h2>
<p>Up till now, you have learned about types, variables, and operators. Now it is time to go into the mechanisms that help you to use these concepts in real-world problems—that is, decision-making statements.</p>
<p>In C#, <strong class="source-inline">if-else</strong> statements are some of the most popular choices for implementing branching in code, which means telling the code to follow one path if a condition is satisfied, else follow another path. They are logical statements that evaluate a Boolean expression and continue the program's execution based on this evaluation result.</p>
<p>For example, you can use <strong class="source-inline">if-else</strong> statements to check whether the password entered satisfies certain criteria (such as having at least six characters and one digit). In the next exercise, you will do exactly that, in a simple console application.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Exercise 1.06: Branching with if-else</h2>
<p>In this exercise, you will use <strong class="source-inline">if-else</strong> statements to write a simple credentials check program. The application should ask the user to enter their username; unless this value is at least six characters in length, the user cannot proceed. Once this condition is met, the user should be asked for a password. The password should also have a minimum of six characters containing at least one digit. Only after both these criteria are met should the program display a success message, such as <strong class="source-inline">User successfully registered</strong>.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Inside the VS Code integrated terminal, create a new console project called <strong class="source-inline">Exercise1_06</strong>:<p class="source-code">dotnet new console -n Exercise1_06</p></li>
<li>Inside the <strong class="source-inline">Main</strong> method, add the following code to ask the user for a username, and assign the value to a variable:<p class="source-code">Console.WriteLine("Please type a username. It must have at least 6 characters: ");</p><p class="source-code">var username = Console.ReadLine();</p></li>
<li>Next, the program needs to check whether the username has more than six characters and if not, write an error message to the console:<p class="source-code">if (username.Length &lt; 6)</p><p class="source-code">{</p><p class="source-code">Console.WriteLine($"The username {username} is not valid.");</p><p class="source-code">}</p></li>
<li>Now, within an <strong class="source-inline">else</strong> clause, you will continue the verification and ask the user to type a password. Once the user has entered a password, three points need to be checked. The first condition to check is whether the password has at least six characters and then whether there is at least one number. Then, if either of these conditions fails, the console should display an error message; else, it should display a success message. Add the following code for this:<p class="source-code">else</p><p class="source-code">{</p><p class="source-code">Console.WriteLine("Now type a </p><p class="source-code">password. It must have a length of at least 6 characters and also contain a number.");</p><p class="source-code">var password = Console.ReadLine();</p><p class="source-code">     </p><p class="source-code">if (password.Length &lt; 6)</p><p class="source-code">     {</p><p class="source-code">     		Console.WriteLine("The password must have at least 6 characters.");</p><p class="source-code">}</p><p class="source-code">     else if (!password.Any(c =&gt; char.IsDigit©))</p><p class="source-code">     {</p><p class="source-code">     		Console.WriteLine("The password must contain at least one number.");</p><p class="source-code">}</p><p class="source-code">else</p><p class="source-code">     {</p><p class="source-code">             Console.WriteLine("User successfully registered.");</p><p class="source-code">}</p><p class="source-code">}</p></li>
</ol>
<p>From the preceding snippet, you can see that if the user enters fewer than six characters, an error message is displayed as <strong class="source-inline">The password must have at least 6 characters.</strong>. If the password doesn't contain a single digit but satisfies the preceding condition, another error message is displayed as <strong class="source-inline">The password must contain at least one number.</strong>.</p>
<p>Notice the logical condition used for this, which is <strong class="source-inline">!password.Any(c =&gt; char.IsDi©(c))</strong>. You will learn more about the <strong class="source-inline">=&gt;</strong> notation in <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>, but for now, you just need to know that this line checks every character in the password and uses the <strong class="source-inline">IsDigit</strong> function to check whether the character is a digit. This is done for every character, and if no digit is found, the error message is displayed. If all the conditions are met, a success message is displayed as <strong class="source-inline">User successfully registered.</strong>.</p>
<ol>
<li value="5">Run the program using <strong class="source-inline">dotnet run</strong>. You should see an output like the following:<p class="source-code">Please type a username. It must have at least 6 characters:</p><p class="source-code">thekingjames</p><p class="source-code">Now type a password. It must have at least 6 characters and a number.</p><p class="source-code">James123!"#</p><p class="source-code">User successfully registered</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/3Q7oK">https://packt.link/3Q7oK</a>.</p></li>
</ol>
<p>In this exercise, you worked with if-else branching statements to implement a simple user registration program.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>The Ternary Operator</h2>
<p>Another simple-to-use, yet effective, decision-making operator is the ternary operator. It allows you to set the value of a variable based on a Boolean comparison. For example, consider the following example:</p>
<p class="source-code">var gift = person.IsChild() ? "Toy" : "Clothes";</p>
<p>Here, you are using the <strong class="source-inline">?</strong> symbol to check whether the Boolean condition placed before it is valid. The compiler runs the <strong class="source-inline">IsChild</strong> function for the <strong class="source-inline">person</strong> object. If the method returns <strong class="source-inline">true</strong>, the first value (before the <strong class="source-inline">:</strong> symbol) will be assigned to the <strong class="source-inline">gift</strong> variable. If the method returns <strong class="source-inline">false</strong>, the second value (after the <strong class="source-inline">:</strong> symbol) will be assigned to the <strong class="source-inline">gift</strong> variable.</p>
<p>The ternary operator is simple and makes assignments based on simple Boolean verifications even more concise. You will be using this quite often in your C# journey.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Reference and Value Types</h2>
<p>There are two types of variables in C#, namely, reference types and value types. Variables of value types, such as structs, contain the values themselves, as the name suggests. These values are stored in a memory space called the stack. When a variable of such a type is declared, specific memory space is allocated to store this value, as illustrated in the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 1.2: Memory allocation for a value type variable " height="224" src="image/B16835_01_02.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.2: Memory allocation for a value type variable</p>
<p>Here, the value of the variable, which is <strong class="source-inline">5</strong>, is stored in memory at the location <strong class="source-inline">0x100</strong> in the RAM. The built-in value types for C# are <strong class="source-inline">bool</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">decimal</strong>, <strong class="source-inline">double</strong>, <strong class="source-inline">enum</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">sbyte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">struct</strong>, <strong class="source-inline">uint</strong>, <strong class="source-inline">ulong</strong>, and <strong class="source-inline">ushort</strong>.</p>
<p>The scenario for reference type variables is different, though. The three main reference types you need to know about in this chapter are <strong class="source-inline">string</strong>, array, and <strong class="source-inline">class</strong>. When a new reference type variable is assigned, what is stored in memory is not the value itself, but instead a memory address where the value gets allocated. For example, consider the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 1.3: Memory allocation for a reference type variable " height="236" src="image/B16835_01_03.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.3: Memory allocation for a reference type variable</p>
<p>Here, instead of the value of the string variable (<strong class="source-inline">Hello</strong>), the address where it is allocated (<strong class="source-inline">0x100</strong>) is stored in memory. For brevity, you will not dive deep into this topic, but it is important to know the following points:</p>
<ul>
<li>When value type variables are passed as parameters or assigned as the value of another variable, the .NET runtime copies the value of the variable to the other object. This means that the original variable is not affected by any changes made in the newer and subsequent variables, as the values were literally copied from one place to another.</li>
<li>When reference type variables are passed as parameters or assigned as the value of another variable, .NET passes the heap memory address instead of the value. This means that every subsequent change made in this variable inside a method will be reflected outside.</li>
</ul>
<p>For instance, consider the following code, which deals with integers. Here, you declare an <strong class="source-inline">int</strong> variable named <strong class="source-inline">a</strong> and assign the value <strong class="source-inline">100</strong> to it. Later, you create another <strong class="source-inline">int</strong> variable named <strong class="source-inline">b</strong> and assign the value of <strong class="source-inline">a</strong> to it. Finally, you modify <strong class="source-inline">b</strong>, to be incremented by <strong class="source-inline">100</strong>:</p>
<p class="source-code">using System;</p>
<p class="source-code">int a = 100;</p>
<p class="source-code">Console.WriteLine($"Original value of a: {a}");</p>
<p class="source-code">int b = a;</p>
<p class="source-code">Console.WriteLine($"Original value of b: {b}");</p>
<p class="source-code">b = b + 100;</p>
<p class="source-code">Console.WriteLine($"Value of a after modifying b: {a}");</p>
<p class="source-code">Console.WriteLine($"Value of b after modifying b: {b}");</p>
<p>The values of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> will be displayed in the following output:</p>
<p class="source-code">Original value of a: 100</p>
<p class="source-code">Original value of b: 100</p>
<p class="source-code">Value of a after modifying b: 100</p>
<p class="source-code">Value of b after modifying b: 200</p>
<p>In this example, the value from <strong class="source-inline">a</strong> was copied into <strong class="source-inline">b</strong>. From this point, any other modification you do on <strong class="source-inline">b</strong> will reflect changes only in <strong class="source-inline">b</strong> and <strong class="source-inline">a</strong> will continue to have its original value.</p>
<p>Now, what if you pass reference types as method arguments? Consider the following program. Here, you have a class named <strong class="source-inline">Car</strong> with two properties—<strong class="source-inline">Name</strong> and <strong class="source-inline">GearType</strong>. Inside the program is a method called <strong class="source-inline">UpgradeGearType</strong> that receives an object of the <strong class="source-inline">Car</strong> type and changes its <strong class="source-inline">GearType</strong> to <strong class="source-inline">Automatic</strong>:</p>
<p class="source-code">using System;</p>
<p class="source-code">var car = new Car();</p>
<p class="source-code">car.Name = "Super Brand New Car";</p>
<p class="source-code">car.GearType = "Manual";</p>
<p class="source-code">Console.WriteLine($"This is your current configuration for the car {car.Name}: Gea–Type - {car.GearType}");</p>
<p class="source-code">UpgradeGearType(car);</p>
<p class="source-code">Console.WriteLine($"You have upgraded your car {car.Name} for the GearType {car.GearType}");</p>
<p class="source-code">void UpgradeGearType(Car car)</p>
<p class="source-code">{</p>
<p class="source-code">    car.GearType = "Automatic";</p>
<p class="source-code">}</p>
<p class="source-code">class Car</p>
<p class="source-code">{</p>
<p class="source-code">    public string Name { get; set; }</p>
<p class="source-code">    public string GearType { get; set; }</p>
<p class="source-code">}</p>
<p>After you create a <strong class="source-inline">Car</strong> <strong class="bold">instance</strong> and call the <strong class="source-inline">UpgradeGearType()</strong> method, the output will be as the follows:</p>
<p class="source-code">This is your current configuration for the car Super Brand New Car: GearType – Manual</p>
<p class="source-code">You have upgraded your car Super Brand New Car for the GearType Automatic</p>
<p>Thus, you see that if you pass an <strong class="bold">object</strong> of a reference type (<strong class="source-inline">car</strong> in this case) as an argument to a method (<strong class="source-inline">UpgradeGearType</strong> in this example), every change made inside this <strong class="bold">object</strong> is reflected after and outside the method call. This is because reference types refer to a specific location in memory.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Exercise 1.07: Grasping Value and Reference Equality </h2>
<p>In this exercise, you will see how equality comparison is different for value types and reference types. Perform the following steps to do so:</p>
<ol>
<li value="1">In VS Code, open the integrated terminal and type the following:<p class="source-code">dotnet new console -n Exercise1_07</p></li>
<li>Open the <strong class="source-inline">Program.cs</strong> file. In the same file, create a struct named <strong class="source-inline">GoldenRetriever</strong> with a <strong class="source-inline">Name</strong> property, as follows:<p class="source-code">struct GoldenRetriever</p><p class="source-code">{</p><p class="source-code">    public string Name { get; set; }</p><p class="source-code">}</p></li>
<li>Still in the same file, create one more class named <strong class="source-inline">BorderCollie</strong> with a similar <strong class="source-inline">Name</strong> property:<p class="source-code">class BorderCollie</p><p class="source-code">{</p><p class="source-code">    public string Name { get; set; }</p><p class="source-code">}</p></li>
<li>One final class must be created, a class named <strong class="source-inline">Bernese</strong>, also having the <strong class="source-inline">Name</strong> property, but with an extra override of the native <strong class="source-inline">Equals</strong> method:<p class="source-code">class Bernese</p><p class="source-code">{</p><p class="source-code">    public string Name { get; set; }</p><p class="source-code">    public override bool Equals(object obj)</p><p class="source-code">    {</p><p class="source-code">        if (obj is Bernese borderCollie &amp;&amp; obj != null)</p><p class="source-code">        {</p><p class="source-code">            return this.Name == borderCollie.Name;</p><p class="source-code">        }</p><p class="source-code">        return false;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Here, the <strong class="source-inline">this</strong> keyword is used to refer to the current <strong class="bold">instance</strong> of the <strong class="source-inline">borderCollie</strong> class.</p>
<ol>
<li value="5">Finally, in the <strong class="source-inline">Program.cs</strong> file, you will create some objects for these types. Note that since you are using <strong class="bold">top-level statements</strong>, these declarations should be above the class and the struct declarations:<p class="source-code">        var aGolden = new GoldenRetriever() { Name = "Aspen" };</p><p class="source-code">        var anotherGolden = new GoldenRetriever() { Name = "Aspen" };</p><p class="source-code">        var aBorder = new BorderCollie() { Name = "Aspen" };</p><p class="source-code">        var anotherBorder = new BorderCollie() { Name = "Aspen" };</p><p class="source-code">        var aBernese = new Bernese() { Name = "Aspen" };</p><p class="source-code">        var anotherBernese = new Bernese() { Name = "Aspen" };</p></li>
<li>Now, right after the previous declarations, compare these values using the <strong class="source-inline">Equals</strong> method and assign the result to some variables:<p class="source-code">var goldenComparison = aGolden.Equals(anotherGolden) ? "These Golden Retrievers have the same name." : "These Goldens have different names.";</p><p class="source-code">var borderComparison = aBorder.Equals(anotherBorder) ? "These Border Collies have the same name." : "These Border Collies have different names.";</p><p class="source-code">var berneseComparison = aBernese.Equals(anotherBernese) ? "These Bernese dogs have the same name." : "These Bernese dogs have different names.";</p></li>
<li>Finally, print the comparison results to the console with the following:<p class="source-code">          Console.WriteLine(goldenComparison);</p><p class="source-code">          Console.WriteLine(borderComparison);</p><p class="source-code">          Console.WriteLine(berneseComparison);</p></li>
<li>Run the program from the command line using <strong class="source-inline">dotnet run</strong> and you will see the following output:<p class="source-code">These Golden Retrievers have the same name.</p><p class="source-code">These Border Collies have different names.</p><p class="source-code">These Bernese dogs have the same name.</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/xcWN9">https://packt.link/xcWN9</a>.</p></li>
</ol>
<p>As mentioned earlier, structs are value types. Therefore, when two objects of the same struct are compared with <strong class="source-inline">Equals</strong>, .NET internally checks all the struct properties. If those properties have equal values, then <strong class="source-inline">true</strong> is returned. With <strong class="source-inline">Golden Retrievers</strong>, for instance, if you had a <strong class="source-inline">FamilyName</strong> property and this property was different between the two objects, the result of the equality comparison would be <strong class="source-inline">false</strong>.</p>
<p>For classes and all other reference types, the equality comparison is quite different. By default, object reference is checked on equality comparison. If the references are different (and they will be, unless the two variables are assigned to the same object), the equality comparison will return <strong class="source-inline">false</strong>. This explains the result you see for <strong class="source-inline">Border Collies</strong> in the example that the references were different for the two instances.</p>
<p>However, there is a method that can be implemented in reference types called Equals. Given two objects, the <strong class="source-inline">Equals</strong> method can be used for comparison following the logic placed inside the method. That is exactly what happened with the Bernese dogs example.</p>
<h3 id="_idParaDest-59"><a id="_idTextAnchor060"/>Default Value Types</h3>
<p>Now that you have dealt with value and reference types, you will briefly explore the default value types. In C#, every type has a default value, as specified in the following table:</p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 1.4: Default value types table " height="450" src="image/B16835_01_04.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.4: Default value types table</p>
<p>These default values can be assigned to a variable using the <strong class="source-inline">default</strong> keyword. To use this word in a variable declaration, you must explicitly declare the variable type before its name. For example, consider the following snippet, where you are assigning the <strong class="source-inline">default</strong> value to two <strong class="source-inline">int</strong> variables:</p>
<p class="source-code">int a = default;</p>
<p class="source-code">int b = default;</p>
<p>Both <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> will be assigned the value <strong class="source-inline">0</strong> in this case. Note that it is not possible to use <strong class="source-inline">var</strong> in this case. This is because, for implicitly declared variables, the compiler needs a value assigned to the variable in order to infer its type. So, the following snippet will lead to an error because no type was set, either through an explicit declaration or by variable assignment:</p>
<p class="source-code">var a = default;</p>
<p class="source-code">var b = default;</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Enhancing Decision Making with the switch Statement</h2>
<p>The <strong class="source-inline">switch</strong> statement is often used as an alternative to the if-else construct if a single expression is to be tested against three or more conditions, that is, when you want to select one of many code sections to be executed, such as the following:</p>
<p class="source-code">switch (matchingExpression) </p>
<p class="source-code">{</p>
<p class="source-code">  case firstCondition:</p>
<p class="source-code">    // code section</p>
<p class="source-code">    break;</p>
<p class="source-code">  case secondCondition:</p>
<p class="source-code">    // code section</p>
<p class="source-code">    break;</p>
<p class="source-code">  case thirdCondition:</p>
<p class="source-code">    // code section</p>
<p class="source-code">    break;</p>
<p class="source-code">  default:</p>
<p class="source-code">    // code section</p>
<p class="source-code">    break;</p>
<p class="source-code">}</p>
<p>The matching expression should return a value that is of one of the following types: <strong class="source-inline">char</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">bool</strong>, <strong class="source-inline">numbers</strong>, <strong class="source-inline">enum</strong>, and <strong class="source-inline">object</strong>. This value will then be evaluated within one of the matching case clauses or within the default clause if it does not match any prior clause.</p>
<p>It is important to say that only one <strong class="source-inline">switch</strong> section in a <strong class="source-inline">switch</strong> statement will be executed. C# doesn't allow execution to continue from one <strong class="source-inline">switch</strong> section to the next. However, a <strong class="source-inline">switch</strong> statement does not know how to stop by itself. You can either use the <strong class="source-inline">break</strong> keyword if you only wish to execute something without returning or return something if that is the case.</p>
<p>Also, the <strong class="source-inline">default</strong> keyword on a <strong class="source-inline">switch</strong> statement is where the execution goes if none of the other options are matched. In the next exercise, you will use a <strong class="source-inline">switch</strong> statement to create a restaurant menu app.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Exercise 1.08: Using switch to Order Food</h2>
<p>In this exercise, you will create a console app that lets the user select from a menu of food items available at a restaurant. The app should display an acknowledgment receipt for the order. You will use the <strong class="source-inline">switch</strong> statement to implement the logic. </p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Create a new console project called <strong class="source-inline">Exercise1_08</strong>.</li>
<li>Now, create an <strong class="bold">instance</strong> of <strong class="source-inline">System.Text.StringBuilder</strong>. This is a class that helps build strings in many ways. Here, you are building strings line by line so that they can be properly displayed on the console:<p class="source-code">var menuBuilder = new System.Text.StringBuilder();</p><p class="source-code">menuBuilder.AppendLine("Welcome to the Burger Joint. ");</p><p class="source-code">menuBuilder.AppendLine(string.Empty);</p><p class="source-code">menuBuilder.AppendLine("1) Burgers and Fries - 5 USD");</p><p class="source-code">menuBuilder.AppendLine("2) Cheeseburger - 7 USD");</p><p class="source-code">menuBuilder.AppendLine("3) Double-cheeseburger - 9 USD");</p><p class="source-code">menuBuilder.AppendLine("4) Coke - 2 USD");</p><p class="source-code">menuBuilder.AppendLine(string.Empty);</p><p class="source-code">menuBuilder.AppendLine("Note that every burger option comes with fries and ketchup!");</p></li>
<li>Display the menu on the console and ask the user to choose one of the options:<p class="source-code">Console.WriteLine(menuBuilder.ToString());</p><p class="source-code">Console.WriteLine("Please type one of the following options to order:");</p></li>
<li>Read the key that the user presses and assign it to a variable with the <strong class="source-inline">Console.ReadKey()</strong> method. This method works similarly to <strong class="source-inline">ReadLine()</strong>, which you have used before, with the difference that it reads the key that is immediately pressed after calling the method. Add the following code for this:<p class="source-code">var option = Console.ReadKey();</p></li>
<li>Now it is time to use the <strong class="source-inline">switch</strong> statement. Use <strong class="source-inline">option.KeyChar.ToString()</strong> as the matching expression of the <strong class="source-inline">switch</strong> clause here. Keys <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and <strong class="source-inline">4</strong> should result in orders accepted for <strong class="source-inline">burgers</strong>, <strong class="source-inline">cheeseburgers</strong>, <strong class="source-inline">double cheeseburgers</strong>, and <strong class="source-inline">Coke</strong>, respectively:<p class="source-code">switch (option.KeyChar.ToString())</p><p class="source-code">{</p><p class="source-code">    case "1":</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("\nAlright, some burgers on the go. Please pay the cashier.");</p><p class="source-code">            break;</p><p class="source-code">        }</p><p class="source-code">    case "2":</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("\nThank you for ordering cheeseburgers. Please pay the cashier.");</p><p class="source-code">            break;</p><p class="source-code">        }</p><p class="source-code">    case "3":</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine("\nThank you for ordering double cheeseburgers, hope you enjoy them. Please pay the cashier!");</p></li>
</ol>
<p>Any other input, however, should be considered invalid and a message gets displayed, letting you know you have selected an invalid option:</p>
<p class="source-code">            break;</p>
<p class="source-code">        }</p>
<p class="source-code">    case "4":</p>
<p class="source-code">        {</p>
<p class="source-code">            Console.WriteLine("\nThank you for ordering Coke. Please pay the cashier.");</p>
<p class="source-code">            break;</p>
<p class="source-code">        }</p>
<p class="source-code">    default:</p>
<p class="source-code">        {</p>
<p class="source-code">            Console.WriteLine("\nSorry, you chose an invalid option.");</p>
<p class="source-code">            break;</p>
<p class="source-code">        }</p>
<p class="source-code">}</p>
<ol>
<li value="6">Finally, run the program with <strong class="source-inline">dotnet run --project Exercise1_08</strong> and interact with the console to see the possible outputs. For example, if you type <strong class="source-inline">1</strong>, you should see an output like the following:<p class="source-code">Welcome to the Burger Joint. </p><p class="source-code">1) Burgers and Fries – 5 USD</p><p class="source-code">2) Cheeseburger – 7 USD</p><p class="source-code">3) Double-cheeseburger – 9 USD</p><p class="source-code">4) Coke – 2 USD</p><p class="source-code">Note that every burger option comes with fries and ketchup!</p><p class="source-code">Please type one of the follow options to order:</p><p class="source-code">1</p><p class="source-code">Alright, some burgers on the go! Please pay on the following cashier!</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/x1Mvn">https://packt.link/x1Mvn</a>.</p></li>
</ol>
<p>Similarly, you should get the output for the other options as well. You have learned about branching statements in C#. There is another type of statement that you will use often while programming using C#, called iteration statements. The next section covers this topic in detail.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Iteration Statements</h2>
<p>Iteration statements, also called loops, are types of statements that are useful in the real world, as you often need to continuously repeat some logical execution in your applications <strong class="source-inline">while</strong> or <strong class="source-inline">until</strong> some condition is met, such as operating with a number that must be incremented until a certain value. C# offers numerous ways of implementing such iterations, and in this section, you will examine each of these in detail.</p>
<h3 id="_idParaDest-63"><a id="_idTextAnchor064"/>while</h3>
<p>The first iteration statement you will consider is the <strong class="source-inline">while</strong> statement. This statement allows a C# program to execute a set of instructions while a certain Boolean expression is evaluated to be <strong class="source-inline">true</strong>. It has one of the most basic structures. Consider the following snippet:</p>
<p class="source-code">int i = 0;</p>
<p class="source-code">while (i &lt; 10)</p>
<p class="source-code">{</p>
<p class="source-code">Console.WriteLine(i);</p>
<p class="source-code">i = i +1;</p>
<p class="source-code">}</p>
<p>The preceding snippet shows how you can use the <strong class="source-inline">while</strong> statement. Note that the <strong class="source-inline">while</strong> keyword is followed by a pair of brackets enclosing a logical condition; in this case, the condition is that the value of <strong class="source-inline">i</strong> must be less than <strong class="source-inline">10</strong>. The code written inside the curly braces will be executed until this condition is <strong class="source-inline">true</strong>.</p>
<p>Thus, the preceding code will print the value of <strong class="source-inline">i</strong>, starting with <strong class="source-inline">0</strong>, up to <strong class="source-inline">10</strong>. This is fairly simplistic code; in the next exercise, you will use the <strong class="source-inline">while</strong> statement for something a little more complex, such as checking whether a number entered by you is a prime number.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Exercise 1.09: Checking Whether a Number is Prime with a while Loop</h2>
<p>In this exercise, you will use a <strong class="source-inline">while</strong> loop to check whether a number you enter is prime. To do so, the <strong class="source-inline">while</strong> loop will check whether the counter is less than or equal to the integer result of the division of the number by <strong class="source-inline">2</strong>. When this condition is satisfied, you check whether the remainder of the division of the number by the counter is <strong class="source-inline">0</strong>. If not, you increment the counter and continue until the loop condition is not met. If it is met, it means the number is not <strong class="source-inline">false</strong> and the loop can stop.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Inside the VS Code integrated terminal, create a new console project called <strong class="source-inline">Exercise1_09</strong>.</li>
<li>Inside the <strong class="source-inline">Program.cs</strong> file, create the following method, which will perform the logic you introduced at the beginning of the exercise:<p class="source-code">static bool IsPrime(int number)</p><p class="source-code">{</p><p class="source-code">if (number ==0 || number ==1) return false;</p><p class="source-code">bool isPrime = true;</p><p class="source-code">int counter = 2;</p><p class="source-code">while (counter &lt;= Math.Sqrt(number))</p><p class="source-code">     {</p><p class="source-code">     		if (number % counter == 0)</p><p class="source-code">           {</p><p class="source-code">           	isPrime = false;</p><p class="source-code">                break;</p><p class="source-code">}</p><p class="source-code">counter++;</p><p class="source-code">}</p><p class="source-code">     return isPrime;</p><p class="source-code">}</p></li>
<li>Now, input a number, so you can check whether it is prime:<p class="source-code">Console.Write("Enter a number to check whether it is Prime: ");</p><p class="source-code">var input = int.Parse(Console.ReadLine());</p></li>
<li>Now, check whether the number is prime and print the result:<p class="source-code">Console.WriteLine($"{input} is prime? {IsPrime(input)}.");</p></li>
<li>Finally, on the VS Code integrated terminal, call <strong class="source-inline">dotnet run --project Exercise1_09</strong> and interact with the program. For example, try entering <strong class="source-inline">29</strong> as an input:<p class="source-code">Enter a number to check whether it is Prime:</p><p class="source-code">29</p><p class="source-code">29 is prime? True</p></li>
</ol>
<p>As expected, the result for <strong class="source-inline">29</strong> is <strong class="source-inline">true</strong> since it is a prime number.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/5oNg5">https://packt.link/5oNg5</a>.</p>
<p>The preceding exercise aimed to show you the simple structure of a <strong class="source-inline">while</strong> loop with some more complex logic. It checks a number (named <strong class="source-inline">input</strong>) and prints whether it is a prime number. Here, you have seen the <strong class="source-inline">break</strong> keyword used again to stop program execution. Now proceed to learn about jump statements.</p>
<h3 id="_idParaDest-65"><a id="_idTextAnchor066"/>Jump Statements</h3>
<p>There are some other important keywords used within loops that are worth mentioning as well. These keywords are called jump statements and are used to transfer program executions to another part. For instance, you could rewrite the <strong class="source-inline">IsPrime</strong> method as follows:</p>
<p class="source-code">static bool IsPrimeWithContinue(int number)</p>
<p class="source-code">        {</p>
<p class="source-code">        if (number == 0 || number ==1) return false;</p>
<p class="source-code">            bool isPrime = true;</p>
<p class="source-code">            int counter = 2;</p>
<p class="source-code">            while (counter &lt;= Math.Sqrt(number))</p>
<p class="source-code">            {</p>
<p class="source-code">                if (number % counter != 0)</p>
<p class="source-code">                {</p>
<p class="source-code">                    counter++;</p>
<p class="source-code">                    continue;</p>
<p class="source-code">                }</p>
<p class="source-code">                isPrime = false;</p>
<p class="source-code">                break;</p>
<p class="source-code">            }</p>
<p class="source-code">            return isPrime;</p>
<p class="source-code">        }</p>
<p>Here, you have inverted the logical check. Instead of checking whether the remainder is zero and then breaking the program execution, you have checked that the remainder is not zero and, if so, have used the <strong class="source-inline">continue</strong> statement to pass the execution to the next iteration.</p>
<p>Now look at how you can rewrite this using another special keyword, <strong class="source-inline">goto</strong>:</p>
<p class="source-code">static bool IsPrimeWithGoTo(int number)</p>
<p class="source-code">        {</p>
<p class="source-code">        if (number == 0 || number ==1) return false;</p>
<p class="source-code">bool isPrime = true;</p>
<p class="source-code">            int counter = 2;</p>
<p class="source-code">            while (counter &lt;= Math.Sqrt(number))</p>
<p class="source-code">            {</p>
<p class="source-code">                if (number % counter == 0)</p>
<p class="source-code">                {</p>
<p class="source-code">                    isPrime = false;</p>
<p class="source-code">                    goto isNotAPrime; </p>
<p class="source-code">                }</p>
<p class="source-code">                counter++;</p>
<p class="source-code">            }</p>
<p class="source-code">            isNotAPrime:</p>
<p class="source-code">            return isPrime;</p>
<p class="source-code">        }</p>
<p>The <strong class="source-inline">goto</strong> keyword can be used to jump from one part of the code to another one defined by what is called a label. In this case, the label was named <strong class="source-inline">isNotAPrime</strong>. Finally, take a look at one last way of writing this logic:</p>
<p class="source-code">static bool IsPrimeWithReturn(int number)</p>
<p class="source-code">        {</p>
<p class="source-code">        if (number == 0 || number ==1) return false;</p>
<p class="source-code">            int counter = 2;</p>
<p class="source-code">            while (counter &lt;= Math.Sqrt(number))</p>
<p class="source-code">            {</p>
<p class="source-code">                if (number % counter == 0)</p>
<p class="source-code">                {</p>
<p class="source-code">                    return false;</p>
<p class="source-code">                }</p>
<p class="source-code">                counter ++;</p>
<p class="source-code">            }</p>
<p class="source-code">            return true;</p>
<p class="source-code">        }</p>
<p>Now, instead of using <strong class="source-inline">break</strong> or <strong class="source-inline">continue</strong> to stop the program execution, you simply use <strong class="source-inline">return</strong> to break the loop execution since the result that you were looking for was already found.</p>
<h3 id="_idParaDest-66"><a id="_idTextAnchor067"/>do-while</h3>
<p>The <strong class="source-inline">do-while</strong> loop is like the previous one, but with one subtle difference: it executes the logic at least once, while a simple <strong class="source-inline">while</strong> statement may never be executed if the condition is not met at the first execution. It has the following structure:</p>
<p class="source-code">int t = 0;</p>
<p class="source-code">do</p>
<p class="source-code">{</p>
<p class="source-code">    Console.WriteLine(t);</p>
<p class="source-code">    t++;</p>
<p class="source-code">} while (t &lt; 5);</p>
<p>In this example, you write the value of <strong class="source-inline">t</strong>, starting from <strong class="source-inline">0</strong>, and keep incrementing it while it is smaller than <strong class="source-inline">5</strong>. Before jumping into the next type of loop, learn about a new concept called arrays.</p>
<h3 id="_idParaDest-67"><a id="_idTextAnchor068"/>Arrays</h3>
<p>An array is a data structure used to store many objects of the same type. For instance, the following example is a variable declared as an array of integer numbers:</p>
<p class="source-code">int[] numbers = { 1, 2, 3, 4, 5 };</p>
<p>The first important thing to note about arrays is that they have a fixed capacity. This means that an array will have the length defined at the time of its creation and this length cannot change. The length can be determined in various ways. In the preceding example, the length is inferred by counting the number of objects in the array. However, another way of creating an array is like this:</p>
<p class="source-code">var numbers = new int[5];</p>
<p>Here, you are creating an array that has the capacity of <strong class="source-inline">5</strong> integers, but you do not specify any value for the array elements. When an array of any data type is created without adding elements to it, the default values for that value type are set for each position of the array. For example, consider the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 1.5: Value type array with no index assigned " height="131" src="image/B16835_01_05.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.5: Value type array with no index assigned</p>
<p>The preceding figure shows that when you create an integer array of five elements, without assigning a value to any element, the array is automatically filled with the default value at every position. In this case, the default value is <strong class="source-inline">0</strong>. Now consider the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 1.6: Reference type array with fixed size and only one index assigned " height="293" src="image/B16835_01_06.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.6: Reference type array with fixed size and only one index assigned</p>
<p>In the preceding example, you have created an array of five objects and assigned the <strong class="source-inline">"Hello"</strong> string value to the element at index <strong class="source-inline">1</strong>. The other positions of the array are automatically assigned the default value for objects, which is <strong class="source-inline">null</strong>.</p>
<p>Finally, it is worth noting that all arrays have indexes, which refers to the positions of the individual array elements. The first position will always have an index <strong class="source-inline">0</strong>. Thus, the positions in an array of size <strong class="source-inline">n</strong> can be specified from index <strong class="source-inline">0</strong> to <strong class="source-inline">n-1</strong>. Therefore, if you call <strong class="source-inline">numbers[2]</strong>, this means that you are trying to access the element in position <strong class="source-inline">2</strong> inside the numbers array.</p>
<h3 id="_idParaDest-68"><a id="_idTextAnchor069"/>for Loops</h3>
<p>A <strong class="source-inline">for</strong> loop executes a set of instructions while a Boolean expression matches a specified condition. Just like <strong class="source-inline">while</strong> loops, jump statements can be used to stop a loop execution. It has the following structure:</p>
<p class="source-code">for (initializer; condition; iterator)</p>
<p class="source-code">{</p>
<p class="source-code">	[statements]</p>
<p class="source-code">}</p>
<p>The initializer statement is executed before the loop starts. It is used to declare and assign a local variable that will be used only inside the scope of the loop.</p>
<p>But in more complex scenarios, it can be used to combine other statement expressions as well. The condition specifies a Boolean condition that indicates when the loop should either continue or exit. The iterator is usually used to increment or decrement the variable created in the initializer section. Take the following example, where a <strong class="source-inline">for</strong> loop is used to print the elements of an integer array:</p>
<p class="source-code">int[] array = { 1, 2, 3, 4, 5 };</p>
<p class="source-code">for (int j = 0; j &lt; array.Length - 1; j++)</p>
<p class="source-code">{</p>
<p class="source-code">Console.WriteLine(array[j]);</p>
<p class="source-code">}</p>
<p>In this example, an initializer variable, <strong class="source-inline">j</strong>, has been created that is assigned <strong class="source-inline">0</strong> initially. The <strong class="source-inline">for</strong> loop will keep executing while <strong class="source-inline">j</strong> is smaller than the array length minus <strong class="source-inline">1</strong> (remember that indexes always start at <strong class="source-inline">0</strong>). After each iteration, the value of <strong class="source-inline">j</strong> is incremented by <strong class="source-inline">1</strong>. In this way, the <strong class="source-inline">for</strong> loop goes through the entire array and performs the given action, that is, printing the value of the current array element.</p>
<p>C# also allows the usage of <strong class="bold">nested loops</strong>, that is, a <strong class="bold">loop within a loop</strong>, as you will see in the next exercise.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Exercise 1.10: Ordering an Array Using Bubble Sort</h2>
<p>In this exercise, you will execute one of the simplest sorting algorithms. Bubble sort consists of going through every pair of elements inside an array and swapping them if they are unordered. In the end, the expectation is to have an array ordered in ascending order. You will use nested <strong class="source-inline">for</strong> loops to implement this algorithm.</p>
<p>To begin with, the array to be sorted should be passed as a parameter to this method. For each element of this array, if the current element is greater than the next, their positions should be swapped. This swap occurs by storing the value of the next element in a temporary variable, assigning the value of the current element to the next element, and finally, setting the value of the current element with the temporary value stored. Once the first element is compared to all others, a comparison starts for the second element and so on, till finally, the array is sorted.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Create a new console project using the following command:<p class="source-code">dotnet new console -n Exercise1_10</p></li>
<li>Inside the <strong class="source-inline">Program.cs</strong> file, create the method to implement the sorting algorithm. Add the following code:<p class="source-code">static int[] BubbleSort(int[] array)</p><p class="source-code">{</p><p class="source-code">    int temp;</p><p class="source-code">    // Iterate over the array</p><p class="source-code">    for (int j = 0; j &lt; array.Length - 1; j++)</p><p class="source-code">    {</p><p class="source-code">        // If the last j elements are already ordered, skip them</p><p class="source-code">        for (int i = 0; i &lt; array.Length - j - 1; i++)</p><p class="source-code">        {</p><p class="source-code">            if (array[i] &gt; array[i + 1])</p><p class="source-code">            {</p><p class="source-code">                temp = array[i + 1];</p><p class="source-code">                array[i + 1] = array[i];</p><p class="source-code">                array[i] = temp;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    return array;</p><p class="source-code">}</p></li>
<li>Now create an <strong class="bold">array</strong> with some numbers, as follows:<p class="source-code">int[] randomNumbers = { 123, 22, 53, 91, 787, 0, -23, 5 };</p></li>
<li>Call the <strong class="source-inline">BubbleSort</strong> method, passing the array as an argument, and assign the result to a variable, as follows:<p class="source-code">int[] sortedArray = BubbleSort(randomNumbers);</p></li>
<li>Finally, you need to print the message that the array was sorted. To do so, iterate over it, printing the array elements:<p class="source-code">Console.WriteLine("Sorted:");</p><p class="source-code">for (int i = 0; i &lt; sortedArray.Length; i++)</p><p class="source-code">{</p><p class="source-code">    Console.Write(sortedArray[i] + " ");</p><p class="source-code">}</p></li>
<li>Run the program with the <strong class="source-inline">dotnet run --project Exercise1_10</strong> command. You should see the following output on your screen:<p class="source-code">Sorted:</p><p class="source-code">-23 0 5 22 53 91 123 787</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cJs8y">https://packt.link/cJs8y</a>.</p></li>
</ol>
<p>In this exercise, you used the two concepts learned in the last two sections: arrays and for loops. You manipulated arrays, accessing their values through indexes, and used for loops to move through these indexes.</p>
<p>There is another way to go through every element of an array or <strong class="bold">group</strong> in C#, called <strong class="source-inline">foreach</strong> statements. You will explore this in the following section.</p>
<h3 id="_idParaDest-70"><a id="_idTextAnchor071"/>foreach Statements</h3>
<p>A <strong class="source-inline">foreach</strong> statement executes a set of instructions for each element of a collection. Just like a <strong class="source-inline">for</strong> loop, the <strong class="source-inline">break</strong>, <strong class="source-inline">continue</strong>, <strong class="source-inline">goto</strong>, and <strong class="source-inline">return</strong> keywords can also be used with <strong class="source-inline">foreach</strong> statements. Consider the following example, in which you iterate over every element of an array and write it to the console as the output:</p>
<p class="source-code">var items = new int[] { 1, 2, 3, 4, 5 };</p>
<p class="source-code">foreach (int element in items)</p>
<p class="source-code">{</p>
<p class="source-code">Console.WriteLine(element);</p>
<p class="source-code">}</p>
<p>The preceding snippet prints the numbers from <strong class="source-inline">1</strong> to <strong class="source-inline">5</strong> to the console. You can use <strong class="source-inline">foreach</strong> statements with much more than arrays; they can also be used with lists, collections, and spans, which are other data structures that will be covered in later chapters.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>File Handling</h2>
<p>So far, you have been creating programs that interact mostly with CPU and memory. This section will focus on I/O operations, that is, input and output operations, on the physical disk. A great example of this type of operation is file handling.</p>
<p>C# has several classes that help you perform I/O operations. Some of these are as follows:</p>
<ul>
<li><strong class="source-inline">File</strong>: This class provides methods for the manipulation of files, that is, reading, writing, creating, deleting, copying, and moving files on the disk.</li>
<li><strong class="source-inline">Directory</strong>: Like the <strong class="source-inline">File</strong> class, this class includes methods to create, move, and enumerate directories and subdirectories on the disk.</li>
<li><strong class="source-inline">Path</strong>: This provides utilities to deal with absolute and relative paths of files and directories on the disk. A relative path is always related to some path inside the current directory where the application is being executed, and an absolute path refers to an absolute location inside the hard drive.</li>
<li><strong class="source-inline">DriveInfo</strong>: This provides information about a disk drive, such as <strong class="source-inline">Name</strong>, <strong class="source-inline">DriveType</strong>, <strong class="source-inline">VolumeLabel</strong>, and <strong class="source-inline">DriveFormat</strong>.</li>
</ul>
<p>You already know that files are mostly some sets of data located somewhere in a hard drive that can be opened for reading or writing by some program. When you open a file in a C# application, your program reads the file as a sequence of bytes through a communication channel. This communication channel is called a stream. Streams can be of two types:</p>
<ul>
<li>The input streams are used for reading operations.</li>
<li>The output streams are used for writing operations.</li>
</ul>
<p>The <strong class="source-inline">Stream</strong> class is an abstract class in C# that enables common operations regarding this byte flow. For file handling on a hard disk, you will use the <strong class="source-inline">FileStream</strong> class, designed specifically for this purpose. The following are two important properties of this class: <strong class="source-inline">FileAccess</strong> and <strong class="source-inline">FileMode</strong>.</p>
<h3 id="_idParaDest-72"><a id="_idTextAnchor073"/>FileAccess</h3>
<p>This is an <strong class="source-inline">enum</strong> that provides you with options to choose a level of access when opening a specified file:</p>
<ul>
<li><strong class="source-inline">Read</strong>: This opens a file in read-only mode.</li>
<li><strong class="source-inline">ReadWrite</strong>: This opens a file in read and write mode.</li>
<li><strong class="source-inline">Write</strong>: This opens a file in write-only mode. This is rarely used, as you usually do some reading along with the writing.</li>
</ul>
<h3 id="_idParaDest-73"><a id="_idTextAnchor074"/>FileMode</h3>
<p>This is an <strong class="source-inline">enum</strong> that specifies the operations that can be performed on a file. It should be used along with the access mode as some modes only work with some levels of access. Take a look at the options, as follows:</p>
<ul>
<li><strong class="source-inline">Append</strong>: Use this when you want to add content at the end of the file. If the file does not exist, a new one will be created. For this operation, the file must have write permission; otherwise, any attempt to read fails and throws a <strong class="source-inline">NotSupportedException</strong> exception. Exceptions are an important concept that will be covered later in this chapter.</li>
<li><strong class="source-inline">Create</strong>: Use this to create a new file or overwrite an existing one. For this option, too, write permission is required. In Windows, if the file exists but is hidden, an <strong class="source-inline">UnauthorizedAccessException</strong> exception is thrown.</li>
<li><strong class="source-inline">CreateNew</strong>: This is like <strong class="source-inline">Create</strong> but is used to create new files and also requires write permission. However, if the file already exists, an <strong class="source-inline">IOException</strong> exception is thrown.</li>
<li><strong class="source-inline">Open</strong>: As the name suggests, this mode is used to open a file. The file must have read or read and write permissions. If the file does not exist, a <strong class="source-inline">FileNotFoundException</strong> exception is thrown.</li>
<li><strong class="source-inline">OpenOrCreate</strong>: This is like <strong class="source-inline">Open</strong>, except it creates a new file if it does not already exist.</li>
</ul>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Exercise 1.11: Reading Content from Text Files</h2>
<p>In this exercise, you will read text from a Comma-Separated Values (CSV) file. CSV files simply contain data represented by strings and separated either by colons or semicolons.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Open Command Prompt and type the following:<p class="source-code">dotnet new console -n Exercise1_11</p></li>
<li>At the <strong class="source-inline">Exercise1_11</strong> project folder location in your computer, create a file named <strong class="source-inline">products.csv</strong> and paste the following content inside it:<p class="source-code">Mo<a id="_idTextAnchor076"/>del;Memory;Storage;USB Ports;Screen;Condition;Price USD</p><p class="source-code">Macbook Pro Mid 2012;8GB;500GB HDD;USB 2.0x2;13" screen;Refurbished;400</p><p class="source-code">Macbook Pro Mid 2014;8GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;750</p><p class="source-code">Macbook Pro Late 2019;16GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;1250</p></li>
<li>Open the <strong class="source-inline">Program.cs</strong> file and replace its contents with the following:<p class="source-code">using System;</p><p class="source-code">using System.IO;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">namespace Exercise1_11</p><p class="source-code">{</p><p class="source-code">    public class Program</p><p class="source-code">    {</p><p class="source-code">        public static async Task Main()</p><p class="source-code">        {</p><p class="source-code">        using (var fileStream = new FileStream("products.csv", FileMode.Open, FileAccess.Read))</p><p class="source-code">        {</p><p class="source-code">            using (var reader = new StreamReader(fileStream))</p><p class="source-code">            {</p><p class="source-code">                var content = await reader.ReadToEndAsync();</p><p class="source-code">                var lines = content.Split(Environment.NewLine);</p><p class="source-code">                foreach (var line in lines)</p><p class="source-code">                {</p><p class="source-code">                    Console.WriteLine(line);</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Call <strong class="source-inline">dotnet run</strong> in Command Prompt and you will get an output that is the same as the contents of the CSV file you have created.<p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/5flid">https://packt.link/5flid</a>.</p></li>
</ol>
<p>This exercise has some pretty interesting outcomes, which you are going to learn step by step. First, you opened a file using the <strong class="source-inline">FileStream</strong> class. This allows you to start streaming bytes from a file with two special properties, namely, <strong class="source-inline">FileMode</strong> and <strong class="source-inline">FileAccess</strong>. It will return a <strong class="bold">stream</strong> of bytes with the file contents. However, to read this content as text, you need to use the <strong class="source-inline">StreamReader</strong> class. This class enables you to read these bytes as text characters.</p>
<p>Notice also that your <strong class="source-inline">Main</strong> method changed from <strong class="source-inline">void</strong> to <strong class="source-inline">async</strong> Task. Additionally, the <strong class="source-inline">await</strong> keyword has been used, which is used for asynchronous operations. You will learn more about these topics in upcoming chapters. For now, you only need to know that an async operation is something that does not block the program execution. This means that you can output lines as they are being read; that is, you do not have to wait for all of them to be read.</p>
<p>In the next section, learn about the special keyword that handles files, databases, and network connections.</p>
<h3 id="_idParaDest-75"><a id="_idTextAnchor077"/>Disposable Objects</h3>
<p>Another special thing about the preceding exercise was the <strong class="source-inline">using</strong> keyword. It is a keyword used to clean up unmanaged resources from memory. These resources are special objects that handle some operational system resources, such as files, databases, and network connections. They are called <strong class="bold">special</strong> because they do what is called I/O operations; that is, they interact with the real resources of the machine, such as network and hard drives, not just with memory spaces.</p>
<p>The memory used by objects in C# is handled by something called the garbage collector. By default, C# handles the memory space in the stack and the heap. The only types of objects that do not perform this cleanup are called unmanaged objects.</p>
<p>Cleaning these objects from memory means that the resources will be free to be used by another process in the computer. That means a file can be handled by another one, a database connection is free to be used again by a connection pool, and so on. Those types of resources are called disposable resources. Every time you deal with a disposable resource, you can use the <strong class="source-inline">using</strong> keyword when creating an object. Then, the compiler knows that when the <strong class="source-inline">using</strong> statement closes, it can automatically free these resources.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Exercise 1.12: Writing to a Text File</h2>
<p>In this exercise, you will write some text into a CSV file, again using the <strong class="source-inline">FileStream</strong> class.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<p class="source-code">dotnet new console -n Exercise1_12</p></li>
<li>At a preferred location on your computer, copy the <strong class="source-inline">products.csv</strong> file from the previous exercise and paste it into this exercise's folder.</li>
<li>In <strong class="source-inline">Program.cs</strong>, create a method named <strong class="source-inline">ReadFile</strong> that will receive a <strong class="source-inline">FileStream</strong> file and iterate over the file lines to output the result to the console:<p class="source-code">static async Task ReadFile(FileStream fileStream)</p><p class="source-code">    {</p><p class="source-code">        using (var reader = new StreamReader(fileStream))</p><p class="source-code">        {</p><p class="source-code">            var content = await reader.ReadToEndAsync();</p><p class="source-code">            var lines = content.Split(Environment.NewLine);</p><p class="source-code">            foreach (var line in lines)</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine(line);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now, in your program, open the <strong class="source-inline">products.csv</strong> file with <strong class="source-inline">StreamWriter</strong> and add some more information to it, as follows:<p class="source-code">        using (var file = new StreamWriter("products.csv", append: true))</p><p class="source-code">        {</p><p class="source-code">            file.Write("\nOne more macbook without details.");</p><p class="source-code">        }</p></li>
<li>Finally, read the contents of the file after modification:<p class="source-code">using (var fileStream = new FileStream("products.csv", FileMode.Open,</p><p class="source-code">            FileAccess.Read))</p><p class="source-code">        {</p><p class="source-code">            await ReadFile(fileStream);</p><p class="source-code">        }</p></li>
<li>Call <strong class="source-inline">dotnet run --project Exercise1_12</strong> in the VS Code integrated terminal and you will be able to see the contents of the CSV file you just created, in addition to the line you just appended:<p class="source-code">Model;Memory;Storage;USB Ports;Screen;Condition;Price USD</p><p class="source-code">Macbook Pro Mid 2012;8GB;500GB HDD;USB 2.0x2;13" screen;Refurbished;400</p><p class="source-code">Macbook Pro Mid 2014;8GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;750</p><p class="source-code">Macbook Pro Late 2019;16GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;1250</p><p class="source-code">One more macbook without details.</p></li>
</ol>
<p>Note that for each run, the program will append a new line, so you will see more lines being added.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/dUk2z">https://packt.link/dUk2z</a>.</p>
<p>Sometimes your program will fail to execute at some point and may not provide an output. Such an instance is called an exception error. The next section details all about such an error.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Exceptions</h2>
<p>Exceptions indicate that a program has failed to execute at some point for some reason and can be raised by either the code itself or the .NET runtime. Usually, an exception is a severe failure and can even terminate your program's execution. Fortunately, C# provides a special way of handling exceptions, which is <strong class="source-inline">try/catch</strong> blocks:</p>
<p class="source-code">try</p>
<p class="source-code">{</p>
<p class="source-code">// some logic that might throw an exception</p>
<p class="source-code">}</p>
<p class="source-code">catch</p>
<p class="source-code">{</p>
<p class="source-code">// error handling</p>
<p class="source-code">}</p>
<p>Inside the <strong class="source-inline">try</strong> clause, you call the code that might throw an exception, and inside the <strong class="source-inline">catch</strong> clause, you can treat the exception that was raised. For instance, consider the following example:</p>
<p class="source-code">double Divide(int a, int b) =&gt; a/b;</p>
<p>This method takes two integers and returns the result of a division between them. However, what will happen if <strong class="source-inline">b</strong> is <strong class="source-inline">0</strong>? In such a case, the runtime will throw <strong class="source-inline">System.DivideByZeroException</strong>, indicating that it is not possible to execute the division. How could you handle this exception in a real-world program? You will explore this in the next exercise.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor080"/>Exercise 1.13: Handling Invalid User Inputs with try/catch</h2>
<p>In this exercise, you will create a console app that takes two inputs from you, divides the first number by the second one, and outputs the result. If you enter an invalid character, the app should throw an exception, and all of this should be handled inside the program logic.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Inside the VS Code integrated terminal, create a new console app called <strong class="source-inline">Exercise1_13</strong>.</li>
<li>Create the following method inside the <strong class="source-inline">Program.cs</strong> file:<p class="source-code">static double Divide(int a, int b)</p><p class="source-code">{</p><p class="source-code">    return a / b;</p><p class="source-code">}</p></li>
<li>Now, create a Boolean variable to indicate whether the division was properly executed. Assign <strong class="source-inline">false</strong> to it as its initial value:<p class="source-code">bool divisionExecuted = false;</p></li>
<li>Write a <strong class="source-inline">while</strong> loop that will check whether the division happened successfully. If it did, the program should terminate. If not, the program should prompt you to input valid data and perform the division again. Add the following code to do this:<p class="source-code">while (!divisionExecuted)</p><p class="source-code">{</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine("Please input a number");</p><p class="source-code">        var a = int.Parse(Console.ReadLine());</p><p class="source-code">        Console.WriteLine("Please input another number");</p><p class="source-code">        var b = int.Parse(Console.ReadLine());</p><p class="source-code">        var result = Divide(a, b);</p><p class="source-code">        Console.WriteLine($"Result: {result}");</p><p class="source-code">        divisionExecuted = true;</p><p class="source-code">    }</p><p class="source-code">    catch (System.FormatException)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine("You did not input a number. Let's start again ... \n");</p><p class="source-code">        continue;</p><p class="source-code">    }</p><p class="source-code">    catch (System.DivideByZeroException)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine("Tried to divide by zero. Let's start again ... \n");</p><p class="source-code">        continue;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Finally, execute the program using the <strong class="source-inline">dotnet run</strong> command and interact with the console. Try to insert strings instead of numbers and see what output you get. Look at the following output as an example:<p class="source-code">Please input a number</p><p class="source-code">5</p><p class="source-code">Please input another number</p><p class="source-code">0</p><p class="source-code">Tried to divide by zero. Let's start again …</p><p class="source-code">Please input a number</p><p class="source-code">5</p><p class="source-code">Please input another number</p><p class="source-code">s</p><p class="source-code">You did not input a number. Let's start again …</p><p class="source-code">Please input a number</p><p class="source-code">5</p><p class="source-code">Please input another number</p><p class="source-code">1</p><p class="source-code">Result: 5</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/EVsrJ">https://packt.link/EVsrJ</a>.</p></li>
</ol>
<p>In this exercise, you handled two types of exceptions that are as follows:</p>
<ul>
<li>The <strong class="source-inline">int.Parse(string str)</strong> method throws <strong class="source-inline">System.FormatException</strong> if it is not possible to convert the <strong class="source-inline">string</strong> variable into an integer.</li>
<li>The <strong class="source-inline">double Divide(int a, int b)</strong> method throws <strong class="source-inline">System.DivideByZeroException</strong> if b is 0.</li>
</ul>
<p>Now that you have seen how exceptions are handled, it is important to note a rule of thumb that will help you in your C# journey, which is that <em class="italic">you should only catch what you can or what you need to handle</em>. There are only a few situations where exception handling is really needed, as follows:</p>
<ul>
<li>When you want to <strong class="bold">mask</strong> an exception, that is, catch it and pretend that nothing happened. This is known as exception suppression. That should take place when the exception that is thrown does not impact the flow of your program.</li>
<li>When you want to control your program's execution flow to perform some alternate actions, as you did in the preceding exercise</li>
<li>When you want to catch a type of exception to throw it as another type. For instance, when communicating with your web API, you might see an exception of type <strong class="source-inline">HttpException</strong> that indicates that the destination is unreachable. You could make use of a custom exception here, such as <strong class="source-inline">IntegrationException</strong>, to indicate more clearly that it happened in a part of your application that performs some integrations with external APIs.</li>
</ul>
<p>The <strong class="source-inline">throw</strong> keyword can also be used to intentionally stop the program execution flow in certain cases. For example, consider that you are creating a <strong class="source-inline">Person</strong> object and that the <strong class="source-inline">Name</strong> property should not be <strong class="source-inline">null</strong> at the time of creation. You can enforce on this class a <strong class="bold">contract</strong> that says: if these parameters are not correctly provided, it cannot be used. Typically, you would do so by throwing <strong class="source-inline">System.ArgumentException</strong> or <strong class="source-inline">System.ArgumentNullException</strong>, as in the following snippet, which uses <strong class="source-inline">ArgumentNullException</strong> to do so:</p>
<p class="source-code">class Person</p>
<p class="source-code">{</p>
<p class="source-code">Person(string name)</p>
<p class="source-code">     {</p>
<p class="source-code">if (string.IsNullOrWhiteSpace(name)) throw new ArgumentNullException(nameof(name));</p>
<p class="source-code">Name = name;</p>
<p class="source-code">     }</p>
<p class="source-code">    String Name { get ; set; }</p>
<p class="source-code">}</p>
<p>Here, if the value of the <strong class="source-inline">name</strong> argument is <strong class="source-inline">null</strong> or if you only enter space characters, <strong class="source-inline">ArgumentNullException</strong> is thrown, and the program does not execute successfully. The null/white space condition is checked with the help of the <strong class="source-inline">IsNullOrWhiteSpace</strong> function, which can be used for string variables.</p>
<p>Now it's time to practice all that you learned in the previous sections through an activity.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>Activity 1.01: Creating a Guessing Game</h2>
<p>To complete this activity, you need to create a guessing game using the concepts you have learned about and practiced so far in this chapter. In this game, first, a random number from one to 10 must be generated, not to be output to the console. The console should then prompt the user to input a number and then guess which random number has been generated, and the user should get a maximum of five chances. </p>
<p>Upon every incorrect input, a warning message should be displayed, letting the user know how many chances they have left, and if all five chances are exhausted with incorrect guesses, the program terminates. However, once the user guesses correctly, a success message should be displayed, before the program terminates.</p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a variable called <strong class="source-inline">numberToBeGuessed</strong> that is assigned to a random number within C#. You can use the following snippet to do so:<p class="source-code">new Random().Next(0, 10)</p></li>
</ol>
<p>This generates a random number for you, between <strong class="source-inline">0</strong> and <strong class="source-inline">10</strong>. You could replace <strong class="source-inline">10</strong> with a higher number if you wanted to make the game a little more difficult, or with a smaller number to make it easier, but for this activity, you will use <strong class="source-inline">10</strong> as the maximum value.</p>
<ol>
<li value="2">Create a variable called <strong class="source-inline">remainingChances</strong> that will store the remaining number of chances that the user has.</li>
<li>Create a <strong class="source-inline">numberFound</strong> variable and assign a <strong class="source-inline">false</strong> value to it.</li>
<li>Now, create a <strong class="source-inline">while</strong> loop that will execute while there are still some chances remaining. Within this loop, add code to output the number of chances remaining, until the correct guess is made. Then, create a variable called <strong class="source-inline">number</strong> that will receive the <strong class="bold">parsed</strong> integer for the user input. Finally, write code to check whether the <strong class="source-inline">number</strong> variable is the correct guess, and assign the value <strong class="source-inline">true</strong> to the <strong class="source-inline">numberFound</strong> variable if so. If not, the number of remaining chances should be reduced by <strong class="source-inline">1</strong>.</li>
<li>Finally, add code to inform users whether they have guessed the number correctly. You can output something such as <strong class="source-inline">Congrats! You've guessed the number with {remainingChanges} chances left!</strong> if they guessed correctly. If they ran out of chances, output <strong class="source-inline">You're out of chances. The number was {numberToBeGuessed}.</strong>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p></li>
</ol>
<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Summary</h1>
<p>This chapter gave you an overview of the fundamentals of C# and what it looks like to write programs with it. You explored everything from the variable declaration, data types, and basic arithmetic and logical operators to file and exception handling. You also explored how C# allocates memory while dealing with value and reference types.</p>
<p>In the exercises and activities in this chapter, you were able to solve some real-world problems and think of solutions that can be implemented with this language and its resources. You learned how to prompt for user inputs in console apps, how to handle files within a system, and finally, how to deal with unexpected inputs through exception handling. </p>
<p>The next chapter will cover the essentials of Object-oriented programming, diving deeper into the concept of classes and objects. You will also learn about the importance of writing clean, concise code that is easy to maintain, and the principles you can follow for writing such code.</p>
</div>
<div>
<div class="Content" id="_idContainer101">
</div>
</div>
<div>
<div class="Content" id="_idContainer102">
</div>
</div>
<div>
<div class="Content" id="_idContainer103">
</div>
</div>
</div>
</body></html>