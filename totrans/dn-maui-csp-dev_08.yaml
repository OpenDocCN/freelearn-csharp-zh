- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Storing and Retrieving Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和检索数据
- en: You now have all the fundamentals to create and navigate pages, layouts, and
    the controls used to populate pages. Congratulations! You are now a .NET MAUI
    programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在拥有了创建和导航页面、布局以及用于填充页面的控件的所有基础知识。恭喜！您现在是一名.NET MAUI程序员。
- en: This chapter begins the intermediate section of the book, in which you will
    see how to store and retrieve data and then create unit tests – both critical
    aspects of writing real-world and, especially, enterprise apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始介绍本书的中间部分，其中您将了解如何存储和检索数据，然后创建单元测试——这两个都是编写现实世界应用，尤其是企业应用的关键方面。
- en: Programs interact with data, and most need to store that data after an app closes
    and restore it as needed when the app resumes. In this chapter, we will consider
    two variations on this – long-term persistence of user preferences and long-term
    database storage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 程序与数据交互，大多数需要在应用关闭后存储数据，并在应用恢复时按需恢复。在本章中，我们将考虑两种变体——用户偏好的长期持久化和长期数据库存储。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Storing user preferences
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用户偏好
- en: Storing to a database on your device
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的设备上存储到数据库
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with this chapter, you will need Visual Studio. You will also
    install another `NuGet` package, as shown later in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要Visual Studio。您还将安装另一个`NuGet`包，如本章后面所示。
- en: 'The source code for the finished code in this chapter can be found here: [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence).
    To follow along, you will need to use the code from the previous chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成代码的源代码可以在以下位置找到：[https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence)。要跟随本章内容，您需要使用上一章的代码。
- en: Storing user preferences
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储用户偏好
- en: Most apps allow a user to set preferences that can be stored on a phone and
    retrieved, typically when the app starts. .NET MAUI provides a service for this,
    easily storing *key/value pairs*, such as theme preferences, the last date used,
    the login name, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用允许用户设置可以存储在手机上并在应用启动时检索的偏好设置。.NET MAUI提供了这项服务，可以轻松存储*键/值对*，例如主题偏好、最后使用日期、登录名等。
- en: '.NET MAUI provides the `IPreferences` interface to help store these preferences.
    With this, and the associated `Preferences` class (both in the `Microsoft.Maui.Storage`
    namespace), you can store string keys and values of any of the following types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI提供了`IPreferences`接口来帮助存储这些偏好。使用它以及相关的`Preferences`类（都在`Microsoft.Maui.Storage`命名空间中），您可以存储以下类型的字符串键和值：
- en: '`Boolean`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔`'
- en: '`Double`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`双精度浮点数`'
- en: '`Int` (`int32`, `single`, and `int64`)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`（`int32`、`single`和`int64`）'
- en: '`String`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`DateTime`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`'
- en: Persisting DateTime
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化日期时间
- en: '`DateTime` values are stored as 64-bit integers and use the `ToBinary` and
    `FromBinary` methods to encode and decode respectively.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`值存储为64位整数，并使用`ToBinary`和`FromBinary`方法进行编码和解码。'
- en: Let’s create a `UserPreferences` page with a short form to gather a user’s preferences.
    We’ll also add `Button`, which will display all the saved preferences and allow
    the user to delete one or all of them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`UserPreferences`页面，包含一个简短表单来收集用户的偏好。我们还将添加`Button`，用于显示所有已保存的偏好，并允许用户删除一个或全部。
- en: Name collisions
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 名称冲突
- en: We have a preferences page, which may cause a problem because we want to use
    the built-in `Preferences` object. To solve this, go to `PreferencesViewModel`
    and rename `List<Preference>` `preferenceList`. There should be no other conflicts.
    The safest way to rename is to use the Visual Studio rename functionality, which
    you can get to by putting your cursor on the name and entering `Control-R R`.
    After you rename, you may have to manually rename `ObservableProperties`, depending
    on the latest update to Visual Studio.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个偏好设置页面，这可能会引起问题，因为我们想使用内置的`Preferences`对象。为了解决这个问题，请转到`PreferencesViewModel`并将`List<Preference>`重命名为`preferenceList`。不应该有其他冲突。最安全的重命名方法是使用Visual
    Studio的重命名功能，您可以通过将光标放在名称上并输入`Control-R R`来访问它。重命名后，您可能需要根据Visual Studio的最新更新手动重命名`ObservableProperties`。
- en: 'The new `UserPreferences` page will gather three preferences from the user,
    which are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`UserPreferences`页面将从用户那里收集三个偏好，具体如下：
- en: The user’s display name
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的显示名称
- en: The preferred theme
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏好的主题
- en: Whether the app can be used on cellular or Wi-Fi only
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用是否可以在蜂窝或Wi-Fi上使用
- en: Light and dark themes
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 浅色和深色主题
- en: It has become common in apps to offer a user light and dark themes. In .NET
    MAUI, you can offer the user the choice, or if you are ambitious, you can create
    your own themes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中提供浅色和深色主题已经变得很常见。在 .NET MAUI 中，你可以为用户提供选择，或者如果你有雄心壮志，你可以创建自己的主题。
- en: We will gather but not implement a user’s preferences relating to light and
    dark themes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收集但不实现与浅色和深色主题相关的用户偏好。
- en: 'Here is the `UserPreferences` page:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `UserPreferences` 页面：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Having gathered the user’s display name, we can go on to ask them which of
    the two mutually exclusive themes they’d like. To do so, we will use `RadioButtonGroup`
    and two `RadioButtons`, initializing `Light` to be selected:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了用户的显示名称后，我们可以继续询问他们希望选择哪两个互斥主题之一。为此，我们将使用 `RadioButtonGroup` 和两个 `RadioButtons`，初始化
    `Light` 为选中状态：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now want to ask the user whether the app should only be used when connected
    to Wi-Fi. We can do this with a switch control, where `on` indicates `WiFi only`
    is `true`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想询问用户是否应该在连接到 Wi-Fi 时才使用应用程序。我们可以使用一个开关控件来实现，其中 `on` 表示 `WiFi only` 是 `true`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`[1]` Here, we introduce a new control, `RadioButton`. Radio buttons are in
    either implicit or explicit groups. Implicit groups are created by putting all
    the `RadioButtons` into the same container (for example, `VerticalStackLayout`).
    Explicit groups are given `GroupName`, as we see here.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]` 在这里，我们引入了一个新的控件，`RadioButton`。单选按钮可以是隐式或显式的组。隐式组是通过将所有 `RadioButtons`
    放入同一个容器中（例如，`VerticalStackLayout`）来创建的。显式组被赋予 `GroupName`，正如我们所看到的。'
- en: '`[2]` The user’s choice is recorded by the `SelectedValue` property.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2]` 用户的选项通过 `SelectedValue` 属性记录。'
- en: '`[3]` When defining `RadioButtons`, you can (and should) set exactly one to
    `IsChecked=true`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3]` 在定义 `RadioButtons` 时，你可以（并且应该）设置一个 `IsChecked=true`。'
- en: '`[4]` The switch control toggles off and on (`false` and `true`).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`[4]` 开关控件切换开和关（`false` 和 `true`）。'
- en: Now that we know how to gather the information the user wants to save, let’s
    take a look at the lightweight mechanism provided by .NET MAUI to do so.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何收集用户想要保存的信息，让我们看看 .NET MAUI 提供的轻量级机制来完成这项任务。
- en: UserPreferencesViewModel
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserPreferencesViewModel
- en: 'As you might expect, the first thing we’ll do is create properties for the
    bound controls:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，我们首先会为绑定的控件创建属性：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to handle the `SavePreferences` command. We do this using the
    .NET MAUI `Preferences` object, calling the static `Set` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理 `SavePreferences` 命令。我们通过使用 .NET MAUI 的 `Preferences` 对象，调用静态的 `Set`
    方法来完成：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: .NET MAUI will handle the persistence for us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 将为我们处理持久性。
- en: Now that we’ve created the page, let’s set up navigation to get to it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了页面，让我们设置导航以到达它。
- en: Navigating to UserPreferences
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航到用户偏好
- en: 'We need a way to get to our new page. A typical place to put this would be
    an `Button` as the last item in `VerticalStackLayout`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来访问我们新的页面。一个典型的放置位置是将 `Button` 作为 `VerticalStackLayout` 的最后一个项目：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `OnPreferences` command simply navigates to our new page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPreferences` 命令简单地导航到我们的新页面：'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Make sure you register the `userpreferences` page in `AppShell` before invoking
    this method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在调用此方法之前在 `AppShell` 中注册 `userpreferences` 页面。
- en: 'The page isn’t pretty, but it is ready to gather a user’s preferences, as shown
    in the following figure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 页面可能看起来并不美观，但它已经准备好收集用户的偏好，如下所示：
- en: '![Figure 8.1 – The preferences page'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 偏好页面'
- en: '](img/Figure_8.1_B19723.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B19723.jpg)'
- en: Figure 8.1 – The preferences page
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 偏好页面
- en: A user is now able to set their preferences. The next time they start up the
    app, we’ll want to retrieve those preferences and set the app accordingly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以设置他们的偏好。下次他们启动应用程序时，我们将想要检索这些偏好并相应地设置应用程序。
- en: Retrieving the preferences
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索偏好
- en: When a user closes the app, the preferences are preserved. The next time we
    return to the preferences page, we should see the preferences restored. We accomplish
    this using the `Get` method on `Preferences.Default`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户关闭应用程序时，偏好将被保留。下次我们返回到偏好页面时，我们应该看到偏好已恢复。我们通过在 `Preferences.Default` 上使用 `Get`
    方法来实现这一点。
- en: 'The `Get` method takes two parameters, the *key* and *a default value*. We’ll
    put this in the `ViewModel` constructor so that the preferences page is populated
    when it is displayed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` 方法接受两个参数，*键*和*默认值*。我们将将其放在 `ViewModel` 构造函数中，以便在显示时填充偏好页面：'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the first argument to `Get` is the key, as defined in the `Set` method
    in the `SavePreferences` method. The second argument is the default value that
    will be provided if the key is not present.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Checking for a key
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: While you don’t have to check that a key exists before trying to retrieve it,
    there are times when you’ll want to differentiate between the value you get back
    being the default value or the value that is actually stored (for example, is
    `WiFiOnly` `false` because it really is `false`, or because that key doesn’t exist
    and you received the default value?).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage this, you can use the `ContainsKey` method on `Preferences.Default`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`bool knowsWifi =` `Preferences.DefaultContainsKey("WifiOnly");`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The user can now store their preferences, and in theory, they can be restored.
    Let’s make sure that this is working.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Testing the persistence
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see that this works, navigate to the `UserPreferences` page by way of the
    `UserPreferences` page, you should see that your entered values have been restored.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Clear
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to clear a specific `UserPreference`, use the `Remove` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`Preferences.Default.Remove("DisplayName");`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove them all, use the `Clear` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`Preferences.Default.Clear()`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The `Preferences` interface is designed to hold simple data in key/value pairs.
    Microsoft warns against storing long strings, as it may negatively affect performance.
    If you need to store more complex or larger data, you’ll want to use a database,
    and the database of choice for many .NET MAUI developers is **SQLite**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The lightweight persistence mechanism is great for storing relatively short
    strings and other primitives, but if you are going to store substantial data,
    you’ll need a real database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Storing to a database on your device
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of contenders for storing data on your device. The most popular
    is SQLite, which is an open source, small, fast, and highly reliable database.
    It is the most used database in the world and is built into all mobile phones
    and most computers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Installing SQLite
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, install the latest version of the **sqlite-net-pcl** NuGet package,
    as shown in *Figure 8**.2*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Installing sqlite-net-pcl'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B19723.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Installing sqlite-net-pcl
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Installing the correct package
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of SQLite packages available on NuGet. The one you want is
    **sqlite-net-pcl** and has the author **SQLite-net**, as shown in *Figure 8**.3*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The author should be SQLite-net'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B19723.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The author should be SQLite-net
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Once `sqlitepclraw.bundle_green` and if it is not automatically installed, manually
    install **SQLitePCLRaw.bundle_green**, as shown in *Figure 8**.4*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Installing SQLitePCLRaw.bundle_green'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B19723.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Installing SQLitePCLRaw.bundle_green
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: With the packages installed, you are ready to set up your program to create
    and use an SQLite database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with SQLite
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create your database, you’ll need to store the database filename and its
    path among other constant values. To do so, right-click on your project and create
    a `Constants.cs` file. For convenience, I’ll create a `Database` folder and place
    it there:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的数据库，你需要存储数据库文件名及其路径以及其他常量值。为此，右键单击你的项目并创建一个 `Constants.cs` 文件。为了方便，我将创建一个
    `Database` 文件夹并将其放置在那里：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`[1]` Set the name for your database. Feel free to use the name as shown or
    rename it to whatever you like.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]` 为你的数据库设置名称。你可以使用显示的名称，也可以将其重命名为你喜欢的任何名称。'
- en: '`[2]` Set the flags for how the file should be managed. Here, we’ve set it
    to read/write mode, to create the database if it doesn’t exist, and finally, to
    enable multithreaded database access.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2]` 设置文件应该如何管理的标志。在这里，我们将其设置为读写模式，如果不存在则创建数据库，最后启用多线程数据库访问。'
- en: '`[3]` Append the database filename we created earlier to the directory name
    for the app.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3]` 将我们之前创建的数据库文件名附加到应用程序的目录名上。'
- en: With these constants established, we’re ready to create the database. We’ll
    encapsulate that work in a class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了这些常量之后，我们就可以创建数据库了。我们将把这个工作封装在一个类中。
- en: The Database class
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库类
- en: It is a common pattern to wrap a database access layer in a class, abstracting
    it away and decoupling it from the rest of the app. We’ll put all the query logic
    into this class. This centralization of database concerns will help make our app
    scalable over time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库访问层包装在类中是一种常见的模式，它可以抽象化它，使其与应用程序的其余部分解耦。我们将把所有的查询逻辑放入这个类中。这种数据库关注点的集中化将有助于使我们的应用程序随着时间的推移而可扩展。
- en: 'The class will need an `Init()` method to create the database and our first
    table. To get us started, let’s create a table to hold all our preferences:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该类需要一个 `Init()` 方法来创建数据库和我们的第一个表。为了让我们开始，让我们创建一个表来存储所有我们的首选项：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`[1]` Declare an object of type `SQLiteAsyncConnection` and name it `Database`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]` 声明一个类型为 `SQLiteAsyncConnection` 的对象，并将其命名为 `Database`。'
- en: '`[2]` If it already exists, then return (that is, treat it as a singleton).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2]` 如果它已经存在，则返回（即，将其视为单例）。'
- en: '`[3]` Create `SQliteAsyncConnection`, passing in the path and flags from the
    `constant` class.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3]` 创建 `SQliteAsyncConnection`，传入 `constant` 类中的路径和标志。'
- en: '`[4]` Create our first table, declaring the type of object we’ll store in the
    table (the `Preference` objects).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`[4]` 创建我们的第一个表，声明我们将存储在表中的对象类型（即 `Preference` 对象）。'
- en: We are ready to start using the database, to add and manipulate our table.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始使用数据库，添加和操作我们的表。
- en: CRUD
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRUD
- en: As is true for virtually all databases, we’ll want to support **Create, Read,
    Update, and Delete** (**CRUD**). For now, let’s just implement the methods to
    create and read records. The method to create is typically combined with the update
    method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有数据库来说，我们都希望支持 **创建、读取、更新和删除**（**CRUD**）。现在，让我们只实现创建和读取记录的方法。创建方法通常与更新方法结合使用。
- en: Create/update
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建/更新
- en: We’re going to want to know whether a `Preference` is already in the table so
    that we know, when given a `Preference` record, whether to add it or update it.
    It will need a unique ID. Fortunately, SQLite is very good at providing IDs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要知道一个 `Preference` 是否已经在表中，这样当我们得到一个 `Preference` 记录时，我们知道是添加它还是更新它。它需要一个唯一的
    ID。幸运的是，SQLite 在提供 ID 方面非常出色。
- en: 'Start by opening `Preference.cs` in the `Model` folder and adding an `id` property:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在 `Model` 文件夹中打开 `Preference.cs` 并添加一个 `id` 属性：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, return to `ForgetMeNotDemoDatabase.cs` and add the `SavePreference` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回到 `ForgetMeNotDemoDatabase.cs` 并添加 `SavePreference` 方法：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`[1]` Our `SavePreference` method takes the type (`Preference`) as an argument
    and returns the number of rows updated (in this case, zero or one).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]` 我们的 `SavePreference` 方法接受一个类型（`Preference`）作为参数，并返回更新的行数（在这种情况下，零或一）。'
- en: '`[2]` Call `Init` on the database each time you take an action.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2]` 每次执行操作时在数据库上调用 `Init`。'
- en: '`[3]` Check to see whether the `Preference` object has `Id`. Since `Id` is
    an `int` type, it defaults to zero, so if it is not zero, we need to do an update;
    otherwise, we need to do an insert.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3]` 检查 `Preference` 对象是否有 `Id`。由于 `Id` 是 `int` 类型，它默认为零，所以如果它不是零，我们需要进行更新；否则，我们需要进行插入。'
- en: Now that we can create (or update) a record, let’s write code to read that data
    out of the database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建（或更新）一个记录，让我们编写代码来从数据库中读取这些数据。
- en: Read
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取
- en: 'We’ll want to be able to get all our preferences back from the database. For
    that, we’ll create a `GetPreferences` method that returns a list of `Preference`
    objects:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将希望能够从数据库中获取所有我们的首选项。为此，我们将创建一个 `GetPreferences` 方法，它返回一个 `Preference` 对象的列表：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Soft deletion
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除
- en: When we write our `Delete` method, we probably will want to do a *soft* deletion
    – that is, mark it as deleted rather than actually removing it. For this to work,
    you’ll need to add another property to `Preference`, `Deleted`, and also `int`.
    Our read statement will then take a `where` clause, checking that the `Deleted`
    property is equal to zero.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写`Delete`方法时，我们可能想要进行一次*软删除*——也就是说，将其标记为已删除而不是实际删除。为了实现这一点，你需要在`Preference`中添加另一个属性`Deleted`，以及`int`类型。然后，我们的读取语句将包含一个`where`子句，检查`Deleted`属性是否等于零。
- en: Once you have a database design, you need to decide whether you are going to
    keep the database locally on a device or in the cloud, accessed through your API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了数据库设计，你需要决定你是打算在设备上本地保留数据库，还是在云端通过你的API访问。
- en: Local or remote?
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地还是远程？
- en: A design question for this app is whether we want to store our preferences,
    buddies, invitations, and so forth in tables on a device, or instead use a web
    service and database in the cloud.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，设计问题在于我们是否想在设备上的表里存储偏好、好友、邀请等等，或者使用云中的网络服务和数据库。
- en: To facilitate a secure interaction when sending and receiving invitations and
    lists of preferences, we’ve decided to move all the database operations to the
    cloud. However, everything in this chapter is not only relevant to `ForgetMeNotDemo`;
    it will be of use to you if you decide to store data locally on a phone or computer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于在发送和接收邀请以及偏好列表时进行安全交互，我们决定将所有数据库操作移至云端。然而，本章中的内容不仅与`ForgetMeNotDemo`相关；如果你决定在手机或电脑上本地存储数据，它也会对你有所帮助。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed two ways of storing data. The simplest and most
    lightweight is to use the preferences facilities of .NET MAUI. This is great if
    all you need is to store primitives and short strings that are targeted at persisting
    a user’s preferences for a program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了两种存储数据的方式。最简单且最轻量级的是使用.NET MAUI的偏好设置功能。如果你只需要存储原始数据和针对持久化程序用户偏好的短字符串，这非常合适。
- en: If you need to persist more substantial data, you’ll need a database, and by
    far the most popular type for on-device storage is SQLite. We examined the CRUD
    functionality of SQLite and then pointed out the alternative of not storing everything
    on a device but, rather, storing in the cloud and gaining access through a program’s
    API.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要持久化更大量的数据，你需要一个数据库，而对于设备上的存储来说，最流行的类型无疑是SQLite。我们检查了SQLite的CRUD功能，然后指出了一种替代方案，即不是在设备上存储所有内容，而是在云中存储并通过程序的API访问。
- en: Quiz
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 习题
- en: What is the class that handles simple storage of user data in key/value pairs?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理用户数据简单存储的键/值对的类是什么？
- en: What two values do we pass to the `Get` method to retrieve the stored value?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向`Get`方法传递哪两个值来检索存储的值？
- en: Which `NuGet` packages do we need to work with SQLite in .NET MAUI?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要哪些`NuGet`包来在.NET MAUI中与SQLite一起工作？
- en: What type of object do we use to create a table?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用什么类型的对象来创建表？
- en: You try it
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你来试试
- en: Add the remaining CRUD operations to the `Preference` table (for example, delete
    and get by ID).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将剩余的CRUD操作添加到`Preference`表（例如，删除和按ID获取）。
