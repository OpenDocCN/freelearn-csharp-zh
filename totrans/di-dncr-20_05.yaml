- en: Object Composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象组合
- en: In [Chapter 4](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml), *Dependency Injection
    in ASP.NET Core*, we got an insight into Dependency Injection with .NET Core and
    ASP.NET Core with default DI Container. We explored how to apply DI to different
    components of the application like controllers and views. Now it's time to deep
    dive into the actual fundamentals behind Dependency Injection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml)，“ASP.NET Core中的依赖注入”，我们了解了.NET
    Core和ASP.NET Core的依赖注入以及默认DI容器。我们探讨了如何将DI应用于应用程序的不同组件，如控制器和视图。现在是时候深入探讨依赖注入背后的实际基础了。
- en: Before moving forward with the main topic, we need to first understand why do
    we even care to read about this topic. The programming world is surrounded with
    objects and their interactions. We achieve certain solutions or build features
    getting help from classes that we generate for two basic reasons that are **code
    reuse** and **maintainability**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论主要主题之前，我们首先需要了解为什么我们要关心阅读这个主题。编程世界充满了对象及其交互。我们通过从我们为两个基本原因生成的类中获取帮助来实现某些解决方案或构建功能，这两个基本原因是**代码重用**和**可维护性**。
- en: Now you might ask me why create classes at all! Yes, I second you, unless you
    ask me to alter code after some days. Then, even I can't help you because that
    will be a nightmare for me. And you know why? That is because I might have to
    repeat the codes (you have already written) in my new classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问我为什么还要创建类！是的，我同意你的看法，除非你让我几天后修改代码。那时，即使是我也无法帮助你，因为那对我来说将是一场噩梦。你知道为什么吗？那是因为我可能不得不在我的新类中重复（你已经写过的）代码。
- en: Suppose you have a class named `Customer` with the properties `CustomerId`,
    `FirstName`, `LastName`, `Email`, `MobileNumber`, `Address1`, `Address2`, `City`
    and so on. I come in and start working on another entity named as `Seller` with
    the properties `SellerId`, `FirstName`, `LastName`, `Email`, `MobileNumber`, `Address1`,
    `Address2`, `City` and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`Customer`的类，具有`CustomerId`、`FirstName`、`LastName`、`Email`、`MobileNumber`、`Address1`、`Address2`、`City`等属性。我介入并开始处理另一个实体，名为`Seller`，具有`SellerId`、`FirstName`、`LastName`、`Email`、`MobileNumber`、`Address1`、`Address2`、`City`等属性。
- en: I think you are smart enough to identify the problem. We can see the properties
    which are *italicised* are getting repeated. One solution to this problem would
    be to create another class, something named `User` with all those common properties.
    Then, the `Customer` and `Seller` classes become its children. Thus, we will achieve
    a simple design to deal with future entities as well. I can easily reuse the `User`
    class to create some other child class, which would inherit the common properties
    if needed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你足够聪明，能够识别这个问题。我们可以看到那些被*斜体*标注的属性正在重复。解决这个问题的一个方法就是创建另一个类，比如命名为`User`的类，包含所有这些公共属性。然后，`Customer`和`Seller`类就变成了它的子类。这样，我们将实现一个简单的设计来处理未来的实体。我可以轻松地重用`User`类来创建其他子类，如果需要的话，这些子类将继承公共属性。
- en: 'Therefore, this chapter plays an important role in helping you grab these relationships.
    Designing a complex class with smaller flexible and reusable classes is an essential
    part of a software project, which will be the focused of this chapter. The following
    are the key topics that we will cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这一章在帮助你掌握这些关系方面起着重要的作用。设计一个由更小、更灵活、可重用的类组成的复杂类是软件项目的一个基本部分，这将是本章的重点。以下是我们将要涵盖的关键主题：
- en: Relationships
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系
- en: Composition
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Aggregation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Association
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联
- en: Inheritance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Composition over Inheritance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: The importance of Object Composition in Dependency Injection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象组合在依赖注入中的重要性
- en: Object Composition in .NET Core 2.0 Console and MVC Apps
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.0控制台和MVC应用中的对象组合
- en: Understanding object relationships
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象关系
- en: Let's try to understand object relationships by first considering human relationships.
    The examples may not be the aptest but if we want to learn about object relationships,
    then why not look into it?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过考虑人类关系来尝试理解对象关系。这些例子可能不是最恰当的，但如果我们要学习对象关系，为什么不看看它呢？
- en: You depend on your parents till you get a job
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在你找到工作之前依赖你的父母
- en: You have a wife and two children
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个妻子和两个孩子
- en: Trees have blossom and leaves on them
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树上长着花朵和叶子
- en: A motherboard is part of a computer
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主板是计算机的一部分
- en: All these relationships possess unique characteristics. Let me simplify my statement.
    You depend on your parents. However, if they become jobless, you are not going
    to die. You will find some way to deal with the situation. On the contrary, if
    a tree dies, its blossom and leaves will die eventually. The relationship between
    the tree and its parts are tightly coupled. After the tree gets a life (instantiated),
    within a short period of time, its parts come to life as well. A motherboard without
    a computer is useless. It comes into play when it becomes a component of a computer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些关系都具有独特的特征。让我简化我的说法。你依赖于你的父母。然而，如果他们失业了，你不会死去。你会找到某种方法来应对这种情况。相反，如果一棵树死了，它的花朵和叶子最终也会死去。树与其部分之间的关系是紧密耦合的。一旦树获得生命（实例化），在很短的时间内，其部分也会苏醒。没有电脑的主板是没有用的。它只有在成为电脑的组成部分时才会发挥作用。
- en: 'Let''s consider the following code snippet to understand the relationship between
    classes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段来理解类之间的关系：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have one `Organisation` class and `Packt`, being an organization, derives
    the parent class `Organisation`. This relationship is denoted as *is a* relationship
    because `Packt` is an organization. `Account` is a class, which can become *a
    part of* a `Packt` class. Thus, there is another relationship between `Packt`
    and `Account`. The name of the relationship is *a part of***.**
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Organisation`类，而`Packt`作为一个组织，从父类`Organisation`派生。这种关系表示为“是一个”关系，因为`Packt`是一个组织。`Account`是一个类，它可以成为`Packt`类的一部分。因此，`Packt`和`Account`之间存在另一种关系。这种关系的名称是“一部分”。**
- en: Notice the method `PrintPacktInfo()` inside `Packt` class, which prints all
    information regarding `Packt`. However, that is not all, because you can see there
    is an `Account` class instance generated inside the method by which we are able
    to print the account information of `Packt`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Packt`类内部的`PrintPacktInfo()`方法，它打印有关`Packt`的所有信息。然而，这还不是全部，因为你可以看到，在该方法内部生成了一个`Account`类实例，通过它我们能够打印出`Packt`的账户信息。
- en: 'The `Main` method looks as follows, where we create an instance of `Packt`
    and provide any necessary details through properties and then call `PrintPacktInfo()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法如下所示，我们创建一个`Packt`实例，并通过属性提供任何必要的详细信息，然后调用`PrintPacktInfo()`：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code produces the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码产生以下输出：
- en: '![](img/c1e32247-cae9-4cf4-9e49-f75a0129a769.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1e32247-cae9-4cf4-9e49-f75a0129a769.png)'
- en: The important thing to take away from this example is the way the `Packt` class
    depends on the `Account` class. `Dependency` is generated inside the `Packt` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们应该吸取的重要信息是`Packt`类对`Account`类的依赖方式。`依赖`是在`Packt`类内部生成的。
- en: Like the preceding one, we can find patterns, relationships, and hierarchies
    in programming. Let's investigate these in more detail and learn how to improve
    code reusability and elasticity of classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的例子一样，我们可以在编程中找到模式、关系和层次结构。让我们更详细地调查这些内容，并学习如何提高代码的可重用性和类的弹性。
- en: Object Composition
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象组合
- en: 'When I searched for the word composition in Google, the first thing I saw was:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在谷歌搜索“词组成”时，首先看到的是：
- en: the nature of something's ingredients or constituents; the way in which a whole
    or mixture is made up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 某物成分或构成的本质；整体或混合物的构成方式。
- en: Now it's very simple to guess what Object Composition would be. Objects collectively
    mix themselves to constitute (be a part of) complex objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易猜测对象组合是什么。对象集体混合自身以构成（成为）复杂对象的一部分。
- en: A simple real life example would be a car whose whole body consists of different
    types of components like engine, break, gear, battery, door, etc. Thus, these
    parts are actually the building blocks of the car and are composed in a very innovative
    way by the maker of the car.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的现实生活例子就是一辆车，其整个车身由不同类型的组件组成，如发动机、刹车、齿轮、电池、车门等。因此，这些部件实际上是汽车的构建块，并且由汽车制造商以非常创新的方式组合在一起。
- en: Likewise, as we discussed, the `Account` class reference inside the `Packt`
    class method in the last section, which generates a relationship among them. We
    can consider that as a dependency too, as we can't execute the method of the `Packt`
    class without an instance of `Account` class. Clearly, we can say that the `Packt`
    object composes itself with the help of the `Account` instance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如我们之前讨论的，上一节中`Packt`类方法内部的`Account`类引用，这在其之间生成了一种关系。我们可以将其视为一种依赖关系，因为我们不能在没有`Account`类实例的情况下执行`Packt`类的函数。显然，我们可以这样说，`Packt`对象通过`Account`实例的帮助来组合自身。
- en: Did you notice the bracketed phrase in the first paragraph *be* *a part of*?
    Confused! Let's discuss again and get hold of this phrase. In other words, this
    phrase can also be represented as *has a,* if I form the sentence from the complex
    object point of view. Refer the lines below.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了第一段中括号内的短语*是*一部分？困惑！让我们再次讨论并掌握这个短语。换句话说，这个短语也可以表示为*有*，如果我从一个复杂对象的角度来构建这个句子。参考下面的行。
- en: A computer *has a* keyboard. (Keyboard *is a part of* computer)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台计算机*有一个*键盘。（键盘*是*计算机的一部分）
- en: A car *has an* engine. (Engine *is a part of* car)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一辆车*有一个*引擎。（引擎*是*车的一部分）
- en: It's pretty clear now, as you can see how these complex objects are made up
    of small objects conceptualizing Object Composition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经很清楚了，正如你所见，这些复杂对象是如何由小对象组成，这些小对象就是对象组合的概念。
- en: As you already know, different fundamental data types like `int`, `string`,
    boolean, and so on, or other class types, can be packaged into one structure or
    another class type, therefore, classes are often considered composite types.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，不同的基本数据类型，如`int`、`string`、布尔值等，或者其他的类类型，可以被包装到一个结构或另一个类类型中，因此，类通常被认为是组合类型。
- en: The most important benefit of applying this concept to your projects is to get
    more easily manageable parts. Not only does it reduces the complexity of the application,
    but it also helps us to write code faster. Another noticeable advantage is code
    reuse, which leads to fewer errors as you will be using codes which have already
    been verified after testing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个概念应用到你的项目中最重要的好处是获得更容易管理的部分。这不仅减少了应用程序的复杂性，还帮助我们更快地编写代码。另一个明显的优势是代码重用，这导致错误更少，因为你将使用经过测试后已经验证的代码。
- en: Types of Object Composition
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象组合类型
- en: There are two subtypes of Object Composition, **Composition** and **aggregation**.
    Let's discuss one by one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对象组合有两种子类型，**组合**和**聚合**。让我们逐一讨论。
- en: Composition
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: A Composition is a way through which you can bind objects together. One object
    can contain another object of the same/another class as a building block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种将对象绑定在一起的方式。一个对象可以包含另一个对象，无论是同一类还是另一类，作为构建块。
- en: In other words, in our last example, `Packt` was dependent upon the `Account`
    class for its operation. The instance is created by the `Packt` class, giving
    life to it and then operated some function with the instance. You can add another
    class like `Packt` and do the same using an `Account` instance. Thus, you are
    trying to compose the objects to form a more complex one, which enables us to
    execute behavior (methods) of all composed/part objects with one composite object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在我们上一个例子中，`Packt`依赖于`Account`类来运行。实例是由`Packt`类创建的，给它生命，然后使用实例执行一些功能。你可以添加另一个类如`Packt`，并使用`Account`实例做同样的事情。因此，你试图组合对象以形成一个更复杂的对象，这使得我们可以通过一个复合对象执行所有组合/部分对象的行为（方法）。
- en: The following are the relationships, which is satisfied by the object and it's
    member or part, qualify as a Composition.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由对象及其成员或部分满足的关系，符合组合的条件。
- en: '**The part** **(member) is a component of the object (class)**: As we have
    already discussed, the part or smaller class should be a part of the bigger complex
    class. For example, your kidney is a part of your body.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）是对象（类）的组成部分**：正如我们已经讨论过的，部分或较小的类应该是较大复杂类的组成部分。例如，你的肾脏是你的身体的一部分。'
- en: '**The part (member) can only belong to one object (class) at a time**: If the
    smaller class is referred to the complex class at a certain period, then it can''t
    be a part of other classes at the same time. For example, your kidney, which is
    a part of your body, can''t be a part of someone else''s body at the same time.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）一次只能属于一个对象（类）**：如果较小的类在某个时期被引用到复杂类中，那么它不能同时是其他类的部分。例如，你的肾脏，它是你身体的一部分，不能同时是其他人身体的一部分。'
- en: '**The part (member) has its existence managed by the object (class)**: The
    object is responsible for the existence of the parts in a Composition relationship.
    In simple words, the part is created when the object is created and destroyed
    when the object is destroyed. This means the object manages the part''s lifetime
    in such a way that the user of the object does not need to get involved. For example,
    when a body is created, the kidney is created too. When a person''s body is destroyed,
    their kidney is destroyed too. Because of this, the Composition is sometimes called
    a **Death Relationship**.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）的存在由对象（类）管理**：对象负责组合关系中部分的存在。简单来说，部分在对象创建时被创建，在对象销毁时被销毁。这意味着对象以这种方式管理部分的生命周期，使得对象的使用者不需要介入。例如，当身体被创建时，肾脏也会被创建。当一个人的身体被销毁时，他们的肾脏也会被销毁。正因为如此，组合有时被称为**死亡关系**。'
- en: '**The part (member) does not know about the existence of the object (class):**
    A particular part in a Composition doesn''t know about the existence of the whole
    object. Your kidney is unaware that it is part of a larger structure but works
    as expected. This is called a **Unidirectional Relationship**. For example, the
    body knows about the kidney, but not the other way around.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）不知道对象（类）的存在**：组合中的特定部分不知道整个对象的存在。你的肾脏不知道它是更大结构的一部分，但按预期工作。这被称为**单向关系**。例如，身体知道肾脏，但反之则不然。'
- en: If you are thinking that as body parts can be transferable, why not member classes,
    then you are assuming right. Member classes can also be transferred. Thus, the
    new larger class is now the owner of the member class and the member class is
    no more related to the previous owner unless that is transferred again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为身体部分可以转移，那么成员类为什么不能，那么你的想法是对的。成员类也可以被转移。因此，新的更大的类现在成为了成员类的所有者，而成员类不再与之前的所有者相关，除非再次转移。
- en: Consider an example
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑一个例子
- en: 'Our favorite `Student` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的`Student`类：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Come on, don''t be so surprised and please don''t scold me now. I know this
    looks like a very basic class, but that is what Composition is all about, in short.
    Don''t believe me? Alright, allow me to match those relationships with this `Student`
    class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 来吧，别这么惊讶，现在也请不要责怪我。我知道这看起来像是一个非常基础的课程，但这就是组合的本质，简而言之。你不信？好吧，让我用这个`Student`类来匹配这些关系：
- en: '**Rule 1: Part of a complex class**: You can see the class members which are
    of different types such as `Integer`, `string`, `DateTime`, `Class` and `List<Class>`
    type. `Integer`, `string`, and `DateTime` are the data types already defined inside
    the `System` namespace of .NET Framework, whereas the `Address` and `Book` classes
    are user-defined classes. All are part of a complex class `Student`. Thus, the
    first condition is satisfied.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1：复杂类的一部分**：你可以看到类成员具有不同的类型，例如`Integer`、`string`、`DateTime`、`Class`和`List<Class>`类型。`Integer`、`string`和`DateTime`是.NET
    Framework中`System`命名空间内已经定义的数据类型，而`Address`和`Book`类是用户定义的类。所有这些都是复杂类`Student`的一部分。因此，第一个条件得到了满足。'
- en: '**Rule 2: Members should belong to one object**: If I create an instance of
    the `Student` class, with a constructor, the members will only belong to the student
    object at that time. It can''t be a member of another instance. Moreover, the
    members are private, which prevents them being used by any other class.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2：成员应属于一个对象**：如果我创建一个`Student`类的实例，带有构造函数，那么这些成员在那个时刻只属于学生对象。它们不能成为另一个实例的成员。此外，成员是私有的，这阻止了它们被任何其他类使用。'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The constructor will look like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数看起来如下：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Rule 3: Members gets a life by the complex class (Death Relationship)**:
    As you can see, members don''t have any existence until we instantiate the `Student`
    class and they get destroyed when the object is dead; proving our rule 3.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则3：成员通过复杂类获得生命（死亡关系）**：正如你所见，成员在没有实例化`Student`类之前并不存在，当对象死亡时它们也会被销毁；这证明了我们的规则3。'
- en: '**Rule 4: Members are unaware of the existence of the complex object (Unidirectional
    Relationship):** The members are very obedient. They just store whatever value
    is assigned to them and don''t even bother about who is assigning them for what
    reasons. The complex instance is their parent but these members behave like orphans
    and don''t recognize it. Likewise, we don''t mind what they are doing because
    our rule 4 is proved.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则4：成员不知道复杂对象的存在（单向关系）：**成员非常听话。他们只存储分配给他们的任何值，甚至不关心是谁以及为什么分配给他们。复杂实例是他们的父级，但这些成员表现得像孤儿一样，不认识它。同样，我们不在乎他们在做什么，因为我们的规则4已经得到证明。'
- en: Another important thing to note here is that the complex class can have a multiplicative
    member like `List<Book> Books`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的另一件重要的事情是，复杂类可以有一个乘法成员，例如`List<Book> Books`。
- en: 'Do you know the shortcut to create a constructor? Just type **ctor** at the
    line where you want the constructor and then hit the *Tab* key two times. You
    will see an empty constructor block available for you. Moreover, Visual Studio
    tooltip tells you how to handle the command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道创建构造函数的快捷键吗？只需在你想创建构造函数的行中输入**ctor**，然后按两次*Tab*键。你会看到一个空构造函数块可供使用。此外，Visual
    Studio的提示信息会告诉你如何处理这个命令：
- en: '![](img/211734ba-9e84-4120-bcf5-997859ff6c4a.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/211734ba-9e84-4120-bcf5-997859ff6c4a.png)'
- en: Contrasting features of Composition
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合的对比特性
- en: The parts are created with the composite class's creation. That means the composite
    class is responsible for the creation. Also, the destruction of the part depends
    upon the destruction of their creator composite class. However, rules are meant
    to be broken and that happens in the case of Composition too.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 部件是在组合类的创建过程中创建的。这意味着组合类负责创建。此外，部件的销毁取决于其创建者组合类的销毁。然而，规则是为了被打破的，这在组合的情况下也是如此。
- en: 'Consider the following scenarios:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：
- en: The creation of a part is postponed till it is actually used. For instance,
    our `Student` class doesn't create the list of books until the user or any other
    method assigns some data to it.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部件的创建被推迟到实际使用时。例如，我们的`Student`类不会创建书籍列表，直到用户或任何其他方法向它分配一些数据。
- en: A Composition assigns the responsibility of destructing the part to some other
    object. We are already aware of such routine named **Garbage Collector**, who
    manages the destruction of unused objects from time to time.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合将销毁部件的责任分配给其他对象。我们已经知道这样一个名为**垃圾回收器（Garbage Collector）**的常规程序，它会定期管理未使用对象的销毁。
- en: Composition acts like a guardian, where all care of the members is taken by
    the composite class. Creation, assignment, and destruction; all are mostly managed
    by the composite class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 组合就像一个守护者，所有成员的关怀都由组合类承担。创建、分配和销毁；所有这些主要都是由组合类管理的。
- en: Why are subclasses inside Composition?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类为什么在组合（Composition）内部？
- en: There is always a decision you need to take while you program. If you closely
    analyze our `Student` class, you will realize a few things. The properties of
    the `Address` class be can directly be declared inside the `Student` class instead
    of declared as a different entity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，你总是需要做出决定。如果你仔细分析我们的`Student`类，你会意识到一些事情。`Address`类的属性可以直接在`Student`类内部声明，而不是作为不同的实体声明。
- en: 'So, instead of the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，而不是以下内容：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We did this. Basically, we just separated out the address properties in a container
    class named `Address`. The following code block shows how we can extract out `Address`
    class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就是这样做的。基本上，我们只是将地址属性分离到一个名为`Address`的容器类中。以下代码块展示了我们如何提取出`Address`类：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These are some of the advantages of doing a subclass instead of directly adding
    them to the composite class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用子类而不是直接将它们添加到组合类中的优点之一：
- en: The subclass is independent and simplifies the architecture. The code seems
    very easy to understand. The actual benefit you get out of it is when you try
    to do something extra on it, in the future. Suppose, I tell you to include another
    member Street for `Address`. If you have designed address properties directly
    inside composite classes, then you have to manually go to each class and add another
    member. However, in the case of the subclass, you just need to add that to the
    subclass and all composite classes using that will get the access automatically.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类是独立的，简化了架构。代码看起来很容易理解。你从中获得的实际好处是在将来尝试对它做额外的事情时。假设，我告诉你为`Address`添加另一个成员街道。如果你直接在组合类中设计地址属性，那么你必须手动进入每个类并添加另一个成员。然而，在子类的情况下，你只需要将其添加到子类中，所有使用该子类的组合类将自动获得访问权限。
- en: The more you break down the classes into subclasses, the more you make them
    be reusable. The address class, for instance, can be reused in some other class
    as well. It is no more tightly coupled with the Composition.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将类分解成子类越多，它们就越具有可重用性。例如，地址类也可以在其他类中重用。它不再与组合紧密耦合。
- en: Due to the introduction of subclasses, the composite class is not complex anymore.
    Moreover, the subclasses can have methods defined in them which makes the life
    of the composite object easy. That is because the subclass can define it's related
    functions which can be called by the composite class. For example, if we want
    to get the full address, we can easily have a method inside the `Address` class,
    which will return a string using all those address properties. Thus, the composite
    class does not need to do anything on `Address` related stuff.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于引入了子类，组合类不再复杂。此外，子类可以在其中定义方法，这使得组合对象的生活变得简单。这是因为子类可以定义与其相关的函数，这些函数可以被组合类调用。例如，如果我们想获取完整的地址，我们可以在`Address`类中轻松地定义一个方法，该方法将使用所有地址属性返回一个字符串。因此，组合类不需要在`Address`相关的事情上做任何事情。
- en: Important notes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Thinking of a better design, such that it distributes responsibilities among
    different entities, is tough. But it is not impossible. When we start building
    the app, we don't always have full specifications or realize what could happen
    next. Eventually, when more specifications come in, we face problems as we ignore
    building subclasses for a certain common usage. Therefore, you will also see bad
    and repeated codes in many classes which can be packaged in a subclass and could
    easily be reused.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑更好的设计，以便在不同实体之间分配责任，是困难的。但这并非不可能。当我们开始构建应用程序时，我们并不总是拥有完整的规格或意识到接下来可能发生什么。最终，当更多的规格出现时，我们面临问题，因为我们忽略了为某些常见用途构建子类。因此，你也会在许多类中看到不良和重复的代码，这些代码可以封装在子类中，并且可以轻松重用。
- en: Composite or main classes should be responsible for what it is designed. A `Student`
    class is responsible for managing student information. There is no doubt that
    the address of the student is something it should handle. But, what if we get
    another entity like `Teacher` who also has an address? We have to repeat the same
    set of properties inside the `Teacher` class to achieve this. Code smell isn't
    it! That is when you should decide to separate `Address`--related information
    to another class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 组合或主要类应该负责其设计的内容。`Student`类负责管理学生信息。毫无疑问，学生的地址是它应该处理的事情。但是，如果我们得到另一个实体，比如`Teacher`，它也有地址呢？我们必须在`Teacher`类内部重复相同的属性集来实现这一点。这不是代码异味吗！这就是你应该决定将`Address`相关的信息分离到另一个类的时候。
- en: Aggregation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregation is another type of object Composition. Let's explore this in details.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是另一种类型的对象组合。让我们详细探讨这一点。
- en: 'It is the process by which you bring existing objects together to form a new
    object. At first, it looks similar to Composition. But in reality, it has differences.
    To qualify as an aggregation, the complex object and its parts must satisfy the
    following relationships:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将现有对象组合成新对象的过程。起初，它看起来与组合相似。但事实上，它有区别。要成为聚合，复杂对象及其部分必须满足以下关系：
- en: '**The part (member) is a component of the object (class)**: It is similar to
    Composition. That means the smaller object is a part of the complex object. For
    example, a person has a Google Drive folder.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）是对象（类）的组成部分**：它与组合类似。这意味着较小的对象是复杂对象的一部分。例如，一个人有一个Google Drive文件夹。'
- en: '**The part (member) can belong to more than one object (class) at a time**:
    Unlike Composition, here the member is independent of the class. It might be referenced
    by other classes as well at the same time. For example, a Drive folder can be
    shared by many users at the same time.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）可以同时属于多个对象（类）**：与组合不同，这里的成员与类是独立的。它可能同时被其他类引用。例如，一个驱动器文件夹可以同时被许多用户共享。'
- en: '**The part (member) does not have its existence managed by the object (class):**
    As the last point states the member is not tied to the complex class, so it''s
    creation and destruction is not managed by it. For example, all those people with
    whom the folder is shared have not created it. Unless they are provided with admin
    rights, they can''t delete the folder.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）的存在不由对象（类）管理**：正如最后一点所述，成员与复杂类没有绑定，因此它的创建和销毁不由它管理。例如，所有与文件夹共享的人都没有创建它。除非他们被赋予管理员权限，否则他们不能删除文件夹。'
- en: '**The part (member) does not know about the existence of the object (class):**
    The member does not know whether the complex object exists or not, same as Composition.
    For example, a person does not know if the Drive folder exists or not.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分（成员）不知道对象（类）的存在**：成员不知道复杂对象是否存在，就像组合一样。例如，一个人不知道驱动器文件夹是否存在。'
- en: Consider an example
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑一个例子
- en: 'Now, we will try to alter the `Student` class which was illustrated in the
    Composition lesson. I am doing it because we have an `Address` property there.
    See how the constructor is updated to have the address as an argument:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试修改在组合课程中展示的`Student`类。我这样做是因为那里有一个`Address`属性。看看构造函数是如何更新的，以便将地址作为参数：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is not new to you. Let's try to elaborate it. We are simply passing the
    `Address` object into the constructor, which is then assigned to the `Address`
    property of the composite class `Student`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说并不陌生。让我们试着详细说明一下。我们只是将`Address`对象传递给构造函数，然后它被分配给复合类`Student`的`Address`属性。
- en: The next confusion is what is the difference then? Let me explain. The `Address`
    property is declared inside the composite class gets created/destroyed like other
    members. But inside the constructor, we are assigning an external `Address` object
    to it. That means the composite class does not have any control over that incoming
    external object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个困惑是那么区别是什么？让我来解释。`Address`属性在复合类内部声明，其创建/销毁与其他成员一样。但在构造函数中，我们将其分配给一个外部的`Address`对象。这意味着复合类对该外部传入的对象没有任何控制权。
- en: 'The `Student` class initialization will also be altered as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`类的初始化也将按以下方式修改：'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's analyze how this change can be considered as an Aggregation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这种变化如何被视为聚合。
- en: '**Rule 1: The part (member) is a component of the object (class)**: The `Address`
    property is referenced inside the `Student` class. Thus, it becomes a part.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1：部分（成员）是对象（类）的组成部分**：`Address`属性在`Student`类中被引用，因此它成为了一个部分。'
- en: '**Rule 2: The part (member) can belong to more than one object (class) at a
    time**: I passed an `Address` object into the constructor, which is used inside
    the composite class, for further operation. However, the object `add` is pretty
    much independent as it is created by the routine (`Main`, as shown in the preceding
    code). Let me allow it to be used by another `Student` as well:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2：部分（成员）可以同时属于多个对象（类）**：我向构造函数传递了一个`Address`对象，它在复合类内部被用于进一步操作。然而，对象`add`相当独立，因为它是由例程（如前述代码中的`Main`）创建的。让我允许它也被另一个`Student`使用：'
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I know you might have some reservations about whether this will work or not.
    Here is the output for you:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能对它是否有效有所保留。以下是为你提供的输出：
- en: '![](img/d96c6715-c721-4cfb-8a68-133bc34fff36.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d96c6715-c721-4cfb-8a68-133bc34fff36.png)'
- en: Straightforward, isn't it! The `Main` method is the creator, so it can be used
    inside the scope anywhere till it is destroyed by it or by Garbage Collector.
    The `add` object is passed as a reference to both of the students. From these
    facts, we can infer that `Jayashree` and `Lipsa` and are two students who stay
    at the same address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很直接，不是吗！`Main`方法是创建者，因此它可以在其作用域内任何地方使用，直到它被它或垃圾收集器销毁。`add`对象被作为引用传递给两个学生。从这些事实中，我们可以推断出`Jayashree`和`Lipsa`是住在同一地址的两个学生。
- en: '**Rule 3: The part (member) does not have its existence managed by the object
    (class)**: Since it is wrapped inside the `Main` method, the composite object
    can''t destroy it. By the way, it did not create it either. It was `Main` who
    gave birth to that.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则3：部分（成员）的存在不由对象（类）管理**：因为它被包裹在`Main`方法中，组合对象无法销毁它。顺便说一下，它也没有创建它。是`Main`让它诞生的。'
- en: '**Rule 4: The part (member) does not know about the existence of the object
    (class)**: The `Address` object does not have any idea about these student objects.
    It is autonomous inside the `Main` block.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则4：部分（成员）不知道对象（类）的存在**：`Address`对象对这些学生对象没有任何了解。它在`Main`块内部是自主的。'
- en: Composition versus Aggregation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合与聚合
- en: 'Now that we have explored both types of Object Composition, let''s look at
    the differences:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了这两种类型的对象组合，让我们看看它们之间的区别：
- en: '| **Composition** | **Aggregation** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **组合** | **聚合** |'
- en: '| Generally, contains built-in type member variablesManages member''s creation
    and destruction | Generally contains reference variables which live out of the
    scope of the composite classDoes not manage member''s creation and destruction
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 通常包含内置类型成员变量管理成员的创建和销毁 | 通常包含超出组合类作用域的引用变量不管理成员的创建和销毁 |'
- en: While these concepts have such tiny but important differences, they can still
    be mixed up in a composite class. That means a `Student` class having simple parts
    like `Id`, `Name`, `Address`, and so on as an Aggregation will be treated as a
    mix of both these concepts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些概念有如此微小但重要的区别，但它们仍然可以在组合类中混合使用。这意味着一个`Student`类，如果将其简单部分如`Id`、`Name`、`Address`等作为聚合，将被视为这两种概念的混合。
- en: Advantages and disadvantages
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优缺点
- en: In case of Composition, you have the control to manage those members as you
    like. However, they are not independent and you can't use them in other places.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合的情况下，你可以随心所欲地管理这些成员。然而，它们并不是独立的，你不能在其他地方使用它们。
- en: Whereas in Aggregation, there is no control of the member's life and if you
    forget to destroy the member after creation, it will be a culprit of memory leaks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而在聚合中，没有对成员生命周期的控制，如果你在创建后忘记销毁成员，它将成为内存泄漏的罪魁祸首。
- en: While both of them have their own pros and cons, it is just a matter of deciding
    which one to use where, according to the scenario. Moreover, you can mix them
    up and do amazing things. For example, some properties like `Id`, `Name`, etc.
    are used exclusively inside the class, so ideally we won't reuse these properties
    anywhere in the application. Therefore, if you build another class with all these
    properties and reference (aggregate) in the first class, that becomes unnecessary
    because the other class has no such usage outside the first class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们各自都有优点和缺点，但只是根据场景决定在哪里使用哪一个的问题。此外，你可以混合使用它们，做一些惊人的事情。例如，一些属性如`Id`、`Name`等仅在类内部使用，所以理想情况下我们不会在应用程序的任何地方重用这些属性。因此，如果你构建另一个包含所有这些属性的类，并在第一个类中引用（聚合），那就变得不必要了，因为其他类在第一个类之外没有这样的用途。
- en: On the other hand, when you identify that some properties that can be packed
    up as a subclass (`AddressId`, `Address`, `State`, `City`, `Country`, and so on),
    you might have a requirement in future to refer to that new subclass somewhere
    in the code. Better to aggregate that. Let the caller manage its lifetime. Just
    get that into your composite class and use as required and forget it's management.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你确定某些属性可以打包成一个子类（`AddressId`、`Address`、`State`、`City`、`Country`等等），你可能在将来需要在代码的某个地方引用这个新的子类。最好是进行聚合。让调用者管理其生命周期。只需将其放入你的组合类中，按需使用，并忘记其管理。
- en: Other important relationships
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要关系
- en: There are a few other relationships which you should be aware of. Unless you
    know these, you won't be able to visualize how objects typically work with each
    other.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些关系，你应该了解。除非你知道这些，否则你将无法可视化对象通常是如何相互协作的。
- en: Association
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: So far we have completed two types of Object Composition, Composition, and Aggregation.
    Just to confirm that we are on the same page, Object Composition is used to package
    relationships into a complex object that is from one or more simpler objects (parts/members).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了两种类型的对象组合：组合和聚合。只是为了确认我们处于同一页面上，对象组合用于将关系打包到一个复杂对象中，该对象由一个或多个更简单的对象（部分/成员）组成。
- en: 'Now, we''ll take a look at a type of relationship between two otherwise unrelated
    objects, called an **Association**. An Association is a bonding between two unrelated
    objects and they must satisfy the following conditions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看两种原本无关的对象之间的一种关系类型，称为**关联**。关联是两个无关对象之间的联系，它们必须满足以下条件：
- en: '**Object (member) associated is unrelated to the other object (class):** Here
    the objects, which are going to be associated, are not related to the object.
    Rather than being a part of a complex object as in a composition or aggregation,
    it is totally independent in nature. For example, a `Teacher` and `Student` are
    two independent objects, but not contained in each other. These entities get associated
    with each other while in a class for lessons.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联的对象（成员）与其他对象（类）无关**：这里将要关联的对象与对象无关。它不是像组合或聚合中那样成为复杂对象的一部分，而是本质上完全独立。例如，`Teacher`和`Student`是两个独立的对象，但它们不包含彼此。这些实体在上课时相互关联。'
- en: '**Object (member) associated can belong to more than one object (class) at
    a time:** Like aggregation, the associated object can belong to multiple objects
    at the same time. For example, a `Student` can be associated with many teachers
    and vice versa.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联的对象（成员）可以同时属于多个对象（类）**：像聚合一样，关联对象可以同时属于多个对象。例如，一个`Student`可以与许多教师相关联，反之亦然。'
- en: '**Object (member) associated does not have its existence managed by the other
    object (class)**: All aggregated objects are independent here. Everyone manages
    themselves. For example, neither `Teacher` is going to decide what a `Student`
    will do nor does the `Student` decides what the actions of the `Teacher` should
    be.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联的对象（成员）的存在不由另一个对象（类）管理**：这里所有聚合的对象都是独立的。每个人自己管理自己。例如，`Teacher`不会决定`Student`会做什么，`Student`也不会决定`Teacher`的行动应该是什么。'
- en: '**Object (member) associated may or may not know about the existence of the
    object (class)**: Association relationships might be unidirectional or bidirectional.
    That means the two associated objects may or may not know each other. We will
    get more clarification on this once we see the code snippet. For example, a `Student`
    may or may not recognize a `Teacher`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联的对象（成员）可能知道也可能不知道对象（类）的存在**：关联关系可能是单向的或双向的。这意味着两个关联的对象可能知道对方，也可能不知道。一旦我们看到了代码片段，我们将对此有更多的了解。例如，一个`Student`可能认识或不认识一个`Teacher`。'
- en: Association can be defined as *uses...a* relationship. The `Teacher` *uses*
    the `Student` to teach the lessons. The `Student` uses the `Teacher` to clarify
    doubts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关联可以定义为*使用...a*关系。`Teacher`使用`Student`来授课。`Student`使用`Teacher`来澄清疑问。
- en: Example
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let''s take an example of a cricket player and bat. Consider the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个板球运动员和板为例。考虑以下内容：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Explanation of the preceding code
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上述代码的解释
- en: 'We have two different classes, `CricketPlayer` and `Bat`. Now let me create
    the objects as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个不同的类，`CricketPlayer`和`Bat`。现在让我按照以下方式创建对象：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/366514c2-bb00-4a94-9786-07d076c94e2b.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/366514c2-bb00-4a94-9786-07d076c94e2b.png)'
- en: The methods `Play` inside the `CricketPlayer` class and `StartPlay` inside the
    `Bat` class are the ones, which you should be concentrating on at this point.
    Both are taking a reference param pointing to the other class's object. The whole
    point of this type of relationship between the player and bat is the common cause
    of starting t0 play.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`CricketPlayer`类内部的`Play`方法和`Bat`类内部的`StartPlay`方法是此时你应该关注的。两者都接受一个指向另一个类对象的引用参数。这种玩家和板之间的关系的关键点是共同的原因是开始比赛。'
- en: Let's look at the rules which this relationship follows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个关系遵循的规则。
- en: '**Rule 1: Object (member) associated is unrelated to the other object (class)**:
    Neither the bat relates to the player nor the player relates to the bat. But we
    will gradually see how they get associated.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 1：关联的对象（成员）与其他对象（类）无关**：板与球员无关，球员与板也无关。但我们将逐步看到它们是如何相互关联的。'
- en: '**Rule 2: Object (member) associated can belong to more than one object (class)
    at a time:** The bat can be used by many other players in the team, not just by
    one.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 2：关联的对象（成员）可以同时属于多个对象（类）**：板可以被团队中的许多其他球员使用，而不仅仅是其中一个球员。'
- en: '**Rule 3: Object (member) associated does not have its existence managed by
    the other object (class)**: The player is not responsible for managing the bat.
    It is created even before the player comes to the team. Likewise, the bat is not
    going to give birth to or be the cause of death of a player unless the player
    hits himself with the bat, which is not going to happen.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则3：关联的对象（成员）的存在不由另一个对象（类）管理**：球员不负责管理球拍。它是在球员加入球队之前就创建的。同样，球拍也不会导致球员出生或死亡，除非球员用球拍打自己，这是不可能发生的。'
- en: '**Rule 4: Object (member) associated may or may not know about the existence
    of the object (class)**: The player knows about the bat as the bat is passed as
    an argument in the `Play` method. Similarly, the bat knows about the player as
    that got passed to the `StartPlay` method.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则4：关联的对象（成员）可能知道也可能不知道对象（类）的存在**：球员知道球拍，因为球拍作为参数传递给了`Play`方法。同样，球拍知道球员，因为它被传递给了`StartPlay`方法。'
- en: If you understand cricket a little bit, you must know that a player uses a bat
    to bat. That means it depends on the bat object. The bat object, however, can
    be used by any batsman in the team, which leads to a `StartPlay` method in the
    `Bat` class. Obviously, the bat object needs to get associated with a player,
    which eventually commences the game.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微了解一点板球，你必须知道球员使用球拍来击球。这意味着它依赖于球拍对象。然而，球拍对象可以被团队中的任何一名击球手使用，这导致了`Bat`类中的`StartPlay`方法。显然，球拍对象需要与一个球员关联，这最终开始了比赛。
- en: 'Both of the objects depend on each other in order to start the game. They still
    exist as independent objects. Suppose, you don''t call the `Play` and `StartPlay`
    method, nothing will change. The code will compile. That defines the association
    with each other for a common cause:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象相互依赖，以便开始比赛。它们仍然作为独立对象存在。假设你没有调用`Play`和`StartPlay`方法，什么都不会改变。代码将编译。这定义了它们为了共同目的而相互关联：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, I just commented out codes for play. That did not have any impact on the
    objects and they still exist. Then I used them to call other methods like `GetPlayerName`
    and `GetBrandName`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我只是注释掉了代码以供玩耍。这并没有对对象产生影响，它们仍然存在。然后我使用它们来调用其他方法，如`GetPlayerName`和`GetBrandName`。
- en: '![](img/788af1ce-221c-4b96-8f6e-9ff2a7beb171.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/788af1ce-221c-4b96-8f6e-9ff2a7beb171.png)'
- en: Types of Association
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联类型
- en: We have learned a bit about Association. However, there are different types
    and it would be handy for us to know about them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对关联有所了解。然而，关联有不同的类型，了解它们对我们来说会很有帮助。
- en: Reflexive Association
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自反关联
- en: 'When two objects of the same type get associated, that association is called
    as **Reflexive Association**. Let''s consider the class `Medicine`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个相同类型的对象相互关联时，这种关联被称为**自反关联**。让我们考虑一下`Medicine`类：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is very useful in many scenarios when we have dependencies of the same
    entity. We know that a medicine might have one alternate medicine, which again
    might have another alternate and so on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，当我们有相同实体的依赖关系时，这非常有用。我们知道一种药物可能有一种替代药物，而这种替代药物又可能有另一种替代药物，依此类推。
- en: Indirect Association
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接关联
- en: 'Association, when formed by other means and not directly between two objects,
    is called an **Indirect Association**. We will try to grasp this concept with
    the help of the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当关联通过其他方式形成，而不是直接在两个对象之间时，这种关联被称为**间接关联**。我们将通过以下示例来尝试理解这个概念：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have two classes named `SoftwareEngineer` and `Laptop` which are meant to
    be associated with each other. In this case, we are trying to relate them indirectly
    via a static class `AvailableLaptops` which has a list of `Laptop` objects containing
    their `Id` and `Name`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个类名为`SoftwareEngineer`和`Laptop`，它们应该相互关联。在这种情况下，我们试图通过一个静态类`AvailableLaptops`间接地将它们联系起来，这个类包含一个包含它们的`Id`和`Name`的`Laptop`对象列表。
- en: Let's focus on the `Main` method now. A `SoftwareEngineer` is instantiated (`Name
    Tworit Dash` with a `LaptopId 3`). We need to print his name and the laptop name
    he is using. We have the `LaptopId`. If you closely look at the `AvailableLaptops`
    class, there is a static method `GetLaptop` which takes `laptopId` as an argument
    and then finds the laptop from the list it already has.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在关注一下`Main`方法。一个`SoftwareEngineer`对象被实例化了（`Name Tworit Dash`，`LaptopId 3`）。我们需要打印他的名字和他正在使用的笔记本电脑名称。我们拥有`LaptopId`。如果你仔细查看`AvailableLaptops`类，你会发现一个静态方法`GetLaptop`，它接受`laptopId`作为参数，然后从它已有的列表中找到对应的笔记本电脑。
- en: 'So, `Laptop usedLaptop = AvailableLaptops.GetLaptop(3);` would get us the required
    `Laptop` object which has ID `3` and `Name Laptop3`. Now, it is just a matter
    of printing the engineer''s name and the name of the laptop returned by the static
    class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Laptop usedLaptop = AvailableLaptops.GetLaptop(3);` 将会获取到具有 ID `3` 和 `Name
    Laptop3` 的所需 `Laptop` 对象。现在，只需要打印工程师的名字和由静态类返回的笔记本电脑的名字：
- en: '![](img/234d4192-1dbf-46a9-aca4-3b138a01321d.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/234d4192-1dbf-46a9-aca4-3b138a01321d.png)'
- en: This is called **Indirect Association** because the association is established
    with the help of another class which can interact with a class and returns the
    results to another class requesting any data from the first class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 **间接关联**，因为关联是通过另一个类建立的，这个类可以与一个类交互，并将结果返回给请求从第一个类获取数据的另一个类。
- en: To summarise the relationships, let's do a quick recap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这些关系，让我们快速回顾一下。
- en: '**Composition:**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合：**'
- en: Part of a complex class.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂类的一部分。
- en: Members can't be a part of multiple classes.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员不能是多个类的部分。
- en: Members are created and destroyed by a complex class.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员由一个复杂的类创建和销毁。
- en: 'Unidirectional: Members do not know about the complex object.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向：成员不知道复杂的对象。
- en: '*A part of* relationship'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分* 关系'
- en: '**Aggregation:**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合：**'
- en: Part of a complex class
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂类的一部分
- en: Members can be a part of multiple classes
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员可以是多个类的部分
- en: Members are neither created nor destroyed by a complex class
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员既不是由一个复杂的类创建，也不是由一个复杂的类销毁
- en: 'Unidirectional: Members do not know about the complex object'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向：成员不知道复杂的对象
- en: '*Has a* relationship'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拥有* 关系'
- en: '**Association:**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联：**'
- en: Classes are not related but require each other when needed
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类之间没有关系，但在需要时相互需要
- en: Associated members or objects can be used by multiple objects
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联的成员或对象可以被多个对象使用
- en: Members are neither created or destroyed by a complex class
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员既不是由一个复杂的类创建，也不是由一个复杂的类销毁
- en: 'Unidirectional or Bidirectional: Objects may or may not know each other'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向或双向：对象可能知道或不了解彼此
- en: '*Uses a* relationship'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* 关系'
- en: Composition over Inheritance
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: This topic is very interesting and is discussed online in many websites and
    blogs. As the topic headline says **Composition is preferred over Inheritance**,
    we need to understand why it is so important by identifying the problems. The
    better the design from the beginning of your software development, the better
    the maintainability and reuse.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题非常有趣，在许多网站和博客上都有讨论。正如主题标题所说 **组合优于继承**，我们需要通过识别问题来理解为什么它如此重要。从软件开发的开始就有一个更好的设计，将使可维护性和重用性更好。
- en: Inheritance and Composition are two pillars of OOPs concepts. Unless they are
    used wisely according to your architecture, they will create problems in the future
    when you start adding complexity to your application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和组合是面向对象概念的两个支柱。除非它们根据你的架构明智地使用，否则在开始向应用程序添加复杂性时，它们会在未来造成问题。
- en: We have already discussed Composition, now, let's discuss Inheritance before
    we move towards the main topic of discussion.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了组合，现在，在我们转向讨论的主题之前，让我们先讨论继承。
- en: Inheritance
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'As the name suggests, the act of acquiring or deriving some behavior from someone
    is called **Inheritance**. In the programming world, when a certain class is inherited
    from another class, it creates an Inheritance. Some basic examples are written
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，从某人那里获取或派生某些行为的行为被称为 **继承**。在编程世界中，当一个类从另一个类继承时，它就创建了一个继承。以下是一些基本示例：
- en: A car *is a* vehicle. The vehicle has a certain behavior which the car acquires
    when it is built.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一辆车 *是一种* 车辆。车辆具有某些行为，当它被建造时，这些行为会被车所获得。
- en: A rectangle *is a* shape.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个矩形 *是一种* 形状。
- en: An `HourlyEmployee` *is an* employee. A `MonthlyEmployee` *is an* employee too.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `HourlyEmployee` *是一个* 员工。一个 `MonthlyEmployee` *也是一个* 员工。
- en: Chicken curry *is a* dish.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸡肉咖喱 *是一种* 菜肴。
- en: Notice, they all have something in common. That is the phrase *is a*. Inheritance
    is defined as an *is a* relationship.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们都有一些共同点。那就是短语 *是*。继承被定义为一种 *是* 关系。
- en: The car is a vehicle, but it might have a music system as well, which is not
    a common behavior of a vehicle. Thus, the derived or child classes can have their
    own behavior as well. `HourlyEmployee` and `MonthlyEmployee` are employees of
    a certain company who share many benefits from the company. However, their salary
    is not the same.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 车是一种车辆，但它可能还配备了一个音乐系统，这不是车辆的一种常见行为。因此，派生或子类也可以有自己的行为。`HourlyEmployee` 和 `MonthlyEmployee`
    是一家公司的员工，他们可以从公司分享许多福利。然而，他们的薪水并不相同。
- en: Example on User class
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类示例
- en: Let's see how we can implement Inheritance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现继承。
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have different types of users in our company such as `Admin`, `Manager`,
    `TeamLeads`, `HR`, and more. Although these entities are different, they have
    some properties in common. They must have an `Id`, `RoleId`, `Name`, `EmailId`,
    `MobileNumber`, and so on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们公司中，有不同类型的用户，例如`Admin`、`Manager`、`TeamLeads`、`HR`等。尽管这些实体是不同的，但它们有一些共同的属性。它们必须有一个`Id`、`RoleId`、`Name`、`EmailId`、`MobileNumber`等。
- en: As they have common properties and behavior we make an abstract base class `User`
    which has all those declared inside it. We won't be instantiating this class,
    so it is restricted by using an abstract keyword. Every type of user is going
    to have some operation. The simplest operation is `SaveUser()`, which is defined
    inside the base class so that it will be available for all child classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们有共同的属性和行为，我们创建了一个抽象的基类`User`，其中包含了所有这些声明。我们不会实例化这个类，因此它通过使用抽象关键字被限制。每种类型的用户都将有一些操作。最简单的操作是`SaveUser()`，它在基类中定义，以便所有子类都可以使用。
- en: In this example, we have different properties declared inside child classes
    as well.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还在子类中声明了不同的属性。
- en: 'Consider the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: Admin--`public string CompanyDepartment { get; set; }`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Admin--`public string CompanyDepartment { get; set; }`
- en: Manager--`public List<TeamLead> TeamLeads { get; set; }`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Manager--`public List<TeamLead> TeamLeads { get; set; }`
- en: TeamLead--`public List<string> Projects { get; set; }`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TeamLead--`public List<string> Projects { get; set; }`
- en: 'We can also define different methods specific to them inside these child classes.
    When we try to create objects, or in other words, create an `Admin` and `Manager`,
    it will look something like as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这些子类中定义针对它们的特定方法。当我们尝试创建对象，换句话说，创建一个`Admin`和一个`Manager`时，它看起来会像以下这样：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see we are creating each type of user and then sending their IDs to
    the save method for further database processing. `RoleId` is assigned inside the
    constructors of each type of `User` class. This produces output as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们正在创建每种类型的用户，然后将它们的ID发送到保存方法以进行进一步的数据库处理。`RoleId`在每种类型的`User`类的构造函数中分配。输出如下：
- en: '![](img/095ed841-57ce-4638-903f-e14c08a99c8b.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/095ed841-57ce-4638-903f-e14c08a99c8b.png)'
- en: New User Type
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新用户类型
- en: The company decides to have a new type of employee named  Delivery Manager,
    who will be having certain privileges, but not all. This role will take partial
    responsibilities from `Manager` as well as from `TeamLead`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 公司决定有一个新的员工类型，名为“配送经理”，他将拥有某些特权，但不是全部。这个角色将从`Manager`和`TeamLead`那里承担部分责任。
- en: 'A Delivery Manager can `CreateProject` (like a TeamLead) and  ;`AssignProjectToTeamLead`
    (like a `Manager`). Also while doing all these, he/she can `SendNotificationToCto`
    which is a new method. So, those two methods will have additional codes which
    are not an exact copy from the  `Manager` and `TeamLead` classes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 配送经理可以`CreateProject`（像TeamLead一样）和`AssignProjectToTeamLead`（像Manager一样）。在执行所有这些操作时，他/她还可以`SendNotificationToCto`，这是一个新方法。因此，这两个方法将包含不是直接从`Manager`和`TeamLead`类复制过来的额外代码：
- en: '![](img/e6bad7a4-a498-4945-95b5-7839807fdeef.png)**Multiple Inheritance** is
    a language-specific feature which enables a class to inherit features of more
    than one parent class. This feature can introduce complexities in the design and
    the supported languages have their own way of handling such scenarios. C#, Java,
    Swift etc. does not support Multiple Inheritance, but they allow implementing
    multiple protocols which are named **Interfaces**. I just wanted to show you that
    we have to go with some alternative approach to solve the problem in hand instead
    of inheriting from multiple classes as shown above, which is anyway not supported
    by C#.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/e6bad7a4-a498-4945-95b5-7839807fdeef.png)**多重继承**是一种特定于语言的特性，它允许一个类继承多个父类的特性。这个特性可能会在设计上引入复杂性，而支持这种特性的语言也有它们自己处理此类场景的方式。C#、Java、Swift等语言不支持多重继承，但它们允许实现多个协议，这些协议被称为**接口**。我只是想向你展示，我们必须采取一些替代方法来解决问题，而不是像上面那样从多个类中继承，因为C#本身就不支持这种做法。'
- en: Problem which we come across
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们遇到的问题
- en: Visual Studio complains to me that I can't code like this, which is actually
    termed Multiple Inheritance. Moreover, when a company introduces more roles, the
    system gets complex to manage when we have responsibilities (methods) defined
    in each class. Because when we have to mix responsibilities for a certain user
    role, we will have to create duplicate codes that would have been already written
    in some class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 告诉我我不能这样编码，这实际上被称为多重继承。此外，当一家公司引入更多角色时，如果我们每个类中都有定义职责（方法），系统在管理上就会变得复杂。因为当我们需要混合特定用户角色的职责时，我们必须创建重复的代码，而这些代码本应该已经在某个类中编写过了。
- en: To explain what I'm saying, imagine a `Car` class, which gets inherited by classes
    like `Toyota`, `BMW`, `Volkswagen`, and more. For some reason, I got mad and brought
    both `Toyota` and `Volkswagen` to my workshop and then built a new brand out of
    them. I will name it VolksTaditToy. Please don't kill me for this name.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释我所说的，想象一个 `Car` 类，它被 `Toyota`、`BMW`、`Volkswagen` 等类继承。由于某种原因，我生气了，把 `Toyota`
    和 `Volkswagen` 都带到了我的车间，然后从它们中创建了一个新的品牌。我将把它命名为 VolksTaditToy。请不要因为这个名字杀了我。
- en: VolksTaditToy now has a combination of functions from both of these cars. But
    there is no way to deal with them in my program. Don't be so surprised, if you
    see more of such cars on the road because there is no scarcity of such fools in
    this world. Gradually your program will be in a situation where there is no escape.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: VolksTaditToy 现在结合了这两款汽车的功能。但在我的程序中，没有方法来处理它们。如果你在路上看到更多这样的汽车，请不要感到惊讶，因为在这个世界上，这样的傻瓜并不稀缺。渐渐地，你的程序将陷入无法逃脱的境地。
- en: How can we write this class with the concept of inheritance? Impossible right!
    Let's make that possible for our initial `User` problem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用继承的概念来编写这个类？不可能吧！让我们让我们的初始 `User` 问题成为可能。
- en: The solution to the problem
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决这个问题的方案
- en: 'The composition is our savior here. Let''s see how we can solve this problem
    using this relationship. We will introduce a `Role` class. Obvious right! `Manager`,
    `TeamLead`, and `DeliveryManager` are different roles played by employees:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 组合在这里是我们的救星。让我们看看我们如何利用这种关系来解决这个问题。我们将引入一个 `Role` 类。显然！`Manager`、`TeamLead`
    和 `DeliveryManager` 是员工扮演的不同角色：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now every other user type class will derive from this class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的其他用户类型类都将从这个类派生：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alright, what is the next step? The remaining class is `User`. We need to do
    a couple of modifications in that, shown as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，下一步是什么？剩下的类是 `User`。我们需要对其进行一些修改，如下所示：
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first modification is to remove the abstract keyword because we will now
    create objects of this class. Next is to have a property `public List<Role> RoleIds
    { get; set; }` instead of `public int RoleId { get; set; }`. We did this to allow
    assigning multiple roles to a user/employee.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个修改是移除抽象关键字，因为我们现在将创建这个类的对象。接下来是拥有一个属性 `public List<Role> RoleIds { get; set;
    }` 而不是 `public int RoleId { get; set; }`。我们这样做是为了允许给用户/员工分配多个角色。
- en: 'Observe, how we can create a user with multiple roles in the following main
    method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 观察，我们如何在以下主方法中创建具有多个角色的用户：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While creating a `DeliveryManager` type of `User`, we are assigning multiple
    roles to the user by creating a list of `Manager` and `TeamLead` types. As they
    inherit from `Role` base class, so `RoleIds` recognize these types.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `DeliveryManager` 类型的 `User` 时，我们通过创建 `Manager` 和 `TeamLead` 类型的列表来给用户分配多个角色。由于它们继承自
    `Role` 基类，所以 `RoleIds` 能够识别这些类型。
- en: 'This piece of code produces the following output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了以下输出：
- en: '![](img/5707a7e8-fbbb-4fbe-8ef6-3838aa1269af.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5707a7e8-fbbb-4fbe-8ef6-3838aa1269af.png)'
- en: We conclude that Composition takes over Inheritance in many of such cases. That
    means you need to be very careful when you start designing the classes. Otherwise,
    the situation will get worse in the future when your system grows as you will
    create a mess. You should definitely avoid duplicate codes. When you see that
    you are writing something which has already been written before, stop and think
    before you proceed. Try to normalize as much as possible at that moment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，在许多这样的情况下，组合取代了继承。这意味着你在开始设计类时需要非常小心。否则，随着你的系统增长，未来的情况会变得更糟，你将陷入混乱。你绝对应该避免重复代码。当你看到你正在编写的东西之前已经编写过时，在继续之前停下来思考。尽可能在那个时刻进行规范化。
- en: Role of Object Composition in Dependency Injection
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象组合在依赖注入中的作用
- en: 'Now that we understand the concept of Object Composition, let''s analyze an
    actual software project problem and how that can be trapped using Object Composition.
    In the process, we will find out the importance of this concept in a DI context:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了对象组合的概念，让我们分析一个实际的软件项目问题，以及如何使用对象组合来陷入困境。在这个过程中，我们将发现这个概念在DI（依赖注入）环境中的重要性：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, the `Notification` class is inheriting the `Mail` class, so that it can
    call `SendMail()`. This structure is not wrong, but it will create complications
    going forward.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Notification`类继承了`Mail`类，以便它可以调用`SendMail()`。这种结构本身并没有错，但将来可能会产生复杂性。
- en: Imagine another class for `Sms`, where we can have a method something like `SendSms()`.
    There is no way here for the `Notification` class to call that method as multiple
    inheritances is not possible.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下另一个用于`Sms`的类，其中我们可以有一个类似`SendSms()`的方法。在这种情况下，`Notification`类无法调用该方法，因为多重继承是不可能的。
- en: 'To solve this problem, we can easily use Object Composition along with Dependency
    Injection. Let''s alter the code first. This is shown as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以轻松地使用对象组合与依赖注入。让我们首先修改代码。如下所示：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`IEmail` and `ISms` are interfaces which have `SendMail()` and `SendSms()`
    methods respectively. The next thing is to implement these interfaces in classes
    `Mail` and `Sms`. We will write our sending logic inside the methods implemented
    in these classes.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEmail`和`ISms`是具有`SendMail()`和`SendSms()`方法的接口。接下来，我们需要在`Mail`和`Sms`类中实现这些接口。我们将在这些类实现的方法中编写我们的发送逻辑。'
- en: Notice the `Notification` class, which is not inheriting any class, rather it
    is referencing new interfaces. Then inside a parameterized constructor, we have
    `IMail` and `ISms` as arguments. The `SendNotification()` method now takes the
    necessary details like `mailId`, `mobile` and `message` to call the methods using
    the interfaces.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Notification`类，它没有继承任何类，而是引用了新的接口。然后在参数化构造函数中，我们有`IMail`和`ISms`作为参数。现在`SendNotification()`方法需要像`mailId`、`mobile`和`message`这样的必要细节来调用接口的方法。
- en: 'What''s the advantage then? We wrote more code, didn''t we? The point here
    is very interesting. If you look at the code to instantiate `Notification` class,
    you will get some hint. Let''s look at that:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 那么优势在哪里呢？我们不是写了更多的代码吗？这里的关键点非常有趣。如果你查看实例化`Notification`类的代码，你会得到一些提示。让我们看看那个：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Got the hint? Let me explain. We injected the `Mail` and `Sms` class instances
    into the `Notification` constructor which is assigned to the properties `_mail`
    and `_sms`. It would automatically call the methods inside `Mail` and `Sms` classes.
    So, we composed `Notification` class with `IMail` and `ISms` references. This
    is where Object Composition came into the picture along with Dependency Injection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了提示吗？让我来解释一下。我们将`Mail`和`Sms`类的实例注入到`Notification`构造函数中，这些实例被分配给属性`_mail`和`_sms`。它会自动调用`Mail`和`Sms`类内部的方法。因此，我们使用`IMail`和`ISms`引用组合了`Notification`类。这就是对象组合与依赖注入出现的地方。
- en: Suppose at some point in time you want to include another class for mail sending
    (something like `SmtpMail`). You just need to write that class implementing the
    same `IMail` interface and define the `SendMail` method. Bang, it's done. No need
    to make the `Notification` class dirty anymore. It will work as expected.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在某个时间点想包含另一个用于邮件发送的类（比如`SmtpMail`），你只需编写一个实现相同`IMail`接口的类，并定义`SendMail`方法。就这样，完成了。不再需要让`Notification`类变得复杂。它将按预期工作。
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, I just declared the new class and injected the object like `new
    SmtpMail()` instead of `new Mail()`. That is the only change. The rest will work
    as expected because I have injected the object instead of directly referencing
    it inside the `Notification` class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我只是声明了新的类，并像`new SmtpMail()`一样注入对象，而不是在`Notification`类内部直接引用它。这就是唯一的改变。其余的将按预期工作，因为我已经注入了对象，而不是在`Notification`类内部直接引用它。
- en: 'To summarise, the following is what we achieved:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是我们所取得的成果：
- en: We introduced flexibility through interfaces for concrete dependencies.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过接口为具体依赖项引入了灵活性。
- en: We can easily plug in new concrete class dependency just by implementing the
    interface abstraction.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过实现接口抽象轻松地插入新的具体类依赖项。
- en: We composed `Notification` object with the dependency objects just with one
    go.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需一次操作，就将`Notification`对象与依赖对象组合在一起。
- en: We moved all initialization code to one place inside the `Main` method
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将所有初始化代码移动到`Main`方法内部的一个地方。
- en: When I said we moved the initialization code to one place, that location is
    denoted as the **Composition Root** of the application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说我们将初始化代码移动到一处时，那个位置被标记为应用程序的**组合根**。
- en: Composition Root
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合根
- en: Composition Root composes all the independent modules of the application. During
    runtime, Object Composition is the first thing that happens before any other operations.
    As soon as the object graph is wired up with dependencies, Object Composition
    is finished, then the components related to the application can take over. Object
    Composition should happen as close as possible to the application's entry point.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 组合根（Composition Root）组合了应用程序的所有独立模块。在运行时，对象组合是任何其他操作之前的第一件事。一旦对象图与依赖项连接，对象组合就完成了，然后与应用程序相关的组件可以接管。对象组合应该尽可能接近应用程序的入口点。
- en: The entry points in .NET Core 2.0 Console App and ASP.NET Core 2.0 MVC app are
    the same and that is inside the `Main` method of the `Program.cs` class. .NET
    Core 2.0 Console App's `Main` method is clean, but on the other hand, ASP.NET
    Core 2.0 MVC has some bootstrapping codes inside the `Main` method. However, we
    usually write composition codes inside a `ConfigureServices` method which can
    be called inside the `Main` method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 2.0控制台应用程序和ASP.NET Core 2.0 MVC应用程序中，入口点是相同的，都在`Program.cs`类的`Main`方法内部。.NET
    Core 2.0控制台应用程序的`Main`方法很简洁，但另一方面，ASP.NET Core 2.0 MVC在`Main`方法内部有一些启动代码。然而，我们通常在`ConfigureServices`方法中编写组合代码，这个方法可以在`Main`方法内部调用。
- en: 'When you do a File | New | Project | .NET Core | Console App (.NET Core) in
    Visual Studio 2017, you will see the following in the `Main` method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Visual Studio 2017中执行File | New | Project | .NET Core | Console App (.NET
    Core)时，你将在`Main`方法中看到以下内容：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the case of ASP.NET Core 2.0 MVC App, when you select  File | New | Project | Web
    | ASP.NET Core Web Application (in the next screen, select appropriate template),
    the template for Web Application generates the `Main` method in the `Program`
    class and `Startup` would look like the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 2.0 MVC应用程序的情况下，当你选择File | New | Project | Web | ASP.NET Core
    Web Application（在下一个屏幕中，选择合适的模板）时，Web应用程序模板会在`Program`类中生成`Main`方法，而`Startup`看起来如下所示：
- en: '![](img/b43a5769-7a5c-4917-b9c0-ffc24875d597.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b43a5769-7a5c-4917-b9c0-ffc24875d597.png)'
- en: The way we composed the `Notification` object in the last section is known as
    **Poor Man's DI**. Instead of doing that, we should apply DI Containers to compose
    and manage objects in that location.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中创建`Notification`对象的方式被称为**穷人版依赖注入（DI**）。而不是这样做，我们应该在该位置应用DI容器来组合和管理对象。
- en: Object Composition is the fundamental building block of DI and the easiest one
    to understand because we already know how to compose objects with many examples.
    Now it's time to learn what are the challenges we would face composing objects
    for DI due to the framework capabilities. The issues are related to a framework
    and nothing to do with the Object Composition concept. Let's find out in the upcoming
    sections.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对象组合是DI的基本构建块，也是最容易理解的一个，因为我们已经通过许多例子知道了如何组合对象。现在，我们需要学习在框架能力的影响下，组合对象时会面临哪些挑战。这些问题与框架有关，与对象组合的概念无关。让我们在接下来的章节中找出答案。
- en: Composing .NET Core 2.0 Console application
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合.NET Core 2.0控制台应用程序
- en: Inside the `Main` method, we can easily compose objects with built-in DI Container.
    If you remember, we have already discussed that from container initialization,
    registration of objects to the container, resolving dependencies and then release
    the components from the container, everything should happen inside the Composition
    Root, which is considered as the `Main` method here.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，我们可以轻松地使用内置的DI容器组合对象。如果你还记得，我们已经讨论过从容器初始化、将对象注册到容器、解析依赖项到最后从容器中释放组件，所有这些都应该在组合根内部发生，在这里被认为是`Main`方法。
- en: 'Consider an example of the `Main` method inside a console application:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个控制台应用程序中的`Main`方法示例：
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is simple code which leverages the extension method available, `Add***`, to
    register the dependency with the container. Then we used the `GetService` method
    to get the implemented type by the interface. With the instance, we then can do
    everything we want further in the application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单，它利用了可用的扩展方法`Add***`来将依赖项注册到容器中。然后我们使用`GetService`方法通过接口获取实现类型。有了这个实例，我们就可以在应用程序中做任何我们想做的事情。
- en: Recall that Composition Root is the place where we should do all operations
    related to Dependency Management. It's not recommended to use the `serviceProvider`
    outside the Composition Root or `Main` method to be specific. The same rule applies
    to ASP.NET Core MVC as well. We are going to explore that in a while.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，组合根是我们应该进行所有与依赖管理相关的操作的地方。不建议在组合根或更具体地说在 `Main` 方法之外使用 `serviceProvider`。同样的规则也适用于
    ASP.NET Core MVC。我们稍后会探讨这一点。
- en: 'You can, of course, introduce another method and you can name it `ConfigureServices` (shown
    as follows) for a cleaner code structure. You can give any name to the method,
    but this name resembles the name of the method specially dedicated in ASP.NET
    Core MVC app for dependency injection configurations as we saw in the picture
    in the last section. This new method added is shown in the following code snippet:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以引入另一个方法，你可以将其命名为 `ConfigureServices`（如下所示）以获得更清晰的代码结构。你可以给方法起任何名字，但这个名字与我们在上一节中看到的
    ASP.NET Core MVC 应用程序中专门用于依赖注入配置的方法的名称相似。新添加的方法如下代码片段所示：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we are not manually releasing the objects or the container. The
    reason is that release is automatically handled by the DI Container according
    to the life style you decide. `AddTransient`, `AddSingleton` and `AddScoped` are
    readily available methods which helps to perform different types of lifetime for
    the objects. We will explore more about Object Lifetime in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml),
    *Object Lifetime*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有手动释放对象或容器。原因是释放会根据你决定的生存周期自动由 DI 容器处理。`AddTransient`、`AddSingleton` 和
    `AddScoped` 是现成的方法，可以帮助执行不同类型的对象生存周期。我们将在 [第 6 章](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml)
    中更深入地探讨对象生存周期，*对象生存周期*。
- en: Object Composition in ASP.NET Core MVC 2.0
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 2.0 的对象组合
- en: Like Console Application, we can follow the same procedure to deal with dependencies
    inside ASP.NET Core MVC 2.0 apps. Unlike the console app, the `Main` method inside
    the `Program.cs`, in this case, is populated with default codes to initiate the
    MVC App with required configurations. It is that location from which it instructs
    the framework to load the Startup class. The `host` inside the `Main` method executes
    the `Startup` class `ConfigureServices` method.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就像控制台应用程序一样，我们可以遵循相同的程序来处理 ASP.NET Core MVC 2.0 应用程序内部的依赖项。与控制台应用程序不同，在这个例子中，`Program.cs`
    中的 `Main` 方法包含默认代码来初始化 MVC 应用程序并配置所需设置。它是从这个位置指示框架加载启动类的。`Main` 方法中的 `host` 执行
    `Startup` 类的 `ConfigureServices` 方法。
- en: ASP.NET Core MVC is designed to be DI-friendly. But it does not force you to
    apply DI always. To deal with dependencies in ASP.NET MVC, we can take the Poor
    Man's DI approach to manually manage them or leverage built-in/third party DI
    Container's technique to register, resolve, and release dependencies. Let's dive
    a little deep into the controller initiation process and see if we find anything
    useful.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 被设计成支持依赖注入。但它并不强迫你总是应用依赖注入。为了处理 ASP.NET MVC 中的依赖项，我们可以采取穷人的
    DI 方法来手动管理它们，或者利用内置/第三方 DI 容器的技术来注册、解析和释放依赖项。让我们深入探讨控制器初始化过程，看看是否能找到有用的东西。
- en: The heart of MVC lies in controllers. Controllers handle requests, process them,
    and return the response back to the client. Thus, the controllers should delegate
    their responsibility to the other modules as required. That means the controller
    will refer to other classes for certain tasks. It will use the `new` keyword for
    the dependency object creation inside the action methods, which we can easily
    avoid as we are using DI Container. With the dependency injection technique, we
    should be able to inject dependencies into the controllers with Constructor Injection.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 的核心在于控制器。控制器处理请求，处理它们，并将响应返回给客户端。因此，控制器应该根据需要将责任委托给其他模块。这意味着控制器将引用其他类来完成某些任务。它将在操作方法内部使用
    `new` 关键字来创建依赖对象，而我们可以通过使用 DI 容器轻松避免这一点。使用依赖注入技术，我们应该能够通过构造函数注入将依赖项注入到控制器中。
- en: '`IControllerFactory` is an interface inside `Microsoft.AspNetCore.Mvc.Controllers`
    namespace which enables us to create and release controllers. The interface contains
    two methods, shown as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`IControllerFactory` 是 `Microsoft.AspNetCore.Mvc.Controllers` 命名空间中的一个接口，它使我们能够创建和释放控制器。该接口包含两个方法，如下所示：'
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'ASP.NET Core MVC 2.0 ships with a `DefaultControlFactory` which implements
    this interface. Let''s have a look at the source code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 2.0 内置了一个 `DefaultControlFactory`，它实现了这个接口。让我们看看源代码：
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`DefaultControllerFactory` has a constructor injection with the required dependencies
    for the `ControllerActivator` and `PropertyActivators`. Thus, this factory is
    composed of activators. Like a factory, there is an interface for `Activator`
    also named `IControllerActivator`. There are providers for Factory and Activators
    named `ControllerFactoryProvider` and `ControllerActivatorProvider` respectively.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultControllerFactory` 具有构造函数注入，用于提供 `ControllerActivator` 和 `PropertyActivators`
    所需的依赖项。因此，这个工厂由激活器组成。就像一个工厂一样，还有一个名为 `IControllerActivator` 的 `Activator` 接口。分别有名为
    `ControllerFactoryProvider` 和 `ControllerActivatorProvider` 的工厂和激活器提供者。'
- en: 'Now, the most important part. The Object Composition of these factories is
    actually done inside the `AddMvcCore()` method of class `MvcServiceCollectionExtensions`
    which stays inside `namespace` `Microsoft.Extensions.DependencyInjection`. The
    `namespace` name contains `DependencyInjection`, which itself gives us a hint
    that we are going to do some injection for sure to initiate these activators and
    factories. Let''s see a snapshot of the `AddMvcCoreServices()` method ( which
    is another method called from `AddMvcCore()`) responsible for composing all required
    dependencies for controller activation and initialization:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最重要的部分。这些工厂的对象组合实际上是在 `MvcServiceCollectionExtensions` 类的 `AddMvcCore()`
    方法中完成的，该方法位于 `namespace` `Microsoft.Extensions.DependencyInjection` 内。`namespace`
    名称包含 `DependencyInjection`，这本身给我们一个提示，即我们肯定会进行一些注入来初始化这些激活器和工厂。让我们看看 `AddMvcCoreServices()`
    方法（这是从 `AddMvcCore()` 调用的另一个方法）的快照，它负责组合所有用于控制器激活和初始化的必需依赖项：
- en: '![](img/e5e5e48a-e6fa-4263-8628-a0a148146ea7.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5e5e48a-e6fa-4263-8628-a0a148146ea7.png)'
- en: You can see how the interfaces are registered as the concrete classes. This
    method contains many other service registrations for all the background work needed
    for the controller process. But we got an idea about how Object Composition is
    implemented inside the framework itself.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到接口是如何注册为具体类的。此方法包含许多其他服务注册，用于控制器过程所需的全部后台工作。但我们对框架内部如何实现对象组合有了了解。
- en: If we want to design our own custom controller factory, we can do that as well
    by registering the required factory and provider inside this method for initiation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要设计自己的自定义控制器工厂，我们也可以通过在此方法中注册所需的工厂和提供者来进行初始化。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter touched upon important relationships between objects in programming.
    We created very basic classes and tried to grasp the concepts. Then we moved our
    focus to Object Composition, and it's types, Composition, and Aggregation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了编程中对象之间的重要关系。我们创建了非常基础的类，并试图掌握这些概念。然后，我们将注意力转向对象组合，以及它的类型、组合和聚合。
- en: Moreover, we discussed Association. With code examples and outputs, we saw how
    these relationships matter a lot while coding.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了关联。通过代码示例和输出，我们看到了这些关系在编码中的重要性。
- en: Finally, we were introduced to Inheritance with an example. Once we completed
    all these, we moved towards a very important saying *Composition over Inheritance*.
    This is a real-time issue which developers face while applying new requirements
    to existing class structures.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过一个示例介绍了继承。一旦我们完成了所有这些，我们就转向一个非常重要的说法：*组合优于继承*。这是开发者在将新需求应用于现有类结构时面临的一个实际问题。
- en: Then, we discussed the important role played by Object Composition in Dependency
    Injection. Also, we saw how this pattern is followed in ASP.NET Core MVC 2.0.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了对象组合在依赖注入中扮演的重要角色。我们还看到了这种模式如何在 ASP.NET Core MVC 2.0 中遵循。
- en: It's time to see how objects are created, how they live and are then destroyed
    in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml), *Object Lifetime*.
    We will relate the object lifetime with what we already know from this chapter.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看对象是如何创建的，它们是如何生存的，然后又是如何被销毁的，在[第6章](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml)，*对象生命周期*中。我们将对象生命周期与我们在这章中学到的知识联系起来。
