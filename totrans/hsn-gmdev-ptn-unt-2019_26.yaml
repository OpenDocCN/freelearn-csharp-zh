- en: Spatial Partition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to review the Spatial Partition pattern; the concept
    of spatial partitioning is prevalent in computer graphics and is used for organizing
    the objects in a virtual space in an optimal way. This approach is also valid
    for the management of GameObjects placed inside of a Unity scene. By implementing
    the core principles of the Spatial Partition pattern, we can divide a large environment
    that's filled to the brim with two-dimensional or three-dimensional objects, and
    still be able to maintain a degree of consistent performance. As you will see
    in this chapter, this pattern is one of the core ingredients that make the production
    of large AAA open-world games possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will review the basic principles behind the Spatial Partition pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement a mini game in which a predator hunts prey in a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands-on, and you will need to have a basic understanding of
    Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with this concept, please review it before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ is a very powerful query language that's somewhat similar to SQL; it can
    be a time saver when you want to simply iterate through a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files from this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2FAyWCf](http://bit.ly/2FAyWCf)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Spatial Partition pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Game programmers are often faced with the problem of finding a way to quickly
    locate the specific entities in a scene that are closest to a reference point,
    for example, the player character. In Unity, there are many approaches to solving
    this problem, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a ray casting system that will scan the area around the player character
    and report the locations of specific entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Unity's API features, such as the `GameObject.Find()` function, to locate
    specific entities in the scene, and then compare their coordinates to those of
    the player character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is valid, but if we have a complex three-dimensional environment,
    it might be difficult to locate all of the entities that we are looking for, because
    they might be behind other objects and cannot be intersected by the ray. The second
    option might not be ideal performance-wise, because we will need to iterate through
    a list that includes every entity in the scene until we find every instance of
    a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can resolve this type of technical challenge by using the Spatial Partition
    pattern; it was designed for this purpose. One thing that we need to address first
    is the name of this pattern. The term **Spatial Partition** can be misleading:
    we are not organizing or modifying the virtual space that we are partitioning.
    We are doing the opposite; we are removing space from the equation.'
  prefs: []
  type: TYPE_NORMAL
- en: We achieve this by putting three-dimensional objects that are in a scene into
    a flat data structure that efficiently represents, in the memory, the distance
    between those objects in relation to each other without having to do calculations
    on the exact coordinates. This approach permits us to do fast and straightforward
    calculations to find the entities that are the closest to or farthest from a reference
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we are sub-dividing a virtual space into a structure that''s
    easier to analyze. An example of a universal structure that''s easy to represent
    in memory (and that is often used to divide space into individual containers)
    is a fixed grid. In the following diagram, you can see a visual representation
    of this concept. The grid contains squares, which we will call **cells**. Those
    cells include **units**. Those units can be anything—a specific type of enemy
    character or hidden loot boxes spread out across a vast map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/159db14d-2aec-488b-8a74-63cad602f3eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's imagine that this grid is superimposed on the enormous open-world
    map of an RPG video game. Each cell (square) represents a virtual 2x2 km area.
    We know that our player character has spawned in a specific cell (square) on the
    map, but we want to offer him the option to quickly travel to an area that's filled
    with level-2 monsters that he can fight. By using a Spatial Partition, we can
    easily calculate for the nearest entities of a specific type in the memory without
    having to scan the entire three-dimensional environment.
  prefs: []
  type: TYPE_NORMAL
- en: The results of the calculations can suggest to us a nearby cell (square) that
    contains the largest grouping of enemies of level 2\. With this information, we
    can move our player character into a random position inside of the suggested cell
    (square), so that he can loot the area. As you will see in the next sections,
    Spatial Partitioning simplifies the process of managing entities that reside in
    complex two-dimensional and three-dimensional spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The drawbacks of this pattern are quite limited (and are non-existent in most
    cases) because it's so easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusable**: We can use the Spatial Partition pattern to optimize the way
    that we manage anything that''s formed of entities spread out in two-dimensional
    or three-dimensional space (for example, user interfaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplification**: A Spatial Partition makes it easier to implement code that
    calculates spatial relationships between objects. It''s very beneficial for those
    that are not good with math.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The drawbacks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not very dynamic**: Spatial Partitioning can lose all of its optimization
    benefits if you are trying to manage entities that are continually moving in space
    over an extended area. So, if you have a scene that''s full of objects bouncing
    around at full speed, you will need to continuously update the data structure
    that contains the collection of entities and their grid positions. In that case,
    this process can be resource-intensive and not worth the effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important skill that a game programmer should acquire is mathematics.
    Being knowledgeable about design patterns is necessary to get into the industry,
    but it's not as important as a deep understanding of advanced mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we need to quickly prototype a straightforward mini game that simulates
    a non-player predator character hunting for prey on a map. The process of spawning
    the entities (prey and predator) in the environment is not complicated; actually,
    it is quite simple. However, how are we going to know if our predator is close
    to potential prey and move him toward it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following possible solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: We could query every object in the scene and compare their coordinates with
    those of the predator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could implement a ray cast system that scans every object in the proximity
    of the predator, in order to spot potential prey.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These solutions could potentially work, but they could be burdensome to implement
    in a short time. However, with the Spatial Partition pattern, we can avoid this
    lengthy process by making sure that all the entities in our scene get contained
    in a data structure that organizes the prey and predator by their relative positions.
    As you will see in our code example, writing this implementation is quite fast
    and useful, especially when you are in a rush and want to sketch out some basic
    AI navigation behaviors in code.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code example might look very rudimentary, but it can easily be
    expanded to implement more complex use cases. In a way, it''s a foundation that
    we will be able to build on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the core element of our pattern, the `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that you should take note of is the `AddToRandomnPosition()`
    function, in which we are adding units to squares in the grid with a `Random.Range()`
    call. We are doing this for two reasons. We want to test our `Grid` implementation
    quickly, so we are simulating having the entities spread out in an environment
    at random positions. We also want to showcase how we can use Spatial Partitioning
    in combination with a spawn system to manage the spawning of entities within a
    specific optimized grid space. In other words, we can partition the virtual space
    of our scene in the memory, even before initializing the things that will inhabit
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Another function to analyze is `FindClosest()`; note that we are using two LINQ
    queries. The first query extracts a list of grid positions from a list of units.
    With the second one, we are querying this list to find the nearest cell in relation
    to a reference unit. For those that have never worked with LINQ, it's a built-in
    C# query language that permits finding and extracting elements in a collection
    with a single line of code. It's an excellent tool to use when you need to prototype
    and quickly write implementations that use data structures and collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a way for our units to register themselves into a specific cell
    of the `Grid`. Let''s start by implementing an interface to manage our unit types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It's quite a straightforward interface; the `GetGridPosition()` function returns
    the grid position of a `Unit`. A question that might arise is, why are we not
    implementing a function that will return the actual location of a `Unit` in the
    scene? It's because, in Unity, if a GameObject has a `Transform` component attached
    to it, we can directly ask this component to return its position inside of a three-dimensional
    scene. In other words, we are using Unity's API to do the heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement two types of units for our code example; let''s start
    with the `Prey`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is our `Predator` class; he hunts our `Prey`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that both our `Predator` and `Prey` have two primary responsibilities,
    linking their positions into a specific cell of the grid and returning that cell
    number if requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our `Client` class, which we are using to spawn `Prey` on the `Grid`
    and unleash the `Predator` upon them, is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's it; note that we never had to deal with the actual three-dimensional
    coordinates of objects to find their relative positions. We are avoiding a lot
    of unnecessary calculations by dividing the space into a grid and containing the
    objects within it. We are reducing the complexity by compartmentalizing it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in our code example, we went with the easy route and avoided calculating
    the relative positions of our `Units` before adding them to a specific square
    in the `Grid`, but this can easily be added if need be. The most important takeaway
    is that we should always avoid doing complex calculations on the entities in a
    three-dimensional space if we can merely partition and manage them inside of a
    data structure that we can easily search and manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a simple approach to learning a pattern that offers
    a solution to a very complex problem, which is how to organize the objects in
    a space optimally. We now have a tool that we can use to build open-world games
    and a quick solution for prototyping a game in which grids are a central component
    (for example, a puzzle game).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final chapter of this book, we are going to review a subject that''s
    the complete opposite of what we just explored: anti-patterns, the antithesis
    of design patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our code example, we implemented a straightforward use case of the Spatial
    Partition pattern. However, we limited ourselves to two-dimensional space; as
    a practical exercise, I would recommend expanding upon this basic example and
    organizing objects in a three-dimensional space. As inspiration, I would recommend
    observing the design of a Rubik's Cube. Note that it's composed of a collection
    of mini cubes; each can be considered a cell in a group.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mathematics for 3D Game Programming and Computer Graphics*by Eric Lengyel: [https://www.mathfor3dgameprogramming.com](https://www.mathfor3dgameprogramming.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
