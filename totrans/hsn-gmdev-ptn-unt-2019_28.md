# 反模式

在整本书中，我们通过实施各种类型的模式来回顾了软件架构的最佳实践。但你可能会问自己，如果这些模式如此有益，为什么不是每个人都使用它们？或者为什么我们仍然经常看到充斥着错误的游戏问世？

如果现在的程序员可以轻松地获取大量关于软件开发最佳实践的信息，那么合理地假设，我们不应该有理由在合理的时间内交付稳定的视频游戏和应用。但在本章中，我们将探讨为什么在软件开发行业中，即使是非常有能力和才华的团队最终也会生产出杂乱的代码，并且无法交付一个稳定的产物。

在前几章中，我们探讨了旨在有益并带来积极结果的模式。但现在，我们将研究它们的邪恶双胞胎，即反模式。这些破坏性的模式很微妙；它们并不总是潜伏在你的代码中，而是通过在每个组织层面引起恐惧、不确定性和怀疑来伤害你。这就是为什么它们如此难以识别，正如我们将在下一节中看到的那样。

本章将涵盖以下主题：

+   我们将回顾一系列常见的反模式

# 反模式

目前，软件开发的每个领域都有超过一百种反模式被专家们记录下来。我们无法在本章中全部回顾，但我已经列出了一份简短的清单，其中包含我发现的一些与设计模式误用相关的内容，无论是直接还是间接的。但我还列出了我在职业生涯中亲身经历过的那些。

与已建立的设计模式相比，关于反模式的学术研究并没有得到充分的记录，因此在特定反模式的命名上存在很多差异。因此，以下材料中的很多内容都是我对普遍存在的反模式的解释，而不是官方定义。那么，现在让我们深入主题，回顾一些我亲身经历并推荐避免的最相关的反模式。

# 假装精通

"如果人们知道我为了达到精通付出了多少努力，那么这一切就不会显得那么神奇了。"

- 米开朗基罗

**这是什么？** 程序员可以轻松访问大量信息、工具和库，使他们能够轻松地开发他们想要的任何东西。因此，这些优势使许多初级开发者相信他们是他们技艺的大师，当他们只是在复制粘贴他人的工作。

**为什么这是错误的？** 认为已经知道一切的想法比任何东西都更能阻碍你学习。这种危险的心态使你对自己的不足视而不见，使你无法处理反馈。结果，你将永远无法进步，你将最终成为职业生涯中一个平庸的程序员，即使你拥有高级或技术总监等头衔。

**根本原因是什么？** 这种过早的失望的主要原因在于，像Unity引擎这样的工具简化了制作游戏的过程，以至于几乎任何人都可以做到。但这意味着很少有人理解他们所使用的工具或编程语言在引擎底层的运作方式。

以为例子，仅仅因为你能够用C#编写程序，并不意味着你就是C#专家，但了解语言库的复杂性将使你成为专家。

**如何避免这种情况？**

以下是一份专业习惯列表，将帮助你避免陷入这种反模式的陷阱：

+   学习，学习，永远不要停止学习。

+   避免追求像高级、技术领导或CTO这样的头衔，而应专注于真正掌握你的技艺。

+   每次你使用一个新的工具、库和语言时，尽可能多地研究其起源以及其复杂性。

+   每天都要谦卑。接受自己并非无所不知，并且成为真正的资深程序员需要几十年的时间。

+   教学相长，写博客，并在论坛上回答技术问题。换句话说，将你所知的知识传授出去，同时吸收新的信息。这种方法将帮助你验证和构建你的学习。

创业公司给出的职位名称与大公司给出的职位名称并不等价。所以，当你从一个小型独立工作室过渡到AAA工作室时，你最终又回到了一个更初级的位置，这并不奇怪。原因是简单的：在大团队中晋升到高级职位更难，因为你需要与更多的程序员竞争更好的职位。

# 对复杂性的恐惧

“不要害怕完美——你永远达不到。”

- 拉斐尔·达利

**这是什么？**

我个人多年来一直受到这种反模式的困扰。这是对简单性总是最好的编程方法的过度热情的结果，因此，你应该避免任何可能看起来稍微复杂一些的解决方案，将其视为阻力最小的路径。

**为什么这是不好的？**

对复杂性的非理性恐惧可能会阻止你使用复杂和高级的设计模式或算法来解决问题。因此，你减少了成长潜力，限制了学习机会。最终，这可能会阻止你达到成熟和资深水平。

**根本原因是什么？**

坚信最简单的解决方案是解决任何技术问题的最佳途径。但通常，这只是一个避免进行研究和离开舒适区的借口。

**如何避免？**

每次你必须决定在简单或复杂解决方案之间做出选择时，你应该问自己以下问题：

+   我目前是在解决技术挑战中感到投入，还是只是试图完成任务？

+   我会因为建议一个更高级的解决方案而害怕看起来很愚蠢，因为我并不理解它吗？

+   我实施的简单解决方案是否会随着时间的推移与当前代码库的整体架构相匹配，或者它只是修补了问题？

因此，总结来说，在决定选择简单或复杂解决方案时，总是问自己这个简单的问题：你是选择最易于访问的方法，因为它是对的，还是因为你只是懒惰，不愿意采用需要更多努力的先进方法？

你经常听到程序员说，复杂性会导致更多的错误。这是真的，但更准确地说，是未管理和误解的复杂性导致了更多的错误。

# 管理者太多

“我们拥有的管理者没有我们应有的那么多，但我们宁愿少一些，也不愿有太多。”

- 拉里·佩奇

**这是什么？**

经理人很棒；他们提供了一个独特的接口，可以访问一组复杂的子系统。由于视频游戏是一个由不断相互交互的系统组成的庞大集合，因此作为接口的管理者可以非常有帮助，有助于减少依赖性。

**为什么这是错误的？**

如果每个类都是一个管理者，最终会导致管理者之间相互依赖。换句话说，管理者变成了其他管理者的子系统，直到你发现自己处于你试图避免的相同境地，一个依赖性的混乱。另一个负面点是，管理者通常被实现为单例，这意味着你在代码库中散布了全局依赖。

以下是一个代码示例，展示了可能过于依赖Manager类的软件架构。如果你在你的源代码中看到类似的情况，你可能需要重构你的架构：

[PRE0]

**根本原因是什么？**

根本原因通常是缺乏经验或懒惰的程序员，他们没有考虑代码库的整体架构，而是专注于即时结果。

**如何避免这种情况？**

这里有一份可能帮助你避免这种反模式的良好习惯列表：

+   每次你即将使用一个特定的模式时，总是考虑使用一个可能更适合的替代方案。换句话说，避免默认选择最简单的解决方案。

+   跟踪你的架构和你正在使用的模式。如果你看到标题中包含Manager的类太多，就提出一个警告。

+   如果你正在为你的核心系统实现单元测试时遇到问题，这是一个很好的迹象，表明你的架构中可能存在问题，这可能与有太多的单例或类似全局管理者的类有关。

新的模式，或者现有模式的排列组合，正在定期出现。阅读关于这个主题的新书，以保持对这些模式保持警觉是一个好习惯。

# 意面代码

"有机建筑寻求优越的使用感，以及更细腻的舒适感，体现在有机的简单性中。"

- 弗兰克·劳埃德·赖特

**那是什么？**

**意面代码**是过度封装和架构被分割成太多单独类别的结果。

**为什么这是错误的？**

大多数程序员在其职业生涯中听说过*意大利面代码*这个术语。它通常用来描述无结构和混乱的代码，这种代码通常是由初级程序员产生的。但意面代码可以被认为是相反的；它通常是经验丰富的程序员制作的过度设计的代码的结果，他们缺乏让其他人阅读其工作的愿望。

在这两种情况下，导航和维护受到这些反模式影响的代码库可能会变得困难。

**根本原因是什么？**

对编程和设计模式采取宗教和教条的态度可能会让你写出看起来准确但对其他人来说却难以阅读的代码。

**如何避免这种情况？**

这里有一些可能帮助您避免这种反模式的技巧：

+   在必要时，愿意为了可读性而牺牲准确性

+   总是考虑设计模式确实为你提供了结构，但通常是以牺牲可读性为代价的

+   为观众编写代码，并记住可能阅读它的人可能没有与你相同的技能集

大多数专业程序员不会自觉地使用设计模式，通常因为他们不理解它们或者不知道如何正确实现它们。因此，要成为一名优秀的程序员，您必须比其他人更了解所有可用的模式以及如何正确使用它们。

# 鬼魂

"确实，最好是推迟，以免我们匆忙完成得太少，或者完成它的时间太长。"

- 特尔图良

**那是什么？**

**鬼魂**对象通常是解决临时架构问题的代码的结果，但它们在代码库中保留的时间比应该的要长。

**为什么这是错误的？**

你必须维护的代码密度通常与你每次进行更改时可能需要修复的bug频率有关。另一个副作用是，鬼魂类在你的代码库中徘徊可能会引起对做出更改的恐惧，因为可能会在错误的时间出现未知对象。

**根本原因是什么？**

可以称为**鬼魂**的鬼魂对象和类，是良好意图变坏的结果。通常，它们的类被实现来解决临时的架构问题，但程序员从未有机会完成它们的设计，因此你最终会得到内存中存在的对象，但它们存在的原因并不明显。

**如何避免这种情况？**以下是一些可能帮助您避免这种反模式的技巧：

+   不要使用你不完全理解的设计模式

+   安排每周代码库审查并删除过时的代码

+   使用源代码分支策略来管理重要组件的重构

+   在你的代码中添加 TODO 注释，并要求你的团队定期审查并采取行动

+   在实施新的架构之前编写文档，以便你的团队可以在你做出更改之前审查你的计划并提供反馈

对于程序员来说，保持极简主义是一种良好的心态。代码可能很复杂，但它永远不应该因为无用的事物而臃肿。始终关注本质，移除非必要的内容。

# 过早优化

“完美是通过缓慢的步骤实现的；它需要时间的双手。”

- 伏尔泰

**什么是它？**

**过早优化**是在代码需要之前对其进行优化和完美化的行为，因此浪费了宝贵的产品时间。

**为什么这是错误的？**

在优化上投入比所需更多的时间是浪费时间的一种最糟糕的方式，同时也浪费了雇主的时间。大多数设备每年都在变快，因此程序员越来越不需要优化他们的代码以在有限的硬件上运行得更快。

**根本原因是什么？**

经验不足通常是根本原因。

**如何避免这种情况？**

在优化代码之前，始终对其进行性能分析。对于那些可能不知道的人来说，**性能分析**是使用诊断工具来分析系统性能的行为。通常，你将发现代码中的性能瓶颈仅限于源代码的特定区域，因此通过关注这些区域，你可以提高速度，而无需重构整个代码库。

就像一位优秀的机械师一样，程序员应该有一个工具箱，里面装满了可以帮助他们更快、更好地工作的工具。

# 供应商锁定

“这不是对技术的信仰。这是对人们的信仰。”

- 史蒂夫·乔布斯

**什么是它？**

**供应商锁定**发生在你开始在代码库中集成第三方组件、插件、框架或库时，但变得依赖于它们以使代码正常工作。

**为什么这是错误的？**

在 Unity 项目的背景下，依赖于第三方库可能会限制你升级到 Unity 的新版本的能力，因为你可能需要等待供应商的补丁以避免回退。

**根本原因是什么？** 从第三方供应商购买即插即用的组件和库可以节省大量的生产时间，因此很容易过度依赖它们。

**如何避免这种情况？** 在购买他们的产品并将它们集成到代码库之前，你应该研究供应商。例如，如果他们没有更新他们的支持论坛，这可能表明他们没有计划在不久的将来发布更新，这可能会限制你在需要时获得即时支持的能力。

作为一名Unity开发者，你在编写任何东西之前应该始终检查Unity资产商店，因为可能已经有其他人已经以更好的方式完成了你想要做的事情。

# 按数字管理

**这是什么？**

**按数字管理**是指基于由工具（如Excel电子表格或报告）生成的统计数据来做出管理决策，而不是基于对项目实际情况的准确分析。

**为什么这是错误的？**

在生产力报告中表达的数据往往不能反映团队的质量或潜力。它们可能隐藏由动态人际互动引起的问题，而不是揭示它们。这种对数字的关注可能会在关键决策过程中使项目经理失明。换句话说，你能通过程序员一周内修复的bug数量来定义程序员的效率吗？答案是*不*，因为特定bug的复杂性不是恒定的。你不能用同样的方式评估一周内修复五个简单bug的程序员和在同一时期内解决一个但非常复杂的bug的程序员。

**根本原因是什么？**

数字容易解释和证明，尤其是在与没有技术专长、只能通过非常一般的指标评估项目的更高管理层沟通时。这种方法可能导致一个组织花费时间关注数字而不是实际结果。

**如何避免这种情况？**

高级程序员应该挑战那些使用一般统计数据和数字来评估项目进度的项目经理，通过提供更具体的质量改进指标。以下是一个例子：

+   服务更新与停机时间

+   随时间发现的和修复的bug数量

在你40岁之后，为了确保自己在科技行业有一个长期的职业生涯，最关键的事情之一是回到学校，获得管理学的文凭或证书。这种教育将使你能够过渡到长期领导角色，公司可能会在你积累了数十年经验后鼓励你考虑这一角色。

# 技术面试

“我选择一个懒惰的人来做一件困难的工作。因为一个懒惰的人会找到一种简单的方法来完成它。”

- 比尔·盖茨

**这是什么？**

在程序员招聘过程中，技术面试的概念本身可能听起来不是一个反模式，但我提出它是一个，并且它会对团队生成的源代码质量产生副作用。对于那些从未经历过程序员技术面试的人来说，它涉及一系列测试，这些测试是给候选人以验证他们的技能和知识的。考试可能包括在白板上、一张纸上或在在线测试环境中编写关于编程的答案。我认为技术面试是一个行业范围内的反模式。

**为什么这是错误的？** 技术面试流程的核心问题是，你只能测试你已经知道的内容。因此，你最终会招聘到与你镜像般的候选人。结果，你将组建一个缺乏各种不同技能的团队。如果您的唯一目标是拥有一个非常专业的团队，这种方法是有效的，但这很少见。大多数公司需要拥有技能多样的员工来平衡组织中的任何弱点。

例如，如果你的技术面试的重点是数据结构，因为这是你作为面试官的优势，那么你可能会淘汰在该领域较弱但在其他领域（如设计模式）较强的候选人。但是，因为你只根据你认为是重要的技术偏见来评估，你可能会错过那些能为你的团队带来新技能的候选人。

**根本原因是什么？** 我们行业程序员招聘流程之所以如此不一致的主要原因在于，很少有人了解程序员的工作以及如何评估他们作为候选人的能力。因此，招聘经理更倾向于根据候选人的最终技术测试分数来评判他们，从而将候选人的价值简化为一个单一的数字。

此外，还有一些面试官的行为模式或流程也可能是根本原因的一部分：

+   **难题制造者**：难题制造者是一种通过提出巧妙谜题来测试候选人技能的面试官。这种方法通常会让大多数候选人感到困惑，并将面试过程变成一场压力游戏。

+   **热椅子**：臭名昭著的热椅子面试类型类似于警察审讯，目的是通过快速连续的问题来隔离候选人的弱点和优势。通常，一个面试官会扮演“坏警察”的角色，在提问时更加激进，而另一个则扮演“好警察”的角色，在候选人回答某些问题耗时过长时提供帮助。这种方法最终会耗尽候选人的精力或迫使他们以他们认为面试官想要听到的答案来回答。这不是了解候选人潜力的合适方法。

+   **白板面试**：白板面试包括让候选人通过在白板上写下答案来回答技术问题。这种评估候选人的方法存在一个特定的问题；大多数程序员在他们的职业生涯中从未在纸上或白板上编写过代码，所以当在压力情境下（如面试）被迫这样做时，会导致大量关于他们实际技能水平的错误否定。

**如何避免这种情况？** 几乎每个人都同意，招聘优秀的程序员是一个昂贵且具有挑战性的过程，但这意味着你需要更有创意地处理技术面试，以免拒绝那些只是你团队现有成员复制品的优秀候选人。

这里有一些可以帮助你避免这种反模式的提示：

+   尝试看看候选人有什么独特和有价值的。找一个能教你和你的团队新东西的候选人。

+   不要寻找弱点。相反，尝试理解候选人的优势，并看看它们是否与他们的潜在弱点相平衡。

+   总是考虑到程序员在行业中的技能可能有很多，这取决于他们的专业。例如，平均的网页开发者可能不如3D程序员擅长数学，但他们可能在数据库规范化或客户端-服务器应用程序设计方面更出色。

+   当候选人未能回答一个技术问题时，问问自己这是否是因为他们不理解它，可能没有足够的技能去做，或者可能因为考试过程而过于紧张。换句话说，在评估申请人的实际技能水平时，面试的背景很重要，而不仅仅是最终分数。

即使你是一位经验丰富的专业程序员，你也绝不能低估现代技术面试过程的潜在难度。你的多年经验可能成为一种劣势，因为面试官通常想评估你是否仍然了解你的计算机科学基础知识。换句话说，你可能需要回答一些自大学以来你可能没有复习过的主题的问题。因此，在参加面试之前，翻阅那些旧课本并学习基础知识是个好主意。

# 摘要

我们已经到达了旅程的终点。在这本书中，我们探讨了各种设计模式，每种模式都有其独特的功能。这本书最重要的收获是，在开始编写代码之前，你应该始终验证是否存在与系统设计意图相匹配的模式。这种方法避免了重复造轮子，并为你提供了一种一致的编程方法，这将有助于你整个职业生涯。

但这一章也揭示了看似合理的设计或管理决策，如果没有意识到其背后的动机和潜在后果，可能会迅速出错。换句话说，作为程序员，我们需要在每个层面上都意识到我们决策的潜在影响，否则我们可能会成为反模式的受害者。

# 练习

对于我们的最终练习，我为你列出了一个日常习惯清单，这将确保你在游戏行业中作为程序员的长期和成功职业生涯。然而，如果你不逐渐提高你的技能，几乎可以肯定你会陷入平庸，甚至可能变得无关紧要。相信我；这发生在我身上，直到有一天，我决定改变我的习惯，再次专注于真正掌握我的技艺。

这里有一些良好的习惯要养成：

+   每年至少学习一种新的编程语言。

+   通过参加练习面试编程考试来定期检查你的技能。

+   每年获得一项新的技术认证，如PMP、CCNA和CEH。

+   列出你作为程序员的全部弱点，并每天努力克服它们。

+   尝试每周至少参加一次与技术相关的聚会活动或会议。

+   加入技术专业组织，如ACM和IEEE，并使用提供的资源。

+   通过每天阅读技术和游戏行业新闻来保持对发生的事情的了解。

+   学习其他领域可能与你的领域相关的课程，包括管理、UI设计和动画。

+   为自己列一个与技术和编程相关的博客和YouTube频道的清单。每天至少阅读一篇博客文章和观看一个视频。

+   每月参加一次编码训练营或订阅至少一个培训课程。别忘了完成它们。

+   每年至少阅读两本关于编程或相关领域的书籍。

+   开一个GitHub账户，并至少为一个开源项目做出贡献，即使只是几行代码。习惯这个过程和社区。

+   学习冥想；这是一份压力很大的工作；知道如何在压力下保持冷静将有助于你保持心理健康并避免过度劳累。

对于我们的最终练习，我建议你列出你最喜欢的模式，并问问自己为什么喜欢它们。是因为它们易于实现，还是因为它们解决了你代码中的实际架构问题？换句话说，确保你不会因为错误的原因而使用特定的模式，永远不要懒惰，在编写代码时始终保持清醒的选择。

# 进一步阅读

**组织**:

+   *ACM*

    [https://www.acm.org](https://www.acm.org)

+   *IEEE*

    [https://www.ieee.org](https://www.ieee.org)

**博客**:

+   *编码恐怖*

    [https://blog.codinghorror.com](https://blog.codinghorror.com)

+   *乔尔·汉斯勒姆博客*

    [https://www.joelonsoftware.com](https://www.joelonsoftware.com)

+   *斯科特·汉斯勒姆博客*

    [https://www.hanselman.com/blog/](https://www.hanselman.com/blog/)

+   *疯狂程序员*

    [https://www.thecrazyprogrammer.com](https://www.thecrazyprogrammer.com)

**YouTube**:

+   *计算机爱好者*

    [https://www.youtube.com/user/Computerphile](https://www.youtube.com/user/Computerphile)

+   *技术成功*

    [https://www.youtube.com/channel/UC-vYrOAmtrx9sBzJAf3x_xw](https://www.youtube.com/channel/UC-vYrOAmtrx9sBzJAf3x_xw)

+   *TED*

    [https://www.youtube.com/user/TEDtalksDirector](https://www.youtube.com/user/TEDtalksDirector)

+   *TechLead*

    [https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw](https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw)

**科技新闻**:

+   *Slashdot*

    [https://slashdot.org](https://slashdot.org)

+   *Wired*

    [https://www.wired.com](https://www.wired.com)

+   *Gamasutra*

    [http://www.gamasutra.com](http://www.gamasutra.com)

+   GamesIndustry.biz

    [https://www.gamesindustry.biz](https://www.gamesindustry.biz)

**在线课程**:

+   *Udemy*

    [https://www.udemy.com](https://www.udemy.com)

+   *Lynda*

    [https://www.lynda.com](https://www.lynda.com)

+   *Pluralsight*

    [https://www.pluralsight.com](https://www.pluralsight.com)

+   MasterClass

    [https://www.masterclass.com](https://www.masterclass.com)

**书籍**:

+   *Anti-patterns: Managing Software Organizations and People*, by Colin J. Neill, Philip A. Laplante, and Joanna F. DeFranco [https://www.crcpress.com/Antipatterns-Managing-Software-Organizations-and-People-Second-Edition/Neill-Laplante-DeFranco/p/book/9781439861868](https://www.crcpress.com/Antipatterns-Managing-Software-Organizations-and-People-Second-Edition/Neill-Laplante-DeFranco/p/book/9781439861868)
