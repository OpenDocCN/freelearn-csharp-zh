- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Getting Started with gRPC
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 gRPC 入门
- en: Besides RESTful APIs, there are other types of APIs. One of them is the **remote
    procedure call** (**RPC**)-based API, which we introduced in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012).
    gRPC is a high-performance RPC framework developed by Google. Now, it is an open-source
    project under the **Cloud Native Computing Foundation** (**CNCF**), and it is
    becoming more and more popular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 RESTful API 之外，还有其他类型的 API。其中之一是基于**远程过程调用**（**RPC**）的 API，我们在[*第1章*](B18971_01.xhtml#_idTextAnchor012)中介绍了它。gRPC
    是由 Google 开发的一个高性能 RPC 框架。现在，它是一个在 **Cloud Native Computing Foundation**（**CNCF**）下的开源项目，并且越来越受欢迎。
- en: 'ASP.NET Core provides a set of gRPC tools to help us build gRPC services. In
    this chapter, we will introduce the fundamentals of gRPC and **Protocol Buffers**
    (**Protobuf**) messages. First, we will learn how to define protobuf messages
    and gRPC services. Then, we will learn how to implement gRPC services in ASP.NET
    Core, empowering us to communicate seamlessly between different applications.
    We will be covering the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一套 gRPC 工具来帮助我们构建 gRPC 服务。在本章中，我们将介绍 gRPC 和 **Protocol Buffers**（**Protobuf**）消息的基础知识。首先，我们将学习如何定义
    protobuf 消息和 gRPC 服务。然后，我们将学习如何在 ASP.NET Core 中实现 gRPC 服务，使我们能够无缝地在不同的应用程序之间进行通信。本章将涵盖以下主题：
- en: Recap of gRPC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 概述
- en: Setting up a gRPC project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 gRPC 项目
- en: Defining gRPC services and messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 gRPC 服务和消息
- en: Implementing gRPC services and clients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现gRPC服务和客户端
- en: Consuming gRPC services in ASP.NET Core applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 应用程序中消费 gRPC 服务
- en: By the end of this chapter, you should be able to understand the fundamentals
    of protobuf and gRPC and know how to build gRPC services in ASP.NET Core.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解 protobuf 和 gRPC 的基础知识，并知道如何在 ASP.NET Core 中构建 gRPC 服务。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11).
    You can use VS 2022 or VS Code to open the solutions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11)找到。你可以使用
    VS 2022 或 VS Code 打开解决方案。
- en: Recap of gRPC
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 概述
- en: If you have read [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012), you should
    be familiar with the concept of RPC – it is a protocol that allows a program to
    call a procedure on a remote machine. Unlike RESTful APIs, which center around
    resources, RPC-based APIs focus on actions. So, RPC methods support various types
    of actions besides CRUD operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了[*第1章*](B18971_01.xhtml#_idTextAnchor012)，你应该熟悉 RPC 的概念——它是一种允许程序在远程机器上调用过程的协议。与围绕资源中心的
    RESTful API 不同，基于 RPC 的 API 侧重于操作。因此，RPC 方法支持除 CRUD 操作之外的各种类型的操作。
- en: gRPC is one of the most popular RPC frameworks. It provides many benefits over
    traditional RPC frameworks. As we mentioned in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012),
    gRPC is based on HTTP/2, which is more efficient than HTTP/1.1\. gRPC uses protobuf
    as the default data serialization format, which is a binary format that is more
    compact and efficient than JSON. The tooling support for gRPC is also very good.
    It follows the contract-first approach, which means we can create language-neutral
    service definitions and generate code for different languages. It also supports
    streaming, which is a very useful feature for real-time communication.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是最受欢迎的 RPC 框架之一。它比传统的 RPC 框架提供了许多优势。正如我们在[*第1章*](B18971_01.xhtml#_idTextAnchor012)中提到的，gRPC
    基于 HTTP/2，比 HTTP/1.1 更高效。gRPC 使用 protobuf 作为默认的数据序列化格式，它是一种比 JSON 更紧凑、更高效的二进制格式。gRPC
    的工具支持也非常好。它遵循“契约优先”的方法，这意味着我们可以创建语言中性的服务定义并为不同的语言生成代码。它还支持流，这对于实时通信是一个非常有用的功能。
- en: With the increasing popularity of microservices, gRPC is becoming more and more
    popular. While gRPC offers some advantages over RESTful APIs, it is not considered
    a complete replacement. gRPC is an excellent choice for high-performance, low-latency
    communication between microservices, but RESTful APIs are more suitable for web-based
    applications and scenarios where simplicity, flexibility, and wide adoption are
    more critical. It’s important to choose the right protocol based on the requirements
    of your specific use case. In the next section, we will learn how to set up a
    gRPC project in ASP.NET Core.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务的日益流行，gRPC 越来越受欢迎。虽然 gRPC 在某些方面优于 RESTful API，但它并不被视为完全的替代品。gRPC 是微服务之间高性能、低延迟通信的绝佳选择，但
    RESTful API 更适合基于 Web 的应用程序和需要简单性、灵活性和广泛采用的场景。根据你特定用例的需求选择正确的协议非常重要。在下一节中，我们将学习如何在
    ASP.NET Core 中设置 gRPC 项目。
- en: Setting up a gRPC project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 gRPC 项目
- en: In this section, we will build a gRPC project using the dotnet CLI. We will
    also create a client project to consume the gRPC service. We will be using the
    same project throughout this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 dotnet CLI 构建一个 gRPC 项目。我们还将创建一个客户端项目以消费 gRPC 服务。我们将在本章中使用相同的项目。
- en: Creating a new gRPC project
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的 gRPC 项目
- en: 'To create a new gRPC project, we can use the `dotnet new` command. The dotnet
    CLI provides a template for gRPC projects, which includes a basic gRPC service.
    We can use the following command to create a new gRPC project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 gRPC 项目，我们可以使用 `dotnet new` 命令。dotnet CLI 为 gRPC 项目提供了一个模板，其中包括一个基本的
    gRPC 服务。我们可以使用以下命令创建一个新的 gRPC 项目：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-o` option specifies the output directory. After running the command, we
    will see that a project named `GrpcDemo` is created.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` 选项指定输出目录。运行命令后，我们将看到创建了一个名为 `GrpcDemo` 的项目。'
- en: 'If you prefer to use VS 2022, you can also create a new gRPC project in VS
    2022 using the built-in gRPC template. You can select the **ASP.NET Core gRPC
    Service** template when creating a new project, as shown in *Figure 11**.1*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 VS 2022，你也可以使用内置的 gRPC 模板在 VS 2022 中创建一个新的 gRPC 项目。创建新项目时，可以选择 **ASP.NET
    Core gRPC Service** 模板，如图 11.1* 所示：
- en: '![Figure 11.1 – Creating a new gRPC project in VS 2022](img/B18971_11_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 在 VS 2022 中创建新的 gRPC 项目](img/B18971_11_1.jpg)'
- en: Figure 11.1 – Creating a new gRPC project in VS 2022
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 在 VS 2022 中创建新的 gRPC 项目
- en: After creating the project, you can use VS Code or VS 2022 to open the project.
    Next, we’ll explore the project structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，你可以使用 VS Code 或 VS 2022 打开项目。接下来，我们将探索项目结构。
- en: Understanding the gRPC project structure
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 gRPC 项目结构
- en: 'The project structure of a gRPC project has some differences from a RESTful
    API project. There is no `Controllers` folder in the gRPC project. Instead, there
    is a `Protos` folder, which contains the proto files. You can find a `greet.proto`
    file in the `Protos` folder, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 项目的项目结构与 RESTful API 项目有所不同。gRPC 项目中没有 `Controllers` 文件夹。相反，有一个 `Protos`
    文件夹，其中包含 proto 文件。你可以在 `Protos` 文件夹中找到一个 `greet.proto` 文件，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: gRPC uses protobuf as the default data serialization format. The `greet.proto`
    file is the proto file that defines the gRPC service and messages. If you are
    familiar with RESTful APIs, you can think of this file as the Swagger file (OpenAPI
    specification). It is the contract of the gRPC service. In the preceding proto
    file, we define a service named `Greeter` with a method named `SayHello()`. The
    `SayHello()` method takes a `HelloRequest` message as input and returns a `HelloReply`
    message as output. Both `HelloRequest` and `HelloReply` messages have string properties
    named `name` and `message`, respectively.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 protobuf 作为默认的数据序列化格式。`greet.proto` 文件是定义 gRPC 服务和消息的 proto 文件。如果你熟悉
    RESTful API，你可以将此文件视为 Swagger 文件（OpenAPI 规范）。它是 gRPC 服务的契约。在先前的 proto 文件中，我们定义了一个名为
    `Greeter` 的服务，其中包含一个名为 `SayHello()` 的方法。`SayHello()` 方法接收一个 `HelloRequest` 消息作为输入，并返回一个
    `HelloReply` 消息作为输出。`HelloRequest` 和 `HelloReply` 消息分别具有名为 `name` 和 `message`
    的字符串属性。
- en: In a proto file, you can use `//` to add comments. To add multi-line comments,
    you can use `/* ... */`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 proto 文件中，你可以使用 `//` 来添加注释。要添加多行注释，可以使用 `/* ... */`。
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: VS Code does not provide syntax highlighting for proto files by default. You
    can install some extensions, such as `vscode-proto3`, to enable syntax highlighting.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 默认不提供 proto 文件的语法高亮。你可以安装一些扩展，例如 `vscode-proto3`，以启用语法高亮。
- en: 'Let’s check the project file. Open the `GrpcDemo.csproj` file; we will see
    the following content:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查项目文件。打开 `GrpcDemo.csproj` 文件；我们将看到以下内容：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will see that it includes two package references:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到它包含两个包引用：
- en: '`Grpc.AspNetCore`: This package provides the gRPC server library for ASP.NET
    Core. It also references the `Grpc.Tools` package, which provides the code-generation
    tooling.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grpc.AspNetCore`: 此包为 ASP.NET Core 提供了 gRPC 服务器库。它还引用了 `Grpc.Tools` 包，该包提供了代码生成工具。'
- en: '`Google.Protobuf`: This package provides the `Protobuf` runtime library.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Google.Protobuf`: 此包提供了 `Protobuf` 运行时库。'
- en: 'There is a `Protobuf` item group that includes the proto file. The `GrpcServices`
    attribute specifies the type of code generated by the proto file. It can be set
    to the following values:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个包含 proto 文件的 `Protobuf` 项目组。`GrpcServices` 属性指定了由 proto 文件生成的代码类型。它可以设置为以下值：
- en: '`None`: No code is generated'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`: 不生成代码'
- en: '`Client`: This option only generates client-side code'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`: 此选项仅生成客户端代码'
- en: '`Server`: This option only generates server-side code'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Server`: 此选项仅生成服务器端代码'
- en: '`Both`: This option generates both client-side code and server-side code. It
    is the default value'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Both`: 此选项生成客户端代码和服务器端代码。这是默认值'
- en: In the template project, the `GrpcServices` attribute is set to `Server`, which
    means only server-side code is generated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板项目中，`GrpcServices` 属性设置为 `Server`，这意味着仅生成服务器端代码。
- en: If you have multiple proto files, you can add multiple `Protobuf` items to the
    `ItemGroup` element.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个 proto 文件，您可以在 `ItemGroup` 元素中添加多个 `Protobuf` 项目。
- en: 'Next, let’s check the `Services` folder. You can find the `GreeterService.cs`
    file in the `Services` folder, which contains the implementation of the `Greeter`
    service:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `Services` 文件夹。您可以在 `Services` 文件夹中找到 `GreeterService.cs` 文件，它包含了
    `Greeter` 服务的实现：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GreeterService` class inherits from the `GreeterBase` class, which is generated
    by the proto file. It has a `SayHello()` method, which takes a `HelloRequest`
    object as input and returns a `HelloReply` object as output. The implementation
    of the `SayHello()` method is very simple – it matches the definition of the `SayHello()`
    method in the proto file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreeterService` 类继承自由 proto 文件生成的 `GreeterBase` 类。它有一个 `SayHello()` 方法，该方法接收一个
    `HelloRequest` 对象作为输入，并返回一个 `HelloReply` 对象作为输出。`SayHello()` 方法的实现非常简单——它匹配 proto
    文件中 `SayHello()` 方法的定义。'
- en: 'If you move your mouse over the `HelloRequest` class in VS Code, you will see
    a pop-up message, which shows that the namespace of the `HelloRequest` class is
    `GrpcDemo.HelloRequest`, as shown in *Figure 11**.2*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将鼠标悬停在 VS Code 中的 `HelloRequest` 类上，您将看到一个弹出消息，显示 `HelloRequest` 类的命名空间为
    `GrpcDemo.HelloRequest`，如图 *图 11.2* 所示。2*：
- en: '![Figure 11.2 – The namespace of the HelloRequest class](img/B18971_11_2.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – HelloRequest 类的命名空间](img/B18971_11_2.jpg)'
- en: Figure 11.2 – The namespace of the HelloRequest class
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – HelloRequest 类的命名空间
- en: The `HelloReply` class is also similar. However, you won’t be able to find the
    `HelloRequest` class and the `HelloReply` class in the project. Where are these
    classes defined?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloReply` 类也类似。然而，您在项目中找不到 `HelloRequest` 类和 `HelloReply` 类。这些类在哪里定义的？'
- en: 'You can press *F12* to go to the definition of the `HelloRequest` class in
    VS Code. You will be navigated to a `Greet.cs` file, which is located in the `obj\Debug\net8.0\Protos`
    folder. This file is generated by the proto file and contains the definition of
    the `HelloRequest` class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按 *F12* 键跳转到 VS Code 中 `HelloRequest` 类的定义。您将被导航到位于 `obj\Debug\net8.0\Protos`
    文件夹中的 `Greet.cs` 文件。此文件由 proto 文件生成，并包含 `HelloRequest` 类的定义：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the definition of the `HelloRequest` class, you can see that it implements
    the `IMessage<HelloRequest>` interface, which is defined in the `Google.Protobuf`
    package. All protobuf messages must implement this base interface. The `HelloRequest`
    class also has a `Name` property, which is defined in the proto file. You can
    find a `DebuggerNonUserCodeAttribute` attribute on the `Name` property. This attribute
    means that the `Name` member is not part of the user code for an application.
    The `Name` property also has a `GeneratedCode` attribute, which means this member
    is generated by the tooling. Specifically, the `Name` property is generated by
    the `protoc` tool, which is the protobuf compiler. Users should not modify this
    member.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HelloRequest` 类的定义中，我们可以看到它实现了 `IMessage<HelloRequest>` 接口，该接口定义在 `Google.Protobuf`
    包中。所有 protobuf 消息都必须实现这个基接口。`HelloRequest` 类还有一个 `Name` 属性，它在 proto 文件中定义。你可以在
    `Name` 属性上找到一个 `DebuggerNonUserCodeAttribute` 属性。这个属性意味着 `Name` 成员不是应用程序用户代码的一部分。`Name`
    属性还有一个 `GeneratedCode` 属性，这意味着这个成员是由工具生成的。具体来说，`Name` 属性是由 `protoc` 工具生成的，它是 protobuf
    编译器。用户不应修改此成员。
- en: 'You can also find the definition of the `HelloReply` class in the `Greet.cs`
    file. Next to the `Greet.cs` file, in the `Protos` folder, you can find a `GreetGrpc.cs`
    file, which defines the `GreeterBase` abstract class as the base class of the
    `GreeterService` class. Similarly, the `GreeterBase` class is also generated by
    the gRPC tooling. It contains the definition of the `SayHello()` method, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `Greet.cs` 文件中找到 `HelloReply` 类的定义。在 `Greet.cs` 文件旁边，在 `Protos` 文件夹中，你可以找到一个
    `GreetGrpc.cs` 文件，它定义了 `GreeterBase` 抽象类作为 `GreeterService` 类的基类。同样，`GreeterBase`
    类也是由 gRPC 工具生成的。它包含了 `SayHello()` 方法的定义，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `GreeterBase` class is marked with the `BindServiceMethod` attribute, which
    means this method is the implementation of the `SayHello()` method defined in
    the proto file. The `SayHello()` method has an attribute called `GeneratedCode`
    that indicates that this class is generated by the gRPC C# plugin. Inside the
    `SayHello()` method, you can see that it throws an exception by default. Because
    this method is `virtual`, we need to override this method in the `GreeterService`
    class to provide the actual implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreeterBase` 类被标记为 `BindServiceMethod` 属性，这意味着这个方法是 proto 文件中定义的 `SayHello()`
    方法的实现。`SayHello()` 方法有一个名为 `GeneratedCode` 的属性，表示这个类是由 gRPC C# 插件生成的。在 `SayHello()`
    方法内部，你可以看到它默认会抛出一个异常。因为这个方法是 `virtual` 的，所以我们需要在 `GreeterService` 类中重写这个方法以提供实际的实现。'
- en: 'Next, let’s check the `Program.cs` file. You will find the following code in
    the `Program.cs` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `Program.cs` 文件。你将在 `Program.cs` 文件中找到以下代码：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code block, we can see that the `AddGrpc()` method is called
    to add gRPC services to the service container. Then, we use the `MapGrpcService<GreeterService>()`
    method to map the `GreeterService` class to the gRPC service, which is similar
    to the `MapControllers` method in the RESTful API project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们可以看到调用了 `AddGrpc()` 方法向服务容器添加 gRPC 服务。然后，我们使用 `MapGrpcService<GreeterService>()`
    方法将 `GreeterService` 类映射到 gRPC 服务，这与 RESTful API 项目中的 `MapControllers` 方法类似。
- en: 'There is another line of code in the `Program.cs` file that uses the `MapGet()`
    method to show a message if users access the root path of the application from
    a web browser:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中还有另一行代码，它使用 `MapGet()` 方法在用户通过网页浏览器访问应用程序的根路径时显示一条消息：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because gRPC services cannot be accessed by a web browser. So, we need
    to show a message to notify users that they need to use a gRPC client to access
    the gRPC service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 gRPC 服务不能通过网页浏览器访问。所以，我们需要显示一条消息来通知用户他们需要使用 gRPC 客户端来访问 gRPC 服务。
- en: 'Let’s update the proto file and see what happens. Open the `greet.proto` file
    and update the `HelloRequest`, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 proto 文件并看看会发生什么。打开 `greet.proto` 文件并更新 `HelloRequest`，如下所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the file and go back to the `GreeterService` class. In the `SayHello()`
    method, you can try to access the `Address` property of the `HelloRequest` object.
    You will find that the `Address` property is not available. This is because the
    generated code is not updated. We need to regenerate the code by using the `dotnet
    build` command. Alternatively, you can delete the `obj` folder and the code will
    be regenerated automatically.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并返回到 `GreeterService` 类。在 `SayHello()` 方法中，你可以尝试访问 `HelloRequest` 对象的 `Address`
    属性。你会发现 `Address` 属性不可用。这是因为生成的代码没有更新。我们需要通过使用 `dotnet build` 命令来重新生成代码。或者，你可以删除
    `obj` 文件夹，代码将自动重新生成。
- en: 'You may find that it is not convenient to store the generated code in the `obj`
    folder. We can change the output directory of the generated code by using the
    `OutputDir` attribute in the `Protobuf` item in the `.csproj` file. For example,
    you can change the `Protobuf` item as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现将生成的代码存储在 `obj` 文件夹中并不方便。我们可以通过在 `.csproj` 文件中的 `Protobuf` 项中使用 `OutputDir`
    属性来更改生成的代码的输出目录。例如，你可以将 `Protobuf` 项更改为以下内容：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the generated code will be stored in the `Generated\Protos` folder. A
    proto file can generate multiple files for server-side code. For example, the
    `greet.proto` file will generate the following files:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成的代码将存储在 `Generated\Protos` 文件夹中。一个 proto 文件可以生成多个用于服务器端代码的文件。例如，`greet.proto`
    文件将生成以下文件：
- en: '`greet.cs`: This file contains the definition of the messages and the methods
    to serialize and deserialize the messages'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`greet.cs`: 此文件包含消息的定义以及序列化和反序列化消息的方法'
- en: '`greetGrpc.cs`: This file contains the definition of the base class of the
    service and the methods to bind the service to the server'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`greetGrpc.cs`: 此文件包含服务基类的定义以及将服务绑定到服务器的方法'
- en: Now that we understand the structure of the gRPC project, let’s learn the concepts
    behind protobuf messages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 gRPC 项目的结构，让我们学习 protobuf 消息背后的概念。
- en: Creating protobuf messages
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 protobuf 消息
- en: In this section, we will learn how to create protobuf messages. We will introduce
    the concepts of protobuf messages and how to define them in a proto file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建 protobuf 消息。我们将介绍 protobuf 消息的概念以及如何在 proto 文件中定义它们。
- en: gRPC is a contract-first framework, meaning that the gRPC service and messages
    must be defined in a proto file. When we talk about messages, we are talking about
    the data that is sent between the client and the server. While gRPC messages may
    be similar to the data model in RESTful APIs, they are not the same. RESTful APIs
    are centered around resources, and the data model is usually a resource model
    that can be mapped to one or multiple database tables. In contrast, gRPC is action-based,
    and the message can be any other type of data model or other message sent between
    the client and the server. Therefore, gRPC messages may not be exactly mapped
    to a resource model in RESTful APIs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是一种以合同为先的框架，这意味着 gRPC 服务和消息必须在 proto 文件中定义。当我们谈论消息时，我们指的是客户端和服务器之间发送的数据。虽然
    gRPC 消息可能与 RESTful API 中的数据模型相似，但它们并不相同。RESTful API 围绕资源，数据模型通常是资源模型，可以映射到一个或多个数据库表。相比之下，gRPC
    是基于操作的，消息可以是任何其他类型的数据模型或客户端和服务器之间发送的其他消息。因此，gRPC 消息可能无法精确映射到 RESTful API 中的资源模型。
- en: For example, when creating an invoice through a RESTful API using JSON as the
    data format, we need to send an HTTP POST request with a JSON body to the server.
    The JSON body will be deserialized into a .NET object, which serves as the data
    model for the invoice. To retrieve an invoice, we need to send an HTTP GET request
    to the server and the server. The server will serialize the data model into a
    JSON string and send it back to the client. We may also have other actions, such
    as updating an invoice, deleting an invoice, and so on. All these actions are
    mapped to HTTP methods.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当通过使用 JSON 作为数据格式的 RESTful API 创建发票时，我们需要向服务器发送一个带有 JSON 体的 HTTP POST 请求。JSON
    体会反序列化为 .NET 对象，该对象作为发票的数据模型。要检索发票，我们需要向服务器发送一个 HTTP GET 请求，服务器会将数据模型序列化为 JSON
    字符串并发送给客户端。我们可能还有其他操作，例如更新发票、删除发票等。所有这些操作都映射到 HTTP 方法。
- en: 'To implement the same functionality using gRPC, we need to define a gRPC service
    with several methods: `CreateInvoice()`, `GetInvoice()`, `UpdateInvoice()`, `DeleteInvoice()`,
    and others. For each of these methods, we must also define the corresponding request
    and response messages. For example, the `CreateInvoice()` method requires a `CreateInvoiceRequest`
    message containing the properties of the invoice, as well as a `CreateInvoiceResponse`
    message containing the ID of the created invoice. It is important to note that
    the request and response messages are distinct from the data model of the invoice,
    which is used to represent the invoice entity in the system. The request and response
    messages are used to send data between the client and the server.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用gRPC实现相同的功能，我们需要定义一个包含几个方法的gRPC服务：`CreateInvoice()`、`GetInvoice()`、`UpdateInvoice()`、`DeleteInvoice()`等。对于这些方法中的每一个，我们还必须定义相应的请求和响应消息。例如，`CreateInvoice()`方法需要一个包含发票属性的`CreateInvoiceRequest`消息，以及一个包含创建的发票ID的`CreateInvoiceResponse`消息。重要的是要注意，请求和响应消息与发票的数据模型不同，该模型用于在系统中表示发票实体。请求和响应消息用于在客户端和服务器之间发送数据。
- en: Note that gRPC and protobuf are not the same thing. protobuf is a language-neutral,
    platform-neutral data serialization format. gRPC is a framework that uses protobuf
    as the default data serialization format. Sometimes, these two terms are used
    interchangeably, but we should know the difference between them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，gRPC和protobuf不是同一回事。protobuf是一种语言无关、平台无关的数据序列化格式。gRPC是一个使用protobuf作为默认数据序列化格式的框架。有时，这两个术语可以互换使用，但我们应该了解它们之间的区别。
- en: Think about the invoice example we mentioned previously. An invoice has several
    properties, such as the invoice number, the invoice date, the customer’s name,
    the total amount, and so on. A customer has a name and an address. An address
    has some properties, such as street, city, state, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们之前提到的发票示例。发票有几个属性，例如发票号码、发票日期、客户名称、总金额等等。客户有一个名称和一个地址。地址有一些属性，例如街道、城市、州等等。
- en: Next, we’ll define the first message that is used to create an address for the
    invoice service. The source code for this section can be found in the `chapter11/GrpcDemo-v2`
    folder. We will start with a simple message and then introduce more concepts regarding
    protobuf messages, including field numbers, field types, and how to use other
    .NET types in protobuf messages. We will also learn how to implement list and
    dictionary types using the `repeated` and `map` keywords.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义第一个消息，该消息用于为发票服务创建地址。本节的源代码可以在`chapter11/GrpcDemo-v2`文件夹中找到。我们将从一个简单的消息开始，然后介绍有关protobuf消息的更多概念，包括字段编号、字段类型以及如何在protobuf消息中使用其他.NET类型。我们还将学习如何使用`repeated`和`map`关键字实现列表和字典类型。
- en: Defining a protobuf message
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义protobuf消息
- en: 'Create a new `invoice.proto` file in the `Protos` folder. VS Code provides
    a proto file template when you create a new file, as shown in *Figure 11**.3*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Protos”文件夹中创建一个新的`invoice.proto`文件。当您创建新文件时，VS Code会提供一个proto文件模板，如图*11.3*所示：
- en: '![Figure 11.3 – The proto file template in VS Code](img/B18971_11_3.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – VS Code中的proto文件模板](img/B18971_11_3.jpg)'
- en: Figure 11.3 – The proto file template in VS Code
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – VS Code中的proto文件模板
- en: 'The proto file template creates a proto file named `Protos.proto`. Rename it
    `invoice.proto`. The content of the proto file is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: proto文件模板创建了一个名为`Protos.proto`的proto文件。将其重命名为`invoice.proto`。proto文件的内容如下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A proto file is a text file with the `.proto` extension. The first line of the
    proto file specifies the syntax version of the proto file. At the time of writing,
    the latest version of the proto file is version 3, which was released in 2016\.
    You can find more information about the proto file syntax at [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: proto文件是一个具有`.proto`扩展名的文本文件。proto文件的第一行指定了proto文件的语法版本。在撰写本文时，proto文件的最新版本是2016年发布的版本3。您可以在[https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/)找到有关proto文件语法的更多信息。
- en: The `option csharp_namespace` line specifies the namespace of the generated
    code in C#. You can change the namespace according to your needs. This option
    is used to avoid naming conflicts between different proto files. Note that even
    though a proto file is language-neutral, the `option csharp_namespace` attribute
    is only used by the C# code generator. In this sample project, we can change the
    namespace to `GrpcDemo` to match the namespace of the existing code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`option csharp_namespace` 行指定了 C# 生成代码的命名空间。你可以根据需要更改命名空间。此选项用于避免不同 proto 文件之间的命名冲突。请注意，尽管
    proto 文件是语言中立的，但 `option csharp_namespace` 属性仅由 C# 代码生成器使用。在这个示例项目中，我们可以将命名空间更改为
    `GrpcDemo` 以匹配现有代码的命名空间。'
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Protobuf supports a `package` keyword to avoid naming conflicts, depending on
    the language. For example, `package com.company` is equivalent to `option csharp_namespace
    = "Com.Company"` in C# (the name will be converted into PascalCase), and `package
    com.company` is equivalent to `option java_package = "com.company"` in Java. However,
    `package com.company` will be ignored in Python since Python modules are organized
    by filesystem directories.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 支持使用 `package` 关键字来避免命名冲突，具体取决于语言。例如，`package com.company` 在 C# 中相当于
    `option csharp_namespace = "Com.Company"`（名称将被转换为 PascalCase），而在 Java 中 `package
    com.company` 相当于 `option java_package = "com.company"`。然而，在 Python 中 `package
    com.company` 将会被忽略，因为 Python 模块是按照文件系统目录组织的。
- en: Since we are using C#, we use the `option csharp_namespace` attribute, which
    can override the `package` keyword for C# applications. If you share the proto
    file with other applications that use other languages, you can use the `package`
    keyword or the language-specific option to avoid naming conflicts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 C#，我们使用 `option csharp_namespace` 属性，它可以覆盖 C# 应用程序的 `package` 关键字。如果你与其他使用其他语言的程序共享
    proto 文件，你可以使用 `package` 关键字或语言特定的选项来避免命名冲突。
- en: 'Once the proto file has been created, we need to add it to the project file.
    Open the `GrpcDemo.csproj` file and add the following code to an `<``ItemGroup>`
    element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 proto 文件，我们需要将其添加到项目文件中。打开 `GrpcDemo.csproj` 文件，并将以下代码添加到 `<ItemGroup>`
    元素中：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the gRPC tooling will generate the code for the `invoice.proto` file when
    we build the project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在构建项目时，gRPC 工具将生成 `invoice.proto` 文件的代码。
- en: 'gRPC proto3 uses similar concepts as .NET classes to define messages. However,
    there are some differences. For example, proto3 does not support `GUID` and `decimal`
    types. Let’s start with a simple message. We can define an `Address` message as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC proto3 使用与 .NET 类相似的概念来定义消息。然而，也有一些不同之处。例如，proto3 不支持 `GUID` 和 `decimal`
    类型。让我们从一个简单的消息开始。我们可以定义一个 `Address` 消息如下：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, it is similar to a .NET class. We use a `message` keyword to
    define a gRPC message. In the message body, we can use `string` to declare a string
    field. However, there are some questions to answer here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它与 .NET 类相似。我们使用 `message` 关键字来定义 gRPC 消息。在消息体中，我们可以使用 `string` 来声明一个字符串字段。然而，这里有一些问题需要回答：
- en: Why do we assign a number to each property? Is it the default value?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们要给每个属性分配一个数字？它是默认值吗？
- en: Why does the number start with 1? Can we use 0?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么数字从 1 开始？我们能否使用 0？
- en: Should we use these numbers in a specific order?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否应该按照特定的顺序使用这些数字？
- en: Let’s answer these questions before we move on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回答这些问题。
- en: Understanding field numbers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解字段编号
- en: 'The numbers following the field names are called *field numbers*. Field numbers
    play an important role in the proto file. These field numbers are used to identify
    the fields in the message. What is the benefit of using field numbers instead
    of field names? Let’s look at an example of an XML document:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名后面的数字被称为 *字段编号*。字段编号在 proto 文件中扮演着重要的角色。这些字段编号用于识别消息中的字段。使用字段编号而不是字段名称有什么好处？让我们看看一个
    XML 文档的例子：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding XML document, each field is wrapped in a tag. We have to open
    and close the tags to wrap the values of the fields. The XML syntax wastes a lot
    of space when transferring data. Consider the following example of a JSON document:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 XML 文档中，每个字段都被一个标签包裹。我们必须打开和关闭这些标签来包裹字段的值。XML 语法在传输数据时浪费了大量的空间。考虑以下 JSON
    文档的例子：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding JSON document, we just use each field name once. Normally,
    JSON format is more compact than XML format. What if we get rid of the field names?
    That is why we use field numbers in the proto file. By using field numbers instead
    of field names when encoding the message, we can make the gRPC message more compact.
    This is because numbers are shorter than field names. Additionally, protobuf uses
    a binary format, which is more compact than plain text formats such as JSON and
    XML. This further helps reduce the size of the message.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 JSON 文档中，我们只使用每个字段名称一次。通常，JSON 格式比 XML 格式更紧凑。如果我们去掉字段名称会怎样？这就是为什么我们在 proto
    文件中使用字段编号的原因。通过在编码消息时使用字段编号而不是字段名称，我们可以使 gRPC 消息更加紧凑。这是因为数字比字段名称短。此外，protobuf
    使用二进制格式，这比 JSON 和 XML 等纯文本格式更紧凑。这进一步有助于减少消息的大小。
- en: 'There are a few things to note about field numbers according to the protobuf
    documentation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 protobuf 文档，关于字段编号有一些需要注意的事项：
- en: The range of field numbers is from `1` to `536,870,911`. So we cannot use `0`
    as a field number.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段编号的范围是从 `1` 到 `536,870,911`。因此，我们不能使用 `0` 作为字段编号。
- en: The field numbers must be unique within a message.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段编号必须在消息内是唯一的。
- en: Field numbers `19000` to `19999` are reserved for protobuf, so you cannot use
    them.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段编号 `19000` 到 `19999` 是为 protobuf 保留的，因此不能使用它们。
- en: Technically, the order of the field numbers does not matter. It is recommended
    to use the ascending order of the field numbers. Smaller field numbers use fewer
    bytes to encode. For example, a field number between `1` and `15` uses only one
    byte to encode, but numbers from `16` to `2047` use two bytes.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从技术上讲，字段编号的顺序并不重要。建议使用字段编号的升序。较小的字段编号使用更少的字节进行编码。例如，编号在 `1` 到 `15` 之间的字段仅使用一个字节进行编码，但编号从
    `16` 到 `2047` 的字段则使用两个字节。
- en: Once a field number is assigned to a field, it cannot be changed if the proto
    file is used in production. Changing a field number will break the backward compatibility
    of the proto file.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦将字段编号分配给字段，如果 proto 文件在生产中使用，则不能更改。更改字段编号将破坏 proto 文件的向后兼容性。
- en: With that, we have learned what field numbers are and why we use them. Next,
    let’s understand field types.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经学习了字段编号是什么以及为什么使用它们。接下来，让我们了解字段类型。
- en: Understanding the field types
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解字段类型
- en: 'Similar to .NET classes, a gRPC message can have different types of fields.
    protobuf provides a set of native types, which are called **scalar value types**.
    These scalar value types have representations in most programming languages. The
    following table lists the mapping between protobuf scalar value types and .NET
    types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与 .NET 类类似，gRPC 消息可以有不同的字段类型。protobuf 提供了一组原生类型，这些类型被称为**标量值类型**。这些标量值类型在大多数编程语言中都有表示。下表列出了
    protobuf 标量值类型与 .NET 类型之间的映射：
- en: '| **Protobuf Type** | **.****NET Type** | **Notes** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **Protobuf 类型** | **.NET 类型** | **注意事项** |'
- en: '| --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `double` | `double` | ±5.0 × 10−324 to ±1.7 × 10308. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `double` | ±5.0 × 10−324 到 ±1.7 × 10308。|'
- en: '| `float` | `float` | ±1.5 x 10−45 to ±3.4 x 1038. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `float` | ±1.5 x 10−45 到 ±3.4 x 1038。|'
- en: '| `int32` | `int` | The length is variable. Use `sint32` if the field has negative
    numbers. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | `int` | 长度可变。如果字段有负数，请使用 `sint32`。|'
- en: '| `int64` | `long` | The length is variable. Use `sint64` if the field has
    negative numbers. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `long` | 长度可变。如果字段有负数，请使用 `sint64`。|'
- en: '| `uint32` | `uint` | The length is variable. Unsigned integer. 0 to (232-1).
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `uint` | 长度可变。无符号整数。0 到 (232-1)。|'
- en: '| `uint64` | `ulong` | The length is variable. Unsigned integer. 0 to (264-1).
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `ulong` | 长度可变。无符号整数。0 到 (264-1)。|'
- en: '| `sint32` | `int` | The length is variable. Signed integer. -231 to (231-1).
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `sint32` | `int` | 长度可变。有符号整数。-231 到 (231-1)。|'
- en: '| `sint64` | `long` | The length is variable. Signed integer. -263 to (263-1).
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `sint64` | `long` | 长度可变。有符号整数。-263 到 (263-1)。|'
- en: '| `fixed32` | `uint` | The length is always 4 bytes. This type is more efficient
    than `uint32` for serializing or deserializing values that are greater than 228.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `fixed32` | `uint` | 长度始终为 4 字节。此类型在序列化或反序列化大于 228 的值时比 `uint32` 更有效。|'
- en: '| `fixed64` | `ulong` | The length is always 8 bytes. This type is more efficient
    than `uint64` for serializing or deserializing values that are greater than 256.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `fixed64` | `ulong` | 长度始终为 8 字节。此类型在序列化或反序列化大于 256 的值时比 `uint64` 更有效。|'
- en: '| `sfixed32` | `int` | The length is always 4 bytes. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed32` | `int` | 长度始终为 4 字节。|'
- en: '| `sfixed64` | `long` | The length is always 8 bytes. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed64` | `long` | 长度始终为 8 字节。|'
- en: '| `bool` | `bool` |  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |  |'
- en: '| `string` | `string` | A `string` field must be encoded in UTF-8 or 7-bit
    ASCII. The maximum length of a `string` field is 232. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `string` | `string` 字段必须以 UTF-8 或 7 位 ASCII 编码。`string` 字段的长度最大为
    232。|'
- en: '| `bytes` | `ByteString` | This type is defined in protobuf runtime. It can
    be mapped to and from C#’s `byte[]` type. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | `ByteString` | 此类型定义在 protobuf 运行时中。它可以映射到并从 C# 的 `byte[]` 类型转换。|'
- en: Table 11.1 – Protobuf scalar value types and .NET types
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – Protobuf 标量值类型和 .NET 类型
- en: 'Let’s create a new message named `CreateContactRequest` and add some fields
    to it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `CreateContactRequest` 的新消息并添加一些字段到它中：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `CreateContactRequest` message requires the `first_name`, `last_name`, `email`,
    `phone`, `year_of_birth`, and `is_active` fields. The types for these fields are
    `string`, `int32`, and `bool`, respectively.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateContactRequest` 消息需要 `first_name`、`last_name`、`email`、`phone`、`year_of_birth`
    和 `is_active` 字段。这些字段的类型分别是 `string`、`int32` 和 `bool`。'
- en: Next, we can run `dotnet build` to generate the code. Alternatively, you can
    delete the existing files in the `Generated` folder and gRPC tooling will regenerate
    the code automatically based on the proto files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以运行 `dotnet build` 来生成代码。或者，您也可以删除 `Generated` 文件夹中的现有文件，gRPC 工具将根据 proto
    文件自动重新生成代码。
- en: 'The generated code files contain some complicated code. However, we can find
    the definition of the `CreateContactRequest` class, which is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码文件包含一些复杂的代码。然而，我们可以找到 `CreateContactRequest` 类的定义，如下所示：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code block, some code has been omitted for brevity. You can
    see that the `CreateContactRequest` message has been converted into a .NET class,
    which includes the properties for each field.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，为了简洁起见，省略了一些代码。您可以看到 `CreateContactRequest` 消息已被转换为 .NET 类，其中包含每个字段的属性。
- en: Important note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Protobuf has a style guide for naming fields and methods. The general rules
    are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 为字段和方法的命名提供了一组风格指南。一般规则如下：
- en: Use `lower_snake_case` for field names
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段名使用 `lower_snake_case`
- en: Use `PascalCase` for method names
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名使用 `PascalCase`
- en: File names should be in `lower_snake_case`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名应使用 `lower_snake_case`
- en: Using double quotes for string literals is preferred over single quotes
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双引号表示字符串字面量比使用单引号更受欢迎
- en: The indentation should be two spaces in length
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进应为两个空格的长度
- en: You can find more information at [https://protobuf.dev/programming-guides/style/](https://protobuf.dev/programming-guides/style/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://protobuf.dev/programming-guides/style/](https://protobuf.dev/programming-guides/style/)
    找到更多信息。
- en: With that, we’ve learned how to use protobuf scalar value types. Now, let’s
    consider other types.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何使用 protobuf 标量值类型。现在，让我们考虑其他类型。
- en: Other .NET types
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 .NET 类型
- en: The protobuf scalar data types do not support all the .NET types, such as `Guid`,
    `DateTime`, `decimal`, and others. There are some workarounds for these types.
    In this section, we will learn how to use these types in protobuf. We will also
    explore some other types, such as `enum` and `repeated`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: protobuf 的标量数据类型不支持所有 .NET 类型，例如 `Guid`、`DateTime`、`decimal` 等。对于这些类型有一些解决方案。在本节中，我们将学习如何在
    protobuf 中使用这些类型。我们还将探索一些其他类型，如 `enum` 和 `repeated`。
- en: GUID values
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GUID 值
- en: The `GUID` type (on other platforms, it may have another name, `UUID`) is a
    128-bit structure that is used to identify objects. It is a very common type in
    .NET applications. Normally, a `GUID` value can be represented as a string that
    contains 32 hexadecimal digits. For example, `31F6E4E7-7C48-4F91-8D33-7A74F6729C8B`
    is a `GUID` value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`GUID` 类型（在其他平台上可能具有另一个名称，`UUID`）是一个 128 位的结构，用于标识对象。它在 .NET 应用程序中非常常见。通常，`GUID`
    值可以表示为一个包含 32 个十六进制数字的字符串。例如，`31F6E4E7-7C48-4F91-8D33-7A74F6729C8B` 是一个 `GUID`
    值。'
- en: However, protobuf does not support the `GUID` type. The best way to represent
    a `GUID` value in protobuf is to use a `string` field. In the .NET code, we can
    use `Guid.Parse()` to convert a string into a `GUID` value and use `Guid.ToString()`
    to convert a `GUID` value into a string.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，protobuf 不支持 `GUID` 类型。在 protobuf 中表示 `GUID` 值的最佳方式是使用 `string` 字段。在 .NET
    代码中，我们可以使用 `Guid.Parse()` 将字符串转换为 `GUID` 值，并使用 `Guid.ToString()` 将 `GUID` 值转换为字符串。
- en: DateTime values
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期时间值
- en: .NET has several types to represent a date and time value, such as `DateTime`,
    `DateTimeOffset`, and `TimeSpan`. Although protobuf does not support these types
    directly, it provides several extensions to support them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 有几种类型来表示日期和时间值，例如 `DateTime`、`DateTimeOffset` 和 `TimeSpan`。尽管 protobuf
    不直接支持这些类型，但它提供了几个扩展来支持它们。
- en: 'To use these extension types, we need to import the `google/protobuf/xxx.proto`
    file into the proto file. For example, here is a message that contains a timestamp
    and a duration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些扩展类型，我们需要将`google/protobuf/xxx.proto`文件导入到proto文件中。例如，以下是一个包含时间戳和持续时间的消息：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check the generated code for the `UpdateInvoiceDueDateRequest` message in the
    `Generated` folder. You will find that the `due_date` field is converted into
    a `Timestamp` type, and the `grace_period` field is converted into a `Duration`
    type, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`Generated`文件夹中生成的`UpdateInvoiceDueDateRequest`消息的代码。你会发现`due_date`字段被转换为`Timestamp`类型，而`grace_period`字段被转换为`Duration`类型，如下所示：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Timestamp` type and the `Duration` type are not native .NET types. They
    are defined in the `Google.Protobuf.WellKnownTypes` namespace, which includes
    some well-known types that are not supported by protobuf. The source code for
    these types can be found at [https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes](https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timestamp`类型和`Duration`类型不是原生.NET类型。它们在`Google.Protobuf.WellKnownTypes`命名空间中定义，该命名空间包含一些protobuf不支持的可知类型。这些类型的源代码可以在[https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes](https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes)找到。'
- en: 'Because these types are not native .NET types, we need to convert them into
    native .NET types when using them. The `Google.Protobuf.WellKnownTypes` namespace
    provides some methods to do the conversion. Here is an example of converting .NET
    types into protobuf types:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些类型不是原生.NET类型，所以在使用时需要将它们转换为原生.NET类型。`Google.Protobuf.WellKnownTypes`命名空间提供了一些转换方法。以下是将.NET类型转换为protobuf类型的示例：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can use the `Timestamp` class to convert `DateTime` and `DateTimeOffset`
    values into `Timestamp` values. The `Timestamp.FromDateTime()` method is used
    to convert a `DateTime` value, while the `Timestamp.FromDateTimeOffset()` method
    is used to convert a `DateTimeOffset` value. We can also use the `Duration.FromTimeSpan()`
    method to convert a `TimeSpan` value into a `Duration` value. Note that if you
    use the `DateTimeOffset` type in your application, the offset of `DateTimeOffset`
    values is always 0, and the `DateTime.Kind` property is always set to `DateTimeKind.Utc`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Timestamp`类将`DateTime`和`DateTimeOffset`值转换为`Timestamp`值。`Timestamp.FromDateTime()`方法用于转换`DateTime`值，而`Timestamp.FromDateTimeOffset()`方法用于转换`DateTimeOffset`值。我们还可以使用`Duration.FromTimeSpan()`方法将`TimeSpan`值转换为`Duration`值。请注意，如果您在应用程序中使用`DateTimeOffset`类型，则`DateTimeOffset`值的偏移量始终为0，并且`DateTime.Kind`属性始终设置为`DateTimeKind.Utc`。
- en: 'Similarly, we can convert protobuf types into .NET types:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将protobuf类型转换为.NET类型：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Timestamp` class provides several methods for converting its values into
    other types. The `ToDateTime()` method can be used to convert a `Timestamp` value
    into a `DateTime` value, while the `ToTimeSpan()` method can be used to convert
    a `Duration` value into a `TimeSpan` value. Additionally, the `ToDateTimeOffset()`
    method can be used to convert a `Timestamp` value into a `DateTimeOffset` value.
    Depending on your requirements, you can select the appropriate method for your
    needs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timestamp`类提供了几种将它的值转换为其他类型的方法。`ToDateTime()`方法可以用于将`Timestamp`值转换为`DateTime`值，而`ToTimeSpan()`方法可以用于将`Duration`值转换为`TimeSpan`值。此外，`ToDateTimeOffset()`方法可以用于将`Timestamp`值转换为`DateTimeOffset`值。根据您的需求，您可以选择适合您需求的方法。'
- en: Decimal values
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十进制值
- en: 'At the time of writing, protobuf does not support the `decimal` type directly.
    There are some discussions about adding the `decimal` type to protobuf, but it
    hasn’t been implemented yet. As a workaround, Microsoft Docs provides a `DecimalValue`
    type, which can be used to represent a `decimal` value in protobuf. The following
    code, which has been copied from Microsoft Docs, shows how to define a `decimal`
    value in protobuf:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，protobuf不支持直接使用`decimal`类型。有一些关于将`decimal`类型添加到protobuf的讨论，但尚未实现。作为解决方案，Microsoft
    Docs提供了一个`DecimalValue`类型，可以用于在protobuf中表示`decimal`值。以下是从Microsoft Docs复制的代码，展示了如何在protobuf中定义`decimal`值：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will not delve into the details of the `DecimalValue` type in this book.
    You can find more information at [https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将不会深入探讨 `DecimalValue` 类型的细节。更多信息请参阅[https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals)。
- en: Enum values
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举值
- en: 'The `enum` type is very common in .NET applications. protobuf supports the
    `enum` type. Here’s an example of its usage:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET 应用程序中，`enum` 类型非常常见。protobuf 支持枚举类型。以下是其使用示例：'
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding enum definition is similar to the enum definition in C#, but
    we need to define it in the proto file. In the preceding code, we define an `InvoiceStatus`
    enum type with six values. Note that every enum type must contain a `0` value,
    which is the default value and must be placed at the first position. The `InvoiceStatus`
    enum type is converted into a .NET enum type, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的枚举定义与 C# 中的枚举定义类似，但我们需要在 proto 文件中定义它。在前面代码中，我们定义了一个包含六个值的 `InvoiceStatus`
    枚举类型。请注意，每个枚举类型都必须包含一个 `0` 值，这是默认值，并且必须放在第一个位置。`InvoiceStatus` 枚举类型将被转换为 .NET
    枚举类型，如下所示：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the `INVOICE_STATUS` prefix in the original names is removed
    because the prefix is the same as the enum name. In the .NET code, the enum names
    are converted into PascalCase.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，原始名称中的 `INVOICE_STATUS` 前缀被移除，因为前缀与枚举名称相同。在 .NET 代码中，枚举名称被转换为 PascalCase。
- en: Besides the `enum` type, .NET also has a common type named `nullable`. We’ll
    check out nullable types in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了枚举类型外，.NET 还有一个名为 `nullable` 的常见类型。我们将在下一节中检查可空类型。
- en: Nullable values
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可空值
- en: 'Protobuf scalar value types, such as `int32`, `sint32`, `fixed32`, and `bool`,
    cannot be `null`. But in .NET, nullable value types are very common. For example,
    we can use `int?` to declare an integer value that can be `null`. To support nullable
    value types, protobuf provides some wrapper types, which are defined in the `google/protobuf/wrappers.proto`
    file, to support nullable types. We can import this file into the proto file and
    use the wrapper types. For example, we can define a message as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 标量值类型，如 `int32`、`sint32`、`fixed32` 和 `bool`，不能为 `null`。但在 .NET 中，可空值类型非常常见。例如，我们可以使用
    `int?` 来声明一个可以 `null` 的整数值。为了支持可空值类型，protobuf 提供了一些包装类型，这些类型在 `google/protobuf/wrappers.proto`
    文件中定义，以支持可空类型。我们可以将此文件导入到 proto 文件中，并使用包装类型。例如，我们可以定义一个消息如下：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, the `google.protobuf.DoubleValue` type is used to represent
    a nullable `double` value, the `google.protobuf.Int32Value` type is used to represent
    a nullable `int32` value, and the `google.protobuf.BoolValue` type is used to
    define a nullable `bool` value. The generated code for the `AddInvoiceItemRequest`
    message is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中，`google.protobuf.DoubleValue` 类型用于表示可空 `double` 值，`google.protobuf.Int32Value`
    类型用于表示可空 `int32` 值，`google.protobuf.BoolValue` 类型用于定义可空 `bool` 值。`AddInvoiceItemRequest`
    消息的生成代码如下所示：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the `unitPrice`, `quantity`, and `IsTaxable` fields are converted
    into nullable types in .NET.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`unitPrice`、`quantity` 和 `IsTaxable` 字段在 .NET 中被转换为可空类型。
- en: 'Most of .NET nullable types are supported by protobuf. Besides the `google.protobuf.DoubleValue`,
    `google.protobuf.Int32Value`, and `google.protobuf.BoolValue` types, protobuf
    also provides the following wrapper types:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 .NET 可空类型都由 protobuf 支持。除了 `google.protobuf.DoubleValue`、`google.protobuf.Int32Value`
    和 `google.protobuf.BoolValue` 类型外，protobuf 还提供了以下包装类型：
- en: '`google.protobuf.FloatValue`: This type is used to represent a `float`? value.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.protobuf.FloatValue`：此类型用于表示 `float`? 值。'
- en: '`google.protobuf.Int64Value`: This type is used to represent a `long`? value.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.protobuf.Int64Value`：此类型用于表示 `long`? 值。'
- en: '`google.protobuf.UInt32Value`: This type is used to represent a `uint`? value.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.protobuf.UInt32Value`：此类型用于表示 `uint`? 值。'
- en: '`google.protobuf.UInt64Value`: This type is used to represent a `ulong`? value.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.protobuf.UInt64Value`：此类型用于表示 `ulong`? 值。'
- en: '`google.protobuf.StringValue`: This type is used to represent a `string` value.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.protobuf.StringValue`：此类型用于表示 `string` 值。'
- en: '`google.protobuf.BytesValue`: This type is used to represent a `ByteString`
    value.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.protobuf.BytesValue`：此类型用于表示 `ByteString` 值。'
- en: 'There are two special types in the preceding list: `google.protobuf.StringValue`
    and `google.protobuf.BytesValue`. The corresponding .NET types are `string` and
    `ByteString`. The `ByteString` type is a class that represents an immutable array
    of bytes, which is defined in the protobuf runtime. The default value of these
    two types is `null`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中，有两个特殊类型：`google.protobuf.StringValue` 和 `google.protobuf.BytesValue`。对应的
    .NET 类型是 `string` 和 `ByteString`。`ByteString` 类型是一个表示不可变字节数组的类，它在 protobuf 运行时中定义。这两个类型的默认值是
    `null`。
- en: So, if `google.protobuf.StringValue` is mapped to `string` in .NET, what is
    the difference between `google.protobuf.StringValue` and `string` in protobuf?
    The difference is the default value. We’ll look at the default values of these
    types in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `google.protobuf.StringValue` 在 .NET 中映射为 `string`，那么 `google.protobuf.StringValue`
    和 protobuf 中的 `string` 之间有什么区别？区别在于默认值。我们将在下一节中查看这些类型的默认值。
- en: Default values
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值
- en: 'The following table lists the default values of the scalar value types:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了标量值类型的默认值：
- en: '| **Protobuf Type** | **Default Value** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **Protobuf 类型** | **默认值** |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `string` | An empty string |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 一个空字符串 |'
- en: '| `bytes` | An empty byte array |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | 一个空字节数组 |'
- en: '| `bool` | `false` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `false` |'
- en: '| Numeric types | `0` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 数值类型 | `0` |'
- en: '| `enums` | The first enum value |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `enums` | 第一个枚举值 |'
- en: Table 11.2 – Default values of protobuf scalar value types
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.2 – Protobuf 标量值类型的默认值
- en: If you use `string` as the type of a field, the default value will be an empty
    string. However, the default value of a `google.protobuf.StringValue` field is
    `null`. Similarly, the default value of a `bytes` field is an empty byte array,
    while the default value of a `google.protobuf.BytesValue` field is `null`. All
    other wrapper types also have a default value of `null`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `string` 作为字段的类型，默认值将是一个空字符串。然而，`google.protobuf.StringValue` 字段的默认值是 `null`。同样，`bytes`
    字段的默认值是一个空字节数组，而 `google.protobuf.BytesValue` 字段的默认值是 `null`。所有其他包装类型也有一个默认值 `null`。
- en: All numeric types, including `int32`, `double`, and `float`, have a default
    value of `0`. This applies to all numerical data types. `Enum` types in protobuf
    have a default value of the first value in the enum type, which must be 0\. For
    instance, the `InvoiceStatus` enum type has a default value of `INVOICE_STATUS_UNKNOWN`,
    which is `0`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数值类型，包括 `int32`、`double` 和 `float`，都有一个默认值 `0`。这适用于所有数值数据类型。protobuf 中的 `Enum`
    类型有一个默认值，即枚举类型中的第一个值，必须是 `0`。例如，`InvoiceStatus` 枚举类型的默认值是 `INVOICE_STATUS_UNKNOWN`，即
    `0`。
- en: Repeated fields
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复字段
- en: 'Similar to .NET collections, protobuf supports repeated fields. A repeated
    field can contain zero or more items. The following code shows how to define a
    repeated field:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 .NET 集合类似，protobuf 支持重复字段。重复字段可以包含零个或多个项目。以下代码展示了如何定义重复字段：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we use the `repeated` keyword to define a repeated field.
    The generated code for the repeated `invoice_ids` field in the `UpdateInvoicesStatusRequest`
    message is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用 `repeated` 关键字定义了一个重复字段。在 `UpdateInvoicesStatusRequest` 消息中，重复的
    `invoice_ids` 字段的生成代码如下：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the generated code, we can see that the repeated `string` field is converted
    into a `RepeatedField<string>` type. The `RepeatedField<T>` type is defined in
    the `Google.Protobuf.Collections` namespace, and it implements the .NET collection
    interfaces, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成的代码中，我们可以看到重复的 `string` 字段被转换为 `RepeatedField<string>` 类型。`RepeatedField<T>`
    类型在 `Google.Protobuf.Collections` 命名空间中定义，并实现了 .NET 集合接口，如下所示：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `RepeatedField<T>` type can be used as a normal .NET collection type, and
    any LINQ methods can be applied to it. This makes it a powerful and versatile
    tool for data manipulation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeatedField<T>` 类型可以用作正常的 .NET 集合类型，并且可以对其应用任何 LINQ 方法。这使得它成为数据操作的一个强大且多功能的工具。'
- en: 'You will also find that the `InvoiceIds` field is a read-only property. To
    add one or multiple items to the collection, the `Add()` method can be used. Here’s
    an example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现 `InvoiceIds` 字段是一个只读属性。要向集合中添加一个或多个项目，可以使用 `Add()` 方法。以下是一个示例：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The default value of a repeated field is an empty collection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重复字段的默认值是一个空集合。
- en: Map fields
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射字段
- en: 'Protobuf supports map fields, which are collections of key-value pairs similar
    to a .NET dictionary. The following code provides an example of how to define
    a map field:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 支持映射字段，它类似于 .NET 字典的键值对集合。以下代码提供了一个如何定义映射字段的示例：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The generated code for the `invoice_status_map` field is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoice_status_map` 字段的生成代码如下：'
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `MapField<Tkey, TValue>` type is defined in the `Google.Protobuf.Collections`
    namespace and it implements the `IDictionary<TKey, TValue>` interface, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapField<Tkey, TValue>` 类型定义在 `Google.Protobuf.Collections` 命名空间中，并实现了 `IDictionary<TKey,
    TValue>` 接口，如下所示：'
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `MapField<TKey, TValue>` type can be used as a normal .NET dictionary type.
    This type provides the same functionality as a standard dictionary, allowing for
    the storage and retrieval of key-value pairs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapField<TKey, TValue>` 类型可以用作正常的 .NET 字典类型。此类型提供了与标准字典相同的功能，允许存储和检索键值对。'
- en: 'Similar to the repeated field, the `InvoiceStatusMap` field is also a read-only
    property. We can use the `Add()` method to add one key-value pair or multiple
    key-value pairs to the collection, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与重复字段类似，`InvoiceStatusMap` 字段也是一个只读属性。我们可以使用 `Add()` 方法向集合中添加一个键值对或多个键值对，如下所示：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that map fields cannot be repeated. Also, the key of a map field must be
    a `string` or integer type. You cannot use an `enum` type as the key of a map
    field. The value of a map field can be any type, including a message type. But
    the value type cannot be another map field.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，映射字段不能重复。此外，映射字段的键必须是 `string` 或整数类型。你不能将 `enum` 类型用作映射字段的键。映射字段的值可以是任何类型，包括消息类型。但值类型不能是另一个映射字段。
- en: We have now acquired a comprehensive understanding of protobuf messages, including
    field numbers, field types, default values, repeated fields, and map fields. For
    further information on protobuf messages, please refer to [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对 protobuf 消息有了全面的理解，包括字段编号、字段类型、默认值、重复字段和映射字段。有关 protobuf 消息的更多信息，请参阅
    [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/)。
- en: Next, we’ll examine the various protobuf services. We will explore the various
    types of RPC methods and how to create a gRPC client for the service. By doing
    so, we will gain a better understanding of how these services function and how
    to use them effectively.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查各种 protobuf 服务。我们将探讨各种 RPC 方法的类型以及如何为服务创建 gRPC 客户端。通过这样做，我们将更好地理解这些服务的工作原理以及如何有效地使用它们。
- en: Creating a protobuf service
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 protobuf 服务
- en: Now that we have understood the definition of a protobuf message, we can move
    on to defining protobuf services. These services are comprised of RPC methods,
    each of which has a request and response message. To facilitate the implementation
    of these services, gRPC tooling will generate the necessary C# code, which can
    then be used as the base class for the service.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了 protobuf 消息的定义，我们可以继续定义 protobuf 服务。这些服务由 RPC 方法组成，每个方法都有一个请求消息和一个响应消息。为了便于实现这些服务，gRPC
    工具将生成必要的 C# 代码，然后可以将该代码用作服务的基础类。
- en: 'gRPC supports four types of RPC methods:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 支持四种类型的 RPC 方法：
- en: '**Unary RPC**: The client sends a single request message to the server and
    receives a single response message in return. This type of method is suitable
    for applications that need single request-response exchanges.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一 RPC**：客户端向服务器发送一个单一请求消息，并收到一个单一响应消息。此类方法适用于需要单一请求-响应交换的应用程序。'
- en: '**Server streaming RPC**: The client sends a single request message to the
    server and the server then responds with a stream of response messages. This type
    of method allows for continuous data exchange between the client and server.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器流式 RPC**：客户端向服务器发送一个单一请求消息，然后服务器响应一个响应消息流。此类方法允许客户端和服务器之间进行连续的数据交换。'
- en: '**Client streaming RPC**: The client sends a stream request message to the
    server and the server then responds with a response message. Similar to server
    streaming RPC, this type of method also allows for a continuous data exchange
    but the data change is initiated by the client.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端流式 RPC**：客户端向服务器发送一个流请求消息，然后服务器响应一个响应消息。类似于服务器流式 RPC，此类方法也允许进行连续的数据交换，但数据变化是由客户端发起的。'
- en: '**Bidirectional streaming RPC**: The client initiates the process by sending
    a stream request message, to which the server responds with a stream response
    message. This type of method enables communication between the client and the
    server to be conducted in both directions.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向流式 RPC**：客户端通过发送一个流请求消息来启动过程，服务器随后响应一个流响应消息。此类方法允许客户端和服务器在两个方向上进行通信。'
- en: Let’s check out these RPC methods one by one. The source code for this section
    can be found in the `chapter11/GrpcDemo-v3` folder.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查这些 RPC 方法。本节的源代码可以在 `chapter11/GrpcDemo-v3` 文件夹中找到。
- en: Defining a unary service
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个一元服务
- en: 'A unary service is the simplest type of RPC method. The following code shows
    a unary service:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一元服务是 RPC 方法中最简单的一种类型。以下代码展示了一元服务：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we define a `CreateContactRequest` message and a `CreateContactResponse`
    message, and then we define a `ContactService` service, which contains a `CreateContact()`
    RPC method. The `CreateContact` RPC method requires a `CreateContactRequest` request
    message and a `CreateContactResponse` response message.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个 `CreateContactRequest` 消息和一个 `CreateContactResponse` 消息，然后定义了一个
    `ContactService` 服务，其中包含一个 `CreateContact()` RPC 方法。`CreateContact` RPC 方法需要一个
    `CreateContactRequest` 请求消息和一个 `CreateContactResponse` 响应消息。
- en: 'The generated code for the `CreateContact()` RPC method is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateContact()` RPC 方法的生成代码如下：'
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ContactServiceBase` class is a base class for the service implementation.
    It contains the `CreateContact()` method, which is a `virtual` method. By default,
    the `CreateContact()` method throws an exception because the method is not implemented.
    We need to override this method in the service implementation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactServiceBase` 类是服务实现的基类。它包含一个 `CreateContact()` 方法，这是一个 `virtual` 方法。默认情况下，`CreateContact()`
    方法会抛出异常，因为该方法尚未实现。我们需要在服务实现中重写此方法。'
- en: 'Next, create a `ContactService.cs` file in the `Service` folder. In the `ContactService.cs`
    file, we need to implement the `ContactService` class, which is derived from the
    `ContactServiceBase` class. The `ContactService` class is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `Service` 文件夹中创建一个 `ContactService.cs` 文件。在 `ContactService.cs` 文件中，我们需要实现
    `ContactService` 类，该类是从 `ContactServiceBase` 类派生的。`ContactService` 类如下：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we override the `CreateContact()` method and implement
    the method. This `CreateContact()` method allows us to execute some logic we need,
    such as saving the contact to the database. For simplicity, we just return a new
    `CreateContactResponse` object with a new `ContactId` value. In reality, we may
    have additional logic.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们重写了 `CreateContact()` 方法并实现了该方法。这个 `CreateContact()` 方法允许我们执行一些需要的逻辑，例如将联系人保存到数据库中。为了简单起见，我们只是返回一个新的
    `CreateContactResponse` 对象，并带有新的 `ContactId` 值。实际上，我们可能还有其他逻辑。
- en: 'Next, we need to register the `ContactService` class in the DI container. Open
    the `Program.cs` file and add the following code to the `ConfigureServices()`
    method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 DI 容器中注册 `ContactService` 类。打开 `Program.cs` 文件，并在 `ConfigureServices()`
    方法中添加以下代码：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our new unary service simplifies the process of handling HTTP requests, eliminating
    the need to write any code or manage different HTTP methods. All RPC calls are
    handled by the gRPC framework, allowing for a streamlined process.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新一元服务简化了处理 HTTP 请求的过程，消除了编写任何代码或管理不同 HTTP 方法的需要。所有 RPC 调用都由 gRPC 框架处理，从而实现了一个简化的流程。
- en: To call a gRPC service, a gRPC client must be created as current browsers do
    not support this protocol. Alternatively, tools such as Postman can be used to
    access the service. In the following section, we will demonstrate how to create
    a console application to call the service.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 gRPC 服务，必须创建一个 gRPC 客户端，因为当前浏览器不支持此协议。作为替代，可以使用 Postman 等工具来访问服务。在下一节中，我们将演示如何创建控制台应用程序来调用该服务。
- en: Creating a gRPC client
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 gRPC 客户端
- en: 'A gRPC can be a console application, a web application, or any other type of
    application, such as a WPF application. In this section, we will create a console
    application as the gRPC client for the unary service we created in the previous
    section. You can use similar code in other types of applications. Follow these
    steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 可以是一个控制台应用程序、一个 Web 应用程序或任何其他类型的应用程序，例如 WPF 应用程序。在本节中，我们将创建一个控制台应用程序作为前一节中创建的一元服务的
    gRPC 客户端。您可以在其他类型的应用程序中使用类似的代码。按照以下步骤操作：
- en: 'Use the `dotnet new` command to create a new console project:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet new` 命令创建一个新的控制台项目：
- en: '[PRE38]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we have two projects. If you have not created a solution file, you can
    create it by running the following command:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有两个项目。如果您尚未创建解决方案文件，可以通过运行以下命令创建它：
- en: '[PRE39]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, add the two projects to the solution:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将两个项目添加到解决方案中：
- en: '[PRE40]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: cd GrpcDemo.Clientdotnet add GrpcDemo.Client.csproj package Grpc.Net.Client
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cd GrpcDemo.Client
- en: '[PRE41]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To use the gRPC tooling to generate the client code, we also need to add the
    following packages:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 gRPC 工具生成客户端代码，我们还需要添加以下包：
- en: '[PRE42]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, copy the `Protos` folder from the `GrpcDemo` project to the `GrpcDemo.Client`
    project. Then, add the following code to the `GrpcDemo.Client.csproj` file:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Protos`文件夹从`GrpcDemo`项目复制到`GrpcDemo.Client`项目。然后，将以下代码添加到`GrpcDemo.Client.csproj`文件中：
- en: '[PRE43]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Similar to the `GrpcDemo` project, we use the `Protobuf` element to specify
    the proto files and the output directory. The `GrpcServices` attribute is used
    to specify the type of the generated code. In this case, we use `Client` because
    we are creating a gRPC client.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`GrpcDemo`项目类似，我们使用`Protobuf`元素来指定proto文件和输出目录。`GrpcServices`属性用于指定生成的代码类型。在这种情况下，我们使用`Client`，因为我们正在创建一个gRPC客户端。
- en: When you make changes to the proto files in the `GrpcDemo` project, do not forget
    to copy the changes to the `GrpcDemo.Client` project to ensure that the client
    code is up to date.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您在`GrpcDemo`项目中对proto文件进行更改时，请务必将更改复制到`GrpcDemo.Client`项目，以确保客户端代码是最新的。
- en: 'In the `Generated/Protos` folder, you will find the generated code for each
    proto file. For example, the `invoice.proto` file will generate the following
    files:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Generated/Protos`文件夹中，您将找到每个proto文件的生成代码。例如，`invoice.proto`文件将生成以下文件：
- en: '`Invoice.cs`: This file contains the definition of the messages in the `invoice.proto`
    file'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoice.cs`：此文件包含`invoice.proto`文件中消息的定义'
- en: '`InvoiceGrpc.cs`: This file contains the gRPC client code for the services
    in the `invoice.proto` file'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvoiceGrpc.cs`：此文件包含`invoice.proto`文件中服务器的gRPC客户端代码'
- en: 'Next, let’s create an `InvoiceClient.cs` file in the project root folder and
    add the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在项目根目录中创建一个`InvoiceClient.cs`文件，并添加以下代码：
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we use the `GrpcChannel.ForAddress()` method to create
    a gRPC channel, which accepts the address of the gRPC server.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`GrpcChannel.ForAddress()`方法创建一个gRPC通道，它接受gRPC服务器的地址。
- en: 'To get the address of the gRPC server, you can use the `dotnet run` command
    in the `GrpcDemo` project to start the gRPC server. The following output shows
    the address of the gRPC server:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取gRPC服务器的地址，您可以在`GrpcDemo`项目中使用`dotnet run`命令来启动gRPC服务器。以下输出显示了gRPC服务器的地址：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Alternatively, you can check the `applicationUrl` property in the `Properties/launchSettings.json`
    file. The following code shows the `applicationUrl` property:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以在`Properties/launchSettings.json`文件中检查`applicationUrl`属性。以下代码显示了`applicationUrl`属性：
- en: '[PRE46]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A gRPC channel is used to establish a connection to the gRPC server on the specified
    address and port. Once we have the gRPC channel, we can create an instance of
    the `ContactClient` class, which is generated from the proto file. Then, we call
    the `CreateContactAsync()` method to create a contact. The `CreateContactAsync()`
    method accepts a `CreateContactRequest` object as the parameter. The `CreateContactAsync()`
    method returns a `CreateContactResponse` object, which contains the `ContactId`
    value. At the end of the method, we print the `ContactId` value to the console.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: gRPC通道用于在指定的地址和端口上建立与gRPC服务器的连接。一旦我们有了gRPC通道，我们就可以创建一个由proto文件生成的`ContactClient`类的实例。然后，我们调用`CreateContactAsync()`方法来创建一个联系人。`CreateContactAsync()`方法接受一个`CreateContactRequest`对象作为参数。`CreateContactAsync()`方法返回一个包含`ContactId`值的`CreateContactResponse`对象。在方法结束时，我们将`ContactId`值打印到控制台。
- en: 'This method is straightforward. There are a few things to note:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法很简单。有一些需要注意的事项：
- en: Creating a gRPC channel is an expensive operation. So, it is recommended to
    reuse the gRPC channel. However, a gRPC client is a lightweight object, so there
    is no need to reuse it.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建gRPC通道是一个昂贵的操作。因此，建议重用gRPC通道。然而，gRPC客户端是一个轻量级对象，因此没有必要重用它。
- en: You can create multiple gRPC clients from one gRPC channel, and you can safely
    use multiple gRPC clients concurrently.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从一个gRPC通道创建多个gRPC客户端，并且可以安全地同时使用多个gRPC客户端。
- en: 'To secure the gRPC channel using TLS, you need to run the gRPC service with
    HTTPS. For example, you can use the following command to run the gRPC service:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用TLS保护gRPC通道，您需要使用HTTPS运行gRPC服务。例如，您可以使用以下命令运行gRPC服务：
- en: '[PRE47]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, you can use the HTTPS address to create the gRPC channel:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用HTTPS地址创建gRPC通道：
- en: '[PRE48]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: var contactClient = new InvoiceClient();await contactClient.CreateContactAsync();
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var contactClient = new InvoiceClient();await contactClient.CreateContactAsync();
- en: '[PRE49]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the gRPC server and the gRPC client in different terminals. By doing this,
    you will be able to see the following output in the gRPC client terminal:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的终端中运行gRPC服务器和gRPC客户端。通过这样做，您将在gRPC客户端终端看到以下输出：
- en: '[PRE50]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is a simple example of a gRPC client in a console application. In the next
    section, we will create a server streaming service and the corresponding gRPC
    client.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个控制台应用程序中gRPC客户端的简单示例。在下一节中，我们将创建一个服务器流式服务及其对应的gRPC客户端。
- en: Defining a server streaming service
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义服务器流式服务
- en: Similar to a unary service, a server streaming service has a request message
    and a response message. The difference is that the response message is a stream
    message. Once the server starts to send the stream response message, the client
    cannot send any more messages to the server, unless the server finishes sending
    the stream response message or the client cancels the RPC call by raising `ServerCallContext.CancellationToken`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与单一服务类似，服务器流式服务有一个请求消息和一个响应消息。区别在于响应消息是一个流消息。一旦服务器开始发送流响应消息，客户端就不能再向服务器发送任何消息，除非服务器完成发送流响应消息或客户端通过触发`ServerCallContext.CancellationToken`来取消RPC调用。
- en: 'The server streaming service is useful when we need to send a stream of data
    to the client. In this case, the server can send multiple messages to the client
    over a single RPC call. Here are some scenarios where a server streaming service
    is useful:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要向客户端发送一系列数据时，服务器流式服务非常有用。在这种情况下，服务器可以在单个RPC调用中向客户端发送多个消息。以下是一些服务器流式服务有用的场景：
- en: '**Events streaming**: When the server needs to send a stream of event messages
    to the client so that the client can process the event messages.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件流式传输**：当服务器需要向客户端发送一系列事件消息，以便客户端可以处理这些事件消息时。'
- en: '**Real-time data feeds**: When the server has a continuous stream of data to
    send to the client, such as stock prices, weather data, and so on.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据流**：当服务器有一个连续的数据流要发送给客户端，例如股票价格、天气数据等。'
- en: '**File streaming**: When the server needs to send a large file to the client,
    the server can split the file into small chunks and send them one by one as a
    stream response message. This can reduce the memory usage on the server and the
    client because the server and the client do not need to load the entire file into
    memory.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件流式传输**：当服务器需要向客户端发送大文件时，服务器可以将文件分割成小块，并逐个作为流响应消息发送。这可以减少服务器和客户端的内存使用，因为服务器和客户端不需要将整个文件加载到内存中。'
- en: 'The following code shows a server streaming service with the required message
    types:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了具有所需消息类型的服务器流式服务：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding proto file, we define two messages named `GetRandomNumbersRequest`
    and `GetRandomNumbersResponse`. Then, we define a `RandomNumbers` service, which
    contains a `GetRandomNumbers()` RPC method. Note that the response message of
    the `GetRandomNumbers` RPC method is annotated with the `stream` keyword. This
    means that the response message is a stream message.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的proto文件中，我们定义了两个名为`GetRandomNumbersRequest`和`GetRandomNumbersResponse`的消息。然后，我们定义了一个`RandomNumbers`服务，其中包含一个`GetRandomNumbers()`
    RPC方法。请注意，`GetRandomNumbers` RPC方法的响应消息被注解了`stream`关键字。这意味着响应消息是一个流消息。
- en: 'The generated code for the `GetRandomNumbers()` RPC method is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为`GetRandomNumbers()` RPC方法生成的代码如下：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the generated code, we can see that the type of the response message is
    `IServerStreamWriter<GetRandomNumbersResponse>`. Let’s add a simple implementation
    for the `RandomNumbers` service. Follow these steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的代码中，我们可以看到响应消息的类型是`IServerStreamWriter<GetRandomNumbersResponse>`。让我们为`RandomNumbers`服务添加一个简单的实现。按照以下步骤操作：
- en: 'Create a `RandomNumbersService.cs` file in the `Service` folder and add the
    following code:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Service`文件夹中创建一个`RandomNumbersService.cs`文件，并添加以下代码：
- en: '[PRE53]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the implementation of the `GetRandomNumbers()` method, we use a `for` loop
    to generate random numbers and send them to the client every second. Note that
    we use the `responseStream.WriteAsync()` method to send the stream response message
    to the client. The message finishes sending when the loop ends.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`GetRandomNumbers()`方法的实现中，我们使用`for`循环生成随机数，并每秒将它们发送给客户端。请注意，我们使用`responseStream.WriteAsync()`方法将流响应消息发送给客户端。消息发送完成时，循环结束。
- en: 'If we need a continuous stream response message, we can check the `ServerCallContext.CancellationToken`
    property of the `context` parameter. If the client cancels the RPC call, the `ServerCallContext.CancellationToken`
    property will be raised. The following code shows how to check the `ServerCallContext.CancellationToken`
    property:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们需要一个连续的流响应消息，我们可以检查`context`参数的`ServerCallContext.CancellationToken`属性。如果客户端取消了RPC调用，`ServerCallContext.CancellationToken`属性将被触发。以下代码展示了如何检查`ServerCallContext.CancellationToken`属性：
- en: '[PRE54]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code, we use a `while` loop to check the `ServerCallContext.CancellationToken`
    property. If the client cancels the RPC call, the `ServerCallContext.CancellationToken`
    property will be raised, and the `while` loop will end. If there are any other
    asynchronous operations in the method, we can pass the `ServerCallContext.CancellationToken`
    property to the asynchronous operations. This can ensure that the asynchronous
    operations will be canceled when the client cancels the RPC call.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`while`循环来检查`ServerCallContext.CancellationToken`属性。如果客户端取消RPC调用，`ServerCallContext.CancellationToken`属性将被触发，`while`循环将结束。如果方法中还有其他异步操作，我们可以将`ServerCallContext.CancellationToken`属性传递给异步操作。这可以确保当客户端取消RPC调用时，异步操作将被取消。
- en: 'Next, we will register the `RandomNumbersService` class in the DI container.
    Open the `Program.cs` file and add the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在依赖注入容器中注册`RandomNumbersService`类。打开`Program.cs`文件并添加以下代码：
- en: '[PRE55]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we will create a gRPC client to call the `GetRandomNumbers()` RPC method.
    Create a `RandomNumbersClient.cs` file in the project root folder and add the
    following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个gRPC客户端来调用`GetRandomNumbers()` RPC方法。在项目根目录下创建一个`RandomNumbersClient.cs`文件并添加以下代码：
- en: '[PRE56]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The code to create the client is similar to that of `InvoiceClient`, which we
    introduced in the *Creating a gRPC client* section. The only difference is in
    the response message, which is handled using the `await foreach` statement. The
    `ReadAllAsync()` method returns an `IAsyncEnumerable<T>` object, which can be
    iterated over using the `await` `foreach` statement.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建客户端的代码与我们在*创建gRPC客户端*部分介绍的`InvoiceClient`类似。唯一的区别在于响应消息的处理，它使用`await foreach`语句处理。`ReadAllAsync()`方法返回一个`IAsyncEnumerable<T>`对象，可以使用`await`
    `foreach`语句遍历。
- en: 'In the `Program.cs` file of the `GrpcDemo.Client` project, call the `GetRandomNumbers()`
    method, as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GrpcDemo.Client`项目的`Program.cs`文件中，调用`GetRandomNumbers()`方法，如下所示：
- en: '[PRE57]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the gRPC server and the gRPC client in different terminals. You will see
    that the output contains a series of random numbers.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的终端中运行gRPC服务器和gRPC客户端。您将看到输出包含一系列随机数。
- en: This is an example of a server streaming service and the corresponding gRPC
    client. In the next section, we will create a client streaming service and the
    corresponding gRPC client.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个服务器流式服务和相应的gRPC客户端的示例。在下一节中，我们将创建客户端流式服务和相应的gRPC客户端。
- en: Defining a client streaming service
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义客户端流式服务
- en: A client streaming service allows the client to send a stream of messages to
    the server over a single request. The server then sends a single response message
    to the client when it finishes processing the stream request messages. Once the
    server sends the response message, the client streaming call is complete.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端流式服务允许客户端通过单个请求将一系列消息发送到服务器。服务器在完成处理流请求消息后，向客户端发送单个响应消息。一旦服务器发送响应消息，客户端流式调用即完成。
- en: 'Here are some scenarios where a client streaming service is useful:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些场景，客户端流式服务非常有用：
- en: '**File uploading**: When the client uploads a large file to the server, the
    client can split the file into small chunks and send them one by one as a stream
    request message, which can be more efficient than sending the entire file in a
    single request.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件上传**：当客户端将大文件上传到服务器时，客户端可以将文件分割成小块，并逐个作为流请求消息发送，这比在单个请求中发送整个文件更有效率。'
- en: '**Real-time data capture**: When the client needs to send a stream of data
    to the server, such as sensor data, user interactions, or any continuous stream
    of data, the server can process the data and respond to the batch of data.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据捕获**：当客户端需要向服务器发送一系列数据流，例如传感器数据、用户交互或任何连续的数据流时，服务器可以处理这些数据并对这批数据进行响应。'
- en: '**Data aggregation**: When the client needs to send a batch of data to the
    server for aggregation or analysis.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据聚合**：当客户端需要将一批数据发送到服务器进行聚合或分析时。'
- en: 'To define a client streaming service, we need to use the `stream` keyword to
    annotate the request message. The following code shows a client streaming service
    with the required message types:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义客户端流式服务，我们需要使用`stream`关键字来注解请求消息。以下代码展示了具有所需消息类型的客户端流式服务：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding `.proto` file defines two messages: `SendRandomNumbersRequest`
    and `SendRandomNumbersResponse`. The client sends a stream message containing
    a series of numbers to the server. The server then processes the stream message
    and calculates the sum of the numbers. Finally, the server sends a response message
    to the client, which contains the count of the numbers and the sum of the numbers.
    It is important to note that the `SendRandomNumbers()` RPC method is annotated
    with the `stream` keyword, indicating that the request message is a stream message.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `.proto` 文件定义了两个消息：`SendRandomNumbersRequest` 和 `SendRandomNumbersResponse`。客户端向服务器发送一个包含一系列数字的流消息。然后，服务器处理流消息并计算数字的总和。最后，服务器向客户端发送一个响应消息，其中包含数字的数量和总和。需要注意的是，`SendRandomNumbers()`
    RPC 方法被 `stream` 关键字注释，表示请求消息是一个流消息。
- en: 'Similar to the server streaming service, we can implement the `SendRandomNumbers()`
    method, as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器流式服务类似，我们可以实现 `SendRandomNumbers()` 方法，如下所示：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We utilize the `IAsyncStreamReader<T>.ReadAllAsync()` method in the preceding
    code to read all the stream request messages from the client. Subsequently, we
    use `await foreach` to iterate over the stream request messages. Lastly, we compute
    the count and sum of the numbers and return a `SendRandomNumbersResponse` object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中使用了 `IAsyncStreamReader<T>.ReadAllAsync()` 方法来读取客户端的所有流请求消息。随后，我们使用
    `await foreach` 来遍历流请求消息。最后，我们计算数字的数量和总和，并返回一个 `SendRandomNumbersResponse` 对象。
- en: 'To consume the client streaming service, we will copy the proto files from
    the `GrpcDemo` project to the `GrpcDemo.Client` project. Then, we will create
    a `ClientStreamingClient` class in the `GrpcDemo.Client` project and add the following
    code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要消费客户端流式服务，我们将从 `GrpcDemo` 项目复制 proto 文件到 `GrpcDemo.Client` 项目。然后，我们在 `GrpcDemo.Client`
    项目中创建一个 `ClientStreamingClient` 类，并添加以下代码：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the `SendRandomNumbers()` method, we create an `AsyncClientStreamingCall`
    object by calling the `SendRandomNumbers()` method of the `RandomNumbersClient`
    class. Note that the client streaming call starts when the `SendRandomNumbers()`
    method is called, but the client does not send any messages until the `RequestStream.CompleteAsync()`
    method is called. In a `for` loop, we use the `RequestStream.WriteAsync()` method
    to send the stream request message to the server. At the end of the method, we
    call the `RequestStream.CompleteAsync()` method to indicate that the stream request
    message is complete. The stream request message contains 20 numbers, which are
    generated randomly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SendRandomNumbers()` 方法中，我们通过调用 `RandomNumbersClient` 类的 `SendRandomNumbers()`
    方法创建一个 `AsyncClientStreamingCall` 对象。请注意，客户端流式调用在调用 `SendRandomNumbers()` 方法时开始，但客户端不会发送任何消息，直到调用
    `RequestStream.CompleteAsync()` 方法。在一个 `for` 循环中，我们使用 `RequestStream.WriteAsync()`
    方法将流请求消息发送到服务器。在方法结束时，我们调用 `RequestStream.CompleteAsync()` 方法来指示流请求消息已完成。流请求消息包含
    20 个随机生成的数字。
- en: 'In the `Program.cs` file of the `GrpcDemo.Client` project, we then call the
    `SendRandomNumbers()` method, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GrpcDemo.Client` 项目的 `Program.cs` 文件中，我们随后调用 `SendRandomNumbers()` 方法，如下所示：
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the gRPC server and the gRPC client in different terminals. After around
    20 seconds, you will see the following output in the gRPC client terminal (the
    sum may be different):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的终端中运行 gRPC 服务器和 gRPC 客户端。大约 20 秒后，你将在 gRPC 客户端终端看到以下输出（总和可能不同）：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With that, we’ve learned how to create a client streaming service and the corresponding
    gRPC client. In the next section, we will create a bidirectional streaming service
    and the corresponding gRPC client.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何创建客户端流式服务及其对应的 gRPC 客户端。在下一节中，我们将创建双向流式服务及其对应的 gRPC 客户端。
- en: Defining a bidirectional streaming service
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义双向流式服务
- en: A bidirectional streaming service allows the client and the server to send a
    stream of messages to each other over a single request concurrently. Once the
    connection has been established, the client and the server can send messages to
    each other at any time in any order because the two streams are independent. For
    example, the server can respond to each message from the client, or the server
    can send a response message after receiving a series of messages from the client.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 双向流式服务允许客户端和服务器在单个请求中并发地向对方发送消息流。一旦建立连接，客户端和服务器可以在任何时间以任何顺序相互发送消息，因为两个流是独立的。例如，服务器可以响应客户端的每条消息，或者服务器可以在收到客户端的一系列消息后发送响应消息。
- en: 'Here are some scenarios where a bidirectional streaming service is useful:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些双向流服务有用的场景：
- en: '**Chat applications**: When the client and the server need to send instant
    messages to each other'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聊天应用**：当客户端和服务器需要互相发送即时消息时'
- en: '**Real-time data dashboard**: When the client continuously sends data to the
    server and the server builds a real-time dashboard to display the data'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据仪表板**：当客户端持续向服务器发送数据，并且服务器构建实时仪表板以显示数据时'
- en: '**Multiplayer games**: When the players need to interact with each other in
    real-time and the server needs to synchronize the game state between the players'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多人游戏**：当玩家需要实时交互，并且服务器需要在玩家之间同步游戏状态时'
- en: 'Let’s define a bidirectional streaming service. In this example, the client
    sends some sentences to the server and the server responds to each sentence with
    the uppercase version of the sentence. The following code shows the required message
    types:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个双向流服务。在这个例子中，客户端向服务器发送一些句子，服务器则对每个句子返回句子的大写版本。以下代码显示了所需的消息类型：
- en: '[PRE63]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the preceding proto file, we have defined a `ChatMessage` message containing
    two fields: `sender` and `message`. Additionally, we have defined a `Chat` service
    with a `SendMessage` RPC method. It is important to note that both the request
    and response of this method are annotated with the `stream` keyword, indicating
    that they are both stream messages.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的proto文件中，我们已经定义了一个包含两个字段：`sender`和`message`的`ChatMessage`消息。此外，我们还定义了一个具有`SendMessage`
    RPC方法的`Chat`服务。需要注意的是，此方法的请求和响应都被注解了`stream`关键字，表示它们都是流消息。
- en: 'Now, we can implement the `SendMessage()` method. Follow these steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`SendMessage()`方法。按照以下步骤进行：
- en: 'Create a `ChatService.cs` file in the `Service` folder and add the following
    code:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Service`文件夹中创建一个`ChatService.cs`文件并添加以下代码：
- en: '[PRE64]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we utilize the `await foreach` method to iterate over the stream request
    messages. For each request message, we use the `WriteAsync()` method to send a
    response message back to the client. This response message contains the uppercase
    version of the request message.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`await foreach`方法遍历流请求消息。对于每个请求消息，我们使用`WriteAsync()`方法向客户端发送响应消息。这个响应消息包含请求消息的大写版本。
- en: 'Next, register the `ChatService` class in the dependency injection container.
    Open the `Program.cs` file and add the following code:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在依赖注入容器中注册`ChatService`类。打开`Program.cs`文件并添加以下代码：
- en: '[PRE65]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: internal class BidirectionalStreamingClient{    public async Task SendMessage()    {        using
    var channel = GrpcChannel.ForAddress("https://localhost:7179");        var client
    = new Chat.ChatClient(channel);        // Create a streaming request        using
    var streamingCall = client.SendMessage();        Console.WriteLine("Starting a
    background task to receive messages...");        var responseReaderTask = Task.Run(async
    () =>        {            await foreach (var response in streamingCall.ResponseStream.ReadAllAsync())            {                Console.WriteLine(response.Message);            }        });        Console.WriteLine("Starting
    to send messages...");        Console.WriteLine("Input your message then press
    enter to send it.");        while (true)        {            var message = Console.ReadLine();            if
    (string.IsNullOrWhiteSpace(message))            {                break;            }            await
    streamingCall.RequestStream.WriteAsync(new ChatMessage            {                Message
    = message            });        }        Console.WriteLine("Disconnecting...");        await
    streamingCall.RequestStream.CompleteAsync();        await responseReaderTask;    }}
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内部类`BidirectionalStreamingClient`{    public async Task SendMessage()    {        using
    var channel = GrpcChannel.ForAddress("https://localhost:7179");        var client
    = new Chat.ChatClient(channel);        // 创建一个流请求        using var streamingCall
    = client.SendMessage();        Console.WriteLine("开始一个后台任务以接收消息...");        var
    responseReaderTask = Task.Run(async () =>        {            await foreach (var
    response in streamingCall.ResponseStream.ReadAllAsync())            {                Console.WriteLine(response.Message);            }        });        Console.WriteLine("开始发送消息...");        Console.WriteLine("输入你的消息然后按回车键发送。");        while
    (true)        {            var message = Console.ReadLine();            if (string.IsNullOrWhiteSpace(message))            {                break;            }            await
    streamingCall.RequestStream.WriteAsync(new ChatMessage            {                Message
    = message            });        }        Console.WriteLine("断开连接...");        await
    streamingCall.RequestStream.CompleteAsync();        await responseReaderTask;    }}
- en: '[PRE66]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the `Program.cs` file of the `GrpcDemo.Client` project, call the `SendMessage()`
    method, as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GrpcDemo.Client`项目的`Program.cs`文件中，调用`SendMessage()`方法，如下所示：
- en: '[PRE67]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the gRPC server and the gRPC client in different terminals. You will see
    the following output in the gRPC client terminal:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的终端中运行 gRPC 服务器和 gRPC 客户端。你将在 gRPC 客户端终端看到以下输出：
- en: '[PRE68]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This example is a simple demonstration of a bidirectional streaming service
    and the corresponding gRPC client. The bidirectional streaming service allows
    the client and the server to send a stream of messages to each other at any time
    in any order. In the preceding example, the service responds to each message from
    the client. However, using similar code, we can implement more complex logic per
    the requirements.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是一个双向流服务的简单演示以及相应的 gRPC 客户端。双向流服务允许客户端和服务器在任何时间以任何顺序相互发送消息流。在上面的示例中，服务对客户端的每条消息做出响应。然而，使用类似的代码，我们可以根据需求实现更复杂的逻辑。
- en: 'We have now explored four types of gRPC services: unary, server streaming,
    client streaming, and bidirectional streaming. We have also learned how to create
    a gRPC client to call each of these gRPC services. In the next section, we will
    learn how to use gRPC services in ASP.NET Core applications.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探讨了四种类型的 gRPC 服务：单一请求、服务器端流、客户端流和双向流。我们还学习了如何创建 gRPC 客户端来调用这些 gRPC 服务。在下一节中，我们将学习如何在
    ASP.NET Core 应用程序中使用 gRPC 服务。
- en: Consuming gRPC services in ASP.NET Core applications
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 应用程序中消费 gRPC 服务
- en: In the previous section, we learned how to create console applications to consume
    gRPC services. In this section, we will integrate gRPC services into ASP.NET Core
    applications. We will reuse the gRPC services we created in the previous section,
    and we will create a new ASP.NET Core application to consume the gRPC services.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何创建控制台应用程序来消费 gRPC 服务。在本节中，我们将集成 gRPC 服务到 ASP.NET Core 应用程序中。我们将重用上一节中创建的
    gRPC 服务，并创建一个新的 ASP.NET Core 应用程序来消费这些 gRPC 服务。
- en: To get started with the steps outlined in this section, begin with the `GrpcDemo-v3`
    folder of the source code. The complete code for this section can be found in
    the `GrpcDemo-v4` folder.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本节中概述的步骤，请从源代码的 `GrpcDemo-v3` 文件夹开始。本节的完整代码可以在 `GrpcDemo-v4` 文件夹中找到。
- en: 'In the console applications, we used the `GrpcChannel` class to create a gRPC
    channel, after which we used the gRPC channel to create a gRPC client, as shown
    in the following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，我们使用 `GrpcChannel` 类创建一个 gRPC 通道，然后使用 gRPC 通道创建一个 gRPC 客户端，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In ASP.NET Core applications, a better way to create a gRPC client is to use
    the `IHttpClientFactory` interface with dependency injection. Let’s see how to
    use the DI container to create a gRPC client:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 应用程序中，创建 gRPC 客户端的一个更好的方法是使用 `IHttpClientFactory` 接口和依赖注入。让我们看看如何使用
    DI 容器创建 gRPC 客户端：
- en: 'First, we must create a new ASP.NET Core application. In this ASP.NET Core
    application, we will create a REST API to consume the gRPC services we created
    in the previous section. Use the `dotnet new` command to create a new ASP.NET
    Core application:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个新的 ASP.NET Core 应用程序。在这个 ASP.NET Core 应用程序中，我们将创建一个 REST API 来消费我们在上一节中创建的
    gRPC 服务。使用 `dotnet new` 命令创建一个新的 ASP.NET Core 应用程序：
- en: '[PRE70]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, add this project to the solution:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此项目添加到解决方案中：
- en: '[PRE71]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Grpc.Net.ClientFactory package allows developers to create a gRPC client using
    a dependency injection container, eliminating the need for the new keyword. Additionally,
    the Grpc.Tools package can be used to generate gRPC client code from proto files.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Grpc.Net.ClientFactory 包允许开发人员使用依赖注入容器创建 gRPC 客户端，从而消除了使用 new 关键字的需求。此外，Grpc.Tools
    包可以用于从 proto 文件生成 gRPC 客户端代码。
- en: '[PRE72]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, copy the `Protos` folder from the `GrpcDemo` project to the `GrpcDemo.Api`
    project. Next, add the following code to the `GrpcDemo.Api.csproj` file:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `GrpcDemo` 项目的 `Protos` 文件夹复制到 `GrpcDemo.Api` 项目中。接下来，将以下代码添加到 `GrpcDemo.Api.csproj`
    文件中：
- en: '[PRE73]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Similar to the `GrpcDemo.Client` project, we use the `GrpcServices="Client"`
    attribute to specify the type of the generated code. In this case, we use `Client`
    because we will create a gRPC client to consume the gRPC services in the ASP.NET
    Core application.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `GrpcDemo.Client` 项目类似，我们使用 `GrpcServices="Client"` 属性来指定生成的代码的类型。在这种情况下，我们使用
    `Client`，因为我们将在 ASP.NET Core 应用程序中创建一个 gRPC 客户端来消费 gRPC 服务。
- en: 'Next, we can register the gRPC client in the DI container. Open the `Program.cs`
    file and add the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以在 DI 容器中注册 gRPC 客户端。打开 `Program.cs` 文件并添加以下代码：
- en: '[PRE74]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[ApiController][Route("[controller]")]public class ContactController(Contact.ContactClient
    client, ILogger<ContactController> logger) : ControllerBase{    [HttpPost]    public
    async Task<IActionResult> CreateContact(CreateContactRequest request)    {        var
    reply = await _client.CreateContactAsync(request);        return Ok(reply);    }}'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[ApiController][Route("[controller]")]public class ContactController(Contact.ContactClient
    client, ILogger<ContactController> logger) : ControllerBase{    [HttpPost]    public
    async Task<IActionResult> CreateContact(CreateContactRequest request)    {        var
    reply = await _client.CreateContactAsync(request);        return Ok(reply);    }}'
- en: '[PRE75]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Run the gRPC server and the ASP.NET Core application in different terminals.
    Note that the gRPC server address must match the address specified in the `AddGrpcClient()`
    method. Then, you can navigate to the Swagger UI page, such as `http://localhost:5284/swagger/index.html`,
    to test the `CreateContact()` action method. For example, you can use the following
    JSON object as the request body:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的终端中运行 gRPC 服务器和 ASP.NET Core 应用程序。请注意，gRPC 服务器地址必须与 `AddGrpcClient()` 方法中指定的地址匹配。然后，您可以导航到
    Swagger UI 页面，例如 `http://localhost:5284/swagger/index.html`，以测试 `CreateContact()`
    动作方法。例如，您可以使用以下 JSON 对象作为请求体：
- en: '[PRE76]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You will see the following response (the `contactId` value may be different):'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到以下响应（`contactId` 值可能不同）：
- en: '[PRE77]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This simple example shows how to use the `AddGrpcClient()` method to register
    a gRPC client in the DI container in ASP.NET Core applications, and how to use
    the gRPC client to consume a unary gRPC service. For other types of gRPC services,
    you need to update the code accordingly.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此简单示例展示了如何在 ASP.NET Core 应用程序中 DI 容器中使用 `AddGrpcClient()` 方法注册 gRPC 客户端，以及如何使用
    gRPC 客户端消费 unary gRPC 服务。对于其他类型的 gRPC 服务，您需要相应地更新代码。
- en: Updating proto files
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 proto 文件
- en: gRPC is a contract-first RPC framework. This means that the server and the client
    communicate with each other using a contract, which is defined in a proto file.
    Inevitably, the contract will change over time. In this section, we will learn
    how to update the contract and how to handle the changes in the server and the
    client.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是一种以合约为中心的 RPC 框架。这意味着服务器和客户端通过在 proto 文件中定义的合约进行通信。不可避免地，合约会随着时间的推移而变化。在本节中，我们将学习如何更新合约以及如何处理服务器和客户端中的更改。
- en: Once a proto file is used in production, we need to consider backward compatibility
    when we update the proto file. This is because the existing clients may use the
    old version of the proto file, which may not be compatible with the new version
    of the proto file. If the new version of the contract is not backward compatible,
    the existing clients will break.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 proto 文件在生产环境中使用，我们在更新 proto 文件时需要考虑向后兼容性。这是因为现有的客户端可能使用旧版本的 proto 文件，这可能与新版本的
    proto 文件不兼容。如果新版本的合约不向后兼容，现有的客户端将无法工作。
- en: 'The following changes are backward compatible:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改与旧版本兼容：
- en: '**Adding new fields to a request message**: If the client does not send the
    new fields, the server can use the default values of the new fields.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向请求消息中添加新字段**：如果客户端不发送新字段，则服务器可以使用新字段的新默认值。'
- en: '**Adding new fields to a response message**: If the response message contains
    the new fields but the client does not recognize the new fields, the client will
    discard the new fields in proto 3\. In the future version of proto, known as 3.5,
    this behavior will be changed to preserve the new fields as unknown fields.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向响应消息中添加新字段**：如果响应消息包含新字段，但客户端不识别新字段，则客户端将在 proto 3 中丢弃新字段。在未来版本的 proto，称为
    3.5 的版本中，此行为将改为将新字段作为未知字段保留。'
- en: '**Adding a new RPC method to a service**: The client that uses old versions
    of the proto file will not be able to call the new RPC method. However, the old
    RPC methods will still work.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向服务中添加新的 RPC 方法**：使用旧版本 proto 文件的客户端将无法调用新的 RPC 方法。但是，旧的 RPC 方法仍然可以工作。'
- en: '**Adding a new service to a proto file**: Similar to adding a new RPC method,
    the new service will not be available to the old clients, but the old services
    will still work.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向 proto 文件中添加新服务**：类似于添加新的 RPC 方法，新服务将不会对旧客户端可用，但旧服务仍然可以工作。'
- en: 'The following changes may cause breaking changes, which require the clients
    to be updated accordingly:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改可能会导致破坏性更改，需要相应地更新客户端：
- en: Removing a field from a message
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从消息中删除字段
- en: Renaming a field in a message
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息中重命名字段
- en: Removing or renaming a message
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或重命名消息
- en: Changing a data type of a field
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改字段的数据类型
- en: Changing a field number
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改字段编号
- en: Removing or renaming a service
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或重命名服务
- en: Removing or renaming an RPC method from a service
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务中删除或重命名 RPC 方法
- en: Renaming a package
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新命名一个包
- en: Changing the `csharp_namespace` option
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `csharp_namespace` 选项
- en: Protobuf uses field numbers to serialize and deserialize messages. If we rename
    a field in a message without changing the field number and the data type, the
    message can still be serialized and deserialized correctly, but the field name
    in the .NET code will be different from the field name in the proto file. This
    can be confusing for developers. So, the client code needs to be updated to use
    the new field name.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 使用字段编号来序列化和反序列化消息。如果我们不更改字段编号和数据类型，仅更改消息中的一个字段名称，则消息仍然可以正确地进行序列化和反序列化，但
    .NET 代码中的字段名称将与 proto 文件中的字段名称不同。这可能会让开发者感到困惑。因此，客户端代码需要更新以使用新的字段名称。
- en: Removing a field from a message is a breaking change as the field number cannot
    be reused. For example, if we remove the `year_of_birth` field from the `CreateContactRequest`
    message defined in the *Understanding the field types* section for the gRPC server,
    the server will deserialize field number 5 as an unknown field. This could lead
    to errors in serialization/de-serialization if a developer later decides to add
    a new field with field number 5 as a different data type while existing clients
    still send field number 5 as an integer value.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 从消息中删除字段是一个破坏性更改，因为字段编号不能重复使用。例如，如果我们从 *Understanding the field types* 部分定义的
    `CreateContactRequest` 消息中删除 `year_of_birth` 字段，服务器将反序列化字段编号 5 为未知字段。如果开发者后来决定添加一个新的字段，该字段的字段编号为
    5，并且数据类型不同，而现有客户端仍然发送字段编号 5 作为整数值，这可能导致序列化/反序列化错误。
- en: 'To safely remove a field, we must ensure that the removed field number is not
    being used in the future. To avoid any potential conflicts, we can reserve the
    removed field number by using the `reserved` keyword. For example, if we delete
    the `year_of_birth` and `is_active` fields from the `CreateContactRequest` message,
    we can reserve the field numbers, as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要安全地删除一个字段，我们必须确保被删除的字段编号在将来不会被使用。为了避免任何潜在冲突，我们可以通过使用 `reserved` 关键字来保留被删除的字段编号。例如，如果我们从
    `CreateContactRequest` 消息中删除 `year_of_birth` 和 `is_active` 字段，我们可以保留字段编号，如下所示：
- en: '[PRE78]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the preceding code, we use the `reserved` keyword to reserve field numbers
    5 and 6, and the `year_of_birth` and `is_active` field names. The reserved field
    numbers and field names cannot be reused in the proto file. If we try to use a
    reserved field number or field name, the gRPC tooling will report an error.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `reserved` 关键字保留字段编号 5 和 6，以及 `year_of_birth` 和 `is_active` 字段名称。保留的字段编号和字段名称不能在
    proto 文件中重复使用。如果我们尝试使用保留的字段编号或字段名称，gRPC 工具将报告错误。
- en: Note that the reserved field names should be listed, as well as the reserved
    field numbers. This ensures that the JSON and text formats are backward compatible.
    When the field names are reserved, they cannot be placed in the same `reserved`
    statement with the field numbers.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应列出保留的字段名称以及保留的字段编号。这确保了 JSON 和文本格式具有向后兼容性。当字段名称被保留时，它们不能与字段编号放在同一个 `reserved`
    语句中。
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored the fundamentals of gRPC services and clients.
    We discussed the field types that are used in protobuf, including the scalar types
    and some other types such as `DateTime`, `enum`, repeated fields, and map fields.
    Then, we learned about four types of gRPC services: unary, server streaming, client
    streaming, and bidirectional streaming. We explored how to implement each type
    of gRPC service and how to create a gRPC client to consume the gRPC service. Additionally,
    we demonstrated how to use the `AddGrpcClient()` method to register a gRPC client
    in the DI container of an ASP.NET Core application and how to use the gRPC client
    to consume a unary gRPC service. Finally, we discussed how to update the proto
    files and how to handle the changes in the server and the client.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 gRPC 服务和客户端的基础知识。我们讨论了在 protobuf 中使用的字段类型，包括标量类型和一些其他类型，如 `DateTime`、`enum`、重复字段和映射字段。然后，我们学习了四种类型的
    gRPC 服务：单一请求、服务器流式传输、客户端流式传输和双向流式传输。我们探讨了如何实现每种类型的 gRPC 服务以及如何创建 gRPC 客户端以消费 gRPC
    服务。此外，我们还演示了如何使用 `AddGrpcClient()` 方法在 ASP.NET Core 应用程序的依赖注入 (DI) 容器中注册 gRPC
    客户端，以及如何使用 gRPC 客户端消费单一 gRPC 服务。最后，我们讨论了如何更新 proto 文件以及如何处理服务器和客户端的变化。
- en: To simplify the code samples, we did not use any database access code in the
    gRPC services. In a real-world application, we may need to interact with a database
    or other external services in the gRPC services. You can follow the same approach
    as you do in REST API services.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码示例，我们在 gRPC 服务中没有使用任何数据库访问代码。在实际应用中，我们可能在 gRPC 服务中需要与数据库或其他外部服务进行交互。你可以遵循与
    REST API 服务相同的做法。
- en: gRPC is suitable for building high-performance service-to-service communication.
    Due to this book’s content limitations, we only covered the basics of gRPC. We
    did not cover advanced topics such as authentication, error handling, performance
    tuning, and others. However, this chapter should be enough to get you started
    with gRPC.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 适用于构建高性能的服务间通信。由于本书的内容限制，我们只涵盖了 gRPC 的基础知识。我们没有涵盖高级主题，如身份验证、错误处理、性能调整等。然而，这一章应该足以让你开始使用
    gRPC。
- en: In the next chapter, we will explore GraphQL, an alternative approach to web
    APIs. GraphQL provides clients with the ability to request only the data they
    need, making it easier to modify APIs over time and enabling the use of powerful
    developer tools.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 GraphQL，这是一种替代 Web API 的方法。GraphQL 允许客户端仅请求他们所需的数据，这使得随着时间的推移修改
    API 更容易，并能够使用强大的开发者工具。
- en: Further reading
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about gRPC on .NET Core, please refer to the following resources:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 .NET Core 上的 gRPC 的信息，请参考以下资源：
- en: '[https://protobuf.dev/](https://protobuf.dev/)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://protobuf.dev/](https://protobuf.dev/)'
- en: '[https://grpc.io/docs/languages/csharp/](https://grpc.io/docs/languages/csharp/)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://grpc.io/docs/languages/csharp/](https://grpc.io/docs/languages/csharp/)'
- en: '[https://learn.microsoft.com/en-us/aspnet/core/grpc/](https://learn.microsoft.com/en-us/aspnet/core/grpc/)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/aspnet/core/grpc/](https://learn.microsoft.com/en-us/aspnet/core/grpc/)'
