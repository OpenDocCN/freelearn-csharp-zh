<html><head></head><body>
<div><div><div><div><h1 class="title"><a id="ch12"/>
 Chapter 12. F# and OOP Principles/Design Patterns</h1>
</div>
</div>
</div>
<p>Previous chapters were aimed at developing and honing your taste for the usage patterns of functional programming, paying very occasional attention to comparison with OOP arrangements. This chapter caters to those of you who have an OOP background and may be anxiously expecting for the book to begin meticulously porting each and every one of the of 
<strong>23 original Gang of Four object-oriented design patterns</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns</a>
 ), one by one into F#.</p>
<p>I may disappoint you, as all topics covered so far indicate that staying with the functional-first facet of F# promoted by the book may make some of these patterns just irrelevant, intrinsic, or ubiquitous. In other words, the original patterns may morph into something much less fundamental compared to their role in the OOP world.</p>
<p>A similar transformation applies to OOP principles, collectively known as 
<strong>SOLID</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)</a>
 ). That is, from a functional programming standpoint, these principles may become either granted, irrelevant, or just respected, without much extra effort required from developers.</p>
<p>The goal of this chapter is to briefly demonstrate some cases of the morphing outlined in the preceding paragraphs. In this chapter, we will take a look at the following topics:</p>
<div><ul class="itemizedlist">
<li class="listitem">How OOP SOLID principles get morphed within the functional-first paradigm, and what exactly happens to each of these five pillars</li>
<li class="listitem">How some of the specific design patterns (Command, Template, Strategy) diminish in role, or just become simply equivalent to bits and pieces of the functional-first paradigm</li>
</ul>
</div>
<p>I will not attempt to lay out an exhaustive, thorough review. In the end, this book aims to develop skills and techniques of the functional-first paradigm, not any other paradigms supported by F#.</p>
<div><div><div><div><h1 class="title" id="toc_1"><a id="ch12lvl1sec72"/>
 Morphing SOLID principles</h1>
</div>
</div>
</div>
<p>Let's consider how the functional programming paradigm morphs the five basic principles of the object-oriented design known under this bold acronym of 
<strong>SOLID</strong>

 .</p>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch12lvl2sec132"/>
 Single Responsibility Principle</h2>
</div>
</div>
</div>
<p>The gist of 
<strong>Single Responsibility Principle</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">https://en.wikipedia.org/wiki/Single_responsibility_principle</a>
 ) (
<strong>SRP</strong>

 ), standing for the letter "S" in 
<strong>SOLID</strong>

 , in OOP terms is:</p>
<div><blockquote class="blockquote">
<p>

<em>"There should never be more than one reason for a class to change"</em>

</p>
</blockquote>
</div>
<p>In other words, if a class implementation is to be changed in response to two or more independent modifications to a functionality, this is an evidence of the 
<strong>Single Responsibility Principle</strong>

 (
<strong>SRP</strong>

 ) violation in its design. Following this principle in the OOP world entails designs consisting of many lean classes in lieu of fewer but bulkier classes.</p>
<p>If we consider a function as a degenerate case of class free of encapsulated data and having only the single method, then this is nothing but a quintessence of SRP applied. The following figure illustrates this transformation:</p>
<div><img src="img/Image00060.jpg" alt="Single Responsibility Principle"/>
<div><p>Honoring Single Responsibility Principle in functional programming</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>When we program in idiomatic F#, we compose the functions of a single purpose together. In other words, SRP is naturally promoted and enforced in F#.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch12lvl2sec133"/>
 Open/Closed Principle</h2>
</div>
</div>
</div>
<p>

<strong>Open/Closed Principle</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Open/closed_principle">https://en.wikipedia.org/wiki/Open/closed_principle</a>
 ) (
<strong>OCP</strong>

 ), representing the letter "O" in 
<strong>SOLID</strong>

 , states that:</p>
<div><blockquote class="blockquote">
<p>

<em>"software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification"</em>

</p>
</blockquote>
</div>
<p>In the pure OOP realm, such a property is granted by 
<strong>inheritance</strong>

 , both by direct 
<strong>implementation inheritance</strong>

 (that is, substituting a superclass with its subclass) and by 
<strong>polymorphic implementation</strong>

 (that is, just another implementation of a given interface that keeps itself closed to a modification but is open to additionally implementing other interfaces). Both of these forms of OCP are near, clear, and dear to the OOP facet of F#; however, they are not idiomatic to any extent. The functional-first mechanisms of extension in idiomatic F# are type augmentation and composition. The following figure serves as a cheat sheet here, as we have devoted a fair amount of attention in the book to these extension methods:</p>
<div><img src="img/Image00061.jpg" alt="Open/Closed Principle"/>
<div><p>Honoring Open/Closed Principle in functional programming</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The figure above shows in a very compelling manner how simple, succinct, and to the point the extensibility mechanics is within the functional-first idioms.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_4"><a id="ch12lvl2sec134"/>
 Liskov Substitution Principle</h2>
</div>
</div>
</div>
<p>The letter "L" in 
<strong>SOLID</strong>

 comes from 
<strong>Liskov Substitution Principle</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">https://en.wikipedia.org/wiki/Liskov_substitution_principle</a>
 ) (
<strong>LSP</strong>

 ) that states:</p>
<div><blockquote class="blockquote">
<p>

<em>"objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program"</em>

</p>
</blockquote>
</div>
<p>As formulated 
<strong>LSP</strong>

 is concerned purely with OOP inheritance, it does not seem related to idiomatic F#. Nevertheless, I would mention at least the following three F# functional-first idioms that strongly enforce this principle:</p>
<div><ul class="itemizedlist">
<li class="listitem">

<strong>Referential transparency</strong>

 : If a function is pure and produces a certain result given an argument of type <code class="literal">T</code>
 , then given the corresponding instance of type <code class="literal">S</code>
 that is a subtype of <code class="literal">T</code>
 as an argument, it must produce the identical result indeed</li>
<li class="listitem">

<strong>F# function argument type substitution</strong>

 : Based on what has been discussed in the preceding bullet point, if we have a type <code class="literal">'S</code>
 that derives from type <code class="literal">'T</code>
 , then an instance of <code class="literal">'S</code>
 can be used as a substitute for the corresponding instance of <code class="literal">'T</code>
 ; so for the following function <code class="literal">f</code>
 : <code class="literal">'T -&gt; 'R</code>
 , expression <code class="literal">f('S())</code>
 
<em>does not require any coercion</em>

 of the argument, as the following snippet demonstrates (<code class="literal">Ch12_1.fsx</code>
 ):</li>
</ul>
</div>
<pre class="programlisting">        type T = interface end // base 
        type S() = interface T // an implementation 
        let f (x: T) = () // a function upon base 
        f(S()) // application does not require coercion! 
</pre>
<div><ul class="itemizedlist">
<li class="listitem">

<strong>Immutability</strong>

 : If we have built a valid immutable instance of <code class="literal">'S</code>
 , it cannot anyhow be invalidated by using it as a substitute for the instance of <code class="literal">'T</code>
 by the virtue of its immutability</li>
</ul>
</div>
</div>
<div><div><div><div><h2 class="title" id="toc_5"><a id="ch12lvl2sec135"/>
 Interface Segregation Principle</h2>
</div>
</div>
</div>
<p>Standing for the letter "I" in 
<strong>SOLID</strong>

 , 
<strong>Interface Segregation Principle</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Interface_segregation_principle">https://en.wikipedia.org/wiki/Interface_segregation_principle</a>
 ) (
<strong>ISP</strong>

 ) claims that:</p>
<div><blockquote class="blockquote">
<p>

<em>"many client-specific interfaces are better than one general-purpose interface"</em>

</p>
</blockquote>
</div>
<p>In other words, an interface that a client is linked with should not introduce dependencies that are not used by the client. The 
<strong>ISP</strong>

 is just SRP being applied to interfaces. Idiomatic F# fully supports ISP by statelessness and naturally segregated functions representing interfaces that contain exactly one method.</p>
</div>
<div><div><div><div><h2 class="title" id="toc_6"><a id="ch12lvl2sec136"/>
 Dependency Inversion Principle</h2>
</div>
</div>
</div>
<p>The letter "
<strong>D</strong>

 " in 
<strong>SOLID</strong>

 stands for 
<strong>Dependency Inversion Principle</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a>
 ) (
<strong>DIP</strong>

 ) stating:</p>
<div><blockquote class="blockquote">
<p>

<em>"depend upon abstractions, do not depend upon concretions"</em>

</p>
</blockquote>
</div>
<p>The following figure shows how 
<strong>DIP</strong>

 is achieved in OOP: if an instance of class <code class="literal">A</code>
 refers the instance of class <code class="literal">B</code>
 , this is a direct dependency violating DIP. This problem may be fixed by making an instance of class <code class="literal">A</code>
 dependent on the interface <code class="literal">IB</code>
 . So far, so good, but something must implement <code class="literal">IB</code>
 , right? Let it be the instance of class <code class="literal">B</code>
 , which is now a dependent of <code class="literal">IB</code>
 , so the inversion of dependency takes place.</p>
<p>It is easy to notice that in idiomatic F#, the role of dependency inversion plays a vanilla higher-order function: for example, function <code class="literal">f</code>
 has a parameter function, <code class="literal">g</code>
  which is used in defining <code class="literal">f</code>
 . When <code class="literal">f</code>
 is called, any of the argument functions <code class="literal">a</code>
 , <code class="literal">b</code>
 , or <code class="literal">c</code>
 may play the role of <code class="literal">g</code>
 as long as their signatures conform to <code class="literal">g</code>
 :</p>
<div><img src="img/Image00062.jpg" alt="Dependency Inversion Principle"/>
<div><p>Honoring Dependency Inversion Principle in functional programming</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch12lvl1sec73"/>
 Diminishing patterns</h1>
</div>
</div>
</div>
<p>Similarly to 
<strong>SOLID</strong>

 principles, many OOP design patterns in the context of idiomatic functional-first F# either diminish (sometimes to the extent of disappearing) or significantly morph. Let's take a quick look at some instances of such transformation. I will be using samples taken from the code base I authored, implementing payment applications for Jet.com. Samples are somewhat simplified to align with the book format.</p>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch12lvl2sec137"/>
 The Command design pattern</h2>
</div>
</div>
</div>
<p>The 
<strong>Command Design Pattern</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Command_pattern">https://en.wikipedia.org/wiki/Command_pattern</a>
 ) in OOP stands for a behavioral design pattern where all the information required to perform an action at a later time is encapsulated in an object. But wait a minute; doesn't this exactly coincide with what a function is? That's right; almost any idiomatic F# pattern of dealing with a higher-order function to traverse a data structure while applying a lower-order function to each element can be considered an occurrence of the Command pattern. Mapping, folding, you name it - all fit into this category. Doing what the Command pattern prescribes is an ubiquitous idiom in functional-first F#.</p>
<p>Let's consider an example: an order flow of a merchant participating in an e-commerce marketplace consists of transactions, each representing either 
<strong>sale</strong>

 or 
<strong>refund</strong>

 . By taking any continuous sequence of elements of the order flow, its running balance can be found. Now, the factor that makes things more interesting is that some orders may be nullified during an established period of time since their introduction being canceled. We are charged with tracking a running total for the marketplace finance department.</p>
<p>The functional-first aspect of F# allows for a very clean, idiomatic solution. I begin with two core domain objects, representing order types and customer transactions, combining the order type and its cost of goods (<code class="literal">Ch12_2.fsx</code>
 ):</p>
<pre class="programlisting">type OrderType = Sale | Refund 
type Transaction = Transaction of OrderType * decimal 
</pre>
<p>I continue with two core functions accounting for the total based on the order type:</p>
<pre class="programlisting">let sale total cost = total + cost 
let refund total cost = total - cost 
</pre>
<p>Equipped with this, it is time to define our 
<strong>commands</strong>

 in the pattern's sense. Both <code class="literal">Order</code>
 and <code class="literal">Cancellation</code>
 will take a running total and a transaction and return a new running total adjusted accordingly (note that <code class="literal">Cancellation</code>
 mirrors <code class="literal">Order</code>
 in terms of the total):</p>
<pre class="programlisting">let Order total = function 
| Transaction(OrderType.Sale, cost) -&gt; sale total cost 
| Transaction(OrderType.Refund, cost) -&gt; refund total cost 
let Cancellation total = function 
| Transaction(OrderType.Sale, cost) -&gt; refund total cost 
| Transaction(OrderType.Refund, cost) -&gt; sale total cost 
</pre>
<p>I'm done! Let me just demonstrate the built code in action by applying it to a sample order flow in FSI. The results are presented in the following screenshot, where a sequence of some <code class="literal">orderFlow</code>
 transactions is run through orders yielding <code class="literal">totalForward</code>
 of $271.86 and then through cancelation, eventually yielding the expected running total <code class="literal">totalBackward</code>
 of $0.00:</p>
<div><img src="img/Image00063.jpg" alt="The Command design pattern"/>
<div><p>Command pattern as idiomatic F# folding</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch12lvl2sec138"/>
 The Template design pattern</h2>
</div>
</div>
</div>
<p>The 
<strong>Template design pattern</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Template_method_pattern">https://en.wikipedia.org/wiki/Template_method_pattern</a>
 ) in OOP defines a common skeleton of an algorithm or a program, of which components can be overwritten but the general structure stays unchanged. Again, achieving this effect following the route that has functions as first class objects is trivial. For example, passing functions as parameters will work nicely, so the pattern diminishes to non-existing.</p>
<p>Idiomatic F# is even richer than this approach, allowing functions to cohesively keep participating in an interface and providing any of the concrete implementations in the form of an object expression.</p>
<p>Let's turn to a corresponding code sample taken from the enterprise codebase of Jet.com payment applications. The process of paying a partner participating in the Jet.com marketplace consists of three consecutive steps:</p>
<div><ol class="orderedlist arabic">
<li class="listitem">Obtaining payment requisites and the amount due based on the merchant ID.</li>
<li class="listitem">Formatting a payment for the use of a specific payment method.</li>
<li class="listitem">Submitting payment advice to the bank for execution.</li>
</ol>
<div></div>
<p>The template keeps the preceding parts together, allowing you to change each of the pieces to the case at the same time. As shown in the previous example, I begin with defining a few core domain entities (<code class="literal">Ch12_3.fsx</code>
 ):</p>
<pre class="programlisting">open System 
type PayBy = ACH | Check | Wire 
             override x.ToString() = 
                match x with 
                | ACH -&gt; "By ACH" 
                | Check -&gt; "By Check" 
                | Wire -&gt; "By Wire" 
type Payment = string 
type BankReqs = { ABA: string; Account: string} 
type Merchant = { MerchantId: Guid; Requisites: BankReqs } 
</pre>
<p>Here, <code class="literal">PayBy</code>
 represents a specific payment instrument (<code class="literal">Check</code>
 /<code class="literal">ACH</code>
 /<code class="literal">Wire</code>
 ), formatted <code class="literal">Payment</code>
 is just a type abbreviation, <code class="literal">BankReqs</code>
 represents a merchant's bank requisites for the account to accept the deposited payment, and <code class="literal">Merchant</code>
 wires together the merchant ID and bank requisites.</p>
<p>Now I define the template as an interface that reflects parts of the payment process being cohesive (<code class="literal">Ch12_3.fsx</code>
 ):</p>
<pre class="programlisting">type ITemplate = 
    abstract GetPaymentDue: Guid -&gt; Merchant*decimal 
    abstract FormatPayment: Merchant*decimal -&gt; Payment 
    abstract SubmitPayment: Payment -&gt;bool 
</pre>
<p>This piece is quite straightforward; <code class="literal">GetPaymentDue</code>
 retrieves the given merchant's requisites and payment amount due from the relevant persisted store, <code class="literal">FormatPayment</code>
 performs the required payment advice formatting, and <code class="literal">SubmitPayment</code>
 takes care of delivering the advice to Jet's bank. Note that I intentionally didn't specify the payment format here as this detail may be delayed for the implementation.</p>
<p>Then, here, I provide a specific (mock) implementation for <code class="literal">ITemplate</code>
 . Still, you can see that this arrangement allows plenty of flexibility; in particular, I made a specific payment instrument a parameter of the implementation (<code class="literal">Ch12_3.fsx</code>
 ):</p>
<pre class="programlisting">let Template  payBy = 
    { new ITemplate with 
        member __.GetPaymentDuemerchantId = 
          printfn "Getting payment due of %s" 
          (merchantId.ToString()) 
        (* mock access to ERP getting Accounts payable due for
            merchantId *) 
        ({ MerchantId = merchantId; 
          Requisites = {ABA="021000021"; 
          Account="123456789009"} }, 25366.76M) 
        member __.FormatPayment (m,t)  = 
          printfn "Formatting payment of %s" 
          (m.MerchantId.ToString()) 
        sprintf "%s:%s:%s:%s:%.2f" "Payment to" m.Requisites.ABA 
          m.Requisites.Account (payBy.ToString()) t 
        member __.SubmitPayment p = 
          printfn "Submitting %s..." p 
          true 
     } 
</pre>
<p>Finally, I wrap everything together into the function using the template (<code class="literal">Ch12_3.fsx</code>
 ):</p>
<pre class="programlisting">let makePaymentmerchantIdpayBy  = 
    let template = Template payBy in 
template.GetPaymentDuemerchantId 
    |&gt;template.FormatPayment 
    |&gt;template.SubmitPayment 
</pre>
<p>As usual, in order to see this code in action, I turn to FSI, presenting the results of running some mock payments in the following screenshot. I've omitted the complete script source from here for the sake of fitting the figure within a single book page:</p>
<div><img src="img/Image00064.jpg" alt="The Template design pattern"/>
<div><p>Template pattern disappearing in idiomatic F#</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch12lvl2sec139"/>
 The Strategy pattern</h2>
</div>
</div>
</div>
<p>The 
<strong>Strategy pattern</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Strategy_pattern">https://en.wikipedia.org/wiki/Strategy_pattern</a>
 ) is simply about adjusting the algorithm behavior in runtime by implementing a family of algorithms and using them interchangeably. Once again, what could suit this purpose better than a functional-first setting with functions as first-class language citizens?</p>
<p>To illustrate the use of the Strategy pattern, I will use just another use case from Jet.com's Payment system. In its shipping operations, Jet.com uses multiple carriers, and due to the significant volume of shipments, it processes carrier invoices electronically. The gist of this processing is the loading of invoices from each carrier into a staging data table, and then merging the contents of this data table with corresponding persistent stores in the 
<strong>upsert</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Merge_(SQL)">https://en.wikipedia.org/wiki/Merge_(SQL)</a>
 ) manner.</p>
<p>I approach the implementation of this 
<strong>EDI</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Electronic_data_interchange">https://en.wikipedia.org/wiki/Electronic_data_interchange</a>
 ) by outlining the implementation of the core behavior first (<code class="literal">Ch12_4.fsx</code>
 ):</p>
<pre class="programlisting">open System 
open System.Data 
type InvoiceFormat = 
| Excel 
| Csv 
let load (format: InvoiceFormat) (path: String) = 
    let dt = new DataTable() in 
    (* IMPLEMENTATION GOES HERE *) 
dt 
let merge (target: string) (dt: DataTable) = 
    (* IMPLEMENTATION GOES HERE *) 
    () 
</pre>
<p>The preceding snippet indicates that the supported invoice formats are either <code class="literal">Excel</code>
 or <code class="literal">CSV</code>
 , and there are two generic functions available to load invoices, somehow delivered to a location in any acceptable format, into a data table, and to merge the filled data table with the existing contents of the corresponding persistent store.</p>
<p>So far, so good; these two functions may be made accessible via an interface whose implementation is to be specific for each of the supported carriers (<code class="literal">Ch12_4.fsx</code>
 ):</p>
<pre class="programlisting">type ILoadVendorInvoices = 
    abstract LoadInvoices: String -&gt;DataTable 
    abstract member MergeInvoices: DataTable -&gt; unit 
</pre>
<p>Now, I provide specific implementations of the preceding interface for two of the carriers Jet.com engages into order shipments, namely FedEX and LaserShip (<code class="literal">Ch12_4.fsx</code>
 ):</p>
<pre class="programlisting">let LoadFedex = 
    { new ILoadVendorInvoices with 
        member __.LoadInvoices path = load Csv path 
        member __.MergeInvoicesdataTable = 
            merge "Fedex" dataTable 
    } 
let LoadLasership = 
    { new ILoadVendorInvoices with 
        member __.LoadInvoices path = load Excel path 
        member __.MergeInvoicesdataTable = 
            merge "Lasership" dataTable 
    } 
</pre>
<p>Now stay with me; we have two objects of the <code class="literal">ILoadVendorInvoices</code>
 type, each encapsulating its own carrier specifics. However, we can use them uniformly for EDI, as shown in the following function (<code class="literal">Ch12_4.fsx</code>
 ):</p>
<pre class="programlisting">let importEDIData (loader: ILoadVendorInvoices) path = 
    loader.LoadInvoices path |&gt;loader.MergeInvoices 
</pre>
<p>Just beautiful; now we can use instances of <code class="literal">LoadFedex</code>
 and <code class="literal">LoadLasership</code>
 to switch the behavior of EDI processing exactly in a manner the Strategy pattern prescribes. Let's turn to FSI for the demonstration. The following screenshot shows the results:</p>
<div><img src="img/Image00065.jpg" alt="The Strategy pattern"/>
<div><p>Strategy pattern expressed using F# idioms</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch12lvl1sec74"/>
 Summary</h1>
</div>
</div>
</div>
<p>This chapter highlighted that the functional-first approach does not blindly contradicts principles and patterns of object-oriented programming. Sometimes it also supports and amplifies them.</p>
<p>I'm going to devote the final chapter of this book to the subject of troubleshooting functional-first code, as it has certain specifics.</p>
</div>
</body></html>