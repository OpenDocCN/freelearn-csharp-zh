- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static Code Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s software development world, I believe it’s more important than ever
    to write clean and maintainable code. The increasing complexity of software, lower
    retention in the workforce, and increased competition should lead us to standardize
    our way of writing software more and put the next developer in the pit of success
    coming into the codebase. Catching errors early is super important when the developers
    have it in their mind, preferably. One of the ways to achieve this is through
    the use of static code analysis, which allows developers to identify potential
    issues and bugs in their code before it is even executed. With the Roslyn compiler
    extensions in C#, developers have the ability to create custom analyzers and code
    fixes that can help automate this process.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the basics of static code analysis and how to
    use Roslyn compiler extensions to write your own analyzers and code fixes. We’ll
    cover everything from the fundamentals of writing an analyzer to create automated
    tests to ensure that your code is working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re a seasoned developer looking to improve your code quality or
    a newcomer to the world of static code analysis, this chapter will provide you
    with the tools and knowledge you need to get started with Roslyn compiler extensions
    and take your code analysis to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: What is static code analysis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write an analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a code fix for an analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a solid understanding of how to
    use Roslyn compiler extensions to implement static code analysis in C#. You should
    be able to write your own custom analyzers and code fixes and know how to create
    automated tests to ensure the correctness of their implementation. Additionally,
    you should have a good understanding of the benefits of static code analysis and
    how it can improve the overall quality and maintainability of their code. With
    this knowledge, you will be well equipped to apply static code analysis techniques
    in your own development projects, leading to more efficient and effective software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17)),
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
    It also leverages the **Roslyn.Extensions** code that is found in the GitHub repository
    ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions)).
  prefs: []
  type: TYPE_NORMAL
- en: What is static code analysis?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static code analysis** is a powerful technique for detecting issues and bugs
    in your code before it’s even executed. While it may seem like a relatively new
    development, the truth is that static code analysis has been around for decades
    and has been used in languages such as C/C++ through tools such as linters.'
  prefs: []
  type: TYPE_NORMAL
- en: Linters are essentially static code analysis tools that analyze source code
    to flag suspicious constructs or style inconsistencies. They have been around
    for several decades and are widely used in languages such as C/C++ to improve
    code quality and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, static code analysis has gained more popularity with the rise
    of languages such as JavaScript and TypeScript. Tools such as ESLint have been
    developed to provide similar benefits to JavaScript and TypeScript developers
    by analyzing code for potential issues and providing feedback on best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Compiler **Software Development Kit** (**SDK**) from Microsoft takes
    a comprehensive approach to extending the compiler. Rather than just focusing
    on expanding its functionality, the SDK also enables the code to identify potential
    issues within your code editor or **Integrated Development Environment** (**IDE**).
    This feature is supported by popular editors, including **Visual Studio Code**
    (**VSCode**), Rider, and Visual Studio. As you work with files, the editors run
    analyzers in the background, highlighting potential issues with squiggly underlines.
    These analyzers can flag code that is incorrect or could be improved, providing
    real-time feedback to help you catch and correct mistakes more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside analyzers, Microsoft has introduced code fixers, a feature that enables
    analyzer vendors to provide code that can automatically fix flagged code issues.
    These code fixes are represented by light bulbs within the editor, and you can
    click on them to execute the code fix. With this feature, you can quickly and
    easily apply fixes to your code and improve its overall quality.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will provide an overview of static code analysis
    and code fixes in the context of the C# compiler and how they work. Although we
    won’t delve into the subject in great depth, we’ll provide you with the necessary
    information to get started. It’s important to note that the C# compiler APIs are
    extensive and offer great possibilities, and this introduction will serve as a
    starting point for exploring these features.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into writing an analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: How to write an analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing an analyzer that gets automatically run as part of the compile process
    has been made very simple by Microsoft. It follows the same principles as source
    generators, as we saw in [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272), *Generating
    Code*. Once you have the project set up, as we did back in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250),
    *Roslyn Compiler Extensions*, it’s all about dropping in a class that represents
    the analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, all code assumes you have the **Roslyn.Extensions** project
    that we established in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn*
    *Compiler Extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: The analyzer we’re going to make is a highly opinionated one that affects the
    naming of exception types. One of the things we tend to do is to suffix our types
    with what they technically represent; for instance, exceptions are often suffixed
    with **Exception**. Looking at exceptions found in the .NET base class libraries,
    you’ll see things such as **NotImplementedException**, **ArgumentException**,
    or **ArgumentNullException**. This is something I personally don’t like, and I
    believe that it is not important information to communicate, and we should instead
    put effort into properly naming the types for what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Take **ArgumentException** as an example. Its name does not convey its purpose.
    By simply changing it to be called **InvalidArgument**, it communicates that there
    is a violation – *the argument* *is invalid*.
  prefs: []
  type: TYPE_NORMAL
- en: You might not agree with this type of rule in your code base. But let’s set
    aside that for a minute and just use this as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Fleshing out an analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a home for the analyzer. In the **Roslyn.Extensions**
    project, add a folder called **CodeAnalysis**. I like to have folders for every
    analyzer type since we might be providing code fixes for the analyzer, and we
    might want to have more than just the analyzer class to create the analyzer. With
    that as a principle, add a folder within the **CodeAnalysis** folder called **ExceptionShouldNotBeSuffixed**;
    this will be the name of the analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **ExceptionShouldNotBeSuffixed**, you can now add a file called **Analyzer.cs**.
    Put the following into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up the basics for an analyzer by inheriting the **DiagnosticAnalyzer**
    type from the **.NET Compiler SDK**. In addition to this, it adorns the class
    with an **[DiagnosticAnalyzer]** attribute, instructing it that the supported
    language is C#. All the **using** statements are for the code to come.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Analyzers can support multiple languages by specifying the additional languages
    it supports. It can, however, affect the complexity of your analyzer as there
    are differences in how the **abstract syntax tree** (**AST**) is represented.
  prefs: []
  type: TYPE_NORMAL
- en: For the analyzer to work and be hooked up, it needs to be configured properly
    and register any actions that should be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the **Analyzer** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code calls **EnableConcurrentExecution()** on the **AnalysisContext** passed,
    which informs the compiler that your analyzer can be executed concurrently with
    other analyzers in an asynchronous manner. If your analyzer does not support concurrent
    execution, you can simply omit this call. If your analyzer does support concurrent
    execution, it can help to speed up your builds, making your development process
    more efficient. Next, it configures whether or not your analyzer should be run
    on generated code. The analyzer you’re building now should not care about generated
    code; it is therefore configured to ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the code registers an action to be run on syntax nodes. A **syntax node**
    is a fundamental unit of the AST, as we looked at in [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272),
    *Generating Code*, and corresponds to a specific syntactic construct, such as
    a method call, a loop statement, or a class declaration. Syntax nodes are represented
    as objects in memory and are linked together in a tree-like structure that mirrors
    the structure of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we’re only interested in class declarations; it therefore registers
    a **HandleClassDeclaration** callback with **SyntaxKind.ClassDeclaration**.
  prefs: []
  type: TYPE_NORMAL
- en: When an analyzer encounters a problem, it needs to produce a response to the
    compiler that tells there is an issue, and it should be reported back to the developer.
    The representation of the issue is formalized into something called **DiagnosticDescriptor**.
    You need to create specific ones of these for every specific broken rule you get.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the top of the **Analyzer** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code establishes a custom **DiagnosticDescriptor** that holds a reference
    to a unique diagnostic identifier (**PP0001**), a title, and a message to display
    to the developer. It also puts the broken rule into a category (**Naming**). Since
    the category is a string, this could be anything, but there are a few well-known
    ones used by other analyzers, such as **Naming**, **Design**, **Correctness**,
    **Performance**, and **Documentation**. The categories are used by tools to let
    developers group warnings or errors in a codebase. In the descriptor, you also
    put the severity level for the broken rule. The levels are shown in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Hidden | Not surfaced through normal means |'
  prefs: []
  type: TYPE_TB
- en: '| Info | Information that does not indicate a problem |'
  prefs: []
  type: TYPE_TB
- en: '| Warning | Suspicious but allowed; the developer should just know about it
    |'
  prefs: []
  type: TYPE_TB
- en: '| Error | Not allowed; the build will be broken |'
  prefs: []
  type: TYPE_TB
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the developer using your analyzer decides to use the **TreatWarningsAsErrors**
    option in the **.csproj** file, the warnings will be treated as errors and break
    the build. The **Roslyn.Extension.props** file that is included in projects using
    this extension has that option turned on.
  prefs: []
  type: TYPE_NORMAL
- en: The last few properties of **DiagnosticDescriptor** are further details to help
    the developers understand the compiler error or warning you want to communicate.
    You could, for instance, include a link to a web page describing in detail the
    analyzer or the specific rule you have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the syntax nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the analyzer to work, you’re going to need an implementation of the **HandleClassDeclaration**
    callback that was given during the **Initialize** method. Add the following private
    method to the **Analyzer** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by looking at the syntax node being analyzed. The syntax node
    would typically be things such as a method declaration, a class definition, or
    a variable declaration. Syntax nodes are used to represent the structure of the
    code but do not convey information about the meaning or semantics of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The code assumes the syntax node is a **ClassDeclarationSyntax** node, as that
    was what was configured as a filter in the **Initialize()** method. It then looks
    at the **BaseList** property to see whether the class declaration inherits from
    another type. If it doesn’t, the analyzer is not interested in the node, as it
    only wants to analyze types that inherit from **Exception**.
  prefs: []
  type: TYPE_NORMAL
- en: For the analyzer to understand the semantic meaning of the node being passed,
    it has to use **SemanticModel** to do so. From the declared symbol, it makes sure
    it has a base type; if not, it just returns.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code asks for a representation of the **System.Exception** type, which
    is then used to check if **BaseType** is, in fact, an exception. If it is an exception,
    it then checks the class identifier to see whether it is suffixed with the **Exception**
    text. If it is suffixed, it then reports back with an instance of the broken rule
    that holds the location of the class declaration identifier that was wrong.
  prefs: []
  type: TYPE_NORMAL
- en: That is pretty much it for creating a simple analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: Release tracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you go and build the **Roslyn.Extensions** project, you will get a
    warning that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The **RS2008** warning tells you that we could add information to our project
    that would make it easier to track releases of your packaged analyzers and the
    rules it provides. If this is not important to you, you can ignore this warning
    and move on.
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy the warning, we need to provide two files. One that contains the
    shipped rules and one that contains the unshipped rules. For an initial release,
    the unshipped rules file would typically be empty, while you might be putting
    in unshipped rules as part of releases for rules that are upcoming. When the rules
    are shipped, you typically move these from unshipped to shipped.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more detail about the purpose of these files on GitHub ([https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md](https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a file in the root of the **Roslyn.Extensions** project called **AnalyzerReleases.Shipped.md**
    and add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The content indicates a release version of **1.0** and provides a table of rules.
    In your case, you only have one rule. The **Notes** column could hold the name
    of the analyzer and, if you’d like, a link to a description of the broken rule.
  prefs: []
  type: TYPE_NORMAL
- en: With the shipped file in place, you’ll need a file for unshipped. Add a file
    called **AnalyzerReleases.Unshipped.md**. This file can be empty at this point,
    so just leave it as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'When packaging your Roslyn extension as a NuGet package, you want the files
    to be included. Open the **Roslyn.Extensions.csproj** file and add the following
    at the bottom of the file, within the **Project** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Your analyzer is now ready to be put into the real world and used.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the analyzer and see that it works and performs the way we expect it
    to, you’ll need a project that has code that violates the rule put into the analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder, next to the **Roslyn.Extensions** folder called **Chapter17**.
    Within the **Chapter17** folder in a terminal, create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you need a reference to the **Roslyn.Extensions** project. The project
    reference can not be a standard project reference; it needs to be slightly different.
    Add the following within the **Project** tag of the **Chapter17.csproj** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By telling it that **OutputItemType** is **Analyzer**, it will automatically
    hook up the assembly output from the **Roslyn.Extensions** project to the compiler.
    **ReferenceOutputAssembly** set to **false** tells it that the compiled output
    of the project will not reference the output assembly of the **Roslyn.Extensions**
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since your **Roslyn.Extensions** project should, at this point in time, be
    holding the **General Data Protection Regulation** (**GDPR**) solution built in
    [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272), *Generating Code*, and it has
    a requirement of a configuration property to be present, you’ll need to add the
    following within a **PropertyGroup** tag in the **Chapter17.csproj** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the **Chapter17.csproj** file in the **Chapter17** folder, you will
    need to add a reference to the props file from the **Roslyn.Extensions** project.
    Add the following at the top of the file within the **Project** tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Chapter17** folder, add a file called **MyException.cs** and add the
    following to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open your terminal and do a build, you should see something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output clearly says that you have a **PP0001** error, and the text describes
    the actual problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty cool, but what’s even cooler is that in your editor, you should
    get a clear indication that you have an error by getting a squiggly line underlining
    the **MyException** class name. In **Visual Studio Code** (**VS Code**), this
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – VS Code analysis error
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having trouble getting your editor to show the analyzer error, you
    might need to restart it, or if it has a language server, just restart that. For
    VS Code, you can simply bring up the command palette (*F1*) and type **OmniSharp**
    and then select **OmniSharp:** **Restart OmniSharp**.
  prefs: []
  type: TYPE_NORMAL
- en: With an analyzer in place, it’s time to look into making your developers more
    productive so that they can fix errors quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: How to write a code fix for an analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, the .NET Compiler SDK supports more than just writing
    analyzers that analyze your code. You can also provide code that quickly fixes
    any errors that occur. These are understood by most editors and IDEs and will
    automatically be loaded and presented when applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be reusing the **Roslyn.Extensions** project for the code fix as well.
    The code fix needs to tap into specific APIs and needs another package reference.
    Add a reference to **Microsoft.CodeAnalysis.CSharp.Workspaces** by running the
    following in your terminal within the **Roslyn.Extensions** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the package reference in place, it’s time for the implementation of the
    code fix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a file called **CodeFix.cs** within the **CodeAnalysis/ExceptionShouldNotBeSuffixed**
    folder in the **Roslyn.Extensions** project folder. Add the following to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code sets up a code fix by inheriting from the **CodeFixProvider** and adding
    the **[ExportCodeFixProvider]** attribute. It specifies the language it supports
    and the name of the code fix. As with the analyzer, you can support multiple languages
    by specifying that on the attribute. If you want, you can narrow down the document
    types you want to support and also file extensions by setting the **DocumentKinds**
    or **DocumentExtensions** properties of **ExportCodeFixProvider**. We leave these
    as default, as we trust the editor to call us correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code fix to be invoked, it needs to specify what broken rule it can
    fix. This is done by providing an array of the rule diagnostic identifier. Add
    the following within the **CodeFix** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the broken rule association in place, the next thing you’ll need is a
    method that registers the code fix and the code to be called when the code fix
    is invoked. Add the following method to the **CodeFix** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code assumes there is only one **Diagnostic** that can be errored. This
    is because there is only one in the analyzer. If you have more, you’d need to
    find the correct diagnostic and match the appropriate code fix to it. However,
    for maintainability, I would recommend having one file per code fix linked to
    one broken rule.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code registers a code fix for the diagnostic; it does so by creating
    a **CodeAction** that holds a title to display the code fix and the callback to
    be called when the code fix is invoked by the developer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All code fix providers can fix single problems, but they can also fix multiple
    by providing **FixAllProvider**. This is something you can choose to implement
    yourself if it needs special handling or use the default **BatchFixer**. Add the
    following method to provide **FixAllProvider**. This is completely optional; by
    default, it does not provide any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing you’ll need is the code that performs the code fix. The only
    fix you can really do is to provide code that removes the suffix. Add the following
    code to the **CodeFix** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code navigates the document and finds the **ClassDeclarationSyntax** node.
    If it can’t find it, the code fix does not do anything. It then replaces the **Exception**
    text in the **Identifier** of the node with **string.Empty** and then replaces
    the node. It then returns a modified version of the document with the modified
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Since this code fix is a very simple one, it does not leverage much of the APIs
    available for code fixes. An important aspect of code fixes is to be aware of
    formatting and make sure the result is formatted correctly. This is done by adding
    **.WithAdditionalAnnotations(Formatter.Annotation)** on the node when altering
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to do for a simple code fix to work. All you now need to
    do is compile it and open a file that violates the rule. In your case, that would
    be the **MyException.cs** file within the **Chapter17** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Editors do this slightly differently, but within VS Code, the code fix capability
    would show up as a lightbulb, and clicking the lightbulb would then show the **Remove
    Exception suffix** code fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – VS Code code fix
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you’re having trouble getting your editor to show the code fix, you might
    need to restart it, or if it has a language server, just restart that. For VS
    Code, you can simply bring up the command palette (*F1*) and type **OmniSharp**
    and then select **OmniSharp:** **Restart OmniSharp**.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your analyzer and code fix with the compiler and an editor does not
    give you the best feedback loop, and as with any code you write, it would be hard
    to catch regression bugs.
  prefs: []
  type: TYPE_NORMAL
- en: How to write automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing automated tests for all your code gives you the confidence to change
    your code and know whether you broke anything. This applies to all code, including
    analyzers and code fixes. For anything that extends the compiler or provides editors
    or IDEs with new capabilities, it’s also harder to test whether or not your implementation
    works. It can be frustrating at times to get things working and can hamper your
    productivity by building these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Microsoft has provided an easy way to test your analyzers and code
    fixes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the **Roslyn.Extensions** folder, create a folder called **Roslyn.Extensions.Tests**.
    In a terminal, navigate to the **Roslyn.Extensions.Tests** folder and run the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command will set up a [test project usin](https://xunit.net)g the xUnit
    ([https://xunit.net](https://xunit.net)) testing library.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can use other testing frameworks as well, such as MSTest or NUnit.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover unit testing or the specifics of xUnit. You can read more
    about xUnit on its site.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing you’ll need is a project reference to the **Roslyn.Extensions**
    project. Run the following command within the **Roslyn.Extensions.Tests** folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds a project reference to the **Roslyn.Extensions** project, and you
    may notice that you did this differently than with the **Chapter17** project.
    The reason is that in the context of testing, you need the **Roslyn.Extensions**
    assembly to be referenced by the test assembly and be present at the runtime of
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzer tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the test project in place and the reference to the extension project itself,
    we can start filling it with the tests we want. The first thing you want to write
    a test for is the analyzer. The purpose of the tests for the analyzer is to verify
    that the analyzer will give an error when the code contains an exception that
    is suffixed and not give an error when exception types do not have a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called **ExceptionShouldNotBeSuffixed** within the **Roslyn.Extensions.Tests**
    folder. Then add a file called **AnalyzerTests**. Put the following content into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This sets up the basics needed for writing the tests. You’re probably asking
    yourself why the namespace declaration comes before the **using** statements.
    We’re doing that to avoid having to use the fully qualified name in **Verify**
    using an alias. The **Verify** alias creates an alias for the **AnalyzerVerifier<>**
    generic type and gives it the analyzer under test as a generic parameter. The
    aliasing is just for convenience, making your tests easier to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Also, another slightly different thing is the word **Tests**, which the **Roslyn.Extensions.Tests**
    project name is suffixed with, which is normally something you would also reflect
    in the namespace. Personally, I prefer not to, as test projects are not something
    you’re deploying, and it generally makes things simpler if you omit this from
    your namespace. But that is entirely a personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you want to test is whether the analyzer is analyzing the correct
    code. Add the following method to the **AnalyzerTests** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The test sets up a valid C# program and calls the **VerifyAnalyzerAsync()**
    method for that program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need a test for testing the violation of the rule. Add the following
    method to the **AnalyzerTests** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The test sets up an invalid C# program and sets up an expectation of a failure
    at line **5** and column **30**. Since you’re putting in the content of the file
    this way, the first line will be empty, and the column is also then the column
    you see in the editor, which should be **30** with the method indented. You could
    improve this by embedding files as embedded resources that you could then maintain
    separately and have a more predictable setup for. The **VerifyAnalyzerAsync()**
    method is then called with the content and the expectations.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the tests we want to perform for the analyzer at this point. But we do
    also have a code fix for the analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: Code fix tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the analyzer, you can create tests specific to code fixes. It uses
    a different verifier than the analyzer: **CodeFixVerifier**. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **CodeFixTests** within the **ExceptionShouldNotBeSuffixed**
    folder in the **Roslyn.Extensions.Test** project folder. Then add a file called
    **CodeFixTests.cs** and add the following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you did with the analyzer tests, you used a verifier. For code fixes, it
    is a different type of verifier: **CodeFixVerifier**.'
  prefs: []
  type: TYPE_NORMAL
- en: The **CodeFixVerifier** verifier needs two generic arguments, the first one
    representing the analyzer and the second representing the code fix being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to the **CodeFixTests** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code verifies that the code fix does not perform any actions when the C#
    program is a valid program that doesn’t break the rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need a test that verifies the code fix actually performs what is
    expected. Add the following method to the **CodeFixTests** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with the analyzer test for the broken rule scenario, it sets up an expectation
    that there should be a compiler error at a specific location. Additionally, it
    then verifies that the code fix actually replaces the **MyException** text by
    removing the suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'With tests for both the analyzer and the code fix in place, you can run these
    by running the following in your terminal within the **Roslyn.Extensions.Tests**
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should then see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you are using an editor that supports xUnit tests, chances are they are already
    visible in the test explorer of your editor, and you can run them from there as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: For a full overview of the **Microsoft.CodeAnalysis.Testing** project, I recommend
    heading over to GitHub ([https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md](https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered the use of Roslyn compiler extensions for performing
    static code analysis in C#. We began by explaining what static code analysis is
    and how it differs from dynamic analysis, as well as its benefits and limitations.
    We then covered how to write custom analyzers using Roslyn, using diagnostics
    to report issues, and implementing code fixes to automatically correct issues.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed best practices for testing and maintaining code analysis tools,
    as well as how to build rules that are specific to your team and domain. Catching
    errors fast is crucial for minimizing development time and cost, and static code
    analysis is a powerful tool for achieving this. By detecting issues and bugs in
    your code before it’s even executed, you can avoid costly mistakes and improve
    overall code quality and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a solid understanding of how to use Roslyn for static code
    analysis in C#, as well as the benefits and challenges of this approach. You should
    also understand how to write effective analyzers and code fixes and how to build
    custom rules for their specific team and domain.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is a powerful technique for catching errors quickly and
    improving overall code quality and maintainability. By building custom rules that
    are specific to your team and domain, you can ensure that your code is not only
    error-free but also conforms to your team’s standards and practices. This can
    save time and resources that would otherwise be spent on debugging and testing,
    allowing you to deliver higher-quality software faster.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the practical sides of the book, and the next and final
    chapter will cover general caveats and some final words about everything discussed
    in the book.
  prefs: []
  type: TYPE_NORMAL
