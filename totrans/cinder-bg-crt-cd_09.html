<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Enter Sound – Adding Sound and Audio</h1></div></div></div><p>In this chapter, we will talk a bit about the concept of sound in creative coding.</p><p>In this chapter we will learn the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to load and play sound in Cinder</li><li class="listitem" style="list-style-type: disc">How to modify sound in real time</li><li class="listitem" style="list-style-type: disc">How to use audio data to draw and animate</li><li class="listitem" style="list-style-type: disc">How to make use of live sound input</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Loading and playing a sound file</h1></div></div></div><p>There are several <a class="indexterm" id="id303"/>ways of using sound in creative coding. One way is to use audio <a class="indexterm" id="id304"/>samples, another one is to use live input, and then there is the possibility of generating sound from scratch. Nevertheless, a lot more possibilities emerge when you start to combine all of these approaches.</p><p>In this chapter, we will learn to load, play, and visualize audio files and capture live input. To get started, open <a class="indexterm" id="id305"/>TinderBox and make another project with the name <code class="literal">BasicAudio</code>. Open <code class="literal">xcode/BasicAudio.xcodeproj</code> (<code class="literal">vc10\BasicAudio.sln</code> on Windows). Open <code class="literal">BasicAudioApp.cpp</code> in the editor.</p><p>To use the basic audio features of Cinder, we have to import the appropriate libraries:</p><div><pre class="programlisting">#include "cinder/audio/Output.h"</pre></div><p>This particular one contains all the code that is needed to load and play back an audio file. Go and find your own audio file (<code class="literal">mp3</code> or <code class="literal">wav</code> will work), and place it in the project's <code class="literal">assets</code> folder.</p><p>We will need an <code class="literal">audio::SourceRef</code> object<a class="indexterm" id="id306"/> for storing the reference to the audio source that <a class="indexterm" id="id307"/>we will use in our code. Add the following line to your class declaration:</p><div><pre class="programlisting">audio::SourceRef src;</pre></div><p>Add the following <a class="indexterm" id="id308"/>code snippet into the <code class="literal">setup()</code> method implementation:</p><div><pre class="programlisting">src = audio::load(loadAsset("sample.wav"));
audio::Output::play(src);</pre></div><p>This will load the audio file into the computer memory as the <code class="literal">audio::Source</code> object and save a reference in the <code class="literal">src</code> variable. Then, we can play the sound by using the <code class="literal">audio::Output::play()</code> <a class="indexterm" id="id309"/>class method.</p><p>Compile and run our application. You should hear the sound. There are some limitations with this way of playing the sound back. It is not possible to apply the loop control to it in any other way (except for setting and getting the volume).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Using tracks</h1></div></div></div><p>The Cinder <code class="literal">Track</code> class<a class="indexterm" id="id310"/> provides more control over a sound file. Let's go over a couple of features of the <code class="literal">Track</code> class that we might use most often.</p><p>To loop the loaded audio file, we <a class="indexterm" id="id311"/>will need to add a <code class="literal">Track</code> object to the <code class="literal">Output</code> object and save the returned track reference so that we can use it to control the sound later. Add a variable for storing the track reference in the class declaration:</p><div><pre class="programlisting">audio::TrackRef trackRef;</pre></div><p>Replace the code in the <code class="literal">setup()</code> method implementation with the following:</p><div><pre class="programlisting">src = audio::load(loadAsset("sample.wav"));
trackRef = audio::Output::addTrack(src);</pre></div><p>This will basically do the same as before for now, except that it will store the <code class="literal">audio::Source</code> pointer<a class="indexterm" id="id312"/> as a separate track in the <code class="literal">audio::Output</code> object. The <code class="literal">addTrack()</code> function<a class="indexterm" id="id313"/> has another parameter, <code class="literal">autoplay</code>, which is automatically set to <code class="literal">true</code> if we don't provide the other value. Let's try to set it to <code class="literal">false</code>:</p><div><pre class="programlisting">trackRef = audio::Output::addTrack(src, <strong>false</strong>);</pre></div><p>As we set the <code class="literal">autoplay</code> parameter<a class="indexterm" id="id314"/> to <code class="literal">false</code>, audio file is not played after it is loaded. We can use this approach if we want the audio file to be played at some other point of the application flow. Use the following code to play it:</p><div><pre class="programlisting">trackRef-&gt;play();</pre></div><p>We used the <a class="indexterm" id="id315"/>arrow syntax here because the track reference is just a C++ pointer to the actual <code class="literal">Track</code> object. All other properties of the track are accessed in the same manner.</p><p>We can add more than one track to the <code class="literal">Output</code> object by creating a new audio source object and adding it to the <code class="literal">audio::Output</code> pointer. We won't do it now, but keep in mind that this is possible in case we want to create some kind of multilayer audio application.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Changing track parameters</h1></div></div></div><p>Next thing that <a class="indexterm" id="id316"/>we want to do is to make the audio file play again after it has finished playing. It is possible by setting the looping of the track to <code class="literal">true</code>:</p><div><pre class="programlisting">trackRef-&gt;setLooping(true);</pre></div><p>This will make the track loop infinite.</p><p>Another thing that we might want to do is to change the track volume. You can think of the <code class="literal">Output</code> volume as the master volume and the <code class="literal">Track</code> volumes as individual track volumes of a mixer.</p><p>To change the volume, use the following code:</p><div><pre class="programlisting">trackRef-&gt;setVolume(0.5f); // set track volume
audio::Output::setVolume(0.5f); // set master volume</pre></div><p>We can use variables to dynamically change the volume of the sound. Let's do that for both master and track volumes.</p><p>Add the following lines to the class declaration of the app:</p><div><pre class="programlisting">float masterVol, trackVol;
void mouseMove(MouseEvent event);</pre></div><p>With these lines of code, we declare two floats that will store the master and track volumes and a <code class="literal">mouseMove</code> method<a class="indexterm" id="id317"/> override of the <code class="literal">AppBasic</code> class that will let us respond to mouse movements.</p><p>Let's go to the <code class="literal">setup()</code> method implementation and initialize the <code class="literal">masterVol</code> and <code class="literal">trackVol</code> variables, additionally change the raw values of <code class="literal">trackRef-&gt;setVolume()</code> and <code class="literal">audio::Output::setVolume()</code>:</p><div><pre class="programlisting">void BasicAudioApp::setup() {
<strong>  masterVol = trackVol = 0.5f;</strong>
  src = audio::load(loadAsset("sample.wav"));
  trackRef = audio::Output::addTrack(src, false);
  trackRef-&gt;setLooping(true);
  trackRef-&gt;setVolume(<strong>trackVol</strong>); // set track volume
  audio::Output::setVolume(<strong>masterVol</strong>); // set master volume
  trackRef-&gt;play();
}</pre></div><p>Add the <a class="indexterm" id="id318"/>implementation of the <code class="literal">mouseMove</code> method at the end of the file, before the <code class="literal">CINDER_APP_BASIC()</code> call:</p><div><pre class="programlisting">void BasicAudioApp::mouseMove(MouseEvent event) {
    masterVol = (float)event.getX()/getWindowWidth();
    trackVol = (float)event.getY()/getWindowHeight();
    audio::Output::setVolume(masterVol);
    trackRef-&gt;setVolume(trackVol);
}</pre></div><p>An <code class="literal">event</code> object of the type <code class="literal">MouseEvent</code> is passed to this method. We can get the current location of the mouse cursor at the time of the event as well as many other parameters that the <code class="literal">event</code> object holds. We will stick to the mouse <code class="literal">x</code> and <code class="literal">y</code> coordinates for now and use them for changing the volume.</p><p>For changing the master volume, we are using the <code class="literal">x</code> coordinate. We are using the <code class="literal">y</code> coordinate for the track volume.</p><p>As volume of the sound in Cinder is defined in a range from <code class="literal">0.0f</code> to <code class="literal">1.0f</code>, we need to transform the mouse positions in this kind of form. To do that, we need to divide the actual mouse position with its maximum range that is the width and height of the window. So, if the mouse <code class="literal">x</code> position is <code class="literal">0</code> and window width is <code class="literal">100</code>, after dividing the coordinate with the window width (0/100) we get <code class="literal">0</code>. If the mouse <code class="literal">x</code> position is <code class="literal">100</code>, we get <code class="literal">1</code>. Additionally, if the mouse <code class="literal">x</code> position is <code class="literal">50</code>, we get <code class="literal">0.5</code> (50/100).</p><p>As the mouse positions and window dimensions are returned as <code class="literal">int</code> values, we will need to cast one of the values to <code class="literal">float</code> for a successful floating point number operation. That is why there is <code class="literal">(float)</code> before the <code class="literal">event.getX()/getWindowWidth()</code> and <code class="literal">event.getY()/getWindowHeight()</code> parts of the code, it casts the <code class="literal">int</code> value returned by <code class="literal">event.getX()</code> to <code class="literal">float</code>. Finally, we set the master volume and track volume with <code class="literal">audio::Output::setVolume(masterVol);</code> and <code class="literal">trackRef-&gt;setVolume(trackVol);</code>.</p><p>Compile and run our application. Move the mouse, you should hear how the volume of the sound is changing.</p><p>Next useful feature that we might want to learn is jumping to a certain position of the time of the track. To do that, we will use the <code class="literal">mouseDrag</code> method of the <code class="literal">AppBasic</code> class. Let's declare an override of it by adding the following line to the class declaration:</p><div><pre class="programlisting">void mouseDrag(MouseEvent event);</pre></div><p>Let's implement that. Add the following code at the end of the file, before the <code class="literal">CINDER_APP_BASIC()</code> call:</p><div><pre class="programlisting">void BasicAudioApp::mouseDrag(MouseEvent event) {
    double time =
    (double)event.getX()/getWindowWidth()*src-&gt;getDuration();
    trackRef-&gt;setTime( time );
}</pre></div><p>In this<a class="indexterm" id="id319"/> example, the application window's width is being mapped to the duration of the track. The <code class="literal">x</code> position of the mouse is being transformed to a specific time in the audio track. The <code class="literal">trackRef-&gt;setTime(time)</code> part of the code sets the position of the track playhead.</p><p>Compile and run our application. You should be able to do live seeking now. Click and drag to try that out.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec59"/>Visualizing audio</h1></div></div></div><p>There is one important <a class="indexterm" id="id320"/>thing missing in our creative sound application—the visual side of it. Let's create a simple equalizer.</p><p>First, we will need to enable the PCM buffering of the audio track.</p><p>
<strong>PCM</strong>
<a class="indexterm" id="id321"/> stands for <strong>pulse code modulation</strong> and it is a method for digitally representing sampled analog signals. An analog audio signal is the fluctuation of voltage inside a conductor. A digital representation of that are samples or bytes with floating point values usually from <code class="literal">-1</code> to <code class="literal">1</code>.</p><p>In the world of audio sampling there is a term, sampling rate, which represents the amount of samples or values being sampled each second. The PCM values and sampling rate of an audio file determine its playback speed.</p><p>To enable PCM buffering<a class="indexterm" id="id322"/> and be able to read PCM values during application runtime, add the following code in the <code class="literal">setup()</code> method's declaration before <code class="literal">trackRef-&gt;play()</code>:</p><div><pre class="programlisting">trackRef-&gt;enablePcmBuffering( true );</pre></div><p>Second, we need a variable that will serve as a pointer to the track's PCM buffer.</p><p>A PCM<a class="indexterm" id="id323"/> buffer is the secret place in computer memory where the raw values of the sound wave coming out from our speakers reside. Before any sound is sent to the audio output, it is kept in the buffer for some time. When the sound is played, the buffer is cleared and filled again with new audio data.</p><p>We will need to access the PCM buffer to read the raw waveform values from it. Add the following line to the class declaration to add a variable that will serve as a reference to it:</p><div><pre class="programlisting">audio::PcmBuffer32fRef pcmBuffer;</pre></div><p>Third, we need to get a copy of the most recent buffer in each frame. Add the following code to the <code class="literal">update()</code> method implementation:</p><div><pre class="programlisting">pcmBuffer = trackRef-&gt;getPcmBuffer();</pre></div><p>Finally, change the <code class="literal">draw()</code> method implementation as follows:</p><div><pre class="programlisting">void BasicAudioApp::draw() {
  // clear the screen by drawing
  // a semi-transparent black rectangle all over the screen
  gl::enableAlphaBlending();
  gl::color( 0.f, 0.f, 0.f, 0.1f );
  gl::drawSolidRect(getWindowBounds());

  if( !pcmBuffer ) {
    gl::disableAlphaBlending();
    return; // stop here if the buffer is empty
  }

  // get copy of the left channel data from the pcmBuffer
  audio::Buffer32fRef buffer =
  pcmBuffer-&gt;getChannelData( audio::CHANNEL_FRONT_LEFT );

  // get buffer length
  uint32_t bufferLength = pcmBuffer-&gt;getSampleCount();

  // calculate scale for mapping the buffer data on the screen
  float scale = getWindowWidth() / (float)bufferLength;
  // set color to cyan
  gl::color( 0.f, 1.f ,1.f ,0.8f );

  // loop through current buffer data
  // in steps of 10 and construct waveform
  for( int i=0; i&lt;bufferLength; i+=10 ) {
    // map current x position of buffer value to window width
    float x = i * scale;
    
    // buffer data fluctuates from -1 to +1,
    // map it to window height
    float y = ( (buffer-&gt;mData[i]+1) * getWindowHeight()/2 );

    // draw a circle
    gl::drawStrokedCircle( Vec2f(x, y),
    ( abs(buffer-&gt;mData[i])*getWindowHeight()/2 ) );
  }

  gl::disableAlphaBlending();
}</pre></div><p>Compile and<a class="indexterm" id="id324"/> run our application, you should see an image as shown in the following screenshot:</p><div><img alt="Visualizing audio" src="img/9564_09_01.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Using audio input</h1></div></div></div><p>How about using <a class="indexterm" id="id325"/>a microphone or line-in as the audio source? No problem. To make this possible, we will need to import the audio <code class="literal">Input</code> library:</p><div><pre class="programlisting">#include "cinder/audio/Input.h"</pre></div><p>We are going to extend our current application so that we can switch between live input and playback of the loaded file. We will need to declare two new variables for this:</p><div><pre class="programlisting">audio::Input input;
bool useInput;</pre></div><p>The first variable represents our sound input, and we will use the second one as a switch.</p><p>Next, we have to initialize the <code class="literal">input</code> variable, so go to the <code class="literal">setup()</code> method implementation and add the following line there:</p><div><pre class="programlisting">input = audio::Input();</pre></div><p>This assigns the default audio input to the <code class="literal">input</code> variable.</p><p>Let's use the <code class="literal">mouseDown</code> method override and fill it with the following code:</p><div><pre class="programlisting">useInput = !useInput;
    
if ( useInput ) {
    input.start();
    trackRef-&gt;stop();
} else {
    input.stop();
    trackRef-&gt;play();
}</pre></div><p>These lines of code handle the switching between live and loaded input. Every time the mouse is clicked, the <code class="literal">useInput</code> variable is inverted from <code class="literal">false</code> to <code class="literal">true</code> or vice versa. Depending on the value we get, we enable the live or loaded input.</p><p>Finally, replace the code in the <code class="literal">update()</code> method implementation as follows:</p><div><pre class="programlisting">if ( useInput ) pcmBuffer = input.getPcmBuffer();
else pcmBuffer = trackRef-&gt;getPcmBuffer();</pre></div><p>These lines of code get the current PCM buffer. If the <code class="literal">useInput</code> variable is set to <code class="literal">true</code>, we use the PCM buffer of the live input, if not, we use the PCM buffer of the loaded track.</p><p>Compile and run the application. Click on the window to enable live input. Click again to return to the loaded sound.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter we learned the basics of audio in Cinder. We learned how to load and play back an audio file, how to change its volume, and seek and visualize the PCM buffer. We also learned how to use live input audio data.</p><p>With this knowledge, now we are able to create audio-reactive applications that are capable of analyzing almost any kind of sound in real time and provide high performance visual feedback. Audio analysis is a broad topic and you may want to study it further. Try to Google "FFT", "octave analysis", or "beat tracking", for example. It is also possible to use some kind of third-party audio processing library, if the features that Cinder provides in terms of audio processing are not enough for you.</p></div></body></html>