- en: Chapter 4. XamChat – a Cross-platform App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。XamChat – 一个跨平台应用
- en: The best way to truly learn a programming skill, in my opinion, is to take on
    a simple project that requires you to exercise that skill. This gives new developers
    a project where they can focus on the concepts they are trying to learn without
    the overhead of fixing bugs or following customer requirements. To increase our
    understanding of Xamarin and cross-platform development, let's develop a simple
    app called **XamChat** for iOS and Android.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，真正学习编程技能的最佳方式是承担一个需要你练习该技能的简单项目。这为新开发者提供了一个项目，他们可以在其中专注于他们试图学习的概念，而无需处理修复错误或遵循客户要求的开销。为了提高我们对Xamarin和跨平台开发的理解，让我们为iOS和Android开发一个名为**XamChat**的简单应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Our sample application concept
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的示例应用程序概念
- en: The Model layer of our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序的模型层
- en: Mocking a web service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟一个网络服务
- en: The ViewModel layer of our application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序的视图模型层
- en: Writing unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Starting our sample application concept
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始我们的示例应用程序概念
- en: 'The concept is simple: a chat application that uses a standard Internet connection
    as an alternative to send text messages. There are several popular applications
    like this on the Apple App Store, probably due to the cost of text messaging and
    support for devices such as the iPod Touch or iPad. This will be a neat real-world
    example that can be useful for users, and will cover specific topics in developing
    applications for iOS and Android.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 概念很简单：一个使用标准互联网连接作为发送文本消息替代方案的聊天应用程序。在苹果应用商店中有几个类似的应用程序，这可能是由于短信的成本以及iPod Touch或iPad等设备的支持。这将是一个整洁的现实世界示例，对用户来说可能很有用，并将涵盖为iOS和Android开发应用程序的特定主题。
- en: 'Before we start with the development, let''s list the set of screens that we''ll
    need:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发之前，让我们列出我们将需要的屏幕集：
- en: '**Login / sign up**: This screen will include a standard login and sign-up
    process for the user'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录/注册**：此屏幕将包括用户的标准登录和注册过程'
- en: '**List of conversations**: This screen will include a button to start a new
    conversation'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对话列表**：此屏幕将包括一个按钮来开始新的对话'
- en: '**List of friends**: This screen will provide a way to add new friends when
    we start a new conversation'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**朋友列表**：此屏幕将在我们开始新对话时提供添加新朋友的方式'
- en: '**Conversation**: This screen will have a list of messages between you and
    another user, and an option to reply'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对话**：此屏幕将显示您和另一个用户之间的消息列表，以及回复的选项'
- en: 'So a quick wireframe layout of the application will help you grasp a better
    understanding of the layout of the app. The following figure shows you the set
    of screens to be included in your app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个快速的应用程序线框布局将帮助你更好地理解应用程序的布局。以下图显示了您应用程序中应包含的屏幕集：
- en: '![Starting our sample application concept](img/00027.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![开始我们的示例应用程序概念](img/00027.jpeg)'
- en: Developing our Model layer
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的模型层
- en: Since we have a good idea of what the application is, the next step is to develop
    the business objects, or Model layer, of this application. Let's start by defining
    a few classes that will contain the data to be used throughout the app. It is
    recommended, for the sake of organization, to add these to a `Models` folder in
    your project. This is the bottom layer of the MVVM design pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对应用程序有了很好的了解，下一步是开发这个应用程序的业务对象，即模型层。让我们先定义几个将包含整个应用程序所需数据的类。为了组织上的原因，建议将这些类添加到项目中的`Models`文件夹中。这是MVVM设计模式的底层。
- en: 'Let''s begin with a class that represents a user. The class can be created
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从代表用户的类开始。该类可以创建如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pretty straightforward so far; let''s move on to create classes representing
    a conversation and a message as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，事情相当直接；让我们继续创建代表对话和消息的类的如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we are using strings as identifiers for the various objects. This
    will simplify our integration with Azure Mobile Services in the later chapters.
    `UserId` is the value that will be set by the application to change the user that
    the object is associated with.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用字符串作为各种对象的标识符。这将在后续章节中简化我们与Azure Mobile Services的集成。`UserId`是应用程序将设置的值，用于更改与对象关联的用户。
- en: 'Now, let''s go ahead and set up our solution by performing the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续通过以下步骤来设置我们的解决方案：
- en: Start by creating a new solution and a new **Portable Library** project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的解决方案和一个新的**可移植库**项目。
- en: Name the project `XamChat.Core` and the solution `XamChat`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `XamChat.Core`，解决方案命名为 `XamChat`。
- en: You can also choose to use a **Shared Project** for this project, but I chose
    to use a portable class library because it encourages better programming practices
    in general.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以选择为这个项目使用一个 **共享项目**，但我选择使用可移植类库，因为它鼓励更好的编程实践。
- en: Writing a mock web service
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模拟网络服务
- en: Many times when developing a mobile application, you might need to begin the
    development of your application before the real backend web service is available.
    To prevent the development from halting entirely, a good approach would be to
    develop a mock version of the service. This is also helpful when you need to write
    unit tests, or just need to add a real backend to your app later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发移动应用程序时，很多时候你需要在真正的后端网络服务可用之前就开始开发你的应用程序。为了防止开发完全停滞，一个很好的方法就是开发一个服务的模拟版本。这在你需要编写单元测试，或者稍后需要向你的应用程序添加真实后端时也非常有用。
- en: 'First, let''s break down the operations our app will perform against a web
    server. The operations are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分解我们的应用程序将对网络服务器执行的操作。操作如下：
- en: Log in with a username and password.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户名和密码登录。
- en: Register a new account.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个新账户。
- en: Get the user's list of friends.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的联系人列表。
- en: Add friends by their usernames.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用户名添加朋友。
- en: Get a list of the existing conversations for the user.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户现有对话的列表。
- en: Get a list of messages in a conversation.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取对话中的消息列表。
- en: Send a message.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一条消息。
- en: 'Now let''s define an interface that offers a method for each scenario. The
    method is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个接口，为每个场景提供一个方法。方法如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we're simplifying any asynchronous communication with a web
    service by leveraging the **Task Parallel Library** (**TPL**) from the .NET base
    class libraries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过利用 .NET 基类库中的 **任务并行库**（**TPL**）简化了与网络服务的任何异步通信。
- en: Since communicating with a web service can be a lengthy process, it is always
    a good idea to use the `Task<T>` class for these operations. Otherwise, you can
    inadvertently run a lengthy task on the user interface thread, which will prevent
    user input during the operation. `Task` is definitely needed for web requests,
    since users could be using a cellular Internet connection on iOS and Android,
    and it will give us the ability to use the `async` and `await` keywords down the
    road.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与网络服务的通信可能是一个漫长的过程，因此始终使用 `Task<T>` 类进行这些操作是一个好主意。否则，你可能会无意中在用户界面线程上运行一个漫长的任务，这将阻止在操作期间用户输入。`Task`
    对于网络请求绝对是必需的，因为用户可能在 iOS 和 Android 上使用蜂窝互联网连接，它将使我们能够将来使用 `async` 和 `await` 关键字。
- en: 'Now let''s implement a fake service that implements this interface. Place classes
    such as `FakeWebService` in the `Fakes` folder of the project. Let''s start with
    the class declaration and the first method of the interface:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个实现此接口的模拟服务。将 `FakeWebService` 类等放在项目的 `Fakes` 文件夹中。让我们从类声明和接口的第一个方法开始：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We started off with a `SleepDuration` property to store a number in milliseconds.
    This is used to simulate an interaction with a web server, which can take some
    time. It is also useful for changing the `SleepDuration` value in different situations.
    For example, you might want to set this to a small number when writing unit tests
    so that the tests execute quickly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初使用了一个 `SleepDuration` 属性来存储一个以毫秒为单位的数字。这用于模拟与网络服务交互，这可能需要一些时间。它也有助于在不同情况下更改
    `SleepDuration` 的值。例如，你可能希望在编写单元测试时将其设置为较小的数字，以便测试可以快速执行。
- en: Next, we implemented a simple `Sleep` method to return a task that introduces
    a delay of a number of milliseconds. This method will be used throughout the fake
    service to cause a delay on each operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了一个简单的 `Sleep` 方法，该方法返回一个任务，引入了若干毫秒的延迟。这个方法将在整个模拟服务中用于在每个操作上引入延迟。
- en: Finally, the `Login` method merely used an `await` call on the `Sleep` method
    and returned a `new User` object with the appropriate `Username`. For now, any
    username or password combination will work; however, you might wish to write some
    code here to check specific credentials.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Login` 方法仅仅是在 `Sleep` 方法上使用了一个 `await` 调用，并返回了一个带有适当 `Username` 的 `new User`
    对象。目前，任何用户名或密码组合都将有效；然而，你可能希望在这里编写一些代码来检查特定的凭据。
- en: 'Now, let''s implement a few more methods to continue our `FakeWebService` class
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一些更多的方法，以继续我们的 `FakeWebService` 类，如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each of these methods, we used exactly the same pattern as the `Login` method.
    Each method will delay and return some sample data. Feel free to mix the data
    with your own values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些方法中的每一个，我们都使用了与 `Login` 方法完全相同的模式。每个方法都会延迟并返回一些示例数据。请随意将数据与您自己的值混合。
- en: 'Now, let''s implement the `GetConversations` method required by the interface
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实现接口所需的 `GetConversations` 方法：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Basically, we just create a new array of the `Conversation` objects with arbitrary
    IDs. We also make sure to match up the `UserId` values with the IDs we have used
    on the `User` objects so far.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只是创建了一个新的 `Conversation` 对象数组，具有任意 ID。我们还确保将 `UserId` 值与迄今为止在 `User` 对象上使用的
    ID 匹配。
- en: 'Next, let''s implement `GetMessages` to retrieve a list of messages as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现 `GetMessages` 以获取消息列表，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, we are adding some arbitrary data here, and mainly making sure that
    `UserId` and `ConversationId` match our existing data so far.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在这里添加了一些任意数据，并主要确保 `UserId` 和 `ConversationId` 与我们迄今为止现有的数据匹配。
- en: 'And finally, we will write one more method to send a message, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写一个发送消息的方法，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most of these methods are very straightforward. Note that the service doesn't
    have to work perfectly; it should merely complete each operation successfully
    with a delay. Each method should also return test data of some kind to be displayed
    in the UI. This will give us the ability to implement our iOS and Android applications
    while filling in the web service later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的大多数都非常直接。请注意，服务不必完美工作；它只需在延迟后成功完成每个操作即可。每个方法还应该返回某种测试数据，以便在 UI 中显示。这将使我们能够在填充
    Web 服务的同时实现我们的 iOS 和 Android 应用程序。
- en: 'Next, we need to implement a simple interface for persisting application settings.
    Let''s define an interface named `ISettings` as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现一个用于持久化应用程序设置的简单接口。让我们定义一个名为 `ISettings` 的接口，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are making `ISettings` synchronous, but you might want to set up the `Save`
    method to be asynchronous and return `Task` if you plan on storing settings in
    the cloud. We don't really need this with our application since we will only be
    saving our settings locally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ISettings` 设置为同步的，但如果你计划在云中存储设置，你可能希望将 `Save` 方法设置为异步并返回 `Task`。对于我们的应用程序，我们并不真正需要这样做，因为我们只会将设置保存在本地。
- en: 'Later on, we''ll implement this interface on each platform using Android and
    iOS APIs. For now, let''s just implement a fake version that will be used later
    when we write unit tests. We will implement the interface with the following lines
    of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用 Android 和 iOS API 在每个平台上实现这个接口。现在，让我们只实现一个将用于稍后编写单元测试的假版本。我们将使用以下代码行实现接口：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the fake version doesn't actually need to do anything; we just need
    to provide a class that will implement the interface and not throw any unexpected
    errors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，假版本实际上不需要做任何事情；我们只需要提供一个实现接口并不会抛出任何意外错误的类。
- en: 'This completes the Model layer of the application. Here is a final class diagram
    of what we have implemented so far:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了应用程序的模型层。以下是到目前为止我们已实现的最终类图：
- en: '![Writing a mock web service](img/00028.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![编写模拟的 Web 服务](img/00028.jpeg)'
- en: Writing the ViewModel layer
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 ViewModel 层
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `BaseViewModel` class is a great place to place any common functionality
    that you plan on reusing throughout your application. For this app, we only need
    to implement some functionality to indicate whether the ViewModel layer is busy.
    We provided a property and an event that the UI will be able to subscribe to and
    display a wait indicator on the screen. We also added some fields for the services
    that will be needed. Another common functionality that could be added would be
    validation for user inputs; however, we don't really need it for this application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseViewModel` 类是一个放置任何计划在整个应用程序中重用的公共功能的好地方。对于这个应用程序，我们只需要实现一些功能来指示 ViewModel
    层是否忙碌。我们提供了一个属性和一个事件，UI 将能够订阅并在屏幕上显示等待指示器。我们还添加了一些需要的服务字段。还可以添加的一个常见功能是对用户输入进行验证；然而，对于这个应用程序，我们并不真正需要它。'
- en: Implementing our LoginViewModel class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的 LoginViewModel 类
- en: Now that we have a base class for all of the ViewModel layers, we can implement
    a ViewModel layer for the first screen in our application, the **Login** screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为所有 ViewModel 层创建了一个基类，我们可以为我们的应用程序中的第一个屏幕实现一个 ViewModel 层，即 **登录** 屏幕。
- en: 'Now let''s implement a `LoginViewModel` class as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实现 `LoginViewModel` 类：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this class, we implemented the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们实现了以下内容：
- en: We subclassed `BaseViewModel` to get access to `IsBusy` and the fields that
    contain common services
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`BaseViewModel`派生类以获取访问`IsBusy`和包含常见服务的字段
- en: We added the `Username` and `Password` properties to be set by the View layer
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`Username`和`Password`属性，由视图层进行设置
- en: We added a `User` property to be set when the login process is completed
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`User`属性，当登录过程完成时进行设置
- en: We implemented a `Login` method to be called from View, with validation on the
    `Username` and `Password` properties
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了一个`Login`方法，可以从视图调用，并在`Username`和`Password`属性上进行验证
- en: We set `IsBusy` during the call to the `Login` method on `IWebService`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`IWebService`上的`Login`方法时，我们设置了`IsBusy`
- en: We set the `User` property by awaiting the result from `Login` on the web service
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过等待来自网络服务中`Login`操作的`User`属性结果来设置`User`属性
- en: Basically, this is the pattern that we'll follow for the rest of the ViewModel
    layers in the application. We provide properties for the View layer to be set
    by the user's input, and methods to call for various operations. If it is a method
    that could take some time, such as a web request, you should always return `Task`
    and use the `async` and `await` keywords.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是我们将在应用程序中其余的ViewModel层中遵循的模式。我们提供属性供视图层根据用户输入进行设置，并提供用于各种操作的方法。如果是一个可能需要一些时间的方法，例如网络请求，你应该始终返回`Task`并使用`async`和`await`关键字。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we used `try` and `finally` blocks for setting `IsBusy` back to `false`.
    This will ensure that it gets reset properly even when an exception is thrown.
    We plan on handling the error in the View layer so that we can display a native
    pop up to the user displaying a message.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`try`和`finally`块来将`IsBusy`重置为`false`。这将确保即使在抛出异常的情况下也能正确重置。我们计划在视图层处理错误，以便向用户显示一个包含消息的原生弹出窗口。
- en: Implementing our RegisterViewModel class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的`RegisterViewModel`类
- en: Since we have finished writing our `ViewModel` class to log in, we will now
    need to create one for the user's registration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了我们的`ViewModel`类以进行登录，我们现在需要创建一个用于用户注册的类。
- en: 'Let''s implement another ViewModel layer to register a new user:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现另一个ViewModel层来注册新用户：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These properties will handle inputs from the user. Next, we need to add a `Register`
    method as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将处理来自用户的输入。接下来，我们需要添加一个`Register`方法，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `RegisterViewModel` class is very similar to the `LoginViewModel` class,
    but has an additional `ConfirmPassword` property for the UI to be set. A good
    rule to follow for when to split the ViewModel layer's functionality is to always
    create a new class when the UI has a new screen. This helps you keep your code
    clean and somewhat follow the **Single Responsibility Principal (SRP)** for your
    classes. The **SRP** states that a class should only have a single purpose or
    responsibility. We'll try to follow this concept to keep our classes small and
    organized, which can be more important than usual when sharing code across platforms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterViewModel`类与`LoginViewModel`类非常相似，但额外有一个用于UI设置的`ConfirmPassword`属性。遵循ViewModel层功能分割的良好规则是，当UI有新屏幕时，始终创建一个新的类。这有助于你保持代码整洁，并在一定程度上遵循类的**单一职责原则（SRP**）。**SRP**指出，一个类应该只有一个目的或职责。我们将尝试遵循这个概念，以保持我们的类小巧且有序，这在跨平台共享代码时可能比通常更重要。'
- en: Implementing our FriendViewModel class
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的`FriendViewModel`类
- en: Next on the list is a ViewModel layer to work with a user's friend list. We
    will need a method to load a user's friend list and add a new friend.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是处理用户朋友列表的ViewModel层。我们需要一个方法来加载用户的朋友列表并添加一个新朋友。
- en: 'Now let''s implement the `FriendViewModel` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现`FriendViewModel`，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we''ll need a method to load friends. This method is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个方法来加载朋友。此方法如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we''ll need a method to add a new friend and then update the list
    of friends contained locally:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个方法来添加一个新朋友并更新本地包含的朋友列表：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, this class is fairly straightforward. The only thing new here is that
    we added some logic to update the list of friends and sort them within our client
    application and not the server. You can also choose to reload the complete list
    of friends if you have a good reason to do so.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个类相当直接。唯一的新增内容是我们添加了一些逻辑来更新朋友列表并在我们的客户端应用程序中对其进行排序，而不是在服务器上。你也可以选择在有充分理由的情况下重新加载朋友列表的完整列表。
- en: Implementing our MessageViewModel class
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的`MessageViewModel`类
- en: Our final required ViewModel layer will handle messages and conversations. We
    need to create a way to load conversations and messages and send a new message.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要的ViewModel层将处理消息和对话。我们需要创建一种加载对话和消息以及发送新消息的方法。
- en: 'Let''s start implementing our `MessageViewModel` class as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始实现我们的`MessageViewModel`类：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let''s implement a method to retrieve a list of conversations as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个方法来检索对话列表，如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, we need to retrieve a list of messages within a conversation. We
    will need to pass the conversation ID to the service as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还需要在对话中检索消息列表。我们需要将对话ID传递给服务，如下所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we need to write some code to send a message and update the local
    list of messages as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一些代码来发送消息并更新本地消息列表，如下所示：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This concludes the ViewModel layer of our application and the entirety of the
    shared code used on iOS and Android. For the `MessageViewModel` class, you could
    have also chosen to put the `GetConversations` and `Conversations` properties
    in their own class, since they can be considered as a separate responsibility,
    but it is not really necessary.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们应用程序的ViewModel层以及iOS和Android上使用的所有共享代码。对于`MessageViewModel`类，你也可以选择将`GetConversations`和`Conversations`属性放在它们自己的类中，因为它们可以被视为一个单独的责任，但这并不是真的必要。
- en: 'Here is the final class diagram of our ViewModel layer:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的ViewModel层的最终类图：
- en: '![Implementing our MessageViewModel class](img/00029.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的MessageViewModel类](img/00029.jpeg)'
- en: Writing unit tests
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Since all the code we've written so far is not dependent on the user interface,
    we can easily write unit tests against our classes. This step is generally taken
    after the first implementation of a `ViewModel` class. Proponents of **Test Driven
    Development** (**TDD**) would recommend writing tests first and implementing things
    afterward, so choose which method is best for you. In either case, it is a good
    idea to write tests against your shared code before you start using them from
    the View layer, so that you can catch bugs before they hold up your development
    on the UI.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们迄今为止编写的所有代码都不依赖于用户界面，我们可以轻松地为我们的类编写单元测试。这一步骤通常在`ViewModel`类的首次实现之后进行。**测试驱动开发**（**TDD**）的支持者会建议先编写测试，然后再实现功能，所以选择最适合你的方法。在任何情况下，在从视图层使用之前编写针对共享代码的测试都是一个好主意，这样你就可以在它们阻碍你的UI开发之前捕捉到错误。
- en: Xamarin projects take advantage of an open source testing framework called **NUnit**.
    It was originally derived from a Java testing framework called **JUnit**, and
    it is the de-facto standard for unit testing C# applications. Xamarin Studio provides
    several project templates for writing tests with **NUnit**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin项目利用一个名为**NUnit**的开源测试框架。它最初是从一个名为**JUnit**的Java测试框架派生出来的，并且是C#应用程序单元测试的事实标准。Xamarin
    Studio提供了几个用于编写NUnit测试的项目模板。
- en: Setting up a new project for unit tests
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置单元测试的新项目
- en: 'Let''s set up a new project for unit tests by performing the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤设置一个新的单元测试项目：
- en: Add a new **NUnit Library** **Project** to your solution, which is found under
    the **C#** section.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案中添加一个新的**NUnit库**项目，该项目位于**C#**部分。
- en: Name the project `XamChat.Tests` to keep things consistent.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`XamChat.Tests`以保持一致性。
- en: Next, let's set the library to a Mono/.NET 4.5 project under **Project Options**,
    then navigate to **Build** | **General** | **Target Framework**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在**项目选项**下将库设置为Mono/.NET 4.5项目，然后导航到**构建** | **常规** | **目标框架**。
- en: Right-click on **Project References** and choose **Edit References**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**项目引用**并选择**编辑引用**。
- en: Under the **Projects** tab, add a reference to **XamChat.Core**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**选项卡下，添加对**XamChat.Core**的引用。
- en: 'Now, open the `Test.cs` file and you will notice the following required attributes
    that make up a unit test using NUnit:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`Test.cs`文件，你会注意到以下必需的属性，它们构成了使用NUnit的单元测试：
- en: '`using NUnit.Framework`: This attribute is the main statement to be used to
    work with NUnit'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using NUnit.Framework`: 这个属性是用于与NUnit一起使用的主要语句'
- en: '`[TestFixture]`: This decorates a class to indicate that the class has a list
    of methods for running tests'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[测试用例]`: 这个装饰器用于表示一个类包含运行测试的方法列表'
- en: '`[Test]`: This decorates a method to indicate a test'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[测试]`: 这个装饰器用于表示一个测试方法'
- en: 'In addition to the required C# attributes, there are several others that are
    useful for writing tests, and they are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必需的C#属性之外，还有一些其他属性对于编写测试很有用，如下所示：
- en: '`[TestFixtureSetUp]`: This decorates a method that runs before all the tests
    contained within a text fixture class.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TestFixtureSetUp]`: 这装饰了一个在测试固定类中所有测试之前运行的方法。'
- en: '`[SetUp]`: This decorates a method that runs before each test in a test fixture
    class.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[SetUp]`: 这装饰了一个在测试固定类中每个测试之前运行的方法。'
- en: '`[TearDown]`: This decorates a method that runs after each test in a test fixture
    class.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TearDown]`: 这装饰了一个在测试固定类中每个测试之后运行的方法。'
- en: '`[TestFixtureTearDown]`: This decorates a method that runs after all the tests
    in a text fixture class have been completed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TestFixtureTearDown]`: 这装饰了一个在测试固定类中所有测试完成后运行的方法。'
- en: '`[ExpectedException]`: This decorates a method that is intended to throw an
    exception. It is useful for test cases that are supposed to fail.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ExpectedException]`: 这装饰了一个旨在抛出异常的方法。对于应该失败的测试用例来说，它非常有用。'
- en: '`[Category]`: This decorates a test method and can be used to organize different
    tests; for example, you might categorize them as fast and slow tests.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Category]`: 这装饰了一个测试方法，可以用来组织不同的测试；例如，你可能将它们分类为快速测试和慢速测试。'
- en: Writing assertions
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写断言
- en: The next concept to learn about writing tests with NUnit is how to write **assertions**.
    An assertion is a method that will throw an exception if a certain value is not
    true. It will cause a test to fail and give a descriptive explanation as to what
    happened. NUnit has a couple of different sets of APIs for assertions; however,
    we will use the more readable and fluent versions of the APIs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用NUnit编写测试时，下一个要了解的概念是如何编写**断言**。断言是一个方法，如果某个值不正确，它将抛出一个异常。它将导致测试失败，并提供关于发生了什么的描述性解释。NUnit有几个不同的断言API集；然而，我们将使用更易读的流式API版本。
- en: 'The basic syntax of a fluent-style API is using the `Assert.That` method. The
    following example this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 流式API的基本语法是使用`Assert.That`方法。以下是一个例子：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Likewise, you can assert the opposite:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以断言相反的情况：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or any of the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者以下任何一个：
- en: '`Assert.That(myVariable, Is.GreaterThan(0));`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.That(myVariable, Is.GreaterThan(0));`'
- en: '`Assert.That(myBooleanVariable, Is.True);`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.That(myBooleanVariable, Is.True);`'
- en: '`Assert.That(myObject, Is.Not.Null);`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.That(myObject, Is.Not.Null);`'
- en: Feel free to explore the APIs. With code completion in Xamarin Studio, you should
    be able to discover useful static members or methods on the `Is` class to use
    within your tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随意探索API。在Xamarin Studio中的代码补全功能，你应该能够发现`Is`类中的有用静态成员或方法，以便在测试中使用。
- en: 'Before we begin writing specific tests for our application, let''s write a
    static class and method to create a global setup to be used throughout our tests.
    You can rewrite `Test.cs` as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为我们的应用程序编写特定测试之前，让我们编写一个静态类和方法来创建一个全局设置，以便在整个测试中使用。你可以将`Test.cs`重写如下：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We'll use this method throughout our tests to set up fake services in our Model
    layer. Additionally, this replaces the existing services so that our tests execute
    against new instances of these classes. This is a good practice in unit testing
    to guarantee that no old data is left behind from a previous test. Also, notice
    that we set `SleepDuration` to `0`. This will make our tests run very quickly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个测试中使用此方法来设置模型层中的模拟服务。此外，这还替换了现有的服务，以便我们的测试针对这些类的新实例执行。这是单元测试中的一个良好实践，以确保没有从之前的测试中留下旧数据。另外，请注意我们设置了`SleepDuration`为`0`。这将使我们的测试运行得非常快。
- en: 'We will begin by creating a `ViewModels` folder in our test project and adding
    a class named `LoginViewModelTests` as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的测试项目中创建一个`ViewModels`文件夹，并添加一个名为`LoginViewModelTests`的类，如下所示：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice our use of a `SetUp` method. We recreate the objects used in every test
    to make sure that no old data is left over from the previous test runs. Another
    point to note is that you must return a `Task` when using `async`/`await` in a
    test method. Otherwise, NUnit would not be able to know when a test completes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用`SetUp`方法。我们重新创建每个测试中使用的对象，以确保没有从之前的测试运行中留下旧数据。另一个需要注意的点是，在使用测试方法中的`async`/`await`时，你必须返回一个`Task`。否则，NUnit将无法知道何时测试完成。
- en: 'To run the test, use the NUnit menu found docked to the right of Xamarin Studio,
    by default. Go ahead and run the test using the **Run Test** button that has a
    gear icon. You will get a successful result similar to what is shown in the following
    screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请使用位于Xamarin Studio右侧的NUnit菜单，默认情况下。点击带有齿轮图标的**运行测试**按钮来运行测试。你将得到一个类似于以下截图的成功结果：
- en: '![Writing assertions](img/00030.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![编写断言](img/00030.jpeg)'
- en: 'You can also view the **Test Results** pane, which will show you the extended
    details if a test fails, as shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看**测试结果**面板，如果测试失败，它将显示扩展的详细信息，如下面的截图所示：
- en: '![Writing assertions](img/00031.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![编写断言](img/00031.jpeg)'
- en: 'To see what happens when a test fails, go ahead and modify your test to assert
    against an incorrect value as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看测试失败时会发生什么，请修改你的测试以断言一个错误值，如下所示：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will get a very descriptive error in the **Test Results** pane, as shown
    in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在**测试结果**面板中看到一个非常详细的错误，如下面的截图所示：
- en: '![Writing assertions](img/00032.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![编写断言](img/00032.jpeg)'
- en: 'Now let''s implement another test for the `LoginViewModel` class; let''s make
    sure that we get the appropriate outcome if the username and password fields are
    blank. The test is implemented as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现`LoginViewModel`类的另一个测试；确保如果用户名和密码字段为空时，我们得到适当的输出。测试的实现如下：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run the test as it is, we will get an exception and the test will fail.
    Since we expect an exception to occur, we can decorate the method to make the
    test pass only if an exception occurs as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照原样运行测试，将会抛出异常，测试将失败。由于我们预期会发生异常，我们可以装饰该方法，使得测试仅在发生异常时通过，如下所示：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that in our ViewModel, the Exception type is thrown if a field is blank.
    You can also change the type of expected exception in cases where it is a different
    exception type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的视图模型中，如果字段为空，将抛出异常类型。你还可以在期望的异常类型不同的情况下更改期望的异常类型。
- en: More tests are included with the sample code along with this book. It is recommended
    that you write tests against each public operation on each `ViewModel` class.
    Additionally, write tests for any validation or other important business logic.
    I would also recommend that you write tests against the Model layer; however,
    this is not needed in our project yet since we only have fake implementations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 样本代码以及本书中包含更多测试。建议你对每个`ViewModel`类上的每个公共操作编写测试。此外，为任何验证或其他重要业务逻辑编写测试。我还建议你对模型层编写测试；然而，在我们的项目中这还不是必需的，因为我们只有模拟实现。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the concept of building a sample application
    called XamChat. We also implemented the core business objects for the application
    in the Model layer. Since we do not have a server to support this application
    yet, we implemented a fake web service. This gives you the flexibility to move
    forward with the app without building a server application. We also implemented
    the ViewModel layer. This layer will expose operations in a simple way to the
    View layer. Finally, we wrote tests covering the code we've written so far using
    NUnit. Writing tests against shared code in a cross-platform application can be
    very important, as it is the backbone of more than one application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了构建一个名为XamChat的示例应用程序的概念。我们还实现了应用程序在模型层中的核心业务对象。由于我们还没有服务器来支持这个应用程序，我们实现了一个模拟的Web服务。这让你在不需要构建服务器应用程序的情况下继续前进有了灵活性。我们还实现了视图模型层。这一层将以简单的方式向视图层公开操作。最后，我们使用NUnit编写了覆盖我们迄今为止所编写代码的测试。在跨平台应用程序中对共享代码编写测试可能非常重要，因为它是多个应用程序的骨架。
- en: After completing this chapter, you should have completed the shared library
    for our cross-platform application in its entirety. You should have a very firm
    grasp on our application's architecture and its distinct Model and ViewModel layers.
    You should also have a good understanding of how to write fake versions of parts
    of your application that you might not be ready to implement yet. In the next
    chapter, we will implement the iOS version of XamChat.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你应该已经完成了我们跨平台应用程序的共享库的全部内容。你应该对我们的应用程序架构及其独特的模型和视图模型层有非常牢固的掌握。你还应该很好地理解如何编写你尚未准备好实现的某些应用程序部分的模拟版本。在下一章中，我们将实现XamChat的iOS版本。
