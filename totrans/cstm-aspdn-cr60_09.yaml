- en: '*Chapter 9*: Working with Endpoint Routing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the new endpoint routing in **ASP.NET**
    **Core**. We will learn what endpoint routing is, how it works, where it is used,
    and how you are able to create your own routes to your own endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring endpoint routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a more complex endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The topics in this chapter refer to the routing layer of the ASP.NET Core architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The ASP.NET Core architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B17996.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The ASP.NET Core architecture
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this series, we just need to set up a small, empty web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Open the application with Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at: [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring endpoint routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn about **endpoint routing**, you need to learn what an *endpoint* is
    and what *routing* is.
  prefs: []
  type: TYPE_NORMAL
- en: '**Endpoints** are part of an app that get executed when a route maps the incoming
    request to it. Let''s analyze this definition in a little more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: A client usually requests a resource from a server. In most cases, the client
    is a browser. The resource is defined by a URL, which points to a specific target.
    In most cases, the target is a web page. It could also be a mobile app that requests
    specific data from a JSON web API. What data the app requests is defined in the
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the incoming request is also defined by the URL. The executing
    endpoint, on the other hand, is mapped to a specific route. A route is a URL or
    a pattern for a URL. ASP.NET Core developers are already familiar with such a
    route pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the route or the route pattern matches the URL of the incoming request, the
    request gets mapped to that endpoint. In this case, the request gets mapped to
    the MVC endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core can map to the following endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Controllers (for example, MVC or web APIs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR (and Blazor Server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gRPC services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the endpoints have really simple route patterns. Only the MVC and web
    API endpoints use the more complex patterns. The route definitions of Razor pages
    are based on the folder and file structure of the actual pages.
  prefs: []
  type: TYPE_NORMAL
- en: Before endpoints were introduced in ASP.NET Core 2.2, routing was only a thing
    in MVC and web APIs. The implicit routing in **Razor Pages** was built-in there,
    and SignalR wasn't really ready. Blazor and gRPC weren't a thing back then, and
    the health checks were initially implemented as a middleware component.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint routing was introduced to separate routing from the actual endpoints.
    This makes the framework much more flexible, and it means that new endpoints don't
    need to implement their own kind of routing. This way, the endpoints can use the
    existing flexible routing technology to get mapped to a specific route.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how you can create your own custom endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to create an endpoint is by using the lambda-based endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This maps the `/map` route to a simple endpoint that writes the word `"OK"`
    to the response stream.
  prefs: []
  type: TYPE_NORMAL
- en: A Note regarding Prior .NET 6.0 Versions
  prefs: []
  type: TYPE_NORMAL
- en: Prior to .NET 6.0, you would map custom endpoints on the `endpoints` object
    inside the lambda that gets passed to the `UseEndpoints` method in the `Startup.cs`
    file. With .NET 6.0 and the new `app` object in the `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: You might need to add the `Microsoft.AspNetCore.Http` namespace to the `using`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also map specific HTTP methods (such as `GET`, `POST`, `PUT`, and `DELETE`)
    to an endpoint. The following code shows how to map the `GET` and `POST` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also map two or more HTTP methods to an endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These endpoints look like the lambda-based terminating middleware components
    that we saw in [*Chapter 8*](B17996_08_ePub.xhtml#_idTextAnchor124), *Writing
    Custom Middleware*. These are middleware components that terminate the pipeline
    and return a result, such as HTML-based views, JSON structured data, or similar.
    Endpoint routing is a more flexible way to create an output, and it should be
    used in all versions from ASP.NET Core 3.0 onward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B17996_08_ePub.xhtml#_idTextAnchor124), *Writing Custom Middleware*,
    we saw that we can branch pipelines like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This also creates a route, but this will only listen to URLs that start with
    `/map`. If you would prefer to have a routing engine that handles patterns such
    as `/map/{id:int?}` to also match `/map/456` and not `/map/abc`, you should use
    the new routing, as demonstrated earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Those lambda-based endpoints are useful for simple scenarios. However, because
    they are defined in `Program.cs`, things will quickly become messy if you start
    to implement more complex scenarios using this kind of lambda-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: So, we should try to find a more structured way to create custom endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a more complex endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a more complex endpoint, step by step. Let''s
    do this by writing a really simple health check endpoint, similar to what you
    might need if you were to run your application inside a **Kubernetes** cluster,
    or just to tell others about your health status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft advices starting with the definition of the API to add the endpoint
    from the developer''s point of view. We do the same here. This means that we will
    add a `MapSomething` method first, without an actual implementation. This will
    be an extension method on the `IEndpointRouteBuilder` object. We are going to
    call it `MapMyHealthChecks`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new endpoint should be added in the same way as the prebuilt endpoints,
    so as not to confuse the developer who needs to use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we know how the method should look, let's implement it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new static class called `MapMyHealthChecksExtensions` and place an
    extension method inside the `MapMyHealthChecks` object that extends `IEndpointRouteBuilder`
    and returns an `IEndpointConventionBuilder` object. I placed it in the `MapMyHealthChecksExtensions.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is just the skeleton. Let's start with the actual endpoint first before
    using it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The actual endpoint will be written as a *terminating* middleware component
    – that is, a middleware component that doesn''t call the next one (see [*Chapter
    8*](B17996_08_ePub.xhtml#_idTextAnchor124), *Writing Custom Middleware*) and creates
    an output to the response stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The actual work is done in the `Invoke` method. Currently, this doesn't really
    do more than respond with `OK` in plaintext and the `200` HTTP status, which is
    fine if you just want to show that your application is running. Feel free to extend
    the method with actual checks, such as checking for the availability of a database
    or related services, for example. Then, you would need to change the HTTP status
    and the output related to the result of your checks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's use this terminating middleware.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s go back to the skeleton of the `MapMyHealthChecks` method. We now need
    to create our own pipeline, which we map to a given route. Place the following
    lines in that method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach allows you to add some more middleware just for this new pipeline.
    The `WithDisplayName` extension method sets the configured display name to the
    endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it! Press *F5* in your IDE to start the application and call `https://localhost:7111/myhealth`
    in your browser. You should see **OK** in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A screenshot of the endpoint routing output](img/Figure_9.2_B17996.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – A screenshot of the endpoint routing output
  prefs: []
  type: TYPE_NORMAL
- en: Please note the port number might vary. You can also convert an already existing
    terminating middleware component to a routed endpoint to benefit from much more
    flexible routing. And that's it for this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core knows many ways in which to work with a request and to provide
    information to the requesting client. Endpoint routing is a way to provide resources
    based on the requested URL and the requested method.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use a terminating middleware component as
    an endpoint that gets mapped to the new routing engine to be more flexible, matching
    the routes by which you want to serve the information to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: Every web application needs to know its users to allow or restrict access to
    specific areas of the application or to specific data. In the next chapter, we
    show how to configure authentication to recognize your users.
  prefs: []
  type: TYPE_NORMAL
