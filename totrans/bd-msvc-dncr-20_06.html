<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing Microservices</h1>
                
            
            
                
<p>Security is one of the most important cross-cutting concerns for web applications. Unfortunately, data breaches of well-known sites seem commonplace these days. Taking this into account, information and application security has become critical to web applications. For the same reason, secure applications should no longer be an afterthought. Security is everyone's responsibility in an organization.</p>
<p>Monolithic applications have less surface area when compared to microservices, however, microservices are distributed systems by nature. Also, in principle, microservices are isolated from each other; hence, well-implemented microservices are more secure as compared to monolithic applications. A monolith has different attack vectors compared to microservices. The microservice architecture style forces us to think differently in the context of security. However, let me tell you upfront, microservice security is a complex domain to understand and implement.</p>
<p>Before we dive deep into microservice security, let's understand our approach toward it. We will be focusing more on how authentication and authorization (collectively referred to as <strong>auth</strong> in the chapter henceforth) work and the options available within the .NET ecosystem.</p>
<p>We will explore Azure API management and its suitability as an API gateway for .NET-based microservice environments; we'll also see how Azure API management can help us protect microservices through its security features. Then, we'll briefly touch base with different, peripheral aspects that have <em>defense in depth</em> mechanisms for microservice security. We will also discuss the following topics:</p>
<ul>
<li>Why are form authentication and older techniques not sufficient?</li>
<li>Authentication and the available options, including OpenID and Azure Active Directory</li>
<li>Introducing OAuth 2.0</li>
<li>Introducing Azure API management as an API gateway</li>
<li>Using Azure API management for security</li>
<li>Interservice communication security approaches</li>
<li>Container security and other peripheral security aspects</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Security in monolithic applications</h1>
                
            
            
                
<p>To understand microservice security, let's step back and recall how we used to secure .NET monolithic applications. This will help us better grasp why a microservice's auth mechanism needs to be different.</p>
<p>The critical mechanism to secure applications has always been auth. Authentication verifies the <em>identity</em> of a user. Authorization manages what a user can or cannot access, also known as <em>permissions</em>. Encryption, well, that's the mechanism that helps you protect data as it passes between the client and server. We're not going to discuss encryption too much though, just ensure the data that goes over the wire is encrypted everywhere. This can be achieved through the use of the HTTPS protocol.</p>
<p>The following diagram depicts the flow of a typical auth mechanism in .NET monoliths:</p>
<div><img class="image-border" height="294" src="img/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png" width="527"/></div>
<p>In the preceding diagram, we can see that the user enters his or her username and password typically through a web browser. Then, this request hits some thin layer in a web application that is responsible for auth. This layer or component connects to the user credential store, typically an SQL server in the case of a .NET application. The auth layer verifies user-supplied credentials against the username and password stored in the credential store.</p>
<p>Once the user credentials are verified for the session, a session cookie gets created in the browser. Unless the user has a valid session cookie, he cannot access the app. Typically, a session cookie is sent with every request. Within these kinds of monolithic applications, modules can freely interact with each other since they are in the same process and have in-memory access. This means trust is implicit within those application modules so they do not need separate validation and verification of requests while talking to each other.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Security in microservices</h1>
                
            
            
                
<p>Now let's look at the case of microservices. By nature, microservices are distributed systems. There is not a single instance of an application; rather, there are several distinct applications that coordinate with each other in harmony to produce the desired output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why won't a traditional .NET auth mechanism work?</h1>
                
            
            
                
<p>One of the possible approaches for microservice security might be this: we mimic the same behavior as that of the auth layer in a monolith. This could be depicted as follows:</p>
<div><img class="image-border" height="233" src="img/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png" width="575"/></div>
<p>In this approach, we distributed the auth layer and provided it to all the microservices. Since each one is a different application, it will need its own auth mechanism. This inherently means that the user credential store is also different for every microservice. This raises so many questions, such as how do we keep the auth in sync across all services? How can we validate inter-service communication, or do we skip it? We do not have satisfactory answers to these questions. Hence, this approach does not make sense and just increases complexity. With this approach, we cannot even be sure whether it will work in the real world.</p>
<p>There is one more factor we need to take into account for modern applications. In the microservice world, we need to support native mobile apps and other non-standard form factor devices as well as IoT applications. With the significant proliferation of native mobile applications, the microservice architecture also needs to support secure communication between those clients and microservices. This is different from the traditional web browser-based user interface. On mobile platforms, a web browser is not part of any native mobile app. This means cookie-based or session-based authentication is not possible. So microservices need to support this kind of interoperability between client applications. This was never a concern for .NET monolithic applications.</p>
<p>In the case of traditional authentication, the browser is responsible for sending the cookie upon each request. But we're not using the browser for a native mobile app. In fact, we're neither using ASPX pages, nor the form's authentication module. For an iOS client or Android, it's something different altogether. What's more, we are also trying to restrict unauthorized access to our API. In the preceding example, we'd be securing the client, be it an MVC app or a Windows phone app, and not the microservice. Moreover, all these mobile client devices are not part of the trust subsystem. For every request, we cannot trust that the mobile user is indeed the owner; the communication channel is not secured either. So any request coming from them cannot be trusted at all.</p>
<p>But apart from these problems, there's another more conceptual problem we have. Why should the application be responsible for authenticating users and authorization? Shouldn't this be separated out?</p>
<p>One more solution to this is using the SAML protocol, but again, this is based on SOAP and XML, so not really a good fit for microservices. The complexity of the implementation of SAML is also high.</p>
<p>Therefore, it is evident from the preceding discussion that we need a token-based solution. The solution for microservices' auth comes in the form of OpenID Connect and OAuth 2.0. OpenID Connect is the standard for authentication and OAuth 2.0 is the specification for the authorization. However, this authorization is delegated by nature.</p>
<p>We will see this in detail in further sections. But before that, let's take a detour and look at JSON Web Tokens and see why they are significant with respect to microservice security.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JSON Web Tokens</h1>
                
            
            
                
<p><strong>JSON Web Tokens</strong> (<strong>JWT</strong>) is pronounced <em>JOT</em>. It is a well-defined JSON schema or format to describe the tokens involved in a data exchange process. JWTs are described in <em>RFC 7519</em>.</p>
<p>JWTs are not tied to either OpenID Connect or OAuth 2.0. This means they can be used independently, irrespective of OAuth 2.0 or OpenID Connect. OpenID Connect mandates the use of a JWT for all the tokens that are exchanged in the process. In OAuth 2.0, the use of JWTs isn't mandated, more a kind of implementation format. Moreover, the .NET framework has built-in support for JWT.</p>
<p>The purpose of a JWT-based security token is to produce a data structure that contains information about the issuer and the recipient along with a description of the sender's identity. Therefore, tokens should be protected over the wire so they cannot be tampered with. To do so, tokens are signed with symmetric or asymmetric keys. This means when a receiver trusts the issuer of the token, it can also trust the information inside it.</p>
<p>Here is an example of a JWT:</p>
<div><div><div><div><div><div><div><div><pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</pre></div>
</div>
</div>
</div>
</div>
</div>
<p>This is the encoded form of a JWT. If we see the same token in decoded form, it has three components: header, payload, and signature; they are all separated by a period (.). The preceding example token can be decoded as follows:</p>
</div>
</div>
<pre><strong>Header</strong>: {"alg": "HS256", "type": "JWT"}<br/><strong>Payload</strong>: {"sub": "1234567890","name": "John Doe","admin": true}<br/><strong>Signature</strong>:HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)</pre>
<p>NET v.4.5.1 and onward has built-in support for generating and consuming JWTs. You can install JWT support in any .NET application using the package manager console with the following command:</p>
<pre><strong>Install-Package System.IdentityModel.Tokens.Jwt</strong></pre>
<p>Visit <a href="https://jwt.io/">https://jwt.io/</a>, where you can view and decode JWTs very easily. Moreover, you can add it as part of the Chrome debugger as well, which is quite handy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is OAuth 2.0?</h1>
                
            
            
                
<p>Okay, you might not know what OAuth 2.0 is, but you will have surely used it for several websites. Nowadays, many websites allow you to log in with your username and password for Facebook, Twitter, or Google accounts. Go to your favorite website, for example, the <a href="http://www.stackoverflow.com">www.stackoverflow.com</a> login page. There is a login button that says you can sign in with your Google account, for example. When you click on the Google button, it takes you to Google's login page along with some of the permissions mentioned. Here you provide your Google username and password and click on the Allow button to grant permissions to your favorite site. Then, Google redirects you to Stack Overflow and you are logged in with appropriate permissions in Stack Overflow. This is merely the end user experience for OAuth 2.0 and OpenID Connect.</p>
<p>OAuth 2.0 can be best described as a series of specification-turned-authorization frameworks. <em>RFC 6749</em> defines OAuth as follows:</p>
<p>"The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf."</p>
<p>OAuth 2.0 handles authorization on the web, in native mobile applications, and all headless server applications (these are nothing more than microservice instances in our context). You must be wondering why we are discussing authorization first instead of authentication. The reason is that OAuth 2.0 is a delegated authorization framework. This means, to complete the authorization flow, it relies on an authentication mechanism.</p>
<p>Now let's see some terminology associated with it.</p>
<p>OAuth 2.0 roles describe the involved parties in the authorization process:</p>
<ul>
<li>Resource: The entity that is getting protected from unintended access and usage. This is nothing more than a microservice in our case.</li>
<li>Resource owner: Resource owner is a person or entity who owns the specified resource. When a person owns a resource, he or she is an end user.</li>
<li>Client: Client is the term used to refer to all kinds of client applications. This refers to any application trying to access the protected resource. In a microservices' context, the applications involved are single page applications, web user interface clients, and native mobile applications, or even a microservice that is trying to access another microservice downstream.</li>
<li>Authorization server: This is the server that hosts the secure token service and issues tokens to the client after successfully authenticating the resource owner and obtaining permissions from the resource owner or on their behalf.</li>
</ul>
<ol start="4"/>
<p>You may have noticed that OAuth does differentiate between end users and applications used by an end user. This is a bit odd but makes perfect sense since it is also generally viewed as saying, <em>I am authorizing this app to perform these actions on my behalf</em>.</p>
<p>The following diagram depicts how these roles interact with each other in the general flow of authorization in the OAuth framework:</p>
<div><img height="442" src="img/e58404a3-3107-4236-ba49-b9e8dda72c70.png" width="591"/></div>
<p>In <em>step 6</em>, illustrated in the preceding diagram, the client passes the authorization grant to the authorization server. This step is not as simple as it looks. Authorization grants are of different types. The grant types represent four, different possible use cases for getting access tokens in OAuth 2.0. If you choose the wrong grant type, you might be compromising security:</p>
<ul>
<li>Authorization code: This is the typical OAuth grant used by server-side web applications, the one you would use in your ASP.NET apps.</li>
<li>Implicit: Authenticating with a server returns an access token to the browser, which can then be used to access resources. This is useful for single page applications where communication cannot be private.</li>
<li>Resource owner password credentials: This requires the user to directly enter their username and password in the application. It is useful when you are developing a first-party application to authenticate with your own servers. For example, a mobile app might use a resource owner grant to authenticate with your own servers.</li>
<li>Client credentials: This is typically used when the client is acting on its own behalf (the client is also the resource owner) or is requesting access to protected resources based on an authorization previously arranged with the authorization server.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is OpenID Connect?</h1>
                
            
            
                
<p>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. OpenID Connect is all about authentication. It allows clients to verify end users based on the authentication performed by an authorization server. It is also used to obtain basic profile information about the end user in an interoperable and REST-like manner.</p>
<p>So OpenID Connect allows clients of all types—web-based, mobile, and JavaScript—to request and receive information about authenticated sessions and end users. We know that OAuth 2.0 defines access tokens. Well, OpenID Connect defines a standardized identity token (commonly referred to as <strong>ID token</strong>). The identity token is sent to the application so the application can validate who the user is. It defines an endpoint to get identity information for that user, such as their name or email address. That's the user info endpoint.</p>
<p>It's built on top of OAuth 2.0, so the flows are the same. It can be used with the authorization code grant and implicit grant. It's not possible with the client credentials grant, as the client credentials grant is for server-to-server communication.</p>
<p>There's no end user involved in the process so there's no end user identity either. Likewise, it doesn't make sense for the resource owner path of usage or process. Now how does that work? Well, instead of only requesting an access token, we'll request an additional ID token from the <strong>security token service</strong> (<strong>STS</strong>) that implements the OpenID Connect specification. The client receives an ID token, and usually, also an access token. To get more information for the authenticated user, the client can then send a request to the user info endpoint with the access token; this user info endpoint will then return the claims about the new user.</p>
<p>OpenID supports authorization code flow and implicit flow. It also adds some more additional protocols, which are discovery and dynamic registration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Azure Active Directory</h1>
                
            
            
                
<p>There are multiple providers for OAuth 2.0 and OpenID Connect 1.0 specifications. <strong>Azure Active Directory</strong> (<strong>Azure AD</strong>) is one of them. Azure AD provides organizations with enterprise-grade identity management for cloud applications. Azure AD integration will give your users a streamlined sign-in experience, and it will help your application conform to the IT policy. Azure AD provides advanced security features, such as multifactor authentication, and scales really well with application growth. It is used in all Microsoft Azure Cloud products, including Office 365, and processes more than a billion sign-ins per day.</p>
<p>One more interesting aspect of traditional .NET environments is that they can integrate their organizational Windows Server Active Directory with Azure AD really well. This can be done with the Azure AD sync tool or the new capability of pass-through authentication. So, organizational IT compliances will still be managed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Microservice Auth example with OpenID Connect, OAuth 2.0, and Azure AD</h1>
                
            
            
                
<p>Now we are well-equipped with all the prerequisite knowledge to start coding. Let's try and build a <kbd>ToDoList</kbd> application. We are going to secure <kbd>TodoListService</kbd>, which represents one of our microservices. In the solution, the <kbd>ToDoList</kbd> microservice is represented by the <kbd>TodoListService</kbd> project and <kbd>ToDoListWebApp</kbd> represents the server-side web application. It will be easier to follow if you open up the Visual Studio solution named <kbd>OpenIdOAuthAzureAD.sln</kbd> provided with this chapter. This example uses the client credentials grant.</p>
<p>Note that, due to the ever-changing nature of Azure portal and the corresponding Azure services UI, it is advisable that you use the Azure Service management API and automate some of the registration tasks about to follow. However, for learning purposes and largely for encouraging developers who are new to Azure or might be trying Azure AD for the first time, we are going to follow the Azure portal user interface.</p>
<p>Here are the prerequisites:</p>
<ul class="ol-list">
<li>Visual Studio 2017 Update 3</li>
<li>An Azure subscription (if you don't have this, you can use the free trial account for this demo)</li>
<li>Azure AD tenant (single-tenant): You can also work with your Azure account's own default directory, which should be different from that of the Microsoft organization</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Registration of TodoListService and TodoListWebApp with Azure AD tenant</h1>
                
            
            
                
<p>Now let's look at how to register <kbd>TodoListService</kbd>.</p>
<p>In this step, we will add <kbd>TodoListService</kbd> with Azure AD tenant. To achieve this, log in to the Azure management portal, then do the following:</p>
<ol>
<li>Click on App registrations. Click on the Add button. It will open the Create pane, as depicted here:</li>
</ol>
<div><img src="img/64a8579c-88d4-4915-ba87-4fa8380a541c.png"/></div>
<ol start="2">
<li>Provide all the mandatory details as displayed in the preceding screenshot and click on the Create button at the bottom of the Create pane. While we are providing a sign-on URL, make sure that you are providing it for your app. In our case, <kbd>TodoListService</kbd> is a microservice, so we won't have a special sign-in URL. Hence, we have to provide the default URL or just the hostname of our microservice. Here we are going to run the service from our machine, so the localhost URL will be sufficient. You can find the sign-in URL once you right-click on project URL under <kbd>TodoListService</kbd> project and navigate to Web, as shown in the following diagram:</li>
</ol>
<div><img height="245" src="img/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png" width="418"/></div>
<p>A sign-in URL in Azure portal should have the trailing <kbd>/</kbd>; otherwise, you may face an error, even if you execute all the steps correctly.</p>
<ol start="3">
<li>If you deploy your service with the Microsoft Azure App Service plan, you will get a URL that is similar to <kbd>https://todolistservice-xyz.azurewebsites.net/</kbd>. You can later change the sign-on URL if you deploy the service on Azure.</li>
<li>Once you click on the Create button, Azure will add the application to your Azure AD Tenant. However, there are still a few more details that need to be completed for finishing the registration of TodoListService. So navigate to App Registration | TodoListService | Properties. You will notice that there are a few more additional properties, such as App ID URL, which has been provided now.</li>
</ol>
<ol start="5">
<li>For the App ID URL, enter <a href="https://%5BYour_Tenant_Name%5D/TodoListService"><kbd>https://[Your_Tenant_Name]/TodoListService</kbd></a>, replacing <kbd>[Your_Tenant_Name]</kbd> with the name of your Azure AD tenant. Click on OK to complete the registration. The final configuration should look like this: </li>
</ol>
<div><img class="image-border" src="img/084b7590-c707-4eb9-a75c-898ae12cf8b9.png"/></div>
<p>Now we move on to the registration of TodoListWebApp:</p>
<ol start="1">
<li>First, we register TodoListWebApp. This is necessary since we are going to use OpenID Connect to connect to this browser-based web application. So we need to establish the trust between the end user, that is, us and TodoListWebApp.</li>
<li>Click on App registrations. Click on the Add button. It will open up the Create pane, as depicted in the following screenshot. Fill in the sign-in URL as <kbd>https://localhost:44322/</kbd>.</li>
</ol>
<p> </p>
<ol start="3">
<li>Once again, as in the TodoListService  registration, we will be able to view most of the additional properties once we create the web app. So, the final properties configuration will look like this:</li>
</ol>
<div><img class="image-border" height="518" src="img/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png" width="730"/></div>
<ol start="4">
<li>A setting to note here is the logout URL: we set it as <kbd>https://localhost:44322/Account/EndSession</kbd>.<br/>
This is because after ending the session, Azure AD will redirect the user to this URL. For the App ID URL, enter <kbd>https://[Your_AD_Tenant_Name]/TodoListWebApp</kbd>, replacing [<kbd>Your_AD_Tenant_Name</kbd>] with the name of your Azure AD tenant. Click on OK to complete the registration. </li>
</ol>
<p> </p>
<ol start="5">
<li>Now we need to set up permissions between TodoListWebApp so that it can call our microservice: TodoListService. So, navigate to App Registration | TodoListWebApp | Required Permissions again and click on Add. Now click on 1 Select an API. This navigation is displayed in the following screenshot. You need to key in ToDoListService for it to show up in the API pane:</li>
</ol>
<div><img class="image-border" src="img/46044531-310c-4a25-aa0d-29b222d2bf12.png"/></div>
<ol start="6">
<li>Now you will be able to view the Enable Access pane, where you have to tick for Access TodoListService Permissions under the Delegated Permissions, and Done under the Add API access pane. This will save the permissions.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Generation of AppKey for TodoListWebApp</h1>
                
            
            
                
<p>Another important step for registration is adding <kbd>client_secret</kbd>, which is necessary to establish trust between Azure AD and TodoListWebApp. This <kbd>client_secret</kbd> is generated only once and configured in the web application. To generate this key, navigate to App Registrations | TodoListWebApp | Keys. Then, add the description as <kbd>AppKey</kbd> and click on Save. Once the key is saved, the value of the key is autogenerated by Azure and will be displayed next to the description. This key is displayed only once, so you have to immediately copy it and save it for later use. We will be keeping this key in the <kbd>web.config</kbd> file of TodoListWebApp in this case.</p>
<p>The key stored will be displayed on the Azure portal as follows:</p>
<div><img src="img/a983ea10-4845-4d3d-809f-d39af7965390.png"/></div>
<p>For production-grade applications, it is a bad idea to keep <kbd>client_Secret</kbd> and all such critical key values in <kbd>web.config</kbd>. It is good practice to keep them encrypted and isolated from applications. For such purposes, in production-grade applications, you can use Azure key-vault (<a href="https://azure.microsoft.com/en-us/services/key-vault/">https://azure.microsoft.com/en-us/services/key-vault/</a>) to keep all your keys protected. Another advantage of a key vault is that you can manage the keys according to the environment, such as dev-test-staging and production.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Visual Studio solution projects</h1>
                
            
            
                
<p>First, we look at how to configure this with the <kbd>TodoListService</kbd> project.</p>
<p>Open the <kbd>web.config</kbd> file and replace the following keys:</p>
<ol>
<li>Search for the <kbd>ida:Tenant</kbd> key. Replace its value with your AD tenant name, for example, <kbd>contoso.onmicrosoft.com</kbd>. This will also be part of any of the application's APP ID URL.</li>
<li>Replace the <kbd>ida:Audience </kbd> key. Replace its value with <kbd>https://[Your_AD_Tenant_Name]/TodoListService</kbd>.<br/> Replace <kbd>[Your_AD_Tenant_Name]</kbd> with the name of your Azure AD tenant.</li>
</ol>
<p>Now let's see how to configure this with the <kbd>TodoListWebApp</kbd> project.</p>
<p>Open the <kbd>web.config</kbd> file and find and replace the following keys with the provided values:</p>
<ol>
<li>Replace <kbd>todo:TodoListResourceid</kbd> with <kbd>https://[Your_Tenant_Name]/TodoListService</kbd>.</li>
<li>Replace <kbd>todo:TodoListBaseAddress</kbd> with <kbd>https://localhost:44321/</kbd>.</li>
<li>Replace <kbd>ida:ClientId</kbd> with the application ID of ToDoListWebApp. You can get it by navigating to App Registration | TodoListWebApp.</li>
<li>Replace <kbd>ida:AppKey</kbd> with <kbd>client_secret</kbd> that we generated in step 2 of the process of registering TodoListWebApp. If you missed noting this key, you need to delete the previous key and generate a new key.</li>
<li>Replace <kbd>ida:Tenant</kbd> with your AD tenant name, for example, <kbd>contoso.onmicrosoft.com</kbd>.</li>
<li>Replace <kbd>ida:RedirectUri</kbd> with the URL you want the application to redirect to when the user signs out of TodoListWebApp. In our case, the default is <kbd>https://localhost:44322/</kbd> since we want the user to navigate to the home page of the application.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Generate client certificates on IIS Express</h1>
                
            
            
                
<p>Now <kbd>TodoListService</kbd> and <kbd>TodoListWebApp</kbd> will talk over a secure channel. To establish a secure channel, <kbd>ToDoListWebApp</kbd> needs to trust the client certificate. Both services are hosted on the same machine and run on IIS Express.</p>
<p>To configure your computer to trust the IIS Express SSL certificate, open the PowerShell command window as an administrator. Query your personal certificate store to find the thumbprint of the certificate for <kbd>CN=localhost</kbd>:</p>
<div><div><div><div><div><div><pre>PS C:windowssystem32&gt; dir Cert:LocalMachineMy<br/>Directory: Microsoft.PowerShell.SecurityCertificate::LocalMachineMy<br/>Thumbprint Subject<br/>---------- -------<br/>C24798908DA71693C1053F42A462327543B38042 CN=localhost</pre></div>
</div>
</div>
</div>
<p>Next, add the certificate to the trusted root store:</p>
</div>
</div>
<div><div><div><div><div><div><pre>PS C:windowssystem32&gt; $cert = (get-item cert:LocalMachineMyC24798908DA71693C1053F42A462327543B38042)<br/>PS C:windowssystem32&gt; $store = (get-item cert:LocalmachineRoot)<br/>PS C:windowssystem32&gt; $store.Open("ReadWrite")<br/>PS C:windowssystem32&gt; $store.Add($cert)<br/>PS C:windowssystem32&gt; $store.Close()</pre></div>
</div>
</div>
</div>
</div>
</div>
<p>The preceding set of instructions will add a client certificate to the local machine's certificate store.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running both the applications</h1>
                
            
            
                
<p>We are done with all those tedious configuration screens and replacing of keys. Excited? But before you hit <em>F5</em>, set <kbd>ToDoListService</kbd> and <kbd>ToDoListWebApp</kbd> as startup projects. Once this is done, we can safely run our application and be greeted with the landing page of our application. If you click on the Sign-in button, you will be redirected to <a href="http://login.microsoftonline.com">login.microsoftonline.com</a>; this represents the Azure AD login. Once you are able to log in, you will see the landing page as follows:</p>
<div><img class="image-border" height="374" src="img/e29198da-d86b-4acc-a219-c9565624f490.png" width="727"/></div>
<p>You can observe network traffic and URL redirection when you log in to the application to study a detailed exchange of ID tokens and get an access token. If you explore the application through the ToDoList menu, you will be able to access the ToDoList screen as well as add items to ToDoList. This is where our <kbd>TodoListService</kbd> microservice is getting called, as well as getting authorization permissions from the <kbd>TodoWebApp</kbd> web application. If you explore the profile menu, you will see the ID token return along with your first name, last name, and email ID, which shows OpenID Connect in action.</p>
<p>If you want to explore the code in detail, <kbd>TodoListController.cs</kbd> in the TodoListService project, <kbd>Startup.Auth.cs</kbd>, and <kbd>TodoListController.cs</kbd> contain interesting bits of code along with explanatory comments.</p>
<p>In this example, we used OAuth and OpenID Connect to secure a browser-based user interface, a web application, and a microservice. Things might be different if we have an API gateway between the user interface web app and microservice. In this case, we need to establish trust between the web app and API gateway. Also, we have to pass the ID token and access token from the web app to the API gateway. This, in turn, passes the tokens to the microservice. However, it is not feasible to cover the discussion and implementation in this chapter's scope.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Azure API management as an API gateway</h1>
                
            
            
                
<p>Another important pattern in microservices' implementation is <strong>Backends For Frontends</strong> (<strong>BFF</strong>). This pattern was introduced and made popular by Sam Newman. The actual implementation of the BFF pattern is done by introducing the API gateway between various types of clients and microservices.</p>
<p>This is depicted in the following diagram:</p>
<div><img class="image-border" height="450" src="img/d10acc55-d9a0-4d01-806d-95039ad04cfc.png" width="587"/></div>
<p>Azure API Management (henceforth referred to as <strong>Azure APIM</strong> or just <strong>APIM</strong> ) is just the right fit, and it can act as an API gateway in .NET-based microservice implementation. Since Azure APIM is one of the cloud services, it is ultra-scalable and can be integrated well within the Azure ecosystem. In the current chapter, we will focus on the following features of Azure APIM.</p>
<p>Azure APIM is logically divided into three parts:</p>
<ul>
<li>API gateway: API gateway is merely a proxy between client applications and services. It is responsible for the following functionalities; these are mainly used by various applications to talk to microservices:<br/>
<ul>
<li>Accepts API calls and routes them to your backends</li>
<li>Verifies API keys, JWTs, and certificates</li>
<li>Supports auth through Azure AD and OAuth 2.0 access token</li>
<li>Enforces usage quotas and rate limits</li>
<li>Transforms your API on the fly without code modifications</li>
<li>Caches backend responses where set up</li>
<li>Logs call metadata for analytics purposes</li>
</ul>
</li>
<li>Publisher portal: This is the administrative interface to organize and publish an API program. It is mainly used by microservice developers to make microservices/APIs available to API consumers or client applications. Through this, API developers can:<br/>
<ul>
<li>Define or import API schema</li>
<li>Package APIs into products</li>
<li>Set up policies such as quotas or transformations on the APIs</li>
<li>Get insights from analytics</li>
<li>Manage users</li>
</ul>
</li>
<li>Developer portal: This serves as the main web presence for API consumers where they can do the following:<br/>
<ul>
<li>Read the API documentation</li>
<li>Try out an API via the interactive console</li>
<li>Create an account and subscribe to it to get the API keys</li>
<li>Access analytics on their own usage</li>
</ul>
</li>
</ul>
<p>Azure APIM comes with an easy-to-follow user interface and good documentation. Azure API management also comes with its REST API, hence all the capabilities of the Azure APIM portal, which you see can see, can be programmatically achieved by Azure REST API endpoint available for Azure APIM.</p>
<p>Now, let's quickly look at some security-related concepts in Azure APIM and how they can be used in microservices:</p>
<ul>
<li> Products: Products are merely a collection of APIs. They also contain usage quota and terms of use.</li>
<li>Policies: Policies are dynamic security features of API management. They allow the publisher to change the behavior of the API through configuration. Policies are a collection of statements that are executed sequentially upon the request or response of an API. API management is fundamentally a proxy that is sitting between our microservices hosted in Azure and client applications. By virtue of the fact that it is an intermediate layer, it is able to provide additional services. These additional services are defined in a declarative XML-based syntax called <strong>policies</strong>. Azure APIM allows various policies. In fact, you can compose your own custom policies by combining the existing ones. A few of the important policies are as follows:</li>
<li>Access restriction policies:<br/>
<ul>
<li>Check the HTTP header: This policy checks whether a specific HTTP header or its value exists in every request received by Azure APIM.</li>
<li>Limit call rate by subscription: This policy provides allow or deny access to the microservice based on the number of times the specific service has been called on a per subscription basis.</li>
<li>Restrict caller IPs: This policy refers to white-boxing of IP addresses so only known IPs can access the services.</li>
<li>Set usage quota by subscription: This policy allows a number of calls. It allows you to enforce a renewable or lifetime call volume and/or bandwidth quota on a per subscription basis.</li>
<li>Validate JWT: This policy validates the JWT token parameter that is used for auth in applications.</li>
</ul>
</li>
</ul>
<ul>
<li>Authentication policies:<br/>
<ul class="ul-list">
<li>Authenticate with basic : This policy helps apply basic authentication over the incoming request.</li>
<li>Authenticate with client certificate: This policy helps carry out authentication of a service that is behind the API gateway, using client certificates.</li>
</ul>
</li>
<li>Cross domain policies:<br/>
<ul class="ul-list">
<li>Allow cross-domain calls: This policy enables us to make CORS requests through Azure APIM.</li>
<li>CORS : This adds CORS support to an endpoint or a microservice to allow cross-domain calls from browser-based web applications.</li>
<li>JSONP: The JSONP policy adds <strong>JSON padding</strong> (<strong>JSONP</strong>) support to an endpoint or entire microservice to allow cross-domain calls from Java Script web applications.</li>
</ul>
</li>
<li>Transformation policies:<br/>
<ul class="ul-list">
<li>Mask URLs in content: This policy masks URLs in response; it does so via Azure APIM.</li>
<li class="">Set backend service: This policy alters the behavior of the backend service of an incoming request.</li>
</ul>
</li>
</ul>
<p style="padding-left: 120px">Another great thing about policies is they can be applied for inbound and outbound requests. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rate limit and quota policy example</h1>
                
            
            
                
<p>In the preceding section, we saw what is meant by a policy. Now let's see an example. The following is one of the quota policies applied for an endpoint:</p>
<div><div><div><div><div><div><pre style="padding-left: 60px">&lt;policies&gt;<br/>  &lt;inbound&gt;<br/>    &lt;!-- Change the quota to immediately see the effect--&gt;<br/>    &lt;rate-limit calls="100" renewal-period="60"&gt;<br/>    &lt;/rate-limit&gt;<br/>    &lt;quota calls="200" renewal-period="604800"&gt;<br/>    &lt;/quota&gt;<br/>    &lt;base /&gt;<br/>  &lt;/inbound&gt;<br/>  &lt;outbound&gt;<br/>    &lt;base/&gt;<br/>  &lt;/outbound&gt;<br/>&lt;/policies&gt;</pre></div>
</div>
</div>
</div>
<p>In this example, we are limiting incoming requests (inbound) from a single user. So, an API user can only make <kbd>100</kbd> calls within <kbd>60</kbd> seconds. If they try to make more calls within that duration, the user will get an error with status code <kbd>429</kbd>, which basically states <em>Rate limit is exceeded</em>. Also, we are assigning the quota limit of <kbd>200</kbd> calls in a year for the same user. This kind of throttling behavior is a great way to protect microservices from unwanted requests and even DOS attacks.</p>
</div>
</div>
<p>Azure APIM also supports Auth with OAuth 2.0 and OpenID Connect. Inside the publisher portal, you can easily see OAuth and OpenID Connect tabs to configure the providers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Container security</h1>
                
            
            
                
<p>Docker is a big part of the containerization of applications used in the industry. With the widespread usage of containers, it is evident that we need to have effective security measures around containers. If we take a look at the internal architecture of containers, they are quite close to the host operating system kernel.</p>
<p>Docker applies the principle of least privilege to provide isolation and reduce the attack surface. Despite the advances, the following points will help you understand the security measures you can take for containers:</p>
<ul>
<li>Ensure all the container images used for microservices are signed and originate from a trusted registry</li>
<li>Harden the host environment, the daemon process, and images</li>
<li>Follow the principle of least privilege and do not elevate access to access devices</li>
<li>Use control groups in Linux to keep tabs on resources, such as memory, I/O, and CPU</li>
<li>Even though containers live for a very short duration, logging all of the container activity is advisable and important to understand for post analysis</li>
<li>If possible, integrate the container scanning process with tools, such as Aqua (<a href="http://www.aquasec.com">http://www.aquasec.com</a>) or Twistlock (<a href="https://www.twistlock.com">https://www.twistlock.com</a>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Other security best practices</h1>
                
            
            
                
<p>The microservice architectural style is new, although some of the security practices around the infrastructure and writing secure code are still applicable. In this section, let's discuss some of these practices:</p>
<ul>
<li>Standardization of libraries and frameworks: There should be a process to introduce new libraries and frameworks or tools in the development process. This will ease out patching in case any vulnerability is found; it will also minimize the risks introduced by ad hoc implementation of libraries or tools around development.</li>
<li>Regular vulnerability identification and mitigation: Using the industry standard vulnerability scanner to scan the source code and binaries should be a regular part of development. The findings and observations should be addressed as equally as functional defects.</li>
<li>Third-party audits and pen testing: External audits and penetration testing exercises are immensely valuable. There should be a regular practice of conducting such exercises. This is quite essential in applications where mission critical or sensitive data is handled.</li>
<li>Logging and monitoring: Logging is quite a useful technique for detecting and recovering from attacks. Having the capability of aggregating logs from different systems is essential in the case of microservices. Tools such as Riverbed, AppDynamics, and Splunk are quite useful in this space.</li>
<li>Firewalls: Having one or more firewall at network boundaries is always beneficial. Firewall rules should be properly configured.</li>
<li>Network segregation: Network partitioning is constrained and limited in the case of monoliths. However, with microservices, we need to logically create different network segments and subnets. Segmentation based on microservices' interaction patterns can be very effective to keep and develop additional security measures.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The microservice architectural style, being distributed by design, gives us better options to protect valuable business-critical systems. Traditional .NET-based authentication and authorization techniques are not sufficient and cannot be applied to the microservice world. We also saw why secure token-based approaches, such as OAuth 2.0 and OpenID Connect 1.0, are becoming concrete standards for microservice authorization and authentication. If you want to have more general information related to security, do visit <strong>Open Web Application Security Project</strong> (<strong>OWASP</strong>) at <a href="http://www.owasp.org">http://www.owasp.org</a> and Microsoft Security development life cycle at <a href="https://www.microsoft.com/en-us/sdl/">https://www.microsoft.com/en-us/sdl/</a>. Azure AD can support OAuth 2.0 and OpenID Connect 1.0 very well. Azure API Management can also act as an API gateway in microservices' implementation and also provide nifty security features, such as policies.</p>
<p>Azure AD and Azure API management provide quite a few powerful features to monitor and log the requests received. This will be quite useful, not only for security but also for tracing and troubleshooting scenarios. We will see logging, monitoring, and the overall instrumentation around troubleshooting of microservices in the next chapter.</p>


            

            
        
    </body></html>