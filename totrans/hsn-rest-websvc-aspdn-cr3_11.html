<html><head></head><body>
        

                            
                    <h1 class="header-title">Building the Data Access Layer</h1>
                
            
            
                
<p class="mce-root">Starting from this chapter, we are going to walk through the concrete implementation of the web service part using .NET Core. We will cover some key aspects of developing real web services—from the design of the data access layer to the implementation of the HTTP routes. </p>
<p>In this chapter, we will start by defining the data access part. The data access part is necessary to store information in a database or data source, and it is usually one of the most delicate parts of an application. We will be focusing on the implementation of a catalog web service. Additionally, we will explore different third-party tools for accessing our data and explain how to set up a project and implement a data domain.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Designing project entities</li>
<li>Choosing the right tool</li>
<li>Implementing a data access layer using EF Core</li>
<li>Implementing a data access layer using Dapper</li>
<li>Testing a data layer using the in-memory database</li>
</ul>
<p>The code in this chapter is available from the following GitHub repository: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the project</h1>
                
            
            
                
<p>Just like previous chapters, we can start by creating a new project using the web API template. Let's open the terminal and execute the following commands:</p>
<pre><strong>mkdir Catalog.API</strong><br/><strong>cd Catalog.API</strong><br/><strong>dotnet new sln -n Catalog.API</strong><br/><strong>mkdir src</strong><br/><strong>cd src</strong><br/><strong>dotnet new webapi -n Catalog.API</strong><br/><strong>dotnet sln ../Catalog.API.sln add Catalog.API</strong></pre>
<p>The first <kbd>dotnet new</kbd> command creates a new solution file named <kbd>Catalog.API</kbd>. The second <kbd>dotnet new</kbd> instruction creates a new web API project in the <kbd>src</kbd> folder. Finally, the last <kbd>dotnet sln</kbd> command adds the project to our solution.</p>
<p>The resulting filesystem structure looks like the following:</p>
<pre>.<br/>├── Catalog.API.sln<br/>├── src<br/>│   ├── Catalog.API<br/>│   │   ├── Controllers<br/>│   │   ├── Program.cs<br/>│   │   ├── Properties<br/>│   │   │   └── launchSettings.json<br/>│   │   ├── Startup.cs<br/>│   │   ├── Catalog.API.csproj<br/>│   │   ├── appsettings.Development.json<br/>│   │   ├── appsettings.json<br/>│   │   ├── bin<br/>│   │   ├── obj<br/>│   │   └── wwwroot</pre>
<p>The <kbd>src</kbd> folder will contain all our code and the additional projects we will add in the book. Later on in this chapter, we will also add a <kbd>tests</kbd> folder that will contain all the tests for our projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the domain model</h1>
                
            
            
                
<p>As discussed in the <em>Data transfer</em> section in <a href="deede298-fc20-4523-afa6-02ed2c0592fd.xhtml">Chapter 5</a>, <em>Web Service Stack in ASP.NET Core</em>, the <em>domain model</em> is the representation of the data handled by our service. Thinking about a <em>catalog web service</em> for a music store, the primary data we need to process includes the<em> entities</em> used by the API<em>. </em></p>
<p>To guarantee reusability and loose coupling, we are going to define the domain model of the service<em> </em>in a separate project. First of all, let's create a new <kbd>Catalog.Domain</kbd> project inside the <kbd>src</kbd> folder by executing the following command:</p>
<pre><strong>dotnet new classlib -n Catalog.Domain -f netstandard2.1</strong></pre>
<p>The above command also specifies the <kbd>netstandard2.1</kbd> version as target framework. Furthermore, after creating the <kbd>Catalog.Domain</kbd> project, we need to add it to our solution:</p>
<pre><strong>dotnet sln ../Catalog.API.sln add Catalog.Domain</strong></pre>
<p>The preceding instruction adds a reference to the <kbd>Catalog.Domain</kbd> project to the <kbd>Catalog.API.sln</kbd> file. Therefore, we are now ready to design and implement the entities of our web service. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing entities</h1>
                
            
            
                
<p>We can now proceed with the design phase of the entities we need for this implementation. Let's start with the <kbd>Item</kbd> class, which will be the central entity in our domain model. It is a representation of a music album, and it contains all the attributes and characteristics related to albums, including the <em>description</em>, <em>name</em>, <em>release</em> <em>date</em>, and <em>format.</em> The entity will also provide some additional information that is usually present in a catalog, such as available stock, a picture, and the price.</p>
<p>Let's start by designing a diagram to describe our code:</p>
<div><img src="img/1390bf3f-dc67-4333-908f-e1df3a3fc65f.png" style=""/></div>
<p>This diagram defines the entities involved in the service:</p>
<ul>
<li><kbd>Item</kbd> is the primary entity in our claim. It contains all the information about the album and the references to the <em>artist</em> and the <em>genre</em>.</li>
<li>The <kbd>Artist</kbd> entity represents the artist associated with the album.</li>
<li>The <kbd>Genre</kbd> entity represents the music genre associated with the album.</li>
<li>The <kbd>Money</kbd> entity represents the price of the album. This is a complex type that contains the amount of <em>money</em> and the <em>currency</em> it is in.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implement entities</h1>
                
            
            
                
<p>Now we have defined which properties and objects are included in the catalog service, let's start by implementing the entities as concrete types. All domain models are conventionally stored in the <kbd>Entities</kbd> folder in the <kbd>Catalog.Domain</kbd> project. The first type we are creating is the <kbd>Item</kbd> class:</p>
<pre>using System;<br/><br/>namespace Catalog.Domain.Entities<br/>{<br/>    public class Item<br/>    {<br/>        public Guid Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Description { get; set; }<br/>        public string LabelName { get; set; }<br/>        <strong>public Price Price { get; set</strong><strong>; }</strong><br/>        public string PictureUri { get; set; }<br/>        public DateTimeOffset ReleaseDate { get; set; }<br/>        public string Format { get; set; }<br/>        public int AvailableStock { get; set; }<br/>        <strong>public Genre Genre { get; set; }<br/>        public Artist Artist { get; set; }</strong><br/>    }<br/>}</pre>
<p>First, we can see that the definition of the <kbd>Item</kbd> class contains some references to the other types. It is crucial to note that the implementation uses the <kbd>Guid</kbd> type to specify <kbd>Id</kbd>. The primary purpose of that approach is to avoid conflicts in the event of a merger between two different data sources or catalogs.</p>
<p>Let's proceed by defining the related entities of our domain model:</p>
<pre>using System;<br/><br/>namespace Catalog.Domain.Entities<br/>{<br/>    //Artist.cs file<br/>    public class Artist<br/>    {<br/>        public Guid ArtistId { get; set; }<br/>        public string ArtistName { get; set; }<br/>    }<br/>    //Genre.cs file<br/>    public class Genre<br/>    {<br/>        public Guid GenreId { get; set; }<br/>        public string GenreDescription { get; set; }<br/>    }<br/>    //Price.cs file<br/>    public class Price<br/>    {<br/>        public decimal Amount { get; set; }<br/>        public string Currency { get; set; }<br/>    }<br/>}</pre>
<p>For representational purposes, the following classes are implemented in the same fragment of code. Note that they are defined in different files: <kbd>Artist.cs</kbd>, <kbd>Genre.cs</kbd>, and <kbd>Price.cs</kbd>.</p>
<p>The preceding code defines the related entities contained in our domain model<em>.</em> The <kbd>Artist</kbd> class represents an artist related to an album. It includes <kbd>Guid id</kbd> and <kbd>ArtistName</kbd>. In the same way, the <kbd>Genre</kbd> class is another category type that represents the genre of a specific album. Finally, the <kbd>Price</kbd> class represents the price (and the currency) of the product.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data access using ORMs</h1>
                
            
            
                
<p>Data access is the part of our service that helps us to perform reading or writing operations on the data source. The data access section is usually combined with an ORM. In general, we can define an ORM as an object-relational mapping tool for converting relational data between incompatible type systems using an object-oriented programming approach. </p>
<p>ORM tools or packages are a bridge between a data source and a web application. They map the information represented in relational tables into classes and, consequently, objects.</p>
<p>In the .NET ecosystem, we can choose between a vast number of different ORMs. The one that is officially maintained by Microsoft is EF Core.</p>
<p>EF Core is an open source ORM powered by Microsoft and the community. It is the default ORM used in .NET Core applications and web services. In this chapter, we will also have an overview of <strong>Dapper</strong>, an open source micro-ORM powered by Stack Exchange and the community. Both EF Core and Dapper are distributed as NuGet packages, and, in general, they are very well integrated with the .NET Core framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding the right tool for the job</h1>
                
            
            
                
<p>EF Core and Dapper provide an abstraction level over our data source. Nevertheless, both of them have some pros and cons. It is essential to bear in mind that, for every project we are working on, we should seek to find the right tool for the job.</p>
<p>Let's analyze some pros and cons for these two libraries. Before that, we should take a quick look at some demo queries in order to understand the differences between the two. The following snippet describes a sample query using EF Core:</p>
<pre>using (var context = new CatalogContext()) {<br/>     var items = context.Items         <br/>                        .Where(b =&gt; b.Description.Contains("various <br/>                         artists"))<br/>                        .ToList();<br/>}</pre>
<p>In the preceding code, we search for every <kbd>Item</kbd> entity with a corresponding description. Let's proceed by taking a Dapper query as an example:</p>
<pre>connection.Query&lt;Item&gt;("select * from (select Id from dbo.Catalog where Description like '%@searchTerm%', new { searchTerm = "various artists" });</pre>
<p>As you can see, EF Core provides a high level of abstraction over our data source.</p>
<p>Moreover, EF Core, by default, allows developers to query data using collections (integrated with LINQ). This type of approach is quick and easy, but it comes at a cost: EF Core translates queries into the SQL language, and, sometimes, it produces SQL queries that are not optimized. EF Core also encourages a code-first approach over the database, which means that all the entities that are present on the database side are generated using C# code. This may seem easy when you have a single object, but it can present maintainability problems when you have complex entities.</p>
<p>In complex entities, or applications that use the code-first approach, the code that generates database entities is usually implemented in a separate project and repository to avoid tight coupling between the database and the entire solution. </p>
<p class="mce-root">A common problem with EF Core, though, is the early fetching of resources. For example, consider a query such as this:</p>
<div><pre class="crayon-line"> List&lt;Item&gt; items = db.Items.ToList();<br/> List&lt;Item&gt; variousArtistItems = items<br/>                     .Where(s =&gt; s.Description.Contains("various <br/>                          artist") == city).ToList();<br/></pre></div>
<p>It produces a SQL query similar to the following:</p>
<pre>SELECT [i].[Id],<br/>       [i].[Description],<br/>       [i].[ArtistId], <br/>       [i].[GenreId],<br/>FROM   [dbo].[Items] as [i]</pre>
<p>As you can see, despite the fact we use the <kbd>Where</kbd> clause, earlier the <kbd>ToList</kbd> method evaluated the query without considering the <kbd>Where</kbd> clause. To get a better result, we should execute the <kbd>Where</kbd> statement before the evaluation:</p>
<pre class="crayon-line"> List&lt;Item&gt; variousArtistItems = db.Items<br/>                     .Where(s =&gt; s.Description.Contains("various <br/>                          artist") == city).ToList();<br/></pre>
<p>This kind of procedure is better both for performance and network reasons. It may seem simple enough, but it is quite common that these kinds of error are introduced in the codebase in distributed teams, and they can be quite tricky to spot in the code review process.</p>
<p>In terms of Dapper, which is a micro-ORM, the abstraction level changes. Dapper provides more <em>transparent</em> access to the data source. It guarantees, by default, a clear way to query your data by using plain SQL or stored procedures. Consequently, it also ensures better performance. On the other hand, it is tightly coupled with the data source, because it executes queries using the data source query language. </p>
<p>In summary, this chapter will cover both EF Core and Dapper libraries. To choose between them, you should consider the skills already present in your team and how the service can be performance-optimized. If your team has a strong knowledge of SQL, you may proceed by implementing stored procedures instead of using EF Core. On the other hand, if your team doesn't already have SQL skills, you should consider using EF Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a data access layer using EF Core</h1>
                
            
            
                
<p>In this section, we will explore how to build a data access layer using the repository pattern and EF Core. The <strong>repository pattern</strong> is an additional abstraction over our data source. It provides reading and writing operations on data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the repository pattern and unit of work</h1>
                
            
            
                
<p>Before we start, we need to define some interfaces in the <kbd>Catalog.Domain</kbd> project. Let's proceed by setting a generic interface to determine the unit of work of our repository:</p>
<pre>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/><br/>namespace Catalog.Domain.Repositories<br/>{<br/>    public interface IUnitOfWork : IDisposable<br/>    {<br/>        Task&lt;int&gt; SaveChangesAsync(CancellationToken cancellationToken = <br/>         default(CancellationToken));<br/>        Task&lt;bool&gt; SaveEntitiesAsync(CancellationToken cancellationToken = <br/>         default(CancellationToken));<br/>    }<br/>}</pre>
<p><kbd>IUnitOfWork</kbd> defines two methods: <kbd>SaveChangesAsync</kbd> and <kbd>SaveEntitiesAsync</kbd>. These two methods are used to save changes in our collection to the database effectively. These methods are both asynchronous: they return a <kbd>Task</kbd> type and they accept a <kbd>CancellationToken</kbd> type as a parameter. The <kbd>CancellationToken</kbd> parameter provides a way to stop pending asynchronous operations.</p>
<p>In some cases, the repository pattern is implemented in such a way that, when you update or create new elements in a collection, those changes are automatically saved to the database. I prefer to keep the effective saving operation separate from the reading and writing part. This can be achieved using the unit of work approach. Therefore, the repository allows the higher layers to perform get, create, and update operations on the memory collection, while the <em>unit of work</em><strong> </strong>implements a way to transfer those changes to the database.</p>
<p>Let's proceed by defining an <kbd>IRepository</kbd> interface at the same folder level as the <kbd>IUnitOfWork</kbd> interface defined previously:</p>
<div><pre>namespace Catalog.Domain.Repositories<br/>{<br/>    public interface IRepository<br/>    {<br/>        IUnitOfWork UnitOfWork { get; }<br/>    }<br/>}</pre></div>
<p class="mce-root"/>
<p>As you can see, <kbd>IRepository</kbd> does not implicitly use the <kbd>IUnitOfWork</kbd> interface. Additionally, it exposes the <kbd>UnitOfWork</kbd> instance as a property of the class. This approach guarantees that all the consumers of the <kbd>IRepository</kbd> interface must explicitly update the database by calling the <kbd>SaveChangesAsync</kbd> or <kbd>SaveEntitiesAsync</kbd> methods. </p>
<p>The final step is to define the <kbd>IItemRepository</kbd> interface, as follows:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Domain.Repositories<br/>{<br/>    public interface IItemRepository : IRepository<br/>    {<br/>        Task&lt;IEnumerable&lt;Item&gt;&gt; GetAsync();<br/>        Task&lt;Item&gt; GetAsync(Guid id);<br/>        Item Add(Item item);<br/>        Item Update(Item item);<br/>    }<br/>}</pre>
<p>The interface extends the <kbd>IRepository</kbd> class and refers to the <kbd>Item</kbd> entity that was defined previously. <kbd>IItemRepository</kbd> defines reading and writing operations over our data source. You may notice that the <kbd>Add</kbd>, <kbd>Update</kbd>. This is because they only act on the collection stored in the memory of the application, and the effective saving operation is performed by the unit of work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting our repository to the database</h1>
                
            
            
                
<p>Once we have defined the <kbd>IItemRepository</kbd> interfaces and all the abstractions in the domain project, we should continue by creating the classes that will represent the concrete implementation of the previously defined abstractions. We will also create a new <kbd>Catalog.Infrastructure</kbd> project containing all the implementations of our repositories and the classes that represent the layer between our service and the database. Let's create the <kbd>Catalog.Infrastructure</kbd> project by executing the following commands in the <kbd>src</kbd> folder:</p>
<pre><strong>dotnet new classlib -n Catalog.Infrastructure -f netstandard2.1<br/><br/></strong><strong>dotnet sln ../Catalog.API.sln add Catalog.Infrastructure</strong></pre>
<p>Once finished, the folder structure for our solution looks as follows:</p>
<pre>.<br/>├── Catalog.API.sln<br/>└── src<br/>    ├── Catalog.API<br/>    │ ...<br/>    ├── Catalog.Domain<br/>    │ ├── Entities<br/>    │ │ ├── Artist.cs<br/>    │ │ ├── Genre.cs<br/>    │ │ ├── Item.cs<br/>    │ │ └── Money.cs<br/>    │ │ └── Repositories<br/>    │ │ ├── IItemRepository.cs<br/>    │ │ ├── IRepository.cs<br/>    │ │ └── IUnitOfWork.cs<br/>    │ ├── Catalog.Domain.csproj<br/>    └── Catalog.Infrastructure<br/>        ├── Catalog.Infrastructure.csproj</pre>
<p>Before proceeding with the implementation of <kbd>IItemRepository</kbd>, we need to add the <kbd>Microsoft.EntityFrameworkCore</kbd> NuGet package to the <kbd>Catalog.Infrastructure</kbd> project by executing the following command inside the project folder:</p>
<pre class="p1"><strong>dotnet add package Microsoft.EntityFrameworkCore</strong><br/></pre>
<p>After that, we can proceed by adding the reference to the <kbd>Catalog.Domain</kbd> project into the infrastructure project, using the following command:</p>
<pre><strong> dotnet add reference ../Catalog.Domain</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">DbContext definition</h1>
                
            
            
                
<p><kbd>DbContext</kbd> is one of the abstractions between our application and the database. It enables us to interact with, and perform operations over, data. A <kbd>DbContext</kbd> implementation is also the representation of a session between our application and the database, and it can be used to query and save the instances of the application entities into our data source. Let's take a quick look at the <kbd>DbContext</kbd> implementation in the <kbd>Catalog.Infrastructure</kbd> project:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/>using Microsoft.EntityFrameworkCore;<br/><br/>namespace Catalog.Infrastructure<br/>{<br/>    public class CatalogContext : DbContext, IUnitOfWork<br/>    {<br/>        public const string DEFAULT_SCHEMA = "catalog";<br/>        <br/>        public DbSet&lt;Item&gt; Items { get; set; }<br/><br/>        public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : <br/>         base(options)<br/>        {<br/>        }<br/><br/>        protected override void OnModelCreating(ModelBuilder modelBuilder)<br/>        {<br/>        }<br/><br/>        public async Task&lt;bool&gt; SaveEntitiesAsync(CancellationToken <br/>         cancellationToken = default(CancellationToken))<br/>        {<br/>            await SaveChangesAsync(cancellationToken);<br/>            return true;<br/>        }<br/>    }<br/>}</pre>
<p>After taking a quick look at the code, we should mention the following:</p>
<ul>
<li>The <kbd>CatalogContext</kbd> class represents our unit of work; therefore, it implements the <kbd>IUnitOfWork</kbd> interface.</li>
<li>It uses the <kbd>DbSet&lt;Item&gt;</kbd> type to represent the collection of <kbd>Item</kbd> instances.</li>
<li>The constructor of the <kbd>CatalogContext</kbd> class accepts a mandatory argument, which represents <kbd>DbContextOptions</kbd>. These options are used to specify some key information about the connection with the database. This includes the database provider to be used, the connection string to that database, and all the tracking policies used by the ORM.</li>
<li>The <kbd>CatalogContext</kbd> class also implements <kbd>SaveEntitiesAsync</kbd>, which calls the <kbd>SaveChangesAsync</kbd> method derived by the <kbd>DbContext</kbd> class.</li>
</ul>
<p>Once we have <kbd>CatalogContext</kbd>, we can continue by implementing the <kbd>IItemRepository</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the repository </h1>
                
            
            
                
<p>The following subsection focuses on building the concrete implementation of the <kbd>IItemRepository</kbd> interface. It is vital to note that the <kbd>IItemRepository</kbd> interface is located in the <kbd>Catalog.Domain</kbd> project and the implementation of <kbd>ItemRepository</kbd> is in the <kbd>Catalog.Infrastructure</kbd> project<em>.</em></p>
<p>Once we have built the <kbd>DbContext</kbd> class, we can proceed by implementing the concrete <kbd>ItemRepository</kbd> class:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/>using Microsoft.EntityFrameworkCore;<br/><br/>namespace Catalog.Infrastructure.Repositories<br/>{<br/>    public class ItemRepository<br/>        : IItemRepository<br/>    {<br/>        private readonly CatalogContext _context;<br/><br/>        public IUnitOfWork UnitOfWork =&gt; _context;<br/><br/>        public ItemRepository(CatalogContext context)<br/>        {<br/>            _context = context ?? throw new <br/>             ArgumentNullException(nameof(context));<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetAsync()<br/>        {<br/>            return await _context<br/>                .Items<br/>                .AsNoTracking()<br/>                .ToListAsync();<br/>        }<br/><br/>        public async Task&lt;Item&gt; GetAsync(Guid id)<br/>        {<br/>            var item = await _context.Items<br/>                .AsNoTracking()<br/>                .Where(x =&gt; x.Id == id)<br/>                .Include(x =&gt; x.Genre)<br/>                .Include(x =&gt; x.Artist).FirstOrDefaultAsync();<br/><br/>            return item;<br/>        }<br/><br/>        public Item Add(Item order)<br/>        {<br/>            return _context.Items<br/>                .Add(order).Entity;<br/>        }<br/><br/>        public Item Update(Item item)<br/>        {<br/>            _context.Entry(item).State = EntityState.Modified;<br/>            return item;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code implements the CRUD operations previously defined in the <kbd>IItemRepository</kbd> interface. It also exposes <kbd>CategoryContext</kbd> using the <kbd>IUnitOfWork</kbd> interface. This kind of approach guarantees that the consumer of <kbd>IItemRepository</kbd> can modify and query our collections and also update the data source with the corresponding changes. Let's walk-through the methods implemented in the preceding code:</p>
<ul>
<li>The <kbd>GetAsync()</kbd> method uses the context to retrieve the collection of <kbd>Items</kbd> entities. The method uses the <kbd>AsNoTracking()</kbd> method explicitly in order to prevent the tracking of entities. This extension method can be used every time you don't need to perform writing operations on entities, and it is meant for read-only data.</li>
<li><kbd>GetAsync(Guid id)</kbd> overloads the previously mentioned method, and it uses <kbd>AsNoTracking()</kbd> for the same purpose described previously. This method also gets details of the related entities (<kbd>Genre</kbd> and <kbd>Artist</kbd>) by using the <kbd>Include()</kbd> extension method provided by EF Core. </li>
</ul>
<ul>
<li>The <kbd>Add(Item entity)</kbd> method uses the context to add the entity passed as a parameter and it returns the added entity to the caller.</li>
<li>The <kbd>Edit</kbd> method updates the target entity from the context and sets <kbd>EntityState.Modified</kbd>. This approach guarantees that, once the entity is in a modified state, it will be updated at the saving step.</li>
</ul>
<p class="mce-root"/>
<p>The preceding code doesn't implement the <kbd>Delete</kbd> method. This is because the delete process will be implemented later on in the book. We will essentially perform a soft deletion of our data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transforming entities into a SQL schema</h1>
                
            
            
                
<p>EF Core encourages the code-first approach in our services. The <strong>code-first</strong> technique consists of defining some entity classes in C# and using them to generate tables on the database side. The same approach is applied to all the relationships and constraints that are usually present in a SQL ecosystem, such as the index, the primary keys, and<em> </em>the foreign keys. This section demonstrates how to use this kind of approach to generate the database schema.</p>
<p>First of all, let's start by taking back our <kbd>Item.cs</kbd> entity and adding an ID that represents the relationship with the other entities:</p>
<pre>using System;<br/><br/>namespace Catalog.Domain.Entities<br/>{<br/><strong>    //Item.cs file</strong><br/>   public class Item<br/>    {<br/>        public Guid Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Description { get; set; }<br/>        public string LabelName { get; set; }<br/>        public Price Price { get; set; }<br/>        public string PictureUri { get; set; }<br/>        public DateTimeOffset ReleaseDate { get; set; }<br/>        public string Format { get;set; }<br/>        public int AvailableStock { get; set; }<br/>       <strong> public Guid GenreId { get; set; }</strong><br/>        public Genre Genre { get; set; }<br/>       <strong> public Guid ArtistId { get; set; }</strong><br/>        public Artist Artist { get; set; }<br/>    }<br/>    <br/>   <strong> //Artist.cs file</strong><br/>    public class Artist<br/>    {<br/>        public Guid ArtistId { get; set; }<br/>        public string ArtistName { get; set; }<br/>        <strong>public ICollection&lt;Item&gt; Items {get; set;}</strong><br/>    }<br/><br/><strong>    //Genre.cs file</strong><br/>    public class Genre<br/>    {<br/>        public Guid GenreId { get; set; }<br/>        public string GenreDescription { get; set; }<br/>        <strong>public ICollection&lt;Item&gt; Items {get; set;}<br/></strong>    }<br/>}</pre>
<p>The preceding code describes the <em>many-to-one</em> relationship between the <kbd>Item</kbd> class and the <kbd>Artist</kbd> class and between the <kbd>Item</kbd> class and the <kbd>Genre</kbd> class. Additionally, both the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities have a collection that refers to a collection of <kbd>Item</kbd> entities.</p>
<p>Let's continue by implementing the constraints of our <kbd>Item</kbd> entity using the Fluent API approach. In general, EF Core ORM implements the Fluent API's technique to help us to deal with the constraint's definitions.</p>
<p>In general, the Fluent API, also called the<strong> Fluent interface</strong>, is a method for composing object-oriented APIs that are essentially based on method chaining. The chain between methods produces source code that is very close to written prose; for example, <kbd>myList.First().Items.Count().ShouldBe(2)</kbd><em>.</em> You can see how readable this example is; it can be understood by anyone. Most EF Core constraints are usually built using this kind of approach.</p>
<p>Let's proceed by adding a new folder called <kbd>SchemaDefinitions</kbd> inside our <kbd>Catalog.Infrastructure</kbd> project. The folder will contain all the schema definitions implemented for the application and all the definitions of the constraints between the entities. For example, in the case of the <kbd>Item</kbd> entity, we need to create a new <kbd>ItemEntitySchemaDefinition</kbd> class:</p>
<pre>using System;<br/>using Catalog.Domain.Entities;<br/>using Microsoft.EntityFrameworkCore;<br/>using Microsoft.EntityFrameworkCore.Metadata.Builders;<br/>namespace Catalog.Infrastructure.SchemaDefinitions<br/>{<br/>    public class ItemEntitySchemaDefinition :<br/>        IEntityTypeConfiguration&lt;Item&gt;<br/>    {<br/>        public void Configure(EntityTypeBuilder&lt;Item&gt; builder)<br/>        {<br/>            builder.ToTable("Items", CatalogContext.DEFAULT_SCHEMA);<br/>            builder.HasKey(k =&gt; k.Id);<br/><br/>            builder.Property(p =&gt; p.Name)<br/>                .IsRequired();<br/><br/>            builder.Property(p =&gt; p.Description)<br/>                .IsRequired()<br/>                .HasMaxLength(1000);<br/><br/>            builder<br/>                .HasOne(e =&gt; e.Genre)<br/>                .WithMany(c =&gt; c.Items)<br/>                .HasForeignKey(k =&gt; k.GenreId);<br/><br/>            builder<br/>                .HasOne(e =&gt; e.Artist)<br/>                .WithMany(c =&gt; c.Items)<br/>                .HasForeignKey(k =&gt; k.ArtistId);<br/><br/>            builder.Property(p =&gt; p.Price).HasConversion(<br/>                p =&gt; $"{p.Amount}:{p.Currency}",<br/>                p =&gt; new Price<br/>                {<br/>                    Amount = Convert.ToDecimal(<br/>                     p.Split(':', StringSplitOptions.None)[0]),<br/>                     Currency = p.Split(':', StringSplitOptions.None)[1]<br/>                });<br/>        }<br/>    }<br/>}</pre>
<p>This is the schema definition of the <kbd>Item</kbd> entity constraints. The class implements the <kbd>IEntityTypeConfiguration&lt;T&gt;</kbd> interface exposed by the <kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd> package. It is necessary to add a new reference to the <kbd>Catalog.Infrastructure</kbd> project by using the following command:</p>
<pre><strong>dotnet add package Microsoft.EntityFrameworkCore.SqlServer</strong></pre>
<p>The package provides an extension method to interact with a SQL server database: the <kbd>Configure</kbd> method implementation defines rules, which will be applied to the <kbd>Item</kbd> entity. Because of the Fluent API approach, it is easy to understand these rules:</p>
<ul>
<li>The <kbd>ToTable</kbd> method is used to define the name of the SQL table explicitly</li>
<li>The <kbd>HasKey</kbd> method sets the property as the primary key for this entity type</li>
<li>The <kbd>IsRequired</kbd> method is used to mark all the required features</li>
</ul>
<p>EF Core provides different <em>out-of-box</em> configurations for our properties; a complete list is available at <a href="https://docs.microsoft.com/en-us/ef/core/modeling/">https://docs.microsoft.com/en-us/ef/core/modeling/</a>. These properties can be combined to obtain a better result regarding the correct representation of our domain model.</p>
<p>The <kbd>Configure</kbd> method also adds some additional constraints to the <em>one-to-many</em> relationship between the <kbd>Item</kbd> entity and the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities:</p>
<pre>      ...            <br/>            builder<br/>                .HasOne(e =&gt; e.Genre)<br/>                .WithMany(c =&gt; c.Items)<br/>                .HasForeignKey(k =&gt; k.GenreId);<br/>            <br/>            builder<br/>                .HasOne(e =&gt; e.Artist)<br/>                .WithMany(c =&gt; c.Items)<br/>                .HasForeignKey(k =&gt; k.ArtistId);<br/>      ...</pre>
<p>This snippet specifies the relationships of the <kbd>Item</kbd> entity. Note that we follow a fluent approach. In this specific case, we are defining a 1-N relationship between the <kbd>Item</kbd> class and the <kbd>Artist</kbd> and <kbd>Genre</kbd> classes, by specifying <kbd>GenreId</kbd> and <kbd>ArtistId</kbd> as the foreign keys.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom conversions using the Fluent API</h1>
                
            
            
                
<p>EF Core also provides a way to add custom conversions<em>.</em> This approach may be useful for providing a custom representation of complex entities. As an example, let's take the following snippet of code declared in <kbd>ItemEntitySchemaDefinition</kbd>:</p>
<pre>            builder.Property(p =&gt; p.Price).HasConversion(<br/>                p =&gt; $"{p.Amount}:{p.Currency}",<br/>                p =&gt; new Price<br/>                {<br/>                    Amount = Convert.ToDecimal(p.Split(':', <br/>                     StringSplitOptions.None)[0]),<br/>                    Currency = p.Split(':', StringSplitOptions.None)[1]<br/>                });</pre>
<p>The <kbd>HasConversion</kbd> method offers a way to customize data inserted into the database. This method serializes the <kbd>Price</kbd> field, which is of the <kbd>Price</kbd> type, into a string by using the following format: <kbd>34.05:EUR</kbd>. On the other hand, when the <kbd>Price</kbd> data is read from the database, the string is deserialized into the <kbd>Price</kbd> type. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying the schema definition on the current data context </h1>
                
            
            
                
<p class="mce-root">To utilize the schema implemented in the <kbd>ItemEntitySchemaDefinition</kbd> class, we should apply it in the <kbd>OnModelCreating</kbd> method contained in the <kbd>CatalogContext</kbd> class:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Microsoft.EntityFrameworkCore;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/><strong>using Catalog.Infrastructure.SchemaDefinitions;</strong><br/><br/><br/>namespace Catalog.Infrastructure<br/>{<br/>    public class CatalogContext : DbContext, IUnitOfWork<br/>    {<br/>        public const string DEFAULT_SCHEMA = "catalog";<br/>        public DbSet&lt;Item&gt; Items { get; set; }<br/><br/><br/>        public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) <br/>            : base (options) { }<br/><br/><br/>      <strong>  protected override void OnModelCreating(ModelBuilder modelBuilder)</strong><br/><strong>        {</strong><br/><strong>            modelBuilder.ApplyConfiguration(new ItemEntitySchemaDefinition());</strong><br/><strong>            base.OnModelCreating(modelBuilder);</strong><br/><strong>        }</strong><br/><br/>        public async Task&lt;bool&gt; SaveEntitiesAsync(CancellationToken <br/>            cancellationToken = default(CancellationToken))<br/>        {<br/>            await SaveChangesAsync(cancellationToken);<br/>            return true;<br/>        }        <br/>    }<br/>}</pre>
<p>The preceding code uses the <kbd>ApplyConfiguration</kbd> extension method to apply configurations to the SQL schema during the runtime execution. It is important to note that the <kbd>OnModelCreating</kbd> method implemented in the class always calls the <kbd>base.OnModelCreating</kbd> method of the parent class, in order to preserve the behavior of the extended class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating a schema for the Artist and Genre entities</h1>
                
            
            
                
<p>The preceding process can also be applied to the <kbd>Artist</kbd> and <kbd>Genre</kbd> entities. The following code shows the definitions of the two entities in the <kbd>Catalog.Domain.Entities</kbd> namespace:</p>
<pre>using System.Collections.Generic;<br/><br/>namespace Catalog.Domain.Entities<br/>{<br/>    //Artist.cs<br/>    public class Artist<br/>    {<br/>        public Guid ArtistId { get; set; }<br/>        public string ArtistName { get; set; }<br/>        public ICollection&lt;Item&gt; Items { get; set; }<br/>    }<br/><br/>    //Genre.cs<br/>    public class Genre<br/>    {<br/>        public Guid GenreId { get; set; }<br/>        public string GenreDescription { get; set; }<br/>        public ICollection&lt;Item&gt; Items { get; set; }<br/>    }<br/>}</pre>
<p>Consequently, we can add two files to the <kbd>Catalog.Infrastructure</kbd> project as follows:</p>
<pre> <strong>//SchemaDefinitions/</strong><strong>ArtistEntitySchemaConfiguration.cs<br/></strong>using Microsoft.EntityFrameworkCore;<br/>using Microsoft.EntityFrameworkCore.Metadata.Builders;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Infrastructure.SchemaDefinitions<br/>{<br/>    public class ArtistEntitySchemaConfiguration : <br/>        IEntityTypeConfiguration&lt;Artist&gt;<br/>    {<br/>        public void Configure(EntityTypeBuilder&lt;Artist&gt; builder)<br/>        {<br/>            builder.ToTable("Artists", CatalogContext.DEFAULT_SCHEMA);<br/>            builder.HasKey(k =&gt; k.ArtistId);<br/>            <br/>            builder.Property(p =&gt; p.ArtistId);<br/><br/>            builder.Property(p =&gt; p.ArtistName)<br/>                .IsRequired()<br/>                .HasMaxLength(200);<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>GenreEntitySchemaConfiguration.cs</kbd> file looks as follows:</p>
<pre> <strong>//SchemaDefinitions/GenreEntitySchemaConfiguration.cs<br/></strong>using Catalog.Domain.Entities;<br/>using Microsoft.EntityFrameworkCore;<br/>using Microsoft.EntityFrameworkCore.Metadata.Builders;<br/><br/>namespace Catalog.Infrastructure.SchemaDefinitions<br/>{<br/>    public class GenreEntitySchemaConfiguration : <br/>        IEntityTypeConfiguration&lt;Genre&gt;<br/>    {<br/>        public void Configure(EntityTypeBuilder&lt;Genre&gt; builder)<br/>        {<br/>            builder.ToTable("Genres", CatalogContext.DEFAULT_SCHEMA);<br/>            builder.HasKey(k =&gt; k.GenreId);<br/>            <br/>            builder.Property(p =&gt; p.GenreId);<br/>            <br/>            builder.Property(p =&gt; p.GenreDescription)<br/>                .IsRequired()<br/>                .HasMaxLength(1000);<br/>        }<br/>    }<br/>}</pre>
<p>Both <kbd>GenreEntitySchemaConfiguration</kbd> and <kbd>ArtistEntitySchemaConfiguration</kbd> define the keys for our tables using the <kbd>HasKey</kbd> method. As we have already discussed, they use the same fluent approach applied to the <kbd>ItemEntitySchemaConfiguration</kbd> class defined previously. Also, we need to include <kbd>GenreEntitySchemaConfiguration</kbd> and <kbd>ArtistEntitySchemaConfiguration</kbd> in the <kbd>OnModelCreating</kbd> method of the <kbd>CatalogContext</kbd> class:</p>
<pre><br/>    public class CatalogContext : DbContext, IUnitOfWork<br/>    {<br/>...<br/>      <strong>  protected override void OnModelCreating(ModelBuilder modelBuilder)</strong><br/><strong>        {</strong><br/>            modelBuilder.ApplyConfiguration(new ItemEntitySchemaDefinition());<strong><br/>            modelBuilder.ApplyConfiguration(new GenreEntitySchemaConfiguration());<br/>            modelBuilder.ApplyConfiguration(new ArtistEntitySchemaConfiguration());<br/><br/></strong>            base.OnModelCreating(modelBuilder);<br/><strong>        }</strong><br/>...     <br/>    }</pre>
<p>I've omitted the full definition of the <kbd>CatalogContext</kbd> class for brevity. The significant change is the extension of the <kbd>OnModelCreating</kbd> method by applying the configuration for the <kbd>GenreEntitySchemaConfiguration</kbd> and <kbd>ArtistEntitySchemaConfiguration</kbd> classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing migrations</h1>
                
            
            
                
<p>The last step in implementing data access using EF Core is to connect a <kbd>DbContext</kbd> instance to the database and run the migrations using the command exposed by the .NET CLI. Before doing that, we need to have a working database in our local environment. To keep our local development environment as lightweight as possible, this example will use a Docker image of Microsoft SQL Server on Linux. It is possible to get the Docker image here: <a href="https://hub.docker.com/r/microsoft/mssql-server-linux/">https://hub.docker.com/r/microsoft/mssql-server-linux/</a>. If you don't have any previous experience with Docker, you can follow this guide to install and set it up on your local machine: <a href="https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017</a>.</p>
<p>Containers are an excellent way to quickly set up your local environment without the need to configure a lot of different tools and systems. Nowadays, Microsoft is investing a lot in simplifying their systems and processes, both for developers and cloud systems. </p>
<p>After running our SQL instance, let's create a new database called <kbd>Store</kbd><em>,</em> by running the following commands:</p>
<pre><strong>docker exec -it sql1 </strong><strong>"bash"<br/></strong><br/><strong>/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P '&lt;YOUR_PASSWORD&gt;'<br/></strong><br/>1&gt; CREATE LOGIN catalog_srv WITH PASSWORD = 'P@ssw0rd';<br/>2&gt; CREATE DATABASE Store;<br/>3&gt; GO<br/>1&gt; USE Store;<br/>2&gt; CREATE USER catalog_srv;<br/>3&gt; GO<br/>1&gt; EXEC sp_addrolemember N'db_owner', N'catalog_srv';<br/>2&gt; GO</pre>
<p>A valid alternative to the CLI is to use a SQL editor. One recommended tool is the <kbd>mssql</kbd> extension for VS Code: <a href="https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017</a>. Otherwise, you can download this cross-platform SQL editor based on VS Code: <a href="https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017</a>.</p>
<p>Once we get Microsoft SQL Server working in our local environment, we can proceed by connecting our service with the database. The <kbd>Startup</kbd> class already present in the <kbd>Catalog.API</kbd> project will define the connection string and the provider used by our service. As we will see, all the migration classes will also be stored in the same project. This kind of approach guarantees a unique entry point, <kbd>Catalog.API</kbd>, for our .NET CLI instructions, without being tightly coupled with the database logic (<kbd>Catalog.Infrastructure</kbd>).</p>
<p>Before proceeding further, we need to add the <kbd>Catalog.Infrastructure</kbd> project as a reference for the API project by using the following command in the API project folder:</p>
<pre><strong>dotnet add reference ../Catalog.Infrastructure</strong></pre>
<p>The API project also requires you to refer to the <kbd>Microsoft.EntityFrameworkCore.Design</kbd> NuGet package, which shares design-time components for EF Core tools. We can add the latest version of the package by executing the following CLI instruction into the <kbd>Catalog.API</kbd> project folder: </p>
<pre><strong>dotnet add package Microsoft.EntityFrameworkCore.Design</strong></pre>
<p>After that, we can proceed by adding the database connection in the <kbd>Startup</kbd> class:</p>
<pre>using System;<br/>using System.Reflection;<br/>using Microsoft.AspNetCore.Builder;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/><strong>using Microsoft.EntityFrameworkCore;<br/>using Catalog.Infrastructure;<br/></strong><br/>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>        public Startup(IConfiguration configuration)<br/>        {<br/>          ...<br/>        }<br/><br/>        ...<br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>          <strong> </strong><strong>   services<br/>                .AddEntityFrameworkSqlServer()<br/>                .AddDbContext&lt;CatalogContext&gt;(contextOptions =&gt;<br/>                {<br/>                    contextOptions.UseSqlServer(<br/> "Server=localhost,1433;Initial Catalog=Store;User Id=&lt;SA_USER&gt;;Password=&lt;PASSWORD&gt;",<br/>                        serverOptions =&gt; {             <br/>                           serverOptions.MigrationsAssembly<br/>                           (typeof(Startup).Assembly.FullName); });<br/>                });</strong><br/>             ...<br/>        }<br/><br/>        public void Configure(IApplicationBuilder app, <br/>            IHostingEnvironment env)<br/>        {<br/>          ...<br/>        }<br/>    }<br/>}<br/><br/></pre>
<p>The <kbd>ConfigureServices</kbd> method contains the initialization of the SQL connection. First of all, it adds the services required by the SQL provider using <kbd>AddEntityFameworkSqlServer</kbd>. Following that, it adds <kbd>CatalogContext</kbd>, utilizing the <kbd>AddContext&lt;T&gt;</kbd> generic method by passing an action method of the <kbd>Action&lt;DbContextOptionsBuilder&gt;</kbd> type. </p>
<p>Finally, the action method configures the SQL Server provider by using the <kbd>UseSqlServer</kbd> extension method and passing the connection string for our database. The <kbd>MigrationsAssembly</kbd> method defines where the assemblies should be stored. In this case, it specifies that all migrations will be stored in our <kbd>Catalog.API</kbd> project.</p>
<p>To keep our <kbd>Startup</kbd> class clean and readable, we may create a custom extension method to initialize the connection to the <kbd>Catalog</kbd> database. Let's create a new folder called <kbd>Extensions</kbd> in our <kbd>Catalog.API</kbd> project<em>,</em> add a new <kbd>DatabaseExtension</kbd> class, and move our code into a new <kbd>AddCatalogContext</kbd> method:</p>
<pre>using Catalog.Infrastructure;<br/>using Microsoft.EntityFrameworkCore;<br/>using Microsoft.Extensions.DependencyInjection;<br/><br/>namespace Catalog.API.Extensions<br/>{<br/>        public static class DatabaseExtensions<br/>        {<br/>            public static IServiceCollection AddCatalogContext(this <br/>                IServiceCollection services)<br/>            {<br/>                return services<br/>                    .AddEntityFrameworkSqlServer()<br/>                    .AddDbContext&lt;CatalogContext&gt;(contextOptions =&gt;<br/>                    {<br/>                        contextOptions.UseSqlServer(<br/>                            "Server=localhost,1433;Initial Catalog=Store;User Id=&lt;SA_USER&gt;;Password=&lt;PASSWORD&gt;",<br/>                            serverOptions =&gt; { <br/>                                serverOptions.MigrationsAssembly<br/> (typeof(Startup).Assembly.FullName); });<br/>                    });<br/>            }<br/>        }<br/>}</pre>
<p>We can simplify the <kbd>Startup</kbd> class as follows:</p>
<pre>   public class Startup<br/>    {<br/>       ...<br/><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>           <strong> services.AddCatalogContext();</strong><br/>            ...<br/>        }<br/>    }</pre>
<p>Now that the <kbd>Startup</kbd> class is ready, execute <kbd>migrations</kbd> in the <kbd>Catalog.API</kbd> project folder using the following commands:</p>
<pre><strong>dotnet ef migrations add InitMigration<br/></strong><strong>dotnet ef database update</strong></pre>
<p class="mce-root">The first command generates the <kbd>Migration</kbd> folder and two different files inside it:</p>
<ul>
<li><kbd>{timestamp}_InitMigration.cs</kbd>: This class creates the tables, constraints, and indexes present in the database.</li>
<li><kbd>CatalogContextModelSnapshot.cs</kbd>: This is formed only on the first migration command and represents the current state of the entities of the service.</li>
</ul>
<p>Every migration class, including the one we just generated, has the following structure:</p>
<pre>using Microsoft.EntityFrameworkCore.Migrations;<br/><br/>namespace Catalog.API.Migrations<br/>{<br/>    public partial class InitMigration : Migration<br/>    {<br/>        protected override void Up(MigrationBuilder migrationBuilder)<br/>        {<br/>          ...<br/>        }<br/><br/>        protected override void Down(MigrationBuilder migrationBuilder)<br/>        {<br/>          ...<br/>        }<br/>    }<br/>}</pre>
<p class="p1">The class contains two methods: <kbd>Up</kbd> and <kbd>Down</kbd>. The <kbd>Up</kbd> method is called during the generation of the database schema. The <kbd>Down</kbd> method is called during the deletion of the schema.</p>
<p>The generated tables and SQL entities are created under the <kbd>catalog</kbd> schema. The <kbd>dotnet ef</kbd> CLI tool will create a new migration class each time we execute the following command:</p>
<pre><strong>dotnet ef migrations add &lt;migration_name&gt;</strong></pre>
<p>The schema of the database will be refreshed every time we run the EF Core update process Core inside our project folder. Therefore, we can proceed by executing the following CLI command in the <kbd>Catalog.API</kbd> project folder:</p>
<pre><strong>dotnet ef database update<br/></strong></pre>
<p>The preceding command creates the SQL schema using the migrations stored in the <kbd>Migration</kbd> folder of the project: it will connect to the database specified in the connection string, which is stored in the <kbd>AddCatalogContext()</kbd> extension method. In the next section, we will examine how to move the specified connection string into the <kbd>appsettings.json</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the configuration part</h1>
                
            
            
                
<p>As discussed in <a href="6127f023-703b-42e3-a76e-b70a7b110b90.xhtml">Chapter 2</a>, <em>Overview of ASP.NET Core</em>, the <kbd>appsettings.json</kbd> file usually contains the application settings. The connection strings are typically stored in that file. Therefore, that kind of approach makes our service more reusable and configurable, especially when it is already running in a staging or production environment. Let's move the connection string from the <kbd>AddCatalogContext</kbd> method to the <kbd>appsettings.json</kbd> file in the following way:</p>
<pre>{<br/>...<br/>  "DataSource": {<br/>   <strong> "ConnectionString": "Server=localhost,1433;Initial Catalog=Store;User Id=catalog_srv;Password=P@ssw0rd"</strong><br/>  }<br/>}</pre>
<p>In this way, we can read the connection string and pass it to <kbd>AddCatalogContext</kbd> as a parameter using the following syntax:</p>
<pre>..<br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>..    services.AddCatalogContext(<strong>Configuration.GetSection("DataSource:ConnectionString").Value</strong>);<br/>  ...<br/>}<br/>..</pre>
<p>Therefore, we need to change the signature of the <kbd>AddCatalogContext</kbd> extension method by adding a <kbd>connectionString</kbd> parameter as follows: </p>
<pre>public static IServiceCollection AddCatalogContext(this IServiceCollection services, string connectionString)</pre>
<p>We can pass the newly defined <kbd>connectionString</kbd> parameter to the <kbd>UseSqlServer</kbd> extension method. In the next section, we will go on to test the repository logic implemented in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the EF Core repository</h1>
                
            
            
                
<p>This section covers some common testing practices used to test .NET Core applications. More specifically, it focuses on testing the repository part of the application. First of all, let's create a new test project by executing the following commands in the root folder of the project (the same folder as the <kbd>.sln</kbd> file): </p>
<pre><strong>mkdir tests</strong><br/><strong>cd tests</strong><br/><br/><strong>dotnet new xunit -n Catalog.Infrastructure.Tests</strong><br/><strong>dotnet sln ../Catalog.API.sln add Catalog.Infrastructure.Tests</strong></pre>
<p>As a result, we have created a new <kbd>tests</kbd> directory, which will contain all the test projects of the service. We also created a new <kbd>Catalog.Infrastructure.Tests</kbd> project using the <kbd>xunit</kbd> template.</p>
<p><kbd>xunit</kbd> is a very popular test framework in the .NET ecosystem, and it is the default choice for testing in .NET Core framework templates. Because we created our project using the <kbd>xunit</kbd> template, the <kbd>Catalog.Infrastructure.Tests.csproj</kbd> file will contain references to the <kbd>xunit</kbd> packages:</p>
<pre>&lt;ItemGroup&gt;<br/>  &lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version=".." /&gt;<br/>  &lt;PackageReference Include="xunit" Version=".." /&gt;<br/>  &lt;PackageReference Include="xunit.runner.visualstudio" Version=".." /&gt;<br/>  &lt;DotNetCliToolReference Include="dotnet-xunit" Version=".." /&gt;<br/>&lt;/ItemGroup</pre>
<p>These packages allow us to run unit tests by using the <kbd>dotnet test</kbd> CLI instruction in the test project folder at the solution level, or by using test runner tools integrated into our preferred IDE, such as Visual Studio or Rider.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Seeding data using DbContext</h1>
                
            
            
                
<p>Let's continue by looking at another EF Core feature, which allows us to seed data. The seeding data technique facilitates testing environments to get a <strong>default</strong> snapshot of our integration test database.</p>
<p>Let's walk through an example of database seeding using .NET Core. First of all, let's create a new <kbd>Data</kbd> folder and add the JSON files that contain the test records. For brevity, I've included both the <kbd>artist.json</kbd> file and the <kbd>genre.json</kbd> file in the same snippet of code:</p>
<pre>// Data/artist.json<br/>[<br/>    {<br/>        "ArtistId": "3eb00b42-a9f0-4012-841d-70ebf3ab7474",<br/>        "ArtistName": "Kendrick Lamar",<br/>        "Items": null<br/>    },<br/>    {<br/>        "ArtistId": "f08a333d-30db-4dd1-b8ba-3b0473c7cdab",<br/>        "ArtistName": "Anderson Paak.",<br/>        "Items": null<br/>    }<br/>]<br/><br/>// Data/genre.json<br/>[<br/>    {<br/>        "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>        "GenreDescription": "Hip-Hop",<br/>        "Items": null<br/>    }<br/>]<br/><br/></pre>
<p>The aforementioned files contain data related to the <kbd>Genre</kbd> and <kbd>Artist</kbd> entities. In the same way, we can proceed by creating a new <kbd>item.json</kbd> file containing information about the <kbd>Item</kbd> entity:</p>
<pre>//item.json<br/>[<br/>    {<br/>        "Id": "86bff4f7-05a7-46b6-ba73-d43e2c45840f",<br/>        "Name": "DAMN.",<br/>        "Description": "DAMN. by Kendrick Lamar",<br/>        "LabelName": "TDE, Top Dawg Entertainment",<br/>        "Price": {<br/>            "Amount": 34.5,<br/>            "Currency": "EUR"<br/>        },<br/>        "PictureUri": "https://mycdn.com/pictures/45345345",<br/>        "ReleaseDate": "2017-01-01T00:00:00+00:00",<br/>        "Format": "Vinyl 33g",<br/>        "AvailableStock": 5,<br/>        "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>        "Genre": null,<br/>        "ArtistId": "3eb00b42-a9f0-4012-841d-70ebf3ab7474",<br/>        "Artist": null<br/>    },<br/>    {<br/>        "Id": "b5b05534-9263-448c-a69e-0bbd8b3eb90e",<br/>        "Name": "GOOD KID, m.A.A.d CITY",<br/>        "Description": "GOOD KID, m.A.A.d CITY. by Kendrick Lamar",<br/>        "LabelName": "TDE, Top Dawg Entertainment",<br/>        "Price": {<br/>            "Amount": 23.5,<br/>            "Currency": "EUR"<br/>        },<br/>        "PictureUri": "https://mycdn.com/pictures/32423423",<br/>        "ReleaseDate": "2016-01-01T00:00:00+00:00",<br/>        "Format": "Vinyl 33g",<br/>        "AvailableStock": 6,<br/>        "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>        "Genre": null,<br/>        "ArtistId": "3eb00b42-a9f0-4012-841d-70ebf3ab7474",<br/>        "Artist": null<br/>    },<br/>    {<br/>        "Id": "be05537d-5e80-45c1-bd8c-aa21c0f1251e",<br/>        "Name": "Malibu",<br/>        "Description": "Malibu. by Anderson Paak",<br/>        "LabelName": "Steel Wool/OBE/Art Club",<br/>        "Price": {<br/>            "Amount": 23.5,<br/>            "Currency": "EUR"<br/>        },<br/>        "PictureUri": "https://mycdn.com/pictures/32423423",<br/>        "ReleaseDate": "2016-01-01T00:00:00+00:00",<br/>        "Format": "Vinyl 43",<br/>        "AvailableStock": 3,<br/>        "GenreId": "c04f05c0-f6ad-44d1-a400-3375bfb5dfd6",<br/>        "Genre": null,<br/>        "ArtistId": "f08a333d-30db-4dd1-b8ba-3b0473c7cdab",<br/>        "Artist": null<br/>    }<br/>]</pre>
<p>These files hold some seed data to add to our database before each test. To read them, we need to include the <kbd>Newtonsoft.Json</kbd> package in the <kbd>Catalog.Infrastructure.Tests</kbd> project using the following command in the project folder:</p>
<pre><strong>dotnet add package Newtonsoft.Json</strong><br/></pre>
<p>We should also ensure that the JSON files are copied to the <kbd>bin</kbd> folder during the compilation step by adding the following code to <kbd>Catalog.Infrastructure.Tests.csproj</kbd>:</p>
<pre>...<br/>&lt;ItemGroup&gt;<br/>  &lt;None Update="Data\artist.json"&gt;<br/>    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>  &lt;/None&gt;<br/>  &lt;None Update="Data\genre.json"&gt;<br/>    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>  &lt;/None&gt;<br/>  &lt;None Update="Data\item.json"&gt;<br/>    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>  &lt;/None&gt;<br/>&lt;/ItemGroup&gt;<br/>..</pre>
<p>The next step is to implement a method to read data from JSON and serialize it in our database context. Also, we should add the <kbd>Microsoft.EntityFrameworkCore</kbd> NuGet package to the test project using the following CLI command:</p>
<pre>dotnet add package Microsoft.EntityFrameworkCore</pre>
<p>The aforementioned package will provide the EF Core <kbd>ModelBuilder</kbd> type, which is used to generate the mock data used by our tests. Since we will use some of the code implemented in the <kbd>Catalog.Infrastructure</kbd> project, we should also add a reference to the test project using the following command in the root of the solution:</p>
<pre><strong>dotnet add ./tests/Catalog.Infrastructure.Tests reference ./src/Catalog.Infrastructure</strong></pre>
<p>After that, we can create a new extension method, named <kbd>Seed&lt;T&gt;</kbd>, inside a new <kbd>Extensions</kbd> folder in the <kbd>Catalog.Infrastructure.Tests</kbd> project:</p>
<pre>using System.IO;<br/>using Microsoft.EntityFrameworkCore;<br/>using Newtonsoft.Json;<br/><br/>namespace Catalog.Infrastructure.Tests.Extensions<br/>{<br/>    public static class ModelBuilderExtensions<br/>    {<br/>        public static ModelBuilder Seed&lt;T&gt;(this ModelBuilder <br/>            modelBuilder, string file) where T : class<br/>        {<br/>            using (var reader = new StreamReader(file))<br/>            {<br/>                var json = reader.ReadToEnd();<br/>                var data = JsonConvert.DeserializeObject&lt;T[]&gt;(json);<br/>              <strong>  modelBuilder.Entity&lt;T&gt;().HasData(data);</strong><br/>            }<br/><br/>            return modelBuilder;<br/>        }<br/>    }<br/>}</pre>
<p>EF Core 2.1 has introduced a new way to perform data seeding in our database by exposing the <kbd>HasData&lt;T&gt;</kbd> method. The preceding code allows us to read a JSON file and serialize it into entities referred by <kbd>modelBuilder</kbd>. This approach provides a way to seed our mock database using the data written in the JSON files.</p>
<p>Finally, we can proceed by creating a new context in the <kbd>Catalog.Infrastructure.Tests</kbd> project named <kbd>TestCatalogContext</kbd>:</p>
<pre>using Microsoft.EntityFrameworkCore;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Infrastructure.Tests.Extensions;<br/><br/>namespace Catalog.Infrastructure.Tests<br/>{<br/>    public class TestCatalogContext : CatalogContext<br/>    {<br/>        public TestCatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)<br/>        {<br/>        }<br/><br/>        protected override void OnModelCreating(ModelBuilder <br/>            modelBuilder)<br/>        {<br/>            base.OnModelCreating(modelBuilder);<br/>            <br/>           <strong> modelBuilder.Seed&lt;Artist&gt;("./Data/artist.json");</strong><br/><strong>            modelBuilder.Seed&lt;Genre&gt;("./Data/genre.json");</strong><br/><strong>            modelBuilder.Seed&lt;Item&gt;("./Data/item.json");</strong><br/>        }<br/>    }<br/>}</pre>
<p>Here, <kbd>TestCatalogContext</kbd> class extends the <kbd>CatalogContext</kbd> class present in the <kbd>Catalog.Infrastructure</kbd> project, and overrides the <kbd>OnModelCreating</kbd> method to call the <kbd>Seed&lt;T&gt;</kbd> extension method on our entities. Consequently, when a consumer initializes the database using <kbd>TestCatalogContext</kbd>, it will have all the prepopulated data written in the JSON.</p>
<p>Note here that the <kbd>TestCatalogContext</kbd> extends the <kbd>DbContextOptions&lt;CatalogContext&gt;</kbd> option in the constructor in order to initialize the <kbd>CatalogContext</kbd> base class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Initializing the testing class</h1>
                
            
            
                
<p>Let's proceed by creating a new testing class in our <kbd>Catalog.Infrastructure.Tests</kbd> project called <kbd>ItemRepositoryTests</kbd>:</p>
<pre>using Xunit;<br/><br/>namespace Catalog.Infrastructure.Tests<br/>{<br/>    public class ItemRepositoryTests<br/>    {<br/>        [Fact]<br/>        public void should_get_data()<br/>        {<br/>            Assert.True(true);<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>Xunit</kbd> framework identifies test classes using the <kbd>Fact</kbd> attribute. Every class that contains a method that has the <kbd>Fact</kbd> attribute or, as we'll see later in this section, the <kbd>Theory</kbd> attribute, will be considered as a test by the unit test runner. </p>
<p>Let's continue by adding our first test method. This checks the <kbd>GetAsync</kbd> method of the <kbd>ItemRepository</kbd> class:</p>
<pre>using System.Threading.Tasks;<br/>using Microsoft.EntityFrameworkCore;<br/>using Shouldly;<br/>using Catalog.Infrastructure.Repositories;<br/>using Xunit;<br/><br/>namespace Catalog.Infrastructure.Tests<br/>{<br/>    public class ItemRepositoryTests<br/>    {<br/>        [Fact]<br/>        public async Task should_get_data()<br/>        {<br/>            var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase(databaseName: "should_get_data")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/>            <br/>            var sut = new ItemRepository(context);<br/>            var result = await sut.GetAsync();<br/><br/>            result.ShouldNotBeNull();<br/>        }<br/>    }<br/>}</pre>
<p>This code initializes a new <kbd>Options</kbd> object using <kbd>DbContextOptionsBuilder&lt;T&gt;</kbd>, which is of the <kbd>CatalogContext</kbd> type. It also uses the <kbd>UseInMemoryDatabase</kbd> extension method to create a new in-memory database instance with a given name. Since <kbd>DbContext</kbd> is extended by the <kbd>CatalogContext</kbd> class, which implements the <kbd>IAsyncDisposable</kbd> type, it is possible to use the <kbd>await using var</kbd> keywords. This approach avoids any type of nesting and provides a cleaner way of reading code, by avoiding the any use of nesting:</p>
<pre>...<br/>    using (var context = new TestCatalogContext(options))<br/>    {<br/>        context.Database.EnsureCreated();<br/>        var sut = new ItemRepository(context);<br/><br/>        var result = await sut.GetAsync();<br/><br/>        result.ShouldNotBeNull();<br/>    }<br/>...</pre>
<p>To build the code, it is necessary to add the following package to the <kbd>Catalog.Infrastructure.Tests</kbd> project:</p>
<pre><strong>dotnet add package Microsoft.EntityFrameworkCore.InMemory</strong></pre>
<p>The <kbd>UseInMemoryDatabase</kbd> extension method is useful for configuring a new in-memory database instance. It is important to note that it is not designed to be a relational database. Furthermore, it doesn't perform any database integrity checks or constraint checks. For more appropriate testing, we should use the in-memory version of SQLite. You can find more information about the SQLite provider in the following documentation: <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite">https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite</a>.</p>
<p class="mce-root">After the creation of a new <kbd>Options</kbd> object, the <kbd>should_get_data</kbd> method creates a new instance of <kbd>TestCatalogContext</kbd>, and calls the <kbd>EnsureCreated()</kbd> method, which ensures that the context exists in the in-memory database. The <kbd>EnsureCreate</kbd> method also implicitly calls the <kbd>OnModelCreating</kbd> method. After that, the test initializes a new <kbd>ItemRepository</kbd> by using the context and executes the <kbd>GetAsync</kbd> method. Finally, it checks the result using <kbd>result.ShouldNotBeNull()</kbd>.</p>
<p>Note that all test examples in this book use <kbd>Shouldly</kbd> as an assertion framework. <kbd>Shouldly</kbd> focuses on giving error messages that are concise and straightforward when an assertion fails. It is possible to avoid the use of <kbd>Shouldly</kbd> by using the default assertion framework built-in to .NET Core. You can find more information about <kbd>Shouldly</kbd> from the following link: <a href="https://github.com/shouldly/shouldly">https://github.com/shouldly/shouldly</a>. It is possible to add the <kbd>Shouldly</kbd> package executing the following CLI instruction in the <kbd>Catalog.Infrastructure.Tests</kbd> project: <kbd>dotnet add package Shouldly</kbd>.</p>
<p>Let's continue by implementing tests for all the methods implemented in the <kbd>ItemRepository</kbd> class:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using Microsoft.EntityFrameworkCore;<br/>using Shouldly;<br/>using Catalog.Infrastructure.Repositories;<br/>using Xunit;<br/><br/>namespace Catalog.Infrastructure.Tests<br/>{<br/>    public class ItemRepositoryTests<br/>    {<br/>        [Fact]<br/>        public async Task should_get_data()<br/>        {<br/>            var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase("should_get_data")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/><br/>            var sut = new ItemRepository(context);<br/>            var result = await sut.GetAsync();<br/><br/>            result.ShouldNotBeNull();<br/>        }<br/><br/>        [Fact]<br/>        public async Task should_returns_null_with_id_not_present()<br/>        {<br/>            var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase(databaseName: <br/>                    "should_returns_null_with_id_not_present")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/><br/>            var sut = new ItemRepository(context);<br/>            var result = await sut.GetAsync(Guid.NewGuid());<br/><br/>            result.ShouldBeNull();<br/>        }<br/><br/>        [Theory]<br/>        [InlineData("b5b05534-9263-448c-a69e-0bbd8b3eb90e")]<br/>        public async Task should_return_record_by_id(string guid)<br/>        {<br/>            var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase(databaseName: <br/>                    "should_return_record_by_id")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/><br/>            var sut = new ItemRepository(context);<br/>            var result = await sut.GetAsync(new Guid(guid));<br/><br/>            result.Id.ShouldBe(new Guid(guid));<br/>        }<br/>...</pre>
<p>The preceding snippet defines tests that cover the <kbd>GetAsync</kbd> methods. The first method, <kbd>should_get_data</kbd>, tests the <kbd>GetAsync()</kbd> overload with no parameters, while the second method tests the <kbd>GetAsync(guid id)</kbd> overload. In both cases, we use <kbd>InMemoryDatabase</kbd> to emulate the underlying data source. In the same <kbd>ItemRepositoryTests</kbd> class, it is also possible to define test cases related to create/update actions:</p>
<pre>...<br/>        [Fact]<br/>        public async Task should_add_new_item()<br/>        {<br/>            var testItem = new Item<br/>            {<br/>                Name = "Test album",<br/>                Description = "Description",<br/>                LabelName = "Label name",<br/>                Price = new Price { Amount = 13, Currency = "EUR" },<br/>                PictureUri = "https://mycdn.com/pictures/32423423",<br/>                ReleaseDate = DateTimeOffset.Now,<br/>                AvailableStock = 6,<br/>                GenreId = new Guid("c04f05c0-f6ad-44d1-a400-3375bfb5dfd6"),<br/>                ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-3b0473c7cdab")<br/>            };<br/>            <br/>            var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase("should_add_new_items")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/><br/>            var sut = new ItemRepository(context);<br/><br/>            sut.Add(testItem);<br/>            await sut.UnitOfWork.SaveEntitiesAsync();<br/><br/>            context.Items<br/>                .FirstOrDefault(_ =&gt; _.Id == testItem.Id)<br/>                .ShouldNotBeNull();<br/>        }<br/><br/>        [Fact]<br/>        public async Task should_update_item()<br/>        {<br/>            var testItem = new Item<br/>            {<br/>                Id = new Guid("b5b05534-9263-448c-a69e-0bbd8b3eb90e"),<br/>                Name = "Test album",<br/>                Description = "Description updated",<br/>                LabelName = "Label name",<br/>                Price = new Price { Amount = 50, Currency = "EUR" },<br/>                PictureUri = "https://mycdn.com/pictures/32423423",<br/>                ReleaseDate = DateTimeOffset.Now,<br/>                AvailableStock = 6,<br/>                GenreId = new Guid("c04f05c0-f6ad-44d1-a400-3375bfb5dfd6"),<br/>                ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-3b0473c7cdab")<br/>            };<br/><br/>            var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase("should_update_item")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/><br/>            var sut = new ItemRepository(context);<br/>            sut.Update(testItem);<br/><br/>            await sut.UnitOfWork.SaveEntitiesAsync();<br/><br/>            context.Items<br/>                .FirstOrDefault(x =&gt; x.Id == testItem.Id)<br/>                ?.Description.ShouldBe("Description updated");<br/>        }<br/>...<br/>}</pre>
<p>Finally, the <kbd>ItemRepositoryTests</kbd> class provides test coverage for all CRUD methods implemented by the <kbd>ItemRepository</kbd> class. The <kbd>should_get_data</kbd>, <kbd>should_returns_null_with_id_not_present</kbd>, and <kbd>should_return_record_by_id</kbd> methods execute the <kbd>GetAsync</kbd> method and check whether the result is what we expect. The <kbd>should_add_new_item</kbd> and <kbd>should_update_item</kbd> test cases provide test coverage for the <kbd>ItemRepository.Add</kbd> and <kbd>ItemRepository.Update</kbd> methods. Both the tests initialize a new record of type <kbd>Item</kbd> and they update the database through the methods exposed by the <kbd>ItemRepository</kbd> type.</p>
<p>As a result, we can run our tests by executing the following command in the <kbd>Catalog.Infrastructure.Tests</kbd> folder:</p>
<pre><strong> dotnet test<br/></strong></pre>
<p>The preceding command executes tests implemented in the project. Therefore, the result will be a report with a list of tests that have succeeded. As an alternative, we can also choose to run tests using the tests runner provided by the IDE. Now that we have completed the data access part using EF Core combined with the code-first approach, we can also take a quick look at Dapper, and how it can be useful by providing a more lighter way to access data. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a data access layer using Dapper</h1>
                
            
            
                
<p>Another standard tool that provides a way to implement a data access layer is Dapper. We have already taken an overview of Dapper<em>,</em> but<em> </em>this section will cover in more detail how to deal with this package and how to use it to implement a data access layer. The following process will be more SQL-heavy. We will also demonstrate how you can deal with some stored CRUD procedures.</p>
<p>Note that EF Core also provides a way to query data sources by using stored procedures. Moreover, it exposes methods such as <kbd>DbSet&lt;TEntity&gt;.FromSql()</kbd> or <kbd>DbContext.Database.ExecuteSqlCommand()</kbd>. So, why use Dapper? As mentioned previously, Dapper is a micro-ORM that is simple and faster than EF Core. EF is more of a multipurpose ORM, and it adds a discrete overhead on each operation performed.</p>
<p>Before starting, let's create another project inside the <kbd>src</kbd> folder called <kbd>Catalog.InfrastructureSP</kbd>, by launching the following command inside the <kbd>src</kbd> folder:</p>
<pre><strong>dotnet new classlib -n Catalog.InfrastructureSP</strong></pre>
<p>After creating the <kbd>Catalog.InfrastructureSP</kbd> project, we need to add it to our solution:</p>
<pre><strong>dotnet sln ../Catalog.API.sln add Catalog.InfrastructureSP</strong></pre>
<p>The preceding command includes the <kbd>Catalog.InfrastructureSP</kbd> project in the solution. Once we have set up our new project containing all the alternative implementation of the data access layer, we can proceed by implementing the core part of the project using a SQL-first approach. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating stored CRUD procedures</h1>
                
            
            
                
<p>In the current example, we use some stored procedures that implement create<em>,</em> read<em>,</em> and update operations. In this book, we will not go into much detail about the SQL server programming model, but it is essential to understand that the code-first approach is not the only way to proceed. Stored procedures are an excellent way to implement interactions between services and a database.</p>
<p>Stored procedures are the best way to interact with databases. Developers can proceed by executing complex queries and calling the procedure name. This modular approach provides some benefits in terms of permission configuration, faster network traffic, and faster execution.</p>
<p>First of all, let's create stored procedures to read data:</p>
<pre>create procedure [catalog].[GetAllItems] <br/>as<br/>begin<br/>   select [Id]<br/>       [Name]<br/>      ,[Description]<br/>      ,[LabelName]<br/>      ,[Price]<br/>      ,[PictureUri]<br/>      ,[ReleaseDate]<br/>      ,[Format]<br/>      ,[AvailableStock]<br/>      ,[GenreId]<br/>      ,[ArtistId]<br/>  from [catalog].[Items]<br/>end</pre>
<p>The first snippet of code defines the <kbd>GetAllItems</kbd> stored procedure. It returns the whole collection of items. For demonstration purposes, the procedure doesn't include any performance optimization. When we perform a <kbd>select</kbd> query on a large table, with a lot of records, it is necessary, at least, to insert a top statement to avoid long-running queries and timeout problems. Moreover, in a real-world application, it is uncommon to see a query without a specific filter. Let's continue by creating the <kbd>GetItemById</kbd> procedure:</p>
<pre>create procedure [catalog].[GetItemById] <br/>   @Id uniqueidentifier<br/>as<br/>begin<br/>   select [Id]<br/>       [Name]<br/>      ,[Description]<br/>      ,[LabelName]<br/>      ,[Price]<br/>      ,[PictureUri]<br/>      ,[ReleaseDate]<br/>      ,[Format]<br/>      ,[AvailableStock]<br/>      ,[GenreId]<br/>      ,[ArtistId]<br/>  from [catalog].[Items] <br/>  where Id = @Id<br/>end</pre>
<p>These two procedures are quite simple. The first one selects all the records from the <kbd>catalog. Item</kbd> table. The second one accepts an <kbd>Id</kbd> as the parameter and allows us to retrieve just the corresponding record.</p>
<p>The next step is to implement operations to do with creating and updating a record. Both implementations are quite simple – the <kbd>InsertItem</kbd> and <kbd>UpdateItem</kbd> stored procedures wrap <kbd>insert</kbd> and <kbd>update</kbd> SQL statements:</p>
<pre>create procedure [catalog].[InsertItem] (<br/> @Id uniqueidentifier,<br/> @Name nvarchar(max),<br/> @Description nvarchar(1000),<br/> @LabelName nvarchar(max) NULL,<br/> @Price nvarchar(max) NULL,<br/> @PictureUri nvarchar(max) NULL,<br/> @ReleaseDate datetimeoffset(7),<br/> @Format nvarchar(max) ,<br/> @AvailableStock int,<br/> @GenreId uniqueidentifier,<br/> @ArtistId uniqueidentifier<br/>)<br/>as<br/>begin<br/>  insert into  [catalog].[Items]  (Id, Name, Description,LabelName,Price,PictureUri, ReleaseDate,<br/>  Format,AvailableStock, GenreId,ArtistId)<br/> <strong> output inserted.*</strong><br/>  values   (@Id,<br/>            @Name,<br/>            @Description,<br/>            @LabelName,<br/>            @Price,<br/>            @PictureUri,<br/>            @ReleaseDate,<br/>            @Format,<br/>            @AvailableStock,<br/>            @GenreId,<br/>            @ArtistId)<br/>end<br/></pre>
<p>The <kbd>InsertItem</kbd> stored procedure executes a simple <kbd>insert</kbd> statement on the database by accepting data as parameters of the stored procedure. Let's proceed by defining the <kbd>UpdateItem</kbd> stored procedure: </p>
<pre>create procedure [catalog].[UpdateItem] (<br/> @Id uniqueidentifier,<br/> @Name nvarchar(max),<br/> @Description nvarchar(1000),<br/> @LabelName nvarchar(max) NULL,<br/> @Price nvarchar(max),<br/> @PictureUri nvarchar(max) NULL,<br/> @ReleaseDate datetimeoffset(7) NULL,<br/> @Format nvarchar(max) ,<br/> @AvailableStock int,<br/> @GenreId uniqueidentifier,<br/> @ArtistId uniqueidentifier<br/>)<br/>as<br/>begin<br/>  update [catalog].[Items]<br/>  set Name = @Name,<br/>      Description = @Description,<br/>      LabelName = @LabelName,<br/>      Price = @Price,<br/>      PictureUri = @PictureUri,<br/>      ReleaseDate = @ReleaseDate,<br/>      Format = @Format,<br/>      AvailableStock = @AvailableStock,<br/>      GenreId = @GenreId,<br/>      ArtistId = @ArtistId<br/>   <strong>output inserted.*</strong><br/>   where Id = @Id<br/>end</pre>
<p>Note that both operations use the <kbd>output</kbd> statement to retrieve the inserted, or updated, record as a result of the execution. In that way, we can retrieve the updated record from our repository pattern without extra effort.</p>
<p>Microsoft SQL Server provides a way to return inserted or deleted data using the <em>output</em> operator. It returns information from, or expressions based on, each row affected by an <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, <kbd>DELETE</kbd>, or <kbd>MERGE</kbd> statement. </p>
<p>Finally, to get these scripts working, it is necessary to execute them in our database. I suggest using the previously mentioned SQL Operations Studio tool or another SQL client to run these scripts in the <kbd>Catalog</kbd> database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the IItemRepository interface</h1>
                
            
            
                
<p>In <em>Implementing the data access layer using EF Core</em> section, we used two different interfaces to get the jobs done: <kbd>IItemRepository</kbd>, which contains all the CRUD operations, and <kbd>IUnitOfWork</kbd>, which covers the unit of work pattern. For each CRUD operation, we need to call the <kbd>IUnitOfWork</kbd> interface to save our changes in the database. On the other hand, the application of Dapper as a micro-ORM doesn't need to provide a unit of work interface because ORM executes queries directly on the database using the stored procedures. For that reason, we don't need to implement the <kbd>IRepository</kbd> interface anymore and, consequently, we will not implement the <kbd>IUnitOfWork</kbd> interface either.</p>
<p>So, as a first step, we should remove the <kbd>IRepository</kbd> interface implementation from our <kbd>IItemRepository</kbd> interface. Also, in this case, we can see the real power of dependency inversion: <kbd>Catalog.Domain</kbd> does not depend on <kbd>Catalog.Infrastructure</kbd><em>.</em> It can also change the contract and requirements, and it forces <kbd>Catalog.Infrastructure</kbd> to alter its behavior:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Infrastructure.Entities;<br/><br/>namespace Catalog.Domain.Infrastructure.Repositories<br/>{<br/>    public interface IItemsRepository  <br/>    {<br/>        Task&lt;IEnumerable&lt;Item&gt;&gt; GetAsync();<br/>        Task&lt;Item&gt; GetAsync(Guid id);<br/>        Item Add(Item order);<br/>        Item Update(Item item);<br/>        Item Delete(Item item);<br/>    }<br/>}</pre>
<p>The next step is to add Dapper to our <kbd>Catalog.InfrastructureSP</kbd> project by executing the following command:</p>
<pre><strong> dotnet add package Dapper</strong></pre>
<p>Let's proceed by implementing the <kbd>IItemRepository</kbd> interface using the <kbd>ItemRepository</kbd> class in the <kbd>Catalog.InfrastructureSP</kbd> project:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Data;<br/>using System.Data.SqlClient;<br/>using System.Threading.Tasks;<br/>using Dapper;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Infrastructure.Repositories;<br/><br/>namespace Catalog.InfrastructureSP<br/>{<br/>    public class ItemRepository : IItemRepository<br/>    {<br/>        private readonly SqlConnection _sqlConnection;<br/><br/>        public ItemRepository(string connectionString)<br/>        {<br/><br/>            _sqlConnection = new SqlConnection(connectionString);<br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;Item&gt;&gt; GetAsync()<br/>        {<br/>            var result = await _sqlConnection.QueryAsync&lt;Item&gt;<br/>                ("GetAllItems",  commandType: <br/>                CommandType.StoredProcedure);<br/>            return result.AsList();<br/>        }<br/><br/>        public async Task&lt;Item&gt; GetAsync(Guid id)<br/>        {<br/>            return await _sqlConnection.ExecuteScalarAsync&lt;Item&gt;<br/>                ("GetAllItems", new {Id = id.ToString()}, commandType: <br/>                CommandType.StoredProcedure);<br/>        }<br/><br/>        public Item Add(Item order)<br/>        {<br/>            var result = _sqlConnection.ExecuteScalar&lt;Item&gt;<br/>            ("InsertItem", order, commandType:CommandType.StoredProcedure);<br/>            return result;<br/>        }<br/><br/>        public Item Update(Item item)<br/>        {<br/>            var result = _sqlConnection.ExecuteScalar&lt;Item&gt;<br/>                ("UpdateItem", item, commandType: <br/>                CommandType.StoredProcedure);<br/>            return result;<br/>        }<br/><br/>        public Item Delete(Item item)<br/>        {<br/>            throw new NotImplementedException();<br/>        }<br/>    }<br/>}</pre>
<p>To initialize our concrete class, it is necessary to pass <kbd>connectionString</kbd> to the SQL database in the constructor of the <kbd>ItemRepository</kbd> class.</p>
<p>As you can see, the Dapper approach is entirely different from EF Core. It doesn't add any particular overhead to our data source; it merely executes the aforementioned stored procedures by filling the requested parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter described you how to build a data access layer using EF Core and Dapper. It also showed you how to build unit tests using the in-memory database, and how to execute migrations with EF Core. I want to reiterate that the choice between EF Core and Dapper depends on different parameters: what kind of service we are building, the skills of our team members, and the type of infrastructure we're using.</p>
<p>The topics covered in this chapter provide the necessary knowledge to access data sources in .NET Core, using a code-first approach and also the stored-procedure approach. The chapter covered the use of technologies such as EF Core and Dapper. Additionally, it showed you how to test the data access layer using the in-memory approach.</p>
<p>In the next chapter, we will demonstrate how to implement handlers and the logic of our services. </p>


            

            
        
    </body></html>