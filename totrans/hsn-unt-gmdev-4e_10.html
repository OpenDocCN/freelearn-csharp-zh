<html><head></head><body>
  <div><h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-117" class="chapterTitle">Victory or Defeat: Win and Lose Conditions</h1>
    <p class="normal">Now that we have a basic gameplay experience, it’s time to make the game end with the outcomes of winning or losing. One common way to implement this is through separated components with the responsibility of overseeing a set of objects to detect certain situations that need to happen, such as the player’s life becoming 0 or all of the waves being cleared. We will implement this through the concept of <strong class="screenText">managers</strong>, components that will manage and monitor several objects.</p>
    <p class="normal">In this chapter, we will examine the following manager concepts:</p>
    <ul>
      <li class="bulletList">Creating object managers</li>
      <li class="bulletList">Creating game modes</li>
      <li class="bulletList">Improving our code with events</li>
    </ul>
    <p class="normal">With this knowledge, you will be able to not only create the victory and loss conditions of the game but also do this in a properly structured way using design patterns such as <strong class="keyWord">Singleton</strong> and <strong class="keyWord">Event Listeners</strong>. These skills are not only useful for creating the winning and losing code of the game but any code in general. First, let’s begin by creating managers to represent concepts such as score or game rules.</p>
    <h1 id="_idParaDest-118" class="heading-1">Creating object managers</h1>
    <p class="normal">Not every<a id="_idIndexMarker417"/> object in your Scene should be something that can be seen, heard, or collided with. Some objects can also exist with a conceptual meaning, not something tangible. For example, imagine you need to keep a count of the number of enemie­s: where do you save that? You also need some place to save the current score of the player, and you may be thinking it could be on the player itself, but what happens if the player dies and respawns?</p>
    <p class="normal">The data<a id="_idIndexMarker418"/> would be lost! In such scenarios, the concept of a <strong class="screenText">manager</strong> can be a useful way of solving this in our first games, so let’s explore it.</p>
    <p class="normal">In this section, we are going to see the following object manager concepts:</p>
    <ul>
      <li class="bulletList">Sharing variables with the Singleton design pattern</li>
      <li class="bulletList">Sharing variables in Visual Scripting</li>
      <li class="bulletList">Creating managers</li>
    </ul>
    <p class="normal">We will start by discussing what the Singleton design pattern is and how it helps us simplify the communication of objects. With it, we will create manager objects that allow us to centralize information about a group of objects, among other things. Let’s start by discussing the Singleton design pattern.</p>
    <h2 id="_idParaDest-119" class="heading-2">Sharing variables with the Singleton design pattern</h2>
    <p class="normal">Design patterns<a id="_idIndexMarker419"/> are usually described as common solutions to common problems. There are several coding <a id="_idIndexMarker420"/>design decisions you will have to make while you code your game, but luckily, the ways to tackle the most common situations are well known and documented. In this section, we are going to discuss one of the most common design patterns, <strong class="keyWord">Singleton</strong>, a convenient one to implement in simple projects.</p>
    <p class="normal">The <a id="_idIndexMarker421"/>Singleton pattern is used when we need a single instance of an object, meaning that there shouldn’t be more than one instance of a class and that we want it to be easily accessible (not necessary, but useful in our scenario). We have plenty of cases in our game where this can be applied, for example, <code class="inlineCode">ScoreManager</code>, a component that will hold the current score. In this case, we will never have more than one score, so we can take advantage of the benefits of the Singleton manager here.</p>
    <p class="normal">One benefit is being sure that we won’t have duplicated scores, which makes our code less error-prone. Also, so far, we have needed to create public references and drag objects via the editor to connect two objects, or look for them using <code class="inlineCode">GetComponent</code>; with this pattern, however, we will have global access to our Singleton component, meaning you can just write the name of the component in your script and you will access it. In the end, there’s just one <code class="inlineCode">ScoreManager</code> component, so specifying one via the editor is redundant. This is similar to <code class="inlineCode">Time.deltaTime</code>, the class responsible for managing time—we have just one time.</p>
    <p class="normal">If you are an advanced programmer, you may be thinking about code testing and dependency<a id="_idIndexMarker422"/> injection now, and you are right, but remember, we are trying to write simple code so far, so we<a id="_idIndexMarker423"/> will stick to this simple solution.</p>
    <p class="normal">Let’s create a <strong class="screenText">Score Manager</strong> object, responsible for handling the score, to show an example of a Singleton by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an empty GameObject (<strong class="screenText">GameObject | Create Empty</strong>) and call it <code class="inlineCode">ScoreManager</code>; usually, managers are put in empty objects, separated from the rest of the Scene’s objects.</li>
      <li class="numberedList">Add a script called <strong class="screenText">ScoreManager</strong> to this object with an <strong class="screenText">int</strong> field called <strong class="screenText">amount</strong> that will hold the current score.</li>
      <li class="numberedList">Add a field of the <strong class="screenText">ScoreManager</strong> type called <strong class="keyWord">instance</strong>, but add the <strong class="keyWord">static</strong> keyword to it; this will make the variable global, meaning it can be accessed anywhere by just writing its name:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_01_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.1: A static field that can be accessed anywhere in the code</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In <strong class="screenText">Awake</strong>, check whether the <strong class="screenText">instance</strong> field is not <code class="inlineCode">null</code>, and in that case, set this <strong class="screenText">ScoreManager</strong> instance as the instance reference using the <strong class="screenText">this</strong> reference.</li>
      <li class="numberedList">In the <code class="inlineCode">else</code> clause of the <code class="inlineCode">null</code> checking <code class="inlineCode">if</code> statement, print a message indicating that there’s a second <strong class="screenText">ScoreManager</strong> instance that must be destroyed:
    <figure class="mediaobject"><img src="img/B21361_08_02_PE.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.2: Checking whether there’s only one Singleton instance</p>
    <p class="normal">The<a id="_idIndexMarker424"/> idea is to<a id="_idIndexMarker425"/> save the reference to the only <strong class="screenText">ScoreManager</strong> instance in the <code class="inlineCode">instance</code> static field, but if by mistake the user creates two objects with the <strong class="screenText">ScoreManager</strong> component, this <code class="inlineCode">if</code> statement will detect it and inform the user of the error, asking them to take action. In this scenario, the first <strong class="screenText">ScoreManager</strong> instance to execute <strong class="screenText">Awake</strong> will find that there’s no instance set (the field is <code class="inlineCode">null</code>) so it will set itself as the current instance, while the second <strong class="screenText">ScoreManager</strong> instance will find the instance is already set and will print the message.</p>
    <p class="normal">Remember that <code class="inlineCode">instance</code> is a static field, shared between all classes, unlike regular reference fields, where each component will have its own reference, so in this case, we have two <code class="inlineCode">ScoreManager</code> instances added to the scene, and they will share the same instance field.</p>
    <p class="normal">To improve the example a little bit, it would be ideal to have a simple way to find the second <code class="inlineCode">ScoreManager</code> in the game. It will be hidden somewhere in the Hierarchy and it may be difficult to find, but we fix this by doing the following:</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Replace <code class="inlineCode">print</code> with <code class="inlineCode">Debug.Log</code>. <code class="inlineCode">Debug.Log</code> is similar to <code class="inlineCode">print</code> but has a second <a id="_idIndexMarker426"/>argument <a id="_idIndexMarker427"/>that expects an object to be highlighted when the message is clicked in the console. In this case, we will pass the <code class="inlineCode">gameObject</code> reference to allow the console to highlight the duplicated object:
    <figure class="mediaobject"><img src="img/B21361_08_03_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 8.3: Printing messages in the console with Debug.Log</p>
    <p class="normal">After clicking the log message, the GameObject containing the duplicated <code class="inlineCode">ScoreManager</code> will be highlighted in the Hierarchy:</p>
    <figure class="mediaobject"><img src="img/B21361_08_04_PE.png" alt="A screen shot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.4: The highlighted object after clicking the message</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Finally, a little improvement can be made here by replacing <code class="inlineCode">Debug.Log</code> with <code class="inlineCode">Debug.LogError</code>, which will also print the message but with an error icon. In a real game, you will have lots of messages in the console, and highlighting the errors over the information messages will help us to identify them quickly:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_05_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 8.5: Using LogError to print an error message</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Try the code and observe the error message in the console:
    <figure class="mediaobject"><img src="img/B21361_08_06_PE.png" alt="A screenshot of a computer error message  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.6: An error message in the console</p>
    <p class="normal">The <a id="_idIndexMarker428"/>next<a id="_idIndexMarker429"/> step would be to use this Singleton object somewhere, so in this case, we will make the enemies give points when they are killed by doing the following:</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">Add a script to the <code class="inlineCode">Enemy</code> Prefab called <code class="inlineCode">ScoreOnDeath</code> with an <code class="inlineCode">int</code> field called <code class="inlineCode">amount</code>, which will indicate the number of points the enemy will give when killed. Remember to set the value to something other than <code class="inlineCode">0</code> in the editor for the Prefab.</li>
      <li class="numberedList">Create the <code class="inlineCode">OnDestroy</code> event function, which will be automatically called by Unity when this object is destroyed – in our case, the enemy:
    <figure class="mediaobject"><img src="img/B21361_08_07_PE.png" alt="A picture containing text, font, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.7: The OnDestroy event function</p>
    <p class="normal">Consider that the <code class="inlineCode">OnDestroy</code> function is also called when we change scenes or the game is quitting, so in this scenario, we might get points when changing scenes, which is not correct. So far, this is not a problem in our case, but later in this chapter, we will see a way to prevent this.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="11">Access the <a id="_idIndexMarker430"/>Singleton reference in the <code class="inlineCode">OnDestroy</code> function by writing <code class="inlineCode">ScoreManager.instance</code>, and add the <code class="inlineCode">amount</code> field of our script to the <code class="inlineCode">amount</code> field of the Singleton to increase the score when an enemy is killed:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_08_PE.png" alt="A screen shot of a computer code  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.8: Full ScoreOnDeath component class contents</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="12">Select <code class="inlineCode">ScoreManager</code> in the Hierarchy, hit <strong class="screenText">Play</strong>, and kill some enemies to see the score rise with every kill. Remember to set the <code class="inlineCode">amount</code> field of the <code class="inlineCode">ScoreOnDeath</code> component of the Prefab.</li>
    </ol>
    <p class="normal">As you can <a id="_idIndexMarker431"/>see, the Singleton pattern has simplified the way we access <code class="inlineCode">ScoreManager</code> and have security measures to prevent duplicates of itself a lot, which will help us to reduce errors in our code. Something to take into account is that now you will be tempted to just make everything a Singleton, such as the player’s life or player’s bullets, and just to make your life easier when creating gameplay mechanics such as power-ups.</p>
    <p class="normal">While that will totally work, remember that your game will change, and I mean change a lot; any real project will experience constant change. Maybe today, the game has just one player, but in the future, you may want to add a second player or an AI companion, and you’ll want the<a id="_idIndexMarker432"/> power-ups to affect them too. If you abuse the Singleton pattern, you will have trouble handling those scenarios and many more. Maybe a future player companion will try to get the health pickup but the main player will be healed instead!</p>
    <p class="normal">The point here is to try to use the pattern as few times as you can, in case you don’t have any other way to solve the problem. To be honest, there are always ways to solve problems without Singleton, but they are a little bit more difficult to implement for beginners, so<a id="_idIndexMarker433"/> I prefer to simplify your life a little bit to keep you motivated. With enough practice, you will reach a point where you will be ready to improve your coding standards.</p>
    <div><p class="normal">There are lots of design patterns out there to help you design your game. Once you get comfortable with Unity scripting, we recommend reading the following Unity official game programming patterns book: <a href="https://resources.unity.com/games/level-up-your-code-with-game-programming-patterns">https://resources.unity.com/games/level-up-your-code-with-game-programming-patterns</a>. This book also includes an advanced implementation of Singleton.</p>
    </div>
    <p class="normal">Now, let’s discuss how to achieve this in Visual Scripting, which deserves its own section given that it will be a little bit different. You may consider skipping the following section if you are not interested in the Visual Scripting side of these scripts.</p>
    <h2 id="_idParaDest-120" class="heading-2">Sharing variables with Visual Scripting</h2>
    <p class="normal">Visual Scripting <a id="_idIndexMarker434"/>has a mechanism<a id="_idIndexMarker435"/> that replaces Singleton as a holder of variables to be shared between objects: <strong class="screenText">scene variables</strong>. If you check the left panel in the <strong class="screenText">Script Graph</strong> editor (the window where we edit the nodes of a script) under the <code class="inlineCode">Blackboard</code> panel (the panel that shows the variables of our object), you will notice it will have many tabs: <strong class="screenText">Graph, Object, Scene, App</strong>, and <strong class="screenText">Saved</strong>. If you don’t see the <strong class="screenText">Blackboard</strong> panel, click the third button from left to right in the top-left part of the window – the button at the right of the <strong class="screenText">i </strong>(information) button:</p>
    <figure class="mediaobject"><img src="img/B21361_08_09_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.9: Blackboard (variables) editor in Script Graph</p>
    <p class="normal">So far, when<a id="_idIndexMarker436"/> we created a variable in<a id="_idIndexMarker437"/> the <strong class="screenText">Variables</strong> component of any object, we were actually creating <strong class="screenText">Object Variables</strong>: variables that belong to an object and are shared between all Visual Scripts in that object, but that’s not the only scope a variable can have. Here’s a list of the remaining scopes:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Graph</strong>: Variables that can only be accessed by our current graph. No other script can read or write that variable. This is useful to save internal state, like private variables in C#.</li>
      <li class="bulletList"><strong class="keyWord">Scene</strong>: Variables that can be accessed by all objects in the current scene. When we change the scene, those variables are lost.</li>
      <li class="bulletList"><strong class="keyWord">App</strong>: Variables that can be accessed in any part of the game at any time. This is useful to move values from one scene to another. For example, you can increase the score in one level and keep increasing it in the next, instead of restarting the score from 0.</li>
      <li class="bulletList"><strong class="keyWord">Saved</strong>: Variables whose values are kept between game runs. You can save persistent data such as the Player Level or Inventory to continue the quest, or simpler things such as the sound volume as set by the user in the <strong class="screenText">Options</strong> menu (if you created one).</li>
    </ul>
    <p class="normal">In this case, the <strong class="screenText">Scene</strong> scope is the one we want, as the score we intend to increase will be accessed by <a id="_idIndexMarker438"/>several objects in the scene (more on that later) and we don’t want it to persist if we reset the level to play again; it will need to be set again to 0 in each run of the level and game.</p>
    <p class="normal">To create<a id="_idIndexMarker439"/> scene variables, you can simply select the <strong class="screenText">Scene</strong> tab in the <strong class="screenText">Blackboard</strong> pane of the <strong class="screenText">Script Graph</strong> editor while you are editing any script graph, or you can also use the <strong class="screenText">Scene Variables</strong> GameObject that was created automatically when you started editing any graph. That object is the one that really holds the variables and must not be deleted. You will notice that it will have a <strong class="screenText">Variables</strong> component as we have used before, but it will also have the <strong class="screenText">Scene Variables</strong> component, indicating those variables are scene variables.</p>
    <p class="normal">In the following screenshot, you can see how we have simply added the <strong class="screenText">score</strong> variable to the <strong class="screenText">Scene Variables </strong>tab to make it accessible in any of our script graphs.</p>
    <figure class="mediaobject"><img src="img/B21361_08_10_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.10: Adding scene variables to our game</p>
    <p class="normal">Finally, for the score-increasing behavior, we can add the following graph to our enemy. Remember, as <a id="_idIndexMarker440"/>usual, to have the C# or the<a id="_idIndexMarker441"/> Visual Scripting version of the scripts, not both.</p>
    <figure class="mediaobject"><img src="img/B21361_08_11_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.11: Adding score when this object is destroyed</p>
    <p class="normal">At first, this script seems pretty similar to our C# version; we add the <code class="inlineCode">s</code><strong class="screenText">coreToAdd</strong> variable of our object (<strong class="screenText">Object</strong> scope) and then we add it to the whole scene’s <code class="inlineCode">score</code> variable, as specified in the node. The main difference you can see is that here we are using the <strong class="screenText">On Disable </strong>event instead of <strong class="screenText">OnDestroy.</strong> Actually, <strong class="screenText">OnDestroy</strong> is the correct one, but in the current version of Visual Scripting, there is a bug that prevents it from working properly, so I replaced it for now. The problem with <strong class="screenText">On Disable</strong> is that it executes whenever the object is disabled, and while the object is disabled before it is destroyed, it can also be disabled in other circumstances (for example, using <strong class="keyWord">Object Pooling</strong>, a way to recycle objects instead of destroying and instancing them constantly), but so far it is enough for us. Please consider trying with <strong class="screenText">OnDestroy</strong> first when you try this graph to see if it runs properly in your Unity or Visual Scripting package version.</p>
    <p class="normal">Something to highlight is the usage of the <strong class="screenText">Has Variable</strong> node to check if the <strong class="screenText">score</strong> variable exists. This is done because <strong class="screenText">OnDisable</strong> can be executed either at the moment the enemy is destroyed or when the scene changes, which we will do later in this chapter <a id="_idIndexMarker442"/>with the lose/win screen. If <a id="_idIndexMarker443"/>we try to get a Scene variable at that moment, we risk getting an error if the <strong class="screenText">Scene Variables</strong> object is destroyed before the <strong class="screenText">GameMode</strong> object, given the change of Scene involves destroying every object in the Scene first.</p>
    <p class="normal">As you may have noticed by now, even though Visual Scripting is mostly extremely similar to C#, one has concepts to solve certain scenarios that the other doesn’t. Now that we know how to share variables, let’s finish some other managers that we will need later in the game.</p>
    <h2 id="_idParaDest-121" class="heading-2">Creating managers</h2>
    <p class="normal">Sometimes, we need a <a id="_idIndexMarker444"/>place to put together information about a group of similar objects, for example, <code class="inlineCode">EnemyManager</code>, to check the number of enemies and potentially access an array of them to iterate over them and do any extra gameplay implementation we want, for instance making our <code class="inlineCode">MissionManager</code>, to have access to all of the active missions in our game. Again, these cases can be considered Singletons, single objects that won’t be repeated (in our current game design), so let’s create the ones we will need in our game, that is, <code class="inlineCode">EnemyManager</code> and <code class="inlineCode">WaveManager</code>.</p>
    <p class="normal">In our game, <code class="inlineCode">EnemyManager</code> and <code class="inlineCode">WaveManager</code> will just be used as places to save an array of references to the existing enemies and waves in our game, just as a way to know their current amount. There are ways to search all objects of a certain type to calculate their count, but those functions are expensive and not recommended for use unless you really know what you are doing. So, having a manager implemented as a Singleton, with a separate updated list of references to the target object type will require more code but will perform better. Also, as the game features increase, these managers will have more functionality and helper functions to interact with those objects.</p>
    <p class="normal">Let’s start with<a id="_idIndexMarker445"/> the enemies manager by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add a script called <code class="inlineCode">Enemy</code> to the <strong class="screenText">Enemy</strong> Prefab; this will be the script that will connect this object with <code class="inlineCode">EnemyManager</code> in a moment.</li>
      <li class="numberedList">Create an empty <code class="inlineCode">GameObject</code> called <code class="inlineCode">EnemyManager</code> and add a script to it called <code class="inlineCode">EnemiesManager</code>.</li>
      <li class="numberedList">Create a <code class="inlineCode">public</code> static field of the <code class="inlineCode">EnemiesManager</code> type called <code class="inlineCode">instance</code> inside the script and add the Singleton repetition check in <code class="inlineCode">Awake</code> as we did in <code class="inlineCode">ScoreManager</code>.</li>
      <li class="numberedList">Create<a id="_idIndexMarker446"/> a public field of the <code class="inlineCode">List&lt;Enemy&gt;</code> type called <code class="inlineCode">enemies</code>:
    <figure class="mediaobject"><img src="img/B21361_08_12_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 8.12: List of Enemy components</p>
    <p class="normal">A list in C# represents a dynamic array, an array capable of adding and removing objects. You will see that you can add and remove elements to and from this list in the editor, but keep the list empty; we will add enemies another way. Take into account that <code class="inlineCode">List</code> is in the <code class="inlineCode">System.Collections.Generic</code> namespace; you will find the <code class="inlineCode">using</code> sentence at the beginning of our script. Also, consider that you can make the list private and expose it to the code via a getter instead of making it a public field; but as usual, we will make our code as simple as possible for now:</p>
    <figure class="mediaobject"><img src="img/B21361_08_13_PE.png" alt="A picture containing text, font, white, screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.13: Using needed to use the List class, inside System.Collections.Generic</p>
    <p class="normal">Consider that <code class="inlineCode">List</code> is a class type, so it must be instantiated, but as this type has exposing support in the editor, Unity will automatically instantiate it. You must use the <code class="inlineCode">new</code> keyword to instantiate it in cases where you want a non-editor-exposed list, such as a private one or a list in a regular non-component C# class.</p>
    <p class="normal">The C# list internally is implemented as an array. If you need a linked list, use the <strong class="screenText">LinkedList</strong> collection type instead.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">In the <code class="inlineCode">Start</code> function of the <code class="inlineCode">Enemy</code> script, access the <code class="inlineCode">EnemyManager</code> Singleton and, using the <code class="inlineCode">Add</code> function of the enemies list, add this object to the list. This will “register” this enemy as active in the manager, so other objects can access the manager and check for the current enemies. The <code class="inlineCode">Start</code> function is called after<a id="_idIndexMarker447"/> all of the <code class="inlineCode">Awake</code> function calls, and this is important because we need to be sure that the <code class="inlineCode">Awake</code> function of the manager is executed prior to the <code class="inlineCode">Start</code> function of the enemy to ensure that there is a manager set as the instance.
    <p class="normal">The problem we solved with the <code class="inlineCode">Start</code> function is called a race condition, that is, when two pieces of code are not guaranteed to be executed in the same order, whereas the <code class="inlineCode">Awake</code> execution order can change due to different reasons. There are plenty of situations in code where this will happen, so pay attention to the possible race conditions in your code. Also, you might consider using more advanced solutions such as lazy initialization here, which can give you better stability, but again, for the sake of simplicity and exploring the Unity API, we will use the <code class="inlineCode">Start</code> function approach for now.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">In the <code class="inlineCode">OnDestroy</code> function, remove the enemy from the list to keep the list updated with just the active ones:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_14_PE.png" alt="A screen shot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.14: The enemy script to register ourselves as an active enemy</p>
    <p class="normal">With this, now we<a id="_idIndexMarker448"/> have a centralized place to access all of the active enemies in a simple but efficient way. I challenge you to do the same with the waves, using <strong class="screenText">WaveManager</strong>, which will have the collection of all active waves to later check whether all waves finished their work to consider the game as won. </p>
    <p class="normal">Take some time to solve this; you will find the solution in the following screenshots, starting with <strong class="screenText">WavesManager</strong>:</p>
    <figure class="mediaobject"><img src="img/B21361_08_15_PE.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.15: The full WavesManager script</p>
    <p class="normal">You will also<a id="_idIndexMarker449"/> need the <code class="inlineCode">WaveSpawner</code> script:</p>
    <figure class="mediaobject"><img src="img/B21361_08_16_PE.png" alt="A screenshot of a computer code  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.16: The modified WaveSpawner script to support WavesManager</p>
    <p class="normal">As you can <a id="_idIndexMarker450"/>see, <code class="inlineCode">WavesManager</code> is created the same way <code class="inlineCode">EnemyManager</code> was – just a Singleton with a list of <code class="inlineCode">WaveSpawner</code> references, but <code class="inlineCode">WaveSpawner</code> is different. We execute the <code class="inlineCode">Add</code> function of the list in the <code class="inlineCode">Start</code> event of <code class="inlineCode">WaveSpawner</code> to register the wave as an active one, but the <code class="inlineCode">Remove</code> function needs more work.</p>
    <p class="normal">The idea is <a id="_idIndexMarker451"/>to deregister the wave from the active waves list when the spawner finishes its work. Before this modification, we used <code class="inlineCode">Invoke</code> to call the <code class="inlineCode">CancelInvoke</code> function after a while to stop the spawning, but now we need to do more after the end time.</p>
    <p class="normal">Instead of calling <code class="inlineCode">CancelInvoke</code> after the specified wave end time, we will call a custom function called <code class="inlineCode">EndSpawner</code>, which will call <code class="inlineCode">CancelInvoke</code> to stop the spawner, <code class="inlineCode">Invoke Repeating</code>, but also will call the remove-from-<code class="inlineCode">WavesManager</code>-list function to make sure the removing-from-the-list function is called exactly when <code class="inlineCode">WaveSpawner</code> finishes its work.</p>
    <p class="normal">Regarding the Visual Scripting version, we can add two lists of the GameObject type to the Scene variables to hold the references to the existing waves and enemies so we can keep track of them. Just search <code class="inlineCode">List of GameObject</code> in the search bar of the variable type selector and you will find it. In this case, the lists contain only GameObjects given that the Visual Scripting versions of <code class="inlineCode">WaveSpawner</code> and enemy scripts are not types we can reference like C# ones. If you did both C# and Visual Scripting versions of these, you will see you can reference the C# versions, but we are not going to mix C# and Visual Scripting as it is out of the scope of the book, so ignore them. Anyway, given how the <strong class="screenText">Variables</strong> system of Visual Scripting works, we can still access variables inside if needed using the <strong class="screenText">GetVariable</strong> node—remember the variables are not in the Visual Scripts but in the <strong class="screenText">Variables</strong> node:</p>
    <figure class="mediaobject"><img src="img/B21361_08_17_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.17: Adding lists to the Scene variables</p>
    <p class="normal">Then, we can<a id="_idIndexMarker452"/> add the following to the <strong class="screenText">WaveSpawner</strong> graph:</p>
    <figure class="mediaobject"><img src="img/B21361_08_18_PE.png" alt="A picture containing text, screenshot, font, diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.18: Adding elements to List</p>
    <p class="normal">We used<a id="_idIndexMarker453"/> the <strong class="screenText">Add List Item</strong> node to add our GameObject to the <strong class="screenText">waves</strong> variable. We did this as the first thing to do in the <strong class="screenText">On Start</strong> event node before anything. And to remove that wave from the active ones, you will need to make the following change:</p>
    <figure class="mediaobject"><img src="img/B21361_08_19_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.19: Removing elements from List</p>
    <p class="normal">We remove<a id="_idIndexMarker454"/> this spawner from the list using the <strong class="screenText">Exit</strong> flow output pin of <strong class="screenText">For Loop</strong>, which is executed when the <code class="inlineCode">for</code> loop finishes iterating.</p>
    <p class="normal">Finally, regarding <strong class="screenText">Enemy</strong>, you will need to create a new <strong class="screenText">Enemy Script</strong> graph, which will look similar:</p>
    <figure class="mediaobject"><img src="img/B21361_08_20_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.20: Enemy adding and removing itself from the lists</p>
    <p class="normal">As you can <a id="_idIndexMarker455"/>see, we simply add the enemy on <strong class="screenText">On Start </strong>and remove it in <strong class="screenText">OnDisable</strong>. Remember to first try using <strong class="screenText">OnDestroy</strong> instead of <strong class="screenText">OnDisable</strong> due to the bug we mentioned previously. You can check these changes by playing the game while having the <strong class="screenText">Scene Variables</strong> GameObject selected and seeing how its value changes. Also, remember the need to use the <strong class="screenText">Has Variable</strong> node in case we are changing scenes.</p>
    <p class="normal">Using object managers, we now have centralized information about a group of objects, and we can add all sorts of object group logic here. We created the <code class="inlineCode">EnemiesManager</code>, <code class="inlineCode">WavesManager</code>, and <code class="inlineCode">ScoreManager</code> as centralized places to store several game systems’ information, such as the enemies and waves present in the scene, and the score as well. We also saw the Visual Scripting version, centralizing that data in the Scene Variables object, so all Visual Scripts can read that data. But aside from having this information for updating the UI (which we will do in the next chapter), we can use this information to detect whether the victory and loss conditions of our game are met, creating a <strong class="screenText">Game Mode</strong> object to detect that.</p>
    <h2 id="_idParaDest-122" class="heading-2">Creating Game Modes</h2>
    <p class="normal">We have <a id="_idIndexMarker456"/>created objects to simulate lots of gameplay aspects of our game, but the game needs to end sometime, whether we win or lose. As always, the question is where to put this logic, and that leads us to further questions. The main questions would be, will we always win or lose the game the same way? Will we have a special level with different criteria than “kill all of the waves,” such as timed survival? Only you know the answer to those questions, but if right now the answer is no, it doesn’t mean that it won’t change later, so it is advisable to prepare our code to adapt seamlessly to changes.</p>
    <div><p class="normal">To be honest, preparing code to adapt seamlessly to changes is almost impossible; there’s no way to have code that considers every possible case, and we will always need to rewrite some code sooner or later. We will try to make the code as generic as possible to adapt to changes, but we need to find a balance between necessary and unnecessary adaptability. Creating generic code tends to generate complex codebases and takes more time, and while a certain degree of complexity is certainly necessary, many times, I have seen programmers go beyond what’s needed, taking a huge amount of time to solve simple cases, creating tools that ended up being under-utilized.</p>
    </div>
    <p class="normal">To do this, we <a id="_idIndexMarker457"/>will separate the victory and loss conditions’ logic in its own object, which I like to call the “GameMode” (not necessarily an industry standard). This will be a component that will oversee the game, checking conditions that need to be met in order to consider the game over. It will be like the referee of our game. The Game Mode will constantly check the information in the object managers, and maybe other sources of information, to detect the needed conditions. Having this object separated from other objects allows us to create different levels with different Game Modes; just use another Game Mode script in that level and that’s all.</p>
    <p class="normal">In our case, we will have a single Game Mode for now, which will check whether the number of waves and enemies becomes 0, meaning that we have killed all of the possible enemies and the game is won. Also, it will check whether the life of the player reaches 0, considering the game lost in that situation. Let’s create it by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an empty <code class="inlineCode">GameMode</code> object and add a <code class="inlineCode">WavesGameMode</code> script to it. As you can see, we gave the script a descriptive name considering that we can add other Game Modes.</li>
      <li class="numberedList">In its <code class="inlineCode">Update</code> function, check whether the number of enemies and waves has reached <code class="inlineCode">0</code> by using the <code class="inlineCode">Enemy</code> and <code class="inlineCode">Wave</code> managers; in that case, just <code class="inlineCode">print</code> a message in the console for now. All lists have a <code class="inlineCode">Count</code> property, which will tell you the number of elements stored inside.</li>
      <li class="numberedList">Add a <code class="inlineCode">public</code> field of the <code class="inlineCode">Life</code> type called <code class="inlineCode">PlayerLife</code> and drag the player to that one; the idea is to also detect the loss condition here.</li>
      <li class="numberedList">In <code class="inlineCode">Update</code>, add another check to detect whether the life amount of the <code class="inlineCode">playerLife</code> reference reached <code class="inlineCode">0</code>, and in that case, <code class="inlineCode">print</code> a lose message in the console:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_21_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.21: Win and lose condition checks in WavesGameMode</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Play the <a id="_idIndexMarker458"/>game and test both cases – whether the player’s life reaches 0 or whether you have killed all enemies and waves.
    <p class="normal">Now, it is time to replace the messages with something more interesting. For now, we will just change the current scene to a <strong class="screenText">Win Scene</strong> or <strong class="screenText">Lose Scene</strong>, which will only have a UI with a win or lose message and a button to play again. In the future, you could add a <strong class="keyWord">Main Menu</strong> <strong class="screenText">Scene</strong> and have an option to get back to it. Let’s implement this by doing the following:</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Create a new scene (<strong class="screenText">File | New Scene</strong>) and save it, calling it <code class="inlineCode">WinScreen</code>.</li>
      <li class="numberedList">Add something to indicate that this is the win screen, such as simply a sphere with the camera pointing to it. This way, we know when we change to the win screen.</li>
      <li class="numberedList">Select the scene in the <strong class="screenText">Project</strong> view and press <em class="keystroke">Ctrl</em> + <em class="keystroke">D</em> (<em class="keystroke">Cmd</em> + <em class="keystroke">D</em> on Mac) to duplicate the scene. Rename it <code class="inlineCode">LoseScreen</code>.</li>
      <li class="numberedList">Double-click the <code class="inlineCode">LoseScreen</code> scene to open it and change the sphere to something different, maybe a cube.</li>
      <li class="numberedList">Go to <strong class="screenText">File | Build Settings</strong> to open the <strong class="screenText">Scenes In Build</strong> list inside this window.</li>
    </ol>
    <p class="normal">The idea is that <a id="_idIndexMarker459"/>Unity needs you to explicitly declare all Scenes that must be included in the game. You might have test Scenes or Scenes that you don’t want to release yet, so that’s why we need to do this. In our case, our game will have <code class="inlineCode">WinScreen</code>, <code class="inlineCode">LoseScreen</code>, and the Scene we have created so far with the game scenario, which I called <code class="inlineCode">Game</code>, so just drag those Scenes from the <strong class="screenText">Project</strong> view to the list of the <strong class="screenText">Build Settings</strong> window; we will need this to make the Game Mode script change between Scenes properly. Also, consider that the first Scene in this list will be the first Scene to be opened when we play the game in its final version (known as the build), so you may want to rearrange the list according to that:</p>
    <figure class="mediaobject"><img src="img/B21361_08_22_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.22: Registering the Scenes to be included in the build of the game</p>
    <ul>
      <li class="bulletList">In <code class="inlineCode">WavesGameMode</code>, add a <code class="inlineCode">using</code> statement for the <code class="inlineCode">UnityEngine.SceneManagement</code> namespace to enable the scene-changing functions in this script.</li>
      <li class="bulletList">Replace the console <code class="inlineCode">print</code> messages with calls to the <code class="inlineCode">SceneManager.LoadScene</code> function, which will receive a string with the name of the Scene to load; in this case, it would be <code class="inlineCode">WinScreen</code> and <code class="inlineCode">LoseScreen</code>. You just need the Scene name, not the entire path to the file.
    <p class="normal">If you want to chain different levels, you can create a <code class="inlineCode">public</code> string field to allow you to specify via editor which Scenes to load. Remember to have the Scenes <a id="_idIndexMarker460"/>added to <strong class="screenText">Build Settings</strong>. If you don’t, you will receive an error message in the console when you try to change the Scenes:</p>
    <figure class="mediaobject"><img src="img/B21361_08_23_PE.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.23: Changing Scenes with SceneManager</p></li>
    </ul>
    <ul>
      <li class="bulletList">Play the game and check whether the Scenes change properly.</li>
    </ul>
    <p class="normal">Right now, we picked the simplest way to show whether we lost or won, but in the future, you may want <a id="_idIndexMarker461"/>something gentler than a sudden change of Scene, such as maybe waiting a few moments with <code class="inlineCode">Invoke</code> to delay that change or directly show the winning message inside the game without changing Scenes. Bear this in mind when testing the game with people and checking whether they understood what happened when they were playing—game feedback is important to keep the player aware of what is happening and is not an easy task to tackle.</p>
    <p class="normal">Regarding the Visual Scripting version, we added a new script graph to a separate object. Let’s examine it piece by piece to see it clearly. Let’s start with the win condition:</p>
    <figure class="mediaobject"><img src="img/B21361_08_24_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.24: Win condition in Visual Scripting</p>
    <p class="normal">Here, we are<a id="_idIndexMarker462"/> getting the <strong class="screenText">enemies</strong> list from the scene context (<strong class="screenText">Get Variable</strong> node), and knowing that it contains a List, we are using the <strong class="screenText">Count Items</strong> node to check how many enemies remain in this list. Remember we have a script that adds the enemy to the list when it’s spawned and removes it when it is destroyed. We do the same for the waves, so combine the conditions with an <strong class="screenText">And</strong> node and connect it with an <strong class="screenText">If</strong> to then do something (more on that in a moment).</p>
    <p class="normal">Now let’s examine the lose condition:</p>
    <figure class="mediaobject"><img src="img/B21361_08_25_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.25: Lose condition in Visual Scripting</p>
    <p class="normal">As the player’s life is not in <a id="_idIndexMarker463"/>the Scene context (and shouldn’t be), and the player is a different GameObject from the one called <code class="inlineCode">GameMode</code> (the one we created specifically for this script), we need a variable of type Game Object called <strong class="screenText">Player</strong> to reference it.</p>
    <p class="normal">As you can see, we dragged our player to it in the <strong class="screenText">Variables</strong> component. Finally, we used <strong class="screenText">GetVariable</strong> to access our player reference in the graph, and then another <strong class="screenText">GetVariable</strong> to extract the life from it. We accomplished that by connecting the player reference to the <strong class="screenText">GetVariable</strong> node<a id="_idIndexMarker464"/> of the <strong class="screenText">life</strong> variable. Then we repeated this for the player’s base.</p>
    <p class="normal">Finally, we load the scenes by doing the following:</p>
    <figure class="mediaobject"><img src="img/B21361_08_26_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.26: Loading scenes in Visual Scripting</p>
    <p class="normal">As you can see, we use the <strong class="screenText">Scene Manager Load Scene (SceneName)</strong> node to load the Scenes. Notice how we load both Scenes we created before (<strong class="screenText">WinScene</strong> and <strong class="screenText">LoseScene</strong>). Remember that<a id="_idIndexMarker465"/> these two Scenes need to be added to the <strong class="screenText">Scenes In Build</strong> section inside <strong class="screenText">Build Settings</strong> as we did before, in order to be available to be loaded by the Scene Manager here.</p>
    <p class="normal">Now we have a fully functional simple game, with mechanics and win and lose conditions, and while this is enough to start developing other aspects of our game, I want to discuss some issues with our current manager approach and how to solve them with events.</p>
    <h2 id="_idParaDest-123" class="heading-2">Improving our code with events</h2>
    <p class="normal">So far, we<a id="_idIndexMarker466"/> have used Unity event functions to detect situations that can happen in the game such as <code class="inlineCode">Awake</code> and <code class="inlineCode">Update</code>. There are other similar functions that Unity uses to allow components to communicate with each other, as in the case of <code class="inlineCode">OnTriggerEnter</code>, which is a way for the Rigidbody component to inform other components <a id="_idIndexMarker467"/>in the GameObject that a collision has happened. In our case, we are using <code class="inlineCode">if</code> statements inside the <code class="inlineCode">Update</code> method to detect changes on other components, such as <code class="inlineCode">GameMode</code> checking whether the number of enemies has reached 0. But we can improve this if we are informed by the Enemy manager when something has changed, and just do the check at that moment, such as with the Rigidbody component telling us when collisions occur instead of checking for collisions every frame.</p>
    <p class="normal">Also, sometimes, we rely on Unity events to execute logic, such as the score being given in the <code class="inlineCode">OnDestroy</code> event, which informs us when the object is destroyed, but due to the nature of the event, it can be called in situations we don’t want to add to the score, such as when the Scene is changed, or the game is closed. Objects are destroyed in those cases, but not because the player killed the enemy, leading to the score increasing when it shouldn’t. In this case, it would be great to have an event that tells us that life reached 0 to execute this logic, instead of relying on the general-purpose <code class="inlineCode">OnDestroy</code> event.</p>
    <p class="normal">The idea of events is to improve the model of communication between our objects, with the assurance that at the exact moment something happens, the relevant parts in that situation are notified to react accordingly. Unity has lots of events, but we can create ones specific to our gameplay logic. Let’s start by applying this in the score scenario we discussed earlier; the idea is to make the <code class="inlineCode">Life</code> component have an event to communicate to the other components that the object was destroyed because life reached 0.</p>
    <p class="normal">There are <a id="_idIndexMarker468"/>several ways to implement this, and we will use a little bit <a id="_idIndexMarker469"/>of a different approach than the <strong class="screenText">Awake</strong> and <strong class="screenText">Update</strong> methods; we will use the <code class="inlineCode">UnityEvent</code> field type. This is a field type capable of holding references to functions to be executed when we want to, like C# delegates, but with other benefits, such as better Unity editor integration.</p>
    <p class="normal">To implement this, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In the <code class="inlineCode">Life</code> component, create a <code class="inlineCode">public</code> field of the <code class="inlineCode">UnityEvent</code> type called <code class="inlineCode">onDeath</code>. This field will represent an event where other classes can subscribe to it to be made aware when <code class="inlineCode">Life</code> reaches 0:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_27_PE.png" alt="A picture containing text, font, screenshot, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.27: Creating a custom event field</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">If you save the script and go to the editor, you can see the event in the Inspector. Unity events support being subscribed to methods in the editor so we can connect two objects together. We will use this in the UI scripting chapter, so let’s just ignore this for now:
    <figure class="mediaobject"><img src="img/B21361_08_28_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.28: UnityEvents showing up in the Inspector</p>
    <p class="normal">You can<a id="_idIndexMarker470"/> use the generic delegate action or a <a id="_idIndexMarker471"/>custom delegate to create events instead of using <code class="inlineCode">UnityEvent</code>, and aside from certain performance aspects, the only noticeable difference is that <code class="inlineCode">UnityEvent</code> will show up in the editor, as demonstrated in <em class="italic">step 2</em>.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">When life reaches <code class="inlineCode">0</code>, call the <code class="inlineCode">Invoke</code> function of the event. This way, we will be telling any script interested in the event that it has happened:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_29_PE.png" alt="A screenshot of a computer code  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.29: Executing the event</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In <code class="inlineCode">ScoreOnDeath</code>, rename the <code class="inlineCode">OnDestroy</code> function to <code class="inlineCode">GivePoints</code> or whatever name <a id="_idIndexMarker472"/>you prefer; the idea here is to stop<a id="_idIndexMarker473"/> giving points in the <code class="inlineCode">OnDestroy</code> event.</li>
      <li class="numberedList">In the <code class="inlineCode">Awake</code> function of the <code class="inlineCode">ScoreOnDeath</code> script, get the <code class="inlineCode">Life</code> component using <code class="inlineCode">GetComponent</code> and save it in a local variable.</li>
      <li class="numberedList">Call the <code class="inlineCode">AddListener</code> function of the <code class="inlineCode">onDeath</code> field of the <code class="inlineCode">Life</code> reference and pass the <code class="inlineCode">GivePoints</code> function as the first argument. This is known as <strong class="screenText">subscribing</strong> our <code class="inlineCode">listener</code> method, <code class="inlineCode">GivePoints</code>, to the <code class="inlineCode">onDeath</code> event. The idea is to tell <code class="inlineCode">Life</code> to execute <code class="inlineCode">GivePoints</code> when the <code class="inlineCode">onDeath</code> event is invoked. This way, <code class="inlineCode">Life</code> informs us about that situation. Remember that you don’t need to call <code class="inlineCode">GivePoints</code>, but just pass the function as a field:
    <figure class="mediaobject"><img src="img/B21361_08_30_PE.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.30: Subscribing to the OnDeath event to give points in that scenario</p>
    <p class="normal">Consider<a id="_idIndexMarker474"/> calling <code class="inlineCode">RemoveListener</code> in <code class="inlineCode">OnDestroy</code>; as usual, it is convenient<a id="_idIndexMarker475"/> to unsubscribe listeners when possible to prevent any memory leak (when a reference is preventing the GC from deallocating memory). In this scenario, it is not entirely necessary because both the <code class="inlineCode">Life</code> and <code class="inlineCode">ScoreOnDeath</code> components will be destroyed at the same time, but try to get used to this as a good practice.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Save, select <code class="inlineCode">ScoreManager</code> in the editor, and hit <strong class="screenText">Play</strong> to test this. Try deleting an enemy from the Hierarchy while in <strong class="screenText">Play</strong> mode to check that the score doesn’t rise because the enemy was destroyed for a reason other than their life becoming 0; you must destroy an enemy by shooting at them to see the score increase.
    <p class="normal">Now that <code class="inlineCode">Life</code> has an <code class="inlineCode">onDeath</code> event, we can also replace the player’s <code class="inlineCode">Life</code> check from the <code class="inlineCode">WavesGameMode</code> to use the event by doing the following:</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Create an <code class="inlineCode">OnPlayerDied</code> function on the <code class="inlineCode">WavesGameMode</code> script and move the loading of the <code class="inlineCode">LoseScreen</code> scene from <code class="inlineCode">Update</code> to this function. You will be removing the <code class="inlineCode">if</code> that checks the life from the <code class="inlineCode">Update</code> method, given that the event version will replace it.</li>
      <li class="numberedList">In <code class="inlineCode">Awake</code>, add this new function to the <code class="inlineCode">onDeath</code> event of the player’s <code class="inlineCode">Life</code> component reference, called <code class="inlineCode">playerLife</code> in our script:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_31_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.31: Checking the lose condition with events</p>
    <p class="normal">As you can see, creating <a id="_idIndexMarker476"/>custom events allows you to detect more specific situations other than the defaults in Unity, and keeps your code clean, without <a id="_idIndexMarker477"/>needing to constantly check several conditions in the <code class="inlineCode">Update</code> function, which is not necessarily bad, but the event approach generates clearer code.</p>
    <p class="normal">Remember that we can also lose our game by the player’s base <code class="inlineCode">Life</code> reaching 0, so let’s create a cube that represents the object that enemies will attack to reduce the base <code class="inlineCode">Life</code>. Taking this into account, I challenge you to add this second lose condition (player’s base life reaching 0) to our script. When you finish, you can check the solution in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_08_32_PE.png" alt="A screen shot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.32: Complete WavesGameMode lose condition</p>
    <p class="normal">As you can <a id="_idIndexMarker478"/>see, we just repeat the <code class="inlineCode">life</code> event subscription, remember<a id="_idIndexMarker479"/> to create an object to represent the player’s base damage point, add a <code class="inlineCode">Life</code> script to it, and drag that one as the player base <code class="inlineCode">Life</code> reference of the <code class="inlineCode">WavesGameMode</code>. Something interesting here is that we subscribed the same function called <code class="inlineCode">OnPlayerOrBaseDied</code> to both player <code class="inlineCode">Life</code> and base <code class="inlineCode">Life</code> <code class="inlineCode">onDeath</code> events, given that we want the same result in both situations.</p>
    <p class="normal">Now, let’s keep illustrating this concept by applying it to the managers to prevent the Game Mode from checking conditions every frame:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add a <code class="inlineCode">UnityEvent</code> field to <code class="inlineCode">EnemyManager</code> called <code class="inlineCode">onChanged</code>. This event will be executed whenever an enemy is added or removed from the list.</li>
      <li class="numberedList">Create two functions, <code class="inlineCode">AddEnemy</code> and <code class="inlineCode">RemoveEnemy</code>, both receiving a parameter of the <code class="inlineCode">Enemy</code> type. The idea is that instead of <code class="inlineCode">Enemy</code> adding and removing itself from the list directly, it should use these functions.</li>
      <li class="numberedList">Inside these two functions, invoke the <code class="inlineCode">onChanged</code> event to inform others that the enemies list has been updated. The idea is that anyone who wants to add or remove enemies from the list needs to use these functions:
    <figure class="mediaobject"><img src="img/B21361_08_33_PE.png" alt="A screenshot of a computer code  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.33: Calling events when enemies are added or removed</p>
    <p class="normal">Here, we <a id="_idIndexMarker480"/>have the problem that nothing stops us<a id="_idIndexMarker481"/> from bypassing those two functions and using the list directly. You can solve that by making the list private and exposing it using the <code class="inlineCode">IReadOnlyList</code> interface. Remember that, this way, the list won’t be visible in the editor for debugging purposes.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Change the <code class="inlineCode">Enemy</code> script to use these functions:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_34_PE.png" alt="A screen shot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.34: Making the Enemy use the add and remove functions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Repeat <a id="_idIndexMarker482"/>the same process for <code class="inlineCode">WaveManager</code> and <code class="inlineCode">WaveSpawner</code>, create an <code class="inlineCode">onChanged</code> event, and create the <code class="inlineCode">AddWave</code> and <code class="inlineCode">RemoveWave</code> functions and call them in <code class="inlineCode">WaveSpawner</code> instead of directly <a id="_idIndexMarker483"/>accessing the list. This way, we are sure the event is called when necessary as we did with <code class="inlineCode">EnemyManager</code>. 
    <p class="numberedList">Try to solve this step by yourself and then check the solution in the following screenshot, starting with <code class="inlineCode">WavesManager</code>:</p>
    <figure class="mediaobject"><img src="img/B21361_08_35_PE.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.35: WavesManager OnChanged event implementation</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Also, <code class="inlineCode">WaveSpawner</code> needed <a id="_idIndexMarker484"/>the<a id="_idIndexMarker485"/> following changes:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_36_PE.png" alt="A screenshot of a computer program  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.36: Implementing the AddWave and RemoveWave functions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">In <code class="inlineCode">WavesGameMode</code>, rename <code class="inlineCode">Update</code> to <code class="inlineCode">CheckWinCondition</code> and subscribe this function to the <code class="inlineCode">onChanged</code> event of <code class="inlineCode">EnemyManager</code> and the <code class="inlineCode">onChanged</code> event of <code class="inlineCode">WavesManager</code>. The idea is to check for the number of enemies and waves being changed<a id="_idIndexMarker486"/> only when necessary. Remember<a id="_idIndexMarker487"/> to do the subscription to the events in the <code class="inlineCode">Start</code> function due to the Singletons being initialized in <code class="inlineCode">Awake</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_08_37_PE.png" alt="A screen shot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 8.37: Checking the win condition when the enemies or waves amount is changed</p>
    <p class="normal">Regarding the Visual Scripting version, let’s start checking the lose condition with events, first checking some changes needed in the <strong class="screenText">Life Script Graph</strong>:</p>
    <figure class="mediaobject"><img src="img/B21361_08_38_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 8.38: Triggering a Custom Event in our Life script graph</p>
    <p class="normal">First, after<a id="_idIndexMarker488"/> destroying the object when life reaches 0, we use the <strong class="screenText">Trigger Custom Event</strong> node, specifying the name of our event is <code class="inlineCode">OnDeath</code>. This will tell anyone <a id="_idIndexMarker489"/>waiting for the execution of the <code class="inlineCode">OnDeath</code> event that it has been executed. Remember, this is our <strong class="screenText">Life Script Graph</strong>. Be sure to call <strong class="screenText">destroy</strong> after triggering the event—while most of the time the order doesn’t matter, given that the <strong class="screenText">destroy</strong> action doesn’t actually happen until the end of the frame, sometimes it can cause issues, so better be safe here. In this case, Game Mode should listen to the player’s <code class="inlineCode">OnDeath</code> event, so let’s make the following change in our <strong class="screenText">Game Mode Graph</strong>:</p>
    <figure class="mediaobject"><img src="img/B21361_08_39_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 8.39: Listening to the OnDeath event of Player in Visual Scripting</p>
    <p class="normal">We <a id="_idIndexMarker490"/>used the <strong class="screenText">Custom Event</strong> node, connecting it to the player reference<a id="_idIndexMarker491"/> of our GameMode. This way, we are specifying that if that player executes that event, we will execute the <strong class="screenText">Load Scene</strong> node. Remember that the player reference is crucial to specify from whom we want to execute the <code class="inlineCode">OnDeath</code> event, and remember that the <strong class="screenText">Life Visual Graph</strong> will also be present in the enemies and we are not interested in them here. Also, remember to remove the <code class="inlineCode">If</code> node and the condition nodes we used previously to detect this – the only <code class="inlineCode">If</code> our Game Mode will have is the one for the win condition.</p>
    <p class="normal">Essentially, we made any object with the <code class="inlineCode">Life</code> script have an <code class="inlineCode">OnDeath</code> event, and we made the GameMode listen to the <code class="inlineCode">OnDeath</code> event of the player specifically.</p>
    <p class="normal">We could also create events for enemies and waves, but that would complicate our graphs somewhat, given that we don’t have <code class="inlineCode">WaveManager</code> or <code class="inlineCode">EnemyManager</code> in the Visual Scripting versions. We could certainly create those to accomplish this, but sometimes the point of using Visual Scripting is to create simple logic, and these kinds of changes tend to make a graph grow quite a bit.</p>
    <p class="normal">Another possible solution is to make the enemy and wave directly inform the Game Mode. We could use <strong class="screenText">Trigger Custom Event</strong> in the enemies and waves, connecting that node to the Game Mode, to finally let the Game Mode have a <strong class="screenText">Custom Event</strong> node from which to listen. The issue is that that would violate the correct dependencies between our objects; lower-level objects such as enemies and waves shouldn’t communicate with higher-level objects such as Game Mode. </p>
    <p class="normal">Essentially, Game Mode was supposed to be an overseer. If <a id="_idIndexMarker492"/>we apply the solution described in the previous paragraph, we won’t be able to have an enemy in another scene or game without having a Game Mode. So, for simplicity and code decoupling purposes, let’s keep the other conditions as they are—more complex logic such as this would probably be handled in C# in full-production projects.</p>
    <p class="normal">Yes, using events <a id="_idIndexMarker493"/>means that we have to write more code than before, and in terms of functionality, we didn’t obtain anything new, but in bigger projects, managing conditions through <code class="inlineCode">Update</code> checks will lead to different kinds of problems, as previously discussed, such as race conditions and performance issues. Having a scalable code base sometimes requires more code, and this is one of those cases.</p>
    <p class="normal">Before we finish, something to consider is that Unity events are not the only way to create this kind of event communication in Unity; you will find a similar approach called <strong class="screenText">Action</strong>, the native C# version of events, which I recommend you look into if you want to see all of the options out there.</p>
    <div><p class="normal">We explored some programming patterns in this chapter, but there are plenty. You can learn more about them here: <a href="https://gameprogrammingpatterns.com/">https://gameprogrammingpatterns.com/</a></p>
    </div>
    <h1 id="_idParaDest-124" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we finished an important part of the game: the ending, both by victory and by defeat. We discussed a simple but powerful way to separate the different layers of responsibilities by using managers created through Singletons, to guarantee that there isn’t more than one instance of every kind of manager and simplifying the connections between them through static access. Also, we visited the concept of events to streamline communication between objects to prevent problems and create more meaningful communication between objects.</p>
    <p class="normal">With this knowledge, you are now able not only to detect the victory and loss conditions of the game but you can also do it in a better-structured way. These patterns can be useful to improve our game code in general, and I recommend you try to apply them in other relevant scenarios.</p>
    <p class="normal">In the next chapter, we are going to start <em class="chapterRef">Section 3</em>, <em class="italic">Elevating Visuals, Effects, and Audio</em> of the book, where we are going to see different Unity systems to improve the graphics and audio aspects of our game, starting by seeing how we can create materials to modify aspects of our objects and create shaders with Shader Graph.</p>
    <h1 class="heading-1"/>
    <h1 id="_idParaDest-125" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
    <p class="normal"><img src="img/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>