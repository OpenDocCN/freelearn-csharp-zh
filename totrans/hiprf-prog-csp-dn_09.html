<html><head></head><body>
		<div><h1 id="_idParaDest-137"><em class="italic"><a id="_idTextAnchor139"/>Chapter 7</em>: LINQ Performance</h1>
			<p>LINQ has a reputation for being slow. But contrary to people's views, there are ways to use LINQ that ensure optimal performance. </p>
			<p>In this chapter, you will learn how to perform LINQ queries with performance in mind. Depending on how you use LINQ, different methods that return the same result can behave and perform differently. And so, in this chapter, you will learn how best to perform queries on LINQ to improve the performance of your applications.</p>
			<p>Here, you will benchmark different ways to determine the most performative ways to obtain the last element of a LINQ query. You will learn about the performance penalty of using the <code>let</code> keyword in LINQ statements, and why you should avoid using it. Benchmarking different <code>Group By</code> methods, you will gain insight into the most performant way to perform GroupBy queries using LINQ. When performing queries and data manipulation using LINQ, there may be times when you need to use closures. By writing parametrized and non-parameterized closures, you will see that parameterized closures perform much better than non-parameterized closures.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li>Setting up our sample database</li>
				<li>Setting up our in-memory sample data </li>
				<li>Querying a database using LINQ </li>
				<li>Getting the last value of a collection </li>
				<li>Avoid using the let keyword in LINQ queries </li>
				<li>Increasing Group By performance in LINQ queries </li>
				<li>Filtering lists </li>
				<li>Understanding closures </li>
			</ul>
			<p>By the end of this chapter, you will have the skills to securely store secrets and query databases and in-memory data using efficient LINQ. You will also be able to understand the performance impact of using the <code>let</code> keyword in your queries and performing efficient filtering and grouping of data using LINQ. </p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>In order to follow along with this chapter, you will need access to the following tools:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>SQL Server 2019</li>
				<li>SQL Server Management Studio</li>
				<li>The book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07 ">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07</a></li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor141"/>Setting up a sample database</h1>
			<p>In this chapter, we will be demonstrating the difference between how different collection interfaces handle data, and for the demonstrations, you require access to database data. To do so, you will<a id="_idIndexMarker743"/> create a database, add a table, and populate it with data. You will use SQL Server for your database engine, and use SQL Server Management Studio to develop your sample database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the <code>CH07_LinqPerformance.Data</code> source code folder, you will find a database creation script called <code>SampleData.Product.sql</code> that creates the database and populates it with data. You can run this script in SQL Server Management Studio. This will save you from having to run through setting up the database in this section. But if you are new to SQL Server, you may want to run through this section.</p>
			<p>To add your database, follow these steps:</p>
			<ol>
				<li>Open SQL Server Management Studio and connect to your database engine.</li>
				<li>Right-click on the <strong class="bold">Databases</strong> folder in <strong class="bold">Object Explorer</strong> as shown in <em class="italic">Figure 7.1</em>:</li>
			</ol>
			<div><div><img src="img/B16617_07_01.jpg" alt="Figure 7.1: The SQL Server Management Studio Object Explorer tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: The SQL Server Management Studio Object Explorer tab</p>
			<ol>
				<li value="3">Select <strong class="bold">New Database</strong> from the <a id="_idIndexMarker744"/>context menu. This will display the <strong class="bold">New Database</strong> dialog as shown in <em class="italic">Figure 7.2</em>:</li>
			</ol>
			<div><div><img src="img/B16617_07_02.jpg" alt="Figure 7.2: The SQL Server Management Studio New Database dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: The SQL Server Management Studio New Database dialog</p>
			<ol>
				<li value="4">Once you have entered <code>SampleData</code> for the database name, click on the <strong class="bold">OK</strong> button to <a id="_idIndexMarker745"/>create the database.</li>
				<li>Locate the database by expanding the <code>Products</code> as shown in the following figure:</li>
			</ol>
			<div><div><img src="img/Table_7.1.jpg" alt="Table 7.1: The Products table design&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 7.1: The Products table design</p>
			<ol>
				<li value="6">Save the table and then expand the <strong class="bold">Tables</strong> folder. Right-click on the <strong class="bold">Products</strong> table and <a id="_idIndexMarker746"/>select <strong class="bold">Edit Top n records</strong> where <em class="italic">n</em> will be the number of configured records to edit, which is <em class="italic">200</em> by default.</li>
				<li>Add the data shown in the following figure to the <strong class="bold">Product</strong> table:</li>
			</ol>
			<div><div><img src="img/Table_7.2.jpg" alt="Table 7.2: The Product table row data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 7.2: The Product table row data</p>
			<p>We now have a<a id="_idIndexMarker747"/> database with a single table filled with data that we will use later in the chapter. In the next section, we will be adding our in-memory sample data.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>Setting up our in-memory sample data</h1>
			<p>You will be studying<a id="_idIndexMarker748"/> LINQ performance, therefore, you are going to need a collection to work with. You will work with a collection of <code>Person</code> objects. Each person will be named from the Greek alphabet. A <code>Person</code> object will consist of a <code>FirstName</code>, <code>LastName</code>, and <code>FullName</code> property. The <code>FullName</code> property will be an interpolated string that combines the first and last name of the person. </p>
			<p>Let us now begin coding our LINQ <a id="_idIndexMarker749"/>coding combined with <strong class="bold">benchmarking</strong>, so that we can measure the performance of our LINQ statements:</p>
			<ol>
				<li value="1">Create a new .NET 6.0 console application called <code>CH07_LinqPerformance</code>.</li>
				<li>Install the NuGet package <code>BenchmarkDotNet</code>.</li>
				<li>Add the following <code>Person</code> struct:<pre>public struct Person
{
      public string FirstName { get; set; }
      public string LastName { get; set; }
      public string FullName { get { return 
        $"{FirstName} {LastName}"; } }
public Person(string firstName, string lastName)
{
    FirstName = firstName;
    LastName = lastName;
}
}</pre></li>
			</ol>
			<p>This structure defines the <code>Person</code> with their <code>FirstName</code>, <code>LastName</code>, and computed <code>FullName</code>. </p>
			<ol>
				<li value="4">Now, add a new <a id="_idIndexMarker750"/>class called <code>LinqPerformance</code> with the following <code>using </code>statements:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
using System.Collections.Generic;
using System.Linq;</pre></li>
			</ol>
			<p>These <code>using</code> statements provide you with access to benchmarking, generic collections, and LINQ classes. </p>
			<ol>
				<li value="5">Add the following code to the top of the class:<pre>private List&lt;Person&gt; _people = new List&lt;Person&gt;();
private string[] _group1 = new string[] { "iota", 
    "epsilon", "sigma", "upsilon" };
private string[] _group2 = new string[] { "alpha", 
    "omega" };</pre></li>
			</ol>
			<p>You have declared a list of people and two arrays. Both these arrays contain the surnames of people in lowercase that belong to those groups. </p>
			<ol>
				<li value="6">Now, add the global <a id="_idIndexMarker751"/>setup class that will prepare your collection for benchmarking various LINQ queries:<pre>[GlobalSetup]
public void PrepareBenchmarks()
{
  _people.Add(new Person("Alpha", "Beta"));
  _people.Add(new Person("Chi", "Delta"));
  _people.Add(new Person("Epsilon", "Phi"));
  _people.Add(new Person("Gamma", "iota"));
  _people.Add(new Person("Kappa", "Lambda"));
  _people.Add(new Person("Mu", "Nu"));
  _people.Add(new Person("Omicron", "Pi"));
  _people.Add(new Person("Theta", "Rho"));
  _people.Add(new Person("Sigma", "Tau"));
  _people.Add(new Person("Upsilon", "Omega"));
  _people.Add(new Person("Xi", "Psi"));
  _people.Add(new Person("Zeta", "Iota"));
  _people.Add(new Person("Alpha", "Omega"));
     _people.Add(new Person("Omega", "Chi"));
     _people.Add(new Person("Sigma", "Tau"));
}</pre></li>
			</ol>
			<p>You now have your sample database and in-memory sample data in place for the topics we will be covering in this chapter. So, let us start by investigating various ways of querying a database <a id="_idIndexMarker752"/>and their effects on LINQ query performance.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>Database query performance</h1>
			<p>We saw in <a href="B16617_06_Final_SB_Epub.xhtml#_idTextAnchor117"><em class="italic">Chapter 6</em></a>, <em class="italic">The .NET Collection</em>, how <code>IEnumerator</code> is different from <code>IEnumerable</code>, and how <code>IEnumerator</code> performs faster than <code>IEnumerable</code> when iterating through an in-memory collection. Now, we will query a database and iterate through the<a id="_idIndexMarker753"/> resulting collection using various benchmarked techniques. To do so, we will follow these steps:</p>
			<ol>
				<li value="1">Add a new class called <code>IEnumeratorVsIQueryable</code>.</li>
				<li>You will be connecting to a SQL Server database and will have the information you need to keep secret. Your <code>secret.json</code> files do not get checked into version control. So, right-click on the project and select <strong class="bold">Manage User Secrets</strong> from the context menu.</li>
				<li>A dialog will pop up informing you that additional packages are required. Click on <strong class="bold">Yes</strong>.</li>
			</ol>
			<div><div><img src="img/B16617_07_03.jpg" alt="Figure 7.3: Dialog Informing you that additional packages are required to manage user secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: Dialog Informing you that additional packages are required to manage user secrets</p>
			<ol>
				<li value="4">Visual Studio will then open the <code>secrets.json</code> file in a new tab. This is where you will add your user secrets.</li>
				<li>Open <strong class="bold">Package Manager Console</strong> and add the following packages:<pre>Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFrameworkCore.Tools
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.EnvironmentVariables
Microsoft.Extensions.Configuration.UserSecrets
Microsoft.Extensions.OptionsConfigurationExtensions</pre></li>
			</ol>
			<p>These packages<a id="_idIndexMarker754"/> enable you to connect to and extract data from the SQL Server database. </p>
			<ol>
				<li value="6">Update your <code>secrets.json</code> file with the connection string to the database you created at the start of the chapter:<pre>{
  "DatabaseSettings": {
    "ConnectionString": "YOUR_CONNECTION_STRING"
  }
}</pre></li>
			</ol>
			<p>This connection string will be used to connect to your database, perform a query that returns some data, and enable you to iterate through that data and perform operations on it. </p>
			<ol>
				<li value="7">Add a folder called <code>Configuration</code>, and in that folder, add a class called <code>SecretsManager</code> with an empty static constructor and the following <code>using</code> statements:<pre>using Microsoft.Extensions.Configuration;
using System;
using System.IO;</pre></li>
			</ol>
			<p>You need these <code>using</code> statements for your file I/O and system configuration such as obtaining secrets from a <code>secrets.json</code> file. </p>
			<ol>
				<li value="8">Add the following line at the top of the <code>SecretsManager</code> class:<pre>public static IConfigurationRoot Configuration 
    { get; set; }</pre></li>
			</ol>
			<p>This line declares your static configuration property that is used to obtain your configuration data within your application. </p>
			<ol>
				<li value="9">Now add the <a id="_idIndexMarker755"/>following code:<pre>public static T GetSecrets&lt;T&gt;(string sectionName) 
    where T : class
{
var devEnvironmentVariable = Environment
      .GetEnvironmentVariable("NETCORE_ENVIRONMENT");
var isDevelopment = string.IsNullOrEmpty
       (devEnvironmentVariable) || devEnvironment
            Variable.ToLower() == "development";
var builder = new ConfigurationBuilder() 
    .SetBasePath(Directory.GetCurrentDirectory())
.AddJsonFile("appsettings.json", optional: true, 
    reloadOnChange: true)
.AddEnvironmentVariables();
if (isDevelopment) //only add secrets in development
{
    builder.AddUserSecrets&lt;T&gt;();
}
Configuration = builder.Build();
return Configuration.GetSection(sectionName).Get&lt;T&gt;();</pre></li>
			</ol>
			<p>This code gets the environment variables for the .NET Core environment. It then gets the code to see if it is running in a software development environment or production environment. The configuration is then built for the environment it will be running in. So, if we are in debug mode, the configuration will be built for the development <a id="_idIndexMarker756"/>environment. And if we are in release mode, the configuration will be built for the production environment. If we are in development, then we add our <code>secrets</code> class as defined by the <code>T</code> variable.</p>
			<ol>
				<li value="10"> Create a new folder, <code>Models</code>, and add the <code>Product</code> class using the following code:<pre>using System.ComponentModel.DataAnnotations;
public class Product
{
       public Product() { }
       public Product(int id)
       {
            Id = id;
           Name = $"Item {Id} Name";
           Description = $"Item {Id} description.";
         }
       [Key]
       public int Id { get; private set; }
       public string Name { get; private set; }
       public string Description { get; private set; }
       public override string ToString()
       {
      return $"Id: {Id}, Name: {Name}, 
        Description: {Description}";
       }
}</pre></li>
			</ol>
			<p>Our <code>Product</code> class provides the model for our product data with <code>Id</code>, <code>Name</code>, and <code>Description</code> properties<a id="_idIndexMarker757"/> that are set via the constructor. We also <a id="_idIndexMarker758"/>override the <code>ToString</code> method to return a textual representation of the property values.</p>
			<ol>
				<li value="11">Add a <code>using</code> statement for <code>System.ComponentModel.DataAnnotations</code>. Change the struct to a class, and add the <code>[Key]</code> attribute to the <code>Id</code> property. We need these changes since we are using Entity Framework to connect to a database and extract data.</li>
				<li>In the <code>CH07_LinqPerformance.Data</code> folder, add the <code>DatabaseContext</code> class:<pre>using Microsoft.EntityFrameworkCore;
using CH07_LinqPerformance.Models;
public class DatabaseContext : DbContext
{
}</pre></li>
			</ol>
			<p>We have declared our <code>DatabaseContext</code> class, which inherits from the <code>DbContext</code> class. Now we'll need to add its internals.</p>
			<ol>
				<li value="13">Add the following items to the <code>DatabaseContext</code> class:<pre>public DbSet&lt;Product&gt; Products { get; set; }
public DatabaseContext(string connectionString) : 
    base(GetOptions(connectionString))
{
}</pre></li>
			</ol>
			<p>In this code, we have declared our <code>DbSet</code> of products property, which will hold a collect of our <code>Product</code> class, and a connection string member variable that will hold the string that connects us to our database. Our constructor is then declared, which takes in <a id="_idIndexMarker759"/>a connection string, which we pass into the <code>GetOptions</code> method that then gets passed into the base class constructor. </p>
			<ol>
				<li value="14">Add the <code>GetOptions</code> method to the <code>DatabaseContext</code> class:<pre>private static DbContextOptions GetOptions(string 
    connectionString)
{
       return SqlServerDbContextOptionsExtensions
             .UseSqlServer(
                   new DbContextOptionsBuilder(),  
                   connectionString)
             .Options;
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker760"/>returns the <code>DbContextOptions</code> for our SQL Server database connection. The connection string used is the one that is stored in our <code>secrets.json</code> file in development and in <code>appsettings.json</code> when in production.</p>
			<ol>
				<li value="15">Add the <code>OnModelCreating</code> method:<pre>protected override void OnModelCreating(ModelBuilder 
    modelBuilder)
{
       modelBuilder.Entity&lt;Product&gt;(entity =&gt;
     {
                 entity.HasKey(e =&gt; e.Id);
           entity.Property(e =&gt; e.Name)
                  .HasMaxLength(50);
             Entity.Property(e =&gt; e.Description)
                .HasMaxLength(255);
            });
        }</pre></li>
			</ol>
			<p>Here, we are configuring our <code>Product</code> class that will be used in our <code>DbSet</code>. We are declaring that the <code>Id</code> field is<a id="_idIndexMarker761"/> our primary key and that the <code>Name</code> field has a maximum<a id="_idIndexMarker762"/> length of 50 while the <code>Description</code> field has a maximum length of 255.</p>
			<ol>
				<li value="16">Add the <code>DatabaseSettings</code> class to the <code>Configuration</code> folder:<pre>public class DatabaseSettings
{
      public string ConnectionString { get; set; }
}</pre></li>
			</ol>
			<p>This class has a single property called <code>ConnectionString</code> that will hold your connection string to our <code>SampleData</code> database. Notice that the name of the class and property match the name of the JSON section and property! </p>
			<ol>
				<li value="17">Now, add <code>appsettings.json</code> to the root of your project with the following contents:<pre>{
  "DatabaseSettings": {
    "ConnectionString": "Set in Azure. For 
        development, set in User Secrets"
  }
}</pre></li>
			</ol>
			<p>This file has the same layout as the <code>secrets.json</code> file and the <code>DatabaseSettings</code> class. This file is used to store your connection string. In development, it is set in the<a id="_idIndexMarker763"/> secrets file, and in production, it is set in Azure. Now that you have your database configuration in place, you can add your benchmarking code.</p>
			<ol>
				<li value="18">Add a new class in the root of the project called <code>DatabaseQueryAndIteration</code> that implements <code>IDisposable</code> with the following code:<pre>using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Order;
using CH07_Collections.Configuration;
using CH07_Collections.Data;
using CH07_Collections.Models;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.Declared)]
[RankColumn]
public class DatabaseQueryAndIteration : IDisposable 
{
}</pre></li>
			</ol>
			<p>This code declares our class and defines the fact that it implements <code>IDisposable</code>. It is also <a id="_idIndexMarker764"/>configured to be benchmarked.</p>
			<ol>
				<li value="19">Implement the <code>IDisposable</code> interface in our class:<pre>private bool disposedValue;
protected virtual void Dispose(bool disposing)
{
    if (!disposedValue) {
        if (disposing)
            _context.Dispose();
        disposedValue = true;
    }
}
public void Dispose(){
    Dispose(disposing: true);
    GC.SuppressFinalize(this);
}</pre></li>
			</ol>
			<p>This code disposes of our managed resources and suppresses the call to the class finalizer method.</p>
			<ol>
				<li value="20">We have everything in place to benchmark the methods in this class, access database resources, and clean up after ourselves. Add the following code to the class:<pre>private DatabaseContext _context;
[GlobalSetup]
public void GlobalSetup()
{
      var connectionString = SecretsManager
        .GetSecrets&lt;DatabaseSettings&gt;(nameof
          (DatabaseSettings)).ConnectionString;
  _context = new DatabaseContext(connectionString);
}
[GlobalCleanup]
public void GlobalCleanup()
{
      Dispose(true);
}</pre></li>
			</ol>
			<p>The <code>_context</code> variable provides us with our database access. The <code>GlobalSetup()</code> method gets our <a id="_idIndexMarker765"/>connection string from our secrets file, and creates a new <code>DatabaseContext</code> using the safely stored connection string. The <code>GlobalSetup()</code> method will run before our benchmarks. The <code>GlobalCleanup()</code> method calls the <code>Dispose(disposing)</code> method to clean up our managed resources after our benchmarks have finished running.</p>
			<ol>
				<li value="21">Next, add the <code>QueryDb()</code> method:<pre>[Benchmark]
public void QueryDb()
{
      var products = (from p in _context.Products
                      where p.Id &gt; 1select p);
foreach (var product in products)
    Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p>The <code>QueryDb()</code> method performs a simple LINQ query on the database by selecting products with an ID of <a id="_idIndexMarker766"/>greater than <code>1</code>. It then iterates each product in the <code>IQueryable&lt;Product&gt;</code> list and writes the product name out to the debug window. </p>
			<ol>
				<li value="22">Now, add the <code>QueryDbAsList()</code> method:<pre>[Benchmark]
public void QueryDbAsList()
{
List&lt;Product&gt; products = (from p in _context.Products
  where p.Id &gt; 1select p).ToList&lt;Product&gt;();
foreach (var product in products)
Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p><code>QueryDbAsList()</code> performs the same query as <code>QueryDb()</code>, except the processed type is of type <code>List&lt;Product&gt;</code>. </p>
			<ol>
				<li value="23">Add the <code>QueryDbAsIEnumerable()</code> method:<pre>[Benchmark]
public void QueryDbAsIEnumerable()
{
var products = (from p in _context.Products
                where p.Id &gt; 1
                select p).AsEnumerable&lt;Product&gt;();
foreach (var product in products)
    Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p>The <code>QueryDbAsIEnumerable()</code> method performs the same query as <code>QueryDbAsList</code>, but processes a<a id="_idIndexMarker767"/> type of <code>IEnumerable&lt;Product&gt;</code> instead. </p>
			<ol>
				<li value="24">Add the <code>QueryDbAsIEnumerator()</code> method:<pre>[Benchmark]
public void QueryDbAsIEnumerator()
{
      var products = (from p in _context.Products
                      where p.Id &gt; 1
                      select p).GetEnumerator();
    while (products.MoveNext())
    Debug.WriteLine(products.Current.Name);
}</pre></li>
			</ol>
			<p><code>QueryDbAsIEnumerator()</code> does the same as the previous methods but operates on a type of <code>IEnumerator&lt;Product&gt;</code> and iterates using a <code>while</code> loop instead of a <code>foreach</code> loop. </p>
			<ol>
				<li value="25">The final method in this class that we need to add is the <code>QueryDbAsIQueryable()</code> method:<pre>[Benchmark]
public void QueryDbAsIQueryable()
{
var products = (from p in _context.Products
                where p.Id &gt; 1
                select p).AsQueryable&lt;Product&gt;();
foreach (var product in products)
    Debug.WriteLine(product.Name);
}</pre></li>
			</ol>
			<p>This method is the same as <code>QueryDb</code> but explicitly operates on a type of <code>IQueryable&lt;Product&gt;</code>. </p>
			<ol>
				<li value="26">Replace the code in the <code>Main</code> method<a id="_idIndexMarker768"/> within the <code>Program</code> class with the following:<pre>BenchmarkRunner.Run&lt;DatabaseQueryAndIteration&gt;();</pre></li>
			</ol>
			<p>This code runs your benchmarks. Do a release build of the code and run the executable from the command line. You should see a summary report similar to the following:</p>
			<div><div><img src="img/B16617_07_04.jpg" alt="Figure 7.4: The different times and memory allocation of various database query types using LINQ&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: The different times and memory allocation of various database query types using LINQ</p>
			<p>Let us summarize what we learn <a id="_idIndexMarker769"/>from the summary report after running our query benchmarks:</p>
			<ul>
				<li>In terms of memory usage, the worst performer is the <code>QueryDb()</code> method followed by the <code>QueryDbAsList()</code> method. <code>QueryDbAsIEnumerable()</code> and <code>QueryDbAsIQueryable()</code> are both slightly better than the previous two. But the best performing method in terms of memory allocation out of all five methods is the <code>QueryDbAsIEnumerator()</code> method.</li>
				<li>Speed wise, the <code>QueryDb()</code> method was the worst again. Followed by <code>QueryDbAsIEnumerable()</code>, then <code>QueryDbAsList()</code>, and then <code>QueryDbAsIQueryable()</code>. And again, the best performer in terms of speed is the <code>QueryDbAsIEnumerator()</code> method.</li>
			</ul>
			<p>So, we can see that the best performing method for querying and iterating a database in both speed and memory usage terms is the <code>QueryDbAsIEnumerator()</code> method out of all the methods we've chosen to investigate. </p>
			<p>In the next section, we will be investigating which is the fastest method for obtaining the last item in a collection.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/>Getting the last value of a collection</h1>
			<p>You are now going to<a id="_idIndexMarker770"/> see how the LINQ method that obtains the last element in the collection is really slow when compared to directly accessing the item by its index. This will be accomplished using benchmarking to measure the performance of different methods:</p>
			<ol>
				<li value="1">Update the <code>Main</code> method as follows:<pre>static void Main(string[] args)
{
      BenchmarkRunner.Run&lt;LinqPerformance&gt;();
}</pre></li>
				<li>Open the <code>LinqPerformance</code> class.</li>
				<li>Add the <code>GetLastPersonVersion1()</code> method:<pre>[Benchmark]
public void GetLastPersonVersion1()
{
      var lastPerson = _people.Last();
}</pre></li>
			</ol>
			<p>This method gets the last person in the collection using the LINQ-provided <code>Last()</code> method. </p>
			<ol>
				<li value="4">Add the <code>GetLastPersonVersion2()</code> method:<pre>[Benchmark]
public void GetLastPersonVersion2()
{
      var lastPerson = _people[_people.Count - 1];
}</pre></li>
				<li>Here, we are using the index of the list to extract the last person in the list. At this point, it is worth noting that the difference between the two methods is that in the first method, this <code>Last()</code> method call is actually declared in <code>System.Linq.Enumerable</code>. The method signature is as follows:<pre>public static TSource Last&lt;TSource&gt;(this 
    IEnumerable&lt;TSource&gt; source);</pre></li>
			</ol>
			<p>So, the <code>Last()</code> call in<a id="_idIndexMarker771"/> the <code>GetLastPersonVersion1()</code> method performs various checks before the last value is returned. But the <code>GetLastPersonVersion2()</code> method does not perform these checks, and immediately returns the value at the last position. This explains why the method used in <code>GetLastPersonVersion1()</code> is much slower than accessing an element by its index in <code>GetLastPersonVersion2()</code>, as you will see in the following screenshot: </p>
			<div><div><img src="img/B16617_07_05.jpg" alt="Figure 7.5: Get Last Person example performance using the Last() method and direct index access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: Get Last Person example performance using the Last() method and direct index access</p>
			<p>Looking at the summary report of the benchmarks we have just run, it is evident that using the index for direct access is better than using the <code>Last()</code> method call in terms of improved performance.</p>
			<p>We have seen how we can quickly access the last element in a collection. Let us now consider why we should avoid<a id="_idIndexMarker772"/> using the <code>let</code> keyword in LINQ queries.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor145"/>Avoid using the let keyword in LINQ queries</h1>
			<p>You can use the <code>let</code> keyword to declare <a id="_idIndexMarker773"/>a variable and assign it a value to use in your LINQ query if the value is to be used several times within the query. At first glance, this may seem like you are improving performance since you only<a id="_idIndexMarker774"/> perform a single assignment, and then use the same variable several times. But this is not actually the case. Using the <code>let</code> keyword in your LINQ queries can actually decrease the performance of your LINQ query.</p>
			<p>Let us work through some benchmark examples. In the <code>LinqPerformance</code> class, do the following:</p>
			<ol>
				<li value="1">Add the <code>ReadingDataWithoutUsingLet()</code> method:<pre>[Benchmark]
public void ReadingDataWithoutUsingLet()
{
var result = from person in _people
    where person.LastName.Contains("Omega")
    &amp;&amp; person.FirstName.Equals("Upsilon")
    select person;
}</pre></li>
			</ol>
			<p>In this method, we are selecting people from the <code>_people</code> list with a last name of <em class="italic">Omega</em>, and a first name of <em class="italic">Upsilon</em> using LINQ without the <code>let</code> keyword.</p>
			<ol>
				<li value="2">Now, add the <code>ReadingDataUsingLet()</code> method:<pre>[Benchmark]
public void ReadingDataUsingLet()
{
      var result = from person in _people
      let lastName = person.LastName.Contains("Omega")
      let firstName = person.FirstName.Equals("Upsilon")
      where lastName &amp;&amp; firstName
      select person;
}</pre></li>
			</ol>
			<p>In this method, we are also selecting people from the <code>_people</code> list with a last name of <em class="italic">Omega</em> and a<a id="_idIndexMarker775"/> first name of <em class="italic">Upsilon</em>. But this time, we <a id="_idIndexMarker776"/>use the <code>let</code> keyword for both the filters and use them in the <code>where</code> clause.</p>
			<ol>
				<li value="3">Build the project and run the executable from the command line. You should see results similar to those shown in <em class="italic">Figure 7.6</em>:</li>
			</ol>
			<div><div><img src="img/B16617_07_06.jpg" alt="Figure 7.6: BenchmarkDotNet results for reading data with and without using the let keyword&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: BenchmarkDotNet results for reading data with and without using the let keyword</p>
			<p>As you can see from these results, the use of the <code>let</code> keyword in our query reduced the performance. The processing time increased and so did the memory allocation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You will see websites that promote the use of the <code>let</code> keyword in LINQ queries to improve performance and readability. But as you have seen in the example we have worked through, using the <code>let</code> keyword can seriously slow down the performance of your queries and increase memory usage. So, as a rule of thumb, take to measuring your performance for your particular queries and choosing the method that performs best for your query task.</p>
			<p>In this section, we<a id="_idIndexMarker777"/> have seen how the use of the <code>let</code> keyword can<a id="_idIndexMarker778"/> increase the time taken and memory used to perform a simple <code>select</code> query using LINQ. This performance decrease can become a real problem when working with large volumes of data. In the next section, we will look at several methods for grouping data and see which method performs the best.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/>Increasing Group By performance in LINQ queries</h1>
			<p>In this section, we will look at<a id="_idIndexMarker779"/> three different ways of performing the same <code>Group By</code> operation. Each way provides a different <a id="_idIndexMarker780"/>performance level. You will see by the end of this section which method is best for performing fast <code>Group By</code> queries. The methods that we add in this section will be added to the <code>LinqPerformance</code> class.</p>
			<p>For our scenario, we want to get a list of people from a collection that all share the same name. To extract those people, we will perform a <code>Group By</code> operation. Then, we will extract all those for whom the group count is greater than one, and then add them to a list of people. </p>
			<p>Let us add our three methods that use the <code>GroupBy</code> clause to return a list of people:</p>
			<ol>
				<li value="1">Add the <code>GroupByVersion1()</code> method:<pre>[Benchmark]
public void GroupByVersion1()
{
List&lt;Person&gt; People = _people.GroupBy(x =&gt; x.LastName)
              .Where(x =&gt; x.Count() &gt; 1)
              .SelectMany(group =&gt; group)
              .ToList();
}</pre></li>
			</ol>
			<p>As you can see, we are <a id="_idIndexMarker781"/>grouping on the person's last name. We then filter the groups to include only those groups with a count greater than <em class="italic">1</em>. Those groups are then selected and <a id="_idIndexMarker782"/>then returned as a list of people. </p>
			<ol>
				<li value="2">Now, add the <code>GroupByVersion2()</code> method:<pre>[Benchmark]
public void GroupByVersion2()
{
      IEnumerator&lt;IGrouping&lt;string, Person&gt;&gt; test = 
          _people.GroupBy(p =&gt; p.LastName)
    .Where(p =&gt; p.Count() &gt; 2).GetEnumerator();
List&lt;Person&gt; people = new List&lt;Person&gt;();
while (test.MoveNext())
{
    IGrouping&lt;string, Person&gt; current = test.Current;
    foreach (Person person in current)
    {
        people.Add(person);
    }
}
}</pre></li>
			</ol>
			<p>In this method, we obtain an enumerator by grouping people by their last name and then filtering the groups to only include those groups with a count of <em class="italic">2</em> or more. Then we declare a <a id="_idIndexMarker783"/>new list of people. We then loop<a id="_idIndexMarker784"/> through the enumerator and obtain the current <code>IGrouping&lt;string, Person&gt;</code>. The grouping is then iterated through, and each person in the group is added to the list of people. </p>
			<ol>
				<li value="3">Add the <code>GroupByVersion3()</code> method:<pre>[Benchmark]
public void GroupByVersion3()
{
      IEnumerator&lt;IGrouping&lt;string, Person&gt;&gt; test = 
        _people.ToArray().GroupBy(p =&gt; p.LastName)
    .Where(p =&gt; p.Count() &gt; 2).GetEnumerator();
    List&lt;Person&gt; people = new List&lt;Person&gt;();
while (test.MoveNext())
      {
    var current = test.Current;
    foreach (var person in current)
    {
        people.Add(person);
    }
}
}</pre></li>
			</ol>
			<p>The <code>GroupByVersion3()</code> method is the same as and behaves the same as the <code>GroupByVersion2()</code> method, but with one main difference. We convert the list of people to an array before we perform the <code>Group By</code>.</p>
			<ol>
				<li value="4">Add the following<a id="_idIndexMarker785"/> annotations to the top of the <code>LinqPerformance</code> class:<pre>[MemoryDiagnoser]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
[RankColumn]</pre></li>
			</ol>
			<p>These annotations will expand the data contained in the summary report as you will see shortly. Do a <a id="_idIndexMarker786"/>release build of the project and then run the project from the command line to benchmark these three methods. You should see the following benchmark summary report:</p>
			<div><div><img src="img/B16617_07_07.jpg" alt="Figure 7.7: The BenchmarkDotNet Group By summary report&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7: The BenchmarkDotNet Group By summary report</p>
			<p>As we can see, our first attempt at performing a <code>Group By</code> operation takes <em class="italic">2.204</em> microseconds, our second attempt takes <em class="italic">2.011</em> microseconds, and our third and final attempt takes <em class="italic">2.204</em> microseconds. So, we can see that converting our list to an array before performing a <code>Group By</code> speeds things up. Our final version is <em class="italic">0.243</em> microseconds faster than our original version, and that is despite the fact that more code is involved!</p>
			<p>The section that follows will <a id="_idIndexMarker787"/>take you through the benchmarking of<a id="_idIndexMarker788"/> five different ways to provide filtering of lists. You will see how the different methods affect the performance of LINQ queries.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>Filtering lists</h1>
			<p>In this section, we will look at<a id="_idIndexMarker789"/> various ways to filter a list using LINQ. We will see that the various ways all perform differently. By the end of this section, you will know the best way to filter a list for increased performance. You will be writing two different benchmarks that demonstrate query performance differences when using the <code>let</code> keyword and not using the <code>let</code> keyword. Let's begin writing our benchmarks:</p>
			<ol>
				<li value="1">Add the <code>FilterGroupsVersion1()</code> method:<pre>[Benchmark]
public List&lt;Person&gt; FilterGroupsVersion1()
{
 return (from p in _people where 
             _group1.Contains(p.LastName.ToLower())
             || _group2.Contains(p.LastName.ToLower())
             select p).ToList(
}</pre></li>
			</ol>
			<p>The first of our benchmarks filters people that belong to <code>_group1</code> and <code>_group2</code>. Since the arrays are in lowercase, <code>LastName</code> is also converted to lowercase. The filtered people are then returned as a list of people. </p>
			<ol>
				<li value="2">Add the <code>FilterGroupsVersion2()</code> benchmark:<pre>[Benchmark]
public List&lt;Person&gt; FilterGroupsVersion2()
{
      return (from p in _people
          let lastName = p.LastName.ToLower()
          where _group1.Contains(lastName)
          || _group2.Contains(lastName)
          select p).ToList();
}</pre></li>
			</ol>
			<p>This does the same as our first benchmark. The main difference is that we introduce the <code>lastName</code> variable using the <code>let</code> keyword, and assign it the lowercase <code>LastName</code> of the person.</p>
			<ol>
				<li value="3">Compile the project in<a id="_idIndexMarker790"/> release mode and run it from the command line. The benchmarks will be generated, and you should see a benchmark report similar to the one in <em class="italic">Figure 7.8</em>:</li>
			</ol>
			<div><div><img src="img/B16617_07_08.jpg" alt="Figure 7.8: Benchmark Report for LINQ with and without using the let keyword&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8: Benchmark Report for LINQ with and without using the let keyword</p>
			<p>We can see in the summary report that using the <code>let</code> keyword slows things down considerably. And so, we will now investigate why the <code>let</code> keyword slows things down.</p>
			<ol>
				<li value="4">Open <code>CH07_LinqPerformance.dll</code>.</li>
				<li>Expand <code>FilterGroupsVersion1</code> and <code>FilterGroupsVersion2</code>.</li>
				<li>Double-click on the method <code>FilterGroupsVersion1</code> to reveal the intermediate language generated by the compiler.</li>
				<li>Now, do the same<a id="_idIndexMarker791"/> with the <code>FilterGroupsVersion2</code> method. When you compare the IL for both methods, you will clearly see that the IL for <code>FilterGroupsVersion2</code> contains more lines of code than the IL for <code>FilterGroupsVersion1</code>.</li>
			</ol>
			<p>And that explains why the <code>let</code> version of the code performs slower than the original code that does not use the <code>let</code> keyword. But can we do better than <code>FilterGroupsVersion1</code> in terms of performance? Well, it turns out that, yes, we can. </p>
			<ol>
				<li value="8">Add the <code>FilterGroupsVersion3</code> method:<pre>[Benchmark]
public List&lt;Person&gt; FilterGroupsVersion3()
{
List&lt;Person&gt; people = new List&lt;Person&gt;();
for (int i = 0; i &lt; _people.Count; i++)
{
    var person = _people[i];
    var lastName = person.LastName.ToLower();
    if (
        _group1.Contains(lastName) 
        || _group2.Contains(lastName)
    )
    people.Add(person);
}
return people;
}</pre></li>
			</ol>
			<p>As you can see, we create a new people list. We then loop through the <code>_people</code> list. For each person, we get them from the <code>_people</code> list. We then assign the lowercase <a id="_idIndexMarker792"/>form of their name to a local variable. Using this variable, we check to see if either <code>_group1</code> or <code>_group2</code> contains the names. If they do, then the person is added to the <code>_people</code> list. Once the iteration has finished, the <code>_people</code> collection is returned.</p>
			<ol>
				<li value="9">Build and run the code again. You should see the following report:</li>
			</ol>
			<div><div><img src="img/B16617_07_09.jpg" alt="Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3's performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3's performance</p>
			<p>As you can see, we have three different versions of the code that produce the same output, and each one's execution time is different. Between these three different methods, <code>FilterGroupsVersion3</code> is by far the quickest method in achieving the desired result.</p>
			<ol>
				<li value="10">We will have another <a id="_idIndexMarker793"/>go at improving the performance of our LINQ filter query. Add the <code>FilterGroupsVersion4</code> method:<pre>[Benchmark]
public List&lt;Person&gt; FilterGroupsVersion4()
{
      List&lt;Person&gt; people = new List&lt;Person&gt;();
for (int i = 0; i &lt; _people.Count; i++)
{
    var person = _people[i];
    var lastName = person.LastName.ToLower();
    if (
        _group2.Contains(lastName) 
        || _group1.Contains(lastName)
    )
    people.Add(person);
}
return people;
}</pre></li>
			</ol>
			<p>It can be seen that the only difference between <code>FilterGroupsVersion3</code> and <code>FilterGroupsVersion4</code> is the ordering of the <code>if</code> condition check. </p>
			<ol>
				<li value="11">Build the project and run the benchmark tests. <em class="italic">Figure 7.10</em> shows the performance summary:</li>
			</ol>
			<div><div><img src="img/B16617_07_10.jpg" alt="Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4's performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4's performance</p>
			<p>It is clear from the benchmark report that version 4 of our filter is the winning method in terms of performance. So, why is version 4 better than version 3? The <code>_group2</code> array contains fewer items than <code>_group1</code>. If you understand the business domain, you will be able to order<a id="_idIndexMarker794"/> the filter checks in such a way that the arrays with fewer items will be checked first. </p>
			<p>You have seen how using the <code>let</code> keyword slows things down. But you have also seen how the ordering of checks in a conditional statement can also have an impact on performance. Placing the check with the least elements first within a conditional check statement will improve performance.</p>
			<p>In the next section, we will look at closures in LINQ statements and how they affect query performance.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor148"/>Understanding closures</h1>
			<p>In this section, we will understand closures from a C# perspective, and apply them to LINQ queries. Let's start with the<a id="_idIndexMarker795"/> definition of computer programming closures according to the content on Wikipedia.</p>
			<p class="author-quote">Wikipedia: "In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. </p>
			<p class="author-quote">Operationally, a closure is a record storing a function together with an environment. </p>
			<p class="author-quote">The environment is a mapping associating each free variable of the function (variables that are used locally but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.</p>
			<p class="author-quote">Unlike a plain function, a closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope."</p>
			<p>To understand what's being said here, we will begin by understanding what first-class functions are.</p>
			<p>A first-class function is a method that is treated by C# as a first-class data type. This means that you can assign a method to a variable and pass it around, and you can invoke it as you would a normal method. First-class functions can be created using anonymous methods<a id="_idIndexMarker796"/> and lambdas.</p>
			<p>Free variables are variables that are not parameter variables to a method, and they are variables that are not local to that method, which, in plain English, means that they are variables that exist outside of a method, but are being referenced within a method's closing scope.</p>
			<p>We are going to apply closures to a LINQ expression and benchmark them. The first one will be using LINQ with a closure that takes parameters, and the second one will be using LINQ with a closure that uses free variables. Follow these steps:</p>
			<ol>
				<li value="1">In the <code>LinqPerformance</code> class, comment out the current <code>[Benchmark]</code> annotated methods.</li>
				<li>Add the <code>LinqClosureUsingParameters</code> method:<pre>[Benchmark]
public void LinqClosureUsingParameters()
{           Func&lt;string, char, char, bool&gt; Between()
       {
             Func&lt;string, char, char, bool&gt; IsBetween 
                   = delegate (
              string param1, char param2, char param3)
             {
                 var character = param1[0];
                   return (
                         (character &gt;= param2) 
                         &amp;&amp; (character &lt;= param3)
                   );
             };
             return IsBetween;
       }
       var IsBetween = Between();
       var data = (from p in _people.ToList()
                where IsBetween(p.LastName, 'A', 'G')
                  select p).ToList();
}</pre></li>
			</ol>
			<p>In the <code>LinqClosureUsingParameters</code> method, we declare closure using a delegate with parameters. We declare a variable called <code>IsBetween</code> and assign the <code>Between</code> method to it. Then<a id="_idIndexMarker797"/> we perform a LINQ query and filter the results by calling <code>IsBetween</code>. The result is that we will have only those people whose last name's first letters are between A and G.</p>
			<ol>
				<li value="3">We can also use free variables. So, let us now look at a different example that uses free variables. Add the <code>LinqClosureUsingVariables</code> method:<pre>[Benchmark]
public void LinqClosureUsingVariables()
{
Func&lt;string, bool&gt; Between()
       {
                 char first = 'A';
           char last = 'G';
           Func&lt;string, bool&gt; IsBetweenAG = delegate 
               (string param1)
           {
                 var character = param1[0];
                return ((character &gt;= first) &amp;&amp; 
                    (character &lt;= last));
             };
             return IsBetweenAG;
       }
       var IsBetweenAG = Between();
       var data = (from p in _people.ToList()
                   where IsBetweenAG(p.LastName)
                    select p).ToList();
}</pre></li>
			</ol>
			<p>In the <code>LinqClosureUsingVariables</code> method, we declare our closure using free variables to declare the first and last characters used for filtering the dataset. We then <a id="_idIndexMarker798"/>assign the <code>Between</code> method to the <code>IsBetweenAG</code> variable. Then, we perform a LINQ query and filter the results by passing in the last name of each individual into the <code>IsBetweenAG</code> method.</p>
			<ol>
				<li value="4">Add a method called <code>NonLinqFilter</code>:<pre>[Benchmark]
public void NonLinqFilter()
{
       var data = _people.FindAll(
       x =&gt; x.LastName[0] &gt;= 'A' &amp;&amp; x.LastName[0] 
           &lt;= 'G');
}</pre></li>
			</ol>
			<p>In this method, we simply filter a list using its own <code>FindAll</code> method.</p>
			<ol>
				<li value="5">Make sure you are in Release<a id="_idIndexMarker799"/> mode and then run your project. You should end up with results similar to those in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B16617_07_11.jpg" alt="Figure 7.11: Closure benchmarks with and without parameters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11: Closure benchmarks with and without parameters</p>
			<p>As we can clearly see in the benchmarks of <em class="italic">Figure 7.11</em>, closures with parameters are faster and allocate less memory than closures without parameters. But it is far better to use a list's own <code>FindAll</code> method for filtering as it is faster and uses less allocated memory than LINQ and closures.</p>
			<p>A situation when you may need to apply your own custom closures for use in LINQ queries is when you have complex data manipulation and query generation that cannot be dealt with easily with normal LINQ. In this case, closures would be of benefit to you. Having performed the benchmarking of closures, you now know to use closures with parameters for optimal performance when using LINQ. But if you don't need to use LINQ, then using a list's own methods may be more advantageous. And if you do have to work on lists, then it could pay to do the filtering of the dataset using non-LINQ methods first, then perform your<a id="_idIndexMarker800"/> LINQ queries on the filtered lists.</p>
			<p>This chapter is now complete. But before we move on to <a href="B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152"><em class="italic">Chapter 8</em></a>, <em class="italic">File and Stream I/O</em>, let us summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/>Summary</h1>
			<p>In this chapter, we studied LINQ performance by benchmarking a variety of ways to query, group, filter, and iterate data obtained from databases and in-memory collections. The most performant way to query a database was found to be using the <code>IEnumerator</code> interface. By disassembling code, we saw that the <code>let</code> keyword can degrade performance due to the extra lines of IL code produced by the compiler. We also saw how accessing the last element in a collection using its index is faster than calling the <code>Last()</code> method. And we also learned that filtering lists by filtering on objects with the least items first improves filter performance operations. Closures provided better overall performance when passing in parameters, compared to not passing in parameters.</p>
			<p>In the next chapter, we will be looking at file and stream I/O performance. But for now, see if you can answer the following questions, and check out the further reading material to solidify what you have learned in this chapter.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor150"/>Questions</h1>
			<ol>
				<li value="1">Name some ways to improve LINQ performance.</li>
				<li>What is wrong with using the <code>let</code> keyword in a LINQ query?</li>
				<li>What is the best way to improve the performance of a <code>Group By</code> query?</li>
				<li>What performs better, closures with parameters, or closures without parameters?</li>
			</ol>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Further reading</h1>
			<ul>
				<li><strong class="bold">Console User Secrets</strong>: <a href="https://github.com/jasonshave/ConsoleSecrets">https://github.com/jasonshave/ConsoleSecrets</a>.</li>
				<li><strong class="bold">Optimising LINQ</strong>: <a href="https://mattwarren.org/2016/09/29/Optimising-LINQ/&#13;">https://mattwarren.org/2016/09/29/Optimising-LINQ/</a></li>
				<li><strong class="bold">Five Tips to Improve LINQ to SQL Performance</strong>: <a href="https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx">https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx</a>.</li>
				<li><strong class="bold">Make your C# applications faster with LINQ joins</strong>: <a href="https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins">https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins</a>.</li>
				<li><strong class="bold">LINQ Stinks – code smells in your LINQ</strong>: <a href="https://markheath.net/post/linq-stinks">https://markheath.net/post/linq-stinks</a>.</li>
				<li><strong class="bold">How to get a value out of a Span&lt;T&gt; with Linq expression trees?</strong>: <a href="https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees">https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees</a>.</li>
				<li><strong class="bold">Linq ToLookup Method in C#</strong>: <a href="https://dotnettutorials.net/lesson/linq-tolookup-operator/">https://dotnettutorials.net/lesson/linq-tolookup-operator/</a>.</li>
				<li><strong class="bold">LINQ (C#) – ToLookup Operator Example And Tutorial</strong>: <a href="https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php">https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php</a>.</li>
				<li><strong class="bold">A Simple Explanation of C# Closures</strong>: <a href="https://www.simplethread.com/c-closures-explained/">https://www.simplethread.com/c-closures-explained/</a>.</li>
			</ul>
		</div>
	</body></html>