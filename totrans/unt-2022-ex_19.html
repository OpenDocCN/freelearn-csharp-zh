<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-255"><a id="_idTextAnchor272" class="pcalibre1 pcalibre calibre6"/>14</h1>
<h1 id="_idParaDest-256" class="calibre5"><a id="_idTextAnchor273" class="pcalibre1 pcalibre calibre6"/>Entering Mixed Reality with the XR Interaction Toolkit</h1>
<p class="calibre3">In <a href="B18347_13.xhtml#_idTextAnchor256" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, we made some changes to our 3D FPS game’s enemy NPCs. We upgraded them from 2D to 3D components while still using waypoints for navigation but utilized Unity’s NavMesh system to rapidly implement the patrolling behavior. We also enhanced the complexity of the NPC behavior by adding sensors that allow them to interact with the player and the environment in a more realistic way.</p>
<p class="calibre3">We continued by discussing how to create dynamic enemy behavior using our sensors as conditions within behavior trees. We then completed our AI discussion with an introduction to <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) using <a id="_idIndexMarker1439" class="pcalibre1 pcalibre calibre6"/>Unity’s ML-Agents, which enables NPCs to learn and evolve. We can create remarkable experiences for our players by integrating advanced AI-based gameplay!</p>
<p class="calibre3">In this chapter, we’ll finish the journey that started with the 3D FPS game by creating the final boss room encounter in <strong class="bold">mixed reality</strong> (<strong class="bold">MR</strong>). We’ll accomplish this by using the <strong class="bold">Unity XR Interaction Toolkit</strong> along with assets, reusable components, and systems accumulated from previous efforts, all coming together to create a battle to take place in your own room!</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:<a id="_idTextAnchor274" class="pcalibre1 pcalibre calibre6"/></p>
<ul class="calibre17">
<li class="calibre15">Introduction to MR and development frameworks</li>
<li class="calibre15">Designing a boss room</li>
<li class="calibre15">Working with AR planes (AR Foundation)</li>
<li class="calibre15">Placing interactable objects in the world</li>
<li class="calibre15">Implementing the boss room mechanics</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to make an MR game or experience that incorporates the player’s physical space – such as walls, the floor, and tables – to create a novel experience for players. You’ll also learn how to create interactable objects and manage their instantiation, particularly with regard to detected surface planes that define the boundaries and objects of the physical space. The chapter completes the accumulation of knowledge required to rapidly build out features and behaviors when making games.</p>
<h1 id="_idParaDest-257" class="calibre5">Technical requirements<a id="_idTextAnchor275" class="pcalibre1 pcalibre calibre6"/></h1>
<p class="calibre3">To follow along with this chapter, you’ll need a Meta Quest 2 or 3 headset and a USB-C cable to connect it to your computer. The cable lets you push the Unity project build to your device and test some functionality directly in the Unity Editor’s play mode.</p>
<p class="callout-heading">If you don’t have an MR headset</p>
<p class="callout">You can still follow along in this chapter even without owning an MR headset – by using the Meta XR Simulator, available from the Unity Asset Store: <a href="https://assetstore.unity.com/packages/tools/integration/meta-xr-simulator-266732" class="pcalibre1 pcalibre calibre6">https://assetstore.unity.com/packages/tools/integration/meta-xr-simulator-266732</a>.</p>
<p class="calibre3">You can download the complete project from GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-258" class="calibre5"><a id="_idTextAnchor276" class="pcalibre1 pcalibre calibre6"/>Introduction to MR and development frameworks</h1>
<p class="calibre3"><strong class="bold">Mixed reality</strong> has <a id="_idIndexMarker1440" class="pcalibre1 pcalibre calibre6"/>only recently hit the forefront of what’s possible with the <a id="_idIndexMarker1441" class="pcalibre1 pcalibre calibre6"/>latest <strong class="bold">head-mounted displays</strong> (<strong class="bold">HMDs</strong>) to <a id="_idIndexMarker1442" class="pcalibre1 pcalibre calibre6"/>create environments where the physical and virtual worlds are blended to have digital and physical objects co-exist and appear to interact with one another. An MR gaming, educational, healthcare, or industrial application combines aspects of <a id="_idIndexMarker1443" class="pcalibre1 pcalibre calibre6"/>both <strong class="bold">virtual reality</strong> (<strong class="bold">VR</strong>) and <strong class="bold">augmented reality</strong> (<strong class="bold">AR</strong>) to offer <a id="_idIndexMarker1444" class="pcalibre1 pcalibre calibre6"/>an immersive experience where virtual content is anchored in the real world.</p>
<p class="calibre3">One doesn’t need to look much further than popular VR adaptations of popular PC games such <a id="_idIndexMarker1445" class="pcalibre1 pcalibre calibre6"/>as <strong class="bold">Skyrim VR</strong> or <strong class="bold">Resident Evil VR</strong> to<a id="_idIndexMarker1446" class="pcalibre1 pcalibre calibre6"/> understand that VR-based technology has a strong outlook for the future of virtual entertainment. Additionally, games<a id="_idIndexMarker1447" class="pcalibre1 pcalibre calibre6"/> such as <strong class="bold">Minecraft VR</strong> and <strong class="bold">Roblox VR</strong>, with <a id="_idIndexMarker1448" class="pcalibre1 pcalibre calibre6"/>their enormous and engaged player base no less, offer immersive experiences that turn otherwise static surroundings into dynamic worlds that allow interaction and exploration in unprecedented ways never experienced before.</p>
<p class="calibre3">The breakout success of the original VR <a id="_idIndexMarker1449" class="pcalibre1 pcalibre calibre6"/>title <strong class="bold">Beat Saber</strong> also shows the diverse potential of the platform, not only for entertainment but also for physically involved gameplay. The future of VR, AR, and MR will continue to interest us, so let’s be sure we’re armed with the tools to succeed in this space.</p>
<p class="calibre3">In this section, we’ll review the technology we’ll use to build our boss room game. The tech stack includes the<a id="_idIndexMarker1450" class="pcalibre1 pcalibre calibre6"/> Unity <strong class="bold">XR Interaction Toolkit</strong>, <strong class="bold">AR Foundation</strong> framework, and <a id="_idIndexMarker1451" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">OpenXR</strong> Meta<a id="_idIndexMarker1452" class="pcalibre1 pcalibre calibre6"/> package. These technologies on their own are powerful but combine one with another, and something new is created. They enable developers to create impressive <a id="_idIndexMarker1453" class="pcalibre1 pcalibre calibre6"/>MR <a id="_idIndexMarker1454" class="pcalibre1 pcalibre calibre6"/>experiences much more quickly when used in tandem.</p>
<p class="calibre3">Let’s have a brief overview of each and see how they harmonize.</p>
<h2 id="_idParaDest-259" class="calibre8"><a id="_idTextAnchor277" class="pcalibre1 pcalibre calibre6"/>XR Interaction Toolkit (XRI)</h2>
<p class="calibre3">Unity’s XRI is a<a id="_idIndexMarker1455" class="pcalibre1 pcalibre calibre6"/> versatile interaction system for VR/AR that simplifies and streamlines cross-platform creation. It provides a common framework for various interactions such as poking, gazing (i.e., rays), and grabbing for controllers and hands. It also includes virtual hands, haptic feedback, and responses for selections using scaling, animation, or even blend shapes.</p>
<p class="callout-heading">Additional reading | XR Interaction Toolkit (XRI)</p>
<p class="callout">XRI: <a href="https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/index.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/index.xhtml</a>.</p>
<p class="callout">XRI examples: <a href="https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples</a>.</p>
<p class="callout">XR: <a href="https://docs.unity3d.com/Manual/XR.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/XR.xhtml</a>.</p>
<p class="calibre3">The XRI toolkit dramatically simplifies the process of developing interactive VR and AR experiences by providing a comprehensive set of interaction components and systems, minimizing the barrier to entry for developers looking to enter this space. It allows for easy implementation of common functions such as head tracking, locomotion (i.e., movement), object interactions, and the UI within the virtual space. The toolkit is also flexible and modular, which provides an excellent foundation for creating an MR game.</p>
<p class="calibre3">Specifically for Unity 2022, Unity’s cross-platform MR development tools for the Meta Quest HMDs have moved from the experimental preview state to fully supported in the 2022 LTS release!</p>
<p class="calibre3">XRI provides the<a id="_idIndexMarker1456" class="pcalibre1 pcalibre calibre6"/> interaction part; now, let’s look at the environment part of these technologies.</p>
<h2 id="_idParaDest-260" class="calibre8"><a id="_idTextAnchor278" class="pcalibre1 pcalibre calibre6"/>AR Foundation</h2>
<p class="calibre3">Unity’s AR Foundation<a id="_idIndexMarker1457" class="pcalibre1 pcalibre calibre6"/> is a cross-platform framework that provides a unified API for simplifying building applications for mobile and head-worn AR/MR devices. The package is designed to work natively with XRI (and XR Hands), significantly reducing any hurdles for developers accessing the specific device features to support building AR applications.</p>
<p class="callout-heading">Additional reading | AR Foundation</p>
<p class="callout">AR Foundation: <a href="https://unity.com/unity/features/arfoundation" class="pcalibre1 pcalibre calibre6">https://unity.com/unity/features/arfoundation</a></p>
<p class="callout">Unity documentation: <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/index.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/index.xhtml</a></p>
<p class="calibre3">More specifically, AR Foundation is the layer that <a id="_idIndexMarker1458" class="pcalibre1 pcalibre calibre6"/>unifies <strong class="bold">ARCore</strong> (Google) and <strong class="bold">ARKit</strong> (Apple) APIs <a id="_idIndexMarker1459" class="pcalibre1 pcalibre calibre6"/>into a single higher-level API. This single API allows developers to write code once where the specific feature implementations of the underlying platforms are handled automagically.</p>
<p class="calibre3">AR Foundation simplifies building spatial awareness into applications, making digital objects appear interactable with the real world. This is crucial for creating MR experiences that seamlessly blend the virtual and the real world.</p>
<p class="calibre3">We’ll be working specifically on<a id="_idIndexMarker1460" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Meta Quest HMD</strong> platforms. Our boss room game will be compatible with Quest 2 and Quest 3 devices. The AR Foundation support for Meta Quest is built using a familiar industry-adopted standard interface for XR hardware and software, and<a id="_idIndexMarker1461" class="pcalibre1 pcalibre calibre6"/> that interface is called <strong class="bold">OpenXR</strong>.</p>
<p class="calibre3">AR Foundation provides the visual part; now, let’s look at the platform support part of these technologies.</p>
<h2 id="_idParaDest-261" class="calibre8"><a id="_idTextAnchor279" class="pcalibre1 pcalibre calibre6"/>OpenXR: Meta package</h2>
<p class="calibre3"><strong class="bold">OpenXR</strong> is an<a id="_idIndexMarker1462" class="pcalibre1 pcalibre calibre6"/> open, royalty-free standard that enables high-performance access via a unified interface across multiple AR and VR hardware and software platforms and devices, collectively known as XR.</p>
<p class="calibre3">Developing with OpenXR simplifies the development process by allowing developers to target any supporting OpenXR system without worrying about specific platform details. The Meta package (available since Unity 2022.3.11.f1) contains <strong class="bold">Meta-specific OpenXR</strong> extensions<a id="_idIndexMarker1463" class="pcalibre1 pcalibre calibre6"/> and Meta’s <strong class="bold">AR Foundation provider plugin</strong> for its <a id="_idIndexMarker1464" class="pcalibre1 pcalibre calibre6"/>Quest devices – it ensures compatibility and interoperability between the software and hardware to support its specific input devices, head-mounted displays, and other peripherals.</p>
<p class="callout-heading">Additional reading | OpenXR</p>
<p class="callout">Kronos Group: OpenXR: <a href="https://www.khronos.org/openxr/" class="pcalibre1 pcalibre calibre6">https://www.khronos.org/openxr/</a></p>
<p class="calibre3">To summarize, OpenXR is the glue that binds the interaction and visual systems to any supporting hardware devices – especially new devices that feature better graphics performance and sensors. The trio of technologies, when combined, enable developers to rapidly create prototypes and deploy production-ready MR games and experiences – XRI provides the foundation for interactive elements, AR Foundation builds on the ability to merge digital and physical-world visuals, and OpenXR ensures the experiences are accessible across different devices.</p>
<div><div><img alt="Figure 14.1 – Unity XR tech stack" src="img/B18347_14_01.jpg" class="calibre158"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Unity XR tech stack</p>
<p class="calibre3">In this section, we learned what Unity MR technologies are available to us and that this combination of MR-based technologies not only simplifies development but also enables the creation <a id="_idIndexMarker1465" class="pcalibre1 pcalibre calibre6"/>of complex, engaging MR applications to have broad end-user reach. This brings us right into the next section, where we’ll get down to the business of designing our MR boss room.</p>
<h1 id="_idParaDest-262" class="calibre5"><a id="_idTextAnchor280" class="pcalibre1 pcalibre calibre6"/>Designing a boss room</h1>
<p class="calibre3">Designing a boss<a id="_idIndexMarker1466" class="pcalibre1 pcalibre calibre6"/> room encounter is a critical part of game creation that combines aspects of narrative, mechanical, and environmental considerations to create an engaging and challenging experience for players.</p>
<p class="calibre3">There are several key areas to consider when designing a boss room encounter, and we’ll take a shallow dive into a few:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Narrative element</strong>: The encounter should feel like a natural progression or even the story’s climax.</li>
<li class="calibre15"><strong class="bold">Boss mechanics</strong>: The player’s battle with the boss element should stand out as a unique experience, separate from the player mechanics mainly being used, requiring players to adapt a strategy to overcome attack patterns and other behaviors.</li>
<li class="calibre15"><strong class="bold">Environment design</strong>: The layout of the boss room itself should complement the narrative and mechanics being implemented. This is a special consideration for MR because we’ll use the player’s own room (i.e., their physical space) to construct the gameplay environment and place the interactive elements, creating a novel challenge for each player.</li>
<li class="calibre15"><strong class="bold">Balancing</strong>: Challenges presented by boss encounters should be demanding yet feel pretty balanced to avoid undue frustration while still providing a solvable challenge for the player.</li>
</ul>
<p class="calibre3">By incorporating these elements into our boss room, we aim to offer players an enjoyable and unforgettable experience. Overcoming the <em class="italic">boss challenge</em> will give them a sense of satisfaction and accomplishment. Moreover, with MR included in our case, the experience<a id="_idIndexMarker1467" class="pcalibre1 pcalibre calibre6"/> becomes even more remarkable and rewarding.</p>
<p class="calibre3">Let’s revisit our GDD for a moment to get a quick update for the boss room battle added that will provide the context we’ll follow when setting up our scene.</p>
<table class="no-table-style" id="table001-8">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is the habitat interior’s </strong><strong class="bold">boss encounter?</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3">In the game’s climax, players must infiltrate a heavily guarded central control room to re-energize the reactor that’s been turned off – its crystal modules have been ejected – by the evil alien plant entity that has taken over. The outcome of this battle will determine the future of the Kryk’zylx race on the planet.</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 14.1 – GDD snippet setting the scene for the boss battle</p>
<p class="calibre3">Very nice. The context has been set, and we have some story background for the purpose of the boss battle. You are not just some kid from a trailer park; you are a Kryk’zylx scout! As such, you are armed with the most advanced energy-based weaponry, such as this laser pistol: pew-pew!</p>
<div><div><img alt="Figure 14.2 – XR interactable gun" src="img/B18347_14_02.jpg" class="calibre159"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.2 – XR interactable gun</p>
<p class="calibre3">Let’s start by first <a id="_idIndexMarker1468" class="pcalibre1 pcalibre calibre6"/>defining our physical space, then move on to creating the Unity project and testing our MR setup.</p>
<h2 id="_idParaDest-263" class="calibre8"><a id="_idTextAnchor281" class="pcalibre1 pcalibre calibre6"/>Setting up the physical space</h2>
<p class="calibre3">Properly defining <a id="_idIndexMarker1469" class="pcalibre1 pcalibre calibre6"/>the physical space set up on the device<a id="_idIndexMarker1470" class="pcalibre1 pcalibre calibre6"/> for an MR game is of utmost importance, as it directly impacts the possibilities available in the immersive experience. It seamlessly blends virtual content, such as the horizontal AR surface planes defined for walls, the floor, the ceiling, tables, and seats, in addition to vertical AR surface planes, such as doors and windows. Having these virtual surface objects in place for their real-world counterparts enhances gameplay, ensures safety, and maximizes the player’s engagement. The physical space environment setup also serves as an interactive canvas for the game developer’s storytelling and exploration.</p>
<p class="calibre3">For Meta Quest 3, the headset includes a depth sensor to scan your room surroundings and detect the floor, walls, and ceiling to establish a starting point for your physical space setup. Once you’ve finished the room scan, you can manually confirm the walls and add furniture.</p>
<p class="calibre3">For Meta Quest 2, you’ll have to set up your physical space entirely manually.</p>
<p class="callout-heading">Meta Quest room setup</p>
<p class="callout">For plane detection to function correctly on a Meta Quest device, you must first complete the new <strong class="bold">Room Setup</strong> feature found in <strong class="bold">Settings</strong> | <strong class="bold">Physical Space</strong> | <strong class="bold">Space Setup</strong> on the Quest headset before entering an MR game. To ensure optimal performance, it’s also recommended to include at least one piece of furniture with a horizontal surface, such as a table.</p>
<p class="calibre3">Please note that the MR game we’ll create relies on providing examples for the different surface planes established by either the physical scan or manual space setup. You must ensure your room includes at least four walls and a table.</p>
<p class="calibre3">You can perform the room setup any time before running an MR game or experience, so you can do this at your leisure. But for now, we’ll move on to creating and setting up our Unity project<a id="_idIndexMarker1471" class="pcalibre1 pcalibre calibre6"/> to <a id="_idIndexMarker1472" class="pcalibre1 pcalibre calibre6"/>get started with our boss room battle.</p>
<h2 id="_idParaDest-264" class="calibre8"><a id="_idTextAnchor282" class="pcalibre1 pcalibre calibre6"/>Creating the Unity project</h2>
<p class="calibre3">Install the <a id="_idIndexMarker1473" class="pcalibre1 pcalibre calibre6"/>latest Unity 2022.3 LTS release if you haven’t already – this is<a id="_idIndexMarker1474" class="pcalibre1 pcalibre calibre6"/> so we have access to the new VR and MR templates in <strong class="bold">Unity Hub</strong>. We’ll <a id="_idIndexMarker1475" class="pcalibre1 pcalibre calibre6"/>also require the <strong class="bold">Android Build Support</strong> module to be available, so ensure you have that, along with the <strong class="bold">OpenJDK</strong> and <strong class="bold">Android SDK &amp; NDK Tools</strong> modules installed.</p>
<div><div><img alt="Figure 14.3 – Install the Android Build Support module" src="img/B18347_14_03.jpg" class="calibre160"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Install the Android Build Support module</p>
<p class="calibre3">With the minimum required Unity Editor version and Android dependency modules now installed, we’re ready to rapidly set up our MR boss room project using Unity’s new <strong class="bold">Mixed Reality</strong> (Core) template. It’s built upon the core MR technologies outlined in the <em class="italic">Introduction to MR and development frameworks</em> section. How very convenient!</p>
<p class="calibre3">The MR template project simplifies XR development by streamlining the implementation of advanced features such as plane detection, device passthrough, and spatial UI creation alongside designer-friendly XR interactable components. It comes pre-configured with essential packages such as XRI, AR Foundation, Unity OpenXR Meta, and XR Hands, making project setup and package management a breeze. This MR project template approach targets the needs of MR creators for richer content and reduces developer <a id="_idIndexMarker1476" class="pcalibre1 pcalibre calibre6"/>friction<a id="_idIndexMarker1477" class="pcalibre1 pcalibre calibre6"/> in accessing advanced MR features.</p>
<p class="callout-heading">Additional reading | Unity MR template</p>
<p class="callout">Mixed Reality Template Quick Start Guide: <a href="https://docs.unity3d.com/Packages/com.unity.template.mixed-reality%401.0/manual/index.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.template.mixed-reality%401.0/manual/index.xhtml</a></p>
<p class="callout">Explore cross-platform MR development on Meta Quest 3: <a href="https://blog.unity.com/engine-platform/cross-platform-mixed-reality-development-on-meta-quest-3" class="pcalibre1 pcalibre calibre6">https://blog.unity.com/engine-platform/cross-platform-mixed-reality-development-on-meta-quest-3</a></p>
<p class="calibre3">Open Unity Hub and click the <strong class="bold">New Project</strong> button (top-right corner) to create a new project. Then, referring to <em class="italic">Figure 14</em><em class="italic">.4</em>, follow these steps.</p>
<ol class="calibre14">
<li class="calibre15">Ensure the Unity 2022.3 LTS version previously installed is selected in the <strong class="bold">Editor Version</strong> dropdown at the top.</li>
<li class="calibre15">In the center template list, scroll down and select <strong class="bold">Mixed </strong><strong class="bold">Reality</strong> (Core).</li>
<li class="calibre15">In the right pane, if you’re prompted with a <strong class="bold">Download template</strong> button, click to download the template.</li>
<li class="calibre15">Once the template finishes downloading, provide these options:<ul class="calibre22"><li class="calibre15"><code>MR </code><code>Boss Room</code>.</li><li class="calibre15"><strong class="bold">Location</strong>: Select the folder path for where to store your project files.</li><li class="calibre15"><strong class="bold">Unity Cloud Organization</strong>: You must select the organization to which this project will belong. When you create a new Unity ID account, Unity generates an organization associated with your username and ID. The base feature a Unity organization provides is the ability to organize your projects, services, and licenses.</li><li class="calibre15"><strong class="bold">Connect to Unity Cloud</strong>: Only enable this if you wish to take advantage of gaming<a id="_idIndexMarker1478" class="pcalibre1 pcalibre calibre6"/> services<a id="_idIndexMarker1479" class="pcalibre1 pcalibre calibre6"/> for your project (generally, yes, you’ll want this).</li><li class="calibre15"><strong class="bold">Use Unity Version Control</strong>: Enable this option if you want to have Unity Cloud’s <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) back<a id="_idIndexMarker1480" class="pcalibre1 pcalibre calibre6"/> up your project to the cloud and allow additional team members to collaborate on the project (we’ll cover Unity Version Control in <a href="B18347_15.xhtml#_idTextAnchor301" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>).</li></ul></li>
</ol>
<div><div><img alt="Figure 14.4 – New Mixed Reality project from a template" src="img/B18347_14_04.jpg" class="calibre161"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.4 – New Mixed Reality project from a template</p>
<ol class="calibre14">
<li value="5" class="calibre15">To start creating the project, click the <strong class="bold">Create project</strong> button and relax for a few minutes.</li>
</ol>
<p class="calibre3">Let’s finalize some essential setup steps once the project opens in the Unity Editor.</p>
<p class="calibre3">Open <strong class="bold">File</strong> | <strong class="bold">Build Settings…</strong> and follow these steps to configure the platform to support building to our Meta Quest device:</p>
<ol class="calibre14">
<li class="calibre15">Select <strong class="bold">Android</strong> in the <strong class="bold">Platform</strong> list.</li>
<li class="calibre15">Select <strong class="bold">ASTC</strong> from the <strong class="bold">Texture </strong><strong class="bold">Compression</strong> dropdown.</li>
<li class="calibre15">Click the <strong class="bold">Switch </strong><strong class="bold">Platform</strong> button.</li>
</ol>
<p class="calibre3">Done!</p>
<p class="callout-heading">ASTC</p>
<p class="callout"><strong class="bold">Adaptable Scalable Texture Compression</strong> (<strong class="bold">ASTC</strong>) is a texture compression method <a id="_idIndexMarker1481" class="pcalibre1 pcalibre calibre6"/>that uses variable block sizes instead of a single fixed size and replaces older formats while also providing additional features.</p>
<p class="calibre3">You can now open the <code>SampleScene</code> scene located in the <code>Assets/Scenes</code> folder to examine the <a id="_idIndexMarker1482" class="pcalibre1 pcalibre calibre6"/>scene setup, including the following GameObjects<a id="_idIndexMarker1483" class="pcalibre1 pcalibre calibre6"/> responsible for managing the XR features, including controller and hand tracking, interaction with the UI and virtual objects, and AR features such as surface plane detection and passthrough: <strong class="bold">MR Interaction Setup</strong>, <strong class="bold">UI</strong>, and <strong class="bold">Environment</strong>.</p>
<p class="callout-heading">Universal RP renderer settings</p>
<p class="callout">Please note that the <a id="_idIndexMarker1484" class="pcalibre1 pcalibre calibre6"/>Meta Quest headset is sensitive to the Unity renderer settings being correctly configured for the platform. Therefore, I suggest keeping the URP renderer and quality settings at the default values provided by the MR project template (unless you really know what you’re doing).</p>
<p class="callout">Also note that standalone VR hardware, such as the Quest, requires additional consideration for performance optimization to sustain a minimum FPS (typically, not less than 72 FPS): this is to prevent vection (the visual perception of motion while the body is still), which can make people nauseous.</p>
<p class="calibre3">With your Quest headset attached to your system with the USB-C cable, you can verify the device is recognized by Unity by going to the <strong class="bold">Build Settings</strong> window with the <strong class="bold">Android</strong> platform selected, in the <strong class="bold">Run Device</strong> field, and clicking the dropdown that currently shows <strong class="bold">Default device</strong>. Your Meta/Oculus Quest 3 (or 2) device should be listed there.</p>
<p class="callout-heading">Testing in Play Mode with Quest Link</p>
<p class="callout">To thoroughly <a id="_idIndexMarker1485" class="pcalibre1 pcalibre calibre6"/>test and play our game, we must build to the<a id="_idIndexMarker1486" class="pcalibre1 pcalibre calibre6"/> device because plane detection and passthrough are currently not supported with Quest Link when entering Play Mode in the Unity Editor. I would still recommend leveraging Quest Link for rapidly iterating on setting up object interactions independent of the gameplay and then building to the device for complete gameplay testing.</p>
<p class="callout">To use Quest Link, ensure you are connected to your system with the USB-C cable and have the Oculus app (Meta Quest Link) running, then click the Quest Link button on the Quest headset’s <strong class="bold">Quick Settings</strong> menu. Once established, you can enter Play Mode in Unity to playtest your scene.</p>
<p class="calibre3">Now, still in<a id="_idIndexMarker1487" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Build Settings</strong> window, click <strong class="bold">Build And Run</strong>, or <a id="_idIndexMarker1488" class="pcalibre1 pcalibre calibre6"/>press <em class="italic">Ctrl/Cmd</em> + <em class="italic">B</em> and pop on that headset!</p>
<p class="callout-heading">Tip</p>
<p class="callout">It’s vital to recenter or reset your orientation when you begin a MR environment. This ensures that virtual objects are placed correctly about your current position and facing direction. Doing this will enhance your experience, especially as device orientation detection technology continues to improve.</p>
<p class="calibre3">The MR template is configured to use either controllers or hands. Still, we’ll focus on using the controllers for our game, so I’d recommend you play around with using the controllers as input in the sample project.</p>
<p class="calibre3">This verifies your Quest headset device and Unity MR project setup for XR development are ready. So, let’s<a id="_idIndexMarker1489" class="pcalibre1 pcalibre calibre6"/> start<a id="_idIndexMarker1490" class="pcalibre1 pcalibre calibre6"/> building out the boss room!</p>
<h2 id="_idParaDest-265" class="calibre8"><a id="_idTextAnchor283" class="pcalibre1 pcalibre calibre6"/>Laying out the boss room scene</h2>
<p class="calibre3">According to our<a id="_idIndexMarker1491" class="pcalibre1 pcalibre calibre6"/> GDD, we must clear the central control system from the evil plant entity infestation. So, to do that, we need to energize the sabotaged control console and restart the reactor (yes, believe me, that will do the trick). Therefore, the boss room’s layout requires objects related to this context to be present in our scene.</p>
<p class="calibre3">Here are the objects we’ll need for our boss room setup:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Control console</strong>: Maintains the state of all the habitation station’s primary systems, including the main power reactor. It has three crystal module slots for energizing the system.</li>
<li class="calibre15"><strong class="bold">Power reactor</strong>: Provides power to the central systems, especially the ones in charge of environmental control and eradicating foreign entities.</li>
<li class="calibre15"><strong class="bold">Corridors</strong>: The habitat station comprises several rooms and connecting corridors – this should already be familiar from the 3D FPS project.</li>
</ul>
<p class="calibre3">These are the primary objects we need in our scene, which, again, is your room, to provide the setting for the boss encounter. We’ll construct the layout to have the control console near the player and virtual corridors extending from the center of the room, providing a central focal point for the action.</p>
<p class="calibre3">With this layout in mind, in the following screenshot – from a Quest 3 with a passthrough visible – we can see the objects instantiated in this fashion in a real-world room.</p>
<div><div><img alt="Figure 14.5 – Virtual objects spawned in a physical space" src="img/B18347_14_05.jpg" class="calibre162"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Virtual objects spawned in a physical space</p>
<p class="calibre3">Let’s first duplicate<a id="_idIndexMarker1492" class="pcalibre1 pcalibre calibre6"/> the provided MR template’s sample scene to start setting up the scene:</p>
<ol class="calibre14">
<li class="calibre15">Find the <code>SampleScene</code> scene in the <code>Assets/Scenes</code> folder.</li>
<li class="calibre15">Duplicate it by selecting and pressing <em class="italic">Crtl/Cmd</em> + <em class="italic">D</em>.</li>
<li class="calibre15">Rename it to <code>Boss Room</code>.</li>
</ol>
<p class="calibre3">Now, open the scene, and we’ll deactivate some example content provided in the scene Hierarchy that we won’t use. Select and deactivate the following objects (using the checkbox at the top of the Inspector to the left of the object’s name):</p>
<ol class="calibre14">
<li class="calibre15">Disable these two child objects of <code>MR </code><code>Interaction Setup</code>:<ul class="calibre22"><li class="calibre15"><code>Goal Manager</code></li><li class="calibre15"><code>Object Spawner</code></li></ul></li>
<li class="calibre15">Disable these two child objects of <code>UI</code>:<ul class="calibre22"><li class="calibre15"><code>Coaching UI</code></li><li class="calibre15"><code>Hand </code><code>Menu Setup</code></li></ul></li>
<li class="calibre15">Save the scene.</li>
</ol>
<p class="calibre3">We’re done! We now have an empty scene with all the XR setup ready for us to create our MR game. Easy-peasy.</p>
<p class="calibre3">In this section, we covered the fundamental principles of designing a boss room and the steps required to set up our physical space with our Quest devices. Additionally, we learned how to create a basic starting project using Unity’s MR template and configuring it for our use.</p>
<p class="calibre3">When creating the virtual objects that construct our boss room, we use AR surface planes representing<a id="_idIndexMarker1493" class="pcalibre1 pcalibre calibre6"/> real-world objects in our physical space to spawn them dynamically. Let’s explore how to spawn virtual objects using detected AR planes next.</p>
<h1 id="_idParaDest-266" class="calibre5"><a id="_idTextAnchor284" class="pcalibre1 pcalibre calibre6"/>Working with AR planes (AR Foundation)</h1>
<p class="calibre3">AR planes are<a id="_idIndexMarker1494" class="pcalibre1 pcalibre calibre6"/> virtual representations of flat planar surfaces, both horizontal and vertical, represented by dimensions and boundary points and detected by the AR Foundation technology. The planes provide a foundation for accurately placing digital objects and interacting with the surfaces.</p>
<p class="calibre3">As previously mentioned, these planes represent the walls, floor and ceiling, tables, and so on, and we’ll use the walls, floor, and table specifically in this example boss room to blend the gameplay seamlessly with the player’s physical surroundings.</p>
<p class="callout-heading">Tip</p>
<p class="callout"><strong class="source-inline1">AR Plane Manager</strong> allows you to specify a prefab for plane visualization. The <strong class="source-inline1">AR Plane</strong> Prefab, provided by the MR template, uses a shader that occludes objects assigned a material with transparency, so if you want objects that are meant to be seen past the AR planes, ensure you don’t use a transparent material.</p>
<p class="calibre3">Now, let’s start working with our first horizontal plane type, the table, to see how we can detect the <a id="_idIndexMarker1495" class="pcalibre1 pcalibre calibre6"/>plane type and use its properties to spawn an object.</p>
<h2 id="_idParaDest-267" class="calibre8"><a id="_idTextAnchor285" class="pcalibre1 pcalibre calibre6"/>Spawning using planes with AR Plane Manager</h2>
<p class="calibre3">The <code>AR Plane Manager</code> component, located<a id="_idIndexMarker1496" class="pcalibre1 pcalibre calibre6"/> on<a id="_idIndexMarker1497" class="pcalibre1 pcalibre calibre6"/> the <code>XR Origin (XR Rig)</code> object as a child of the <code>MR Interaction Setup</code> root object, is responsible for the detection of the horizontal and vertical surfaces in the physical space and creates the virtual plane objects (<code>AR Plane</code> Prefab) that our virtual content can be placed and interacted with.</p>
<p class="callout-heading">Optimization note</p>
<p class="callout">With <strong class="source-inline1">AR Plane Manager</strong>, in addition to specifying the <strong class="source-inline1">AR Plane</strong> Prefab, you can choose between horizontal, vertical, or both for <strong class="bold">Detection Mode</strong>. Turning off vertical plane detection is recommended if you only need to detect horizontal planes.</p>
<p class="calibre3">One of the first things we’ll have to do is enable the <code>AR Plane Manager</code> component because it is deactivated by default within the MR sample scene. We’ll do that with our first script, the game manager.</p>
<p class="calibre3">Create a new script named <code>GameManager</code> in the <code>Assets/Scripts</code> folder, and start with the following code:</p>
<pre class="source-code">
using UnityEngine.XR.ARFoundation;
public class GameManager : MonoBehaviour
{
    [SerializeField]
    private ARPlaneManager _planeManager;
    private IEnumerator Start()
    {
        yield return new WaitForSeconds(2f);
        EnablePlaneManager();
    }
    public void EnablePlaneManager()
        =&gt; _planeManager.enabled = true;
}</pre> <p class="calibre3">Now, create a GameObject in the scene and attach this script to it. As you can see, we’ve changed the method signature for the <code>Start()</code> method to be an <code>IEnumerator</code> (yes, you can do that), and we’ve delayed the execution of the <code>EnablePlaneManager()</code> method call for 2 seconds (to give XR components time to initialize).</p>
<p class="calibre3">Assign <code>_planeManager</code> in the<a id="_idIndexMarker1498" class="pcalibre1 pcalibre calibre6"/> Inspector <a id="_idIndexMarker1499" class="pcalibre1 pcalibre calibre6"/>by dragging in the <code>XR Origin (XR Rig)</code> object to the field on the <code>GameManager</code> component. We’re enabling the component in the <code>EnablePlaneManager()</code> method like so:</p>
<pre class="source-code">
    _planeManager.enabled = true;</pre> <p class="calibre3">You can now playtest the boss room scene by first ensuring the scene is added to <strong class="bold">Scenes in Build</strong> in the <strong class="bold">Build Settings</strong> window, connecting your Quest device to your system via the USB-C cable, and clicking <strong class="bold">Build And Run</strong> (<em class="italic">Ctrl/Cmd</em> + <em class="italic">B</em>, i.e., <em class="italic">build </em><em class="italic">and run)</em>.</p>
<p class="calibre3">You should see something similar to the following figure, where the detected planes for the walls, floor and ceiling, and any horizontal surfaces such as tables have a fading dotted material. Note that I’ve manually added the magenta lines for better visibility of the planar surfaces (which include a table, the walls, and the floor).</p>
<div><div><img alt="Figure 14.6 – Detected surface planes in the room" src="img/B18347_14_06.jpg" class="calibre163"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Detected surface planes in the room</p>
<p class="calibre3">Now that we’ve<a id="_idIndexMarker1500" class="pcalibre1 pcalibre calibre6"/> verified we have planes to<a id="_idIndexMarker1501" class="pcalibre1 pcalibre calibre6"/> work with, let’s start spawning in our virtual objects for the boss room.</p>
<h2 id="_idParaDest-268" class="calibre8"><a id="_idTextAnchor286" class="pcalibre1 pcalibre calibre6"/>Instantiating on a table plane</h2>
<p class="calibre3">Whoa, wait<a id="_idIndexMarker1502" class="pcalibre1 pcalibre calibre6"/> a second… we need the objects we’ll be<a id="_idIndexMarker1503" class="pcalibre1 pcalibre calibre6"/> spawning into the room. We can<a id="_idIndexMarker1504" class="pcalibre1 pcalibre calibre6"/> thank <strong class="bold">Polypix Studios</strong> again for providing 3D art for these assets: console, module, reactor, corridor, gun, and hover bot.</p>
<p class="callout-heading">Boss room virtual objects</p>
<p class="callout">You can download <strong class="source-inline1">VirtualObjects-start.zip</strong> from the book’s GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Art-Assets</a>.</p>
<p class="callout">Unzip the file to get the '<strong class="source-inline1">.unitypackage</strong>' file and import it into your project – you can do that by dragging and dropping the file from your system’s file manager to Unity’s <strong class="bold">Project</strong> window.</p>
<p class="calibre3">The first asset we’ll work with is the reactor model imported as the <code>Reactor</code> Prefab in the <code>Assets/Prefabs</code> folder, as seen in the following screenshot:</p>
<div><div><img alt="Figure 14.7 – Boss room 3D asset Prefabs" src="img/B18347_14_07.jpg" class="calibre164"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Boss room 3D asset Prefabs</p>
<p class="calibre3">And we’ll spawn the <code>Reactor</code> Prefab on the first table detected in the room.</p>
<p class="calibre3"><code>AR Plane Manager</code> provides a <code>planesChanged</code> event that we’ll subscribe to, and when a <code>PlaneClassification</code> is of the <code>Table</code> type, we know we should spawn the reactor. So, let’s add the listener in our <code>GameManager</code> class and the handler method<a id="_idIndexMarker1505" class="pcalibre1 pcalibre calibre6"/> for <a id="_idIndexMarker1506" class="pcalibre1 pcalibre calibre6"/>spawning the object:</p>
<pre class="source-code">
public void EnablePlaneManager()
{
    _planeManager.enabled = true;
    _planeManager.planesChanged += OnPlanesChanged;
}</pre> <p class="calibre3">Don’t forget to unsubscribe from the listener in <code>OnDisable()</code> or <code>OnDestroy()</code>.</p>
<p class="calibre3">Now, add the handler method:</p>
<pre class="source-code">
private void OnPlanesChanged(ARPlanesChangedEventArgs args)
{
    foreach (var plane in args.added)
    {
        switch (plane.classification)
        {
            case PlaneClassification.Table:
                if (!_hasSpawnedPrefab_Reactor)
                {
                    SpawnPrefab(plane, _prefabReactor);
                    _hasSpawnedPrefab_Reactor = true;
                }
                break;
        }
    }
}</pre> <p class="calibre3">Here, you can see we loop through all the detected planes (<code>ARPlane</code> type) provided by the handler’s <code>args</code> parameter with a <code>foreach</code> statement. Then, the <code>switch</code> statement allows us to<a id="_idIndexMarker1507" class="pcalibre1 pcalibre calibre6"/> work with the specific plane classification<a id="_idIndexMarker1508" class="pcalibre1 pcalibre calibre6"/> for our needs, which, again, is <code>Table</code>. We use a helper <code>SpawnPrefab()</code> method, which performs the instantiation – passing in the specific plane and Prefab:</p>
<pre class="source-code">
private void SpawnPrefab(ARPlane plane, GameObject prefab)
{
    Instantiate(prefab,
        plane.transform.position,
        plane.transform.rotation);
}</pre> <p class="calibre3">You can see we’re using the regular <code>Instantiate()</code> method and the plane’s <code>position</code> and <code>rotation</code> values for the point of instantiation.</p>
<p class="calibre3">To ensure we’re only spawning one reactor in the scene, if the physical space has multiple table surfaces defined, we’ll use the <code>_hasSpawnedPrefab_Reactor</code> Boolean to limit it to one and call the <code>SpawnPrefab()</code> method, specifying the <code>ARPlane</code> and <code>Reactor</code> Prefab as the parameters. Setting <code>_hasSpawnedPrefab_Reactor</code> to <code>true</code> after calling the spawn method ensures only one Prefab is spawned.</p>
<p class="calibre3">You must ensure you’ve declared the variables to assign the <code>Reactor</code> Prefab and <em class="italic">has spawned</em> bool. Then, assign the <code>Reactor</code> Prefab from the <code>GameManager</code> field<a id="_idIndexMarker1509" class="pcalibre1 pcalibre calibre6"/> in <a id="_idIndexMarker1510" class="pcalibre1 pcalibre calibre6"/>the Inspector.</p>
<p class="calibre3">If you build and run the project on your device now, you should see the reactor appear on your table!</p>
<div><div><img alt="Figure 14.8 – The reactor Prefab spawned on the table plane" src="img/B18347_14_08.jpg" class="calibre165"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.8 – The reactor Prefab spawned on the table plane</p>
<p class="callout-heading">Enabling passthrough</p>
<p class="callout">If you want to temporarily skip ahead to see the virtual objects sitting in your real-world surroundings, we’ll need to toggle the passthrough to be visible. In the <em class="italic">Toggling MR visuals with XR Input section</em>, we’ll add the ability to toggle passthrough visibility.</p>
<p class="calibre3">That takes care of demonstrating how to instantiate an object on the table plane. Let’s move on to <a id="_idIndexMarker1511" class="pcalibre1 pcalibre calibre6"/>spawning <a id="_idIndexMarker1512" class="pcalibre1 pcalibre calibre6"/>on the floor plane next.</p>
<h2 id="_idParaDest-269" class="calibre8"><a id="_idTextAnchor287" class="pcalibre1 pcalibre calibre6"/>Instantiating using the floor plane</h2>
<p class="calibre3">Unlike the<a id="_idIndexMarker1513" class="pcalibre1 pcalibre calibre6"/> reactor’s placement, we’ll prioritize the<a id="_idIndexMarker1514" class="pcalibre1 pcalibre calibre6"/> orientation of the controller console object relative to the player’s forward direction (when the planes are detected) to ensure immediate interaction availability for the player.</p>
<p class="calibre3">The process is relatively the same, except for said orientation. So, let’s first add to our <code>switch (plane.classification)</code> block to handle the <code>Floor</code> classification:</p>
<pre class="source-code">
    case PlaneClassification.Floor:
        if (!_hasSpawnedPrefab_Console)
        {
            SpawnPrefab(plane,
                _prefabConsole,
                new Vector3(-1f, 0f, 0f));
            _hasSpawnedPrefab_Console = true;
        }
        break;</pre> <p class="calibre3">We have a similar Boolean check to ensure we don’t have multiple control consoles spawned into the room with the <code>_hasSpawnedPrefab_Console</code> variable and a method overload for <code>SpawnPrefab()</code>. The new spawn method signature takes an additional parameter for an offset – and we’ll assume that the offset is from the player’s location.</p>
<p class="calibre3">The new spawner method with the offset looks like the following – add it to the <code>GameManager</code> class:</p>
<pre class="source-code">
private void SpawnPrefab(
    ARPlane plane, GameObject prefab, Vector3 playerOffset)
{
    var playerTransform = Camera.main.transform;
    playerTransform.position = new Vector3(
        playerTransform.position.x,
        plane.transform.position.y,
        playerTransform.position.z);
    var worldOffset =
        playerTransform.TransformDirection(playerOffset);
    var spawnPosition = playerTransform.position
        + worldOffset;
    var directionToPlayer =
        (playerTransform.position
            - spawnPosition).normalized;
    var spawnRotation =
        Quaternion.LookRotation(-directionToPlayer,
            Vector3.up);
    Instantiate(prefab, spawnPosition, spawnRotation);
}</pre> <p class="calibre3">The <a id="_idIndexMarker1515" class="pcalibre1 pcalibre calibre6"/>points <a id="_idIndexMarker1516" class="pcalibre1 pcalibre calibre6"/>of interest in the new spawn method are as follows:</p>
<ul class="calibre17">
<li class="calibre15"><code>playerTransform</code>: We get the player’s current position in the world from the main camera, which is attached to <code>XR Origin (XR Rig)</code> to represent the player’s head.</li>
<li class="calibre15"><code>playerTransform.position</code>: We apply a new <code>Vector3</code> Y-value to <code>playerTransform</code> to anchor the instantiated model to the floor plane (its Y-value).</li>
<li class="calibre15"><code>worldOffset</code>: We take the player offset value provided and use the <code>TransformDirection()</code> method to ensure the player offset will be applied in the appropriate world space coordinates – there is no way we could know the world coordinates to pass into the spawn method since it is relative to the player’s current position.</li>
<li class="calibre15"><code>spawnRotation</code>: We want to ensure the console faces the player when instantiated, so we use <code>Quaternion.LookRotation()</code> to accomplish that.</li>
</ul>
<p class="calibre3">We finish by just calling the <code>Instantiate()</code> method, like before. Add the required variables and make the Inspector assignments. Then, save your changes and go ahead and do another <em class="italic">build and run</em> to see the console in your room. An example of the console placement can be seen in the virtual objects spawned into the actual room in the <em class="italic">Figure 14</em><em class="italic">.5</em>.</p>
<p class="calibre3">Okay, we’re making great progress on the boss room layout! The last environmental object to get into<a id="_idIndexMarker1517" class="pcalibre1 pcalibre calibre6"/> our room is the corridor, which will <a id="_idIndexMarker1518" class="pcalibre1 pcalibre calibre6"/>virtually extend the reality of the room and set the stage for our enemy hover bots to engage the player.</p>
<h2 id="_idParaDest-270" class="calibre8"><a id="_idTextAnchor288" class="pcalibre1 pcalibre calibre6"/>Instantiating with wall planes</h2>
<p class="calibre3">Our last AR-detected <a id="_idIndexMarker1519" class="pcalibre1 pcalibre calibre6"/>plane instantiation example will still be<a id="_idIndexMarker1520" class="pcalibre1 pcalibre calibre6"/> relatively the same as the previous two, except we now have to account for spawning an object relative to a vertical surface. This will require a bit of additional care during positioning because the plane anchors are located in the center of the plane’s surface object.</p>
<p class="calibre3">Fortunately, we have access to all the basic <code>Bounds</code> properties, such as <code>extents</code>, but we still need the surface extent and orientation. So, let’s first add to our <code>switch (plane.classification)</code> block to handle the <code>Wall</code> classification:</p>
<pre class="source-code">
    case PlaneClassification.Wall:
        if (!_hasSpawnedPrefab_Corridor)
        {
            SpawnPrefabAtWallBase(
                plane, _prefabCorridorDoorway);
            _hasSpawnedPrefab_Corridor = true;
        }
        break;</pre> <p class="calibre3">You can see the same pattern here as before, using the Boolean to determine whether we’ve spawned the corridor Prefab already and calling a spawn Prefab method, passing in just the plane and the Prefab again this time.</p>
<p class="calibre3">The <code>SpawnPrefabAtWallBase()</code> method<a id="_idIndexMarker1521" class="pcalibre1 pcalibre calibre6"/> looks<a id="_idIndexMarker1522" class="pcalibre1 pcalibre calibre6"/> like this:</p>
<pre class="source-code">
private void SpawnPrefabAtWallBase(
    ARPlane plane, GameObject prefab)
{
    var planeCenter = plane.transform.position;
    var heightOffset = plane.extents.y;
    var basePosition =
        new Vector3(planeCenter.x, planeCenter.y
            - heightOffset, planeCenter.z);
    var prefabRotation =
        Quaternion.LookRotation(-plane.normal, Vector3.up);
    Instantiate(prefab, basePosition, prefabRotation);
}</pre> <p class="calibre3">Just a bit more calculation is required here to ensure we are anchoring the Prefab’s instantiation point to the vertical bottom of the surface plane – at the same Y-value as the floor – by using <code>plane.extents</code> and subtracting from the plane’s transform position (at the center of the plane).</p>
<p class="calibre3">For the rotation of the spawned Prefab, we’ll again use <code>LookRotation()</code>, but this time, instead of using the <em class="italic">direction to player</em> vector, we’ll use the plane’s surface normal vector. The plane’s surface normal is pointing away from the center of the room, so we want to invert it for the instantiation of the corridor Prefab that has its forward direction looking down the corridor (for your own 3D models, you can invert either the normal vector or rotate the pivot’s forward direction for the correct orientation).</p>
<p class="calibre3">Again, add the required script variables, save the script, make the corridor Prefab assignment to the field on <code>GameManager</code>, save your scene, and build and run the app to test the placement of the corridor addition to the boss room.</p>
<p class="calibre3">Now that we have the layout of the boss room completed, with all the elements required for the<a id="_idIndexMarker1523" class="pcalibre1 pcalibre calibre6"/> battle, let’s see how we can work with the<a id="_idIndexMarker1524" class="pcalibre1 pcalibre calibre6"/> MR visuals to set a proper gameplay experience without AR planes being visible and passthrough enabled.</p>
<h2 id="_idParaDest-271" class="calibre8"><a id="_idTextAnchor289" class="pcalibre1 pcalibre calibre6"/>Toggling MR visuals with XR Input</h2>
<p class="calibre3">You know how <a id="_idIndexMarker1525" class="pcalibre1 pcalibre calibre6"/>much of a fan I am of reusable <a id="_idIndexMarker1526" class="pcalibre1 pcalibre calibre6"/>components to build out functionality that is also designer-friendly in our games. So, let’s approach input from our XR controllers similarly by adding an <em class="italic">on button press</em> component that relies on an <code>InputAction</code> input signal (courtesy of the new Input System) to identify the button presses.</p>
<p class="calibre3">You can get the <code>OnButtonPress</code> script file from the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets</a>, then import it into your project in the <code>Assets/Scripts/Interaction</code> folder.</p>
<p class="calibre3">We’re going to wire up buttons for the following in-game actions:</p>
<ul class="calibre17">
<li class="calibre15">Right controller, primary button (<strong class="bold">A</strong>) à Toggle passthrough visibility.</li>
<li class="calibre15">Right controller, secondary button (<strong class="bold">B</strong>) à Toggle AR plane surfaces.</li>
<li class="calibre15">Left controller, primary button (<strong class="bold">X</strong>) à Start game.</li>
</ul>
<p class="calibre3">Let’s see what the buttons for the Oculus controllers with Unity’s <strong class="bold">XR Input</strong> mappings look like in the following figure.</p>
<div><div><img alt="Figure 14.9 – Oculus XR controller button mapping" src="img/B18347_14_09.jpg" class="calibre166"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Oculus XR controller button mapping</p>
<p class="callout-heading">Additional reading | XR Input</p>
<p class="callout">Unity XR Input mappings: <a href="https://docs.unity3d.com/Manual/xr_input.xhtml#XRInputMappings" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/xr_input.xhtml#XRInputMappings</a></p>
<p class="calibre3">Okay, simple <a id="_idIndexMarker1527" class="pcalibre1 pcalibre calibre6"/>enough. Let’s start by wiring up the passthrough <a id="_idIndexMarker1528" class="pcalibre1 pcalibre calibre6"/>visibility toggle for when the <strong class="bold">A</strong> button is pressed.</p>
<h3 class="calibre10">Toggling passthrough</h3>
<p class="calibre3">The MR template <a id="_idIndexMarker1529" class="pcalibre1 pcalibre calibre6"/>showcases the ability to switch between the virtual environment and device passthrough. This is achieved by using a simple fade transition on an environment mesh. The mesh employs a vertex<a id="_idIndexMarker1530" class="pcalibre1 pcalibre calibre6"/> color <strong class="bold">ShaderGraph</strong>, which has an alpha property that can be smoothly transitioned.</p>
<p class="calibre3">We don’t even have to write a script to perform the fade transition. The MR template’s <code>Environment</code> Prefab already includes a <code>FadeMaterial</code> component with an exposed public method for fading!</p>
<p class="calibre3">So, let’s hook into it quickly to toggle the fade, starting with making a new controller script named <code>SceneController</code> in the <code>Assets/Scripts</code> folder with the following code:</p>
<pre class="source-code">
using UnityEngine.Events;
using UnityEngine.XR.ARFoundation;
public class SceneController : MonoBehaviour
{
    [Header("Triggered Events")]
    public UnityEvent&lt;bool&gt; OnTogglePassthrough;
}</pre> <p class="calibre3">Save the script and add it to the <code>GameManager</code> object. As you can see, we’ll use a <code>UnityEvent</code> to assign the reference to the <code>FadeMaterial</code> function, passing a Boolean parameter<a id="_idIndexMarker1531" class="pcalibre1 pcalibre calibre6"/> representing the visible state to fade to.</p>
<p class="calibre3">Let’s assign the <code>OnTogglePassthrough(Boolean)</code> callback in the Inspector and then finish by adding the toggle logic code afterward. So, start by clicking the <strong class="bold">+</strong> icon to add a new event callback entry. Then, using <em class="italic">Figure 14</em><em class="italic">.10</em> as a reference, find the <strong class="bold">UI</strong> | <strong class="bold">Environment</strong> object in the scene Hierarchy and drag it to the <strong class="bold">Object</strong> field.</p>
<p class="calibre3">Now, select the <code>FadeMaterial.FadeSkybox</code> function at the top in the <code>UnityEvent</code>’s <code>bool</code> parameter when the event is invoked.</p>
<div><div><img alt="Figure 14.10 – SceneController component setup" src="img/B18347_14_10.jpg" class="calibre167"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.10 – SceneController component setup</p>
<p class="calibre3">All that’s left to do is<a id="_idIndexMarker1532" class="pcalibre1 pcalibre calibre6"/> invoke the <code>OnTogglePassthrough</code> event when the player presses the right controller’s primary button (<code>SceneController</code> class for that:</p>
<pre class="source-code">
public void TogglePassthrough()
{
    _isPassthroughVisible = !_isPassthroughVisible;
    SetPassthroughVisible(_isPassthroughVisible);
}
public void SetPassthroughVisible(bool visible)
{
    _isPassthroughVisible = visible;
    OnTogglePassthrough.Invoke(_isPassthroughVisible);
}</pre> <p class="calibre3">Straightforward, single-responsibility, and well-named methods. Add the private member variable <code>_isPassthroughVisible</code> for keeping track of the current toggle state, which defaults to <code>false</code> and is the correct default passthrough state.</p>
<p class="calibre3">Lastly, referring to <em class="italic">Figure 14</em><em class="italic">.10</em> for these steps, to receive the player input when the controller’s button is pressed, let’s use the <code>OnButtonPress</code> component with the input action configured for the <strong class="bold">A</strong> button:</p>
<ol class="calibre14">
<li class="calibre15">Add the <code>OnButtonPress</code> component to the <code>SceneController</code>).</li>
<li class="calibre15">Click the <strong class="bold">+</strong> dropdown, then <strong class="bold">Add binding</strong>.</li>
<li class="calibre15">Double-click <strong class="bold">&lt;</strong><strong class="bold">No Binding&gt;</strong>.</li>
<li class="calibre15">In the <strong class="bold">Path</strong> dropdown, select <strong class="bold">XR Controller</strong> | <strong class="bold">XR Controller (Right Hand)</strong> | <strong class="bold">Optional Controls</strong> | <strong class="bold">primaryButton</strong>.</li>
</ol>
<p class="calibre3">Alternatively, enter the following text (click the <code>&lt;XRController&gt;{RightHand}/primaryButton.</code></p>
<ol class="calibre14">
<li value="5" class="calibre15">Lastly, assign the <code>OnPress()</code> <code>UnityEvent</code> function to <code>SceneController.TogglePassthrough</code>.</li>
</ol>
<p class="calibre3">Doing a <em class="italic">build and run</em> to your <a id="_idIndexMarker1533" class="pcalibre1 pcalibre calibre6"/>device now, you can toggle the passthrough visibility by pressing the <strong class="bold">A</strong> button on your right controller. This will be your first time seeing the boss room’s digital objects spawned within your real-world space – pretty awesome, right?</p>
<p class="callout-heading">Camera setup to support passthrough</p>
<p class="callout">The MR template’s main camera comes preconfigured to enable device passthrough, but it’s worth mentioning the setup. The camera’s background type is <strong class="source-inline1">Solid Color</strong> with the background color set to black, with <strong class="source-inline1">0</strong> alpha. The <strong class="source-inline1">AR Camera Manager</strong> component is also explicitly included to control passthrough on Meta Quest devices.</p>
<p class="calibre3">Passthrough, check! Now, let’s see about toggling the AR plane visibility when the <strong class="bold">B</strong> button is pressed.</p>
<h3 class="calibre10">Toggling AR plane visibility</h3>
<p class="calibre3">It shouldn’t be any <a id="_idIndexMarker1534" class="pcalibre1 pcalibre calibre6"/>surprise that we’ll mimic<a id="_idIndexMarker1535" class="pcalibre1 pcalibre calibre6"/> the passthrough toggle setup. We’ve already seen how to reference and use the <code>AR Plane Manager</code> to spawn the virtual objects for the different plane classifications. Well, we’ll be using it again here to access the current <a id="_idIndexMarker1536" class="pcalibre1 pcalibre calibre6"/>set of <strong class="bold">trackables</strong>.</p>
<p class="calibre3">A trackable is a component that represents AR objects detected in the real world. Examples include planes (you’re already familiar with these), point clouds, anchors, environment probes, faces, bodies, images, and 3D objects.</p>
<p class="callout-heading">Trackables (AR Foundation)</p>
<p class="callout">Trackables and trackable managers: <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/architecture/managers.xhtml#trackables-and-trackable-managers" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/architecture/managers.xhtml#trackables-and-trackable-managers</a></p>
<p class="calibre3">Let’s start by adding the following toggle code to the <code>SceneController</code> class for plane visibility:</p>
<pre class="source-code">
[SerializeField]
private ARPlaneManager _planeManager;
public void TogglePlaneVisibility()
{
    _arePlanesVisible = !_arePlanesVisible;
    SetPlaneVisible(_arePlanesVisible);
}
public void SetPlaneVisible(bool visible)
{
    _arePlanesVisible = visible;
    foreach (var plane in _planeManager.trackables)
    {
        if (plane.gameObject.
            TryGetComponent&lt;FadePlaneMaterial&gt;(
                out var planeFader))
        {
            planeFader.FadePlane(_arePlanesVisible);
        }
    }
}</pre> <p class="calibre3">The <code>foreach</code> loop in the <code>SetPlaneVisible()</code> method is responsible for implementing the fade on the planes found while iterating the trackable collection based on finding a <code>FadePlaneMaterial</code> component. If found, we simply call that plane’s <code>FadePlane()</code> method. The <code>FadePlaneMaterial</code> component provides us with the MR template’s <code>AR Plane</code> Prefab. Easy-peasy.</p>
<p class="calibre3">Let’s hook it up<a id="_idIndexMarker1537" class="pcalibre1 pcalibre calibre6"/> now to <a id="_idIndexMarker1538" class="pcalibre1 pcalibre calibre6"/>the controller button press – which will be the right controller’s secondary button (<strong class="bold">B</strong>):</p>
<ol class="calibre14">
<li class="calibre15">Add another <code>OnButtonPress</code> component to the <code>GameManager</code> object (just below the previous <code>OnButtonPress</code> component).</li>
<li class="calibre15">Click the <strong class="bold">+</strong> dropdown, then <strong class="bold">Add binding</strong>.</li>
<li class="calibre15">Double-click <strong class="bold">&lt;</strong><strong class="bold">No Binding&gt;</strong>.</li>
<li class="calibre15">In the <strong class="bold">Path</strong> dropdown, select <strong class="bold">XR Controller</strong> | <strong class="bold">XR Controller (Right Hand)</strong> | <strong class="bold">Optional Controls</strong> | <strong class="bold">secondaryButton</strong>.</li>
</ol>
<p class="calibre3">Altern<a id="_idTextAnchor290" class="pcalibre1 pcalibre calibre6"/>atively, enter the following text (click the <code>&lt;XRController&gt;{RightHand}/secondaryButton.</code></p>
<ol class="calibre14">
<li value="5" class="calibre15">Lastly, assign the <code>OnPress()</code> <code>UnityEvent</code> function to <code>SceneController.</code> <code>TogglePlaneVisibility</code>.</li>
</ol>
<p class="calibre3">Doing a <em class="italic">build and run</em> to your device now, you can toggle the AR plane visibility by pressing the <strong class="bold">B</strong> button on your right controller. Toggling the plane visibility will mostly serve the purpose of debugging; in case objects spawn in unexpected ways, you can verify the plane detected in the physical space (any that do might indicate you need to revisit your Quest headset’s <strong class="bold">Room </strong><strong class="bold">Setup</strong> configuration).</p>
<p class="callout-heading">Mixed Reality template script fix!</p>
<p class="callout">At the time of writing, the <strong class="source-inline1">/Assets/MRTemplateAssets/Scripts/FadePlaneMaterial.cs</strong> script has an error with the <strong class="source-inline1">FadePlane()</strong> method that must be corrected for the planes to fade in and out correctly after first being called in its <strong class="source-inline1">Awake()</strong> method.</p>
<p class="callout">On <em class="italic">line 91</em>, within the <strong class="source-inline1">FadeAlpha()</strong> method, replace the <strong class="source-inline1">k_DotViewRadius</strong> variable with <strong class="source-inline1">k_Alpha</strong>. The line should now read: <strong class="source-inline1">rend.material.SetFloat(k_Alpha, alphaValue);</strong>.</p>
<p class="calibre3">Note that we’ll turn<a id="_idIndexMarker1539" class="pcalibre1 pcalibre calibre6"/> off the plane visibility<a id="_idIndexMarker1540" class="pcalibre1 pcalibre calibre6"/> when we start the game. Speaking of… let’s wire up starting the game now.</p>
<h3 class="calibre10">Starting the game</h3>
<p class="calibre3">Offering players<a id="_idIndexMarker1541" class="pcalibre1 pcalibre calibre6"/> a choice to start a game via a button or menu selection creates a sense of control and anticipation. In contrast, for MR and even VR, an automatic game start can be disorienting or, worse, jarring. Well, that is, unless you want to be hostile and throw players directly into unforgiving action without warning (ahem, <em class="italic">Dark Souls</em>, I see you).</p>
<p class="calibre3">As mentioned, we won’t be so cruel and will provide a button press for the player to enter the MR environment to start the game. With that in mind, we need to make some additions to the <code>GameManager</code> class. Let’s add the following code:</p>
<pre class="source-code">
private SceneController _sceneController;
private void Awake()
    =&gt; _sceneController = GetComponent&lt;SceneController&gt;();</pre> <p class="calibre3">Here, we’re just getting a reference to the <code>SceneController</code> sibling component. Go ahead and add a <code>[RequireComponent]</code> attribute for the <code>SceneController</code> component, too.</p>
<p class="calibre3">Here’s the <code>StartGame()</code> method we’ll call from the button press:</p>
<pre class="source-code">
public void StartGame()
{
    EnablePlaneManager();
    StartCoroutine(DelayStartGame());
    IEnumerator DelayStartGame()
    {
        yield return new WaitForSeconds(1.5f);
        _sceneController.SetPlaneVisible(false);
        _sceneController.SetPassthroughVisible(true);
    }
}</pre> <p class="calibre3">The first thing we’ll <a id="_idIndexMarker1542" class="pcalibre1 pcalibre calibre6"/>do with the <code>EnablePlaneManager()</code> call is to enable the plane manager to spawn the virtual objects that make up our boss room game. We’ll then use a coroutine to delay calling the local <code>DelayStartGame()</code> function by 1.5 seconds, setting planes invisible and the passthrough visible – this will ensure we see the virtual objects unobstructed in our real-world space.</p>
<p class="callout-heading">Remove the IEnumerator Start() method</p>
<p class="callout">Don’t forget, we’ll have <a id="_idIndexMarker1543" class="pcalibre1 pcalibre calibre6"/>to remove the <strong class="source-inline1">Start()</strong> method we started with to set up the object spawning in the earlier <em class="italic">Spawning using planes with AR Plane Manager</em> section. We’re now going to wait until the player presses the button to start the game to enable spawning the virtual objects.</p>
<p class="calibre3">Okay, let’s finish things up by adding the <strong class="bold">X</strong> button press to start the game by following these steps again – but simplified this time (you got this):</p>
<ol class="calibre14">
<li class="calibre15">Add another <code>OnButtonPress</code> component to the <code>GameManager</code> object.</li>
<li class="calibre15">Assign input action binding for the XR left-hand controller’s primary button (<code>&lt;XRController&gt;{LeftHand}/primaryButton</code>.</li>
<li class="calibre15">Assign the <code>OnPress()</code> function to <code>GameManager.StartGame</code>.</li>
</ol>
<p class="calibre3">This time, when you <em class="italic">build and run</em>, you’ll see yourself in the empty virtual environment until you press the <strong class="bold">X</strong> button to start the game and enter the boss room battle!</p>
<p class="calibre3">In this section, we learned how to work with the generated AR planes to spawn objects in our rooms about their transform position and rotation. We also learned how to access the AR systems and pre-made components (provided by the MR template) to toggle the visual state of passthrough and AR planes.</p>
<p class="calibre3">We have the boss room environment taken care of now, and we have the game starting, but there’s still <a id="_idIndexMarker1544" class="pcalibre1 pcalibre calibre6"/>nothing for us to do or interact with. We’ll solve that problem now by adding XRI interactable objects to the room.</p>
<h1 id="_idParaDest-272" class="calibre5"><a id="_idTextAnchor291" class="pcalibre1 pcalibre calibre6"/>Placing interactable objects in the world</h1>
<p class="calibre3">In MR game design, interactive<a id="_idIndexMarker1545" class="pcalibre1 pcalibre calibre6"/> objects are essential to bridging the virtual and real worlds. Interactable objects are designed to respond to user input, even as basic as hand (or controller) movements that allow natural and intuitive interactions like pushing, grabbing, throwing, or even complex multi-hand manipulation (for example, rotating and scaling the object). They really help to sell the reality of the environment, and as a result, they significantly enhance the player’s engagement and overall gameplay experience.</p>
<p class="calibre3">For our game’s purposes, we’ll have examples of a simple grab and placement interaction and, with the gun, a secondary interactable event action for shooting. Note that while many MR games and experiences are built for use with hands (hand tracking), our boss room example game will use controllers.</p>
<p class="calibre3">Let’s start by configuring the modules for grabbing – these will then be configured to be inserted into the slots<a id="_idIndexMarker1546" class="pcalibre1 pcalibre calibre6"/> on the control console (refer to the GDD in the <em class="italic">Designing a boss </em><em class="italic">room</em> section).</p>
<h2 id="_idParaDest-273" class="calibre8"><a id="_idTextAnchor292" class="pcalibre1 pcalibre calibre6"/>Making objects XR interactables</h2>
<p class="calibre3">The first grabbable <a id="_idIndexMarker1547" class="pcalibre1 pcalibre calibre6"/>object we’ll work with is the crystal module. The player must be able to grab the module and insert it into the control console, so we’ll open up the provided <code>Module</code> Prefab asset in Prefab Mode (double-click on it in the <code>XR Grab Interactable</code> component to the root.</p>
<p class="calibre3">As seen in the following screenshot, grabbable objects should have a transform positioned and appropriately rotated for grabbing the item with the correct orientation for proper usage – here, we see both the <code>Module</code> and the <code>Gun</code> assets with their <code>Attach</code> object positioned and rotated for a good grab.</p>
<div><div><img alt="Figure 14.11 – Configuring the XR grab attach transforms" src="img/B18347_14_11.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.11 – Configuring the XR grab attach transforms</p>
<p class="calibre3">Note from the screenshot that the forward direction (Z-axis, blue arrow) of the <code>Attach</code> transform is pointing away from the player holding the object. Some experimentation may be done to attain the desired grab position.</p>
<p class="calibre3">Now, we just need to assign the <code>Attach</code> object to the <code>XR Grab Interactable</code> <strong class="bold">Attach Transform</strong> field to ensure it gets properly attached to the player’s controller. You can find the <strong class="bold">Attach Transform</strong> field hidden within the many options the interactable <a id="_idIndexMarker1548" class="pcalibre1 pcalibre calibre6"/>component provides.</p>
<div><div><img alt="Figure 14.12 – XR Grab Interactable Attach Transform assignment" src="img/B18347_14_12.jpg" class="calibre168"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.12 – XR Grab Interactable Attach Transform assignment</p>
<p class="callout-heading">Additional reading | Affordance system</p>
<p class="callout">The XRI affordance system gives visual color and audio feedback cues when interacting with objects, especially when haptics are unavailable while using hands, using an <strong class="source-inline1">XR Interactable Affordance State Provider</strong> component with the interactable source. Samples are provided in the XRI example project.</p>
<p class="callout">Affordance system: <a href="https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/affordance-system.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/affordance-system.xhtml</a></p>
<p class="calibre3">Save the module and temporarily add it to your <code>Boss Room</code> scene near the <code>MR Interaction Setup</code> object. Enter Play Mode and test grabbing the module and moving it around with the controller (by using the grip button on the side of the controller, with your middle finger). Notice I said <em class="italic">enter play mode</em> this time, not <em class="italic">build and run</em>. That’s because we want to iterate changes like grab point attachment positions more quickly. For details, refer to the Quest Link callout in the <em class="italic">Creating the Unity </em><em class="italic">project</em> section.</p>
<p class="callout-heading">Completed interactable objects</p>
<p class="callout">All of the completed XR interactable objects are provided in the completed Unity project files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/XR-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/XR-Assets</a>.</p>
<p class="calibre3">That’s all there is to making an object interactable in XR. XRI makes it very easy to get the minimum required interactions, such as grabbing in place for games and experiences. We <a id="_idIndexMarker1549" class="pcalibre1 pcalibre calibre6"/>saw how to dynamically place other digital objects in the world; let’s do the same for the modules, but with a twist.</p>
<h2 id="_idParaDest-274" class="calibre8"><a id="_idTextAnchor293" class="pcalibre1 pcalibre calibre6"/>Placing the modules in the room</h2>
<p class="calibre3">In our boss room<a id="_idIndexMarker1550" class="pcalibre1 pcalibre calibre6"/> battle, our primary objective, besides just staying alive, is to collect the crystal modules to restore the functionality of the control console and energize the reactor to expel the evil plant entity. So, we have a sort of collection game here again! However, let’s add to the challenge of collecting and managing the modules.</p>
<p class="calibre3">Collecting objects in an MR game can be made more engaging by having these objects move around the room. The player will need to rely on their spatial awareness and timing skills, which introduces a more dynamic and novel challenge requiring them to explore the room. With the objects reacting to not only the player’s actions but the physicality of the space, it also deepens the immersion of the MR gameplay experience.</p>
<p class="calibre3">If the collectible objects were to float somehow, the modules could also contribute to the game’s narrative or aesthetic theme. As it happens, crystal modules have a strange other-worldly property – gravity does not affect them, but forces do. ¯\_(ツ)_/¯</p>
<p class="calibre3">With that context set, let’s first create the three required modules, then spawn them into the room<a id="_idIndexMarker1551" class="pcalibre1 pcalibre calibre6"/> when the game starts.</p>
<h3 class="calibre10">Creating unique module variants</h3>
<p class="calibre3">The three <code>Module</code> Prefab<a id="_idIndexMarker1552" class="pcalibre1 pcalibre calibre6"/> variants we’ll create can be seen in <em class="italic">Figure 14</em><em class="italic">.7</em>, and each will have a unique identifier – the ID of the module will come into play when we configure the control console slots.</p>
<p class="calibre3">There are multiple ways to create a Prefab variant, but this time, we’ll use the following steps to create each unique module:</p>
<ol class="calibre14">
<li class="calibre15">Make a Prefab variant of <code>Module</code> by right-clicking on it in the <strong class="bold">Project</strong> window and selecting <strong class="bold">Create</strong> | <strong class="bold">Prefab Variant</strong>.</li>
<li class="calibre15">Name it <code>Module Variant A</code> (the proceeding variants will be <code>B</code> and <code>C</code>).</li>
<li class="calibre15">Double-click on <code>Module Variant A</code> to open it in Prefab Mode.</li>
<li class="calibre15">In the <code>Module</code> component, set it to <code>A</code> (followed by <code>B</code> and <code>C</code>). (The <code>Module</code> script is provided as part of the imported base assets.)</li>
<li class="calibre15">From the <code>Assets/Materials</code> folder, assign the <code>Module_A</code> material. You can easily do this by dragging the material from the <strong class="bold">Project</strong> window onto the model visible in the <strong class="bold">Scene</strong> view.</li>
<li class="calibre15"><code>false</code> on the <code>Rigidbody</code> component.</li>
</ol>
<p class="calibre3">Repeat these steps to create variants for modules <code>B</code> and <code>C</code>, respectively. Remember, any edits you make to a Prefab variant, such as modified property values or added/removed components, become overrides of the base Prefab, so you don’t want to apply these overrides, or you’ll be applying them to the base Prefab asset, and we don’t want that!</p>
<p class="callout-heading">XR interactable required component</p>
<p class="callout">Adding an <strong class="source-inline1">XR Grab Interactable</strong> component to our objects will automatically add a <strong class="source-inline1">Rigidbody</strong> component with its default values.</p>
<p class="calibre3">Three unique modules, check! We can now add the necessary code to our game manager to <a id="_idIndexMarker1553" class="pcalibre1 pcalibre calibre6"/>spawn the modules when the game starts.</p>
<h3 class="calibre10">Spawning the modules to get things moving</h3>
<p class="calibre3">There is no <a id="_idIndexMarker1554" class="pcalibre1 pcalibre calibre6"/>sense in reinventing the wheel to spawn another Prefab into the scene; we can rely on the work we’ve already coded (as we should generally do). We will, however, change the spawning up just a bit because we don’t want to instantiate the objects about a plane object. We want a more arbitrary position in the world, but still in relation to the player position.</p>
<p class="calibre3">Open up the <code>GameManager</code> script for editing. Let’s first create the serialized private member variable where we can assign all the module variants in the Inspector that need to be spawned into the scene:</p>
<pre class="source-code">
[SerializeField]
private GameObject[] _prefabModules;</pre> <p class="calibre3">Now, we can create another method overload for the <code>SpawnPrefab()</code> method:</p>
<pre class="source-code">
private void SpawnPrefab(GameObject[] prefabs,
    Vector3 playerOffset,
    Vector3 forceDirection, float force)
{
    var playerTransform = Camera.main.transform;
    var spawnPosition = new Vector3(
        playerTransform.position.x
            + (playerTransform.right * playerOffset.x).x,
        playerTransform.position.y
            + (playerTransform.up * playerOffset.y).y,
        playerTransform.position.z
            + (playerTransform.forward * playerOffset.z).z
    );
    foreach (var item in prefabs)
    {
        var module = Instantiate(item,
            spawnPosition, Quaternion.identity);
    }
}</pre> <p class="calibre3">In the method signature, we’ve made the <code>prefabs</code> parameter an array, <code>GameObject[] prefabs</code>, to accept any number of Prefabs to spawn, then added <code>forceDirection</code> and <code>force</code> parameters, which we’ll use to apply a force to the objects after instantiation.</p>
<p class="calibre3">The primary difference with this Prefab spawning method is that we’re using a <code>foreach</code> statement<a id="_idIndexMarker1555" class="pcalibre1 pcalibre calibre6"/> to iterate the array of Prefabs to ensure each one is instantiated.</p>
<p class="calibre3">Now, we can add the call to <code>SpawnPrefab()</code> to do the module spawning. For simplicity’s sake, we’ll just tag it onto the console spawning. Add the following call to <code>SpawnPrefab()</code> in the <code>switch</code> statement’s floor plane classification <code>case</code> statement:</p>
<pre class="source-code">
    case PlaneClassification.Floor:
        if (!_hasSpawnedPrefab_Console)
        {
            …
            SpawnPrefab(_prefabModules,
                new Vector3(0f, 1.5f, 0.8f),
                Vector3.up, 0.05f);
        }
        break;</pre> <p class="calibre3">A new vector position is passed in as the offset from the player’s position (world space), the <code>Vector3.up</code> is the direction force, and <code>0.05f</code> is the force applied to the modules when they are instantiated. Simple.</p>
<p class="calibre3">Okay, we’ve talked about adding a force to the crystal modules so that they float about the room… now’s the time to implement it! Add the following lines to this iteration of the <code>SpawnPrefab()</code> method:</p>
<pre class="source-code">
    // Existing line in foreach body.
    var module = Instantiate(item,
        spawnPosition, Quaternion.identity);
    // Added lines.
    if (forceDirection != Vector3.zero || force != 0)
    {
        if (module.TryGetComponent&lt;Rigidbody&gt;(out var rb))
        {
            ApplyForce(rb);
        }
    }</pre> <p class="calibre3">If we have a force<a id="_idIndexMarker1556" class="pcalibre1 pcalibre calibre6"/> direction and amount passed as parameters to the <code>SpawnPrefab()</code> call that are not zero, we attempt to get the <code>Rigidbody</code> component of the instantiated Prefab. If the <code>Rigidbody</code> component reference is successfully retrieved, we call <code>ApplyForce()</code> and pass it in.</p>
<p class="calibre3">All that remains is to add the <code>ApplyForce()</code> method as a local function to work its physics magic:</p>
<pre class="source-code">
    void ApplyForce(Rigidbody rb)
    {
        rb.AddForce(forceDirection * force, ForceMode.Impulse);
        var torqueMultiplier = 3f;
        var randomRotation = new Vector3(
            Random.Range(-1f, 1f),
            Random.Range(-1f, 1f),
            Random.Range(-1f, 1f)).normalized
                * (force * torqueMultiplier);
        rb.AddTorque(randomRotation, ForceMode.Impulse);
    }</pre> <p class="calibre3">The physics API methods we’re taking advantage of here are <code>rb.AddForce()</code> and <code>rb.AddTorque()</code> to apply forces using an <code>Impulse</code> force mode.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">Rigidbody.AddForce</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddForce.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddForce.xhtml</a></p>
<p class="callout"><strong class="source-inline1">Rigidbody.AddTorque</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddTorque.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddTorque.xhtml</a></p>
<p class="calibre3">Save the script and <a id="_idIndexMarker1557" class="pcalibre1 pcalibre calibre6"/>assign all the crystal module Prefab variants to the <code>GameManager</code>’s <strong class="bold">Prefab Modules</strong> field. Playtest and adjust the spawn position of the modules to your liking. Have fun chasing them down!</p>
<p class="callout-heading">Applying impact force</p>
<p class="callout">The provided <strong class="source-inline1">Module</strong> Prefab comes with an <strong class="source-inline1">ImpactApplyForce</strong> script added to it that will apply an opposite force to the module when it collides with any other object with a collider. Combined with a very bouncy physics material assigned to the collider, this attempts to keep the modules moving about the room constantly.</p>
<p class="calibre3">In this section, we got the crystal modules floating about the room, adding the first challenge to the boss room battle mechanics. The second half of the challenge with the modules has to do <a id="_idIndexMarker1558" class="pcalibre1 pcalibre calibre6"/>with inserting them correctly into the slots of the control console. In the next section, we’ll perform the XR interactable configuration necessary for this interaction.</p>
<h2 id="_idParaDest-275" class="calibre8"><a id="_idTextAnchor294" class="pcalibre1 pcalibre calibre6"/>Making the module slots interactable</h2>
<p class="calibre3">To have objects that <a id="_idIndexMarker1559" class="pcalibre1 pcalibre calibre6"/>can work together <a id="_idIndexMarker1560" class="pcalibre1 pcalibre calibre6"/>to create an intuitive system that mimics how things work in the real world, we use an <code>XR Grab Interactable</code> object and an <code>XR Socket Interactor</code> object – we have an <em class="italic">interactable</em> and an <em class="italic">interactor</em>. The grab interactor allows players to pick up and interact with objects, while the socket interactor provides the designated spots to place them. This handshake between the two components makes it easier for users to interact with objects and provides a more seamless and immersive experience in virtual or MR environments.</p>
<p class="calibre3">This means we’ll be configuring each control console slot with a socket interactor. Go ahead and open up the <code>Console</code> Prefab in Prefab Mode from the <code>Assets/Prefabs</code> folder. Add the <code>XR Socket Interactor</code> component for the <code>Slot A</code>, <code>Slot B</code>, and <code>Slot C</code> objects parented to the <code>ConsoleSlots</code> object. The object hierarchy can be seen in the following screenshot:</p>
<div><div><img alt="Figure 14.13 – Console slot configuration" src="img/B18347_14_13.jpg" class="calibre169"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.13 – Console slot configuration</p>
<p class="calibre3">An <em class="italic">attach</em> transform object can also be seen in the preceding screenshot; each slot has an object parented to it, and named <code>Socket Attach</code>. For each socket interactor added to the slot objects, assign the <em class="italic">attach</em> object to the interactor’s <strong class="bold">Attach Transform</strong> field (just <a id="_idIndexMarker1561" class="pcalibre1 pcalibre calibre6"/>like we did for the grab interactables).</p>
<p class="calibre3">We also want to ensure that only modules are inserted into the slots on the control console; we can do something about that. We can use the <code>Interaction Layer Mask</code> property of both <code>XR Grab Interactable</code> and <code>XR </code><code>Socket Interactor</code>.</p>
<p class="calibre3">It doesn’t matter which one you start with, but it’s essential first to add a <code>Module</code> interaction layer. You can do that from any <strong class="bold">Interaction Layer Mask</strong> field by clicking the dropdown and selecting <strong class="bold">Add layer…</strong> (at the bottom), then going back to the component and selecting <strong class="bold">Nothing</strong>, then <strong class="bold">Module</strong> for each.</p>
<p class="callout-heading">Setting the interactive layer with the asset</p>
<p class="callout">Alternatively, find the interactive layer asset at <strong class="source-inline1">Assets/XRI/Settings/Resources/InteractionLayerSettings</strong>, add the <strong class="source-inline1">Module</strong> layer, then return to the components and set the layer.</p>
<p class="calibre3">The last part of the<a id="_idIndexMarker1562" class="pcalibre1 pcalibre calibre6"/> slot configuration is that the slots are configured with a <code>ConsoleSlot</code> component already, similar to how we configured the module’s <code>Module</code> component; ensure <code>A</code>, <code>B</code>, and <code>C</code> again.</p>
<p class="calibre3">Speaking of the <code>ConsoleSlot</code> component, let’s take a closer look at the code. It’s more than just a slot ID – it can detect when a module is inserted or removed. This allows it to tell the parent console controller when the specific slot is interacted with, which can then respond accordingly:</p>
<pre class="source-code">
public class ConsoleSlot : MonoBehaviour
{
    [SerializeField] private char _slotID;
    private ConsoleController _controller;
    private XRSocketInteractor _socketInteractor;
    private void Awake()
    {
        _controller =
            GetComponentInParent&lt;ConsoleController&gt;();
        _socketInteractor = GetComponent&lt;XRSocketInteractor&gt;();
        _socketInteractor.selectEntered.
            AddListener(HandleModuleInserted);
        _socketInteractor.selectExited.
            AddListener(HandleModuleRemoved);
    }
}</pre> <p class="calibre3">We declare our<a id="_idIndexMarker1563" class="pcalibre1 pcalibre calibre6"/> variables, then, in <code>Awake()</code>, once we <a id="_idIndexMarker1564" class="pcalibre1 pcalibre calibre6"/>have the references to the required components, we register the listeners for responding to the socket interactor <code>selectEntered</code> and <code>selectExited</code> events for handling inserting and removing modules, respectively.</p>
<p class="calibre3">Here are the handler method declarations:</p>
<pre class="source-code">
private char _moduleID;
private void HandleModuleInserted(SelectEnterEventArgs arg)
{
    _moduleID = arg.interactableObject.transform.
        GetComponent&lt;Module&gt;().ModuleID;
    if (!char.IsWhiteSpace(_moduleID))
    {
        _controller.InsertModule(_slotID, _moduleID);
    }
}
private void HandleModuleRemoved(SelectExitEventArgs arg)
    =&gt; _controller.ResetSlots();</pre> <p class="calibre3">The first thing we do is get the ID of the inserted module (remember, only modules can be inserted due to the interaction’s layer mask assignment). We then call a method of the <code>ConsoleController</code> instance for either the module being inserted, <code>InsertModule()</code>, or simply resetting the slots, <code>ResetSlots()</code>, when the module is removed.</p>
<p class="calibre3">You might be considering having <code>ConsoleController</code> subscribe to a <code>ConsoleSlot</code> exposed event. Since there are three slots, it is more efficient to have each slot handle its own interactions (objects should be responsible for their own state) and notify the controller (by passing its ID and the module’s ID). This is a more simplified approach.</p>
<p class="callout-heading">Bonus activity</p>
<p class="callout">Feel free to <em class="italic">flip the script</em> and experiment with the console controller listening to events on all three slots to compare the required code differences.</p>
<p class="calibre3">You should now be able to playtest the console slot interactions by grabbing a crystal module and<a id="_idIndexMarker1565" class="pcalibre1 pcalibre calibre6"/> placing <a id="_idIndexMarker1566" class="pcalibre1 pcalibre calibre6"/>it in any slot. Fun!</p>
<p class="calibre3">There’s more fun to be had… let’s get that laser pistol configured to provide us some protection against infiltrated hover bots.</p>
<h2 id="_idParaDest-276" class="calibre8"><a id="_idTextAnchor295" class="pcalibre1 pcalibre calibre6"/>Configuring the laser gun</h2>
<p class="calibre3">The configuration<a id="_idIndexMarker1567" class="pcalibre1 pcalibre calibre6"/> for the interactable <a id="_idIndexMarker1568" class="pcalibre1 pcalibre calibre6"/>gun object is pretty much the same as the crystal module; we already saw how to configure an attach transform in <em class="italic">Figure 14</em><em class="italic">.11</em>. Except now, we’ll add a secondary action for shooting when the trigger is pulled.</p>
<h3 class="calibre10">Implementing shooting with XR Interactable Events</h3>
<p class="calibre3">We only <a id="_idIndexMarker1569" class="pcalibre1 pcalibre calibre6"/>want<a id="_idIndexMarker1570" class="pcalibre1 pcalibre calibre6"/> shooting triggered when we’re actually grabbing the gun, so we won’t be relying on the reusable <code>OnButtonPress</code> component this time. Instead, we’ll use the <code>XR Grab Interactable</code> component, specifically, <code>Activated</code>. <code>Activated</code> is called when the interactor selecting the interactable sends a command to activate the interactable – precisely what we need.</p>
<p class="callout-heading">Additional reading | Grab interactables</p>
<p class="callout">Both basic and advanced examples of grab interactions are available in the XRI examples: <a href="https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/blob/main/Documentation/GrabInteractables.md" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/blob/main/Documentation/GrabInteractables.md</a>.</p>
<p class="calibre3">To set up the <code>Gun</code> Prefab, take the following steps:</p>
<ol class="calibre14">
<li class="calibre15">Either modify the provided <code>Gun</code> Prefab directly or make a Prefab variant to work with.</li>
<li class="calibre15">Open the Prefab in <strong class="bold">Prefab Mode</strong>.</li>
<li class="calibre15">Add an <code>XR Grab Interactable</code> component to the root.<ol class="calibre42"><li class="calibre15">Assign the <code>Attach</code> object to the <code>Activated</code>, assign the <code>Gun.Shoot</code> function.</li></ol></li>
</ol>
<div><div><img alt="Figure 14.14 – XR Grab Interactable event Activated assignment" src="img/B18347_14_14.jpg" class="calibre170"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.14 – XR Grab Interactable event Activated assignment</p>
<ol class="calibre14">
<li value="4" class="calibre15">For the <code>Rigidbody</code> component, use <a id="_idIndexMarker1571" class="pcalibre1 pcalibre calibre6"/>the following property values (the gun will stay floating in the air right where the player releases their grip; Kryk’zylx military tech is truly advanced!):<ul class="calibre22"><li class="calibre15"><code>false</code></li><li class="calibre15"><code>true</code></li></ul></li>
</ol>
<p class="calibre3">And that’s all that’s required to configure the <code>Gun</code> Prefab to make it an interactable object that players can pick up and shoot. Pew-pew!</p>
<p class="callout-heading">Gun sound FX</p>
<p class="callout">We also have sound FX added for the shooting, courtesy of <strong class="source-inline1">AudioManager</strong> and the <strong class="source-inline1">AudioPlayerSFX3D</strong> audio-playing component. So, add the audio manager to the boss room scene, create an audio mixer and the required mixer groups, and then assign the mixer groups to the audio manager. For a refresher, visit <a href="B18347_12.xhtml#_idTextAnchor232" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>.</p>
<p class="calibre3">All the code responsible for making the gun shoot a laser beam when the <code>Shoot()</code> method is called is <a id="_idIndexMarker1572" class="pcalibre1 pcalibre calibre6"/>contained entirely within the <code>Gun</code> class. It’s single-responsibility for its specific use case in this game, and the code is simple and straightforward, so I didn’t feel the need to overcomplicate the architecture here.</p>
<p class="callout-heading">Code architecture philosophy</p>
<p class="callout">“<em class="italic">When you have a hammer, everything looks like a nail</em>” is a metaphor we can apply to a common pitfall in software development. People may use their favorite approaches to solve every problem they encounter, unintentionally leading to overcomplicated and inefficient code. Choosing the most appropriate solution for each problem or situation is important, rather than relying solely on a software doctrine.</p>
<p class="callout">Sometimes, you just need to embrace simplicity. Knowing when to – or not to – is called experience.</p>
<p class="calibre3">When you examine the <code>Gun</code> script, you’ll see that we’re simply using <code>Physics.Raycast()</code> and <code>LineRenderer</code> with the two points for drawing the line set to the firing point<a id="_idIndexMarker1573" class="pcalibre1 pcalibre calibre6"/> and the end of the gun’s firing range, or the point at which the ray hits a damageable object (filtered by use<a id="_idIndexMarker1574" class="pcalibre1 pcalibre calibre6"/> of a <strong class="bold">layer mask</strong>).</p>
<p class="callout-heading">Tip</p>
<p class="callout">Unity provides a specialized <strong class="source-inline1">XRLineRenderer</strong> component for producing an XR-optimized line render compared to the regular <strong class="source-inline1">LineRenderer</strong> component. It’s also capable of producing very inexpensive glow effects, which is fantastic for laser beams!</p>
<p class="callout">XR Line Renderer: <a href="https://github.com/Unity-Technologies/XRLineRenderer" class="pcalibre1 pcalibre calibre6">https://github.com/Unity-Technologies/XRLineRenderer</a></p>
<p class="calibre3">If the raycast hits a damageable object, we pass the damage amount specified in <code>_damageAmount</code> in a call to <code>TakeDamage()</code>. This is how we’ll work within our health system, from <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a> (yes, reusable system for the win!), to cause damage to objects that have <a id="_idIndexMarker1575" class="pcalibre1 pcalibre calibre6"/>health (i.e., a <code>HealthSystem</code> component added).</p>
<p class="calibre3">Now that we have a functional self-defense weapon, let’s get it into the player’s hands.</p>
<h3 class="calibre10">Spawning the gun position</h3>
<p class="calibre3">Alright, this will be<a id="_idIndexMarker1576" class="pcalibre1 pcalibre calibre6"/> a piece of cake! We’re already pros at spawning virtual objects into the room. We’ll reuse most of what we already have in place for spawning objects because we’ll spawn the gun near the player, on their right-hand side (sorry, left-handers).</p>
<p class="calibre3">First things first, open up the <code>GameManager</code> script and add a declaration for a serialized private variable, <code>_prefabGun</code>, to hold the reference to the <code>Gun</code> Prefab:</p>
<pre class="source-code">
[SerializeField] private GameObject _prefabGun;</pre> <p class="calibre3">We’re already using the <code>Console</code> Prefab spawning section to spawn other objects, so let’s tag the gun instantiation onto it:</p>
<pre class="source-code">
    case PlaneClassification.Floor:
        if (!_hasSpawnedPrefab_Console)
        {
            …
            SpawnPrefab(_prefabGun,
                new Vector3(0.5f, 1.2f, 0.15f));
        }
        break;</pre> <p class="calibre3">Notice this time, when we call <code>SpawnPrefab()</code>, we have another new method signature. This is very much like the method overload we used to spawn the modules, except we’re going to spawn a single Prefab and won’t apply any physics force in a specified direction to it.</p>
<p class="calibre3">In this version, let’s create a new method overload for spawning a single Prefab. This method will simply pass values to our previous <code>SpawnPrefab()</code> method, which requires an array of Prefabs. So, we just need to add the single Prefab to a <em class="italic">single item </em><em class="italic">array</em> first:</p>
<pre class="source-code">
private void SpawnPrefab(GameObject prefab, Vector3 playerOffset)
    =&gt; SpawnPrefab(new GameObject[] { prefab },
        playerOffset, Vector3.zero, 0f);</pre> <p class="calibre3">Notice we preset<a id="_idIndexMarker1577" class="pcalibre1 pcalibre calibre6"/> the parameter values for <code>forceDirection</code> and <code>force</code> to zeros to ensure no physics forces will be applied to the spawned object.</p>
<p class="calibre3">Save the script, assign <code>Gun</code> to the <code>GameManager</code>’s <strong class="bold">Prefab Gun</strong> field, save the scene, and playtest with all the elements in place for the start of our game.</p>
<p class="calibre3">In this section, we learned how to create interactable Prefab variants for the player and collect and place modules into slots on the control console, enhancing player engagement <a id="_idIndexMarker1578" class="pcalibre1 pcalibre calibre6"/>within the environment. We also learned how to implement shooting for the gun as a secondary activate action for objects held by the player. Now, with the added ability to shoot, let’s see how we bring everything together with the gameplay mechanics.</p>
<h1 id="_idParaDest-277" class="calibre5"><a id="_idTextAnchor296" class="pcalibre1 pcalibre calibre6"/>Implementing the boss room mechanics</h1>
<p class="calibre3">In our climactic<a id="_idIndexMarker1579" class="pcalibre1 pcalibre calibre6"/> boss room battle, the player will collect the crystal module puzzle pieces while defending against virtual enemies – the patrolling hover bots the evil plant entity has so rudely infected. With the unique blend of a physical space for exploration and interactive gameplay with digital objects the MR technology provides, our players will be challenged to think strategically while physically exerting themselves. This innovative and novel approach to boss room mechanics pushes the boundaries of traditional video game design, and I’m very excited to see this technology continue to mature and break more boundaries!</p>
<p class="calibre3">This chapter is dedicated to introducing the Unity technologies that enable game developers and creators to rapidly produce compelling and immersive MR experiences for players to consume and enjoy enthusiastically. As such, the concepts for the boss room mechanics will be discussed in a broader sense and we’ll only dive into the details where additional clarification is required.</p>
<p class="calibre3">In this section, we’ll finalize the puzzle mechanic by implementing the logic required to solve it and energize the console. We’ll also set up the enemy bots to spawn and move toward the player, as well as their shooting behavior. Finally, we will complete the game loop by updating the game state.</p>
<p class="calibre3">So, first, concerning the crystal modules, let’s work with the problem of solving the control console <a id="_idIndexMarker1580" class="pcalibre1 pcalibre calibre6"/>puzzle.</p>
<h2 id="_idParaDest-278" class="calibre8"><a id="_idTextAnchor297" class="pcalibre1 pcalibre calibre6"/>Solving the crystal modules puzzle</h2>
<p class="calibre3">As previously<a id="_idIndexMarker1581" class="pcalibre1 pcalibre calibre6"/> discussed, the crystal modules <a id="_idIndexMarker1582" class="pcalibre1 pcalibre calibre6"/>must be collected and placed back into the control console. Each console slot and module have corresponding IDs, but the order in which they must be placed is not apparent to us – the console just shows some garbled characters. Let’s have a look at the console controller script to set the correct combination for the modules and determine when they’ve been inserted successfully.</p>
<p class="calibre3">To complete the task of restoring the console and reenergizing the reactor successfully, the modules must be inserted in the exact order, starting with the first one – you cannot just randomly place them to end up in the correct order (that’s just how this tech works; I don’t think you should blame me for this). This makes the puzzle more challenging for the player because you must fend off the enemy hover bots while figuring this out!</p>
<p class="calibre3">Inspecting the <code>ConsoleController</code> script, we first see the solution code as a serialized private <code>string</code> variable, <code>_consoleCode</code>, so we can inspect and set it in the Inspector at any time:</p>
<pre class="source-code">
public class ConsoleController : MonoBehaviour
{
    [SerializeField] private string _consoleCode = "CBA";
    …
    public void InsertModule(char slotID, char moduleID)
    {
        // TODO: Solve module sequence logic.
        ConsoleEnergized();
    }
}</pre> <p class="calibre3">The <code>InsertModule()</code> code will efficiently handle modules inserted in a specific order, provide feedback for incorrect placement, and signal success for the correct sequence. The module insertion and solving logic should be carried out like so:</p>
<ol class="calibre14">
<li class="calibre15">Using the current slot index, starting at zero, check the slot order against the inserted module.</li>
<li class="calibre15">Increment the slot index when the next correct module ID has been provided; otherwise, reset the slots (index set back to zero).</li>
<li class="calibre15">Check for code completion and update UI or trigger events accordingly.</li>
</ol>
<p class="callout-heading">Bonus challenge</p>
<p class="callout">In the <strong class="source-inline1">ConsoleController</strong> class, based on the above steps, code the puzzle-solving logic for the correct order of modules inserted into the console with the <strong class="source-inline1">InsertModule(_slotID, _moduleID)</strong> method yourself first.</p>
<p class="callout">You can get just the completed console puzzle code in the <strong class="source-inline1">ConsoleController</strong> script from the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets</a>.</p>
<p class="calibre3">These steps are<a id="_idIndexMarker1583" class="pcalibre1 pcalibre calibre6"/> designed to ensure that the<a id="_idIndexMarker1584" class="pcalibre1 pcalibre calibre6"/> modules are inserted in the correct order and that a module’s ID matches the expected ID for the current slot index. The console is activated if all modules are correctly inserted, while progress is displayed on the console screen (UI).</p>
<p class="callout-heading">World space UI</p>
<p class="callout">For the console screen (UI) mentioned above, in step 3’s <em class="italic">update UI</em>, the control console Prefab includes a world<a id="_idIndexMarker1585" class="pcalibre1 pcalibre calibre6"/> space <strong class="bold">uGUI Canvas</strong><strong class="bold"><a id="_idIndexMarker1586" class="pcalibre1 pcalibre calibre6"/></strong>. A world space UI is a user interface that appears within the game’s 3D world instead of as a screen overlay. It is rendered on a canvas that can be positioned, rotated, and scaled just like any other 3D object in the scene. Developers use them to create interactive elements within the game world, such as control panels, information displays, or interactive menus.</p>
<pre>TextMeshProUGUI</strong> and <strong class="source-inline1">.text = "string"</strong>; either approach is acceptable (i.e., developer style).</pre>
<p class="calibre3">When the player has restored the console, we can notify the reactor to energize it via an event. And what better event implementation could we use than our very own global event system? Refer to <a href="B18347_09.xhtml#_idTextAnchor169" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a> for a refresher on the event system’s setup and usage (just make sure to add the <code>EventSystem</code> component to the scene somewhere). But you can see how we trigger this event in the <code>ConsoleEnergized()</code> method here:</p>
<pre class="source-code">
public void ConsoleEnergized()
{
    _consoleScreen.SetText(MSG_SOLVED);
    EventSystem.Instance.TriggerEvent(
        EventConstants.OnConsoleEnergized, true);
}</pre> <p class="calibre3">Then, in the <code>Reactor</code> script, we<a id="_idIndexMarker1587" class="pcalibre1 pcalibre calibre6"/> respond to <a id="_idIndexMarker1588" class="pcalibre1 pcalibre calibre6"/>the event by simply swapping the mesh renderer’s material to one with an emissive property to visually indicate that it has been energized (this can be much more than just a simple material change; think of a particle <a id="_idIndexMarker1589" class="pcalibre1 pcalibre calibre6"/>system, <strong class="bold">VFX Graph</strong>, or <a id="_idIndexMarker1590" class="pcalibre1 pcalibre calibre6"/>a custom <strong class="bold">Shader Graph</strong>):</p>
<pre class="source-code">
public class Reactor : MonoBehaviour
{
    …
    private void OnEnable()
        =&gt; EventSystem.Instance.AddListener&lt;bool&gt;(
            EventConstants.OnConsoleEnergized, Energize);
    public void Energize(bool energize)
        =&gt; _renderer.material = _matEnergized;
}</pre> <p class="calibre3">With the problem now solved to implement the puzzle mechanics, let’s move on to spawning the waves <a id="_idIndexMarker1591" class="pcalibre1 pcalibre calibre6"/>of hover bot enemies… since they are supposed to get in our way and make solving the puzzle even more challenging!</p>
<h2 id="_idParaDest-279" class="calibre8"><a id="_idTextAnchor298" class="pcalibre1 pcalibre calibre6"/>Spawning enemies</h2>
<p class="calibre3">We have a<a id="_idIndexMarker1592" class="pcalibre1 pcalibre calibre6"/> challenge. Now, let’s make it even more<a id="_idIndexMarker1593" class="pcalibre1 pcalibre calibre6"/> difficult for the player! Spawning waves of enemies in a boss room encounter dramatically enhances the player’s challenge and boosts the intensity of the gameplay. The approach of spawning an unrelenting number of adversaries not only heightens the excitement and satisfaction of overcoming the challenge but also deepens the player’s engagement with the mechanics of the battle.</p>
<p class="calibre3">The <code>Corridor</code> Prefab provided with the boss room starter assets includes game objects for the locations of the spawner and the target position at the doorway end of the hallway for where the hover bot will travel. So, let’s complete the setup by adding the <code>EnemySpawner</code> component and configuring its properties.</p>
<div><div><img alt="Figure 14.15 – The enemy spawner component values" src="img/B18347_14_15.jpg" class="calibre171"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 14.15 – The enemy spawner component values</p>
<p class="callout-heading">Note on the starter assets provided</p>
<p class="callout">The assets included in the provided starter assets package already imported have been created using the techniques in previous chapters. You will find that the design patterns, code architecture, and all the components used will be familiar. Therefore, we won’t be covering everything again. However, I recommend taking some time to examine the components used for configuring these Prefabs, especially <strong class="source-inline1">Enemy Hover Bot A Shooting 1</strong>, since it offers the most significant example.</p>
<p class="calibre3">You may very well already be able to handle adding the spawner component and configuring it. If so, congrats! Still, for reference, here are the steps we can follow to configure it now:</p>
<ol class="calibre14">
<li class="calibre15">Open the <code>Corridor</code> Prefab in the <code>Assets/Prefabs</code> folder in Prefab Mode.</li>
<li class="calibre15">Add the <code>EnemySpawner</code> script to the <code>SpawnerLocation</code> child object. We add the script here because we’ll use the object’s transform forward as the direction of travel for the spawned hover bot.</li>
<li class="calibre15">Assign the component’s field values:<ul class="calibre22"><li class="calibre15"><code>2</code> (starting value – this is the time between checking if the currently instantiated bot has been destroyed).</li><li class="calibre15"><code>(2, 6)</code> (the time between instantiating the bot and sending it on its way down the corridor).</li></ul></li>
<li class="calibre15">Exit Prefab Mode and save the changes.</li>
</ol>
<p class="calibre3">Now, when we do the <em class="italic">build and run</em> drill, we’ll have enemy hover bots repeatedly spawning when <a id="_idIndexMarker1594" class="pcalibre1 pcalibre calibre6"/>destroyed, moving toward us in their<a id="_idIndexMarker1595" class="pcalibre1 pcalibre calibre6"/> menacing fashion, and when they get within range, they’ll start shooting (using our pooled shooting setup, of course).</p>
<p class="calibre3">We’ll have to ensure a few things are configured still because importing assets from <code>'.unitypackage'</code> is not the same as having a starting Unity project. Things such as <strong class="bold">Layers</strong> and <strong class="bold">Tags</strong>, <strong class="bold">AI Navigation</strong> settings, and <strong class="bold">Build Settings</strong> are not brought in with the imported assets.</p>
<p class="calibre3">Ensure the following layers are added to the project (<code>Projectile</code>, <code>Damageable</code></p>
<p class="calibre3">Now, within the <code>Assets/Prefabs</code> folder, make the following Prefab objects’ assignments:</p>
<ul class="calibre17">
<li class="calibre15"><code>PlasmaBall</code> Prefab: Select it and, in the Inspector, using the <code>Projectile</code>.</li>
</ul>
<p class="calibre3">Also, use <strong class="bold">Layer Collision Matrix</strong> at the bottom of the <strong class="bold">Edit</strong> | <strong class="bold">Project Settings…</strong> | <strong class="bold">Physics</strong> settings page to disable collisions between <strong class="bold">Placeable Surface</strong> and <strong class="bold">Projectile</strong> – we don’t want the two to have a physics interaction.</p>
<ul class="calibre17">
<li class="calibre15"><code>Gun</code> Prefab: Select it and, in the Inspector, for the <code>Gun</code> component, set <code>Damageable</code>.</li>
<li class="calibre15"><code>Enemy Hover Bot A Shooting 1</code>: Select it and, in the Inspector, set <code>Damageable</code>. You can probably recognize how this layer assignment correlates to the damage mask assignment for the preceding gun.</li>
</ul>
<p class="callout-heading">Complete code</p>
<p class="callout">For reference, the complete code and project setup for this section can be found in the Unity project files provided for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Unity-Project" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Unity-Project</a>.</p>
<p class="calibre3">This time, playing the game will have the proper interactions between the interactable objects and the virtual room surfaces where the gun damages and destroys the hover bots, and the bot’s <a id="_idIndexMarker1596" class="pcalibre1 pcalibre calibre6"/>projectile weaponry, the<a id="_idIndexMarker1597" class="pcalibre1 pcalibre calibre6"/> plasma ball, approaches the player – you – fully. All that’s left to do is complete the game loop for win-and-lose conditions… making it an actual game challenge.</p>
<h2 id="_idParaDest-280" class="calibre8"><a id="_idTextAnchor299" class="pcalibre1 pcalibre calibre6"/>Completing the game loop</h2>
<p class="calibre3">Completing a game loop <a id="_idIndexMarker1598" class="pcalibre1 pcalibre calibre6"/>with clear conditions for <a id="_idIndexMarker1599" class="pcalibre1 pcalibre calibre6"/>winning or losing is fundamental in game design. Winning conditions often culminate in overcoming a final challenge like our boss room and reward players with an enormous sense of accomplishment for winning, while losing conditions such as depleting health increases the game’s challenge. The fragile balance between these conditions is critical to ensure the experience is engaging, rewarding, and fair in terms of the time players invest in your game.</p>
<p class="calibre3">I’m not going to make the claim that I have accomplished perfect, or even near perfect, game balance in the boss room battle we’ve created with the default values provided in this chapter. It’s simply the foundation for what’s possible when creating an immersive, engaging, and fun MR game experience.</p>
<p class="calibre3">Let’s finish up the boss <a id="_idIndexMarker1600" class="pcalibre1 pcalibre calibre6"/>room MR game by looking at how we tie in the winning <a id="_idIndexMarker1601" class="pcalibre1 pcalibre calibre6"/>and losing conditions from the gameplay created, starting with losing.</p>
<h3 class="calibre10">Losing the battle</h3>
<p class="calibre3">When it comes to <a id="_idIndexMarker1602" class="pcalibre1 pcalibre calibre6"/>playing video games, losing is just as common as winning – anyone who’s played a video game has experienced losing. For our MR boss room battle, with enemy hover bots shooting at us, the apparent game-losing scenario is we run out of health to continue playing. So, that’s just what we’re going to do.</p>
<p class="calibre3">To complete the setup in our scene to support losing by player health depletion, we first need to ensure we have a <code>Player</code> object in the scene – a GameObject tagged <code>Player</code> with the <code>Player</code> script added. Follow these steps to complete the player setup:</p>
<ol class="calibre14">
<li class="calibre15">Add the <code>Player</code> Prefab as a child of <code>MR </code><code>Interaction Setup</code>.</li>
<li class="calibre15">Ensure it’s tagged as <code>Player</code>. Add the <code>Player</code> tag for assigning it now if it’s not already there.</li>
<li class="calibre15">Ensure the <code>Player</code> object’s layer is set to <code>Damageable</code>.</li>
</ol>
<p class="calibre3"><code>Player</code> implements the <code>IHaveHealth</code> interface for the health system, so also ensure the enemy’s <code>PlasmaBall</code> Prefab’s <code>ProjectileDamage</code> component has <code>Damageable</code> set for <strong class="bold">Damage Mask</strong>.</p>
<p class="calibre3">Within the <code>Player</code> class, we have an event system event triggered when the player’s health has fully diminished after taking too many plasma ball hits from the enemy hover bots:</p>
<pre class="source-code">
public class Player : MonoBehaviour, IHaveHealth
{
    …
    public void Died()
        =&gt; EventSystem.Instance.TriggerEvent(
            EventConstants.OnPlayerDied, true);
}</pre> <p class="calibre3">Our <code>GameManager</code> class will listen to the event and respond by setting the <code>_isConditionMetLose</code> condition variable for losing and responding accordingly. With <code>true</code> being passed as the Boolean value for the event, we use it to set the condition:</p>
<pre class="source-code">
private void OnEnable()
{
    EventSystem.Instance.AddListener&lt;bool&gt;(
        EventConstants.OnPlayerDied, SetLoseCondition);}
}
private void SetLoseCondition(bool value)
    =&gt; _isConditionMetLose = value;</pre> <p class="calibre3">We can use the individual event to update the UI, turn the passthrough off, or fade to black. However, the <code>GameManager</code> will <a id="_idIndexMarker1604" class="pcalibre1 pcalibre calibre6"/>respond to the condition change by ending the game:</p>
<pre class="source-code">
private void Update()
{
    switch (_currentState)
    {
        case State.Playing:
            if (_isConditionMetLose || _isConditionMetWin)
                ChangeState(State.GameOver);
            break;
    }
}</pre> <p class="callout-heading">FSM refactor</p>
<p class="callout">The best solution to keep track of our game states is, of course, a state pattern. We previously used a <a id="_idIndexMarker1605" class="pcalibre1 pcalibre calibre6"/>simple <strong class="bold">finite state machine</strong> (<strong class="bold">FSM</strong>) in our <strong class="source-inline1">EnemyController</strong> class; you can also find it here. A refactor of the enum-based FSM was beyond the scope of what I had planned for the book, so I’ve left the refactor to you, but with a provided example <a id="_idIndexMarker1606" class="pcalibre1 pcalibre calibre6"/>using the <strong class="bold">UnityHFSM</strong> (<strong class="bold">Unity Hierarchical Finite State Machine</strong>) package available on GitHub here: <a href="https://github.com/Inspiaaa/UnityHFSM?tab=readme-ov-file#simple-state-machine" class="pcalibre1 pcalibre calibre6">https://github.com/Inspiaaa/UnityHFSM?tab=readme-ov-file#simple-state-machine</a>.</p>
<p class="callout">In the project files provided by the book’s GitHub repo, inspect and evaluate the refactored <strong class="source-inline1">Assets/Scripts/Refactored/GameManager_HFSM</strong> script for an example implementation compared to the enum-based <strong class="source-inline1">switch</strong> statements in <strong class="source-inline1">GameManager</strong> and implement it in your project.</p>
<p class="calibre3">Losing the battle is not fun, but if you don’t succeed… what’s the saying “<em class="italic">try, try again</em>?” I’m sure if yo<a id="_idIndexMarker1607" class="pcalibre1 pcalibre calibre6"/>u do, you will win. Let’s see how the win condition is wired; it’s really just like the lose condition – the global event system really makes this easy.</p>
<h3 class="calibre10">Winning the battle</h3>
<p class="calibre3">For our MR boss room <a id="_idIndexMarker1608" class="pcalibre1 pcalibre calibre6"/>battle, with enemy hover bots as the primary adversaries, the winning scenario is clearly defeating all waves of enemies, right? No. That’s not what we’ve laid the groundwork for here; as you already know, we win the game when we solve the puzzle of the control console slots and reenergize the reactor.</p>
<p class="calibre3">Since everything is already in place for reenergizing the reactor with a global event system event, we’re just going to add another listener to the <code>OnConsoleEnergized</code> event in <code>GameManager</code> to set the win condition variable, exactly like we did for losing:</p>
<pre class="source-code">
private void OnEnable()
{
    …
    EventSystem.Instance.AddListener&lt;bool&gt;(
        EventConstants.OnConsoleEnergized, SetWinCondition);
}
private void SetWinCondition(bool value)
    =&gt; _isConditionMetWin = value;</pre> <p class="calibre3">And that’s it! Setting the game state to <code>State.GameOver</code> handles the rest!</p>
<p class="calibre3">By carefully setting up the game states and defining a clear path to victory, we create a rewarding gameplay loop that challenges players to develop strategies to overcome the game’s challenges and ultimately achieve success in their MR boss room battle.</p>
<p class="calibre3">In this section, we explored a basic set of boss room mechanics for our MR game. We learned how to integrate and solve a puzzle mechanic that players must figure out under pressure and introduced how to spawn waves of enemies equipped with projectile weaponry. Learning about the player’s laser pistol configuration allows for damaging and destroying the hover bots. Then, we further understood how to connect the win and lose <a id="_idIndexMarker1609" class="pcalibre1 pcalibre calibre6"/>conditions in the game manager state machine to complete the game design, emphasizing the strategic balance between solving puzzles and surviving.</p>
<h1 id="_idParaDest-281" class="calibre5"><a id="_idTextAnchor300" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we explored the Unity MR technologies that streamline development and empower developers to create immersive MR experiences. We took a dive into the design principles of crafting a captivating boss room while setting up our physical space with Quest devices and configuring Unity’s MR template to suit our needs. Furthermore, we gained insights into leveraging AR planes and components to manipulate AR visual elements and spawn virtual objects dynamically within our environment.</p>
<p class="calibre3">Additionally, we honed our skills in creating interactive Prefab variants and integrating shooting mechanics to support core gameplay. By enabling players to collect and place modules into control console slots, we deepened the XR interactive potential of our game world. Bringing together all the various MR elements, we crafted a compelling MR gaming experience.</p>
<p class="calibre3">In the next chapter, we’ll see what it means to operate a published game by exploring Games as a Service, including Unity DevOps and LiveOps, look at safeguarding the investment you make in your projects through robust source code management and strategies for engaging players through in-game economies, and touch on some essentials of platform distribution. This overview will equip you with the tools and knowledge to effectively manage, maintain, expand, and distribute your finished games.</p>
</div>
</div></body></html>