<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Project A – the Collection Game Continued</h1></div></div></div><p>This chapter continues from the previous one by building a collection game with Unity. In this game, the player wanders an environment in first-person mode, searching for and collecting all coins in a scene before a global timer expires. If all coins are collected before timer expiry, the game is won. However, if the timer expires before all coins are collected, the game is lost. The project created so far features a complete environment, with a floor, props, and water, and it also features a first-person controller along with a basic coin object, which looks correct in shape and form but still cannot be collected.</p><p>This chapter completes the project by creating a coin object to collect and adding a timer system to determine whether the total game time has elapsed. In essence, this chapter is about defining a system of logic and rules governing the game. To achieve this, we'll need to code in C# and so this chapter requires a basic understanding of programming. This book is about Unity and developing games with that engine. The basics of programming as a subject is, however, beyond the scope of this book. So I'll assume that you already have a working knowledge of coding generally but have simply not coded in Unity before. Overall, this chapter will demonstrate the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Material creation</li><li class="listitem" style="list-style-type: disc">Prefabs</li><li class="listitem" style="list-style-type: disc">Coding with C#</li><li class="listitem" style="list-style-type: disc">Writing script files</li><li class="listitem" style="list-style-type: disc">Using particle systems</li><li class="listitem" style="list-style-type: disc">Building and compiling games</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating a coin material</h1></div></div></div><p>The previous <a id="id82" class="indexterm"/>chapter closed by creating a basic coin object from a <a id="id83" class="indexterm"/>non-uniformly scaled cylinder primitive. This object was created by selecting <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Cylinder</strong> from the application menu. See <em>Figure 2.1</em>. The coin object, as a concept, represents a basic or fundamental unit in our game logic because the player character should be actively searching the level looking for coins to collect before a timer runs out. This means that the coin is more than mere <em>appearance</em>; its purpose in the game is not simply eye candy, but is functional. It makes an immense difference to the game outcome whether the coin is collected by the player or not. Therefore, the <a id="id84" class="indexterm"/>coin object, as it stands, is lacking in two important respects. Firstly, it looks dull and grey—it doesn't really stand out and grab the player's attention. Secondly, the coin cannot actually be collected yet. Certainly, the player can walk into the coin, but nothing appropriate <a id="id85" class="indexterm"/>happens in response.</p><div><img src="img/figure_02_01.jpg" alt="Creating a coin material"/><div><p>Figure 2.1: The coin object so far</p></div></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>The completed <code class="literal">CollectionGame</code> project, as discussed in this chapter and the next, can be found in the book companion files in the <code class="literal">Chapter02/CollectionGame</code> folder.</p></div></div><p>In this section, we'll <a id="id86" class="indexterm"/>focus on improving the coin appearance using a <strong>material</strong>. A material defines an algorithm (or instruction set) specifying how the coin should be rendered. A material doesn't just say what the coin should look like in terms of color; it defines how shiny or smooth a surface is, as opposed to rough and diffuse. This is important to recognize and is why a texture and material refer to different things. A texture is simply an image file loaded in memory, which can be wrapped around a 3D object via its UV mapping. In contrast, a material defines how one or more textures can be combined together and applied to an object to shape its appearance. To create a new material asset in Unity, right-click on an empty area in the <strong>Project</strong> panel, and from the context menu, choose <strong>Create</strong> | <strong>Material</strong>. See <em>Figure 2.2</em>. You can also choose <strong>Assets</strong> | <strong>Create</strong> | <strong>Material</strong> <a id="id87" class="indexterm"/>from the application menu.</p><div><img src="img/figure_02_02.jpg" alt="Creating a coin material"/><div><p>Figure 2.2: Creating a material</p></div></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>A material is sometimes called a <strong>Shader</strong>. If needed, you can create custom materials using a <strong>Shader Language</strong> or you can use a Unity add-on, such as <strong>Shader Forge</strong>.</p></div></div><p>After creating a new material, assign it an appropriate name from the Project panel. As I'm aiming for a gold look, I'll name the material <code class="literal">mat_GoldCoin</code>. Prefixing the asset name with <code class="literal">mat</code> helps me know, just from the asset name, that it's a material asset. Simply type a new name in the <a id="id88" class="indexterm"/>text edit field to name the material. You can also <a id="id89" class="indexterm"/>click on the material name twice to edit the name at any time later. See <em>Figure 2.3</em>:</p><div><img src="img/figure_02_03.jpg" alt="Creating a coin material"/><div><p>Figure 2.3: Naming a material asset</p></div></div><p>Next, select the material asset in the <strong>Project</strong> panel, if it's not already selected, and its properties display immediately in the <strong>Object Inspector</strong>. There are lots of properties listed! In addition, a material preview displays at the bottom of the <strong>Object Inspector</strong>, showing you how the material would look, based on its current settings, if it were applied to a 3D object, such as a sphere. As you change material settings from the <strong>Inspector</strong>, the preview panel updates automatically to reflect your changes, offering instant feedback on how the material would look. See <a id="id90" class="indexterm"/>the following screenshot:</p><div><img src="img/figure_02_04.jpg" alt="Creating a coin material"/><div><p>Figure 2.4: Material properties are changed from the Object Inspector</p></div></div><p>Let's now create a gold <a id="id91" class="indexterm"/>material for the coin. When creating any material, the first setting to choose is the <strong>Shader</strong> type because this setting affects all other parameters available to you. The <strong>Shader</strong> type determines which algorithm will be used to shade your object. There are many different choices, but most material types can be approximated using either <strong>Standard</strong> or <strong>Standard (Specular setup)</strong>. For the gold coin, we can leave the <strong>Shader</strong> as <strong>Standard</strong>. See the following screenshot:</p><div><img src="img/figure_02_05.jpg" alt="Creating a coin material"/><div><p>Figure 2.5: Setting the material Shader type</p></div></div><p>Right now, the preview panel displays the material as a dull grey, which is far from what we need. To define a <a id="id92" class="indexterm"/>gold color, we must specify the <strong>Albedo</strong>. To do this, click on the <strong>Albedo</strong> color slot to display a <strong>Color</strong> picker, and from the <strong>Color</strong> picker dialog, select a <a id="id93" class="indexterm"/>gold color. The material preview updates in response to reflect the changes. Refer to the following screenshot:</p><div><img src="img/figure_02_06.jpg" alt="Creating a coin material"/><div><p>Figure 2.6: Selecting a gold color for the Albedo channel</p></div></div><p>The coin material is looking better than it did, but it's still supposed to represent a metallic surface, which <a id="id94" class="indexterm"/>tends to be shiny and reflective. To add this quality to our <a id="id95" class="indexterm"/>material, click and drag the <strong>Metallic</strong> slider in the <strong>Object Inspector</strong> to the right-hand side, setting its value to <code class="literal">1</code>. This indicates that the material represents a fully metal surface as opposed to a diffuse surface such as cloth or hair. Again, the preview panel will update to reflect the change. See <em>Figure 2.7</em>:</p><div><img src="img/figure_02_07.jpg" alt="Creating a coin material"/><div><p>Figure 2.7: Creating a metallic material</p></div></div><p>We now have a gold material created, and it's looking good in the preview panel. If needed, you can change the kind of object used for a preview. By default, Unity assigns the created material to <a id="id96" class="indexterm"/>a sphere, but other primitive objects are allowed, including cubes, cylinders, and torus. This helps you preview materials under different conditions. You can change objects by clicking on the geometry button directly above the preview panel to cycle through them. See <em>Figure 2.8</em>:</p><div><img src="img/figure_02_08.jpg" alt="Creating a coin material"/><div><p>Figure 2.8: Previewing a material on an object</p></div></div><p>When your material is ready, you can assign it directly to meshes in your scene just by dragging and dropping. Let's assign the coin material to the coin. Click and drag the material from the <strong>Project</strong> <a id="id97" class="indexterm"/>panel to the coin object in the scene. On dropping the <a id="id98" class="indexterm"/>material, the coin will change appearance. See <em>Figure 2.9</em>:</p><div><img src="img/figure_02_09.jpg" alt="Creating a coin material"/><div><p>Figure 2.9: Assigning the material to the coin</p></div></div><p>You can confirm that material assignment occurred successfully and can even identify which material was assigned by selecting the <code class="literal">Coin</code> object in the <strong>Scene</strong> and viewing its <strong>Mesh Renderer</strong> component from the <strong>Object Inspector</strong>. The <strong>Mesh Renderer</strong> component is responsible for making sure that a mesh object is actually visible in the scene when the camera is looking. The <strong>Mesh Renderer</strong> component contains a <strong>Materials</strong> field. This lists all materials currently assigned to the object. By clicking on the material name from the <strong>Materials</strong> field, Unity <a id="id99" class="indexterm"/>automatically selects the material in the <strong>Project</strong> panel, making <a id="id100" class="indexterm"/>it quick and simple to locate materials. See <em>Figure 2.10</em>, The <strong>Mesh Renderer</strong> component lists all materials assigned to an object:</p><div><img src="img/figure_02_10.jpg" alt="Creating a coin material"/><div><p>Figure 2.10: The Mesh Renderer component lists all materials assigned to an object</p></div></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Mesh objects may have multiple materials with different materials assigned to different faces. For the best in-game performance, use as few unique materials on an object as <a id="id101" class="indexterm"/>necessary. Make the extra effort to share materials across multiple objects, if possible. Doing so can significantly enhance the performance of your game. For more information on optimizing <a id="id102" class="indexterm"/>rendering performance, see the online documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html">http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html</a>.</p></div></div><p>That's it! You now have a complete and functional gold material for the collectible coin. It's looking good. However, we're still not finished with the coin. The coin looks right, but it doesn't behave right. Specifically, it doesn't disappear when touched, and we don't yet keep track of how <a id="id103" class="indexterm"/>many coins the player has collected overall. To address this, then, we'll need to script.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>C# scripting in Unity</h1></div></div></div><p>Defining game <a id="id104" class="indexterm"/>logic, rules, and behavior often requires scripting. Specifically, to <a id="id105" class="indexterm"/>transform a static and lifeless scene with objects into an environment that does something, a developer needs to code behaviors. It requires someone to define how things should act and react under specific conditions. The coin collection game is no exception to this. In particular, it requires three main features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To know when the player collects a coin</li><li class="listitem" style="list-style-type: disc">To keep track of how many coins are collected during gameplay</li><li class="listitem" style="list-style-type: disc">To determine whether a timer has expired</li></ul></div><p>There's no default out-of-the-box functionality included with Unity to handle this scenario. So we must write some code to achieve it. Unity supports two languages, namely, UnityScript (sometimes called JavaScript) and C#. Both are capable and useful languages, but this book uses C# because, going forward, support for JavaScript will eventually be dropped. Let's start coding these three features in sequence. To create a new script file, right-click on an <a id="id106" class="indexterm"/>empty area in the <strong>Project</strong> panel, and from the context menu, choose <strong>Create</strong> | <strong>C# Script</strong>. Alternatively, you can navigate to <strong>Assets</strong> | <strong>Create</strong> | <strong>C# Script</strong> from the application menu. See <em>Figure 2.11</em>:</p><div><img src="img/figure_02_11.jpg" alt="C# scripting in Unity"/><div><p>Figure 2.11: Creating a new C# script</p></div></div><p>After the file is <a id="id107" class="indexterm"/>created, you'll need to assign a descriptive name to it. I'll call it <code class="literal">Coin.cs</code>. In Unity, each script file represents a single, discrete class of matching names. Hence, the <code class="literal">Coin.cs</code> file encodes the <code class="literal">Coin</code> class. The <code class="literal">Coin</code> class will encapsulate the behavior of a <code class="literal">Coin</code> object and will, eventually, be attached to the <code class="literal">Coin</code> object in the scene. See <em>Figure 2.12</em>:</p><div><img src="img/figure_02_12.jpg" alt="C# scripting in Unity"/><div><p>Figure 2.12: Naming a script file</p></div></div><p>Double-click on the <code class="literal">Coin.cs</code> file from the <strong>Object Inspector</strong> to open it to edit in <strong>MonoDevelop</strong>, a third-party <a id="id108" class="indexterm"/>IDE application that ships with Unity. This program lets you <a id="id109" class="indexterm"/>edit and write code for your games. Once opened in MonoDevelop, the source file will appear, as shown in <em>Code Sample 2.1</em>:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Coin : MonoBehaviour
{

  // Use this for initialization
  void Start () {}
  
  // Update is called once per frame
  void Update () {}
}</pre></div><div><div><h3 class="title"><a id="tip0007"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for this book from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>You can download the code files by following these steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Log in or register to our website using your e-mail address and password.</li><li class="listitem" style="list-style-type: disc">Hover the mouse pointer on the <strong>SUPPORT</strong> tab at the top.</li><li class="listitem" style="list-style-type: disc">Click on <strong>Code Downloads &amp; Errata</strong>.</li><li class="listitem" style="list-style-type: disc">Enter the name of the book in the <strong>Search</strong> box.</li><li class="listitem" style="list-style-type: disc">Select the book for which you're looking to download the code files.</li><li class="listitem" style="list-style-type: disc">Choose from the drop-down menu where you purchased this book from.</li><li class="listitem" style="list-style-type: disc">Click on <strong>Code Download</strong>.</li></ul></div><p>Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">WinRAR / 7-Zip for Windows</li><li class="listitem" style="list-style-type: disc">Zipeg / iZip / UnRarX for Mac</li><li class="listitem" style="list-style-type: disc">7-Zip / PeaZip for Linux</li></ul></div></div></div><p>By default, all newly created classes derive from <code class="literal">MonoBehavior</code>, which defines a common set of functionality <a id="id110" class="indexterm"/>shared by all components. The <code class="literal">Coin</code> class features two autogenerated functions, namely <code class="literal">Start</code> and <code class="literal">Update</code>. These functions are events invoked automatically by Unity. <code class="literal">Start</code> is called once as soon as the <code class="literal">GameObject</code> (to which the script is attached) is created in the <strong>Scene</strong>. <code class="literal">Update</code> is called once per frame on the object to which the script is attached. <code class="literal">Start</code> is useful for initialization code and <code class="literal">Update</code> is useful to create behaviors over time, such as motion and change. Now, before moving any further, let's attach the newly created script file to the <code class="literal">Coin</code> object in the <strong>Scene</strong>. To do this, drag and drop the <code class="literal">Coin.cs</code> script file from the <strong>Project</strong> panel on the <code class="literal">Coin</code> object. When you do this, a new <strong>Coin</strong> component is added to the object. This means that the script is instantiated and lives on the object. See <em>Figure 2.13</em>, attaching a script file to an object:</p><div><img src="img/figure_02_13.jpg" alt="C# scripting in Unity"/><div><p>Figure 2.13: Attaching a script file to an object</p></div></div><p>When a script is attached to an object, it exists on the object as a component. A script file can normally be added to multiple objects and even to the same object multiple times. Each component represents a separate and unique instantiation of the class. When a script is attached in this way, Unity automatically invokes its events, such as <code class="literal">Start</code> and <code class="literal">Update</code>. You can confirm that your script is working normally by including a <code class="literal">Debug.Log</code> statement in the <code class="literal">Start</code> <a id="id111" class="indexterm"/>function. This prints a debug message to the <strong>Console</strong> window <a id="id112" class="indexterm"/>when the <code class="literal">GameObject</code> is created in the <strong>Scene</strong>. Consider <em>Code Sample 2.2</em>, which achieves this:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Coin : MonoBehaviour
 {
  // Use this for initialization
  void Start () {
    <strong>Debug.Log ("Object Created");</strong>
  }
  
  // Update is called once per frame
  void Update () {
  

  }
}</pre></div><p>If you press play (<em>Ctrl</em> + <em>P</em>) on the toolbar to run your game with the preceding script attached to an object, you will see the message, <strong>Object Created</strong>, printed to the <strong>Console</strong> window—once for each instantiation of the class. See <em>Figure 2.14</em>:</p><div><img src="img/figure_02_14.jpg" alt="C# scripting in Unity"/><div><p>Figure 2.14: Printing messages to the Console window</p></div></div><p>Good work! We've now created a basic script for the <code class="literal">Coin</code> class and attached it to the coin. Next, let's <a id="id113" class="indexterm"/>define its functionality to keep track of coins as they are <a id="id114" class="indexterm"/>collected.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Counting coins</h1></div></div></div><p>The coin collection <a id="id115" class="indexterm"/>game wouldn't really be much of a game if there were only one coin. The central idea is that a level should feature many coins, all of which the player <a id="id116" class="indexterm"/>should collect before a timer expires. Now, to know whether all coins have been collected, we'll need to know how many coins there are in total in the scene. After all, if we don't know how many coins there are, then we can't know if we've collected them all. So, our first task in scripting is to configure the <code class="literal">Coin</code> class so that we can know the total number of coins in the scene at any moment easily. Consider <em>Code Sample 2.3</em>, which adapts the <code class="literal">Coin</code> class to achieve this:</p><div><pre class="programlisting">//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour 
{
  //-------------------------
  //Keeps track of total coin count in scene
  <strong>public static int CoinCount = 0;</strong>
  //-------------------------
  // Use this for initialization
  void Start () 
{
    //Object created, increment coin count
    <strong>++Coin.CoinCount;</strong>
  }
  //-------------------------
  //Called when object is destroyed
  void OnDestroy()
  {
    //Decrement coin count
    <strong>--Coin.CoinCount;</strong>
    
    //Check remaining coins
    if(Coin.CoinCount &lt;= 0)
    {
      //We have won
    }
  }
  //-------------------------
}
//-------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Code Sample 2.3</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Coin</code> class <a id="id117" class="indexterm"/>maintains a static member variable, <code class="literal">CoinCount</code>, which, being static, is shared across all instances of the class. This variable keeps count of the total number of coins in the scene and each instance has access to it.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Start</code> function is called once per <code class="literal">Coin</code> instance when the object is created in the <strong>Scene</strong>. For coins that are present when the scene begins, the <code class="literal">Start</code> event is called at scene startup. This function increments the <code class="literal">CoinCount</code> variable by one per instance, thus keeping count of all coins.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnDestroy</code> function is called once per instance when the object is destroyed. This decrements the <code class="literal">CoinCount</code> variable, reducing the count for each coin destroyed.</li></ul></div><p>Altogether, <em>Code Sample 2.3</em> maintains a <code class="literal">CoinCount</code> variable. In short, this variable allows us to always keep track of the total coin count. We can query it easily to determine how many coins remain. This is good, but is only the first step towards completing the coin collection functionality.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Collecting coins</h1></div></div></div><p>Previously, we <a id="id118" class="indexterm"/>developed a coin counting variable telling us how many coins are <a id="id119" class="indexterm"/>in the scene. However, regardless of the count, the player still can't collect the coins during gameplay. Let's fix this now. To start, we need to think about collisions. Thinking carefully, we know that a coin is considered collected whenever the player walks into it, that is, a coin is collected when the player and the coin intersect or collide.</p><p>To determine when a collision happens like that, we must approximate the volume of both the player and coin in order to determine when the two volumes overlap in space. This is achieved in Unity through colliders. Colliders are special physics objects attached to meshes. They tell us when two meshes intersect. The <code class="literal">FPSController</code> object (First-person controller) already has a collider on it, through its <strong>Character Controller</strong> component. This approximates the physical body of a generic person. This can be confirmed by selecting <code class="literal">FPSController</code> in the <strong>Scene</strong> and examining the green wireframe cage surrounding the main camera. It is capsule-shaped. See <em>Figure 2.15</em>, the <strong>Character Controller</strong> features a Collider to approximate the player body:</p><div><img src="img/figure_02_15.jpg" alt="Collecting coins"/><div><p>Figure 2.15: The Character Controller features a collider to approximate the player body</p></div></div><p>
<code class="literal">FPSController</code> features a <strong>Character Controller</strong> component attached, which is configured by default with <strong>Radius</strong>, <strong>Height</strong>, and <strong>Center</strong> settings, defining the physical extents of the character <a id="id120" class="indexterm"/>in the scene. See <em>Figure 2.16</em>, <code class="literal">FPSController</code> features <strong>Character Controller</strong>. These settings can be left unchanged for our game:</p><div><img src="img/figure_02_16.jpg" alt="Collecting coins"/><div><p>Figure 2.16: FPSController features a Character Controller</p></div></div><p>The <code class="literal">Coin</code> object, in contrast, features only a <strong>Capsule Collider</strong> component, which was added automatically when we created the <strong>Cylinder</strong> primitive earlier to resemble a coin. This approximates the coin's physical volume in the scene without adding any additional features specific to characters and motion as found in the <strong>Character Controller</strong> component. This is fine, because the coin is a <strong>Static</strong> object as opposed to a moving and dynamic object like the <a id="id121" class="indexterm"/>
<code class="literal">FPSController</code>. See <em>Figure 2.17</em>, <strong>Cylinder</strong> primitives <a id="id122" class="indexterm"/>feature a <strong>Capsule Collider</strong> component:</p><div><img src="img/figure_02_17.jpg" alt="Collecting coins"/><div><p>Figure 2.17: Cylinder primitives feature a Capsule Collider component</p></div></div><p>For this project, I'll stick to using a <strong>Capsule Collider</strong> component for the <code class="literal">Coin</code> object. However, if you want to change the attached collider to a different shape instead, such as a box or sphere, you can do this by first removing any existing collider components on the coin—click on the cog icon of the component in the <strong>Object Inspector</strong> and then select <strong>Remove Component</strong> <a id="id123" class="indexterm"/>from the context menu. See <em>Figure 2.18</em>:</p><div><img src="img/figure_02_18.jpg" alt="Collecting coins"/><div><p>Figure 2.18: Removing a component from an object</p></div></div><p>You can then add a new collider component to the selected object by choosing <strong>Component</strong> | <strong>Physics</strong> <a id="id124" class="indexterm"/>from the application menu and then choosing a suitably shaped collider. See <em>Figure 2.19</em>:</p><div><img src="img/figure_02_19.jpg" alt="Collecting coins"/><div><p>Figure 2.19: Adding a component to the selected object</p></div></div><p>Regardless of the collider type used, there's a minor problem. If you play the game now and try to run through the coin, it'll block your path. The coin acts as a solid, physical object through which <code class="literal">FPSController</code> cannot pass. However, for our purposes, this isn't how the coin should behave. It's supposed to be a collectible object. The idea is that when we walk through it, the coin is collected and disappears. We can fix this easily by selecting the <code class="literal">Coin</code> object and enabling the <strong>Is Trigger</strong> checkbox in the <strong>Capsule Collider</strong> component, in the <a id="id125" class="indexterm"/>
<strong>Object Inspector</strong>. The <strong>Is Trigger</strong> setting appears for almost all collider types. It lets us detect collisions and intersections with other colliders while allowing them to pass through. See <em>Figure 2.20</em>:</p><div><img src="img/figure_02_20.jpg" alt="Collecting coins"/><div><p>Figure 2.20: The Is Trigger setting allows objects to pass through colliders</p></div></div><p>If you play the game now, <code class="literal">FPSController</code> will easily walk through all coin objects in the scene. This is a good start. However, the coins don't actually disappear when touched; they still don't get collected. To achieve this, we'll need to add more script to the <code class="literal">Coin.cs</code> file. Specifically, we'll add an <code class="literal">OnTriggerEnter</code> function. This function is called automatically <a id="id126" class="indexterm"/>when an object, like the player, enters a collider. For now, we'll add a <code class="literal">Debug.Log</code> statement to print a debug message when the player enters the <a id="id127" class="indexterm"/>collider, just for test purposes. See <em>Code Sample 2.4</em>:</p><div><pre class="programlisting">//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour 
{
  //-------------------------
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Start () {
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  <strong>void OnTriggerEnter(Collider Col)</strong>
  <strong>{</strong>
    <strong>Debug.Log ("Entered Collider")</strong>;
  <strong>}</strong>
  //-------------------------
  //Called when object is destroyed
  void OnDestroy()
  {
    //Decrement coin count
    --Coin.CoinCount;
    
    //Check remaining coins
    if(Coin.CoinCount &lt;= 0)
    {
      //We have won
    }
  }
  //-------------------------
}
//-------------------------</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>More <a id="id128" class="indexterm"/>information on the <code class="literal">OnTriggerEnter</code> function can be found at the online Unity documentation here:</p><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html</a>
</p></div></div><p>Test the <em>Code Sample 2.4</em> by pressing play on the toolbar. When you run into a coin, the <code class="literal">OnTriggerEnter</code> function will be executed and the message displayed. However, the question remains as to <a id="id129" class="indexterm"/>what object initiated this function in the first place. It's true that something collided with the coin, but what exactly? Was it the player, an enemy, a falling brick, or something else? To check this, we'll use <strong>Tag</strong>. The <strong>Tag</strong> feature lets you mark specific objects in the scene with specific tags or labels, allowing these objects to be easily identified in code so that we can check quickly that the player, rather than other objects, are colliding with the coins. After all, it should only be the player that can <a id="id130" class="indexterm"/>collect coins. So, firstly, we'll tag the player object with a tag called <strong>Player</strong>. To do this, select the <code class="literal">FPSController</code> object in the scene and then click on the <strong>Tag</strong> drop-down box in the <strong>Object Inspector</strong>. From here, select the <strong>Player</strong> tag. This marks <code class="literal">FPSController</code> as the <code class="literal">Player</code> object. See <em>Figure 2.21</em>:</p><div><img src="img/figure_02_21.jpg" alt="Collecting coins"/><div><p>Figure 2.21: Tagging FPSController as Player</p></div></div><p>With <code class="literal">FPSController</code> now tagged as <strong>Player</strong>, we can refine the <code class="literal">Coin.cs</code> file, as shown in <em>Code Sample 2.5</em>. This <a id="id131" class="indexterm"/>handles coin collection, making the coin disappear on touch and decreasing the coin count.</p><div><pre class="programlisting">//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour 
{
  //-------------------------
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Start () {
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  void OnTriggerEnter(Collider Col)
  {
    //If player collected coin, then destroy object
    <strong>if(Col.CompareTag("Player"))</strong>
      <strong>Destroy(gameObject);</strong>
  }
  //-------------------------
  //Called when object is destroyed
  void OnDestroy()
  {
    //Decrement coin count
    --Coin.CoinCount;
    
    //Check remaining coins
    if(Coin.CoinCount &lt;= 0)
    {
      //We have won
    }
  }
  //-------------------------
}
//-------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Code Sample 2.5</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnTriggerEnter</code> is called once automatically by Unity each time <code class="literal">FPSController</code> <a id="id132" class="indexterm"/>intersects the <code class="literal">Coin</code> collider</li><li class="listitem" style="list-style-type: disc">When <code class="literal">OnTriggerEnter</code> is called, the <code class="literal">Col</code> argument contains information about the object that entered the collider on this occasion</li><li class="listitem" style="list-style-type: disc">The <code class="literal">CompareTag</code> function is used to determine if the colliding object is the <code class="literal">Player</code> as opposed to a different object</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Destroy</code> function is called to destroy the <code class="literal">Coin</code> object itself, represented internally by the inherited member variable, <code class="literal">gameObject</code><p>When the <code class="literal">Destroy</code> function is called, the <code class="literal">OnDestroy</code> event is invoked automatically, which decrements the <code class="literal">Coin</code> count</p></li></ul></div><p>Excellent work! You've just created your first working coin. The player can now run into the coin, collect it, and remove it from the scene. This is a great beginning, but the scene should contain more than one coin. We could solve this by duplicating the existing coin many times and repositioning each duplicate to a different place. However, there's a better way, as we'll see next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Coins and prefabs</h1></div></div></div><p>The basic coin <a id="id133" class="indexterm"/>functionality is now created, but the scene needs more than one coin. The problem with simply duplicating a coin and scattering the duplicates is that if we make a change later to one coin and need to propagate that change to all other coins, we'd <a id="id134" class="indexterm"/>need to delete the former duplicates and manually replace those with newer and amended duplicates. To avoid this tedious repetition, we can use prefabs. Prefabs let you convert an object in the scene to <code class="literal">Assets</code> in the <strong>Project</strong> panel. This can be instantiated in the scene as frequently as needed, as though it were a mesh asset. The advantage is that changes made to the asset are automatically applied to all instances automatically, even across multiple scenes.</p><p>This makes it easier to work with custom assets, so let's prefab the coin right now. To do this, select the <code class="literal">Coin</code> object in the scene and then drag and drop it in the <strong>Project</strong> panel. When this happens, a new <code class="literal">prefab</code> is created. The object in the scene is automatically updated to be an instance of <code class="literal">prefab</code>. This means that if the asset is deleted from the <code class="literal">Project</code> panel, the instance will become invalidated. See <em>Figure 2.22</em>:</p><div><img src="img/figure_02_22.jpg" alt="Coins and prefabs"/><div><p>Figure 2.22: Creating a coin prefab</p></div></div><p>After <code class="literal">prefab</code> is created, you can add more instances of the coin easily to the level by dragging and dropping <code class="literal">prefab</code> from the <strong>Project</strong> panel to the <strong>Scene</strong>. Each instance is linked to the original <code class="literal">prefab</code> asset, which means that all changes made to the asset will immediately be made to <a id="id135" class="indexterm"/>all instances. With this in mind, go ahead now and add as many <a id="id136" class="indexterm"/>
<code class="literal">Coin</code> prefabs to the level as suitable for your coin collection game. Refer to the following figure for my arrangement:</p><div><img src="img/figure_02_23.jpg" alt="Coins and prefabs"/><div><p>Figure 2.23: Adding coin prefabs to the level</p></div></div><p>One question that naturally arises is how you can transform prefab back into an independent <code class="literal">GameObject</code> that is no longer connected to the <code class="literal">prefab</code> asset. This is useful to do if you want some objects to be based on <code class="literal">prefab</code> but deviate from it slightly. To achieve this, select a <a id="id137" class="indexterm"/>
<code class="literal">prefab</code> instance in the <strong>Scene</strong>, and then navigate to <strong>GameObject</strong> | <strong>Break Prefab Instance</strong> from the application menu. See <em>Figure 2.24</em>:</p><div><img src="img/figure_02_24.jpg" alt="Coins and prefabs"/><div><p>Figure 2.24: Breaking the prefab instance</p></div></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>If you add a <code class="literal">prefab</code> instance to <strong>Scene</strong> and make changes to it that you like and want to distribute <a id="id138" class="indexterm"/>upstream back to the <code class="literal">prefab</code> asset, then select the object and choose <strong>GameObject</strong> | <strong>Apply Changes to Prefab</strong>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Timers and countdowns</h1></div></div></div><p>You should <a id="id139" class="indexterm"/>now have a level complete with geometry and coin objects. Thanks to our newly added <code class="literal">Coin.cs</code> script, the coins are both countable and collectible. Even so, the level still poses little or no challenge to the player because there's no way the level can be won or lost. Specifically, there's nothing for the player to achieve. This is why a time limit is important for the game: it defines a win and loss condition. Namely, collecting all coins before the timer expires results in a win condition and failing to achieve this results in a loss condition. Let's get started at creating a timer countdown for the level. To do this, create a new and empty game object by selecting <strong>GameObject</strong> | <strong>Create Empty</strong> and rename this to <code class="literal">LevelTimer</code>. See <em>Figure 2.25</em>:</p><div><img src="img/figure_02_25.jpg" alt="Timers and countdowns"/><div><p>Figure 2.25: Renaming the timer object</p></div></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Remember <a id="id140" class="indexterm"/>that empty game objects cannot be seen by the player because they have no mesh renderer component. They are especially useful to create functionality and behaviors that don't correspond directly to physical and visible entities, such as timers, managers, and game logic controllers.</p></div></div><p>Next, create a new script file named <code class="literal">Timer.cs</code> and add it to the <code class="literal">LevelTimer</code> object in <strong>Scene</strong>. By doing this, the timer functionality will exist in the scene. Make sure, however, that the timer script is added to one object, and no more than one. Otherwise, there will effectively be multiple, competing timers in the same scene. You can always search a scene to find all components of a specified type by using the <strong>Hierarchy</strong> panel. To do this, click in the <strong>Hierarchy</strong> search box and type <code class="literal">t:Timer</code>. Then press <em>Enter</em> on the keyboard to confirm the search. This searches the scene for all objects with a component attached of the timer type, and the results are displayed in the <strong>Hierarchy</strong> panel. Specifically, the <strong>Hierarchy</strong> <a id="id141" class="indexterm"/>panel is filtered to show only the matching objects. The <code class="literal">t</code> prefix in the search string indicates a search by type operation. See <em>Figure 2.26</em>:</p><div><img src="img/figure_02_26.jpg" alt="Timers and countdowns"/><div><p>Figure 2.26: Searching for objects with a component of matching type</p></div></div><p>You can easily cancel a search and return the <strong>Hierarchy</strong> panel back to its original state by clicking on the small cross icon aligned to the right-hand side of the search field. This button can be tricky to <a id="id142" class="indexterm"/>spot. See <em>Figure 2.27</em>:</p><div><img src="img/figure_02_27.jpg" alt="Timers and countdowns"/><div><p>Figure 2.27: Canceling a type search</p></div></div><p>The timer script itself must be coded if it's to be useful. The full source code for the <code class="literal">Timer.cs</code> file is given in the following <em>Code Sample 2.6</em>. This source code is highly important if you've never scripted in Unity before. It demonstrates so many critical features. See the comments for a fuller explanation.</p><div><pre class="programlisting">//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Timer : MonoBehaviour
{
  //-------------------------
  //Maximum time to complete level (in seconds)
  public float MaxTime = 60f;
  //-------------------------
  //Countdown
  <strong>[SerializeField]</strong>
  private float CountDown = 0;
  //-------------------------
  // Use this for initialization
  void Start () 
  {
    CountDown = MaxTime;
  }
  //-------------------------
  // Update is called once per frame
  <strong>void Update () </strong>
  {
    //Reduce time
    CountDown -= <strong>Time.deltaTime;</strong>

    //Restart level if time runs out
    if(CountDown &lt;= 0)
    {
      //Reset coin count
      Coin.CoinCount=0;
      <strong>Application.LoadLevel(Application.loadedLevel);</strong>
    }
  }
  //-------------------------
}
//-------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Code Sample 2.6</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In Unity, class <a id="id143" class="indexterm"/>variables declared as <code class="literal">public</code> (such as <code class="literal">public float MaxTime</code>) are displayed as editable fields in the <strong>Object Inspector</strong> of the editor. However, this applies to a range of supported data types only, but it's a highly useful feature. It means that developers can monitor and set <code class="literal">public</code> variables for classes directly from the <strong>Inspector</strong> as opposed to changing and recompiling code every time a change is needed. The <code class="literal">private</code> variables, in contrast, are hidden from the <strong>Inspector</strong> by default. However, you can force them to be visible, if needed, using the <code class="literal">SerializeField</code> attribute. The <code class="literal">private</code> variables prefixed with this attribute, such as the <code class="literal">CountDown</code> variable, will be displayed in the <strong>Object Inspector</strong> just like a <code class="literal">public</code> variable, even though the variable's scope still remains <code class="literal">private</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Update</code> function is a Unity native event supported for all classes derived from <code class="literal">MonoBehaviour</code>. <code class="literal">Update</code> is invoked automatically once per frame for all active <code class="literal">GameObjects</code> in the scene. This means that all active game objects are notified about frame change events. In short, <code class="literal">Update</code> is therefore called many times per <a id="id144" class="indexterm"/>second; the game FPS is a general indicator as to how many times each second. The actual number of calls will vary in practice from second to second. In any case, <code class="literal">Update</code> is especially useful to animate, update, and change objects over time. In the case of a <code class="literal">CountDown</code> class, it'll be useful to keep track of time as it passes, second by <a id="id145" class="indexterm"/>second. More information on the <code class="literal">Update</code> function can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html</a>.<div><div><h3 class="title"><a id="note11"/>Note</h3><p>In addition to the <code class="literal">Update</code> function called on each frame, Unity also supports two other related functions, namely, <code class="literal">FixedUpdate</code> and <code class="literal">LateUpdate</code>. <code class="literal">FixedUpdate</code> is used when coding with <strong>Physics</strong>, as we'll see later, and is called a fixed number of times per frame. <code class="literal">LateUpdate</code> is called once per frame for each active object, but the <code class="literal">LateUpdate</code> call will always happen after every object has received an <code class="literal">Update</code> event. Thus, it happens after the <code class="literal">Update</code> cycle, making it a late update. There are reasons for this late update and we'll see them later in the book.</p><p>More information on <code class="literal">FixedUpdate</code> <a id="id146" class="indexterm"/>can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html</a>. More information on the <code class="literal">LateUpdate</code> function can be found in <a id="id147" class="indexterm"/>the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html</a>.</p></div></div></li><li class="listitem" style="list-style-type: disc">When scripting, the static <code class="literal">Time.deltaTime</code> variable is constantly available and updated automatically by Unity. It always describes the amount of time (in seconds) that has passed since the previous frame ended. For example, if your game has a frame rate of 2 FPS (a very low frame rate!) then <code class="literal">deltaTime</code> will be <code class="literal">0.5</code>. This is because, in each second, there would be two frames, and thus each frame would be half a second. The <code class="literal">deltaTime</code> is useful because, if added over time, it tells you how much time in total has elapsed or passed since the game began. For this reason, <code class="literal">deltaTime</code> floating point variable is used heavily in the <code class="literal">Update</code> function for the timer to subtract the elapsed time from the countdown <a id="id148" class="indexterm"/>total. More information can be found on <code class="literal">deltaTime</code> at the online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Time-deltaTime.html">http://docs.unity3d.com/ScriptReference/Time-deltaTime.html</a>.</li><li class="listitem" style="list-style-type: disc">The static <code class="literal">Application.LoadLevel</code> function can be called anywhere in code to change the active scene at runtime. Thus, this function is useful to move the gamer from one level to another. It causes Unity to terminate the active scene, destroying all its contents, and load a new scene. It can also be used to restart the active scene, simply by loading the active level again. <code class="literal">Application.LoadLevel</code> is most appropriate for games with clearly defined levels that are separate from each other and have clearly defined beginnings and <a id="id149" class="indexterm"/>endings. It is not, however, suitable for large open-world games in which large sprawling environments stretch on, seemingly without any breakage or disconnection. More information <a id="id150" class="indexterm"/>on <code class="literal">Application.LoadLevel</code> can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html">http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html</a>.</li></ul></div><p>After the timer script is created, select the <code class="literal">LevelTimer</code> object in the scene. From the <strong>Object Inspector</strong>, you can set the maximum time (in seconds) that the player is allowed in order to complete the level. See <em>Figure 2.28</em>. I've set the total time to <code class="literal">60</code> seconds. This means that all coins must be completed within <code class="literal">60</code> seconds from the level start. If the timer expires, the level is restarted.</p><div><img src="img/figure_02_28.jpg" alt="Code Sample 2.6"/><div><p>Figure 2.28: Setting the level total time</p></div></div><p>Great work! You should now have a completed level with a countdown that works. You can collect coins <a id="id151" class="indexterm"/>and the timer can expire. Overall, the game is taking shape. There is a further problem, however, which we'll address next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Celebrations and fireworks!</h1></div></div></div><p>The coin collection <a id="id152" class="indexterm"/>game is nearly finished. Coins can be collected and <a id="id153" class="indexterm"/>a timer expires, but the win condition itself is not truly handled. That is, when all coins are collected before time expiry, nothing actually happens to show the player that they've won. The countdown still proceeds and even restarts the level as though the win condition hadn't been satisfied at all. Let's fix this now. Specifically, when the win scenario happens, we should delete the timer object to prevent further countdown and show visual feedback to signify that the level has been completed. In this case, I'll add some fireworks! So, let's start by creating the fireworks. You can add these <a id="id154" class="indexterm"/>easily from the Unity 5 <strong>Particle System</strong> packages. Navigate to the <code class="literal">Standard Assets</code> | <code class="literal">ParticleSystems</code> | <code class="literal">Prefabs</code> folder. Then, drag and drop the <code class="literal">Fireworks</code> particle system in <strong>Scene</strong>. Add a second or even a third one if you want.</p><div><img src="img/figure_02_29.jpg" alt="Celebrations and fireworks!"/><div><p>Figure 2.29: Adding two Fireworks prefabs</p></div></div><p>By default, all firework particle systems will play when the level begins. You can test this by pressing play on the toolbar. This is not the behavior that we want. We only want the fireworks to play when the win condition has been satisfied. To disable playback on level startup, select the <strong>Particle System</strong> object in the <strong>Scene</strong> and, from the <strong>Object Inspector</strong>, disable the <strong>Play On Awake</strong> checkbox, which can be found in the <strong>Particle System</strong> component. See <em>Figure 2.30</em>, Disabling <strong>Play On Awake</strong>:</p><div><img src="img/figure_02_30.jpg" alt="Celebrations and fireworks!"/><div><p>Figure 2.30: Disabling Play On Awake</p></div></div><p>Disabling <strong>Play On Awake</strong> prevents particle systems playing automatically at level startup. This is fine, but if they are ever to play at all, something must manually start them at the right time. We can achieve this through code. Before resorting to a coding solution, however, we'll first mark all firework objects with an appropriate tag. The reason for this is that, in code, we'll want to search for all firework objects in the scene and trigger them to play when needed. To isolate the firework objects from all other objects, we'll use tags. So, let's create a new <strong>Fireworks</strong> tag and assign them to the firework objects only in the <strong>Scene</strong>. Tags were created earlier in this chapter when configuring the player character for coin collisions. See <em>Figure 2.31</em>:</p><div><img src="img/figure_02_31.jpg" alt="Celebrations and fireworks!"/><div><p>Figure 2.31: Tagging firework objects</p></div></div><p>With the firework objects now tagged, we can refine the <code class="literal">Coin.cs</code> script class to handle a win condition for the scene, as shown in <em>Code Sample 2.7</em>. Comments follow:</p><div><pre class="programlisting">//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Coin : MonoBehaviour
{
  //-------------------------
  public static int CoinCount = 0;
  //-------------------------
  // Use this for initialization
  void Awake () 
  {
    //Object created, increment coin count
    ++Coin.CoinCount;
  }
  //-------------------------
  void OnTriggerEnter(Collider Col)
  {
    //If player collected coin, then destroy object
    if(Col.CompareTag("Player"))
      Destroy(gameObject);
  }
  //-------------------------
  void OnDestroy()
  {
    --Coin.CoinCount;

    //Check remaining coins
    if(Coin.CoinCount &lt;= 0)
    {
      //Game is won. Collected all coins
      //Destroy Timer and launch fireworks
      <strong>GameObject Timer = GameObject.Find("LevelTimer");</strong>
      <strong>Destroy(Timer);</strong>

      <strong>GameObject[] FireworkSystems = </strong>        <strong>GameObject.FindGameObjectsWithTag("Fireworks");</strong>
      <strong>foreach(GameObject GO in FireworkSystems)</strong>
      <strong>GO.GetComponent&lt;ParticleSystem&gt;().Play();</strong>
    }
  }
  //-------------------------
}
//-------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Code Sample 2.7</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">OnDestroy</code> <a id="id155" class="indexterm"/>function is critical. It occurs when a coin is collected and features an <code class="literal">if</code> statement to determine when all coins are collected (the win scenario).</li><li class="listitem" style="list-style-type: disc">When a win scenario happens, the <code class="literal">GameObject.Find</code> function is called to search the complete scene hierarchy for any active object named <code class="literal">LevelTimer</code>. If found, the object is deleted. This happens to delete the timer and prevent any further countdown when the level is won. If the scene contains multiple objects of a matching name, then only the first object is returned. This is one reason why the scene should contain one and only one timer.<div><div><h3 class="title"><a id="note12"/>Note</h3><p>Avoid using the <code class="literal">GameObject.Find</code> function wherever possible. It's slow for performance. Instead, use <code class="literal">FindGameObjectsWithTag</code>. It's been used here only to demonstrate its existence and purpose. Sometimes, you'll need to use it to find a single, miscellaneous object that has no specific tag.</p></div></div></li><li class="listitem" style="list-style-type: disc">In addition to deleting the <code class="literal">LevelTimer</code> object, the <code class="literal">OnDestroy</code> function finds all firework objects in the scene and initiates them. It finds all objects of a matching tag using the <code class="literal">GameObject.FindGameObjectsWithTag</code> function. This function returns an array of all objects with the <strong>Fireworks</strong> tag and the <code class="literal">ParticleSystem</code> is initiated for each object by calling the <code class="literal">Play</code> function.<div><div><h3 class="title"><a id="note13"/>Note</h3><p>As mentioned, each <code class="literal">GameObject</code> in Unity is really made from a collection of attached <a id="id156" class="indexterm"/>and related components. An object is the sum of its components. For example, a standard cube (created using <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Cube</strong>) is made from a <strong>Transform</strong> component, <strong>Mesh Filter</strong> component, <strong>Mesh Renderer</strong> component, and <strong>Box Collider</strong> component. These components together make the cube what it is and behave how it does.</p><p>The <code class="literal">GetComponent</code> function can be called in script to retrieve a reference to any specified component, giving you direct access to its public properties. The <code class="literal">OnDestroy</code> function in the preceding code uses <code class="literal">GetComponent</code> to retrieve a reference to the <code class="literal">ParticleSystem</code> component attached to the object. <code class="literal">GetComponent</code> is a highly useful and important function. More information on <a id="id157" class="indexterm"/>
<code class="literal">GetComponent</code> can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html">http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html</a>.</p></div></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Play testing</h1></div></div></div><p>You've now <a id="id158" class="indexterm"/>completed your first game in Unity! It's time to take it for a test run and then finally build it. Testing in Unity firstly consists of pressing play on the toolbar and simply playing your game to see that it works as intended from the perspective of a gamer. In addition to playing, you can also enable debugging mode from the <strong>Object Inspector</strong> to keep a watchful eye on all <code class="literal">public</code> and <code class="literal">private</code> variables during runtime, making sure that no variable is assigned an unexpected value. To activate the <strong>Debug</strong> mode, click on the menu icon at the top right corner of the <strong>Object Inspector</strong> and, from the context menu that appears, select the <strong>Debug</strong> option. See <em>Figure 2.32</em>:</p><div><img src="img/figure_02_32.jpg" alt="Play testing"/><div><p>Figure 2.32: Activating Debug mode from the Object Inspector</p></div></div><p>After activating the <a id="id159" class="indexterm"/>
<strong>Debug</strong> mode, the appearance of some variables and components in the <strong>Object Inspector</strong> may change. Typically, you'll get a more detailed and accurate view of your variables, and you'll also be able to see most <code class="literal">private</code> variables. See <em>Figure 2.33</em> for the <strong>Transform</strong> component in <strong>Debug</strong> mode:</p><div><img src="img/figure_02_33.jpg" alt="Play testing"/><div><p>Figure 2.33: Viewing the Transform component in Debug mode</p></div></div><p>Another useful <a id="id160" class="indexterm"/>debugging tool at runtime is the <strong>Stats</strong> panel. This can be accessed from the <strong>Game</strong> tab by clicking on the <strong>Stats</strong> button from the toolbar. See <em>Figure 2.34</em>:</p><div><img src="img/figure_02_34.jpg" alt="Play testing"/><div><p>Figure 2.34: Accessing the Stats panel from the Game tab</p></div></div><p>The <strong>Stats</strong> panel is only useful during the play mode. In this mode, it details the critical performance statistics for your game, such as Frame Rate (FPS) and memory usage. This lets you diagnose or determine whether any problems may be affecting your game. The FPS represents the total <a id="id161" class="indexterm"/>number of frames (ticks or cycles) per second that your game can sustain on average. There is no right, wrong, or magical FPS, but higher values are better than lower ones. Higher values represent better performance because it means that your game can sustain more cycles in one second. If your FPS falls below 20 or 15, it's likely that your game will appear choppy or laggy as the performance weight of each cycle means it takes longer to process. Many variables can affect FPS, some internal and some external to your game. Internal factors include the number of lights in a scene, vertex density of meshes, number of instructions, and complexity of code. Some external factors include the quality of your computer's hardware, number of other applications and processes running at the same time, amount of hard drive space, among others.</p><p>In short, if your FPS is low, then it indicates a problem that needs attention. The solution to that problem varies depending on the context and you'll need to use judgement, for example, are your meshes too complex? Do they have too many vertices? Are your textures too large? Are there too many sounds playing? See <em>Figure 2.35</em> for the coin collection game up and running. The completed game can be found <a id="id162" class="indexterm"/>in the book companion files in the <code class="literal">Chapter02/End</code> folder.</p><div><img src="img/figure_02_35.jpg" alt="Play testing"/><div><p>Figure 2.35: Testing the coin collection game</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Building</h1></div></div></div><p>So now it's time to build the <a id="id163" class="indexterm"/>game! That is, to compile and package the game into a standalone and self-executing form, which the gamer can run and play without needing to use the Unity Editor. Typically, when developing games, you'll reach a decision about your target platform (such as Windows, iOS, Android, and others) during the design phase and not at the end of development. It's often said that Unity is a 'develop once, deploy everywhere tool. This slogan can conjure up the unfortunate image that, after a game is made, it'll work just as effortlessly on every platform supported by Unity as it does on the desktop.</p><p>Unfortunately, things are not so simple; games that work well on desktop systems don't necessarily perform equally well on mobiles and vice versa. This is largely due to the great differences in target hardware and industry standards that hold between them. Due to these differences, I'll focus our attention here to the Windows and Mac desktop platforms, ignoring mobiles and consoles and other platforms. To <a id="id164" class="indexterm"/>create a Build for desktop platform, select <strong>File</strong> | <strong>Build Settings</strong> from the <strong>File</strong> menu:</p><div><img src="img/figure_02_36.jpg" alt="Building"/><div><p>Figure 2.36: Accessing the Build Settings for the project</p></div></div><p>The <strong>Build Settings</strong> dialog is displayed and its interface consists of three main areas. The <strong>Scenes In Build</strong> list is a complete list of all scenes to be included in the build, regardless of whether the gamer will actually visit them in the game. It represents the totality of all scenes that could ever be visited in the game. In short, if you want or need a scene in your game, then it needs to be in <a id="id165" class="indexterm"/>this list. Initially, the list is empty. See <em>Figure 2.37</em>:</p><div><img src="img/figure_02_37.jpg" alt="Building"/><div><p>Figure 2.37: The Build Settings dialog</p></div></div><p>You can easily add scenes to the list by simply dragging and dropping the scene asset from the <strong>Project</strong> panel to the <strong>Scenes In Build</strong> list. For the coin collection game, I'll drag and drop the <code class="literal">Level_01</code> scene to the list. As scenes are added, Unity automatically assigns them a number, depending on their order in the list. <strong>0</strong> represents the topmost item, 1 the next item, and so on. This number is important insofar as the <strong>0</strong> item is concerned. The topmost scene (scene 0) will always be the starting scene. That is, when the build runs, Unity automatically <a id="id166" class="indexterm"/>begins execution from scene 0. Thus, scene 0 will typically be your splash or intro scene. See <em>Figure 2.38</em>, Adding a level to the <strong>Build Settings</strong> dialog:</p><div><img src="img/figure_02_38.jpg" alt="Building"/><div><p>Figure 2.38: Adding a level to the Build Settings dialog</p></div></div><p>Next, be sure to select your target platform from the <strong>Platform</strong> list at the bottom left-hand side of the <strong>Build Settings</strong> dialog. For desktop platforms, choose <strong>PC, Mac &amp; Linux Standalone</strong>, which should be selected by default. Then, from the options, set the <strong>Target Platform</strong> drop-down list to either <strong>Windows</strong>, <strong>Linux</strong>, or <strong>Mac OS X</strong>, depending on your system. See <em>Figure 2.39</em>:</p><div><img src="img/figure_02_39.jpg" alt="Building"/><div><p>Figure 2.39: Choosing a target build platform</p></div></div><p>If you've previously been testing your game for multiple platforms or trying out other platforms such as <strong>Android</strong> and <strong>iOS</strong>, the <strong>Switch Platform</strong> button (at the bottom left of the <strong>Build Settings</strong> dialog) might become active when you select the <strong>Standalone</strong> option. If it does, click on the <strong>Switch </strong>
<a id="id167" class="indexterm"/>
<strong>Platform</strong> button to confirm to Unity that you intend building for the selected platform. On clicking this, Unity may spend a few minutes configuring your assets for the selected platform:</p><div><img src="img/figure_02_40.jpg" alt="Building"/><div><p>Figure 2.40: Switching platforms</p></div></div><p>Before building for the first time, you'll probably want to view the <strong>Player Settings</strong> options to fine-tune <a id="id168" class="indexterm"/>important build parameters, such as game resolution, quality settings, executable icon, and information, among other settings. To access the <strong>Player Settings</strong>, you can simply click on the <strong>Player Settings</strong> button from the <strong>Build</strong> dialog. This displays the <strong>Player Settings</strong> in the <strong>Object Inspector</strong>. The same settings can also be accessed via the application menu by navigating to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Player</strong>. See <em>Figure 2.4</em>:</p><div><img src="img/figure_02_41.jpg" alt="Building"/><div><p>Figure 2.41: Accessing the Player Settings options</p></div></div><p>From the <strong>Player Settings</strong> options, set <strong>Company Name</strong> and <strong>Product Name</strong> as this information is baked and stored within the built executable. You can also specify an icon image for the executable as <a id="id169" class="indexterm"/>well as a default mouse cursor, if one is required. For the collection game, however, these latter two settings will be left empty. See <em>Figure 2.42</em>:</p><div><img src="img/figure_02_42.jpg" alt="Building"/><div><p>Figure 2.42: Setting a publisher name and product name</p></div></div><p>The <strong>Resolution and Presentation</strong> tab is especially important as it specifies the game screen size and whether a default splash screen (<strong>Resolution</strong> dialog) should appear at the application startup. From this tab, ensure that the <strong>Default Is Full Screen</strong> option is enabled, meaning that the <a id="id170" class="indexterm"/>game will run at the complete size of the system's screen as opposed to a smaller and movable window. In addition, enable the <strong>Display Resolution Dialog</strong> drop-down list. See <em>Figure 2.43</em>. When this is enabled, your application will display an options screen at startup, allowing the user to select a target resolution and screen size and customize controls. For a final build, you'll probably want to disable this option, presenting the same settings through your own customized options screen in-game instead. However, for test builds, the <strong>Resolution</strong> dialog can be a great help. It lets you test your build easily at different sizes.</p><div><img src="img/figure_02_43.jpg" alt="Building"/><div><p>Figure 2.43: Enabling the Resolution dialog</p></div></div><p>Now you're ready to make your first compiled build. So, click on the <strong>Build</strong> button from the <strong>Build Settings</strong> dialog or else, choose <strong>File</strong> | <strong>Build &amp; Run</strong> from the application menu. When you do this, Unity presents you with a <strong>Save</strong> dialog, asking you to specify a target location on your computer <a id="id171" class="indexterm"/>where the build should be made. Select a location and choose <strong>Save</strong>, and the build process will be completed. Occasionally, this process can generate errors, which are printed in red in the <strong>Console</strong> window. This can happen, for example, when you save to a read-only drive, have insufficient hard drive space, or don't have the necessary administration privileges on your computer. However, generally, the build process succeeds if your game runs properly in the editor. See <em>Figure 2.44</em>:</p><div><img src="img/figure_02_44.jpg" alt="Building"/><div><p>Figure 2.44: Building and running a game</p></div></div><p>After the <strong>Build</strong> is completed, Unity generates new files at your destination location. For Windows, it generates an <a id="id172" class="indexterm"/>executable file and data folder. See <em>Figure 2.45</em>. Both are essential and interdependent. That is, if you want to distribute your game and have other people play it without needing to install Unity, then you'll need to send users both the executable file and associated data folder and all its contents.</p><div><img src="img/figure_02_45.jpg" alt="Building"/><div><p>Figure 2.45: Unity builds several files</p></div></div><p>On running your game, the <strong>Resolution</strong> dialog will show, assuming that you <strong>Enabled</strong> the <strong>Display Resolution </strong>
<a id="id173" class="indexterm"/>
<strong>Dialog</strong> option from the <strong>Player Settings</strong>. From here, users can select the game resolution, quality, and output monitor and configure player controls:</p><div><img src="img/figure_02_46.jpg" alt="Building"/><div><p>Figure 2.46: Preparing to run your game from the Resolution dialog</p></div></div><p>On clicking the play button, your game will run by default in fullscreen mode. Congratulations! Your <a id="id174" class="indexterm"/>game is now completed and built and you can send it to your friends and family for play testing! See <em>Figure 2.47</em>:</p><div><img src="img/figure_02_47.jpg" alt="Building"/><div><p>Figure 2.47: Running the coin collection game in fullscreen mode</p></div></div><p>But wait! How do you exit your game when you're finished playing? There's no quit button or main menu <a id="id175" class="indexterm"/>option in the game. For Windows, you just need to press <em>Alt</em> + <em>F4</em> on the keyboard. For Mac, you press <em>cmd</em> + <em>Q</em> and for Ubuntu, it's <em>Ctrl</em> + <em>Q</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Summary</h1></div></div></div><p>Excellent work! On reaching this point, you've completed the coin collection game as well as your first game in Unity. On achieving this, you've seen a wide range of Unity features including level editing and design, prefabs, particle systems, meshes, components, script files, and build settings. That's a lot! Of course, there's a lot more to be said and explored for all these areas, but nevertheless, we've pulled them together to make a game. Next, we'll get stuck in with a different game altogether and, in doing this, we'll see a creative reuse of the same features as well as the introduction of completely new features. In short, we're going to move from the world of beginner-level Unity development to intermediate.</p></div></body></html>