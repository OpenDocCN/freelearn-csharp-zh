- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core Web API Common Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have introduced a lot of concepts in the previous chapters, including the
    basics of ASP.NET web API, the RESTful style, Entity Framework, unit testing and
    integration testing, CI/CD, and so on. You should be able to build a simple ASP.NET
    Core web API application by yourself. However, there are still many things that
    we need to learn.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard the phrase “*there is no silver bullet*” before. It means
    that there are often no simple, universal, or one-size-fits-all solutions to solve
    all problems. No matter how powerful the technologies, tools, or frameworks are,
    they are not omnipotent. This is true for ASP.NET Core web API development. However,
    there are some common practices that can help us build a better ASP.NET Core web
    API application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will summarize the common practices of ASP.NET Core web
    API development. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Common practices of ASP.NET Core web API development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance by implementing caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HttpClientFactory to manage HttpClient instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you should be able to expand your knowledge of ASP.NET
    Core web API development and build a better web API application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code example in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Common practices of ASP.NET web API development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce some common practices of ASP.NET web API
    development. Of course, we can’t cover all the common practices in this book.
    However, we will try to cover the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTPS instead of HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we have used HTTP endpoints for simplicity; however,
    in the real world, HTTPS should always be used instead of HTTP. HTTPS is a secure
    version of HTTP, which uses TLS/SSL to encrypt the HTTP traffic, thus preventing
    data from being intercepted or tampered with by a third party. This ensures the
    safety and integrity of the data being transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS is becoming increasingly popular for websites that require secure data
    transmission, such as online banking and online shopping. This trend is reflected
    in the fact that many web browsers, such as Google Chrome, Microsoft Edge, Firefox,
    and so on, now mark HTTP websites as **Not Secure** to encourage users to switch
    to HTTPS. This is a clear indication of the growing trend toward using HTTPS for
    secure data transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default ASP.NET Core web API template uses HTTPS by default. You can find
    the following code in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code redirects all HTTP requests to HTTPS. In the development environment,
    the ASP.NET Core web API application uses a self-signed certificate. When you
    deploy your ASP.NET Core web API application to the production environment, you
    need to use a valid certificate issued by a trusted **certificate authority**
    (**CA**), such as Let’s Encrypt, DigiCert, Comodo, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP status codes correctly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP status codes are used to indicate the status of the HTTP request. There
    are five categories of HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '1xx: Informational'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2xx: Success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3xx: Redirection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4xx: Client errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5xx: Server errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table provides a summary of some of the most commonly used HTTP
    status codes in RESTful web APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `200` | OK |'
  prefs: []
  type: TYPE_TB
- en: '| `201` | Created |'
  prefs: []
  type: TYPE_TB
- en: '| `202` | Accepted |'
  prefs: []
  type: TYPE_TB
- en: '| `204` | No Content |'
  prefs: []
  type: TYPE_TB
- en: '| `301` | Moved Permanently |'
  prefs: []
  type: TYPE_TB
- en: '| `302` | Found |'
  prefs: []
  type: TYPE_TB
- en: '| `304` | Not Modified |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | Bad Request |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | Unauthorized |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | Forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | Not Found |'
  prefs: []
  type: TYPE_TB
- en: '| `405` | Method Not Allowed |'
  prefs: []
  type: TYPE_TB
- en: '| `409` | Conflict |'
  prefs: []
  type: TYPE_TB
- en: '| `410` | Gone |'
  prefs: []
  type: TYPE_TB
- en: '| `415` | Unsupported Media Type |'
  prefs: []
  type: TYPE_TB
- en: '| `422` | Unprocessable Entity |'
  prefs: []
  type: TYPE_TB
- en: '| `429` | Too Many Requests |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | Internal Server Error |'
  prefs: []
  type: TYPE_TB
- en: '| `501` | Not Implemented |'
  prefs: []
  type: TYPE_TB
- en: '| `503` | Service Unavailable |'
  prefs: []
  type: TYPE_TB
- en: '| `504` | Gateway Timeout |'
  prefs: []
  type: TYPE_TB
- en: Table 15.1 – Commonly used HTTP status codes in RESTful web APIs
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the HTTP methods and their corresponding status codes
    for RESTful web APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: The `GET` method is used to retrieve a single resource or a collection
    of resources. A `GET` request should not modify the state of the server. It can
    return the following status codes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200`: The resource is found and returned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404`: The resource is not found. Note that if a collection exists but is empty,
    the `GET` method should return the `200` status code instead of the `404` status
    code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: The `POST` method is used to create a new single resource or a collection
    of resources. It can be also used to update a resource. It can return the following
    status codes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200`: The resource is updated successfully.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201`: The resource is created successfully. The response should include the
    identifier of the newly created resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`202`: The resource is accepted for processing, but the processing is not yet
    complete. This status code is often used for long-running operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400`: The request is invalid.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`409`: The resource already exists.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: The `PUT` method is used to update a single resource or a collection
    of resources. It is rarely used to create resources. It can return the following
    status codes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200`: The resource was updated successfully.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204`: The resource was updated successfully but there is no content to return.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404`: The resource was not found.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: The `DELETE` method is used to delete a single resource with a specific
    identifier. It can be used to delete a collection of resources but it is not a
    common scenario. It can return the following status codes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200`: The resource was deleted successfully and the response includes the
    deleted resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204`: The resource was deleted successfully but there is no content to return.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404`: The resource was not found.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that this list is not exhaustive and only applies to
    RESTful web APIs. When selecting the appropriate HTTP status codes, please consider
    the specific scenarios. For GraphQL APIs, `200` is typically used for most responses,
    with the `errors` field indicating any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ASP.NET Core web API framework is designed to process requests asynchronously,
    so we should use asynchronous programming as much as possible. Asynchronous programming
    allows the application to process multiple tasks concurrently, which can improve
    the performance of the application. For many I/O-bound operations, such as accessing
    the database, sending HTTP requests, and operating files, using asynchronous programming
    can release the thread to process other requests while waiting for the I/O operation
    to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, you can use the `async` and `await` keywords to define and await asynchronous
    operations. Many methods in .NET have synchronous and asynchronous versions. For
    example, the `StreamReader` class has the following synchronous and asynchronous
    methods to read the content of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In these four methods, the methods without the `Async` suffix are synchronous,
    which blocks the thread until the operation is completed. In contrast, the methods
    that have the `Async` suffix are asynchronous, which returns a `Task` object immediately
    and allows the thread to process other requests. When the operation is completed,
    the `Task` object will be completed and the thread will continue to process the
    request. Whenever possible, we should use asynchronous programming to improve
    the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For I/O operations, we should always use asynchronous programming. For example,
    when accessing `HttpRequest` and `HttpResponse` objects, we should use the asynchronous
    methods. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `ReadToEndAsync()` method is used to read the content
    of the request body. For this case, we should not use the synchronous `ReadToEnd()`
    method because it will block the thread until the operation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are multiple asynchronous operations that need to be executed concurrently,
    we can use the `Task.WhenAll()` method to wait for all the asynchronous operations
    to complete. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `Task.WhenAll()` method waits for the `task1` and
    `task2` tasks to complete. If you need to get the results of the tasks after they
    are completed, you can use the `Result` property of the `Task` object to get the
    results. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Result` property of the `task1` and `task2` objects
    is used to get the results of the tasks. As we already used the `await` keyword
    to wait for the tasks to be completed, the `Result` property will return the results
    immediately. But if we don’t use the `await` keyword to wait for the tasks to
    be completed, the `Result` property will block the thread until the tasks are
    completed. So, please be careful when using the `Result` property. Similarly,
    the `Wait()` method of the `Task` object will also block the thread until the
    task is completed. If you want to wait for a task to complete, use the `await`
    keyword instead of the `Wait` method.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Task.WhenAll()` method is not suitable for all scenarios. For
    example, EF Core does not support running multiple queries in parallel on the
    same database context. If you need to execute multiple queries on the same database
    context, you should use the `await` keyword to wait for the previous query to
    complete before executing the next query.
  prefs: []
  type: TYPE_NORMAL
- en: 'When utilizing asynchronous programming, there are several important considerations
    to keep in mind. These include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not use `async void` in ASP.NET Core. The only scenario where `async void`
    is allowed is in event handlers. If an async method returns `void`, the exceptions
    thrown in the method will not be caught by the caller properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not mix synchronous and asynchronous methods in the same method. Try to use
    async for the entire process if possible. This allows the entire call stack to
    be asynchronous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to use the `Result` property of the `Task` object, make sure that
    the `Task` object is completed. Otherwise, the `Result` property will block the
    thread until the `Task` object is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have a method that only returns the result of another async method,
    there’s no need to use the `async` keyword. Just return the `Task` object directly.
    For example, the following code is unnecessary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code does not use the `async`/`await` keywords, which is better:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because the `async` keyword will create a state machine to manage the
    execution of the async method. In this case, it is unnecessary. Returning the
    `Task` directly does not create additional overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Using pagination for large collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not recommended to return a large collection of resources in a single
    response, as this can lead to performance issues. Such issues may include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The server may require a significant amount of time to query the database and
    process the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response payload may be quite large, resulting in network congestion. This
    can negatively impact the performance of the system, leading to increased latency
    and decreased throughput.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client may require additional time and resources to process the large response.
    Deserializing a large JSON object can be computationally expensive for the client.
    Also, rendering a large collection of items on the UI may cause the client to
    become unresponsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to efficiently manage large collections, it is recommended to use
    pagination. [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198) introduces pagination
    and filtering through the use of the `Skip()` and `Take()` methods of the `IQueryable`
    interface. Also, we mentioned that the `AsNoTracking()` method should be used
    to improve the performance of the read-only queries. This will result in a collection
    of resources being returned to the client. However, the client may not be aware
    of whether there are more resources available. To address this issue, we can create
    a custom class to represent the paginated response. An example of this is provided
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `PaginatedList<T>` class contains a couple of properties
    to represent the pagination information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PageIndex`: The current page index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PageSize`: The page size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalPages`: The total number of pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Items`: The collection of items on the current page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HasPreviousPage`: Indicates whether there is a previous page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HasNextPage`: Indicates whether there is a next page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we can use this class in the controller for pagination. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, besides the `Items` property, the `PaginatedList<T>`
    class also contains the pagination information, such as `PageIndex`, `PageSize`,
    `TotalPages`, `HasPreviousPage`, `HasNextPage`, and so on. The response of the
    endpoint will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the clients can implement pagination easily. You can also include
    more information in the `PaginatedList<T>` class, such as the links to the previous
    page and the next page, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing pagination, it is important to consider sorting and filtering.
    Generally, the data should be filtered first, followed by sorting and then pagination.
    For example, the following LINQ query can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Where()` method should be used to filter the data first in order to reduce
    the amount of data to be sorted. This is important, as sorting is often an expensive
    operation. Once the data has been filtered, the `OrderBy()` method can be used
    to sort it. Finally, the `Skip()` and `Take()` methods can be used to paginate
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the response types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An ASP.NET Core web API endpoint can return various types of responses, such
    as `ActionResult`, `ActionResult<T>`, or a specific type of the object. For example,
    the following code returns a `Post` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works, but what if the `post` cannot be found? It is recommended
    to use `ActionResult<T>` instead of the specific type of the object. The `ActionResult<T>`
    class is a generic class that can be used to return various HTTP status codes.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `ActionResult<Post>` class is used to return a `Post`
    object. If the `post` cannot be found, the `NotFound` method is used to return
    the `404 Not Found` status code. If the `post` is found, the `Ok` method is used
    to return the `200 OK` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the `[ProducesResponseType]` attribute to specify the response types
    of the endpoint. Here is a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, there are two `[ProducesResponseType]` attributes. The
    first one specifies the `200 OK` status code and the second one specifies the
    `404 Not Found` status code. The `[ProducesResponseType]` attribute is optional,
    but it is recommended to use it to specify the response types of the endpoint.
    The Swagger UI will use the `[ProducesResponseType]` attribute to generate the
    response types of the endpoint, as shown in *Figure 15**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to
    generate the response types of the endpoint](img/B18971_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to generate
    the response types of the endpoint
  prefs: []
  type: TYPE_NORMAL
- en: We can see there are possible responses in the Swagger UI. This endpoint can
    return the `200 OK` status code or the `404 Not Found` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce the use of the `[ProducesResponseType]` attribute, we can use the
    `OpenAPIAnalyzers`. This analyzer can be used to report the missing `[ProducesResponseType]`
    attribute. Add the following code in the `<PropertyGroup>` section of the `*.``csproj`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see the warning in Visual Studio if the controller action does
    not have the `[ProducesResponseType]` attribute, as shown in *Figure 15**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Visual Studio displays the warning if the controller action
    does not have the [ProducesResponseType] attribute](img/B18971_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Visual Studio displays the warning if the controller action does
    not have the [ProducesResponseType] attribute
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will provide you with a quick fix to add these attributes. This
    analyzer is very useful and it is recommended to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments to the endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding XML comments to the endpoints can help other developers understand them
    better. These comments will be displayed in the Swagger UI, providing a comprehensive
    description of the endpoints. This can be a great resource for developers to use
    when working with the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding XML comments to the endpoints is very simple. We just need to add the
    `///` comments to them. Visual Studio will automatically generate the XML comments
    structure when you type `///`. You need to add the description of the method,
    the parameters, the return value, and so on. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add comments to the model classes. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to enable the XML documentation file generation in the project
    file. Open the `*.csproj` file and add the following code in the `<``PropertyGroup>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `GenerateDocumentationFile` property specifies whether an XML documentation
    file should be generated. The `NoWarn` property can be used to suppress specific
    warnings, such as the `1591` warning code, which is associated with missing XML
    comments. Suppressing this warning is beneficial, as it prevents the warning from
    appearing when the project is built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure the Swagger UI to use the XML documentation file.
    Open the `Program.cs` file and update the `builder.Services.AddSwaggerGen()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `IncludeXmlComments` method is used to specify the
    XML documentation file. We can use reflection `{Assembly.GetExecutingAssembly().GetName().Name}.xml`,
    to get the name of the XML documentation file. The `AppContext.BaseDirectory`
    property is used to get the base directory of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the comments in the Swagger UI, run the application and open the Swagger
    UI. As shown in *Figure 15**.3*, the comments will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – The Swagger UI displays the comments of the endpoints](img/B18971_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – The Swagger UI displays the comments of the endpoints
  prefs: []
  type: TYPE_NORMAL
- en: 'The model classes are also described in the Swagger UI, as shown in *Figure
    15**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The Swagger UI displays the comments of the model classes](img/B18971_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – The Swagger UI displays the comments of the model classes
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the comments in the Swagger UI is a great way to provide developer-friendly
    API documentation. It is highly recommended to add comments to the endpoints and
    model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using System.Text.Json instead of Newtonsoft.Json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Newtonsoft.Json` is a popular JSON library for .NET and is widely used in
    many projects. It was created as a personal project by James Newton-King in 2006
    and has since become the number one library on NuGet, with over one billion downloads.
    An interesting fact is that in 2022, the downloads of `Newtonsoft.Json` on NuGet
    reached an impressive 2.1 billion, surpassing the `Int32.MaxValue` of 2,147,483,647\.
    This milestone necessitated a change to NuGet to support the continued downloads
    of `Newtonsoft.Json`.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has introduced a new JSON library, `System.Text.Json`, with the release
    of .NET Core 3.0\. This library was designed to be high performing by utilizing
    `Span<T>`, which provides a type-safe and memory-safe representation of contiguous
    regions of arbitrary memory. Using `Span<T>` can reduce memory allocation and
    improve the performance of .NET code. `System.Text.Json` is included in the .NET
    Core SDK and is actively being developed. Although it may not have all the features
    of `Newtonsoft.Json`, it is a great choice for new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest ASP.NET web API template uses `System.Text.Json` by default. It
    provides a simple way to serialize and deserialize JSON data. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you still want to use `Newtonsoft.Json`, you can install the `Microsoft.AspNetCore.Mvc.NewtonsoftJson`
    NuGet package and update the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can update the `options` object to configure the `Newtonsoft.Json` library.
    Again, it is recommended to use `System.Text.Json` instead of `Newtonsoft.Json`
    unless you need some specific features of `Newtonsoft.Json` because `System.Text.Json`
    has better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance by implementing caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is a common technique used to improve the performance of the application.
    In web API development, caching can store frequently accessed data in a temporary
    storage, such as memory or disk, to reduce the number of database queries and
    improve the responsiveness of the application. In this section, we will introduce
    the caching in ASP.NET Core web API development.
  prefs: []
  type: TYPE_NORMAL
- en: Caching is an effective tool when handling data that is not regularly updated
    but is costly to compute or obtain from the database. It is also useful when multiple
    clients access the same data frequently. As an example, consider an e-commerce
    application that displays a list of categories. The categories of the products
    are not often changed, yet they are frequently viewed by users. To improve the
    performance of the application, we can cache the categories. When a user requests
    the categories, the application can return the cached data directly without querying
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core, we have several options for implementing caching, each suited
    to a specific scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-memory caching**: This type of caching stores data in the memory of the
    application. It is fast and efficient and is suitable for scenarios where the
    data does not need to be shared across multiple instances of the application.
    However, the data will be lost when the application is restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed caching**: This type of caching involves storing cached data
    in a shared storage, such as Redis or SQL Server, which can be accessed by multiple
    instances of the application. It is suitable for applications that are deployed
    with multiple instances, such as a web farm, container orchestration, or serverless
    computing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response caching**: This caching technique is based on the HTTP caching mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will introduce the in-memory caching and distributed
    caching in ASP.NET Core web API development, as well as the output caching, which
    is introduced in ASP.NET Core 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In-memory caching is a fast and easy way to store data in an application’s memory.
    ASP.NET Core provides the `IMemoryCache` interface to facilitate this process.
    This type of caching is highly versatile, as it can store any type of data in
    the form of a key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: The example project in this section can be found in the `chapter15/CachingDemo`
    folder. This is a simple ASP.NET Core web API application. It contains a `/categories`
    endpoint that returns the categories of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the example, we use a static list to store the categories to simulate
    a database. When the application queries the categories, it will print a log to
    indicate that the categories are queried from the database. Here is the code in
    the `CategoryService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use a `Task.Delay()` method to simulate a database
    query. This query takes two seconds to complete, which is slow. As the categories
    are not often changed, we can use in-memory caching to improve the performance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use in-memory caching, we need to add the `Microsoft.Extensions.Caching.Memory`
    NuGet package by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to register the in-memory caching in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `IMemoryCache` interface in other classes. Inject the
    `IMemoryCache` interface into the `CategoryService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `GetCategoriesAsync` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the updated code, we first try to get the categories from the cache by the
    cache key. If the categories are found in the cache, we return them directly.
    Otherwise, we query the database and cache the categories for 10 minutes. The
    `SetAbsoluteExpiration()` method is used to set the absolute expiration time of
    the cache entry. After 10 minutes, the cache entry will be removed from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send a request to the `/categories` endpoint. The first
    request will take 2 seconds to complete, and then the subsequent requests will
    be completed immediately. You may see the following log in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this way, in-memory caching can significantly improve the performance of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the cache does not become bloated with outdated entries, the
    cache must apply a proper expiration policy. The cache has several options for
    expiration, two of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute expiration**: The cache entry will be removed from the cache after
    a specified time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sliding expiration**: The cache entry will be removed after a predetermined
    period of time if it is not accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using `SlidingExpiration`, the cache can be retained indefinitely if it
    is accessed frequently. To avoid this, we can set the `AbsoluteExpiration` property
    or `AbsoluteExpirationRelativeToNow` property to limit the maximum lifetime of
    the cache entry. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `SlidingExpiration` property is set to 10 minutes,
    and the `AbsoluteExpirationRelativeToNow` property is set to 30 minutes. This
    means that the cache entry will be removed from the cache after 30 minutes, even
    if it is frequently accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we may need to manually update the cache entry. For example, when
    a new category is created, or an existing category is updated or deleted, we can
    remove the cache entry to force the application to query the database again and
    refresh the cache entry. Move the preceding code to a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding code, we should query the database first, then remove
    the cache entry and reset it. Otherwise, the application may query the database
    multiple times if the cache entry is removed before the database query is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can call the `RefreshCategoriesCache()` method when a new category
    is created or an existing category is updated or deleted. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can create a background task to update the cache entry periodically.
    A background task is a task that runs behind the scenes without user interaction.
    It is useful for performing tasks that are not time-sensitive, such as updating
    the cache entry. To create a background task, we can use the `BackgroundService`
    class. Create a new class named `CategoriesCacheBackgroundService` that inherits
    from the `BackgroundService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use a `while` loop to reset the cache entry every
    one hour. Note that you cannot inject the `ICategoryService` directly because
    the `BackgroundService` class will be registered as a singleton service, but the
    `ICategoryService` is registered as a scoped service. A singleton service cannot
    depend on a scoped service. To solve this problem, we need to use the `IServiceProvider`
    interface to create a scope and get the `ICategoryService` from the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, register the `CacheBackgroundService` class in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When the background task is executed every one hour, the cache entry will be
    removed from the cache. The background task should first query the database and
    then remove the cache entry and reset it. If the cache entry is deleted first,
    the application may query the database multiple times, resulting in performance
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing caching, it is important to consider scenarios where records
    cannot be found in the database. Let us see how it happens. Update the `GetCategoryAsync()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, if the category cannot be found in the cache, we query
    the database and cache the category. But there is a potential issue here. What
    if the category with the specified ID does not exist? In this case, the application
    will not set the cache and each request will query the database. Cache is not
    used at all. To solve this problem, we can use the `GetOrCreateAsync` method of
    the `IMemoryCache` interface. Here is the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The updated code uses the `GetOrCreateAsync` method to retrieve the category
    from the cache. If the category is not present, the method will execute the specified
    delegate to fetch it from the database. Upon successful retrieval, the category
    will be cached and returned. If the category is not found, `null` will be returned.
    So, the application will not query the database every time. To avoid the issue
    mentioned earlier, it is recommended to use the `GetOrCreateAsync` method to obtain
    the data from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more important considerations when using in-memory caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consider the expiration time of the cache entry*. If the data is not often
    changed, we can set a longer expiration time. Otherwise, use a shorter expiration
    time. Also, you can use the `SlidingExpiration` property and the absolute expiration
    time to achieve a balance between the performance and the freshness of the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The in-memory cache can cache any object, but be careful when caching large
    objects*. It is important to limit the size of the cache entry. We can use `SetSize`,
    `Size`, and `SizeLimit` to limit the size of the cache. Note that when using these
    methods, the in-memory cache must be registered as a singleton service. Please
    refer to the documentation for more information at [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Define proper cache keys*. The cache keys should be unique and descriptive.
    Especially, when using caching for users, ensure that the cache keys are unique
    for each user. Otherwise, the cached data of one user may be used by another user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Provide a way to fall back to the data source when the cache is* *not available*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no hard rules for these settings. You need to consider the specific
    scenarios and adjust the settings accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory caching is a simple and effective way to improve the performance of
    the application. However, it is not suitable for applications that are deployed
    with multiple instances. The cached data only works for the current instance.
    When a client requests the data from another instance, the cached data in the
    original instance will not be used. To solve this problem, one solution is to
    implement session affinity, which means the request from a user will always be
    routed to the same instance. This can be achieved by using a load balancer that
    supports session affinity, such as Nginx, Azure Application Gateway, and so on.
    This is out of the scope of this book. Please refer to the documentation of the
    load balancer for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to this issue is to implement a distributed cache, as outlined
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Distributed caching offloads the cache from the application to a shared storage,
    such as Redis or SQL Server. The data stored in the distributed cache can be accessed
    by multiple instances of the application. If the application restarts, the cached
    data will not be lost. There is no need to implement session affinity when using
    distributed caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several options to implement distributed caching in ASP.NET Core.
    The following are the most commonly used options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis**: Redis is an open-source, in-memory data structure store. It has
    many features, such as caching, pub/sub, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Server**: SQL Server can be also used as a distributed cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Cache for Redis**: Azure Cache for Redis is a fully managed, open-source,
    in-memory data structure store. It is based on the popular open-source Redis cache.
    You can use a local Redis server for development and testing and use Azure Cache
    for Redis in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://github.com/Alachisoft/NCache`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will introduce the Redis cache using the same sample project
    as the previous section. We use a static `Dictionary<int, List<Category>>` to
    store the users’ favorites categories, which simulates the data stored in the
    database. When a user requests the favorites categories, the application will
    use the user ID as the key to query the database. If we use in-memory caching,
    the caching key should include the user ID, such as `1_Favorites_Categories`.
    However, if this user’s subsequent requests are routed to another instance, there
    is no way to get the cached data. That is why we need to use the distributed caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to prepare a Redis server. We can use the Docker to run a Redis
    server. Start Docker Desktop on your machine and run the following command to
    pull the Redis image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The Redis server will be listening on port `6379`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the Redis server in the terminal, we need to use the `redis-cli`
    command. This command is included in the Redis image. Run the following command
    to access the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker exec` command is used to execute a command in a running container.
    The `-it` option is used to run the command interactively. It means we want to
    execute the `redis-cli` command in the container. You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we have successfully accessed the Redis server. Now we can use the
    `redis-cli` command to access the Redis server. For example, we can use the `set`
    command to set the value of a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the `get` command to get the value of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You will see `Hello World` in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the Redis server is ready to use. To use the Redis cache in ASP.NET Core,
    we need to install the `Microsoft.Extensions.Caching.StackExchangeRedis` NuGet
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to register the Redis cache in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `AddStackExchangeRedisCache` extension method is
    used to register the Redis cache. We specify the Redis server address and an optional
    instance name, which is used to create a logical partition for the cache. Note
    that these configurations can be defined in the `appsettings.json` file or environment
    variables, allowing for different Redis instances to be used for development and
    production purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can use the `IDistributedCache` interface to operate the Redis cache.
    Inject the `IDistributedCache` interface into the `CategoryService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first try to get the favorites categories from the
    cache using the cache key. If the favorites categories are found in the distributed
    cache, we return the cached data directly. Otherwise, we query the database and
    store the result in the distributed cache.
  prefs: []
  type: TYPE_NORMAL
- en: As the Redis cache stores the data as `byte[]`, to store the cached data, we
    need to serialize the data into a JSON string and then convert the JSON string
    into a `byte[]` value using the `Encoding.UTF8.GetBytes()` method. Similarly,
    when getting the cached data, we need to convert the `byte[]` value to a JSON
    string using the `Encoding.UTF8.GetString()` method and then deserialize the JSON
    string into the strongly-typed object using the `JsonSerializer.Deserialize()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the caching key must be a `string` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to convert the data to and from `byte[]`, the `IDistributedCache`
    interface has a few extension methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetStringAsync` and `SetString`: These two methods can save `string` values
    directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetStringAsync` and `GetString`: These two methods can read `string` values
    directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remove a cache entry, we can use the `RemoveAsync()` method or `Remove()`
    method. As we mentioned before, using the asynchronous versions of these methods
    is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send some requests to the `Categories/favorites/1`
    endpoint. You will see that the logs show the first response was from the database
    and the subsequent responses were from the distributed cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `redis-cli` to examine the cached data. Run the following command
    to get the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `HGETALL` command to show the cached data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that you cannot use the `GET` command here because it is used to retrieve
    the string values only. The categories data is stored as `hash` in Redis, so we
    need to use the `HGETALL` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look as follows, including all the fields of the cached entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using a distributed cache can help make applications more scalable by allowing
    cached data to be shared across multiple instances. However, this does come with
    the potential cost of increased latency due to the extra network I/O required.
    Careful consideration should be taken when deciding whether to use a distributed
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IDistributedCache` interface does not have the `GetOrCreateAsync()` method.
    If the cached data is not found, the application still needs to query the database.
    To solve this problem, we can implement our own `GetOrCreateAsync()` method. Create
    an extension method for the `IDistributedCache` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `GetFavoritesCategoriesAsync` method can be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the category is not found in the database, the `GetOrCreateAsync()` method
    will return `null` and cache the `null` value for future requests. In this way,
    the application will not query the database again and again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the differences between in-memory caching and distributed
    caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **In-memory caching** | **Distributed caching** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Cache data in the memory of the application | Cache data in a shared storage
    |'
  prefs: []
  type: TYPE_TB
- en: '| Suitable for applications that are deployed with a single instance | Suitable
    for applications that are deployed with multiple instances |'
  prefs: []
  type: TYPE_TB
- en: '| The cached data is lost when the application restarts | The cached data is
    not lost when the application restarts |'
  prefs: []
  type: TYPE_TB
- en: '| The caching keys can be any `object` | The caching keys must be `string`
    |'
  prefs: []
  type: TYPE_TB
- en: '| The cached data value can be any strongly-typed object | The cached data
    is persisted as `byte[]` and may need serialization and deserialization. |'
  prefs: []
  type: TYPE_TB
- en: Table 15.2 – The differences between in-memory caching and distributed caching
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to use other distributed cache, you can install other packages
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet add` `package Microsoft.Extensions.Caching.SqlServer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet add` `package NCache.Microsoft.Extensions.Caching.OpenSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to their official documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Response caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Response caching is defined in the RFC 9111 specification ([https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111)).
    It uses the HTTP header `cache-control` to specify the caching behavior. The clients
    (such as browsers) and immediate proxies (such as CDNs and gateways), can use
    the `cache-control` header to determine whether to cache the response and how
    long to cache it for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cache-control` header has several directives as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: The response can be cached by the clients and the intermediate proxies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: The response can be cached by the clients only. A shared cache,
    such as CDN, must not cache the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-cache`: For requests, the clients must send the request to the server for
    validation before using a cached copy of the response. For responses, the clients
    must not use a cached copy of the response without successful validation on the
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-store`: For requests, the clients must not store any part of the request.
    For responses, the clients must not store any part of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-age`: This is the maximum age of the response in seconds. The clients
    can use the cached copy of the response if it is not expired. For example, `max-age=3600`
    means the response can be cached for one hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `ResponseCache` attribute to specify the caching behavior of
    the endpoint. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `ResponseCache` attribute on the controller
    to specify the caching behavior of the endpoint. `Duration = 60` means the response
    can be cached for 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and test the `/Categories` endpoint in the Swagger UI.
    You will see the `cache-control` header in the response, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you resubmit the request, the browser will use the cached version of the
    response without sending the request to the server. This is managed by the `max-age`
    directive in the `cache-control` header. After 60 seconds have elapsed, the browser
    will send the request to the server for validation if the request is resubmitted.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP-based response caching takes effect on the client side. If multiple
    clients send requests to the same endpoint, each request will cause the server
    to handle the request and generate the response. ASP.NET Core provides a server-side
    response caching middleware to cache the response on the server side. However,
    this middleware has a few limitations.
  prefs: []
  type: TYPE_NORMAL
- en: It only supports the `GET` and `HEAD` requests and it does not support requests
    that contain the `Authorization`, `Set-Cookie` headers, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot invalidate the client-side cached response on the server side when
    the data is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, most browsers, such as Chrome and Edge, automatically send requests
    with the `cache-control: max-age=0` header, which disables response caching on
    the client side. As a result, the server will also respect this header and disable
    server-side response caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book does not cover the middleware mentioned; for more information, please
    refer to the documentation at [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware).
    We will, however, introduce output caching, which is available in ASP.NET Core
    7.0 and later versions. This middleware resolves some of the limitations of the
    server-side response caching middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Output caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ASP.NET Core 7.0, Microsoft introduced the output caching middleware. This
    middleware works in a similar way to the server-side response caching middleware,
    but it has a few advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It configures the caching behavior on the server side, so the client HTTP caching
    configuration does not affect the output caching configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the capability to invalidate the cached response on the server side when
    the data is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use external cache stores, such as Redis, to store the cached response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can return a `304 Not Modified` response to the client when the cached response
    is not modified. This can save the network bandwidth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the output caching middleware also has similar limitations to the
    response caching middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: It only supports `GET` and `HEAD` requests with the `200 OK` status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not support `Authorization` and `Set-Cookie` headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable output caching, we need to register the output caching middleware
    in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add the middleware to the HTTP request pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, apply the `OutputCache` attribute to the endpoints that need to be cached.
    For example, we can apply the `OutputCache` attribute to the `/``categories/{id}`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetOrCreateAsync()` method is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we use a `Task.Delay()` method to simulate the database query. Run
    the application and test the `/categories/1` endpoint in the Swagger UI. You will
    see that the console log shows that the first response was from the database.
    The headers of the response look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the request again. You will not see the database query log in the console.
    The headers of the response look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can find that the headers of the response contain the `age` header, which
    indicates that the response is cached. The `age` header is the number of seconds
    since the response was generated.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the expiration time of the cached response is 60 seconds. After
    60 seconds have elapsed, the next request will query the database again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define different caching policies for different endpoints. Update the
    `AddOutputCache()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added two caching policies. The first `Expire600`
    policy will expire the cached response after 10 minutes, and the second one will
    expire the cached response after 1 hour. Then, we can apply the `OutputCache`
    attribute to the endpoints as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, the cached response will expire in 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: What caching strategy should I use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caching is a useful tool for improving the performance of applications. In this
    section, we introduced a couple of caching techniques, including in-memory caching,
    distributed caching, response caching, and output caching. Each caching technique
    has its suitable scenarios. We need to choose the proper caching technique based
    on the specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Response caching is relatively straightforward to implement; however, it is
    dependent on the client-side HTTP caching configuration. If the client-side HTTP
    caching is disabled, response caching will not work as intended. Output caching
    is more flexible and can be used independently of the client-side HTTP caching
    configuration. It does not need much effort to implement, but it has a few limitations.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory caching is a fast and easy way to cache data in a single instance
    of the application. However, it needs session affinity to work properly if there
    are multiple instances of the application. Distributed caching supports multiple
    instances, but it needs extra network I/O to access the cache. So, we need to
    consider the trade-off between the performance and the scalability. If retrieving
    the data from the database is complex or needs expensive computation and the data
    is not often changed, we can use distributed caching to reduce the load on the
    database or the computation. Additionally, we can use in-memory caching and distributed
    caching together to leverage the advantages of both caching techniques. For example,
    we can query the data from the in-memory cache first, and if the data is not found,
    we can then query the distributed cache. Also, consider the expiration time of
    the cache entry. You may need various expiration policies for different data.
  prefs: []
  type: TYPE_NORMAL
- en: "This section only introduces the basic concepts of caching in ASP.NET Core.\
    \ To learn more about caching, please refer to the documentation at [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/](https://docs.microsoft.com/en-us/aspnet/core/p\uFEFF\
    erformance/caching/)."
  prefs: []
  type: TYPE_NORMAL
- en: Using HttpClientFactory to manage HttpClient instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET provides the `HttpClient` class for sending HTTP requests. However, there
    is some confusion when using it. In the past, many developers would misuse the
    `using` statement to create a `HttpClient` instance, as it implements the `IDisposal`
    interface. This is not recommended, as the `HttpClient` class is designed to be
    reused for multiple requests. Creating a new instance for each request can exhaust
    the local socket ports.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, Microsoft introduced the `IHttpClientFactory` interface
    in ASP.NET Core 2.1\. This interface simplifies the management of `HttpClient`
    instances. It allows us to use dependency injection to inject `HttpClient` instances
    into the application without worrying about the life cycle of the `HttpClient`
    instances. In this section, we will introduce how to use the `IHttpClientFactory`
    interface to manage `HttpClient` instances.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample application for this section in the `samples/chapter15/HttpClientDemo`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use the `IHttpClientFactory` interface, we need to have
    a web API application as the backend service. You can use any sample applications
    we have created in the previous chapters. In this section, we will use a fake
    API service: `https://jsonplaceholder.typicode.com/`. This is a free online REST
    API service that can be used for testing and prototyping. It provides a set of
    endpoints, such as `/posts`, `/comments`, `/albums`, `/photos`, `/todos`, and
    `/users`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When you create C# models from JSON data, you can use the **Paste JSON as Classes**
    feature in Visual Studio. You can find this feature in the **Edit** | **Paste**
    **Special** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic HttpClient instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `IHttpClientFactory` interface provides an `AddHttpClient()` extension
    method to register the `HttpClient` instances. Add the following code in the `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can inject the `IHttpClientFactory` interface into the controller
    and use it to create a `HttpClient` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `CreateClient()` method to create a `HttpClient`
    instance. Then, we create an `HttpRequestMessage` instance and use the `SendAsync()`
    method to send the HTTP request. The `EnsureSuccessStatusCode()` method is used
    to ensure the response is successful. If the response fails, an exception will
    be thrown. The `ReadAsStringAsync()` method is used to read the response content
    as a string. Finally, we use the `JsonSerializerHelper` class to deserialize the
    JSON string into a list of `Post` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JsonSerializerHelper` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is because the JSON data returned by the API uses the camel case naming
    convention. We need to use the `JsonNamingPolicy.CamelCase` property to deserialize
    the JSON string into the strongly-typed object. We can pass a `JsonSerializerOptions`
    instance to the `JsonSerializer.Serialize()` and `JsonSerializer.Deserialize()`
    methods to specify the serialization and deserialization options. Using a helper
    method can simplify the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HttpRequestMessage` class is a low-level class that represents an HTTP
    request message. In most cases, we can use the `GetStringAsync()` method to send
    a `GET` request and get the response content as a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to send a `POST` request is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: To send a `POST` request, we need to serialize the `Post` object to a JSON string
    and then convert the JSON string into a `StringContent` instance. Then, we can
    use the `PostAsync()` method to send the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StringContent` class is a concrete implementation of the `HttpContent`
    class. The `HttpContent` class is an abstract class that represents the content
    of an HTTP message. It has the following concrete implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByteArrayContent`: Represents an `HttpContent` instance based on a byte array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormUrlEncodedContent`: Represents a collection of name/value pairs encoded
    using `application/x-www-form-urlencoded` MIME type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultipartContent`: Represents a collection of `HttpContent` instances serialized
    using `multipart/*` MIME type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamContent`: Represents an `HttpContent` instance based on a stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringContent`: Represents an `HttpContent` instance based on a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `HttpClient` class has a few methods and extension methods to send HTTP
    requests. The following table shows the commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SendAsync()` | Sends an HTTP request to the specified URI. This method can
    send any HTTP request. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetAsync()` | Sends a `GET` request to the specified URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetStringAsync()` | Sends a `GET` request to the specified URI. This method
    returns the response body as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetByteArrayAsync()` | Sends a `GET` request to the specified URI. This
    method returns the response body as a byte array. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetStreamAsync()` | Sends a `GET` request to the specified URI. This method
    returns the response body as a stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetFromJsonAsync<T>()` | Sends a `GET` request to the specified URI. This
    method returns the response body as a strongly-typed object. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetFromJsonAsAsyncEnumerable<T>()` | Sends a `GET` request to the specified
    URI. This method returns the response body as an `IAsyncEnumerable<T>` instance.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PostAsync()` | Sends a `POST` request to the specified URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `PostAsJsonAsync()` | Sends a `POST` request to the specified URI. The request
    body is serialized as JSON. |'
  prefs: []
  type: TYPE_TB
- en: '| `PutAsync()` | Sends a `PUT` request to the specified URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `PutAsJsonAsync()` | Sends a `PUT` request to the specified URI. The request
    body is serialized as JSON. |'
  prefs: []
  type: TYPE_TB
- en: '| `DeleteAsync()` | Sends a `DELETE` request to the specified URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `DeleteFromJsonAsync<T>()` | Sends a `DELETE` request to the specified URI.
    This method returns the response body as a strongly-typed object. |'
  prefs: []
  type: TYPE_TB
- en: '| `PatchAsync()` | Sends a `PATCH` request to the specified URI. |'
  prefs: []
  type: TYPE_TB
- en: Table 15.3 – The commonly used methods of the HttpClient class
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `HttpClient` instance created by the `IHttpClientFactory` interface,
    we need to specify the request URL. We can set the base address of the `HttpClient`
    instance when registering the `HttpClient` instance. Update the `AddHttpClient()`
    method in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Then, we do not need to specify the base address when sending the HTTP request.
    However, what if we need to send requests to multiple endpoints with different
    base addresses? Let us see how to solve this problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Named HttpClient instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is tedious to specify the base address of the `HttpClient` instance or the
    request URI every time. We can specify some common settings when registering the
    `HttpClient` instance. For example, we can specify the base address of the `HttpClient`
    instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we register the `HttpClient` instance with the name
    `JsonPlaceholder` and specify the base address of the `HttpClient` instance. We
    can also set the default request headers, such as the `Accept` and `User-Agent`
    headers. Then, we can use the `JsonPlaceholder` name to inject the `HttpClient`
    instance into the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is called named `HttpClient` instances, which allows us to register multiple
    `HttpClient` instances with different names. This is useful when we need multiple
    `HttpClient` instances with different configurations. By using the name, we can
    easily access the desired instance.
  prefs: []
  type: TYPE_NORMAL
- en: Typed HttpClient instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better encapsulate the `HttpClient` instances, we can create a typed `HttpClient`
    instance for a specific type. For example, we can create a typed `HttpClient`
    instance for the `User` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `UserService` class to encapsulate the `HttpClient`
    instance. Register the `UserService` class in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can inject the `UserService` class into the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the controller does not need to know the details of the
    `HttpClient` instance. It only needs to call the methods of the `UserService`
    class. The code is much cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: "The `IHttpClientFactory` interface is the recommended way to manage `HttpClient`\
    \ instances. It saves us from the tedious work of managing the lifetime of the\
    \ `HttpClient` instances. It also allows us to configure the `HttpClient` instances\
    \ in a centralized place. For more information, please refer to the documentation\
    \ at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requ\uFEFF\
    ests)."
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed common practices in ASP.NET Core web API development,
    such as HTTP status codes, asynchronous programming, pagination, response types,
    and API documentation. We also explored several caching techniques, including
    in-memory caching, distributed caching, response caching, and output caching.
    Each technique has its own advantages and disadvantages, so it is important to
    consider the trade-offs and choose the appropriate caching strategy for the given
    scenario. Additionally, we discussed the `IHttpClientFactory` interface, which
    simplifies the management of `HttpClient` instances and allows us to use dependency
    injection to inject `HttpClient` instances into the application without worrying
    about their life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to handle errors in ASP.NET Core web
    API applications and how to monitor the applications using OpenTelemetry.
  prefs: []
  type: TYPE_NORMAL
