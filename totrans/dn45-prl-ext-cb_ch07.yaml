- en: Chapter 7. Profiling and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 性能分析和调试
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Using the Threads and Call Stack windows
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程和调用堆栈窗口
- en: Using the Parallel Stacks window
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行堆栈窗口
- en: Watching values in a thread with Parallel Watch window
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行监视窗口监视线程中的值
- en: Detecting deadlocks with the parallel tasks window
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行任务窗口检测死锁
- en: Measuring CPU utilization with Concurrency Visualizer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发可视化器测量CPU利用率
- en: Using Concurrency Visualizer Threads view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发可视化器线程视图
- en: Using Concurrency Visualizer Cores view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发可视化器核心视图
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Parallel programming can create complex problems. Maybe you didn't get the performance
    gain you expected from parallelizing your application. It could even be running
    slower that a sequential version of the same algorithm. Maybe you are getting
    consistently or occasionally incorrect results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程可以创建复杂的问题。也许你没有从并行化你的应用程序中获得预期的性能提升。它甚至可能比相同算法的顺序版本运行得更慢。也许你得到的是持续或偶尔的错误结果。
- en: The problems that can occur in a parallel program are numerous and can be hard
    to detect. Perhaps oversubscription is causing poor performance because of the
    high number of context switches. Maybe you have inadvertently created a lock convoy,
    which is a condition that occurs when multiple threads of equal priority contend
    repeatedly for the same lock, and can lead to significant lock contention and
    serialization of the program even though multiple threads are in use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并行程序中可能出现的问题众多，且难以检测。可能是因为上下文切换次数过多，过度订阅导致了性能不佳。也许你无意中创建了一个锁车队，这是一种当多个优先级相同的线程反复争夺同一锁时发生的情况，即使使用了多个线程，也可能导致显著的锁竞争和程序序列化。
- en: In this chapter, we are going to take a look at the Visual Studio 2012 debugging
    features for multi-threaded applications, and how to use those features to solve
    concurrency related issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Visual Studio 2012的多线程应用程序调试功能，以及如何使用这些功能来解决与并发相关的问题。
- en: Using the Threads and Call Stack windows
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程和调用堆栈窗口
- en: When we want a thread-centric view of our application, the Threads window is
    the place to start. We can use the Threads window to see the location of all of
    our threads, see the thread call stack, and more. We can use the Call Stack window
    to view the stack frames of our application, or the function, or procedure calls
    that are currently on the stack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要以线程为中心的视图查看我们的应用程序时，线程窗口是开始的地方。我们可以使用线程窗口来查看所有线程的位置，查看线程调用堆栈，等等。我们可以使用调用堆栈窗口来查看应用程序的堆栈帧，或当前在堆栈上的函数或过程调用。
- en: In this recipe, we are going to see how to use the Threads and Call Stack windows
    in Visual Studio 2012 to view the call stack information for the threads in our
    application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何在Visual Studio 2012中使用线程和调用堆栈窗口来查看应用程序中线程的调用堆栈信息。
- en: Getting ready…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: Before we start looking at the debugging features of Visual Studio 2012, we
    need an application to debug. Let's create a `Console` application that spins
    up a few tasks so we can take a look at their call stack information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看Visual Studio 2012的调试功能之前，我们需要一个可调试的应用程序。让我们创建一个`Console`应用程序，启动几个任务，以便我们可以查看它们的调用堆栈信息。
- en: Start a new project using the **C# Console Application** project template and
    assign `LockExample` as the **Solution name.**
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新项目，并将`LockExample`指定为**解决方案名称**。
- en: Add the following `using` directives to the top of your `Program` class.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`Program`类的顶部。
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's start by creating a few `static` methods on the `Program` class. Add a
    method named `Method1` that loops three times, creating tasks. The tasks just
    need to call `Method2` with an `integer` parameter.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在`Program`类上创建几个`static`方法。添加一个名为`Method1`的方法，该方法循环三次，创建任务。任务只需要调用带有`integer`参数的`Method2`。
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now create a method named `Method2`. `Method2` just adds a random number to
    the parameter, writes the parameter to `Console`, and calls `Method4`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为`Method2`的方法。`Method2`只是将一个随机数添加到参数中，将参数写入`Console`，并调用`Method4`。
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next create `Method3`, which just starts a third task that calls `Method2`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来创建`Method3`，它仅启动一个调用`Method2`的第三个任务。
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, create `Method4` which contains our breakpoint.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建包含我们的断点的`Method4`。
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `Main` method, create a task that calls `Method1` and `Task` that calls
    `Method3`. Wait for the user input before exiting.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，创建一个调用`Method1`的任务和一个调用`Method3`的任务。在退出之前等待用户输入。
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's start a debugging session and take a look at the window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个调试会话并查看窗口。
- en: In Visual Studio 2012, press *F5* to run the project.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu
    of Visual Studio 2012, and click on **Windows**, and click on **Call Stack** to
    view the **Threads** window.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调试器触碰到 `Debug.Break` 语句时，转到 Visual Studio 2012 的 **调试** 菜单，点击 **窗口**，然后点击 **调用堆栈**
    以查看 **线程** 窗口。
- en: The active thread is the thread that is currently selected in the **Threads**
    window, indicated by the arrow icon. By default, the active thread is the one
    that hits the breakpoint. Switch the active thread via the **Threads** window
    by double-clicking on a different thread in the view.![How to do it…](img/0225OT_07_07.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 活跃线程是当前在 **线程** 窗口中选中的线程，由箭头图标指示。默认情况下，活跃线程是触碰到断点的线程。通过在 **线程** 窗口中双击视图中的不同线程来切换活跃线程。![如何操作…](img/0225OT_07_07.jpg)
- en: Go back to the **Debug** menu, click on **Windows,** and click on **Threads**
    to show the **Call** **Stack** window.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **调试** 菜单，点击 **窗口**，然后点击 **线程** 以显示 **调用** **堆栈** 窗口。
- en: The **Call Stack** window indicates the top of stack of the active thread with
    a arrow icon. This is known as the active stack frame. When switching threads,
    the active stack frame changes. When execution resumes, the execution continues
    from the active stack frame onwards.![How to do it…](img/0225OT_07_08.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用堆栈** 窗口使用箭头图标指示活跃线程的堆栈顶部。这被称为活跃堆栈帧。当切换线程时，活跃堆栈帧会改变。当执行恢复时，执行从活跃堆栈帧开始继续。![如何操作…](img/0225OT_07_08.jpg)'
- en: The current stack frame is the stack frame that drives the rest of the debugger
    tools and windows. Change the current stack frame by double-clicking on a different
    entry in the **Call Stack** window. When changing the current stack frame to be
    something other than the active stack frame, it shows a tapered arrow.![How to
    do it…](img/0225OT_07_09.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前堆栈帧是驱动其余调试工具和窗口的堆栈帧。通过在 **调用堆栈** 窗口中双击不同的条目来更改当前堆栈帧。当将当前堆栈帧更改为非活跃堆栈帧时，它显示一个细长的箭头。![如何操作…](img/0225OT_07_09.jpg)
- en: You can navigate to the source code for any entry in stack frame. In the **Call
    Stack** window, right-click on the function whose source code you want to see
    and click on **Go To Source Code** from the shortcut menu.![How to do it…](img/0225OT_07_10.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以导航到堆栈帧中任何条目的源代码。在 **调用堆栈** 窗口中，右键单击您想查看源代码的函数，然后从快捷菜单中选择 **转到源代码**。![如何操作…](img/0225OT_07_10.jpg)
- en: Using the Parallel Stacks window
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行堆栈窗口
- en: As the degree of parallelism in our applications continues to grow, we need
    the ability to view and navigate multiple threads call stacks from a single view.
    A developer debugging a multi-threaded application needs the ability to view call
    stacks of multiple threads at the same time, in order to see an overall picture
    of the application's status.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序并行度的持续增长，我们需要能够从单个视图中查看和导航多个线程的调用堆栈。调试多线程应用程序的开发者需要能够同时查看多个线程的调用堆栈，以便看到应用程序的整体状态。
- en: In this recipe, we will see how to use the Parallel Stacks window in Visual
    Studio 2012 to get a graphical view of the call stacks of all tasks in our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何在 Visual Studio 2012 中使用并行堆栈窗口来获取应用程序中所有任务的调用堆栈的图形视图。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, let's go back to Visual Studio 2012 and take a look at the Parallel Stacks
    window.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 Visual Studio 2012 并查看并行堆栈窗口。
- en: In Visual Studio 2012, press *F5* to run the project.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu,
    click on **Windows**, and click on **Parallel Stacks** to display the **Parallel
    Stacks** window.![How to do it…](img/0225OT_07_01.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调试器触碰到 `Debug.Break` 语句时，转到 **调试** 菜单，点击 **窗口**，然后点击 **并行堆栈** 以显示 **并行堆栈**
    窗口。![如何操作…](img/0225OT_07_01.jpg)
- en: Your **Parallel Stacks** view may differ slightly from the image, but you can
    see the call stacks of all of our tasks in a single graph view. The Parallel Stacks
    window in the preceding screenshot shows that we have one thread that went from
    an anonymous method in `Main` to `Method3`, as was called out to **External Code**.
    One thread is in `Main`, and had gone out to the **External Code**. Two other
    threads started, have gone through an anonymous method in `Method1`, through `Method2`,
    to `Method4`. This is also the active stack frame and this is the current thread,
    as indicated by the flag on the active thread. Visual Studio 2012 groups threads
    that have the same call stack information together into the same box.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的**并行堆栈**视图可能与图片略有不同，但您可以在单个图形视图中看到所有任务的调用堆栈。前一个屏幕截图中的并行堆栈窗口显示，我们有一个线程从`Main`中的匿名方法切换到`Method3`，正如在**外部代码**中指出的。一个线程在`Main`中，并已切换到**外部代码**。另外两个线程启动，通过`Method1`中的匿名方法，通过`Method2`，到`Method4`。这也是活动堆栈帧，这是当前线程，如活动线程上的标志所示。Visual
    Studio 2012将具有相同调用堆栈信息的线程组合到同一个框中。
- en: Hover your mouse over the boxes and notice the tool tips that show the stack
    frame information, including method name and parameter values for each thread
    grouped into the box.![How to do it…](img/0225OT_07_02.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在框上，并注意显示堆栈帧信息（包括每个线程的方法名称和参数值）的工具提示。![如何做到这一点…](img/0225OT_07_02.jpg)
- en: You can double-click on any item in the stack frame of the thread to navigate
    to the code.![How to do it…](img/0225OT_07_03.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以双击线程堆栈中的任何项来导航到代码。![如何做到这一点…](img/0225OT_07_03.jpg)
- en: To switch to another thread, right-click on the stack frame of the desired thread
    and click on **Switch To Frame**. Notice that highlight has changed to the selected
    stack frame, and there is a green arrow in the box indicating that this is the
    current stack frame that the debugger is focusing on, as opposed to the active
    stack frame which is indicated by an arrow.![How to do it…](img/0225OT_07_04.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要切换到另一个线程，右键单击所需线程的堆栈帧，然后单击**切换到帧**。注意，高亮显示已更改为所选堆栈帧，并且框中有一个绿色箭头指示这是调试器当前关注的当前堆栈帧，而不是由箭头指示的活动堆栈帧。![如何做到这一点…](img/0225OT_07_04.jpg)
- en: You can switch back to the active stack frame by double-clicking on it in the
    **Parallel Stacks** windows. Notice that it has a thread icon rather than an arrow
    while the different stack frame has the focus of the debugger. Once you double-click
    on it, the arrow returns, indicating that this is the active and current thread.![How
    to do it…](img/0225OT_07_05.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在**并行堆栈**窗口中双击它来切换回活动堆栈帧。注意，它有一个线程图标而不是箭头，而不同的堆栈帧则是调试器的焦点。一旦您双击它，箭头就会返回，指示这是活动且当前线程。![如何做到这一点…](img/0225OT_07_05.jpg)
- en: You can see the **Threads** that have called a method by clicking on the current
    stack frame, and then click on the **Method View** button on the **Parallel Stacks**
    window menu. After clicking on the button, the view will change to show which
    methods the threads are calling.![How to do it…](img/0225OT_07_06.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过单击当前堆栈帧并然后单击**并行堆栈**窗口菜单上的**方法视图**按钮来查看调用方法的**线程**。单击按钮后，视图将更改以显示线程正在调用哪些方法。![如何做到这一点…](img/0225OT_07_06.jpg)
- en: Watching values in a thread with Parallel Watch window
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行监视窗口监视线程中的值
- en: Traditionally, debuggers have been designed to work in the context of a single
    thread at a time. In order to work with a different thread, you needed to first
    switch the thread context. Visual Studio 2012 has a feature known as Parallel
    Watch window that allows you to display the values of a variable or expression
    on multiple threads.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，调试器被设计为一次只在一个线程的上下文中工作。为了与不同的线程一起工作，您需要首先切换线程上下文。Visual Studio 2012有一个称为并行监视窗口的功能，允许您在多个线程上显示变量或表达式的值。
- en: In this recipe, we are going to see how to view the value of a variable across
    multiple threads using the Parallel Watch window.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何使用并行监视窗口查看多个线程中变量的值。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's see how the Parallel Watch window can help us view variable values across
    multiple threads.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看并行监视窗口如何帮助我们查看多个线程中的变量值。
- en: In Visual Studio 2012, press *F5* to run the project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu
    of Visual Studio 2012, and click on **Windows**. Then click on **Parallel Watch**
    and **Parallel Watch 1** to view the window.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调试器遇到 `Debug.Break` 语句时，转到 Visual Studio 2012 的 **Debug** 菜单，然后点击 **Windows**。然后点击
    **Parallel Watch** 和 **Parallel Watch 1** 来查看窗口。
- en: By default, the **Parallel Watch** window brings up all the threads currently
    executing in the process. In order to add new watches, we need to click on **<Add
    Watch>** column which allows us to enter an expression. Click on **<Add Watch>**
    and enter numbers as the expression to watch. As soon as the watch is added we
    can now see the expression evaluated across all the different threads in the **Watch**
    window.![How to do it…](img/0225OT_07_11.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，**Parallel Watch** 窗口会显示进程中当前正在执行的所有线程。为了添加新的监视，我们需要点击 **<Add Watch>**
    列，这允许我们输入一个表达式。点击 **<Add Watch>** 并输入数字作为监视的表达式。一旦监视被添加，我们就可以在 **Watch** 窗口中看到表达式在所有不同的线程中被评估。![如何操作…](img/0225OT_07_11.jpg)
- en: Enter a Boolean expression in the **Filter by Boolean Expression** box. The
    debugger evaluates the expression for each thread context. Only rows where the
    value is true are displayed.![How to do it…](img/0225OT_07_12.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Filter by Boolean Expression** 框中输入一个布尔表达式。调试器为每个线程上下文评估表达式。只有值为真的行才会显示。![如何操作…](img/0225OT_07_12.jpg)
- en: Detecting deadlocks with the Parallel Tasks window
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Parallel Tasks 窗口检测死锁
- en: A very useful feature of the Visual Studio 2012 debugger is the ability to detect
    deadlocks in your tasks. A deadlock occurs when two or more tasks permanently
    block each other by each task having a lock on a resource which the other tasks
    are trying to lock, or by waiting for each other to finish.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2012 调试器的一个非常有用的功能是能够检测任务中的死锁。死锁发生在两个或更多任务永久性地相互阻塞的情况下，每个任务都锁定了一个其他任务试图锁定的资源，或者通过等待对方完成。
- en: The easiest way to find a deadlock in your application is to use the Parallel
    Tasks window of Visual Studio 2012\. The Parallel Tasks window is very similar
    to the Threads window, except that it shows information about each `Task` or `task_handle`
    object instead of each thread, along with the status of the task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 的 Parallel Tasks 窗口中查找死锁是最简单的方法。Parallel Tasks 窗口与 Threads
    窗口非常相似，但它显示的是每个 `Task` 或 `task_handle` 对象的信息，而不是每个线程的信息，以及任务的状态。
- en: In this recipe, we are going to create a `Console` application that will create
    several tasks in a loop. The tasks will deadlock because each task will be waiting
    for the next task to finish.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个 `Console` 应用程序，该程序将在循环中创建几个任务。由于每个任务都在等待下一个任务完成，因此任务将会发生死锁。
- en: Getting ready…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Before we use the Parallel Task window to see the deadlocks in our code, we
    need to create an application that has some deadlocks for us to see.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Parallel Task 窗口查看代码中的死锁之前，我们需要创建一个具有一些死锁的应用程序以便我们查看。
- en: Start a new project using the **C# Console Application** project template and
    assign `DetectDeadlock` as the **Solution name**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板创建一个新的项目，并将 `DetectDeadlock` 作为 **Solution
    name**。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `Main` method of the `Program` class, let's start by creating a variable
    for the number of tasks to create `CountDownEvent`, and an array of `tasks`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类的 `Main` 方法中，让我们首先创建一个用于创建 `CountDownEvent` 的任务数量的变量，以及一个 `tasks`
    数组。
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, just below the previous code, let's create the blocked `tasks` in a `for`
    loop. Each task should wait for the next task to finish.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就在之前的代码下方，让我们在 `for` 循环中创建阻塞的 `tasks`。每个任务都应该等待下一个任务完成。
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let's create and start a couple of tasks that won't block.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建并启动几个不会阻塞的任务。
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finish up the `Main` method by waiting for `CountDownEvent` and setting a breakpoint
    for `Debugger`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过等待 `CountDownEvent` 并为 `Debugger` 设置断点来完成 `Main` 方法。
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In Visual Studio 2012, press *F5* to run the project.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu
    of Visual Studio 2012 and click on **Windows**. Then click on **Parallel Tasks**
    to view the window.![How to do it…](img/0225OT_07_13.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调试器遇到 `Debug.Break` 语句时，转到 Visual Studio 2012 的 **Debug** 菜单并点击 **Windows**。然后点击
    **Parallel Tasks** 来查看窗口。![如何操作…](img/0225OT_07_13.jpg)
- en: In the **Parallel Tasks** window you can see all of the tasks that have been
    identified to be deadlocked. Hover your mouse over any of the blocked tasks to
    see what the task is waiting for.![How to do it…](img/0225OT_07_14.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Parallel Tasks** 窗口中，您可以查看所有已识别为死锁的任务。将鼠标悬停在任何阻塞任务上，以查看任务正在等待什么。![如何做到这一点...](img/0225OT_07_14.jpg)
- en: For applications with a lot of tasks, it can be useful to group the tasks by
    their status. Right-click anywhere in the **Parallel Tasks** window, click on
    **Group By** and then click on **Status**.![How to do it…](img/0225OT_07_15.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于有很多任务的程序，按其状态分组任务可能很有用。在 **Parallel Tasks** 窗口中右键单击任何位置，然后单击 **Group By**，再单击
    **Status**。![如何做到这一点...](img/0225OT_07_15.jpg)
- en: Measure CPU utilization with Concurrency Visualizer
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发可视化器测量 CPU 利用率
- en: Parallel applications are not only prone to common sources of inefficiency that
    are found in sequential applications, but they can also suffer from uniquely parallel
    performance issues such as load imbalance, excessive synchronization overhead,
    or thread migration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 并行应用程序不仅容易受到在顺序应用程序中发现的常见效率低下来源的影响，而且它们还可能遭受独特的并行性能问题，如负载不平衡、过度的同步开销或线程迁移。
- en: Understanding such performance issues can be a difficult and time-consuming
    process. However, Visual Studio 2012 includes a profiling tool, the Concurrency
    Visualizer, which can significantly reduce the burden of parallel performance
    analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这样的性能问题可能是一个困难且耗时的过程。然而，Visual Studio 2012 包含了一个分析工具，即并发可视化器，它可以显著减少并行性能分析的工作量。
- en: In this recipe we will be looking at the CPU Utilization view of the Concurrency
    Visualizer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看并发可视化器的 CPU 利用率视图。
- en: Getting ready…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Before we look at the Concurrency Visualizer, we need to create a `Console`
    application that is going to exercise the processor on your development machine
    a bit. This `Console` application will be a slight variation of the `MultipleProducerConsumer`
    application we created in [Chapter 5](ch05.html "Chapter 5. Concurrent Collections"),
    *Concurrent Collections*. The application will use a `for` loop to create some
    producer `tasks` that the producers use to perform a mathematic operation on some
    numbers, and add the results to `BlockingCollection`. `BlockingCollection`, which
    is a class that provides blocking and bounding capabilities for thread safe collections
    that implement `IProducerConsumerCollection<T>`. There will also be four consumer
    `tasks` that retrieve the results from `BlockingCollection` and write them to
    `Console`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看并发可视化器之前，我们需要创建一个 `Console` 应用程序，该程序将稍微改变我们在 [第 5 章](ch05.html "第 5 章。并发集合")
    中创建的 `MultipleProducerConsumer` 应用程序，即并发集合。该应用程序将使用 `for` 循环创建一些生产者 `tasks`，生产者使用这些
    `tasks` 对一些数字执行数学运算，并将结果添加到 `BlockingCollection`。`BlockingCollection` 是一个提供对实现
    `IProducerConsumerCollection<T>` 的线程安全集合进行阻塞和限制功能的类。还将有四个消费者 `tasks` 从 `BlockingCollection`
    中检索结果并将它们写入 `Console`。
- en: Start a new project using the **C# Console Application** project template and
    assign `MultipleProducerConsumer` as the **Solution name**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# Console Application** 项目模板启动一个新项目，并将 `MultipleProducerConsumer` 作为 **Solution
    name** 分配。
- en: 'Add the following `using` directives to the top of your `Program` class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's add a `static` method to the `Program` class which the producer tasks
    will call to perform the calculation.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `Program` 类中添加一个 `static` 方法，生产者 `tasks` 将调用它来执行计算。
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, just below the previous method, let's create another `static` method that
    consumer `tasks` will use to write the results to `Console`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在之前的方法下面，让我们创建另一个 `static` 方法，该方法是消费者 `tasks` 将用来将结果写入 `Console` 的。
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `Main` method, let's start by creating `BlockingCollection`, to be the
    buffer between the producers and consumers, list of tasks, and the definition
    for four consumer `tasks`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中，让我们首先创建 `BlockingCollection`，作为生产者和消费者之间的缓冲区，任务列表以及四个消费者 `tasks`
    的定义。
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now let's create a `for` loop that spins up some producer `tasks`, performs
    the calculations, and adds the results to `BlockingCollection`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 `for` 循环，启动一些生产者 `tasks`，执行计算，并将结果添加到 `BlockingCollection`。
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, let's create a continuation that calls `CompleteAdding` on `BlockingCollection`
    when all producer `tasks` finish. Wait for the user input before exiting.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个延续，当所有生产者 `tasks` 完成时，在 `BlockingCollection` 上调用 `CompleteAdding`。在退出之前等待用户输入。
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Now, let's see how we can use Concurrency Visualizer to report on the performance
    and efficiency of parallel code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用并发可视化器来报告并行代码的性能和效率。
- en: On Visual Studio 2012 menu, click on **Analyze**, and then click on **Concurrency
    Visualizer**, and **Start with Current Project**. You will see the application
    running while Visual Studio 2012 collects data and builds a report in the background.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 菜单上，点击 **分析**，然后点击 **并发可视化器**，并 **使用当前项目启动**。您将看到应用程序在
    Visual Studio 2012 收集数据和在后台构建报告的同时运行。
- en: When the application finishes running, close the application. Visual Studio
    2012 will then finalize and open the performance report.![How to do it…](img/0225OT_07_16.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序运行完成后，请关闭应用程序。此时，Visual Studio 2012 将最终化并打开性能报告。![如何操作…](img/0225OT_07_16.jpg)
- en: Once the report is completed and loaded, you will see the **Utilization** view
    of the Concurrency Visualizer. The X axis shows the **Elapsed Time** since the
    trace started. The Y axis shows the number of logical processor cores in your
    system. The green area shows the **Number of Logical Cores** that the application
    is using at any given point in the analysis run. The rest of the cores are either
    idle, or are being used by **Other Processes** which are shown by the gray lines
    coming from the top of the graph. There is a **Zoom** slider at the top which
    can be used to narrow the time scale of the graph.![How to do it…](img/0225OT_07_17.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦报告完成并加载，您将看到并发可视化器的 **利用率** 视图。X 轴显示从跟踪开始以来的 **已过时间**。Y 轴显示您系统中的逻辑处理器核心数。绿色区域显示在分析运行中的任何给定点上应用程序正在使用的
    **逻辑核心数**。其余的核心要么是空闲的，要么被 **其他进程** 使用，这些进程通过从图表顶部延伸的灰色线条显示。顶部有一个 **缩放** 滑块，可以用来缩小图表的时间范围。![如何操作…](img/0225OT_07_17.jpg)
- en: When tuning your parallel application, this view allows you to confirm the degree
    of parallelism. You can get hints of common parallel performance problems by reviewing
    the graph. Load imbalances among the processor's cores appear as stair-step patterns
    in the graph. Contention for synchronization objects appear on the graph, such
    as serial execution when parallel is expected.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调整您的并行应用程序时，此视图允许您确认并行程度。您可以通过查看图表来获得常见并行性能问题的提示。处理器核心之间的负载不平衡在图表中表现为阶梯状模式。对同步对象的竞争在图表上显示，例如，当期望并行执行时出现串行执行。
- en: Using Concurrency Visualizer Threads view
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发可视化器线程视图
- en: Threads view is probably the most useful and frequently used view in the Concurrency
    Visualizer. By using this view, you can identify whether the threads are executing
    or blocking because of synchronization or some other reason. Threads view assigns
    a category to each context switch when a thread has stopped executing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 线程视图可能是并发可视化器中最有用且最常使用的视图。通过使用此视图，您可以确定线程是因为同步或其他原因而执行或阻塞。当线程停止执行时，线程视图会将一个类别分配给每个上下文切换。
- en: In this recipe, we are going to use the Concurrency Visualizer to show all of
    the context switch events for each application thread.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用并发可视化器来显示每个应用程序线程的所有上下文切换事件。
- en: Getting ready…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: For this recipe, we will use the same sample application as in the previous
    recipe. If you have closed the `MultipleProducerConsumer` solution, please reopen
    it, and go to the Concurrency Visualizer through the Visual Studio 2012 menu,
    and click on **Analyze**. Then, click on **Concurrency Visualizer**, and **Open
    Trace.** Alternately, you can rerun the Concurrency Visualizers as in the previous
    recipe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用与上一个菜谱相同的示例应用程序。如果您已经关闭了 `MultipleProducerConsumer` 解决方案，请重新打开它，并通过
    Visual Studio 2012 菜单进入并发可视化器，然后点击 **分析**。接着，点击 **并发可视化器**，并 **打开跟踪**。或者，您也可以像上一个菜谱中那样重新运行并发可视化器。
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's take a look at what we can do with the Concurrency Visualizer Threads
    view.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以使用并发可视化器的线程视图做什么。
- en: Open the **Concurrency Visualizer** for the **MultipleProducerConsumer** solution
    and click on the **Threads** view.![How to do it…](img/0225OT_07_18.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **MultipleProducerConsumer** 解决方案的 **并发可视化器** 并点击 **线程** 视图。![如何操作…](img/0225OT_07_18.jpg)
- en: When the **Threads** view opens, you will notice that the X axis is again a
    **Timeline**. However, the Y axis is divided into horizontal channels. If the
    physical disks on your machine have any activity during the running of the application
    (which in this case they don't), the top channels will depict your physical disks.
    In our case, the channels are all threads in our application. You will see the
    `Main` thread, a debugger helper thread, and all of your worker threads. Below
    the list of **Threads**, you will see the **Execution Categories** that are assigned
    by Concurrency Visualizer. In the following screenshot, you can see that the application
    spent **16%** of the **Timeline** in **Execution** and **71%** of the **Timeline**
    in **Synchronization**.![How to do it…](img/0225OT_07_19.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**线程**视图打开时，您会注意到X轴再次是**时间线**。然而，Y轴被划分为水平通道。如果您的机器上的物理磁盘在应用程序运行期间有任何活动（在这个例子中它们没有），顶部通道将描述您的物理磁盘。在我们的案例中，通道都是我们的应用程序中的线程。您将看到`Main`线程、一个调试器辅助线程以及所有工作线程。在**线程**列表下方，您将看到并发可视化器分配的**执行类别**。在下面的屏幕截图中，您可以看到应用程序在**执行**中花费了**16%**的**时间线**，在**同步**中花费了**71%**的**时间线**。![如何操作…](img/0225OT_07_19.jpg)
- en: Click on one of the CLR worker threads in the top channel. The **Timeline**
    next to the channel for the **CLR Worker Thread** will be divided into the **Time
    slices** for the thread. Click on the **Current** tab in the **Profile Report**
    tab. You will see the call stack for the thread at the time of the context switch,
    the reason for the context switch, and **Category** assigned by the report. You
    can see on the **Current** tab that this thread was context switched because it
    arrived at a **Monitor.Wait** call.![How to do it…](img/0225OT_07_20.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部通道中单击一个CLR工作线程。**CLR工作线程**通道旁边的**时间线**将被划分为线程的**时间片**。在**配置文件报告**选项卡中单击**当前**选项卡。您将看到上下文切换时线程的调用堆栈、上下文切换的原因以及报告分配的**类别**。您可以在**当前**选项卡中看到，此线程上下文切换是因为它到达了**Monitor.Wait**调用。![如何操作…](img/0225OT_07_20.jpg)
- en: One of the most valuable features of the **Threads** view is the ability to
    determine thread dependencies. Select a synchronization segment for a worker thread
    (a pink segment). On the **Current** tab you will see the thread that unblocked
    the current thread. Click on the **Unblocking Stack** tab and you will see the
    call stack of the thread that unblocked the current thread.![How to do it…](img/0225OT_07_21.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**线程**视图最有价值的特性之一是确定线程依赖关系的能力。选择一个工作线程的同步段（一个粉红色的段）。在**当前**选项卡中，您将看到解除当前线程阻塞的线程。单击**解除阻塞堆栈**选项卡，您将看到解除当前线程阻塞的线程的调用堆栈。![如何操作…](img/0225OT_07_21.jpg)'
- en: Using Concurrency Visualizer Cores view
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发可视化器核心视图
- en: Frequent context switching can seriously degrade application performance, especially
    when threads migrate across cores when they resume execution. The reason for this
    performance impact is that running threads load instructions and data they need
    into the cache hierarchy, and when a thread resumes execution on a different core,
    there can be latency while working data is reloaded from memory or other caches.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 经常切换上下文会严重影响应用程序的性能，尤其是在线程在恢复执行时跨越核心时。这种性能影响的原因是运行中的线程将它们需要的指令和数据加载到缓存层次结构中，而当一个线程在不同的核心上恢复执行时，可能会出现延迟，因为工作数据需要从内存或其他缓存中重新加载。
- en: The Cores view of the Concurrency Visualizer is a tool that aids in identifying
    excessive context switches. In this recipe, we will return to the `MultipleProducerConsumer`
    solution to see how we can examine the context switching that occurs in the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 并发可视化器的核心视图是一个帮助识别过度上下文切换的工具。在这个配方中，我们将回到`MultipleProducerConsumer`解决方案，看看我们如何检查应用程序中发生的上下文切换。
- en: Getting ready…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: For this recipe, we will use the same sample application as in the previous
    recipe. If you have closed the `MultipleProducerConsumer` solution, please reopen
    it and go to the Concurrency Visualizer through the Visual Studio 2012 menu. Click
    on **Analyze**, and then click on **Concurrency Visualizer**, and **Open Trace**.
    Alternately, you can rerun the Concurrency Visualizers as in the previous recipe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用与上一个配方相同的示例应用程序。如果您已关闭`MultipleProducerConsumer`解决方案，请重新打开它，并通过Visual
    Studio 2012菜单转到并发可视化器。单击**分析**，然后单击**并发可视化器**，并**打开跟踪**。或者，您可以根据上一个配方重新运行并发可视化器。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Open the Concurrency Visualizer for the `MultipleProducerConsumer` solution
    and click on the **Cores** view.![How to do it…](img/0225OT_07_22.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MultipleProducerConsumer`解决方案的并发可视化器，并点击**核心**视图。![如何操作…](img/0225OT_07_22.jpg)
- en: Like the other views, the **Cores** view displays the timeline on the X axis.
    The logical cores of the system are shown on the Y axis. Each thread in the application
    is shown in a different color, and thread execution segments are displayed on
    the core channels.![How to do it…](img/0225OT_07_23.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他视图一样，**核心**视图在X轴上显示时间线。系统的逻辑核心显示在Y轴上。应用程序中的每个线程以不同的颜色显示，线程执行段显示在核心通道上。![如何操作…](img/0225OT_07_23.jpg)
- en: The statistics shown in the **Cores** view help the developer to identify **Threads**
    that have excessive context switches and incur core migrations. The list of threads
    at the bottom of the **Cores** view is sorted by the number of **Cross-Core Context
    Switches**. Click on the thread with the highest number of core switches (the
    top thread in the list). Notice how the thread execution is spread across the
    available **Cores** in your system.![How to do it…](img/0225OT_07_24.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**核心**视图中显示的统计信息有助于开发者识别发生过多上下文切换并导致核心迁移的**线程**。**核心**视图底部的线程列表按**跨核心上下文切换次数**排序。点击列表中核心切换次数最多的线程（列表顶部的线程）。注意线程执行是如何分散到系统可用的**核心**上的。![如何操作…](img/0225OT_07_24.jpg)'
