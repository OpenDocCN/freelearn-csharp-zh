- en: Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 不再孤单 - 甜食熊猫出击
- en: '*"They are angry and they are hungry. Beware, the sweet-tooth pandas are getting
    closer for your delicious cake!*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"他们生气又饿。小心，甜食熊猫正靠近你的美味蛋糕！*'
- en: Animations and artificial intelligence are at the core of giving life to an
    **Non-Playing Characters** (**NPCs**) or complex objects in games. The former
    makes NPCs appear dynamic and not static; the latter gives them an intelligence,
    with which they can move and act into the world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动画和人工智能是赋予游戏中的**非玩家角色（NPCs**）或复杂物体生命力的核心。前者使NPC看起来动态而非静态；后者赋予它们智能，使它们能够在世界中移动和行动。
- en: This chapter explains how to use the animation system of Unity, with a particular
    focus on 2D animations. We will cover artificial intelligence and what it can
    do in video games later in the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何使用Unity的动画系统，特别是关注2D动画。我们将在本书的后面部分介绍人工智能及其在视频游戏中的功能。
- en: The first part of the chapter will focus on the rich and sophisticated animation
    system of Unity (sometimes referred to as Mecanim). In explaining each part, we
    will bring, bit by bit, our evil pandas to life.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分将重点关注Unity丰富而复杂的动画系统（有时称为Mecanim）。在解释每个部分时，我们将逐步将我们的邪恶熊猫栩栩如生。
- en: However, in the second part of the chapter, we will give the evil pandas the
    possibility to move around the map, to trigger actions such as dying or eating
    so much cake that they will explode... *literally*!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在章节的第二部分，我们将给邪恶的熊猫移动地图的可能性，触发死亡或吃太多蛋糕以至于爆炸等动作... *字面上的*！
- en: 'In particular, we will see:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是以下内容：
- en: Animation clips and how to create and handle them from Sprite Sheets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画剪辑及其从精灵图集中创建和处理方法
- en: The Animator and how to build a finite state machine for animations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator及其如何为动画构建有限状态机
- en: Scripting objects with an Animator component to trigger animations and make
    the animation machine working
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Animator组件脚本化对象以触发动画并使动画机器工作
- en: Implementing a waypoint system to move the sweet-tooth pandas around
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路径点系统以移动甜食熊猫
- en: Like all the other chapters of this book, you will find the *Homework* section
    at the end. It has a range of different exercises for you to do to improve your
    skills and implement a range of different functionalities in your game. So, let's
    get ready to learn how to bring our evil pandas to life.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书的所有其他章节一样，你将在结尾找到*作业*部分。它包含一系列不同的练习，以提高你的技能并在你的游戏中实现各种不同的功能。所以，让我们准备好学习如何让我们的邪恶熊猫栩栩如生。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The graphic package that we are using for this book contains an animation Sprite
    Sheet for our terrible sweet-tooth pandas. Therefore, be sure to have the Sprite
    Sheet imported as **Sprite** and to set **Sprite Mode** to **Multiple**. In fact,
    you should have all single frames in a different sprite. Remember to rename them
    so that you will be less confused later on. The same applies if you are using
    your own graphics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于本书的图形包包含一个动画精灵图集，用于我们可怕的甜食熊猫。因此，请确保将精灵图集导入为**精灵**，并将**精灵模式**设置为**多个**。实际上，你应该将所有单独的帧放在不同的精灵中。记住重命名它们，这样你以后就不会那么困惑了。如果你使用自己的图形，这也适用。
- en: '![Getting ready](img/image00445.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/image00445.jpeg)'
- en: An evil panda is looking forward to eat your cake
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一只邪恶的熊猫正期待着吃你的蛋糕
- en: Animations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: Life and all of its creatures are dynamic. We move, and our movements, even
    the subtlest of ones, express emotions. If we were to remove such things, even
    the tiniest smile, life would become dull and static. Animation effects can range
    from the simplest of things such as a flag waving to a dragon flying. Just look
    around you, inside and outside; something will be moving or will move from time
    to time. Even stones move, albeit with wind, something knocking them, or someone
    skipping them across water.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 生命及其所有生物都是动态的。我们移动，我们的动作，即使是微妙的动作，也表达着情感。如果我们移除这些事物，即使是微小的微笑，生命也会变得乏味和静态。动画效果可以从最简单的事物，如旗帜挥舞，到龙飞翔。只需环顾四周，无论是室内还是室外；总会有东西在移动，或者时不时地移动。即使是石头也会移动，尽管是风吹，或者有人从水面上跳过它们。
- en: Unity has a complex animation system, also known as **Mecanim**, which requires
    time to get used to. It includes different components. Some of these are specifically
    for 3D animations; others can be used for both 2D and 3D. Usually, animating in
    3D is harder than in 2D since it requires tweaking of many parameters, and therefore
    much more practice is needed to master it. If you are interested in learning more
    about 3D animation in Unity, I suggest that you to read a specific book about
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 拥有一个复杂的动画系统，也称为 **Mecanim**，需要时间来习惯。它包括不同的组件。其中一些是专门用于 3D 动画的；其他则可以用于
    2D 和 3D。通常，3D 动画比 2D 动画更难，因为它需要调整许多参数，因此需要更多的实践来掌握它。如果你对在 Unity 中学习 3D 动画感兴趣，我建议你阅读关于它的特定书籍。
- en: 'In this book, we will focus on animating only in 2D. As such, our workflow
    becomes simple enough that it can be explained within this chapter. In particular,
    we will go through the following workflow:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将专注于仅进行 2D 动画。因此，我们的工作流程足够简单，可以在本章中解释。特别是，我们将进行以下工作流程：
- en: Creating some files called animation clips, to store our animations. We will
    do this starting from animation Sprite Sheets.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些名为动画剪辑的文件，以存储我们的动画。我们将从动画 Sprite Sheets 开始做这件事。
- en: Building a finite-state machine to control the flow of the animations.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个有限状态机来控制动画的流程。
- en: Writing a script to control the finite-state machine triggers.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个脚本以控制有限状态机的触发器。
- en: Specifically, in this section, we will see how to animate our terrible sweet-tooth
    pandas. In our graphic package, we can find the animation Sprite Sheets of the
    panda under the `Graphic/Enemies` folder. Of course, all the Sprite Sheets should
    already be sliced, as we have seen back in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity* and if you are using
    your own graphics, it is better if all the single sprites have the same dimensions.
    But before we go any further in exploring Mecanim, let's go through some background
    information about animation in the next two sections.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本节中，我们将看到如何为我们的糟糕甜食爱好者熊猫进行动画制作。在我们的图形包中，我们可以在 `Graphic/Enemies` 文件夹下找到熊猫的动画
    Sprite Sheets。当然，所有的 Sprite Sheets 应该已经切片，正如我们在 [第 1 章](part0016.xhtml#aid-F8901
    "第 1 章。Unity 中的平面世界")，*Unity 中的平面世界* 中所看到的，如果你使用自己的图形，最好所有单个精灵都有相同的尺寸。但在我们进一步探索
    Mecanim 之前，让我们在接下来的两个部分中了解一些关于动画的背景信息。
- en: A historical overview
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史概述
- en: The term *animation* derives from the Latin word *animates*, which is the past
    participle of the verb *animare*; that means *give breath to*. The verb derives
    from the word *anima*, which means *life, breath*, originating from the Greek
    word *anemos*, literally *wind*, which in turn descend from the Sanskrit word
    *aniti*, meaning *breathes*. It was only during the 1742 that the verb *to animate*
    was used for the first time with the sense of *give life to*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *animation* 来自拉丁语单词 *animates*，它是动词 *animare* 的过去分词；这意味着 *赋予生命*。这个动词来自单词
    *anima*，意思是 *生命，呼吸*，起源于希腊语单词 *anemos*，字面意思是 *风*，它又源自梵文单词 *aniti*，意思是 *呼吸*。直到 1742
    年，动词 *to animate* 才第一次被用来表示 *赋予生命* 的意思。
- en: 'Modern animations are based on the concept of motion. Therefore, it''s worthwhile
    to mention that the first studies of motion were conducted by the Greek Philosopher
    *Ζήνων ὁ Ἐλεάτης* (known in English as *Zeno of Elea*) during the 4th century
    B.C. We can read about many of his ideas in works by another Greek philosopher:
    *Ἀριστοτέλης* (known in English as *Aristotle*). Zeno is famous for conceiving
    many paradoxes about motion, exploring the problem to prove the inexistence of
    motion. One of these paradoxes is the arrow paradox (also known as **Fletcher''s
    paradox**). We can read a little bit about this from Aristotle''s book Physics
    IV, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现代动画基于运动的概念。因此，值得一提的是，关于运动的第一项研究是在公元前 4 世纪由希腊哲学家 *Ζήνων ὁ Ἐλεάτης*（在英语中被称为 *Zeno
    of Elea*）进行的。我们可以在另一位希腊哲学家 *Ἀριστοτέλης*（在英语中被称为 *Aristotle*）的作品中读到许多他的想法。Zeno
    以构想许多关于运动的悖论而闻名，探索这个问题以证明运动的不存在。其中一个悖论是箭悖论（也称为 **Fletcher's paradox**）。我们可以从亚里士多德的《物理学》第四卷中读到一些关于这个悖论的内容，如下所示：
- en: '*"If everything when it occupies an equal space is at rest, and if that which
    is in locomotion is always occupying such a space at any moment, the flying arrow
    is therefore motionless."*'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"如果一切在占据相等空间时都是静止的，如果运动中的物体在任何时刻都占据这样的空间，那么飞箭因此就是静止的。"*'
- en: '![A historical overview](img/image00446.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![历史概述](img/image00446.jpeg)'
- en: The Zeno's Fletcher's paradox described by Aristotle. You don't see the arrow
    moving towards the target, but just moments in which the arrow is static, albeit
    in different positions. Therefore, motion is an illusion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 亚里士多德描述的芝诺的飞矢悖论。你并没有看到箭头向目标移动，而只是看到箭头静止在某个位置上的瞬间，尽管这些位置各不相同。因此，运动是一种错觉。
- en: As we can see from the preceding picture, the paradox claims the motionlessness
    of the arrow, since in each instant the arrow is in a very particular position
    in space and it is static in that instant. Besides the many philosophical implications
    and solutions to the paradox, it's interesting to note that the same concept applies
    nowadays for animation. Animations in movies and video games (to name a few) are
    just a series of static frames, which, in a rapid succession, give the illusion
    of motion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，悖论声称箭头的静止状态，因为箭头在每一瞬间都在空间中的一个非常特定的位置，并且在这一瞬间是静止的。除了悖论的多重哲学含义和解决方案之外，值得注意的是，同样的概念现在也适用于动画。电影和视频游戏（仅举几个例子）中的动画只是一系列静态帧，这些帧以快速连续的方式给出运动错觉。
- en: Animations in video games
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频游戏中的动画
- en: Animations help to bring our creations to life. They make the living more vibrant
    and the dead even creepier! The development of animation has come a long way since
    the pixel art graphics to what can only be described as an uncanny valley of movement.
    In some cases, the animations are so life like that for a moment we forget that
    we're in an alternate reality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 动画有助于使我们的创作栩栩如生。它们使生活更加生动，使死者更加令人毛骨悚然！自从像素艺术图形发展到只能用“运动怪异谷”来形容的程度，动画的发展已经走了很长的路。在某些情况下，动画如此逼真，以至于我们一时忘记了我们身处一个不同的现实。
- en: Now, let's go back to the start of game animation. Space Invaders, Donkey Kong,
    and Tempest. If you have ever experienced one of these games, then you will know
    what I mean when a lot can be conveyed by very simple animation, whether it is
    translating side to side with Space Invaders, jumping to dodge barrels in Donkey
    Kong, or rotating in Tempest. However, as time progressed, so too did the animation
    techniques that we have become all too familiar with. With the introduction of
    3D games and consequently characters, we have seen animations enter another dimension...
    literally. But despite their polygonal bodies and ridged movements, such as the
    following image of Lara Croft (though not so much nowadays), animations allow
    us to simply interact with a game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到游戏动画的起点。太空侵略者、大金刚和暴风雨。如果你曾经玩过这些游戏中的任何一个，那么当你听到“很多内容可以通过非常简单的动画传达”时，你会明白我的意思。无论是太空侵略者横向移动，大金刚跳跃躲避油桶，还是暴风雨中的旋转，都是如此。然而，随着时间的推移，我们变得非常熟悉的动画技术也在不断发展。随着3D游戏和随之而来的角色的引入，我们看到动画进入了另一个维度……字面上的。但尽管它们的身体是多边形的，动作是刻板的，比如以下劳拉·克劳馥的图像（尽管现在不那么明显了），动画使我们能够简单地与游戏互动。
- en: '![Animations in video games](img/image00447.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏中的动画](img/image00447.jpeg)'
- en: Taken from the gameplay of Lara Croft in Tomb Raider I
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 取自《古墓丽影》中劳拉·克劳馥的游戏画面
- en: One good philosophy behind including animation is to think of animations as
    a way of communicating with your audience. Sometimes, emotions such as love, excitement,
    and hate are great ways to communicate feelings, just like body movements such
    as running, jumping, and attacking are good ways to indicate a state that the
    player is currently experiencing. However, animation doesn't just include the
    player; objects such as trees, and animals, and those who are not playing, or
    NPC, also interact and move about the game space, sometimes just as any controlled
    player would. Some of the most prolific examples of the use of animation with
    NPCs are in **Role Playing Games** (**RPGs**).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含动画背后的一个良好哲学是，将动画视为与观众沟通的一种方式。有时，像爱、兴奋和仇恨这样的情感是传达感受的好方法，就像跑步、跳跃和攻击这样的身体动作是表明玩家当前体验状态的好方法。然而，动画不仅仅包括玩家；树木、动物以及那些不玩游戏或NPC也会在游戏空间中互动和移动，有时就像任何受控玩家一样。使用动画与NPC的一些最典型的例子是在**角色扮演游戏**（**RPGs**）中。
- en: Many characters that you interact with develop a feeling about you. For example,
    if you constantly answer them with an abrupt response, they are likely to display
    facial expressions of despise, or shock like the next image. Where, on the other
    hand, if you're warm, friendly, and offer a helping hand, then their facial expressions
    are likely to be more welcoming.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你与之互动的许多角色都会对你产生某种感觉。例如，如果你总是用简短的反应回答他们，他们很可能会表现出轻蔑或震惊的表情，就像下一张图片所示。另一方面，如果你热情友好，并伸出援手，那么他们的表情可能会更加欢迎。
- en: '![Animations in video games](img/image00448.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏中的动画](img/image00448.jpeg)'
- en: Shepard, clearly not laughing at a joke (Mass Effect series)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Shepard，显然没有在笑一个笑话（质量效应系列）
- en: Timing is everything, so when it comes to animations, make sure that they happen
    when they are supposed to. Pressing ***X*** to jump and the jump happening only
    3 seconds later is not going to end well, for your game or the player. It is not
    enough to just animate a character or an object, but you've to add them up to
    create an immersive environment. The importance of being immersed within a game
    is vital if you want your player to come back for more. If you have clunky animation
    that causes frustration, chances are that the player won't be persistent, unless
    perhaps the story is extremely intriguing. Even the trees in most games animate,
    even with subtle swaying or leaves flickering with the wind. In this way, it's
    better than having giant poles of static wood sticking out from the ground.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 时间就是一切，所以当涉及到动画时，确保它们在应该发生的时候发生。按***X***键跳跃，而跳跃却在3秒后才发生，这对你的游戏或玩家来说都不会有好的结果。仅仅为角色或物体制作动画是不够的，你必须将它们组合起来以创造一个沉浸式的环境。如果你想让玩家再次回来，那么沉浸在游戏中是至关重要的。如果你有笨拙的动画导致玩家沮丧，那么玩家可能不会坚持下去，除非故事极其吸引人。即使在大多数游戏中，树木也会进行动画处理，即使只是细微的摇摆或随风摇曳的树叶。这样，它比从地面上伸出的大木桩要好得多。
- en: 'Another thing to consider when it comes to animation is the frame rate and,
    in turn, the hardware. You may have a wonderful animation sequence, such as the
    epic cut scene like the fight in Crisis Core: Final Fantasy VII between Sephiroth,
    Genesis, and Angeal (as shown in the following image); another example is the
    gameplay while you''re killing enemies in Battlefield 4\. But if there were a
    delay, well, it would have been pretty much nothing! When creating games for Unity,
    it is very important to consider this, especially when you are targeting mobile
    devices. While many mobile devices have the ability to play some resource-heavy
    media, not all do. Therefore, if your ultimate device won''t be able to keep up,
    your intense efforts are likely to go in vain, unless of course you find another
    device to target. This is mostly the case with 3D games on mobile devices, and
    you can find out more here in the official Unity documentation: [https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑动画时，还有另一件事需要考虑，那就是帧率和相应的硬件。你可能有一个精彩的动画序列，比如在《最终幻想VII：核心危机》中Sephiroth、Genesis和Angeal之间的史诗级场景（如以下图片所示）；另一个例子是在《战地4》中杀敌时的游戏画面。但如果有延迟，那基本上就没什么了！当为Unity创建游戏时，考虑这一点非常重要，尤其是当你针对移动设备时。虽然许多移动设备能够播放一些资源密集型的媒体，但并非所有都能。因此，如果你的最终设备无法跟上，你的辛勤努力很可能会白费，除非当然你找到了另一个目标设备。这在移动设备上的3D游戏中尤为常见，你可以在官方Unity文档中了解更多信息：[https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I recommend that you visit the preceding link once you've finished the chapter
    so as to have a better understanding of the animation system in Unity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在完成本章后访问前面的链接，以便更好地了解Unity中的动画系统。
- en: '![Animations in video games](img/image00449.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏中的动画](img/image00449.jpeg)'
- en: 'Gameplay screenshot of Genesis and Sephiroth fighting in Crisis Core: Final
    Fantasy VII'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Genesis和Sephiroth在《最终幻想VII：核心危机》中的战斗游戏截图
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Check out this site for some great tips for using animation in mobile games:
    [www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging](http://www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个网站，了解一些在移动游戏中使用动画的绝佳技巧：[www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging](http://www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging)。
- en: Now that we have an overview of animations in video games, let's head back to
    Unity to discover what it handles with animations, starting with the general workflow.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对视频游戏中的动画有了概述，让我们回到 Unity，了解它如何处理动画，从一般的工作流程开始。
- en: Workflow for animations
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画工作流程
- en: Now that we have understood why animations are so important for video games,
    let's give them a closer look. Unity's animation system is based on the concept
    of animation clips; we will explore this in more detail in the next section. As
    the name suggests, they are just clips containing data for a single animation
    (with a few exceptions).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了动画对视频游戏的重要性，让我们更深入地了解一下。Unity 的动画系统基于动画片段的概念；我们将在下一节中更详细地探讨这一点。正如其名所示，它们只是包含单个动画数据的片段（有一些例外）。
- en: Animation clips are organized into a structure that is similar to a flowchart
    system, where different nodes are connected to others (like the next screenshot).
    This system is called an Animator Controller and it acts as a state machine. It
    keeps track of which clip should currently be played and determines when the animations
    should change or blend together.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 动画片段被组织成一个类似于流程图系统的结构，其中不同的节点相互连接（如下一张截图所示）。这个系统被称为动画控制器（Animator Controller），它充当状态机。它跟踪当前应该播放哪个片段，并确定何时动画应该改变或混合在一起。
- en: '![Workflow for animations](img/image00450.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![动画工作流程](img/image00450.jpeg)'
- en: A very simple Animator Controller might only contain a small amount of clips.
    For example, one clip may be an object breaking, the other a fan rotating. On
    the other hand, a more advanced Animator Controller is likely to contain a lot
    more animations, for instance, all actions related to the main character, such
    as running, walking, idling, dying, and so on. In addition, animations may blend
    between multiple clips in order to look more fluid-like and less robotic, unless
    of course that is your intention!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的动画控制器可能只包含少量片段。例如，一个片段可能是一个物体破碎，另一个是风扇旋转。另一方面，一个更高级的动画控制器可能包含更多的动画，例如与主要角色相关的所有动作，如跑步、行走、闲置、死亡等。此外，动画可以在多个片段之间混合，以看起来更流畅，更不机械，除非当然这是您的意图！
- en: Unity's animation system also has many special features, especially when using
    humanoid characters. These features allow you to retarget human-like or humanoid
    animations from any source, such as motion capture, the Unity asset store, or
    software such as Maya or Blender, and then apply them to your own character model.
    In addition to applying these animations, you are also able to adjust muscle definitions
    on characters. These special features are enabled by Unity's Avatar system, where
    humanoid characters are mapped to a common internal format (we won't see this
    in detail, but you can learn more in the optional section at the end of the chapter).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的动画系统也拥有许多特殊功能，尤其是在使用类人角色时。这些功能允许您从任何来源重新定位类似人类或类人动画，例如动作捕捉、Unity 资产商店，或如
    Maya 或 Blender 这样的软件，然后将它们应用到自己的角色模型上。除了应用这些动画外，您还可以调整角色的肌肉定义。这些特殊功能是通过 Unity
    的 Avatar 系统实现的，其中类人角色被映射到一个通用的内部格式（我们不会在这里详细讨论，但您可以在章节末尾的选读部分了解更多信息）。
- en: Ultimately, the animation clips, the Animator Controller, and the Avatar, are
    brought together on a gameObject via the Animator Component. This component references
    an Animator Controller and (if required) the Avatar for the model in question.
    The Animator Controller in turn contains the references to the animation clips
    it uses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，动画片段、动画控制器和 Avatar 通过动画组件在 gameObject 上汇集在一起。该组件引用一个动画控制器（如果需要）以及相应模型的 Avatar。反过来，动画控制器包含它所使用的动画片段的引用。
- en: Animations clips and the Animator component
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画片段和动画组件
- en: At the heart of Unity's animation system, there are Animation Clips. These components
    contain information that relate to an object's animation, such as whether or not
    they need to change their translation (position), their rotation, and so on, as
    the animation takes place. Animation clips can be 2D or 3D and are often made
    in programs such as 3D Studio Max, Flash, Maya, Blender, and even Photoshop. In
    addition to using software, animations can be created manually, such as rigging
    a 3D character (giving it a skeleton to move) or creating movement-by-movement
    sprites where each movement is drawn out. Remember the old Disney cartoons? Well
    they used similar processes to bring us some of our most beloved memories. However,
    if your game requires something that isn't too complex such as opening and closing
    doors, you are able to do this in Unity. Unity offers a tool known as the the
    Animation window (more about this later in the chapter).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Unity动画系统的核心是动画剪辑。这些组件包含与对象动画相关的信息，例如它们是否需要在动画过程中改变它们的平移（位置）、旋转等。动画剪辑可以是2D或3D，通常在3D
    Studio Max、Flash、Maya、Blender甚至Photoshop等程序中创建。除了使用软件，动画还可以手动创建，例如为3D角色绑定（给它一个可以移动的骨架）或创建逐帧移动的精灵，其中每个动作都是单独绘制的。还记得那些老迪士尼卡通吗？嗯，他们使用了类似的过程带给我们一些最珍贵的记忆。然而，如果你的游戏需要的东西不是很复杂，比如开关门，你可以在Unity中做到这一点。Unity提供了一个名为动画窗口的工具（本章后面将详细介绍）。
- en: In the case of 2D, these animation clips can contain an arbitrary sequence of
    sprites, like single frames in a movie, and change them over time so to give the
    illusion of motion. Usually, in 2D game development, sprite sheets are used for
    these purposes (like we anticipated in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A
    Flat World in Unity"), *A Flat World in Unity*). As such, our graphic package
    contains these animation sprite sheets as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D的情况下，这些动画剪辑可以包含任意序列的精灵，就像电影中的单帧一样，并且随着时间的推移改变它们，以产生运动的错觉。通常，在2D游戏开发中，精灵图用于这些目的（正如我们在[第1章](part0016.xhtml#aid-F8901
    "第1章。Unity中的平面世界")中预期的，*Unity中的平面世界*)。因此，我们的图形包中也包含这些动画精灵图。
- en: '![Animations clips and the Animator component](img/image00451.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![动画剪辑和Animator组件](img/image00451.jpeg)'
- en: Another useful way to think about Animation clips is to pretend that they are
    actions, such as pick up an object, walk, or jump.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动画剪辑的另一种有用的思考方式是想象它们是动作，比如捡起一个物体、行走或跳跃。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In most advanced cases, Animation clips can contain part of an action that can
    be blended or merged with other animation clips.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数高级情况下，动画剪辑可以包含一个动作的一部分，可以与其他动画剪辑混合或合并。
- en: 'For our pandas, we have the following animations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的熊猫，我们有以下动画：
- en: '**Walk**: When our panda will move along the path'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行走**：当我们的熊猫沿着路径移动时'
- en: '**Die**: When the player''s cupcake towers will take the panda down'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死亡**：当玩家的杯子蛋糕塔将熊猫击倒时'
- en: '**Hit**: When the player''s cupcake towers will hit the panda'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击中**：当玩家的杯子蛋糕塔击中熊猫时'
- en: '**Eat**: When the panda reaches the end of the level and eats a slice of the
    player''s cake'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吃**：当熊猫到达关卡末尾并吃掉玩家蛋糕的一块'
- en: As such, we need to create four different animation clips, one for each of these.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建四个不同的动画剪辑，每个对应这些中的一个。
- en: Creating Animation clips with a controller
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用控制器创建动画剪辑
- en: The method explained in this section is a rapid way to start to create the first
    Animation clip, starting from a sprite sheet, and as a side effect, a controller
    will be created. However, we will deal with it later in the chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中解释的方法是一种快速创建第一个动画剪辑的方法，从精灵图开始，并且作为副作用，会创建一个控制器。然而，我们将在本章的后面处理它。
- en: First of all, create an empty game object in the scene, and rename it to `Panda`
    (or if you prefer, `Sweet-Tooth_Panda`). Eventually, you'll want to store it,
    once finished working on it, inside a prefab.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在场景中创建一个空的游戏对象，并将其重命名为`Panda`（或者如果你愿意，`Sweet-Tooth_Panda`）。最终，当你完成对这个对象的工作后，你希望将其存储在一个预制体中。
- en: 'Now in the project panel, if we select `animation_panda_sprite_sheet` and expand
    it, we will have something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在项目面板中，如果我们选择`animation_panda_sprite_sheet`并展开它，我们会看到如下内容：
- en: '![Creating Animation clips with a controller](img/image00452.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用控制器创建动画剪辑](img/image00452.jpeg)'
- en: All the single Sprites/frames of the animation should be the same size. By ensuring
    this in the beginning, it allows you to avoid many headaches later on. Therefore,
    if the Sprite Sheet is well done, it should be sliced without difficultly with
    the **Grid By Cell Count** mode in the Sprite Editor, as we did in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity*. In our package,
    our Sprite Sheet is already good to go with each Sprite distributed evenly, but
    if you're using your own graphic and the Sprite Sheet doesn't have all the frames
    of the same size, you might want to modify it within a graphics program (such
    as Photoshop or Gimp) so that the sprites are distributed accordingly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的单个精灵/帧应该具有相同的大小。通过在开始时确保这一点，它可以帮助你避免以后出现许多头痛问题。因此，如果精灵图已经做得很好，它应该可以在精灵编辑器中的**按单元格计数网格**模式下轻松切片，就像我们在[第1章](part0016.xhtml#aid-F8901
    "第1章。Unity中的平面世界")中做的那样。在我们的包中，我们的精灵图已经准备好了，每个精灵均匀分布，但如果你使用自己的图形，并且精灵图没有所有帧的大小相同，你可能需要在图形程序（如Photoshop或Gimp）中修改它，以便精灵相应地分布。
- en: 'This is the final result in the Sprite Editor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是精灵编辑器中的最终结果：
- en: '![Creating Animation clips with a controller](img/image00453.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用控制器创建动画片段](img/image00453.jpeg)'
- en: 'However, if you move the slider at the bottom part of the project panel (as
    we learned in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in
    Unity"), *A Flat World in Unity*), you are able to see all the single sprites,
    as the following image shows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你移动项目面板底部滑块（正如我们在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")中学习的），你将能够看到所有单个精灵，如下图所示：
- en: '![Creating Animation clips with a controller](img/image00454.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用控制器创建动画片段](img/image00454.jpeg)'
- en: 'Select all the Sprites that belong to the animations of the walking Panda,
    and drag them onto the **Panda** game object we have created before:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 选择属于行走熊猫动画的所有精灵，并将它们拖动到我们之前创建的**熊猫**游戏对象上：
- en: '![Creating Animation clips with a controller](img/image00455.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用控制器创建动画片段](img/image00455.jpeg)'
- en: In our case, we have 11 sprites for the Walking animation, then 5 sprites for
    the Hit animation, 10 for the Die animation, and finally 16 for the Eat animation
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，行走动画有11个精灵，然后是5个击打动画的精灵，10个死亡动画的精灵，最后是16个进食动画的精灵
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It may happen that the last Sprite is equal to the first one. Depending on the
    case, you might not want it because it is likely to cause a disruption in the
    animation, such as a delay in a walking sequence. In that case, you can just select
    all the sprites but the last one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能最后一张精灵图与第一张相同。根据情况，你可能不希望它因为很可能会在动画中引起中断，比如行走序列中的延迟。在这种情况下，你只需选择除了最后一张之外的所有精灵。
- en: Unity will ask you where to save the animation clip and under which name. We
    can name it `Panda_Walk_Animation` and save it in our `Animation` folder. If you
    don't have it, you can create it under the `Asset` folder. In this way, as we
    discussed in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in
    Unity"), *A Flat World in Unity*, we keep our project clean and tidy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity会询问你将动画剪辑保存到何处以及使用哪个名称。我们可以将其命名为`Panda_Walk_Animation`并将其保存在我们的`Animation`文件夹中。如果你没有它，你可以在`Asset`文件夹下创建它。这样，正如我们在[第1章](part0016.xhtml#aid-F8901
    "第1章。Unity中的平面世界")中讨论的，我们可以保持我们的项目整洁有序。
- en: When we select the `Panda` object, we can notice that in the Inspector two components
    have been added. One is a **Sprite Renderer**, which we have already discussed
    in previous chapters. The other is an **Animator** component. Let's see it in
    detail in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择`Panda`对象时，我们可以在检查器中注意到已经添加了两个组件。一个是**精灵渲染器**，我们已经在之前的章节中讨论过。另一个是**动画器**组件。让我们在下一节中详细了解它。
- en: '![Creating Animation clips with a controller](img/image00456.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用控制器创建动画片段](img/image00456.jpeg)'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you navigate in the **Animation** folder, other than the animation file we
    have just created, you will also find an Animator controller called `Panda` (or
    `Sweet-Tooth_Panda`, since the name is taken from the Game Object). For our purposes,
    it's better to rename it as something that describes it better, such as `PandaAnimatorController`.
    We will learn more about this later in the chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到**动画**文件夹，除了我们刚刚创建的动画文件外，你还会找到一个名为`Panda`（或`Sweet-Tooth_Panda`，因为名称是从游戏对象中取的）的动画控制器。为了我们的目的，最好将其重命名为更描述性的名称，例如`PandaAnimatorController`。我们将在本章后面了解更多关于它的内容。
- en: The Animator component
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画组件
- en: The main function of the Animator component is to hold a reference to an Animator
    Controller, which defines how our animation clips should be played. Furthermore,
    it controls when and how to blend and/or transition between them. We will explore
    the controller in the next sections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Animator组件的主要功能是持有Animator Controller的引用，它定义了我们的动画剪辑应该如何播放。此外，它控制何时以及如何混合和/或在这之间进行过渡。我们将在下一节中探讨控制器。
- en: 'The Animator component has some parameters that can adjusted. Let''s see the
    main ones:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Animator组件有一些可以调整的参数。让我们看看主要的几个：
- en: '**Controller**: This is the reference to the Animator Controller, and it''s
    the most important variable. If not set, the Animator component can''t work. In
    the previous picture, the controller is set to `Panda` (or `PandaAnimatorController`
    if you have renamed it), which is a controller we just created.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这是Animator Controller的引用，是最重要的变量。如果没有设置，Animator组件将无法工作。在前面的图片中，控制器设置为`Panda`（或者如果您已重命名它，则为`PandaAnimatorController`），这是我们刚刚创建的控制器。'
- en: '**Avatar**: A parameter only for 3D Humanoid characters, so you can ignore
    it (however, if you are interested in learning more, check out the *More about
    Animations* section later in the chapter).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Avatar**：仅适用于3D人形角色参数，您可以忽略它（然而，如果您想了解更多，请查看本章后面的*关于动画的更多信息*部分）。'
- en: '**Apply Root Motion**: You can ignore this too (however, if you are interested
    in the learning more, check out the *More about Animations* section).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用根运动**：您也可以忽略这一点（然而，如果您想了解更多，请查看*关于动画的更多信息*部分）。'
- en: '**Update Mode**: Specifies when the Animator is updated and which timescale
    it should use. The **Normal** mode updates the controller in sync with the update
    calls, and the Animator''s speed matches the current timescale. If the timescale
    is slowed, animations will slow down to match. The **Animate Physics** mode instead
    updates the Animator in sync with the **FixedUpdate** calls, which are used by
    the Physic engine. This is useful when the object you are animating has a physical
    interaction, for instance, if a character needs to push or pull a rigid body (more
    about Physics in the next chapter). Finally, the **Unscaled Time** mode updates
    the Animator in sync with the Update calls, like the **Normal** mode, but the
    current timescale is ignored and it always plays at 100% of its speed. For instance,
    this mode is useful when you pause the game but you still want to animate part
    of the UI or the pause menu itself.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新模式**：指定Animator何时更新以及它应该使用哪个时间尺度。**正常**模式与更新调用同步更新控制器，Animator的速度与当前时间尺度匹配。如果时间尺度减慢，动画也会减慢以匹配。**Animate
    Physics**模式则相反，它与**FixedUpdate**调用同步更新Animator，这些调用由物理引擎使用。这在您所动画化的对象具有物理交互时很有用，例如，如果角色需要推动或拉动一个刚体（关于物理的更多内容将在下一章中介绍）。最后，**Unscaled
    Time**模式与更新调用同步更新Animator，就像**正常**模式一样，但当前时间尺度被忽略，它总是以100%的速度播放。例如，当您暂停游戏但仍然想要动画化部分UI或暂停菜单本身时，此模式很有用。'
- en: '**Culling Mode**: Specifies the culling mode for animations (more on this in
    the *More about Animations* section later in the chapter).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剔除模式**：指定动画的剔除模式（关于这一点将在本章后面的*关于动画的更多信息*部分中详细介绍）。'
- en: Furthermore, at the bottom of the Animator component, there is an information
    box with some useful information about the Animator controller we are using. For
    now, the only information that is relevant is **Clip Count**, which tells you
    how many animation clips are used by the controller. You can find out more about
    this information box in the *More about Animations* section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Animator组件的底部，有一个包含有关我们使用的Animator控制器一些有用信息的信息框。目前，唯一相关的信息是**剪辑数量**，它告诉您控制器使用了多少个动画剪辑。您可以在*关于动画的更多信息*部分了解更多关于这个信息框的内容。
- en: '![The Animator component](img/image00457.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Animator组件](img/image00457.jpeg)'
- en: Creating the other animation clips
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建其他动画剪辑
- en: Now, we need to create the remaining animation clips respectively for when the
    pandas die, eat or get hit. This time, we want to do it without generating the
    controller. We have two choices. In the first, we still keep dragging and dropping
    the other groups of Sprites onto the **Panda** game object as we did previously.
    As a result, Unity will still ask to give a name and a location for the animation
    clip, but it won't generate another controller. This is the fastest way. However,
    there is another one. It involves the **Animation** window, but for the sake of
    learning we will use this second method to create the remaining Animation clips.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要分别为熊猫死亡、吃或被击中时创建剩余的动画片段。这次，我们不想生成控制器。我们有两种选择。第一种，我们仍然像之前那样将其他组精灵拖放到**熊猫**游戏对象上。结果，Unity仍然会要求为动画片段命名和指定位置，但不会生成另一个控制器。这是最快的方法。然而，还有另一种方法。它涉及到**动画**窗口，但为了学习，我们将使用第二种方法来创建剩余的动画片段。
- en: 'To do so, open the **Animation** windows (click on the top bar menu on **Window**
    | **Animation** or use the shortcut *Ctrl* + **6**). Then, select your **Panda**
    from the **Hierarchy** panel. You should see something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，打开**动画**窗口（点击**窗口**菜单栏上的**动画**或使用快捷键*Ctrl* + **6**）。然后，从**层次结构**面板中选择你的**熊猫**。你应该会看到如下内容：
- en: '![Creating the other animation clips](img/image00458.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画片段](img/image00458.jpeg)'
- en: 'The **Animation** window allows you to create animations within Unity. It uses
    interpolation techniques between key frames to compute the position and rotation
    (along with other parameters) between each frame. It also supports a recording
    functionality as well as a curve editor. In 2D game development, this is not much
    used if animation Sprite Sheets are available, like our case (unless you need
    to fine-tune the animation). Yet, this is an important tool that avoids the need
    for third-party programs to create your animations. Also, it is useful for prototyping
    animations. Unfortunately, we don''t have enough room in this chapter to talk
    in detail about the **Animation** window, but you can read more about it in the
    official documentation here: [https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html](https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画**窗口允许你在Unity中创建动画。它使用关键帧之间的插值技术来计算每帧之间的位置和旋转（以及其他参数）。它还支持录制功能以及曲线编辑器。在2D游戏开发中，如果可用动画精灵表（如我们的情况），则不太使用此功能（除非你需要微调动画）。然而，这是一个重要的工具，可以避免需要第三方程序来创建你的动画。此外，它还适用于原型设计动画。不幸的是，我们在这章中没有足够的空间详细讨论**动画**窗口，但你可以在官方文档中了解更多信息：[https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html](https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html)。'
- en: 'In our case, however, we will use it just to create and save animation clips
    starting from our Sprites. As we can notice from the preceding picture, there
    is already the Walk animation created in the last section. To create a new animation
    clip, click on **Panda_Walk_Animation** and a drop-down menu like the following
    should appear:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，我们只是用它来从我们的精灵开始创建和保存动画片段。正如我们可以从前面的图片中注意到的那样，在上一个部分中已经创建了一个行走动画。要创建一个新的动画片段，点击**Panda_Walk_Animation**，应该会出现如下下拉菜单：
- en: '![Creating the other animation clips](img/image00459.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画片段](img/image00459.jpeg)'
- en: 'Click on **Create New Clip...** and Unity will ask you where to save this new
    file and its name. We can name it `Panda_Die_Animation` and save it within the
    `Animations` folder. As a result, the **Animation** window should now be cleared,
    as shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建新片段...**，Unity会询问你保存新文件的位置和名称。我们可以将其命名为`Panda_Die_Animation`并在`Animations`文件夹中保存。结果，**动画**窗口现在应该已经清空，如图所示：
- en: '![Creating the other animation clips](img/image00460.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画片段](img/image00460.jpeg)'
- en: 'Now, we can select the Sprites of the die animation, and drag and drop them
    within the window. Thus, the Sprite animation is loaded within the animation file,
    as we can see from the Animation window:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择死亡动画的精灵，并将它们拖放到窗口中。因此，精灵动画被加载到动画文件中，正如我们可以从动画窗口中看到的那样：
- en: '![Creating the other animation clips](img/image00461.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画片段](img/image00461.jpeg)'
- en: 'We need to repeat the process to create the Hit and Eat animations. At the
    end, you should have the following files in the `Animations` folder:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重复这个过程来创建击中和吃动画。最后，你应该在`Animations`文件夹中有以下文件：
- en: '![Creating the other animation clips](img/image00462.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画片段](img/image00462.jpeg)'
- en: One more thing. If you click on one of them, in the **Inspector**, you can see
    some options about whether the animation can be played in loop and how, along
    with an information box with some the amount of certain kind of data for the animation,
    such as how many muscles (but this is for 3D animation, and we won't use this
    information).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点要注意。如果你点击其中一个，在**检查器**中，你可以看到一些选项，关于动画是否可以循环播放以及如何播放，还有一个信息框，显示动画的一些数据量，例如肌肉数量（但这是针对3D动画的，我们不会使用这些信息）。
- en: '![Creating the other animation clips](img/image00463.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画剪辑](img/image00463.jpeg)'
- en: 'Not all our animations are supposed to be played in loop. In fact, all but
    the walk animations are not supposed to loop. Therefore, for them, just uncheck
    the **Loop Time** variable in the **Inspector**, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的动画都旨在循环播放。实际上，除了走路动画之外，其他所有动画都不应该循环播放。因此，对于它们，只需在**检查器**中取消勾选**Loop Time**变量，就像这样：
- en: '![Creating the other animation clips](img/image00464.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建其他动画剪辑](img/image00464.jpeg)'
- en: So far so good. Before you proceed, I advise you to create a new prefab in the
    `Prefab` folder, called `PandaPrefab`, and drag your **Panda** there.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。在你继续之前，我建议你在`Prefab`文件夹中创建一个新的预制件，命名为`PandaPrefab`，并将你的**熊猫**拖放到那里。
- en: The Animator
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画师
- en: Imagine all of the different types of actions that you perform throughout the
    day-from the moment you wake up, to making coffee, having a shower, and getting
    ready for work. Each of these would have a different animation. The same goes
    for characters. In most games, characters or other animated objects (animals,
    trees, and so on) have a range of animations. Just like our example before, each
    animation will correspond to a different moment during gameplay. For example,
    when a character is just standing and being idle, they aren't doing much, but
    it is likely that they are still breathing. In some games, if characters remain
    idle for an extended period of time, other animation sequences are then triggered,
    such as impatient foot tapping or something completely unexpected. In first-person
    shooters, objects within the game environment may have the ability to be affected
    by things such as bullets or force (such as running hard into a wall), and as
    a result, they might break, crack, open, or even close. Mecanim uses a visual
    layout system similar to a flowchart to represent a state machine and enable you
    to control and sequence the animation clips that you want to use on your character
    or object. We will discuss this in more detail later.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你一天中执行的所有不同类型的动作——从你醒来，到煮咖啡、洗澡、准备上班。每个动作都会有不同的动画。对于角色来说也是如此。在大多数游戏中，角色或其他动画对象（动物、树木等）都有一系列动画。就像我们之前的例子一样，每个动画都会对应游戏过程中的不同时刻。例如，当一个角色只是站立并处于闲置状态时，他们并没有做什么，但他们很可能会继续呼吸。在一些游戏中，如果角色长时间闲置，那么就会触发其他动画序列，比如不耐烦的脚趾敲击或完全出乎意料的事情。在第一人称射击游戏中，游戏环境中的物体可能能够被子弹或力量（比如用力撞墙）影响，因此它们可能会破碎、开裂、打开或甚至关闭。Mecanim使用类似于流程图的视觉布局系统来表示状态机，并允许你控制并编排你想要在角色或对象上使用的动画剪辑。我们将在稍后详细讨论这一点。
- en: The Animator window
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画师窗口
- en: The Animator window allows you to create, view, and modify Animator Controller
    assets within Unity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 动画师窗口允许你在Unity中创建、查看和修改动画控制器资产。
- en: 'Now that we have all our animation files, we need to embed them within the
    Animator Controller in a meaningful way. If you double-click on `PandaAnimatorController`,
    the **Animator** window opens, and you should have a screen similar to the following
    one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有的动画文件，我们需要以有意义的方式将它们嵌入到动画控制器中。如果你双击`PandaAnimatorController`，动画师窗口就会打开，你应该有一个类似于以下屏幕的界面：
- en: '![The Animator window](img/image00465.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![动画师窗口](img/image00465.jpeg)'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you don't see your panda animations within rectangles, like the preceding
    image, it is probably because you have created the animation clips without having
    the animation window linked to a controller. That is not a problem; you just need
    to select the animation clips you want in the controller and drag them into the
    **Animator** window, and they will be added.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在矩形框内看不到你的熊猫动画，就像前面的图片那样，可能是因为你没有将动画窗口链接到控制器就创建了动画剪辑。这不是问题；你只需要在控制器中选择你想要的动画剪辑，并将它们拖入**动画师**窗口，它们就会被添加。
- en: The **Animator** window is divided into two sections. The main section with
    the dark gray grid is the layout area. You can use this area to create, arrange,
    and connect states in your Animator Controller.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画器**窗口分为两个部分。深灰色网格的主区域是布局区域。您可以使用此区域在您的动画控制器中创建、排列和连接状态。'
- en: 'You can right-click on the grid to create a new state node. Using the middle
    mouse button or ***Alt*** /Option, drag to pan the view around. Click to select
    state nodes, so as to edit them in the **Inspector**, and click and drag state
    nodes to rearrange the layout of your state machine, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网格上右键单击以创建一个新的状态节点。使用中间鼠标按钮或***Alt*** /Option，拖动以在视图中平移。点击以选择状态节点，以便在**检查器**中编辑它们，并点击并拖动状态节点以重新排列状态机的布局，如下所示：
- en: '![The Animator window](img/image00466.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![动画器窗口](img/image00466.jpeg)'
- en: In this way, our state machine will be clearer and tidy for what we are going
    to do. The second section of the **Animator** window is the left-hand pane, which
    can be switched between the **Parameters** tab and **Layers** tab (if you want
    to learn more about layers, you can read the optional section of this chapter,
    **Layers** in the **Animator**, inside the *More about Animations* section). The
    **Parameters** tab allows you to create, view, and edit the Animator Controller
    parameters. These are variables that you define, which will then act as inputs
    into the state machine. We will see them in detail soon.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的状态机将更加清晰和整洁，以便我们进行操作。**动画器**窗口的第二部分是左侧面板，可以在**参数**选项卡和**层**选项卡之间切换（如果您想了解更多关于层的信息，可以阅读本章的可选部分，*更多关于动画*部分中的**动画器**中的**层**）。**参数**选项卡允许您创建、查看和编辑动画控制器参数。这些是您定义的变量，它们将作为输入进入状态机。我们很快就会详细了解它们。
- en: Also, toggling the eye icon on or off (highlighted in the next image to easily
    locate it) will show or hide the **Parameters** and **Layers** side pane, allowing
    you more room to see and edit your state machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，打开或关闭眼睛图标（在下一张图片中突出显示以便轻松定位）将显示或隐藏**参数**和**层**侧边栏，这为您提供了更多空间来查看和编辑您的状态机。
- en: '![The Animator window](img/image00467.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![动画器窗口](img/image00467.jpeg)'
- en: Furthermore, if we enable the lock icon (as in the next image) in the top-right
    corner, we are able to keep the **Animator** window focused on the current state
    machine. If the lock icon is disabled, clicking on a new Animator asset or a Game
    Object with an Animator component will switch the **Animator** window. As a result,
    we are then able to show that item's state machine. The benefit of locking the
    window is that it allows us to keep the **Animator** window from showing the same
    state machine, regardless of what assets or Game Objects are selected.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们启用右上角的上锁图标（如下一张图片所示），我们就能使**动画器**窗口始终聚焦于当前状态机。如果上锁图标被禁用，点击新的动画器资产或带有动画组件的游戏对象将切换**动画器**窗口。因此，我们就能展示该对象的州机。锁定窗口的好处是，它允许我们保持**动画器**窗口不显示相同的州机，无论选择了哪些资产或游戏对象。
- en: '![The Animator window](img/image00468.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![动画器窗口](img/image00468.jpeg)'
- en: 'The last useful toggle (located just below the lock icon) is **Auto Live Link**,
    which allows us to see the machine in action at runtime. For your convenience,
    it is highlighted in the following image, but we will talk more about it when
    we need to test the machine we are building up:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有用的切换（位于上锁图标下方）是**自动实时链接**，它允许我们在运行时看到机器的实际运行情况。为了您的方便，它在以下图片中突出显示，但当我们需要测试我们正在构建的机器时，我们会更多地讨论它：
- en: '![The Animator window](img/image00469.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![动画器窗口](img/image00469.jpeg)'
- en: The Animator state machine
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画器状态机
- en: 'As we already have mentioned, the Animator controller is a flowchart system;
    specifically it is a kind of finite-state machine. But what is a finite-state
    machine? From Wikipedia, we can read:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，动画控制器是一个流程图系统；具体来说，它是一种有限状态机。但什么是有限状态机？从维基百科，我们可以读到：
- en: '*"A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata),
    or simply a state machine, is a mathematical model of computation used to design
    both computer programs and sequential logic circuits. It is conceived as an abstract
    machine that can be in one of a finite number of states. The machine is in only
    one state at a time; the state it is in at any given time is called the current
    state. It can change from one state to another when initiated by a triggering
    event or condition; this is called a transition. A particular FSM is defined by
    a list of its states, its initial state, and the triggering condition for each
    transition."*'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"有限状态机（FSM）或有限状态自动机（FSA，复数：automata），或简单地称为状态机，是一种用于设计计算机程序和时序逻辑电路的计算数学模型。它被构想为一个可以处于有限多个状态之一的抽象机器。机器在任何给定时间只处于一个状态；它在任何给定时间所处的状态称为当前状态。当由触发事件或条件启动时，它可以从一个状态转换到另一个状态；这称为转换。特定的FSM由其状态列表、初始状态以及每个转换的触发条件定义。"*'
- en: In our specific cases, the states will be the animations. So, saying that our
    Animator is a specific state means that the Game Object with that Animator controller
    is playing that specific animation. If it is not completely clear right now, it
    will be a while before we explain the different parts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定情况下，状态将是动画。所以，说我们的动画师是特定的状态意味着具有该动画师控制器的游戏对象正在播放该特定动画。如果现在还不完全清楚，我们将在稍后解释不同的部分。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will explore finite-state machines a bit more in detail later in the book,
    when we deal with Artificial Intelligence.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分更详细地探讨有限状态机，当我们处理人工智能时。
- en: Unity generated an Animator controller for us when we created the first Animation
    clip. But if you need to manually create it, here's how to do it. From the **Project**
    panel (possibly within a meaningful folder, such as `Animations`), right-click
    and select **Create** | **Animator Controller**. Once renamed, double-click on
    it to open it in the **Animator** window. Contrary to the automatically generated
    controller, which already contains all the states of our Panda animation, here
    there are no such states. In fact, we need to manually import them. In the case
    of our Pandas, we just need to select the animations file that we have created
    before from the **Project** panel and drag them into the grid of the **Animator**
    window. If you remember, we stored them inside the `Animations` folder. Always
    remember that you can move any state just by dragging it. This is useful, because
    you can reorganize states so as to have a visual order and improve the readability
    of your work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建第一个动画剪辑时，Unity为我们生成了一个动画师控制器。但如果你需要手动创建它，这里是如何做的。从**项目**面板（可能在一个有意义的文件夹中，例如`Animations`），右键单击并选择**创建**
    | **动画师控制器**。一旦重命名，双击它以在**动画师**窗口中打开它。与自动生成的控制器不同，它已经包含了我们熊猫动画的所有状态，这里没有这样的状态。实际上，我们需要手动导入它们。在我们的熊猫案例中，我们只需要从**项目**面板中选择我们之前创建的动画文件，并将它们拖放到**动画师**窗口的网格中。如果你记得，我们把它们存储在`Animations`文件夹中。始终记住，你可以通过拖动来移动任何状态。这很有用，因为你可以重新组织状态，以便有一个视觉顺序并提高你工作的可读性。
- en: Now, it's time to dig deeper and see how to actually build an animation machine
    for our pandas. If you created a new Animator controller, discard it, and let's
    take the one we had before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候深入挖掘，看看如何为我们的熊猫实际构建一个动画机。如果你创建了一个新的动画师控制器，请丢弃它，让我们使用之前的一个。
- en: The Animator states
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画师状态
- en: Animations bring characters to life, and therefore Animation states provide
    the foundations for the Animation State Machine within Unity. Each state contains
    an individual animation sequence (or blend tree), such as running, walking, climbing,
    jumping, and so on. All these animation sequences will then be triggered and subsequently
    played when the character is in that respective state. When an event in the game
    triggers a state transition, such as the player jumps over a ledge while running,
    the character will be left in a new state whose animation sequence will then take
    over.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 动画使角色栩栩如生，因此动画状态为Unity中的动画状态机提供了基础。每个状态都包含一个独立的动画序列（或混合树），例如跑步、行走、攀爬、跳跃等。所有这些动画序列将在角色处于相应状态时被触发并播放。当游戏中的事件触发状态转换，例如玩家在跑步时跳过边缘，角色将保持在新的状态，其动画序列将随后接管。
- en: 'When you select a state in the Animator Controller, you will see the properties
    for that state in the inspector, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在动画师控制器中选择一个状态时，你将在检查器中看到该状态的属性，如图所示：
- en: '![The Animator states](img/image00470.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![动画状态](img/image00470.jpeg)'
- en: 'These properties and their functions are listed here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性及其功能在此列出：
- en: '**Name**: Is just how the state will be referred in the Animator, and it is
    also the name showed on top of the state. If it is automatically generated from
    an animation, as a default, it will have the same name of the animation clip.
    In fact, our four panda states have the same names as their respectively animation
    clips.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：这是在Animator中引用状态的方式，也是显示在状态顶部的名称。如果它是从动画自动生成的，默认情况下，它将具有与动画片段相同的名称。实际上，我们的四个熊猫状态与它们的相应动画片段具有相同的名称。'
- en: '**Tag**: Just another way to identify a state or a set of them. It is useful
    when you need to control animation machines from a script. For our purposes, we
    can leave it in blank.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：识别状态或一组状态的一种方式。当需要从脚本中控制动画机器时很有用。就我们的目的而言，我们可以将其留空。'
- en: '**Motion**: This is the animation clip assigned to this state, for example,
    one of the animation clips that we have created before, such as `Panda_Walk_Animation`
    or `Panda_Die_Animation` (actually, it can also be a blending tree; see the optional
    section *More about animations* later in the chapter).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：这是分配给此状态的动作片段，例如，我们之前创建的动画片段之一，如`Panda_Walk_Animation`或`Panda_Die_Animation`（实际上，它也可以是一个混合树；请参阅本章后面的可选部分*更多关于动画*）。'
- en: '**Speed**: The default speed of the animation. For example, the default speed
    of an animation may be too slow, such as a running animation, and therefore, the
    speed needs to be increased. By changing the value of **Speed**, the animation
    is able to player faster.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：动画的默认速度。例如，动画的默认速度可能过慢，比如跑步动画，因此需要提高速度。通过改变**速度**的值，动画可以播放得更快。'
- en: '**Multiplier**: A number that is multiplied by **Speed** to increase it or
    decrease it. Next to it, there is the parameter checkbox. This allows us to transform
    this number into an animator parameter (please also note that the multiplier cannot
    have an independent value, but just be linked to a float parameter). In this way,
    we can control the speed of some animations, without touching the **Speed** settings
    (given that all of them are linked to the same parameter).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘数**：一个乘以**速度**的数字，以增加或减少速度。旁边有一个参数复选框。这允许我们将这个数字转换为动画参数（请注意，乘数不能有独立的价值，只能链接到浮点参数）。这样，我们可以控制某些动画的速度，而无需触摸**速度**设置（假设它们都链接到相同的参数）。'
- en: '**Mirror**: Should the state be mirrored, which means if the animation clip
    should be played like in a mirror, exchanging left with right and vice versa.
    This is only applicable to 3D humanoid animations, and therefore we won''t deal
    with it. Note that can be transformed into a parameter Boolean.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：是否应该镜像状态，这意味着动画片段应该像镜子中播放，左右互换。这仅适用于3D人形动画，因此我们不会处理它。注意，这可以转换为布尔参数。'
- en: '**Cycle Offset**: Determines if the animation loop should start to a different
    point, and the value indicates the offset from the beginning of the animation.
    Also this acts as a **Multiplier** and can be set to be a parameter.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环偏移**：确定动画循环是否应该从不同的点开始，该值表示从动画开始处的偏移量。此外，它还充当**乘数**，可以设置为参数。'
- en: '**Foot IK**: Should **Foot IK** be respected for this state? This is applicable
    to 3D humanoid animations, so we won''t deal with it.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**足部逆运动学**：是否应该尊重此状态的**足部逆运动学**？这适用于3D人形动画，因此我们不会处理它。'
- en: '**Write Defaults**: This decides whether or not AnimatorStates writes back
    the default values for properties that are not animated by its motion. By default,
    it is set to true, but unchecking it means that the non-animated properties of
    a state will keep the value they had previously.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入默认值**：这决定了AnimatorStates是否将默认值写回未由其动作动画化的属性。默认情况下，它设置为true，但取消选中它意味着状态的非动画属性将保持它们之前的价值。'
- en: '**Transitions**: The list of transitions originating from this state. It is
    equivalent to identify under which conditions this state changes into another
    one. We will see transitions in detail in a couple of sections.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡**：从这个状态起源的过渡列表。它等同于确定在什么条件下这个状态会变成另一个状态。我们将在接下来的几个部分中详细讨论过渡。'
- en: '**Add Behaviour**: For the description of this button see the optional section
    *More about Animations* later in the chapter.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加行为**：关于此按钮的描述请参阅本章后面的可选部分*更多关于动画*。'
- en: The default state, displayed in brown, is the state that the machine will be
    in when it is first activated. If you want, you are able to change the default
    state of the state machine by right-clicking on another state and selecting **Set
    As Layer Default State** from the context menu.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认状态，以棕色显示，是机器首次激活时将处于的状态。如果你想，你可以通过在另一个状态上右键单击并从上下文菜单中选择**设置为层默认状态**来更改状态机的默认状态。
- en: '![The Animator states](img/image00471.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![动画状态](img/image00471.jpeg)'
- en: In our case, the default state is the **Panda_Walk_Animation** state, so be
    sure that it is selected as the default state. In addition, to add a new state,
    right-click on an empty space in the **Animator Controller** window and navigate
    to **Create State** | **Empty** from the context menu. Another way to create a
    state, as we have already pointed out, is to drag an animation into the **Animator
    Controller** window, and as a result, you will create a state containing that
    animation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，默认状态是**Panda_Walk_Animation**状态，所以请确保它被选为默认状态。此外，要添加新状态，在**Animator
    Controller**窗口的空白区域右键单击，并从上下文菜单导航到**创建状态** | **空**。另一种创建状态的方法，正如我们之前指出的，是将动画拖入**Animator
    Controller**窗口，结果，你将创建包含该动画的状态。
- en: As far as our panda's animation states are concerned, we don't have particular
    needs or settings to tweak. After all, what we are building is a relatively simple
    finite state machine compared to big, complex 3D animation machines. But, if at
    any moment you feel that one of the four animations that we have is too fast or
    too slow, just select it and change its speed. In that case, you can do it at
    the end, when we finish the state machine, so as to have better and complete vision
    of the panda animation as a whole, and tweak these values to improve it. For instance,
    I slowed down the walking, hit, and eat animation to 25%, which means a speed
    of 0.25, whereas for the die animation, I used 0.2\. Usually you find these values
    by trial and error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们熊猫的动画状态而言，我们没有特别的需要或设置去调整。毕竟，我们构建的是一个相对简单的有限状态机，与大型、复杂的3D动画机器相比。但是，如果你在任何时候觉得我们拥有的四个动画中有一个太快或太慢，只需选择它并改变其速度。在这种情况下，你可以在我们完成状态机之后进行，以便更好地全面了解熊猫动画，并调整这些值来改进它。例如，我将行走、击打和进食动画的速度减慢到25%，这意味着速度为0.25，而对于死亡动画，我使用了0.2。通常，你通过试错来找到这些值。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you can only drag Mecanim animations into the controller; non-Mecanim
    animations will be rejected. Moreover, states do not necessarily contain single
    animation clips. In fact, they could also contain Blend Trees. You can read more
    about them in the optional section, *More about Animations*, later in the chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你只能将Mecanim动画拖入控制器；非Mecanim动画将被拒绝。此外，状态不一定只包含单个动画剪辑。实际上，它们也可能包含混合树。你可以在本章后面的可选部分*关于动画的更多内容*中了解更多关于它们的信息。
- en: Special states
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特殊状态
- en: 'An animator machine also has some special states, which are presented in this
    image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 动画机也有一些特殊状态，如图中所示：
- en: '![Special states](img/image00472.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![特殊状态](img/image00472.jpeg)'
- en: '**Any State** is a special state that is always present. **Any State** implies
    that it cannot be the end point of a transition. For example, jumping to *any
    state* cannot be used as a way to pick a random state to enter the next. **Any
    State** exists for the situation where you want to go to a specific state regardless
    of which state you are currently in. This is a simpler way of adding the same
    outward transition to all states in your machine. **Entry** and **Exit** are states
    that determine the beginning and the end of the Animation State Machine.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何状态**是一个始终存在的特殊状态。**任何状态**意味着它不能是转换的终点。例如，跳转到*任何状态*不能用作选择随机状态进入下一状态的方法。**任何状态**存在于你想无论当前处于哪个状态都要进入特定状态的情况。这是向你的机器中添加相同的外部转换的更简单方式。**进入**和**退出**是确定动画状态机开始和结束的状态。'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other special states to handle sub-machines. For more information,
    check out the *More about Animation* section later on in the chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他特殊状态来处理子机。有关更多信息，请参阅本章后面的*关于动画的更多内容*部分。
- en: The animator parameters
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画参数
- en: 'As we already introduced before, on the left-hand side of the **Animator**
    window, there are two tabs: **Layers**, which we won''t deal with here (but I
    remind you that you can read the optional *Layers in the Animator* section), and
    **Parameters**, which we will learn in this section.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所介绍，在**动画器**窗口的左侧，有两个标签页：**层**，这里我们不会处理（但我提醒你，你可以阅读可选的*动画器中的层*部分），以及**参数**，我们将在本节中学习。
- en: '![The animator parameters](img/image00473.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![动画器参数](img/image00473.jpeg)'
- en: Animation **Parameters** are variables that are defined within an **Animator
    Controller**. These parameters can be accessed and their values assigned from
    scripts. As a result, scripts can control or affect the flow of the state machine.
    For example, a script can set a parameter that indicates how fast an animation
    should be played, such as running or walking; these can be the same animation,
    just played at different speed. In a more sophisticated behavior, the same parameter
    can be a condition to switch between a proper walking animation and a running
    one, based on the player's input.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 动画**参数**是在**动画控制器**内定义的变量。这些参数可以从脚本中访问并分配它们的值。因此，脚本可以控制或影响状态机的流程。例如，脚本可以设置一个参数，指示动画应该播放多快，例如跑步或行走；这些可以是相同的动画，只是以不同的速度播放。在更复杂的行为中，相同的参数可以是根据玩家的输入在合适的行走动画和跑步动画之间切换的条件。
- en: 'To add a parameter, click on the small + button, as highlighted in this picture:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个参数，点击图中突出显示的小+按钮：
- en: '![The animator parameters](img/image00474.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![动画器参数](img/image00474.jpeg)'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, if you want to delete a parameter, select the parameter in the lists
    and press the *Delete* key.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想删除一个参数，请在列表中选择该参数，然后按*删除*键。
- en: 'A drop-down menu appears, asking which kind of parameter we want to add:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 出现一个下拉菜单，询问我们想添加哪种类型的参数：
- en: '![The animator parameters](img/image00475.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![动画器参数](img/image00475.jpeg)'
- en: 'They can be of four basic types:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以是四种基本类型：
- en: '`Int`: An integer (whole number)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`：一个整数（整个数）'
- en: '`Float`: A number with a decimal part'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float`：一个带有小数部分的数字'
- en: '`Bool`: A true or false value (represented by a checkbox)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool`：一个真或假值（由复选框表示）'
- en: '`Trigger`: A Boolean parameter that is reset by the controller when consumed
    by a transition (represented by a circle button)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trigger`：一个布尔参数，当被过渡消耗时由控制器重置（由圆形按钮表示）'
- en: 'Parameters can be assigned values from a script using functions in the `Animator`
    class, specifically with the following self-explanatory functions: `SetFloat()`,
    `SetInt()`, `SetBool()`, `SetTrigger()`, and `ResetTrigger()`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Animator`类中的函数从脚本中为参数分配值，具体来说，以下函数具有自解释性：`SetFloat()`、`SetInt()`、`SetBool()`、`SetTrigger()`和`ResetTrigger()`。
- en: As we have already seen, parameters can be linked to transition conditions or
    even to state variables (such as the speed multiplier), and then be controlled
    by scripts. To give an example, imagine the heroine of your game is riding a horse.
    A script can change a float parameter, which is linked to the speed multiplier
    of the galloping horse animation, based on how much the player spurs the horse.
    As a result, the animation of the horse will change in real time, based on the
    player input (if the player is controlling your heroine), and the horse will move
    faster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，参数可以链接到过渡条件，甚至可以链接到状态变量（例如速度乘数），然后由脚本控制。以一个例子来说明，假设你的游戏中的女主角正在骑马。脚本可以根据玩家踢马的程度改变一个浮点参数，该参数与奔跑动画的速度乘数相链接。结果，马的动作将根据玩家的输入（如果玩家正在控制你的女主角）实时改变，马会跑得更快。
- en: 'However, for our Tower Defense game, we just need triggers, in particular,
    three: one for when the panda is hit, another one when it reaches the end and
    eats the cake, and the last one when it dies under sprinkles hit. We can respectively
    name them `HitTrigger`, `EatTrigger`, and `DieTrigger`. At the end, you should
    see the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的塔防游戏，我们只需要触发器，特别是三个：一个用于熊猫被击中时，另一个用于它到达终点并吃掉蛋糕时，最后一个用于它在被喷溅击中时死亡。我们可以分别将它们命名为`HitTrigger`、`EatTrigger`和`DieTrigger`。最后，你应该看到以下内容：
- en: '![The animator parameters](img/image00476.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![动画器参数](img/image00476.jpeg)'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, this is not the only way to implement this system. Refer to the *State
    machine behaviours* section later to learn how to use behaviours within a state
    so that in the *Homework* section you can test yourself with this new technique
    in order to implement this kind of behaviours in a different way.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是实现此系统的唯一方法。请参阅后面的*状态机行为*部分，了解如何在状态内使用行为，以便在*作业*部分您可以使用这种新技术进行自我测试，以以不同的方式实现此类行为。
- en: The animator transitions
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画师过渡
- en: Transitions allow us to change from one state of the Finite State Machine into
    another one. They can be triggered when certain conditions are met. As the name
    suggests, they handle how the current state transits into the destination state
    and how these two should be merged to have a smooth transition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡使我们能够从有限状态机的当前状态切换到另一个状态。当满足某些条件时，它们可以被触发。正如其名称所暗示的，它们处理当前状态如何过渡到目标状态以及这两个状态应该如何合并以实现平滑过渡。
- en: 'They are represented as mono-directional arrows between two states. To create
    a new transition between two state, right-click from the state where the transition
    should start (in our case, `Panda_Walk_Animation`) and select **Make Transition**,
    as shown in this screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它们表示为两个状态之间的单向箭头。要创建两个状态之间的新过渡，请从过渡应开始的状态（在我们的案例中，`Panda_Walk_Animation`）右键单击并选择**创建过渡**，如图所示：
- en: '![The animator transitions](img/image00477.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![动画过渡](img/image00477.jpeg)'
- en: 'Then click on another state to make the transition between them. In this example,
    we are doing a transition from `Panda_Walk_Animation` to `Panda_Hit_Animation`,
    as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后单击另一个状态以创建它们之间的过渡。在这个例子中，我们正在从`Panda_Walk_Animation`过渡到`Panda_Hit_Animation`，如图所示：
- en: '![The animator transitions](img/image00478.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![动画过渡](img/image00478.jpeg)'
- en: Transition settings
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过渡设置
- en: 'If you click on the arrow, you can see the transition settings/properties in
    the **Inspector**, like the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击箭头，您可以在**检查器**中看到过渡设置/属性，如下面的截图所示：
- en: '![Transition settings](img/image00479.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![过渡设置](img/image00479.jpeg)'
- en: 'If you wish, you can assign a name to the transition, by typing it in the field
    shown next (you need to press *Enter* to confirm your choice):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以通过在下面的字段中输入来为过渡分配一个名称（您需要按*Enter*键来确认您的选择）：
- en: '![Transition settings](img/image00480.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![过渡设置](img/image00480.jpeg)'
- en: 'As a result, its name will be shown in the state that contains that transition
    (for instance, in our example, within the `Panda_Walk_Animation` state):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，其名称将在包含该过渡的状态中显示（例如，在我们的例子中，在`Panda_Walk_Animation`状态内）：
- en: '![Transition settings](img/image00481.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![过渡设置](img/image00481.jpeg)'
- en: Renaming transition is your choice. Someone prefers to give proper names, someone
    else references to it as initial and final state, which is the default name. However,
    if you decide to rename them, remember to give meaningful names; it doesn't matter
    if they are long.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名过渡是您的选择。有人喜欢给出合适的名称，有人则将其引用为初始状态和最终状态，这是默认名称。然而，如果您决定重命名它们，请记住给出有意义的名称；它们是否长无关紧要。
- en: Let's cover in detail each of these settings so as to have a better understanding
    of what they mean. Keep in mind that some of them refer to certain conditions,
    which we will explore soon.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明每个设置，以便更好地理解它们的含义。请记住，其中一些设置涉及特定条件，我们将在不久后探讨。
- en: '**Has Exit Time**: If this is set to true, the transition can only happen at
    the time specified in the **Exit Time** variable.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有退出时间**：如果此设置为true，则过渡只能在**退出时间**变量指定的时刻发生。'
- en: '**Exit Time**: If **Has Exit Time** is enabled, this value represents the exact
    time for the transition to take effect. This is represented in normalized time
    (percentage value); so, for example, an exit time of 0.65 means that on the first
    frame where 65% of the animation has played, the **Exit Time** condition will
    be true. On the next frame, the condition will be false. For looped animations,
    transitions with exit times smaller than 1 will be evaluated on every loop, so
    you can use this to time your transition with the proper timing in the animation,
    for every loop. Transitions with exit times greater than 1 will be evaluated only
    once, so they can be used to exit at a specific time-after a fixed number of loops.
    For example, a transition with an exit time of 4.5 will be evaluated once, after
    four and a half loops.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出时间**：如果启用了**Has Exit Time**，此值表示过渡生效的确切时间。这以归一化时间（百分比值）表示；因此，例如，退出时间为0.65表示在动画播放了65%的第一帧时，**退出时间**条件为真。在下一帧，条件将为假。对于循环动画，具有小于1的退出时间的过渡将在每个循环中评估，因此您可以使用此功能在动画的每个循环中根据适当的时机进行过渡。具有大于1的退出时间的过渡将只评估一次，因此它们可以用于在固定数量的循环后退出。例如，退出时间为4.5的过渡将只评估一次，在四个半循环之后。'
- en: '**Fixed Duration**: If enabled, the transition time is interpreted in seconds;
    otherwise, it is interpreted in a percentage between 0 and 1 (normalized time),
    such as 0.5, which would represent 50%.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定持续时间**：如果启用，过渡时间以秒为单位解释；否则，它以0到1之间的百分比（归一化时间）解释，例如0.5，它将表示50%。'
- en: '**Transition Duration**: This is the duration of the transition. This will
    also determine the length between the two blue markers in the Transition Graph
    (see the next section).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡持续时间**：这是过渡的持续时间。这还将确定过渡图中两个蓝色标记之间的长度（参见下一节）。'
- en: '**Transition Offset**: This is the offset of the time where the animation (in
    the destination state that is transitioned to) begins to play. For example, a
    value of 0.4 would mean the target state will begin playing at 40% of the way
    through its own timeline.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡偏移**：这是动画（过渡到的目标状态）开始播放的时间偏移。例如，值为0.4表示目标状态将在自己的时间线的40%处开始播放。'
- en: '**Interrupt Source**: This allows you to control the circumstances that allow
    a transition to interrupt the current one. In particular, you can select five
    different modes:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断源**：这允许您控制允许过渡中断当前过渡的环境。特别是，您可以选择五种不同的模式：'
- en: '**None** won''t allow anything to interrupt the transition.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**将不允许任何内容中断过渡。'
- en: '**Current State** allows only transitions, within the current state, to interrupt
    the transition.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前状态**仅允许当前状态内的过渡中断过渡。'
- en: '**Next State** allows the transition to be interrupted by other transitions,
    but only if those are within the destination state. Therefore, if the destination
    state has a transition that is ready to fire, it will interrupt this one and will
    be triggered.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一状态**允许过渡被其他过渡中断，但仅当这些过渡在目标状态内时。因此，如果目标状态有一个准备触发的过渡，它将中断此过渡并触发。'
- en: '**Current State then Next State** allows the transition to be interrupted by
    transitions from either the current or the destination state. However, if the
    conditions of a transition becomes true on both the current state and the destination
    one, then the former will take the priority. For example, if two transitions are
    ready to fire but one is on the current state and another one on the destination
    one, the first transition will be triggered and will interrupt the current playing
    transition.'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前状态然后下一状态**允许过渡被当前状态或目标状态的过渡中断。然而，如果过渡的条件在当前状态和目标状态上同时为真，则前者将具有优先权。例如，如果有两个过渡准备触发，但一个在当前状态，另一个在目标状态，则第一个过渡将被触发并中断当前正在播放的过渡。'
- en: '**Next State then Current State** still allows the transition to be interrupted
    by either transitions of the current or destination state. But in contrast to
    **Current State then Next State**, if the condition of a transition becomes true
    on both the current state and the destination one, then the latter will take priority.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一状态然后当前状态**仍然允许过渡被当前状态或目标状态的过渡中断。但与**当前状态然后下一状态**相比，如果过渡的条件在当前状态和目标状态上同时为真，则后者将具有优先权。'
- en: '**Ordered Interruption**: This determines whether the current transition can
    be interrupted by other transitions independently of their order.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序中断**：这确定当前转换是否可以被其他转换独立于它们的顺序中断。'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Now that you can make transitions, remember to rearrange often your finite state
    machine so as to improve readability. You should always place the states in such
    a way that all the transitions are nicely visible, and ideally they shouldn't
    cross each other much.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用转换，请记住经常重新排列您的有限状态机以提高可读性。您应该始终将状态放置得使所有转换都清晰可见，并且理想情况下它们不应交叉太多。
- en: Transition graph
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换图
- en: Unity also provides a useful way to tweak these properties (listed just now)
    in a visual way, through the transition graph, which is located just below the
    settings of the previous section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还提供了一种通过转换图以可视方式调整这些属性（如上所述）的有用方法，转换图位于上一节设置下方。
- en: The transition settings can be adjusted either manually by entering numbers
    into the fields that we saw before, or by using the transition diagram, which
    will modify the values when the visual elements are manipulated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以手动调整转换设置，通过在之前看到的字段中输入数字，或者使用转换图，当操作视觉元素时，它将修改值。
- en: '![Transition graph](img/image00482.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![转换图](img/image00482.jpeg)'
- en: The Transition Graph with a clear timeline; we can tweak how the transition
    will happen in a visual way
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 带有清晰时间线的转换图；我们可以以可视方式调整转换将如何发生
- en: 'In the preceding diagram, you can do one of the following things:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以执行以下操作之一：
- en: Change the duration of the transition by dragging the *out* marker.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过拖动*出*标记来更改转换的持续时间。
- en: Change the duration of the transition and the exit time by dragging the *in*
    marker.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过拖动*入*标记来更改转换的持续时间和退出时间。
- en: Adjust the transition offset by dragging the animation clips shown in the bottom
    part of the graph.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过拖动图底部显示的动画片段来调整转换偏移量。
- en: Preview the transition by dragging the playback marker and navigate frame by
    frame to adjust how the animation clips blend together. The preview window is
    located at the bottom of the inspector.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过拖动播放标记预览转换，逐帧导航以调整动画片段的混合方式。预览窗口位于检查器的底部。
- en: '![Transition graph](img/image00483.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![转换图](img/image00483.jpeg)'
- en: This is the preview window, where you can rotate, scale and play animations,
    as well as display their pivot point (or center of mass in the case of 3D models)
    and change the time scale to which you want to play the preview
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预览窗口，您可以在这里旋转、缩放和播放动画，以及显示它们的旋转中心点（或3D模型的质量中心）并更改预览播放的时间比例。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the transition involves a blending tree as one of the two states (or both),
    the blend tree parameters will also appear in the transition graph. You can find
    a bit more about blending trees in the *More about Animations* section later in
    the chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换涉及混合树作为两个状态之一（或两个状态），混合树参数也将出现在转换图中。您可以在本章后面的*关于动画的更多信息*部分找到有关混合树的一些更多信息。
- en: Transition conditions
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换条件
- en: 'So far we have seen many settings for our transitions, but when are they actually
    triggered? That''s why, at the bottom of the settings, there are the transition
    conditions. You can see them here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多转换的设置，但它们实际上何时被触发？这就是为什么在设置底部有转换条件。您可以看到它们在这里：
- en: '![Transition conditions](img/image00484.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![转换条件](img/image00484.jpeg)'
- en: To add a condition, press the **+** button. To remove, select one of them and
    click on the **-** button. Besides, you can reorder them by dragging their left
    handle. However, the order doesn't affect the logic behind the transition (just
    the implementation of it, and maybe the readability of your project).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加条件，请按**+**按钮。要删除，选择其中一个并点击**-**按钮。此外，您可以通过拖动它们的左侧手柄来重新排列它们。然而，顺序不会影响转换背后的逻辑（只是其实施，以及可能的项目可读性）。
- en: These conditions can be checked against the parameters. For `int` and `float`
    parameters, we can check them against a fixed number. So if the value in the parameter
    is **Greater** or **Less** than the fixed number. For `int` parameters, we can
    also check whether they are **Equals** or **NotEqual** compared to the fixed number.
    Bools, instead, can be checked to find out whether they are true or false. Finally,
    triggers cannot be checked against something, but the condition checks whether
    they fire.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件可以与参数进行核对。对于`int`和`float`参数，我们可以将它们与一个固定数字进行比较。所以如果参数中的值是**大于**或**小于**固定数字。对于`int`参数，我们还可以检查它们是否与固定数字**相等**或**不相等**。布尔值，相反，可以检查它们是**真**还是**假**。最后，触发器不能与某物进行比较，但条件检查它们是否被触发。
- en: 'Here is an example of conditions using all of the four kinds of parameters:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用所有四种参数的条件的示例：
- en: '![Transition conditions](img/image00485.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![Transition conditions](img/image00485.jpeg)'
- en: Please note that the transition is executed/performed only if all the conditions
    are verified in that moment. A transition without conditions is triggered at the
    time specified in **Exit Time**.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有在该时刻所有条件都得到验证时，过渡才会执行/执行。如果没有条件，则过渡在**退出时间**指定的时刻触发。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If **Has Exit Time** is not checked and the transition has no condition as well,
    then the transition is ignored by Unity. So it is as if the transition didn't
    exist.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**有退出时间**没有被勾选，并且过渡没有条件，那么Unity将忽略该过渡。所以它就像过渡不存在一样。
- en: Now that we have learned how to set a transition, we will explore some useful
    functionalities to test them in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何设置过渡，我们将在下一节探索一些有用的功能来测试它们。
- en: Testing transitions
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试过渡
- en: 'There are two useful functionalities to know about if you need to test the
    transitions. The first one is **Solo** and second is **Mute**. If you select a
    transition, you can see them at the top of the **Inspector**:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要测试过渡，有两个有用的功能需要了解。第一个是**独奏**，第二个是**静音**。如果你选择一个过渡，你可以在**检查器**的顶部看到它们：
- en: '![Testing transitions](img/image00486.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Testing transitions](img/image00486.jpeg)'
- en: 'However, I suggest you to set **Solo** and **Mute** in another way. In fact,
    if we select a state, we can find in the **Inspector** all the transitions from
    that state with the **Solo** and **Mute** functionalities. As a result, we will
    have a handy view, since we can look at and set all the transitions from that
    state in one go, shown as follows (all the transitions in this picture will be
    made in the next section):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我建议你以另一种方式设置**独奏**和**静音**。实际上，如果我们选择一个状态，我们可以在**检查器**中找到该状态的所有具有**独奏**和**静音**功能的过渡。因此，我们将有一个方便的视图，因为我们可以一次性查看和设置该状态的所有过渡，如下所示（本图中的所有过渡将在下一节中实现）：
- en: '![Testing transitions](img/image00487.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Testing transitions](img/image00487.jpeg)'
- en: 'When the **Mute** checkbox is selected, that specific transition will be ignored
    completely. Whereas, when the **Solo** checkbox is selected, all the other transitions
    will be considered muted. Furthermore, in the **Animator** window, it is possible
    to see **Mute** transitions in red, whereas **Solo** transitions are in green:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择**静音**复选框时，该特定过渡将被完全忽略。而，当选择**独奏**复选框时，所有其他过渡都将被视为静音。此外，在**动画器**窗口中，可以看到**静音**过渡为红色，而**独奏**过渡为绿色：
- en: '![Testing transitions](img/image00488.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Testing transitions](img/image00488.jpeg)'
- en: An example of Solo and Mute transitions
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 独奏和静音过渡的示例
- en: If you have the hard copy of this book (so without colors), the transition that
    goes from `Panda_Walk_Animation` to `Panda_Hit_Animation` is a **Mute** transition,
    so the arrow is red. Both the transitions from `Panda_Walk_Animation` to `Panda_Die_Animation`
    and `Panda_Eat_Animation` are **Solo** transitions, and the arrow is green. The
    remaining one is neither a **Mute** nor **Solo** transition, and therefore it
    is white. However, this is just an example; feel free to test in the best way
    that suits you.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有这本书的纸质版（因此没有颜色），从`Panda_Walk_Animation`到`Panda_Hit_Animation`的过渡是一个**静音**过渡，所以箭头是红色的。从`Panda_Walk_Animation`到`Panda_Die_Animation`和`Panda_Eat_Animation`的过渡都是**独奏**过渡，箭头是绿色的。剩下的一个既不是**静音**也不是**独奏**过渡，因此它是白色的。然而，这只是一个例子；请随意以最适合你的方式测试。
- en: 'Moreover, from the official documentation we can read a rule of thumb about
    **Solo** and **Mute** functionalities:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从官方文档中我们可以找到关于**独奏**和**静音**功能的经验法则：
- en: '*"The basic rule of thumb is that if one Solo is ticked, the rest of the transitions
    from that state will be muted. If both Solo and Mute are ticked, then Mute takes
    precedence."*'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"基本规则是，如果选中了一个 Solo，那么从该状态到其他状态的过渡将被静音。如果同时选中了 Solo 和 Mute，则 Mute 优先。"*'
- en: 'Finally, it''s worthy to keep in mind that at the time I''m writing this sentence,
    there is a known issue (always from the official documentation):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，在我写这句话的时候，有一个已知的问题（始终来自官方文档）：
- en: '*"The controller graph currently doesn''t always reflect the internal mute
    states of the engine."*'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"控制器图目前并不总是反映引擎的内部静音状态。"*'
- en: The panda's Animation State Machine
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熊猫的动画状态机
- en: 'Now that we learnt a bit more about how to use Mecanim system, we will do what
    we started-have a complete controller for the animations of our pandas. This is
    how the controller should look once finished:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何使用 Mecanim 系统有了更多了解，我们将做我们开始的事情——为我们的熊猫动画创建一个完整的控制器。这是控制器完成后的样子：
- en: '![The panda''s Animation State Machine](img/image00489.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![熊猫的动画状态机](img/image00489.jpeg)'
- en: 'As you can see, there are four transitions, and we''ve got only one. But we
    still need to properly set all of them. Therefore, create and complete the transitions
    in the following way:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有四个过渡，而我们只有一个。但我们仍然需要正确设置所有这些。因此，按照以下方式创建和完成过渡：
- en: '`Panda_Walk_Animation` to `Panda_Hit_Animation`: When the panda is walking
    and a sprinkle hits it, the panda will play the Hit animation. Therefore, let''s
    add `HitTrigger` as a condition and uncheck **Has Set Time** to trigger the transition
    at any moment during the walk loop. Furthermore, to make the transition instantaneous,
    let''s set **Transition Duration** to zero to make it start playing the Hit animation
    from the first frame set **Transition Offset** to zero.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panda_Walk_Animation` 到 `Panda_Hit_Animation`：当熊猫在行走时被洒水击中，熊猫将播放击中动画。因此，让我们添加
    `HitTrigger` 作为条件，并取消选中 **Has Set Time** 以在行走循环的任何时刻触发过渡。此外，为了使过渡瞬间发生，让我们将 **Transition
    Duration** 设置为零，使其从第一帧开始播放击中动画，并将 **Transition Offset** 设置为零。'
- en: '`Panda_Hit_Animation` to `Panda_Walk_Animation`: After the panda has been hit,
    he will then keep walking again towards the player''s cake. As a result, we need
    to recover the panda from the `Panda_Hit_Animation` state as soon as the animation
    finishes. So, let''s set **Has Exit Time** to true and **Transition Duration**
    and **Transition Offset** to zero, since we want the transition to be instantaneous.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panda_Hit_Animation` 到 `Panda_Walk_Animation`：当熊猫被击中后，它将再次继续向玩家的蛋糕走去。因此，我们需要在动画结束时立即将熊猫从
    `Panda_Hit_Animation` 状态恢复过来。所以，让我们将 **Has Exit Time** 设置为 true，并将 **Transition
    Duration** 和 **Transition Offset** 设置为零，因为我们希望过渡是瞬间的。'
- en: '`Panda_Walk_Animation` to `Panda_Eat_Animation`: When the panda finally arrives
    to the player''s cake, the panda will eat so much of it that he will explode!
    Therefore, the transition needs to be triggered with `EatTrigger`, so add it to
    the conditions and uncheck **Has Exit Time**. Moreover, as all the transitions
    of the panda should be immediate, set both **Transition Duration** and **Transition
    Offset** to zero.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panda_Walk_Animation` 到 `Panda_Eat_Animation`：当熊猫最终到达玩家的蛋糕时，它会吃掉那么多的蛋糕以至于会爆炸！因此，过渡需要通过
    `EatTrigger` 触发，所以将其添加到条件中，并取消选中 **Has Exit Time**。此外，由于熊猫的所有过渡都应该是立即的，将 **Transition
    Duration** 和 **Transition Offset** 都设置为零。'
- en: '`Panda_Walk_Animation` to `Panda_Die_Animation`: Being under fire by sprinkles
    is tough for our panda. If it cannot hold anymore, it will die, leaving the player''s
    cake untouched. This is a transition triggered by `DieTrigger`, which we need
    to add to the conditions. Again, for the same reasons as before, uncheck **Has
    Exit Time** and set both **Transition Duration** and **Transition Offset** to
    zero.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panda_Walk_Animation` 到 `Panda_Die_Animation`：被洒水攻击对我们熊猫来说很困难。如果它不能再坚持，它就会死去，而玩家的蛋糕则完好无损。这是一个由
    `DieTrigger` 触发的过渡，我们需要将其添加到条件中。同样，由于之前的相同原因，取消选中 **Has Exit Time** 并将 **Transition
    Duration** 和 **Transition Offset** 都设置为零。'
- en: '`Panda_Die_Animation` to `Exit`: Once the panda is dead, we want to get rid
    of it. Going in the `Exit` state, actually (since we don''t have any sub-machines),
    will make the controller start again from the enter state/node. However, we will
    see how to destroy the panda before this happens. It doesn''t matter if this animation
    goes in any other state, but choosing exit makes more sense, and so it helps in
    the readability of your controller. Once more, we want the transition to be instantaneous,
    so we set both **Transition Duration** and **Transition Offset** to zero; but
    we want to trigger this transition as soon as the animation finishes, which means
    having **Has Exit Time** set to true.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panda_Die_Animation`到`Exit`：一旦熊猫死亡，我们希望将其移除。进入`Exit`状态（因为我们没有子状态机），实际上会让控制器从进入状态/节点重新开始。然而，我们将在发生之前展示如何销毁熊猫。这个动画进入任何其他状态都无关紧要，但选择退出更有意义，这有助于提高你控制器可读性。再次强调，我们希望转换是瞬时的，因此我们将**转换持续时间**和**转换偏移**都设置为零；但我们希望动画完成后立即触发这个转换，这意味着将**Has
    Exit Time**设置为true。'
- en: '`Panda_Eat_Animation` to `Exit`: The same reasons we said for the previous
    transition hold for this too. The panda will eat so much cake that it will explode,
    and again the panda will be removed from the scene. Check **Has Exit Time** and
    set **Transition Duration** and **Transition Offset** to zero.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panda_Eat_Animation`到`Exit`：我们之前提到的原因也适用于这个转换。熊猫会吃掉很多蛋糕以至于爆炸，然后熊猫将从场景中移除。检查**Has
    Exit Time**，并将**转换持续时间**和**转换偏移**设置为零。'
- en: Testing the panda's Animation State Machine
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试熊猫的动画状态机
- en: Before we move on to the next section, we should check whether what we have
    done so far works. However, the whole system will be completed only when we finish
    the game. Therefore, we need to find a smart and fast way to test the controller.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，我们应该检查我们到目前为止所做的工作是否有效。然而，整个系统只有在完成游戏后才会完成。因此，我们需要找到一个既聪明又快速的方式来测试控制器。
- en: 'The easiest way is to create a new scene and drag and drop the panda Prefab
    into it. Then, build an UI interface with three buttons. Change their text so
    that you will have `Trigger Die Animation`, `Trigger Hit Animation`, and `Trigger
    Eat Animation`, as shown in this screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个新的场景，并将熊猫Prefab拖放到其中。然后，构建一个包含三个按钮的UI界面。更改它们的文本，以便你将拥有`触发死亡动画`、`触发击打动画`和`触发进食动画`，如图所示：
- en: '![Testing the panda''s Animation State Machine](img/image00490.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00490.jpeg)'
- en: As we learnt in the previous chapter, the buttons have the **On Click ()** event,
    which allows us to call some functions when the button is pressed. However, we
    didn't have chance to use this functionality. In fact, we will work more on UI
    events in the next chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，按钮有**On Click ()**事件，这允许我们在按钮被按下时调用一些函数。然而，我们没有机会使用这个功能。实际上，我们将在下一章中更多地处理UI事件。
- en: 'For now, you can select all the three buttons, and click on the small **+**
    button in the bottom-right corner of the **On Click ()** event. We can see this
    in the following image:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以选择所有三个按钮，并点击**On Click ()**事件右下角的小**+**按钮。我们可以在以下图像中看到这一点：
- en: '![Testing the panda''s Animation State Machine](img/image00491.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00491.jpeg)'
- en: 'A new event appears, as shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一个新的事件，如图所示：
- en: '![Testing the panda''s Animation State Machine](img/image00492.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00492.jpeg)'
- en: 'Drag the panda from the **Hierarchy** panel, into the object variable, so that
    you will have the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将熊猫从**层次结构**面板拖动到对象变量中，这样你将得到以下内容：
- en: '![Testing the panda''s Animation State Machine](img/image00493.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00493.jpeg)'
- en: 'From the drop-down menu, navigate to **Animator** | **Set Trigger (string)**.
    In this way, we can set the triggers of our Animator. So at the end, you should
    have this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从下拉菜单中，导航到**Animator** | **设置触发器（字符串）**。这样，我们可以设置Animator的触发器。所以最后，你应该有这个：
- en: '![Testing the panda''s Animation State Machine](img/image00494.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00494.jpeg)'
- en: 'Now, select each button separately, and assign to each one of them the respective
    trigger. For instance, in the **Trigger Die Animation** button, you should write
    `DieTrigger`, as shown in this picture:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分别选择每个按钮，并将相应的触发器分配给它们。例如，在**触发投掷动画**按钮中，你应该写下`DieTrigger`，如图所示：
- en: '![Testing the panda''s Animation State Machine](img/image00495.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00495.jpeg)'
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `Set Trigger (string)` function is not the best option, since it involves
    the use of strings. But for testing purposes, it's more than fine. In the next
    section, when we build a script that controls the Animator, we will see how to
    use hashes to refer to Animator parameters as numbers, and improve efficiency.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Set Trigger (字符串)`函数并不是最佳选择，因为它涉及到字符串的使用。但出于测试目的，这已经足够好了。在下一节中，当我们构建一个控制动画器的脚本时，我们将看到如何使用散列来引用动画器参数作为数字，并提高效率。
- en: As a result, each one of those buttons now acts as a trigger for our panda.
    Therefore, we can press **Play**, and finally see our panda walking. Then, by
    clicking on the buttons, we can trigger the transitions in the Animator and see
    the panda changing state/animation. As a result, we can test if the transitions
    work well or not. Feel free to tweak any parameters you want, such as the speed
    of an animation or the transition graph of one of the transitions to suit your
    needs.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在每个按钮现在都充当我们熊猫的触发器。因此，我们可以按下**播放**，最终看到我们的熊猫在行走。然后，通过点击按钮，我们可以触发动画器中的转换并看到熊猫改变状态/动画。结果，我们可以测试转换是否工作良好。请随意调整任何您想要的参数，例如动画的速度或某个转换的转换图，以满足您的需求。
- en: Do you remember the **Auto live link** toggle when we talked about the **Animator**
    window? Once you are in **Play** mode, that is the right moment to activate it.
    As a result, you will be able to have a visual representation on your **Animator**
    window of the state of your machine.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们讨论**动画器**窗口时提到的**自动活链**切换吗？一旦你进入**播放**模式，这就是激活它的正确时机。结果，你将能够在你的**动画器**窗口中看到机器的状态的视觉表示。
- en: For instance, in the following screenshot, the walk loop is performed and it
    also shows a bar with the progress of the animation. This can help you a lot to
    tweak the Animator controller.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的屏幕截图中，执行了行走循环，并且还显示了一个显示动画进度的条形图。这可以帮助你大量调整动画器控制器。
- en: '![Testing the panda''s Animation State Machine](img/image00496.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![测试熊猫的动画状态机](img/image00496.jpeg)'
- en: Now, once you are happy with your changes and you have applied them, save the
    scene if you want, but come back to our main scene. Then, we are ready to create
    a script, or two, for our pandas.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你对你的更改感到满意并且已经应用了它们，如果你想的话，保存场景，然后回到我们的主场景。然后，我们准备好为我们的熊猫创建一个或两个脚本。
- en: Scripting Animations
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画脚本
- en: 'Finally, we''ve got all the animations for our pandas and a controller that
    changes them based on some triggers. However, so far nothing will ever set a trigger
    of the Animator (except our UI test buttons in the other scene). Therefore, we
    need to create the script for the panda, which will not only include the behaviour
    of the panda, but it will also trigger the right animations. In the next section,
    we will learn how to tweak the parameters of an Animator within a script. But
    before we get there, let me to introduce you a very powerful tool: State Machine
    Behaviours!'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为我们的熊猫准备好了所有的动画以及一个根据某些触发器改变它们的控制器。然而，到目前为止，没有任何东西会设置动画器的触发器（除了其他场景中的我们的UI测试按钮）。因此，我们需要为熊猫创建脚本，这个脚本不仅包括熊猫的行为，还会触发正确的动画。在下一节中，我们将学习如何在脚本中调整动画器的参数。但在我们到达那里之前，让我先向你介绍一个非常强大的工具：状态机行为！
- en: State machine behaviours
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机行为
- en: 'Each state of the animation machines can contain one or more behaviours. These
    are scripts that extend the `StateMachineBehaviour` class, which include the following
    functions/events, with self-explanatory names regarding when they are called/triggered:
    `OnStateEnter()`, `OnStateExit()`, `OnStateIK()`, `OnStateMove()`, and `OnStateUpdate()`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 动画机的每个状态可以包含一个或多个行为。这些是扩展`StateMachineBehaviour`类的脚本，包括以下函数/事件，具有关于它们何时被调用/触发的自解释名称：`OnStateEnter()`、`OnStateExit()`、`OnStateIK()`、`OnStateMove()`和`OnStateUpdate()`。
- en: 'In particular, you need to override these functions from the mother class,
    and they take as input three parameters. The first is the Animator itself, the
    second is an `AnimatorStateInfo` that stores information about the current state,
    and finally we have an integer that represents the layer. In our case, since we
    won''t use any other layer than the base one, it will be always zero. They have
    the following signature (take `OnStateEnter()` for example):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，你需要从母类中重写这些函数，并且它们接受三个参数作为输入。第一个是动画器本身，第二个是`AnimatorStateInfo`，它存储有关当前状态的信息，最后是一个表示层的整数。在我们的案例中，因为我们不会使用除了基础层以外的任何其他层，所以它总是零。它们具有以下签名（以`OnStateEnter()`为例）：
- en: '[PRE0]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a result, we can control everything within a state. In fact, State Machine
    Behaviours are a very powerful tool. Once you have created a script that extends
    the `StateMachineBehaviour` class, select the state where you want to add it.
    Then, click on the **Add Behaviour** button at the bottom of the **Inspector**,
    like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在一个状态下控制一切。实际上，状态机行为是一个非常强大的工具。一旦你创建了一个扩展`StateMachineBehaviour`类的脚本，选择你想要添加该脚本的州。然后，点击**检查器**底部的**添加行为**按钮，如下所示：
- en: '![State machine behaviours](img/image00497.jpeg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![状态机行为](img/image00497.jpeg)'
- en: 'If your class contains variables, they are shown in the **Inspector** as for
    any other script, and they can be configured for that specific state. Here is
    a State Machine Behaviour that contains some variables and how they are displayed:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类包含变量，它们在**检查器**中的显示方式与其他脚本相同，并且可以为该特定状态进行配置。以下是一个包含一些变量及其显示方式的状态机行为：
- en: '![State machine behaviours](img/image00498.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![状态机行为](img/image00498.jpeg)'
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when using static variables, because they are shared among all the
    instances of the State Machine Behaviour among all the controllers! In fact, it's
    good practice to not use static variables in this context.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态变量时要小心，因为它们在所有控制器的状态机行为实例之间是共享的！实际上，在这个上下文中不使用静态变量是一个好的实践。
- en: Now, imagine that the hero of your game that has the ability to carry and hold
    different weapons. In this case, with a machine behaviour, you can check which
    weapon the character is holding, and if it matches with the legendary fire sword,
    add a fire particle effect when our hero slashes an enemy. Another example could
    be where some characters share the same animation machine, since they are really
    similar, but some of them can glide after a jump. As such, you'd want to check
    this and, in some way, modify some parameters of your animation machines.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你的游戏中的英雄角色拥有携带和持有不同武器的能力。在这种情况下，使用机器行为，你可以检查角色手持的是哪一把武器，如果它与传说中的火焰剑相匹配，当我们的英雄挥砍敌人时，就会添加火焰粒子效果。另一个例子可能是，一些角色共享相同的动画机器，因为它们真的很相似，但其中一些角色在跳跃后可以滑行。因此，你可能想要检查这一点，并以某种方式修改你的动画机器的一些参数。
- en: To put simply, the only limit is your imagination (and computational power),
    and you can enhance your animation machine. Of course, all that you can achieve
    with State Machine Behaviour can be done in other ways, but they offer a simple
    and quite intuitive way to do it. It doesn't take much to get used and learn how
    to deal with this tool.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，唯一的限制是你的想象力（以及计算能力），你可以增强你的动画机器。当然，你可以用状态机行为实现的所有事情都可以用其他方式完成，但它们提供了一个简单且相当直观的方式来做到这一点。熟悉并学习如何使用这个工具并不需要太多时间。
- en: Now that we know what a State Machine Behaviours is, let's make one for our
    panda!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了状态机行为是什么，让我们为我们的熊猫创建一个状态机行为！
- en: The destroy behaviour
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摧毁行为
- en: When our panda is killed either by a terrible rain of sprinkles or by eating
    too much cake, in some way we need to make the panda disappear from the scene.
    However, we need to do it, after that the death animation is played, and eventually
    also after we have updated the gameplay (which we will see later in the book).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的熊猫被可怕的喷水雨或吃太多蛋糕杀死时，我们需要以某种方式让熊猫从场景中消失。然而，我们需要在播放死亡动画之后，以及我们在书中稍后将要看到的更新游戏玩法之后完成这个操作。
- en: That's why we have created two extra transitions from the **Die** and **Eat**
    animations into the **Exit** state. These transitions will be executed once the
    respective animation has finished playing. Moreover, these animations are triggered
    by us in a separate script (see the next section), so before the panda dies, we
    have a chance to update the gameplay, such as the amount of sugar or health of
    the player.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们才创建了从**死亡**和**进食**动画到**退出**状态的额外两个转换。这些转换将在相应的动画播放完毕后执行。此外，这些动画是由我们在单独的脚本中触发的（见下一节），所以在熊猫死亡之前，我们有更新游戏玩法的机会，比如玩家的糖分或健康值。
- en: A State Machine Behaviour allows us to have this level of control, that is to
    destroy the panda when it finishes to play that particular animation. Therefore,
    we can create a new script and call it something meaningful, such as `StateMachineBehaviour_DestroyOnExit`.
    Now, double-click on the script to open it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机行为允许我们达到这样的控制水平，即在熊猫播放特定动画结束后摧毁熊猫。因此，我们可以创建一个新的脚本，并将其命名为有意义的名称，例如`StateMachineBehaviour_DestroyOnExit`。现在，双击脚本以打开它。
- en: 'First of all, we need to extend `StateMachineBehaviour` and not `MonoBehaviour`.
    We can just replace the latter with the former. Since the script doesn''t extend
    `MonoBehaviour` anymore, we can also remove the `Start()` and `Update()` functions.
    At the end, we should come up with the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要扩展`StateMachineBehaviour`而不是`MonoBehaviour`。我们可以直接用前者替换后者。由于脚本不再扩展`MonoBehaviour`，我们也可以移除`Start()`和`Update()`函数。最后，我们应该得到以下结果：
- en: '[PRE1]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to override one of the aforementioned functions of a State Machine
    Behaviour. In particular we want to override the `OnExit()` function. So every
    time the state changes to another (which in the case of the **Die** and **Eat** states
    means immediately after their animations are played), the panda will be destroyed.
    We can do this easily, since one of the parameters of the function is the Animator
    itself, and from it, we can retrieve the gameObject to which the Animator is attached
    and destroy it. Therefore, we can just add this function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要覆盖上述状态机行为中的一个函数。特别是我们想要覆盖`OnExit()`函数。所以每次状态改变到另一个（在**死亡**和**进食**状态的情况下意味着动画播放后立即），熊猫将被销毁。我们可以轻松做到这一点，因为函数的一个参数就是Animator本身，我们可以从中检索Animator附加的gameObject并将其销毁。因此，我们只需添加这个函数：
- en: '[PRE2]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the script, and select the **Die** and **Eat** states. From there, click
    on **Add Behaviour** and select `StateMachineBehaviour_DestroyOnExit`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后选择**死亡**和**进食**状态。从那里，点击**添加行为**并选择`StateMachineBehaviour_DestroyOnExit`。
- en: Once you have done all of this, we are done! Now, every time the **Die** or
    **Eat** animations are played, on their completion, the panda will be destroyed.
    The next step is to see how to actually trigger the states within the controller.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有这些，我们就完成了！现在，每次播放**死亡**或**进食**动画时，在动画完成后，熊猫将被销毁。下一步是看看如何在控制器中实际触发状态。
- en: The panda script
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熊猫脚本
- en: 'We need to create a new script, and this time let it be derived from `MonoBehaviour`.
    We can call it `PandaScript`. Then, we can start to create some variables inside
    it. Let''s start with a public variable to keep track of the panda''s life and
    another one for its speed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的脚本，这次让它从`MonoBehaviour`派生。我们可以称它为`PandaScript`。然后，我们可以在其中创建一些变量。让我们从一个公共变量开始，用于跟踪熊猫的生命，另一个用于其速度：
- en: '[PRE3]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need a variable to store the reference to the Animator. So, we can
    use this variable when we need to trigger an animation in the Animator:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个变量来存储Animator的引用。因此，当我们需要在Animator中触发动画时，我们可以使用这个变量：
- en: '[PRE4]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we learned in the *Animator Parameter* section, there are different methods
    to set parameters within the Animator. However, there are two versions of them:
    one refers to the parameter with an ID or Hash, the other one as a string. The
    latter is for sure the most intuitive, but since it relies on string processing,
    it''s a bit slower than the first one. As such, whenever this is possible, it''s
    better to use a hash (see the information box) to refer to a specific parameter
    within the Animator. Therefore, we can store these hashes inside some variable,
    so to fast use them.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在**Animator参数**部分所学，在Animator中设置参数有不同的方法。然而，它们有两种版本：一种是通过ID或哈希引用参数，另一种是作为字符串。后者当然是最直观的，但由于它依赖于字符串处理，所以比第一种慢一些。因此，只要可能，最好使用哈希（见信息框）来引用Animator中的特定参数。因此，我们可以将这些哈希存储在某个变量中，以便快速使用它们。
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In computer science when we need to map data of an arbitrary size onto data
    of a fixed size, we use a `Hash` function. The result of this function is called
    *hash values*, *hash codes*, *digests*, or simply *hashes*. The main uses of these
    `Hash` functions are in cryptography and digital security. Whenever you digitally
    sign a document, behind the scenes there is a `Hash` function somewhere too. However,
    they are also used in other contexts, such as to optimize, as in the case of Unity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，当我们需要将任意大小的数据映射到固定大小的数据时，我们使用`Hash`函数。这个函数的结果被称为*哈希值*、*哈希码*、*摘要*或简单地称为*哈希*。这些`Hash`函数的主要用途在密码学和数字安全中。每次你进行数字签名时，幕后也有一处使用`Hash`函数。然而，它们在其他上下文中也被使用，例如在Unity中用于优化。
- en: In our very specific case, we have a set of parameters, which need an integer
    ID so that they can be referred to quickly in the Animator. A `Hash` function
    is applied from the name of the parameter, which is a string, and so potentially
    with infinite combinations, since a string can be long arbitrary, onto a finite
    set of the Integers which may be expressed with a single `int` variable (so only
    up to two billion, one hundred and forty-seven million, four hundred and eighty-three
    thousand, six hundred and forty-seven). So every time in your video game use an
    `int` variable for storing money or lives, like we did in the last chapter, `2,147,483,647`
    is the maximum amount. Usually for video games, this limit is more than fine for
    any integer parameters you may want, although it is possible to overcome it if
    needed with special data structures. As a result, from the name of the parameter
    of the Animator, we can have a number with which we can refer to the parameter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们非常具体的案例中，我们有一组参数，它们需要一个整数ID，这样它们就可以在Animator中快速引用。从参数的名称（一个字符串）应用一个`Hash`函数，由于字符串可以是非常长的任意长度，因此有无限多的组合，将其映射到一个有限的整数集合上，这些整数可以用一个单一的`int`变量表示（因此最多可达二十亿一千四百七十万四千八百三十个六百四十七）。所以，在您的视频游戏中，每次使用`int`变量来存储金钱或生命值，就像我们在上一章中所做的那样，`2,147,483,647`是最大值。通常对于视频游戏来说，这个限制对于您可能想要的任何整数参数来说都足够好了，尽管如果需要的话，可以通过特殊的数据结构来克服它。因此，从Animator参数的名称中，我们可以得到一个可以用来引用参数的数字。
- en: These hashes are Animator independent, since they are based only on the name
    of the parameter itself. So they can be calculated or retrieved from the static
    function `Animator.StringToHash()`, which takes as input the name of the parameter
    and returns as output it's numerical representation to use in an Animator.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这些哈希值是Animator无关的，因为它们仅基于参数本身的名称。因此，它们可以通过静态函数`Animator.StringToHash()`计算或检索，该函数接受参数的名称作为输入，并返回用于Animator的数值表示。
- en: 'In our specific case, we have the three triggers, and we can store their hashes
    in the following variables:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们具体的案例中，我们有三个触发器，我们可以将它们的哈希值存储在以下变量中：
- en: '[PRE5]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to get the reference to the Animator controller in the `Start()`
    function, so to be used in the other functions. We can achieve this by using the
    `GetComponent()` function, which returns the component specified as `Type` attached
    to the same gameObject of this script. Therefore, we can simply add this line
    in the `Start()` function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`Start()`函数中获取Animator控制器的引用，以便在其他函数中使用。我们可以通过使用`GetComponent()`函数来实现这一点，该函数返回指定为`Type`的组件，该组件附加到与该脚本相同的gameobject上。因此，我们可以在`Start()`函数中简单地添加这一行：
- en: '[PRE6]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, as for a modular workflow, we can create some private functions to implement
    the logic behind controlling the state machine. However, we will deal with them
    when we need to call them later on.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于模块化工作流程，我们可以创建一些私有函数来实现控制状态机的逻辑。然而，我们将等到需要调用它们的时候再处理它们。
- en: 'So now, we need a function that allows our panda to move towards a point in
    the map. This function takes a `Vector3` as input parameter, which is the destination
    point on the map. Based on the speed variable, it creates a step for our panda.
    Then, using the `MoveTowards()` function, it moves the panda of one step towards
    the destination point:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们需要一个函数，允许我们的熊猫移动到地图上的一个点。这个函数接受一个`Vector3`作为输入参数，它是地图上的目标点。根据速度变量，它为熊猫创建一个步骤。然后，使用`MoveTowards()`函数，它将熊猫移动一步，朝向目标点：
- en: '[PRE7]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another function will be called when the panda is hit by a sprinkle from one
    of the player''s cupcake towers. It has as input a float, which is the amount
    of damage the panda has taken from the hit. So, the function subtracts this value
    to the health of the panda, and then checks if the health is less than zero. If
    so, the function triggers the Die Animation by set the `DieTrigger` parameter.
    We don''t need to then destroy the panda because once death is triggered, the
    state machine behaviour will take care of it. On the other hand, if the panda
    is not dead yet, the function, instead, plays the Hit Animation:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当熊猫被玩家的一个纸杯蛋糕塔的喷雾击中时，将调用另一个函数。它的输入是一个浮点数，表示熊猫从击打中受到的伤害量。因此，该函数从这个值中减去熊猫的健康值，然后检查健康值是否小于零。如果是这样，该函数通过设置`DieTrigger`参数来触发死亡动画。我们不需要销毁熊猫，因为一旦触发死亡，状态机行为将负责处理它。另一方面，如果熊猫还没有死，该函数将播放击打动画：
- en: '[PRE8]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One last function we need to add is for when the panda reaches the end of its
    path and it''s standing in front of the player''s cake. Here the function just
    triggers the `Eat animation`. How to damage the player is something that we will
    deal in the next chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的最后一个功能是当熊猫到达其路径的末端并站在玩家蛋糕前面时。在这里，这个功能只是触发`吃动画`。如何伤害玩家是我们将在下一章中讨论的内容：
- en: '[PRE9]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can save the script for now. It should appear like this in the Inspector:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先保存这个脚本。它在检查器中的样子应该是这样的：
- en: '![The panda script](img/image00499.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![熊猫脚本](img/image00499.jpeg)'
- en: No need to worry now about how to set the speed and the health! We will see
    this when we will talk about gameplay programming.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不需要担心如何设置速度和健康！当我们讨论游戏玩法编程时，我们会看到这一点。
- en: Unless you want to read the next optional section, which will guide you through
    more advanced topics, we can say that we have finished with animation. If you
    don't want to read the next section, or want to come back to it later, maybe once
    you've finished the whole book, you can skip directly to the homework and summary
    sections. Otherwise, take a break and continue with the next section.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你想阅读下一个可选部分，该部分将引导你了解更高级的主题，否则我们可以这样说，我们已经完成了动画。如果你不想阅读下一个部分，或者想稍后再回来，也许在你完成整本书之后，你可以直接跳到作业和总结部分。否则，休息一下，继续下一部分。
- en: More about Animations
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于动画的内容
- en: We have seen a lot about the Animation workflow in Unity, yet a lot has been
    left out. This section presents some relatively advanced topics of the Animation
    workflow in Unity, and they are not needed to develop our Tower Defense Game.
    In fact, some of these applies only on 3D, but I feel that it's worthwhile to
    mention them to have a rough, but complete picture of the whole workflow for Animations
    in Unity. Therefore, feel free to skip this section, or read without focus to
    understand completely what's written. You can always come back here later, maybe
    when you've finished the book, for a deeper look to its content.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Unity中动画工作流程的很多内容，但还有很多内容被省略了。本节介绍了Unity中动画工作流程的一些相对高级主题，它们对于开发我们的塔防游戏不是必需的。实际上，其中一些只适用于3D，但我认为提及它们对于有一个关于Unity中动画整个工作流程的粗略但完整的了解是有价值的。因此，你可以自由地跳过这一节，或者不用太专注地阅读，以完全理解所写的内容。你总是可以在以后回来，也许在你完成这本书之后，可以更深入地研究其内容。
- en: Note
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the following sections are not intended to explain in detail how to use
    these tools in Unity, but rather to be aware of their existence and functionalities
    so as to learn them later on when you are a bit more practical with Unity.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下章节的目的不是详细解释如何在Unity中使用这些工具，而是让你了解它们的存在和功能，以便你在对Unity有更多实践经验时再学习它们。
- en: Avatars
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟形象
- en: 'In the case of 3D characters, and especially for humanoids, you need to *rig*
    your character, which means to match all bones of the 3D model into a Unity Avatar.
    If the model is well done and optimized for Unity, this process can be automatized;
    otherwise it needs to be done by hand, as shown in this picture:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D角色，尤其是人类角色的案例中，你需要对你的角色进行**绑定**，这意味着将3D模型的所有骨骼匹配到Unity虚拟形象中。如果模型制作得很好并且已经针对Unity进行了优化，这个过程可以自动化；否则，需要手动完成，如图所示：
- en: '![Avatars](img/image00500.jpeg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟形象](img/image00500.jpeg)'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the scene view, there is your 3D model, from which you can drag and drop
    the parts of his/her/its body in the avatar.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景视图中，你可以看到你的3D模型，你可以从其中拖放身体部分到虚拟形象中。
- en: In this way, Unity stores additional information about the 3D model. It stores
    not only the matching bones, but also muscles. The main reason is that by doing
    it in this way it is possible to perform retargeting, which means using the same
    animations for different character. Suppose you have a beautiful walking animation,
    and you want to apply it to all your characters. But some of them are tall. Others
    are fat or full of muscles. The Avatar stores this additional information to overcome
    the problem and adapt the walking animation to each character.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，Unity存储了关于3D模型的附加信息。它不仅存储了匹配的骨骼，还存储了肌肉。主要原因是通过这种方式，可以执行重定向，这意味着使用相同的动画应用于不同的角色。假设你有一个美丽的行走动画，并且你想将其应用于所有角色。但其中一些角色很高。其他人很胖或者肌肉发达。虚拟形象存储这些附加信息以克服这个问题，并使行走动画适应每个角色。
- en: Furthermore, Unity also allows masking, which means to discard part of the Animation
    clip data and uses specific parts only. For instance, imagine you have a beautiful
    walking animation and an animation of someone drinking a glass of water. Suppose
    you want to make your character to drink a glass of water while he or she keeps
    walking. By masking the drinking animation, we are able to crop it just onto the
    upper body part. As a result, we can leave the walking animation playing on the
    legs, while the drinking one is playing on the upper body of the character.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Unity还允许遮罩，这意味着丢弃动画剪辑数据的一部分，只使用特定的部分。例如，想象你有一个美丽的行走动画和一个某人喝水动画。假设你想要在角色行走的同时喝水。通过遮罩喝水动画，我们能够将其裁剪到上半身部分。结果，我们可以让行走动画在腿部播放，而喝水动画在角色的上半身播放。
- en: If you imagine a complex game, where the characters can do many things while
    walking (such as shoot, reload or talk) this functionality is really helpful.
    Keep in mind that masking can be done to different levels. For instance, you can
    merge more than two animations together with respect to different body parts,
    as well as sub-masking. The possibilities are endless!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想象一个复杂的游戏，其中角色在行走时可以做很多事情（例如射击、装弹或交谈），这个功能真的非常有用。记住，遮罩可以在不同级别进行。例如，你可以根据不同的身体部分合并超过两个动画，以及子遮罩。可能性是无限的！
- en: 'That''s why Unity offers also a more detailed mapping when required, for instance,
    for the head or the hands, as the next picture shows, where we can see the mapping
    for the left hand:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，Unity在需要时也提供了更详细的映射，例如，对于头部或手部，如图所示，我们可以看到左手部的映射：
- en: '![Avatars](img/image00501.jpeg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![头像](img/image00501.jpeg)'
- en: All of this is really powerful when used in combination with sub-state machines,
    state-behaviors and Layers in the Animator.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能与子状态机、状态行为和动画器中的层结合使用时都非常强大。
- en: Sub-state machines
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子状态机
- en: Previously, we have seen that the Animator is a finite state machine with different
    states, each one of them as an animation clip. But in actual fact, not all of
    the states are animation clips. Some of them can be something else, such as sub-state
    machines. This means, that a state can contain another whole finite state machine!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了Animator是一个有限状态机，具有不同的状态，每个状态都是一个动画剪辑。但实际上，并非所有状态都是动画剪辑。其中一些可以是其他东西，例如子状态机。这意味着，一个状态可以包含另一个完整的有限状态机！
- en: '![Sub-state machines](img/image00502.jpeg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![子状态机](img/image00502.jpeg)'
- en: A sub-state machine appears into the upper level like a state, though with a
    slightly different shape. In fact, transitions can both start or end on a sub-state
    machine like any other state.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 子状态机以状态的形式出现在上层，尽管形状略有不同。实际上，转换可以在子状态机上开始或结束，就像任何其他状态一样。
- en: Note
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can recognize a sub-state machine since the shape around the name is slightly
    different.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过名称周围的形状略有所不同来识别子状态机。
- en: In this scenario, the exit state/node becomes important, because it allows us
    to finish/exit from the sub-state machine and continue in the next state. Of course,
    also a sub-machine can be interrupted if set to do so when some conditions are
    met. Needless to say, being able to nest animation machines is indeed a very powerful
    tool to build very complex Animators.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，退出状态/节点变得很重要，因为它允许我们完成/退出子状态机并继续到下一个状态。当然，如果满足某些条件，子机器也可以被中断。不言而喻，能够嵌套动画机确实是一个非常强大的工具，可以构建非常复杂的动画器。
- en: The hierarchical location menu
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层级位置菜单
- en: 'As we have seen, states can contain sub-states and trees and these structures
    can be nested repeatedly. When drilling down into sub-states, the hierarchy of
    parent states and the current state can be viewed on the top bar (highlighted
    in the following picture):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，状态可以包含子状态和树，这些结构可以重复嵌套。当深入到子状态时，父状态和当前状态的层次结构可以在顶部栏中查看（以下图片中突出显示）：
- en: '![The hierarchical location menu](img/image00503.jpeg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![层级位置菜单](img/image00503.jpeg)'
- en: Clicking on the parent states allows you to jump back up to parent states or
    go straight back to the base layer of the state machine.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 点击父状态允许你跳回到父状态或直接回到状态机的基层。
- en: Layers in the Animator
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画器中的层
- en: 'Now, if we want to create, view, or edit layers within our Animator Controller,
    we need to make sure that the left-hand pane is set to Layers view, like this
    image:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想在Animator控制器中创建、查看或编辑层，我们需要确保左侧面板设置为层视图，就像以下图片所示：
- en: '![Layers in the Animator](img/image00504.jpeg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![动画器中的图层](img/image00504.jpeg)'
- en: This allows you to have multiple layers of animation within a single animation
    controller. All these layers are then able to run at the same time, where each
    layer is controlled by a separate state machine. This process is commonly used
    when, for instance, you have a separate layer playing upper-body animations over
    a base layer that controls the general movement animations for a character (to
    use in combination with Avatar Masks).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在单个动画控制器中拥有多个动画层。所有这些层都可以同时运行，其中每个层由一个独立的状态机控制。这个过程在例如，你有一个单独的图层在基础层上播放上半身动画时常用，基础层控制角色的整体运动动画（与Avatar
    Masks结合使用）。
- en: To begin, click on the plus icon to add a layer. On the other hand, to delete
    a layer, select the layer and press the *Delete* key.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，点击加号图标以添加图层。另一方面，要删除图层，选择图层并按*Delete*键。
- en: Blending trees
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合树
- en: Besides Animation clips and sub-state machines, a state in the Animator can
    be also a blending tree. A common process to apply between different frames of
    an animation is to blend two or more similar motions, so that it feels like one
    fluid animation. For example, walking and running animations may require that
    key frames are blended between one another according to the character's speed.
    Ideally, you want the player to be slower if they are walking and faster if they
    are running. In some cases, the speed of how fast a player runs can also be increased
    again with game elements such as items (speed boosts). Another typical example
    is to lean the character left or right while they are turning to achieve a more
    realist behaviors. This can be obtained with blend trees, which are able to *blend*
    animation clips.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动画片段和子状态机之外，动画器中的状态也可以是一个混合树。在动画的不同帧之间应用的一个常见过程是将两个或更多相似的动作混合在一起，这样就会感觉像是一个流畅的动画。例如，行走和跑步动画可能需要根据角色的速度在关键帧之间进行混合。理想情况下，你希望玩家行走时速度较慢，跑步时速度较快。在某些情况下，玩家的跑步速度还可以通过游戏元素（如物品，速度提升）再次增加。另一个典型的例子是在角色转向时向左或向右倾斜，以实现更真实的行为。这可以通过混合树来实现，混合树能够*混合*动画片段。
- en: '![Blending trees](img/image00505.jpeg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![混合树](img/image00505.jpeg)'
- en: An example of a very common blending tree; Here the walking animation is split
    in three animation clips, so the character can lean to the left or right as he/she
    turns during the walk
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的混合树示例；在这里，行走动画被分成三个动画片段，因此角色在行走时可以向左或向右倾斜。
- en: In fact, they use linear interpolation, which can be controlled by some weights
    and parameters. Unity supports both 1D and 2D interpolation for blending trees.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它们使用线性插值，可以通过一些权重和参数进行控制。Unity支持混合树的一维和二维插值。
- en: '![Blending trees](img/image00506.jpeg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![混合树](img/image00506.jpeg)'
- en: 2D interpolation of Blending trees. Numbers and animation clips are placed at
    random, the aim of the figure it's showing the 2D interpolation in the upper part,
    where the diamond shapes are the different animation clips and the circle shape
    is the 2D value that controls the blending among the clips.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 混合树的二维插值。数字和动画片段随机放置，图中的目的是展示上部分的二维插值，其中菱形是不同的动画片段，圆形是控制片段之间混合的二维值。
- en: We won't go further into blending trees, but keep in mind that they can be used
    to blend more animations together in real time to achieve incredibly real behaviors
    and smoother animations.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会进一步探讨混合树，但请记住，它们可以用于实时混合更多动画，以实现极其真实的行为和更平滑的动画。
- en: Animator Override Controller
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画器覆盖控制器
- en: Imagine that you have just created a beautiful Animation State Machine, full
    of layers and transitions, since it is super detailed. Your character has states
    that allows her to cast a spell, to grab a coffee or to swing a sword. However,
    now, you need to consider that also a Goblin can do that. And even the Ogre of
    your second level as well as the elf that your protagonist has to fight later
    on in your game. Should you create again a very similar Animation Machine for
    each one of them, but just changing the Animation clips? And what if later on
    you decide to slightly change the controller, do you have to slightly change all
    of them? Thank God, Unity offers an easier way, called the **Animator Override
    Controller**.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你刚刚创建了一个美丽的动画状态机，它充满了层和转换，因为它非常详细。你的角色有状态，允许她施展法术、拿咖啡或挥舞剑。然而，现在，你需要考虑即使是哥布林也能做到这一点。以及你的第二级中的巨魔，以及你游戏后期要与之战斗的精灵。你是否需要为每一个都再次创建一个非常相似的动画机，但只是更改动画剪辑？而且如果你稍后决定稍微改变控制器，你是否需要稍微改变所有这些？感谢上帝，Unity提供了一个更简单的方法，称为**动画覆盖控制器**。
- en: 'You can create an **Animator Override Controller** by right-clicking on the
    project panel and navigate to **Create** | **Animator Override Controller**. It
    will be an asset as the others Animator controllers. However, you cannot open
    it in the **Animator** window. If you select it in the **Inspector**, you will
    see that you can link a normal Animator controller to it, as shown in this screenshot:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在项目面板上右键单击并导航到**创建** | **动画覆盖控制器**来创建一个**动画覆盖控制器**。它将像其他动画控制器一样成为一个资产。然而，你无法在**动画**窗口中打开它。如果你在**检查器**中选择它，你会看到你可以将其链接到一个正常的动画控制器，如图中所示：
- en: '![Animator Override Controller](img/image00507.jpeg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![动画覆盖控制器](img/image00507.jpeg)'
- en: Just for the sake of learning, we drag and drop the only controller that we
    have in our project, the panda controller. As a result, all the Animator states
    we used will appear in a list, and we can assign a different animation clip from
    the original controller.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了学习的目的，我们将我们项目中唯一的控制器，即熊猫控制器拖放到这里。结果，我们使用的所有动画状态都会出现在列表中，我们可以从原始控制器分配不同的动画剪辑。
- en: '![Animator Override Controller](img/image00508.jpeg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![动画覆盖控制器](img/image00508.jpeg)'
- en: In this way, you don't need to replicate the Animator controller but just assign
    new animation clips. Once the Animator controller changes, all the **Animator
    Override Controllers** will change accordingly, updating all the characters in
    your game that use that controller. Not bad, isn't it?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你不需要复制动画控制器，只需分配新的动画剪辑。一旦动画控制器发生变化，所有相关的**动画覆盖控制器**也会相应地改变，更新你游戏中使用该控制器的所有角色。不错，不是吗？
- en: Culling Mode in the Animator component
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画组件中的剔除模式
- en: For a moment now, picture a beautiful animation of a shiny coin. It is so beautiful
    that you decide to include many coins in your game. As a result, it might be computationally
    heavy to make rotate thousands of coins if then the player can see just three
    on his or her screen.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下一枚闪亮的硬币的美丽动画。它如此美丽，以至于你决定在你的游戏中包含许多硬币。结果，如果玩家只能看到屏幕上的三个硬币，那么旋转数千枚硬币可能会在计算上变得很重。
- en: Consider, instead, this other case. The player just turned a switch that triggers
    a really heavy and slow door. So, while the door is opening, the player explores
    a bit the environment. When he or she comes back, the player would expect that
    the animation of the door is complete and so the door is open. This means that
    the animation of the door should run also when it is not visible, whereas the
    coin is not needed to be animated in any moment, for instance when it is off screen.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一种情况。玩家刚刚打开了一个开关，触发了一扇非常重且缓慢的门。因此，当门在打开时，玩家会稍微探索一下环境。当他或她回来时，玩家会期望门的动画已经完成，所以门是开着的。这意味着门动画应该在它不可见时也运行，而硬币在任何时候都不需要动画，例如当它在屏幕之外时。
- en: 'To optimize this issue, Unity offers an option in the Animator component, the
    **Culling Mode**. This allows us to specify when the object should animate. The
    possible values are the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化这个问题，Unity在动画组件中提供了一个选项，称为**剔除模式**。这允许我们指定对象何时应该动画化。可能的值如下：
- en: '**Always Animate**: The most expensive, although realistic, solution. As the
    name suggests, the object is always animated, so in the case of the door also,
    when it is off screen, it will keep opening.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终动画**：最昂贵但也是最逼真的解决方案。正如其名所示，对象始终在动画中，所以在这种情况下，当门在屏幕之外时，它也会继续打开。'
- en: '**Cull Update Transforms**: This is a mid-solution; it disables only some parts,
    such as Retargeting and IK, to improve performance, but still has a certain degree
    of realism when needed, without paying too much in computational cost.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剔除更新变换**：这是一个中间解决方案；它仅禁用一些部分，如重定向和IK，以提高性能，但在需要时仍具有一定的真实感，而不需要付出太多的计算成本。'
- en: '**Cull Completely**: This is the cheapest from a computational point of view,
    since the object stops being animated completely when it is off screen.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全剔除**：从计算角度来看，这是最便宜的，因为当对象离屏时，它将完全停止动画。'
- en: Root motion
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根运动
- en: Some animations, in theory, should displace the character, such as walking but
    not drinking a glass of water. So in order to fix this issue in Unity, you can
    either move the character with a script, as we did in our case, or use root motion.
    As the name suggests, this allows the animation itself to move the root of the
    character (or object or creature) achieving a more realistic motion in space.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动画，从理论上讲，应该改变角色的位置，例如走路但不喝水。因此，为了在Unity中解决这个问题，你可以用脚本移动角色，就像我们在我们的案例中所做的那样，或者使用根运动。正如其名所示，这允许动画本身移动角色的根（或对象或生物）以在空间中获得更真实的运动。
- en: However, it is not straightforward and has some drawbacks. For instance, it
    is more expensive from a computational point of view, and as such, many characters
    with root motions on low-end devices could be prohibitive. Furthermore, it requires
    different tweaks, especially if the animation is not really well done.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不简单，并且有一些缺点。例如，从计算角度来看，它更昂贵，因此，在低端设备上具有根运动的许多角色可能会变得不可行。此外，它需要不同的调整，特别是如果动画做得不是很好。
- en: Inverse Kinematic
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向运动学
- en: Inverse Kinematic is something relatively new in video games. It allows you
    to have a target into the animation, and sometimes compute in real time an animation
    that suits the target. For instance, imagine a character who just wants to rest
    his or her hands on the wall. The Inverse Kinematic should allow you to control
    the animation to place the hand on the wall, regardless of whether the wall is
    1 centimeter further or closer.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 反向运动学是视频游戏中相对较新的技术。它允许你将目标纳入动画中，有时还能实时计算出适合目标的动画。例如，想象一个角色只想把手放在墙上。反向运动学应该允许你控制动画，将手放在墙上，无论墙是远1厘米还是更近。
- en: Usually animations use what is called Direct Kinematic (or Forward Kinematic).
    Based on the position and rotation of the joints, it is possible to determine
    the position of each part of the skeleton. So imagine having an arm, and based
    on the positions and rotations of your shoulder, elbow, and wrist, you can determine
    the position and rotation of your hand. In fact, these techniques come from robotic
    research.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，动画使用所谓的直接运动学（或正向运动学）。基于关节的位置和旋转，可以确定骨骼每个部分的位置。所以想象一下有一个手臂，基于肩部、肘部和手腕的位置和旋转，你可以确定手的位置和旋转。实际上，这些技术来自机器人研究。
- en: The inverse problem, known as Inverse Kinematic, is to determine the positions
    and rotations of your shoulder, elbow, and wrist starting from the position and
    rotation of your hand. However, this problem is not uniquely determined, since
    it might have infinite solutions. Therefore, solving this problem wasn't straightforward.
    In any case, different techniques (which in the case of robotics may involve inverting
    the Jacobian matrix) were developed to solve this problem.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 反向问题，称为反向运动学，是从手的位置和旋转确定肩部、肘部和手腕的位置和旋转。然而，这个问题不是唯一确定的，因为它可能有无限多的解。因此，解决这个问题并不简单。无论如何，已经开发出不同的技术（在机器人技术中可能涉及雅可比矩阵的逆运算）来解决这个问题。
- en: The problem with having different solutions is that some of them may lead to
    very unusual poses. Following again the example of the arm, a solution that, in
    order to rest the hand to the wall, brings the elbow up to the eye is not really
    believable (see the next image, on the left). Whereas this might be a relative
    problem if applied to robotics, in animation this is indeed a big problem, because
    we want our characters to be believable.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的解决方案的问题在于，其中一些可能会导致非常不寻常的姿态。再次以手臂为例，一个为了将手放在墙上而将肘部抬到眼睛高度的解决方案并不真实（见下一张图片，左侧）。虽然这可能在应用于机器人技术时是一个相对问题，但在动画中这确实是一个大问题，因为我们希望我们的角色是可信的。
- en: So, other techniques have been developed to solve the problem, and the study
    of social behaviors (for humanoid characters) have been conducted to understand
    why some poses are more realistic than others. For instance, the pose in the preceding
    picture is tiring; nobody will ever rest his hand on the wall in such way. In
    fact, this also deals with physics, since our brain tries to control our body
    in such a way to spend as less energy as possible. This results in an unconscious
    behavior that we recognize in other people, and our videogame characters need
    it as well.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，已经开发出其他技术来解决这一问题，并对社会行为（针对人形角色）进行了研究，以了解为什么某些姿势比其他姿势更真实。例如，前一张图片中的姿势很累人；没有人会把手放在墙上这样。实际上，这也涉及到物理，因为我们的大脑试图以尽可能少消耗能量的方式控制我们的身体。这导致了一种无意识的行为，我们在其他人身上也能识别出来，我们的游戏角色也需要这种行为。
- en: 'Unity implements some of these techniques, and Mecanim supports some kind of
    Inverse Kinematic for humanoid characters, given that they have a correct configured
    avatar. However, we don''t want to dig any deeper in this. I just leave the most
    curious reader with the link to the Official Documentation here: [https://docs.unity3d.com/Manual/InverseKinematics.html](https://docs.unity3d.com/Manual/InverseKinematics.html).'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Unity实现了其中一些技术，Mecanim支持人形角色的一些逆运动学，前提是他们有一个正确配置的化身。然而，我们不想深入探讨这个问题。我只是把最好奇的读者留在这里，提供官方文档的链接：[https://docs.unity3d.com/Manual/InverseKinematics.html](https://docs.unity3d.com/Manual/InverseKinematics.html)。
- en: Note
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another example where Inverse Kinematic is studied and used is for virtual presence
    in virtual reality. The recent Oculus Touch allows you to have your hands within
    the Rift Headset, but not your elbow and/or shoulder. While implementing inverse
    kinematic-even taking into account the believability and the less energy pose-the
    software is yet not able to precisely map your arm positions in space, because
    you will feel awkward. However, in multiplayer games, you can see other people
    in the virtual world but not in reality (or feel their bodies like they do), and
    therefore Inverse Kinematic can be applied. Although it won't give the exact position
    of the elbows of the other players in the game, it is close enough to be believable.
    A game that uses this mechanism is for instance Dead and Buried. As you can see
    from the next picture, you can see only your hands, but of the other players,
    you can see their whole bodies.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个研究并使用逆运动学的例子是用于虚拟现实中的虚拟存在。最近的Oculus Touch允许您在Rift头显内拥有您的手，但不能是肘部和/或肩膀。在实现逆运动学时——即使考虑到可信度和更节省能量的姿势——软件仍然无法精确地映射您的手臂在空间中的位置，因为您会感到不舒服。然而，在多人游戏中，您可以在虚拟世界中看到其他人，但在现实中却看不到（或像他们那样感受他们的身体），因此可以应用逆运动学。尽管它不会给出游戏中其他玩家肘部的确切位置，但足够接近以令人信服。例如，使用这种机制的其中一个游戏是Dead
    and Buried。正如您从下一张图片中可以看到的，您只能看到自己的手，但其他玩家的整个身体您也能看到。
- en: '![Inverse Kinematic](img/image00509.jpeg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![逆运动学](img/image00509.jpeg)'
- en: Animator component information box
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画组件信息框
- en: 'As we already mentioned before, the Animator component has an information box
    at the bottom, which may contain some useful data. Here is a picture of the information
    box again, for your reference:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，动画组件在底部有一个信息框，其中可能包含一些有用的数据。这里再次提供信息框的图片，供您参考：
- en: '![Animator component information box](img/image00510.jpeg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![动画组件信息框](img/image00510.jpeg)'
- en: 'Besides the **Clip Count** that we already have seen, here is a briefly list
    of the other information:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已看到的**剪辑数量**之外，这里简要列出其他信息：
- en: '**Pos**, **Rot**, and **Scale**: These indicate the total number of curves
    used respectively for the position, rotation and scale. The animation window,
    the one we didn''t see in detail, allows you to create such curves.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**、**旋转**和**缩放**：这些分别表示用于位置、旋转和缩放的曲线总数。动画窗口，我们没有详细看到的一个，允许您创建这样的曲线。'
- en: '**Muscles**: The number of muscles used in the Animator in case of Humanoid
    characters.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**肌肉**：在动画器中用于人形角色的肌肉数量。'
- en: '**Generic**: The number of numeric curves used by the Animator to animate other
    properties.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**：动画器用于动画其他属性的数值曲线数量。'
- en: '**PPtr**: The total count of sprite animation curves; it is useful when we
    work in 2D.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PPtr**：精灵动画曲线的总数；当我们在2D中工作时很有用。'
- en: '**Curves Count**: The total combined number of animation curves.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**曲线数量**：动画曲线的总数。'
- en: '**Constant**: The number of animation curves that are optimized as constant
    values. Unity selects this automatically if your animation files contain curves
    with unchanging values.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**: 作为常量值优化的动画曲线数量。如果您的动画文件包含具有不变值的曲线，Unity会自动选择此选项。'
- en: '**Dense**: The number of animation curves that are optimized using the *dense*
    method of storing data (discrete values, which are interpolated between linearly).
    This method uses less significantly less memory than the *stream* method.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密集**: 使用*密集*方法存储数据（离散值，这些值在线性之间进行插值）优化的动画曲线数量。这种方法比*流式*方法使用的内存显著更少。'
- en: '**Stream**: The number of animation curves using the *stream* method of storing
    data (values with time and tangent data for curved interpolation). This data occupies
    significantly more memory than the *dense* method.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流式存储**: 使用*流式*方法存储数据（用于曲线插值的值和时间以及切线数据）的动画曲线数量。这种数据比*密集*方法占用更多的内存。'
- en: Legacy animation
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统的动画
- en: A simpler animation system was used by Unity prior to the introduction of Mecanim
    (in year 2012, with Unity 4.0). Given that some time has passed since then, backward
    compatibility is still available. As a result, it is still possible to continue
    working on older projects without having to update Mecanim or worrying about other
    issues arising from the software.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mecanim（2012年，Unity 4.0版本）引入之前，Unity使用了一个更简单的动画系统。鉴于从那时起已经过去了一段时间，向后兼容性仍然存在。因此，仍然可以在不更新Mecanim或担心软件引发的其他问题的情况下继续处理旧项目。
- en: Some people find the Legacy animation system useful for fast prototyping and/or
    testing animation clips, especially when the object has only one animation clip.
    This is because it was based on the Animation component (picture given next),
    and it should not be confused with the Animator component that we have seen before
    in the chapter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人发现传统的动画系统对于快速原型制作和/或测试动画剪辑很有用，尤其是在对象只有一个动画剪辑时。这是因为它是基于动画组件（下图中所示），并且不应与我们在本章之前看到的Animator组件混淆。
- en: '![Legacy animation](img/image00511.jpeg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![传统动画](img/image00511.jpeg)'
- en: 'You can find out more about the Legacy animation system here in the official
    documentation: [https://docs.unity3d.com/Manual/Animations.html](https://docs.unity3d.com/Manual/Animations.html).'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中了解更多关于传统动画系统信息：[https://docs.unity3d.com/Manual/Animations.html](https://docs.unity3d.com/Manual/Animations.html)。
- en: So, unless you have a specific need for it, you can completely ignore the Legacy
    Animation system, but it was worthwhile to mention it so that you don't get confused
    in case you found the Animation component and didn't know what it was.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非您有特定的需求，否则您可以完全忽略传统的动画系统，但提到它是值得的，以免您在找到动画组件但不知道它是做什么的时候感到困惑。
- en: In saying that, and while the legacy animation is still available, it is not
    recommended that you use it for new projects with Unity.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在说这个的同时，虽然传统的动画仍然可用，但不建议您使用它来创建新的Unity项目。
- en: Get animated!!
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始动画吧！！
- en: One practical example to do that takes you outside of Unity is to think about
    the movement involved in animation. For example, when you are walking, typing,
    drinking, eating, any kind of movement, do it in slow motion. What you begin to
    notice is how subtle movements can make animations distinct and give it character.
    For each animation, such as drinking a glass of water for instance, do it in a
    different way. Pick up the cup, perhaps with a different grip such as using your
    whole hand or a few fingers around the handle. As you begin to become more conscious
    about movement, you should be able to gain some insight into how you might need
    to adjust an animation in Unity when something doesn't quite feel right. To get
    a better idea again, search for videos, even books to explore the uses of animation
    and some of their underpinnings. While this book is in no way a how to on animation,
    understanding the fundamentals not only help you to improve your own understanding
    about animations, but also help you to better understand the role of an animator
    and what it entails. This kind of information will be valuable to you later if
    you ever work or need to work with an animator.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际例子是思考动画中涉及到的动作。例如，当你走路、打字、喝水、吃饭，任何类型的动作，都尝试用慢动作来做。你开始注意到微妙的动作如何使动画独特并赋予其个性。对于每个动画，比如喝水，你可以用不同的方式来做。拿起杯子，可能用不同的握法，比如用整个手或几个手指握住把手。当你开始更加关注动作时，你应该能够获得一些关于你如何在Unity中调整动画的见解，当某些事情感觉不太对劲时。为了再次获得更好的想法，搜索视频，甚至书籍，以探索动画的应用和一些基础。虽然这本书并不是关于动画的指南，但理解基础不仅有助于你提高自己对动画的理解，而且有助于你更好地理解动画师的角色及其所涉及的内容。如果你将来需要与动画师合作，这类信息将对你非常有价值。
- en: Homework
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'In this chapter, we faced many aspects of Animation clips and Animator controllers.
    However, before we go to the next chapter, I invite you to give a look to these
    exercises to improve your skills:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遇到了动画剪辑和动画控制器方面的许多方面。然而，在我们进入下一章之前，我邀请你看看这些练习，以提高你的技能：
- en: '**Becoming an animation designer**: Think of five games that you play, and
    select a part of each game such as the tutorial level, fighting a boss, walking
    through a forest, or even the main menu. Now, write down a list of animations
    that each of them have. Next, remove some animations, or even add some and think
    how it would alter the experience. Does it improve it, or does it change the atmosphere
    entirely? Could you make a relatively happy atmosphere really dark by changing
    some of the animations, and vice versa? By doing this, you will begin to understand
    the importance that animations play on not only providing life to your game, but
    also emotion and setting the atmosphere.'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**成为动画设计师**：想想你玩过的五款游戏，并选择每个游戏的一部分，比如教程关卡、与Boss战斗、穿过森林，甚至是主菜单。现在，列出每个游戏所拥有的动画列表。接下来，移除一些动画，甚至添加一些，并思考这会如何改变体验。它是否改善了体验，或者是否完全改变了氛围？你能通过改变一些动画，让相对愉快的氛围变得非常黑暗，反之亦然吗？通过这样做，你将开始理解动画在不仅为你的游戏带来生命，而且带来情感和设定氛围方面所扮演的重要角色。'
- en: '**Drawing an animation (Part I)**: Imagine that you need to create an animation;
    you can do this simply in a graphics program. Begin by blocking out the arm; you
    can use a square for the hand, a rectangle for the forearm, and a longer rectangle
    for the upper arm. Now, move each one so that it performs a swing animation. It
    would be ideal to set it up like the Sprite Sheets that we have used so far. Then,
    import them inside Unity and test it out.'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画绘制（第一部分）**：想象一下你需要创建一个动画；你可以在图形程序中简单地完成这个任务。首先，勾勒出手臂的轮廓；你可以用正方形代表手，用矩形代表前臂，用更长的矩形代表上臂。现在，移动每一个部分，使其能够执行摆动动画。理想的情况是设置成我们之前使用的精灵图集那样。然后，将它们导入Unity中并测试一下。'
- en: '**Drawing an animation (Part II)**: Now, add details to your animation, or
    other body parts such as legs. Moreover, feel free to add some special effects,
    like the Hit animation of the panda. Once you have you animation ready, try to
    create a second and a third one. Then, import them all, set them up, and build
    an Animator controller to see how they are animated. Furthermore, you can polish
    your animations in order to improve the transitions between them.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画绘制（第二部分）**：现在，给你的动画添加细节，或者添加其他身体部位，比如腿。此外，你可以自由地添加一些特殊效果，比如熊猫的击打动画。一旦你的动画准备好了，尝试创建第二个和第三个。然后，将它们全部导入，设置好，并构建一个动画控制器来查看它们的动画。此外，你可以润色你的动画，以改善它们之间的过渡。'
- en: '**A less dauntless Panda (Part I)**: As we have scripted, when the panda is
    hit, it keeps moving forward. However, the panda should be a little stunned. Only
    when the animation finishes, the panda should continue its advance towards the
    player''s cake. Fix this problem with any technique you come up, so you can modify
    the **Panda Script** or create Machine State Behaviours.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个不那么无畏的熊猫（第一部分）**：正如我们所编写的，当熊猫被击中时，它会继续向前移动。然而，熊猫应该有点震惊。只有当动画结束时，熊猫才应该继续向玩家的蛋糕前进。用你想到的任何技术解决这个问题，以便你可以修改**熊猫脚本**或创建机器状态行为。'
- en: '**A less dauntless Panda (Part II)**: If you have done the previous exercise
    and found a solution to the fix, it''s time to make your code a bit more robust.
    Add a Boolean value in the **Panda Script** and stop the panda from moving when
    it is hit, but only if the Boolean is set to true. In this way, we can expose
    this variable in the **Inspector** and give more possibilities of which kind of
    panda the player has to face (continued in the next chapter).'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个不那么无畏的熊猫（第二部分）**：如果你已经完成了前面的练习并找到了解决方案，那么是时候让你的代码更加健壮了。在**熊猫脚本**中添加一个布尔值，并在布尔值设置为true时停止熊猫移动，但只有当它被击中时。这样，我们可以在**检查器**中公开这个变量，为玩家面临的熊猫类型提供更多可能性（在下一章中继续）。'
- en: '**State Machine Behaviour as a listener**: We have implemented the **Panda
    Script** in such a way that triggers are set in the Animator controller to change
    animations. Now, remove both the Hit and Die triggers from the **Panda Script**
    and implement other Machine State Behaviours that retrieve the value of panda''s
    health and respectively trigger the Hit animation when health is decreased from
    the last time or the Die animation if it is below zero.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**状态机行为作为监听器**：我们已经以这种方式实现了**熊猫脚本**，在Animator控制器中设置了触发器以改变动画。现在，从**熊猫脚本**中移除击打和死亡触发器，并实现其他机器状态行为，这些行为检索熊猫的健康值，并在健康值从上次降低或低于零时分别触发击打动画或死亡动画。'
- en: '**Explore the Animation window**: Even if we didn''t deal with the animation
    window, you can try to explore it, maybe by following the link to the official
    documentation provided. Then, try to make some animations for our sprinkles so
    that they can rotate while they are flying towards an evil Panda. Maybe you can
    also create a collision animation. Wrap these animations within an Animator controller
    and modify the Projectile script if needed.'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**探索动画窗口**：即使我们没有处理动画窗口，你也可以尝试探索它，也许可以通过点击提供的官方文档链接。然后，尝试为我们的糖浆制作一些动画，以便它们在飞向邪恶熊猫的过程中旋转。也许你还可以创建一个碰撞动画。将这些动画包裹在Animator控制器中，并在需要时修改Projectile脚本。'
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Thus, we created four different animation clips for our panda, one for each
    of its possible actions: Walk, Die, Hit, and Eat. Then, we wrapped them within
    a controller and built a finite state machine to define how these animation clips
    are linked, through transitions. Finally, we wrote a script to trigger the different
    states of the machine.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为我们的熊猫制作了四个不同的动画片段，每个片段对应其可能的行为：行走、死亡、击打和进食。然后，我们将它们包裹在一个控制器中，并构建了一个有限状态机来定义这些动画片段如何通过转换相互链接。最后，我们编写了一个脚本来触发机器的不同状态。
- en: Now that we have seen how to animate our Pandas, it's time to move on to the
    next chapter, maybe after a coffee break.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何为我们的熊猫动画，是时候进入下一章了，也许在喝杯咖啡之后。
