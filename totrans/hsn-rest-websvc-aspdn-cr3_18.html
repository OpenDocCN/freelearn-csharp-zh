<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing Your Service</h1>
                
            
            
                
<p class="mce-root">In the previous chapters, we saw how to exchange data between multiple services using an event bus and resilient clients and how to consume messages and run background services using ASP.NET Core. This chapter is about securing service data. It covers concepts such as SSL, <strong>cross-origin resource sharing</strong> (<strong>CORS</strong>), and HTTP/2, and it walks through the implementation of token-based authentication. </p>
<p class="mce-root">In more detail, this chapter covers the following topics:</p>
<ul>
<li>A general overview of SSL</li>
<li>How to enable CORS in an ASP.NET Core service</li>
<li>How to enable HTTPS and HTTP/2</li>
<li>How token-based authentication works</li>
<li>How to build token-based authentication in ASP.NET Core</li>
</ul>
<p>By the end of the chapter, you will have a broad understanding of the security features provided by ASP.NET Core, and you will be able to implement token-based authentication in ASP.NET Core.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of secure communication</h1>
                
            
            
                
<p>Security is a crucial aspect of building applications. Web services usually expose information to third-party clients and companies; therefore, it is vital to avoid leaking data. The security layer of a web service is often a tedious part of the development process because it is hard to test and to verify. </p>
<p>Security is important even for web services that are published in the internal network of the company, which, by default, is not accessible from the outside. As software engineers, we should do as much as possible to guarantee a strong level of security when we release a web service. It is also essential to understand that securing a web service is necessary to identify the consumers of your data and to prevent overuse of your web service. The next section will start by describing HTTPS and how to secure your data using HTTPS in a ASP.NET Core web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing data using HTTPS  </h1>
                
            
            
                
<p>A common practice for attackers is to intercept data exchanged between the client and the server. For that reason, it is essential to encrypt communication between them to keep the data secure. SSL uses SSL certificates to set up a trusted connection between the server company and the client. SSL uses <em>symmetric</em> and <em>asymmetric encryption</em> to encrypt keys used during this communication. Let's see a schema of a typical SSL handshake between client and server:</p>
<div><img src="img/38cf9627-a94f-4c11-a896-59138269b4f8.png" style=""/></div>
<p>This schema shows the conventional steps of an SSL handshake: </p>
<ol>
<li>The connection starts with the client that initiates the request. Before the start, the server sends an SSL certificate to the client, which ensures that the certificate is valid and trustable.</li>
<li>The client proceeds by extracting and encrypting the <em>public key</em> included in the SSL certificate.</li>
</ol>
<ol start="3">
<li>The client sends the encrypted key (private key) to the server, which encodes the data and transmits it back to the client.</li>
<li>Data communication starts and the encrypted key is used to encrypt and decrypt data shared by the client and the server.</li>
</ol>
<p class="mce-root">SSL is the basis of the HTTPS protocol, which is the standard way to transfer encrypted data. The following section describes how to set up and enforce HTTPS in ASP.NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enforcing HTTPS in ASP.NET Core</h1>
                
            
            
                
<p>HTTPS is enabled by default on ASP.NET Core. The main middleware related to the HTTPS protocol is the  <kbd>HttpsRedirection</kbd> middleware class, which enforces redirection from HTTP to HTTPS. Therefore, it is possible to call the <kbd>UseHttpsRedirection</kbd> extension method in the <kbd>Startup</kbd> class in order to enable the middleware.</p>
<p>Let's see how to enable and force HTTPS in an ASP.NET Core application running in a docker container. The first step is to generate a self-signed certificate used by the ASP.NET Core application that runs in the container. .NET Core provides a global tool that creates a self-signed certificate on your local environment called <kbd>dotnet-dev-certs</kbd>. We can proceed by installing this tool on our local environment using the following CLI command:</p>
<pre><strong>dotnet tool install --global dotnet-dev-certs</strong></pre>
<p>After that, it is possible to create a new certificate using the <kbd>.pfx</kbd> format in the following command:</p>
<pre><strong>dotnet dev-certs https -ep &lt;path_to_certificate&gt;/certificate.pfx -p &lt;certificate_password&gt;</strong></pre>
<p>The aforementioned instruction specifies the export path using the <kbd>-ep</kbd> option, with the <kbd>-p</kbd> password. Furthermore, it is possible to trust the certificate using the <kbd>--trust</kbd> options. </p>
<p>It is important to note that the <kbd>dotnet-dev-certs</kbd> tool works only on Windows and macOS. In the case of Linux, we should proceed by generating the certificate using OpenSSL. The following tutorial (<a href="https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core">https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core</a>) provides more information about the creation of an HTTPS certificate using OpenSSL.</p>
<p>Once we have created a new certificate file, we can proceed by adjusting the <kbd>docker-compose.yml</kbd> file of the <kbd>Catalog.API</kbd> and <kbd>Cart.API</kbd> solutions:</p>
<pre>version: "3.7"<br/>services:<br/>  catalog_api:<br/>    container_name: catalog_api<br/>    build:<br/>      context: .<br/>      dockerfile: containers/api/Dockerfile<br/><strong>    volumes:</strong><br/><strong>      - ./&lt;path_to_certificate&gt;/:/root/.dotnet/https</strong><br/>    env_file:<br/>      - containers/api/api.env<br/>    networks:<br/>      - my_network<br/>    ports:<br/>      - 5000:5000<br/><strong>      - 5001:5001</strong><br/>    depends_on:<br/>      - catalog_db<br/>      - catalog_esb<br/><br/> ...</pre>
<p>The aforementioned <kbd>docker-compose.yml</kbd> definition declares a <kbd>volumes</kbd> node to create a binding between the local   <kbd>./certificate/</kbd> folder and the <kbd>/root/.dotnet/https</kbd> folder in the instance of the container. Furthermore, we can proceed by adding the following variables in the <kbd>containers/api.env</kbd> file:</p>
<pre>ASPNETCORE_ENVIRONMENT=Integration<br/>ASPNETCORE_URLS=https://*:5001<br/>ASPNETCORE_Kestrel__Certificates__Default__Password=&lt;certificate_password&gt;<br/>ASPNETCORE_Kestrel__Certificates__Default__Path=/root/.dotnet/https/certificate.pfx</pre>
<p>The file adds two environment variables related to the certificate: <kbd>ASPNETCORE_Kestrel__Certificates__Default__Password</kbd> provides the certificate password, and <kbd>ASPNETCORE_Kestrel__Certificates__Default__Path</kbd> defines its path.  The new definition of the <kbd>docker-compose.yml</kbd> file also exposes the <kbd>5001</kbd> port, and it also adds the <kbd>https://*:5001 URL</kbd> URL to the pool of URLs run by Kestrel. Futhermore, now it is possible to enforce the HTTPS in our <kbd>Startup</kbd> class by adding the following line in the <kbd>Configure</kbd> method:</p>
<pre>app<strong>.</strong>UseHttpsRedirection();</pre>
<p>After applying the HTTPS restriction, the client will always be redirected to the HTTPS endpoint of the web service for every request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP/2 on Kestrel</h1>
                
            
            
                
<p>ASP.NET Core has supported HTTP/2 on Kestrel since version 2.2.0, and it is enabled by default if you are using HTTPS. In addition, another HTTP/2 requirement is support for the <strong>Application-Layer Protocol Negotiation</strong> (<strong>ALPN</strong>) protocol. The ALPN protocol enhances the handshake process between a client and a server: the client lists all the supported protocols, and the server will confirm which protocol to use for the HTTP transfer. Moreover, this approach allows an eventual fallback to HTTP 1.1 if the client or the server doesn't support HTTP/2.</p>
<p>As the default configuration, both HTTP 1.1 and HTTP/2 run on the same binding, but it is possible to customize and create a dedicated binding for HTTP/2 by extending the Kestrel configuration in the <kbd>static void Main</kbd> method:</p>
<pre>using System.Net;<br/>using Microsoft.AspNetCore;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Server.Kestrel.Core;<br/><br/>namespace Catalog.API<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            CreateWebHostBuilder(args).Build().Run();<br/>        }<br/><br/>        public static IWebHostBuilder CreateWebHostBuilder(string[] args)<br/>        {<br/>            return WebHost.CreateDefaultBuilder(args)<br/>                <strong>.ConfigureKestrel(options =&gt;</strong><br/><strong>                {</strong><br/><strong>                    options.Listen(IPAddress.Any, 5002,listenOptions =&gt;</strong><br/><strong>                    {</strong><br/><strong>                        listenOptions.Protocols = HttpProtocols.Http2;</strong><br/><strong>                    });</strong><br/><strong>                })</strong><br/>                .UseStartup&lt;Startup&gt;();<br/>        }<br/>    }<br/>}</pre>
<p>This snippet shows how to set an HTTP/2 binding on port number <kbd>5002</kbd>. This approach forces the HTTP/2 bindings without providing any fallback to HTTP 1.1.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enabling CORS in ASP.NET Core</h1>
                
            
            
                
<p>Another critical aspect of security is to protect our APIs from CORS calls. By default, it is not possible to use client-side code to call services that are hosted on other domains, because scam websites may use a cross-origin call to get sensitive information about users. This security restriction is called <em>the same-origin policy</em>.</p>
<p>The restrictions on the <em>same-origin policy</em> act on HTTP calls using the following criteria:</p>
<ul class="postList">
<li class="graf graf--li graf-after--p">The request is made from a different domain (for example, the site at <kbd>example.com</kbd> calls <kbd>api.com</kbd>).</li>
<li class="graf graf--li graf-after--p">The request is enabled from a different subdomain (for example, the website at <kbd>example.com</kbd> calls <kbd>api.example.com</kbd>).</li>
<li class="graf graf--li graf-after--li">The request is made from a different port (for example, the site at <kbd>example.com</kbd> calls <kbd>example.com:3001</kbd>).</li>
<li class="graf graf--li graf-after--li">The request is made from a different protocol (for example, the <kbd>https://example.com</kbd> site calls <kbd>http://example.com</kbd>).</li>
</ul>
<p class="mce-root">CORS provides a way to allow a specific domain to make client-side calls to a service hosted within a different domain. This kind of approach becomes very useful when we want to enable a customer or a third-party client to call our service without restrictions. It is also essential to note that CORS can be enabled to allow every domain. This approach must be avoided because it will enable attackers to use our API inappropriately.</p>
<p class="mce-root">ASP.NET Core provides an out-of-the-box way to enable CORS<em>.</em> The framework permits the creation of CORS policies using two approaches: the <em>middleware approach</em> and the <em>attributes approach.</em> As we saw in <a href="77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml">Chapter 3</a>, <em>Working with the Middleware Pipeline</em>, middleware are usually implemented to develop cross-cutting logic that covers the whole web service. On the other hand, <em>attributes</em> are used to apply a restriction on a single action. In the same way, this approach is taken for CORS policies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing CORS using the middleware approach</h1>
                
            
            
                
<p>The <em>CORS middleware</em> approach can be used to enable a specific HTTP domain, method, or port to call our service. As with any middleware, it can be defined in the <kbd>Startup</kbd> class of the service, specifically in the <kbd>Configure</kbd> method:</p>
<pre>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>       ...<br/>  <br/>        public void Configure(IApplicationBuilder app, <br/>        IWebHostingEnvironment env)<br/>        {<br/>            ...<br/>           <strong> app.UseCors(cfg =&gt;</strong><br/><strong>            {</strong><br/><strong>                cfg.AllowAnyOrigin();</strong><br/><strong>            });</strong><br/><strong>            </strong><br/>            ..<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>UseCors</kbd> middleware extension method accepts an action method to configure the different rules. For example, the previous code executes the <kbd>AllowAnyOrigin</kbd> method to allow calls from any website. In the same way, it is possible to define more restricting rules on a specific domain, like this:</p>
<pre>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>       ...<br/>        public void Configure(IApplicationBuilder app, <br/>        IWebHostingEnvironment env)<br/>        {<br/>            ...<br/>           <strong> app.UseCors(cfg =&gt;</strong><br/><strong>            {</strong><br/><strong>                cfg.AllowAnyOrigin("https://samuele.dev");</strong><br/><strong>            });</strong><strong>   </strong><br/>            ...<br/>        }<br/>    }<br/>}</pre>
<p>In this case, we are blocking all cross-origin requests except those coming from the <a href="https://samuele.dev/">https://samuele.dev/</a> website. A more advanced and clean way to define CORS rules is to group them using named policies. It is also possible to use the following approach:</p>
<pre>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>      <br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            ...<br/>            services.AddCors(opt =&gt;<br/>            {<br/>               <strong> opt.AddPolicy("BlogDomainPolicy", cfg =&gt; <br/>                { cfg.WithOrigins("https://samuele.dev"); });</strong><br/>            });<br/>            ..<br/>        }<br/><br/>        public void Configure(IApplicationBuilder app, <br/>        IWebHostingEnvironment env)<br/>        {<br/>           ...<br/>            <strong>app.UseCors("BlogDomainPolicy");</strong><br/>           ...<br/>        }<br/>    }<br/>}</pre>
<p>The previous code defines a CORS policy with the name <kbd>BlogDomainPolicy</kbd> using the <kbd>app.AddCors</kbd> construct in the <kbd>ConfigureServices</kbd> method. Once we have described the rules for the policy, we can proceed with using the defined policy in the <kbd>Configure</kbd> method of the <kbd>Startup</kbd> class using the <kbd>app.UseCors</kbd> method. It will enable us to establish different policies and apply them conditionally in the <kbd>Startup</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing CORS using the attribute approach</h1>
                
            
            
                
<p>In some cases, it may be necessary to define specific policies for some routes or actions. Therefore, it is possible to apply CORS policies using attributes, as follows:</p>
<pre>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    [JsonException]<br/>  <strong>  [EnableCors("BlogDomainPolicy")]</strong><br/>    public class ItemController : ControllerBase<br/>    {<br/>        <br/>        ...<br/>    }<br/>}</pre>
<p>In this case, we are restricting the use of the <kbd>BlogDomainPolicy</kbd> only to the <kbd>ItemController</kbd>. Therefore, all of the routes defined under the controller will use the same policy. In the same way, we can add the policy to a specific action method in the controller:</p>
<pre>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    [JsonException]<br/>   <strong> [EnableCors("BlogDomainPolicy")]</strong><br/>    public class ItemController : ControllerBase<br/>    {<br/>        ...<br/><br/>        [HttpGet("{id:guid}")]<br/>        <strong>[EnableCors("GetByIdActionPolicy")]</strong><br/>        public async Task&lt;IActionResult&gt; GetById(string id)<br/>        {<br/>            ...<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>In that case, the <kbd>GetByIdActionPolicy</kbd> will act only on the <kbd>GetById</kbd> action method, while the <kbd>BlogDomainPolicy</kbd> will act on the whole controller. This approach provides a nice level of granularity; furthermore, it provides a way to specify policies for a single route of the service. The next section describes the characteristics of the token-based authentication approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing APIs with token-based authentication</h1>
                
            
            
                
<p>Applications have traditionally persisted identity through session cookies, relying on session IDs stored on the server-side. This method brings a few significant problems and pitfalls: it is <em>not</em> <em>scalable</em>,<em> </em>because you need a common point where you can store sessions and, every time a user is authenticated; the server will need to create a new record in a data source. Therefore, this approach may become a significant bottleneck for your web service. </p>
<p>Nowadays, token authentication can be helpful to authenticate and authorize users, especially in a distributed system context. The main strength of token-based authentication lies in the fact that the consumer asks for a token to an identity<em> </em>service. Next, the client can store the token locally and use it for authentication and authorization purposes.</p>
<p>Therefore, token authentication is <em>stateless</em> and <em>designed to be scalable</em>. Let's have a look at the token-authentication process and how it works, to better understand the benefits of this kind of approach:</p>
<div><img src="img/1ee505ee-009d-4b3e-a04b-4499295d996b.png" style=""/></div>
<p>This schema describes a typical workflow when implementing token-based authentication. The schema describes three entities:</p>
<ul>
<li>The <em>client</em> is the application that is trying to access our resources.</li>
<li>The <em>identity provider</em> is the service that, given a username and a password, provides an encrypted authentication token.</li>
<li>The <em>resource provider</em> is another service called by the <em>client.</em> Furthermore<em>, the resource provider </em>will accept the encrypted authentication token, and it will provide the information requested by the <em>client</em> if it is authorized.</li>
</ul>
<p>Since token-based authentication has a <em>stateless</em> approach, the application doesn't store the authentication tokens. Therefore, it is essential to note that the client must pass the authentication token in every request.</p>
<p>Token-based authentication can be implemented in different ways. <strong>JSON Web Token</strong> (<strong>JWT</strong>) is a standard, defined in the RFC 7519 (<a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>) open directive, which describes a way to represent claims between two parties. JWT is defined as a JSON object, which contains the payload, and a signature, which encrypts the data in the token. In other words, it provides a way to encrypt secure data formatted as JSON through the use of a secret key. The JWT token standard has become quite popular in recent years because web services can use it for two purposes:</p>
<ul>
<li><strong>Authorization</strong>: The web service returns a JWT token to transfer information about claims and personal details to signed-in users. Moreover, single sign-on features and token authentication features use this technique to transfer data to the client.</li>
<li><strong>Information exchange</strong>: You can use the JWT token standard to prevent data exploitation and to certify the authenticity of the data you have received by signing it with the provided key.</li>
</ul>
<p>The JWT token anatomy is very similar to the structure of a web request. It is composed of three parts: <em>header</em>, <em>payload</em>, and <em>signature</em>. The header part contains information about the token type and the signing algorithm used by the token:</p>
<pre>{   "alg": "HS256",   "typ": "JWT" }</pre>
<p>In that case, we can deduce that the token uses the <em>HMAC</em> <em>SHA256</em> algorithm, and it is a JWT token type. The <em>payload</em> part is the core part of our token, and it contains the information to be sent to the user. By default, there is a set of predefined information to populate, for example, the <kbd>exp</kbd> <em>(expiration time)</em> field. The following JSON is an example of a payload:</p>
<pre>{<br/>  "email": "example@handsonaspnetcore.com",<br/>  "nbf": 1546196276,<br/>  "exp": 1546801076,<br/>  "iat": 1546196276<br/>}</pre>
<p>The <kbd>email</kbd> field is a claim for the token. <kbd>nbf</kbd> stands for <strong>not valid before</strong>, and <kbd>iat</kbd> stands for <strong>issued at</strong>. The three fields represent the time calculated since the UNIX epoch.</p>
<p>Finally, the <em>signature</em> part of the token signs the encoded header and the encoded payload with the secret key and the algorithm specified in the header.</p>
<p>The resulting encoded token is similar to the following:</p>
<pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<strong>.</strong>eyJlbWFpbCI6InNhbXVlbGUucmVzY2FAZ21haWwuY29tIiwibmJmIjoxNTQ2MTk2Mjc2LCJleHAiOjE1NDY4MDEwNzYsImlhdCI6MTU0NjE5NjI3Nn0<strong>.</strong>yQGT1TJYL4U_IqBpoQ6MjUchET06BRE-YJ0sf-MRA</pre>
<p>It is crucial to note that each point separator (<kbd>.</kbd>) in the encoded token represents an encrypted token, as described earlier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing token-based authentication</h1>
                
            
            
                
<p>In this section, we will see how to perform token-based authentication using ASP.NET Core. Going into more detail, we will dig into the development and testing of the token-based authentication and learn how to store user data in a database using the default identity provider of ASP.NET Core.  </p>
<p>Furthermore, we will implement the authentication as part of the <em>catalog service</em> solution. It is essential to note that, in real-world applications, the authentication and the whole identity process have a dedicated service with a separate data store.</p>
<p>For demo purposes, we are going to implement the authentication part inside the <em>catalog service</em>. Please consider keeping the identity part of your application in a separate service.</p>
<p>Let's start by adding the packages we need to develop token-based authentication in our <kbd>Catalog.Domain</kbd> and <kbd>Catalog.Infrastructure</kbd> projects. Please note that these packages are compatible only with the <kbd>netcoreapp3.1</kbd> framework, therefore, you need to change the <kbd>TargetFramework</kbd> variable in the csproj from <kbd>netstandard2.1</kbd> to <kbd>netcoreapp3.1</kbd>:</p>
<pre><strong>dotnet add Catalog.Domain package Microsoft.AspNetCore.Authentication.JwtBearer</strong><br/><strong>dotnet add Catalog.Infrastructure package Microsoft.AspNetCore.Identity.EntityFrameworkCore</strong></pre>
<p>The next step is to define the <kbd>User</kbd> entity inside the <kbd>Catalog.Domain</kbd> project:</p>
<pre>using Microsoft.AspNetCore.Identity;<br/><br/>namespace Catalog.Domain.Entities<br/>{<br/>    public class User : IdentityUser<br/>    {<br/>        public string Name { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>User</kbd> entity represents a generic user inside the <em>domain model</em> of the service. It is important to note that it extends the <kbd>IdentityUser</kbd> class, which provides some additional fields to the entity. The <kbd>IdentityUser</kbd> class identifies a storable user entity. Furthermore, the entity can be used to store data through the <kbd>Microsoft.AspNetCore.Identity</kbd> package.</p>
<p>Let's proceed by declaring the <kbd>IUserRepository</kbd> interface in the <kbd>Catalog.Domain</kbd> project:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Domain.Repositories<br/>{<br/>    public interface IUserRepository<br/>    {<br/>        Task&lt;bool&gt; AuthenticateAsync(string email, string password, <br/>            CancellationToken cancellationToken = default);<br/>        Task&lt;bool&gt; SignUpAsync(User user, string password, <br/>            CancellationToken cancellationToken = default);<br/>        Task&lt;User&gt; GetByEmailAsync(string requestEmail, <br/>            CancellationToken cancellationToken = default);<br/>    }<br/>}</pre>
<p>This interface represents an intermediary between the <em>catalog service</em> and the data layer. Moreover, it can be used to authenticate, register, and retrieve <kbd>User</kbd> entities. The <kbd>IUserRepository</kbd> acts like a data store for the user data, and it also performs user-related operations, such as the sign-up process and authentication. It is also important to note that the <kbd>AuthenticateAsync</kbd> and <kbd>SignUpAsync</kbd> methods return a boolean that indicates whether the corresponding operation has succeeded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the service layer</h1>
                
            
            
                
<p>After defining the <kbd>User</kbd> entity and the <kbd>IUserRepository</kbd> interface, we can proceed with the definition of the service layer in the <kbd>Catalog.Domain</kbd> project. Let's start by describing the <kbd>IUserService</kbd> interface:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Repositories;<br/>using Catalog.Domain.Requests.User;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public interface IUserService<br/>    {<br/>        Task&lt;UserResponse&gt; GetUserAsync(GetUserRequest request, <br/>            CancellationToken cancellationToken = default);<br/>        Task&lt;UserResponse&gt; SignUpAsync(SignUpRequest request, <br/>            CancellationToken cancellationToken = default);<br/>        Task&lt;TokenResponse&gt; SignInAsync(SignInRequest request, <br/>            CancellationToken cancellationToken = default);<br/>    }<br/>}</pre>
<p>The interface defines the methods necessary for the authentication phase. The <kbd>GetUserAsync</kbd> method uses the <kbd>GetUserRequest</kbd> type to retrieve information related to a specific user. The <kbd>SignUpAsync</kbd> and the <kbd>SignInAsync</kbd> methods define the sign-up and sign-in process: the sign-up operation returns a new <kbd>UserResponse</kbd> instance, which determines the information related to the signed user, and the sign-in operation returns the <kbd>TokenResponse</kbd> instance, which contains the resulting token that will be stored by the client. Therefore, let's proceed by defining the request DTOs used by the service interface:</p>
<pre>namespace Catalog.Domain.Requests.User<br/>{<br/>    public class GetUserRequest<br/>    {<br/>        public string Email { get; set; }<br/>    }<br/>    <br/>    public class SignInRequest<br/>    {<br/>        public string Email { get; set; }<br/>        public string Password { get; set; }<br/>    }<br/>    <br/>    public class SignUpRequest<br/>    {<br/>        public string Email { get; set; }<br/>        public string Password { get; set; }<br/>        public string Name { get; set; }<br/>    }<br/>}</pre>
<p>For brevity, request classes are represented in a unique snippet.  The <kbd>GetUserRequest</kbd> type contains an <kbd>Email</kbd> field that specifies the email address to retrieve. As we will see later in the chapter, the <kbd>GetUser</kbd> action method of the controller will need to be authenticated in order to retrieve the user's data.</p>
<p>The <kbd>SignInRequest</kbd> type defines the <kbd>Email</kbd> and the <kbd>Password</kbd> fields used to authenticate the user. Finally, the <kbd>SignUpRequest</kbd> type also contains the <kbd>Name</kbd> of the user represented by a string. Please note that for demo purposes, the code only stores the <kbd>Name</kbd> of the user. In a real-world application, the complexity of the <kbd>SignUpRequest</kbd> type is likely to increase with more personal information.</p>
<p>Let's proceed by also defining the response type used by the <kbd>IUserService</kbd> interface:</p>
<pre>namespace Catalog.Domain.Responses<br/>{<br/>    public class TokenResponse<br/>    {<br/>        public string Token { get; set; }<br/>    }<br/>    <br/>    public class UserResponse<br/>    {<br/>        public string Name { get; set; }<br/>        public string Email { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>UserResponse</kbd> type is meant to retrieve all the personal information of the user. It is important to note that it obviously omits the <kbd>Password</kbd> field of the entity for security reasons. On the other hand, the <kbd>TokenResponse</kbd> type retrieves the <kbd>Token</kbd> field containing the JWT token resulting from the authentication process.</p>
<p>Therefore, we can continue by describing the implementation of <kbd>IUserService</kbd> interface: it will contain the logic related to the generation of the token used by ASP.NET Core for authentication, and the get and sign-up operations on user entities. The following code illustrates the dependencies in the implementation:  </p>
<pre>using System;<br/>using System.IdentityModel.Tokens.Jwt;<br/>using System.Security.Claims;<br/>using System.Text;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Repositories;<br/>using Catalog.Domain.Requests.User;<br/>using Catalog.Domain.Responses;<br/>using Microsoft.Extensions.Options;<br/>using Microsoft.IdentityModel.Tokens;<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public class UserService : IUserService<br/>    {<br/><strong>        private readonly AuthenticationSettings <br/>            _authenticationSettings;</strong><br/><strong>        private readonly IUserRepository _userRepository;</strong><br/><br/>        public UserService(IUserRepository userRepository, <br/><strong>        IOptions&lt;AuthenticationSettings&gt; authenticationSettings</strong>)<br/>        {<br/>            _userRepository = userRepository;<br/>            _authenticationSettings = authenticationSettings.Value;<br/>        }</pre>
<p>As mentioned previously, the <kbd>IUserRepository</kbd> interface is used as the main entry point to query and perform operations on our data source. <kbd>IOption&lt;AuthenticationSettings&gt;</kbd> type defines the settings needed by the authentication process:</p>
<pre> namespace Catalog.Domain.Configurations<br/>{<br/>    public class AuthenticationSettings<br/>    {<br/>        public string Secret { get; set; }<br/>        public int ExpirationDays { get; set; }<br/>    }<br/>}</pre>
<p>The class is stored in the <kbd>Configurations</kbd> folder of the <kbd>Catalog.Domain</kbd> project. The <kbd>AuthenticationSettings</kbd> class contains the <kbd>Secret</kbd> field, which describes a phrase that is used to encrypt the token's information, and the <kbd>ExpirationDays</kbd> field provides the number of days before the omitted tokens expire. Furthermore, we can proceed by defining the <kbd>GetUserAsync</kbd> and the <kbd>SignUpAsync</kbd> methods:</p>
<pre>...<br/>public async Task&lt;UserResponse&gt; GetUserAsync(GetUserRequest request, <br/>    CancellationToken cancellationToken)<br/>{<br/>    var response = await _userRepository.GetByEmailAsync(request.Email, <br/>        cancellationToken);<br/><br/>    return new UserResponse { Name = response.Name, Email = <br/>        response.Email };<br/>}<br/><br/>public async Task&lt;UserResponse&gt; SignUpAsync(SignUpRequest request, <br/>    CancellationToken cancellationToken)<br/>{<br/>    var user = new Entities.User { Email = request.Email, UserName = <br/>        request.Email, Name = request.Name };<br/><br/>    bool result = await _userRepository.SignUpAsync(user, <br/>        request.Password, cancellationToken);<br/><br/>    return !result ? null : new UserResponse { Name = request.Name, <br/>        Email = request.Email };<br/>}<br/>...</pre>
<p>The <kbd>GetUserAsync</kbd> method uses the request provided by the high-level layer to execute the <kbd>GetByEmailAsync</kbd> method of the <kbd>IUserRepository</kbd> interface. It also maps the response and retrieves a new instance of the <kbd>UserReponse</kbd> type.</p>
<p>On the other hand, the <kbd>SignUpAsync</kbd> method initializes a new <kbd>User</kbd> instance with the corresponding values, and it performs the <kbd>SignUpAsync</kbd> method provided by the <kbd>IUserRepository</kbd> interface. Finally, if the user is created, the <kbd>SignUpAsync</kbd> method retrieves a new <kbd>UserResponse</kbd> instance. Let's continue by completing the implementation of the <kbd>IUserService</kbd> by defining the <kbd>SignInAsync</kbd> method:</p>
<pre>...<br/>public async Task&lt;TokenResponse&gt; SignInAsync(SignInRequest request,     CancellationToken cancellationToken)<br/>{<br/>    bool response = await _userRepository.<br/>       AuthenticateAsync(request.Email, request.Password,<br/>       cancellationToken);<br/><br/>    return response == false ? null : new TokenResponse { Token = <br/>        <strong>GenerateSecurityToken</strong>(request)          k . };<br/><br/>}<br/><br/>private string <strong>GenerateSecurityToken</strong>(SignInRequest request)<br/>{<br/>    var tokenHandler = new JwtSecurityTokenHandler();<br/>    var key = Encoding.ASCII.GetBytes(_authenticationSettings.Secret);<br/><br/>    var tokenDescriptor = new SecurityTokenDescriptor<br/>    {<br/>        Subject = new ClaimsIdentity(new[]<br/>        {<br/>            new Claim(ClaimTypes.Email, request.Email)<br/>        }),<br/>        Expires = <br/>        DateTime.UtcNow.AddDays<br/>        (_authenticationSettings.ExpirationDays),<br/>        SigningCredentials = new SigningCredentials(new <br/>        SymmetricSecurityKey(key), <br/>            SecurityAlgorithms.HmacSha256Signature)<br/>    };<br/><br/>    var token = tokenHandler.CreateToken(tokenDescriptor);<br/>    return tokenHandler.WriteToken(token);<br/>}<br/>...</pre>
<p>As a first step, the <kbd>SignInAsync</kbd> method calls the underlying <kbd>AuthenticateAsync</kbd> method provided by <kbd>IUserRepository</kbd> by giving the <kbd>Email</kbd> and the <kbd>Password</kbd> sent by the client. The statement returns a boolean variable that indicates whether the user is authenticated. If the user is authenticated, the method retrieves a new instance of the <kbd>TokenResponse</kbd> class by calling the <kbd>GenerateSecurityToken</kbd> method.</p>
<p>The <kbd>GenerateSecurityToken</kbd> method defines a new instance of the <kbd>JwtSecurityTokenHandler</kbd> type, which provides some utilities for generating and creates tokens through the use of the <kbd>CreateToken</kbd> and the <kbd>WriteToken</kbd> methods.</p>
<p>Furthermore, it defines a new instance of the <kbd>SecurityTokenDescriptor</kbd> type, which declares the <kbd>Expire</kbd> time and the <kbd>SigningCredentials</kbd> fields by signing the <kbd>Secret</kbd> field of the <kbd>AuthorizationSettings</kbd> instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying authentication on the controller</h1>
                
            
            
                
<p>The next steps consist of registering dependencies in the dependency injection engine and in using the resulting dependency, for example, the <kbd>IUserService</kbd> instance, in the controller layer. Therefore, this section focuses on the <kbd>Catalog.API</kbd> and <kbd>Catalog.Infrastructure</kbd> projects.</p>
<p>Let's start by defining a new extension method in the <kbd>Catalog.Infrastructure</kbd> project, which adds the authentication part:</p>
<pre>using System.Text;<br/>using Catalog.Domain.Configurations;<br/>using Microsoft.AspNetCore.Authentication.JwtBearer;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using Microsoft.IdentityModel.Tokens;<br/>namespace Catalog.Infrastructure.Extensions<br/>{<br/>    public static class AuthenticationExtensions<br/>    {<br/>        public static IServiceCollection AddTokenAuthentication(this <br/>            IServiceCollection services, IConfiguration configuration)<br/>        {<br/>            var settings = configuration.GetSection<br/>                ("AuthenticationSettings");<br/>            var settingsTyped = settings.Get&lt;AuthenticationSettings&gt;();<br/><br/>            services.Configure&lt;AuthenticationSettings&gt;(settings);<br/>            var key = Encoding.ASCII.GetBytes(settingsTyped.Secret);<br/>            services.AddAuthentication(x =&gt;<br/>                {<br/>                    x.DefaultAuthenticateScheme = <br/>                        JwtBearerDefaults.AuthenticationScheme;<br/>                    x.DefaultChallengeScheme = <br/>                        JwtBearerDefaults.AuthenticationScheme;<br/>                })<br/>                .AddJwtBearer(x =&gt;<br/>                {<br/>                    x.TokenValidationParameters = new <br/>                        TokenValidationParameters<br/>                        {<br/>                            IssuerSigningKey = new <br/>                                SymmetricSecurityKey(key),<br/>                            ValidateIssuer = false,<br/>                            ValidateAudience = false<br/>                        };<br/>                });<br/>            return services;<br/>        }<br/>    }<br/>}</pre>
<p>The core part of the preceding code is the execution of two methods: <kbd>AddAuthentication</kbd> and <kbd>AddJwtBearer</kbd>. Both extension methods add the middlewares and the services used by the authentication process. In more detail, <kbd>AddAuthentication</kbd> specifies <kbd>DefaultAuthenticationScheme</kbd> and <kbd>DefaultChallengeScheme</kbd> by applying the JWT bearer authentication scheme.</p>
<p>At the same time, the <kbd>AddJwtBearer</kbd> method defines the options related to token authentication, such as the <kbd>TokenValidationParameters</kbd> field, which includes the <kbd>SigningKey</kbd> used to validate the token parameter.</p>
<p>Furthermore, the <kbd>IssuerSigningKey</kbd> must be the same as the key used to generate the token. Otherwise, the validation will fail. It is important to note that the <kbd>ValidateIssuer</kbd> and the <kbd>ValidateAudience</kbd> fields are <kbd>false</kbd>. Therefore, ASP.NET Core will not validate the issuer or the audience URL. Although this approach works fine for testing environments, I strongly suggest using the following setup for production cases:</p>
<pre>.AddJwtBearer(x =&gt;<br/>{<br/>    x.TokenValidationParameters = new TokenValidationParameters<br/>    {<br/>        IssuerSigningKey = new SymmetricSecurityKey(key),<br/>  <strong>      ValidateIssuer = true,</strong><br/><strong>        ValidateAudience = true,</strong><br/><strong>        ValidIssuer = "yourhostname",</strong><br/><strong>        ValidAudience = </strong><strong>"yourhostname"</strong><br/>    };<br/>});</pre>
<p>In this case, the validation of the issuer and the audience will happen; therefore it will check that the token issuer and the audience of the token match those specified in the configurations. The <kbd>AddTokenAuthentication</kbd> extension method also owns the registration of the <kbd>AuthenticationSettings</kbd> used by the <kbd>UserService</kbd> class. Therefore, let's have a look at the <kbd>AuthenticationSettings</kbd> values defined in the <kbd>appsettings.json</kbd> file:</p>
<pre>...<br/>"AuthenticationSettings": {<br/>    "Secret": "My Super long secret",<br/>    "ExpirationDays": "7"<br/>}<br/>...</pre>
<p>After that, we can proceed by adding the authentication implementation to the <kbd>Startup</kbd> class in the <kbd>Catalog.API</kbd> project:</p>
<pre>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>        public Startup(IConfiguration configuration, <br/>        IWebHostingEnvironment environment)<br/>        {<br/>            Configuration = configuration;<br/>            CurrentEnvironment = environment;<br/>        }<br/><br/>        <strong>...</strong><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            ...<br/>        <br/>            services<br/>               <strong>  .AddTokenAuthentication(Configuration)</strong><br/>             <br/>            ...<br/>        }<br/><br/>        public void Configure(IApplicationBuilder app, <br/>        IHostingEnvironment env)<br/>        {<br/>            ...<br/>          <strong>  app.UseAuthentication();<br/>            app.UseAuthorization();<br/>            </strong>app.UseEndpoints(endpoints =&gt;<strong><br/>       </strong>     {<strong><br/>           </strong>     endpoints.MapControllers();<strong><br/>            </strong>});<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>Startup</kbd> class is the core component that initializes the authentication process. In the <kbd>ConfigureServices</kbd> method, it configures and initializes the <kbd>AuthorizationSettings</kbd> class by reading from the <kbd>appsettings.json</kbd> file. Next, it calls the <kbd>AddAuthentication</kbd> extension method by passing the <kbd>AuthorizationSettings</kbd> type instance. It is also essential to note that the <kbd>Configure</kbd> method adds authentication middleware by calling the <kbd>UseAuthentication</kbd> method. </p>
<p>Finally, we can proceed by adding the <kbd>UserController</kbd> and exposing authentication routes:</p>
<pre>using System.Linq;<br/>using System.Security.Claims;<br/>using System.Threading.Tasks;<br/>using Catalog.API.Filters;<br/>using Catalog.Domain.Requests.User;<br/>using Catalog.Domain.Services;<br/>using Microsoft.AspNetCore.Authorization;<br/>using Microsoft.AspNetCore.Mvc;<br/><br/>namespace Catalog.API.Controllers<br/>{<br/>    <strong>[Authorize]</strong><br/>    [ApiController]<br/>    [Route("api/user")]<br/>    [JsonException]<br/>    public class UserController : ControllerBase<br/>    {<br/>        private readonly IUserService _userService;<br/><br/>        public UserController(IUserService userService)<br/>        {<br/>            _userService = userService;<br/>        }<br/><br/>        [HttpGet]<br/>        public async Task&lt;IActionResult&gt; Get()<br/>        {<br/>            var claim = HttpContext.User.Claims.FirstOrDefault(x =&gt; <br/>                x.Type == ClaimTypes.Email);<br/><br/>            if (claim == null) return Unauthorized();<br/><br/>            var token = await _userService.GetUserAsync(new <br/>                GetUserRequest { Email = claim.Value });<br/>            return Ok(token);<br/>        }<br/><br/>        <strong>[AllowAnonymous]</strong><br/>        [HttpPost("auth")]<br/>        public async Task&lt;IActionResult&gt; SignIn(SignInRequest request)<br/>        {<br/>            var token = await _userService.SignInAsync(request);<br/>            <br/>            if (token == null) return BadRequest();<br/>            <br/>            return Ok(token);<br/>        }<br/><br/>        <strong>[AllowAnonymous]</strong><br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; SignUp(SignUpRequest request)<br/>        {<br/>            var user = await _userService.SignUpAsync(request);<br/>            if (user == null) return BadRequest();<br/>            return CreatedAtAction(nameof(Get), new { }, null);<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code defines the <kbd>UserController</kbd> class, which exposes authentication routes. It is important to note that the whole controller is decorated by using the <kbd>[Authorize]</kbd> attribute, which means that each route is covered by authentication. Therefore, to access the routes declared within the controller it is necessary to use a valid token in the request. The class defines an action method for each operation defined before in the service layer:</p>
<ul>
<li>The <kbd>Get</kbd> action method exposes some details regarding the current user, such as the <kbd>Email</kbd> field and the <kbd>Name</kbd> field. The action method gets user details from the incoming token. The token information is represented by accessing the <kbd>HttpContext.User</kbd> property and getting the value of <kbd>ClaimType.Email</kbd>.</li>
<li>The <kbd>SignIn</kbd> action method is decorated using <kbd>[AllowAnonymous]</kbd> attribute. Furthermore, it is possible to call the action method without being authenticated. The action method binds the <kbd>request.Email</kbd> and <kbd>request.Password</kbd> fields and sends the request object using <kbd>IUserService</kbd> interface. The action method returns the <kbd>TokenResponse</kbd> with the generated token.</li>
</ul>
<ul>
<li>The <kbd>SignUp</kbd> action method is also decorated using the <kbd>[AllowAnonymous]</kbd> attribute. In that case, the action method registers a new user and returns the <kbd>201 Created</kbd> HTTP code if the operation has success.</li>
</ul>
<p>Our setup is now almost complete. What we need to do is define the last common point between the <kbd>IUserRepository</kbd> interface and the underlying data store. For this purpose, we will use again the EF Core framework combined with the <kbd>Microsoft.AspNetCore.Identity.EntityFrameworkCore</kbd> package maintained by Microsoft.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Storing data using EF Core</h1>
                
            
            
                
<p>Let's proceed by implementing the data access layer and create a concrete implementation of the <kbd>IUserRepository</kbd> interface. The <kbd>UserRepository</kbd> class will have to main dependencies, the <kbd>SignInManager</kbd> and the <kbd>UserManager</kbd> classes, both of which are provided by the <kbd>Microsoft.AspNetCore.Identity</kbd> package:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/>using Microsoft.AspNetCore.Identity;<br/>using Microsoft.EntityFrameworkCore;<br/><br/>namespace Catalog.Infrastructure.Repositories<br/>{<br/>    public class UserRepository : IUserRepository<br/>    {<br/>        private readonly SignInManager&lt;User&gt; _signInManager;<br/>        private readonly UserManager&lt;User&gt; _userManager;<br/><br/>        public UserRepository(UserManager&lt;User&gt; userManager, <br/>            SignInManager&lt;User&gt; signInManager)<br/>        {<br/>            _userManager = userManager;<br/>            _signInManager = signInManager;<br/>        }<br/><br/>        public async Task&lt;bool&gt; AuthenticateAsync(string email, <br/>            string password, CancellationToken cancellationToken)<br/>        {<br/>            var result = await _signInManager.PasswordSignInAsync(<br/>                email, password, false, false);<br/>            return result.Succeeded;<br/>        }<br/><br/>        public async Task&lt;bool&gt; SignUpAsync(User user, string password, <br/>            CancellationToken cancellationToken)<br/>        {<br/>            var result = await _userManager.CreateAsync(user, <br/>                password);<br/>            return result.Succeeded;<br/>        }<br/><br/>        public async Task&lt;User&gt; GetByEmailAsync(string requestEmail, <br/>            CancellationToken cancellationToken)<br/>        {<br/>            return await _userManager<br/>                .Users<br/>                .FirstOrDefaultAsync(u =&gt; u.Email == requestEmail, <br/>                    cancellationToken);<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, the resulting code implements the <kbd>IUserRepository</kbd> interface. The class depends on the <kbd>SignInManager&lt;User&gt;</kbd> and the <kbd>UserManager&lt;User&gt;</kbd> types. These types accept a generic entity class that is a representation of the authentication objects. The <kbd>SignInManager&lt;T&gt;</kbd> generic class provides functionalities with which to interact with the user sign-in process.</p>
<p>It exposes the <kbd>PasswordSignInAsync</kbd> method used by the <kbd>UserRepository.Authenticate</kbd> method. On the other hand, the <kbd>UserManager&lt;T&gt;</kbd> class provides ways to interact with users in a persistent store. Furthermore, <kbd>UserRepository</kbd> uses the <kbd>SignUp</kbd> and the <kbd>UserRepository.GetByEmail</kbd> method to interact with the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring the identity database context</h1>
                
            
            
                
<p>Once we have declared the <kbd>IUserRepository</kbd> implementation, we can proceed by declaring the <em>identity data context. </em>The <em>identity data context</em> is identified by extending the <kbd>IdentityDbContext</kbd> class. This type of <kbd>DbContext</kbd> is used by EF Core to locate and access the data source used as the persistent user store. In order to declare the <em>identity data context,</em> it is necessary to extend the <kbd>CatalogContext</kbd> in the following way:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/><strong>using Microsoft.AspNetCore.Identity.EntityFrameworkCore;</strong><br/>using Microsoft.EntityFrameworkCore;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/>using Catalog.SchemaDefinitions;<br/><br/>namespace Catalog.Infrastructure<br/>{<br/>    public class CatalogContext : <strong>IdentityDbContext&lt;User&gt;,</strong> IUnitOfWork<br/>    {<br/>          ...<br/>       <br/>        protected override void OnModelCreating(ModelBuilder <br/>            modelBuilder)<br/>        {<br/>            modelBuilder.ApplyConfiguration(new <br/>                ItemEntitySchemaDefinition());<br/>            modelBuilder.ApplyConfiguration(new <br/>                GenreEntitySchemaConfiguration());<br/>            modelBuilder.ApplyConfiguration(new <br/>                ArtistEntitySchemaConfiguration());<br/>            <br/>          <strong>  base.OnModelCreating(modelBuilder);</strong><br/>        }<br/>    }<br/>}</pre>
<p>It is essential to note that the <kbd>IdentityDbContext</kbd> class extends the <kbd>DbContext</kbd> class. Furthermore, every property and behavior present in the <kbd>DbContext</kbd> class is also inherited by the <kbd>IdentityDbContext</kbd> class. Therefore, it is essential to note that the override method, <kbd>OnModelCreating</kbd>, must also call the base method.</p>
<p>To provide a way to store user information using EF Core, it is also necessary to add and configure the identity system for the specified <kbd>User</kbd> type by calling the <kbd>AddIdentity</kbd> extension method. Furthermore, it is also essential to call <kbd>AddEntityFrameworkStores</kbd> and refer to the <kbd>CatalogContext</kbd> class to add the entity framework implementation. The following code is the previously created <kbd>AddAuthentication</kbd> extension method:</p>
<pre>using System.Text;<br/>using Microsoft.AspNetCore.Authentication.JwtBearer;<br/>using Microsoft.AspNetCore.Identity;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using Microsoft.IdentityModel.Tokens;<br/>using Catalog.Domain;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Infrastructure.Extensions<br/>{<br/>    public static class AuthenticationExtensions<br/>    {<br/>        public static IServiceCollection AddTokenAuthentication(this <br/>        IServiceCollection services, AuthenticationSettings settings)<br/>        {<br/>            var key = Encoding.ASCII.GetBytes(settings.Secret);<br/><br/>         <strong>   services.AddIdentity&lt;User, IdentityRole&gt;()</strong><br/><strong>                .AddEntityFrameworkStores&lt;CatalogContext&gt;();</strong><br/><br/>            ...<br/>            return services;<br/>        }<br/>    }<br/>}</pre>
<p>Finally, we can proceed by initializing <kbd>IUserRepository</kbd> with its concrete implementation. Also, in that case, we will declare the dependency injection resolution in the <kbd>Startup</kbd> class:</p>
<pre>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            ...<br/>          <strong>  services.AddScoped&lt;IUserRepository, UserRepository&gt;();</strong>            </pre>
<p>In the same way, we can register <kbd>IUserService</kbd> by adding the following row to the <kbd>AddServices</kbd> extension method:</p>
<pre>public static IServiceCollection AddServices(this IServiceCollection services)<br/>{<br/>    services<br/>          ...<br/>        <strong>.AddScoped&lt;IUserService, UserService&gt;();</strong><br/><br/>    return services;<br/>}</pre>
<p>To sum up, now we have the whole authentication stack in place. The <kbd>Catalog.API</kbd> project exposes the HTTP routes through the <kbd>UserController</kbd> class. The controller depends on the <kbd>IUserService</kbd> interface, which exposes the operation needed by the authentication process.</p>
<p>Consequently, the <kbd>UserService</kbd> class depends on the <kbd>IUserRepository</kbd> interface, which is the main entry point that calls the API exposed by the EF Core framework. Therefore, we can now proceed by verifying the authentication logic using some tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing authentication</h1>
                
            
            
                
<p>Testing our code is essential at this point: we should check, document, and verify the behaviors of our system before running the application in a server instance. Furthermore, it is also crucial to test authentication behavior because it is a sensitive part of our service. </p>
<p>Since the <kbd>UserRepository</kbd> implementation is the most low-level part of the authentication stack and the first component that relies on EF Core to retrieve, update, and authenticate the user, we can keep it isolated and exclude it from the testing process by mocking the <kbd>IUserRepository</kbd> interface.</p>
<p>Both <kbd>SignInManager&lt;T&gt;</kbd> and the  <kbd>UserManager&lt;T&gt;</kbd> classes represent a core part of our authentication process, and they are part of a third-party package maintained by Microsoft. Furthermore, it is not necessary to cover their implementations with tests.</p>
<p>Let's start by defining a new <kbd>UserContextFactory</kbd> in the <kbd>Catalog.Fixture</kbd> project in the <kbd>tests</kbd> folder:</p>
<div><pre>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Repositories;<br/>using Microsoft.AspNetCore.Identity;<br/>using Moq;<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class UsersContextFactory<br/>    {<br/>        private readonly PasswordHasher&lt;User&gt; _passwordHasher;<br/>        private readonly IList&lt;User&gt; _users;<br/><br/>        public UsersContextFactory()<br/>        {<br/>            _passwordHasher = new PasswordHasher&lt;User&gt;();<br/><br/>            _users = new List&lt;User&gt;();<br/><br/>            var user = new User<br/>            {<br/>                Id = "test_id",<br/>                Email = "samuele.resca@example.com",<br/>                Name = "Samuele Resca"<br/>            };<br/>            user.PasswordHash = _passwordHasher.HashPassword(user, <br/>            "P@$$w0rd");<br/><br/>            _users.Add(user);<br/>        }<br/><br/>        public IUserRepository InMemoryUserManager =&gt; <br/>        GetInMemoryUserManager();<br/><br/>        <strong>private IUserRepository GetInMemoryUserManager()</strong><br/><strong>        {</strong><br/><strong>            ...</strong><br/><strong>        }</strong><br/>    }<br/>}</pre></div>
<p>The factory class exposes an <kbd>IUserRepository</kbd> instance with some pre-populated data and it depends on the <kbd>PasswordHasher&lt;T&gt;</kbd> generic type, which is used by <kbd>SignUp</kbd> and in the <kbd>Authenticate</kbd> mock methods declaration to <em>encode-decode</em> the password by using the <kbd>HashPassword</kbd> and <kbd>VerifyHashedPassword</kbd> methods. </p>
<p>It is important to note that the <kbd>IUserRepository</kbd> interface is mocked through the use of the <kbd>GetInMemoryUserManager</kbd> method. Furthermore, it uses <kbd>List&lt;User&gt;</kbd> to emulate a data source, and it implements the <kbd>AuthenticateAsync</kbd>, <kbd>GetByEmailAsync</kbd>, and <kbd>SignUpAsync</kbd> methods exposed by the <kbd>IUserRepository</kbd> interface using the <kbd>Moq</kbd> library:</p>
<pre>namespace Catalog.Fixtures<br/>{<br/>    public class UsersContextFactory<br/>    {<br/>    ...<br/>        <strong>private IUserRepository GetInMemoryUserManager()</strong><br/>        {<br/>            var fakeUserService = new Mock&lt;IUserRepository&gt;();<br/><br/>            fakeUserService.Setup(x =&gt; <br/>            x.<strong>AuthenticateAsync</strong>(It.IsAny&lt;string&gt;(), <br/>            It.IsAny&lt;string&gt;(), CancellationToken.None))<br/>                .ReturnsAsync((string email, string password, <br/>                CancellationToken token) =&gt;<br/>                {<br/>                    var user = _users.FirstOrDefault(x =&gt; <br/>                    x.Email == email);<br/><br/>                    if (user == null) return false;<br/><br/>                    var result = _passwordHasher.<br/>                        VerifyHashedPassword(user,  <br/>                    user.PasswordHash, password);<br/>                    return result == PasswordVerificationResult.<br/>                        Success;<br/>                });<br/>            fakeUserService.Setup(x =&gt; <br/>            x.<strong>GetByEmailAsync</strong>(It.IsAny&lt;string&gt;(), <br/>                CancellationToken.None))<br/>                .ReturnsAsync((string email, CancellationToken token) <br/>            =&gt; <br/>                 _users.First(x =&gt; x.Email == email));<br/>            fakeUserService.Setup(x =&gt; x.<strong>SignUpAsync</strong>(It.IsAny&lt;User&gt;(), <br/>            It.IsAny&lt;string&gt;(), CancellationToken.None))<br/>                .ReturnsAsync((User user, string password,  <br/>                CancellationToken token) =&gt;<br/>                {<br/>                    user.PasswordHash = <br/>                        _passwordHasher.HashPassword(user, <br/>                    password);<br/>                    _users.Add(user);<br/>                    return true;<br/>                });<br/>            return fakeUserService.Object;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code returns a mocked <kbd>IUserRepository</kbd> instance by providing a fake behavior for the methods of the interface. Consequently, it is possible to verify the <kbd>IUserService</kbd> class by implementing the following test class:</p>
<pre>using System.Threading.Tasks;<br/>...<br/>namespace Catalog.Domain.Tests.Services<br/>{<br/>    public class UserServiceTests : IClassFixture&lt;UsersContextFactory&gt;<br/>    {<br/>        private readonly IUserService _userService;<br/><br/>        public UserServiceTests(UsersContextFactory <br/>            usersContextFactory)<br/>        {<br/>            _userService = new UserService(usersContextFactory.<br/>             InMemoryUserManager, Options.Create( <br/>             new AuthenticationSettings { Secret = <br/>             "Very Secret key-word to match", ExpirationDays = 7 }));<br/>        }<br/>        [Fact]<br/>        public async Task <br/>        signin_with_invalid_user_should_return_a_valid_token_response()<br/>        {<br/>            var result =<br/>                await _userService.SignInAsync(new SignInRequest { <br/>                Email = "invalid.user", Password = "invalid_password" });<br/>            result.ShouldBeNull();<br/>        }<br/>        [Fact]<br/>        public async Task <br/>        signin_with_valid_user_should_return_a_valid_token_response()<br/>        {<br/>            var result =<br/>                await _userService.SignInAsync(new SignInRequest { <br/>                Email = "samuele.resca@example.com",<br/>                Password = "P@$$w0rd" });<br/>            result.Token.ShouldNotBeEmpty();<br/>        }<br/>        ...<br/>    }<br/>}</pre>
<p>The test class implements two different tests: <kbd>signin_with_invalid_user_should_return_a_valid_token_response</kbd> and <kbd>signin_with_valid_user_should_return_a_valid_token_response</kbd>. In both cases, the tests will use <kbd>UserContextFactory</kbd> to resolve the dependency of the class. We will also use the <kbd>Option.Create</kbd> method provided by ASP.NET Core to generate <kbd>AuthenticationSettings</kbd> options. In this case, we are testing the entire stack that has been implemented in the handler layer.</p>
<p>It is essential to note that we are excluding the whole underlying part related to the management and storage of the users' information. We can expand the scope of our tests by including the controller part. Going into more detail, we can implement the test to check the functionalities implemented in the <kbd>UserController</kbd> class. To do that, we will inject a fake <kbd>IUserRepository</kbd> implementation at <kbd>TStartup</kbd> time, using the <kbd>services.Replace</kbd> instruction:</p>
<pre>using System;<br/>...<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class InMemoryApplicationFactory&lt;TStartup&gt;<br/>        : WebApplicationFactory&lt;TStartup&gt; where TStartup : class<br/>    {<br/>        protected override void ConfigureWebHost(IWebHostBuilder <br/>            builder)<br/>        {<br/>            builder<br/>                .UseEnvironment("Testing")<br/>                .ConfigureTestServices(services =&gt;<br/>                {<br/>                    ...<br/>                  <strong>  services.Replace(ServiceDescriptor.Scoped(_ =&gt; new       <br/>                    UsersContextFactory().InMemoryUserManager));</strong><br/><br/>                    var sp = services.BuildServiceProvider();<br/><br/>                    using var scope = sp.CreateScope();<br/>                    var scopedServices = scope.ServiceProvider;<br/>                    var db = scopedServices.GetRequiredService<br/>                    &lt;CatalogContext&gt;();<br/>                    db.Database.EnsureCreated();<br/>                });<br/>        }<br/>    }<br/>}</pre>
<p>We can act on the <kbd>InMemoryApplicationFactory&lt;TStartup&gt;</kbd> class to replace the <kbd>IUserService</kbd> with a new instance of the mocked class by initializing the <kbd>UsersContextFactory</kbd> class. After that, it will be possible to test the <kbd>UserController</kbd> class action by resolving the <kbd>InMemoryApplicationFactory&lt;TStartup&gt;</kbd> factory class:</p>
<pre>using System.Net;<br/>...<br/>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class UserControllerTests : <br/><strong>    IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;</strong><br/>    {<br/>      <strong>  private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;</strong><br/><br/>        public UserControllerTests(InMemoryApplicationFactory&lt;Startup&gt; <br/>        factory)<br/><br/>        {<br/>            _factory = factory;<br/>        }<br/><br/>        [Theory]<br/>        [InlineData("/api/user/auth")]<br/>        public async Task sign_in_should_retrieve_a_token(string url)<br/>        {<br/>            var client = _factory.CreateClient();<br/>            var request = new SignInRequest { Email = <br/>            "samuele.resca@example.com", Password = "P@$$w0rd" };<br/>            var httpContent =<br/>                new StringContent(JsonConvert.SerializeObject(request), <br/>                Encoding.UTF8, "application/json");<br/><br/>            var response = await client.PostAsync(url, httpContent);<br/>            string responseContent = await <br/>            response.Content.ReadAsStringAsync();<br/><br/>            response.EnsureSuccessStatusCode();<br/>            response.StatusCode.ShouldBe(HttpStatusCode.OK);<br/>            responseContent.ShouldNotBeEmpty();<br/>        }<br/><br/>        [Theory]<br/>        [InlineData("/api/user/auth")]<br/>        public async <br/>        Task sign_in_should_retrieve_bad_request_with_invalid_password<br/>        (string url)<br/>        {<br/>            var client = _factory.CreateClient();<br/>            var request = new SignInRequest { Email = <br/>            "samuele.resca@example.com", Password = "NotValidPWD" };<br/>            var httpContent =<br/>                new StringContent(JsonConvert.SerializeObject(request), <br/>                Encoding.UTF8, "application/json");<br/><br/>            var response = await client.PostAsync(url, httpContent);<br/>            string responseContent = await <br/>            response.Content.ReadAsStringAsync();<br/>            response.StatusCode.ShouldBe(HttpStatusCode.BadRequest);<br/>            responseContent.ShouldNotBeEmpty();<br/>        }<br/>            ...<br/>        }<br/>    }<br/>}</pre>
<p>The previous code verifies the routes defined in the <kbd>UserController</kbd> class, and it also performs an integration test by checking the authentication process. The <kbd>sign_in_should_retrieve_a_token</kbd> test method calls the <kbd>/api/user/auth</kbd> address using the HTTP <kbd>POST</kbd> verb to verify the implementation of the sign-in procedure.</p>
<p>Additionally, it also validates the operation in case the user's password is wrong.  Furthermore, we can also provide more tests to verify the whole process of authentication, from the sign-in phase to the call to retrieve the authenticated user data:</p>
<pre>...<br/><br/>[Theory]<br/>[InlineData("/api/user")]<br/>public async Task get_with_authorized_user_should_retrieve_the_right_user(string url)<br/>{<br/>    var client = _factory.CreateClient();<br/><br/>    var signInRequest = new SignInRequest { Email = <br/>    "samuele.resca@example.com", Password = "P@$$w0rd" };<br/>    var httpContent = new StringContent(JsonConvert.SerializeObject<br/>    (signInRequest), Encoding.UTF8, "application/json");<br/><br/>    var response = await client.PostAsync(url + "/auth", httpContent);<br/>    string responseContent = await <br/>        response.Content.ReadAsStringAsync();<br/><br/>    response.EnsureSuccessStatusCode();<br/><br/>    var tokenResponse = JsonConvert.DeserializeObject&lt;TokenResponse&gt;<br/>    (responseContent);<br/><br/>    client.DefaultRequestHeaders.Authorization =<br/>        new AuthenticationHeaderValue("Bearer", tokenResponse.Token);<br/><br/>    var restrictedResponse = await client.GetAsync(url);<br/><br/>    restrictedResponse.EnsureSuccessStatusCode();<br/>    restrictedResponse.StatusCode.ShouldBe(HttpStatusCode.OK);<br/>}<br/>...</pre>
<p>Going into more detail, the <kbd>get_with_authorized_user_should_retrieve_the_right_user</kbd> test executes the following operations:</p>
<ol>
<li>It performs a <kbd>POST</kbd> request to the following route/<kbd>auth</kbd> in order to authenticate the user.</li>
<li>It deserializes the result of the <kbd>POST</kbd> request, and it gets the token field.</li>
<li>It adds an authentication header by passing the token, and it performs a request to the <kbd>/api/user</kbd> route.</li>
<li>It checks that the result status code is HTTP <kbd>200 OK</kbd>.</li>
</ol>
<p>In this way, we are testing both the <kbd>UsersController</kbd> class and the underlying handlers used in each action method.  It is also possible to test the authentication process by running the catalog web service using the <kbd>docker-compose up --build</kbd> command. First of all, we need to create a new user by adding  some necessary information, such as the email and the name of the user:</p>
<pre>curl -X POST \<br/>  https://localhost:5001/api/users \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "email": "newuser@example.com",<br/>    "password": "&lt;my_secret_password&gt;",<br/>    "name": "Your name"<br/>}'</pre>
<p>The previous HTTP call (written as a <kbd>curl</kbd> call) creates a new user with the specified credentials. We can proceed by generating the token using our credentials:</p>
<pre>curl -X POST \<br/>  https://localhost:5001/api/users/auth \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "email": "newuser@example.com",<br/>    "password": "&lt;my_secret_password&gt;"<br/>}'</pre>
<p>Finally, we can continue by calling the secret endpoint using the following call:</p>
<pre><strong>curl -X GET </strong><strong>https://localhost:5001/api/users </strong><strong>-H 'Authorization: Bearer &lt;my_token&gt;'</strong></pre>
<p>The aforementioned <kbd>curl</kbd> command calls the <kbd>https://localhost:5001/api/users/</kbd> address by passing the token in the <kbd>Authorization</kbd> header of the request. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to secure a web service using some standard practices. HTTPS is now a standard and must-have feature if you want to secure data. Furthermore, we saw how token-based authentication provides a useful way to secure data and information that are exposed.</p>
<p>The topics covered in this chapter provide a way to secure information exposed by the web service, and explored the implementation of token-based authentication in distributed systems.</p>
<p>In the next chapter, we will see how to cache responses in ASP.NET Core and look at how a caching mechanism works in general.</p>


            

            
        
    </body></html>