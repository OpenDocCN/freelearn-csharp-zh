- en: Scripting Strategies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本策略
- en: Since scripting will consume a great deal of our development time, it will be
    enormously beneficial to learn some best practices. Scripting is a very broad
    term, so we will try to limit our exposure in this chapter to situations that
    are very Unity-specific, focusing on problems surrounding MonoBehaviours, GameObjects,
    and related functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本编写将消耗我们大量的开发时间，因此学习一些最佳实践将非常有益。脚本是一个非常广泛的概念，所以我们将尝试在本章中限制我们的讨论范围，专注于与MonoBehaviours、GameObject和相关功能有关的问题。
- en: We will discuss the nuances and advanced topics of the C# language, .NET library,
    and Mono framework in Chapter 8, *Masterful Memory Management*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章“精湛的内存管理”中讨论C#语言、.NET库和Mono框架的细微差别和高级主题。
- en: 'In this chapter, we will explore ways of applying performance enhancements
    for the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下方面的性能提升方法：
- en: Obtaining components in other game objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他游戏对象中获取组件
- en: Optimizing component callbacks (`Update()`, `Awake()`, and so on)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化组件回调（`Update()`、`Awake()`等）
- en: Using coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程
- en: Using `GameObject` and `Transform` efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用`GameObject`和`Transform`
- en: Exchanging messages between different objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同对象之间交换消息
- en: Optimizing mathematical calculations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数学计算
- en: Serializing/deserializing during scene and Prefab loading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景和Prefab加载期间进行序列化和反序列化
- en: Whether you have some specific problems in mind that you wish to solve or you
    just want to learn some techniques for future reference, this chapter will introduce
    you to a wide array of methods that you can use to improve your scripting efforts
    now and in the future. In each case, we will explore how and why the performance
    issue arises, an example situation in which the problem occurs, and one or more
    solutions to combat the issue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否有想要解决的特定问题，或者只是想学习一些未来参考的技术，本章将向你介绍一系列你可以用来现在和未来提高脚本编写工作的方法。在每种情况下，我们将探讨性能问题是如何产生以及为什么会产生，一个发生问题的示例情况，以及一个或多个解决这个问题的方案。
- en: Obtaining components using the fastest method
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最快的方法获取组件
- en: There are several variations of the `GetComponent()` method, and they each have
    a different performance cost, so it is prudent to call the fastest possible version
    of this method. The three overloads available are `GetComponent(string)`, `GetComponent<T>()`,
    and `GetComponent(typeof(T))`. It turns out that the fastest version depends on
    which version of Unity we are running since several optimizations have been made
    to these methods through the years; however, if you are using any version of Unity
    (from Unity 2017 onward), it is best to use the `GetComponent<T>()` variant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponent()`方法有几个变体，它们各自有不同的性能成本，因此明智的做法是调用这个方法最快的版本。可用的三个重载是`GetComponent(string)`、`GetComponent<T>()`和`GetComponent(typeof(T))`。实际上，最快的版本取决于我们正在运行的Unity版本，因为多年来对这些方法进行了多次优化；然而，如果你使用任何版本的Unity（从Unity
    2017开始），最好使用`GetComponent<T>()`变体。'
- en: 'Let''s prove this with some simple testing:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些简单的测试来证明这一点：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code tests each of the `GetComponent()` overloads a million times.
    This is far more tests than would be sensible for a typical project, but it helps
    to make the relative costs clear.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码测试了`GetComponent()`的每个重载一百万次。这比典型项目中的测试数量要多得多，但它有助于使相对成本变得清晰。
- en: 'Here is the result we get when the tests complete (of course, the specific
    numeric values may be different on your machine):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是测试完成后我们得到的结果（当然，具体的数值可能因机器而异）：
- en: '![](img/4ff13d26-1b2f-4301-8140-d2787c6bc483.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ff13d26-1b2f-4301-8140-d2787c6bc483.png)'
- en: As you can see, the `GetComponent<T>()` method is only a tiny fraction faster
    than `GetComponent(typeof(T))`, whereas `GetComponent(string)` is significantly
    slower than the alternatives. Therefore, it is pretty safe to use either of the
    type-based versions of `GetComponent()` because of the small performance difference.
    However, we should ensure that we never use `GetComponent(string)` since the outcome
    is identical, and there are no benefits for the costs incurred. There are some
    very rare exceptions. Imagine that we were writing a custom debug console for
    Unity that can parse a user-input `string` to acquire a component. In this case,
    we would acquire a component by using the expensive `GetComponent(string)` only
    during debugging and diagnostics situations. In these cases, performance isn't
    too important. On the contrary, for a production-level application, the use of
    `GetComponent(string)` is just a needless waste of CPU cycles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`GetComponent<T>()`方法仅比`GetComponent(typeof(T))`快一小部分，而`GetComponent(string)`则比其他替代方案慢得多。因此，由于性能差异很小，使用`GetComponent()`的基于类型的版本是相当安全的。然而，我们应该确保永远不使用`GetComponent(string)`，因为结果相同，而且没有为所付出的成本带来任何好处。有一些非常罕见的例外。想象一下，如果我们正在编写一个用于Unity的自定义调试控制台，它可以解析用户输入的`string`以获取组件。在这种情况下，我们只有在调试和诊断情况下才会使用昂贵的`GetComponent(string)`来获取组件。在这些情况下，性能并不是很重要。相反，对于生产级应用程序，使用`GetComponent(string)`只是无谓地浪费CPU周期。
- en: Removing empty callback definitions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除空的回调定义
- en: The primary means of scripting in Unity is to write callback functions in classes
    derived from `MonoBehaviour`, which we know Unity will call when necessary. Perhaps
    the four most commonly used callbacks are `Awake()`, `Start()`, `Update()`, and
    `FixedUpdate()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中脚本的主要编写方式是在从`MonoBehaviour`派生的类中编写回调函数，我们知道Unity会在必要时调用这些函数。可能最常用的四个回调函数是`Awake()`、`Start()`、`Update()`和`FixedUpdate()`。
- en: '`Awake()` is called the moment `MonoBehaviour` is first created, whether this
    occurs during scene initialization or when a new `GameObject` instance containing
    the `MonoBehaviour` component is instantiated at runtime from a Prefab. `Start()`
    will be called shortly after `Awake()` but before its first `Update()`. During
    scene initialization, every `MonoBehaviour` component''s `Awake()` callback will
    be called before any of their `Start()` callbacks are.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()`函数在`MonoBehaviour`首次创建时被调用，无论这是在场景初始化期间发生，还是在运行时从Prefab实例化包含`MonoBehaviour`组件的新`GameObject`实例时。`Start()`函数将在`Awake()`之后不久被调用，但在其第一次`Update()`之前。在场景初始化期间，每个`MonoBehaviour`组件的`Awake()`回调将在它们的`Start()`回调之前被调用。'
- en: After this, `Update()` will be called repeatedly, each time the rendering pipeline
    presents a new image. `Update()` will continue to be called provided `MonoBehaviour`
    is still present in the scene, it is still enabled, and its parent `GameObject`
    is active.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`Update()`函数将反复被调用，每次渲染管线呈现新的图像时都会调用一次。只要`MonoBehaviour`仍然存在于场景中，它仍然被启用，并且其父`GameObject`是活动的，`Update()`函数将持续被调用。
- en: Finally, `FixedUpdate()` is called just before the physics engine updates. Fixed
    updates are used whenever we want activity similar in behavior to `Update()` but
    that isn't tied directly to the render frame rate and is called more consistently
    over time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`FixedUpdate()`函数在物理引擎更新之前被调用。固定更新在需要行为类似于`Update()`但不是直接绑定到渲染帧率，并且随时间更一致地被调用时使用。
- en: Refer to the following page in the Unity documentation for an accurate picture
    of when various Unity callbacks are called: [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下Unity文档中的页面，以了解各种Unity回调函数被调用的准确情况：[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)。
- en: Whenever a `MonoBehaviour` component is first instantiated in our scene, Unity
    will add any defined callbacks to a list of function pointers, which it will call
    at key moments. However, it is important to realize that Unity will hook into
    these callbacks even if the function body is empty. The core Unity Engine has
    no awareness that these function bodies may be empty and only knows that the method
    has been defined and, therefore, that it must acquire it and then call it when
    necessary. Consequently, if we leave empty definitions of these callbacks scattered
    throughout the code base, then they will waste a small amount of CPU due to the
    overhead cost of the engine invoking them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在我们的场景中首次实例化一个 `MonoBehaviour` 组件时，Unity 会将这些定义的回调函数添加到一个函数指针列表中，并在关键时刻调用它们。然而，重要的是要意识到，即使函数体为空，Unity
    也会将这些回调函数钩入。核心 Unity 引擎并不知道这些函数体可能为空，只知道该方法已被定义，因此它必须获取它并在必要时调用它。因此，如果我们让这些回调函数的定义散布在代码库中，那么它们将因为引擎调用它们而产生的开销而浪费一小部分
    CPU。
- en: 'This can be a problem since, anytime we create a new `MonoBehaviour` script
    file in Unity, it will automatically generate two boilerplate callback stubs for
    us for `Start()` and `Update()`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个问题，因为每次我们在 Unity 中创建一个新的 `MonoBehaviour` 脚本文件时，它都会自动为我们生成两个样板回调函数，用于 `Start()`
    和 `Update()`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It can be easy to accidentally leave these empty definitions on scripts that
    don't actually need them. An empty `Start()` definition is liable to cause any
    object to initialize a little more slowly, for no good reason. This effect may
    not be particularly noticeable for a handful of MonoBehaviours, but as development
    on the project continues and we populate our scenes with thousands of custom MonoBehaviours
    with lots of empty `Start()` definitions, it could start to become a problem,
    causing slow scene initialization and wasting CPU time whenever a new Prefab is
    created via `GameObject.Instantiate()`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易不小心在实际上不需要这些函数的脚本上留下空定义。一个空的 `Start()` 定义可能会导致任何对象初始化得稍微慢一些，而没有任何合理的理由。这种影响可能对于少数几个
    `MonoBehaviours` 来说并不明显，但随着项目的开发继续进行，我们将场景填充成千上万的具有许多空 `Start()` 定义的定制 `MonoBehaviours`，这可能会开始成为一个问题，每次通过
    `GameObject.Instantiate()` 创建新的 Prefab 时，都会导致场景初始化缓慢和浪费 CPU 时间。
- en: Such calls typically happen during key gameplay events; for instance, when two
    objects collide, we might spawn a particle effect, create some floating damage
    text, play a sound effect, and so on. This can be a critical moment for performance
    because we've suddenly requested that the CPU makes a lot of complicated changes,
    but with only a finite amount of time to complete them before the current frame
    ends. If this process takes too long, then we would experience a frame drop as
    the Rendering Pipeline isn't allowed to present a new frame until all of the `Update()`
    callbacks—counted across all MonoBehaviours in the scene—have finished. Ergo,
    a bunch of empty `Start()` definitions being called at this time is a needless
    waste and could potentially cut into our tight time-budget at a critical moment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用通常发生在关键的游戏事件期间；例如，当两个对象碰撞时，我们可能会生成一个粒子效果，创建一些漂浮的损伤文本，播放音效等等。这可能是性能的关键时刻，因为我们突然要求
    CPU 进行大量的复杂更改，但在当前帧结束之前，我们只有有限的时间来完成它们。如果这个过程花费了太长时间，那么我们就会遇到帧率下降，因为渲染管线不允许在所有场景中的
    `Update()` 回调（跨所有 `MonoBehaviours`）完成之前展示新的帧。因此，此时调用大量空的 `Start()` 定义是一种无谓的浪费，并可能在我们关键时刻的紧张时间预算中削减时间。
- en: Meanwhile, if our scene contains thousands of MonoBehaviours with these empty
    `Update()` definitions, then we would be wasting a lot of CPU cycles every frame,
    potentially causing havoc on our frame rate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们的场景包含具有这些空 `Update()` 定义的成千上万的 `MonoBehaviours`，那么我们每帧都会浪费大量的 CPU 循环，这可能会对我们的帧率造成破坏。
- en: 'Let''s prove all of this with a simple test. Our test scene should have GameObjects
    with two types of component, `EmptyClassComponent`, with no methods defined at
    all, and `EmptyCallbackComponent`, with an empty `Update()` callback defined:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的测试来证明所有这些。我们的测试场景应该包含具有两种类型组件的 GameObject，`EmptyClassComponent`，没有任何方法定义，以及
    `EmptyCallbackComponent`，定义了一个空的 `Update()` 回调：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the test results for 30,000 components of each type. If we
    enable all GameObjects with attached `EmptyClassComponents` during runtime, then
    nothing interesting happens under the CPU Usage area of the Profiler. There will
    be a small amount of background activity, but none of this activity will be caused
    by `EmptyClassComponents`. However, as soon as we enable all objects with `EmptyCallbackComponent`,
    we will observe a huge increase in CPU usage:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每种类型 30,000 个组件的测试结果。如果在运行时启用所有附加了 `EmptyClassComponents` 的 GameObject，那么在
    Profiler 的 CPU 使用区域下将不会发生任何有趣的事情。会有一些少量的后台活动，但这些活动都不会由 `EmptyClassComponents`
    引起。然而，一旦我们启用所有带有 `EmptyCallbackComponent` 的对象，我们就会观察到 CPU 使用量的巨大增加：
- en: '![](img/a2a791aa-9c6a-4d68-9d2e-fdae438d9d7c.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2a791aa-9c6a-4d68-9d2e-fdae438d9d7c.png)'
- en: It's hard to imagine a scene with more than 30,000 objects in it, but keep in
    mind that MonoBehaviours contain the `Update()` callback, not GameObjects. A single
    `GameObject` instance can contain multiple MonoBehaviours at once, and each of
    their children can contain even more MonoBehaviours, and so on. A few thousand
    or even a hundred empty `Update()` callbacks will inflict a noticeable impact
    on frame rate budget, for zero potential gain. This is particularly common with
    Unity UI components, which tend to attach a lot of different components in a very
    deep hierarchy.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个包含超过 30,000 个对象的场景，但请记住，MonoBehaviours 包含 `Update()` 回调，而不是 GameObjects。一个
    `GameObject` 实例可以同时包含多个 MonoBehaviours，并且它们的每个子对象还可以包含更多的 MonoBehaviours，依此类推。几千个甚至一百个空的
    `Update()` 回调将对帧率预算产生明显的影响，而没有任何潜在的好处。这在 Unity UI 组件中尤其常见，这些组件倾向于在非常深的层次结构中附加很多不同的组件。
- en: 'The fix for this is simple: delete the empty callback definitions. Unity will
    have nothing to hook into, and nothing will be called. Finding such empty definitions
    in an expansive code base may be difficult, but if we use some basic regular expressions
    (known as *regex*), we should be able to find what we''re looking for relatively
    easily.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题很简单：删除空的回调定义。Unity 将没有任何东西可以挂钩，并且不会调用任何东西。在一个庞大的代码库中找到这样的空定义可能很困难，但如果我们使用一些基本的正则表达式（称为
    *regex*），我们应该能够相对容易地找到我们想要的东西。
- en: All common code-editing tools for Unity, such as MonoDevelop, Visual Studio,
    and even Notepad++, provide a way to perform a regex-based search on the entire
    code base. Check out the tool's documentation for more information, since the
    method can vary greatly depending on the tool and its version.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有常见的 Unity 代码编辑工具，如 MonoDevelop、Visual Studio，甚至 Notepad++，都提供了一种在整个代码库上执行基于正则表达式的搜索的方法。请查阅工具的文档以获取更多信息，因为此方法可能因工具及其版本的不同而有很大差异。
- en: 'The following regex search should find any empty `Update()` definitions in
    our code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式搜索应该能在我们的代码中找到任何空的 `Update()` 定义：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This regex checks for a standard method definition of the `Update()` callback,
    while including any surplus whitespace and newline characters that can be distributed
    throughout the method definition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此正则表达式检查 `Update()` 回调的标准方法定义，同时包括可能分布在整个方法定义中的任何多余的空白和换行符。
- en: Naturally, all of the preceding is also true for the non-boilerplate Unity callbacks,
    such as `OnGUI()`, `OnEnable()`, `OnDestroy()`, and `LateUpdate()`. The only difference
    is that only `Start()` and `Update()` are defined automatically in a new script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，所有上述内容也适用于非模板化的 Unity 回调，如 `OnGUI()`、`OnEnable()`、`OnDestroy()` 和 `LateUpdate()`。唯一的区别是，只有
    `Start()` 和 `Update()` 在新脚本中自动定义。
- en: Check out the `MonoBehaviour` Unity Documentation page for a complete list of
    these callbacks at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅 Unity 的 `MonoBehaviour` 文档页面，以获取这些回调的完整列表，链接为 [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html)。
- en: It might also seem unlikely that someone generated so many empty versions of
    these callbacks in our code base, but never say never. For example, if we use
    a common base class, `MonoBehaviour`, throughout all of our custom components,
    then a single empty callback definition in that base class will permeate the entire
    game, which can cost us dearly. Be particularly careful of the `OnGUI()` method,
    as it can be invoked multiple times within the same frame or UI event.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码库中，似乎不太可能有人生成这么多空的回调版本，但永远不要说永远不可能。例如，如果我们在我们所有的自定义组件中普遍使用一个常见的基类，`MonoBehaviour`，那么该基类中的单个空回调定义将渗透整个游戏，这可能会给我们带来巨大的损失。特别小心
    `OnGUI()` 方法，因为它可以在同一帧或 UI 事件中多次被调用。
- en: 'Perhaps the most common source of performance problems in Unity scripting is
    to misuse the `Update()` callback by doing one or more of the following things:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本中，性能问题最常见的原因之一是误用`Update()`回调，通过执行以下一项或多项操作：
- en: Repeatedly recalculating a value that rarely or never changes
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反复重新计算很少或从不改变的价值
- en: Having too many components perform work for a result that could be shared
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有太多组件为可能共享的结果执行工作
- en: Performing work far more often than is necessary
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行比必要更频繁的工作
- en: It's worth getting into the habit of remembering that literally every single
    line of code we write in an `Update()` callback, and functions called by those
    callbacks, will eat into our frame rate budget. To hit 60 fps, we have 16.667
    milliseconds to complete all of the work in all of our `Update()` callbacks, every
    frame. This seems like plenty of time when we start prototyping, but somewhere
    in the middle of development, we will probably start noticing things getting slower
    and less responsive because we've gradually been eating away at that budget, due
    to an unchecked desire to cram more stuff into our project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得养成记住的习惯，即我们编写的每一条代码，以及由这些回调调用的函数，都会消耗我们的帧率预算。为了达到60 fps，我们每帧有16.667毫秒的时间来完成所有`Update()`回调中的工作。当我们开始原型设计时，这似乎是足够的，但在开发的中期，我们可能会开始注意到事情变得缓慢和响应迟钝，因为我们逐渐消耗了那个预算，这是由于我们无节制地想将更多东西塞入项目中的欲望。
- en: Let's cover some tips that directly address these problems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些直接解决这些问题的技巧。
- en: Caching component references
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存组件引用
- en: 'Repeatedly recalculating a value is a common mistake when scripting in Unity,
    and particularly when it comes to the `GetComponent()` method. For example, the
    following script code is trying to check a creature''s health value, and if its
    health goes below `0`, it will disable a series of components to prepare it for
    a death animation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本编写中，反复重新计算一个值是一个常见的错误，尤其是在使用`GetComponent()`方法时。例如，以下脚本代码试图检查一个生物的健康值，如果其健康值低于`0`，它将禁用一系列组件以准备死亡动画：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each time this poorly optimized method executes, it will reacquire five different
    component references. This is not very friendly on CPU usage. This is particularly
    problematic if the main method was called during `Update()`. Even if it is not,
    it still might coincide with other important events, such as creating particle
    effects, replacing an object with a Ragdoll (hence invoking various activity in
    the Physics Engine), and so on. This coding style can seem harmless, but it can
    cause a lot of long-term problems and runtime work for very little benefit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每次这个低效的方法执行时，它都会重新获取五个不同的组件引用。这对CPU使用率来说并不友好。如果主方法在`Update()`期间被调用，这尤其成问题。即使它没有被调用，它仍然可能与其他重要事件同时发生，例如创建粒子效果、用一个Ragdoll替换对象（从而在物理引擎中引发各种活动），等等。这种编码风格可能看似无害，但它可能会引起很多长期问题和运行时工作，而收益却微乎其微。
- en: 'It costs us a small amount of memory space (only 32 or 64 bits each time—Unity
    version, platform, and fragmentation permitting) to cache these references for
    future use. So, unless you''re extremely bottlenecked on memory, a better approach
    would be to acquire the references during initialization and keep them until they
    are needed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了未来使用，缓存这些引用只花费我们一小部分内存空间（每次只有32或64位——取决于Unity版本、平台和碎片化允许），所以，除非你在内存上极度瓶颈，更好的方法是在初始化时获取引用并保留它们，直到需要它们：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Caching component references in this way spares us from reacquiring them each
    time they're needed, saving us some CPU overhead each time. The cost is a small
    amount of additional memory consumption, which is very often worth the price.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式缓存组件引用可以让我们避免每次需要时都重新获取它们，每次都节省一些CPU开销。代价是额外的少量内存消耗，这通常是非常值得的。
- en: The same tip applies to literally any piece of data we decide to calculate at
    runtime. There's no need to ask the CPU to keep recalculating the same value every
    `Update()` callback when we can just store it in memory for future reference.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的建议适用于我们决定在运行时计算的任何数据。当我们可以将它存储在内存中以供未来参考时，没有必要让CPU在每次`Update()`回调时都重新计算相同的值。
- en: Sharing calculation output
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享计算输出
- en: Performance can be saved by having multiple objects share the result of some
    calculation; of course, this only works if all of them generate the same result.
    Such situations are often easy to spot but can be tricky to refactor, and so exploiting
    this would be very implementation-dependent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让多个对象共享某些计算的结果，可以节省性能；当然，这只有在它们都生成相同的结果时才有效。这种情况通常很容易发现，但重构可能很棘手，因此利用这一点将非常依赖于实现。
- en: Some examples might include finding an object in a scene, reading data from
    a file, parsing data (such as XML or JSON), finding something in a big list or
    deep dictionary of information, calculating pathing for a group of **Artificial
    Intelligence** (**AI**) objects, complex mathematics-like trajectories, raycasting,
    and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子可能包括在场景中找到一个对象、从文件中读取数据、解析数据（如XML或JSON）、在一个大列表或信息深度字典中找到某个东西、计算一组**人工智能**（**AI**）对象的路径、类似复杂数学的轨迹、光线投射等等。
- en: Think about each time an expensive operation is undertaken, and consider whether
    it is being called from multiple locations but always results in the same output.
    If this is the case, then it would be wise to restructure things so that the result
    is calculated once and then distributed to every object that needs it to minimize
    the amount of recalculation. The biggest cost is typically just a small loss in
    code simplicity, although we may inflict some extra overhead by moving the value
    around.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每当进行一次昂贵的操作时，考虑它是否从多个位置调用但总是产生相同的输出。如果是这样，那么重新组织事物以使结果只计算一次，然后将其分发给需要它的每个对象，以最小化重新计算的数量将是明智的。最大的成本通常是代码简单性的一小部分损失，尽管我们可能通过移动值而造成一些额外的开销。
- en: Note that it's often easy to get into the habit of hiding some big complex function
    in a base class, and then we define derived classes that make use of that function,
    completely forgetting how costly that function is because we rarely glance at
    that code again. It's best to use the Unity Profiler to tell us how many times
    that expensive function may be called, and as always, don't preoptimize those
    functions unless it's been proven to be a performance issue. No matter how expensive
    it may be, if it doesn't cause us to exceed performance restrictions (such as
    frame rate and memory consumption), then it's not really a performance problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常很容易养成在基类中隐藏一些大而复杂的函数的习惯，然后我们定义派生类来使用该函数，完全忘记了该函数的成本，因为我们很少再次查看那段代码。最好使用Unity
    Profiler来告诉我们那个昂贵的函数可能被调用多少次，并且像往常一样，除非已经证明它是性能问题，否则不要预先优化这些函数。无论它可能多么昂贵，如果它不会导致我们超过性能限制（如帧率和内存消耗），那么它实际上并不是一个性能问题。
- en: Update, coroutines, and InvokeRepeating
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新、协程和InvokeRepeating
- en: 'Another habit that''s easy to fall into is to call something repeatedly in
    an `Update()` callback way more often than is needed. For example, we may start
    with a situation like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容易陷入的习惯是在`Update()`回调中以比所需更频繁的方式重复调用某些东西。例如，我们可能从一个类似这样的情况开始：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we're calling some custom `ProcessAI()` subroutine every single
    frame. This may be a complex task, requiring the AI system to check some grid
    system to figure out where it's meant to move or determine some fleet maneuvers
    for a group of spaceships or whatever our game needs for its AI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们每帧都调用一些自定义的`ProcessAI()`子程序。这可能是一项复杂的工作，需要AI系统检查一些网格系统以确定它应该移动到哪个位置，或者为一批宇宙飞船或我们游戏AI需要的任何东西确定一些舰队机动。
- en: 'If this activity is eating into our frame rate budget too much, and the task
    can be completed less frequently than every frame with no significant drawbacks,
    then a good trick to improve performance is to simply reduce the frequency at
    which that `ProcessAI()` gets called:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个活动消耗了我们的帧率预算太多，并且任务可以比每帧更少地完成而没有显著的缺点，那么提高性能的一个好方法就是简单地减少调用`ProcessAI()`的频率：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we've reduced the `Update()` callback's overall cost by only invoking
    `ProcessAI()` about five times every second, which is an improvement over the
    previous situation, at the expense of code that can take a bit of time to understand
    at first glance, and a little extra memory to store some floating-point data—although,
    at the end of the day, we're still having Unity call an empty callback function
    more often than not.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过每秒只调用`ProcessAI()`大约五次来减少了`Update()`回调的整体成本，这比之前的情况有所改进，但代价是代码可能需要一点时间才能理解，并且需要额外的内存来存储一些浮点数据——尽管，最终，我们仍然经常让Unity调用一个空的回调函数。
- en: 'This function is a perfect example of a function, which can be converted into
    a coroutine to make use of their delayed invocation properties. As mentioned previously,
    coroutines are typically used to script a short sequence of events, either as
    a one-time or repeated action. They should not be confused with threads, which
    would run on a completely different CPU core concurrently, and multiple threads
    can be running simultaneously. Instead, coroutines run on the main thread in a
    sequential manner such that only one coroutine is handled at any given moment,
    and each coroutine decides when to pause and resume via `yield` statements. The
    following code is an example of how we might rewrite the preceding `Update()`
    callback in the form of a coroutine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个完美的例子，可以将它转换成协程以利用它们的延迟调用特性。如前所述，协程通常用于编写一系列事件，无论是单次还是重复执行的动作。它们不应与线程混淆，线程会在不同的
    CPU 核心上并发运行，并且可以同时运行多个线程。相反，协程在主线程上以顺序方式运行，在任何给定时刻只处理一个协程，每个协程通过 `yield` 语句决定何时暂停和恢复。以下代码示例展示了我们如何将前面的
    `Update()` 回调以协程的形式重写：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code demonstrates a coroutine that calls `ProcessAI()`, then pauses
    at the `yield` statement for the given number of seconds (the value of `_aiProcessDelay`)
    before the main thread resumes the coroutine again, at which point, it will return
    to the start of the loop, call `ProcessAI()`, pause on the `yield` statement again,
    and repeat forever (via the `while(true)` statement) until asked to stop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了一个协程，它调用 `ProcessAI()`，然后在 `yield` 语句上暂停给定的时间（`_aiProcessDelay` 的值）后，主线程再次恢复协程，此时它将回到循环的开始，调用
    `ProcessAI()`，再次在 `yield` 语句上暂停，并无限重复（通过 `while(true)` 语句）直到被要求停止。
- en: The main benefit of this approach is that this function will only be called
    as often as dictated by the value of `_aiProcessDelay`, and it will sit idle until
    that time, reducing the performance hit inflicted in most of our frames. However,
    this approach has its drawbacks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要好处是，这个函数将只根据 `_aiProcessDelay` 的值调用，并且在此期间将处于空闲状态，减少了对大多数帧造成的性能影响。然而，这种方法也有其缺点。
- en: For one, starting a coroutine comes with an additional overhead cost relative
    to a standard function call (around three times as slow), as well as some memory
    allocations to store the current state in memory until it is invoked the next
    time. This additional overhead is also not a one-time cost because coroutines
    often constantly call `yield`, which inflicts the same overhead cost again and
    again, so we need to ensure that the benefits of reduced frequency outweigh this
    cost.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动协程相对于标准函数调用会带来额外的开销（大约慢三倍），以及一些内存分配来存储当前状态，直到下一次被调用。这种额外的开销也不是一次性成本，因为协程经常不断地调用
    `yield`，这会反复产生相同的开销成本，因此我们需要确保减少频率带来的好处超过这种成本。
- en: In a test of 1,000 objects with empty `Update()` callbacks, it took 1.1 milliseconds to
    process, whereas 1,000 coroutines yielding on `WaitForEndOfFrame` (which has an
    identical frequency to `Update()` callbacks) took 2.9 milliseconds. So, the relative
    cost is almost three times as much.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 1,000 个具有空 `Update()` 回调的对象进行测试时，处理耗时为 1.1 毫秒，而 1,000 个在 `WaitForEndOfFrame`
    上产生 `yield` 的协程（其频率与 `Update()` 回调相同）耗时为 2.9 毫秒。因此，相对成本几乎是三倍。
- en: Secondly, once initialized, coroutines run independently of the triggering `MonoBehaviour`
    component's `Update()` callback and will continue to be invoked regardless of
    whether the component is disabled or not, which can make them unwieldy if we're
    performing a lot of `GameObject` construction and destruction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一旦初始化，协程将独立于触发 `MonoBehaviour` 组件的 `Update()` 回调运行，并且无论组件是否被禁用，都会继续被调用，这在我们进行大量的
    `GameObject` 构造和销毁时可能会使它们难以控制。
- en: Thirdly, the coroutine will automatically stop the moment the `GameObject` instance
    that contains it is made inactive for whatever reason (whether it was set inactive
    or one of its parents was) and will not automatically restart if `GameObject`
    is set to active again.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，一旦包含它的 `GameObject` 实例因任何原因（无论是被设置为非活动状态还是其父对象之一被设置为非活动状态）变得非活动，协程将自动停止，并且如果
    `GameObject` 再次设置为活动状态，它不会自动重新启动。
- en: Finally, by converting a method into a coroutine, we may have reduced the performance
    hit inflicted during most of our frames, but if a single invocation of the method
    body causes us to break our frame rate budget, then it will still be exceeded
    no matter how rarely we call the method. Therefore, this approach is best used
    for situations where we are only breaking our frame rate budget because of the
    sheer number of times the method is called in a given frame, not because the method
    is too expensive on its own. In those cases, we have no option but to either dig
    into and improve the performance of the method itself or reduce the cost of other
    tasks to free up the time it needs to complete its work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将方法转换为协程，我们可能已经减少了在大多数帧上造成的性能损失，但如果方法体的单个调用导致我们超出帧率预算，那么无论我们调用该方法的频率有多低，它仍然会超出预算。因此，这种方法最好用于我们只是因为方法在给定帧中被调用的次数过多而打破帧率预算的情况，而不是因为方法本身成本过高。在这种情况下，我们别无选择，只能深入挖掘并提高方法本身的性能，或者减少其他任务的成本，以便为完成其工作腾出时间。
- en: There are several `yield` types available to us when generating coroutines.
    `WaitForSeconds` is fairly self-explanatory; the coroutine will pause at the `yield`
    statement for a given number of seconds. It is not really an exact timer, however,
    so expect a small amount of variation when this `yield` type actually resumes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成协程时，我们有几种 `yield` 类型可供选择。`WaitForSeconds` 是相当直观的；协程将在 `yield` 语句暂停给定的时间数秒。然而，它并不是一个精确的计时器，因此当这个
    `yield` 类型实际恢复时，请预期会有一些变化。
- en: '`WaitForSecondsRealTime` is another option and is different from `WaitForSeconds`
    only in that it uses unscaled time. `WaitForSeconds` compares against scaled time,
    which is affected by the global `Time.timeScale` property while `WaitForSecondsRealTime`
    is not, so be careful about which `yield` type you use if you''re tweaking the
    time scale value (for example, for slow-motion effects).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitForSecondsRealTime` 是另一个选项，它与 `WaitForSeconds` 的区别仅在于它使用未缩放的时间。`WaitForSeconds`
    是与缩放时间进行比较，这会受到全局 `Time.timeScale` 属性的影响，而 `WaitForSecondsRealTime` 则不会，因此在调整时间缩放值（例如，用于慢动作效果）时，请注意您使用的
    `yield` 类型。'
- en: There is also `WaitForEndOfFrame`, which would continue at the end of the next
    `Update()` callback, and then there's `WaitForFixedUpdate`, which would continue
    at the end of the next `FixedUpdate()` invocation. Lastly, Unity 5.3 introduced
    `WaitUntil` and `WaitWhile`, where we provide a delegate function, and the coroutine
    will pause until the given delegate returns `true` or `false`, respectively. Note
    that the delegates provided to these `yield` types will be executed for each `Update()`
    until they return the Boolean value needed to stop them, which makes them very
    similar to a coroutine using `WaitForEndOfFrame` in a `while` loop that ends on
    a certain condition. Of course, it is also important that the delegate function
    we provide is not too expensive to execute.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `WaitForEndOfFrame`，它将在下一个 `Update()` 回调结束时继续执行，然后是 `WaitForFixedUpdate`，它将在下一个
    `FixedUpdate()` 调用结束时继续执行。最后，Unity 5.3 引入了 `WaitUntil` 和 `WaitWhile`，我们在这里提供委托函数，协程将暂停，直到提供的委托返回
    `true` 或 `false`。请注意，提供给这些 `yield` 类型的委托将在每次 `Update()` 调用中执行，直到它们返回所需的布尔值以停止执行，这使得它们与使用
    `WaitForEndOfFrame` 在 `while` 循环中结束的协程非常相似。当然，我们提供的委托函数执行成本不高也很重要。
- en: Delegate functions are incredibly useful constructs in C# that allow us to pass
    local methods around as arguments to other methods and are typically used for
    callbacks. Check out the MSDN *C# Programming Guide* for more information on delegates
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 委托函数是 C# 中非常实用的结构，它允许我们将局部方法作为参数传递给其他方法，并且通常用于回调。有关委托的更多信息，请参阅 MSDN 的 *C# 编程指南*，链接为
    [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/)。
- en: The way that some `Update()` callbacks are written could probably be condensed
    down into simple coroutines that always call `yield` on one of these types, but
    we should be aware of the drawbacks mentioned previously. Coroutines can be tricky
    to debug since they don't follow normal execution flow; there's no caller in the
    callstack we can directly blame for why a coroutine triggered at a given time,
    and if coroutines perform complex tasks and interact with other subsystems, then
    they can result in some impossibly difficult bugs because they happened to be
    triggered at a moment that some other code didn't expect, which also tend to be
    the kinds of bugs that are painstakingly difficult to reproduce. If you do wish
    to make use of coroutines, the best advice is to keep them simple and independent
    of other complex subsystems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些`Update()`回调的编写方式可能可以被简化为简单的协程，这些协程始终在这些类型之一上调用`yield`，但我们应意识到之前提到的缺点。协程调试可能很棘手，因为它们不遵循正常的执行流程；在调用栈中没有直接的调用者可以责怪为什么协程在特定时间被触发，并且如果协程执行复杂任务并与其他子系统交互，那么它们可能导致一些难以置信的困难错误，因为这些错误发生在其他代码没有预料到的时间点，这些错误通常也很难重现。如果你确实希望使用协程，最好的建议是保持它们简单，并且与其他复杂的子系统独立。
- en: 'Indeed, if our coroutine is simple enough that it can be boiled down to a `while` loop
    that always calls `yield` on `WaitForSeconds` or `WaitForSecondsRealtime`, as
    in the preceding example, then we can usually replace it with an `InvokeRepeating()`
    call, which is even simpler to set up and has a slightly lower overhead cost.
    The following code is functionally equivalent to the previous implementation that
    used a coroutine to regularly invoke a `ProcessAI()` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我们的协程足够简单，可以简化为一个始终在`WaitForSeconds`或`WaitForSecondsRealtime`上调用`yield`的`while`循环，就像前面的例子一样，那么我们通常可以用一个`InvokeRepeating()`调用替换它，这甚至更容易设置，并且有稍微低的开销成本。以下代码在功能上与之前使用协程定期调用`ProcessAI()`方法的实现等效：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An important difference between `InvokeRepeating()` and coroutines is that `InvokeRepeating()`
    is completely independent of the states of both `MonoBehaviour` and `GameObject`.
    The only two ways to stop an `InvokeRepeating()` call is to either call `CancelInvoke()`,
    which stops all `InvokeRepeating()` callbacks initiated by the given `MonoBehaviour`
    (note that they cannot be canceled individually) or to destroy the associated
    `MonoBehaviour` or its parent `GameObject`. Disabling either `MonoBehaviour` or
    `GameObject` does not stop `InvokeRepeating()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvokeRepeating()`和协程之间的重要区别在于`InvokeRepeating()`完全独立于`MonoBehaviour`和`GameObject`的状态。停止`InvokeRepeating()`调用的唯一两种方式是调用`CancelInvoke()`，这将停止由给定`MonoBehaviour`启动的所有`InvokeRepeating()`回调（注意，它们不能单独取消）或者销毁相关的`MonoBehaviour`或其父`GameObject`。禁用`MonoBehaviour`或`GameObject`都不会停止`InvokeRepeating()`。'
- en: A test of 1,000 `InvokeRepeating()` calls was processed in about 2.6 milliseconds;
    this is slightly faster than 1,000 equivalent coroutine `yield` calls, which took
    2.9 milliseconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对1,000次`InvokeRepeating()`调用的测试处理大约需要2.6毫秒；这比1,000次等效的协程`yield`调用快一点，后者耗时2.9毫秒。
- en: That covers most of the useful information related to the `Update()` callback.
    Let's look into some other useful scripting tips.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了与`Update()`回调相关的多数有用信息。让我们来看看其他有用的脚本提示。
- en: Faster GameObject null reference checks
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的GameObject空引用检查
- en: 'It turns out that performing a `null` reference check against a `GameObject`
    will result in some unnecessary performance overhead. GameObjects and MonoBehaviours
    are special objects compared to a typical C# object, in that they have two representations
    in memory: one exists within the memory managed by the same system managing the
    C# code we write (managed code), whereas the other exists in a different memory
    space, which is handled separately (native code). Data can move between these
    two memory spaces, but each time this happens will result in some additional CPU
    overhead and possibly an extra memory allocation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，对`GameObject`执行空引用检查将导致一些不必要的性能开销。与典型的C#对象相比，GameObject和MonoBehaviours是特殊对象，因为它们在内存中有两种表示：一个存在于管理我们编写的C#代码的同一系统的内存中（托管代码），而另一个存在于不同的内存空间中，该空间被单独处理（原生代码）。数据可以在这两个内存空间之间移动，但每次发生这种情况都会导致一些额外的CPU开销，并可能需要额外的内存分配。
- en: 'This effect is commonly referred to as crossing the Native-Managed Bridge.
    If this happens, it is likely to generate an additional memory allocation for
    an object''s data to get copied across the bridge, which will require the garbage
    collector to eventually perform some automatic cleanup of memory for us. This
    subject will be explored in much more detail in Chapter 8, *Masterful Memory Management*,
    but for the time being, just consider that there are many subtle ways to accidentally
    trigger this extra overhead, and a simple `null` reference check against `GameObject`
    is one of them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果通常被称为跨越原生-托管桥接。如果发生这种情况，它可能会为对象的数据在桥接过程中生成额外的内存分配，这将需要垃圾回收器最终为我们执行一些自动内存清理。这个主题将在第8章*精通内存管理*中详细探讨，但在此期间，只需考虑有许多微妙的方式可以意外触发这种额外的开销，而检查`GameObject`的简单`null`引用就是其中之一：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An alternative that generates a functionally equivalent output that operates
    around twice as quickly (although it does obfuscate the purpose of the code a
    little) is `System.Object.ReferenceEquals()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一种生成功能等效输出且操作速度快两倍的方法（尽管它稍微模糊了代码的目的）是`System.Object.ReferenceEquals()`：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This applies to both GameObjects and MonoBehaviours, as well as other Unity
    objects, which have both native and managed representations such as the `WWW`
    class. However, some rudimentary testing reveals that either `null` reference
    check approach still consumes mere nanoseconds on an Intel Core i5 3570K processor.
    So, unless you are performing massive amounts of `null` reference checks, the
    gains might be marginal at best. However, this is a warning worth keeping in mind
    for the future, as it will come up a lot.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于GameObject和MonoBehaviours，以及具有原生和托管表示的其他Unity对象，例如`WWW`类。然而，一些基本的测试表明，无论是哪种`null`引用检查方法，在Intel
    Core i5 3570K处理器上仍然只消耗微秒级的纳秒。所以，除非你正在执行大量的`null`引用检查，否则收益可能微乎其微。然而，这是一个值得记住的未来警告，因为它会经常出现。
- en: Avoid retrieving string properties from GameObjects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免从GameObject中检索字符串属性
- en: Ordinarily, retrieving a `string` property from an object is the same as retrieving
    any other reference type property in C#; it should be acquired with no additional
    memory cost. However, retrieving `string` properties from GameObjects is another
    subtle way of accidentally crossing over the Native-Managed Bridge.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从对象中检索`string`属性与检索C#中的任何其他引用类型属性相同；它应该没有额外的内存成本。然而，从GameObject中检索`string`属性是另一种意外跨越原生-托管桥接的微妙方式。
- en: The two properties of `GameObject` affected by this behavior are `tag` and `name`.
    Therefore, it is unwise to use either property during gameplay, and you should
    only use them in performance-inconsequential areas, such as editor scripts. However,
    the tag system is commonly used for the runtime identification of objects, which
    can make this a significant problem for some teams.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 受此行为影响的`GameObject`的两个属性是`tag`和`name`。因此，在游戏过程中使用这两个属性是不明智的，你应该只在性能无关的区域使用它们，例如编辑器脚本。然而，标签系统通常用于对象的运行时识别，这可能会给某些团队带来重大问题。
- en: 'For example, the following code would cause an additional memory allocation
    during every iteration of the loop:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码会在循环的每次迭代中造成额外的内存分配：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is often a better practice to identify objects by their components and class
    types and to identify values that do not involve `string` objects, but sometimes
    we're forced into a corner. Maybe we didn't know any better when we started, we
    inherited someone else's code base, or we're using it as a workaround for something.
    Let's assume that, for whatever reason, we're stuck with the tag system, and we
    want to avoid the Native-Managed Bridge overhead cost.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过识别对象的组件和类类型来识别对象，以及识别不涉及`string`对象的值，是一种更好的做法。但有时我们被迫陷入困境。也许我们在开始时并不了解更好的方法，我们继承了别人的代码库，或者我们正在用它作为某种问题的解决方案。让我们假设，无论出于什么原因，我们都陷入了标签系统，并且我们希望避免原生-托管桥接的开销。
- en: Fortunately, the `tag` property is most often used in comparison situations,
    and `GameObject` provides the `CompareTag()` method, which is an alternative way
    to compare `tag` properties that avoids the Native-Managed Bridge entirely.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`tag`属性通常用于比较场景，`GameObject`提供了`CompareTag()`方法，这是一种比较`tag`属性的方法，可以完全避免原生-托管桥接。
- en: 'Let''s perform a simple test to prove how this simple change can make all the
    difference:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个简单的测试来证明这个简单的改变可以带来多大的差异：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can execute these tests by pressing the *1* and *2* keys to trigger the
    respective `for` loops. Here are the results:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过按下 *1* 和 *2* 键来触发相应的 `for` 循环来执行这些测试。以下是结果：
- en: '![](img/734fa0a1-c811-4c02-90cc-84c9b339efee.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/734fa0a1-c811-4c02-90cc-84c9b339efee.png)'
- en: 'Looking at the breakdown view for each spike, we can see two completely different
    outcomes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每个峰值的分析视图，我们可以看到两种完全不同的结果：
- en: '![](img/1d563564-de53-4404-af35-b354e8cc25f1.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d563564-de53-4404-af35-b354e8cc25f1.png)'
- en: It's worth noting how the two spikes in the Timeline View appear relatively
    the same height, and yet one operation took twice as long as the other. The Profiler
    doesn't have the vertical resolution necessary to generate relatively accurate
    peaks when we go beyond the 15FPS marker. Both would result in a poor gameplay
    experience anyway, so the accuracy doesn't really matter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，时间轴视图中的两个峰值看起来高度相对相同，但一个操作却比另一个操作耗时多一倍。当超过 15FPS 标记时，Profiler 没有足够的垂直分辨率来生成相对准确的峰值。无论如何，这两种情况都会导致糟糕的游戏体验，所以准确性并不重要。
- en: Retrieving the `tag` property 10 million times (way more than makes sense in
    reality, but this is useful for comparison) results in about 400 megabytes of
    memory being allocated just for `string` objects alone. We can see this memory
    allocation happening in the spike within the GC Allocated element in the Memory
    Area of the Timeline View. Also, this process takes around 2,000 milliseconds
    to process, where another 400 milliseconds are spent on garbage collection once
    the `string` objects are no longer needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重复获取 `tag` 属性 1000 万次（在现实中远远超过合理的次数，但这对比较很有用）仅导致大约 400 兆字节的内存被分配，仅用于 `string`
    对象。我们可以在时间轴视图的内存区域中看到 GC Allocated 元素中的峰值，这个过程大约需要 2,000 毫秒来处理，一旦 `string` 对象不再需要，垃圾回收会花费另外
    400 毫秒。
- en: Meanwhile, using `CompareTag()` 10 million times costs around 1,000 milliseconds
    to process and causes no memory allocations, and hence no garbage collection.
    This is made apparent from the lack of a spike in the GC Allocated element in
    the Memory Area. This should make it abundantly clear that we must avoid accessing
    the `name` and `tag` properties whenever possible. If `tag` comparison becomes
    necessary, then we should make use of `CompareTag()`. Unfortunately, there is
    no equivalent for the `name` property, so we should stick to using tags where
    possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，使用 `CompareTag()` 10 万次大约需要 1,000 毫秒来处理，并且不会引起内存分配，因此也不会有垃圾回收。这一点可以从内存区域中
    GC Allocated 元素没有峰值中明显看出。这应该清楚地表明，我们应尽可能避免访问 `name` 和 `tag` 属性。如果 `tag` 比较成为必要，那么我们应该使用
    `CompareTag()`。不幸的是，没有 `name` 属性的等效函数，因此我们应该尽可能使用标签。
- en: Note that passing in a `string` literal, such as `"Player"`, into `CompareTag()`
    does not result in a runtime memory allocation since the application allocates
    hardcoded strings like this during initialization and merely references them at
    runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将 `string` 文字字面量，如 `"Player"`，传递给 `CompareTag()` 不会导致运行时内存分配，因为应用程序在初始化期间分配硬编码的字符串，并在运行时仅引用它们。
- en: Using appropriate data structures
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合适的数据结构
- en: C# offers many different data structures in the `System.Collections` namespace
    and we shouldn't become too accustomed to using the same ones over and over again.
    A common performance problem in software development is making use of an inappropriate
    data structure for the problem we're trying to solve simply because it's convenient.
    The two most commonly used are perhaps lists (`List<T>`) and dictionaries (`Dictionary<K,V>`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C# 在 `System.Collections` 命名空间中提供了许多不同的数据结构，我们不应该过于习惯于反复使用相同的结构。软件开发中常见的性能问题之一是，由于方便而使用不合适的数据结构来解决我们试图解决的问题。最常用的可能是列表
    (`List<T>`) 和字典 (`Dictionary<K,V>`)。
- en: If we want to iterate through a set of objects, then a list is preferred, since
    it is effectively a dynamic array where the objects and/or references reside next
    to one another in memory, and therefore iteration causes minimal cache misses.
    Dictionaries are best used if two objects are associated with one another and
    we wish to acquire, insert, or remove these associations quickly. For example,
    we might associate a level number with a particular scene file, or an `enum` representing
    different body parts on a character, with `Collider` components for those body
    parts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要遍历一组对象，那么列表是首选的，因为它实际上是一个动态数组，其中对象和/或引用在内存中相邻，因此迭代造成的缓存未命中最小。当两个对象相互关联，并且我们希望快速获取、插入或删除这些关联时，字典是最佳选择。例如，我们可能会将一个层级编号与特定的场景文件关联起来，或者用一个表示角色不同身体部位的`enum`与这些身体部位的`Collider`组件关联起来。
- en: However, it's fairly common that we want a data structure that handles both
    scenarios; we want to quickly figure out which object maps to another, while also
    being able to iterate through the group. Typically, the developer of this system
    will use a dictionary and then iterate over it. However, this process is unfortunately
    very slow, compared to iterating over a list, since it must check every potential
    hash in the dictionary to iterate over it fully.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常希望有一个可以处理这两种情况的数据结构；我们希望快速找出哪个对象映射到另一个对象，同时还能遍历该组。通常，这个系统的开发者会使用一个字典，然后遍历它。然而，与遍历列表相比，这个过程非常慢，因为它必须检查字典中的每个潜在哈希值才能完全遍历它。
- en: In these cases, it is often better to store data in both a list and a dictionary
    to better support this behavior. This will cost additional memory overhead to
    maintain multiple data structures, and insertion and deletion will require adding
    and removing objects from both data structures each time, but the benefits of
    iteration on the list (which tends to happen way more often) will be a stark contrast
    compared to iterating over a dictionary.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，通常更好的做法是在列表和字典中同时存储数据，以更好地支持这种行为。这将为维护多个数据结构带来额外的内存开销，并且插入和删除操作需要每次从这两个数据结构中添加和删除对象，但列表迭代的优点（这通常发生得更多）与遍历字典相比将形成鲜明的对比。
- en: Avoiding re-parenting transforms at runtime
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在运行时重新分配变换的父子关系
- en: In earlier versions of Unity (version 5.3 and older), the references to `Transform`
    components would be laid out in memory in a generally random order. This meant
    that iteration over multiple `Transform` components was fairly slow due to the
    likelihood of cache misses. The upside was that re-parenting `GameObject` to another
    one wouldn't really cause a significant performance hit since the `Transforms`
    operated a lot like a heap data structure, which tend to be relatively fast at
    insertion and deletion. This behavior wasn't something we could control, and so
    we simply lived with it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的早期版本（5.3及更早版本）中，`Transform`组件的引用在内存中的布局通常是随机的。这意味着遍历多个`Transform`组件相当慢，因为缓存未命中的可能性很高。好处是，将`GameObject`重新分配给另一个对象不会真正造成显著的性能损失，因为`Transforms`操作类似于堆数据结构，通常在插入和删除方面相对较快。这种行为是我们无法控制的，所以我们只能忍受它。
- en: However, since Unity 5.4 and beyond, the `Transform` component's memory layout
    has changed significantly. Since then, a `Transform` component's parent-child
    relationships have operated more like dynamic arrays, whereby Unity attempts to
    store all `Transforms` that share the same parent sequentially in memory inside
    a pre-allocated memory buffer and are sorted by their depth in the Hierarchy window
    beneath the parent. This data structure allows for much, much faster iteration
    across the entire group, which is particularly beneficial to multiple subsystems
    such as physics and animation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从Unity 5.4版本以来，`Transform`组件的内存布局发生了显著变化。从那时起，`Transform`组件的父子关系更像是动态数组，Unity试图在预分配的内存缓冲区中按顺序存储所有与同一父对象共享的`Transform`，并在父对象下方的层次结构窗口中按深度排序。这种数据结构允许在整个组上快速迭代，这对于多个子系统（如物理和动画）特别有益。
- en: The downside of this change is that if we re-parent `GameObject` to another
    one, the parent must fit the new child within its pre-allocated memory buffer
    as well as sorting all of these `Transforms` based on the new depth. Also, if
    the parent has not pre-allocated enough space to fit the new child, then it must
    expand its buffer to be able to fit the new child, and all of its children, in
    depth-first order. This could take some time to complete for deep and complex
    `GameObject` structures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的缺点是，如果我们将 `GameObject` 重新设置为另一个对象的子对象，父对象必须在其预分配的内存缓冲区中适应新的子对象，并且根据新的深度对所有这些
    `Transforms` 进行排序。此外，如果父对象没有预分配足够的空间来适应新的子对象，那么它必须扩展其缓冲区以能够适应新的子对象及其所有子对象，按照深度优先的顺序。对于深度和复杂的
    `GameObject` 结构，这可能需要一些时间才能完成。
- en: When we instantiate a new `GameObject` through `GameObject.Instantiate()`, one
    of its arguments is the `Transform` component we wish to parent `GameObject` to,
    which is `null` by default and which would place `Transform` at the root of the Hierarchy
    window. All `Transforms` at the root of the Hierarchy window need to allocate
    a buffer to store its current children as well as those that might be added later
    (child `Transforms` do not need to do this). But, if we then re-parent `Transform`
    to another one immediately after instantiation, then it discards the buffer we
    just allocated! To avoid this, we should provide the parent `Transform` argument
    into the `GameObject.Instantiate()` call, which skips this buffer allocation step.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 `GameObject.Instantiate()` 实例化一个新的 `GameObject` 时，其中一个参数是我们希望将 `GameObject`
    设置为其父对象的 `Transform` 组件，默认情况下为 `null`，这将 `Transform` 放置在 Hierarchy 窗口的根位置。Hierarchy
    窗口根位置的所有 `Transforms` 都需要分配一个缓冲区来存储其当前子对象以及以后可能添加的子对象（子 `Transforms` 不需要这样做）。但是，如果我们立即在实例化后重新将
    `Transform` 设置为另一个对象，那么它会丢弃我们刚刚分配的缓冲区！为了避免这种情况，我们应该在 `GameObject.Instantiate()`
    调用中提供父 `Transform` 参数，这将跳过此缓冲区分配步骤。
- en: Another way to reduce the costs of this process is to make root `Transform`
    pre-allocate a larger buffer before we need it so that we don't need to both expand
    and re-parent another `GameObject` instance into the buffer in the same frame.
    This can be accomplished by modifying a `Transform` component's `hierarchyCapacity`
    property. If we can estimate the number of child `Transforms` the parent will
    contain, then we can save a lot of unnecessary memory allocations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少此过程成本的方法是在我们需要之前预先为根 `Transform` 分配更大的缓冲区，这样我们就不需要在同一帧中同时扩展和重新将另一个 `GameObject`
    实例放入缓冲区。这可以通过修改 `Transform` 组件的 `hierarchyCapacity` 属性来实现。如果我们能够估计父对象将包含的子 `Transforms`
    的数量，那么我们可以节省大量的不必要的内存分配。
- en: Considering caching transform changes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑缓存变换更改
- en: The `Transform` component stores data only relative to its own parent. This
    means that accessing and modifying a `Transform` component's `position`, `rotation`,
    and/or `scale` properties could potentially result in a lot of unanticipated matrix
    multiplication calculations to generate the correct `Transform` representation
    for the object through its parent `Transforms`. The deeper the object is in the
    Hierarchy window, the more calculations are needed to determine the final result.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform` 组件仅存储相对于其自身父对象的数据。这意味着访问和修改 `Transform` 组件的 `position`、`rotation`
    和/或 `scale` 属性可能会引发大量未预料的矩阵乘法计算，以生成通过父 `Transforms` 的正确 `Transform` 表示。对象在 Hierarchy
    窗口中的深度越深，所需的计算就越多，以确定最终结果。'
- en: However, this also means that using `localPosition`, `localRotation`, and `localScale` has
    a relatively trivial cost associated with it since these are the values stored
    directly in the given `Transform` component and they can be retrieved without
    any additional matrix multiplication. Therefore, these local property values should
    be used whenever possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着使用 `localPosition`、`localRotation` 和 `localScale` 与之相关的成本相对较小，因为这些值直接存储在给定的
    `Transform` 组件中，并且可以在没有任何额外的矩阵乘法的情况下检索。因此，应尽可能使用这些局部属性值。
- en: Unfortunately, changing our mathematical calculations from world-space to local-space
    can over-complicate what were originally simple (and solved) problems, so making
    such changes risks breaking our implementation and introducing a lot of unexpected
    bugs. Sometimes, it's worth absorbing a minor performance hit to solve a complex
    3D mathematical problem more easily.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将我们的数学计算从世界空间转换为局部空间可能会使原本简单（且已解决）的问题变得过于复杂，因此进行此类更改的风险是破坏我们的实现并引入大量意外的错误。有时，为了更容易地解决复杂的
    3D 数学问题，值得承受轻微的性能损失。
- en: Another problem with constantly changing a `Transform` component's properties is
    that it also sends internal notifications to components such as `Collider`, `Rigidbody`, `Light`,
    and `Camera`, which must also be processed since the physics and rendering systems
    both need to know the new value of `Transform` and update accordingly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 持续更改 `Transform` 组件的属性还存在另一个问题，即它还会向 `Collider`、`Rigidbody`、`Light` 和 `Camera`
    等组件发送内部通知，这些组件也必须被处理，因为物理和渲染系统都需要知道新的 `Transform` 值并相应地更新。
- en: 'It is not uncommon, during a complex event chain, that we replace a `Transform`
    component''s properties multiple times in the same frame (although this is probably
    a warning sign of over-engineered design). This would cause the internal messages
    to fire each and every time this happens, even if they occur during the same frame
    or even the same function call. Ergo, we should consider minimizing the number
    of times we modify `Transform` properties by caching them in a member variable
    and committing them only at the end of the frame, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的事件链中，我们有时会在同一帧内多次替换 `Transform` 组件的属性（尽管这可能是过度设计的一个警告信号）。这会导致每次发生这种情况时都会触发内部消息，即使它们发生在同一帧或同一函数调用中。因此，我们应该考虑通过在成员变量中缓存它们并在帧末尾提交来最小化修改
    `Transform` 属性的次数，如下所示：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code will only commit changes to `position` in the next `FixedUpdate()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码只会在下一个 `FixedUpdate()` 方法中提交对 `position` 的更改。
- en: Note that changing the `Transform` component in this manner does not result
    in strange-looking behavior or teleporting objects during gameplay. The whole
    purpose of those internal events is to make sure the physics and rendering systems
    are always synchronized with the current `Transform` state. Hence, Unity doesn't
    skip a beat and fires the internal events every time changes come through the
    `Transform` component, just to be sure nothing gets missed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以这种方式更改 `Transform` 组件不会在游戏过程中导致看起来奇怪的行为或物体瞬移。这些内部事件的整体目的是确保物理和渲染系统始终与当前的
    `Transform` 状态同步。因此，Unity 不会错过任何一次，每当通过 `Transform` 组件传递更改时，都会触发内部事件，以确保不会错过任何东西。
- en: Avoiding Find() and SendMessage() at runtime
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在运行时使用 Find() 和 SendMessage()
- en: The `SendMessage()` method and family of `GameObject.Find()` methods are notoriously
    expensive and should be avoided at all costs. The `SendMessage()` method is about
    2,000 times slower than a simple function call, and the cost of the `Find()` method
    scales very poorly with scene complexity since it must iterate through every `GameObject`
    in the scene. It is sometimes forgivable to call `Find()` during the initialization
    of a scene, such as during an `Awake()` or `Start()` callback. Even in this case,
    it should only be used to acquire objects that we know for certain already exist
    in the scene and for scenes that have only a handful of GameObjects in them. Regardless,
    using either of these methods for inter-object communication at runtime is likely
    to generate a very noticeable overhead and, potentially, dropped frames.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessage()` 方法及其 `GameObject.Find()` 方法族因其高昂的成本而臭名昭著，应尽量避免使用。`SendMessage()`
    方法的速度大约是简单函数调用的 2,000 倍慢，而 `Find()` 方法的成本随着场景复杂性的增加而非常差，因为它必须遍历场景中的每一个 `GameObject`。在某些情况下，例如在场景初始化期间，如
    `Awake()` 或 `Start()` 回调中调用 `Find()` 可能是情有可原的。即使在这种情况下，也仅应使用它来获取我们确信已经存在于场景中的对象，以及那些只有少数
    `GameObject` 的场景。无论如何，在运行时使用这些方法进行对象间通信很可能会产生非常明显的开销，甚至可能导致帧率下降。'
- en: Relying on `Find()` and `SendMessage()` is typically symptomatic of poor design,
    inexperience in programming with C# and Unity, or just plain laziness during prototyping.
    Their usage has become something of an epidemic among beginner-level and intermediate-level
    projects, so much so that Unity Technologies feels the need to keep reminding
    users to avoid using them in a real game over and over again in their documentation
    and at their conferences. They only exist as a less *programmer-y* way to introduce
    new users to inter-object communication, and for some special cases where they
    can be used in a responsible way (which are few and far between). In other words,
    they're so ridiculously expensive that they break the rule of not pre-optimizing
    our code, and it's worth going out of our way to avoid using them if our project
    is going beyond the prototyping stage (which is a distinct possibility since you're
    reading this book).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于`Find()`和`SendMessage()`通常是设计不佳、C#和Unity编程经验不足或原型设计时的懒惰的典型症状。它们的用法在初级和中级项目中已经成为一种流行病，以至于Unity
    Technologies觉得有必要在他们的文档和会议上反复提醒用户，避免在实际游戏中反复使用它们。它们只是一种不那么“程序员风格”的方式来向新用户介绍对象间通信，以及在少数特殊情况下可以负责任地使用（这些情况很少见）。换句话说，它们过于昂贵，以至于违反了不预先优化代码的规则，如果我们的项目超出了原型设计阶段（由于你正在阅读这本书，这完全有可能），那么避免使用它们是值得的。
- en: To be fair, Unity targets a wide demographic of users, from hobbyists to students
    and professionals, to individual developers, to hundreds of people on the same
    team. This results in an incredibly wide range of software development ability.
    When you're starting out with Unity, it can be difficult to figure out on your
    own what you should be doing differently, especially given how the Unity engine
    does not adhere to the design paradigms of many other game engines we might be
    familiar with. It has some foreign and quirky concepts relating to scenes and
    Prefabs and does not have a built-in `God` class entry point, nor any obvious
    raw data storage systems to work with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，Unity的目标用户群体非常广泛，从爱好者到学生和专业人员，再到个人开发者，以及同一个团队中的数百人。这导致软件开发能力范围极其广泛。当你刚开始使用Unity时，自己很难弄清楚应该做哪些不同的事情，特别是考虑到Unity引擎并不遵循我们可能熟悉的许多其他游戏引擎的设计范式。它有一些与场景和Prefab相关的陌生和古怪的概念，并且没有内置的`God`类入口，也没有明显的原始数据存储系统可供使用。
- en: A `God` class is a fancy name for the first object we might create in our application
    and whose job would be to create everything else we need based on the current
    context (what level to load, which subsystems to activate, and so on). These can
    be particularly useful if we want a single centralized location that controls
    the order of events as they happen during the entire lifecycle of our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`God`类是一个对我们应用中可能创建的第一个对象的别称，其职责是根据当前上下文（例如加载哪个级别，激活哪些子系统等）创建我们需要的所有其他东西。这些类在需要单个集中位置来控制事件在整个应用生命周期中发生顺序的情况下特别有用。'
- en: Understanding how to exchange messages between intricate software architecture
    components is not useful just for Unity's performance, but also for the design
    of any real-time event-driven system (including, but not limited to games), so
    it is worth exploring the subject in some detail, evaluating some alternative
    methods for inter-object communication.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在复杂的软件架构组件之间交换消息不仅对Unity的性能有用，而且对任何实时事件驱动系统（包括但不限于游戏）的设计也很有用，因此详细探讨这个主题，评估一些替代对象间通信的方法是值得的。
- en: Let's start by examining a worst-case example, which uses both `Find()` and
    `SendMessage()` to communicate between objects, and then look into ways to improve
    upon it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考察一个最坏情况的例子，它同时使用`Find()`和`SendMessage()`在对象之间进行通信，然后探讨改进的方法。
- en: 'The following is a class definition for a simple `EnemyManagerComponent` instance
    that tracks a list of GameObjects representing enemies in our game and provides
    a `KillAll()` method to destroy them all when needed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的`EnemyManagerComponent`实例的类定义，它跟踪表示游戏中敌人的GameObject列表，并提供一个`KillAll()`方法，在需要时销毁它们：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We would then place a `GameObject` instance in our scene containing this component,
    and name it `EnemyManager`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将一个包含此组件的`GameObject`实例放置到场景中，并将其命名为`EnemyManager`。
- en: 'The following example method attempts to instantiate several enemies from a
    given Prefab, and then notifies the `EnemyManager` object of their existence:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例方法尝试从给定的Prefab实例化几个敌人，然后通知`EnemyManager`对象它们的存在：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Initializing data and putting method calls inside any kind of loop, which always
    outputs to the same result, is a big red flag for poor performance, and when we're
    dealing with expensive methods, such as `Find()`, we should always look for ways
    to call them as few times as possible. Ergo, one improvement we can make is to
    move the `Find()` call outside of the `for` loop and cache the result in a local
    variable so that we don't need to keep reacquiring the `EnemyManager` object over
    and over again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何类型的循环中初始化数据和将方法调用放入其中，这总是输出相同的结果，是性能不佳的一个大红旗，当我们处理像`Find()`这样的昂贵方法时，我们应该总是寻找尽可能少调用它们的方法。因此，我们可以做出的一个改进是将`Find()`调用移出`for`循环，并将结果缓存到局部变量中，这样我们就不需要一次又一次地重新获取`EnemyManager`对象。
- en: Moving the initialization of the `names` variable outside of the `for` loop
    is not necessarily critical since the compiler is often smart enough to realize
    it doesn't need to keep reinitializing data that isn't being changed elsewhere.
    However, it does often make the code easier to read.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将`names`变量的初始化移出`for`循环并不一定是关键的，因为编译器通常足够聪明，能够意识到它不需要重新初始化那些在其他地方没有改变的数据。然而，这通常会使代码更容易阅读。
- en: Another big improvement we can implement is to optimize our usage of the `SendMessage()`
    method by replacing it with a `GetComponent()` call. This replaces a very costly
    method with an equivalent and much cheaper alternative.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施的另一个重大改进是优化我们对`SendMessage()`方法的用法，通过将其替换为`GetComponent()`调用。这用一个成本高昂的方法替换了一个等效且成本更低的替代方案。
- en: 'This gives us the following result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下结果：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this method is called during the initialization of the scene, and we're not
    overly concerned with loading time, then we can probably consider ourselves finished
    with our optimization work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个方法在场景初始化期间被调用，并且我们不太关心加载时间，那么我们可能可以认为我们的优化工作已经完成了。
- en: However, we will often need new objects that are instantiated at runtime to
    find an existing object to communicate with. In this example, we want new enemy
    objects to register with our `EnemyManagerComponent` so that it can do whatever
    it needs to do to track and control the enemy objects in our scene. We would also
    like `EnemyManager` to handle all enemy-related behavior so that objects calling
    its functions don't need to perform work on its behalf. This will improve the
    coupling (how well our code base separates related behavior) and encapsulation (how
    well our classes prevent outside changes to the data they manage) of our application.
    The ultimate aim is to find a reliable and fast way for new objects to find existing
    objects in the scene without unnecessary usage of the `Find()` method so that
    we can minimize complexity and performance costs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们经常需要新的对象，这些对象在运行时实例化以找到现有对象进行通信。在这个例子中，我们希望新的敌人对象注册到我们的`EnemyManagerComponent`，以便它可以执行跟踪和控制场景中敌人对象所需的一切。我们还希望`EnemyManager`处理所有与敌人相关的行为，这样调用其函数的对象就不需要代表它执行工作。这将提高我们应用程序的耦合度（我们的代码库如何分离相关行为）和封装性（我们的类如何防止外部对其管理的数据进行更改）。最终目标是找到一种可靠且快速的方法，让新对象在场景中找到现有对象，而不必使用`Find()`方法，这样我们就可以最小化复杂性和性能成本。
- en: 'There are multiple approaches we can take to solving this problem, each with
    their own benefits and pitfalls:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取多种方法来解决此问题，每种方法都有其自身的优点和缺点：
- en: Assign references to preexisting objects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将引用分配给现有对象
- en: Static classes
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类
- en: Singleton components
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例组件
- en: A global messaging system
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全局消息系统
- en: Assigning references to pre-existing objects
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将引用分配给现有对象
- en: A simple approach to the problem of inter-object communication is to use Unity's
    built-in serialization system. Software design purists tend to get a little combative
    about this feature since it breaks encapsulation; it makes any field (the C# term
    for a member variable) marked `private` act in a way that treats it like a `public` field. However,
    it is a very effective tool for improving development workflow. This is particularly
    true when artists, designers, and programmers are all tinkering when the same
    product, where each has wildly varying levels of computer science and software
    programming knowledge, and with some of whom would prefer to stay away from modifying
    code files. Sometimes, it's worth bending a few rules in the name of productivity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 解决对象间通信问题的简单方法之一是使用Unity内置的序列化系统。软件设计纯粹主义者可能会对这个特性有些抵触，因为它打破了封装性；它使得标记为`private`的字段表现得像`public`字段一样。然而，它是一个非常有效的工具，可以改善开发工作流程。这在艺术家、设计师和程序员都在同一个产品上摸索，每个人的计算机科学和软件开发知识水平差异很大，有些人可能更愿意远离修改代码文件的情况下尤其如此。有时，为了提高生产力，稍微放宽一些规则是值得的。
- en: Whenever we create a `public` field in `MonoBehaviour`, Unity automatically
    serializes and exposes the value in the Inspector window when the component is
    selected. However, `public` fields are always dangerous from a software design
    perspective. These variables can be changed through code at anytime from anywhere,
    making it hard to keep track of the variable and it's liable to introduce a lot
    of unexpected bugs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们在`MonoBehaviour`中创建一个`public`字段，当组件被选中时，Unity都会自动序列化并在检查器窗口中暴露其值。然而，从软件设计的角度来看，`public`字段总是危险的。这些变量可以从任何地方通过代码随时更改，这使得跟踪变量变得困难，并且容易引入许多意外的错误。
- en: A better solution is to take any `private` or `protected` member variable of
    a class and expose it to the Inspector window with the `[SerializeField]` attribute.
    The value will then behave like a `public` field with respect to the Inspector
    window, allowing us to change it through the Editor interface for convenience,
    but will keep the data safely encapsulated from other parts of our code base.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将类的任何`private`或`protected`成员变量暴露给检查器窗口，使用`[SerializeField]`属性。然后，该值将像`public`字段一样在检查器窗口中表现，允许我们通过编辑器界面方便地更改它，但将数据安全地封装在我们的代码库的其他部分。
- en: 'For example, the following class exposes three `private` fields to the Inspector
    window:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下类将三个`private`字段暴露给检查器窗口：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `private` access specifiers shown in the preceding code are redundant
    keywords in C# since fields and methods default to `private` unless specified
    otherwise. However, it is often best practice to be explicit about the intended
    access level.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面代码中显示的`private`访问修饰符在C#中是多余的，因为字段和方法默认为`private`，除非指定了其他情况。然而，通常最好明确指定预期的访问级别。
- en: 'Looking at this component in the Inspector window reveals three values, initially
    given default values of `0` or `null`, which can be modified through the Editor
    interface:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器窗口中查看此组件会显示三个值，最初给定默认值`0`或`null`，可以通过编辑器界面进行修改：
- en: '![](img/5f599976-6b0f-4c49-9202-7d2205825918.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f599976-6b0f-4c49-9202-7d2205825918.png)'
- en: We can drag and drop a Prefab reference from the Project window into the Enemy
    Prefab field revealed in the Inspector window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将从项目窗口拖放的一个Prefab引用拖放到检查器窗口中显示的Enemy Prefab字段。
- en: Note how Unity automatically takes a camel-cased field name and creates a convenient
    Inspector window name for it. `_numEnemies` becomes Num Enemies, `_enemyPrefab` becomes Enemy Prefab, and
    so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Unity如何自动将驼峰式命名的字段名称转换为方便的检查器窗口名称。`_numEnemies`变为Num Enemies，`_enemyPrefab`变为Enemy
    Prefab，依此类推。
- en: Meanwhile, the `_enemyManager` field is interesting because it is a reference
    to a specific `MonoBehaviour` class type. If a `GameObject` is dragged and dropped
    into this field, then it will refer to the component on the given object as opposed
    to the `GameObject` itself. Note that if `GameObject` does not contain the expected
    `MonoBehaviour`, instance, then nothing will be assigned to the field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`_enemyManager`字段很有趣，因为它是对特定`MonoBehaviour`类类型的引用。如果将`GameObject`拖放到这个字段中，那么它将引用给定对象上的组件，而不是`GameObject`本身。请注意，如果`GameObject`不包含预期的`MonoBehaviour`实例，则该字段将不会被分配任何内容。
- en: A common usage of this component reference technique is to obtain references
    to other components attached to the very same `GameObject` a component is attached
    to. This is an alternative means of caching components with zero cost, as discussed
    in the section entitled *Cache component references*, earlier in this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组件引用技术的常见用法是获取附加到与组件相同的 `GameObject` 上的其他组件的引用。这是缓存组件的一种零成本替代方法，正如本章前面标题为“缓存组件引用”的部分所讨论的。
- en: There is some danger to using this method. Much of our code would assume that
    a Prefab is assigned to a field that is used like a Prefab and `GameObject` is
    assigned to a field that refers to an instance of `GameObject`. However, since
    Prefabs are essentially GameObjects, any Prefab or `GameObject` can be assigned
    to a serialized `GameObject` reference field, which means we could assign the
    wrong type by accident.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法存在一些风险。我们的大部分代码都会假设 Prefab 被分配到一个用作 Prefab 的字段，而 `GameObject` 被分配到一个引用
    `GameObject` 实例的字段。然而，由于 Prefab 本质上是 GameObject，任何 Prefab 或 `GameObject` 都可以分配到序列化的
    `GameObject` 引用字段，这意味着我们可能会意外地分配错误的类型。
- en: If we do assign the wrong type, then we could accidentally instantiate a new
    `GameObject` instance from an existing one that was previously modified, or we
    could make changes to a Prefab, which would then change the state of all GameObjects
    instantiated from it. To make matters worse, any accidental changes to a Prefab
    become permanent since Prefabs occupy the same memory space whether Playmode is
    active or not. This is the case even if the Prefab is only modified during Playmode.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们错误地分配了类型，那么我们可能会意外地从之前修改过的现有 `GameObject` 实例中实例化一个新的 `GameObject` 实例，或者我们可能会修改
    Prefab，这将随后改变从它实例化的所有 GameObject 的状态。更糟糕的是，由于 Prefab 无论 Playmode 是否激活都占用相同的内存空间，任何对
    Prefab 的意外更改都会变成永久性的。即使 Prefab 只在 Playmode 期间被修改，也是如此。
- en: Therefore, this approach is a very team-friendly way of solving the problem
    of inter-object communication, but it is not ideal due to all of the risks involved
    with team members accidentally leaving `null` references in place, assigning Prefabs
    to references that expect an instance of `GameObject` from the scene or vice versa.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种方法是解决对象间通信问题的一种非常团队友好的方法，但由于所有涉及的风险，它并不理想，因为团队成员可能会意外地留下 `null` 引用，将 Prefab
    分配到期望从场景中获取 `GameObject` 实例的引用，反之亦然。
- en: It is also important to note that not all objects can be serialized and revealed
    in the Inspector window. Unity can serialize all primitive data types (`int`, `float`, `string`,
    and `bool`), various built-in types (`Vector3`, `Quaternion`, and so on), `enum`, `class`, `struct`,
    and various data structures containing other serializable types such as `List`.
    However, it is unable to serialize `static` fields, `readonly` fields, properties,
    and dictionaries.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，并非所有对象都可以序列化并在检查器窗口中显示。Unity 可以序列化所有原始数据类型（`int`、`float`、`string` 和
    `bool`）、各种内置类型（`Vector3`、`Quaternion` 等）、`enum`、`class`、`struct` 以及包含其他可序列化类型（如
    `List`）的各种数据结构。然而，它无法序列化 `static` 字段、`readonly` 字段、属性和字典。
- en: Some Unity developers like to implement the pseudo-serialization of dictionaries
    via two separate lists for keys and values, along with a Custom Editor script,
    or via a single list of `struct` objects, which contain both keys and values.
    Both of these solutions are a little clumsy, and are rarely as performant as a
    proper dictionary, but they can still be useful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Unity 开发者喜欢通过两个单独的列表来实现字典的伪序列化，一个用于键，一个用于值，以及一个自定义编辑器脚本，或者通过一个包含键和值的 `struct`
    对象的单列表。这两种解决方案都有些笨拙，并且通常不如正确的字典那样高效，但它们仍然可能很有用。
- en: Another solution to the problem of inter-object communication is to try and
    make use of globally accessible objects to minimize the number of custom assignments
    we need to make.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 解决对象间通信问题的另一种方法是尝试使用全局可访问的对象来最小化我们需要进行的自定义赋值数量。
- en: Static classes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态类
- en: This approach involves creating a class that is globally accessible to the entire
    code base at anytime. Any kind of global manager class is often frowned upon in
    software engineering circles, partly since the name manager is vague and doesn't
    say much about what it's meant to do, but mostly because problems can be difficult
    to debug. Changes can occur from anywhere and at any point during runtime, and
    such classes tend to maintain state information that other systems rely upon.
    It is also perhaps the most difficult approach to change or replace since many
    of our classes might contain direct function calls into it, requiring each to
    be modified at a future date if it were to be replaced. Despite all of these drawbacks,
    it is by far the easiest solution to understand and implement.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法涉及创建一个类，该类可以在任何时候被整个代码库全局访问。在软件工程领域，任何类型的全局管理类通常都不受欢迎，部分原因是名称“管理器”含糊不清，并没有说明它打算做什么，但主要原因是问题可能难以调试。更改可能发生在运行时任何地方和任何时刻，并且这类类倾向于维护其他系统所依赖的状态信息。此外，这可能是最难更改或替换的方法，因为我们的许多类可能直接调用它，如果需要替换，则每个类都需要在未来某个日期进行修改。尽管存在所有这些缺点，但这是最容易理解和实现的方法。
- en: The singleton design pattern is a common way of ensuring only one instance of
    a certain object type ever exists in memory. This design pattern is implemented
    by giving the class a `private` constructor, a `static` variable is maintained
    to keep track of the object instance, and the class can only be accessed through
    a `static` property it provides. Singletons can be useful for managing shared
    resources or heavy data traffic, such as file access, downloads, data parsing,
    and messaging. A singleton ensures that we have a single entry point for such
    activities, rather than having tons of different subsystems competing for shared
    resources and potentially bottlenecking one another.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式是确保在内存中始终只有一个特定对象类型的实例的常见方法。这种设计模式通过给类提供一个`private`构造函数来实现，维护一个`static`变量以跟踪对象实例，并且只能通过它提供的`static`属性来访问该类。单例对于管理共享资源或大量数据流量（如文件访问、下载、数据解析和消息传递）非常有用。单例确保我们有一个此类活动的单一入口点，而不是有大量不同的子系统争夺共享资源，并可能相互阻塞。
- en: Singletons don't necessarily have to be globally accessible objects—their most
    important feature is that only a single instance of the object exists at a time.
    However, the way that singletons are primarily used in most projects is to be
    a global access point to some shared functionality, and they are designed to be
    created once during application initialization, persist through the entire lifecycle
    of the application, and only be destroyed during application shutdown. As such,
    a simpler way of implementing this kind of behavior in C# is to use a static class.
    In other words, implementing the typical singleton design pattern in C# just provides
    the same behavior as a static class, but takes more time and code to implement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 单例不一定是全局可访问的对象——它们最重要的特性是在任何时候只有一个对象实例存在。然而，单例在大多数项目中主要被用作对某些共享功能的全局访问点，并且它们被设计为在应用程序初始化期间创建一次，在整个应用程序生命周期中持续存在，并且仅在应用程序关闭时被销毁。因此，在C#中实现这种行为的简单方法就是使用静态类。换句话说，在C#中实现典型的单例设计模式只是提供了与静态类相同的行为，但需要更多的时间和代码来实现。
- en: 'A static class that functions in much the same way as `EnemyManagerComponent`,
    as demonstrated in the previous example, can be defined as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态类，其功能与`EnemyManagerComponent`在先前的示例中展示的方式几乎相同，可以定义为如下：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that every method, property, and field in a static class must have the
    `static` keyword attached, which implies that only one instance of this object
    will ever reside in memory. This also means that its `public` methods and fields
    are accessible from anywhere. Static classes, by definition, do not allow any
    non-`static` fields to be defined.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，静态类中的每个方法、属性和字段都必须附加`static`关键字，这意味着内存中将始终只有一个此类对象的实例。这也意味着其`public`方法和字段可以从任何地方访问。根据定义，静态类不允许定义任何非`static`字段。
- en: 'If static class fields need to be initialized (such as the `_enemies` field,
    which is initially set to `null`), then static class fields can be initialized
    inline like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态类字段需要初始化（例如，`_enemies`字段最初设置为`null`），则静态类字段可以像这样内联初始化：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, if object construction needs to be more complicated than this, then
    static classes can be given a `static` constructor, instead. The static class
    constructor is automatically called the moment the class is first accessed through
    any of its fields, properties, or methods and can be defined like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果对象构造比这更复杂，则可以给静态类提供一个`static`构造函数。静态类构造函数在第一次通过其任何字段、属性或方法访问类时自动调用，可以定义如下：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, we have implemented the `CreateEnemy()` method so that it handles
    much of the activity for creating an enemy object. However, the static class must
    still be given a reference to a Prefab from which it can instantiate an enemy
    object. A static class can only contain `static` member variables, and therefore
    cannot easily interface with the Inspector window in the same way that MonoBehaviours
    can, therefore requiring the caller to provide some implementation-specific information
    to it. To solve this problem, we could implement a companion-component for our
    static class to keep our code properly *decoupled*. The following code demonstrates
    what this class might look like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们实现了`CreateEnemy()`方法，以便它处理创建敌人对象的大部分活动。然而，静态类仍然需要提供一个从其中实例化敌人对象的Prefab的引用。静态类只能包含`static`成员变量，因此不能像MonoBehaviours那样轻松地与检查器窗口接口，因此需要调用者提供一些特定实现的详细信息。为了解决这个问题，我们可以为我们的静态类实现一个伴随组件，以使我们的代码正确地解耦。以下代码演示了这个类可能的样子：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Despite these drawbacks, the `StaticEnemyManager` class illustrates a simple
    example of how a static class might be used to provide information or communication
    between external objects, providing a better alternative than using `Find()` or `SendMessage()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些缺点，`StaticEnemyManager`类展示了如何使用静态类提供外部对象之间信息或通信的简单示例，这比使用`Find()`或`SendMessage()`提供了更好的替代方案。
- en: Singleton components
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例组件
- en: As mentioned previously, static classes have difficulty interfacing with Unity-related
    functionality and cannot directly make use of `MonoBehaviour` features, such as
    event callbacks, coroutines, hierarchical design, and Prefabs. Also, since there's
    no object to select in the Inspector window, we lose the ability to inspect the
    data of a static class at runtime through the Inspector window, which can make
    debugging difficult. These are features that we may wish to make use of in our
    global classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，静态类在接口Unity相关功能方面有困难，并且不能直接使用`MonoBehaviour`功能，如事件回调、协程、层次设计和Prefab。此外，由于检查器窗口中没有对象可以选择，我们失去了在运行时通过检查器窗口检查静态类数据的能力，这可能会使调试变得困难。这些是我们可能希望在我们的全局类中使用的功能。
- en: A common solution to this problem is to implement a component that acts as a
    singleton—it provides `static` methods to grant global access, and only one instance
    of `MonoBehaviour` is ever allowed to exist at any given time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是实现一个充当单例的组件——它提供`static`方法以提供全局访问，并且在任何给定时间只允许存在一个`MonoBehaviour`实例。
- en: 'The following is the definition for a `SingletonComponent` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`SingletonComponent`类的定义：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This class works by creating `GameObject` containing a component of itself the
    first time it is accessed. Since we wish this to be a global and persistent object,
    we will need to call `DontDestroyOnLoad()` shortly after `GameObject` is created.
    This is a special function that tells Unity that we want the object to persist
    between scenes for as long as the application is running. From that point onward,
    when a new scene is loaded, the object will not be destroyed and will retain all
    of its data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类通过在第一次访问时创建包含其自身组件的`GameObject`来工作。由于我们希望这是一个全局且持久化的对象，我们将在创建`GameObject`后不久调用`DontDestroyOnLoad()`。这是一个特殊函数，告诉Unity我们希望对象在应用程序运行期间在场景之间持久化。从那时起，当加载新场景时，该对象将不会被销毁并保留其所有数据。
- en: This class definition assumes two things. Firstly, because it is using *generics*
    to define its behavior, we must derive it to create a concrete class. Secondly,
    a method must be defined to assign the `_Instance` property (which, in turn, sets
    the private `__Instance` field) and cast it to/from the correct class type.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义假设了两件事。首先，因为它使用*泛型*来定义其行为，我们必须从中派生出一个具体类。其次，必须定义一个方法来分配`_Instance`属性（这反过来又设置了私有的`__Instance`字段）并将其转换为正确的类类型。
- en: 'For example, the following is the minimum amount of code that is needed to
    successfully generate a new `SingletonComponent` derived class called `EnemyManagerSingletonComponent`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是需要成功生成一个名为 `EnemyManagerSingletonComponent` 的 `SingletonComponent` 派生类的最小代码量：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This class can be used at runtime by having any other object access the `Instance`
    property at anytime. If the component does not already exist in our scene, then
    the `SingletonComponent` base class will instantiate its own `GameObject` and
    attach an instance of the derived class to it as a component. From that point
    forward, access through the `Instance` property will reference the component that
    was created, and only one instance of that component will exist at a time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以在运行时通过任何其他对象在任何时候访问 `Instance` 属性来使用。如果该组件在我们的场景中尚未存在，则 `SingletonComponent`
    基类将实例化自己的 `GameObject` 并将其派生类的实例作为组件附加到它上。从那时起，通过 `Instance` 属性的访问将引用创建的组件，并且同一时间只有一个该组件的实例存在。
- en: Note that this means we don't need to implement `static` methods in a singleton
    component class definition. For example, we could simply call `EnemyManagerSingletonComponent.Instance.KillAll()` to
    access the `KillAll()` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这意味着我们不需要在单例组件类定义中实现 `static` 方法。例如，我们可以简单地调用 `EnemyManagerSingletonComponent.Instance.KillAll()`
    来访问 `KillAll()` 方法。
- en: Note that it is possible to place an instance of `SingletonComponent` in a Hierarchy
    window since it derives from `MonoBehaviour`. Although, be warned, the `DontDestroyOnLoad()`
    method would never be called, which would prevent the singleton component's `GameObject`
    from persisting when the next scene is loaded. We will perhaps need to call `DontDestroyOnLoad()`
    in the `Awake()` callback of the derived class to make this work, unless, of course,
    we actually want destructible singletons. Sometimes, it makes sense to allow such
    singletons to be destroyed between scenes so that it can start fresh each time;
    it all depends on our particular use cases.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 `SingletonComponent` 继承自 `MonoBehaviour`，因此可以在层次结构窗口中放置 `SingletonComponent`
    的实例。但是，警告，`DontDestroyOnLoad()` 方法永远不会被调用，这会阻止单例组件的 `GameObject` 在加载下一个场景时持续存在。我们可能需要在派生类的
    `Awake()` 回调中调用 `DontDestroyOnLoad()` 来使这生效，除非，当然，我们实际上想要可破坏的单例。有时，允许这样的单例在场景之间被销毁是有意义的，这样它就可以每次都从头开始；这完全取决于我们的特定用例。
- en: In either case, the shutdown of a singleton component can be a little convoluted
    because of how Unity tears down scenes. An object's `OnDestroy()` callback is
    called whenever it is destroyed during runtime. The same method is called during
    application shutdown, whereby every component on each `GameObject` has its `OnDestroy()`
    callback called by Unity. The same activities take place when we end Playmode
    in the Editor, hence returning to edit mode. However, the destruction of objects
    occurs in a random order, and we cannot assume that the `SingletonComponent` object
    will be the last object destroyed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，由于 Unity 如何拆解场景，单例组件的关闭可能会有些复杂。对象的 `OnDestroy()` 回调会在运行时对象被销毁时被调用。在应用程序关闭期间也会调用相同的方法，其中每个
    `GameObject` 上的每个组件的 `OnDestroy()` 回调都会被 Unity 调用。在编辑器中结束 Playmode 时也会发生同样的活动，因此返回到编辑模式。然而，对象的销毁是随机发生的，我们不能假设
    `SingletonComponent` 对象将是最后一个被销毁的对象。
- en: 'Consequently, if any object attempts to do anything with the singleton component
    in the middle of their `OnDestroy()` callback, then they may be calling the `SingletonComponent` object''s `Instance`
    property. However, if the singleton component has already been destroyed before
    this moment, then a new instance of `SingletonComponent` will be created in the
    middle of the application shutdown. This can corrupt our scene files, as instances
    of our singleton components will be left behind in the scene. If this happens,
    then Unity will throw the following error message:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果任何对象在它们的 `OnDestroy()` 回调期间尝试对单例组件进行任何操作，那么它们可能正在调用 `SingletonComponent`
    对象的 `Instance` 属性。然而，如果单例组件在此之前已经被销毁，那么在应用程序关闭过程中将创建一个新的 `SingletonComponent`
    实例。这可能会损坏我们的场景文件，因为我们的单例组件的实例将留在场景中。如果发生这种情况，那么 Unity 将抛出以下错误信息：
- en: '"Some objects were not cleaned up when closing the scene. (Did you spawn new
    GameObjects from OnDestroy?)"'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '"在关闭场景时，一些对象没有被清理。（你是在 OnDestroy 中创建新的 GameObject 吗？）"'
- en: 'The obvious workaround is to simply never call into a `SingletonComponent` object
    during any `MonoBehaviour` component''s `OnDestroy()` callback. However, there
    are some legitimate reasons we may wish to do so: most notable is that singletons
    are often designed to make use of the observer design pattern. This design pattern
    allows other objects to register/deregister with them for certain tasks, similar
    to how Unity latches onto callback methods, such as `Start()` and `Update()`,
    but in a more strict fashion.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，解决方案是简单地在任何 `MonoBehaviour` 组件的 `OnDestroy()` 回调中不调用 `SingletonComponent`
    对象。然而，我们可能有一些合法的理由想要这样做：最显著的是，单例通常被设计成利用观察者设计模式。这种设计模式允许其他对象注册/注销以执行特定任务，类似于 Unity
    如何捕获回调方法，例如 `Start()` 和 `Update()`，但以一种更严格的方式。
- en: With the observer design pattern, objects will typically register with the system
    when they are created, will make use of it during runtime, and then either deregister
    from it during runtime when they are finished using it or deregister during their
    own shutdown for the sake of cleanup. We will see an example of this design pattern
    in the upcoming section, *A global messaging system*, but if we imagine `MonoBehaviour`
    making use of such a system, then the most convenient place to perform shutdown
    deregistration would be within an `OnDestroy()` callback. Consequently, such objects
    are likely to run into the aforementioned problem, where a new `GameObject` instance
    for `SingletonComponent` is accidentally created during application shutdown.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者设计模式，对象通常在创建时会向系统注册，在运行时会使用它，然后在完成使用后或在它们自己的关闭过程中注销，以便进行清理。我们将在下一节中看到一个设计模式的例子，即**全局消息系统**，但如果想象
    `MonoBehaviour` 使用这样一个系统，那么执行关闭注销的最方便地方可能就是 `OnDestroy()` 回调中。因此，这样的对象很可能会遇到上述问题，即在应用程序关闭期间意外创建
    `SingletonComponent` 的新 `GameObject` 实例。
- en: 'To solve this problem, we will need to make three changes. Firstly, we need
    to add an additional flag to `SingletonComponent`, which keeps track of its active
    state and disables it at the appropriate times. This includes the singleton''s
    own destruction, as well as application shutdown (`OnApplicationQuit()` is another
    useful Unity callback for MonoBehaviours, which is called during this time):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要进行三项更改。首先，我们需要向 `SingletonComponent` 添加一个额外的标志，该标志跟踪其活动状态并在适当的时候禁用它。这包括单例自己的销毁，以及应用程序关闭（`OnApplicationQuit()`
    是另一个有用的 Unity 回调，它在此时被调用）：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Secondly, we should implement a way for external objects to verify the singleton''s
    current state:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们应该实现一种方法，让外部对象验证单例的当前状态：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, any object that attempts to call into the singleton during its own
    `OnDestroy()` method must first verify the state using the `IsAlive` property
    before calling `Instance`, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何尝试在其自己的 `OnDestroy()` 方法中调用单例的对象，在调用 `Instance` 之前必须首先使用 `IsAlive` 属性验证状态，如下所示：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will ensure that nobody attempts to access the singleton instance during
    destruction. If we don't follow this rule, then we will run into problems where
    instances of our singleton object will be left behind in the scene after returning
    to Edit Mode.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在销毁过程中没有人尝试访问单例实例。如果我们不遵循这个规则，那么我们可能会遇到问题，即我们的单例对象实例在返回到编辑模式后会被遗留在场景中。
- en: The irony of the `SingletonComponent` approach is that we are using a `Find()`
    call to determine whether or not one of these `SingletonComponent` objects already
    exists in the scene before we attempt to assign the `__Instance` reference variable.
    Fortunately, this will only happen when the singleton component is first accessed,
    which is usually not a problem if there aren't too many GameObjects in the scene,
    but it's possible that the initialization of the singleton component may not necessarily
    occur during scene initialization and can, therefore, cost us a performance spike
    at a bad time during gameplay when an instance is first acquired and `Find()`
    gets called. The workaround for this is to have some `God` class confirm that
    the important singletons are instantiated during scene initialization by simply
    accessing the `Instance` property on each one.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonComponent` 方法的讽刺之处在于，我们在尝试分配 `__Instance` 引用变量之前，使用 `Find()` 调用来确定这些
    `SingletonComponent` 对象中是否已经有一个存在于场景中。幸运的是，这只会发生在首次访问单例组件时，通常情况下，如果场景中游戏对象不多，这不会成为问题，但单例组件的初始化可能并不一定发生在场景初始化期间，因此可能会在游戏进行中，当首次获取实例并调用
    `Find()` 时，给我们带来性能峰值。解决这个问题的方法是让某个 `God` 类通过简单地访问每个实例的 `Instance` 属性来确认重要的单例在场景初始化期间已经实例化。'
- en: Another downside to this approach is that if we later decide that we want more
    than one of these singletons executing at once or we wish to separate out its
    behavior to be more modular, then there would be a lot of code that needs to change.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个缺点是，如果我们后来决定我们希望同时有多个这些单例执行，或者我们希望将其行为分离出来以使其更模块化，那么将需要更改大量的代码。
- en: The final approach we will explore will attempt to solve many of the problems
    revealed by the previous solutions and provide a way to gain all of their benefits,
    by combining ease of implementation, ease of extension, and strict usage that
    also reduces the likelihood of human error during configuration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的最终方法将尝试解决之前解决方案中揭示的许多问题，并通过结合易于实现、易于扩展和严格的用法来提供一种方法，这也有助于在配置过程中减少人为错误的可能性。
- en: A global messaging system
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局消息系统
- en: The final suggested approach to solve the problem of interobject communication
    is to implement a global messaging system that any object can access and send
    messages through to any object that may be interested in listening to that specific
    type of message. Objects can send messages or listen for them (sometimes both!),
    and the responsibility is on the listener to decide what messages they are interested
    in. The message sender can broadcast the message without caring at all who is
    listening, and a message can be sent through the system regardless of the specific
    contents of the message. This approach is by far the most complex and may require
    some effort to implement and maintain, but it is an excellent long-term solution
    to keep our object communication modular, decoupled, and fast as our application
    gets more and more complex.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 解决对象间通信问题的最终建议方法是实现一个全局消息系统，任何对象都可以访问并通过它向任何可能对特定类型消息感兴趣的对象发送消息。对象可以发送消息或监听消息（有时两者都是！），责任在于监听器决定他们感兴趣的消息。消息发送者可以广播消息而不关心谁在监听，并且无论消息的具体内容如何，都可以通过系统发送消息。这种方法无疑是迄今为止最复杂的，可能需要一些努力来实现和维护，但它是一个出色的长期解决方案，可以保持我们的对象通信模块化、解耦和快速，随着我们的应用程序变得越来越复杂。
- en: The kinds of message we wish to send can take many forms, including data values,
    references, instructions for listeners, and more, but they should all have a common,
    basic definition that our messaging system can use to determine what the message
    is and who it is intended for.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望发送的消息可以采取多种形式，包括数据值、引用、对监听器的指令等，但它们都应该有一个共同的、基本定义，我们的消息系统可以使用它来确定消息的内容以及它针对的对象。
- en: 'The following is a simple class definition for a `Message` object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的 `Message` 对象的类定义：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Message` class constructor caches the message's `type` in a local `string`
    property to be used later for cataloging and distribution purposes. Caching this
    value is important, as each call to `GetType().Name` will result in a new string
    being allocated, and we've previously learned that we want to minimize this activity
    as much as possible.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 类的构造函数将消息的 `type` 缓存到一个本地的 `string` 属性中，以便稍后用于分类和分发目的。缓存这个值非常重要，因为每次调用
    `GetType().Name` 都会分配一个新的字符串，而我们之前已经了解到我们希望尽可能减少这种活动。'
- en: Any custom messages can contain whatever superfluous data they wish so long
    as they derive from this base class, which will allow it to be sent through our
    messaging system. Take note that despite acquiring `type` from the object during
    its base class constructor, the `name` property will still contain the name of
    the derived class, not the base class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 任何自定义消息都可以包含它们希望包含的任何多余数据，只要它们源自这个基类，这将允许它通过我们的消息系统发送。请注意，尽管在基类构造函数期间从对象中获取了`type`，但`name`属性仍然包含派生类的名称，而不是基类的名称。
- en: 'Moving on to our `MessagingSystem` class, we should define its features by
    what kind of requirements we need it to fulfill:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转向我们的`MessagingSystem`类，我们应该通过我们需要它满足的要求来定义其功能：
- en: It should be globally accessible
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是全局可访问的
- en: Any object (`MonoBehaviour` or not) should be able to register/deregister as
    listeners to receive specific message types (that is, the observer design pattern)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对象（`MonoBehaviour`或不是）都应该能够注册/注销作为监听器以接收特定的消息类型（即观察者设计模式）
- en: Registering objects should provide a method to call when the given message is
    broadcasted from elsewhere
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册对象应提供在从其他地方广播给定消息时可以调用的方法
- en: The system should send the message to all listeners within a reasonable time
    frame, but not choke on too many requests at once
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该在合理的时间内将消息发送给所有监听器，但不会因为过多的请求而阻塞
- en: A globally accessible object
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个全局可访问的对象
- en: The first requirement makes the messaging system an excellent candidate for
    a singleton object, since we would only ever need one instance of the system.
    Although, it is wise to think long and hard as to whether this is truly the case
    before committing to implementing a singleton.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求使得消息系统成为单例对象的绝佳候选者，因为我们只需要系统的一个实例。尽管如此，在承诺实现单例之前深思熟虑是否真的是这样是明智的。
- en: If we later decide that we want multiple instances of this object to exist,
    wish to allow the systems to be created/destroyed during runtime, or even wish
    to create test cases that allow us to fake or create/destroy them in the middle
    of a test, then it can be a difficult task to refactor a singleton out of our
    code base. This is due to all of the dependencies we will gradually introduce
    to our code as we use the system more and more.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们后来决定我们希望存在多个此类对象的实例，希望允许系统在运行时创建/销毁，或者甚至希望创建允许我们在测试过程中伪造或创建/销毁它们的测试用例，那么从代码库中重构单例可能是一项艰巨的任务。这是由于我们将逐渐引入到我们的代码中的所有依赖项。
- en: If we wish to avoid singletons due to the above drawbacks, then it may be easier
    to create a single instance of the messaging system during initialization and
    then pass it around from subsystem to subsystem as needed, or we might wish to
    go further and explore the concept of dependency injection, which attempts to
    solve problems like these. However, for the sake of simplicity, we will assume
    that a singleton fits our needs and design our `MessagingSystem` class accordingly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望避免上述缺点而避免使用单例，那么在初始化期间创建消息系统的单个实例，然后根据需要将其传递给子系统，或者我们可能希望进一步探索依赖注入的概念，该概念试图解决这些问题。然而，为了简单起见，我们将假设单例符合我们的需求，并据此设计我们的`MessagingSystem`类。
- en: Registration
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: The second and third requirements can be achieved by offering some public methods
    that allow registration with the messaging system. If we force the listening object
    to provide us a delegate function to call when the message is broadcast, then
    this allows listeners to customize which method is called for which message. We
    can make our code base very easy to understand if we name the delegate after the
    message it is intended to process.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二和第三个要求可以通过提供一些公共方法来实现，这些方法允许与消息系统进行注册。如果我们强制监听对象提供一个在消息广播时调用的委托函数，那么这允许监听器自定义针对哪种消息调用哪种方法。如果我们根据要处理的消息命名委托，我们可以使我们的代码库非常易于理解。
- en: In some cases, we might wish to broadcast a general notification message and
    have all listeners do something in response, such as an *Enemy Created* message.
    Other times, we might be sending a message that specifically targets a single
    listener among a group. For example, we might want to send an *Enemy Health Value
    Changed* message that is intended for a specific health bar object that is attached
    to the enemy that was damaged. However, we may have many health bar objects in
    the scene, all of which are interested in this message type, but each is only
    interested in hearing health update messages for the enemy they're providing health
    information for. So, if we implement a way for the system to stop checking after
    it has been handled, then we can probably save a good number of CPU cycles when
    many listeners are waiting for the same message type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望广播一个通用通知消息，并让所有监听器做出响应，例如一个*敌人已创建*消息。在其他时候，我们可能发送一个专门针对组中单个监听器的消息。例如，我们可能想发送一个*敌人生命值已更改*消息，该消息旨在针对被损坏的敌人附着的特定生命值条对象。然而，场景中可能有多个生命值条对象，所有这些对象都对这种消息类型感兴趣，但每个对象只对其提供的敌人生命值更新消息感兴趣。因此，如果我们实现一种让系统在处理完毕后停止检查的方法，那么当许多监听器都在等待相同类型的消息时，我们可能可以节省大量的CPU周期。
- en: The delegate we define should, therefore, provide a way to retrieve the message
    via an argument and return a response that determines whether or not processing
    for the message should stop if and when the listener is done with it. The decision
    on whether to stop processing or not can be achieved by returning a simple Boolean,
    where `true` implies that this listener has handled the message and the processing
    for the message must stop, and `false` implies that this listener has not handled
    the message and the messaging system should try the next listener.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义的委托应该提供一种通过参数检索消息的方式，并返回一个响应，以确定是否停止对消息的处理，如果监听器处理完毕。是否停止处理的决定可以通过返回一个简单的布尔值来实现，其中`true`表示此监听器已处理消息，必须停止消息的处理，而`false`表示此监听器未处理消息，消息系统应尝试下一个监听器。
- en: 'Here is the definition for the delegate:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是委托的定义：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listeners must define a method of this form and pass a delegate reference to
    the messaging system during registration, hence providing a means for the messaging
    system to tell the listening object when the message is being broadcast.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器必须定义这种形式的方法，并在注册期间将委托引用传递给消息系统，从而为消息系统提供一种方式，告诉正在监听的对象消息正在广播。
- en: Message processing
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息处理
- en: The final requirement for our messaging system is that this object should have
    some kind of timing-based mechanism built in to prevent it from choking on too
    many messages at once. This means that, somewhere in the code base, we will need
    to make use of `MonoBehaviour` event callbacks to tell our messaging system to
    perform work during Unity's `Update()`, essentially enabling it to count time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息系统最终需求是，这个对象应该内置某种基于时间的机制，以防止它因一次性接收太多消息而阻塞。这意味着在代码库的某个地方，我们需要使用`MonoBehaviour`事件回调来告诉我们的消息系统在Unity的`Update()`期间执行工作，从而使其能够计算时间。
- en: This could be achieved with the static class singleton (which we defined earlier),
    which would require some other `MonoBehaviour`-based `God` class to call into
    it, informing it that the scene has been updated. Alternatively, we can use the
    singleton component to achieve the same thing, which has its own means of determining
    when `Update()` is called and hence handle its workload independently of any `God`
    class. The most notable difference between the two approaches is whether or not
    the system is dependent on the control of other objects and the various pros and
    cons of managing a singleton component (such that it won't get destroyed between
    scenes; we don't want to accidentally recreate it during shutdown).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过我们之前定义的静态类单例（singleton）来实现，这将需要一个基于`MonoBehaviour`的`God`类来调用它，通知它场景已经被更新。或者，我们可以使用单例组件来实现相同的功能，它有自己确定何时调用`Update()`的方法，因此可以独立于任何`God`类处理其工作负载。这两种方法之间最显著的区别是系统是否依赖于其他对象的控制以及管理单例组件的各种优缺点（这样它就不会在场景之间被销毁；我们不希望在关闭时意外地重新创建它）。
- en: The singleton component approach is probably the best since there aren't too
    many occasions where we wouldn't want this system acting independently, even if
    much of our game logic depends upon it. For example, even if the game was paused,
    we wouldn't want the game logic to pause our messaging system. We would still
    want the messaging system to continue receiving and processing messages so that
    we could, for example, keep UI-related components communicating with one another
    while the gameplay is in a paused state.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 单例组件方法可能是最好的，因为并不是在所有情况下我们都不希望这个系统独立运行，即使我们的大部分游戏逻辑都依赖于它。例如，即使游戏暂停，我们也不希望游戏逻辑暂停我们的消息系统。我们仍然希望消息系统能够继续接收和处理消息，以便我们可以在游戏处于暂停状态时，保持与
    UI 相关的组件之间的通信。
- en: Implementing the messaging system
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现消息系统
- en: 'Let''s define our messaging system by deriving from the `SingletonComponent`
    class and provide a method for objects to register with it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过从 `SingletonComponent` 类派生来定义我们的消息系统，并为对象提供一个注册它的方法：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `_listenerDict` field is a dictionary of strings mapped to lists containing `MessageHandlerDelegate`.
    This dictionary organizes our listener delegates into lists by which message type
    they wish to listen to. Hence, if we know what message type is being sent, then
    we can quickly retrieve a list of all delegates that have been registered for
    that message type. We can then iterate through the list, querying each listener
    to check whether one of them wants to handle it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`_listenerDict` 字段是一个字符串映射到包含 `MessageHandlerDelegate` 的列表的字典。这个字典根据它们希望监听的消息类型将我们的监听器委托组织到列表中。因此，如果我们知道正在发送什么消息类型，那么我们可以快速检索已为该消息类型注册的所有委托的列表。然后我们可以遍历列表，查询每个监听器，检查它们是否想要处理它。'
- en: 'The `AttachListener()` method requires two parameters: a message type in the
    form of its `System.Type` and `MessageHandlerDelegate` to send the message to
    when the given message type comes through the system.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttachListener()` 方法需要两个参数：一个表示消息类型的 `System.Type` 和一个 `MessageHandlerDelegate`，当给定的消息类型通过系统时，将使用它发送消息。'
- en: Message queuing and processing
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息排队和处理
- en: 'To process messages, our messaging system should maintain a queue of incoming
    message objects so that we can process them in the order they were broadcast:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理消息，我们的消息系统应该维护一个传入消息对象的队列，以便我们可以按它们被广播的顺序处理它们：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `QueueMessage()` method simply checks whether the given message type is
    present in our dictionary before adding it to the queue. This effectively tests
    whether or not an object actually cares to listen to the message before we queue
    it to be processed later. We have introduced a new `private` field, `_messageQueue`,
    for this purpose.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueMessage()` 方法简单地检查在将其添加到队列之前，给定的消息类型是否存在于我们的字典中。这实际上测试了在将消息排队以供稍后处理之前，对象是否真的关心监听该消息。为此，我们引入了一个新的
    `private` 字段，`_messageQueue`。'
- en: 'Next, we''ll add a definition for `Update()`. This callback will be called
    regularly by the Unity Engine. Its purpose is to iterate through the current contents
    of the message queue, one message a time; verify whether or not too much time
    has passed since we began processing; and if not, pass them along to the next
    stage in the process:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `Update()` 的定义。这个回调将由 Unity 引擎定期调用。它的目的是逐个遍历消息队列的当前内容；验证自我们开始处理以来是否已经过去了太多时间；如果没有，就将它们传递到处理过程的下一阶段：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The time-based safeguard is in place to make sure that it does not exceed a
    processing time limit threshold. This prevents the messaging system from freezing
    our game if too many messages get pushed through the system too quickly. If the
    total time limit is exceeded, then all message processing will stop, leaving any
    remaining messages to be processed during the next frame.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的保护措施旨在确保它不会超过处理时间限制阈值。这防止了消息系统在太多消息快速通过系统时冻结我们的游戏。如果总时间限制超过，则所有消息处理将停止，任何剩余的消息将在下一帧进行处理。
- en: Note that we use the full namespace when creating the `Stopwatch` object. We
    could have added `using System.Diagnostics`, but this would lead to a namespace
    conflict between `System.Diagnostics.Debug` and `UnityEngine.Debug`. Omitting
    it allows us to continue to call Unity's debug logger with `Debug.Log()`, without
    having to explicitly call `UnityEngine.Debug.Log()` each time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在创建 `Stopwatch` 对象时使用了完整的命名空间。我们本来可以添加 `using System.Diagnostics`，但这会导致
    `System.Diagnostics.Debug` 和 `UnityEngine.Debug` 之间的命名空间冲突。省略它允许我们继续使用 `Debug.Log()`
    调用 Unity 的调试记录器，而无需每次都显式调用 `UnityEngine.Debug.Log()`。
- en: 'Lastly, we will need to define the `TriggerMessage()` method, which distributes
    messages to listeners:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义 `TriggerMessage()` 方法，它将消息分配给监听器：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding method is the main workhorse behind the messaging system. The
    `TriggerEvent()` method's purpose is to obtain the list of listeners for the given
    message type and give each of them an opportunity to process it. If one of the
    delegates returns `true`, then the processing of the current message ceases and
    the method exits, allowing the `Update()` method to process the next message.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法是消息系统背后的主要工作马。`TriggerEvent()` 方法的目的是获取给定消息类型的监听器列表，并给每个监听器一个处理它的机会。如果其中一个委托返回
    `true`，则当前消息的处理将停止，方法退出，允许 `Update()` 方法处理下一个消息。
- en: Normally, we would want to use `QueueEvent()` to broadcast messages, but we
    also provide direct access to `TriggerEvent()` as an alternative. Using `TriggerEvent()`
    directly allows message senders to force their messages to be processed immediately
    without waiting for the next `Update()` event. This bypasses the throttling mechanism,
    which might be necessary for messages that need to be sent during critical moments
    of gameplay, where waiting an additional frame might result in strange-looking
    behavior.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望使用 `QueueEvent()` 来广播消息，但我们也提供了对 `TriggerEvent()` 的直接访问作为替代。直接使用 `TriggerEvent()`
    允许消息发送者强制其消息立即处理，而无需等待下一个 `Update()` 事件。这绕过了节流机制，这对于需要在游戏关键时刻发送的消息可能是必要的，等待额外的帧可能会导致看起来奇怪的行为。
- en: For example, if we intend for two objects to be destroyed and create a Particle
    Effect the moment they collide with one another, and this work is handled by another
    subsystem (hence an event needs to be sent for it), then we would want to send
    the message via `TriggerEvent()` to prevent the objects from continuing to exist
    for one frame before the event is handled. Conversely, if we wanted to do something
    less frame-critical, such as create a pop-up message when the player walks into
    a new area, we could safely use a `QueueEvent()` call to handle it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们打算让两个对象在相互碰撞时被销毁并创建一个粒子效果，这项工作由另一个子系统处理（因此需要发送一个事件），那么我们希望通过 `TriggerEvent()`
    发送消息，以防止对象在事件处理之前再存在一帧。相反，如果我们想做一些不那么帧关键的事情，比如当玩家走进一个新的区域时创建一个弹出消息，我们可以安全地使用 `QueueEvent()`
    调用来处理它。
- en: Try to avoid habitually using `TriggerEvent()` for all events, as we could end
    up handling too many calls simultaneously in the same frame, causing a sudden
    drop in frame rate. Decide which events are frame-critical, and which are not,
    and use the `QueueEvent()` and `TriggerEvent()` methods appropriately.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免习惯性地对所有事件使用 `TriggerEvent()`，因为我们可能会在同一帧内同时处理过多的调用，导致帧率突然下降。决定哪些事件是帧关键性的，哪些不是，并适当地使用
    `QueueEvent()` 和 `TriggerEvent()` 方法。
- en: Implementing custom messages
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义消息
- en: 'We''ve created the messaging system, but an example of how to use it would
    help us to wrap our heads around the concept. Let''s start by defining a pair
    of simple classes that derive from `Message`, which we can use to create a new
    enemy, as well as to notify other parts of our code base that an enemy was created:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了消息系统，但一个如何使用它的例子将帮助我们更好地理解这个概念。让我们从定义一对从 `Message` 派生的简单类开始，我们可以使用这些类来创建一个新的敌人，以及通知代码库的其他部分敌人已被创建：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`CreateEnemyMessage` is the simplest form of message that contains no special
    data, while `EnemyCreatedMessage` will contain a reference to the enemy''s `GameObject`
    as well as its name. Good practice for message objects is to make their member
    variables not only `public` but also `readonly`. This ensures that the data is
    easily accessible but cannot be changed after the object''s construction. This
    safeguards the content of our messages against being altered, as they''re passed
    between one listener and another.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateEnemyMessage` 是最简单的消息形式，不包含特殊数据，而 `EnemyCreatedMessage` 将包含对敌人 `GameObject`
    的引用以及其名称。对于消息对象的好做法是使它们的成员变量不仅是 `public` 的，也是 `readonly` 的。这确保了数据易于访问，但在对象构造之后不能被更改。这保护了消息的内容不被更改，因为它们在监听器之间传递。'
- en: Message sending
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息发送
- en: 'To send one of these message objects, we simply need to call either `QueueEvent()`
    or `TriggerEvent()` and pass it an instance of the message we wish to send. The
    following code demonstrates how we would broadcast a `CreateEnemyMessage` object
    when the spacebar is pressed:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送这些消息对象之一，我们只需调用`QueueEvent()`或`TriggerEvent()`，并传递我们希望发送的消息的实例。以下代码演示了当按下空格键时，我们如何广播`CreateEnemyMessage`对象：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we were to test this code right now, nothing would happen, because even though
    we are sending a message through the messaging system, there are no listeners
    for this message type. Let's cover how to register listeners with the messaging
    system.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试此代码，将不会发生任何事情，因为尽管我们通过消息系统发送消息，但没有任何监听器为此消息类型。让我们来看看如何将监听器注册到消息系统中。
- en: Message registration
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息注册
- en: 'The following code contains a pair of simple classes that register with the
    messaging system, each requesting to have one of their methods called whenever
    certain types of messages have been broadcast from anywhere in our code base:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含一对简单的类，它们注册到消息系统中，每个类都请求在其代码库的任何地方广播特定类型的消息时调用它们的方法：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: During initialization, the `EnemyManagerWithMessagesComponent` class registers
    to receive messages of the `CreateEnemyMessage` type, and will process the message
    through its `HandleCreateEnemy()` delegate. During this method, it can typecast
    the message into the appropriate derived message type and resolves the message
    in its own unique way. Other classes can register for the same message and resolve
    it differently through its own custom delegate method (assuming that an earlier
    listener didn't return `true` from its own delegate).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化期间，`EnemyManagerWithMessagesComponent`类注册接收`CreateEnemyMessage`类型的消息，并通过其`HandleCreateEnemy()`代理处理这些消息。在这个过程中，它可以将其转换为适当的派生消息类型，并以其独特的方式解析消息。其他类可以注册相同的消息，并通过其自定义代理方法以不同的方式解析（假设早期监听器没有从其自己的代理返回`true`）。
- en: We know what type of messages will be provided by the `msg` argument of the
    `HandleCreateEnemy()` method, because we defined it during registration through
    the `AttachListener()` call. Due to this, we can be certain that our typecasting
    is safe, and we can save time by not having to do a `null` reference check although,
    technically, nothing is stopping us using the same delegate to handle multiple
    message types. In these cases, though, we will need to implement a way to determine
    which message object is being passed and treat it accordingly. However, the best
    approach is to define a unique method for each message type to keep things appropriately
    decoupled. There really is little benefit in trying to use one monolithic method
    to handle all message types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`HandleCreateEnemy()`方法的`msg`参数将提供哪种类型的消息，因为我们通过`AttachListener()`调用在注册期间定义了它。因此，我们可以确信我们的类型转换是安全的，我们可以通过不必进行`null`引用检查来节省时间，尽管技术上没有阻止我们使用相同的代理来处理多个消息类型。然而，在这些情况下，我们需要实现一种方法来确定传递的是哪个消息对象，并相应地处理它。但是，最佳方法是为每种消息类型定义一个独特的方法，以保持适当的解耦。试图使用一个单一的方法来处理所有消息类型实际上几乎没有好处。
- en: Note how the `HandleEnemyCreated()` method definition matches the function signature
    of `MessageHandlerDelegate` (that is, it has the same return type and argument
    list), and that it is being referenced in the `AttachListener()` call. This is
    how we tell the messaging system what method to call when the given message type
    is broadcast and how delegates ensure type-safety.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`HandleEnemyCreated()`方法定义与`MessageHandlerDelegate`函数签名（即，具有相同的返回类型和参数列表）相匹配，并且它在`AttachListener()`调用中被引用。这就是我们告诉消息系统在给定消息类型被广播时调用哪个方法的方式，以及委托如何确保类型安全。
- en: If the function signature had a different return value or a different list of
    arguments, then it would be an invalid delegate for the `AttachListener()` method,
    and we would get compiler errors. Also, note that `HandleEnemyCreated()` is a
    `private` method, and yet our `MessagingSystem` class can call it. This is a useful
    feature of delegates in that we can allow only systems we give permission to call
    this message handler. Exposing the method publicly might lead to some confusion
    in our code's API, and developers may think that they're meant to call the method
    directly, which is not its intended use.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数签名有不同的返回值或不同的参数列表，那么它将不是`AttachListener()`方法的有效委托，我们会得到编译器错误。此外，请注意`HandleEnemyCreated()`是一个`private`方法，但我们的`MessagingSystem`类可以调用它。这是委托的一个有用特性，我们可以只允许我们给予权限的系统调用这个消息处理器。公开方法可能会导致我们代码的API中的一些混淆，开发者可能会认为他们可以直接调用该方法，但这不是它的预期用途。
- en: The beautiful part is that we're free to give the delegate method whatever name
    we want. The most sensible approach is to name the method after the message that
    it handles. This makes it clear to anyone reading our code what the method is
    used for and what message object type must be sent to call it. This makes the
    future parsing and debugging of our code much more straightforward since we can
    follow the chain of events by the matching names of the messages and their handler
    delegates.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙的部分在于我们可以自由地为委托方法命名。最合理的方法是按照它处理的消息来命名方法。这使任何阅读我们代码的人都能清楚地知道该方法的作用以及必须发送什么类型的消息对象来调用它。这使得我们代码的将来解析和调试变得更加简单，因为我们可以通过消息和它们的处理委托的匹配名称来跟踪事件链。
- en: During the `HandleCreateEnemy()` method, we also queue another event, which
    broadcasts `EnemyCreatedMessage` instead. The second class, `EnemyCreatedListenerComponent`,
    registers to receive these messages and then prints out a message containing that
    information. This is how we would implement a way for subsystems to notify other
    subsystems of changes. In a real application, we might register a UI system to
    listen for these types of messages and update a counter on the screen to show
    how many enemies are now active. In this case, the enemy management and UI systems
    are appropriately *decoupled* such that neither needs to know any specific information
    about how the other operates to do their assigned tasks.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HandleCreateEnemy()`方法中，我们还排队另一个事件，它广播`EnemyCreatedMessage`。第二个类`EnemyCreatedListenerComponent`注册接收这些消息，然后打印出包含该信息的消息。这就是我们实现子系统通知其他子系统变化的方式。在实际应用中，我们可能会注册一个UI系统来监听这些类型的消息，并在屏幕上更新计数器以显示现在有多少敌人处于活动状态。在这种情况下，敌人和UI系统是适当*解耦*的，这样它们就不需要知道任何关于对方如何操作的具体信息，以便完成它们分配的任务。
- en: 'If we now add `EnemyManagerWithMessagesComponent`, `EnemyCreatorComponent`,
    and `EnemyCreatedListenerComponent` to our scene, and press the spacebar several
    times, we should see log messages appear in the Console window, informing us of
    a successful test:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将`EnemyManagerWithMessagesComponent`、`EnemyCreatorComponent`和`EnemyCreatedListenerComponent`添加到我们的场景中，并多次按下空格键，我们应该在控制台窗口中看到日志消息出现，告知我们测试成功：
- en: '![](img/3d70bb31-226c-4f62-b217-b386d32cde0b.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d70bb31-226c-4f62-b217-b386d32cde0b.png)'
- en: Note that a `MessagingSystem` singleton object will be created during scene
    initialization, when either the `EnemyManagerWithMessagesComponent` or `EnemyCreatedListenerComponent`
    object's `Start()` methods are called (whichever happens first), since that is
    when they register their delegates with the messaging system, which accesses the
    `Instance` property, and hence creates the necessary `GameObject` instance containing
    the singleton component. No additional effort is required on our part to create
    the `MessagingSystem` object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在场景初始化期间，当`EnemyManagerWithMessagesComponent`或`EnemyCreatedListenerComponent`对象的`Start()`方法被调用时（哪个先发生），将创建一个`MessagingSystem`单例对象，因为那时它们将它们的委托注册到消息系统中，该系统访问`Instance`属性，因此创建了包含单例组件的必要`GameObject`实例。我们不需要做任何额外的工作来创建`MessagingSystem`对象。
- en: Message cleanup
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息清理
- en: Since message objects are classes, they will be created dynamically in memory
    and will be disposed of shortly afterward when the message has been processed
    and distributed among all listeners. However, as you will learn in Chapter 8,
    *Masterful Memory Management*, this will eventually result in garbage collection,
    as memory accumulates over time. If our application runs for long enough, it will
    eventually result in occasional garbage collection, which is the most common cause
    of unexpected and sudden CPU performance spikes in Unity applications. Therefore,
    it is wise to use the messaging system sparingly and avoid spamming messages too
    frequently on every update.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息对象是类，它们将在内存中动态创建，并在消息被处理并分发给所有监听器后不久被销毁。然而，正如你将在第8章“精通内存管理”中了解到的那样，这最终会导致垃圾回收，因为随着时间的推移，内存会积累。如果我们的应用程序运行时间足够长，最终会导致偶尔的垃圾回收，这是Unity应用程序中意外和突然的CPU性能激增的最常见原因。因此，明智的做法是谨慎使用消息系统，并避免在每次更新时频繁地发送消息。
- en: The more important cleanup operation to consider is the deregistration of delegates
    if an object needs to be destroyed. If we don't handle this properly, then the
    messaging system will hang on to delegate references that prevent objects from
    being fully destroyed and freed from memory.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的重要清理操作是在对象需要被销毁时注销代表。如果我们处理不当，那么消息系统将保留代表引用，这会阻止对象被完全销毁并从内存中释放。
- en: Essentially, we will need to pair every `AttachListener()` call with an appropriate
    `DetachListener()` call when the object is destroyed or disabled or we otherwise
    decide that we no longer need it to be queried when messages are being sent.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当对象被销毁、禁用或我们决定不再需要它在消息发送时被查询时，我们需要将每个`AttachListener()`调用与适当的`DetachListener()`调用配对。
- en: 'The following method definition in the `MessagingSystem` class will detach
    a listener for a specific event:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MessagingSystem`类中的以下方法定义将断开特定事件的监听器：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is an example usage of the `DetachListener()` method added to our `EnemyManagerWithMessagesComponent`
    class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是添加到我们的`EnemyManagerWithMessagesComponent`类中的`DetachListener()`方法的一个示例用法：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note how this definition makes use of the `IsAlive` property declared in the
    `SingletonComponent` class. This safeguards us against the aforementioned problem
    of accidentally creating a new `MessagingSystem` class during application shutdown
    since we can never guarantee that the singleton gets destroyed last.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个定义是如何使用在`SingletonComponent`类中声明的`IsAlive`属性的。这保护我们免受在应用程序关闭期间意外创建新的`MessagingSystem`类的问题，因为我们永远无法保证单例是最后一个被销毁的。
- en: Wrapping up the messaging system
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结消息系统
- en: Congratulations are in order, as we have finally built a fully functional global
    messaging system that any and all objects can interface with and use it to send
    messages between one another. A useful feature of this approach is that it is
    `Type`-agnostic, meaning that the message senders and listeners do not even need
    to derive from any particular class in order to interface with the messaging system;
    it just needs to be a class that provides a message type and a delegate function
    of the matching function signature, which makes it accessible to both ordinary
    classes and MonoBehaviours.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经最终构建了一个完全功能化的全局消息系统，任何对象都可以与之交互并使用它来相互发送消息。这种方法的一个有用特性是它是`Type`无关的，这意味着消息发送者和监听者甚至不需要从任何特定的类派生出来，以便与消息系统交互；它只需要是一个提供消息类型和匹配函数签名的委托函数的类，这使得它对普通类和MonoBehaviours都可用。
- en: As far as benchmarking the `MessagingSystem` class goes, we will find that it
    is capable of processing hundreds, if not thousands, of messages in a single frame
    with minimal CPU overhead (depending on the CPU, of course). The CPU usage is
    essentially the same, whether one message is being distributed to 100 different
    listeners or 100 messages are distributed to just one listener. Either way, it
    costs about the same.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 就`MessagingSystem`类的基准测试而言，我们会发现它能够在单个帧中处理数百甚至数千条消息，同时CPU开销最小（当然，这取决于CPU）。无论是一条消息被分发到100个不同的监听器，还是100条消息被分发到仅一个监听器，CPU的使用率基本上是相同的。两种情况下，成本大致相同。
- en: Even if we're predominantly sending messages during UI or gameplay events, this
    probably has far more power than we need. So, if it does seem to be causing performance
    problems, then it's far more likely to be caused by what the listener delegates
    are doing with the message than the messaging system's ability to process those
    messages.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在UI或游戏事件期间主要发送消息，这也可能比我们需要的强大得多。所以，如果它似乎确实导致了性能问题，那么更有可能是由监听器委托处理消息的方式造成的，而不是消息系统能够处理这些消息的能力。
- en: 'There are many ways to enhance the messaging system to provide more useful
    features we may need in the future, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以增强消息系统，以提供我们未来可能需要的更多有用功能，如下所示：
- en: Allow message senders to suggest a delay (in time or frame count) before a message
    is delivered to its listeners.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许消息发送者在消息传递给监听器之前建议一个延迟（时间或帧数）。
- en: Allow message listeners to define a priority for how urgently it should receive
    messages compared to other listeners waiting for the same message type. This is
    a means for a listener to skip to the front of the queue if it was registered
    later than other listeners.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许消息监听器定义一个优先级，以确定它相对于其他等待相同消息类型的监听器接收消息的紧急程度。这是监听器在注册晚于其他监听器时跳到队列前面的一个方法。
- en: Implement some safety checks to handle situations where a listener gets added
    to the list of message listeners for a particular message while a message of that
    type is still being processed. Currently, C# will throw `EnumerationException`
    at us since the delegate list will be changed by `AttachListener()`, while it
    is still being iterated through in `TriggerEvent()`.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一些安全检查来处理在监听器被添加到特定消息的消息监听器列表中，而该类型的消息仍在处理时的情况。目前，C#会抛出`EnumerationException`，因为`AttachListener()`会更改委托列表，而它仍在`TriggerEvent()`中迭代。
- en: At this point, we've probably explored the messaging system enough, so these
    tasks will be left as an academic exercise for you to undertake if you become
    comfortable using this solution in your games. Let's continue to explore more
    ways to improve performance through script code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能已经足够了解消息系统了，所以这些任务将留给你作为学术练习，如果你在使用这个解决方案时感到舒适。让我们继续探索更多通过脚本代码提高性能的方法。
- en: Disabling unused scripts and objects
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用未使用的脚本和对象
- en: Scenes can get pretty busy sometimes, especially when we're building large,
    open worlds. The more objects there are invoking code in an `Update()` callback,
    the worse it will scale and the slower the game becomes. However, much of what
    is being processed may be completely unnecessary if it is outside of the player's
    view or simply too far away to matter. This may not be a possibility in large
    city-building simulation games, where the entire simulation must be processed
    at all times, but it is often possible in first-person and racing games since
    the player is wandering around a large expansive area, where non-visible objects
    can be temporarily disabled without having any noticeable effect on gameplay.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 场景有时会非常繁忙，尤其是在我们构建大型开放世界时。调用`Update()`回调函数的对象越多，其扩展性越差，游戏运行速度越慢。然而，如果这些处理在玩家视野之外，或者距离太远以至于无关紧要，那么其中很大一部分可能是完全不必要的。这在大型城市模拟游戏中可能不是一个可行的选择，因为在所有时候都必须处理整个模拟，但在第一人称和赛车游戏中通常是可以的，因为玩家在一个广阔的区域中四处游荡，非可见对象可以暂时禁用，而不会对游戏玩法产生任何明显的影响。
- en: Disabling objects by visibility
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过可见性禁用对象
- en: Sometimes, we may want components or GameObjects to be disabled when they're
    not visible. Unity comes with built-in rendering features to avoid rendering objects
    that are not visible to the player's camera view (through a technique known as
    **Frustum Culling**, which is an automatic process) and to avoid rendering objects
    that are hidden behind other objects (**Occlusion Culling**, which will be discussed
    in Chapter 6, *Dynamic Graphics*), but these are only rendering optimizations.
    Frustum and Occlusion Culling do not affect components that perform tasks on the
    CPU, such as AI scripts, user interface, and gameplay logic. We must control their
    behavior ourselves.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望当组件或GameObject不可见时禁用它们。Unity自带内置的渲染功能，可以避免渲染玩家摄像机视野之外的物体（通过称为**视锥剔除**的技术，这是一个自动过程），以及避免渲染被其他物体遮挡的物体（**遮挡剔除**，将在第6章*动态图形*中讨论），但这些只是渲染优化。视锥和遮挡剔除不会影响在CPU上执行任务的组件，如AI脚本、用户界面和游戏逻辑。我们必须自己控制它们的行为。
- en: A good solution to this problem is using the `OnBecameVisible()` and `OnBecameInvisible()` callbacks.
    As the names imply, these callback methods are invoked when a renderable object
    has become visible or invisible with respect to any cameras in our scene. Also,
    when there are multiple cameras in a scene (for example, a local multiplayer game),
    the callbacks are only invoked if the object becomes visible to any one camera
    and becomes invisible to all cameras. This means that the aforementioned callbacks
    will be called at exactly the right times we expect; if nobody can see it, `OnBecameInvisible()`
    gets called, and if at least one player can see it, `OnBecameVisible()` gets called.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的好方法是使用`OnBecameVisible()`和`OnBecameInvisible()`回调。正如其名称所暗示的，这些回调方法在可渲染对象相对于场景中的任何相机变得可见或不可见时被调用。此外，当场景中有多个相机（例如，本地多人游戏）时，只有当对象对任何相机可见而对所有相机不可见时，回调才会被调用。这意味着上述回调将在我们期望的确切时间被调用；如果没有人能看到它，`OnBecameInvisible()`将被调用，如果至少有一个玩家能看到它，`OnBecameVisible()`将被调用。
- en: Since the visibility callbacks must communicate with the rendering pipeline,
    `GameObject` must have a renderable component attached, such as `MeshRenderer`
    or `SkinnedMeshRenderer`. We must ensure that the components we want to receive
    the visibility callbacks from are also attached to the same `GameObject` instance
    as the renderable object and are not a parent or child `GameObject`; otherwise,
    they won't be invoked.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可见性回调必须与渲染管线通信，`GameObject`必须附加一个可渲染组件，例如`MeshRenderer`或`SkinnedMeshRenderer`。我们必须确保我们想要接收可见性回调的组件也附加到与可渲染对象相同的`GameObject`实例上，并且不是父或子`GameObject`；否则，它们不会被调用。
- en: Note that Unity also counts the hidden camera of the Scene window toward the
    `OnBecameVisible()` and `OnBecameInvisible()` callbacks. If we find that these
    methods are not being invoked properly during Playmode testing, ensure that you
    turn the Scene window camera away from everything or disable the Scene window entirely.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Unity也将场景窗口的隐藏相机计算到`OnBecameVisible()`和`OnBecameInvisible()`回调中。如果我们发现这些方法在Playmode测试期间没有被正确调用，确保将场景窗口的相机远离所有对象，或者完全禁用场景窗口。
- en: 'To enable/disable individual components with the visibility callbacks, we can
    add the following methods:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用可见性回调来启用/禁用单个组件，我们可以添加以下方法：
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, to enable/disable the entire `GameObject` the component is attached to,
    we can implement the methods this way instead:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要启用/禁用组件附加到的整个`GameObject`，我们可以这样实现方法：
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Although, be warned that disabling the `GameObject` containing the renderable
    object, or one of its parents, will make it impossible for `OnBecameVisible()`
    to be called since there's now no graphical representation for the camera to see
    and trigger the callback with. We should place the component on a child `GameObject`,
    and have the script disable that instead, leaving the renderable object always
    visible (or find another way to re-enable it later).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，禁用包含可渲染对象的`GameObject`或其父对象，将使得`OnBecameVisible()`无法被调用，因为现在没有图形表示供相机看到并触发回调。我们应该将组件放置在子`GameObject`上，并让脚本禁用该子对象，这样可渲染对象始终保持可见（或找到其他方法在稍后重新启用它）。
- en: Disabling objects by distance
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过距离禁用对象
- en: 'In other situations, we may want components or GameObjects to be disabled after
    they are far enough away from the player such that they may be barely visible,
    but too far away to matter. A good candidate for this type of activity is roaming
    Non-Player Character creatures: we want to see them at a distance, but where we
    don''t need them to process anything, and therefore they can sit idle until we
    get closer.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可能希望组件或GameObject在距离玩家足够远时被禁用，这样它们可能几乎可见，但太远以至于无关紧要。这种活动的合适候选者是游荡的非玩家角色生物：我们希望在远处看到它们，但不需要它们处理任何事情，因此它们可以闲置直到我们靠近。
- en: 'The following code is a simple coroutine that periodically checks the total
    distance from a given target object and disables itself if it strays too far away
    from it:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的协程，它定期检查给定目标对象的总距离，并在偏离太远时禁用自己：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We should assign the player's character object (or whatever object we want it
    to compare with) to the `_target` field in the Inspector window, define the maximum
    distance in `_maxDistance`, and modify the frequency with which the coroutine
    is invoked using the `_coroutineFrameDelay` field. Anytime the object goes further
    than `_maxDistance` distance away from the object assigned to `_target`, it will
    be disabled. It will be re-enabled if it returns within that distance.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在检查器窗口中将玩家的角色对象（或我们想要与之比较的任何对象）分配给`_target`字段，在`_maxDistance`中定义最大距离，并使用`_coroutineFrameDelay`字段修改协程调用的频率。每当对象距离分配给`_target`的对象超过`_maxDistance`距离时，它将被禁用。如果它返回到该距离内，它将被重新启用。
- en: A subtle performance-enhancing feature of this implementation is comparing against
    distance-squared instead of the raw distance. This leads us conveniently to our
    next section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的微妙性能增强特性是使用距离平方而不是原始距离进行比较。这很方便地引出了我们下一个部分。
- en: Using distance-squared over distance
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用距离平方而不是距离
- en: It is safe to say that CPUs are relatively good at multiplying floating-point
    numbers together, but relatively dreadful at calculating square roots from them.
    Every time we ask `Vector3` to calculate a distance with the `magnitude` property
    or with the `Distance()` method, we're asking it to perform a square root calculation
    (as per Pythagorean theorem), which can cost a lot of CPU overhead compared to
    many other types of vector math calculations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，CPU在乘以浮点数方面相对较好，但在从它们中计算平方根方面相对较差。每次我们要求`Vector3`使用`magnitude`属性或`Distance()`方法计算距离时，我们都在要求它执行平方根计算（根据勾股定理），这与其他类型的向量数学计算相比可能会消耗大量的CPU开销。
- en: However, the `Vector3` class also offers a `sqrMagnitude` property, which provides
    the same result as distance, only the value is squared. This means that if we
    also square the value we wish to compare distance against, then we can perform
    essentially the same comparison without the cost of an expensive square-root calculation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Vector3`类还提供了一个`sqrMagnitude`属性，它提供了与距离相同的结果，只是值是平方的。这意味着如果我们也将我们想要比较距离的值平方，那么我们可以不进行昂贵的平方根计算而进行本质上相同的比较。
- en: 'For example, consider the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE42]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This can be replaced with the following and achieve a nearly identical result:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以替换为以下代码，并实现几乎相同的结果：
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The reason the result is nearly identical is because of the floating-point precision.
    We're likely to lose some of the precision that we would have had from using the
    square root values, since the value will be adjusted to an area with a different
    density of representable numbers; it could land exactly on, or closer to, a more
    accurate representable number, or, more likely, it will land on a number with
    less accuracy. As a result, the comparison is not exactly the same, but, in most
    cases, it is close enough to be unnoticeable, and the performance gain can be
    quite significant for each instruction we replace in this manner.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结果几乎相同的原因是浮点精度。我们可能会失去使用平方根值所拥有的部分精度，因为值将被调整到一个具有不同可表示数字密度的区域；它可能正好落在或更接近一个更精确的可表示数字上，或者更有可能，它将落在精度较低的数字上。因此，比较并不完全相同，但在大多数情况下，它足够接近以至于不明显，并且以这种方式替换每个指令的性能提升可以非常显著。
- en: If this minor precision loss is not important, then this performance trick should
    be considered. However, if precision is very important (such as running an accurate
    large-scale galactic space simulation), then you may want to give this tip a pass.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种轻微的精度损失并不重要，那么应该考虑这种性能技巧。然而，如果精度非常重要（例如运行精确的大型星际空间模拟），那么你可能想跳过这个提示。
- en: Note that this technique can be used for any square-root calculations, not just
    for distance. This is simply the most common example you might come across, and
    it brings to light the important `sqrMagnitude` property of the `Vector3` class.
    This is a property that Unity Technologies intentionally exposed for us to make
    use of in this manner.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种技术可以用于任何平方根计算，而不仅仅是距离。这只是一个你可能遇到的常见例子，它突出了`Vector3`类的重要`sqrMagnitude`属性。这是一个Unity
    Technologies有意暴露给我们以便以这种方式使用的属性。
- en: Minimizing deserialization behavior
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化反序列化行为
- en: Unity's serialization system is mainly used for scenes, Prefabs, ScriptableObjects,
    and various asset types (which tend to derive from ScriptableObject). When one
    of these object types is saved to disk, it is converted into a text file using
    the **Yet Another Markup Language** (**YAML**) format, which can be deserialized
    back into the original object type at a later time. All GameObjects and their
    properties get serialized when a Prefab or scene is serialized, including `private` and
    `protected` fields and all of their components, as well as child GameObjects and
    their components and so on.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的序列化系统主要用于场景、Prefab、ScriptableObjects以及各种资产类型（这些通常从ScriptableObject派生）。当这些对象类型之一被保存到磁盘时，它会被转换为使用**另一种标记语言**（**YAML**）格式的文本文件，稍后可以反序列化回原始对象类型。当Prefab或场景被序列化时，所有GameObject及其属性都会被序列化，包括`private`和`protected`字段以及所有组件，以及子GameObject及其组件等等。
- en: When our application is built, this serialized data is bundled together in large
    binary data files internally called serialized files in Unity. Reading and deserializing
    this data from disk at runtime is an incredibly slow process (relatively speaking)
    and so all deserialization activity comes with a significant performance cost.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序构建时，这种序列化数据在Unity内部以大型二进制数据文件的形式捆绑在一起，称为序列化文件。在运行时从磁盘读取和反序列化这些数据是一个极其缓慢的过程（相对而言），因此所有反序列化活动都伴随着显著的性能成本。
- en: This kind of deserialization takes place anytime we call `Resources.Load()` for
    a file path found under a folder named `Resources`. Once the data has been loaded
    from disk into memory, then reloading the same reference later is much faster,
    but disk activity is always required the first time it is accessed. Naturally,
    the larger the dataset we need to deserialize, the longer this process takes.
    Since every component of a Prefab gets serialized, then the deeper the hierarchy
    is, the more data needs to be deserialized.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的反序列化发生在我们调用`Resources.Load()`为名为`Resources`的文件夹下的文件路径时。一旦数据从磁盘加载到内存中，然后稍后重新加载相同的引用会更快，但第一次访问时始终需要磁盘活动。自然地，我们需要反序列化的数据集越大，这个过程就越长。由于Prefab的每个组件都会被序列化，因此层次结构越深，需要反序列化的数据就越多。
- en: This can be a problem for Prefabs with very deep hierarchies, Prefabs with many
    empty GameObjects (since every `GameObject` always contains at least a `Transform`
    component), and particularly problematic for **User Interface** (**UI**) Prefabs,
    since they tend to house many more components than a typical Prefab.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于具有非常深层次结构的Prefab、具有许多空GameObject的Prefab（因为每个`GameObject`都至少包含一个`Transform`组件）以及尤其是对于**用户界面**（**UI**）Prefab来说可能是一个问题，因为它们通常包含比典型Prefab更多的组件。
- en: Loading in large serialized datasets like these could cause a significant spike
    in CPU the first time they are loaded, which tends to increase loading time if
    they're needed immediately at the start of the scene. More importantly, they can
    cause frame drops if they are loaded at runtime. There are a couple of approaches
    we can use to minimize the costs of deserialization.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 加载这类大型序列化数据集可能会在首次加载时导致CPU使用量显著增加，如果它们在场景开始时立即需要，这往往会增加加载时间。更重要的是，如果在运行时加载，它们可能会导致帧率下降。我们可以采用几种方法来最小化反序列化的成本。
- en: Reducing serialized object size
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少序列化对象的大小
- en: We should aim to make our serialized objects as small as possible or partition
    them into smaller data pieces we combine together piece by piece so that they
    can be loaded one piece at a time over time. This can be tricky to manage for
    Prefabs since Unity does not inherently support nested Prefabs, and so we would
    be implementing such a system ourselves, which is a notoriously difficult problem
    to solve in Unity. UI Prefabs are good candidates for separating into smaller
    pieces since we don't normally need the entire UI at any given moment, and so
    we can usually afford to load them in one piece at a time.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该努力使我们的序列化对象尽可能小，或者将它们分成更小的数据块，我们逐个将它们组合在一起，这样它们就可以在一段时间内逐个加载。对于Prefab来说，这可能很难管理，因为Unity本身不支持嵌套Prefab，因此我们可能需要自己实现这样一个系统，这在Unity中是一个臭名昭著的难题。UIPrefab是分离成更小块的好候选，因为我们通常不需要在任何给定时刻加载整个UI，因此我们通常可以一次加载一个部分。
- en: Loading serialized objects asynchronously
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步加载序列化对象
- en: Prefabs and other serialized content can be loaded in asynchronously via `Resources.LoadAsync()`,
    which will offload reading from disk onto a worker thread that eases the burden
    on the main thread. It will take some time for the serialized object to become
    available, which can be checked by calling the `isDone` property on the `ResourceRequest`
    object returned by the previous method call.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 预制体和其他序列化内容可以通过`Resources.LoadAsync()`异步加载，这将把从磁盘读取的工作卸载到工作线程，从而减轻主线程的负担。序列化对象可用需要一些时间，可以通过调用前一个方法调用返回的`ResourceRequest`对象的`isDone`属性来检查。
- en: This is not ideal for Prefabs we need immediately at the start of the game,
    but all future Prefabs are good candidates for asynchronous loading if we're willing
    to create systems that manage this behavior.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于游戏开始时就需要立即使用的预制体来说并不理想，但如果我们愿意创建管理系统来管理这种行为，那么所有未来的预制体都是异步加载的良好候选者。
- en: Keeping previously loaded serialized objects in memory
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持之前加载的序列化对象在内存中
- en: As previously mentioned, once a serialized object has been loaded into memory,
    then it remains there and can be copied if we need it again later, such as instantiating
    more copies of a Prefab. We can free this data later with explicit calls to `Resources.Unload()`,
    which will release the memory space to be reused later. But if we have a lot of
    surplus memory in the application's budget, then we could choose to keep this
    data in memory, which would reduce the need to reload it again from disk later.
    This naturally consumes a lot of memory with more and more serialized data, making
    it a risky strategy for memory management, and so we should only do this when
    necessary.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦序列化对象被加载到内存中，它就会保留在那里，如果以后需要，可以复制它，例如实例化更多预制体的副本。我们可以通过显式调用`Resources.Unload()`来释放这些数据，这将释放内存空间以供以后重用。但是，如果我们有大量的剩余内存空间，我们可以选择将这些数据保留在内存中，这会减少以后从磁盘重新加载的需要。这自然会消耗越来越多的内存，随着序列化数据的增加，这会使得内存管理策略变得风险较大，因此我们只有在必要时才这样做。
- en: Moving common data into ScriptableObjects
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将公共数据移动到`ScriptableObjects`
- en: If we have a lot of different Prefabs with components that contain a lot of
    properties that tend to share data, such as game design values such as hit points,
    strength, and speed, then all of this data will be serialized into every Prefab
    that uses them. A better approach is to serialize this common data in a `ScriptableObject`,
    which they load and use instead. This reduces the amount of data stored within
    the serialized file for the Prefab and could significantly reduce the loading
    time of our scenes by avoiding too much repetitive work.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很多不同的预制体，它们包含大量倾向于共享数据的组件，例如游戏设计值，如生命值、力量和速度，那么所有这些数据都将序列化到使用它们的每个预制体中。更好的方法是序列化这些公共数据到`ScriptableObject`中，它们将加载并使用这些数据。这减少了预制体序列化文件中存储的数据量，并且可以通过避免过多重复工作显著减少场景的加载时间。
- en: Loading scenes additively and asynchronously
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加和异步加载场景
- en: Scenes can be loaded either to replace the current scene or can be loaded additively
    to add its contents to the current scene without unloading the preceding one.
    This can be toggled via the `LoadSceneMode` argument of the `SceneManager.LoadScene()`
    family of functions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 场景可以加载以替换当前场景，也可以附加加载以将其内容添加到当前场景中而不卸载先前的场景。这可以通过`SceneManager.LoadScene()`函数系列的`LoadSceneMode`参数来切换。
- en: Another mode of scene loading is to complete it either synchronously or asynchronously,
    and there are good reasons to use both. Synchronous loading is the typical means
    of loading a scene by calling `SceneManager.LoadScene()`, where the main thread
    will block until the given scene completes loading. This normally results in poor
    user experience, as the game appears to freeze as the contents are loaded in (whether
    as a replacement or additively). This is best used if we want to get the player
    into the action as soon as possible, or we have no time to wait for scene objects
    to appear. This would normally be used if we're loading into the first level of
    the game or returning to the main menu.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种场景加载模式是同步或异步地完成它，使用这两种方法都有很好的理由。同步加载是通过调用`SceneManager.LoadScene()`来加载场景的典型方法，此时主线程将阻塞，直到指定的场景加载完成。这通常会导致用户体验不佳，因为当内容加载时（无论是替换还是附加），游戏看起来会冻结。这最好用于我们希望尽快让玩家进入行动，或者我们没有时间等待场景对象出现的情况。通常情况下，如果我们正在加载游戏的第一级或返回主菜单，会使用这种方法。
- en: 'For future scene loading, however, we may wish to reduce the performance impact
    so that we can continue to keep the player in action. Loading a scene can take
    a lot of work, and the larger the scene, the longer it will take. However, the
    option of asynchronous additive loading offers a huge benefit: we can let the
    scene gradually load in the background without causing a significant impact on
    the user experience. This can be accomplished with `SceneManager.LoadSceneAsync()` combined
    with passing in `LoadSceneMode.Additive` for the loading mode argument.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于未来的场景加载，我们可能希望减少性能影响，以便我们可以继续让玩家保持活跃。加载一个场景可能需要大量工作，场景越大，所需时间越长。然而，异步增量加载的选项提供了巨大的好处：我们可以让场景在后台逐渐加载，而不会对用户体验造成重大影响。这可以通过`SceneManager.LoadSceneAsync()`实现，并结合传递`LoadSceneMode.Additive`作为加载模式参数。
- en: It's important to realize that scenes do not strictly follow the concept of
    a game level. In most games, players are normally trapped in one level at a time,
    but Unity can support multiple scenes being loaded simultaneously through additive
    loading, allowing each scene to represent a small chunk of a level. Ergo, we could
    initialize the first scene for the level (*Scene-1-1a*), and as the player nears
    the next section, asynchronously and additively load in the next (*Scene-1-1b*),
    and repeat this continuously as the player travels through the level.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，场景并不严格遵循游戏关卡的概念。在大多数游戏中，玩家通常一次被困在一个关卡中，但Unity可以通过增量加载支持同时加载多个场景，允许每个场景代表关卡的一小部分。因此，我们可以初始化关卡的第一个场景（*Scene-1-1a*），当玩家接近下一部分时，异步和增量加载下一个（*Scene-1-1b*），然后随着玩家在关卡中的移动持续重复这个过程。
- en: Exploiting this feature would require a system that either constantly checks
    the player's position in the level until they get close or uses trigger volumes
    to broadcast a message that the player is nearing the next section and begin asynchronous
    loading at the appropriate time. Another important consideration is that the scene's
    contents won't appear immediately since asynchronous loading effectively spreads
    the loading out over a handful of frames to cause as little visible impact as
    possible. We need to make sure that we trigger asynchronous scene loading with
    more than enough time to spare so that the player won't see objects popping into
    the game.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个功能需要一种系统，要么不断检查玩家在关卡中的位置直到他们接近，要么使用触发体积来广播一个消息，表明玩家即将进入下一部分，并在适当的时间开始异步加载。另一个重要的考虑因素是，由于异步加载有效地将加载分散在几个帧上以尽可能减少可见影响，场景的内容不会立即出现。我们需要确保我们有足够的时间触发异步场景加载，这样玩家就不会看到对象突然出现在游戏中。
- en: Scenes can also be unloaded to clear them out of memory. This will save some
    memory or runtime performance in the form of removing any components making use
    of `Update()` that we no longer need. Again, this can be done both synchronously
    and asynchronously with `SceneManager.UnloadScene()` and `SceneManager.UnloadSceneAsync()`.
    This can be an enormous performance benefit because we're only using what we need
    due to the player's location in the level, but note that it is not possible to
    unload small chunks of a monolithic scene. If the original scene file was enormous,
    then unloading it would unload everything. The original scene would have to be
    broken up into smaller scenes and then loaded and unloaded as needed. Similarly,
    we should only begin to unload a scene if we're certain the player can no longer
    see its constituent objects; otherwise, they would witness objects disappearing
    out of nowhere. One last consideration is that scene unloading would trigger the
    destruction of many objects, which is likely to free up a lot of memory and trigger
    the garbage collector. The efficient use of memory is also important when making
    use of this tip.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 场景也可以被卸载以从内存中清除。这将节省一些内存或运行时性能，通过移除不再需要的任何使用`Update()`组件来实现。再次强调，这可以通过`SceneManager.UnloadScene()`和`SceneManager.UnloadSceneAsync()`同步和异步地完成。这可以带来巨大的性能提升，因为我们只使用玩家在关卡中的位置所需要的内容，但请注意，不可能卸载单体场景的小部分。如果原始场景文件非常大，那么卸载它将卸载一切。原始场景必须被分割成更小的场景，然后根据需要加载和卸载。同样，我们只有在确定玩家无法再看到其组成对象时才开始卸载场景；否则，他们会看到对象突然消失。最后一个考虑因素是，场景卸载会触发许多对象的销毁，这可能会释放大量内存并触发垃圾回收器。在利用这个技巧时，高效地使用内存也很重要。
- en: This approach would require a significant amount of scene redesign work, scriptwriting,
    testing, and debugging, which is not to be underestimated, but the benefits of
    improving user experience are exceptional. Having seamless transitions between
    areas in a game is a benefit that is often praised by players and critics because
    it doesn't take the player out of the action. If we use it appropriately, it can
    save a significant amount of runtime performance, improving the user experience
    further.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将需要大量的场景重新设计工作、脚本编写、测试和调试，这不可小觑，但改善用户体验的好处是显著的。在游戏中不同区域之间实现无缝过渡是玩家和评论家经常称赞的优点，因为它不会让玩家脱离游戏。如果我们恰当地使用它，可以节省大量的运行时性能，进一步提高用户体验。
- en: Creating a custom Update() layer
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义的 Update() 层
- en: Earlier in this chapter, in the *Update, coroutines, and InvokeRepeating* section,
    we discussed the relative pros and cons of using these Unity Engine features as
    a means of avoiding excessive CPU workload during most of our frames. Regardless
    of which of these approaches we might adopt, there is an additional risk of having
    lots of MonoBehaviours written to periodically call some function, which is having
    too many methods triggering in the same frame simultaneously.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的 *更新、协程和InvokeRepeating* 部分，我们讨论了使用这些 Unity 引擎功能作为避免大多数帧中过度 CPU 工作负载的相对优缺点。无论我们可能采用哪种方法，都存在一个额外的风险，即许多
    MonoBehaviours 都会定期调用某个函数，这会导致在同一帧内同时触发太多方法。
- en: Imagine thousands of MonoBehaviours that initialized together at the start of
    a scene, each starting a coroutine at the same time that will process their AI
    tasks every 500 milliseconds. It is highly likely that they would all trigger
    within the same frame, causing a huge spike in its CPU usage for a moment, which
    settles down temporarily and then spikes again a few moments later when the next
    round of AI processing is due. Ideally, we would want to spread these invocations
    out over time.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在场景开始时一起初始化成千上万的 MonoBehaviours，每个 MonoBehaviours 都在相同的时间启动一个协程，每500毫秒处理一次它们的
    AI 任务。它们很可能都在同一帧内触发，导致 CPU 使用率瞬间激增，然后暂时稳定下来，几秒钟后又因为下一轮 AI 处理而再次激增。理想情况下，我们希望将这些调用分散到不同的时间。
- en: 'The following are the possible solutions to this problem:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对这个问题的可能解决方案：
- en: Generating a random amount of time to wait each time the timer expires or a
    coroutine triggers
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次计时器到期或协程触发时，生成一个随机的等待时间
- en: Spreading out coroutine initialization so that only a handful of them are started
    at each frame
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将协程初始化分散开来，以便每帧只启动少数几个
- en: Passing the responsibility of calling updates to some `God` class that places
    a limit on the number of invocations that occur each frame
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用更新责任传递给一个名为 `God` 的类，该类对每帧发生的调用次数进行限制
- en: The first two options are appealing since they're relatively simple and we know
    that coroutines can potentially save us a lot of unnecessary overhead. However,
    as we discussed, there are many dangers and unexpected side effects associated
    with such drastic design changes.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法很有吸引力，因为它们相对简单，而且我们知道协程可以潜在地为我们节省很多不必要的开销。然而，正如我们讨论的那样，这种激进的设计变化有许多危险和意外的副作用。
- en: A potentially better approach to optimize updates is to not use `Update()` at
    all—or, more accurately, to use it only once. When Unity calls `Update()`, and
    in fact, any of its callbacks, it crosses the aforementioned Native-Managed Bridge,
    which can be a costly task. In other words, the processing cost of executing 1,000
    separate `Update()` callbacks will be more expensive than executing one `Update()` callback,
    which calls into 1,000 regular functions. As we witnessed in the <q>Remove empty
    callback definitions</q> section, calling `Update()` thousands of times is not
    a trivial amount of work for the CPU to undertake, primarily because of the bridge.
    We can, therefore, minimize how often Unity needs to cross the bridge by having
    a `God` class `MonoBehaviour` use its own `Update()` callback to call our own
    custom update-style system used by our custom components.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 优化更新的一个潜在更好的方法是完全不使用 `Update()`——或者更准确地说，只使用一次。当 Unity 调用 `Update()` 时，实际上是其任何回调，它都会跨越上述原生-托管桥，这可能是一项昂贵的任务。换句话说，执行
    1,000 个单独的 `Update()` 回调的处理成本将比执行一个 `Update()` 回调（该回调调用 1,000 个常规函数）更高。正如我们在 `<q>删除空回调定义</q>`
    部分所见证的，调用 `Update()` 数千次对 CPU 来说不是一项微不足道的工作，主要是因为桥接。因此，我们可以通过让一个 `God` 类 `MonoBehaviour`
    使用其自己的 `Update()` 回调来调用我们自定义的更新风格系统（该系统由我们的自定义组件使用）来最小化 Unity 需要跨越桥的频率。
- en: In fact, many Unity developers prefer implementing this design right from the
    start of their projects, as it gives them finer control over when and how updates
    propagate throughout the system; this can be used for things such as menu pausing,
    cool-time manipulation effects, or prioritizing important tasks and/or suspending
    low-priority tasks if we detect that we're about to reach our CPU budget for the
    current frame.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多 Unity 开发者更喜欢从项目一开始就实现这种设计，因为它让他们能够更精细地控制更新何时以及如何在整个系统中传播；这可以用于菜单暂停、冷却时间操纵效果，或者在我们检测到即将达到当前帧的
    CPU 预算时，优先处理重要任务和/或挂起低优先级任务。
- en: All objects wanting to integrate with such a system must have a common entry
    point. We can achieve this through an `Interface` class with the `interface` keyword.
    An `Interface` is a code construct used to essentially set up a contract whereby
    any class that implements the `Interface` class must provide a specific series
    of methods. In other words, if we know the object implements an `Interface` class,
    then we can be certain about what methods are available. In C#, classes can only
    derive from a single base class, but they can implement any number of `Interface`
    classes (this avoids the *deadly diamond of death* problem that C++ programmers
    will be familiar with).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有希望与这种系统集成的对象都必须有一个公共的入口点。我们可以通过使用 `interface` 关键字的 `Interface` 类来实现这一点。`Interface`
    是一种代码结构，用于基本上设置一个合同，即任何实现 `Interface` 类的类都必须提供一系列特定的方法。换句话说，如果我们知道对象实现了 `Interface`
    类，那么我们可以确定有哪些方法可用。在 C# 中，类只能从单个基类派生，但它们可以实现任意数量的 `Interface` 类（这避免了 C++ 程序员熟悉的
    *致命菱形死亡* 问题）。
- en: 'The following `Interface` class definition will suffice, which only requires
    the implementing class to define a single method called `OnUpdate()`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Interface` 类定义就足够了，它只要求实现类定义一个名为 `OnUpdate()` 的方法：
- en: '[PRE44]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It's common practice to start an `Interface` class definition with an uppercase
    "I" to make it clear that it is an `Interface` class we're dealing with. The beauty
    of `Interface` classes is that they improve the decoupling of our code base, allowing
    huge subsystems to be replaced, and as long as the `Interface` class is adhered
    to, we will have greater confidence that it will continue to function as intended.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是以大写 "I" 开头定义 `Interface` 类，以使其清晰表明我们正在处理的是一个 `Interface` 类。`Interface`
    类的美丽之处在于它们提高了我们代码库的解耦，允许替换巨大的子系统，并且只要坚持 `Interface` 类，我们将更有信心它将继续按预期工作。
- en: 'Next, we''ll define a custom `MonoBehaviour` type that implements this `Interface` class:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个自定义的 `MonoBehaviour` 类型，该类型实现了这个 `Interface` 类：
- en: '[PRE45]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we're naming the method `OnUpdate()` rather than `Update()`. We're
    defining a custom version of the same concept, but we want to avoid name collisions
    with the built-in `Update()` callback.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们给这个方法命名为 `OnUpdate()` 而不是 `Update()`。我们正在定义同一概念的定制版本，但希望避免与内置的 `Update()`
    回调发生名称冲突。
- en: The `OnUpdate()` method of the `UpdateableComponent` class retrieves the current
    delta time (`dt`), which spares us from a bunch of unnecessary `Time.deltaTime` calls,
    which are commonly used in `Update()` callbacks. We've also created the  `virtual` function
    to allow derived classes to customize it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateableComponent`类的`OnUpdate()`方法检索当前的时间增量(`dt`)，这使我们免去了许多不必要的`Time.deltaTime`调用，这些调用通常用于`Update()`回调中。我们还创建了一个`virtual`函数，以允许派生类自定义它。'
- en: This function will never be called as it's currently being written. Unity automatically
    grabs and invokes methods defined with the `Update()` name, but has no concept
    of our `OnUpdate()` function, so we will need to implement something that will
    call this method when the time is appropriate. For example, some kind of `GameLogic` `God`
    class could be used for this purpose.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数永远不会被调用，因为它目前是这样编写的。Unity会自动获取并调用名为`Update()`的方法，但它没有我们`OnUpdate()`函数的概念，因此我们需要实现一些东西，在适当的时候调用这个方法。例如，可以使用某种`GameLogic`的`God`类来完成这个目的。
- en: During the initialization of this component, we should do something to notify
    our `GameLogic` object of both its existence and its destruction so that it knows
    when to start and stop calling its `OnUpdate()` function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件初始化期间，我们应该做一些事情来通知我们的`GameLogic`对象其存在和销毁，以便它知道何时开始和停止调用其`OnUpdate()`函数。
- en: In the following example, we will assume that our `GameLogic` class is `SingletonComponent`,
    as defined earlier, in the <q>Singleton components</q> section, and has appropriate
    `static` functions defined for registration and deregistration. Bear in mind that
    it could just as easily use the aforementioned `MessagingSystem` to notify `GameLogic`
    of its creation/destruction.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将假设我们的`GameLogic`类是之前定义的`SingletonComponent`，在《<q>单例组件</q>》部分中定义，并且为注册和注销定义了适当的`static`函数。请记住，它同样可以使用上述的`MessagingSystem`来通知`GameLogic`其创建/销毁。
- en: 'For MonoBehaviours to hook into this system, the most appropriate place is
    within their `Start()` and `OnDestroy()` callbacks:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让MonoBehaviours能够钩入这个系统，最合适的地方是在它们的`Start()`和`OnDestroy()`回调中：
- en: '[PRE46]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It is best to use the `Start()` method for the task of registration, since using `Start()` means
    that we can be certain all other pre-existing components will have at least had
    their `Awake()` methods called prior to this moment. This way, any critical initialization
    work will have already been done on the object before we start invoking updates
    on it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Start()`方法进行注册任务是最好的，因为使用`Start()`意味着我们可以确定所有其他现有的组件在此之前至少已经调用了它们的`Awake()`方法。这样，任何关键初始化工作在我们在其上调用更新之前就已经在对象上完成了。
- en: Note that because we're using `Start()` in a `MonoBehaviour` base class, if
    we define a `Start()` method in a derived class, it will effectively override
    the base class definition, and Unity will grab the derived `Start()` method as
    a callback instead. It would, therefore, be wise to implement a virtual `Initialize()` method
    so that derived classes can override it to customize initialization behavior without
    interfering with the base class's task of notifying the `GameLogic` object of
    our component's existence.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我们在一个`MonoBehaviour`基类中使用`Start()`，如果我们在一个派生类中定义一个`Start()`方法，它将有效地覆盖基类的定义，Unity将获取派生类的`Start()`方法作为回调。因此，实现一个虚拟的`Initialize()`方法是明智的，以便派生类可以覆盖它来自定义初始化行为，而不会干扰基类通知`GameLogic`对象我们的组件存在的工作。
- en: 'The following code provides an example of how we might implement a virtual
    `Initialize()` method:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个示例，说明我们如何实现一个虚拟的`Initialize()`方法：
- en: '[PRE47]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, we will need to implement the `GameLogic` class. The implementation
    is effectively the same whether it is `SingletonComponent` or `MonoBehaviour`,
    and whether or not it uses `MessagingSystem`. Either way, our `UpdateableComponent`
    class must register and deregister as `IUpdateable` objects, and the `GameLogic`
    class must use its own `Update()` callback to iterate through every registered
    object and call their `OnUpdate()` function.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现`GameLogic`类。无论它是`SingletonComponent`还是`MonoBehaviour`，或者是否使用`MessagingSystem`，实现都是相同的。无论如何，我们的`UpdateableComponent`类必须注册和注销为`IUpdateable`对象，而`GameLogic`类必须使用它自己的`Update()`回调来遍历每个注册的对象并调用它们的`OnUpdate()`函数。
- en: 'Here is the definition for our `GameLogic` class:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`GameLogic`类的定义：
- en: '[PRE48]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we make sure that all of our custom components inherit from the `UpdateableComponent`
    class, then we've effectively replaced *N* invocations of the `Update()` callback
    with just one `Update()` callback, plus <q>N</q> virtual function calls. This
    can save us a large amount of performance overhead because even though we're calling
    virtual functions (which cost a small overhead more than non-virtual function
    calls because they need to redirect the call to the correct place), we're still
    keeping the overwhelming majority of update behavior inside our managed code and
    avoiding the Native-Managed Bridge as much as possible. This class can even be
    expanded to provide priority systems, to skip low-priority tasks if it detects
    that the current frame has taken too long, and many other possibilities.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确保所有的自定义组件都继承自`UpdateableComponent`类，那么我们就有效地将*N*次`Update()`回调调用替换为仅一次`Update()`回调调用，以及<q>N</q>次虚函数调用。这可以为我们节省大量的性能开销，因为尽管我们在调用虚函数（这比非虚函数调用多出一些开销，因为它们需要将调用重定向到正确的地方），但我们仍然将绝大多数的更新行为保持在我们的托管代码中，并尽可能避免使用原生-托管桥接。这个类甚至可以扩展以提供优先级系统，如果检测到当前帧耗时过长，则跳过低优先级任务，以及许多其他可能性。
- en: Depending on how deep you already are into your current project, such changes
    can be incredibly daunting, time-consuming, and likely to introduce a lot of bugs
    as subsystems are updated to make use of a completely different set of dependencies.
    However, the benefits can outweigh the risks if time is on your side. It would
    be wise to do some testing on a group of objects in a scene that is similarly
    designed to your current scene files to verify that the benefits outweigh the
    costs.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对当前项目的熟悉程度，这样的改变可能会非常令人畏惧、耗时且可能引入大量错误，因为子系统被更新以使用一组完全不同的依赖项。然而，如果时间站在你这边，这些好处可能会超过风险。明智的做法是在一个与你的当前场景文件设计类似的场景中测试一组对象，以验证好处是否超过成本。
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to many methods that will improve your scripting
    practices in the Unity Engine and to improve performance if (and only if) you
    have already proven some scripts are the cause of a performance problem. Some
    of these techniques demand some forethought and profiling investigation before
    being implemented since they often come with introducing additional risks or obfuscating
    our code base. Workflow is often just as important as performance and design,
    so before you make any performance changes to the code, you should consider whether
    or not you're sacrificing too much on the altar of performance optimization.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了许多方法，这些方法将提高您在Unity引擎中的脚本实践，并在（且仅在你已经证明某些脚本是性能问题的原因时）提高性能。这些技术中的一些在实施之前需要一些预先思考和性能分析调查，因为它们通常会带来额外的风险或使我们的代码库变得难以理解。工作流程通常与性能和设计一样重要，所以在你对代码进行任何性能更改之前，你应该考虑你是否在性能优化的祭坛上牺牲了太多。
- en: We will investigate more advanced scripting improvement techniques later, in
    Chapter 8, *Masterful Memory Management*, but let's take a break from staring
    at code and explore some ways to improve graphics performance using a pair of
    built-in Unity features known as dynamic batching and static batching.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章“精通内存管理”中稍后探讨更高级的脚本改进技术，但现在让我们暂时放下代码，探索一些使用名为动态批处理和静态批处理的一对内置Unity功能来提高图形性能的方法。
