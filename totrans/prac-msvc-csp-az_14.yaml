- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: gRPC for Binary Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service-to-service communication does not need to be via REST passing JSON data.
    Performance and cost are important factors to consider when it comes to using
    **gRPC**, a binary and platform-independent communication technology. Reducing
    the data that’s transferred can increase performance and reduce costs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll change some services in the Codebreaker solution so that
    they offer gRPC instead or in addition to REST services. You’ll learn how gRPC
    differs from REST, as well as how to create services and clients using this binary
    communication technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure a service project to use gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a platform-independent communication contract with Protobuf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create gRPC services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create clients that call gRPC services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription
    and Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ch14` folder contains the projects we’ll be looking at in this chapter,
    as well as their results. To add the functionality from this chapter, you can
    start with the source code from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projects we’ll be considering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost`: The .NET Aspire host project. The app model has been
    updated to use HTTPS with the `game-apis` service and `live-service` so that it
    supports gRPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Live`: The project we created in the previous chapter has been
    changed to offer a gRPC service instead of a REST service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs`: This project has been updated so that it includes a
    gRPC client to invoke `live-service`. In addition to the REST service used by
    many different clients, a gRPC service has been added as an alternative. This
    is invoked by the bot service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot`: The bot service has been updated to use a gRPC client instead
    of REST to invoke the `game-apis` service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveTestClient`: You will need to use the live test client from the previous
    chapter to verify the SignalR service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before digging into gRPC, let’s compare it with **Representational State** **Transfer**
    (**REST**).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing REST with gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important difference between REST and gRPC is that REST is a *guideline*
    that builds upon HTTP, whereas gRPC is a *protocol*. Both are used for communication
    between clients and services. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Communication style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is a guideline that defines services to be stateless, makes use of HTTP
    verbs (GET, POST, PUT, DELETE) to manipulate resources, typically uses a human-readable
    format such as JSON or XML, and is commonly used with web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC uses a *strongly defined contract* to specify the operations that are available
    with the services. While other specifications can be used as well, most services
    make use of **Protocol Buffers** (**Protobuf**) to specify the contract. With
    this, gRPC has a compact payload size and efficient serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to textual representation, REST has a higher overhead and a higher
    latency. With gRPC, because of its efficient serialization, latency is lower,
    and the binary serialization reduces the payload’s size. With gRPC, multiplexing
    allows for concurrent requests across a single connection.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST adds flexibility by using URIs for resources and is not strictly based
    on HTTP and HTTPS. Other protocols can be used as well that fulfill REST principles.
  prefs: []
  type: TYPE_NORMAL
- en: With gRPC, contracts strictly specify the communication. gRPC is based on HTTP/2,
    which offers some advantages compared to HTTP/1, such as multiplexing concurrent
    calls over a single connection. gRPC-Web is an alternative that allows a subset
    of gRPC to be used with HTTP/1.
  prefs: []
  type: TYPE_NORMAL
- en: Language support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST just needs HTTP and works with any language that supports HTTP. With gRPC,
    based on the protobuf contract, code is created – and this requires supported
    languages to be used. Check out the list of supported languages at [https://grpc.io/docs/languages/](https://grpc.io/docs/languages/).
    It includes C#, C++, Dart, Java, Go, Python, PHP, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST relies on transport security (HTTPS). Authentication and authorization
    are done at the application level. With gRPC, transport security (TLS/SSL) is
    supported, and authentication via OAuth and JWT is built-in. gRPC supports per-message
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST allows for easy interoperability. Only HTTP calls need to be made. It’s
    used with web APIs and simple services, as well as for interoperability with existing
    services.
  prefs: []
  type: TYPE_NORMAL
- en: With cloud services, we pay for compute and memory resources. With a lot of
    communication going on, the number of instances needed can be reduced by using
    memory and CPU-efficient technologies. Communication between services can be done
    using gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by updating the solution so that it makes use of gRPC (with the
    logging collectors, gRPC is already in use).
  prefs: []
  type: TYPE_NORMAL
- en: Updating a service project so that it uses gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using .NET templates to create new projects, a gRPC service can be created
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When using such a project, you can check the project file to see the NuGet packages
    and other configurations that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we already have existing projects, we’ll update these to offer a gRPC
    service. But first, let’s have a look at the communication between the Codebreaker
    services shown in *Figure 14**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Codebreaker communication technologies](img/B21217_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Codebreaker communication technologies
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the right-hand side. In [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317),
    we implemented the Codebreaker live service using a SignalR hub, which notifies
    SignalR clients. For the SignalR client, we created a console client application.
    Also in [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317), we used minimal ASP.NET
    Core APIs which allowed us to call the `game-apis` service to send completed games.
    This is a form of service-to-service communication that can be replaced by gRPC.
    The `game-apis` service itself is called by clients and the bot service. With
    this service, a REST API must be invoked by any client technology. The communication
    between the bot and the `game-apis` service can be done using gRPC as well. Thus,
    when it comes to the `game-apis` service, we’ll offer an alternative communication
    technology so that communication between the `game-apis` service and `live-service`
    will be replaced. Thus, in this chapter, we’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the minimal API implementation of `live-service` with gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an alternative option for the `game-apis` service so that we offer gRPC
    as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a gRPC client with the `game-apis` service to invoke `live-service`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a gRPC client with clients of the `game-apis` service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by creating a gRPC service contract for `live-service` that’s invoked
    by the `game-apis` service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating service contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to add the `Grpc.AspNetCore` NuGet package to the `Codebreaker.Live`
    project. Then, we must add a Protobuf file as a contract to the service. The contract
    file is language and platform-independent, so a .NET service can communicate with
    a Dart application using the same Protobuf file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Visual Studio, add a `Protos` folder, and use the Visual Studio template
    to create a `Codebreaker.Live`, you can run the following command to create the
    `LiveGame.proto` file inside the `Protos` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s create contracts for both `live-service` and `game-apis`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a gRPC service contract for live-service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simpler contract is the one for `live-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Protos/LiveGame.proto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `syntax` keyword specifies the Protobus version that should be used. Version
    3 added features such as `maps` and `oneof` fields. The `option` keyword allows
    us to add language-specific features. `option csharp_namespace` sets the C# namespace
    that should be used by the generated classes, postfixed with the name set by the
    `package` keyword. The `service` keyword describes the list of operations offered
    by the gRPC service. Every operation within the service uses the `rpc` keyword
    (remote procedure call). In our code, the operation is called `ReportGameCompleted`,
    uses `ReportGameCompletedRequest` as a parameter, and returns `google.protobuf.Empty`.
    `google.protobuf.Empty` is one of the well-known Protobuf types that’s available.
    When used, this type must be imported using the `import` keyword. The `google.protobuf.Duration`
    and `google.protobuf.Timestamp` types are imported as well. `ReportGameCompletedRequest`
    is a message that’s specified using the `message` keyword. Every field within
    a message needs a unique identifier. The serializer and deserializers use this
    number to get a match. Thus, if you specify a contract once, don’t change the
    number in future versions, as this breaks existing clients or services. The types
    used need to be platform-independent as the same Protobuf file can be used by
    all platforms that support gRPC. `string`, `bool`, and `int32` are types that
    are defined by the Protobuf specification. With .NET, these types map to `string`,
    `bool`, and `int`, respectively. `Id` is a GUID, but there’s no representation
    for GUIDs with Protobuf. `string` can be used for the identifier. With the .NET
    `GameSummary` class, the `StartTime` property is of the `DateTime` type and the
    `Duration` property is of the `TimeSpan` type. To map these types with Protobuf,
    you can use `Timestamp` and `Duration`. These types are defined in the `Google.Protobuf.WellKnownTypes`
    .NET namespace. `Timestamp` and `Duration` offer conversion methods to convert
    to and from `DateTime` and `TimeSpan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create .NET classes from the Protobuf file, a `Protobuf` entry needs to
    be added to the project file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Codebreaker.Live.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This `Protobuf` entry references the Protobuf file with the `Include` attribute
    and specifies the code to be generated for the server by setting `GrpcServices`
    to `Server`. With the server, classes for all the defined messages and base classes
    for every service specified are generated. Later in this chapter, we’ll use the
    `Protobuf` element to generate classes for the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created the `GameSummary` class to report game
    completions. To convert this class into the gRPC-generated `ReportGameCompletedRequest`
    class, we must define a conversion method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Extensions/ReportGameCompletedRequestExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we create a new `GameSummary` instance and use conversion
    methods – for example, we parse a string to a `Guid` value and invoke the `ToDateTime`
    and `ToTimeSpan` methods to convert the `Timestamp` and `Duration` values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To see the generated code with Visual Studio, click on the `ReportGameCompletedRequest`
    class, use the context menu, and select **Go To Implementation**. This directly
    opens the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: With `ReportGameService`, we just have a very simple contract. To allow `game-apis`
    to be called and moves to be made by the bot service, we need a more complex contract.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a gRPC service contract for the game-apis service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The gRPC contracts of the `game-apis` service are lengthier than for `live-service`.
    Here, we’ll focus on some specific parts of the contract. Check out this book’s
    GitHub repository for the complete definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service contract specifies operations to play the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The alternative option to the REST interface, `GrpcGameService`, defines operations
    to create a game (`CreateGame`), set a move (`SetMove`), and get information about
    a game (`GetGame`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most messages that are used to send a request to the service just contain scalar
    values. The `SetMoveRequest` message is different. This message contains a list
    of guess pegs:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Lists are specified using the `repeated` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only pre-defined types can be repeated – it’s also possible to repeat an
    inner message type:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `GetGameResponse` message type contains a repeated list of `Move` messages.
    The `Move` message type contains a list of strings for the guess pegs and the
    key pegs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protobuf also defines a list of keys and values via the `map` type:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Protos/GameService.proto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With a map, the key and value types are specified. With the `fieldValues` field,
    the key is a string. The corresponding REST API specifies a string array for the
    value. Using `repeated` with the value type is not possible with Protobuf. Instead,
    `FieldMessage` is defined to contain a `repeated string`, and this is used with
    the `map` value.
  prefs: []
  type: TYPE_NORMAL
- en: The message contracts create .NET classes that are specific to gRPC. When it
    comes to the local service classes, it’s better if they’re independent of communication
    technologies. So, we need to create conversion methods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conversion methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gRPC service of `live-service` receives `ReportGameCompletedRequest`. This
    is forwarded to the SignalR service we created in the previous chapter as a `GameSummary`
    method. So, we need to convert `ReportGameCompletedRequest` into a `GameSummary`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Extensions/GrpcExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is done in the form of an extension method where we extend the `ReportGameCompletedRequest`
    type. With the implementation of the `ToGameSummary` method, simple scalar types
    can be passed on, creating a `GameSummary` object. Google’s `Timestamp` and `Duration`
    types offer the `ToDateTime` and `ToTimeSpan` methods to convert `DateTime` and
    `TimeSpan`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Libraries such as `AutoMapper`, `Mapster`, and others can be used to automatically
    implement such conversions. While this works out of the box with simple properties
    without the need to add custom code, some customization is needed when converting
    different types. What you need to be aware of is that mapper libraries that use
    .NET reflection instead of source generators increase memory and CPU usage and
    cannot be used with native AOT. Depending on the types you need to map, you might
    prefer a custom extension method.
  prefs: []
  type: TYPE_NORMAL
- en: Check out this book’s GitHub repository for additional conversion methods that
    can be used with the `game-apis` service.
  prefs: []
  type: TYPE_NORMAL
- en: With the conversion methods in place, let’s create the gRPC service implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating gRPC services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement a gRPC service for the `Codebreaker.Live` project, create the
    `GRPCLiveGameService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Endpoints/GRPCLiveGameService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the `GRPCLiveGameService` class, using constructor injection, the hub context
    we created in the previous chapter is injected to send a `GameSummary` method
    to all connected clients participating with the group that is named with `game-type`.
    The `GRPCLiveGameService` class needs to derive from the base class – that is,
    `ReportGame.ReportGameBase`. `ReportGameBase` is implemented as an inner class
    of `ReportGame` based on the Protobuf contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the `GRPCLiveGameService` class to map it as a gRPC endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can remove the mapping of the minimal API endpoint and just configure the
    gRPC endpoint with the `WebApplication` class known as `MapGrpcService`, passing
    the service class as a generic parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC requires HTTP/2\. So, we need to configure the `Kestrel` server:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Configuring `Protocols` to `Http1And2` starts the `Kestrel` server and ensures
    it supports both HTTP/1 and HTTP/2\. The gRPC service needs HTTP/2\. When it comes
    to `live-service`, SignalR is offered from the same server. To allow the SignalR
    service to connect via HTTP/1 or HTTP/2, the server must be configured to offer
    both versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `game-apis` service’s implementation has similarities. In the project file,
    we need to add the `Grpc.AspNetCore` package, add a `Protobuf` element to the
    project file, and specify that we wish to create classes for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this aspect of the gRPC service is simple: we can inject the `IGameService`
    interface. This uses the same classes we already used to implement the minimal
    API service:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/GrpcGameEndpoints.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In gRPC, we can derive from the generated base class, `GrpcGame.GrpcGameBase`,
    override the base class methods that have been specified with the service contracts,
    and use the conversion methods to convert the input and output types into their
    corresponding gRPC representations.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `live-service`, the `game-apis` service needs gRPC to be added to
    the DI container and mapped to the endpoint, and `Kestrel` needs to be configured
    so that it supports both HTTP/1 and HTTP/2.
  prefs: []
  type: TYPE_NORMAL
- en: With the services implemented, let’s consider the gRPC clients.
  prefs: []
  type: TYPE_NORMAL
- en: Creating gRPC clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re using Visual Studio 2022, you can take advantage of its built-in
    support to add a gRPC client. From Solution Explorer, select the project, open
    the context menu, and select **Add** | **Connected Service**. This opens the dialogue
    shown in *Figure 14**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Add service reference](img/B21217_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Add service reference
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **gRPC** and click **Next**. This opens the dialogue shown in *Figure
    14**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Add new gRPC service reference](img/B21217_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Add new gRPC service reference
  prefs: []
  type: TYPE_NORMAL
- en: Select the Protobuf file, then select **Client** from the **Select the type
    of class to be generated** dropdown to create the classes for messages and the
    code for the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not using Visual Studio, you can use a .NET command-line tool called
    `dotnet`. To install this tool, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With this tool globally installed, you can use the `dotnet-grpc` command to
    create the proxy classes for the `game-apis` client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the following for the bot service client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What happened with these commands or with the Visual Studio integration?
  prefs: []
  type: TYPE_NORMAL
- en: The `Grpc.AspNetCore` NuGet package was added to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Protobuf` element was added to the project file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the command-line tool, code for both the client and the server is created
    when the `Protobuf` entry is created. To only create code for the client, the
    `GrpcServices="Client"` attribute needs to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPis/Codebreaker.GameAPIs.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Regarding the `game-apis` service, the project file now includes two `Protobuf`
    entries. One is used to create the service part (which we did in the previous
    section), while the new entry is for the client code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bot invokes the `game-apis` service. So, the proto file of the `game-apis`
    service needs to be referenced in the bot project file:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Bot/Codebreaker.Bot.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, for the client, `GrpcServices` is set to `Client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon using the proto files, client proxy classes are created, offering methods
    to invoke the service with the names of the operations. These proxy classes can
    be injected. In the following code snippet, the generated `ReportGameClient` class
    is being injected into the `GrpcLiveReportClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameApis/GrpcLiveReportClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`ReportGameClient` implements the `ILiveReportClient` interface – the same
    interface we defined and implemented in the previous chapter to invoke the SignalR
    service on completion of a game. When implementing the same interface, we just
    need to change the configuration of the DI container so that it invokes the service
    via gRPC instead of using the REST interface. With the implementation of the `ReportGameEndedAsync`
    method, we can invoke the generated method from the proxy and need to convert
    the parameter with the help of an extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameApis/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for the bot service, `GrpcGamesClient` implements the `IGamesClient`
    interface and injects `GrpcGame.GrpcGameClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Bot/GrpcGamesClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `IGamesClient` interface was the same one that’s implemented by `GameClient`,
    which calls the REST API. This interface is injected into `CodebreakerGameRunner`,
    so no changes are required when switching to gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetMoveAsync` method makes a request to the gRPC service by invoking the
    `SetMoveAsync` method of `GrpcGame.GrpcGameClient`. Similar to before, it aims
    to convert the parameters into the ones needed by gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: For help with implementing the other methods of the interface, check out this
    book’s GitHub repository. Note that it’s similar to what we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To glue `IGamesClient` to the new implementation, and to configure the gRPC
    client, we need to update the DI container’s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Bot/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `AddGrpcClient` method configures the generated class with the address of
    the `game-apis` service.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the application and start one or multiple instances of the live test
    client to see if completed games show up. Start the bot service and send requests
    to the bot service to play several games. At the same time, use another client
    to play a game. How many games does the bot run until you complete one? Of course,
    this depends on the think time you configure with the bot. Do the results show
    up in the console of the live test client? Check the logs and the environment
    variables of the different services in the .NET Aspire dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the differences between REST APIs and gRPC, as
    well as the advantages when using gRPC with service-to-service communication.
  prefs: []
  type: TYPE_NORMAL
- en: You created a service contract using Protobuf syntax to define services and
    messages. Contrary to REST, gRPC is strict when it comes to messages and service
    operations. You created servers and clients using the classes that were generated
    with the proto files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce cost in the cloud, it can be cost-effective to use protocols with
    lower overhead for service-to-service communication. However, other options are
    available as well. Upon completion of the game, it’s not required to inform the
    listener immediately. There’s also a price aspect to this: with the current implementation,
    the live service is running when accessed from the game APIs service. If nobody
    is listening, this is not required. By using asynchronous communication, the `live-service`
    can register to receive information when it’s started – this is when a listener
    is active. Asynchronous communication will be covered in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Protobuf Language* *Guide*: [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*gRPC on .NET-supported* *platforms*: [https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms](https://learn.microsoft.com/en-us/aspnet/core/grpc/supported-platforms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*grpc-dotnet GitHub* *repository*: [https://github.com/grpc/grpc-dotnet](https://github.com/grpc/grpc-dotnet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Call gRPC services with the .NET* *client*: [https://learn.microsoft.com/en-us/aspnet/core/grpc/client](https://learn.microsoft.com/en-us/aspnet/core/grpc/client)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
