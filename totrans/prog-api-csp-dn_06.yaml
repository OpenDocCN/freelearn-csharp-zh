- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Determining the execution environment of your APIs can have a large impact
    on how they run, how they scale, how much they cost, and what features come out
    of the box. Azure Functions provides a different hosting option that complements
    existing Azure services with a focus on event-driven execution. While Functions
    provides many ways to react to different things in a system, we’ll focus on a
    specific event: the HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover some technical aspects related to hosting and billing
    and finish with a walkthrough that includes cloud deployment and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you’ll have a good base to continue your API journey
    by knowing about the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Hosting considerations that affect certain runtime options and limitations based
    on the needs of your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How certain aspects of your application can affect billing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure, general familiarity, and possibilities of code design related
    specifically to HTTP APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Azure from Visual Studio. Automated builds, continuous integration,
    and continuous delivery will be covered later in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making runtime configuration changes without redeployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to adjust scaling settings to reduce the potential cost of a public endpoint,
    colloquially known as a Denial-of-Wallet attack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build Azure Functions in Visual Studio, you’ll need the Azure development
    workload available in Visual Studio Installer. The source code for this chapter
    is available at https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter06
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions fills a large role in execution environments while focusing
    on event-based data processing. Traditionally, those environments have a lot of
    overhead in terms of hardware or **virtual machines** ( **VMs** ) and boilerplate
    code. Functions is Microsoft’s execution environment to allow ease of development,
    deployment, and scaling. While a few types of underlying execution environments
    are available, it defaults to consumption, which brings a set of defaults that
    are well suited to a large variety of different data processing scenarios and
    are billed per event execution. If you need more CPU cores or memory, other environments
    are available; these will be covered later in this chapter. While all execution
    environments in Functions are considered serverless in the sense that you don’t
    have to manage individual instances, other non-consumption environments are not
    pay-per-use and instead are charged based on the amount of CPU cores and memory
    allocated to each instance. C# is the predominant language that’s used, although
    a variety of languages and bindings are supported.
  prefs: []
  type: TYPE_NORMAL
- en: The main entry points for the execution of these applications are triggers.
    A variety of these triggers exist to react to external events. From queue polling
    to ServiceBus pushing, reacting to blob, or database record changes, many ready-to-go
    bindings allow you to mix and match your solution. For APIs, the triggers we care
    most about are HTTP triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP triggers are exactly what they sound like: a request-response to a normal
    API request. These requests can come from all the usual suspects: browsers, webhooks,
    service-to-service calls, and so on. They can be routed to individual functions
    using the built-in routing template support. Incoming data from these routes can
    be automatically matched to the specified data types, deserialized, and bound.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Built-in authorization is either none or API key-based, with the latter available
    in two flavors: function-specific or a single global application key. Other standard
    authorization can be implemented with Entra ID, manually in code, or both.'
  prefs: []
  type: TYPE_NORMAL
- en: Hosting should also be considered since your application will need to run somewhere
    – likely, though not necessarily, in the cloud. Various hosting and packaging
    options are provided, allowing you to tailor deployment to accommodate your application’s
    needs. ZIP files, Docker, plain file copy (xcopy), and on-premises are all available.
    AMD64 Windows and Linux are supported on Azure, while ARM64 is supported in other
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a good understanding of the environment in which
    Azure Functions operates and what’s available to you.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a variety of hosting options available to suit practically any need.
    Each has its pros and cons. **Consumption** is the default and will be used in
    this chapter. **Flex Consumption** (in preview at the time of writing), **Premium**
    , **Application Service Environment** ( **ASE** ), and **Kubernetes** are additional
    supported offerings that won’t be discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Although powerful, Consumption comes with several limitations. First, the instance
    memory is limited to 1.5 GB, which can put a hard limit on the types of applications
    that can be run directly inside this Functions option. The second is that the
    instance only has a single core. The third is timeout. Azure only allows a timeout
    limit of 5 to 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: However, many workloads do fit well within these constraints. From standard
    **Software-as-a-Service** ( **SaaS** ), APIs, and periodic updates to CRUD and
    Durable Functions-related calls (explained in the next chapter), the potential
    is there for the vast majority of these to fit well within the limits.
  prefs: []
  type: TYPE_NORMAL
- en: Needing more compute resources can be common in artificial intelligence workloads,
    for example. While Consumption is conceptually easy to think about, Premium is
    the next step up. You’re billed for individual CPU vCores and GBs of memory allocated
    together in classic VM form. Managing these VMs is completely delegated to Azure.
    You set the maximum (and/or minimum) of the number of instances that the application
    can scale out to, and Azure handles the rest. The current limitations are 4 vCores
    and 14 GB of memory per host. Windows allows up to 100 hosts, and Linux between
    20 and 100 hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Application packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few application packaging and deployment options available as well,
    depending on what size of resource you require. Docker is supported on Premium
    and App Service, allowing you to control the runtime environment with precision.
    ZIP files (published archives containing your entire application) are supported
    for all runtimes and required with Consumption.
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that most of the runtime hosting modes, while they may still be available,
    are now considered deprecated. Originally, compiled functions were loaded inside
    the same physical operating system process that the function host was running
    in. This “in-proc” model allowed direct function calling between the host and
    custom functions but introduced potential issues with library dependencies and
    language updates. Hard dependencies on specific library versions couldn’t be changed,
    and new C# language versions couldn’t be used if they were incompatible with the
    existing runtime. Assembly loading quirks were also common, with varying success
    in workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions initially launched with an Azure-based browser editor, and although
    it was serverless, the model had room for improvement. Later, a new version allowed
    standard .NET assemblies to be compiled so that the function host, starting the
    physical operating system process, would load. This introduced dependency resolution
    conflicts and required pinning functions to the same runtime version as the host,
    highlighting the need for further solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Today, with out-of-process hosting, the majority of the aforementioned problems
    go away. Your function application runs in its own operating system process, managing
    its own startup, dependency injection, language, and .NET version. Communication
    is handled through an internal channel between the host application and your function
    application. This is the recommended way forward for .NET 6 and .NET 8 functions.
  prefs: []
  type: TYPE_NORMAL
- en: Though historical context is worth knowing for completeness, the defaults guide
    you through the recommended experience out of the box. So, how does the Consumption
    plan measure the usage of your API? Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Billing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The billing model for Consumption is a new metric that you may not be familiar
    with unless you’ve dealt with cloud cost estimation before. **Gigabytes per second**
    ( **GB/s** ) is the measure that’s used in Consumption to accurately bill for
    applications and is the first part of the billing process. Whether they’re quick
    and fast responses or memory-hungry multi-second responses, this style of metric
    allows it to be reported as a single numeric value. For example, a single request
    that takes 1 second to respond, using 1 GB of memory, would result in **1*1s*1GB=1GB/s**
    for billing. As for the inverse, four requests taking 250 milliseconds using the
    same 1 GB of memory would also equal 1 GB/s: **4*250ms*1GB=1GB/s** . At the time
    of writing, Azure’s free tier grants 400,000 GB/s of free usage per month. With
    each request potentially taking an average of 100ms and using 256 MB of memory,
    that works out to be 16 million requests. The second part of billing is more straightforward:
    the number of requests. Azure grants 1 million requests for free per month, and
    it’s $0.20 per million requests after that.'
  prefs: []
  type: TYPE_NORMAL
- en: Project walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll begin creating a new Functions project, adding an additional
    HTTP trigger with an API route, and setting up some configuration that practically
    all applications will require.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new Functions project is just like creating any other project. There
    are templates available in Visual Studio’s new project wizard to aid you with
    this. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Azure Functions** or search for it using the **functions** keyword
    and click **Next** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – New project wizard](img/B21988_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – New project wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'Name your project and click **Next** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Project configuration](img/B21988_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Project configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the runtime and hosting configuration options. Usually, the latest **Long
    Term Support** option is a safe bet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Functions worker configuration](img/B21988_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Functions worker configuration
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Http trigger** option, choose **Anonymous** under **Authorization
    level** , and click **Create** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll cover authentication and authorization later in this book. As mentioned
    earlier, Docker containers are supported, but leave this option unchecked for
    now. Ensure the **Azurite** option is selected. This supports backend state management
    for various things and is also the “Durable” in Durable Functions, something that
    will be covered in the next chapter. Other triggers can be added later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Additional Functions authorization options](img/B21988_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Additional Functions authorization options
  prefs: []
  type: TYPE_NORMAL
- en: 'Many different triggers are available, and you can mix and match as needed.
    Right-click on the project in the **Solution Explorer** area and select **Add**
    | **New** **Azure Function** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Adding a new Azure Function](img/B21988_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Adding a new Azure Function
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need to search for **Function** in the list, then click **Add** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – New item dialog](img/B21988_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – New item dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of triggers should appear. Select **Http trigger** , choose **Anonymous**
    for **Authorization level** , and click **Add** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The New Azure Function dialog](img/B21988_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The New Azure Function dialog
  prefs: []
  type: TYPE_NORMAL
- en: Note that templates are revised over time, and this new one may look different
    compared to the original Function. It also may add some interesting new objects
    that may look familiar to you, including **IActionResult** and **OkObjectResult**
    . These come from ASP.NET Core libraries. Install the latest **Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore**
    NuGet package if it wasn’t referenced by default.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve created two HTTP endpoints that should compile.
  prefs: []
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications will need options or configuration in some form. .NET provides
    built-in support for passing options in many forms, including custom ones, to
    your application when it starts up. These different instances, such as environment
    variables, JSON ( **appsettings.json** ) and XML files, and command-line arguments,
    are all layered on top of one another so that individual settings can be overridden
    as needed. Note that this is different from settings that are altered while the
    application is running, which are more advanced and circumstantial when creating
    APIs, and thus won’t be covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add support for these options, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class called **MyOptions** , make it **public** , and add a standard
    **string** property called **MyReturnValue** . We’ll use this to control the return
    value of the Function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and default the property value in the **MyOptions** class to anything
    you like. We’ll override it in the **appsettings.json** file in a moment, and
    change it at startup time during deployment later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new property to the **appsettings.json** file named **MyReturnValue**
    , and a different value than you originally defaulted to in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we must configure the application so that it can use the configuration
    framework at startup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify **.ConfigureServices** in **Program.cs** to add an additional argument
    to the **context** Lambda. Add calls to **.AddOptions<MyOptions>** to the services
    variable, or chain them onto the end of **.ConfigureFunctionsApplicationInsights**
    . Chain a call after **.AddOptions** to **.BindConfiguration** , taking an empty
    string. This binds values in the root configuration path to matching property
    names in the **MyOptions** class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Program.cs** file should look this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **MyOptions.cs** file should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify **Function1.cs** so that it includes **IOptions<MyOptions>** in the constructor,
    then save a reference to that as a class member. Have **OkObjectResult** return
    **_options.Value.MyReturnProperty** so that we can see values changing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Function1.cs** file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Test this out by running it. You should see the standard output console window
    with some informational Function messages including the visible routes. Hold *Ctrl*
    and click (on Windows) to run them in your browser, or use any standard HTTP software.
    You should see your hard-coded string as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Expected output in the browser](img/B21988_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Expected output in the browser
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Not only is your Function running, but it’s been set up so
    that its values can be altered at deployment time. Now, let’s learn how to route
    incoming requests to different sections of code.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll almost certainly need multiple routes in your Function API, including
    routing parameters, query parameters, and so on. This forms part of the “shape”
    or public contract of your API. Routing supports this concept. If you’re familiar
    with ASP.NET Core routes, then you’ll be right at home as they’re also supported,
    including constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do different requests know where to enter into your application? How should
    you describe what types of data should be allowed to be processed? Let’s start
    with a classic storefront products endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate **Function1.cs** and rename it **Products.cs** , ensuring that you
    include all the references to **Function1** in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **string category** and an **int id** parameter to the **Run** method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of returning a string in **OkObjectResult** , return an anonymous object
    containing **category** and **id** so that we can see the values that are passed
    in from the route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Product.cs** file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the new **Route** property in the **HttpTrigger** attribute, **"products/{category:alpha}/{id:int?}"**
    . This allows us to customize, restrict, and parse out the arguments from the
    desired endpoint. Since these route designs will likely be part of a larger web
    API for third-party consumers to use, you’ll want to take care in creating them.
    You know that the product ID must be numeric, but you may want to restrict the
    category so that it only contains letters. When implemented as a route template,
    it would look like the one we mentioned previously: **"products/{category:alpha}/{id:int?}"**
    . This will only match incoming requests that have your desired URI segments in
    the specified format. The question mark ( **?** ) denotes that the specified parameter
    is optional, and can be defaulted in the method parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice that *Figure 6* *.8* had the **api** URL segment prefixed to
    it when it wasn’t specified in the route? Where does this prefix come from? By
    default, **api** is the default prefix for Functions. This can be changed in the
    **host.json** file under the **extensions** > http > **routePrefix** setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: More details on overriding settings after deployment can be found in the *Post-deployment*
    *reconfiguration* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create the necessary Azure cloud resources and environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to create some resources before we can view them in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Azure resource creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s deploy your Function to production! To do so, create a new **Consumption
    Linux Function** and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://portal.azure.com](https://portal.azure.com) and create a new
    resource group if you don’t have one already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Creating a new resource group](img/B21988_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Creating a new resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'Place it in an Azure region geographically close to you. We’ll use this same
    region when we create other resources to minimize lag and potential bandwidth.
    Click on the **Review + create** tab, then **Create** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Successfully creating a new resource group](img/B21988_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Successfully creating a new resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this resource group, create a new Function app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Creating a new resource inside the resource group](img/B21988_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Creating a new resource inside the resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for **function** if you don’t see it in the default selection. Select
    **Create** | **Function App** to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Selecting Function App as the resource to create](img/B21988_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Selecting Function App as the resource to create
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select **Consumption** as your hosting option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Function hosting configuration](img/B21988_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Function hosting configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **.NET** for **Runtime stack** , **8 (LTS), isolated worker model**
    for **Version** , and **Linux** for **Operating system** . Select the region that
    you selected when you created the resource group and click **Next** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Function details](img/B21988_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Function details
  prefs: []
  type: TYPE_NORMAL
- en: 'A **storage account** resource will also need to be created to hold various
    things for the Function runtime, including logs, your deployment package, and
    optionally the Durable state, something we’ll discuss in the next chapter. Disable
    **Blob service diagnostic settings** for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Storage configuration](img/B21988_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Storage configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable **public access** . Then, choose **No** for **Enable** **Application
    Insights** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Application Insights creation](img/B21988_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Application Insights creation
  prefs: []
  type: TYPE_NORMAL
- en: Disable **continuous deployment** , an aspect that will also be covered in [*Chapter
    10*](B21998_10.xhtml#_idTextAnchor136) . We can use **Tags** to filter or group
    resources, and so on. Add tags if desired, or leave this section empty and click
    **Review + create** . Review your settings; if everything looks good, click **Create**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the deployment process will continue. Click **Go to resource**
    ; you’ll be taken to your brand new Function!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Portal overview blade for your Azure Function](img/B21988_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Portal overview blade for your Azure Function
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the URL listed on the right-hand side. You’ll be taken to a default
    page indicating that your Function is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 6.18 – Default Azure Functions landing page\uFEFF](img/B21988_06_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Default Azure Functions landing page
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: While these steps and screenshots are accurate at the time of writing, Azure
    often changes and upgrades its design, features, flow, and so on. It’s recommended
    that you check out the official documentation for updated guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Function resource is running with a default template, let’s deploy
    from Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing from Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s walk through deploying manually from Visual Studio. Automated deployments,
    also known as continuous delivery, will be covered in [*Chapter 10*](B21998_10.xhtml#_idTextAnchor136)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in **Visual Studio** , right-click on the **FunctionsChapter6** project
    and select **Publish…** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Publishing our project](img/B21988_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Publishing our project
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select **Azure** and click **Next** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Types of publishing](img/B21988_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Types of publishing
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Azure Function App (Linux)** and click **Next** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Azure publishing targets](img/B21988_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Azure publishing targets
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Microsoft account** and **subscription** you created the Function
    resource under. Search or locate your Function by name, select it, and click **Finish**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Selecting the account, subscription, and resource to publish
    to](img/B21988_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Selecting the account, subscription, and resource to publish to
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Finish** , then **Close** when you’re done. Details about your published
    profile will appear, including its **Configuration** and **Target Runtime** ,
    as well as any dependencies that it needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Function publish profile](img/B21988_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Function publish profile
  prefs: []
  type: TYPE_NORMAL
- en: When you’re ready, click **Publish** . Once that succeeds, you can view your
    new API route at https://<my resource name>.azurewebsites.net/api/products/electronics/471337.
    Note that you can see the default data if you go to https://<my resource name>.azurewebsites.net/api/Function
    .
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously in this chapter, we’ll now look at changing a configuration
    value without recompiling the Function, and without redeploying it.
  prefs: []
  type: TYPE_NORMAL
- en: Post-deployment reconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s change the configuration to a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Environment variables** blade, under the **Settings** section of the
    Function resource in the Azure portal, create a new key to override the setting
    we hard-coded earlier. Use **MyReturnProperty** as the key since we’re reading
    the configuration variables from the root namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.24 - Adding a new environment variable to override a setting](img/B21988_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 - Adding a new environment variable to override a setting
  prefs: []
  type: TYPE_NORMAL
- en: '**Apply** this addition, **Apply** the changes, and **Confirm** the save; your
    Function application will be restarted. Navigate to https://<my resource name>.azurewebsites.net/api/Function1
    so that you can see the new configuration value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Overridden configuration value](img/B21988_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Overridden configuration value
  prefs: []
  type: TYPE_NORMAL
- en: This can be nested arbitrarily deep. For example, if your **MyOptions** class’s
    **MyReturnValue** was a complex type with its own **MyOtherReturnValue** property,
    the path for the key in Azure would be **MyReturnValue__MyOtherReturnValue** .
    Note that there are two underscores between the property names.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is publicly accessible, it has the potential to cost you money if
    a rogue process becomes aware of your new endpoint. Securing this new site with
    what’s colloquially known as **Easy Auth** will be discussed later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: But in the meantime, you can adjust some hosting options to limit the potential
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Settings** | **Scale out** and change **Maximum Scale Out Limit**
    to **1** . Then, click **Save** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Limiting scale out](img/B21988_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 – Limiting scale out
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, navigate to **Settings** | **Configuration** , change **Daily Usage Quota**
    to **1** , and click **Save** , then **Continue** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Adding a daily quota](img/B21988_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – Adding a daily quota
  prefs: []
  type: TYPE_NORMAL
- en: At this point, while you haven’t secured your site against bots or malicious
    actors, you have at least taken a few steps to mitigate any potential damage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through creating multiple HTTP endpoints inside a
    single Azure Function, adding a route template to assist with managing differing
    URI segments at runtime. Then, we added configuration options to our project,
    deployed it to Azure, and adjusted the configuration options after deployment.
    To limit the potential cost of a deployed, live HTTP endpoint, we adjusted two
    settings until authorization was in place.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how HTTP triggers work in Azure Functions, in the next
    chapter, we’ll explore other types of triggers we can use to build reliable, stateful,
    and scalable workflows.
  prefs: []
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write an API using Azure Functions, create a Function resource in Azure, and
    then deploy your Function to it with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
