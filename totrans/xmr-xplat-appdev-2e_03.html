<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Code Sharing between iOS and Android</h1></div></div></div><p class="calibre8">Xamarin's tools promise to share a good portion of your code between iOS and Android while taking advantage of the native APIs on each platform where possible. Doing so is an exercise in software engineering more than a programming skill or having the knowledge of each platform. To architect a Xamarin application to enable code sharing, it is a must to separate your application into distinct layers. We'll cover the basics of this in this chapter as well as specific options to consider in certain situations.</p><p class="calibre8">In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem">The MVVM design pattern for code sharing</li><li class="listitem">Project and solution organization strategies</li><li class="listitem">Portable Class Libraries (PCLs)</li><li class="listitem">Preprocessor statements for platform-specific code</li><li class="listitem">Dependency injection (DI) simplified</li><li class="listitem">Inversion of Control (IoC)</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec23" class="calibre1"/>Learning the MVVM design pattern</h1></div></div></div><p class="calibre8">The <strong class="calibre2">Model-View-ViewModel</strong> (<strong class="calibre2">MVVM</strong>)<a id="id158" class="calibre1"/> design pattern<a id="id159" class="calibre1"/> was originally invented for <strong class="calibre2">Windows Presentation Foundation</strong> (<strong class="calibre2">WPF</strong>)<a id="id160" class="calibre1"/> applications using <strong class="calibre2">XAML</strong><a id="id161" class="calibre1"/> for separating the UI from business logic and taking full advantage of <a id="id162" class="calibre1"/><strong class="calibre2">data binding</strong>. Applications architected in this way have a distinct ViewModel layer that has no dependencies on its user interface. This architecture in itself is optimized for unit testing as well as cross-platform development. Since an application's ViewModel classes have no dependencies on the UI layer, you can easily swap an iOS user interface for an Android one and write tests against the ViewModel<strong class="calibre2"> </strong>layer. </p><p class="calibre8">The MVVM design pattern is also very similar to the MVC design pattern discussed in the previous chapters.</p><p class="calibre8">The MVVM design pattern includes the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Model</strong>: The Model<a id="id163" class="calibre1"/> layer is the backend business logic that drives the application and any business objects to go along with it. This can be anything from making web requests to a server to using a backend database.</li><li class="listitem"><strong class="calibre2">View</strong>: This<a id="id164" class="calibre1"/> layer is the actual user interface seen on the screen. In the case of cross-platform development, it includes any platform-specific code for driving the user interface of the application. On iOS, this includes controllers used throughout an application, and on Android, an application's activities.</li><li class="listitem"><strong class="calibre2">ViewModel</strong>: This <a id="id165" class="calibre1"/>layer acts as the glue in MVVM applications. The ViewModel layers<strong class="calibre2"> </strong>coordinate operations between the View and Model layers. A ViewModel layer will contain properties that the View will get or set, and functions for each operation that can be made by the user on each View. The ViewModel layer will also invoke operations on the Model layer if needed.</li></ul></div><p class="calibre8">The following figure shows you the MVVM design pattern:</p><div><img src="img/00024.jpeg" alt="Learning the MVVM design pattern" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">It is important to note that the interaction between the View and ViewModel layers is traditionally created by data binding with WPF. However, iOS and Android do not have built-in data binding mechanisms, so our general approach throughout the book will be to manually call the ViewModel layer from the View layer. There are a few frameworks out there that provide data binding functionality such as <a id="id166" class="calibre1"/><strong class="calibre2">MVVMCross</strong> (not covered in this book) and <a id="id167" class="calibre1"/><strong class="calibre2">Xamarin.Forms</strong>.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec08" class="calibre1"/>Implementing MVVM in an example</h2></div></div></div><p class="calibre8">To understand this pattern better, let's <a id="id168" class="calibre1"/>implement a common scenario. Let's say we have a search box on the screen and a search button. When the user enters some text and clicks on the button, a list of products and prices will be displayed to the user. In our example, we use the <a id="id169" class="calibre1"/><strong class="calibre2">async</strong> and <a id="id170" class="calibre1"/><strong class="calibre2">await</strong> keywords that are available in C# 5 to simplify asynchronous programming.</p><p class="calibre8">To implement this feature, we will start with a simple <code class="literal">model</code> class (also called a <strong class="calibre2">business object</strong>) as follows:</p><div><pre class="programlisting">public class Product
{
    public int Id { get; set; } //Just a numeric identifier
    public string Name { get; set; } //Name of the product
    public float Price { get; set; } //Price of the product
}</pre></div><p class="calibre8">Next, we will implement our Model layer to retrieve products based on the searched term. This is where the business logic is performed, expressing how the search needs to actually work. This is seen in the following lines of code:</p><div><pre class="programlisting">// An example class, in the real world would talk to a web
// server or database.
public class ProductRepository
{
  // a sample list of products to simulate a database
  private Product[] products = new[]
  {
    new Product { Id = 1, Name = "Shoes", Price = 19.99f },
    new Product { Id = 2, Name = "Shirt", Price = 15.99f },
    new Product { Id = 3, Name = "Hat", Price = 9.99f },
  };
  public async Task&lt;Product[]&gt; SearchProducts(string searchTerm)
  {
    // Wait 2 seconds to simulate web request
    await Task.Delay(2000);

    // Use Linq-to-objects to search, ignoring case
    searchTerm = searchTerm.ToLower();
    return products.Where(p =&gt; p.Name.ToLower().Contains(searchTerm)).ToArray();
  }
}</pre></div><p class="calibre8">It is important to note here <a id="id171" class="calibre1"/>that the <code class="literal">Product</code> and <code class="literal">ProductRepository</code> classes are both considered as a part of the Model layer of a cross-platform application. Some might consider <code class="literal">ProductRepository</code> as a<a id="id172" class="calibre1"/> <strong class="calibre2">service</strong> that is generally a self-contained class to retrieve data. It is a good idea to separate this functionality into two classes. The <code class="literal">Product</code> class's job is to hold information about a product, while the <code class="literal">ProductRepository</code> class is in charge of retrieving products. This is the basis for the <a id="id173" class="calibre1"/><strong class="calibre2">single responsibility principle</strong>, which states that each class should only have one job or concern.</p><p class="calibre8">Next, we will implement a <code class="literal">ViewModel</code> class as follows:</p><div><pre class="programlisting">public class ProductViewModel
{
  private readonly ProductRepository repository = new ProductRepository();

  public string SearchTerm
  {
    get;
    set;
  }
  public Product[] Products
  {
    get;
    private set;
  }
  public async Task Search()
  {
    if (string.IsNullOrEmpty(SearchTerm))
      Products = null;
    else
      Products = await repository.SearchProducts(SearchTerm);
  }
}</pre></div><p class="calibre8">From here, your platform-specific code starts. Each platform will handle managing an instance of a <code class="literal">ViewModel</code> class, setting the <code class="literal">SearchTerm</code> property, and calling <code class="literal">Search</code> when the button is clicked. When the task completes, the user interface layer will update a list displayed on the screen.</p><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">If you are familiar with the <a id="id174" class="calibre1"/>MVVM design pattern used with WPF, you might notice that we are not implementing <code class="literal">INotifyPropertyChanged</code> for data binding. Since iOS and Android don't have the concept of data binding, we omitted this functionality. If you plan on having a WPF or Windows 8 version of your mobile application or are using a framework that provides data binding, you should implement support for it where needed.</p></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>Comparing project organization strategies</h1></div></div></div><p class="calibre8">You might be asking <a id="id175" class="calibre1"/>yourself at this point, how do I set up my solution in Xamarin Studio to handle shared code and also have platform-specific projects? Xamarin.iOS applications can only reference Xamarin.iOS class libraries, so setting up a solution can be problematic. There are several strategies for setting up a cross-platform solution, each with its own advantages and disadvantages.</p><p class="calibre8">Options for cross-platform solutions are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">File Linking</strong>: For this <a id="id176" class="calibre1"/>option, you will start with either a <a id="id177" class="calibre1"/>plain .NET 4.0 or .NET 4.5 class library that contains all the shared code. You would then have a new project for each platform you want your app to run on. Each platform-specific project will have a subdirectory with all of the files linked in from the first class library. To set this up, add the existing files to the project and select the <strong class="calibre2">Add a link to the file</strong> option. Any unit tests can run against the original class library. The advantages and disadvantages of file linking are as follows:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">Advantages</strong>: This <a id="id178" class="calibre1"/>approach is very flexible. You can choose to link or not link certain files and can also use preprocessor directives such as <code class="literal">#if IPHONE</code>. You can also reference different libraries on Android versus iOS.</li><li class="listitem"><strong class="calibre2">Disadvantages</strong>: You have to<a id="id179" class="calibre1"/> manage a file's existence in three projects: core library, iOS, and Android. This can be a hassle if it is a large application or if many people are working on it. This option is also a bit outdated since the arrival of shared <a id="id180" class="calibre1"/>projects.</li></ul></div></li><li class="listitem"><strong class="calibre2">Cloned Project Files</strong>: This is very<a id="id181" class="calibre1"/> similar to file linking. The<a id="id182" class="calibre1"/> main difference being that you have a class library for each platform in addition to the main project. By placing the iOS and Android projects in the same directory as the main project, the files can be added without linking. You can easily add files by right-clicking on the solution and navigating to <strong class="calibre2">Display Options</strong> | <strong class="calibre2">Show All Files</strong>. Unit tests can run against the original class library or the platform-specific versions:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">Advantages</strong>: This <a id="id183" class="calibre1"/>approach is just as flexible as file linking, but you don't have to manually link any files. You can still use preprocessor directives and reference different libraries on each platform.</li><li class="listitem"><strong class="calibre2">Disadvantages</strong>: You <a id="id184" class="calibre1"/>still have to manage a file's existence in three projects. There is additionally some manual file arranging required to set this up. You also end up with an extra project to manage on each platform. This option is also a bit outdated since the arrival of shared projects.</li></ul></div></li><li class="listitem"><strong class="calibre2">Shared Projects</strong>: Starting with <a id="id185" class="calibre1"/>Visual Studio 2013 Update 2, Microsoft <a id="id186" class="calibre1"/>created the concept of shared projects to enable code sharing between Windows 8 and Windows Phone apps. Xamarin has also implemented shared projects in Xamarin Studio as another option to enable code sharing. Shared projects are virtually the same as file linking, since adding a reference to a shared project effectively adds its files to your project:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">Advantages</strong>: This<a id="id187" class="calibre1"/> approach is the same as file linking, but a lot cleaner since your shared code is in a single project. Xamarin Studio also provides a dropdown to toggle between each referencing project, so that you can see the effect of preprocessor statements in your code.</li><li class="listitem"><strong class="calibre2">Disadvantages</strong>: Since <a id="id188" class="calibre1"/>all the files in a shared project get added to each platform's main project, it can get ugly to include platform-specific code in a shared project. Preprocessor statements can quickly get out of hand if you have a large team or have team members that do not have a lot of experience. A shared project also doesn't compile to a DLL, so there is no way to<a id="id189" class="calibre1"/> share this kind of project without the source code.</li></ul></div></li><li class="listitem"><strong class="calibre2">Portable Class Libraries</strong>: This is the <a id="id190" class="calibre1"/>most optimal option; you begin the solution by making a <a id="id191" class="calibre1"/><strong class="calibre2">Portable Class Library</strong> (<strong class="calibre2">PCL</strong>) project for all your shared code. This is a special project type that allows multiple platforms to reference the same project, allowing you to use the smallest subset of C# and the .NET framework available in each platform. Each platform-specific project will reference this library directly as well as any unit test projects:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">Advantages</strong>: All your<a id="id192" class="calibre1"/> shared code is in one project, and all platforms use the same library. Since preprocessor statements aren't possible, PCL libraries generally have cleaner code. Platform-specific code is generally abstracted away by interfaces or abstract classes.</li><li class="listitem"><strong class="calibre2">Disadvantages</strong>: You are<a id="id193" class="calibre1"/> limited to a subset of .NET depending on how many platforms you are targeting. Platform-specific code requires use of <a id="id194" class="calibre1"/><strong class="calibre2">dependency injection</strong>, which can be a more advanced topic for developers not familiar with it.</li></ul></div></li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec09" class="calibre1"/>Setting up a cross-platform solution</h2></div></div></div><p class="calibre8">To understand each <a id="id195" class="calibre1"/>option completely and what different situations call for, let's define a solution structure for each cross-platform solution. Let's use the product search example used earlier in the chapter and set up a solution for each approach.</p><p class="calibre8">To set up file linking, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open Xamarin Studio and start a new solution.</li><li class="listitem" value="2">Select a new <strong class="calibre2">Library</strong> project under the general <strong class="calibre2">C#</strong> section.</li><li class="listitem" value="3">Name the project <code class="literal">ProductSearch.Core</code>, and name the solution <code class="literal">ProductSearch</code>.</li><li class="listitem" value="4">Right-click on the newly created project and select <strong class="calibre2">Options</strong>.</li><li class="listitem" value="5">Navigate to <strong class="calibre2">Build</strong> | <strong class="calibre2">General</strong>, and set the <strong class="calibre2">Target Framework</strong> option to <strong class="calibre2">.NET Framework 4.5</strong>.</li><li class="listitem" value="6">Add the <code class="literal">Product</code>, <code class="literal">ProductRepository</code>, and<strong class="calibre2"> </strong><code class="literal">ProductViewModel</code> classes to the project used earlier in the chapter. You will need to add <code class="literal">using System.Threading.Tasks;</code> and <code class="literal">using System.Linq;</code> where needed.</li><li class="listitem" value="7">Navigate to <strong class="calibre2">Build</strong> | <strong class="calibre2">Build All</strong> from the menu at the top to be sure that everything builds properly.</li><li class="listitem" value="8">Now, let's create a new iOS project by right-clicking on the solution and navigating to <strong class="calibre2">Add</strong> | <strong class="calibre2">Add New Project</strong>. Then, navigate to <strong class="calibre2">iOS</strong> | <strong class="calibre2">iPhone</strong> | <strong class="calibre2">Single View Application</strong> and name the project <code class="literal">ProductSearch.iOS</code>.</li><li class="listitem" value="9">Create a new Android project by right-clicking on the solution and navigating to <strong class="calibre2">Add</strong> | <strong class="calibre2">Add New Project</strong>. Create a new project by navigating to <strong class="calibre2">Android</strong> | <strong class="calibre2">Android Application</strong> and name it <code class="literal">ProductSearch.Droid</code>.</li><li class="listitem" value="10">Add a new folder named <code class="literal">Core</code> to both the iOS and Android projects.</li><li class="listitem" value="11">Right-click on the new folder for the iOS project and navigate to <strong class="calibre2">Add</strong> | <strong class="calibre2">Add Files from Folder</strong>. Select the root directory for the <code class="literal">ProductSearch.Core</code> project.</li><li class="listitem" value="12">Check the three <a id="id196" class="calibre1"/>C# files in the root of the project. An <strong class="calibre2">Add File to Folder</strong> dialog will appear.</li><li class="listitem" value="13">Select <strong class="calibre2">Add a link to the file</strong> and make sure that the <strong class="calibre2">Use the same action for all selected files</strong> checkbox is selected.</li><li class="listitem" value="14">Repeat this process for the Android project.</li><li class="listitem" value="15">Navigate to <strong class="calibre2">Build</strong> | <strong class="calibre2">Build All</strong> from the menu at the top to double-check everything. You have successfully set up a cross-platform solution with file linking.</li></ol><div></div><p class="calibre8">When all is done, you will have a solution tree that looks something like what you can see in the following screenshot:</p><div><img src="img/00025.jpeg" alt="Setting up a cross-platform solution" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">You should<a id="id197" class="calibre1"/> consider using this technique when you have to reference different libraries on each platform. You might consider using this option if you are using <code class="literal">MonoGame</code>, or other frameworks that require you to reference a different library on iOS versus Android.</p><p class="calibre8">Setting up a solution with the cloned project files approach is similar to file linking, except that you will have to create an additional class library for each platform. To do this, create an Android library project and an iOS library project in the same <code class="literal">ProductSearch.Core</code> directory. You will have to create the projects and move them to the proper folder manually, then re-add them to the solution. Right-click on the solution and navigate to <strong class="calibre2">Display Options</strong> | <strong class="calibre2">Show All Files</strong> to add the required C# files to these two projects. Your main iOS and Android projects can reference these projects directly.</p><p class="calibre8">Your project will<a id="id198" class="calibre1"/> look like what is shown in the following screenshot, with <code class="literal">ProductSearch.iOS</code> referencing <code class="literal">ProductSearch.Core.iOS</code> and <code class="literal">ProductSearch.Droid</code> referencing <code class="literal">ProductSearch.Core.Droid</code>:</p><div><img src="img/00026.jpeg" alt="Setting up a cross-platform solution" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>Working with Portable Class Libraries</h1></div></div></div><p class="calibre8">A <strong class="calibre2">Portable Class Library</strong> (<strong class="calibre2">PCL</strong>) is a C# <a id="id199" class="calibre1"/>library project that can be supported on multiple platforms, including iOS, Android, Windows, Windows Store apps, Windows Phone, Silverlight, and Xbox 360. PCLs have been an effort by Microsoft to simplify development across different versions of the .NET framework. Xamarin has also added support for iOS and Android for PCLs. Many popular cross-platform frameworks and open source libraries are starting to develop PCL versions such as Json.NET and MVVMCross.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec10" class="calibre1"/>Using PCLs in Xamarin</h2></div></div></div><p class="calibre8">Let's create our first portable class library:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open <a id="id200" class="calibre1"/>Xamarin <a id="id201" class="calibre1"/>Studio and start a new solution.</li><li class="listitem" value="2">Select a new <strong class="calibre2">Portable Library</strong> project under the general <strong class="calibre2">C#</strong> section.</li><li class="listitem" value="3">Name the project <code class="literal">ProductSearch.Core</code> and name the solution <code class="literal">ProductSearch</code>.</li><li class="listitem" value="4">Add the <code class="literal">Product</code>, <code class="literal">ProductRepository</code>, and <code class="literal">ProductViewModel</code> classes to the project used earlier in the chapter. You will need to add <code class="literal">using System.Threading.Tasks;</code> and <code class="literal">using System.Linq;</code> where needed.</li><li class="listitem" value="5">Navigate to <strong class="calibre2">Build</strong> | <strong class="calibre2">Build All</strong> from the menu at the top to be sure that everything builds properly.</li><li class="listitem" value="6">Now, let's create a new iOS project by right-clicking on the solution and navigating to <strong class="calibre2">Add</strong> | <strong class="calibre2">Add New Project</strong>. Create a new project by navigating to <strong class="calibre2">iOS</strong> | <strong class="calibre2">iPhone</strong> | <strong class="calibre2">Single View Application</strong> and name it <code class="literal">ProductSearch.iOS</code>.</li><li class="listitem" value="7">Create a new Android project by right-clicking on the solution and navigating to <strong class="calibre2">Add</strong> | <strong class="calibre2">Add New Project</strong>. Then, navigate to <strong class="calibre2">Android</strong> | <strong class="calibre2">Android Application</strong> and name the project <code class="literal">ProductSearch.Droid</code>.</li><li class="listitem" value="8">Simply add a reference to the portable class library from the iOS and Android projects.</li><li class="listitem" value="9">Navigate to <strong class="calibre2">Build</strong> | <strong class="calibre2">Build All</strong> from the top menu and you have successfully set up a simple solution with a portable library.</li></ol><div></div><p class="calibre8">Each solution type has its distinct advantages and disadvantages. PCLs are generally better, but there are certain cases where they can't be used. For example, if you were using a library such as <a id="id202" class="calibre1"/><code class="literal">MonoGame</code>, which is a different library for each platform, you would be much better off using a shared project or file linking. Similar issues would arise if you needed to use a preprocessor statement such as <code class="literal">#if IPHONE</code> or a native library such as the Facebook SDK on iOS or Android.</p><div><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">Setting up a shared project is almost the same as setting up a portable class library. In step 2, just select <strong class="calibre2">Shared Project</strong> under the general <strong class="calibre2">C#</strong> section and complete the remaining steps as stated.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Using preprocessor statements</h1></div></div></div><p class="calibre8">When using shared <a id="id203" class="calibre1"/>projects, file linking, or cloned project files, one of your most powerful tools is the use of preprocessor statements. If you are unfamiliar with them, C# has the ability to define preprocessor variables such as <code class="literal">#define IPHONE</code> , allowing you to use <code class="literal">#if IPHONE</code> or <code class="literal">#if !IPHONE</code>.</p><p class="calibre8">The following is a simple example of using this technique:</p><div><pre class="programlisting">#if IPHONE
  Console.WriteLine("I am running on iOS");
#elif ANDROID
  Console.WriteLine("I am running on Android");
#else
  Console.WriteLine("I am running on ???");
#endif</pre></div><p class="calibre8">In Xamarin Studio, you can define preprocessor variables in your project's options by navigating to <strong class="calibre2">Build</strong> | <strong class="calibre2">Compiler</strong> | <strong class="calibre2">Define Symbols</strong>, delimited with semicolons. These will be applied to the entire project. Be warned that you must set up these variables for each configuration setting in your solution (<strong class="calibre2">Debug</strong> and <strong class="calibre2">Release</strong>); this can be an easy step to miss. You can also define these variables at the top of any C# file by declaring <code class="literal">#define IPHONE</code>, but they will only be applied within the C# file.</p><p class="calibre8">Let's go over another example, assuming that we want to implement a class to open URLs on each platform:</p><div><pre class="programlisting">public static class Utility
{
  public static void OpenUrl(string url)
  {
    //Open the url in the native browser
  }
}</pre></div><p class="calibre8">The preceding example is a perfect candidate for using preprocessor statements, since it is very specific to each platform and is a fairly simple function. To implement the method on iOS and Android, we will need to take advantage of some native APIs. Refactor the class to look as follows:</p><div><pre class="programlisting">#if IPHONE
  //iOS using statements
  using MonoTouch.Foundation;
  using MonoTouch.UIKit;
#elif ANDROID
  //Android using statements
  using Android.App;
  using Android.Content;
  using Android.Net;
#else
  //Standard .Net using statement
  using System.Diagnostics;
#endif

public static class Utility
{
  #if ANDROID
    public static void OpenUrl(Activity activity, string url)
  #else
    public static void OpenUrl(string url)
  #endif
  {
    //Open the url in the native browser
    #if IPHONE
      UIApplication.SharedApplication.OpenUrl(NSUrl.FromString(url));
    #elif ANDROID
      var intent = new Intent(Intent.ActionView,Uri.Parse(url));
      activity.StartActivity(intent);
    #else
      Process.Start(url);
    #endif
  }
}</pre></div><p class="calibre8">The preceding class <a id="id204" class="calibre1"/>supports three different types of projects: Android, iOS, and a standard Mono or .NET framework class library. In the case of iOS, we can perform the functionality with static classes available in Apple's APIs. Android is a little more problematic and requires an <code class="literal">Activity</code> object to launch a browser natively. We get around this by modifying the input parameters on Android. Lastly, we have a plain .NET version that uses <code class="literal">Process.Start()</code> to launch a URL. It is important to note that using the third option would not work on iOS or Android natively, which necessitates our use of preprocessor statements.</p><p class="calibre8">Using preprocessor <a id="id205" class="calibre1"/>statements is not normally the cleanest or the best solution for cross-platform development. They are generally best used in a tight spot or for very simple functions. Code can easily get out of hand and can become very difficult to read with many <code class="literal">#if</code> statements, so it is always better to use it in moderation. Using inheritance or interfaces is generally a better solution when a class is mostly platform specific.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Simplifying dependency injection</h1></div></div></div><p class="calibre8">
<strong class="calibre2">Dependency injection</strong> <a id="id206" class="calibre1"/>at first seems like a complex topic, but for the most part it is a simple concept. It is a design pattern aimed at making your code within your applications more flexible so that you can swap out certain functionality when needed. The idea builds around setting up dependencies between classes in an application so that each class only interacts with an interface or base/abstract class. This gives you the freedom to override different methods on each platform when you need to fill in native functionality.</p><p class="calibre8">The concept originated from the <strong class="calibre2">SOLID</strong> object-oriented design principles, which is a set of rules you might want to research if you are interested in software architecture. There is a good article about SOLID on <a id="id207" class="calibre1"/>Wikipedia, (<a class="calibre1" href="http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29">http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29</a>) if you would like to learn more. The <strong class="calibre2">D</strong> in SOLID, which we are interested in, stands for <strong class="calibre2">dependencies</strong>. Specifically, the principle declares that a program should depend on abstractions, not <a id="id208" class="calibre1"/>concretions (concrete types).</p><p class="calibre8">To build upon this concept, let's walk you through the following example:</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's assume that we need to store a setting in an application that determines whether the sound is on or off.</li><li class="listitem" value="2">Now let's declare a simple interface for the setting: <code class="literal">interface ISettings { bool IsSoundOn { get; set; } }</code>.</li><li class="listitem" value="3">On iOS, we'd want to implement this interface using the <code class="literal">NSUserDefaults</code> class.</li><li class="listitem" value="4">Likewise, on Android, we will implement this using <code class="literal">SharedPreferences</code>.</li><li class="listitem" value="5">Finally, any class that needs to interact with this setting will only reference <code class="literal">ISettings</code> so that the implementation can be replaced on each platform.</li></ol><div></div><div><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">
<strong class="calibre2">Downloading the example code</strong>
</p><p class="calibre8">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre8">For reference, the full <a id="id209" class="calibre1"/>implementation of this example will look like the following snippet:</p><div><pre class="programlisting">public interface ISettings
{
  bool IsSoundOn
  {
    get;
    set;
  }
}
//On iOS
using MonoTouch.UIKit;
using MonoTouch.Foundation;

public class AppleSettings : ISettings
{
  public bool IsSoundOn
  {
    get
    {
      return NSUserDefaults.StandardUserDefaults
      BoolForKey("IsSoundOn");
    }
    set
    {
      var defaults = NSUserDefaults.StandardUserDefaults;
      defaults.SetBool(value, "IsSoundOn");
      defaults.Synchronize();
    }
  }
}
//On Android
using Android.Content;

public class DroidSettings : ISettings
{
  private readonly ISharedPreferences preferences;

  public DroidSettings(Context context)
  {
    preferences = context.GetSharedPreferences(context.PackageName, FileCreationMode.Private);
  }
  public bool IsSoundOn
  {
    get
    {
      return preferences.GetBoolean("IsSoundOn", true");
    }
    set
    {
      using (var editor = preferences.Edit())
      {
        editor.PutBoolean("IsSoundOn", value);
        editor.Commit();
      }
    }
  }
}</pre></div><p class="calibre8">Now you will potentially<a id="id210" class="calibre1"/> have a <code class="literal">ViewModel</code> class that will only reference <code class="literal">ISettings</code> when following the MVVM pattern. It can be seen in the following snippet:</p><div><pre class="programlisting">public class SettingsViewModel
{
  private readonly ISettings settings;

  public SettingsViewModel(ISettings settings)
  {
    this.settings = settings;
  }
  public bool IsSoundOn
  {
    get;
    set;
  }
  public void Save()
  {
    settings.IsSoundOn = IsSoundOn;
  }
}</pre></div><p class="calibre8">Using a ViewModel<a id="id211" class="calibre1"/> layer for such a simple example is not necessarily needed, but you can see it would be useful if you needed to perform other tasks such as input validation. A complete application might have a lot more settings and might need to present the user with a loading indicator. Abstracting out your setting's implementation has other benefits that add flexibility to your application. Let's say you suddenly need to replace <code class="literal">NSUserDefaults</code> on iOS with the iCloud instead; you can easily do so by implementing a new <code class="literal">ISettings</code> class and the remainder of your code will remain unchanged. This will also help you target new platforms such as Windows Phone, where you might choose to implement <code class="literal">ISettings</code> in a platform-specific way.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>Implementing Inversion of Control</h1></div></div></div><p class="calibre8">You might be asking yourself at this point in time, how do I switch out different classes such as the <code class="literal">ISettings</code> example? <strong class="calibre2">Inversion of Control</strong> (<strong class="calibre2">IoC</strong>)<a id="id212" class="calibre1"/> is a design pattern meant to complement dependency injection and solve this problem. The basic principle is that many of the objects created throughout your application are managed and created by a single class. Instead of using the standard C# constructors for your <code class="literal">ViewModel</code> or <code class="literal">Model</code> classes, a service locator or factory class will manage them throughout the application.</p><p class="calibre8">There are many different<a id="id213" class="calibre1"/> implementations and styles of IoC, so let's implement a simple service locator class to use through the remainder of this book as follows:</p><div><pre class="programlisting">public static class ServiceContainer
{
  static readonly Dictionary&lt;Type, Lazy&lt;object&gt;&gt; services = new Dictionary&lt;Type, Lazy&lt;object&gt;&gt;();

  public static void Register&lt;T&gt;(Func&lt;T&gt; function)
  {
    services[typeof(T)] = new Lazy&lt;object&gt;(() =&gt; function());
  }
  public static T Resolve&lt;T&gt;()
  {
    return (T)Resolve(typeof(T));
  }
  public static object Resolve(Type type)
  {
    Lazy&lt;object&gt; service;
    if (services.TryGetValue(type, out service)
    {
      return service.Value;
    }
    throw new Exception("Service not found!");
  }
}</pre></div><p class="calibre8">This class is inspired by <a id="id214" class="calibre1"/>the simplicity of XNA/MonoGame's <code class="literal">GameServiceContainer</code> class and follows the <strong class="calibre2">service locator</strong> pattern. The main differences are the heavy use of generics and the fact that it is a static class.</p><p class="calibre8">To use our <code class="literal">ServiceContainer</code> class, we will declare the version of <code class="literal">ISettings</code> or other interfaces that we want to use throughout our application by calling <code class="literal">Register</code>, as seen in the following lines of code:</p><div><pre class="programlisting">//iOS version of ISettings
ServiceContainer.Register&lt;ISettings&gt;(() =&gt; new AppleSettings());

//Android version of ISettings
ServiceContainer.Register&lt;ISettings&gt;(() =&gt; new DroidSettings());

//You can even register ViewModels
ServiceContainer.Register&lt;SettingsViewMode&gt;(() =&gt; new SettingsViewModel());</pre></div><p class="calibre8">On iOS, you can place <a id="id215" class="calibre1"/>this registration code in either your <code class="literal">static void Main()</code> method or in the <code class="literal">FinishedLaunching</code> method of your <code class="literal">AppDelegate</code> class. These methods are always called before the application is started.</p><p class="calibre8">On Android, it is a little more complicated. You cannot put this code in the <code class="literal">OnCreate</code> method of your activity that acts as the main launcher. In some situations, the Android OS can close your application but restart it later in another activity. This situation is likely to cause an exception somewhere. The guaranteed safe place to put this is in a custom Android <code class="literal">Application</code> class which has an <code class="literal">OnCreate</code> method that is called prior to any activities being created in your application. The following lines of code show you the use of the <code class="literal">Application</code> class:</p><div><pre class="programlisting">[Application]
public class Application : Android.App.Application
{
  //This constructor is required
  public Application(IntPtr javaReference, JniHandleOwnership transfer): base(javaReference, transfer)
  {
  }
  public override void OnCreate()
  {
    base.OnCreate();
    //IoC Registration here
  }
}</pre></div><p class="calibre8">To pull a service out of <a id="id216" class="calibre1"/>the <code class="literal">ServiceContainer</code> class, we can rewrite the constructor of the <code class="literal">SettingsViewModel</code> class so that it is similar to the following lines of code:</p><div><pre class="programlisting">public SettingsViewModel()
{
  this.settings = ServiceContainer.Resolve&lt;ISettings&gt;();
}</pre></div><p class="calibre8">Likewise, you will use the generic <code class="literal">Resolve</code> method to pull out any <code class="literal">ViewModel</code> classes you would need to call from within controllers on iOS or activities on Android. This is a great, simple way to manage dependencies within your application.</p><p class="calibre8">There are, of course, some great open source libraries out there that implement IoC for C# applications. You might consider switching to one of them if you need more advanced features for service location or just want to graduate to a more complicated IoC container.</p><p class="calibre8">Here are a <a id="id217" class="calibre1"/>few <a id="id218" class="calibre1"/>libraries that have been used with Xamarin projects:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">TinyIoC</strong>: <a class="calibre1" href="https://github.com/grumpydev/TinyIoC">https://github.com/grumpydev/TinyIoC</a></li><li class="listitem"><strong class="calibre2">Ninject</strong>: <a class="calibre1" href="http://www.ninject.org/">http://www.ninject.org/</a></li><li class="listitem"><strong class="calibre2">MvvmCross</strong>: <a class="calibre1" href="https://github.com/slodge/MvvmCross">https://github.com/slodge/MvvmCross</a> includes a <a id="id219" class="calibre1"/>full MVVM framework as<a id="id220" class="calibre1"/> well as IoC</li><li class="listitem"><strong class="calibre2">Simple</strong><a id="id221" class="calibre1"/><strong class="calibre2"> Injector</strong>: <a class="calibre1" href="http://simpleinjector.codeplex.com">http://simpleinjector.codeplex.com</a></li><li class="listitem"><strong class="calibre2">OpenNETCF.IoC</strong>: <a class="calibre1" href="http://ioc.codeplex.com">http://ioc.codeplex.com</a></li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we learned about the MVVM design pattern and how it can be used to better architect cross-platform applications. We compared several project organization strategies for managing a Xamarin Studio solution that contains both iOS and Android projects. We went over portable class libraries as the preferred option for sharing code and how to use preprocessor statements as a quick and dirty way to implement platform-specific code.</p><p class="calibre8">After completing this chapter, you should be able to speed up with several techniques for sharing code between iOS and Android applications using Xamarin Studio. Using the MVVM design pattern will help you divide your shared code and code that is platform specific. We also covered several options for setting up cross-platform Xamarin solutions. You should also have a firm understanding of using dependency injection and Inversion of Control to give your shared code access to the native APIs on each platform. In our next chapter, we will begin with writing a cross-platform application and dive into using these techniques.</p></div></body></html>