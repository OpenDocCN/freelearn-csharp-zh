- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Advanced Debugging Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级调试策略
- en: We explored unit testing and **Test-Driven Development** ( **TDD** ) in the
    last chapter, establishing a sturdy groundwork for crafting dependable code. Now,
    our focus shifts toward the realm of advanced debugging strategies within Visual
    Studio. The aim of this chapter is to equip ourselves with the requisite tools
    and methodologies to effectively tackle bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了单元测试和**测试驱动开发**（**TDD**），为构建可靠的代码奠定了坚实的基础。现在，我们的焦点转向 Visual Studio
    中的高级调试策略领域。本章的目标是让我们掌握必要的工具和方法，以有效地处理错误。
- en: 'Throughout this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mastering Visual Studio Debugger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Visual Studio 调试器
- en: Advanced breakpoints and data inspections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级断点和数据检查
- en: Elevating debugging with auto-decompilation and External Sources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自动反编译和外部资源提升调试
- en: Remote debugging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程调试
- en: Extending debugging capabilities beyond our codebase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展调试功能超出代码库
- en: Mastering remote debugging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握远程调试
- en: By the end of this chapter, we’ll be able to resolve complex bugs significantly
    faster, saving ourselves time and effort. We will also gain a deeper understanding
    of our code, leading to more robust and maintainable applications. Finally, we
    will understand how to work confidently in production environments, knowing we
    can handle unexpected issues with ease.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将能够显著更快地解决复杂错误，节省时间和精力。我们还将对代码有更深入的理解，从而构建更健壮、易于维护的应用程序。最后，我们将了解如何在生产环境中自信地工作，知道我们可以轻松处理意外问题。
- en: So, let’s set off on this journey of advanced debugging mastery together. With
    the knowledge and skills we’ll gain, we’ll be able to face any debugging challenge
    head-on, ensuring quality and performance in our code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们一起踏上高级调试大师的旅程。通过我们获得的知识和技能，我们将能够直面任何调试挑战，确保代码的质量和性能。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我使用了以下版本的 Visual Studio：
- en: Visual Studio Enterprise 2022 Version 17.12.0
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise 2022 版本 17.12.0
- en: Preview 1.0
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览 1.0
- en: Mastering Visual Studio Debugger
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 Visual Studio 调试器
- en: Debugging is the process of finding and fixing errors or bugs in the source
    code of any software. There are several steps to follow to correctly accomplish
    this task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是寻找和修复任何软件源代码中的错误或错误的过程。要正确完成这项任务，需要遵循几个步骤。
- en: The first step in debugging is defining the problem. This entails identifying
    its symptoms, comparing expected versus actual outcomes, determining its scope,
    assessing its severity and impact, and noting the steps to reproduce it. This
    clarity streamlines the troubleshooting process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的第一步是定义问题。这包括识别其症状，比较预期与实际结果，确定其范围，评估其严重性和影响，并记录重现它的步骤。这种清晰度简化了故障排除过程。
- en: Reproducing the bug is often the most effective way to pinpoint its cause. However,
    if this can’t be done, try checking the environment where it occurred, searching
    for the error message online, assessing the system’s state at the time, noting
    how often it happens, and identifying any recurring patterns. Effective debugging
    skills are crucial for improving software quality and developer productivity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重新生成错误通常是确定其原因的最有效方法。然而，如果无法这样做，请尝试检查它发生的环境，在线搜索错误消息，评估当时系统的状态，注意其发生的频率，并确定任何重复的模式。有效的调试技能对于提高软件质量和开发者生产力至关重要。
- en: Entering debug mode
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入调试模式
- en: To aid us in these debugging processes, modern **Integrated Development Environments**
    ( **IDEs** ) provide powerful debuggers. As a developer, if you have ever used
    Visual Studio, you should have already used the debugger available in Visual Studio.
    Now, let’s delve into its most valuable features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们进行这些调试过程，现代**集成开发环境**（**IDE**）提供了强大的调试器。作为一名开发者，如果你曾经使用过 Visual Studio，那么你应该已经使用过
    Visual Studio 中的调试器了。现在，让我们深入了解其最有价值的特性。
- en: I’ve set up a project to walk through using the debugger functionality to analyze
    how the code is working, I’m sure you can play with what we will see in one of
    your current projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经设置了一个项目，通过使用调试器功能来分析代码的工作方式，我相信你可以在你当前的一个项目中尝试我们将会看到的内容。
- en: 'There are two common options to launch the debugger:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 启动调试器有两种常见选项：
- en: Launch the entire solution in debug mode
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以调试模式启动整个解决方案
- en: '![Figure 2.1 – Debug mode](img/B22218_02_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 调试模式](img/B22218_02_1.jpg)'
- en: Figure 2.1 – Debug mode
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 调试模式
- en: Debug unit test for the debug-specific public method
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试特定公共方法的单元测试
- en: '![Figure 2.2 – Debugging a unit test](img/B22218_02_2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 单元测试调试](img/B22218_02_2.jpg)'
- en: Figure 2.2 – Debugging a unit test
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 单元测试调试
- en: The second option could be a good choice to save compile time in our development
    process. Regardless of our choice, the first thing to do is set a breakpoint by
    left-clicking on the left side of our source file to navigate through the code.
    We will discuss the details of breakpoints later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项可能是我们在开发过程中节省编译时间的良好选择。无论我们的选择如何，首先要做的事情是通过在源文件左侧单击来设置断点以导航代码。我们将在本章后面讨论断点的详细信息。
- en: Simply put, a breakpoint is an intentional stopping or pausing place in a program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，断点是在程序中故意停止或暂停的位置。
- en: 'As we set the breakpoint and launch the debugger ( *F5* ), we can observe the
    behavior of the method. Here’s a reminder of the three main options to navigate
    on our codebase:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置断点并启动调试器（*F5*）时，我们可以观察方法的行为。以下是我们代码库中导航的三个主要选项的提醒：
- en: '**Step Into** ( *F11* ): This command steps into the code, meaning it goes
    into the method or function that is being called on the current line. If there
    are nested calls, it steps into the most deeply nested one.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步入**（*F11*）：此命令步入代码，意味着它进入当前行上被调用的方法或函数。如果有嵌套调用，它将进入最深层嵌套的调用。'
- en: '**Step Over** ( *F10* ): This command steps over the current line of code,
    which means it executes the current line and then stops at the next line in the
    current method or function. It does not step into any methods or functions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步过**（*F10*）：此命令步过当前代码行，这意味着它执行当前行，然后停止在当前方法或函数的下一行。它不会进入任何方法或函数。'
- en: '**Step Out** ( *Shift* + *F11* ): This command steps out of the current method
    or function, which means that it will execute the rest of the method and then
    stop at the next line after the method cal l.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步出**（*Shift* + *F11*）：此命令从当前方法或函数中退出，这意味着它将执行方法或函数的其余部分，然后停止在方法调用之后的下一行。'
- en: In debug mode, Visual Studio 2022 provides several ways that help us navigate
    through our code application during debugging sessions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下，Visual Studio 2022 提供了多种方式，帮助我们能够在调试会话期间导航我们的代码应用程序。
- en: Advanced debug navigation
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级调试导航
- en: Visual Studio 2022 allows us to play with the debugger cursor to explore different
    areas of our codebase, with two features, described as follows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 允许我们通过调试器光标来探索代码库的不同区域，以下列出了两个功能：
- en: Run To Cursor (Ctrl + F10)
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行到光标（Ctrl + F10）
- en: The **Run To Cursor** feature allows us to quickly navigate to a specific location
    in our code and execute the code up to that point. To use **Run To Cursor** ,
    we simply place the cursor on the line of code where we want execution to stop,
    then right-click and select **Run To Cursor** from the context menu. Alternatively,
    we can use the keyboard shortcut *Ctrl* + *F10* .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行到光标处**功能允许我们快速导航到代码中的特定位置，并执行到该点为止的代码。要使用**运行到光标处**，我们只需将光标放在我们希望执行停止的代码行上，然后右键单击并从上下文菜单中选择**运行到光标处**。或者，我们可以使用键盘快捷键*Ctrl*
    + *F10*。'
- en: '![Figure 2.3 – Run to Cursor](img/B22218_02_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 运行到光标](img/B22218_02_3.jpg)'
- en: Figure 2.3 – Run to Cursor
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 运行到光标
- en: It’s important to note that the line of code where we place the cursor must
    be reachable, meaning it should be part of the code that gets executed when the
    application runs. If the line is unreachable, the **Run To Cursor** command will
    not work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们放置光标的代码行必须是可到达的，这意味着它应该是应用程序运行时执行的代码的一部分。如果该行不可到达，**运行到光标处**命令将不起作用。
- en: This command will run the code until it reaches the cursor’s position, but if
    there’s a breakpoint set at a location before the cursor, the debugger will stop
    at that breakpoint.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行代码，直到达到光标的位置，但如果在光标之前设置了断点，调试器将停止在该断点处。
- en: If we want to directly reach a line of code with the debugger, since Visual
    Studio 2022, we have been able to use the **Force and Run to** **Click** feature.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过调试器直接到达一行代码，自 Visual Studio 2022 以来，我们已经能够使用**强制运行到** **点击**功能。
- en: Force And Run to Click
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制运行到点击
- en: The **Force Run to Click** feature, available from Visual Studio 2022 onward,
    is a powerful tool that allows us to skip over breakpoints and any first-chance
    exceptions that occur during the execution of our code. This is particularly useful
    when we want to test updated code or focus on a specific area of our program without
    being interrupted by breakpoints.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio 2022 开始提供的**强制运行到点击**功能是一个强大的工具，允许我们在代码执行过程中跳过断点以及任何首次机会异常。当我们想要测试更新后的代码或专注于程序中的特定区域而不受断点的干扰时，这特别有用。
- en: To use the **Force Run to Click** feature, we need to be in a paused state in
    the debugger. While the debugger is paused, we can hover over a statement in the
    source code, press the *Shift* key, and then select **Run execution to here**
    (represented by a green arrow icon).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**强制运行到点击**功能，我们需要在调试器中处于暂停状态。当调试器暂停时，我们可以在源代码中悬停在一个语句上，按住*Shift*键，然后选择**运行执行到此处**（由绿色箭头图标表示）。
- en: '![Figure 2.4 – Run execution to here](img/B22218_02_4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 运行执行到此处](img/B22218_02_4.jpg)'
- en: Figure 2.4 – Run execution to here
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 运行执行到此处
- en: When we choose this option, the application will continue to run until it reaches
    the cursor location, and any breakpoints and first-chance exceptions that occur
    during this process will be temporarily disabled.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择此选项时，应用程序将继续运行，直到达到光标位置，在此过程中发生的任何断点和首次机会异常都将暂时禁用。
- en: This feature is especially convenient when we have multiple breakpoints set
    in our application and we want to skip them all to quickly reach a specific point
    in our code for testing or debugging purposes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中设置了多个断点并希望快速跳过它们以测试或调试代码中的特定点时，此功能特别方便。
- en: Now that we’ve navigated through our codebase using the debugger, we need to
    understand what’s happening at each step. Visual Studio provides several tools
    to help us examine the state of our application during debugging sessions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用调试器导航了代码库，我们需要了解每个步骤发生的情况。Visual Studio 提供了几个工具来帮助我们检查调试会话期间应用程序的状态。
- en: Understanding debugger tools
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解调试工具
- en: The Visual Studio debugger offers several windows, some more recent than others,
    to explore our variables and objects. Let’s explore these windows in detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 调试器提供了一些窗口，有些比其他窗口更新，用于探索我们的变量和对象。让我们详细探讨这些窗口。
- en: Autos window
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动窗口
- en: The **Autos** window displays variables and expressions that are automatically
    evaluated by the debugger. It shows the values of local variables and expressions
    that are currently in scope. The **Autos** window is useful when we have many
    variables and we don’t want to clutter the **Locals** window with all of them.
    It evaluates only the most relevant variables based on our current execution context.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动窗口**显示由调试器自动评估的变量和表达式。它显示了当前作用域内局部变量和表达式的值。当拥有许多变量且不想将所有变量都添加到**本地变量**窗口中时，**自动窗口**非常有用。它仅根据我们当前的执行上下文评估最相关的变量。'
- en: '![Figure 2.5 – The Autos window](img/B22218_02_5.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 自动窗口](img/B22218_02_5.jpg)'
- en: Figure 2.5 – The Autos window
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 自动窗口
- en: In this example, we have a **int apple.Id = 1;** variable and the **apple**
    and **stockManager** objects in use; the **Autos** window might show just them
    along with their values, rather than showing every single variable in the current
    scope.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有一个**int apple.Id = 1;**变量以及正在使用的**apple**和**stockManager**对象；**自动窗口**可能只显示它们及其值，而不是显示当前作用域中的每个变量。
- en: Next, let’s take a look at the **Locals** window.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下**本地变量**窗口。
- en: Locals window
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地变量窗口
- en: The **Locals** window shows all local variables in the current scope. Unlike
    the **Autos** window, which only shows a subset of variables, the **Locals** window
    lists all local variables regardless of their relevance. This can be helpful when
    we need to see the exact state of all local variables at a particular breakpoint.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地变量**窗口显示了当前作用域中的所有局部变量。与仅显示变量子集的**自动窗口**不同，**本地变量**窗口列出了所有局部变量，无论其相关性如何。当我们需要查看特定断点处所有局部变量的确切状态时，这可能很有帮助。'
- en: '![Figure 2.6 – The Locals window](img/B22218_02_6.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 本地变量窗口](img/B22218_02_6.jpg)'
- en: Figure 2.6 – The Locals window
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 本地变量窗口
- en: Here, the **Locals** window allows you to see the value of each variable at
    the time the code execution is paused.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**本地变量**窗口允许你在代码执行暂停时查看每个变量的值。
- en: Next, we’ll look at the **Watch** window.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看**监视**窗口。
- en: Watch window
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监视窗口
- en: We use the **Watch** window to monitor specific variables or expressions. We
    can manually add variables or expressions to the **Watch** window, and the debugger
    will evaluate them whenever the execution is paused. This is particularly useful
    when we want to keep track of the changes in the value of a variable over time
    or when we want to evaluate complex expressions that involve multiple variables.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **观察** 窗口来监视特定的变量或表达式。我们可以手动将变量或表达式添加到 **观察** 窗口中，并且当执行暂停时，调试器将评估它们。这在我们需要跟踪变量值随时间的变化或我们需要评估涉及多个变量的复杂表达式时特别有用。
- en: To add an expression to the **Watch** window, right-click on the code and select
    **Add Watch** . We can also type directly or code in the **Watch** window.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要将表达式添加到 **观察** 窗口中，右键单击代码并选择 **添加观察**。我们也可以直接在 **观察** 窗口中键入或编写代码。
- en: '![Figure 2.7 – The Watch window](img/B22218_02_7.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 观察窗口](img/B22218_02_7.jpg)'
- en: Figure 2.7 – The Watch window
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 观察窗口
- en: The **Watch** window can also be used to modify the value of a variable during
    debugging, which can be helpful for testing different scenarios.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察** 窗口还可以在调试过程中修改变量的值，这有助于测试不同的场景。'
- en: Call Stack window
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用栈窗口
- en: Now, if we enter the **UpdateProduct()** method, we can follow the sequence
    in the **Call** **Stack** window.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们进入 **UpdateProduct()** 方法，我们可以在 **调用** **栈** 窗口中跟踪序列。
- en: '![Figure 2.8 – The Call Stack window](img/B22218_02_8.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 调用栈窗口](img/B22218_02_8.jpg)'
- en: Figure 2.8 – The Call Stack window
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 调用栈窗口
- en: The **Call Stack** window in Visual Studio is a critical tool for debugging
    as it allows us to view the sequence of function or method calls that led to the
    current point of execution in our program. This window is essential for understanding
    the flow of execution and for diagnosing issues within our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中的 **调用栈** 窗口是调试的关键工具，因为它允许我们查看导致程序当前执行点的函数或方法调用序列。此窗口对于理解执行流程和诊断代码中的问题至关重要。
- en: 'Here are some key functionalities of the **Call Stack** window in Visual Studio:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Visual Studio 中 **调用栈** 窗口的一些关键功能：
- en: '**Viewing Call Stack** : We can see the sequence of method and function calls
    that led to the current point of execution in our program.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看调用栈**：我们可以看到导致程序当前执行点的函数和方法调用序列。'
- en: '**Switching stack frames** : We can switch to a different stack frame by right-clicking
    a frame in the **Call Stack** window and selecting **Switch to Frame** , or by
    double-clicking the frame. This allows us to inspect the code and data within
    that frame.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换堆栈帧**：我们可以通过在 **调用栈** 窗口中右键单击一个帧并选择 **切换到帧**，或者通过双击帧来切换到不同的堆栈帧。这允许我们检查该帧中的代码和数据。'
- en: '**Disassembly code view** : To view the disassembly code for a function on
    the call stack, simply right-click the function and select **Go** **To Disassembly**
    .'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反汇编代码视图**：要查看调用栈上函数的反汇编代码，只需右键单击该函数并选择**转到** **反汇编**。'
- en: '**Loading Symbols** : The **Call Stack** window in Visual Studio has the capability
    to load debugging symbols for code that currently lacks them. These symbols may
    include .NET or system symbols obtained from Microsoft’s public symbol servers,
    or symbols located within a symbol path on our computer.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载符号**：Visual Studio 中的 **调用栈** 窗口具有为当前缺少符号的代码加载调试符号的能力。这些符号可能包括从微软的公共符号服务器获取的
    .NET 或系统符号，或者位于我们计算机上的符号路径中的符号。'
- en: '**Code map integration** : Visual Studio Enterprise provides the functionality
    to visually map the call stack during debugging. This feature enables us to observe
    the current call stack in a graphical format on a new code map, which updates
    automatically as debugging progresses. This visual representation facilitates
    a more intuitive understanding of the structure and flow of our code, aiding in
    the identification of potential issues or areas for optimization. Please note
    that adding the **CodeMap** extension to Visual Studio is necessary to utilize
    this feature.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码映射集成**：Visual Studio Enterprise 提供了在调试过程中可视映射调用栈的功能。此功能使我们能够在新的代码映射中以图形格式观察当前的调用栈，该映射会随着调试的进行自动更新。这种视觉表示有助于更直观地理解我们代码的结构和流程，有助于识别潜在问题或优化区域。请注意，要将
    **CodeMap** 扩展添加到 Visual Studio 中才能使用此功能。'
- en: Finally, let us look at the **Immediate** Window.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 **立即** 窗口。
- en: Immediate window
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 立即窗口
- en: The **Immediate** window in Visual Studio is an old, little-known debugging
    tool that allows us to execute code, evaluate expressions, and print variable
    values on the fly during a debugging session.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中的**立即**窗口是一个古老且鲜为人知的调试工具，它允许我们在调试会话期间即时执行代码、评估表达式和打印变量值。
- en: '![Figure 2.9 – The Immediate window](img/B22218_02_9.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 立即窗口](img/B22218_02_9.jpg)'
- en: Figure 2.9 – The Immediate window
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 立即窗口
- en: It is designed to help with dynamic code evaluation and the quick testing of
    code snippets without having to stop the execution of the application. To use
    the **Immediate** window, open it by going to the **Debug** menu, selecting **Windows**
    , and then choosing the **Immediate** window, or by pressing *Ctrl* + *Alt* +
    *I* . This window is particularly useful when debugging an application, as it
    allows us to check the value of variables, call functions, and execute statements
    without stepping through the code line by line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它旨在帮助进行动态代码评估和快速测试代码片段，而无需停止应用程序的执行。要使用**立即**窗口，可以通过转到**调试**菜单，选择**窗口**，然后选择**立即**窗口，或者按*Ctrl*
    + *Alt* + *I*来打开它。此窗口在调试应用程序时特别有用，因为它允许我们检查变量的值，调用函数，并执行语句，而无需逐行通过代码。
- en: 'Here are some valuable tricks for using the **Immediate** window effectively
    during debugging:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试期间有效地使用**立即**窗口的一些宝贵技巧：
- en: '**Debugging methods from the Immediate window** : We can place breakpoints
    in methods and call them from the **Immediate** window to debug them, even if
    we’ve already passed that point in the code. Note that we can use the **Run to
    a cursor location** ( *Ctrl* + *Shift* + *F10* ) feature to return to any line
    of code in the same scope and step into methods with *F11* to debug as usual.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即窗口的调试方法**：我们可以在方法中设置断点，并从**立即**窗口中调用它们以进行调试，即使我们已经通过了代码中的该点。请注意，我们可以使用**运行到光标位置**（*Ctrl*
    + *Shift* + *F10*）功能返回到同一作用域中的任何代码行，并使用*F11*进入方法以进行常规调试。'
- en: '**Bypassing access rules** : The **Immediate** window does not enforce class
    accessibility rules, allowing us to call private, protected, and internal members
    that would not be accessible in regular code. However, IntelliSense (the built-in
    autocompletion tool) will still show only the public methods.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绕过访问规则**：**立即**窗口不强制执行类访问规则，允许我们调用在常规代码中不可访问的私有、受保护和内部成员。然而，IntelliSense（内置的自动完成工具）仍然只会显示公共方法。'
- en: '**Evaluating expressions without side effects** : Evaluating expressions in
    the **Immediate** window can change variable values and call methods, potentially
    causing side effects. To avoid this, append **No Side Effects** ( **nse** ) to
    an expression, which will evaluate it without altering the application state.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估无副作用的表达式**：在**立即**窗口中评估表达式可能会更改变量值并调用方法，这可能会引起副作用。为了避免这种情况，将**无副作用**（**nse**）附加到表达式，这将评估它而不会更改应用程序状态。'
- en: '**Accessing special debugging variables** : The **Immediate** window can display
    values of special debugging variables such as **$exception** (the currently thrown
    exception), **$returnvalue** (the return value of the currently returned method),
    and **$user** (the current OS user and process information).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问特殊调试变量**：**立即**窗口可以显示特殊调试变量的值，例如**$exception**（当前抛出的异常）、**$returnvalue**（当前返回方法的返回值）和**$user**（当前操作系统用户和进程信息）。'
- en: '**Evaluating Make Object ID** : When debugging, you can **Make Object ID**
    for a variable in **DataTip** , which creates a unique identifier for the object.
    This identifier can be evaluated in the **Immediate** window at any time to see
    changes in the object’s value or existence in memory.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估 Make Object ID**：在调试时，您可以在**数据提示**中为变量**Make Object ID**，这为对象创建一个唯一的标识符。此标识符可以在任何时间在**立即**窗口中评估，以查看对象值或存在状态的变化。'
- en: Identifying bugs is an essential step in our debugging process, but the goal
    is to fix them. Let’s explore how we can enhance productivity by fixing them on
    the fly with Visual Studio.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 识别错误是我们调试过程中的一个基本步骤，但目标是修复它们。让我们探讨如何通过使用 Visual Studio 在线修复它们来提高生产力。
- en: Fixing bugs on the fly
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时修复错误
- en: To enhance our productivity during debugging and avoid the need to stop and
    start the debugger to fix a bug, Visual Studio 2022 allows us to do so on the
    fly with the following features.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在调试期间提高我们的生产力并避免停止和启动调试器来修复错误的需要，Visual Studio 2022 允许我们使用以下功能即时进行。
- en: Edit and Continue
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑并继续
- en: '**Edit and Continue** is a feature that allows you to modify your source code
    while your application is in break mode. When you apply the changes, Visual Studio
    attempts to recompile the modified code and apply those changes to the running
    application. This means that you can fix bugs, add features, or experiment with
    code changes without interrupting the flow of your debugging session.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑并继续**是一种功能，允许您在应用程序处于断点模式时修改源代码。当您应用更改时，Visual Studio会尝试重新编译修改后的代码并将这些更改应用到正在运行的应用程序中。这意味着您可以在不中断调试会话流程的情况下修复错误、添加功能或对代码更改进行实验。'
- en: 'Here’s how it works:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: We start debugging your application.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始调试您的应用程序。
- en: We hit a breakpoint and pause the execution.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们触发了断点并暂停了执行。
- en: While paused, we can edit the code in the editor.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在暂停时，我们可以在编辑器中编辑代码。
- en: After editing, we can choose to continue execution with the new changes applied.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑完成后，我们可以选择继续执行并应用新更改。
- en: We can even move the yellow execution pointer back to change the execution flow
    and execute our edited code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将黄色的执行指针移动回去以改变执行流程并执行我们的编辑代码。
- en: This feature is particularly useful when we find a bug during a debugging session,
    and we immediately know how to fix it. Instead of stopping the debugger, making
    the change, and then restarting the app, you can simply edit the code and continue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在调试会话期间发现错误时，这个功能尤其有用，我们可以立即知道如何修复它。无需停止调试器、进行更改然后重新启动应用程序，您只需编辑代码并继续即可。
- en: Hot Reload
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 热重载
- en: '**Hot Reload** is a newer feature introduced in **.NET 6** and supported in
    Visual Studio 2022. It allows us to make changes to our code while our application
    is running, and those changes are reflected in the running application almost
    instantly. This is like Edit and Continue, but with a few key differences:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**热重载**是**.NET 6**中引入的新功能，并在Visual Studio 2022中得到支持。它允许我们在应用程序运行时更改代码，并且这些更改几乎会立即反映在运行的应用程序中。这就像编辑并继续，但有一些关键的区别：'
- en: Hot Reload supports UI updates, whereas Edit and Continue does not. If we change
    the layout or appearance of our UI, Hot Reload will update the running app to
    reflect those changes.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热重载支持UI更新，而编辑并继续则不支持。如果我们更改了UI的布局或外观，热重载将更新正在运行的应用程序以反映这些更改。
- en: Hot Reload is designed to work with .NET applications, including ASP.NET Core
    web apps and Blazor WebAssembly apps.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热重载旨在与.NET应用程序一起使用，包括ASP.NET Core Web应用程序和Blazor WebAssembly应用程序。
- en: Hot Reload requires a bit more setup compared to Edit and Continue. We need
    to enable it in our project settings and ensure that our app is compatible with
    the feature. We will delve deeper into it in the next chapter.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与编辑并继续相比，热重载需要更多的设置。我们需要在项目设置中启用它，并确保我们的应用程序与该功能兼容。我们将在下一章中更深入地探讨它。
- en: With Hot Reload, we can see the effects of our changes immediately, which can
    speed up the development process, especially when working on UI or front-end code.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用热重载，我们可以立即看到我们的更改效果，这可以加快开发过程，尤其是在处理UI或前端代码时。
- en: Both Edit and Continue and Hot Reload are powerful tools that can save time
    and reduce the frustration associated with stopping and restarting our application
    during the debugging process. They allow us to maintain a smooth workflow and
    quickly iterate on our code, which can lead to more efficient problem-solving
    and faster development cycles.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑并继续和热重载都是强大的工具，可以节省时间并减少在调试过程中停止和重新启动应用程序的挫败感。它们允许我们保持流畅的工作流程，并快速迭代代码，这可能导致更有效的解决问题和更快的开发周期。
- en: 'Now that we’ve conquered the art of navigating the debugger, taken an overview
    of their windows, and performed live fixes, let’s delve deeper into two powerful
    tools that elevate your debugging game: advanced breakpoints and data inspection.
    While we’ve already touched upon them, consider this a deep dive, equipping you
    to wield them with precision and unlock invaluable insights into your code’s behavior.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了导航调试器的技巧，对它们的窗口进行了概述，并执行了实时修复，让我们更深入地探讨两个提升调试能力的强大工具：高级断点和数据检查。虽然我们已经提到了它们，但请将此视为一次深入探讨，以便您能够精确地使用它们，并从代码行为中获得宝贵的见解。
- en: Advanced breakpoints and data inspections
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级断点和数据检查
- en: Advanced breakpoints in Visual Studio 2022 are powerful tools that allow us
    to inspect and control the execution flow of their programs during debugging sessions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022中的高级断点是强大的工具，允许我们在调试会话期间检查和控制程序的执行流程。
- en: Understanding the types of breakpoints
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解断点的类型
- en: Breakpoints in Visual Studio can be divided into several types. Those are as
    follows.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的断点可以分为几种类型。具体如下。
- en: Conditional breakpoints
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件断点
- en: We can control when a breakpoint executes by setting conditions. That feature
    has been available since Visual Studio 2005. We can right-click the breakpoint
    symbol and select **Conditions** , or right-click in the margin next to a line
    of code and select **Insert Conditional Breakpoint** from the context menu. In
    the **Breakpoint Settings** window, select **Conditional Expression** , **Hit
    Count** , or **Filter** , and set the conditional expression in the text box accordingly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置条件来控制断点的执行时机。这个功能自Visual Studio 2005以来就可用。我们可以右键单击断点符号并选择**条件**，或者右键单击代码旁边的空白处并从上下文菜单中选择**插入条件断点**。在**断点设置**窗口中，选择**条件表达式**、**命中次数**或**过滤器**，并在文本框中相应地设置条件表达式。
- en: '![Figure 2.10 – Conditional breakpoint](img/B22218_02_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 条件断点](img/B22218_02_10.jpg)'
- en: Figure 2.10 – Conditional breakpoint
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 条件断点
- en: In this example, with our setup, the debugger will stop if **newQuantiy** is
    not equal to **product.QuantityStock**
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，根据我们的设置，如果**newQuantiy**不等于**product.QuantityStock**，调试器将停止。
- en: Tracepoints
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tracepoints
- en: Introduced with Visual Studio 2005, a **tracepoint** serves as a breakpoint
    variant enabling users to log information to the **Output** window based on customizable
    conditions as conditional breakpoints without altering or pausing the code execution.
    Tracepoints are compatible with managed languages such as C#, Visual Basic, F#,
    and native code, as well as languages such as JavaScript and Python
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自Visual Studio 2005引入以来，**tracepoint**作为一种断点变体，允许用户根据可定制的条件将信息记录到**输出**窗口，就像条件断点一样，而不会改变或暂停代码执行。Tracepoints与C#、Visual
    Basic、F#等托管语言以及JavaScript和Python等语言兼容。
- en: To set a tracepoint, simply click on the gutter located to the left of the desired
    line number. Hover over the ensuing red circle and click on the gear icon to unveil
    the **Breakpoint Settings** window. Proceed by selecting the **Action** checkbox.
    This action will transform the red circle into a diamond shape, signifying the
    transition from a traditional breakpoint to a tracepoint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置tracepoint，只需单击位于所需行号左侧的空白处。将鼠标悬停在随后出现的红色圆圈上，然后单击齿轮图标以打开**断点设置**窗口。通过选择**操作**复选框来继续。此操作将红色圆圈转换为菱形，表示从传统断点转换为tracepoint。
- en: '![Figure 2.11 – Tracepoint](img/B22218_02_11.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – Tracepoint](img/B22218_02_11.jpg)'
- en: Figure 2.11 – Tracepoint
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – Tracepoint
- en: 'Enter the message we want to log into the **Show a message in the Output Window**
    text box. If we want to add conditions that determine whether our message is displayed,
    we could select the **Conditions** checkbox. As for conditional breakpoints, we
    have three choices for conditions: **Conditional Expression** , **Filter** , and
    **Hit Count** . Tracepoints are useful for debugging because they allow us to
    log information without cluttering our code with print statements or functions
    such as **Debug.WriteLine()** .'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们想要记录的消息输入到**在输出窗口中显示消息**文本框中。如果我们想添加决定我们的消息是否显示的条件，我们可以选择**条件**复选框。至于条件断点，我们有三种条件选择：**条件表达式**、**过滤器**和**命中次数**。Tracepoints对于调试很有用，因为它们允许我们记录信息，而不会在代码中添加打印语句或如**Debug.WriteLine()**之类的函数，从而不会使代码变得杂乱。
- en: Data breakpoints
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据断点
- en: Data breakpoints allow us, as developers, to pause execution when the value
    of a specific object’s property changes. This feature is particularly useful for
    debugging scenarios where we want to monitor changes to data without having to
    manually step through code. Data breakpoints can be set for **.NET Core 3.x**
    or **.NET 5+** projects, and they are particularly useful for tracking changes
    in object properties.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数据断点允许我们作为开发者，在特定对象的属性值改变时暂停执行。这个特性在需要监控数据变化而不必手动逐行通过代码的调试场景中特别有用。数据断点可以为**.NET
    Core 3.x**或**.NET 5+**项目设置，并且对于跟踪对象属性的变化特别有用。
- en: To set a data breakpoint in a .NET Core or .NET 5+ project, we start debugging
    and wait until a breakpoint is reached. Then, in the **Autos** , **Watch** , or
    **Locals** window, we right-click a property and select **Break when value changes**
    from the context menu.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要在.NET Core或.NET 5+项目中设置数据断点，我们开始调试并等待直到达到断点。然后，在**自动**、**监视**或**局部变量**窗口中，我们右键单击一个属性并从上下文菜单中选择**当值改变时中断**。
- en: '![Figure 2.12 – Break When Value Changes](img/B22218_02_12.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 当值改变时中断](img/B22218_02_12.jpg)'
- en: Figure 2.12 – Break When Value Changes
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 当值改变时中断
- en: This will set a data breakpoint that triggers when the selected property’s value
    changes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个数据断点，当所选属性的值发生变化时触发。
- en: Data breakpoints are subject to hardware and kernel limitations. The Windows
    kernel and the underlying hardware impose a maximum number of data breakpoints
    that can be set simultaneously. These limitations ensure that our debugging experience
    remains efficient and responsive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据断点受硬件和内核限制。Windows 内核和底层硬件对可以同时设置的数据断点数量有限制。这些限制确保我们的调试体验保持高效和响应。
- en: It’s important to note that data breakpoints depend on specific memory addresses,
    and that the address of a variable can change from one debugging session to the
    next. Therefore, data breakpoints are automatically disabled at the end of each
    debugging session. If we set a data breakpoint on a local variable, the breakpoint
    remains enabled when the function ends, but the memory address is no longer applicable,
    leading to unpredictable behavior. It’s recommended to delete or disable such
    breakpoints before the function ends to avoid confusion.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，数据断点依赖于特定的内存地址，并且变量的地址可能会从一个调试会话变化到下一个调试会话。因此，数据断点在每个调试会话结束时自动禁用。如果我们对一个局部变量设置了数据断点，当函数结束时，断点仍然启用，但内存地址不再适用，这可能导致不可预测的行为。建议在函数结束时删除或禁用此类断点，以避免混淆。
- en: The introduction of data breakpoints for .NET Core in Visual Studio 2019 marked
    the start of this feature, making it a valuable tool for us when working with
    .NET Core 3.x or . NET 5+.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2019 中为 .NET Core 引入的数据断点标志着这一功能的开始，这使得它在我们使用 .NET Core 3.x 或
    .NET 5+ 时成为一个有价值的工具。
- en: Function breakpoints
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数断点
- en: Since Visual Studio 2012, we have been able to set breakpoints on functions,
    which is useful when we know the function name but not its location, or when we
    have overloaded functions. To set a function breakpoint, select **Debug** | **New
    Breakpoint** | **Function Breakpoint** , or press *Ctrl* + *K* , then *B* .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Visual Studio 2012 以来，我们能够在函数上设置断点，这在我们知道函数名但不知道其位置，或者有重载函数时很有用。要设置函数断点，请选择**调试**
    | **新建断点** | **函数断点**，或者按*Ctrl* + *K*，然后*B*。
- en: '![Figure 2.13 – Function breakpoints](img/B22218_02_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 函数断点](img/B22218_02_13.jpg)'
- en: Figure 2.13 – Function breakpoints
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 函数断点
- en: Enter the fully qualified function name, including parameter types for overloaded
    functions, or use the *!* symbol to specify the module. Here, we set a breakpoint
    to the **SearchProducts** method of the **StockManager** class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输入完全限定的函数名，包括重载函数的参数类型，或使用*!*符号指定模块。在这里，我们为**StockManager**类的**SearchProducts**方法设置了一个断点。
- en: Dependant breakpoints
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖断点
- en: Visual Studio 2022 introduced us to the possibility of setting up a dependent
    breakpoint, which is a powerful debugging feature that allows us to pause the
    execution of our program only when another specific breakpoint has been hit first.
    This is particularly useful in complex debugging scenarios, such as when we are
    working with multi-threaded applications or when we want to focus on debugging
    code in specific parts of our application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 介绍了设置依赖断点的可能性，这是一个强大的调试功能，它允许我们仅在另一个特定的断点首先被触发时暂停程序的执行。这在复杂的调试场景中特别有用，例如当我们处理多线程应用程序或当我们想专注于调试应用程序特定部分的代码时。
- en: To set up a dependent breakpoint, we first need to identify the breakpoint that
    our current breakpoint will depend on. Then, we hover over the breakpoint symbol,
    choose the settings icon, and select **Only enable when the following breakpoint
    is hit** in the **Breakpoint** **Settings** window.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置依赖断点，我们首先需要确定当前断点将依赖的断点。然后，我们将鼠标悬停在断点符号上，选择设置图标，并在**断点设置**窗口中选择**仅当以下断点被触及时启用**。
- en: '![Figure 2.14 – The Only enable when the following breakpoint is hit checkbox](img/B22218_02_14.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 仅当以下断点被触及时启用复选框](img/B22218_02_14.jpg)'
- en: Figure 2.14 – The Only enable when the following breakpoint is hit checkbox
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 仅当以下断点被触及时启用复选框
- en: From the dropdown, we select the prerequisite breakpoint that we want our current
    breakpoint to be dependent on. After setting this up, we can close the dialog.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从下拉菜单中，我们选择我们希望当前断点依赖的先决断点。设置完成后，我们可以关闭对话框。
- en: Another way to set a dependent breakpoint is by using the right-click context
    menu. We right-click in the far-left margin next to a line of code and select
    **Insert Dependent Breakpoint** from the context menu.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设置依赖断点的方法是使用右键单击上下文菜单。我们在代码左侧的空白处右键单击，并从上下文菜单中选择**插入依赖断点**。
- en: '![Figure 2.15 – Insert Dependent Breakpoint](img/B22218_02_15.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 插入依赖断点](img/B22218_02_15.jpg)'
- en: Figure 2.15 – Insert Dependent Breakpoint
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 插入依赖断点
- en: It’s important to note that dependent breakpoints do not work if there is only
    a single breakpoint in our application. If the prerequisite breakpoint is deleted,
    the dependent breakpoint will be converted to a normal line breakpoint.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果我们的应用程序中只有一个断点，依赖断点将不起作用。如果先决断点被删除，依赖断点将被转换为普通行断点。
- en: This feature is designed to streamline our debugging process by allowing us
    to focus on specific parts of our code that are relevant to the debugging task
    at hand, thereby potentially saving time and effort during the debugging process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能旨在通过允许我们专注于与当前调试任务相关的代码特定部分来简化我们的调试过程，从而在调试过程中可能节省时间和精力。
- en: Temporary breakpoints
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时断点
- en: Temporary breakpoints in Visual Studio 2022 are a powerful debugging feature
    that allows us, as developers, to pause the execution of our code only once at
    a specific location. Once the breakpoint is hit during our debugging session,
    it automatically disables itself, making it ideal for scenarios wherein we want
    to inspect a specific condition or behavior without repeatedly hitting the same
    breakpoint.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 中的临时断点是一个强大的调试功能，它允许我们作为开发者，在特定位置暂停代码的执行仅一次。一旦在调试会话中命中断点，它将自动禁用自己，这使得它在需要检查特定条件或行为而不需要重复命中相同断点的情况下非常理想。
- en: To set up a tempory breakpoint, we first need to identify the breakpoint that
    our current breakpoint will depend on. Then, we hover over the breakpoint symbol,
    choose the settings icon, and select **Disable breakpoint once hit** in the **Breakpoint
    Settings** window. This action configures the breakpoint to automatically disable
    itself after it’s hit during our debugging session.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置临时断点，我们首先需要确定当前断点所依赖的断点。然后，我们将鼠标悬停在断点符号上，选择设置图标，并在**断点设置**窗口中选择**一旦命中则禁用断点**。此操作将配置断点在调试会话中命中后自动禁用自己。
- en: '![Figure 2.16 – Disable breakpoint once hit](img/B22218_02_16.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 一旦命中则禁用断点](img/B22218_02_16.jpg)'
- en: Figure 2.16 – Disable breakpoint once hit
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 一旦命中则禁用断点
- en: Alternatively, we can directly set a temporary breakpoint by right-clicking
    in the breakpoint gutter and selecting **Insert Temporary Breakpoint** from the
    context menu.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以通过在断点空白处右键单击并从上下文菜单中选择**插入临时断点**来直接设置临时断点。
- en: The introduction of temporary breakpoints in Visual Studio 2022 enhances our
    debugging experience by providing us with a tool to inspect specific points in
    the code without the need to manually remove or disable breakpoints after they
    have been hit. This feature is particularly useful for validating assumptions,
    checking the flow of execution, or verifying the state of variables at specific
    moments during our debugging process.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'Visual Studio 2022 中临时断点的引入通过提供一种工具来检查代码中的特定点，而不需要在它们被命中后手动删除或禁用断点，从而增强了我们的调试体验。此功能特别适用于验证假设、检查执行流程或在我们调试过程中验证变量的特定状态。 '
- en: Now that we’ve learned all about breakpoints, let’s learn how we can organize
    them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有关于断点的知识，让我们学习如何组织它们。
- en: Organizing our breakpoints
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织我们的断点
- en: We can use labels to sort and filter breakpoints in the **Breakpoints** window.
    Right-click a breakpoint and select **Edit labels...** to add or change labels.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标签在**断点**窗口中对断点进行排序和筛选。右键单击断点并选择**编辑标签…**以添加或更改标签。
- en: '![Figure 2.17 – Edit labels…](img/B22218_02_17.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 编辑标签…](img/B22218_02_17.jpg)'
- en: Figure 2.17 – Edit labels…
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 编辑标签…
- en: Then, in the **Breakpoints** window, we can retrieve our settled labels to filter
    and organize them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**断点**窗口中，我们可以检索我们的标签以进行筛选和组织。
- en: '![Figure 2.18 – Breakpoints with labels](img/B22218_02_18.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 带标签的断点](img/B22218_02_18.jpg)'
- en: Figure 2.18 – Breakpoints with labels
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 带标签的断点
- en: In this example, I labeled my conditional breakpoint **UpdateQuantity** .
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我给我的条件断点命名为**UpdateQuantity**。
- en: Now that we know which breakpoints to use according to our needs, let’s see
    how to inspect the data efficiently.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道根据我们的需求使用哪些断点，让我们看看如何高效地检查数据。
- en: Inspecting the data
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查数据
- en: As we have seen before, the **Watch** window in Visual Studio is a powerful
    debugging tool that allows us to monitor the values of variables and expressions
    during the execution of our program. It is particularly useful when we want to
    keep an eye on the changes in variable values as your code executes, which can
    be especially helpful in debugging complex logic or performance issues.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，Visual Studio 中的 **监视** 窗口是一个强大的调试工具，它允许我们在程序执行期间监控变量和表达式的值。当我们想要关注代码执行时变量值的变化时，它尤其有用，这在调试复杂的逻辑或性能问题时特别有帮助。
- en: 'While the **Watch** window offers a dedicated space for monitoring variables,
    Visual Studio also empowers us with a more immediate option: **DataTips** . These
    handy popups appear right within the code editor, revealing variable values directly
    where they’re used.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **监视** 窗口为监控变量提供了一个专用空间，但 Visual Studio 还为我们提供了一种更直接的选择：**数据提示**。这些方便的弹出窗口直接出现在代码编辑器中，直接显示变量值。
- en: To leverage DataTips, simply hover our mouse over any variable name in our code.
    Then, a tooltip emerges, displaying the current value of that variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 DataTips，只需将鼠标悬停在代码中的任何变量名上。然后，会出现一个工具提示，显示该变量的当前值。
- en: '![Figure 2.19 – Displaying the datatips](img/B22218_02_19.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 显示数据提示](img/B22218_02_19.jpg)'
- en: Figure 2.19 – Displaying the datatips
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 显示数据提示
- en: In certain scenarios, such as the one shown in *Figure 2* *.19* , it can be
    challenging to locate specific items of interest within a large list.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，例如 *图 2.19* 中所示，在大型列表中定位感兴趣的具体项目可能具有挑战性。
- en: Pinning properties
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁定属性
- en: When looking at a data list with a huge list of complex data, it could be difficult
    to focus on the part of the data we need. The solution is to utilize the **Pinnable
    Properties** feature, also available in the **Watch** window. To accomplish this,
    we expand a variable and pin the property that interests us. For example, if we’re
    interested in the name of the product, we can pin it for easy reference.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看包含大量复杂数据的数据列表时，可能很难集中精力关注所需的数据部分。解决方案是利用 **可锁定属性** 功能，该功能也存在于 **监视** 窗口中。为了实现这一点，我们展开一个变量并锁定我们感兴趣的属性。例如，如果我们对产品的名称感兴趣，我们可以将其锁定以方便引用。
- en: '![Figure 2.20 – Pinning the Name property](img/B22218_02_20.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 锁定名称属性](img/B22218_02_20.jpg)'
- en: Figure 2.20 – Pinning the Name property
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 锁定名称属性
- en: '![Figure 2.21 – A list of products with pinned names](img/B22218_02_21.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 带有锁定名称的产品列表](img/B22218_02_21.jpg)'
- en: Figure 2.21 – A list of products with pinned names
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 带有锁定名称的产品列表
- en: Now, whenever we inspect this object with DataTips, even in the **Watch** window,
    the pinned property replaces the name of the object until we unpin it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时我们使用 DataTips 检查此对象，即使在 **监视** 窗口中，锁定属性都会替换对象名称，直到我们取消锁定。
- en: '![Figure 2.22 – Pinned properties in the Watch window](img/B22218_02_22.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 在监视窗口中锁定属性](img/B22218_02_22.jpg)'
- en: Figure 2.22 – Pinned properties in the Watch window
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 监视窗口中的锁定属性
- en: Now, we can easily access the product we want to inspect. Additionally, we can
    use the pin icon located next to our product object to keep the popup visible.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松访问我们想要检查的产品。此外，我们还可以使用位于产品对象旁边的锁定图标来保持弹出窗口可见。
- en: '![Figure 2.23 – The DataTip pin](img/B22218_02_23.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23 – 数据提示锁定](img/B22218_02_23.jpg)'
- en: Figure 2.23 – The DataTip pin
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 数据提示锁定
- en: In this example, I pin the **Name** and **Id** properties of the product so
    we can monitor its behavior during the execution of our loop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我锁定了产品的 **名称** 和 **Id** 属性，这样我们就可以在循环执行期间监控其行为。
- en: Editing value
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑值
- en: DataTips enables us to edit the values of non-read-only variables, which can
    be useful for validating certain scenarios. To do this, we simply click on the
    value of the properties to update it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: DataTips使我们能够编辑非只读变量的值，这在验证某些场景时可能很有用。为此，我们只需单击属性值以更新它。
- en: '![Figure 2.24 – Editing value on DataTips](img/B22218_02_24.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24 – 在 DataTips 中编辑值](img/B22218_02_24.jpg)'
- en: Figure 2.24 – Editing value on DataTips
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24 – 在 DataTips 中编辑值
- en: DataTips also allows us to edit the values of our non-read-only variables, which
    can be useful for validating certain scenarios. This feature is also available
    in the **Watch** window, although it is not present in the **Local** or **Autos**
    windows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 数据提示还允许我们编辑非只读变量的值，这对于验证某些场景可能很有用。此功能也适用于**监视**窗口，尽管它不在**局部**或**自动**窗口中。
- en: While meticulous debugging practices within our own code are crucial, sometimes
    the true culprit lies hidden within external components. Understanding their behavior
    is the key to unlocking elusive bugs and crafting truly robust solutions. Let’s
    explore how Visual Studio, starting from version 17.7, assists us in this endeavor.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们自己的代码中进行细致的调试实践至关重要，但有时真正的罪魁祸首隐藏在外部组件中。理解它们的行为是解锁难以捉摸的bug和构建真正稳健解决方案的关键。让我们探讨从版本
    17.7 开始的 Visual Studio 如何帮助我们在这个方面取得进展。
- en: Elevating debugging with auto-decomplication and External Sources
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自动解耦和外部资源提升调试
- en: Visual Studio 2022 has significantly enhanced the debugging experience with
    the introduction of auto-decompilation and External Sources. These features allow
    developers to debug external code, such as .NET libraries or **NuGet** packages,
    with the same ease as their own code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 通过引入自动解耦和外部资源显著增强了调试体验。这些功能允许开发者以与自己的代码相同的轻松程度调试外部代码，如 .NET
    库或**NuGet**包。
- en: Auto-decompilation
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动解耦
- en: Auto-decompilation is a feature that transforms compiled binary code into a
    higher-level programming language, such as C#, allowing us to examine, troubleshoot,
    and fix issues in external code as if they were working with their own code. This
    is particularly useful for debugging scenarios where the source code is not available
    or when we need to inspect code from a third-party library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 自动解耦是一个将编译的二进制代码转换为高级编程语言（如 C#）的功能，使我们能够像处理自己的代码一样检查、调试和修复外部代码中的问题。这在源代码不可用或我们需要检查第三方库中的代码时尤其有用。
- en: How auto-decompilation works
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动解耦的工作原理
- en: The debugger uses the **ILspy** decompiler engine to decompile external code
    in real time and incorporate it into the debugging session. The debugger first
    looks for local external sources on our machine, then uses **Source Link** or
    **Source Server** information from PDB files to load the source code. If these
    methods fail, the debugger falls back to decompiling the code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器使用**ILspy**反编译器引擎实时反编译外部代码并将其纳入调试会话。调试器首先在我们的机器上查找本地外部资源，然后使用 PDB 文件中的**源链接**或**源服务器**信息来加载源代码。如果这些方法失败，调试器将回退到反编译代码。
- en: Controlling auto-decompilation
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制自动解耦
- en: .NET package authors could, in the past, control whether their code could be
    decompiled by implementing the **SuppressIldasmAttribute** attribute. Although
    this attribute is obsolete as of .NET 6+, Visual Studio still honors it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，.NET 包作者可以通过实现**SuppressIldasmAttribute**属性来控制其代码是否可以被反编译。尽管从 .NET 6+ 开始此属性已过时，但
    Visual Studio 仍然尊重它。
- en: Limitations of auto-decompilation
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动解耦的限制
- en: There can be issues when trying to decompile .NET assemblies, such as inaccurate
    variable names or unavailable variables for evaluation. These limitations can
    be more pronounced when debugging optimized or release assemblies.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试反编译 .NET 程序集时可能会遇到问题，例如变量名称不准确或不可用变量进行评估。这些限制在调试优化或发布程序集时可能更为明显。
- en: External Sources
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部资源
- en: The External Sources feature in Visual Studio allows us to debug and step into
    code from dependent NuGet or .NET libraries that are not part of our solution.
    This is facilitated by the addition of an External Sources node in **Solution
    Explorer** , which appears during debugging and shows sources for managed modules
    with loaded symbols containing Source Link or Source Server information.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 中的外部资源功能允许我们调试并单步执行不属于我们解决方案的依赖 NuGet 或 .NET 库中的代码。这是通过在**解决方案资源管理器**中添加外部资源节点来实现的，该节点在调试期间出现，并显示包含源链接或源服务器信息的已加载符号的管理模块的源。
- en: 'We can find them below the top node of our solution in **Solution Explorer**
    :'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**解决方案资源管理器**中找到它们位于解决方案顶部节点下方：
- en: '![Figure 2.25 – External Sources nodes](img/B22218_02_25.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25 – 外部资源节点](img/B22218_02_25.jpg)'
- en: Figure 2.25 – External Sources nodes
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25 – 外部资源节点
- en: 'Here’s a comprehensive guide on utilizing this feature:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份关于利用此功能的全面指南：
- en: '**Using External Sources** : The External Sources node organizes decompiled
    external code modules from different call stacks, allowing us to navigate and
    set breakpoints within this external code. This makes debugging external code
    as seamless as debugging our own code.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用外部源**：外部源节点组织来自不同调用栈的反编译外部代码模块，使我们能够在其中导航和设置断点。这使得调试外部代码与调试我们自己的代码一样无缝。'
- en: '**Enabling External Sources** : To debug external sources, we may need to enable
    **Load All Modules** to allow the debugger to load symbols for all modules. We
    can also manually load modules from the **Modules** window if necessary from the
    top bar menu by going to **Debug** | **Window** | **Modules** .'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用外部源**：要调试外部源，我们可能需要启用**加载所有模块**，以便调试器为所有模块加载符号。如果需要，我们还可以通过从顶部菜单的**调试**
    | **窗口** | **模块**进入，从**模块**窗口手动加载模块。'
- en: '**Downloading source code** : If we double-click an item in the External Sources
    node, we may be prompted to download the source from the server. After accepting,
    we can view the source code in the editor.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载源代码**：如果我们双击外部源节点中的某个项目，可能会提示从服务器下载源代码。接受后，我们可以在编辑器中查看源代码。'
- en: Auto-decompilation and External Sources make it easier for us to debug external
    code, which can be particularly beneficial when dealing with complex libraries
    or when trying to resolve issues in third-party code. These features streamline
    our debugging process, reducing the time we spend on understanding and navigating
    external code. Package authors can prevent their code from being decompiled by
    using the **SuppressIldasmAttribute** attribute, ensuring that they maintain control
    over their intellectual property. However, debugging decompiled code may not always
    be as accurate as debugging source code, with potential issues such as inaccurate
    variable names or unavailable variables. Additionally, stepping through decompiled
    code may not always align with the original source code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 自动反编译和外部源使得我们更容易调试外部代码，这在处理复杂库或尝试解决第三方代码中的问题时尤其有益。这些功能简化了我们的调试过程，减少了我们在理解和导航外部代码上花费的时间。包作者可以使用**SuppressIldasmAttribute**属性来防止其代码被反编译，从而确保他们对其知识产权的控制。然而，调试反编译代码可能并不总是像调试源代码那样准确，可能会出现诸如变量名不准确或变量不可用等问题。此外，单步执行反编译代码可能并不总是与原始源代码对齐。
- en: By leveraging these features, Visual Studio 2022 offers a more comprehensive
    debugging experience, enabling us to diagnose and resolve issues in their applications
    more effectively.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些功能，Visual Studio 2022提供了更全面的调试体验，使我们能够更有效地诊断和解决应用程序中的问题。
- en: Concurrency debugging
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发调试
- en: Multithreading is a technique whereby a process splits into multiple threads,
    allowing for better performance, especially on systems with multiple processors
    or cores. However, managing multiple threads can be challenging as they may need
    to access shared resources concurrently, leading to potential bugs such as deadlocks
    where threads are unable to progress. Debugging such issues can be difficult and
    time-consuming.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一种技术，其中进程分为多个线程，从而允许更好的性能，尤其是在具有多个处理器或核心的系统上。然而，管理多个线程可能具有挑战性，因为它们可能需要并发访问共享资源，从而导致潜在的死锁等错误。调试此类问题可能既困难又耗时。
- en: In this section, we will learn how to tackle this by using the **Threads** window
    and handling parallel debugging.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何通过使用**线程**窗口和处理并行调试来解决这个问题。
- en: 'For this, we will create a simple console application calling ten simple threads.
    Here’s the code we will use for our example :'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个简单的控制台应用程序，调用十个简单的线程。以下是我们将用于示例的代码：
- en: '[PRE0]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code demonstrates the creation and execution of multiple threads in C#,
    each running an instance of a **Dummy** class’s **Instance** method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码演示了在C#中创建和执行多个线程的过程，每个线程运行一个**Dummy**类的**Instance**方法实例。
- en: First, we will set a breakpoint on **Thread.Sleep(3000)** on the **Instance**
    method and launch our project in debug mode.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在**Instance**方法上的**Thread.Sleep(3000)**处设置断点，并以调试模式启动我们的项目。
- en: We can track the thread by activating the **Show Threads in Source** button
    on the debug toolbar.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在调试工具栏上激活**显示源代码中的线程**按钮来跟踪线程。
- en: '![Figure 2.26 – Show Threads in Source](img/B22218_02_26.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图2.26 – 显示源代码中的线程](img/B22218_02_26.jpg)'
- en: Figure 2.26 – Show Threads in Source
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 – 显示源代码中的线程
- en: That will make **thread maker icons** appear on the left side of the window.
    When we hover over them, we can view the name and thread ID number for each stopped
    thread.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在窗口的左侧显示**线程创建者图标**。当我们悬停在它们上面时，我们可以查看每个停止线程的名称和线程ID号。
- en: '![Figure 2.27 – List of threads](img/B22218_02_27.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图2.27 – 线程列表](img/B22218_02_27.jpg)'
- en: Figure 2.27 – List of threads
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 – 线程列表
- en: 'By right-clicking on one of the threads, we can access different types of action
    to navigate through the threads, such as the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击其中一个线程，我们可以访问不同的操作类型以在线程之间导航，如下所示：
- en: '**Flag** / **Unflag**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记** / **取消标记**'
- en: '**Freeze** / **Thraw**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冻结** / **解冻**'
- en: '**Switch** **To Thread**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换到线程**'
- en: '![Figure 2.28 – Manipulating threads](img/B22218_02_28.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图2.28 – 操作线程](img/B22218_02_28.jpg)'
- en: Figure 2.28 – Manipulating threads
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 – 操作线程
- en: When we flag threads, it enables us to focus on one thread while ignoring the
    others.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们标记线程时，它使我们能够专注于一个线程，同时忽略其他线程。
- en: To resolve concurrency issues and control the order in which threads perform
    work, we must use the **Freeze** and **Thraw** features, allowing us to suspend
    and resume threads.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决并发问题并控制线程执行工作的顺序，我们必须使用**冻结**和**解冻**功能，允许我们挂起和恢复线程。
- en: Additionally, **Switch To Thread** allows us to jump from one thread to another
    for step-by-step debugging.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**切换到线程**功能允许我们在逐步调试中从一个线程跳转到另一个线程。
- en: Regarding the common debugging process, Visual Studio offers a **Watch** window
    named **Parallel Watch** . We access it from the top bar menu by clicking on **Debug**
    | **Window** | **Parallel Watch** | **Parallel** **Watch 1** .
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 关于常见的调试过程，Visual Studio提供了一个名为**并行监视**的**监视**窗口。我们可以通过点击顶部菜单栏的**调试** | **窗口**
    | **并行监视** | **并行监视1**来访问它。
- en: '![Figure 2.29 – Parallel Watch](img/B22218_02_29.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图2.29 – 并行监视](img/B22218_02_29.jpg)'
- en: Figure 2.29 – Parallel Watch
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29 – 并行监视
- en: Here, we can add data to watch by entering their names in the **<Add Watch>**
    cell. Additionally, we can easily switch to a thread by double-clicking on the
    thread line we are interested in. Right-clicking allows us to access the **Flag**
    and **Freeze** features. The flag button in the top left corner enables us to
    filter and display only the flagged threads.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过在**<添加监视>**单元格中输入它们的名称来添加数据到监视。此外，我们可以通过双击我们感兴趣的线程行轻松地切换到线程。右键单击允许我们访问**标记**和**冻结**功能。位于左上角的标记按钮使我们能够过滤并仅显示标记的线程。
- en: Another view offered by Visual Studio to efficiently track threads is the **Parallel
    Stacks** window. To access it, we use the debug menu, which you can reach by clicking
    **Debug** | **Window** | **Parallel Stacks** .
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio提供的另一种高效跟踪线程的视图是**并行堆栈**窗口。要访问它，我们使用调试菜单，可以通过点击**调试** | **窗口**
    | **并行堆栈**来访问。
- en: '![Figure 2.30 – Parallel Stacks](img/B22218_02_30.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图2.30 – 并行堆栈](img/B22218_02_30.jpg)'
- en: Figure 2.30 – Parallel Stacks
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30 – 并行堆栈
- en: This window provides both a **Thread** and a **Tasks** view, showing the call
    stack information for each thread. The current thread is indicated by a yellow
    arrow, allowing us to easily follow the path of each thread. This information
    can also be viewed in a list format in the **Threads** window by going to **Debug**
    | **Windows** | **Threads** .
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口提供了**线程**和**任务**视图，显示每个线程的调用堆栈信息。当前线程由一个黄色箭头指示，使我们能够轻松地跟踪每个线程的路径。这些信息也可以通过转到**调试**
    | **窗口** | **线程**来以列表格式在**线程**窗口中查看。
- en: Finally, we can utilize conditional breakpoints, which allow us to set breakpoints
    based on various conditions, such as the thread name or ID. This feature is particularly
    handy when setting conditions on data unique to each thread. It’s a common approach
    during debugging, especially when focusing on specific data values rather than
    individual threads.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以利用条件断点，这允许我们根据各种条件设置断点，例如线程名称或ID。当需要对每个线程独有的数据进行条件设置时，这个功能特别有用。在调试过程中，尤其是在关注特定数据值而不是单个线程时，这是一个常见的做法。
- en: Now that we have gone on a journey exploring the techniques and tools of Visual
    Studio 2022 concerning debugging, let’s see how we can resolve the famous “it
    works on my laptop” issues by leveraging the remote debugging feature.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了Visual Studio 2022关于调试的技术和工具，让我们看看如何通过利用远程调试功能来解决著名的“在我的笔记本电脑上它工作”的问题。
- en: Remote debugging
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程调试
- en: Remote debugging is a powerful feature in Visual Studio that allows us to debug
    applications running on different machines, devices, or environments. This is
    particularly useful when we need to troubleshoot issues that occur in a production
    environment or on a different platform that we don’t have access to locally.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调试是 Visual Studio 中的一个强大功能，允许我们调试在不同机器、设备或环境中运行的应用程序。当我们需要解决在生产环境中或在我们无法本地访问的不同平台上发生的问题时，这尤其有用。
- en: To leverage this functionality effectively, we need to ensure that Visual Studio
    is installed on both the local and remote machines. We need to configure the remote
    machine by installing the compatible Visual Studio version and allowing remote
    connections via the firewall settings.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用此功能，我们需要确保在本地和远程机器上都安装了 Visual Studio。我们需要通过安装兼容的 Visual Studio 版本并允许通过防火墙设置进行远程连接来配置远程机器。
- en: On the local machine, we enable remote debugging in Visual Studio’s settings
    by specifying the remote machine’s address and credentials, if necessary. To do
    so, we go to the project properties of the application we want to debug and navigate
    to the **Debug** tab.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地机器上，我们通过指定远程机器的地址和（如果需要）凭据，在 Visual Studio 的设置中启用远程调试。为此，我们转到我们想要调试的应用程序的项目属性，并导航到
    **调试** 选项卡。
- en: '![Figure 2.31 – The Project properties | Debug tab](img/B22218_02_31.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31 – 项目属性 | 调试选项卡](img/B22218_02_31.jpg)'
- en: Figure 2.31 – The Project properties | Debug tab
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – 项目属性 | 调试选项卡
- en: 'Here, we can click on the **Open debug launch profiles UI** link. Once in the
    **Launch Profiles** window, we can check the **Use remote machine** checkbox that
    displays the two more fields that allow us to configure the remote connection:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以点击 **打开调试启动配置文件 UI** 链接。一旦进入 **启动配置文件** 窗口，我们可以勾选 **使用远程机器** 复选框，这将显示两个额外的字段，允许我们配置远程连接：
- en: '![Figure 2.32 – The Use remote machine checkbox](img/B22218_02_32.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.32 – 使用远程机器复选框](img/B22218_02_32.jpg)'
- en: Figure 2.32 – The Use remote machine checkbox
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 – 使用远程机器复选框
- en: In a critical situation wherein debugging a web application on a live production
    server, it’s becomes essential to be able to access to the debugger on production
    server.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个关键情况下，如果在实时生产服务器上调试 Web 应用程序，能够访问生产服务器的调试器变得至关重要。
- en: Deploy the application to the production server, ensuring that all necessary
    components are installed. After that, we need to configure Visual Studio on the
    server for remote debugging and adjust the firewall settings accordingly. In Visual
    Studio on the local machine, we attach to the remote process by entering the remote
    machine’s address and credentials.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到生产服务器，确保安装了所有必要的组件。之后，我们需要在服务器上配置 Visual Studio 以进行远程调试，并相应地调整防火墙设置。在本地机器上的
    Visual Studio 中，通过输入远程机器的地址和凭据来附加到远程进程。
- en: Then we can debug the application, select the process for the web application,
    and debug as usual, including setting breakpoints and inspecting variables. Finally,
    we can reproduce the issue while debugging, fix it once it has been identified,
    and deploy the updated application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调试应用程序，选择 Web 应用程序的过程，并像往常一样进行调试，包括设置断点和检查变量。最后，我们可以在调试过程中重现问题，一旦确定问题，就修复它，并部署更新后的应用程序。
- en: Remote debugging facilitates diagnosing issues in production-like environments
    without disrupting live traffic. Accessing production data aids in understanding
    the issue’s context. Security measures should be implemented to safeguard sensitive
    information. Be mindful of performance impacts, scheduling debugging during off-peak
    times or in staging environments. Utilizing remote debugging enhances application
    reliability by addressing issues in environments inaccessible through traditional
    means, bolstering overall quality and stability.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调试简化了在生产环境类似环境中诊断问题，而不会干扰实时流量。访问生产数据有助于理解问题的上下文。应实施安全措施以保护敏感信息。注意性能影响，在非高峰时段或在测试环境中安排调试。利用远程调试通过解决传统方式无法访问的环境中的问题，提高了应用程序的可靠性，增强了整体质量和稳定性。
- en: By using remote debugging, we can effectively diagnose and fix issues that occur
    in environments where we don’t have direct access to the code or data, thereby
    improving the reliability and quality of our applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用远程调试，我们可以有效地诊断和修复在无法直接访问代码或数据的环境中发生的问题，从而提高我们应用程序的可靠性和质量。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter delved into the powerful world of advanced debugging strategies
    in Visual Studio 2022, equipping you with the skills to tackle even the most complex
    code effectively. We explored various debugging tools and techniques that are
    essential for identifying and resolving issues in your code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了 Visual Studio 2022 中强大的高级调试策略世界，为您提供了应对甚至最复杂代码的有效技能。我们探讨了各种调试工具和技术，这些对于识别和解决代码中的问题至关重要。
- en: We began by mastering the art of navigating your code, where we focused on breakpoints,
    step execution modes, and the call stack, all of which are crucial for pinpointing
    the source of errors. The chapter also introduced the concept of live code modification,
    allowing you to dynamically fix bugs and experiment with code changes on the fly
    through features like Edit and Continue and Hot Reload. We didn’t stop at debugging
    your own code; we also explored the advantages of auto-decompilation and External
    Sources, which enable seamless debugging of external libraries and NuGet packages.
    Furthermore, the chapter covered remote debugging, a technique that allows you
    to diagnose and fix issues in production-like environments without impacting live
    traffic. By mastering these advanced debugging techniques, you can resolve complex
    bugs more quickly, thereby reducing development time and frustration.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从掌握导航代码的艺术开始，重点关注断点、单步执行模式和调用栈，这些都是定位错误来源的关键。本章还介绍了实时代码修改的概念，允许您通过诸如“编辑并继续”和“热重载”等功能，动态修复错误并实时实验代码更改。我们不仅限于调试自己的代码；还探讨了自动反编译和外部源的优势，这些功能使得外部库和
    NuGet 包的调试变得无缝。此外，本章还涵盖了远程调试技术，这是一种允许您在不影响实时流量的情况下，在生产环境类似环境中诊断和修复问题的技术。通过掌握这些高级调试技术，您可以更快地解决复杂错误，从而减少开发时间和挫折。
- en: In the next chapter, we’ll continue our journey according to the TDD cycle seen
    in the first chapter. After fixing our code with debugging, we’ll delve into the
    art of shaping our code into its best form. We’ll be embarking on a journey of
    advanced code analysis and refactoring in Visual Studio 2022.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将根据第一章中看到的 TDD 循环继续我们的旅程。在用调试修复我们的代码之后，我们将深入探讨将代码塑造成最佳形态的艺术。我们将开始一段在
    Visual Studio 2022 中进行高级代码分析和重构的旅程。
