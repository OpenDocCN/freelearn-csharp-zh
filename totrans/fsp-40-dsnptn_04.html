<html><head></head><body>
<div><div><div><div><h1 class="title"><a id="ch04"/>
 Chapter 4.  Basic Pattern Matching</h1>
</div>
</div>
</div>
<p>This chapter continues the study of functional programming foundations that the previous chapter opened. It covers basic data pattern matching. Pattern matching is an essential feature-rich mechanism of powerful data processing that is embedded into the F# language's core.</p>
<p>A good grasp of the F# pattern matching features is an absolute must for an enterprise developer because most of the time, enterprise business is revolving around sophisticated data transformations in 
<strong>Line Of Business</strong>

 (
<strong>LOB</strong>

 ) 
<strong>applications</strong>

 (<a class="ulink" href="https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/">https://blogs.msdn.microsoft.com/dragoman/2007/07/19/what-is-a-lob-application/</a>
 ) and along 
<strong>

<strong>E</strong>

 xtract Transform Load</strong>

 (
<strong>ETL</strong>

 ) (<a class="ulink" href="https://en.wikipedia.org/wiki/Extract,_transform,_load">https://en.wikipedia.org/wiki/Extract,_transform,_load</a>
 ) cycles in data warehousing and business analytics.</p>
<p>I intentionally narrowed down the subject of this chapter to basic pattern matching for a merely didactic reason. Usually, F# beginners first grasp pattern matching as an imperative switch on steroids or just a semantically equivalent way of coding lengthy <code class="literal">if...then...elif...elif... ...else...</code>
 expressions. Then, they begin to recognize the role of pattern matching in data structures decomposition. And finally, the pattern matching knowledge acquisition gets completed with embracing 
<strong>active patterns</strong>

 .</p>
<p>The goal of this chapter is to provide you with a thorough grasp of the pattern matching features associated with the F# <code class="literal">match</code>
 construction:</p>
<div><ul class="itemizedlist">
<li class="listitem">The overall composition of this rather complicated language construction</li>
<li class="listitem">Tacit assumptions behind the parts of match (the ordering of matching rules and completeness of pattern cases, to name a few)</li>
<li class="listitem">Specific kinds of pattern cases and how to build composite cases</li>
</ul>
</div>
<p>The decomposition abilities consideration is postponed until the coverage of the data structures in the upcoming chapters. Similarly, I will cope with 
<strong>active patterns</strong>

 when covering the advanced programming techniques of F#.</p>
<div><div><div><div><h1 class="title" id="toc_1"><a id="ch04lvl1sec31"/>
 An explicit form of pattern matching with match construction</h1>
</div>
</div>
</div>
<p>Explicit <code class="literal">match</code>
 construction in F# belongs to control flow elements, along with <code class="literal">if-then-else</code>
 , or <code class="literal">while-do</code>
 . Of other F# bits and pieces, a <code class="literal">match</code>
 is a relatively complicated combination of the following parts and governing rules:</p>
<pre class="programlisting">match comparison-expression with 
  | pattern-expression1 -&gt; result-expression1 
  ......................................... 
  | pattern-expressionN -&gt; result-expressionN 
</pre>
<p>It works in this manner, that is, <code class="literal">comparison-expression</code>
 is juxtaposed with each <code class="literal">pattern-expression</code>
 beginning with <code class="literal">pattern-expression1</code>
 and goes down the list until either the first match occurs, or passing <code class="literal">pattern-expressionN</code>
 still non-matched. If a match is found for <code class="literal">pattern-expressionX</code>
 , then the result of the entire construction is the result of <code class="literal">result-expressionX</code>
 . If no matches are found, then <code class="literal">MatchFailureException</code>
 is thrown, indicating that the match cases were incomplete.</p>
<p>The key points of pattern matching that are often missing by F# beginners on the first read are as follows:</p>
<div><ul class="itemizedlist">
<li class="listitem">The <code class="literal">match</code>
 construction represents an expression, like any other F# construction excluding value binding. This means that the value of one and only one of <code class="literal">result-expressions</code>
 will be taken for the value of the entire construction (given that a certain matching has indeed taken place).</li>
<li class="listitem">Every <code class="literal">pattern-expression1</code>
 through <code class="literal">pattern-expressionN</code>
 must share the same type, which is also the same with the type of <code class="literal">comparison-expression</code>
 in order for the <code class="literal">match</code>
 construction to compile.</li>
<li class="listitem">Every <code class="literal">result-expression1</code>
 through <code class="literal">result-expressionN</code>
 must share the same type in order for the match construction to compile.</li>
<li class="listitem">Listed pattern to result cases are tried at run-time one after another in the top-down order. This arrangement prescribes a certain ordering of the cases from the standpoint of pattern commonality. More specific patterns must precede less specific ones; otherwise, more specific patterns will not have chances to be matched ever.</li>
<li class="listitem">The set of alternatives represented by all patterns must be exhaustive; otherwise, matching <code class="literal">comparison-expression</code>
 not covered by any of the patterns will cause <code class="literal">MatchFailureException</code>
 .</li>
<li class="listitem">More atomic pattern terms can be composed into broader pattern expressions using Boolean logic operators OR (<code class="literal">|</code>
 ), AND (<code class="literal">&amp;</code>
 ), and a special <code class="literal">when</code>
 guard.</li>
</ul>
</div>
<p>Now, I will walk you through the multiplicity of pattern kinds so that you get used to their broad repertoire and become comfortable with getting around <code class="literal">match</code>
 expressions.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>
 Matching literals</h1>
</div>
</div>
</div>
<p>One of the simplest cases of matching patterns is a pattern represented by a literal and assuming a simple <code class="literal">comparison-expression</code>
 value equality. Literals can be of any numeric, character, or string types. They can also be cases of a .NET enumeration (each such case is inherently a symbolic name alias of the integer value) or a value decorated with the <code class="literal">[&lt;Literal&gt;]</code>
 attribute.</p>
<p>In the following script, I can easily match <code class="literal">int</code>
 literals and the <code class="literal">int</code>
 value aliased as <code class="literal">THREE</code>
 , decorated with the <code class="literal">[&lt;Literal&gt;]</code>
 attribute (<code class="literal">Ch4_1.fsx</code>
 ):</p>
<pre class="programlisting">[&lt;Literal&gt;] 
let THREE = 3 
 
let transformA v = 
  match v with 
  | 1 -&gt;"1" 
  | 2 -&gt;"2" 
  | THREE -&gt;"3" 
 
transformA &lt;| (1 + 2) 
</pre>
<p>This yields string <code class="literal">"3"</code>
 , as expected. However, it wouldn't be possible to mix <code class="literal">int</code>
 literals with named <code class="literal">int</code>
 constant values from the following script (<code class="literal">Ch4_1.fsx</code>
 ):</p>
<pre class="programlisting">type Multiples = 
  | Zero = 0 
  | Five = 5 
 
let transformB ``compare me`` = 
  match ``compare me`` with 
  | Multiples.Zero -&gt;"0" 
  | Multiples.Five -&gt;"5" 
Multiples.Five |&gt; transformB 
</pre>
<p>This yields string <code class="literal">"5"</code>
 , although being literals, <code class="literal">Multiples.Zero</code>
 and <code class="literal">Multiples.Five</code>
 are typed as members of the <code class="literal">Multiples</code>
 enumeration.</p>
<p>(Besides, if you did not grok this yet, placing almost any text between the doubled backticks, such as <code class="literal">``compare me``</code>
 above, makes this text a valid F# name and, when used in moderation, may add to improved code readability).</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>
 Wildcard matching</h1>
</div>
</div>
</div>
<p>If I put the preceding scripts into Visual Studio, the F# source code editor will draw a blue warning squiggle line under the <code class="literal">``compare me``</code>
 comparison expression, indicating that the set of rules in this <code class="literal">match</code>
 construction is not exhaustive, as shown in the following screenshot:</p>
<div><img src="img/Image00018.jpg" alt="Wildcard matching"/>
<div><p>An example of an incomplete pattern matching</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The compiler even gives a sample value of <code class="literal">``compare me``</code>
 , which is not going to match. Although this value is not present within the definition of type <code class="literal">Multiples</code>
 , if I synthetically create this value as <code class="literal">enum&lt;Multiples&gt;(1)</code>
 and feed it as an argument into <code class="literal">transformB</code>
 , the result would be the run-time exception of type <code class="literal">Microsoft.FSharp.Core.MatchFailureException</code>
 . This situation should raise the following question: how would it be possible to put a 
<em>match all</em>

 rule into the <code class="literal">match</code>
 , which means anything that was not specified in preceding rules?</p>
<p>For this purpose, F# offers the special 
<strong>wildcard pattern </strong>

 <code class="literal">_</code>
 that matches anything that was not matched in the preceding rules. With its help and turning to the idiomatic F# way of processing undefined values by presenting the result as a value of type <code class="literal">option</code>
 , the function processing only legitimate <code class="literal">Multiples</code>
 values may be defined as shown in the following code (<code class="literal">Ch4_1.fsx</code>
 ):</p>
<pre class="programlisting">let transformB' m = 
  match m with 
  | Multiples.Zero -&gt; Some "0" 
  | Multiples.Five -&gt; Some "5" 
  | _ -&gt; None 
</pre>
<p>Now, the match within the <code class="literal">transformB'</code>
 definition carries the exhaustive set of match cases. Any legitimate value of <code class="literal">Multiples</code>
 given as <code class="literal">m</code>
 will be transformed into a correspondent <code class="literal">Somestring option</code>
 value, and any non-legitimate value of the <code class="literal">m</code>
 argument will be transformed into a <code class="literal">None</code>
 result.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>
 Arranging matching rules</h1>
</div>
</div>
</div>
<p>Wildcard pattern demonstrates the importance of arranging the match cases from more specific to less specific. For example, if I put the 
<em>match all</em>

 third rule with the wildcard pattern before the first two rules in the preceding script, then the F# compiler will put the blue squiggle line under explicit <code class="literal">Multiples</code>
 values, indicating that these rules will never be matched (check out <code class="literal">transformB''</code>
 definition in <code class="literal">Ch4_1.fsx</code>
 ).</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>
 Named patterns</h1>
</div>
</div>
</div>
<p>The F# compiler performs a certain analysis when a name (identifier) occurs in the position of a pattern case. Strictly speaking, there are some opportunities for the name to be as follows:</p>
<div><ul class="itemizedlist">
<li class="listitem">A named literal (such as THREE in the earlier script)</li>
<li class="listitem">A case value of a discriminated union (such as <code class="literal">None</code>
 if matching an F# <code class="literal">option</code>
 )</li>
<li class="listitem">A type of an exception (such as <code class="literal">System.ArgumentException</code>
 if matching an exception type)</li>
<li class="listitem">A custom name of an active pattern (which will be covered in the upcoming chapters)</li>
</ul>
</div>
<p>If the name occurrence does not fit any of the previously listed alternatives, the name is considered a 
<strong>variable pattern</strong>

 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd547125.aspx">https://msdn.microsoft.com/en-us/library/dd547125.aspx</a>
 ). It is treated similarly to the wildcard pattern, getting the value of <code class="literal">comparison-expression</code>
 parameter, which can be used in the corresponding <code class="literal">result-expression</code>
 . Sounds confusing, right? Then let's turn to a sample in order to make this matter clear.</p>
<p>I just took the definition of the <code class="literal">transformA</code>
 function from the matching literals section, changed the name of the function to <code class="literal">transformA'</code>
 , and removed the definition of the <code class="literal">THREE</code>
 literal from the context (<code class="literal">Ch4_2.fsx</code>
 ):</p>
<pre class="programlisting">let transformA' v = 
  match v with 
  | 1 -&gt; "1" 
  | 2 -&gt; "2" 
  | THREE -&gt; "3" 
 
</pre>
<p>The results of experimenting with this function version are shown in the following screenshot.</p>
<div><img src="img/Image00019.jpg" alt="Named patterns"/>
<div><p>Turning of a literal pattern into a variable pattern</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>To begin with, the omission of the literal didn't blow up the script, producing just a benign warning that <code class="literal">THREE</code>
 might be a misspelled pattern name. Applying the function to the argument <code class="literal">50</code>
 that is completely off produces the same result as before for the legitimate argument value <code class="literal">3</code>
 . What gives?</p>
<p>No magic here; in accordance with the description identifier, <code class="literal">THREE</code>
 was not recognized as a named literal, discriminated union case, exception type, or active pattern. This finding turned it into a variable pattern playing the role of a match-all pattern case, which <code class="literal">result-expression</code>
 just blindly outputs as string <code class="literal">"3".</code>
</p>
<p>In my experience as an F# developer, I faced at least one occasion when this seemingly innocuous pattern type transformation typo turned into a nasty bug.</p>
<div><h3 class="title" id="toc_1"><a id="tip6"/>
 Tip</h3>
<p>The moral: handle with care, and do not disregard F# compiler warnings!</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>
 The as pattern</h1>
</div>
</div>
</div>
<p>Interestingly, a pattern case may have the <code class="literal">as</code>
 clause appended to it. This clause binds the matched value to a name that may be used within the corresponding <code class="literal">result-expression</code>
 of the <code class="literal">match</code>
 construction or elsewhere within a local context of an outer <code class="literal">let</code>
 binding. The following script demonstrates how flexible the <code class="literal">as</code>
 pattern can be (<code class="literal">Ch4_3.fsx</code>
 ):</p>
<pre class="programlisting">let verifyGuid g = 
  match System.Guid.TryParse g with 
  | (true,_ as r) -&gt; sprintf "%s is a genuine GUID %A" g (snd r) 
  | (_,_ as r) -&gt; sprintf "%s is a garbage GUID, defaults to %A" 
                        g (snd r);; 
</pre>
<p>In the first case, <code class="literal">r</code>
 is bound using <code class="literal">as</code>
 to the result of <code class="literal">TryParse</code>
 , which is the tuple, so the expression <code class="literal">snd r</code>
 yields the parsed GUID value.</p>
<p>In the second case, <code class="literal">as</code>
 bounds <code class="literal">r</code>
 to any tuple; however, it must be obvious from the match cases sequencing that this case matches the failed GUID parsing and the value of argument is a garbage.</p>
<p>The following screenshot reflects firing each of these using <code class="literal">as</code>
 binding match cases in FSI:</p>
<div><img src="img/Image00020.jpg" alt="The as pattern"/>
<div><p>Pattern matching with as binding</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>
 Grouping patterns</h1>
</div>
</div>
</div>
<p>Pattern match cases I've covered until this point can be composed together in a manner that resembles the terms of a Boolean expression with OR (<code class="literal">|</code>
 ) and AND (<code class="literal">&amp;</code>
 ) operators. Let me demonstrate this technique by implementing a function that accepts two string arguments that represent keys and validates that both the given values are non-empty, providing a detailed diagnostics.</p>
<p>You should be able to grasp at this point why I should begin the matching with the most specific case when both the keys are empty. The next less specific match is represented by two symmetric cases when either the first or the second key is empty. Here, in order to demonstrate the flexibility provided by F# patterns grouping, I combine these two patterns with Boolean OR and at the same time capture key values into the local context with a variable pattern represented by the tuple <code class="literal">(x,y)</code>
 . For the most generic leftover case, I know that both keys are not empty, so just a variable pattern is sufficient here. The sought function definition is as follows (<code class="literal">Ch4_4.fsx</code>
 ):</p>
<pre class="programlisting">open System 
 
let validate keyA keyB = 
  match (keyA,keyB) with 
  | ("","") -&gt; "both keys are empty" 
  | (x,y) &amp; (("",_) | (_,"")) -&gt; 
    sprintf "one key is empty: keyA = %s; keyB = %s" x y 
  | _ &amp; (x,y) -&gt; 
    sprintf "both keys aren't empty: keyA = %s; keyB = %s" x y 
</pre>
<p>Although the boolean OR pattern combinator helps reach F# code succinctness by combining some cases that require the same transformation expression, boolean AND is not used that frequently for combining the pattern cases in regular pattern matching practice. However, it gets very relevant when grouping 
<em>active patterns</em>

 , which I will be covering in later chapters.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>
 Guards</h1>
</div>
</div>
</div>
<p>At this point, I believe you would agree that pattern matching is a powerful data transformation feature. Just to further amplify the facilities considered so far, F# offers enhancing <code class="literal">pattern-expressions</code>
 with additional matching logic. 
<em>Guard</em>

 is represented by an arbitrary boolean expression that is attached to <code class="literal">pattern-expression</code>
 using the <code class="literal">when</code>
 keyword. The guard kicks in only if its <code class="literal">pattern-expression</code>
 host has matched. Then, the guard expression is computed, and if <code class="literal">true</code>
 , it springs the transformation performed by the corresponding <code class="literal">result-expression</code>
 to the right. Otherwise, the entire rule is considered non matched, and the matching continues in an usual manner. The <code class="literal">when</code>
 guards can be mixed and matched within a <code class="literal">match</code>
 construction in a completely arbitrary manner.</p>
<p>To demonstrate <code class="literal">when</code>
 guards in action, let me slightly modify the previous example. In the case where both keys are not empty, there are two subcases: when the keys are equal to each other and when they are not. Furthermore, our function would be required to format the result for each of these cases differently.</p>
<p>All that is required for this modification is just one extra line of code preceding the last one (remember that I want to add a more specific match case, and then it must go in front of a more generic one). The code is as follows:</p>
<pre class="programlisting">| (x,y) when x = y -&gt; sprintf "both keys are not empty: keyA =    keyB = %s" x</pre>
<p>That's it for this modification. I encourage you to play with both scripts <code class="literal">Ch4_4.fsx</code>
 and <code class="literal">Ch4_5.fsx</code>
 in FSI by entering different arguments provided in the scripts and observing the changing function behavior.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>
 The alternative syntax for anonymous function performing matching</h1>
</div>
</div>
</div>
<p>F# offers a special syntax to define anonymous functions that perform matching, or 
<strong>pattern matching functions</strong>

 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/match-expressions</a>
 ).</p>
<p>This syntax assumes that the anonymous function has a single parameter that is placed at the beginning of the function body in the invisible <code class="literal">match</code>
 construction. Having this alternative way of defining pattern matching anonymous functions just adds to the language succinctness and also better reflects the intent behind defining such kind of functions within the code.</p>
<p>Continuing with coding exercises, in the latest F# script I will rewrite the <code class="literal">validate</code>
 function using the alternative syntax. However, to achieve this, it is required that you address the following problem. The alternative syntax assumes that the pattern matching function has a single argument, while validate has a pair of arguments. The way out would be to apply skills acquired after reading the previous chapter and performing the currying. The following is the code (<code class="literal">Ch4_6.fsx</code>
 ):</p>
<pre class="programlisting">open System 
 
let validate key1 key2 = (key1,key2) |&gt; function 
  | ("","") -&gt; "both keys are empty" 
  | (x,y) &amp; (("",_) | (_,"")) -&gt; 
    sprintf "one key is empty: keyA = %s; keyB = %s" x y 
  | (x,y) when x = y -&gt; 
    sprintf "both keys are not empty: keyA = keyB = %s" x 
  | (x,y) -&gt; 
    sprintf "both keys aren't empty: keyA = %s; keyB = %s" x y 
</pre>
</div>


<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>
 Summary</h1>
</div>
</div>
</div>
<p>I hope that this chapter did not leave stones unturned in the matter of plain vanilla pattern matching. You should now be well prepared to overcome typical pattern matching challenges that F# beginner programmers experience. I remind you that further pattern matching features, namely data decomposition and active patterns, will be covered in later chapters in order to preserve the logical flow of the material.</p>
<p>In the next chapter, I will turn to the exciting subject of 
<em>Algebraic Data Types</em>

 . We will explore how data may be composed too and what are the benefits behind the data composition.</p>
</div>
</body></html>