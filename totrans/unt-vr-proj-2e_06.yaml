- en: World Space UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界空间UI
- en: In the previous chapter, we discovered how to interact with game objects in
    the world space scene. Not only can these objects can be balls and toys, or tools
    and weapons, but they can be buttons you interact with and other user interface
    widgets. Furthermore, Unity includes a user interface canvas system for building
    menus and other UI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现了如何在世界空间场景中与游戏对象交互。这些对象不仅可以是球类玩具，或工具和武器，还可以是你可以与之交互的按钮和其他用户界面小部件。此外，Unity还包括一个用户界面画布系统，用于构建菜单和其他UI。
- en: '**Graphical user interface** (**GUI**) or just UI, usually refers to on-screen
    two-dimensional graphics, which overlay the main gameplay and present information
    to the user with status messages, gauges, and input controls such as menus, buttons,
    sliders, and so on.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面（GUI）**或简称UI，通常指的是屏幕上的二维图形，它覆盖了主要游戏玩法，并通过状态消息、仪表和输入控件（如菜单、按钮、滑块等）向用户展示信息。'
- en: 'In Unity, UI elements always reside on a **canvas**. The Unity manual describes
    the `canvas` component as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，UI元素始终位于一个**画布**上。Unity手册将`canvas`组件描述如下：
- en: The `canvas` component represents the abstract space in which the UI is laid
    out and rendered. All UI elements must be children of a `GameObject` that has
    a `canvas` component attached.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas`组件代表UI布局和渲染的抽象空间。所有UI元素都必须是具有附加`canvas`组件的`GameObject`的子元素。'
- en: In conventional video games, UI objects are usually rendered in a **screen space**
    canvas as an overlay. The screen space UI is analogous to a piece of cardboard
    pasted on your TV or monitor, overlaying the game action behind it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统视频游戏中，UI对象通常在**屏幕空间**画布上作为叠加进行渲染。屏幕空间UI类似于贴在你电视或显示器上的一个纸板，覆盖在它后面的游戏动作上。
- en: However, that doesn't work in VR. If you attempt to use screen space for UI
    in virtual reality, you'll run into issues. Since there are two stereographic
    cameras, you need separate views for each eye. While conventional games may co-opt
    the edges of the screen for UI, *virtual reality has no screen edges*!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在VR中这并不适用。如果你尝试在虚拟现实中使用屏幕空间进行UI，你会遇到问题。由于存在两个立体投影相机，你需要为每只眼睛提供不同的视图。虽然传统游戏可能会利用屏幕边缘来显示UI，但**虚拟现实没有屏幕边缘**！
- en: 'Instead, in VR, we use various approaches that place the user interface elements
    in **World Space** rather than screen space. In this chapter, I characterize a
    number of these types. We''ll define these types in detail and show you examples
    of them throughout this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '相反，在VR中，我们使用各种方法将用户界面元素放置在**世界空间**而不是屏幕空间中。在本章中，我将介绍这些类型中的许多。我们将在本章中详细定义这些类型，并展示它们的示例： '
- en: '**Visor heads-up display**: In a visor **heads-up display** (**HUD**), the
    user interface canvas appears at the same spot in front of your eyes regardless
    of your head movement'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**护目镜式抬头显示（HUD）**：在护目镜式抬头显示中，用户界面画布出现在你眼睛前方相同的位置，无论你的头部如何移动'
- en: '**Reticle cursors**: Similar to visor HUD, a crosshair or a pointer cursor
    is used to choose things in the scene'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准星光标**：类似于护目镜式HUD，使用交叉线或指针光标在场景中选择事物'
- en: '**Windshield HUD**: This is a pop-up panel floating in 3D space like a windshield
    in a cockpit'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挡风玻璃式抬头显示（HUD）**：这是一个像驾驶舱中的挡风玻璃一样漂浮在三维空间中的弹出面板'
- en: '**Game element UI**: The canvas is in the scene as a part of the gameplay,
    like a scoreboard in a stadium'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏元素UI**：画布作为游戏玩法的一部分位于场景中，就像体育场中的计分板'
- en: '**Info bubble**: This is a UI message that is attached to objects in the scene,
    like a thought bubble hovering over a character''s head'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息气泡**：这是一种附着在场景中对象上的UI消息，就像漂浮在角色头顶上的思维气泡'
- en: '**In-game dashboard**: This is a control panel that is a part of the gameplay,
    usually at waist or desk height'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏内仪表盘**：这是一个游戏玩法的一部分的控制面板，通常位于腰部或桌面高度'
- en: '**Wrist-based menu palette**: With two-handed input controllers, one hand can
    hold a menu palette while the other makes selections and uses the selected tool'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于手腕的菜单调色板**：使用双手输入控制器，一只手可以握住菜单调色板，而另一只手进行选择并使用选定的工具'
- en: The differences in these UI techniques basically comes down to where and when
    you display the canvas and how the user interacts with it. In this chapter, we're
    going to try each of these in turn. Along the way, we'll also continue to explore
    user input with head movement and gestures as well as button clicks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些UI技术的差异基本上归结于你在哪里以及何时显示画布，以及用户如何与之交互。在本章中，我们将逐一尝试这些方法。在这个过程中，我们还将继续探索使用头部移动和手势以及按钮点击进行用户输入。
- en: Note that some of the exercises in this chapter use the scene completed in [Chapter
    4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based Control*, but are
    separate and not directly required by the other chapters in this book. If you
    decide to skip any of it or not save your work, that's OK.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的一些练习使用了[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)中完成的场景，*基于注视的控制*，但这些练习是独立的，并不直接依赖于本书其他章节。如果你决定跳过其中任何部分或未保存你的工作，那也是可以的。
- en: Studying VR design principles
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习VR设计原则
- en: Before we get into the implementation details, I would like to introduce the
    topic of designing 3D user interfaces and VR experiences. A lot of work has been
    done over the past few decades, and more so in the past few years.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实施细节之前，我想介绍设计3D用户界面和VR体验的主题。在过去几十年里，尤其是最近几年，已经做了很多工作。
- en: 'With consumer VR devices so readily available, and powerful development tools
    like Unity, it''s not surprising there are many people inventing and trying new
    things, innovating continuously, and producing really excellent VR experiences.
    You are probably one of them. But the context of today''s VR is not a vacuum.
    There is a history of research and development that feeds into present-day work. 
    The book *3D User Interfaces: Theory and Practice* (Bowman et al), for example,
    is a classic academic survey of 3D user interaction for consumer, industrial,
    and scientific applications and research. Originally published in 2004, the second
    edition was published in 2017 (LaViola et al) and is an up-to-date review of academic
    theory and practical principles.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着消费级VR设备的普及，以及像Unity这样的强大开发工具，许多人发明和尝试新事物，不断创新，并创造出真正优秀的VR体验，这并不令人惊讶。你可能就是其中之一。但今天VR的背景并非真空。它有着研究和发展的历史，这些历史为当前的工作提供了养分。例如，由Bowman等人撰写的《3D用户界面：理论与实践》一书，是对消费、工业和科学应用及研究的3D用户交互的经典学术综述。该书最初于2004年出版，第二版于2017年（LaViola等人）出版，是对学术理论和实践原则的最新回顾。
- en: 'Current writings for VR design are more accessible. An easy to read but practical
    introduction to VR user experience design is the Medium article *Get started with
    VR: user experience design* ([https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18](https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18))
    by Adrienne Hunter, co-creator of the popular VR physics package, NewtonVR. She
    identifies some important core principles, including It''s like theatre in the
    round, drawing attention with to objects, lighting, and audio cues, and designing
    space for height and accessibility.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当前关于VR设计的写作更加易于理解。Adrienne Hunter撰写的Medium文章《开始VR：用户体验设计》（[https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18](https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18)）是一篇易于阅读但实用的VR用户体验设计入门文章，她是流行的VR物理包NewtonVR的联合创作者。她确定了几个重要的核心原则，包括像圆形剧场一样，通过物体、灯光和音频提示来吸引注意力，以及为高度和可访问性设计空间。
- en: 'Another great article is *Practical VR: A Design Cheat Sheet* ([https://virtualrealitypop.com/practical-vr-ce80427e8e9d](https://virtualrealitypop.com/practical-vr-ce80427e8e9d)).
    This is intended to be a living primer with VR design guidelines, process, tools
    and other resources the author intends to maintain and update.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一篇优秀的文章是《实用VR：设计速查表》（[https://virtualrealitypop.com/practical-vr-ce80427e8e9d](https://virtualrealitypop.com/practical-vr-ce80427e8e9d)）。这是一本旨在持续维护和更新的活页手册，包含了VR设计指南、流程、工具和其他资源。
- en: One of my favorite studies of design for VR is the *VR Interface Design Pre-Visualization
    Methods* produced by Mike Algers as a grad student in 2015\. His inspiring video
    at [https://vimeo.com/141330081](https://vimeo.com/141330081) presents an easily
    digestible thesis of design principles, especially for seated VR experiences,
    based on established ergonomics of workspaces and visual perception. We'll use
    some of these ideas in this chapter. Algers also explores button design for VR,
    mockup workflows, and concepts for VR operating system design. (Algers presently
    works in the Google VR development group.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的VR设计研究之一是Mike Algers作为2015年研究生制作的《VR界面设计预可视化方法》。他在[https://vimeo.com/141330081](https://vimeo.com/141330081)上的鼓舞人心的视频提出了一种易于消化的设计原则论点，特别是对于坐姿VR体验，基于工作空间和视觉感知的既定人体工程学。我们将在本章中运用这些想法。Algers还探讨了VR的按钮设计、原型工作流程和VR操作系统设计概念。（Algers目前供职于谷歌VR开发团队。）
- en: 'In his thesis, Algers establishes a set of comfort zones radially around the
    user''s first-person location, as shown:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的论文中，Algers建立了一套围绕用户第一人称位置的舒适区域，如下所示：
- en: '![](img/1367a872-18be-41e7-bed9-9af40d410cbe.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1367a872-18be-41e7-bed9-9af40d410cbe.png)'
- en: 'Anything closer than 0.5 m is too close for comfort; you might have to cross
    your eyes just to focus and follow objects at that range. Beyond 20 m is too far
    way to have meaningful interactions, and is also too far for depth perception
    with parallax. Your Peripheral Zones (77–102 degrees) should not contain primary
    content and interactions but can have secondary ones. Behind you he calls the
    Curiosity Zone, you''d need to stretch (or swivel your chair or turn around) to
    see what''s going on there so it''d better be important yet not imperative. The
    Main Content Zone is your normal workspace. Then, accounting for arm reach (forward,
    up, and down) and other normal human movement in a workspace, Algers defines the
    optimal virtual work zone for seated VR experience as shown:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 任何距离小于0.5米的都太近，不舒服；你可能不得不眯眼才能聚焦并跟随那个范围内的物体。超过20米太远，以至于无法进行有意义的互动，并且对于视差深度感知来说也太远了。你的周边区域（77–102度）不应包含主要内容和交互，但可以包含次要内容。在你身后，他称之为好奇心区域，你需要伸展（或旋转椅子或转身）才能看到那里的情况，所以它最好很重要但不是强制性的。主要内容区域是你的正常工作空间。然后，考虑到手臂的伸展（向前、向上和向下）以及工作空间中的其他正常人类运动，Algers定义了坐着VR体验的最佳虚拟工作区域，如下所示：
- en: '![](img/f360026f-0430-439e-b914-449282c0f156.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f360026f-0430-439e-b914-449282c0f156.png)'
- en: For standing and room-scale VR, the workspace is different. When standing, it
    may be much easier (and expected) to be able to turn around to access things all
    around you. With room-scale, you can walk around (and jump, duck, and crawl, for
    that matter). Alex Schwartz and Devin Reimer of Owlchemy Labs (since acquired
    by Google), in their talk at Oculus Connect 2 ( [https://www.youtube.com/watch?v=hjc7AJwZ4DI](https://www.youtube.com/watch?v=hjc7AJwZ4DI)), discuss
    the challenges of designing standing VR experiences for their popular Job Simulator,
    including accommodation for real-world ergonomics and varied height experiences.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于站立和房间规模VR，工作空间是不同的。站立时，可能更容易（也是预期的）能够转身来获取你周围的所有东西。在房间规模VR中，你可以四处走动（并且跳跃、蹲下和匍匐，等等）。Owlchemy
    Labs的Alex Schwartz和Devin Reimer（已被谷歌收购）在Oculus Connect 2会议（[https://www.youtube.com/watch?v=hjc7AJwZ4DI](https://www.youtube.com/watch?v=hjc7AJwZ4DI)）上讨论了为他们的热门游戏Job
    Simulator设计站立VR体验的挑战，包括适应现实世界的人体工程学和不同高度体验。
- en: 'Some other great resources on designing for virtual reality include:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于为虚拟现实设计的其他优秀资源包括：
- en: Oculus's series of articles on VR design best practices, including on user input
    ([https://developer.oculus.com/design/latest/concepts/bp-userinput/](https://developer.oculus.com/design/latest/concepts/bp-userinput/))
    which includes recommendations on movement, button mapping, menus, and using your
    hands in VR.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oculus的一系列关于VR设计最佳实践的文章，包括用户输入（[https://developer.oculus.com/design/latest/concepts/bp-userinput/](https://developer.oculus.com/design/latest/concepts/bp-userinput/）），其中包括关于移动、按钮映射、菜单以及在VR中使用双手的建议。
- en: Leap Motion (we do not cover its hand-recognition technology in this book) has
    some great writings on VR design, which can be found at [https://developer.leapmotion.com/explorations](https://developer.leapmotion.com/explorations),
    including very good articles on interactive design ([http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/](http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/))
    and user Interface Design ([http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/](http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/)).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Leap Motion（我们在这本书中不涵盖其手部识别技术）在VR设计方面有一些优秀的作品，可以在[https://developer.leapmotion.com/explorations](https://developer.leapmotion.com/explorations)找到，包括关于交互设计的优秀文章（[http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/](http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/)）和用户界面设计（[http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/](http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/)）。
- en: 'Google has produced a number of seminal examples, including *Daydream Labs:
    Lessons Learned from VR Prototyping - Google I/O 2016* ([https://www.youtube.com/watch?v=lGUmTQgbiAY](https://www.youtube.com/watch?v=lGUmTQgbiAY))
    and Daydream Elements ([https://developers.google.com/vr/elements/overview](https://developers.google.com/vr/elements/overview)).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '谷歌产生了一系列开创性的例子，包括*Daydream Labs: 从VR原型中学习到的经验 - Google I/O 2016*（[https://www.youtube.com/watch?v=lGUmTQgbiAY](https://www.youtube.com/watch?v=lGUmTQgbiAY)）和Daydream
    Elements（[https://developers.google.com/vr/elements/overview](https://developers.google.com/vr/elements/overview)）。'
- en: Of course, this just scratches the surface; more is being published every day.
    Google it. A curated, living list of resources on user Interface Design and user
    experience in virtual reality can be found at The UX of VR site ([https://www.uxofvr.com/](https://www.uxofvr.com/)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这仅仅触及了表面；每天都有更多内容被发布。谷歌搜索一下。关于虚拟现实用户界面设计和用户体验的资源列表，可以在The UX of VR网站上找到（[https://www.uxofvr.com/](https://www.uxofvr.com/))。
- en: Have fun reading and watching videos. Meanwhile, let's get back to work. It's
    time to implement some VR UI ourselves.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 享受阅读和观看视频的乐趣。同时，让我们回到工作中。是时候我们自己实现一些VR UI了。
- en: A reusable default canvas
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个可重用的默认画布
- en: Unity's UI canvas provides lots of options and parameters to accommodate the
    kinds of graphical layout flexibility that we have come to expect not only in
    games but also from web and mobile apps. With this flexibility comes additional
    complexity. To make our examples in this chapter easier, we'll first build a reusable
    prefab canvas that has our preferred default settings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的UI画布提供了许多选项和参数，以适应我们在游戏、网页和移动应用中期望的图形布局灵活性。这种灵活性带来了额外的复杂性。为了使本章的示例更容易理解，我们首先将构建一个可重用的预制画布，它具有我们首选的默认设置。
- en: 'Create a new canvas and change its Render Mode to world space as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的画布，并将其渲染模式更改为如下所示：
- en: Navigate to GameObject | UI | Canvas
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到GameObject | UI | Canvas
- en: Rename the canvas as `DefaultCanvas`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布重命名为`DefaultCanvas`
- en: Set Render Mode to World Space
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置渲染模式为世界空间
- en: 'The Rect Transform component defines the grid system on the canvas itself,
    like the lines on a piece of graph paper. It is used for the placement of UI elements
    on the canvas. Set it to a convenient `640 x 480`, with a `0.75` aspect ratio.
    The `Rect Transform` component''s width and height are different from the world
    space size of the canvas in our scene. Let''s configure the `Rect Transform` component
    using the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Rect Transform组件定义了画布本身的网格系统，就像一张图表纸上的线条。它用于在画布上放置UI元素。将其设置为方便的`640 x 480`，具有`0.75`的纵横比。`Rect
    Transform`组件的宽度和高度与场景中画布的世界空间大小不同。让我们按照以下步骤配置`Rect Transform`组件：
- en: In `Rect Transform`, set the Width to `640` and the Height to `480`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rect Transform`中，将宽度设置为`640`，高度设置为`480`。
- en: In Scale, set X, Y, Z to (`0.00135`, `0.00135`, `0.00135`). This is the size
    for one of our pixels in world space units.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在缩放中，将X、Y、Z设置为(`0.00135`、`0.00135`、`0.00135`)。这是我们在世界空间单位中一个像素的大小。
- en: Now, position the canvas centered on the ground plane one unit above
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将画布定位在地面平面上方一个单位处，使其居中
- en: (`0.325` is half of `0.75`). In Rect Transform, set Pos X, Pos Y, Pos Z to (`0`,
    `1.325`, `0`).
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (`0.325`是`0.75`的一半)。在Rect Transform中，将Pos X、Pos Y、Pos Z设置为(`0`、`1.325`、`0`)。
- en: 'Next, we will add an empty `Image` element (with a white background) to help
    us visualize the otherwise transparent canvas and provide an opaque background
    for the canvas when we need one (we can also use a `Panel` UI element):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个空的`Image`元素（具有白色背景），以帮助我们可视化其他情况下透明的画布，并在需要时为画布提供一个不透明的背景（我们还可以使用`Panel`
    UI元素）：
- en: With `DefaultCanvas` selected, navigate to GameObject | UI | Image (ensure that
    it's created as a child of `DefaultCanvas`; if not, move it under `DefaultCanvas`).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DefaultCanvas`后，导航到GameObject | UI | Image（确保它作为`DefaultCanvas`的子项创建；如果不是，将其移动到`DefaultCanvas`下）。
- en: 'With the Image selected, on the upper left of its Rect Transform pane, there
    is an anchor presets button (shown in the following screenshot). Selecting it
    opens the anchor presets dialog box. Press and hold the *Alt* key to see the stretch
    and position options and choose the one in the bottom-right corner (stretch-stretch).
    Now, the (blank) image is stretched to fill the canvas:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Image后，在其Rect Transform面板的右上角有一个锚点预设按钮（如下面的截图所示）。选择它将打开锚点预设对话框。按住*Alt*键以查看拉伸和位置选项，并选择右下角的选项（拉伸-拉伸）。现在，（空白）图像被拉伸以填充画布：
- en: '![](img/30581c97-e971-45aa-b2c7-659a16919233.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30581c97-e971-45aa-b2c7-659a16919233.png)'
- en: 'Double-check your Image settings based on the default properties for the `Image`
    child of the `DefaultCanvas` as shown in the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下截图所示的`DefaultCanvas`的`Image`子项的默认属性，双重检查您的图像设置：
- en: '![](img/a4dd46fa-cc81-4550-975d-d633cb720423.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4dd46fa-cc81-4550-975d-d633cb720423.png)'
- en: 'Add a `Text` element with useful default settings, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个具有有用默认设置的`Text`元素，如下所示：
- en: With `DefaultCanvas` selected, navigate to GameObject | UI | Text (ensure that
    it's created as a child of `DefaultCanvas` (if not, move it under `DefaultCanvas`).
    The words `New Text` should appear on the canvas.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中`DefaultCanvas`后，导航到GameObject | UI | Text（确保它作为`DefaultCanvas`的子组件创建，如果不是，将其移动到`DefaultCanvas`下）。应该在画布上出现`New
    Text`字样。
- en: With the Text selected, set Alignment to Center Align and Middle Align and set
    Vertical Overflow to Overflow. Set the Scale to (`4`, `4`, `4`).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中文本后，设置对齐为居中对齐和中间对齐，并将垂直溢出设置为溢出。将缩放设置为（`4`，`4`，`4`）。
- en: Set its anchor presets button to (stretch - stretch) using the widget on the
    upper left of its Rect Transform pane.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其矩形变换面板左上角的控件，将它的锚点预设按钮设置为（拉伸 - 拉伸）。
- en: 'Double-check your Text settings based on the default properties for the `Text`
    child of the `DefaultCanvas` as shown in the following screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下截图所示的`DefaultCanvas`的`Text`子组件的默认属性，仔细检查你的文本设置：
- en: '![](img/557031b9-4219-4617-b50e-58112722f0fc.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/557031b9-4219-4617-b50e-58112722f0fc.png)'
- en: Increase the pixel resolution to give cleaner text fonts by keeping `DefaultCanvas`
    selected and setting the Canvas Scaler | Dynamic Pixels Per Unit to `10`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持`DefaultCanvas`选中状态并设置Canvas Scaler | Dynamic Pixels Per Unit为`10`来提高像素分辨率，以获得更清晰的文字字体。
- en: 'Finally, save your work as a prefab asset that you can reuse throughout the
    chapter in the following manner:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将你的工作保存为一个预制体资产，你可以在本章中以以下方式重复使用：
- en: If necessary, in Project Assets, create a new folder named `Prefabs`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在项目资产中创建一个名为`Prefabs`的新文件夹。
- en: Drag the `DefaultCanvas` object into the `Project Assets/Prefabs` folder to
    create a prefab.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DefaultCanvas`对象拖动到`Project Assets/Prefabs`文件夹中，以创建一个预制体。
- en: Delete the `DefaultCanvas` instance in the Hierarchy panel now.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请在层级面板中删除`DefaultCanvas`实例。
- en: OK, glad we got that out of the way! Now we can use the `DefaultCanvas` prefab
    with different VR user interfaces.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很高兴我们已经解决了这个问题！现在我们可以使用`DefaultCanvas`预制体，配合不同的VR用户界面。
- en: A canvas has a `Rect Transform` component, which defines the grid system on
    the canvas itself, like the lines on a piece of graph paper. It is used for the
    placement of UI elements on the canvas. This is different from the size and position
    of a canvas object in world space.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个画布有一个`Rect Transform`组件，它定义了画布本身的网格系统，就像一张图表纸上的线条。它用于在画布上放置UI元素。这与画布对象在世界空间中的大小和位置不同。
- en: Visor HUD
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视窗HUD
- en: A heads-up display, or HUD, is a floating canvas in your field of view that
    overlays the gameplay scene. In VR vernacular, there are two variations of HUDs.
    I'll call these variations the *visor HUD* and the *windshield HUD*. This section
    looks at the first one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 头戴式显示器，或称HUD，是你视野中一个浮动的画布，覆盖在游戏场景之上。在VR术语中，有两种HUD变体。我将把这些变体称为*视窗HUD*和*挡风玻璃HUD*。本节将探讨第一种。
- en: In visor HUD, the UI canvas is attached to the camera. It doesn't appear to
    respond to your head movement. When you move your head, it appears to be *stuck
    to your face*. Let's look at a nicer way of visualizing it. Suppose you're wearing
    a helmet with a visor, and the UI appears projected onto the surface of that visor.
    There may be contexts where this is OK in virtual reality, but it is likely to
    break the sense of immersion. So, it should generally only be used either when
    the visor is a part of the gameplay, or if the intent is to take you out of the
    scene, such as the utility menus for the hardware or the system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在视窗HUD中，UI画布连接到相机上。它似乎不会对你的头部运动做出反应。当你移动头部时，它看起来像是*粘在你的脸上*。让我们看看一种更直观的展示方式。假设你戴着一顶带有视窗的头盔，UI看起来像是投射在那个视窗的表面上。在虚拟现实中，可能有些情况下这是可以接受的，但它很可能会破坏沉浸感。因此，通常只有在视窗是游戏的一部分，或者意图是将你从场景中移出时（例如硬件或系统的实用程序菜单），才应该使用它。
- en: 'Let''s make a visor HUD with a welcome message as follows, and see for ourselves
    how it feels:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有欢迎信息的视窗HUD，如下所示，并亲自感受一下它的感觉：
- en: In the Hierarchy panel, unfold the `MeMyselfEye` object and then drill down
    to the `Main Camera` object (for OpenVR that might be  `[CameraRig]/Camera (head)`;
    for Daydream, it may be  `Player/Main Camera/`).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级面板中，展开`MeMyselfEye`对象，然后深入到`Main Camera`对象（对于OpenVR可能是`[CameraRig]/Camera
    (head)`；对于Daydream，可能是`Player/Main Camera/`）。
- en: From the Project panel, drag the `DefaultCanvas` prefab onto the camera object
    so that it becomes a child of it.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，将`DefaultCanvas`预制体拖动到相机对象上，使其成为其子对象。
- en: In the Hierarchy panel, with the canvas selected, rename the canvas to `VisorCanvas`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级面板中，选择画布后，将其重命名为`VisorCanvas`。
- en: In the Inspector panel for the canvas, change the `Rect Transform` component's
    Pos X, Pos Y, Pos Z to (`0`, `0`, `1`).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布的检查器面板中，将矩形变换组件的Pos X、Pos Y、Pos Z更改为（`0`，`0`，`1`）。
- en: Unfold `VisorCanvas` and select the child `Text` object.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开视场显示器画布并选择其子`Text`对象。
- en: In the Inspector panel, change the text from Default Text to Welcome! My reality
    is your reality. (You can enter line breaks in the input text area.)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，将文本从默认文本更改为欢迎！我的现实是你的现实。（你可以在输入文本区域中输入换行符。）
- en: Change the text color to something bright, such as green.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本颜色更改为鲜艳的颜色，例如绿色。
- en: Disable the `Image` object so that only the text shows by unchecking its Enable
    checkbox in Inspector.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用`Image`对象，通过在检查器中取消选中其启用复选框，使仅显示文本。
- en: Save the scene, and try it in VR.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景，并在VR中尝试。
- en: 'Here''s a capture of the Rift screen with the `VisorCanvas`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有`VisorCanvas`的Rift屏幕截图：
- en: '![](img/512268e3-f19f-45ff-b3d6-ecd174a0e94a.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/512268e3-f19f-45ff-b3d6-ecd174a0e94a.png)'
- en: In VR, when you move your head around, the text follows along as if it's attached
    to a visor in front of your face.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，当你四处移动头部时，文本会跟随移动，就像它被附着在你脸前的视场显示器上一样。
- en: A visor HUD canvas and reticle cursor canvas are set as a child object of the
    camera.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 视场显示器（HUD）画布和瞄准十字准星光标画布被设置为相机的子对象。
- en: Now, go ahead and either disable `VisorCanvas` or just delete it (in the Hierarchy
    panel, right-click on it and click on Delete) because we're going to display the
    welcome message in a different way in a later section. Next, we'll look at a different
    application of this technique.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续禁用`VisorCanvas`或直接删除它（在层次结构面板中，右键单击它并单击删除），因为我们将在稍后的部分以不同的方式显示欢迎信息。接下来，我们将查看这种技术的另一种应用。
- en: The reticle cursor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瞄准十字准星光标
- en: 'A variant of the visor HUD that is essential in first-person shooter games
    is a *reticle* or crosshair cursor. The analogy here is that you''re looking through
    a gun-sight or an eyepiece (rather than a visor) and your head movement is moving
    in unison with the gun or turret itself. You can do this with a regular game object
    (for example, Quad + texture image), but this chapter is about UI. So, let''s
    use our canvas, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称射击游戏中至关重要的视场显示器（HUD）变体是*瞄准十字准星*或交叉线光标。这里的类比是你通过枪口或目镜（而不是视场显示器）观察，你的头部移动与枪或炮塔本身同步。你可以使用一个常规游戏对象（例如，四边形+纹理图像）来做这件事，但本章是关于用户界面（UI）。所以，让我们使用我们的画布，如下所示：
- en: Find your Main Camera object in the Hierarchy panel as we did previously.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中找到我们之前提到的主相机对象。
- en: From the Project panel, drag the `DefaultCanvas` prefab onto the camera object
    so that it becomes a child of the camera. Name it `ReticleCursor`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，将`DefaultCanvas`预制件拖放到相机对象上，使其成为相机的子对象。将其命名为`ReticleCursor`。
- en: Set the Rect Transform component's Pos X, Pos Y, Pos Z to (`0`, `0`, `1`).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩形变换组件的Pos X、Pos Y、Pos Z设置为（`0`，`0`，`1`）。
- en: Delete its child objects: `Image` and `Text`. This will *break* the prefab association;
    that's OK.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除其子对象：`Image`和`Text`。这将*破坏*预制件关联；这是可以的。
- en: Add a raw image child by selecting it from the main menu bar, navigating through
    GameObject | UI | Raw Image and making sure that it's a child of `ReticleCursor`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从主菜单栏中选择它，通过GameObject | UI | Raw Image导航，并确保它是`ReticleCursor`的子对象，添加一个原始图像子对象。
- en: In the Raw Image panel's Rect Transform, set Pos X, Pos Y, Pos Z to (`0`, `0`,
    `0`) and the Width and Height to (`22`, `22`). Then, choose a noticeable Color
    such as red in the Raw Image (Script) properties.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原始图像面板的矩形变换中，将Pos X、Pos Y、Pos Z设置为（`0`，`0`，`0`）并将宽度和高度设置为（`22`，`22`）。然后，在原始图像（脚本）属性中选择一个明显的颜色，例如红色。
- en: Save the scene and try it in VR.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并在VR中尝试。
- en: If you'd like a nicer-looking reticle, in the Raw Image (Script) properties,
    populate the Texture field with a cursor image. For example, click on the tiny
    *circle* icon on the far right of the Texture field. This opens the Select Texture
    dialog. Find and select a suitable one, such as the `Crosshair` image. (A copy
    of `Crosshair.gif` is included with this book.) Just be sure to change the Width
    and Height to the size of your image (`Crosshair.gif` is 22 x 22 in size) and
    ensure that the Anchor is set to middle-center.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个看起来更好的瞄准十字准星，在原始图像（脚本）属性中，将纹理字段填充为光标图像。例如，点击纹理字段最右侧的微小*圆形*图标。这会打开选择纹理对话框。找到并选择一个合适的图像，例如`Crosshair`图像。（本书附带`Crosshair.gif`的副本。）只需确保将宽度和高度更改为你的图像大小（`Crosshair.gif`的大小为22
    x 22）并确保锚点设置为中间中心。
- en: We set the canvas position Pos Z to `1.0` so that the reticle floats in front
    of you at a 1-meter distance. A fixed distance cursor is fine in many UI situations,
    like when you're picking something from a flat canvas that is also at a fixed
    distance from you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将画布位置Pos Z设置为`1.0`，这样十字准线就会在你前方1米处浮动。在许多UI场景中，固定距离的光标就足够了，比如当你从距离你固定的平面上选择某个东西时。
- en: However, this is world space. If another object is between you and the reticle,
    the reticle will be obfuscated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是世界空间。如果你和十字准线之间有另一个对象，十字准线将被遮挡。
- en: 'Also, if you look at something much farther away, you''ll refocus your eyes
    and have trouble viewing the cursor at the same time. To emphasize this problem,
    try moving the cursor closer. For example, if you change the Pos Z of the `ReticleCursor`
    to `0.5` or less, you might have to go cross-eyed to see it! To compensate for
    these issues, we can ray cast and move the cursor to the actual distance of the
    object that you''re looking at, resizing the cursor accordingly so that it appears
    to stay the same size. Here''s a cheap version of this idea:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你看得很远的东西，你会重新聚焦你的眼睛，同时看清楚光标会有困难。为了强调这个问题，尝试将光标移近。例如，如果你将`ReticleCursor`的Pos
    Z改为`0.5`或更小，你可能需要眯着眼睛才能看到它！为了补偿这些问题，我们可以进行射线投射并将光标移动到你所看对象的实际距离，相应地调整光标大小，使其看起来保持相同的大小。这是这个想法的一个简单版本：
- en: With `ReticleCursor` selected, click on Add Component | New Script, name it
    `CursorPositioner` and click on Create and Add.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`ReticleCursor`后，点击添加组件 | 新脚本，将其命名为`CursorPositioner`，然后点击创建并添加。
- en: Open the script in MonoDevelop by double-clicking on the name.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击名称在MonoDevelop中打开脚本。
- en: 'Here''s the `CursorPositioner.cs` script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`CursorPositioner.cs`脚本：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Rect Transform component's Pos Z is found in the script in `transform.localPosition`.
    This script changes it to `hit.distance` if it's less than the given Pos Z. Now,
    you can also move the reticle to a more comfortable distance, such as Pos Z =
    `2`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形变换组件的Pos Z在脚本中的`transform.localPosition`中找到。如果它小于给定的Pos Z，则该脚本将其更改为`hit.distance`。现在，你也可以将十字准线移动到一个更舒适的距离，例如Pos
    Z = `2`。
- en: 'An excellent tutorial by `@eVRydayVR` shows how to implement both distance
    and size compensated world space reticles. You can visit [https://www.youtube.com/watch?v=LLKYbwNnKDg](https://www.youtube.com/watch?v=LLKYbwNnKDg),
    which is a video titled Oculus Rift DK2 - Unity Tutorial: Reticle.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由`@eVRydayVR`编写的一个优秀的教程展示了如何实现距离和尺寸补偿的世界空间十字准线。您可以访问[https://www.youtube.com/watch?v=LLKYbwNnKDg](https://www.youtube.com/watch?v=LLKYbwNnKDg)，这是一个名为Oculus
    Rift DK2 - Unity教程：十字准线的视频。
- en: We just implemented our own cursor reticle, but many VR SDKs now also provide
    cursors. For example, in Google VR, the `GvrReticlePointer.cs` script is a more
    thorough implementation. Another example, the Oculus OVR package, includes a `Cursor_Timer`
    prefab you can use as a Loading... indicator cursor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现了自己的光标十字准线，但现在许多VR SDK也提供了光标。例如，在Google VR中，`GvrReticlePointer.cs`脚本是一个更全面的实现。另一个例子，Oculus
    OVR包包括一个`Cursor_Timer`预制件，你可以将其用作加载...指示光标。
- en: The windshield HUD
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挡风玻璃HUD
- en: The term *heads-up display*, or HUD, originates from its use in aircrafts, where
    a pilot is able to view information with their head positioned in such a way that
    they are looking forward rather down at their instrument panels. Owing to this
    usage, I'll refer it as *windshield HUD*. Like visor HUD, the information panel
    overlays the gameplay, but it isn't attached to your head. Instead, you can think
    of it as being attached to your seat while you are in a cockpit or at the dentist.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*抬头显示*（HUD）起源于其在飞机上的使用，飞行员能够以头部向前而不是向下看仪表板的方式查看信息。由于这种用法，我将它称为*挡风玻璃HUD*。像头盔HUD一样，信息面板覆盖了游戏玩法，但它并没有附着在你的头上。相反，你可以将其视为在你坐在驾驶舱或牙医椅上时附着在你的座位上。
- en: A visor HUD is like the UI canvas—it is attached to your head. A windshield
    HUD is like it's attached to a glass dome around you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 头盔HUD就像UI画布一样——它附着在你的头上。挡风玻璃HUD就像它附着在你周围的玻璃穹顶上。
- en: 'Let''s create a simple windshield HUD by performing the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建一个简单的挡风玻璃HUD：
- en: From the Project panel, drag the `DefaultCanvas` prefab onto the `MeMyselfEye`
    object in the Hierarchy panel so that it becomes an immediate child of `MeMyselfEye` (not
    under the camera this time).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，将`DefaultCanvas`预制件拖动到层次结构面板中的`MeMyselfEye`对象上，使其成为`MeMyselfEye`的直接子对象（这次不在相机下）。
- en: Rename it to `WindshieldCanvas`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`WindshieldCanvas`。
- en: With `WindshieldCanvas` selected, set the Rect Transform component's Pos X,
    Pos Y, Pos Z to (`0`, `1.4`, `1`).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`WindshieldCanvas`后，将Rect Transform组件的Pos X、Pos Y、Pos Z设置为（`0`，`1.4`，`1`）。
- en: Now, we'll set the Text component. With Text under `WindshieldCanvas` selected,
    change the text to Welcome! My reality is your reality. Also, change the color
    to something bright, such as green.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置文本组件。在`WindshieldCanvas`下选择`Text`，将文本改为“欢迎！我的现实即是你的现实。”同时，将颜色改为鲜艳的颜色，例如绿色。
- en: This time, we'll make the panel translucent. Select the image from Image under
    `WindshieldCanvas` and select its color swatch. Then in the Color dialog, modify
    the `Alpha ("A")` channel from `255` to about `115`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们将使面板半透明。从`WindshieldCanvas`下的图像中选择图像，并选择其颜色样本。然后在颜色对话框中，将`Alpha ("A")`通道从`255`修改到大约`115`。
- en: 'That''s pretty straightforward. When you view it in VR, the canvas starts out
    just in front of you, but as you look around, its position seems to remain stationary
    and relative to the other objects in the scene, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。当你通过VR查看时，画布最初就在你面前，但随着你四处张望，它的位置似乎保持静止，并相对于场景中的其他对象，如以下截图所示：
- en: '![](img/88d319a4-a884-45a7-9cfa-910a8123244b.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/88d319a4-a884-45a7-9cfa-910a8123244b.png)'
- en: 'As we''ll see in the next chapter, [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml),
    *Locomotion and Comfort*, when a first-person character moves through the scene,
    the HUD canvas will stay in front of you, at the same relative position to your
    body object, `MeMyselfEye`. You can try it now in the editor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下一章（第7章）[第7章](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml)中将要看到的，*运动与舒适*，当一个第一人称角色在场景中移动时，HUD画布将保持在你的面前，相对于你的身体对象`MeMyselfEye`的相同相对位置。你现在可以在编辑器中尝试它：
- en: Select `MeMyselfEye` in Hierarchy.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`MeMyselfEye`。
- en: Press Play.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放。
- en: Then in the Scene window, using the Move gizmo, move the `MeMyselfEye` position.
    In VR, you'll see the HUD follows along like it's part of your body or a spaceship's
    cockpit.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在场景窗口中，使用移动工具，移动`MeMyselfEye`的位置。在VR中，你会看到HUD（抬头显示）就像是你身体的一部分或宇宙飞船的驾驶舱一样跟随移动。
- en: You might have realized that it's possible for objects in the scene to obfuscate
    the HUD panel since they're all occupying the same world space. If you need to
    prevent this, you have to ensure that the canvas is always rendered last so that
    it appears in front of any other objects regardless of its position in 3D space.
    In a conventional monoscopic game, you can do this by adding a second camera for
    the UI and changing its render priority. In stereoscopic VR, you have to accomplish
    this differently, possibly by writing a custom shader for your UI object or doing
    per-layer occlusion culling. This is an advanced topic; see the *World Space canvas
    on top of everything*? discussion thread for details: [https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html](https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到场景中的对象可能会遮挡HUD面板，因为它们都占据了相同的世界空间。如果你需要防止这种情况，你必须确保画布总是最后渲染，这样它就会出现在任何其他对象的前面，无论其在3D空间中的位置如何。在一个传统的单视角游戏中，你可以通过添加第二个用于UI的相机并更改其渲染优先级来实现这一点。在立体VR中，你必须以不同的方式完成这项任务，可能需要为你的UI对象编写自定义着色器或进行每层遮挡剔除。这是一个高级话题；有关详细信息，请参阅*World
    Space canvas on top of everything*？讨论线程：[https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html](https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html)。
- en: A variant of this HUD is to turn the canvas so that it's always facing you,
    while its position in 3D space is fixed. See the *Info bubble* section of this
    chapter to learn how to code this.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种HUD的一个变体是将画布旋转，使其始终面向你，同时其3D空间中的位置保持固定。参见本章的*信息气泡*部分，了解如何编写此代码。
- en: 'For kicks, let''s write a script that removes the welcome message canvas after
    15 seconds, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，让我们编写一个脚本，在15秒后移除欢迎信息画布，如下所示：
- en: With `WindshieldCanvas` selected, click on Add Component | New Script, name
    the script as `DestroyTimeout`, and click on Create and Add.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`WindshieldCanvas`后，点击添加组件 | 新脚本，将脚本命名为`DestroyTimeout`，然后点击创建并添加。
- en: Open the script in MonoDevelop.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MonoDevelop中打开脚本。
- en: 'Here''s the `DestroyTimeout.cs` script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DestroyTimeout.cs`脚本：
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `WindshieldCanvas` will disappear after the timer runs out when the game
    starts up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏启动时，计时器结束后`WindshieldCanvas`将消失。
- en: A windshield HUD canvas is set as a child object of the first-person avatar,
    a sibling object of the camera.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 风挡HUD画布被设置为第一人称角色的子对象，相机的同级对象。
- en: In this example, we start to move further towards a first-person experience.
    Imagine sitting in a car or the cockpit of an aircraft. The HUD is projected on
    the windshield in front of you, but you're free to move your head to look around.
    In the scene's Hierarchy panel, there's a first-person object (`MeMyselfEye`)
    that contains the camera rig, possibly your avatar body, and the other furnishings
    surrounding you. When the vehicle moves in the game, the entire cockpit moves
    in unison, including the camera rig and the windshield. We'll work with this more
    later in this chapter and [Chapter 7](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing with Physics and Fire*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们开始向第一人称体验迈进。想象一下坐在一辆车或飞机的驾驶舱里。你的抬头显示（HUD）投影在你前面的挡风玻璃上，但你可以自由地转动你的头四处张望。在场景的层次结构面板中，有一个第一人称对象（`MeMyselfEye`），其中包含相机装置，可能是你的角色身体，以及你周围的其它装饰。当车辆在游戏中移动时，整个驾驶舱会一起移动，包括相机装置和挡风玻璃。我们将在本章和第7章[第7章](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml)，*玩转物理和火焰*中进一步探讨这一点。
- en: The game element UI
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏元素 UI
- en: 'When Ethan gets killed in the Diorama scene from [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, the score value in the `GameController` object''s `KillTarget`
    script is updated, but we don''t show the current score to the player (set up
    in that chapter). We''ll do this now, adding a scoreboard into the scene at the
    top-left corner of the backdrop `PhotoPlane` image:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当埃森在第四章的迪奥拉玛场景中被杀时，[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)，*基于注视的控制*，`GameController`
    对象的 `KillTarget` 脚本中的分数值被更新，但我们没有向玩家（在第4章中设置）显示当前分数。我们现在将这样做，在背景图像 `PhotoPlane`
    的右上角添加一个记分板：
- en: From the Project panel, drag the `DefaultCanvas` prefab directly into the Scene
    view
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，将 `DefaultCanvas` 预制体直接拖放到场景视图中
- en: Rename it `ScoreBoard`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `ScoreBoard`
- en: With `ScoreBoard` selected, set the Rect Transform component's Pos X, Pos Y, Pos
    Z to (`-2.8`, `7`, `4.9`) and the Width and Height to (`3000`, `480`)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ScoreBoard`，将矩形变换组件的 Pos X、Pos Y、Pos Z 设置为（`-2.8`、`7`、`4.9`），并将 Width 和
    Height 设置为（`3000`、`480`）
- en: With Text under `ScoreBoard` selected, set the Font Size to `100` and choose
    a noticeable color such as red for the Text
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ScoreBoard` 下的 Text，将字体大小设置为 `100` 并选择一个醒目的颜色，如红色
- en: 'Enter the Score: 0 sample string for Text'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本中输入分数：0 示例字符串
- en: Disable Image under `ScoreBoard` by unchecking the Enable check box or deleting
    it
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过取消选中启用复选框或删除它来禁用 `ScoreBoard` 下的图像
- en: 'We have added another canvas to the scene, sized and placed it where we want,
    and formatted the text for display. It should look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在场景中添加了另一个画布，将其大小和位置设置为我们想要的位置，并格式化文本以进行显示。它应该看起来像这样：
- en: '![](img/21c97363-120f-4523-86bb-e4315d89b258.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21c97363-120f-4523-86bb-e4315d89b258.png)'
- en: 'Now, we need to update the `KillTarget.cs` script, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 `KillTarget.cs` 脚本，如下所示：
- en: 'We may be using the UnityEngine UI classes:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能正在使用 UnityEngine UI 类：
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a public variable for `scoreText`:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `scoreText` 添加一个公共变量：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a line to `Start()` to initialize the score text:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Start()` 中添加一行代码以初始化分数文本：
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And add a line to `Update()` to change the score text when the score changes:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Update()` 方法中添加一行代码以更改分数文本，当分数变化时：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After saving the script file, go back into the Unity editor, select `GameController`
    in the Hierarchy panel, and then drag and drop the Text object under `ScoreBoard`
    from Hierarchy onto the Score Text field in Kill Target (Script).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本文件后，返回到 Unity 编辑器，在层次结构面板中选择 `GameController`，然后将层次结构中的 `ScoreBoard` 下的
    Text 对象拖放到 `Kill Target (Script)` 中的分数文本字段。
- en: Run the scene in VR. Each time you kill Ethan (by staring at him), your score
    will be updated on the `ScoreBoard` on the upper left of `PhotoPlane`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VR 中运行场景。每次你通过注视埃森（通过注视他）杀死他时，你的分数都会在 `PhotoPlane` 上方的 `ScoreBoard` 上更新。
- en: A game element UI canvas is a part of the scene like any other game object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏元素 UI 画布就像任何其他游戏对象一样是场景的一部分。
- en: This was an example of using an object that's a part of the scene for information
    display. Our example is pretty simplistic. You might want to make a nicer modeled
    scoreboard, like the one you'd see in a stadium or something. The point is, it's
    a part of the scene and to see the message you might have to actually turn your
    head and, well, look at it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用场景中物体作为信息显示的例子。我们的例子相当简单。你可能想要制作一个更漂亮的模型记分板，就像你在体育场或类似的地方看到的那样。关键是，它是场景的一部分，要看到信息，你可能实际上需要转动你的头，然后，嗯，看看它。
- en: Using TextMeshPro
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TextMeshPro
- en: 'To make a billboard glow like a neon sign, you can use TextMesh Pro which presently
    comes included free with Unity. For instance:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使广告牌像霓虹灯一样发光，你可以使用TextMesh Pro，它目前免费包含在Unity中。例如：
- en: With `ScoreBoard` selected in Hierarchy, create a new `TextMesh` text element
    (right-click UI | TextMeshPro - Text).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`ScoreBoard`，创建一个新的`TextMesh`文本元素（右键点击UI | TextMeshPro - Text）。
- en: This replaces our standard UI text element, so disable the `Text` object.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将替换我们的标准UI文本元素，因此请禁用`Text`对象。
- en: On the TMP text, set its Font Asset to Bangers SDF.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TMP文本上，将其字体资产设置为Bangers SDF。
- en: For its Material Preset, use Bangers SDF Glow.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其材质预设，请使用Bangers SDF Glow。
- en: Scroll to Glow settings to adjust the colors and other settings as you desire.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到发光设置以调整颜色和其他设置，如你所愿。
- en: You can even write a script that cyclically modifies the glow settings to make
    a flashing, glowing sign!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以编写一个脚本，循环修改发光设置，制作一个闪烁的发光标志！
- en: 'If you choose to try this, be sure to update the GameController''s `KillTarget`
    script to use the TMP object rather than the UI one. `Modify KillTarget.cs` as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择尝试这个，请确保更新GameController的`KillTarget`脚本来使用TMP对象而不是UI对象。`Modify KillTarget.cs`如下：
- en: 'We may be using the UnityEngine TextMesh Pro classes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会使用UnityEngine TextMesh Pro类：
- en: '[PRE6]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the data type of the `scoreText` variable with `TMP_Text`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将`scoreText`变量的数据类型替换为`TMP_Text`：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Drag the TMP text item onto the slot in the Inspector. The rest of the script
    is unchanged since `TMP_Text` has a `text` property just as the UI text one has.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将TMP文本项拖放到检查器中的槽位。脚本的其他部分保持不变，因为`TMP_Text`具有与UI文本相同的`text`属性。
- en: '**TextMesh Pro** is a great tool for text formatting and layout in Unity. It
    is a replacement for Unity''s UI Text, with added advanced text rendering, custom
    shaders, typographic controls such as paragraph spacing and kerning, and a lot
    more. It was a third-party plugin and is now included free with Unity. Documentation
    can be found here: [http://digitalnativestudios.com/textmeshpro/docs/.](http://digitalnativestudios.com/textmeshpro/docs/)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMesh Pro**是Unity中用于文本格式化和布局的强大工具。它是Unity UI Text的替代品，增加了高级文本渲染、自定义着色器、排版控制（如段落间距和字距调整）等。它最初是一个第三方插件，现在免费包含在Unity中。文档可以在以下位置找到：[http://digitalnativestudios.com/textmeshpro/docs/](http://digitalnativestudios.com/textmeshpro/docs/)'
- en: 'Here is a screenshot of the scoreboard text using a glow effect with TextMesh
    Pro and its Inspector settings:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用TextMesh Pro和其检查器设置应用发光效果的分数板文本的截图：
- en: '![](img/47a19eb5-82ed-4e7b-8838-cb785582e14e.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47a19eb5-82ed-4e7b-8838-cb785582e14e.png)'
- en: Info bubble
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息气泡
- en: In a comic book, when a character says something, it's shown in a *speech bubble*.
    In many online social VR worlds, participants are represented by avatars and,
    hovering above someone's avatar, their name is displayed. I'll call this type
    of user interface an *info bubble*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在漫画书中，当一个角色说话时，它会在一个*话泡*中显示。在许多在线社交VR世界中，参与者由头像表示，并且他们的名字会显示在某个人的头像上方。我将这种类型用户界面称为*信息气泡*。
- en: Info bubbles are located in world space at a specific 3D position, but the canvas
    should always be facing the camera. We can ensure this with a script.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 信息气泡位于世界空间中的特定3D位置，但画布应始终面向相机。我们可以通过脚本确保这一点。
- en: 'In this example, we''ll display the X, Z location of the `WalkTarget` object
    (set up in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*), controlled by the `LookMoveTo.cs` script. To add the info bubble, perform
    the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将显示由`LookMoveTo.cs`脚本控制的`WalkTarget`对象的X、Z位置（在[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)，*基于注视的控制*中设置），添加信息气泡的步骤如下：
- en: From the Project window, drag the `DefaultCanvas` prefab directly into the Hierarchy
    window so that it's a child of `WalkTarget`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目窗口，将`DefaultCanvas`预制体直接拖放到层次结构窗口，使其成为`WalkTarget`的子项。
- en: Rename it to `InfoBubble`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`InfoBubble`。
- en: With `InfoBubble` selected, set the Rect Transform component's Pos X, Pos Y,
    Pos Z to (`0`, `0.2`, `0`).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`InfoBubble`后，将Rect Transform组件的Pos X、Pos Y、Pos Z设置为(`0`, `0.2`, `0`)。
- en: With Text under `InfoBubble` selected, set the Rect Transform component's Pos
    X, Pos Y, Pos Z to (`0`, `0`, `0`) and Right and Bottom to `0`, `0`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`InfoBubble`下的文本，将Rect Transform组件的Pos X、Pos Y、Pos Z设置为(`0`, `0`, `0`)，并将Right和Bottom设置为`0`,
    `0`。
- en: With Image under `InfoBubble` selected, set Scale to (`0.7`, `0.2`, `1`).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InfoBubble`下选择Image，将缩放设置为(`0.7`, `0.2`, `1`)。
- en: Enter the `X:00.00`, `Z:00.00` sample string for Text.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文本输入`X:00.00`, `Z:00.00`样本字符串。
- en: Verify that the canvas and text look roughly the right size and position and
    adjust the text as you please. (In my scene, there's a cube at the origin so I
    temporarily disable it to see the WalkTarget also at the origin.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确认画布和文本的大小和位置大致正确，并按需调整文本。（在我的场景中，原点处有一个立方体，所以我暂时禁用它以查看也位于原点的WalkTarget。）
- en: 'Now, we will modify the `LookMoveTo.cs` script to show the current `WalkTarget` X,
    Z position. Open the script in the MonoDevelop editor and add the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改`LookMoveTo.cs`脚本以显示当前的`WalkTarget` X, Z位置。在MonoDevelop编辑器中打开脚本，并添加以下代码：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The line `using UnityEngine.UI;` states that this script will need access to
    the Unity UI API. We defined a `public Transform infoBubble` variable, which will
    be set to the `WalkTarget/InfoBubble` object. We also defined a `private Text
    infoText` variable, which gets set to the `InfoBubble` object's Text object. The
    script assumes that the given `InfoBubble` has a child Text UI object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 行`using UnityEngine.UI;`表示此脚本将需要访问Unity UI API。我们定义了一个`public Transform infoBubble`变量，它将被设置为`WalkTarget/InfoBubble`对象。我们还定义了一个`private
    Text infoText`变量，它被设置为`InfoBubble`对象的Text对象。脚本假设给定的`InfoBubble`有一个子Text UI对象。
- en: Unfortunately, the overuse of the word *text* can be confusing. The `infoText`
    *text* object has a *text* component, which has a *text* string property! You
    can see what I mean in Unity editor. If you examine the Inspector panel while
    `InfoBubble/Text` is selected, you'll see that it contains a Text (Script) component,
    which has a Text field. This Text field is where we write our messages. So in
    `Setup()`, we find the `WalkTarget/InfoBubble/Text` object, assigning the Text
    object to `infoText`, and then in `Update()`, we set the string value of `infoText.text`
    so that the score is shown on the bubble canvas.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，过度使用单词*text*可能会造成混淆。`infoText` *text*对象有一个*text*组件，该组件有一个*text*字符串属性！你可以在Unity编辑器中看到这一点。如果你在`InfoBubble/Text`被选中时检查检查器面板，你会看到它包含一个Text（Script）组件，该组件有一个文本字段。这个文本字段是我们写入消息的地方。因此，在`Setup()`中，我们找到`WalkTarget/InfoBubble/Text`对象，将Text对象分配给`infoText`，然后在`Update()`中，我们设置`infoText.text`的字符串值，以便在气泡画布上显示分数。
- en: Also, in `Update()`, we transformed the `infoBubble` canvas so that it's always
    facing us using `infoBubble.LookAt()` and passing it the camera position. The
    result of `LookAt()` has the canvas facing away from us. So, we also need to rotate
    it around the *y *axis by 180 degrees.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Update()`中，我们通过使用`infoBubble.LookAt()`并将相机位置传递给它来变换`infoBubble`画布，使其始终面向我们。`LookAt()`的结果是画布面向我们。因此，我们还需要围绕*y轴旋转180度。
- en: Save the script and drag the `InfoBubble` object from Hierarchy onto the Info
    Bubble slot in the Look Move To (Script) component. If you don't assign the `InfoBubble`
    canvas, the script will still run because we test for `null` objects before we
    reference them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，并将`InfoBubble`对象从层次结构拖到Look Move To（脚本）组件中的信息气泡槽中。如果你没有分配`InfoBubble`画布，脚本仍然会运行，因为我们在我们引用它们之前测试了`null`对象。
- en: An info bubble UI canvas is attached to other game objects, moving when they
    move and always facing the camera (like a billboard).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 信息气泡UI画布附加到其他游戏对象上，随着它们的移动而移动，并且始终面向相机（就像一个广告牌）。
- en: Run the scene in VR and you'll see that `WalkTarget` has a little info bubble
    telling us about its X, Z position.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中运行场景，你会看到`WalkTarget`有一个小信息气泡告诉我们它的X, Z位置。
- en: 'Extra challenge: Want to try something else? Implement a health meter bar for
    Ethan. Use the `countDown` variable in the `KillTarget` script to determine his
    percentage of health and to display a health meter (horizontal bar) above his
    head when it''s not at 100 percent.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 额外挑战：想要尝试其他东西吗？为Ethan实现一个生命值条。使用`KillTarget`脚本中的`countDown`变量来确定他的健康百分比，并在健康值不为100%时在其头顶上方显示一个生命值条（水平条）。
- en: Info bubbles are useful when you need to display UI messages that belong to
    specific objects in the scene and may move in concert with the objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 信息气泡在需要显示属于场景中特定对象的UI消息时很有用，并且可能随对象一起移动。
- en: An in-game dashboard with input events
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的仪表盘包含输入事件
- en: An in-game dashboard or control panel is a UI display that is integrated into
    the game itself. A typical scenario is an automobile or a spaceship, where you
    are seated in a cockpit. At waist level (desk level) is a panel with a set of
    controls, gauges, information displays, and so on. Dashboards generally feel more
    natural in a seated VR experience.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的仪表盘或控制面板是集成到游戏本身中的UI显示。一个典型的场景是汽车或宇宙飞船，你坐在驾驶舱内。在腰部水平（桌面水平）有一个面板，上面有一套控制装置、仪表、信息显示等。仪表盘在坐姿VR体验中感觉更自然。
- en: A few pages back, we discussed windshield HUDs. Dashboards are pretty much the
    same thing. One difference is that the dashboard may be more obviously part of
    the level environment and not simply an auxiliary information display or a menu.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在几页之前，我们讨论了挡风玻璃HUD。仪表盘基本上是同一件事。一个区别是，仪表盘可能更明显地是关卡环境的一部分，而不仅仅是辅助信息显示或菜单。
- en: In fact, dashboards can be a very effective mechanism to control VR motion sickness.
    Researchers have found that when a VR user has a better sense of being grounded
    and has a consistent *horizon line* in view, he's much less likely to experience
    nausea while moving around a virtual space. In contrast, being a floating one-dimensional
    eyeball with no sense of self or grounding is asking for trouble! (See the *Oculus
    Best Practices* for this, and other great tips, by visiting [https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/](https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，仪表盘可以是一个非常有效的控制VR运动病感的机制。研究人员发现，当VR用户有更好的接地感和一致的*地平线*在视野中时，他在虚拟空间中移动时不太可能感到恶心。相比之下，成为一个没有自我或接地感的一维眼球，无疑是自找麻烦！（有关此内容和其他优秀提示，请参阅[Oculus最佳实践](https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/)）
- en: In this example, we'll make a simple dashboard with Start/Stop buttons. For
    now, the buttons will operate a water hose in the scene to help fend off the zombies.
    (*Why not?*) Like other examples in this chapter, this project uses the scene
    created in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将制作一个简单的带有开始/停止按钮的仪表盘。目前，按钮将操作场景中的水管以帮助抵御僵尸。（为什么不呢？）像本章中的其他示例一样，此项目使用[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)中创建的场景，*基于注视的控制*。
- en: 'This project is a bit more complicated than you might expect. However, if you''ve
    ever had to build anything in Minecraft, you know that even the simple things
    may require assembling multiple parts. Here''s what we will do:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目可能比你想象的要复杂一些。然而，如果你曾经在任何Minecraft中构建过东西，你就知道即使是简单的事情也可能需要组装多个部件。以下是我们将要做的：
- en: Create a dashboard canvas with two functional buttons—Start and Stop
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含两个功能按钮的仪表盘画布——开始和停止
- en: Add a water hose to the scene and wire it to the buttons
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中添加一个水管并将其连接到按钮
- en: Write a simple version of the script that activates the buttons
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的脚本，用于激活按钮
- en: Highlight a button by looking at it
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注视按钮来突出显示按钮
- en: Improve the script to activate the button only if it's highlighted
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进脚本，以便仅在按钮被突出显示时激活按钮
- en: So let's get to it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Creating a dashboard with buttons
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有按钮的仪表盘
- en: 'First, let''s create a dashboard with a Start and a Stop button, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个带有开始和停止按钮的仪表盘，如下所示：
- en: From the Project window, drag the `DefaultCanvas` prefab onto the `MeMyselfEye`
    object in the Hierarchy panel so that it becomes a child.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目窗口，将`DefaultCanvas`预制体拖动到层次结构面板中的`MeMyselfEye`对象，使其成为子对象。
- en: Rename it to `Dashboard`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`Dashboard`。
- en: With `Dashboard` selected, set the Rect Transform component's Pos X, Pos Y,
    Pos Z to (`0`, `0.6`, `0.6`) and its Rotation to (`60`, `0`, `0`). Feel free to
    adjust the position for preferred comfort zone and your specific VR device camera
    rig.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`Dashboard`后，将Rect Transform组件的Pos X、Pos Y、Pos Z设置为(`0`, `0.6`, `0.6`)，并将旋转设置为(`60`,
    `0`, `0`)。请随意调整位置以适应您偏好的舒适区域和您特定的VR设备相机支架。
- en: Disable or delete the Text child object of `Dashboard`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，禁用或删除`Dashboard`的Text子对象。
- en: This places the dashboard 1 m below your eyes and a little out in front.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就将仪表盘放置在您的眼睛下方1米处，并稍微向前。
- en: 'For a *work-in-progress* look, if you''d like, I''ve included an image sketch
    of a vehicle dashboard that you can use, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个*工作进度*的外观，我已包括一个车辆仪表盘的草图图像，您可以使用，如下所示：
- en: Import the `DashboardSketch.png` file into your Project (such as the `Assets/Textures`
    folder).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DashboardSketch.png`文件导入到您的项目（例如`Assets/Textures`文件夹）中。
- en: Add a new GameObject | UI | Raw Image as a child of `Dashboard`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的GameObject | UI | Raw Image作为`Dashboard`的子对象添加。
- en: Drag the `DashboardSketch` texture from the Project panel onto the Texture field
    of the Raw Image component.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DashboardSketch`纹理从项目面板拖动到Raw Image组件的纹理字段。
- en: Set its Rect Transform component's Pos X, Pos Y, Pos Z to (`0`,`0`,`0`), Width
    to `140`, and Height to `105`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Rect Transform组件的Pos X、Pos Y、Pos Z设置为(`0`,`0`,`0`)，宽度为`140`，高度为`105`。
- en: It should be Anchored at middle-center (`0.5`,`0.5`) in X, Y, and Pivot, with
    Rotation (`0`,`0`,`0`).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该在X、Y和Pivot的中间中心(`0.5`,`0.5`)锚定，旋转(`0`,`0`,`0`)。
- en: Set Scale to (`4.5`,`4.5`,`4.5`).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将比例设置为 (`4.5`,`4.5`,`4.5`).
- en: 'Next, we will add the Start and Stop buttons. They can go anywhere you''d like
    on the canvas, but the sketch has two nice spaces predefined for them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加启动和停止按钮。它们可以放在画布上的任何位置，但草图已经为它们预留了两个很好的空间：
- en: Add a new GameObject | UI | Button as a new child of `Dashboard`. Name it `StartButton`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Dashboard` 下添加一个新的 GameObject | UI | Button 作为新的子对象。命名为 `StartButton`。
- en: Set its Rect Transform component's X, Y, Z to (`-48`, `117`, `0`), the Width and Height
    to (`60`, `60`), and Anchored to center-middle (`0.5`). No Rotation and Scale
    of `1`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 Rect Transform 组件的 X、Y、Z 设置为 (`-48`, `117`, `0`), 宽度和高度设置为 (`60`, `60`),
    并锚定到中心中间 (`0.5`)。无旋转和比例 `1`。
- en: In the button's Image (Script) component pane, for Source Image, click on the
    tiny circle on the far right to open the Select Sprite picker and choose `ButtonAcceleratorUpSprite`
    (which you may have imported into the `Assets/Standard Assets/CrossPlatformInput/Sprites`
    folder).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮的 Image (Script) 组件面板中，对于源图像，点击最右侧的小圆圈以打开选择精灵选择器，并选择 `ButtonAcceleratorUpSprite`（你可能已将其导入到
    `Assets/Standard Assets/CrossPlatformInput/Sprites` 文件夹）。
- en: In the button's Button (Script) component pane, for the Normal Color, I used
    RGB (`89`,`154`,`43`) and set Highlighted Color to (`105`, `255`, `0`).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮的 Button (Script) 组件面板中，对于正常颜色，我使用了 RGB (`89`,`154`,`43`) 并将高亮颜色设置为 (`105`,
    `255`, `0`)。
- en: Similarly, create another button named `StopButton` with the Rect Transform
    component's X, Y, Z (`52`, `118`, `0`) and set the Width and Height to (`60`,
    `60`). For Source Image, select `ButtonBrakeOverSprite`, then choose the Normal
    Color (`236`, `141`, `141`) and Highlighted Color (`235`, `45`, `0`).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建另一个名为 `StopButton` 的按钮，其 Rect Transform 组件的 X、Y、Z 为 (`52`, `118`, `0`)，并将宽度和高度设置为
    (`60`, `60`)。对于源图像，选择 `ButtonBrakeOverSprite`，然后选择正常颜色 (`236`, `141`, `141`) 和高亮颜色
    (`235`, `45`, `0`)。
- en: 'The result should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![](img/f7764fc8-bada-442a-8b09-1a9c2bd69425.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7764fc8-bada-442a-8b09-1a9c2bd69425.png)'
- en: 'One last thing. If you''re using the `ReticleCursor` that was created earlier
    in this chapter with the `CursorPositioner.cs` script, we want the dashboard itself
    to have a collider for the script. We can achieve this by performing the following
    steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情。如果你正在使用本章早期创建的 `ReticleCursor`，该 `ReticleCursor` 与 `CursorPositioner.cs`
    脚本一起创建，我们希望仪表板本身具有碰撞器以供脚本使用。我们可以通过以下步骤实现这一点：
- en: With `Dashboard` selected, right-click for options, and navigate to
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Dashboard`，右键单击以获取选项，并导航到
- en: 3D Object | Plane.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3D 对象 | 平面。
- en: Set its Position to (`0`,`0`,`0`), Rotation to (`270`,`0`,`0`), and Scale to
    (`64`,`1`,`48`).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为 (`0`,`0`,`0`), 旋转设置为 (`270`,`0`,`0`), 比例设置为 (`64`,`1`,`48`)。
- en: Disable its Mesh Renderer (but leave its Mesh Collider enabled).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用其 Mesh Renderer（但保留其 Mesh Collider 启用）。
- en: Now the dashboard has a plane child that isn't rendered, but its collider will
    be detected when `CursorPositioner` does its ray cast. We do this to see your
    gaze on this dashboard panel rather than the ground below even when not looking
    directly at a button.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仪表板上有一个未渲染的平面子对象，但当 `CursorPositioner` 执行射线投射时，其碰撞器将被检测到。我们这样做是为了让你在即使不直接看按钮的情况下，也能看到这个仪表板面板上的注视点。
- en: Having a single toggle button with pressed and released states might be better
    than separate Start and Stop buttons. When you're done with this chapter, go ahead
    and figure out how to do it!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个具有按下和释放状态的单独切换按钮可能比单独的启动和停止按钮更好。当你完成这一章后，继续找出如何实现它！
- en: We just created a world space canvas that should appear in VR at waist or desk
    level. We decorated it with a dashboard sketch and added two UI buttons. Now,
    we'll wire up the buttons to specific events.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个应该在 VR 中出现在腰部或桌面高度的宇宙空间画布。我们用仪表板草图进行了装饰，并添加了两个 UI 按钮。现在，我们将为按钮连接到特定的事件。
- en: Linking the water hose to the buttons
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将水管链接到按钮
- en: 'Let''s first give the buttons something to do, such as the action of turning
    on a water hose. If we aim it strategically, it might even fend off rogue zombies.
    Coincidentally, the Unity Particle Systems under Standard Assets which we imported
    earlier has a water hose that we can use. Add it to the scene as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先给按钮分配一些功能，比如打开水管的动作。如果我们有策略地瞄准，甚至可能击退流氓僵尸。巧合的是，我们之前导入的 Unity 粒子系统标准资产中有一个水管，我们可以使用它。按照以下步骤将其添加到场景中：
- en: If you haven't done so already, import the Particle Systems standard asset from
    the main menu bar by navigating to Assets | Import Package | ParticleSystems.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请通过导航到 Assets | Import Package | ParticleSystems 从主菜单栏导入粒子系统标准资产。
- en: In the Project window, find the `Assets/Standard Assets/Particle Systems/Prefabs/Hose`
    prefab and drag it into the Hierarchy window.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，找到`Assets/Standard Assets/Particle Systems/Prefabs/Hose`预制件，并将其拖动到层次窗口中。
- en: Set its Transform component's X, Y, Z to (`-3`, `0`, `1.5`) and Rotation to
    (`340`, `87`, `0`).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Transform组件的X、Y、Z设置为（`-3`、`0`、`1.5`），并将旋转设置为（`340`、`87`、`0`）。
- en: Ensure that Hose is enabled (check its Enable checkbox).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Hose已启用（勾选其启用复选框）。
- en: Unfold the Hose in Hierarchy so that you can see its child WaterShower particle
    system. Select it.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次窗口中展开Hose，以便可以看到其子WaterShower粒子系统。选择它。
- en: In Inspector, in the Particle System properties pane, look for Play On Awake
    and uncheck it.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，在粒子系统属性面板中，查找“唤醒时播放”并取消勾选。
- en: Note that the Hose object in Hierarchy has a `WaterShower` child object. This
    is the actual particle system that we will control with the buttons. It should
    start as *off*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在层次窗口中，Hose对象有一个`WaterShower`子对象。这是我们将通过按钮控制的实际粒子系统。它应该以*关闭*的状态开始。
- en: The Hose prefab itself comes with mouse-driven script that we don't want to
    use,
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Hose预制件本身带有鼠标驱动的脚本，我们不想使用，
- en: 'so disable it as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按照以下方式禁用它：
- en: With Hose selected, disable (uncheck) its Hose (Script).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Hose后，禁用（取消勾选）其Hose（脚本）。
- en: Also, disable (uncheck) the Simple Mouse Rotator (Script) component.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要禁用（取消勾选）简单鼠标旋转（脚本）组件。
- en: 'Now we will wire up `StartButton` to the WaterShower particle system by telling
    the buttons to listen for the `OnClick()` events, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过告诉按钮监听`OnClick()`事件，将`StartButton`连接到WaterShower粒子系统，如下所示：
- en: Unfold the Hose in Hierarchy so that you can see its child WaterShower particle
    system.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次窗口中再次展开Hose，以便可以看到其子WaterShower粒子系统。
- en: In Hierarchy, select `StartButton` (under `MeMyselfEye/Dashboard`).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次窗口中，选择`StartButton`（位于`MeMyselfEye/Dashboard`下）。
- en: Note that in the Inspector, the On Click() pane of the `Button` component is
    empty. Click on the *Plus* (+) icon on the lower right of that pane to reveal
    a new field labeled None (Object).
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在检查器中，`Button`组件的`OnClick()`面板是空的。点击该面板右下角的*加号*（+）图标以显示一个新字段，标签为None（对象）。
- en: Drag the WaterShower particle system from Hierarchy onto the None (Object) field.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将WaterShower粒子系统从层次窗口拖动到None（对象）字段。
- en: Its function selector, the default value, is No Function. Change it to ParticleSystem
    | Play().
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其功能选择器，默认值是“无功能”。将其更改为ParticleSystem | Play()。
- en: 'OK. The steps are similar for the `StopButton`, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。对于`StopButton`，步骤类似，如下所示：
- en: In Hierarchy, select `StopButton`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次窗口中，选择`StopButton`。
- en: Click on the *Plus* (+) icon on the lower right of it's On Click() pane.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击其`OnClick()`面板右下角的*加号*（+）图标。
- en: Drag the WaterShower from Hierarchy onto the None (Object) field.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将WaterShower从层次窗口拖动到None（对象）字段。
- en: Its function selector, the default value, is No Function. Change it to ParticleSystem
    | Stop().
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其功能选择器，默认值是“无功能”。将其更改为ParticleSystem | Stop()。
- en: The Start and Stop buttons *listen for* `OnClick()` *events*, and when one comes,
    it will
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和停止按钮*监听*`OnClick()`*事件*，当其中一个事件发生时，
- en: call the WaterShower particle system's `Play()` and `Stop()` functions respectively.
    To make it work, we need to press the buttons.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 分别调用WaterShower粒子系统的`Play()`和`Stop()`函数。为了使其工作，我们需要按下按钮。
- en: Activating buttons from the script
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过脚本激活按钮
- en: 'Before we give the user a way to press the buttons, let''s see how we can do
    this from a script. Create a new script on `GameController`, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为用户提供按按钮的方法之前，让我们看看我们如何从脚本中做到这一点。在`GameController`上创建一个新的脚本，如下所示：
- en: With `GameController` selected in Hierarchy, press Add Component | New Script
    to create a script named `ButtonExecuteTest`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次窗口中选择`GameController`后，按“添加组件”|“新脚本”以创建一个名为`ButtonExecuteTest`的脚本。
- en: Open the script in MonoDevelop.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MonoDevelop中打开脚本。
- en: 'In the following script, we turn the hose on and off in five-second intervals,
    as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下脚本中，我们每隔五秒切换水龙带的开关，如下所示：
- en: '[PRE9]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The script manages a Boolean `isOn` value, which says if the hose is on or off.
    And it has a timer which counts down from 5 seconds on each update. We use the
    `private` keyword for variables that are only used within this script, whereas
    the `public` ones can be viewed and modified via the Unity editor and other scripts.
    For `startButton` and `stopButton`,  you'll drag and drop them in the Unity editor.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本管理一个布尔值`isOn`，表示水龙带是开启还是关闭。并且它有一个计时器，每次更新时从5秒开始倒计时。我们使用`private`关键字为只在此脚本中使用的变量，而`public`的变量可以通过Unity编辑器和其他脚本查看和修改。对于`startButton`和`stopButton`，你将在Unity编辑器中将它们拖放进去。
- en: In this script, we use the `UnityEngine.UI`. As we saw in the previous chapter, *Events*
    are a way for different components to talk to one another. When an event occurs,
    such as a button press, a function in another script may get called. In our case,
    we're going to trigger an event corresponding to the start button press, and another
    corresponding to the stop button press, as we set up in the Inspector.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and click on Play. The hose should turn on and off every five
    seconds.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have tested the event system connection between the button clicks
    and the hose, we can disable this script before moving on to the next one:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: With `GameController` selected,
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `ButtonExecuteTest` component by unchecking its Enable checkbox,
    or remove the component.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breaking down a complex feature into bite-sized pieces and testing them separately
    is an excellent implementation strategy.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Look to highlight a button
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Meanwhile, let''s detect when the user is looking at a button and highlight
    it. Although Button is a Unity UI object, it needs to be detected with a ray cast.
    There may be other ways to accomplish this, as discussed later in this chapter,
    but here we will add a game object sphere to each button and cast a ray to detect
    it. First, add the spheres by performing the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select `StartButton` (under `MeMyselfEye/Dashboard`),
    right-click for options, and navigate to 3D Object | Sphere.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Transform component's Scale to (`52`, `52`, `52`) so that it fits the
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: button size.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disable the sphere's Mesh Renderer by unchecking the Mesh Renderer checkbox.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, repeat these steps for `StopButton`. A shortcut is to duplicate the sphere,
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the Sphere and choose Duplicate.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the duplicated item (`Sphere (1)`) into `StopButton`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset it Position to (`0`,`0`,`0`).
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a new script on `StartButton`, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: With `StartButton` selected, navigate to Add Component | New Script to create
    a script named `RespondToGaze`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script for editing.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following `RespondToGaze.cs` script, we tell the button to become highlighted
    when you look at it, using the child Sphere object''s collider:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this script, on each update, we cast a ray from the camera. If it hits this
    button's sphere collider, then the hit object's parent should be this button.
    So (after checking that the hit object has a parent), we compare the parent gameObject
    to this button's gameObject.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: If the gaze has selected this button, we trigger the button's Select to make
    it highlight. The highlighting is done within Unity's `EventSystem`. While the
    EventSystem has all this implemented for mouse clicks and screen touches, we have
    to manually tell the button it's been selected by calling `button.Select()`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Unhighlighting the button is not so obvious. The EventSystem maintains a currently
    selected object across your runtime scene. We clear it by passing null to `SetSelectedGameObject()`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and *Play*. When you gaze at a button, it should highlight,
    and when you gaze away from it, it should remove the highlight.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并*播放*。当你注视一个按钮时，它应该突出显示，当你从它移开目光时，它应该移除突出显示。
- en: 'This is also an example of a reusable component script. We just wrote and tested
    it for the StartButton. We can use the same script for the StopButton:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个可重用组件脚本的例子。我们只为StartButton编写并测试了它。我们可以为StopButton使用相同的脚本：
- en: Select the StopButton from the Hierarchy.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择StopButton。
- en: Drag the RespondToGaze script from the Project Assets onto the button, or
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RespondToGaze脚本从项目资产拖到按钮上，或
- en: Select Add Component | Scripts | RespondToGaze.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加组件 | 脚本 | 响应注视。
- en: Test the project one more time. Both buttons should highlight when you gaze
    at them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 再测试一下项目。当你注视按钮时，两个按钮都应该突出显示。
- en: If you are using  Google VR for Cardboard or Daydream, you can include the `GvrEventSystem`
    prefab in your scene. Then this `RespondToGaze` script becomes unnecessary and
    redundant. The `Daydream` component already supports gaze-based select, highlight,
    and clicking with the input controller. But I encourage you to follow along with
    this project nonetheless to experience how this functionality can be implemented. If
    so, temporarily disable `GvrEventSystem` in your scene.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Google VR for Cardboard或Daydream，你可以在场景中包含`GvrEventSystem`预制件。然后这个`RespondToGaze`脚本就变得不必要且冗余了。`Daydream`组件已经支持基于注视的选择、突出显示和输入控制器进行点击。但我鼓励你跟随这个项目，体验一下这种功能是如何实现的。如果是这样，暂时在你的场景中禁用`GvrEventSystem`。
- en: Looking and then clicking to select
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观看并点击以选择
- en: '[PRE11]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The changes to make to the `RespondToGaze.cs` script are pretty simple. At
    top of the class, add the following public variables:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的`RespondToGaze.cs`脚本更改相当简单。在类的顶部添加以下公共变量：
- en: '[PRE12]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the bottom of `Update()`, make the following changes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`的底部进行以下更改：
- en: '[PRE13]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the controller `"Fire1"` button is pressed, it will trigger a click of
    the UI button.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器`"Fire1"`按钮被按下时，它将触发UI按钮的点击。
- en: The component gives you the option to enable highlights and/or clicking with
    the input controller. You can also choose the logical input button that will trigger
    the click events.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件提供了启用高亮显示和/或使用输入控制器进行点击的选项。您还可以选择将触发点击事件的逻辑输入按钮。
- en: We now have an in-game dashboard with buttons that respond to user input, which
    controls the behavior of an object (water hose) in the scene.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个游戏中的仪表板，带有响应用户输入的按钮，它控制场景中对象（水管）的行为。
- en: Looking and starting to select
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观看并开始选择
- en: Instead of using a clicker, we can use a time-based selection to click on the
    button. To make this work, we'll keep a countdown timer while staring at a button,
    much like the one that we used to kill Ethan in the previous chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基于时间的选择而不是点击器来点击按钮。为了使这起作用，我们将在注视按钮时保持倒计时计时器，就像我们在上一章中用来杀死Ethan的那个一样。
- en: 'Change the `RespondToGaze.cs` script. At top of the class, add the following
    variables:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`RespondToGaze.cs`脚本。在类的顶部添加以下变量：
- en: '[PRE14]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `Update()`, make the following changes:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`中，进行以下更改：
- en: '[PRE15]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, not only will a button click get involved on `Input.GetButtonDown`, but
    also if you gaze at the button long enough (when `timedClick` is `true`). We begin
    a timer when the button is selected (highlighted) and count up. When the timer
    expires the click event is invoked. If the button is deselected before then, the
    timer is reset to zero.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不仅按钮点击会在`Input.GetButtonDown`上涉及，而且如果你长时间注视按钮（当`timedClick`为`true`时），也会涉及。当按钮被选中（突出显示）时，我们开始计时并计数。当计时器到期时，将调用点击事件。如果在那时之前取消选中按钮，计时器将重置为零。
- en: '*Does it work for you? Woohoo!*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*它对你有效吗？太棒了！*'
- en: So this was a relatively complex project. The goal was to create a dashboard
    with buttons that turn a hose on and off. We broke it down into discrete steps,
    added the objects and components a step at a time, and tested each step to make
    sure that it worked as expected before moving on. If you tried to implement this
    all at once or blew through it without testing, things can (and will) go wrong,
    and it'll be much harder to figure out where the problem cropped up.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个相对复杂的项目。目标是创建一个带有开关水管的按钮仪表板。我们将它分解成离散的步骤，一次添加一个对象和组件，并在继续之前测试每个步骤以确保其按预期工作。如果你试图一次性实现所有这些，或者在没有测试的情况下快速完成，事情可能会（并且将会）出错，这将使找出问题所在变得更加困难。
- en: 'Extra challenge: This feature can be further enhanced for different purposes.
    For example, it can be used to give the user the information that the countdown
    is running, perhaps by animating a spinner cursor. Also, further feedback can
    be given when the click event is executed. For example, the Button UI object has
    a Transition option called Animation that might be helpful. Also, consider audio
    cues.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 额外挑战：此功能可以根据不同目的进一步增强。例如，它可以用来向用户显示倒计时正在运行，可能通过动画旋转光标来实现。此外，在执行点击事件时还可以提供进一步的反馈。例如，按钮UI对象有一个名为动画的过渡选项，这可能很有帮助。同时，考虑音频提示。
- en: Pointing and clicking with VR components
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VR组件进行指向和点击
- en: As we have seen, while Unity provides UI elements such as canvas text, buttons,
    and other controls that are specially tuned for conventional screen space UI and
    mobile app, using them in World Space and tying them together with VR user input
    can get pretty involved. World space interactions assume some physics, colliders,
    and ray casts to detect interaction events.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，虽然Unity提供了专门针对传统屏幕空间UI和移动应用的UI元素，如画布文本、按钮和其他控件，但在世界空间中使用它们并与VR用户输入相结合可能会相当复杂。世界空间交互假设一些物理、碰撞体和射线投射来检测交互事件。
- en: Fortunately, VR device-specific toolkits may provide components that take care
    of some of this work already. As we saw in previous chapters, device manufacturers
    provide toolkits built atop their Unity SDK with convenient scripts, prefabs,
    and demo scenes that illustrate how to use them.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，VR设备特定的工具包可能提供一些组件，可以处理一些这项工作。正如我们在前面的章节中看到的，设备制造商提供了基于他们Unity SDK的工具包，其中包含方便的脚本、预制体和演示场景，说明了如何使用它们。
- en: 'In this case, we''re looking for components that let you design scenes using
    Unity UI elements on a canvas, take advantage of all their EventSystem interactivity
    goodness, use world space 3D models, and input controllers or laster pointers.
    For example, consider these:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在寻找允许您使用Unity UI元素在画布上设计场景的组件，利用所有它们的EventSystem交互功能，使用世界空间3D模型，以及输入控制器或激光指针的组件。例如，考虑以下内容：
- en: 'Oculus Rift and GearVR: OVRInputModule; see [https://developer.oculus.com/blog/unitys-ui-system-in-vr/](https://developer.oculus.com/blog/unitys-ui-system-in-vr/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Oculus Rift和GearVR: OVRInputModule；请参阅[https://developer.oculus.com/blog/unitys-ui-system-in-vr/](https://developer.oculus.com/blog/unitys-ui-system-in-vr/)'
- en: 'SteamVR: Steam InteractionSystem; see the `/Assets/SteamVR/InteractionSystem/`
    folder after installing the SteamVR package'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SteamVR：Steam InteractionSystem；安装SteamVR包后，请参阅`/Assets/SteamVR/InteractionSystem/`文件夹
- en: 'Daydream:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Daydream：
- en: VRTK open source toolkit: [https://github.com/thestonefox/VRTK](https://github.com/thestonefox/VRTK)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VRTK开源工具包：[https://github.com/thestonefox/VRTK](https://github.com/thestonefox/VRTK)
- en: 'Lastly, you might consider purchasing a package from the Unity Asset Store.
    The Curved UI package ($25), for example, lets you make VR-ready curved canvases
    and supports Vive, Oculus Touch, Daydream controllers, and gaze input, as depicted:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能考虑从Unity Asset Store购买一个包。例如，Curved UI包（$25）允许你创建VR准备好的弯曲画布，并支持Vive、Oculus
    Touch、Daydream控制器和注视输入，如图所示：
- en: '![](img/12341f9a-bccd-4c4e-a2cd-9176aa8aecb2.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12341f9a-bccd-4c4e-a2cd-9176aa8aecb2.png)'
- en: Using Unity UI and SteamVR
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity UI和SteamVR
- en: We introduced the SteamVR InteractionSystem in Chapter 5, *Handy Interactables*.
    It is intended as an example of how to use the SteamVR SDK but includes some very
    useful components and demo scenes. Using the Interaction System, it's very easy
    to convert your Dashboard into a control panel you can operate directly with your
    positionally tracked hand controllers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第5章“实用交互对象”中介绍了SteamVR InteractionSystem。它旨在作为一个如何使用SteamVR SDK的示例，但包括一些非常有用的组件和演示场景。使用交互系统，将仪表板转换为可以直接使用位置跟踪手控制器操作的控制面板变得非常简单。
- en: The Interaction System includes its own `Player` camera rig which replaces the
    default `[CameraRig]` we have been using. It includes a VRCamera, two hands (Hand1
    and Hand2), and other useful objects.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 交互系统包括它自己的`Player`相机装置，它替换了我们一直在使用的默认`[CameraRig]`。它包括一个VRCamera、两个手（Hand1和Hand2）和其他有用的对象。
- en: Locate the `Assets/SteamVR/InteractionSystem/Core/Prefabs` folder in the Project
    window
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中定位`Assets/SteamVR/InteractionSystem/Core/Prefabs`文件夹
- en: Drag the `Player` prefab as a child of `MyMyselfEye` into your scene Hierarchy
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Player`预制体作为`MyMyselfEye`的子对象拖入场景层次结构
- en: Delete or disable the `[CameraRig]` object
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或禁用`[CameraRig]`对象
- en: 'To make the `StartButton` and `StopButton` interactable, add the `Interactable`
    component. Also add the UI `Element` component to handle OnHandClick events, as
    follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`StartButton`和`StopButton`可交互，请添加`Interactable`组件。还要添加UI `Element`组件来处理OnHandClick事件，如下所示：
- en: Select the `StartButton` object in Hierarchy (child of `Dashboard`).
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`StartButton`对象（`Dashboard`的子对象）。
- en: 'In Inspector, select Add Component | Scripts | Valve.VR.InteractionSystem |
    Interactable (tip: use the Search field for "Interactable").'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，选择添加组件 | 脚本 | Valve.VR.InteractionSystem | Interactable（提示：使用搜索字段搜索“Interactable”）。
- en: Select Add Component | Scripts | Valve.VR.InteractionSystem | UI Element.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加组件 | 脚本 | Valve.VR.InteractionSystem | UI Element。
- en: In Inspector on the UI Element component, press the "+" to add an On Hand Click
    handler.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI元素组件的检查器中，按“+”键添加一个“On Hand Click”处理程序。
- en: Drag the `WaterShower` particle system (child of `Hose` object) from Hierarchy
    onto the GameObject field, like we did for the standard Button OnClick event.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WaterShower`粒子系统（`Hose`对象的子对象）从层次结构拖到GameObject字段，就像我们为标准按钮OnClick事件所做的那样。
- en: Select the ParticleSystem | Play() function.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择ParticleSystem | Play()函数。
- en: Optionally, disable the `RespondToGaze` component.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，禁用`RespondToGaze`组件。
- en: Similarly, repeat these steps for the `StopButton`, but choose function ParticleSystem
    | Stop().
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为`StopButton`重复这些步骤，但选择ParticleSystem | Stop()函数。
- en: 'You may also need to move the `Dashboard` closer to yourself so the buttons
    are within comfortable reach when you''re in VR. When you press Play you can now
    reach to touch a button; it highlights. Pull the trigger to press it, as shown
    in the screenshot, and it turns on the hose:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要将“仪表板”移近一些，以便在VR中按钮在舒适范围内。当您按下播放时，现在您可以伸手触摸按钮；它会被高亮显示。拉动扳机按它，如图所示，水龙头就会打开：
- en: '![](img/29dd7a02-8acd-461d-bc37-21feaf308d48.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29dd7a02-8acd-461d-bc37-21feaf308d48.png)'
- en: Using Unity UI and Daydream
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity UI和Daydream
- en: Let's now take a look at how to do this on a mobile VR device using Google Daydream.
    In this case, we won't actually reach out and press the button but use the 3DOF
    hand controller laser pointer. The solution is as simple as replacing the `GvrReticlePointer`
    (if you had been using it) with a `GvrControllerPointer`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在移动VR设备上使用Google Daydream来实现这一功能。在这种情况下，我们实际上不会伸手去按按钮，而是使用3DOF手柄控制器激光指针。解决方案就像将`GvrReticlePointer`（如果您使用过它）替换为`GvrControllerPointer`一样简单。
- en: Under your MeMyselfEye `GVR Camera Rig/ Player / Main Camera /`, if there is
    a GvrReticlePointer, disable it.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的MeMyselfEye `GVR Camera Rig/ Player / Main Camera /`下，如果有GvrReticlePointer，请禁用它。
- en: Locate the GvrControllerPointer in the `GoogleVR/Prefabs/Controller/` folder.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoogleVR/Prefabs/Controller/`文件夹中找到GvrControllerPointer。
- en: Drag the prefab under Player (as a sibling of Main Camera).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Player（作为主相机的兄弟）下的预制件拖动。
- en: 'Then set up the Dashboard canvas to accept raycasts:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置仪表板画布以接受射线投射：
- en: Select the Dashboard object in Hierarchy.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择仪表板对象。
- en: Add the GvrPointerGraphicRaycaster component.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加GvrPointerGraphicRaycaster组件。
- en: Press Play. You can now use the Daydream controller to press the buttons.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。现在您可以使用Daydream控制器来按按钮。
- en: Explore the component options for the GvrControllerPointer, its child Laser
    object, and other Gvr object provided with the package. There's some pretty interesting
    and useful configurations available, including settings for laser color, end color,
    and max distance. There's even a checkbox to Draw Debug Rays in the Editor Scene
    window during Play mode.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 探索GvrControllerPointer、其子Laser对象和包中提供的其他Gvr对象组件选项。有一些相当有趣和有用的配置可用，包括激光颜色、结束颜色和最大距离的设置。甚至还有一个复选框，可以在播放模式下的编辑器场景窗口中绘制调试射线。
- en: Building a wrist-based menu palette
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于手腕的菜单调色板
- en: Some VR applications, designed for two-handed setups such as Oculus Rift, HTC
    Vive, and Windows MR, give you a virtual menu palette attached to one wrist while
    the other hand selects buttons or items from it. Let's see how that is done. *This
    scenario will assume you have a two hand controller VR system.* We'll describe
    it using the SteamVR camera rig, involving attaching the controls to your left
    hand and selecting them with your right.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一些VR应用程序，如Oculus Rift、HTC Vive和Windows MR，为双手设置设计，在一侧手腕上提供虚拟菜单调色板，而另一只手则从中选择按钮或项目。让我们看看这是如何实现的。*此场景假设您有一个双手控制器VR系统。*我们将使用SteamVR相机架来描述，涉及将控制绑定到您的左手，并用右手选择它们。
- en: Converting our dashboard control panel into a wrist palette is not too difficult.
    We just need to scale it appropriately and attach it to the hand controller.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的仪表板控制面板转换为手腕调色板并不太难。我们只需要适当地缩放并将其附加到手控制器上。
- en: 'Given you''ve built the scene up to the point described in the previous *Using
    Unity UI and SteamVR *section, including the SteamVR `Player` rig (instead of
    `[CameraRig]`), we''ll duplicate and repurpose the `Dashboard` to use it on your
    left wrist:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经将场景构建到上一节中描述的点，包括SteamVR `Player`装置（而不是`[CameraRig]`），我们将复制并重新使用`Dashboard`，以便在你的左手腕上使用：
- en: In Hierarchy, right-click the Dashboard and Duplicate.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中，右键点击仪表板并复制。
- en: Rename the new one to "Palette".
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新名称重命名为“调色板”。
- en: Disable the old Dashboard.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用旧仪表板。
- en: Drag the Palette as a child of the Player/Hand1 object.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调色板作为Player/Hand1对象的子对象拖动。
- en: 'Now we''ll modify the Palette graphics as follows. Feel free to change for
    what works for you:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将修改调色板图形如下。请随意更改以适应你的需求：
- en: On the Palette itself, set its Pos X,Y,Z to (0, 0.1, -0.1); Rotation to (90,
    -150, -115); Scale (X,Y,Z) to 0.0005;
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板本身上，将其Pos X，Y，Z设置为（0，0.1，-0.1）；旋转设置为（90，-150，-115）；缩放（X，Y，Z）设置为0.0005；
- en: Unfold the Palette and disable or delete the Raw Image object.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开调色板并禁用或删除原始图像对象。
- en: Enable the Image child object (if it's missing, create a new Image with Anchor
    Presets to stretch-stretch).
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用图像子对象（如果缺失，创建一个新的图像并使用锚点预设进行拉伸拉伸）。
- en: Set the Image Scale (X,Y,Z) to 0.5.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像缩放（X，Y，Z）设置为0.5。
- en: Set the Image Color Alpha to 75 so it's translucent.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像颜色Alpha设置为75，使其半透明。
- en: Enable the Text child object. Set its Rect Transform Top to 100, Font Size to
    18, and Text to "Hose".
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用文本子对象。将其矩形变换顶部设置为100，字体大小设置为18，文本设置为“软管”。
- en: Move the StartButton Pos Y to 0.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将启动按钮的Pos Y移动到0。
- en: Move the StopButton Pos Y to 0.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将停止按钮的Pos Y移动到0。
- en: 'That''s it! All of the click wiring we set up for the Dashboard works without
    change. Shown here is a screenshot of using the Palette attached to the left-hand
    controller, and selecting the start button on it with the right-hand controller:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们为仪表板设置的点击连接都正常工作。这里展示的是使用左手持控制器附加的调色板，并用右手控制器选择其上的启动按钮的截图：
- en: '![](img/453a125e-8442-4dd8-9ef4-8d35a931515e.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/453a125e-8442-4dd8-9ef4-8d35a931515e.png)'
- en: Naturally, the palette can be extended with other buttons and input controls.
    If you had multiple panels arranged as the sides of cube (like the TiltBrush menu),
    you could use the thumb pad to scroll or rotate between the various menus.  And
    that's how it's done.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，调色板可以通过其他按钮和输入控件进行扩展。如果你有多个面板排列成立方体的侧面（如TiltBrush菜单），你可以使用拇指盘在各个菜单之间滚动或旋转。就是这样做的。
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In Unity, user interfaces that are based on a canvas object and the event system
    include buttons, text, images, sliders, and input fields, which can be assembled
    and wired to objects in the scene.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，基于画布对象和事件系统的用户界面包括按钮、文本、图像、滑块和输入字段，它们可以组装并连接到场景中的对象。
- en: In this chapter, we took a close look at various world space UI techniques and
    how they can be used in virtual reality projects. We considered ways in which
    UI for VR differs from UI for conventional video games and desktop applications.
    Also, we implemented over a half-dozen of them, demonstrating how each can be
    constructed, coded, and used in your own projects. Our C# scripting got a little
    more advanced, probing deeper into the Unity Engine API and modular coding techniques.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仔细研究了各种世界空间UI技术及其在虚拟现实项目中的应用。我们考虑了VR用户界面与传统视频游戏和桌面应用程序用户界面不同的方式。我们还实现了其中的一些，展示了如何在你的项目中构建、编码和使用它们。我们的C#脚本编写变得更加高级，深入探讨了Unity引擎API和模块化编码技术。
- en: You now have a broader vocabulary to approach UI in your VR projects. Some of
    the examples in this chapter can be directly applicable in your own work. However,
    not all need to be home-grown. VR UI tools are increasingly being provided in
    VR headset SDKs, open source VR middleware projects, and third-party Unity Assets
    Store packages.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有了更广泛的词汇来处理你的VR项目中的用户界面。本章中的一些示例可以直接应用于你的工作。然而，并非所有都需要从头开始。VR UI工具越来越多地提供在VR头戴式设备SDK、开源VR中间件项目和第三方Unity资产商店包中。
- en: In the next chapter, we will add a first-person character controller to our
    scene. We'll learn about avatars and methods to control navigation in VR so that
    we can comfortably move around inside the virtual world. Also, we'll learn about
    managing one of the negative aspects of virtual reality experiences—VR motion
    sickness.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的场景添加一个第一人称角色控制器。我们将了解化身以及控制VR中导航的方法，以便我们可以在虚拟世界中舒适地移动。此外，我们还将了解管理虚拟现实体验的负面方面之一——VR运动病。
