<html><head></head><body>
        

                            
                    <h1 class="header-title">Facade</h1>
                
            
            
                
<p>The Facade pattern is considered a Structural pattern so, as with most patterns of this type, it primarily focuses on identifying simple ways of establishing relationships between objects. The Facade pattern is an easy pattern to grasp because its name perfectly implies its design. The primary intent of the Facade pattern is to offer a simplified front-facing interface that abstracts the intricate inner workings of complex systems. This approach is beneficial for game developers because games are mostly constructed on layers of complexity and interacting systems.</p>
<p> </p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will be reviewing the basics of the Facade pattern</li>
<li>We will use the Facade pattern to implement a save system</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">This is a hands-on chapter, so you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following specific Unity engine and C# language concepts:</p>
<ul>
<li>Singleton</li>
<li>Serializable</li>
</ul>
<p>If you're unfamiliar with these concepts, please review them before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2I30suS">http://bit.ly/2I30suS</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Facade pattern</h1>
                
            
            
                
<p>The Facade pattern's name is analogous to a facade in architecture—as the name implies, it's an exterior face that hides a complex structure. But, contrary to architecture, in software development, the goal of a Facade is not to beautify, but instead to simplify. As we are going to see in the following diagram, the implementation of the Facade pattern is usually limited to a single class that acts as a simplified interface to a complex array of interdependent sub-systems:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fd5961a2-1b26-4510-8034-d986cbc013ef.png"/></p>
<p>As we can see, when a client calls the <kbd>SaveGame()</kbd> function of <kbd>SaveManager</kbd>, there's a series of calls made to various dependencies and sub-systems (namely <kbd>ScoreSystem</kbd>, <kbd>CloudManager</kbd>, and <kbd>UIManager</kbd>). All of this happens behind the scenes; the client is unaware of the number of the sub-systems being called to complete his request. So, to save the current game's status, the client only needs to know that there's a single function in the <kbd>SaveManager</kbd> class, and the Facade pattern implementation does the rest behind the scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p class="mce-root">The Facade pattern has some substantial benefits, but can also present some long-term drawbacks:</p>
<p>The <strong>benefits</strong> are as follows:</p>
<ul>
<li><strong>Simplified interface to a complex body of code</strong>: A solid Facade class will hide complexity and dependencies, while providing a simplified interface</li>
<li><strong>Localization of all your dependency calls</strong>: The Facade allows you to localize and group your dependencies into a single class</li>
<li><strong>Easier refactoring</strong>: Having complexity and dependency issues between sub-systems isolated in Facade classes simplifies the refactoring process, because you can refactor them in isolation without affecting clients, as the interfaces stay consistent</li>
</ul>
<p>The following are some <strong>drawbacks</strong> to watch out for:</p>
<ul>
<li><strong>It makes it easier to hide the mess</strong>: Having an excess of Facade classes can make it easier for programmers to disguise lousy code by making their architecture look simple to use, while brushing potential long-term architectural issues under the carpet.</li>
<li><strong>Too many managers</strong>: Manager classes are popular among Unity developers, and they often implement them by combining the Singleton and Facade patterns. This approach provokes an architecture that becomes an extensive collection of globally accessible managers. This type of design becomes very difficult to test and manage because the manager classes all become dependent on each other.</li>
</ul>
<p>The Facade establishes a new interface, whereas the Adapter recycles an old interface. It's important, when implementing patterns that might look and sound similar, to keep in mind that they're not necessarily identical in purpose.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">An example use case</h1>
                
            
            
                
<p class="mce-root">We are going to build a simple <em>save game</em> feature using a combination of the Facade and Singleton patterns. Our system has several steps that need to be executed in a specific sequence to complete the process of saving the player's progress. Here are the steps:</p>
<ol>
<li class="mce-root">Trigger <strong>User Interface</strong> (<strong>UI</strong>) feedback to indicate the game is saving</li>
<li class="mce-root">Get the current player's data (health, score, ID)</li>
<li class="mce-root">Save the player's data to disk</li>
<li class="mce-root">Upload the save to the Cloud</li>
</ol>
<p class="mce-root">We must respect the specific order of the preceding steps because we can't save to the disk before getting the current state of the player. But having to type each step manually in the right sequence every time we want to implement a save game event in our scripts can be time-consuming and error-prone. So, we are going to use the Facade pattern to establish a simple re-usable interface for our save game system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A code example</h1>
                
            
            
                
<p>As we are going to see, the Facade pattern is straightforward, so we will keep the following code example simple and straight to the point:</p>
<ol>
<li>First off, we are going to write the classes for each of our sub-system examples:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>Player</kbd>: This class represents our player component:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Player<br/>{<br/>    public int GetHealth()<br/>    {<br/>        return 10;<br/>    }<br/><br/>    public int GetPlayerID()<br/>    {<br/>        return 007;<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ul>
<li style="padding-left: 30px"><kbd>ScoreManager</kbd>: This class is responsible for managing the scoring system; it will return the current player's score:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class ScoreManager<br/>{<br/>    public int GetScore(int playerId)<br/>    {<br/>        Debug.Log("Returning player score.");<br/>        return 0;<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>CloudManager</kbd>: This class is responsible for managing the cloud account of the current player, including uploading their local save data:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class CloudManager<br/>{<br/>    public void UploadSaveGame(string playerData)<br/>    {<br/>        Debug.Log("Uploading save data.");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>UIManager</kbd>: And finally, the UI manager is responsible for displaying the UI components:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class UIManager<br/>{<br/>    public void DisplaySaveIcon()<br/>    {<br/>        Debug.Log("Displaying the save icon.");<br/>    }<br/>}</pre>
<ol start="2">
<li>Our next important class is a container that will hold the properties of the current player that we want to save. Notice that it's <kbd>Serializable</kbd>—this is because we are going to serialize an instance of this class when we save it to disk:</li>
</ol>
<pre style="padding-left: 60px">[System.Serializable]<br/>class PlayerData<br/>{<br/>    public int score;<br/>    public int playerID;<br/>    public float health;<br/>}</pre>
<ol start="3">
<li>Up next is the actual class that will act as our Facade. To avoid having a code example that's ten pages long, we are going to focus only on writing an elementary <kbd>SaveManager</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using System.IO;<br/>using UnityEngine;<br/>using System.Runtime.Serialization.Formatters.Binary;<br/><br/>public class SaveManager : Singleton&lt;SaveManager&gt;<br/>{<br/>    private UIManager m_UIManager;<br/>    private PlayerData m_PlayerData;<br/>    private ScoreManager m_ScoreManager;<br/>    private CloudManager m_CloudManager;<br/><br/>    public void SaveGame(Player player)<br/>    {<br/>        // 1 - Show the save icon on the corner of the screen.<br/>        m_UIManager = new UIManager();<br/>        m_UIManager.DisplaySaveIcon();<br/><br/>        // 2 - Initializing a new Player Data.<br/>        m_PlayerData = new PlayerData();<br/>        m_PlayerData.health = player.GetHealth();<br/>        m_PlayerData.playerID = player.GetPlayerID();<br/><br/>        // 3 - Getting the player's high score.<br/>        m_ScoreManager = new ScoreManager();<br/>        m_PlayerData.score = m_ScoreManager.GetScore(player.GetPlayerID());<br/>        <br/>        // 4 - Let's serialize the player data.<br/>        SerializePlayerData(m_PlayerData, true);<br/>    }<br/>    <br/>    private void SerializePlayerData(PlayerData playerData, bool isCloudSave)<br/>    {<br/>        // Serializing the PlayerData instance      <br/>        BinaryFormatter bf = new BinaryFormatter();<br/>        FileStream file = File.Create(Application.persistentDataPath + "/playerInfo.dat");<br/>        bf.Serialize(file, playerData);<br/>        file.Close();<br/>        <br/>        // Uploading the serialized playerInfo.dat file <br/>        if (isCloudSave)<br/>        {<br/>            m_CloudManager = new CloudManager();<br/>            m_CloudManager.UploadSaveGame(Application.persistentDataPath + "/playerInfo.dat");<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">As we can see, this small example of a <kbd>SaveManager</kbd> class presents a core problem: saving a player's progression has many steps and dependencies. Imagine if we had to write those steps by hand throughout our code every time we wanted to trigger a save game—this would be very difficult to maintain and debug.</p>
<ol start="4">
<li>We can see the benefits of the Facade pattern in action in the following <kbd>Client</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    private Player m_Player;<br/><br/>    void Start()<br/>    {<br/>        m_Player = new Player();<br/>    }<br/><br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.S))<br/>        {<br/>            // Save the current player instance.<br/>            SaveManager.Instance.SaveGame(m_Player);<br/>        }<br/>    }<br/>}</pre>
<p>Now, we can save the current player state from anywhere with just one line of code. This benefit is possible because our <kbd>SaveManager</kbd> is acting like a Facade and offering a simplified interface to a larger body of code. We have also localized the entire save game process so we can easily maintain it.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">We now have the Facade pattern in our toolkit. It fits in perfectly with the reality of managing a complex code base that has an extensive collection of sub-systems that are constantly interacting with each other and are codependent, as in most video games. If the Facade pattern is used wisely, and not as a crutch or a way to mask messy code, it can become a cornerstone of your architecture. But the most critical point to keep in mind is that when you have a feature that relies on a collection of sub-systems to operate, it's a good idea to localize those dependencies so you can easily debug, maintain, and refactor them.<br/>
<br/>
In the next chapter, we will explore the Adapter pattern, a close cousin of the Facade pattern, but with a very different design and intent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<p class="mce-root">In this chapter, we wrote the first draft of a <kbd>SaveManager</kbd> class. As an exercise, try to write for yourself a complete save system for your game. It will be a valuable long-term investment if you design one that can be re-usable for multiple projects. From experience, I often witness game project's get into difficulty later on in their development cycle because they don't have a solid save and serialization system in place early on, so having one already prepared in your back pocket can very helpful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Game Programming Patterns</em> by Robert Nystrom, available here:<strong><br/></strong><a href="http://gameprogrammingpatterns.com/">http://gameprogrammingpatterns.com</a></li>
</ul>


            

            
        
    </body></html>