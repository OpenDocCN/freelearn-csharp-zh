- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Community Toolkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some of the popular **Community Toolkits**
    that have been developed to assist developers in using data binding and the MVVM
    pattern more efficiently and effectively in .NET MAUI. These toolkits offer valuable
    components and utilities that can greatly enhance your development experience
    and help you build robust and maintainable applications. There are numerous large
    and small frameworks or toolkits that facilitate data binding and the application
    of the MVVM pattern in your projects. Some of them have a significant overall
    impact on your code, while others are more focused on providing developers with
    a set of helpers or components that you typically rewrite for each new project.
  prefs: []
  type: TYPE_NORMAL
- en: Every existing toolkit or framework is the product of dedicated developers investing
    their time and expertise, and each one provides value to its users, whether or
    not it suits your particular coding style. In this book, I don’t want to favor
    any specific framework or toolkit over others but rather showcase community-driven
    efforts that can be beneficial to developers. For this reason, we’ll be exploring
    two Community Toolkits that provide some helpers and base classes that you can
    build upon but don’t have a large impact on your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be discussing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The .NET MAUI Community Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other popular frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributing to the community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These toolkits were chosen as examples because they offer tools and components
    that can be integrated into your projects as needed, without imposing a specific
    architectural style or coding paradigm. This feature makes these toolkits particularly
    flexible and adaptable to a variety of coding styles and project requirements.
    Being part of the .NET Community Toolkits, they benefit from a wide community
    of contributors, including both Microsoft employees and independent developers.
    This collaboration ensures the toolkits remain up to date, reliable, and effective
    for developers across the board.
  prefs: []
  type: TYPE_NORMAL
- en: These toolkits aim to simplify many common tasks you will encounter when building
    .NET MAUI applications. The features they provide are often things we’ve covered
    in earlier chapters, but now, they’ve been conveniently implemented for you. It’s
    important to understand that these toolkits are not magical entities; they encapsulate
    strategies and techniques that you could implement yourself. However, their true
    value lies in offering a ready-made, community-approved solution, saving you significant
    time and effort. By knowing what’s available in these toolkits, you can make informed
    decisions about when to leverage them and when to customize your solutions. So,
    without further ado, let’s dive in and see what they have to offer!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be updating some code from the *Recipes!* app.
    The updated code can be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05)
    for reference and comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **MVVM Toolkit** (**CommunityToolkit.Mvvm**) is a comprehensive library
    that’s designed to simplify and streamline the implementation of the MVVM pattern
    in your applications. Developed and maintained by the .NET community, this toolkit
    provides a robust set of framework-independent tools, components, and utilities
    that help you build applications using the MVVM pattern. It’s important to note
    that this toolkit isn’t .NET MAUI-specific; it’s UI framework-agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key features of the MVVM Toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INotifyPropertyChanged` interface, simplifying the process of raising the
    `PropertyChanged` event. Its `SetProperty` method streamlines setting property
    values and automatically raises the `PropertyChanged` event when needed. By using
    this class, developers can reduce the boilerplate code associated with checking
    for property updates and triggering the `PropertyChanged` event accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObservableValidator` extends the `ObservableObject` class and includes built-in
    validation logic. This means that any object that inherits from `ObservableValidator`
    will have both observable and validating features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ICommand` interface. `RelayCommand` handles synchronous operations, while
    `AsyncRelayCommand` is designed for asynchronous tasks. Both support optional
    `CanExecute` logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakReferenceMessenger` is a messaging system that enables communication between
    loosely coupled components. It uses weak references to manage message subscriptions,
    which helps you avoid memory leaks and unintended strong dependencies between
    objects in your application. Messaging will be discussed in more depth in [*Chapter
    7*](B20941_07.xhtml#_idTextAnchor119), *Dependency Injection, Services,* *and
    Messaging*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObservablePropertyAttribute` simplifies the implementation of properties that
    trigger the `PropertyChanged` event, and `RelayCommandAttribute` automates the
    creation of commands, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only a few examples of the components of an MVVM Toolkit. The idea
    here was to let you know what the MVVM library has to offer. Now, let’s look into
    how to effectively use it in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the MVVM Toolkit to your project is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Recipes.Client.Core` project and select **Manage** **Nuget
    Packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for `MVVM Toolkit` and select **CommunityToolkit.Mvvm** from the list.
    *Figure 5**.1* shows the NuGet package we are searching for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1: CommunityToolkit.Mvvm NuGet package](img/B20941_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: CommunityToolkit.Mvvm NuGet package'
  prefs: []
  type: TYPE_NORMAL
- en: Hit `Recipes.Client.Core` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following example, we will be updating `RecipeDetailViewModel` and `IngredientsListViewModel`
    so that they use `ObservableObject` from the MVVM Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: ObservableObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing the `INotifyPropertyChanged` interface in each ViewModel can become
    tedious and repetitive. That’s why developers often create a base class that takes
    care of this task. The MVVM Toolkit provides such a base class for free in the
    form of `ObservableObject`.
  prefs: []
  type: TYPE_NORMAL
- en: By inheriting from `ObservableObject`, your ViewModel classes can automatically
    notify the View of property changes, keeping the UI synchronized with the underlying
    data. `ObservableObject` also provides the `SetProperty` method, which allows
    developers to set a property’s value. As a result, if the value has changed, it
    automatically triggers the `PropertyChanged` event to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our code so that our ViewModels inherit from `ObservableObject`
    instead of each one having its own implementation of the `INotifyPropertyChanged`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to `IngredientsListViewModel` and let this class inherit from `ObservableObject`
    instead of implementing the `INotifyPropertyChanged` interface, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By inheriting `ObservableObject`, we can remove the `OnPropertyChanged` method
    and the `PropertyChanged` event that we had before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we can update the setter of the `NumberOfServings` property so that it
    uses the `SetProperty` method of `ObservableObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SetProperty` method eases the implementation of calling the `PropertyChanged`
    event when the value is being updated. This method will update the provided backing
    field (`_numberOfServings`) and trigger the `PropertyChanged` event automatically
    when the value is being updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can start doing the same thing for `RecipeDetailViewModel` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherit from `ObservableObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `OnPropertyChanged` method and the `PropertyChanged` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the setter of `HideAllergenInformation` so that it uses the `SetProperty`
    method, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By ensuring our ViewModels inherit from `ObservableObject` and utilize the `SetProperty`
    method, we can eliminate excessive boilerplate code. This would benefit us by
    reducing a significant amount of ceremony. This helps maintain the conciseness
    and clarity of our ViewModels, allowing them to stay focused on their core responsibilities.
    Unless you are being paid by lines of code, I think you would agree that these
    updated classes look a lot better with a lot less boilerplate code!
  prefs: []
  type: TYPE_NORMAL
- en: One of the most helpful features in the MVVM Toolkit is the different `ICommand`
    implementations. Let’s take a look!
  prefs: []
  type: TYPE_NORMAL
- en: RelayCommand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MVVM Toolkit provides several robust implementations of the `ICommand`
    interface. Each implementation serves a unique purpose, addressing varied needs
    for communication between the ViewModel and View in different scenarios. These
    implementations help streamline command operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RelayCommand`: This straightforward implementation of `ICommand` allows you
    to specify `Execute` and `CanExecute` methods using delegates, tailoring what
    the command does and whether it can be executed at a given time. This implementation
    is similar to `Microsoft.Maui.Controls.Command`, which we used earlier. However,
    the `Command` implementation had the `ChangeCanExecute` method, which we can call
    to trigger the re-evaluation of the `CanExecute` method. On the `RelayCommand`
    class, a method with this behavior is called `NotifyCanExecuteChanged`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelayCommand<T>`: This is a variant of `RelayCommand` that adds support for
    a parameter that can be passed to the `Execute` and `CanExecute` methods. The
    type of the parameter is determined by the generic type parameter. This implementation
    is similar to `Microsoft.Maui.Controls.Command<T>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncRelayCommand`: An async variant of `ICommand`, `AsyncRelayCommand` returns
    a `Task`, making it ideal for managing asynchronous operations such as network
    data fetches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncRelayCommand<T>`: A parameter-supporting version of `AsyncRelayCommand`,
    this allows you to pass an argument to the asynchronous `Execute` and `CanExecute`
    methods, providing additional versatility for async operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we can update our command so that it leverages the `RelayCommand`
    and `RelayCommand<T>` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows how we can initialize the commands in the constructor
    by updating their type from `Microsoft.Maui.Controls.Command` to `CommunityToolkit.Mvvm.Input.RelayCommand`
    and from `Microsoft.Maui.Controls.Command<T>` to `CommunityToolkit.Mvvm.Input.RelayCommand<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This updated code will instantiate the three commands with a new `RelayCommand`,
    passing in the methods that should be triggered when calling the command’s `Execute`
    and `CanExecute` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we are at it, we can also go ahead and update the types of the commands
    in this class. While `RelayCommand` implements the `ICommand` interface, it also
    implements the `IRelayCommand` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By updating the type of our commands, as shown in the preceding snippet, we
    can avoid additional castings later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The setter of `IsFavorite` can now be updated to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SetProperty` method returns `true` if the property was changed. This allows
    us to do additional things when the property is changed (or not). For example,
    in this case, we want to re-evaluate the `CanExecute` method of the commands when
    the `IsFavorite` property changes its value by calling each command’s `NotifyCanExecuteChanged`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adhering to the best practices of MVVM
  prefs: []
  type: TYPE_NORMAL
- en: Because we don’t use `Microsoft.Maui.Control.Command` anymore, we can also remove
    the MAUI dependency that we currently have on this project. Click on the `Recipes.Client.Core`
    project so that the project’s `.csproj` file opens and remove the `<UseMaui>`
    tag. Now, the ViewModels (and the `Recipes.Client.Core` project) are platform-agnostic
    again, adhering to the best practices of MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015), it was apparent that applying
    the MVVM pattern involves a lot more code compared to writing everything in code-behind.
    Mostly, that’s because of all of the ceremony in the ViewModels. While classes
    such as `ObservableObject` already abstract away some of the boilerplate code,
    we could even go one step further and look at the Source Generators that are available
    in the MVVM Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Source Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source Generators are a compiler feature in .NET that allows developers to generate
    new code during the compilation process. This has the potential to greatly reduce
    manual coding and the likelihood of errors.
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM Toolkit provides `ObservablePropertyAttribute` and `RelayCommandAttribute`,
    which are used by the Source Generators to create properties that notify the UI
    of changes and commands that handle user interactions, respectively. Additionally,
    other attributes such as `NotifyPropertyChangedForAttribute` and `NotifyCanExecuteChangedForAttribute`
    can be used in combination with `ObservablePropertyAttribute` to add even more
    functionality through code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given how Source Generators work, the class on which these attributes are applied
    must be declared as a partial class. In C#, partial classes allow you to split
    a class across multiple files using the `partial` keyword. At compile time, the
    different files are combined into one class. This feature is integral to source
    generators, which generate additional source code during compilation. Therefore,
    when you wish to use any of these attributes, remember to declare your ViewModel
    as `partial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that the ViewModel has been declared as partial, we can begin to adapt our
    code to take advantage of these attributes. Let’s see how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ObservableProperty attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, we need to write some boilerplate code when implementing a property
    that triggers the `PropertyChanged` event. By using `ObservablePropertyAttribute`,
    we can let Source Generators generate this code for us.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute can be applied to a field; at build time, a public property will
    be generated, with the annotated field as the backing field.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can take a look at `RecipeDetailViewModel`. The `HideExtendedAllergenList`
    property can be deleted and `ObservablePropertyAttribute` can be added to the
    `_hideExtendedAllergenList` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this `ObservableProperty` attribute in place, a full-fledged public property
    named `HideExtendedAllergenList` will be generated at build time.
  prefs: []
  type: TYPE_NORMAL
- en: The generated property’s set method will contain logic that checks whether the
    value is updated and triggers the `PropertyChanged` event accordingly. The setter
    will also call a handful of partial methods that are being generated, allowing
    us to add some custom code while the property value is being updated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important to note that the `ObservableProperty` attribute generates
    a public property for us. When binding this value to the UI, make sure you bind
    to this generated property (`HideExtendedAllergenList`, in this case) and not
    try to bind to the field you’ve set the attribute on. Also, when assigning a value,
    always assign it to the generated property to make sure the `PropertyChanged`
    event gets triggered!
  prefs: []
  type: TYPE_NORMAL
- en: But what about the `IsFavorite` property of `RecipeDetailViewModel`?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this setter, we call the `NotifyCanExecuteChanged` method of our commands.
    Can we make this work on a generated property as well? Yes; for those cases, we
    have the `NotifyCanExecuteChangedFor` attribute, which accepts the name of the
    command whose `NotifyCanExecuteChanged` method needs to be triggered when the
    value of the property is updated. This means that the entire `IsFavorite` property
    could be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first attribute, `ObservableProperty`, will generate a property that will
    trigger the `PropertyChanged` event when its value is being updated. The next
    three `NotifyCanExecuteChangedFor` attributes will make sure that the `NotifyCanExecuteChanged`
    method of the three commands of the `IRelayCommand` type will be invoked when
    the property updates.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of commands, there’s a Source Generator for generating a `RelayCommand`
    as well. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RelayCommand attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can apply the `RelayCommand` attribute to a method that you intend to use
    as the execution action for a command. At build time, this will generate a public
    `RelayCommand` property with the same name as the method, suffixed with “Command.”
    When calling the `Execute` method of the generated `RelayCommand`, the method
    on which the attribute was applied will be invoked. This essentially simplifies
    the process of declaring a public `IRelayCommand` command, making a method to
    be invoked, and creating an instance of the command tied to that method, in the
    following simplified form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a `RemoveAsFavoriteCommand` public property of type `IRelayCommand`
    that will call the `RemoveAsFavorite` method when the command is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: When applying this attribute to a method that accepts one parameter, the resulting
    command will be a generic `RelayCommand<T>`, where `T` corresponds to the type
    of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also pass in a string parameter called `CanExecute` that
    points to a method, which should be invoked when calling the command’s `CanExecute`
    method. This is essential if we want to update `RecipeDetailViewModel` and let
    `AddAsFavoriteCommand`, `RemoveAsFavoriteCommand`, and `SetFavoriteCommand` be
    generated by Source Generators. Let’s see how we can achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the public `AddAsFavoriteCommand`, `RemoveAsFavoriteCommand`, and `SetFavoriteCommand`
    properties of type `IRelayCommand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the instantiation of these commands in the constructor of `RecipeDetailViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `RelayCommand` attribute to the `AddAsFavorite`, `RemoveAsFavorite`,
    and `SetFavorite` methods, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At build time, the public command will be generated thanks to the `RelayCommand`
    attributes. In this example, all of the attributes also point to a method that
    gets invoked when calling the generated command’s `CanExecute` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While Source Generators can greatly simplify code bases and improve productivity
    by automating boilerplate code, I choose not to use them for a couple of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, they can obscure some of the underlying implementation details. This
    might make it challenging for newcomers or less experienced developers to fully
    understand the code and its intrinsic patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, employing the MVVM Toolkit’s Source Generators may require adjusting
    your coding style to match the “prescribed” style inherent to the toolkit. This
    may not appeal to all developers who prefer more flexibility in their coding approach.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s essential to note that these are personal preferences, and many
    developers find great value in using Source Generators. They can significantly
    streamline your ViewModel development process, and if you find them beneficial
    and conducive to your coding style, I wholeheartedly recommend their usage!
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, Source Generators are a tool. Like any tool, it’s crucial
    to consider when and where they add the most value. Balancing the benefits of
    automation and simplicity with understanding, flexibility, and individual style
    in your code is always an important consideration in software development.
  prefs: []
  type: TYPE_NORMAL
- en: This covers most of the essentials of the MVVM Toolkit. Now, let’s see how the
    .NET MAUI Community Toolkit can make our lives easier when applying the MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET MAUI Community Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .**NET MAUI Community Toolkit** is a collection of useful components, controls,
    and utilities designed to enhance the development experience with .NET MAUI. Although
    its primary focus is not on enabling or facilitating MVVM, the toolkit does provide
    features that can greatly assist developers in implementing the MVVM pattern in
    their .NET MAUI projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behaviors**: These are reusable pieces of functionality that can be attached
    to certain types of controls. By encapsulating code in behaviors, you can keep
    your views clean and easy to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Converters**: As we’ve seen before, converters help transform data from one
    type into another, making it easier to bind data from your ViewModel to your View.
    The toolkit has a lot of converters for a huge range of common scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is much more to the .NET MAUI Community Toolkit, but in the context of
    MVVM, these are the relevant bits. Please note that this is a toolkit that should
    only be added to MAUI projects and not to the core project that houses your ViewModels,
    for example. Why? Because the .NET MAUI Community is .NET MAUI-dependent and therefore
    it should not be referenced to projects that are agnostic of UI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: By offering these additional features and helpers, the .NET MAUI Community Toolkit
    contributes to a more efficient and streamlined development process when working
    with MVVM in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the .NET MAUI Community Toolkit is just like installing any other
    NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Recipes.Mobile` project and select **Manage** **NuGet Packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for `Maui Community` and select **CommunityToolkit.Maui** from the list.
    *Figure 5**.2* shows the NuGet package we should download:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2: CommunityToolkit.Maui NuGet package](img/B20941_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: CommunityToolkit.Maui NuGet package'
  prefs: []
  type: TYPE_NORMAL
- en: Hit `Recipes.Mobile` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once installed, head over to `MauiProgram.cs` and make sure you call `UseMauiCommunityToolkit`
    on `MauiAppBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use components from the toolkit in XAML, you will need to add the namespace
    to the XAML pages where you want to use the toolkit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all of this is in place, we can start using the .NET MAUI Community Toolkit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding in .NET MAUI*,
    we discussed what value converters are and how to create them. The .NET MAUI Community
    Toolkit comes packed with a whole lot of ready-to-use value converters. One such
    converter is `ListToStringConverter`, which can be very handy for displaying a
    list of items as a single string. Let’s use it to display the allergen information
    of the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let’s add an array of strings called `Allergens` to `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property holds a list of all allergens that the recipe contains. For now,
    we’re hardcoding some values here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On `RecipeDetailPage`, add the toolkit’s namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow us to access the Community Toolkit library in XAML using the
    `toolkit` prefix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an instance of `ListToStringConverter` to the page’s `Resources`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ListToStringConverter` has a property called `Separator` that we set to ",".'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can update the label that should display the allergen information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This value converter and some other converters in the toolkit aren’t exactly
    rocket science. It’s something you could write yourself. However, in my opinion,
    why reinvent the wheel when someone has already done the hard work for you? Utilizing
    these ready-made tools can certainly make your coding life easier!
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behaviors allow you to add functionality to UI controls without the need to
    build custom controls from scratch. This greatly helps in constructing rich and
    intuitive user interfaces tailored to your specific requirements. By encapsulating
    UI-specific actions within the View layer, behaviors help reduce the complexity
    of ViewModels, adhering to the separation of concerns principle central to MVVM.
    The .NET MAUI Community Toolkit comes with a variety of ready-to-use behaviors,
    saving you time and effort in enhancing your UI.
  prefs: []
  type: TYPE_NORMAL
- en: One of the behaviors provided by the .NET MAUI Community Toolkit is `EventToCommand`,
    which allows you to map events to commands. This allows you to further enhance
    the decoupling of your UI and business logic. This behavior is particularly useful
    when dealing with events that do not directly support binding to commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very simple example, let’s imagine that we want to collect some user behavior
    throughout the app. One of the things we might be interested in is whether the
    user scrolls on a recipe page or not, as that might indicate some level of interest
    in that particular recipe. `ScrollView` has a `Scrolled` event, but no corresponding
    command. In such a use case, `EventToCommandBehavior` can be very helpful, as
    I will show you in the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `RelayCommand` on `RecipeDetailViewModel`, which needs to be invoked
    when the user scrolls on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can add `EventToCommandBehavior` to `ScrollView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Command` property of `EventToCommandBehavior` is bound to the `UserIsBrowsingCommand`
    property that we just created on the ViewModel. By setting the `EventName` property
    to `"Scrolled"`, we define that we want this command to be invoked on the `Scrolled`
    event of `ScrollView`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a final example to demonstrate how helpful this toolkit can be by combining
    behaviors and converters, imagine the following: a heart icon should always be
    shown on the screen, but only when the user has marked the recipe as a favorite,
    and it should be red. We can write this without adding a single line of C# code
    and without working with multiple icons! Let’s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, in our *Recipes!* app, the favorite icon was a little misplaced.
    Let’s start by placing the favorite icon next to the recipe title. You can accomplish
    this by replacing the label that displays the recipe’s title with the following
    XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the favorite icon will permanently appear right next to the recipe’s title.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The .NET MAUI Community Toolkit offers `IconTintColorBehavior`, which we can
    apply to change the color of `favoriteIcon`. We can add this behavior to our image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After adding this behavior, the icon will take on the specified `TintColor`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to set the `TintColor` value based on the `IsFavorite` property
    of `RecipeDetailViewModel`. Conveniently, the toolkit provides `BoolToObjectConverter`,
    which we can utilize to convert a `boolean` value into another value. We can add
    an instance of it to `RecipeDetailPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By setting this instance’s `TypeArguments` to `"Color"`, we specify that we
    want to convert a `bool` value into a `Color` value. The `FalseObject` and `TrueObject`
    properties set the values that the converter should return for false and true,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step is to update `IconTintColorBehavior` on the image. The challenge
    is binding the `TintColor` property of the behavior to the `IsFavorite` property
    of `RecipeDetailViewModel`. Since behaviors do not inherit their `BindingContext`
    from the controls they’re defined on, we’ll use `ElementBinding` to access `RecipeDetailViewModel`
    through the `BindingContext` of the `favoriteIcon`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The .NET MAUI Community Toolkit is an invaluable resource that streamlines the
    development process. It offers a wide variety of reusable building blocks, reducing
    the necessity for duplicative work and allowing you to focus on creating unique
    application features. With components such as behaviors, converters, and more,
    the toolkit empowers developers to build rich and interactive user experiences
    with less effort and complexity. Although the toolkit isn’t focused on MVVM, it
    helps in implementing the MVVM pattern by offering handy features such as behaviors,
    converters, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Other popular frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, there are numerous MVVM frameworks available, each with
    its unique characteristics and advantages. Throughout this chapter, we’ve explored
    the MVVM Toolkit and .NET MAUI Community Toolkit. These toolkits, being community-driven
    and highly accessible, offer a variety of useful tools to simplify your MVVM code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the landscape of MVVM frameworks is vast, so it might be worth seeing
    what other frameworks can provide. Here’s a list of some of the most popular third-party
    MVVM frameworks that are compatible with .NET MAUI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ReactiveUI: [https://www.reactiveui.net/](https://www.reactiveui.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prism Library: [https://prismlibrary.com/](https://prismlibrary.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TinyMvvm: [https://github.com/dhindrik/TinyMvvm](https://github.com/dhindrik/TinyMvvm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FreshMvvm: [https://github.com/XAM-Consulting/FreshMvvm.Maui](https://github.com/XAM-Consulting/FreshMvvm.Maui)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you are seeking a simple toolkit for the basics or a comprehensive framework
    with advanced capabilities, you will soon discover a framework that would best
    suit your specific needs and align with your coding style. However, it’s important
    to remember that using an MVVM framework is not a prerequisite for effective MVVM.
    It is entirely possible to implement the MVVM pattern effectively without a dedicated
    framework. Ultimately, the choice of whether to use a framework – and if so, which
    one – should depend on your project’s requirements, your team’s familiarity with
    the framework, and your personal coding preferences. *Remember, tools are there
    to assist you, not dictate how* *you code.*
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to the community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we wrap up this chapter, it’s important to recognize that these third-party
    toolkits and frameworks are, at their core, community contributions. They’re the
    result of someone else’s hard work, thought, and passion. All this code is accessible
    to you on platforms such as GitHub, and it’s maintained by community-minded individuals
    who are always open to suggestions, improvements, and bug reports.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, contributing to the community isn’t limited to creating a new project
    or toolkit of your own. It can be as simple as reporting a bug, suggesting a feature,
    or even making a small code improvement on an open source project. This open source
    ethos is one of the key strengths of the .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you’re using these frameworks and see something that can be improved
    or a bug that needs fixing, don’t hesitate to contribute. By doing so, you’ll
    not only improve the tool for yourself but also for other developers who use it.
    This way, you can give back to the community and maybe learn a thing or two in
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, never forget that these open source MVVM frameworks are not just
    tools for you to use, but they’re also opportunities for you to grow as a developer
    and contribute to the broader .NET community.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, both the MVVM Toolkit and .NET MAUI Community Toolkit offer a
    comprehensive collection of components that facilitate the implementation of the
    MVVM pattern in your applications. By using these toolkits, you can avoid the
    need to build everything from scratch or reinvent existing solutions, ultimately
    saving time and effort, and allowing you to focus on building your application.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the code samples in this book, we’ll be using the MVVM
    Toolkit and make use of classes such as `ObservableObject` and `RelayCommand`.
    These classes are quite straightforward to understand. Even if you choose not
    to use this toolkit, you should still find the code samples clear and comprehensible
    as the underlying concepts are not overly complex.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction to the MVVM Toolkit: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI Community Toolkit documentation: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI Community Toolkit converters: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI Community Toolkit behaviors: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObservablePropertyAttribute`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelayCommandAttribute`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
