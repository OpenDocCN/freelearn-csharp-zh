- en: Chapter 7. Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter takes a highly practical and specialized focus. Here, we''ll cover
    the development of a single Unity project from start to finish in creating a maze
    scene that features enemy characters with **Artificial Intelligence** (**AI**);
    these characters have the ability to search for and chase us, attack us, and also
    flee from us while looking for health-restore potions. The following screenshot
    shows the maze scene in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Artificial Intelligence](img/0655OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The maze scene
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The AI project for this book can be found in the book's companion files (code
    bundle) in the `ai` folder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In creating this project, we'll apply nearly all the concepts and ideas seen
    so far in an isolated and pure form, looking at how they come together in the
    project, alongside a unique range of AI concepts, such as **Finite State Machines**
    (**FSMs**), navigation meshes, line of sight, and more. To follow this chapter
    and get the most from it, I recommend that you create a new and blank Unity project
    and take each step from start to finish. The final, completed project arrived
    at by the end of this chapter can be found in the book's companion files (code
    bundle) in the `ai` folder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial Intelligence in games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of intelligence can be understood in many senses: psychological,
    scientific, philosophical, spiritual, sociological, and others. Many of them are
    profound. However, in video games, it''s primarily about appearances, namely,
    the appearance of intelligence. Perhaps, this is why the word "artificial" enters
    the title. The idea is that video games are primarily about having fun and interesting
    experiences. This means that the believability of a game for the gamer rests on
    how engaged they are with the events actually happening in the game. Thus, whenever
    a **non-player character** (**NPC**), such as an enemy wizard in an RPG, does
    something "silly" (like walking through solid walls for no good reason or aimlessly
    walking back and forth as though stuck), then the gamer perceives that something
    is wrong. They regard the characters as not acting intelligently just because
    the character''s behavior, in those specific circumstances, is not appropriate
    and cannot be explained reasonably with reference to anything else happening in
    the game. The "mistake" or "silliness" of the character''s behavior forces the
    player to recognize a glitch, and in doing so, the gamer is removed from the experience,
    becoming aware that it''s just a game. The upshot of this is that for games, AI
    largely consists of making characters respond appropriately to their situation
    whenever the gamer is looking. In games where AI is for enemies or opponents,
    this consists largely of tweaking difficulty, that is, not making the AI too easy
    or too hard. Seen in this way, AI is not about building a mathematical model of
    the human mind and consciousness that simulates what happens to us while thinking
    from an inward or internal perspective. It''s only about creating behaviors, making
    characters act as we''d expect them to under those specific conditions, as shown
    in the following screenshot. Consequently, there''s something "hollow" about AI
    for games, but this philosophical observation need not concern us here any further.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Artificial Intelligence in games](img/0655OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The enemy AI character to be created using the Unity constructor mesh
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll create a first-person sample game set inside a maze environment.
    Here, the player can attack enemies, and enemies can attack the player. The enemy
    mesh itself is based on the animated constructor character that ships with Unity
    and features the walk, run, and jump animations. The constructor character (not
    class constructors) will search the environment, look for the player, and when
    they are found, chase and attack them. The constructor can also be attacked, and
    when attacked, they will flee and search for power-ups if their health runs low.
    So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Starting the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start, create a blank, new Unity project with a new scene. For this sample,
    I've imported several Unity asset packages via the file menu command by selecting
    the **Import Package** option from **Asset**. The packages are **Character** **Controller**,
    **Skyboxes**, and **Particles**, as shown in the following screenshot. **Character
    Controllers** features the constructor mesh and animations, as well as a first-person
    controller prefab.
  prefs: []
  type: TYPE_NORMAL
- en: The **Skyboxes** package adds some eye candy for a sky that the camera will
    see, and the **Particles** package will be used to create a teleporter device,
    as we'll see.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the project](img/0655OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing assets into the project
  prefs: []
  type: TYPE_NORMAL
- en: Also, add a first-person controller and the maze mesh to the scene (the mesh
    is included in the book's companion files in the `assets` folder of this chapter)
    and create some lighting and light mapping to make things look good initially.
    The mesh was created in a 3D modeling program, in this case, Blender ([http://www.blender.org/](http://www.blender.org/)).None
    of these assets are, however, critical to AI per se, but they create a presentable
    gray-box scenario with which you can work. Lightmapping details are outside the
    scope of this book, but Lightmapping features can be accessed by selecting **Lightmapping**
    in the **Window** option from the application menu, as shown in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: More details on Lightmapping can be found in the online Unity documentation
    at [http://docs.unity3d.com/Manual/Lightmapping.html](http://docs.unity3d.com/Manual/Lightmapping.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the project](img/0655OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the initial scene
  prefs: []
  type: TYPE_NORMAL
- en: Baking a navigation mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enemy to be created needs to walk intelligently around the level to find
    and chase the player as well as to find health-restore power-ups. The AI cannot
    simply walk in a straight line between any two points, as there might be intervening
    obstacles such as walls and other characters. The AI should instead navigate around
    these objects when they're encountered. To achieve this in the long term, a navigation
    mesh should be used. This is an invisible mesh asset that Unity generates automatically
    to approximate all walkable, horizontal surfaces in the level, that is, surfaces
    classified as a floor. The navigation mesh itself contains no AI. It does not
    make anything walk. The navigation mesh is rather a mathematical model that contains
    all the necessary data that allows AI units to successfully calculate and travel
    a path that avoids obstacles as and when required. To generate a navigation mesh
    for the level, select the **Navigation** option from the **Window** tab of the
    application menu. This displays the **Navigation Mesh** tab, which can be docked
    into the Object Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the basics on navigation mesh baking, see the online Unity documentation
    at [http://docs.unity3d.com/Manual/Navmeshes.html](http://docs.unity3d.com/Manual/Navmeshes.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'When baking a navigation mesh, there are some additional details to keep in
    mind, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Baking a navigation mesh](img/0655OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preparing to bake a navigation mesh
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the **Radius** setting will likely require adjusting from its default.
    In short, this setting defines an imaginary circle around the feet of your characters;
    this circle indicates their approximate size as walking agents. If the radius
    is too large, the navigation mesh appears broken or fractured, and if it is too
    small, the mesh takes a long time to generate, and additionally, your agents will
    penetrate through walls while walking. A certain degree of trial and error and
    refinement lets you reach a value that works best for your project. For this sample,
    a value of 0.2 works best. If the radius is too high, your navigation mesh will
    fracture in narrow areas, which is not good because agents cannot travel across
    gaps, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Baking a navigation mesh](img/0655OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Navigation mesh fracture in narrow areas
  prefs: []
  type: TYPE_NORMAL
- en: Second, a navigation mesh (once generated) might appear raised above or offset
    upwards, away from the true mesh floor. If this happens, you could reduce the
    **Height Inaccuracy %** setting to `1` from the **Advanced** group, as shown in
    the following screenshot. This prevents your agents from appearing to hover in
    midair. Remember that after adjusting any settings, you need to rebake the navigation
    mesh to apply the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Baking a navigation mesh](img/0655OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reducing Height Inaccuracy % moves the generated navigation mesh closer to the
    true floor
  prefs: []
  type: TYPE_NORMAL
- en: From the figures, you can see that the maze scene features two separate maze
    areas (left and right) with no connecting mesh between them that allows the creation
    of a path. For this sample, the intelligent agents should be able to move freely
    between each section using a teleporter to transport them from one area to another,
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve a connection like this between a break in the navigation mesh that
    allows the AI to compute valid paths across surfaces, we could use off-mesh links.
    Add a new mesh to the level that should act as a teleporter pad or platform when
    stepped upon. For this example, I used a standard box mesh with a particle system
    for enhanced effect, but this is not essential. Then, attach an off-mesh link
    component to the mesh object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Baking a navigation mesh](img/0655OT_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a teleporter pad using off-mesh links
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the procedure for the destination teleporter pad. For each teleporter,
    assign the object's transform to the **Start** field of the off-mesh link component.
    This indicates the selected teleporter as the start point. Then, for the **End**
    field, assign the destination transform. This establishes a connection between
    the two teleporters that creates a path between them. When the connection is established,
    a connection arrow should be drawn in-between the scene viewport when the **Navigation**
    panel is open and active in the editor, as shown in the following screenshot.
    You can also generate off-mesh links automatically. For more information, visit
    [https://www.youtube.com/watch?v=w3-sSozYph4](https://www.youtube.com/watch?v=w3-sSozYph4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Baking a navigation mesh](img/0655OT_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining a connection between off-mesh links
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting project for this chapter, ready for AI coding, can be found in
    the book's companion files (code bundle) in the `Start` folder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Starting an NPC agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create an AI agent for the level, something that can interact with
    the player. First, the agent needs a physical mesh representation in the scene.
    For this, I used the `Constructor` mesh, which is part of the Unity **Character
    Controllers** package imported earlier. Drag-and-drop this from the **Project**
    panel into the scene and then remove any animator component that might be created,
    as shown in the following screenshot. The animations will be important, but a
    custom-made animator controller will be created later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting an NPC agent](img/0655OT_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a constructor mesh for the enemy character
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we're not using the third-person controller prefab; it's just
    the constructor mesh alone.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `NavMeshAgent` component to the object by navigating to **Component**
    | **Navigation** | **Nav Mesh Agent**. This allows the object to work with the
    navigation mesh, and it is able to find and travel paths when instructed. Set
    both the **Radius** and **Height** values of the component to match the dimensions
    of the mesh. Set the **Stopping Distance** to `2`; this controls how close to
    a destination that the player should reach before stopping, as shown in the following
    screenshot. Of course, for your own projects, the **Stopping Distance** value
    will probably need to be edited.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting an NPC agent](img/0655OT_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a NavMeshAgent component for pathfinding
  prefs: []
  type: TYPE_NORMAL
- en: Now, add a `Rigidbody` component and enable the **Is Kinematic** checkbox, as
    shown in the following screenshot. This allows the object to enter trigger volumes
    and be a part of the physics system by both causing and receiving physics events.
    However, with **Is Kinematic** checked, Unity will not override the object's transformation
    (position, rotation, and scale). This allows the `NavMeshAgent` exclusively to
    control the movement of the character.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting an NPC agent](img/0655OT_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a Rigidbody component for physics
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a `BoxCollider` component to the object and enable the **Is Trigger**
    checkbox to convert it into a trigger volume, that is, a volume that allows physical
    objects to pass through as opposed to blocking them. This will be used by the
    AI to approximate an agent''s field of view or viewing area. It will follow the
    agent, and only other objects entering its field are classified as worthy of further
    consideration. To size the volume to the agent''s field of view, use the **X**,
    **Y**, and **Z** size fields, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting an NPC agent](img/0655OT_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using a BoxCollider component to configure the field of view for an enemy agent
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create a new C# script file, `AI_Enemy.cs`, in the project to define
    the enemy intelligence. This script will encapsulate the complete AI for the enemy
    character and will be developed over the course of this chapter. Once the file
    is initially created, attach it to the enemy object in the scene. We're now ready
    to jump into the AI coding and graph building! We'll start by creating FSMs and
    their attendant states that specify how the enemy should behave.
  prefs: []
  type: TYPE_NORMAL
- en: Finite State Machines in Mecanim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this point onwards, we'll concentrate mainly on coding AI for the enemy
    character both in C# and in terms of visual coding for a Mecanim graph. Mecanim
    refers to the Unity's Animation System ([http://docs.unity3d.com/Manual/MecanimAnimationSystem.html](http://docs.unity3d.com/Manual/MecanimAnimationSystem.html)).
    In the upcoming sections, we'll piece together a complete class that looks at
    and discusses specific sections of code, and the full class source code will be
    pieced together as we go along. It can be viewed in the completed project in the
    `AI_Enemy.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: To start, let's examine FSMs conceptually. When thinking about the enemy character,
    we can observe in them a specific set of behaviors. The enemy begins the scene
    by standing idle and then proceeds to wander around on patrol. During their patrol,
    they might see the player character. If they do so, they'll chase the player until
    the player comes into attack range. When the player enters attack range, they'll
    attack the player. Now, the only exception to these rules is if the enemy sustains
    serious health damage that brings them close to death. On reaching critical levels
    like this, the enemy will, instead of acting aggressively, flee and search for
    a health-restore potion until their health level is returned to normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summarizing the enemy behavior sets like this, we''ve identified a number
    of discrete and critical states for enemy intelligence. These are idle, patrol,
    chase, attack, and flee. The enemy can be in one and only one of these states
    at any one time, and each state determines how the enemy will behave. To implement
    this logic, we can use an FSM design. This refers not to a specific class or object
    type (such as `MonoBehaviour` or `ScriptableObject`) but rather to a design pattern,
    a way of coding. An FSM begins with a finite set of states (idle, patrol, chase,
    and so on, as mentioned earlier) and then manages how the states are connected
    to one another logically. This determines when and how one state changes to another.
    The enemy for our situation here will depend, in fact, on two-state machines under
    the hood: one in C# code and the other in a Mecanim animator graph. The latter
    controls only the animation that should play for the enemy mesh during each state.
    Let''s build the Mecanim graph first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **Project** panel and create a new **Animator Controller**
    asset. Open the asset inside the **Animator** window that is accessible by selecting
    the **Animator** option in **Window** from the application main menu, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the animation graph
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mecanim animator graph defines all the possible animation states for the
    mesh, and these should correspond to the enemy states already outlined, namely,
    idle, patrol, chase, attack, and flee. To configure the animations for these states,
    select the **Constructor** mesh asset in the **Project** panel and make all animations
    loopable by enabling the **Loop Time** and **Loop Pose** checkboxes in the Object
    Inspector, as shown in the following screenshot. This prevents the character animations
    from stopping after playing only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preparation of animation assets for a Mecanim FSM
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add animation states to the graph, one animation per state. For the
    **Idle** state, the idle animation should play. For the **Patrol** state, the
    walk animation should play as the character should be walking around. For the
    **Chase** and **Flee** states, the run animation should play, and for the **Attack**
    state, the jump animation should play. The **Constructor** model lacks a dedicated
    animation for attacks, so (for this sample) the jump animation will suffice as
    an attack animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and add these to the graph by dragging-and-dropping each animation
    from the **Project** panel into the Graph Editor, and name each state as appropriate,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building an FSM in the Animator window
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the standard animation states added so far, let''s add an additional
    empty state too. This will be the initial and default state of the enemy; this
    state plays no animation and represents, effectively, a stateless state until
    we explicitly put the enemy into a specific state at level startup. To create
    an empty and default state, right-click on the empty space inside the Graph Editor
    and choose the **Empty** option in **Create State** from the context menu (rename
    it appropriately to `Start` or `Init`), and then make it the default state by
    right-clicking on the state and choosing **Set As Default**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the empty node as the default state
  prefs: []
  type: TYPE_NORMAL
- en: The graph now features one animation per state for the character, but the states
    are not connected; each state is isolated. Specifically, there's no logic that
    governs the conditions by which one state moves to another. To fix this, create
    five new triggers using the **Parameters** box in the bottom-left corner of the
    Mecanim window. A trigger variable is a special Boolean type that Unity will automatically
    reset to `false`; every time it's made `true`, it allows behaviors to be initiated
    once, such as state changes. The triggers, as we'll see, can be accessed in C#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, create five triggers: **Idle**, **Patrol**, **Chase**, **Attack**,
    and **SeekHealth**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Trigger variable for each animation state
  prefs: []
  type: TYPE_NORMAL
- en: 'With both the states and triggers created, the connection between the states
    in the graph can now be defined more precisely. Specifically, the **Idle** state
    should change to the **Patrol** state when the trigger **Patrol** is activated,
    the **Patrol** to the **Chase** state when trigger **Chase** is activated, the
    **Chase** state to the **Attack** state when trigger **Attack** is activated,
    and so on. In addition, there''s a two-way linkage between most states: **Patrol**
    can transition to **Chase** (such as when the enemy sees the player) and **Chase**
    can transition back to **Patrol** (when the enemy loses sight of the player).
    To create connections between states, right-click on a state, select **Make Transition**
    from the context menu, and then click on the destination state to which a connection
    should be made.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the condition for a state transition
  prefs: []
  type: TYPE_NORMAL
- en: The graph now defines a complete animation state machine (FSM) for an enemy
    object. Attaching this to the enemy object in the scene is simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an **Animator** component to the object and then drag-and-drop the **Animator**
    controller from the **Project** panel into the **Controller** field on the **Animator**
    component, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finite State Machines in Mecanim](img/0655OT_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Attaching Animator to an enemy object
  prefs: []
  type: TYPE_NORMAL
- en: Finite State Machines in C# – getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the FSM for animation is completed, we should turn our attention to
    an FSM in C# that governs the behavior of the enemy as well as initiates our triggers
    in the Mecanim graph to play the appropriate animations (walk and run) at the
    right time. To begin the implementation, add the following public enumeration
    to the top of the `AI_Enemy.cs` script file, as shown in the following code sample
    7-1\. This enumeration defines all the possible states in the FSM for the enemy,
    and each state is assigned its unique string hash code; that is, the `IDLE` state
    is assigned the value of `2081823275`, which is the hash code for the string `IDLE`,
    and so on. This will be important later to work with Mecanim and specifically
    to initiate triggers. You can retrieve the hash code for a string using the `StringToHash`
    function of the `Animator` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information can be found online at [http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html](http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the basis of the enumeration `AI_ENEMY_STATE`, the `AI_Enemy` class will
    maintain a public variable `CurrentState`, which expresses the active state of
    the enemy object right now. This variable will change over time as the states
    change, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Like most objects, the class `AI_Enemy` features an `Awake` function to retrieve
    cached component references to other components, including the `NavMeshAgent`
    and the local `Transform`, as well as to other objects in the scene, such as the
    `Player` object. These references will be used elsewhere in the script, as shown
    in the following code sample 7-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code uses cached variables: `ThisAnimator`, `ThisTransform`, `ThisAgent`,
    and `ThisCollider`. This lets us retrieve immediate and direct references to attached
    components at level startup, which saves us from having to call C# property functions
    (`get` and `set`) every time we need access to an object. Thus, `This.Transform`
    carries a greater performance overhead than the optimized, cached variable, `ThisTransform`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each state in the FSM will be coded as a separate Coroutine, one Coroutine per
    state. The Coroutine will loop infinitely and exclusively as long as the state
    is active, defining all behaviors for the enemy in that state. The primary job
    of the state machine is to select and initiate the appropriate state under the
    correct conditions. Let's start by creating the `Idle` state—the default or normal
    state for the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Idle state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The enemy object begins in the `Idle` state (a "doing nothing" state), which
    is primarily transitional. In this state, the enemies stand where they are, playing
    the idle animation. The state is entered once at scene startup, but we''ll also
    return to it when exiting some other states, as an intermediary step before moving
    onto a new state. Effectively, in this state, the enemy should always play the
    idle animation just once and then leave the state when the animation is completed.
    The enemy can further move to the `Patrol` state automatically, where they begin
    searching the scene for the player. This involves a two-step process. First, we''ll
    need to start playing the idle animation as the `Idle` state begins. Second, we''ll
    need to be notified when the idle animation has completed, to initiate a change
    to the `Patrol` state. Refer to the following code sample 7-3 for the `Idle` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 7-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 03**: `State_Idle` is coded as a Coroutine. For more information on
    Coroutines, see the online Unity documentation at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
    In short, a Coroutine works like an asynchronous function (as a code block that
    runs in the background, parallel to other functions). For this reason, the infinite
    loop in line 15 will not cause a crash because a Coroutine runs like a separate
    thread. Coroutines always return type `IEnumerator` and always feature a yield
    statement somewhere within their body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 09**: The animator `SetTrigger` function is called in this line; it
    passes the hash code for the string `Idle` as an argument to set the `Idle` trigger
    in the Mecanim graph, initiating a playback of the idle animation. This links
    the C# FSM to the Mecanim FSM. Notice that in line 12, the `Stop` function is
    called for the `NavMeshAgent` component to stop any movement that the object might
    have been performing. This is because while the idle animation is playing, the
    enemy should not be moving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 15**: Here, the `State_Idle` function enters an infinite loop; that
    is, it''ll loop frame by frame as long as the enemy is in an `Idle` state. While
    the `Idle` state is active, everything within the loop executes every frame that
    allows the object to update and change its behavior over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 18**: One exit condition for the `Idle` state, other than waiting for
    the idle animation to complete, is if the player is seen in the interim. Player
    visibility is determined by the Boolean variable `CanSeePlayer` (the details of
    line of sight are considered later). If `CanSeePlayer` is `true`, the `Chase`
    state is activated using the `StartCoroutine` function, and the `Idle` state is
    terminated with a call to yield break.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Idle` state, as implemented so far, loops infinitely and never changes
    to another state unless the player is seen. However, the `Idle` state should only
    be temporary; the idle animation should play once and then notify us of its completion.
    To achieve this playback notification, we can use Animation Events. To configure
    this, select the **Constructor** character mesh in the **Project** panel and open
    the **Animation** tab to examine the idle animation in the Object Inspector. From
    here, open the **Events** tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Idle state](img/0655OT_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding the Events tab in the Object Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, double-click on the animation timeline at time **1** (at the end) to
    insert a function call at that time. This sends a message to the enemy object
    when the animation completes, as shown in the following screenshot. For this purpose,
    I''ve coded a method `OnIdleAnimCompleted` inside the `AI_Enemy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Idle state](img/0655OT_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calling a function at animation end
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `OnIdleAnimCompleted` is called automatically by Unity when the
    idle animation completes. The following code sample 7-4 shows how this method
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Patrol state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `Patrol` state, the enemy should wander the environment and look for
    the player. This state can be entered from the `Idle` state, after the idle animation
    is completed, and also from the `Chase` state, if the enemy loses sight of the
    player during a chase. Patrol involves a looping logic. Specifically, the enemy
    should pick a random destination somewhere on the navigation mesh and then travel
    to that destination. When the destination is reached, the process should repeat
    and so on. The only condition that causes the enemy to leave this state is a sighting
    of the player, which demands a `Chase` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though simple to explain, this state relies on two more complex issues: first,
    a random location must be selected and second, a player visibility check should
    be performed. First, let''s consider the random location selection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Scene** tab, I created a collection of waypoints (empty game objects)
    that are tagged **Waypoint** and do nothing but mark locations on the `NavMesh`
    floor. Together, these represent all the possible locations to which an enemy
    could travel during a patrol. The enemy, therefore, needs to randomly select one
    of these destinations, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Patrol state](img/0655OT_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating Waypoint destinations in the Scene tab
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the destination selection for a `Patrol` state, the `Awake` function
    of `AI_Enemy` will first retrieve a list of all waypoints in the scene to be used
    later. We can do this using `Linq`, as shown in the following code sample 7-5\.
    This example code retrieves a static array of all transforms for waypoints in
    the scene, in a private variable named `Waypoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Having retrieved a list of all waypoints, the `Patrol` state can be coded,
    as shown in the following code sample 7-6, which regularly selects waypoints as
    move new targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 7-6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 12**: Here, the `Random.Range` function selects a random destination
    from the `Waypoints` array. This is passed as a destination argument to the `SetDestination`
    function of the `NavMeshAgent` component that sends the enemy to the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 28**: The function `Vector3.Distance` is used to determine whether the
    agent has reached the destination. This does not check for equality between the
    enemy position and destination position, because floating-point inaccuracy means
    we cannot guarantee that the two will ever be the same. Instead, it checks whether
    the enemy has come within a specified distance of the destination (`DistEps`),
    classifying that as having arrived.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 32**: If the destination is reached, the enemy would return to `Idle`.
    After waiting for one cycle of the idle animation, the enemy would again enter
    into the `Patrol` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 21**: Again, the `Patrol` state depends on whether the player is visible
    to the enemy. If so, they enter the `Chase` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Boolean variable `CanSeePlayer` indicates, for any frame, whether the player
    is currently visible to the enemy. This variable is updated on each frame. The
    process for this begins inside the `Update` function, as shown in the following
    code sample 7-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The key question for the `Update` function is whether the player is inside
    the box collider attached to the enemy; this box collider represents the enemy''s
    view or range. If the player is inside that box, the player could possibly be
    visible to the enemy. In this case, further checks are required to be sure. This
    is where the `HaveLineSightToPlayer` function is essential. This function returns
    a Boolean (`true`/`false`) value that indicates whether the player is visible
    to the enemy, as shown in the following code sample 7-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the earlier chapters, visibility is determined by a two-stage process.
    First, the angle between the enemy look at vector and the normalized vector, which
    points from the enemy to the player, decides the visibility. If the angle is less
    than the enemy's field-of-view angle, then the player would be in front of the
    enemy and they would be seen, provided no obstacles, such as walls, lie between
    the enemy and the player. The second test, performed by `Physics.Linecast`, determines
    whether an unbroken line can be drawn between the enemy and the player. If it
    can, then no obstacle would exist between them and the player would be seen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chase state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the player is seen by the enemy and is not within attacking distance, the
    enemy would run to attack the player. This state, in which the enemy runs towards
    the player with hostile intent, is the `Chase` state. There are two main exit
    conditions for this state. If the enemy reaches attacking distance, they should
    change from the `Chase` state to the `Attack` state. In contrast, if the player
    disappears from sight, the enemy should continue to chase as best as they can
    for a while and then give up the chase if, after an interval, the player still
    cannot be sighted. Refer to the following code sample 7-9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 7-9:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 17-48**: During this phase, the `State` loop determines that the player
    visibility has been lost. When this happens, the enemy will continue to chase
    the player for a period of `ChaseTimeOut`. After this time elapses, the enemy
    checks for player visibility again. If the player is sighted at that time, the
    chase resumes as it did earlier. Otherwise, the enemy changes to the `Idle` state,
    ready to begin a new patrol in search of the player again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 51-59**: Here, the `Chase` state checks whether the enemy has come
    within the attack range (`DistEps`). If so, the FSM would enter `State_Attack`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Attack state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Attack` state, the enemy continually attacks the player as long as
    they''re visible. After an attack, the enemy must recover before launching a new
    attack. The only exit condition for this state is losing sight of the player.
    When this happens, the enemy returns to the `Chase` state and, from there, they
    either go back to the attack state or into `Idle`, depending on whether the player
    has been found, as shown in the following code sample 7-10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Seek-Health (or flee) state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Seek-Health` state occurs when the enemy runs low on health and can restore
    it by collecting a medikit. This state is unlike most others, in that, it can
    be reached or entered from any state. The entering of this state doesn''t depend
    on its relationship to others, but only on the player''s health. Specifically,
    this state should be entered when the enemy''s health is reduced beyond a minimum
    floor. As a result of this configuration, be sure to hook up the `Seek-Health`
    animation state in the Mecanim graph to the **Any State** node that allows the
    run animation to be triggered in any state, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Seek-Health (or flee) state](img/0655OT_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Seek-Health state can be accessed from Any State
  prefs: []
  type: TYPE_NORMAL
- en: 'Each enemy maintains a `Health` variable; this variable is adjusted either
    up or down, depending on whether the enemy finds a medikit or is attacked. The
    change occurs inside the method `ChangeHealth`, and this is where we can determine
    whether a `SeekHealth` state must be initiated. The `ChangeHealth` function is
    public; it allows `SendMessage` and `BroadcastMessage` to trigger it as an event,
    if required, as shown in the following code sample 7-11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `State_SeekHealth` method can be coded, as shown in the following code
    sample 7-12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 7-12:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 17**: The `Health-Seek` state begins by finding the nearest medikit
    in the scene and uses it for the agent destination. This is, in a sense, cheating,
    because (of course) without remote viewing powers, the enemy should not be able
    to know where the nearest medikit is. However, remember that what matters is not
    what the enemy really knows but how it appears to the gamer. If the gamer doesn''t
    know about this logic and cannot learn about it from appearances, then it would
    be of no significance. Also note that it''s possible for the player or another
    enemy to collect the medikit before the enemy arrives at the destination. For
    this reason, on each frame, the enemy must determine whether the destination medikit
    is still valid, and if not, they must pick the next, nearest one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 23**: If there is no medikit available or the health has been restored
    to safe limits, the enemy would return to the `Idle` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SeekHealth` state demands that we find and retrieve a reference to the
    nearest medikit in the scene. This is achieved using a `GetNearestHealthRestore`
    method, as shown in the following code sample 7-13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete AI project created in this chapter can be found in the book''s
    companion files (code bundle) in the `ai` folder of this chapter. I recommend
    that you open it and then test it out. Using the first-person controller, the
    player can navigate the level, avoid enemies, and also attack when enemies are
    in range using the Space bar, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/0655OT_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the AI_Enemy class
  prefs: []
  type: TYPE_NORMAL
- en: There are, nonetheless, many ways in which the project can be improved further,
    for example, by adding multiple enemy types as well as varied strategies for each
    type, from taking cover to playing dead, and so on. However, nonetheless, we've
    come a long way and have developed Artificial Intelligence that relies on both
    a C# FSM as well as on a Mecanim FSM for animation playback.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll leap out of the world of AI and into the world of
    editor customization to make game development smoother!
  prefs: []
  type: TYPE_NORMAL
