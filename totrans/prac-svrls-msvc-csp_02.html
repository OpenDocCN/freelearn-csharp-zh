<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor038"/>2</h1>
<h1 class="chapterTitle" id="_idParaDest-29"><a id="_idTextAnchor039"/>Demystifying Microservices Applications</h1>
<p class="normal">Over the last decade, microservices architecture has taken a central role in modern software development. In this chapter, we will define what microservices architecture is. You will learn the reasons behind the success of microservices, their pros and cons, and when it is worth adopting them. Starting with the problems that led to their conception, we will discuss typical scenarios of when to use them, the impact of their adoption on overall project costs, and the returns you might expect.</p>
<p class="normal">You will get insights into the organization of microservices, discovering how it differs from the usual monolithic application by resembling more of an assembly line than user-requests-driven processing. This newly conceived organization brings with it new challenges that require ad hoc techniques to enforce coherence, coordination, and reliability.</p>
<p class="normal">Moreover, new patterns and best practices have been created to tackle challenges with microservices and optimize their advantages. We will introduce and summarize some fundamental patterns here, while their practical implementation, together with more specific patterns, will be detailed throughout the remainder of the book.</p>
<p class="normal">More specifically, this chapter covers the following:</p>
<ul>
<li class="bulletList">The rise of <strong class="keyWord">Service-Oriented Architectures</strong> (<strong class="keyWord">SOAs</strong>) and microservices</li>
<li class="bulletList">The definition and <a id="_idIndexMarker077"/>organization of microservices architecture</li>
<li class="bulletList">When is it worth adopting microservices architectures?<a id="_idTextAnchor040"/></li>
<li class="bulletList">Microservices common patterns</li>
</ul>
<h1 class="heading-1" id="_idParaDest-30"><a id="_idTextAnchor041"/>The rise of Service-Oriented Architectures (SOAs) and microservices</h1>
<p class="normal">Briefly defined, microservices are chunks of software deployed on computer networks that communicate through network protocols. However, this is not all; they must also obey a set of further constraints.</p>
<p class="normal">Before giving a more detailed definition of what a microservices architecture is, we must understand how the idea of microservices evolved and what kind of problems it was called to solve. We will describe the two main steps of this evolution across two separate subsections.</p>
<h2 class="heading-2" id="_idParaDest-31"><a id="_idTextAnchor042"/>The rise of SOA</h2>
<p class="normal">The first step in the direction of <a id="_idIndexMarker078"/>microservices was taken by the so-called <strong class="keyWord">service-oriented architectures</strong>, or <strong class="keyWord">SOAs</strong>, that is, architectures based on networks of communicating processes. Initially, SOAs were implemented as web services similar to the ones you might have already experienced in ASP.NET Core.</p>
<p class="normal">In an SOA, different macro-modules that implement different features or roles in software applications are exposed as separate processes that communicate with each other through standard protocols. The first SOA implementation was web services communicating through the XML-based SOAP protocol. Then, most web services architectures moved toward JSON-based web APIs, which you might already know about since REST web services are available as standard ASP.NET project templates. The <em class="italic">Further reading</em> section contains useful links that provide more details on REST web services.</p>
<p class="normal">SOAs were conceived during the boom in the creation of software for business applications as one of the ways to integrate the various preexisting applications used by different branches and divisions into a unique company information system. Since the preexisting applications were implemented with different technologies, and the software expertise available in the various branches and divisions was heterogeneous, SOA was the answer to the following compelling needs:</p>
<ol>
<li class="numberedList" value="1">Enabling software communication between modules implemented with different technologies and running on different platforms (Linux + Apache, Linux + NGINX, or Windows + IIS). In fact, software based on different technologies is not binary compatible, but it can still cooperate with others if each of them is implemented as a web service that communicates with the others through a technology-independent standard protocol. Among them, it is worth mentioning the text-based HTTP REST protocol and the binary gRPC protocol. Worth mentioning also is that the HTTP REST protocol is an actual standard while at the moment, gRPC is just a de facto standard proposed by Google. The <em class="italic">Further reading</em> section contains useful links for getting more details about these protocols.</li>
<li class="numberedList">Enabling the versioning of each macro-module to evolve independently from the others. For instance, you might decide to move some web service toward the new .NET 9 version to take advantage of new .NET features or new, available libraries, while leaving other web services that don’t need modifications with a previous version, say, .NET 8.</li>
<li class="numberedList">Promoting public web services that offer services to other applications. As an example, think of the various public services offered by Google, such as Google Maps, or the <a id="_idIndexMarker079"/>artificial intelligence services offered by Microsoft, such as language translation services.</li>
<li class="numberedList">Below is a diagram that summarizes classical SOA.</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B31916_02_1.png"/></figure>
<p class="packt_figref">Figure 2.1: SOA</p>
<ol>
<li class="numberedList" value="5">Over time, the company information system and other complex SOA applications conquered more markets and users, so new needs and constraints appeared. We will discuss them in the next subsection.</li>
</ol>
<h2 class="heading-2" id="_idParaDest-32"><a id="_idTextAnchor043"/>Toward microservices architectures</h2>
<p class="normal">As application users and traffic increased up to a different order of magnitude, the optimization of performance and the optimal balancing<a id="_idIndexMarker080"/> of hardware resources among the various software modules became a <em class="italic">must</em>. This led to a new requirement:</p>
<div><p class="normal"> Each software module must be scalable independently from the others so that we can allocate to each module the optimal quantity of resources it needs.</p>
</div>
<p class="normal">As the company information system gained a central role, its continuous operation, that is, almost zero downtime, became a <em class="italic">must</em>, leading to another important constraint:</p>
<div><p class="normal"> Microservices architecture must be redundant. Each software module must have several replicas running on different hardware nodes to resist software crashes and hardware failures.</p>
</div>
<p class="normal">Moreover, to adapt each application to a rapidly evolving market, the requirements on the development times became more compelling. Accordingly, more developers were needed to develop and maintain each application with the given strict milestones.</p>
<p class="normal">Unfortunately, handling software projects involving more than around four people to the required quality <a id="_idIndexMarker081"/>proved to be substantially impossible. So, a new constraint was added to SOAs:</p>
<div><p class="normal"> The services composing an application must be completely independent of each other so that they can be implemented by loosely interacting separate teams.</p>
</div>
<p class="normal">However, the maintenance effort also needed to be optimized, yielding another important constraint:</p>
<div><p class="normal"> Modifications to a service must not propagate to other services. Accordingly, each service must have a well-defined interface that doesn’t change with software maintenance (or that, at least, rarely changes). For the same reason, design choices adopted in the implementation of a service must not constrain any other application service.</p>
</div>
<p class="normal">The first and second requirements can be satisfied by implementing each software module as a separate service so that we might allocate more hardware resources to it by simply replicating it in N different instances as needed to optimize the overall performance and ensure redundancy.</p>
<ol>
<li class="numberedList" value="1">We also need a new actor, something that decides how many copies of each service to use and on what hardware to place them. There are similar entities called <strong class="keyWord">orchestrators</strong>. It is worth<a id="_idIndexMarker082"/> pointing out that we might also have several orchestrators, each taking care of a subset of the services, or no orchestrator at all!</li>
<li class="numberedList">Summing up, we moved from applications made of coarse-grained coupled web services to fine-grained and loosely coupled microservices, each implemented by a different developer team, as shown in the following figure.</li>
</ol>
<figure class="mediaobject"><img alt="Figure 2.2: Microservices architecture" src="img/B31916_02_2.png"/></figure>
<p class="packt_figref">Figure 2.2: Microservices architecture</p>
<ol>
<li class="numberedList" value="3">The diagram shows fine-grained microservices assigned to different loosely coupled teams. It is worth pointing out that while loose coupling was also an initial target for the primordial <a id="_idIndexMarker083"/>web services architectures, it took time to improve to a good level, till reaching its peak with the advent of microservices techniques.</li>
<li class="numberedList">The preceding diagram and requirements do not define exactly what microservices are; they just explain the start of the microservices era. In the next section, we will give a more formal definition of microservices that reflects their current stage of evolution.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-33"><a id="_idTextAnchor044"/>The definition and organization of microservices architectures</h1>
<p class="normal">In this section, we will give a <a id="_idIndexMarker084"/>definition of microservices and detail their immediate consequences on an organization, distinguishing between the <em class="italic">microservices definition</em>, which is expected to change gradually over time, and <em class="italic">microservices practical organization</em>, which might evolve at a faster rate as new technologies appear.</p>
<p class="normal">In the first subsection, we will focus on the definition and its immediate consequences.</p>
<h2 class="heading-2" id="_idParaDest-34"><a id="_idTextAnchor045"/>A definition of microservices architectures</h2>
<p class="normal">Let’s first list all the microservices<a id="_idIndexMarker085"/> requirements. Then, we will discuss each of them in a separate subsection.</p>
<p class="normal">A microservices architecture is an architecture based on SOA that satisfies all the constraints below:</p>
<ul>
<li class="bulletList">Module boundaries are defined according to the domain of expertise they require. As we will discuss in the subsections below, this should ensure they are loosely coupled.</li>
<li class="bulletList">Each module is implemented as a <a id="_idIndexMarker086"/>replicable service, called a <strong class="keyWord">microservice</strong>, where replicable means one can create several instances of each service to enforce scalability and redundancy.</li>
<li class="bulletList">Each service can be implemented and maintained by a different team, where all teams are loosely coupled.</li>
<li class="bulletList">Each service has a well-defined interface known to all teams involved in the development project.</li>
<li class="bulletList">Communication protocols are decided at the project start and are known by all teams.</li>
<li class="bulletList">Each service must depend just on the interface exposed by the others and on the communication protocols adopted. In particular, no design choice adopted for a service can impose constraints on the implementation of the others.</li>
</ul>
<p class="normal">You are encouraged to compare each of the above constraints with the requirements that led to the conception of microservices architecture discussed in the previous section. In fact, each of these constraints is the immediate result of one or more of the previous requirements.</p>
<p class="normal">Let’s discuss each constraint in detail.</p>
<h3 class="heading-3" id="_idParaDest-35"><a id="_idTextAnchor046"/>Domain of expertise and microservices</h3>
<p class="normal">This constraint has the purpose of<a id="_idIndexMarker087"/> providing a practical rule for defining the boundary of each microservice so that microservices are kept loosely coupled and can be <a id="_idIndexMarker088"/>handled by loosely coupled teams. It is based on the theory of <strong class="keyWord">domain-driven design</strong> developed by Eric Evans (see <em class="italic">Domain-Driven Design</em>: <a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</a>). Here, we will go over just a few essential concepts of this theory, but if you’re interested in reading more, refer to the <em class="italic">Further reading</em> section for more details.</p>
<p class="normal">Basically, each domain of expertise uses a typical language. Therefore, during the analysis, it is enough to detect changes in the language used by the experts you speak with to understand what is included in and excluded from each microservice.</p>
<p class="normal">The rationale behind this technique is that toughly interacting people always develop a specific language recognized by others who share the same domain of expertise, while the absence of such a common language is a signal of loose interaction.</p>
<p class="normal">This way, the application <strong class="keyWord">domain</strong> or an application <strong class="keyWord">subdomain</strong> is split into so-called <strong class="keyWord">bounded contexts</strong>, each characterized by the usage of a<a id="_idIndexMarker089"/> common language. It is worth <a id="_idIndexMarker090"/>pointing out that <strong class="keyWord">domain</strong>, <strong class="keyWord">subdomain</strong>, and <strong class="keyWord">bounded context</strong> are all core concepts of DDD. For more <a id="_idIndexMarker091"/>details on them and <a id="_idIndexMarker092"/>DDD, you may refer to the <em class="italic">Further reading</em> section, but our simple description should suffice for getting started with microservices.</p>
<p class="normal">Thus, we get the first division of the application<a id="_idIndexMarker093"/> into <strong class="keyWord">bounded contexts</strong>. Each is assigned to a team and a formal interface for each of them is defined. This interface becomes the specification of a microservice, and it is also <a id="_idIndexMarker094"/>everything the other teams must know about the microservice.</p>
<p class="normal">Then, each team that has been assigned a microservice can split it further into smaller microservices to scale each of them independently from the others, checking that each resulting microservice exchanges an acceptable quantity of messages with the others (loose coupling).</p>
<p class="normal">The first division is used to split the work among the teams, while the second division is designed to optimize performance in various ways, which we will detail in the <em class="italic">Microservices organization</em> subsection.</p>
<h2 class="heading-2" id="_idParaDest-36"><a id="_idTextAnchor047"/>Replicable microservices</h2>
<p class="normal">There should be a way to create several instances of the same microservice and place them on the available hardware to allocate <a id="_idIndexMarker095"/>more hardware resources to the <a id="_idIndexMarker096"/>most critical microservices. For some applications or single microservices, this can be done manually; but, more often, dedicated software tools called <strong class="keyWord">orchestrators</strong> are <a id="_idIndexMarker097"/>adopted. In this book, we will describe<a id="_idIndexMarker098"/> two orchestrators: <strong class="keyWord">Kubernetes</strong>, in <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Practical Microservices Organization with Kubernetes</em>, and <strong class="keyWord">Azure Container Apps</strong>, in <a href="Chapter_9.xhtml#_idTextAnchor261"><em class="italic">Chapter 9</em></a>, <em class="italic">Simplifying Containers and Kubernetes: Azure Container Apps</em><em class="italic"> and other Tools</em>.</p>
<h3 class="heading-3" id="_idParaDest-37"><a id="_idTextAnchor048"/>Splitting microservices development among different teams</h3>
<p class="normal">The way microservices are defined, so that they can be assigned to different loosely coupled teams, has already been explained in the <em class="italic">Domain of expertise and microservices</em> subsection. Here, it is worth pointing out that<a id="_idIndexMarker099"/> the microservices defined at this stage are <a id="_idIndexMarker100"/>called <strong class="keyWord">logical microservices</strong>, and then each team can decide to split each<a id="_idIndexMarker101"/> logical microservice into one or more <strong class="keyWord">physical microservices</strong> for various practical reasons.</p>
<h3 class="heading-3" id="_idParaDest-38"><a id="_idTextAnchor049"/>Microservices, interfaces, and communication protocols</h3>
<p class="normal">Once microservices are assigned to different teams, it is time to define their interfaces and the communication protocol used for each kind of message. This information is shared among all teams so that each team knows how to communicate with the microservices handled by the other teams.</p>
<p class="normal">Only the interfaces of all logical microservices and the associated communication protocols must be shared among all teams, while the division of each logical microservice into physical microservices is just shared within each team.</p>
<p class="normal">The coordination of the various teams, and the documentation and monitoring of all services, is achieved with various tools. Below are the main tools used:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Context maps</strong> are a graphical <a id="_idIndexMarker102"/>representation of the organizational relationships among the various teams working on all application-bounded contexts. </li>
<li class="bulletList"><strong class="keyWord">Service catalogs</strong> collect information <a id="_idIndexMarker103"/>about all microservice requirements, teams, costs, and <a id="_idIndexMarker104"/>other properties. Tools like <strong class="keyWord">Datadog</strong> (<a href="https://docs.datadoghq.com/service_catalog/">https://docs.datadoghq.com/service_catalog/</a>) and <strong class="keyWord">Backstage</strong> (<a href="https://backstage.io/docs/features/software-catalog/">https://backstage.io/docs/features/software-catalog/</a>) perform various <a id="_idIndexMarker105"/>types of monitoring, while tools like <strong class="keyWord">Postman</strong> (<a href="https://www.postman.com/">https://www.postman.com/</a>) and <strong class="keyWord">Swagger</strong> (<a href="https://swagger.io/">https://swagger.io/</a>) are mainly<a id="_idIndexMarker106"/> focused on formal requirements, such as the<a id="_idIndexMarker107"/> testing and automatic generation of clients for interacting with the services.</li>
</ul>
<h3 class="heading-3" id="_idParaDest-39"><a id="_idTextAnchor050"/>Just the interfaces of the logical microservices are public</h3>
<p class="normal">The code of each microservice can’t make<a id="_idIndexMarker108"/> any assumptions about how the public interface of all other logical microservices is implemented. Nothing can be assumed about the technologies used (.NET, Python, Java, and so on) and their versions, and nothing can be assumed about the algorithms and data architectures used by other microservices.</p>
<p class="normal">Having analyzed the definition of microservices architecture, and its immediate consequences, we can move to the current most practical way to organize them.</p>
<h2 class="heading-2" id="_idParaDest-40"><a id="_idTextAnchor051"/>Microservices organization</h2>
<p class="normal">The first consequence of the independence of microservices design choices is that each microservice must have private <a id="_idIndexMarker109"/>storage because a shared database would cause dependencies among the microservices sharing it. Suppose microservices A and B both access the same database table, T. Now, we’re modifying microservice A to meet a new user’s requirements. As part of this update, the solution for A will require us to replace table T with two new tables, T1 and T2.</p>
<p class="normal">In a similar situation, we would be forced to also change the code of B to adapt it to the replacement of T with T1 and T2. Clearly, the same limitation doesn’t apply to different instances of the same microservice, so they can both share the same database. To summarize, we can state the following:</p>
<div><p class="normal"> Instances of different microservices can’t share a common database.</p>
</div>
<p class="normal">Unfortunately, moving away from a single-application database inevitably leads to data duplication and coordination challenges. More specifically, the same chunk of data must be duplicated in several microservices, so when it changes, the change must be communicated to all microservices that are using a duplicated copy of it.</p>
<p class="normal">Thus, we may state another organizational constraint:</p>
<div><p class="normal">Microservices must be designed in a way that minimizes the duplication of data, or stated differently, duplications should involve as few microservices as possible.</p>
</div>
<p class="normal">As has been said in the previous section, if we define microservices according to the domain of expertise, the last constraint should be ensured automatically because different domains of expertise usually share just a little data.</p>
<p class="normal">No other constraints descend immediately from the definition of microservices, but it is enough to add a trivial performance constraint on the response time to force the organization of microservices in a way<a id="_idIndexMarker110"/> that it more closely resembles an assembly line than a usual user-request-driven software. Let’s see why.</p>
<p class="normal">A user request coming to microservice A might cause, in turn, a long chain of requests issued to other microservices, as shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 2.3: Chain of synchronous request-responses" src="img/B31916_02_3.png"/></figure>
<p class="packt_figref">Figure 2.3: Chain of synchronous request-responses</p>
<p class="normal">Messages 1-6 are triggered by a request to microservice <em class="italic">A</em> and are sent in sequence, so their processing times sum up to the response time. Moreover, microservice <em class="italic">A</em>, after having sent message <em class="italic">1</em>, remains blocked, waiting for a response, until it receives the last message (<em class="italic">6</em>); that is, it remains blocked for the whole lifetime of the<a id="_idIndexMarker111"/> overall chained communication process.</p>
<p class="normal">Microservice <strong class="keyWord">B</strong> remains blocked twice, waiting for an answer to a request it issued. The first time is during the <em class="italic">2</em>-<em class="italic">3</em> communication and then the second is during the <em class="italic">4</em>-<em class="italic">5</em> communication. To sum up, a naive request-response pattern to microservices communication implies high response times and a waste of microservices computation time.</p>
<p class="normal">The only ways to overcome the above problems are either avoiding complete dependencies among microservices or caching all information needed to satisfy any user request into the first microservice, <em class="italic">A</em>. Since<a id="_idIndexMarker112"/> reaching total independence is basically impossible, the usual solution is caching in <em class="italic">A</em> whatever data it needs to answer requests without asking for further information about other microservices.</p>
<p class="normal">To achieve this goal, microservices are p<a id="_idTextAnchor052"/>roactive and adopt <a id="_idIndexMarker113"/>the so-called <strong class="keyWord">asynchronous data-sharing</strong> approach. Whenever they update data, they send the updated information to all other microservices that need it for their responses. Put simply, in the example above, tree nodes, instead of waiting for requests from their parent nodes, send pre-processed data to all their possible callers each time their private data changes, as shown in the figure below.</p>
<figure class="mediaobject"><img alt="Figure 2.4: Data-driven communication" src="img/B31916_02_4.png"/></figure>
<p class="packt_figref">Figure 2.4: Data-driven communication</p>
<p class="normal">Both communications labeled <em class="italic">1</em> are triggered when the data of the <em class="italic">C</em>/<em class="italic">D</em> microservices changes, and they may occur in parallel. Moreover, once communication is sent, each microservice can return to its job without waiting for a response. Finally, when a request arrives at microservice <em class="italic">A</em>, it already has all the data it needs to build the response with no need to interact with other microservices. In general, microservices <a id="_idIndexMarker114"/>based on <strong class="keyWord">asynchronous data sharing</strong> pre-process data and send it to whichever<a id="_idIndexMarker115"/> other service might need it as soon as their data changes. This way, each microservice already contains precomputed data that it can use to respond immediately to user requests with no need for further request-specific communications.</p>
<p class="normal">This time, we can’t speak of requests and responses but simply of messages exchanged. People working with classical web applications will be accustomed to request/response communications where a client issues a request and a server processes that request and sends back a response.</p>
<div><p class="normal">In general, in a request/response communication, one of the involved actors, say, <strong class="keyWord">A</strong>, sends a message containing a <strong class="keyWord">request</strong> to perform some <a id="_idIndexMarker116"/>specific processing to another actor, say, <strong class="keyWord">B</strong>, then <strong class="keyWord">B</strong> performs the required processing and <a id="_idIndexMarker117"/>returns a result (the <strong class="keyWord">response</strong>), which may also be an error notification.</p>
<p class="normal">However, we may also have communications that are not request/response-based. In this case, we simply speak of messages. In this case, there are not responses but just acknowledgments that the messages have been correctly received by either the final target or an intermediate actor. Differently from responses, acknowledgments are sent before completing the processing of the messages.</p>
</div>
<p class="normal">Returning to <strong class="keyWord">asynchronous data sharing</strong>, as new <a id="_idIndexMarker118"/>data becomes available, each microservice does its job and then sends the results to all interested microservices, and then it continues performing its job without waiting for a response from its recipients.</p>
<p class="normal">Each sender just waits for an acknowledgment from its immediate recipient, so wait times do not add up like in the initial <a id="_idIndexMarker119"/>chained request/response example.</p>
<p class="normal">What about message acknowledgments? They also cause small delays. Is it possible to also remove this smaller inefficiency? Of course, with the help of asynchronous communication!</p>
<div><p class="normal">In synchronous communication, the sender waits for the message acknowledgment before continuing its processing. This way, if the acknowledgment times out or is replaced by an error notification, the sender can perform corrective actions, such as resending the message.</p>
<p class="normal">In asynchronous communication, the sender doesn’t wait for either an acknowledgment or an error notification but continues its processing, immediately after the message is sent, while acknowledgments or error notifications are sent to a callback.</p>
</div>
<p class="normal">Asynchronous communication is more effective in microservices because it completely avoids wait times. However, the necessity to perform corrective actions in case of possible errors complicates the overall message-sending action. More specifically, all sent messages must be added to a queue, and each time an acknowledgment arrives, the message is marked as correctly sent and removed from this queue. Otherwise, if no acknowledgment arrives within a configurable <code class="inlineCode">timeout</code> time, or if an error is raised, the message is marked to be re-sent according to some retry policies.</p>
<p class="normal">The microservices <strong class="keyWord">asynchronous data-sharing</strong> approach is<a id="_idIndexMarker120"/> often accompanied by the <a id="_idIndexMarker121"/>so-called <strong class="keyWord">Command Query Responsibility Segregation</strong> (<strong class="keyWord">CQRS</strong>) pattern. According to CQRS, microservices are split into <em class="italic">updates microservices</em>, which perform the usual CRUD operations, and <em class="italic">query microservices</em>, which are specialized in answering queries that aggregate data from several other microservices, as shown in the following figure:</p>
<figure class="mediaobject"> <img alt="Figure 2.5: Updates and query microservices" src="img/B31916_02_5.png"/></figure>
<p class="packt_figref">Figure 2.5: Updates and query microservices</p>
<p class="normal">According to the <strong class="keyWord">asynchronous data-sharing</strong> approach, each update microservice sends all its modifications to the query services <a id="_idIndexMarker122"/>that need them, while query microservices precompute all queries to ensure short response times. It is worth pointing out that data-driven updates resemble a factory assembly line that builds all possible query results.</p>
<p class="normal">Both updates and query<a id="_idIndexMarker123"/> microservices are called <strong class="keyWord">frontend </strong>microservices because <a id="_idIndexMarker124"/>they are involved in the usual request-response pattern with the user. However, data updates in their path may also encounter microservices that do not interact at all with a user. They are <a id="_idIndexMarker125"/>called <strong class="keyWord">worker</strong> microservices. The following figure shows the relationship between worker and frontend microservices.</p>
<figure class="mediaobject"><img alt="Figure 2.6: Frontend and worker microservices" src="img/B31916_02_6.png"/></figure>
<p class="packt_figref">Figure 2.6: Frontend and worker microservices</p>
<p class="normal">While frontend microservices usually respond to several user requests in parallel by creating a thread for each request, worker microservices are involved only in data updates, so they don’t need to parallelize requests to ensure low response times to the user.</p>
<p class="normal">Accordingly, their operation is completely analogous to the one of the stations that compose an assembly line. They extract their input messages from an input queue and process them one after the other. Output data is<a id="_idIndexMarker126"/> sent to all interested microservices as soon as they are available. This <a id="_idIndexMarker127"/>kind of processing is called <strong class="keyWord">data-driven</strong>.</p>
<p class="normal">One might object that worker microservices are not necessary since their job might be taken care of by the frontend services that consume their outputs. This is not the case! For instance, let’s imagine accounting data that needs to be consolidated over a period of time before being used as fields of complex queries. Of course, each query microservice that needs the consolidated data might take care of consolidating it. However, this would result in the duplication of the processing effort and the storage needed to hold the partial sums.</p>
<p class="normal">Moreover, embedding the consolidation processing in other microservices would enable its independent scaling, with better optimization of the overall performance.</p>
<p class="normal">The next subsection shows an example that exemplifies all the concepts learned so far.</p>
<h2 class="heading-2" id="_idParaDest-41"><a id="_idTextAnchor053"/>Car-sharing example</h2>
<p class="normal">The following figure shows a <a id="_idIndexMarker128"/>communication diagram of the routes-handling part of a car-sharing application. Dashed lines surround all physical microservices belonging to the same logical microservice. Query microservices are at the top of the image, updates microservices are at the bottom, and worker microservices are in the middle (with gray shading).</p>
<figure class="mediaobject"><img alt="Figure 2.7: Route-handling subsystem of a car-sharing application" src="img/B31916_02_7.png"/></figure>
<p class="packt_figref">Figure 2.7: Route-handling subsystem of a car-sharing application</p>
<p class="normal">The language analysis detected two logical microservices. The first one speaks the language of the car sharer and is made of six physical microservices. The second one is focused on topology since it finds the best routes between a source and a destination and matches intermediate source-destination pairs with existing routes.</p>
<p class="normal">Car holders handle their requests with CRUD operations on the <code class="inlineCode">Car-Holding-Requests</code> updates microservice, whi<a id="_idTextAnchor054"/>le users looking for a car interact with the <code class="inlineCode">Car-Seeking-Requests</code> updates microservice in a similar way. The <code class="inlineCode">Routes-Listing</code> microservice lists all available trips with empty slots for <a id="_idIndexMarker129"/>new passengers to help car seekers choose the date of their trip. Once the date is chosen, the request is submitted through the <code class="inlineCode">Car-Seeking-Requests</code> microservice.</p>
<p class="normal">Both car holders and car seekers interact with the <code class="inlineCode">Route-Choosing</code> updates microservice. Car seekers choose one of several available routes for both the source and destination, while car holders accept car seekers by selecting the routes that fit their sources and destinations. Once a route is selected by a car seeker and accepted by the car holder, all other incompatible options are deleted from the best matches of both the car holder and the car seeker.</p>
<p class="normal">All available routes for b<a id="_idTextAnchor055"/>oth car seekers and car holders are listed by the <code class="inlineCode">My-Best-Matches</code> microservice. The <code class="inlineCode">Routes-Planner</code> worker microservice computes the best routes that fit for the source and destination of a car holder that contains also sources and destinations for some car seekers. It stores unmatched car-seeker requests until a route passing at an acceptable distance from them is added. When this happens, the <code class="inlineCode">Routes-Planner</code> microservice creates a new alternative route for the same trip that contains the new source-destination pair. All routes’ changes are sent to both the <code class="inlineCode">My-Best-Matches</code> and <code class="inlineCode">Route-Choosing</code> microservices.</p>
<p class="normal">The <code class="inlineCode">Locations-Listing</code> microservice handles a database of known locations, and it is used in various kinds of user suggestions, such as autocomplete of user sources and destinations and suggestions for interesting trips based on user preferences statistics. It takes its input from all car-holder and car-seeker requests.</p>
<p class="normal">We have seen what kind of problems microservices were conceived to solve and how their adoption adds complexity to the application design. Moreover, it is not difficult to imagine that testing and maintaining an application that runs on several different machines and relies on complex data-driven<a id="_idIndexMarker130"/> communication patterns should be a complex and time-consuming task.</p>
<p class="normal">Therefore, it is important to assess the impact of using microservices architecture in our application to verify that the cost is affordable and that the advantages of the adoption outweigh the disadvantages and extra costs. In the next section, we will cover som<a id="_idTextAnchor056"/>e criteria for facing this kind of assessment.</p>
<h1 class="heading-1" id="_idParaDest-42"><a id="_idTextAnchor057"/>When is it worth adopting microservices architectures?</h1>
<p class="normal">An application that requires <a id="_idIndexMarker131"/>more than five developers is certainly a good target for a microservices architecture since logical microservices help split the workforce into small, loosely coupled teams.</p>
<p class="normal">A high-traffic application with several time-consuming modules is also a good target for microservices architecture since it needs module-level performance optimizations.</p>
<p class="normal">Low-traffic applications that require just a small team of less than five people for their implementation are not a good target for a microservices architecture.</p>
<p class="normal">Deciding when to adopt microservices in all other situations that fall between the above extreme cases is not easy. In general, it requires a detailed analysis of costs and returns.</p>
<p class="normal">Considering costs, using a microservices architecture requires a development effort of about five times that of a usual monolithic application. We got this scale as an average on 7 total rewrites of monolithic applications with a Microservices architecture.</p>
<p class="normal">This is in part due to the extra effort needed to handle reliable communications, coordination, and detailed resource management. However, most of the costs come from the difficulties of testing, debugging, and monitoring a distributed application.</p>
<p class="normal">Later in the book, we will describe tools and methodologies for efficaciously handling all of the above problems, but the extra cost brought on by microservices remains.</p>
<p class="normal">Considering expected returns, the most significant advantage is the capability of focusing maintenance on just the critical modules, since if the interface of a microservice doesn’t change also the more drastic changes in its implementation, such as moving to a different operating system, or to a different development stack, or simply to a newer version of the same stack, will not require any change to all other Microservices.</p>
<p class="normal">We may decide to reduce the maintenance of modules that do not require several market-critique changes to a minimum while focusing on just the market-critique modules that either increase the perceived value of the application or require changes to adapt them to a quickly evolving market. To summarize, we may focus on just the important changes required by the users, leaving all modules that are not involved in these changes unchanged.</p>
<p class="normal">Focusing on just a few modules ensures a low time to market, so we can satisfy market opportunities as soon as they appear without the risk of releasing a new version too late.</p>
<p class="normal">We are also able to fine-tune performance quickly when the traffic on some specific functionalities increases by scaling just the involved microservices. It is worth pointing out that the capability of fine-tuning each specific building block of our application allows for better usage of the available hardware, thus reducing the overall hardware costs. Moreover, the ability to fine-tune and monitor <a id="_idIndexMarker132"/>specific microservices simplifies achieving better response times and, in general, performance goals.</p>
<p class="normal">Having analyzed the evolution that led to the microservices architecture, as well as its very nature and basic organization, we can move on to patterns that, while not specific to microservices, are common in microservices architectures.</p>
<h1 class="heading-1" id="_idParaDest-43"><a id="_idTextAnchor058"/>Microservices common patterns</h1>
<p class="normal">In this section, we will analyze the fundamental patterns used in all microservices architectures whose description is not tied to a specific <a id="_idIndexMarker133"/>programming language or tool. Most of them concern microservice communication. Let’s start with common retry strategies.</p>
<h2 class="heading-2" id="_idParaDest-44"><a id="_idTextAnchor059"/>Resilient task execution</h2>
<p class="normal">Microservices can be moved from one machine to another to achieve better load balancing. They can also be restarted to reset some possible memory leaks or to solve other performance issues. During these operations, they may<a id="_idIndexMarker134"/> miss some messages sent to them, or they may abort some ongoing computation. Moreover, failure due to software bugs or hardware faults may occur, too.</p>
<p class="normal">Since microservices architectures are required to be reliable (almost zero downtime), they are usually redundant, and particular care is needed to detect faults and apply corrective actions. Therefore, all microservices architectures must provide mechanisms to both detect failures, such as simple timeouts, and correct failed operations.</p>
<p class="normal">Failures are detected through the detection of either unexpected exceptions or timeouts. Since the code can always be arranged in a way to turn timeouts into exceptions, failure detection can always be reduced to adequate exception handling.</p>
<p class="normal">To resolve this problem, the community of microservices developers defined useful <strong class="keyWord">retry policies</strong> one can attach to specific exceptions. They are usually implemented through specific libraries together with other reliability patterns, but sometimes they are offered out of the box by cloud providers.</p>
<p class="normal">Below are the standard reliability patterns used in <a id="_idIndexMarker135"/>microservices architectures:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Exponentials retry</strong>: It has been designed to overcome temporary faults, such as a failure due to a microservice instance restart. After each failure, the operation is retried with a delay that increases exponentially with the number of attempts, until a maximum number of attempts is reached. For instance, first, we would retry after 10 milliseconds, and if this retry operation results in a new failure, a new attempt is made after 20 milliseconds, then after 40 milliseconds, and so on. If the maximum number of attempts is reached, an exception is thrown, where it can find another retry policy or some other exception-handling strategy.</li>
<li class="bulletList"><strong class="keyWord">Circuit break</strong>: It has been designed to handle long-term failures and it is usually triggered after an exponential retry reaches its maximum number of retries. When a long-term failure is assumed, access to the resource is interdicted for a fixed amount of time by returning an immediate exception without attempting all the required operations. The interdiction time must be sufficient to allow human intervention or any other kind of manual fix.</li>
<li class="bulletList"><strong class="keyWord">Bulkhead isolation</strong>: Bulkhead isolation has been designed to prevent failure and congestion propagation. The basic idea is to organize services and/or resources into isolated partitions so that failures or congestions originating in a partition remain confined to that partition, and the remainder of the system continues working properly.</li>
</ul>
<p class="normal-one">Suppose, for instance, that <a id="_idIndexMarker136"/>several microservice replicas use the same database (as is common). Due to a failure, a replica might start opening too many database connections, thus also congesting all other replicas that need to access the same database.</p>
<p class="normal-one">In this case, we recognize that database connections are critical resources that need bulkhead isolation. Thus, we compute the maximum number of connections the database can properly handle and partition them among all replicas, assigning, for instance, a maximum of five simultaneous connections to each microservice replica.</p>
<p class="normal-one">This way, a failure in a replica doesn’t affect the proper access of other replicas to the database. Moreover, if the application is properly organized, requests that fail to be served because of the failed replica will eventually be retried on a properly working replica so that the overall application can continue working properly. In general, if we would like to partition all requests to a shared resource, we can proceed as follows:</p>
<ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1">Only a maximum number of similar pending simultaneous outbound requests to the shared resource is allowed; let’s say 5, as in the previous database example. This is like putting an upper bound on thread creation.</li>
<li class="numberedList level-2">Requests exceeding the previous bound are queued.</li>
<li class="numberedList level-2">If a maximum queue length is reached, any further requests result in exceptions being thrown to abort them.</li>
</ol>
<p class="normal">It is worth pointing out that the requests partitioning and throttling pattern previously shown is a common way of applying bulkhead isolation, but it is not the only way. Any partition plus isolation strategy can be classified as bulkhead isolation. For instance, one might split the replicas of two interacting microservices into two isolated partitions such that only replicas belonging to the same partition might interact. This way, a failure in a partition can’t affect the other partition.</p>
<p class="normal">Together with the actions and strategies for handling failures exposed above, microservices architectures also offer failure prevention strategies. Failure prevention is achieved by monitoring anomalous consumptions of hardware resources and performing periodic hardware and software health checks. For this purpose, orchestrators monitor the usage of memory and CPU resources and restart a <a id="_idIndexMarker137"/>microservice instance or add a new instance when they fall out of a developer-defined range. Moreover, they offer the possibility of declaring periodic software checks that the orchestrator can perform to verify if the microservice is working properly. The most common of such health checks is a call to a <strong class="keyWord">health REST endpoint</strong> exposed <a id="_idIndexMarker138"/>by the microservice. Again, if the microservice fails a health check, it is restarted.</p>
<p class="normal">When a hardware node fails a health check, all of its microservices are moved to a different hardware node.</p>
<h2 class="heading-2" id="_idParaDest-45"><a id="_idTextAnchor060"/>Efficacious handling of asynchronous communication</h2>
<p class="normal">Asynchronous communication with <a id="_idIndexMarker139"/>associated asynchronous acknowledgment causes three important problems:</p>
<ol>
<li class="numberedList" value="1">Since after the communication the sending microservice moves to serving other requests without waiting for the acknowledgment, it must keep a copy of all messages it sent until an acknowledgment or a communication failure, such as a timeout, is detected, so that it can retry the operation (with an exponential retry, for instance), or it can take another kind of corrective action.</li>
<li class="numberedList">Since in case of a timeout a message may be re-sent, the intended recipient can receive several copies of the same message.</li>
<li class="numberedList">Messages can reach a recipient in an order that is different from the one they were sent. For instance, if two messages that instruct the recipient to modify the name of a product are sent in the order M1, M2, we expect the final name to be the one contained in M2. However, if the recipient receives the two messages in the wrong order, M2, M1, the final product name will be the one contained in M1, thus causing an error.</li>
</ol>
<p class="normal">The first problem is handled by keeping all messages in a queue, as shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 2.8: Output message queue" src="img/B31916_02_8.png"/></figure>
<p class="packt_figref">Figure 2.8: Output message queue</p>
<p class="normal">When an acknowledgment is received, the involved message is removed from the queue. If, on the contrary, a failure or timeout is detected, the message is added to the end of the queue to be retried. If a retry must be handled with an exponential retry, each queue entry must contain both the number of the<a id="_idIndexMarker140"/> current attempt and the minimum time when the message can be re-sent.</p>
<p class="normal">The second and third problems require that each received message has a unique identifier and a sequence number. The unique identifier helps recognize and discard duplicates, while the sequence number helps the recipient to reconstruct the right message order. The following figure shows a possible implementation.</p>
<figure class="mediaobject"><img alt="Figure 2.9: Input message queue" src="img/B31916_02_9.png"/></figure>
<p class="packt_figref">Figure 2.9: Input message queue</p>
<p class="normal">Messages can be read from the input queue only after all sequence holes before them have been filled and read, while duplicates are easily recognized and discarded.</p>
<h2 class="heading-2" id="_idParaDest-46"><a id="_idTextAnchor061"/>Event-based communications</h2>
<p class="normal">Suppose we add a new microservice to the car-sharing application in <em class="italic">Figure 2.7</em>, say, a worker microservice that computes statistics <a id="_idIndexMarker141"/>about user trips. We would be forced to modify all microservices it needs input from, because all these microservices must also send some messages to the newly added microservice.</p>
<p class="normal">The main constraint of microservices architectures is that modifications to a microservice must not propagate to other microservices, but by simply adding a new microservice, we have already violated this basic principle.</p>
<p class="normal">To overcome this problem, messages that might also interest newly added microservices are handled with the <strong class="keyWord">publisher-subscriber</strong> pattern. That is, the<a id="_idIndexMarker142"/> sender sends the message to a publisher endpoint instead of sending it directly to the final recipients. Then, each microservice that is interested in that message simply subscribes to this endpoint, so that the subscription endpoint will automatically send to it all messages it receives. The following figure shows how the publisher-subscriber pattern works.</p>
<figure class="mediaobject"><img alt="Figure 2.10: Publisher-subscriber pattern" src="img/B31916_02_10.png"/></figure>
<p class="packt_figref">Figure 2.10: Publisher-subscriber pattern</p>
<p class="normal">Once a publish endpoint receives a message, it resends it to all subscribers that added themselves to its subscriptions queue. This way, if we add a new microservice, no modification is required for all message senders since they need just to continue sending their messages to the adequate publish endpoints. It is up to the newly added microservice to register itself to the proper publish endpoints.</p>
<p class="normal">Publish endpoints are handled by applications called message brokers that offer this service together with other message-delivering services. Message brokers can be deployed themselves as replicable microservices, but they are typically offered as standard services by all main cloud providers.</p>
<p class="normal">Among them, it is worth mentioning <strong class="keyWord">RabbitMQ</strong>, which must <a id="_idIndexMarker143"/>be installed as a microservice, and <strong class="keyWord">Azure Service Bus</strong>, which is available<a id="_idIndexMarker144"/> as a cloud service in Azure. We will say more about them throughout the rest of the book, but interested readers may find links with more details in the <em class="italic">Further reading</em> section.</p>
<h2 class="heading-2" id="_idParaDest-47"><a id="_idTextAnchor062"/>Interfacing the external world</h2>
<p class="normal">Microservices applications are usually confined to a private network and expose their services through public or private IP addresses by<a id="_idIndexMarker145"/> means of gateways, load balancers, and web servers. These components may route external addresses to internal microservices. However, it is hard to leave to the user client-application the choice of the microservice to send each of their requests to.</p>
<p class="normal">Typically, input requests are all handled by a unique<a id="_idIndexMarker146"/> endpoint called an <strong class="keyWord">API gateway</strong> that analyzes them and translates the request to an appropriate request for internal microservices. This way, the user client application doesn’t need any knowledge of how the microservices application is organized internally. Therefore, we are free to change the application organization during its maintenance without affecting the clients that use it, since the needed translations are performed <a id="_idIndexMarker147"/>by the application API gateway. This process is known as <strong class="keyWord">web API interface translation</strong>.</p>
<p class="normal">The following figure summarizes the API gateway operation:</p>
<figure class="mediaobject"><img alt="Figure 2.11: API gateway" src="img/B31916_02_11.png"/></figure>
<p class="packt_figref">Figure 2.11: API gateway</p>
<p class="normal">API gateways can also handle application versioning by sending all requests to the microservices that belong to the version required by the client application.</p>
<p class="normal">Moreover, they typically also handle authentication tokens; that is, they have the keys to decode them and to verify all user information they contain, such as user ID and its access privileges.</p>
<p class="normal">Please do not confuse authentication with login. Login is performed once per session when the user starts interacting with the application, and it is performed by a dedicated microservice. The result of a successful login is an authentication token that encodes information about the user and that must be included in<a id="_idIndexMarker148"/> all subsequent requests.</p>
<p class="normal">Summing up, API gateways offer the following services:</p>
<ul>
<li class="bulletList">Web API interface translation</li>
<li class="bulletList">Versioning</li>
<li class="bulletList">Authentication</li>
</ul>
<p class="normal">However, they often also offer other services, such as:</p>
<ul>
<li class="bulletList">API documentation endpoints, that is, endpoints that offer a formal description of the services offered by the application and how to request them. In the case of REST communication, API documentation is based <a id="_idIndexMarker149"/>on the <strong class="keyWord">OpenAPI</strong> standard (see <em class="italic">Further reading</em>).</li>
<li class="bulletList">Caching, that is, adding the right HTTP headers to handle appropriate caching of all responses in both the user client and the web intermediate nodes.</li>
</ul>
<p class="normal">It is worth pointing out that the above services are just common examples of the services available in commercial or open-source API gateways that usually offer a wide range of services.</p>
<p class="normal">API gateways can be implemented as ad hoc microservices using libraries like YARP (<a href="https://microsoft.github.io/reverse-proxy/index.html">https://microsoft.github.io/reverse-proxy/index.html</a>), or they can use preexisting configurable applications, for instance, the open-source Ocelot (<a href="https://github.com/ThreeMammals/Ocelot">https://github.com/ThreeMammals/Ocelot</a>). All main <a id="_idIndexMarker150"/>providers offer powerful configurable API gateways, called <strong class="keyWord">API management systems</strong> (for Azure, see <a href="https://azure.microsoft.com/en-us/products/api-management">https://azure.microsoft.com/en-us/products/api-management</a>). However, there are also independent cloud-native offers, like Kong (<a href="https://docs.konghq.com/gateway/latest/">https://docs.konghq.com/gateway/latest/</a>).</p>
<h1 class="heading-1" id="_idParaDest-48"><a id="_idTextAnchor063"/>Summary</h1>
<p class="normal">In this chapter, we described the basics of microservices, starting from their evolution and continuing on to their definition, organization, and main patterns.</p>
<p class="normal">We described the main features and requirements of a microservices-based application, how its organization resembles more of an assembly line than a user-requests-driven application, how to make microservices reliable, and how to handle efficaciously both failures and all problems caused by efficient asynchronous communication.</p>
<p class="normal">Finally, we described how to make all microservices more independent from each other with publisher-subscriber-based communication and how to interface a microservices application with the external word.</p>
<p class="normal">The next chapter describes two important building blocks for building enterprise-level microservices: Docker and Onion architectures.</p>
<h1 class="heading-1" id="_idParaDest-49"><a id="_idTextAnchor064"/>Questions</h1>
<ol>
<li class="numberedList" value="1">What is the main difference between a hold-style SOA and a modern microservices architecture?</li>
</ol>
<p class="normal-one">In Microservices architectures are fine-grained. Moreover, each Microservices must not depend on the design choices of other Microservices. Furthermore, microservices must be redundant, replicable, and resilient.</p>
<ol>
<li class="numberedList" value="2">Why are loosely coupled teams so important?</li>
</ol>
<p class="normal-one">Because it is quite easy to coordinate loosely coupled teams.</p>
<ol>
<li class="numberedList" value="3">Why must each logical microservice have dedicated storage?</li>
</ol>
<p class="normal-one">This is an immediate consequence of the independence of the design choices of a Microservice from the design choices adopted in all other Microservices. In fact, sharing a common database would force common design choices on the database structure.</p>
<ol>
<li class="numberedList" value="4">Why is data-driven communication needed?</li>
</ol>
<p class="normal-one">This is the only way to avoid long chains of recursive request and answers that would cause unacceptable overall response times.</p>
<ol>
<li class="numberedList" value="5">Why is event-driven communication so important?</li>
</ol>
<p class="normal-one">Because event-driven communication completely decouples Microservices, so that developers can add a new Microservice without modifying any of the preexisting Microservices.</p>
<ol>
<li class="numberedList" value="6">Do API gateways usually offer login services?</li>
</ol>
<p class="normal-one">No login services are offered by specific Microservices called Authentication Servers.</p>
<ol>
<li class="numberedList" value="7">What is exponential retry?</li>
</ol>
<p class="normal-one">A retry policy that exponentially increases the delay between failures and retries after each failure.</p>
<h1 class="heading-1" id="_idParaDest-50"><a id="_idTextAnchor065"/>Further reading</h1>
<ul>
<li class="bulletList">Eric Evans, Domain-Driven Design: <a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20 ">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</a></li>
<li class="bulletList">More resources on DDD can be found here: <a href="https://www.domainlanguage.com/ddd/">https://www.domainlanguage.com/ddd/</a><a href="https://domainlanguage.com/ddd/ "/></li>
<li class="bulletList">A detailed discussion of CQRS design principles can be found here: <a href="https://udidahan.com/2009/12/09/clarified-cqrs/">https://udidahan.com/2009/12/09/clarified-cqrs/</a><a href="http://udidahan.com/2009/12/09/clarified-cqrs/ "/></li>
<li class="bulletList">ASP.NET Core REST API: <a href="https://docs.microsoft.com/en-US/aspnet/core/web-api/">https://docs.microsoft.com/en-US/aspnet/core/web-api/</a><a href="https://docs.microsoft.com/en-US/aspnet/core/web-api/ "/></li>
<li class="bulletList">Datadog: <a href="https://docs.datadoghq.com/service_catalog/">https://docs.datadoghq.com/service_catalog/</a><a href="https://docs.datadoghq.com/service_catalog/ "/></li>
<li class="bulletList">Backstage: <a href="https://backstage.io/docs/features/software-catalog/">https://backstage.io/docs/features/software-catalog/</a></li>
<li class="bulletList">OpenAPI (REST API specifications): <a href="https://swagger.io/docs/specification/v3_0/about/">https://swagger.io/docs/specification/v3_0/about/</a><a href="https://swagger.io/docs/specification/ "/></li>
<li class="bulletList">Postman: <a href="https://www.postman.com/">https://www.postman.com/</a><a href="https://www.postman.com/ "/></li>
<li class="bulletList">gRPC: <a href="https://grpc.io/ ">https://grpc.io/</a></li>
<li class="bulletList">RabbitMQ: <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></li>
<li class="bulletList">Azure Service Bus: <a href="https://azure.microsoft.com/en-us/products/service-bus/">https://azure.microsoft.com/en-us/products/service-bus/</a></li>
<li class="bulletList">Ocelot: <a href="https://github.com/ThreeMammals/Ocelot">https://github.com/ThreeMammals/Ocelot</a></li>
<li class="bulletList">YARP: <a href="https://microsoft.github.io/reverse-proxy/index.html">https://microsoft.github.io/reverse-proxy/index.html</a><a href="https://microsoft.github.io/reverse-proxy/index.html "/></li>
<li class="bulletList">Kong: <a href="https://docs.konghq.com/gateway/latest/">https://docs.konghq.com/gateway/latest/</a></li>
<li class="bulletList">Azure API Management: <a href="https://azure.microsoft.com/en-us/products/api-management">https://azure.microsoft.com/en-us/products/api-management</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-51"><a id="_idTextAnchor066"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_2.xhtml">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>
</body></html>