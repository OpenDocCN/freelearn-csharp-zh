<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Platform Extras</h1></div></div></div><p>This chapter concentrates on platform-specific APIs and features. It explains some of the peripherals that can be employed in Xamarin applications. We will also discuss native libraries and how to include them in cross platform Xamarin applications. The following topics will be discussed:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Content sharing</li><li class="listitem" style="list-style-type: disc">Peripherals</li><li class="listitem" style="list-style-type: disc">Location data</li><li class="listitem" style="list-style-type: disc">Native libraries</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Content sharing</h1></div></div></div><p>Each Xamarin<a class="indexterm" id="id314"/> target platform implements a certain strategy to share formatted content between the applications. Sharing implementations increases the visibility of your applications by allowing users to open files from your application in any other app. In addition, these types of implementations provide added value to the quality of your cross platform projects from the nativity perspective.</p><p>The inter-application sharing occurs with the underlying runtime acting as a broker between the sharing source and target applications. On iOS and Windows Store applications, the sharing is facilitated in the form of abstract file elements. Android applications, however, can take it one step further by sharing formatted data that can be manipulated by the receiving application, which essentially allows the source application to almost act as a data repository.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>On Windows Store, applications can actively share content such as media elements, URIs, text content, and other types of data. However, in this implementation strategy, that is, sharing contact implementation, the source application has to initiate the sharing process. The content sharing scenarios described in this book are about target applications accessing the content via the source application.</p></div></div><p>On Windows Runtime, applications interact with each other or with the operating system through the usage of so-called application contracts. With the help of contracts, applications can immerse into the runtime and get one step closer to become part of the runtime.</p><p>The same <a class="indexterm" id="id315"/>functionality is achieved by the implementation of the base <code class="literal">ContentProviders</code> on Android and the implementation of document provider extensions on the iOS platform.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec79"/>File pickers and contracts (Windows Store apps)</h2></div></div></div><p>One of <a class="indexterm" id="id316"/>the most commonly used contracts is the File Open Picker contract on Windows Runtime. In this contract implementation, the source application has to implement the activation strategy for when it is called to provide file content for the target application. When the target application requires a certain type of file, the runtime lists all possible source applications that declares this type in their app manifest (for example, on a Windows Phone, when you want to attach a document on the mail client together along with a picture, the OneDrive application is displayed as one of the possible sources).</p><p>The user then selects the file that they want to use in the current application and the provider app is responsible for either creating or providing the file to the target application.</p><div><img alt="File pickers and contracts (Windows Store apps)" src="img/B04693_06_01.jpg"/><div><p>File picker contract in Windows Runtime</p></div></div><p>In this methodology, the file does not necessarily need to be an actual document item, but it can be a <a class="indexterm" id="id317"/>conceptual one. For instance, if we were to implement the File Open Picker in the TravelTrace app, we would not need to use actual documents in the File Open Picker to provide content. The shared content items could be the previous trips that the user kept track of and the selected trip could provide a generated scrap book or a collage of images in an image format or as a PDF document according to the type of document that is being requested by the consumer app.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Document Provider extensions (iOS)</h2></div></div></div><p>The <a class="indexterm" id="id318"/>Document Provider extensions (introduced in iOS 8) allow applications, that is, consuming applications) to access documents outside their application sandbox. Document Provider extensions are twofold. The Document Picker View Controller extension provides a UI implementation for the operating system to display whenever the source application is selected as a document source in the document picker view. However, the File Provider extension is responsible for providing the document level operations.</p><p>In order to create a provider extension, we can use the existing project template in Xamarin Studio.</p><div><img alt="Document Provider extensions (iOS)" src="img/B04693_06_02.jpg"/><div><p>The Document Picker extension project template</p></div></div><p>Once the <a class="indexterm" id="id319"/>project is created, we are responsible for creating the view on the storyboard and implementing <code class="literal">DocumentPickerViewController</code> so that the available files are listed on the UI when our application is selected to provide files. <code class="literal">DocumentPickerViewController</code> initially has two methods that require our attention. The <code class="literal">PrepareForPresentation</code> method receives the picker mode (<code class="literal">Import</code>, <code class="literal">Open</code>, <code class="literal">ExportToService</code>, or <code class="literal">MoveToService</code>) so the user interface can be prepared according to the requested operation. The <code class="literal">OpenDocument</code> method is implemented just for our convenience to demonstrate the fact that once the user selects a document, we should prepare the corresponding file URL and pass it onto the runtime using the <code class="literal">DismissGrantingAccess</code> method.</p><p>It is important to keep in mind that the URL provided from our Document Picker extension should already point to an actual file, or we should go on to implement the Document File Provider extension that will provide the files when either the consuming app displays the document picker and the user selects the file or the consuming app opens the file directly using the cached URL.</p><p>In the <a class="indexterm" id="id320"/>Document File Provider extension project, the crucial implementation is located in the <code class="literal">StartProvidingItemAtUrl</code> method. This method uses the <code class="literal">FileCoordinator</code> class provided to create the file at the target URL (for example, generates the file or downloads it from a remote location).</p><div><pre class="programlisting">public override void StartProvidingItemAtUrl (NSUrl url, Action&lt;NSError&gt; completionHandler)
{
  NSError error, fileError = null;
  NSData fileData;

  // TODO: get the file data for file at &lt;url&gt; from model
  fileData = new NSData ();

  FileCoordinator.CoordinateWrite (url, 0, out error, (newUrl) =&gt; fileData.Save (newUrl, 0, out fileError));

  if (error != null)
    completionHandler (error);
  else
    completionHandler (fileError);
}</pre></div><p>After the implementation of the extensions is complete, we have to prepare the project metadata entries. Each project (both extensions and the container application) needs to make use of the <strong>App Groups</strong> capability. This capability needs to be set up in the <strong>Entitlements</strong> option list. Other settings involve the base document storage URL, type of operations supported for the document picker, and so on. However, these configuration values are inserted in the <code class="literal">Info.plist</code> option list.</p><div><img alt="Document Provider extensions (iOS)" src="img/B04693_06_03.jpg"/><div><p>Entitlements for Document Provider extensions</p></div></div><p>In order to <a class="indexterm" id="id321"/>add the extensions to the containing application, the only thing we need to do is to add them as references to the main project. If you look at the project file of the main project, you will notice that the references are added with the <code class="literal">IsExtension</code> flag set to true.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec81"/>ContentProvider and ContentResolver (Android)</h2></div></div></div><p>Content <a class="indexterm" id="id322"/>providers on Android platform act as data repositories. These repositories are exposed to consuming applications through structured endpoint descriptions (similar to REST endpoints on web services). Using <a class="indexterm" id="id323"/>the metadata provided, providers' content is resolved by the consuming app through the implementation of <code class="literal">ContentResolvers</code>. Using content providers, applications can expose well-known data types such as contact list photos or calendar events, as well as custom data types and formatted data.</p><p>On the consumer side of this infrastructure, there are many content providers already implemented by default on Android runtime, such as <code class="literal">Contacts</code>, <code class="literal">MediaStore</code>, <code class="literal">UserDictionary</code>, and so on. These providers can be accessed by implementing base classes such as <code class="literal">ContentResolver</code> and <code class="literal">CursorAdapter</code>. <code class="literal">CursorAdapter</code> is used to feed the data that is retrieved by <code class="literal">ContentResolver</code> to a UI list view control. The <code class="literal">ContentProvider</code> API operations can involve list queries and CRUD operations on individual records.</p><p>Provider <a class="indexterm" id="id324"/>applications are responsible for registering an authority that is unique to the application. The authority entry can be described as the base content URI for a specific application. Either it can be added to the manifest file, or an attribute entry could be used on the class that is implementing <code class="literal">ContentProvider</code>.</p><div><pre class="programlisting">[ContentProvider(new string[] { "com.xamarin.master.traveltrace.TripProvider" })]
public class TripDataProvider : ContentProvider</pre></div><p>Another<a class="indexterm" id="id325"/> important piece of metadata that the content provider needs to provide is the Mime-Type information. In order to facilitate the use of <code class="literal">CursorAdapter</code> on consumer applications, the content provider needs to provide a Mime-Type for a list of items (starting with <code class="literal">vnd.android.cursor.dir</code>) as well as for a single item (starting with <code class="literal">vnd.android.cursor.item</code>).</p><p>Finally, the content provider needs to expose the data columns for the data that is being made available to other applications. This is achieved by hiding the <code class="literal">InterfaceConstants</code> nested class from the base abstract class.</p><div><pre class="programlisting">public new static class InterfaceConsts
{
    public const string Id = "Id";
    public const string Name = "Name";
    public const string Description = "Description";
    public const string Date = "Date";
    public const string Location = "Location";
    public const string ContentPath = "ContentPath";
}</pre></div><p>Another optional implementation would be to create a <code class="literal">UriMatcher</code> class that could ease the implementation process for the query methods.</p><div><pre class="programlisting">private UriMatcher GetUriMatcher()
{
    var matcher = new UriMatcher(UriMatcher.NoMatch);

    // to get data...
    matcher.AddURI(Authority, _basePath, (int) QueryType.List);
    matcher.AddURI(Authority, _basePath + "/#", (int) QueryType.Single);

    return matcher;
}</pre></div><p>The final <a class="indexterm" id="id326"/>implementation is related to the query, update, insert, and delete methods. Each of these methods needs to return the <code class="literal">ICursor</code> implementations according to the abstract class defined.</p><div><pre class="programlisting">public override global::Android.Database.ICursor Query(global::Android.Net.Uri uri, string[] projection, string selection, string[] selectionArgs, string sortOrder)
{
    switch ((QueryType) m_UriMatcher.Match(uri))
    {
        case QueryType.List:
            // TODO:
        case QueryType.Single:
            // TODO:
        default:
            throw new Java.Lang.IllegalArgumentException("Unknown Uri: " + uri);
    }
}</pre></div><p>Overall, while <a class="indexterm" id="id327"/>providing more flexibility for content sharing, Android makes it a little more difficult for other applications to consume the data provided by the source application. The data provided by a content provider implementation on a Xamarin.Android application cannot be consumed by another without a specialized implementation.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Peripherals</h1></div></div></div><p>In this section, we <a class="indexterm" id="id328"/>will discuss several communication protocols that enable applications to communicate with other platforms and other devices.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Bluetooth</h2></div></div></div><p>The Bluetooth<a class="indexterm" id="id329"/> communication protocol has become an invaluable feature on mobile devices. Especially with the emerging technologies related to <strong>IoT</strong> (<strong>Internet of Things</strong>)<a class="indexterm" id="id330"/>, and various accessories we use in daily life, our dependency on the Bluetooth stack on mobile platforms has increased.</p><p>While Xamarin.Android applications and Windows Runtime applications can make use of both GATT (Bluetooth Low Energy) and RFCOMM (Bluetooth Serial), iOS applications can only communicate through the Bluetooth LE protocol. The main reason for this discrepancy is the fact that Android and Windows Runtime implement the serial communication port according to shared specifications. However, Apple implements a propriety communication stack using an encryption system. This, unfortunately, limits the serial communication to between only Apple produced/compliant accessories or devices.</p><p>For Xamarin.Android, Bluetooth APIs reside in the <code class="literal">Android.Bluetooth</code> namespace. Using the provided <a class="indexterm" id="id331"/>classes, developers can enhance their applications with features like:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scanning for discoverable Bluetooth devices (including LE protocol)</li><li class="listitem" style="list-style-type: disc">Getting information on the local BT adapter and paired devices</li><li class="listitem" style="list-style-type: disc">Creating Serial Communication Sockets using the RFCOMM protocol</li><li class="listitem" style="list-style-type: disc">Acting both as a GATT client or a GATT server</li></ul></div><p>Bluetooth protocols can be accessed only with the user permission manifest entry for Bluetooth.</p><div><pre class="programlisting">&lt;manifest ... &gt;
  &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;
  ...
&lt;/manifest&gt; </pre></div><p>On Windows Runtime, Bluetooth-related features are implemented in the <code class="literal">Windows.Devices.Bluetooth</code> namespace. Similar to the feature-set in Android, Windows Runtime Bluetooth stack requires the applications to declare the adapter access requirement and the protocol to be used in the application manifest (for some specific devices and protocols, the Bluetooth capability declaration has to be inserted manually into the manifest). An important feature on this platform is that the Bluetooth connectivity can be facilitated and kept alive by background tasks, enabling the devices to continue their operations in the backgrounded or suspended states.</p><p>For Xamarin.iOS, Bluetooth LE related implementations would need to use the <code class="literal">CoreBluetooth</code> framework.</p><p>An important component that is currently in the Xamarin store for cross-platform peripherals integration is the Monkey.Robotics project. While implementing the basic APIs for Bluetooth LE and Wi-Fi, some other vendor-specific peripherals, such as health monitoring devices and smart watches, can be used with this component.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Wi-Fi Direct</h2></div></div></div><p>Wi-Fi Direct<a class="indexterm" id="id332"/> is another communication protocol that allows Wi-Fi enabled devices to <a class="indexterm" id="id333"/>create <strong>peer-to-peer</strong> (<strong>P2P</strong>) networks and exchange information using the Wi-Fi adapter without using a common provider network connection.</p><p>Out of the Xamarin target platforms that are described in this book, only the Android platform supports this protocol. The Windows 10 platform will support Wi-Fi Direct; however, this implementation will be targeting only Windows based devices.</p><p>On <a class="indexterm" id="id334"/>Android devices, with the introduction of Wi-Fi P2P, developers can create applications that can communicate with higher speeds and through much longer distances than with Bluetooth adapters. Wi-Fi P2P features were introduced in Android 4.0 (API level 14) and they comply with the Wi-Fi Alliance's Wi-Fi Direct standards.</p><p>In order to be able to use this feature, the application manifest should contain permissions for <code class="literal">ACCESS_WIFI_STATE</code>, <code class="literal">CHANGE_WIFI_STATE</code>, and <code class="literal">INTERNET</code>.</p><p>Access to these services is provided with the WifiP2pManager, which is located in the Android.Net.Wifi.P2P namespace. Using this manager, applications can broadcast, create groups, request peers, and developers can create applications that can communicate over P2P sockets via Wi-Fi Direct.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Near Field Communication</h2></div></div></div><p>The <a class="indexterm" id="id335"/>
<strong>Near Field Communication</strong> (<strong>NFC</strong>) protocol <a class="indexterm" id="id336"/>provides an easy alternative to Bluetooth for pairing and advertising scenarios (for example, NFC tags). With NFC, it is possible to create sockets and transfer data between mobile devices that are in proximity to each other.</p><p>Unfortunately, the NFC protocol is another unsupported communication protocol on iOS devices. (Reports suggest that iPhone 6 technically has the ability to use this protocol; however, this API is not made available to developers.)</p><p>The NFC stacks on Windows Phone and Android devices, however, implement most of the same profiles. In essence, it is technically possible to communicate over NFC across Windows and Android devices in proximity (by default, the tap and send feature works as a cross-platform feature). In spite of the fact that Windows devices use a propriety messaging scheme (<code class="literal">Windows:</code>), there are third-party frameworks for NDEF. NDEF is a cross-platform messaging scheme that is currently the default for Android.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Location data</h1></div></div></div><p>Nowadays, geo-context (location awareness) is becoming more and more crucial for applications, especially <a class="indexterm" id="id337"/>the ones running on mobile platforms. For instance, search engines optimize results according to the location information they gather from the client platform, social media and photo applications add geo-tags to posts and media items, and there are many more use cases for the data about <em>not how or on which platform the application is running, but where</em>.</p><p>On Xamarin platforms, the<a class="indexterm" id="id338"/> location information is provided making use of several different sources. The most accurate of these sources is <a class="indexterm" id="id339"/>
<strong>GPS</strong> (<strong>Global Position System</strong>). This option consumes the most power and, generally, is only available for foreground applications. Other options that can provide somewhat less accurate data are network providers such as Wi-Fi or Cellular data. iBeacon is another technology introduced by Apple and applicable to iOS 7+ devices. iBeacon-compatible devices transmit location information using the Bluetooth LE protocol, and this transmission is then used by the Bluetooth adapter on mobile phones and tablets.</p><p>On Xamarin target platforms, location information can be accessed both proactively and through system events and triggers. In each platform, access to a location is limited by the privacy settings and it is always up to the user whether a certain (or every) application can access the location services.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Android location and Google Play services</h2></div></div></div><p>In early <a class="indexterm" id="id340"/>versions of Android runtime, the <code class="literal">android.location</code> API was the framework-designated module for adding location awareness to applications. However, after the release of Google Play Services SDK (compatible with Android v2.2, API level 8, or higher), location APIs provided by Google became the preferred way to access location data on Android platform.</p><p><code class="literal">LocationManager</code>, a <code class="literal">LocationServices</code> implementation, is a system-wide service and can be accessed through the application context in Xamarin.Android applications. In order to get location information, the application has to subscribe to the location updates with an implementation of <code class="literal">ILocationListener</code>.</p><div><pre class="programlisting">m_LocationService = GetSystemService(LocationService) as LocationManager;

if (m_LocationService != null)
{
    if (m_LocationService.IsProviderEnabled(LocationManager.GpsProvider))
    {
        // Get updates in min every 5 seconds for every minimum 2m change
        m_LocationService.RequestLocationUpdates(LocationManager.GpsProvider, 5000, 2, m_LocationListener);
    }
    else if (m_LocationService.IsProviderEnabled(LocationManager.NetworkProvider))
    {
        // Get updates in min every 10 seconds for every minimum // 10m change
        m_LocationService.RequestLocationUpdates(LocationManager.NetworkProvider, 10000, 10, m_LocationListener);
    }
}</pre></div><p>In the<a class="indexterm" id="id341"/> location listener interface, there are several events that can be utilized. Other than the location change information, developers are provided with the updates related to different location provider status changes.</p><p>A simple location listener implementation used in the previous example would resemble this:</p><div><pre class="programlisting">public class LocationListener : Java.Lang.Object, ILocationListener
{
    public void OnLocationChanged(Location location)
    {
        Trace.WriteLine(string.Format("Lat:{0}, Long {1}", location.Latitude, location.Longitude), "OnLocationChanged");
    }

    public void OnProviderDisabled(string provider)
    {
        Trace.WriteLine(string.Format("Location Provider '{0}' is disabled", provider), "OnProviderDisabled");
    }

    public void OnProviderEnabled(string provider)
    {
        Trace.WriteLine(string.Format("Location Provider '{0}' is enabled", provider), "OnProviderEnabled");
    }

    public void OnStatusChanged(string provider, Availability status, Bundle extras)
    {
        Trace.WriteLine(string.Format("Location Provider '{0}' status changed to {1}", provider, status), "OnStatusChanged");
    }
}</pre></div><p>The listener interface can be implemented on the current <code class="literal">Activity</code> itself or any other <code class="literal">JavaObject</code> class implementation. Using the backgrounding techniques defined in <a class="link" href="ch03.html" title="Chapter 3. Asynchronous Programming">Chapter 3</a>, <em>Asynchronous Programming</em>, the listener interface can also be implemented on a custom <a class="indexterm" id="id342"/>started service and the application can receive background updates on the location changes through the service data directly (bound scenario) or through information persisted by the service.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Testing location information can be difficult on mobile applications. In order to facilitate GPS data testing and diagnostics, Android Emulator in Android SDK and Visual Studio Android Emulator are equipped with location emulation functionality.</p><div><img alt="Android location and Google Play services" src="img/B04693_06_04.jpg"/><div><p>Emulating a car travelling on a route</p></div></div><p>Visual Studio Android Emulator also provides features to emulate the usage of an automobile, or other means of transport, on a route or GPS location changing according to the defined pins with defined intervals.</p></div></div><p>On top of the <a class="indexterm" id="id343"/>location information, using the location provider status information, location info can be gathered in a more efficient and reliable way (for example, switching between GPS and network provided information according to connectivity and requirement for accuracy). In order to get the optimal provider that is currently available for the application scope, you can use the <code class="literal">GetBestProvider</code> method with the desired criteria for accuracy (Coarse or Fine Location Info) and for power consumption (high, medium, and low).</p><p>This intelligent switch between location data providers is the main advantage of using the Fused Location Provider (Google Play Services SDK) and Google Location Services over the default location API.</p><div><img alt="Android location and Google Play services" src="img/B04693_06_05.jpg"/><div><p>Google Play services Xamarin components</p></div></div><p>Xamarin binding libraries to Google Play Services SDK, which are available as components for Xamarin.Android v4.8+ developers, provide an easy way to integrate various services, including location APIs, into Xamarin.Android applications. These components implement the Java Binding projects and take care of the cumbersome implementation and compilation of the Google provided Android libraries.</p><p>After installing the Google Play services' location component, while trying to build the Xamarin.Android application, you might receive a compilation error similar to this:</p><div><blockquote class="blockquote"><p><em>"No resource found that matches the given name (at 'value' with value '@integer/google_play_services_version')."</em></p></blockquote></div><p>The reason<a class="indexterm" id="id344"/> for this error is the fact that the Xamarin component is dependent on the Google Play Services SDK and the SDK modules are supposed to be installed manually using the Android SDK Manager.</p><div><img alt="Android location and Google Play services" src="img/B04693_06_06.jpg"/><div><p>Android Google Play SDK</p></div></div><p>After installing the SDK module, the Xamarin.Android application can be built without errors.</p><p>Once the setup and configuration is complete, the <code class="literal">GoogleApiClient </code>class can be initialized and used in Xamarin applications. <code class="literal">GoogleApiClient</code> requires the implementation of two interfaces to gather information about the client connection status: <code class="literal">GoogleApiClient.IConnectionCallbacks</code> and <code class="literal">GoogleApiClient.IOnConnectionFailedListener</code>.</p><p>If the application you are implementing does not depend on continuous updates of location data, but rather just the current location, you can use the <code class="literal">GetLastLocation</code> method provided on the <code class="literal">GoogleApiClient</code>. This method provides a one-time reading option.</p><div><pre class="programlisting">m_GoogleClient = new GoogleApiClient.Builder(this)
        .AddApi(Gms.Location.LocationServices.API)
        .AddConnectionCallbacks(this)
        .AddOnConnectionFailedListener(this)
        .Build();

m_GoogleClient.Connect();</pre></div><p>In order to<a class="indexterm" id="id345"/> receive real-time updates with the fused location provider, you must implement the <code class="literal">ILocationListener</code> interface for the Google Location Services API. This listener is different from the default one; it only contains a single event handler implementation for location changes. The events related to the data providers do not need to be implemented since the fused location provider itself is responsible for smart switching between the location data providers.</p><p>Although the type of provider and provider status changes are not relevant for us using the fused location provider, it is still possible to let the fused provider know which type of accuracy and priority our application scope demands. For this purpose, we can use the <code class="literal">SetPriority</code> method with the appropriate flag on <code class="literal">LocationRequest</code> while subscribing to the location updates.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>High accuracy (100)</strong>: Requests the finest location available</li><li class="listitem" style="list-style-type: disc"><strong>Balanced power/accuracy (102) (default)</strong>: Requests the <code class="literal">block</code> level accuracy (~100m accuracy)</li><li class="listitem" style="list-style-type: disc"><strong>Low power (104)</strong>: Requests the <code class="literal">city</code> level accuracy (~10km accuracy)</li><li class="listitem" style="list-style-type: disc"><strong>No power (105)</strong>: Sets the location updates to use passive mode; waits for location updates delivered to other client applications (also known as <strong>piggybacking</strong>)</li></ul></div><p>As well as the priority, a fused location provider lets developers set other important delineations of location updates, such as minimum interval, smallest displacement, and expiration time.</p><div><pre class="programlisting">private async Task RequestLocationUpdates(GoogleApiClient apiClient)
{
    // Describe our location request
    var locationRequest = new Gms.Location.LocationRequest()
        .SetInterval(5000) // Setting the interval to 5 seconds
        .SetSmallestDisplacement(5) // Setting the smallest update delta to 5 meters
        .SetPriority(Gms.Location.LocationRequest.PriorityHighAccuracy)
        // Setting the priority to Fine and High Power
        .SetExpirationDuration(20000); // Stopping the location updates after 20 seconds.

    // Request updates
    await Gms.Location.LocationServices.FusedLocationApi
        .RequestLocationUpdates(apiClient, locationRequest, m_LocationListener);
}</pre></div><p>Unfortunately, Google Play services <a class="indexterm" id="id346"/>are only preinstalled on Android SDK emulator and for the other emulators, the Google applications package has to be downloaded and installed on the emulator image.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Location services on iOS</h2></div></div></div><p>On the iOS platform, the <a class="indexterm" id="id347"/>location data is accessed through the <code class="literal">CoreLocation</code> library, and similar to the android location API, location changes are sent to the subscribing application with the help of event delegates. The <code class="literal">CLLocationManager</code> class makes it a trivial task to get location data updates from the mobile device.</p><p>The Xamarin.iOS location data access implementation starts with creating the required <code class="literal">Info.plist</code> entries, which will explain why the application requires access to the user's location. In order to do this, we have to edit the Info.plist file, adding one or both of the following entries:</p><div><img alt="Location services on iOS" src="img/B04693_06_07.jpg"/><div><p>Info.plist entries for location info</p></div></div><p>In addition<a class="indexterm" id="id348"/> to the Info.plist entry, you should also keep in mind that starting with iOS 8, applications have to explicitly ask for permission to use the location data. In order to get consent from the user, the location manager exposes two methods: one for authorizing the app for continuous local data updates and the other one just to be used when the application is in the foreground.</p><div><pre class="programlisting">_LocationManager = new CLLocationManager();

_LocationManager.RequestWhenInUseAuthorization();

_LocationManager.RequestAlwaysAuthorization();</pre></div><p>Finally, we can subscribe to the <code class="literal">LocationsUpdated</code> event to receive the latest location update information.</p><div><pre class="programlisting">if (CLLocationManager.LocationServicesEnabled)
{
    _LocationManager.LocationsUpdated += (sender, eventArgs) =&gt;
    {
        Debug.WriteLine(
            string.Format("Lat:{0}, Long {1}",
            eventArgs.Locations[0].Coordinate.Latitude,
            eventArgs.Locations[0].Coordinate.Longitude), "OnLocationChanged");
    };

    // Every ~500m an update
    _LocationManager.StartMonitoringSignificantLocationChanges();

    // Every 10m send an update event
    _LocationManager.DistanceFilter = 10;
    _LocationManager.StartUpdatingLocation();
}</pre></div><p>The<a class="indexterm" id="id349"/> location information can be further optimized for the application scope using the exposed criteria properties and methods. It is also possible to retrieve other types of information such as heading direction. However, it is important to first check if the service is available and request updates according to the system status information.</p><div><pre class="programlisting">if (CLLocationManager.HeadingAvailable)
{
    // update the heading
    _LocationManager.StartUpdatingHeading();
    _LocationManager.UpdatedHeading += (sender, eventArgs) =&gt;
    {
        Debug.WriteLine("New Heading: X: {0} Y: {1} Z: {2}", 
            eventArgs.NewHeading.X, 
            eventArgs.NewHeading.Y,
            eventArgs.NewHeading.Z);
    };
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Location data on Windows Runtime</h2></div></div></div><p>On <a class="indexterm" id="id350"/>Windows Runtime (Windows Store apps), the <code class="literal">Windows.Device.Geolocation </code>namespace is dedicated for tracking the device's location over time. The <code class="literal">Geolocator</code> class replaces the main access points in the previous platforms and can give on-demand data and information updates through events.</p><p>Similar to iOS access request, the application can request consent from the application user with the <code class="literal">RequestAccessAsync</code> method and according to the response, methods or events can be accessed through the <code class="literal">Geolocator</code> class.</p><div><pre class="programlisting">var accessStatus = await Geolocator.RequestAccessAsync();
if(accessStatus == GeolocationAccessStatus.Allowed)
{
    // Give update in every 5 meters
    Geolocator geolocator = new Geolocator { DesiredAccuracyInMeters = 5 };

    // Use StatusChanged event for Geolocator status change
    geolocator.StatusChanged += OnStatusChanged;

    // Use PositionChanged event for Geolocator status change
    geolocator.PositionChanged += (sender, eventArgs) =&gt;
    {
        UpdateLocationData(eventArgs.Position);
    }
                        
    // Get the current position
    Geoposition pos = await geolocator.GetGeopositionAsync();

    UpdateLocationData(pos);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Geofencing</h2></div></div></div><p>A geofence<a class="indexterm" id="id351"/> is an abstract boundary that can be defined with location services so that the application which created the<a class="indexterm" id="id352"/> geofence receives an update from the mobile device whenever the user is entering or exiting this boundary. This eliminates the need for polling for the location info and opens up different implementation opportunities for mobile applications.</p><p>The use cases for geofences vary from simple reminders on certain locations to virtual tours created by showing certain images or information according to the current region.</p><p>All the Xamarin target platforms support the creation and usage of geofences. For instance, in order to create a geofence on an iOS platform, we would need to use <code class="literal">CLCircularRegion</code> and the location monitoring feature of the <code class="literal">CoreLocation</code> library. There are two events of interest that are fired when the mobile device enters and exists in the region.</p><div><pre class="programlisting">var region = new CLCircularRegion(
new CLLocationCoordinate2D(43.8592, 018.4315), 600, 
"Old Town");

if (CLLocationManager.IsMonitoringAvailable(typeof (CLCircularRegion)))
{
    _LocationManager.DidStartMonitoringForRegion += (sender, eventArgs) =&gt;
    {
        Debug.WriteLine(string.Format("Starting region monitoring for {0}",
       eventArgs.Region.Identifier));
    };

    _LocationManager.RegionEntered += (sender, eventArgs) =&gt;
    {
        CreateLocalNotification("Welcome to Old Town", 
            "Don't forget to take stroll down the Bascarsija and visit the historic national library!");
    };

    _LocationManager.RegionLeft += (sender, eventArgs) =&gt;
    {
        Debug.WriteLine(string.Format("User left {0}",
        eventArgs.Region.Identifier));
    };

    _LocationManager.StartMonitoring(region);
}</pre></div><p>This <a class="indexterm" id="id353"/>implementation creates a geofence around the described region (with a center defined by the coordinates and a radius of 600 m) and sends out a notification when the specified fence is entered, giving information about the location.</p><div><img alt="Geofencing" src="img/B04693_06_08.jpg"/><div><p>Old town geofence</p></div></div><p>The <a class="indexterm" id="id354"/>same implementation on Android platform would use <code class="literal">LocationServices</code> in conjunction with the <code class="literal">GeofenceBuilder</code> class to create <code class="literal">IGeofence</code> type boundaries and add them to the watch list. One important difference on the Android platform is that the events are handled through delegates and are generally implemented by an intent service.</p><p>The implementation starts with creating <code class="literal">GoogleApiClient</code> like in the previous examples, and once the API client is connected, we can go ahead and create the geofence(s) and the intent service that is going to handle the callbacks.</p><div><pre class="programlisting">public void OnConnected(Bundle connectionHint)
{
    var intent = new Intent(this, typeof(GeofenceListenerService));
    var pendingIntent = PendingIntent.GetService(this, 0, intent, PendingIntentFlags.UpdateCurrent);


    var geoFence =
        new GeofenceBuilder().SetRequestId("OldTown")
            .SetTransitionTypes(Geofence.GeofenceTransitionEnter | Geofence.GeofenceTransitionExit)
            .SetCircularRegion(43.8592, 018.4315, 600)
            .SetExpirationDuration(200000) // Expiration Duration is obligatory
            .Build();

    var geofenceRequest = (new GeofencingRequest.Builder()).AddGeofence(geoFence).Build();

    //
    // The async version can be used instead
    // await LocationServices.GeofencingApi.AddGeofencesAsync(m_GoogleClient, geofenceRequest, pendingIntent);
    LocationServices.GeofencingApi.AddGeofences(m_GoogleClient, geofenceRequest, pendingIntent);
}</pre></div><p>The<a class="indexterm" id="id355"/> intent service implementation for sending out a local toast notification on location updates would look similar to this:</p><div><pre class="programlisting">[Service(Exported = false)]
public class GeofenceListenerService : IntentService
{
    public GeofenceListenerService() : base("GeoFenceListenerService")
    {
    }

    protected override void OnHandleIntent(Intent intent)
    {
        var geofencingEvent = GeofencingEvent.FromIntent(intent);

        if (geofencingEvent.HasError)
        {
            int errorCode = geofencingEvent.ErrorCode;
            // TODO: Log Error
        }
        else
        {
            var requestId = geofencingEvent.TriggeringGeofences[0].RequestId;

            switch (geofencingEvent.GeofenceTransition)
            {
                case Geofence.GeofenceTransitionEnter:
                    if (requestId == "OldTown")
                    {
                        Toast.MakeText(Application.Context,
                            "Don't forget to take stroll down the Bascarsija and visit the historic national library!",
                            ToastLength.Short);
                    }
                    break;
                case Geofence.GeofenceTransitionExit:
                    Debug.WriteLine(string.Format("User left {0}", requestId));
                    break;
            }
        }

    }
}</pre></div><p>The <a class="indexterm" id="id356"/>classes used by Windows Store apps for geofences are the <code class="literal">GeofenceMonitor</code> and <code class="literal">Geofence</code>/<code class="literal">GeoCircle</code> descriptive classes. A simple <code class="literal">Geofence</code> class would consist of a <code class="literal">Geocircle</code> class and the associated ID.</p><div><pre class="programlisting">string fenceId = "OldTown";

// Define fence properties
BasicGeoposition position;
position.Latitude = 43.8592;
position.Longitude = 018.4315;
position.Altitude = 0.0;
double radius = 600; // in meters

Geocircle geocircle = new Geocircle(position, radius);

// Create the geofence
Geofence geofence = new Geofence(fenceId, geocircle);</pre></div><p>Once the geofence is initialized, we can use the <code class="literal">GeofenceMonitor</code> class to add the geofence and subscribe to the events.</p><div><pre class="programlisting">GeofenceMonitor.Current.GeofenceStateChanged += OnGeofenceStateChanged;
GeofenceMonitor.Current.StatusChanged += OnGeofenceStatusChanged;</pre></div><p>It is also possible to use the geofence status change events as triggers for a background task so that the registering application does not need to be in the foreground or even in the running state.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Native libraries</h1></div></div></div><p>In spite of <a class="indexterm" id="id357"/>the fact that the Xamarin framework and .NET core implementations on Xamarin.Android and Xamarin.iOS platforms provide a vast amount of features, in some cases it is unavoidable to include native code in cross-platform implementations. Fortunately, it is possible to bind or link native libraries on both of these platforms.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Managed callable wrappers (Android)</h2></div></div></div><p>As <a class="indexterm" id="id358"/>mentioned in previous chapters, managed callable wrappers are generated managed code libraries which provide a way to interact with the Java Runtime over the JNI bridge to execute code from certain Java libraries.</p><p>Java libraries are often packaged in Java archive files (JAR files) and it is possible, using the compiled Java library project, to create a binding library which can be included in Xamarin.Android applications.</p><p>In order to demonstrate this usage, we will be creating a MCW for a simple JSON parsing library. The first step of creating our binding library would be to use the built-in project template to create our binding project.</p><div><img alt="Managed callable wrappers (Android)" src="img/B04693_06_09.jpg"/><div><p>Binding library project</p></div></div><p>Once the binding project is created, we can copy the JAR into the created Jars folder in the binding project. After <a class="indexterm" id="id359"/>the copying is completed, an important step would be to check the <strong>Build Action</strong> configuration for the JAR resource. The copied JAVA library files can be used in two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>InputJar</strong>: This is a Java library archive that is going to be used to generate the managed wrapper.</li><li class="listitem" style="list-style-type: disc"><strong>ReferenceJar</strong>: This is a Java library archive that is only going to be used as a reference and not to generate a wrapper.</li></ul></div><div><img alt="Managed callable wrappers (Android)" src="img/B04693_06_10.jpg"/><div><p>Binding library structure and build action</p></div></div><p>After setting the <strong>Build Action</strong> field to <code class="literal">InputJar</code> (this simple library does not have any dependencies), we can build the library project. Once the build is successful, you can see the generated managed files in the <code class="literal">&lt;Project Directory&gt;\obj\Debug\generated\src</code> directory.</p><div><pre class="programlisting">namespace Org.Json.Simple.Parser {

  // Metadata.xml XPath class reference: path="/api/package[@name='org.json.simple.parser']/class[@name='JSONParser']"
    [global::Android.Runtime.Register (
                "org/json/simple/parser/JSONParser", 
                DoNotGenerateAcw=true)]
  public partial class JSONParser : global::Java.Lang.Object {
        ...</pre></div><p>Looking at <a class="indexterm" id="id360"/>the main parser file, you will notice that the definition for a class consists of an Android runtime registration and a class deriving from a Java object. Metadata about the class or class members also has a metadata comment, which defines the path of the item in the Java library package.</p><p>If we wanted to change the name of a namespace (by default, they are generated from the package names defined in the <code class="literal">api.xml</code> file), or the name of any members of a class or the class itself, we could make use of the <code class="literal">Metadata.xml</code> file that is located in the bindings project. The <code class="literal">Metadata.xml</code> file contains transforms on the api.xml document that is generated from the jar files. This API description document contains the class definitions and components in a format similar to that of GAPI that is used by mono compiler. With the transforms included in the Metadata.xml, we can redefine the managed names designated for the generated C# items.</p><p>For instance, in order to change the namespace, we would use a description similar to this:</p><div><pre class="programlisting">&lt;attr path="/api/package[@name='org.json.simple']" name="managedName"&gt;Json.Simple&lt;/attr&gt;</pre></div><p>For changing the class names, the syntax is quite similar:</p><div><pre class="programlisting">&lt;attr path="/api/package[@name='org.json.simple']/class[@name='JSONParser']" name="managedName"&gt;JsonParser&lt;/attr&gt;</pre></div><p>Finally, the generated class declaration would look similar to this:</p><div><pre class="programlisting">namespace Json.Simple.Parser {

  // Metadata.xml XPath class reference: path="/api/package[@name='org.json.simple.parser']/class[@name='JSONParser']"
  [global::Android.Runtime.Register ("org/json/simple/parser/JSONParser", DoNotGenerateAcw=true)]
  public partial class JsonParser : global::Java.Lang.Object {</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Linking versus binding (iOS)</h2></div></div></div><p>While <a class="indexterm" id="id361"/>dealing with native code on the Xamarin.iOS platform, there are several options developers can use.</p><p>If we were dealing with simple static utility libraries on C or Objective-C, it is possible to create so-called <strong>fat binaries</strong> and then link them at the compile time. Later in Xamarin runtime (remember there is no Xamarin runtime in iOS, everything is compiled into static code), methods from the native library can be invoked using the P/Invoke functionality in the Xamarin framework.</p><p>The other option, which enables users to create a stronger "bridge" (at the cost of performance) with native libraries, is to create bindings to Objective-C classes and methods. Using this approach, similar to managed callable wrappers in Android runtime, we would need to create a C# wrapper over the Objective-C framework library and use the managed wrapper to access the native implementation. Even though this approach creates a more intuitive and manageable access point to native code, since the managed wrapper is, in essence, a high-level implementation and the mono compiler actually generates the P/Invoke and Imports for accessing native functionality, it is inherently a little more costly than native linking.</p><p>Both implementations require the creation of the fat binary as a starting point. A fat binary is the colloquial term used to describe binary packages that contain native binary compilations for all possible CPU architectures (i386 for the Simulator and ARMv7/ARM64 for the devices). In order to create the universal binary that is suitable for use in all iOS development targets, one needs to make use of the command-line utility in Mac OS X.</p><div><pre class="programlisting">
<strong>lipo -create -output libFatBinary.a libThinBinary-i386.a libThinBinary-arm64.a libThinBinary-armv7.a</strong>
</pre></div><p>After the universal binary is created, you can now copy the universal package into a project folder in the Xamarin.iOS application, set the build action to <strong>None</strong>, and instruct the mtouch compiler to link the binary in compile time. For build instructions, you would need to use the build arguments section in project properties and gcc flags.</p><div><pre class="programlisting">
<strong>-gcc_flags "-L${ProjectDir} -lFatBinary -force_load ${ProjectDir}/libFatBinary.a</strong>
</pre></div><p>Additional parameters might need to be included according to the frameworks being used or if the binary includes C++ code (for example, the <code class="literal">–cxx</code> flag for C++ code).</p><p>The other option is to create a <code class="literal">LinkWith</code> declaration (in most cases, this is created automatically) in an Objective-C binding project. The code is as follows:</p><div><pre class="programlisting">[assembly: LinkWith ("libFatBinary.a",     
LinkTarget.ArmV7|LinkTarget.ArmV7s|LinkTarget.Simulator|LinkTarget.Simulator64|LinkTarget.Arm64, 
ForceLoad = true, 
Frameworks = "CoreFoundation CoreData CoreLocation", 
LinkerFlags = "-lz -lsqlite3", 
IsCxx = true)]</pre></div><p>In an <a class="indexterm" id="id362"/>Objective-C binding project, you must first familiarize yourself with the types, methods, and other constructs in the native library to be able to start implementing the responding managed types in the binding library.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>Objective Sharpie is a useful tool for creating managed wrappers for Objective-C libraries. Initially, an internal tool used by the Xamarin team, it soon was released to public. Even though the implementation is not complete and it is not fully supported as an official product, it can help accelerate the implementation against native libraries.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we talked about some platform-specific features related to inter-app communications, peripherals, and location data.</p><p>Using platform-specific features can make your applications more attractive to platform users by providing scenarios that they are familiar with and increase the native look and feel of your applications.</p><p>Platform-specific features related to different communication protocols, such as Bluetooth, NFC, and Wi-Direct, can be employed for various scenarios. However, most of the protocols and profiles described here target Android and Windows Phone. Xamarin.iOS applications can only benefit from the Bluetooth LE profile.</p><p>Location awareness is another platform-specific implementation that all mobile applications can benefit from. By adding a location context to the business logic of applications, developers can create a more personalized experience for users.</p><p>Finally, if needed, Xamarin provides important features for binding and linking native libraries for Android and iOS platforms, which transform a complex porting task into merely imports.</p><p>In the next chapter, we will discuss the user interface components on different platforms and how they correlate with each other.</p></div></body></html>