- en: Abstract Factory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: 'In the previous chapter, we explored the Factory Method, a direct, straightforward,
    variation of the Factory pattern. Now, we will implement a more advanced version
    of the Factory pattern: the well-named Abstract Factory. The primary goal of both
    forms of the Factory pattern is to encapsulate the creation process of objects.
    In this chapter, we will focus on isolating the main differences between the Factory
    Method and Abstract Factory, so that we can better understand in which context
    we might choose one over the other.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了工厂方法（Factory Method），这是工厂模式的一种直接、简单直接的变体。现在，我们将实现工厂模式的一个更高级版本：被良好命名的抽象工厂（Abstract
    Factory）。这两种工厂模式的主要目标都是封装对象的创建过程。在本章中，我们将专注于区分工厂方法和抽象工厂之间的主要区别，以便我们更好地理解在什么情况下我们可能会选择其中一个而不是另一个。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of Abstract Factory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂的基本原理
- en: Designing an NPC spawner using the Abstract Factory pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象工厂模式设计NPC生成器
- en: Explaining the core differences between the Factory Method and Abstract Factory
    is sometimes used as a trick question in technical interviews. So, having a clear
    answer to this type of question can impress your interviewers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解释工厂方法（Factory Method）和抽象工厂（Abstract Factory）之间的核心区别有时会被用作技术面试中的陷阱问题。因此，对这类问题有一个清晰的答案可以给面试官留下深刻印象。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is very hands-on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章非常注重实践，因此你需要对Unity和C#有基本的了解。
- en: 'We will be using the following Unity engine and C# language concept(s):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Unity引擎和C#语言概念：
- en: Enums
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: If you are unfamiliar with these concept(s), please review them before starting
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在开始本章之前复习它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际应用：
- en: '[http://bit.ly/2HKybdy](http://bit.ly/2HKybdy)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2HKybdy](http://bit.ly/2HKybdy)'
- en: An overview of the Abstract Factory
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂概述
- en: The Abstract Factory is often explained in overly complicated terms in academic
    documentation, but if you distill it to its elementary form, its design and intent
    are quite simple. The main purpose of the Abstract Factory is to organize the
    manufacturing process of products (objects) into related groups. This approach
    allows us to manage factories that produce specific families of products (objects).
    In other words, we are able to add layers of abstraction to the creation process
    of particular categories of products (objects), and specific individual types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂通常在学术文档中被过度复杂化地解释，但如果你将其简化到基本形式，其设计和意图相当简单。抽象工厂的主要目的是将产品的制造过程（对象）组织成相关的组。这种方法使我们能够管理生产特定家族产品的工厂（对象）。换句话说，我们能够为特定类别的产品（对象）的创建过程添加抽象层，以及特定的单个类型。
- en: 'In the following diagram, we can see the basic structure of the Abstract Factory
    described visually:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到抽象工厂的基本结构以视觉方式描述：
- en: '![](img/880e98a3-46b7-4544-a961-ac8bb087e9b7.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/880e98a3-46b7-4544-a961-ac8bb087e9b7.png)'
- en: 'Notice the following members of this pattern:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下该模式的成员：
- en: '`FactoryProducer` is responsible for returning individual factories of a specific
    category (families) of products (Human or Animal)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FactoryProducer` 负责返回特定类别（家族）的产品（人类或动物）的单独工厂。'
- en: '`HumanFactory` and `AnimalFactory` are responsible for the creation of Human
    or Animal products'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HumanFactory` 和 `AnimalFactory` 负责创建人类或动物产品'
- en: The benefit of using Abstract Factory is obvious when you are dealing with the
    creation of a catalog of products, with each group having its unique manufacturing
    specifications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理创建产品目录时，每个组都有其独特的制造规范，使用抽象工厂的好处是显而易见的。
- en: When describing a Factory pattern, we often use real-world terms such as *products*,
    *manufacturing*, and *producer*. It's always a wise approach to find correlations
    between real-life notions and computer science terms, because it helps in identifying
    and remembering their core purpose.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当描述工厂模式时，我们经常使用现实世界的术语，如*产品*、*制造*和*生产者*。找到现实生活概念和计算机科学术语之间的相关性总是一个明智的方法，因为它有助于识别和记住它们的核心目的。
- en: Benefits and drawbacks
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和缺点
- en: The benefits and drawbacks of the Abstract Factory are very similar to those
    of the Factory Method, so it doesn't warrant repeating them in this chapter. But
    there's one significant benefit, which is the core difference between both patterns,
    that we need to address. While the Factory Method focuses on exposing a method
    that permits us to request the creation of objects of specific types, the Abstract
    Factory goes beyond this, by giving us a way to manage the creation of particular
    groups of objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂的好处和缺点与工厂方法非常相似，所以在这个章节中不需要重复。但有一个显著的好处，这是两种模式的核心区别，我们需要解决。虽然工厂方法侧重于提供一个方法，允许我们请求创建特定类型的对象，但抽象工厂则更进一步，它为我们提供了一种管理特定组对象创建的方式。
- en: This distinction might not sound important at first, but, if we consider a real-world
    analogy, such as the process of manufacturing a car, we can see why the Abstract
    Factory is advantageous. Your typical car is assembled with individually manufactured
    components, but the process of constructing an engine and tires is entirely different,
    so you need separate factories to create those crucial pieces of the final product.
    That's why the Abstract Factory is beneficial in software development, because
    it offers us a similar approach to structuring and organizing the way we produce
    a final, complex product, featuring multiple components with different object
    creation processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别一开始可能看起来并不重要，但如果考虑现实世界的类比，比如制造汽车的过程，我们可以看到为什么抽象工厂是有优势的。典型的汽车是由单独制造的组件组装而成，但发动机和轮胎的制造过程完全不同，因此需要单独的工厂来创建这些最终产品的关键部件。这就是为什么抽象工厂在软件开发中是有益的，因为它为我们提供了一种类似的方法来构建和组织我们生产最终复杂产品的方式，该产品具有多个组件和不同的对象创建过程。
- en: Use case example
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: We are going to extend the use case from the [Chapter 4](53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml),
    The *Factory Method*, by adding a new type of spawnable NPC, called Animals. So,
    in our example, Humans and Animals are considered non-playable characters, but
    have separate manufacturing processes, so they will need individual factories.
    This type of requirement is easily implementable with the Abstract Factory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展[第4章](53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml)中的用例“*工厂方法*”，通过添加一个新的可生成NPC的类型，称为“动物”。因此，在我们的例子中，人类和动物被认为是不可玩的角色，但它们有独立的制造过程，所以它们将需要单独的工厂。这种需求可以通过抽象工厂轻松实现。
- en: Code example
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Our code example is almost the same as the one that we completed in [Chapter
    4](53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml), *The Factory Method*. But we are
    going to add more depth to the system by including specific families of NPCs;
    in our case, Humans and Animals.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例几乎与我们在[第4章](53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml)中完成的那个相同，*工厂方法*。但我们将通过包括特定的NPC系列来增加系统的深度；在我们的情况下，人类和动物。
- en: 'One key element of the Abstract Factory is that each family of products has
    an associated factory:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象工厂的一个关键元素是每个产品系列都有一个相关的工厂：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that the class is implemented like a Factory Method, because we use a
    simple `switch` case to return the correct `Factory` to the client depending on
    the requested type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个类是按照工厂方法模式实现的，因为我们使用简单的`switch` case来根据请求的类型返回正确的`Factory`给客户端。
- en: 'Now, we need an `abstract` class to maintain consistency in the implementation
    of each product-specific `Factory`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个`抽象`类来保持每个特定产品`Factory`实现的连贯性：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up is our first concrete product factory, `HumanFactory`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的第一个具体产品工厂，`HumanFactory`：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And now, `AnimalFactory`, which will produce cats and dogs:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`AnimalFactory`，它将生产猫和狗：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that both classes implement each other's `GetAnimal()` or `GetHuman()`
    function, but return a `null`, depending on the context. This approach is in case
    a client refers to the wrong factory when requesting a specific type of NPC; instead
    of throwing an exception, it will receive a null.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这两个类都实现了对方的`GetAnimal()`或`GetHuman()`函数，但根据上下文返回`null`。这种方法是在客户端在请求特定类型的NPC时引用了错误的工厂时使用的；而不是抛出异常，它将收到一个`null`。
- en: 'Instead of using strings in our `switch`-type condition block, we are going
    to implement enums for each type of product we support, including the associated
    factories, as follows. This approach will avoid errors and maintain consistency:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不再在`switch`类型的条件块中使用字符串，我们将为每个支持的产品类型实现枚举，包括相关的工厂，如下所示。这种方法将避免错误并保持一致性：
- en: '`FactoryType`:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FactoryType`:'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`HumanType`:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HumanType`:'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`AnimalType`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimalType`:'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our Animals don''t speak, but our Humans do, so they can''t share a standard
    interface. In that case, we are going to implement one for each type, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的食物不会说话，但人类会说话，所以它们不能共享一个标准接口。在这种情况下，我们将为每种类型实现一个，如下所示：
- en: '`IHuman`:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IHuman`:'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`IAnimal`:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IAnimal`:'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to write each concrete class for all our human and animal NPCs,
    as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编写所有人类和动物NPC的每个具体类，如下所示：
- en: '`Beggar`:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Beggar`:'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Farmer`:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Farmer`:'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Shopowner`:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shopowner`:'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Dog`:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dog`:'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Cat`:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cat`:'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can extend our `NPCSpawner` class to support the spawning of Animal
    and Human NPCs:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以扩展我们的`NPCSpawner`类以支持生成动物和人类NPC：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As proof of our concept, our `Client` class can request `Animal` and `Human` NPCs
    from our `Spawner` without having to know the process behind the creation of the
    final product:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为我们概念的证明，我们的`Client`类可以从我们的`Spawner`请求`Animal`和`Human` NPC，而无需了解最终产品的创建过程：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the Abstract Factory gives us a lot more flexibility than its
    cousin, the Factory Method. We can now manage families of products, and add more
    layers of abstraction to manufacturing processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，抽象工厂比其表亲工厂方法提供了更多的灵活性。我们现在可以管理产品系列，并为制造过程添加更多抽象层。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Abstract Factory, a close cousin of the
    Factory Method. As its name implies, Abstract Factory permits us to add layers
    of abstraction to the manufacturing process of specific types of product (objects).
    This pattern is very beneficial when dealing with multiple families of products.
    The main drawback of Abstract Factory, compared to the Factory Method, is that
    it's more wordy and involved.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了抽象工厂，它是工厂方法的近亲。正如其名称所暗示的，抽象工厂允许我们在特定类型产品的制造过程中添加抽象层。当处理多个产品系列时，这种模式非常有用。与工厂方法相比，抽象工厂的主要缺点是它更冗长且复杂。
- en: 'In the next chapter, we are going to explore what is arguably the most famous
    design pattern of them all: the Singleton.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可能是所有设计模式中最著名的一个：单例。
- en: While learning about Factory patterns, you might notice that we are using several
    terms related to traditional manufacturing processes. The manufacturing and software
    industries are quite related. Best practices associated with managing factories
    inspired several core ideas behind DevOps and Kanban, which are now cornerstones
    of robust software development processes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习工厂模式的过程中，你可能会注意到我们使用了与传统制造过程相关的几个术语。制造业和软件产业密切相关。与工厂管理相关的最佳实践启发了DevOps和看板背后的几个核心思想，这些思想现在是稳健软件开发流程的基石。
- en: Practice exercise
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践练习
- en: 'At this point in the book, we have reviewed the two most popular forms of the
    Factory pattern: the Abstract Factory and the Factory Method. However, as an exercise,
    I would recommend expanding your knowledge of factories by implementing a third
    form, for example, the static Factory Method.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们已经回顾了工厂模式中最流行的两种形式：抽象工厂和工厂方法。然而，作为一个练习，我建议通过实现第三种形式来扩展你对工厂的了解，例如，静态工厂方法。
- en: You can learn about the static Factory Method pattern in Joshua Bloch's classic
    book, *Effective Java*. More information can be found in the *Further reading*
    section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Joshua Bloch的经典著作《Effective Java》中了解静态工厂方法模式。更多信息可以在“进一步阅读”部分找到。
- en: Further reading
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Phoenix Project* by Kevin Behr, George Spafford, and Gene Kim[https://itrevolution.com/book/the-phoenix-project](https://itrevolution.com/book/the-phoenix-project/)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kevin Behr、George Spafford和Gene Kim合著的《凤凰项目》[*The Phoenix Project*](https://itrevolution.com/book/the-phoenix-project)
- en: '*Effective Java* by Joshua Bloch[https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html](https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《有效Java》* by Joshua Bloch[https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html](https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html)'
