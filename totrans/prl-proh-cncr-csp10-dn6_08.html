<html><head></head><body>
<div><div><h1 id="_idParaDest-99"><em class="italic"><a id="_idTextAnchor098"/>Chapter 6</em>: Parallel Programming Concepts</h1>
<p>The <code>Task</code> objects. This chapter will delve deeper into the <code>System.Threading.Tasks.Parallel</code> members in the TPL and some additional tasking concepts for handling related tasks.</p>
<p>The lines between parallel programming, concurrency, and asynchronous programming are not always clear-cut, and you will discover where the three concepts intersect as we read ahead. </p>
<p>In this chapter, you will learn the following:</p>
<ul>
<li>Getting started with the TPL</li>
<li>Parallel loops in .NET</li>
<li>Relationships between parallel tasks</li>
<li>Common pitfalls with parallelism</li>
</ul>
<p>By the end of this chapter, you will understand how to use parallel programming in your own projects, why you would choose a parallel loop over a standard loop, and when to use <code>async</code> and <code>await</code> instead of a parallel loop.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06</a>.</p>
<p>Let’s get started by discussing the TPL and where it fits within the world of parallel programming in .NET.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Getting started with the TPL</h1>
<p>The <code>System.Threading</code> and <code>System.Threading.Tasks</code> namespaces in <em class="italic">.NET Framework 4.0</em>. The TPL provides features that make parallelism and concurrency simpler for .NET developers. There is no need to manage the <code>ThreadPool</code> tasks in your code. The TPL handles thread management and automatically scales the number of active threads based on processor capability and availability.</p>
<p>Developers should use the TPL when they need to introduce parallelism or concurrency to their code for improved performance. However, the TPL is not the right choice for every scenario. How do you know when to choose the TPL and which TPL constructs are the best choice for each scenario? </p>
<p>Let’s explore a few common scenarios.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>I/O-bound operations</h2>
<p>When dealing <a id="_idIndexMarker285"/>with I/O-bound operations <a id="_idIndexMarker286"/>such as file operations, database calls, or web service calls, asynchronous programming with <code>Task</code> objects and C# <code>async</code>/<code>await</code> operations are your best choice. If your service requires that you loop through a large collection, making a service call for each object in the loop, you should consider refactoring the service to return the data as a single service call. This will minimize the overhead associated with each network operation. It will also allow your client code to make a single <code>async</code> call to the service while keeping the main thread free to do other work.</p>
<p>I/O-bound operations are usually not suited to parallel operations, but there are exceptions to every rule. If you need to iterate through a set of folders and subfolders in the filesystem, a parallel loop can be well-suited for this. However, it is important that none of the <a id="_idIndexMarker287"/>iterations of your loop attempt to access the same file <a id="_idIndexMarker288"/>in order to avoid locking issues.</p>
<p>Now, let’s explore some CPU-bound scenarios.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>CPU-bound operations</h2>
<p>CPU-bound operations are not reliant on outside resources such as the filesystem, network, or <a id="_idIndexMarker289"/>the internet. They involve <a id="_idIndexMarker290"/>processing data in memory within your application’s process. There are many types of data transformation that fall into this category. Your application may be serializing or deserializing data, converting between file types, or processing images or other binary data.</p>
<p>These types of operations make sense for data parallelism and parallel loops in particular, with a couple of exceptions. First, if each iteration is not very CPU intensive, using the TPL is not worth the overhead it introduces. If the process is very intensive, but there are very few objects to iterate over, consider using <code>Parallel.Invoke</code> instead of one of the parallel loops, <code>Parallel.For</code> or <code>Parallel.ForEach</code>. Using parallel constructs for less CPU-intense operations can often slow your code due to the overhead of using the TPL. In <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a> we will learn how to use Visual Studio to determine the performance of parallel and concurrent code.</p>
<p>Now that you have some understanding of when to use parallelism in your applications, let’s explore some practical examples of using <code>Parallel.For</code> and <code>Parallel.ForEach</code>.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Parallel loops in .NET</h1>
<p>In this <a id="_idIndexMarker291"/>section, we will explore some examples of leveraging data parallelism in .NET projects. The parallel versions of the C# <code>for</code> and <code>foreach</code> loops, <code>Parallel.For</code> and <code>Parallel.ForEach</code>, are part of the <code>System.Threading.Tasks.Parallel</code> namespace. Using these parallel loops is similar to using their standard counterparts in C#.</p>
<p>One key <a id="_idIndexMarker292"/>difference is that the body of the parallel loops is declared as a <code>continue</code> to stop the current iteration of the loop without <a id="_idIndexMarker293"/>breaking the entire loop, you would use a <code>return</code> statement. The equivalent of using <code>break</code> to break out of a parallel loop is to use the <code>Stop()</code> or <code>Break()</code> statements.</p>
<p>Let’s look at an example of using a <code>Parallel.For</code> loop in a .NET WinForms application.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Basic Parallel.For loops</h2>
<p>We are going <a id="_idIndexMarker294"/>to create a new <code>FileProcessor</code> class will iterate the files to aggregate the file size and find the <a id="_idIndexMarker296"/>most recently written file:</p>
<ol>
<li>Start by creating a new .NET 6 WinForms project in Visual Studio</li>
<li>Add a new class named <code>FileData</code>. This class will contain the data from <code>FileProcessor</code>:<pre>public class FileData
{
    public List&lt;FileInfo&gt; FileInfoList { get; set; } = 
        new();
    public long TotalSize { get; set; } = 0;
    public string LastWrittenFileName 
        { get; set; } = "";
    public DateTime LastFileWriteTime { get; set; }
}</pre></li>
</ol>
<p>We will be returning a list of the <code>FileInfo</code> objects for the files in the selected folder, the total size of all files, the name of the last written file, and the date and time that the file was written.</p>
<ol>
<li value="3">Next, create <a id="_idIndexMarker297"/>a new class named <code>FileProcessor</code></li>
<li>Add a <a id="_idIndexMarker298"/>static method named <code>GetInfoForFiles</code> to <code>FileProcessor</code>:<pre>public static FileData GetInfoForFiles(string[] files)
{
    var results = new FileData();
    var fileInfos = new List&lt;FileInfo&gt;();
    long totalFileSize = 0;
    DateTime lastWriteTime = DateTime.MinValue;
    string lastFileWritten = "";
    object dateLock = new();
<strong class="bold">    Parallel.For(0, files.Length,</strong>
<strong class="bold">            index =&gt; {</strong>
<strong class="bold">                </strong><strong class="bold">FileInfo fi = new(files[index]);</strong>
<strong class="bold">                long size = fi.Length;</strong>
<strong class="bold">                DateTime lastWrite = </strong>
<strong class="bold">                    fi.LastWriteTimeUtc;</strong>
<strong class="bold">                lock (dateLock)</strong>
<strong class="bold">                {</strong>
<strong class="bold">                    if (lastWriteTime &lt; lastWrite)</strong>
<strong class="bold">                    {</strong>
<strong class="bold">                        lastWriteTime = lastWrite;</strong>
<strong class="bold">                        lastFileWritten = fi.Name;</strong>
<strong class="bold">                    </strong><strong class="bold">}</strong>
<strong class="bold">                }</strong>
<strong class="bold">                Interlocked.Add(ref totalFileSize, </strong>
<strong class="bold">                    size);</strong>
<strong class="bold">                fileInfos.Add(fi);</strong>
<strong class="bold">            });</strong>
    results.FileInfoList = fileInfos;
    results.TotalSize = totalFileSize;
    results.LastFileWriteTime = lastWriteTime;
    results.LastWrittenFileName = lastFileWritten;
    return results;
}</pre></li>
</ol>
<p>The <code>Parallel.For</code> loop <a id="_idIndexMarker299"/>and the <strong class="bold">lambda expression</strong> of its body are highlighted in the <a id="_idIndexMarker300"/>preceding code. There are a few things to note about the code <a id="_idIndexMarker301"/>inside the loop: </p>
<ol>
<li>First, <code>index</code> is provided as a parameter to the lambda expression so the expression body can use it to access the current member of the <code>files</code> array. </li>
<li>The <code>totalFileSize</code> gets updated inside a call to <code>Interlocked.Add</code>. This is the most efficient way to safely add values in parallel code. </li>
<li>There isn’t a simple way to leverage <code>Interlocked</code> to update the <code>lastWriteTime</code> DateTime value. So, instead, we are using a <code>lock</code> block with a <code>dateLock</code> object to safely read and set the <code>lastWriteTime</code> method-level variable.</li>
</ol>
<ol>
<li value="5">Next, open the designer for <code>Form1.cs</code> and add the following controls to the form:<pre>private GroupBox FileProcessorGroup;
private Button FolderProcessButton;
private Button FolderBrowseButton;
private TextBox FolderToProcessTextBox;
private Label label1;
private TextBox FolderResultsTextBox;
private Label label2;
private FolderBrowserDialog folderToProcessDialog;</pre></li>
</ol>
<p>View the <code>Form1.designer.cs</code> file on this chapter’s GitHub repository (<a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp</a>) to review and set all <a id="_idIndexMarker302"/>of the properties for these controls. </p>
<p>When <a id="_idIndexMarker303"/>you are finished, the form’s designer should look like this:</p>
<div><div><img alt="Figure 6.1 – The completed Form1.cs designer view in Visual Studio " height="512" src="img/Figure_6.1_B18552.jpg" width="1015"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The completed Form1.cs designer view in Visual Studio</p>
<ol>
<li value="6">Next, double-click the <code>Form1</code> designer, and a <code>FolderBrowserButton_Click</code> event handler will be generated in the code-behind <a id="_idIndexMarker304"/>file. Add the following <a id="_idIndexMarker305"/>code to use the <code>folderToProcessDialog</code> object to show a folder picker dialog to the user:<pre>private void FolderBrowseButton_Click(object sender, 
    EventArgs e)
{
    var result = folderToProcessDialog.ShowDialog();
    if (result == DialogResult.OK)
    {
        FolderToProcessTextBox.Text = 
            folderToProcessDialog.SelectedPath;
    }
}</pre></li>
</ol>
<p>The selected folder path will be set in <code>FolderToProcessTextBox</code> for use in the next step. The user can alternatively manually type or paste a folder path in the field. If you would like to prevent manual entry, you can set <code>FolderToProcessTextBox.ReadOnly</code> to <code>true</code>.</p>
<ol>
<li value="7">Next, double-click the <code>FolderProcessButton_Click</code> event handler will be generated in the code behind. Add the following code to call <code>FileProcessor</code> and display the results in <code>FolderResultsTextBox</code>:<pre>private void FolderProcessButton_Click(object sender, 
    EventArgs e)
{
    if (!string.IsNullOrWhiteSpace
        (FolderToProcessTextBox.Text) &amp;&amp;
        Directory.Exists(FolderToProcessTextBox.Text))
    {
        string[] filesToProcess = Directory.GetFiles
            (FolderToProcessTextBox.Text);
        FileData? results = FileProcessor
            .GetInfoForFiles(filesToProcess);
        if (results == null)
        {
            FolderResultsTextBox.Text = "";
            return;
        }
        StringBuilder resultText = new();
        resultText.Append($"Total file count: 
            {results.FileInfoList.Count}; ");
        resultText.AppendLine($"Total file size: 
            {results.TotalSize} bytes");
        resultText.Append($"Last written file: 
            {results.LastWrittenFileName} ");
        resultText.Append($"at 
            {results.LastFileWriteTime}");
        FolderResultsTextBox.Text = 
            resultText.ToString();
    }
}</pre></li>
</ol>
<p>The code here is straightforward enough. The static <code>GetInfoForFiles</code> method returns a <code>FileData</code> instance with the file information. We’re using <code>StringBuilder</code> to create the output to be set in <code>FolderResultsTextBox</code>.</p>
<ol>
<li value="8">We’re <a id="_idIndexMarker306"/>ready to run the application. Start <a id="_idIndexMarker307"/>debugging the project in Visual Studio and give it a try. Your results should look something like this:</li>
</ol>
<div><div><img alt="Figure 6.2 – Running the Parallel Loops application " height="443" src="img/Figure_6.2_B18552.jpg" width="1109"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Running the Parallel Loops application</p>
<p>That’s all there is to it. If you want to try something more advanced, you can try modifying the project to also process files in all subfolders of the selected folder. Let’s make a different change to the project so we can reduce the locking calls to <code>Interlocked.Add</code>.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Parallel loops with thread-local variables</h2>
<p>The <code>Parallel.For</code> construct has an overload that will allow our code to keep a running <a id="_idIndexMarker308"/>subtotal of the total file size for each thread participating in the loop. What that means is that we will only need to use <code>Interlocked.Add</code> when aggregating the subtotal from each thread to <code>totalFileSize</code>. This is <a id="_idIndexMarker309"/>accomplished by providing a <code>Interlocked.Add</code> will only be called 5 times instead of 200 times without losing any thread safety:</p>
<pre class="source-code">public static FileData GetInfoForFilesThreadLocal(string[] </pre>
<pre class="source-code">    files)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var results = new FileData();</pre>
<pre class="source-code">    var fileInfos = new List&lt;FileInfo&gt;();</pre>
<pre class="source-code">    long totalFileSize = 0;</pre>
<pre class="source-code">    DateTime lastWriteTime = DateTime.MinValue;</pre>
<pre class="source-code">    string lastFileWritten = "";</pre>
<pre class="source-code">    object dateLock = new();</pre>
<pre class="source-code">    <strong class="bold">Parallel.For&lt;long&gt;(0, files.Length, () =&gt; 0,</strong></pre>
<pre class="source-code"><strong class="bold">        (index, loop, subtotal) =&gt; {</strong></pre>
<pre class="source-code">            FileInfo fi = new(files[index]);</pre>
<pre class="source-code">            long size = fi.Length;</pre>
<pre class="source-code">            DateTime lastWrite = fi.LastWriteTimeUtc;</pre>
<pre class="source-code">            lock (dateLock)</pre>
<pre class="source-code">            {</pre>
<pre class="source-code">                if (lastWriteTime &lt; lastWrite)</pre>
<pre class="source-code">                {</pre>
<pre class="source-code">                    lastWriteTime = lastWrite;</pre>
<pre class="source-code">                    lastFileWritten = fi.Name;</pre>
<pre class="source-code">                }</pre>
<pre class="source-code">            }</pre>
<pre class="source-code">            <strong class="bold">subtotal += size;</strong></pre>
<pre class="source-code">            fileInfos.Add(fi);</pre>
<pre class="source-code">            <strong class="bold">return subtotal;</strong></pre>
<pre class="source-code">            }<strong class="bold">,</strong></pre>
<pre class="source-code"><strong class="bold">        (runningTotal) =&gt; Interlocked.Add(ref </strong></pre>
<pre class="source-code"><strong class="bold">            totalFileSize, runningTotal)</strong></pre>
<pre class="source-code">    );</pre>
<pre class="source-code">    results.FileInfoList = fileInfos;</pre>
<pre class="source-code">    results.TotalSize = totalFileSize;</pre>
<pre class="source-code">    results.LastFileWriteTime = lastWriteTime;</pre>
<pre class="source-code">    results.LastWrittenFileName = lastFileWritten;</pre>
<pre class="source-code">    return results;</pre>
<pre class="source-code">}</pre>
<p>To summarize <a id="_idIndexMarker311"/>the preceding changes, you will notice we are using the <code>Parallel.For&lt;long&gt;</code> generic method to indicate that the <code>subtotal</code> thread-local variable should be <code>long</code> instead of <code>int</code> (the default type). The size is added to <code>subtotal</code> in the first lambda expression without any locking expression. We now have to return <code>subtotal</code>, so the other iterations have access to the data. Finally, we have added a final parameter to <code>For</code> with a lambda expression that adds each thread’s <code>runningTotal</code> to <code>totalFileSize</code> using <code>Interlocked.Add</code>.</p>
<p>If you update <code>FolderProcessButton_Click</code> to call <code>GetInfoForFilesThreadLocal</code>, the output will be the same, but the performance will be improved, perhaps not noticeably. The performance improvement depends on the number of files in your selected folder.</p>
<p>Now that we have tried a couple of exercises with the <code>Parallel.For</code> loop, let’s create a sample using the <code>Parallel.ForEach</code> method.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Simple Parallel.ForEach loops</h2>
<p>The <code>Parallel.ForEach</code> methods, such as <code>Parallel.For</code>, are similar in use to their <a id="_idIndexMarker312"/>non-parallel counterpart. You would use <code>Parallel.ForEach</code> over <code>Parallel.For</code> when you have an <code>IEnumerable</code> collection <a id="_idIndexMarker313"/>to process. In this sample, we will create a new method that accepts a <code>List&lt;string&gt;</code> of image files to iterate and convert to <code>Bitmap</code> objects:</p>
<ol>
<li value="1">Start by creating a new private static method named <code>ConvertJpgToBitmap</code> in the <code>FileProcessor</code> class. This method will open each JPG file and return a new <code>Bitmap</code> containing the image data:<pre>private static Bitmap ConvertJpgToBitmap(string 
    fileName)
{
    Bitmap bmp;
    using (Stream bmpStream = File.Open(fileName, 
        FileMode.Open))
    {
        Image image = Image.FromStream(bmpStream);
        bmp = new Bitmap(image);
    }
    return bmp;
}</pre></li>
<li>Next, create a public static method in the same class named <code>ConvertFilesToBitmaps</code>:<pre>public static List&lt;Bitmap&gt; ConvertFilesToBitmaps
    (List&lt;string&gt; files)
{
    var result = new List&lt;Bitmap&gt;();
    Parallel.ForEach(files, file =&gt;
    {
        FileInfo fi = new(file);
        string ext = fi.Extension.ToLower();
        if (ext == ".jpg" || ext == ".jpeg")
        {
            result.Add(ConvertJpgToBitmap(file));
        }
    });
    return result;
}</pre></li>
</ol>
<p>This method <a id="_idIndexMarker314"/>accepts <code>List&lt;string&gt;</code> containing the files in the selected folder. Inside the <code>Parallel.ForEach</code> loop, it checks whether the file has a <code>.jpg</code> or <code>.jpeg</code> file extension. If it does, it is converted to a bitmap and added to the <code>result</code> collection.</p>
<ol>
<li value="3">Add a new button to <code>Form1.cs</code>. Set the <code>Name</code> property as <code>ProcessJpgsButton</code> and the <code>Text</code> property as <code>Process JPGs</code>.</li>
<li>Double-click the new button to create an event handler in the code-behind file. Add the following code to the new event handler:<pre>private void ProcessJpgsButton_Click(object sender, 
    EventArgs e)
{
    if (!string.IsNullOrWhiteSpace
        (FolderToProcessTextBox.Text) &amp;&amp;
        Directory.Exists(FolderToProcessTextBox.Text))
    {
        List&lt;string&gt; filesToProcess = Directory
            .GetFiles(FolderToProcessTextBox.Text)
                .ToList();
        List&lt;Bitmap&gt; results = FileProcessor
            .ConvertFilesToBitmaps(filesToProcess);
        StringBuilder resultText = new();
        foreach (var bmp in results)
        {
            resultText.AppendLine($"Bitmap height: 
                {bmp.Height}");
        }
        FolderResultsTextBox.Text = 
            resultText.ToString();
    }
}</pre></li>
<li>Now, run the project, select a folder containing some JPG files, and click the new <strong class="bold">Process JPGs</strong> button. You should see the height of each converted JPG listed in the output.</li>
</ol>
<p>That’s <a id="_idIndexMarker315"/>all you need for a simple <code>Parallel.ForEach</code> loop. What can you do if you need to cancel a long-running parallel loop? Let’s update our example to do just that with <code>Parallel.ForEachAsync</code>.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Cancel a Parallel.ForEachAsync loop</h2>
<p><code>Parallel.ForEachAsync</code> is new in .NET 6. It is an awaitable version of <code>Parallel.ForEach</code> with an <code>async</code> lambda expression as its body. Let’s update the previous <a id="_idIndexMarker316"/>example to use this new <a id="_idIndexMarker317"/>parallel method and add the ability to cancel the operation:</p>
<ol>
<li value="1">We are going to start by making an <code>async</code> copy of <code>ConvertFilesToBitmaps</code> named <code>ConvertFilesToBitmapsAsync</code>. The differences are highlighted in the following:<pre>public static <strong class="bold">async Task&lt;List&lt;Bitmap&gt;&gt; </strong>
<strong class="bold">    ConvertFilesToBitmapsAsync</strong>(List&lt;string&gt; files<strong class="bold">, </strong>
<strong class="bold">        CancellationTokenSource cts</strong>)
{
    <strong class="bold">ParallelOptions po = new()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        CancellationToken = cts.Token,</strong>
<strong class="bold">        MaxDegreeOfParallelism = </strong>
<strong class="bold">            Environment.ProcessorCount == 1 ? 1</strong>
<strong class="bold">                      : Environment.ProcessorCount - 1</strong>
<strong class="bold">    };</strong>
    var result = new List&lt;Bitmap&gt;();
    <strong class="bold">try</strong>
<strong class="bold">    {</strong>
<strong class="bold">        await Parallel.ForEachAsync(files, po, async </strong>
<strong class="bold">            (file, _cts) </strong>=&gt; 
        {
            FileInfo fi = new(file);
            string ext = fi.Extension.ToLower();
            if (ext == ".jpg" || ext == "jpeg")
            {
                result.Add(ConvertJpgToBitmap(file));
                <strong class="bold">await Task.Delay(2000, _cts);</strong>
            }
        });
    <strong class="bold">}</strong>
<strong class="bold">    catch (OperationCanceledException e)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        MessageBox.Show(e.Message);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    finally</strong>
<strong class="bold">    {</strong>
<strong class="bold">        cts.Dispose();</strong>
<strong class="bold">    }</strong>
    return result;
}</pre></li>
</ol>
<p>The <a id="_idIndexMarker318"/>new method is <code>async</code>, returns <code>Task&lt;List&lt;Bitmap&gt;&gt;</code>, accepts <code>CancellationTokenSource</code>, and uses that <a id="_idIndexMarker319"/>when creating <code>ParallelOptions</code> to pass to the <code>Parallel.ForEachAsync</code> method. <code>Parallel.ForEachAsync</code> is awaited and its lambda expression is declared as <code>async</code> so we can await the new <code>Task.Delay</code> that has been added to give us enough time to click the <strong class="bold">Cancel</strong> button before the loop completes.</p>
<p>Enclosing <code>Parallel.ForEachAsync</code> in a <code>try</code>/<code>catch</code> block that handles <code>OperationCanceledException</code> enables the method to catch the cancellation. We’ll show a message to the user after the cancellation is handled.</p>
<p>The code is also setting the <code>ProcessorCount</code> option. If there is only one CPU core available, we will set the value to <code>1</code>; otherwise, we want to use no more than the number of available cores minus one. The .NET runtime typically manages this value very well, so you should only change this option if you find it improves your application’s performance.</p>
<ol>
<li value="2">In the <code>Form1.cs</code> file, add a new <code>CancellationTokenSource</code> private variable:<pre>private CancellationTokenSource _cts;</pre></li>
<li>Update <a id="_idIndexMarker320"/>the event handler <a id="_idIndexMarker321"/>to be <code>async</code>, set <code>_cts</code> to be a new instance of <code>CancellationTokenSource</code>, and pass it to <code>ConvertFilesToBitmapsAsync</code>. Add <code>await</code> to that call as well. </li>
</ol>
<p>All of the necessary changes are highlighted in the following snippet:</p>
<pre>private <strong class="bold">async</strong> void ProcessJpgsButton_Click(object 
    sender, EventArgs e)
{
    if (!string.IsNullOrWhiteSpace
        (FolderToProcessTextBox.Text) &amp;&amp;
        Directory.Exists(FolderToProcessTextBox.Text))
    {
        <strong class="bold">_cts = new CancellationTokenSource();</strong>
        List&lt;string&gt; filesToProcess = Directory
           .GetFiles(FolderToProcessTextBox.Text)
               .ToList();
        List&lt;Bitmap&gt; results = <strong class="bold">await</strong> FileProcessor
            .<strong class="bold">ConvertFilesToBitmapsAsync</strong>
<strong class="bold">                </strong>(filesToProcess<strong class="bold">, _cts</strong>);
        StringBuilder resultText = new();
        foreach (var bmp in results)
        {
            resultText.AppendLine($"Bitmap height: 
                {bmp.Height}");
        }
        FolderResultsTextBox.Text = resultText
            .ToString();
    }
}</pre>
<ol>
<li value="4">Add a <a id="_idIndexMarker322"/>new button to the form named <code>CancelButton</code> with a caption of <code>Cancel</code></li>
<li>Double-click <a id="_idIndexMarker323"/>the <strong class="bold">Cancel</strong> button and add the following event handler code:<pre>private void CancelButton_Click(object sender, 
    EventArgs e)
{
    if (_cts != null)
    {
        _cts.Cancel();
    }
}</pre></li>
<li>Run the application, browse to and select a folder containing JPG files, click the <strong class="bold">Process JPGs</strong> button, and immediately click the <strong class="bold">Cancel</strong> button. You should receive a message indicating that processing has been canceled. No further records are processed.</li>
</ol>
<p>We will <a id="_idIndexMarker324"/>learn more about canceling <a id="_idIndexMarker325"/>asynchronous and parallel work in <a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>. Now, let’s discuss the <code>Parallel.Invoke</code> construct and relationships between tasks in the TPL.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Relationships between parallel tasks</h1>
<p>In the previous chapter, <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>, we learned how <a id="_idIndexMarker326"/>to use <code>async</code> and <code>await</code> to perform work in parallel and manage the flow of tasks by using <code>ContinueWith</code>. In this section, we will examine some of the TPL features that can be leveraged to manage relationships between tasks running in parallel.</p>
<p>Let’s start by looking deeper into the <code>Parallel.Invoke</code> method provided by the TPL.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Under the covers of Parallel.Invoke</h2>
<p>In <a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, we learned how to use the <code>Parallel.Invoke</code> method to execute multiple tasks in parallel. We are going to revisit <code>Parallel.Invoke</code> now and <a id="_idIndexMarker327"/>discover what is happening under the covers. Consider <a id="_idIndexMarker328"/>using it to invoke two methods:</p>
<pre class="source-code">Parallel.Invoke(DoFirstAction, DoSectionAction);</pre>
<p>This is what is happening behind the scenes:</p>
<pre class="source-code">List&lt;Task&gt; taskList = new();</pre>
<pre class="source-code">taskList.Add(Task.Run(DoFirstAction));</pre>
<pre class="source-code">taskList.Add(Task.Run(DoSectionAction));</pre>
<pre class="source-code">Task.WaitAll(taskList.ToArray());</pre>
<p>Two tasks will be created and queued on the thread pool. Assuming the system has available resources, the two tasks should be picked up and run in parallel. The calling method will block the current thread, waiting for the parallel tasks to complete. The action will block the calling thread for the duration of the longest-running task.</p>
<p>If this is acceptable for your application, using <code>Parallel.Invoke</code> makes the code cleaner and easy to understand. However, if you don’t want to block the calling thread, there are a couple of options. First, let’s make a change to the second example to use <code>await</code>:</p>
<pre class="source-code">List&lt;Task&gt; taskList = new();</pre>
<pre class="source-code">taskList.Add(Task.Run(DoFirstAction));</pre>
<pre class="source-code">taskList.Add(Task.Run(DoSectionAction));</pre>
<pre class="source-code">await Task.WhenAll(taskList.ToArray());</pre>
<p>By awaiting <code>Task.WhenAll</code> instead of using <code>Task.WaitAll</code>, we’re allowing the current thread <a id="_idIndexMarker329"/>to do other work while waiting for the two child tasks to <a id="_idIndexMarker330"/>finish processing in parallel. To achieve the same result with <code>Parallel.Invoke</code>, we can wrap it in <code>Task</code>:</p>
<pre class="source-code">await Task.Run(() =&gt; Parallel.Invoke(DoFirstTask, </pre>
<pre class="source-code">    DoSecondTask));</pre>
<p>The same technique can be used with <code>Parallel.For</code> to avoid blocking the calling thread while waiting for the loop to complete. This is not necessary for <code>Parallel.ForEach</code>. Instead of wrapping <code>Parallel.ForEach</code> in <code>Task</code>, we can replace it with <code>Parallel.ForEachAsync</code>. We learned earlier in this chapter that .NET 6 added <code>Parallel.ForEachAsync</code>, which returns <code>Task</code> and can be awaited.</p>
<p>Next, let’s discuss how the relationship between parent tasks and their children can be managed.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Understanding parallel child tasks</h2>
<p>When <a id="_idIndexMarker331"/>executing nested tasks, by default, the parent task <a id="_idIndexMarker332"/>will not wait for its child tasks unless we use the <code>Wait()</code> method or <code>await</code> statements. However, this default behavior can be controlled with some options when using <code>Task.Factory.StartNew()</code>. To illustrate the available options, we are going to create a new sample project:</p>
<ol>
<li value="1">First, create a new C# console application named <code>ParallelTaskRelationshipsSample</code>.</li>
<li>Add a class to the project named <code>ParallelWork</code>. This is where we will create the parent methods and their children.</li>
<li>Add the <a id="_idIndexMarker333"/>three following methods to the <code>ParallelWork</code> class. These will be our child methods. Each one writes some console <a id="_idIndexMarker334"/>output when starting and completing. Delays are injected with <code>Thread.SpinWait</code>. If you are unfamiliar with <code>Thread.SpinWait</code>, it puts the current thread into a loop for the number of iterations specified, injecting a wait without removing the thread from consideration with the scheduler:<pre>public void DoFirstItem()
{
    Console.WriteLine("Starting DoFirstItem");
    Thread.SpinWait(1000000);
    Console.WriteLine("Finishing DoFirstItem");
}
public void DoSecondItem()
{
    Console.WriteLine("Starting DoSecondItem");
    Thread.SpinWait(1000000);
    Console.WriteLine("Finishing DoSecondItem");
}
public void DoThirdItem()
{
    Console.WriteLine("Starting DoThirdItem");
    Thread.SpinWait(1000000);
    Console.WriteLine("Finishing DoThirdItem");
}</pre></li>
<li>Next, add a method named <code>DoAllWork</code>. This method will create a parent task that calls <a id="_idIndexMarker335"/>the preceding three methods with child <a id="_idIndexMarker336"/>tasks. There is no code added to wait for the child tasks:<pre>public void DoAllWork()
{
    Console.WriteLine("Starting DoAllWork");
    Task parentTask = Task.Factory.StartNew(() =&gt;
    {
        var child1 = Task.Factory.StartNew
             (DoFirstItem);
        var child2 = Task.Factory.StartNew
              (DoSecondItem);
        var child3 = Task.Factory.StartNew
              (DoThirdItem);
    });
    parentTask.Wait();
    Console.WriteLine("Finishing DoAllWork");
}</pre></li>
<li>Now, add some code to run <code>DoAllWork</code> from <code>Program.cs</code>:<pre>using ParallelTaskRelationshipsSample;
var parallelWork = new ParallelWork();
parallelWork.DoAllWork();
Console.ReadKey();</pre></li>
<li>Run the <a id="_idIndexMarker337"/>program and examine the output. As you <a id="_idIndexMarker338"/>might expect, the parent task completes before its children:</li>
</ol>
<div><div><img alt="Figure 6.3 – The console application runs DoAllWork " height="425" src="img/Figure_6.3_B18552.jpg" width="757"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The console application runs DoAllWork</p>
<ol>
<li value="7">Next, let’s create a method named <code>DoAllWorkAttached</code>. This method will run the same three child tasks, but the child task will include the <code>TaskCreationOptions.AttachedToParent</code> option:<pre>public void DoAllWorkAttached()
{
    Console.WriteLine("Starting DoAllWorkAttached");
    Task parentTask = Task.Factory.StartNew(() =&gt;
    {
        var child1 = Task.Factory.StartNew
            (DoFirstItem, <strong class="bold">TaskCreationOptions</strong>
<strong class="bold">                .AttachedToParent</strong>);
        var child2 = Task.Factory.StartNew
            (DoSecondItem, <strong class="bold">TaskCreationOptions</strong>
<strong class="bold">                .AttachedToParent</strong>);
        var child3 = Task.Factory.StartNew
            (DoThirdItem, <strong class="bold">TaskCreationOptions</strong>
<strong class="bold">                .AttachedToParent</strong>);
    });
    parentTask.Wait();
    Console.WriteLine("Finishing DoAllWorkAttached");
}</pre></li>
<li>Update <code>Program.cs</code> to <a id="_idIndexMarker339"/>call <code>DoAllWorkAttached</code> instead <a id="_idIndexMarker340"/>of <code>DoAllWork</code> and run the application again:</li>
</ol>
<div><div><img alt="Figure 6.4 – Running our application and calling DoAllWorkAttached " height="476" src="img/Figure_6.4_B18552.jpg" width="762"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Running our application and calling DoAllWorkAttached</p>
<p>You can see <a id="_idIndexMarker341"/>that even though we are not explicitly <a id="_idIndexMarker342"/>waiting for the child tasks, the parent task does not complete until its children do.</p>
<p>Now, suppose you have another parent that should not wait for its child tasks, regardless of whether they are started with the <code>TaskCreationOptions.AttachedToParent</code> option. Let’s create a new method that can handle this scenario:</p>
<ol>
<li value="1">Create a method named <code>DoAllWorkDenyAttach</code> with the following code:<pre>public void DoAllWorkDenyAttach()
{
    Console.WriteLine("Starting DoAllWorkDenyAttach");
    Task parentTask = Task.Factory.StartNew(() =&gt;
    {
        var child1 = Task.Factory.StartNew
            (DoFirstItem, <strong class="bold">TaskCreationOptions</strong>
<strong class="bold">                .AttachedToParent</strong>);
        var child2 = Task.Factory.StartNew
             (DoSecondItem, <strong class="bold">TaskCreationOptions</strong>
<strong class="bold">                 .AttachedToParent</strong>);
        var child3 = Task.Factory.StartNew
            (DoThirdItem, <strong class="bold">TaskCreationOptions</strong>
<strong class="bold">                .AttachedToParent</strong>);
    }, <strong class="bold">TaskCreationOptions.DenyChildAttach</strong>);
    parentTask.Wait();
    Console.WriteLine("Finishing DoAllWork
        DenyAttach");
}</pre></li>
</ol>
<p>The child <a id="_idIndexMarker343"/>tasks are still being created with <a id="_idIndexMarker344"/>the <code>AttachedToParent</code> option, but the parent task now has a <code>DenyChildAttach</code> option set. This will supersede the child requests to attach to the parent.</p>
<ol>
<li value="2">Update <code>Program.cs</code> to call <code>DoAllWorkDenyAttach</code> and run the application once more:</li>
</ol>
<div><div><img alt="Figure 6.5 – The console application calls DoAllWorkDenyAttach " height="463" src="img/Figure_6.5_B18552.jpg" width="810"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The console application calls DoAllWorkDenyAttach</p>
<p>You can <a id="_idIndexMarker345"/>see that <code>DenyChildAttach</code> did <a id="_idIndexMarker346"/>override the <code>AttachToParent</code> option set on each child task. The parent completed without waiting for the children, as it did when calling <code>DoAllWork</code>.</p>
<p>One final note about this example. You may have noticed that we used <code>Task.Factory.StartNew</code> instead of <code>Task.Run</code>, even when we didn’t need to set <code>TaskCreationOption</code>. That is because <code>Task.Run</code> will prohibit any child tasks from attaching to a parent. If you used <code>Task.Run</code> for the parent task in the <code>DoAllWorkAttached</code> method, the parent would have completed first, as it did in the other methods.</p>
<p>Let’s finish up this chapter by covering some potential pitfalls when working with parallel programming in .NET.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Common pitfalls with parallelism</h1>
<p>When working with the TPL, there are some practices to avoid in order to ensure the best outcomes <a id="_idIndexMarker347"/>in your applications. In some cases, parallelism used incorrectly can result in performance degradation. In other cases, it can cause errors or data corruption.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Parallelism is not guaranteed</h2>
<p>When using one of the parallel loops or <code>Parallel.Invoke</code>, the iterations can run in parallel, but they are not guaranteed to do so. The code in these parallel delegates should be able to run successfully in either scenario.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Parallel loops are not always faster</h2>
<p>We discussed this earlier in this chapter, but it is important to remember that parallel versions of <code>for</code> and <code>foreach</code> loops are not always faster. If each loop iteration runs quickly, the overhead of adding parallelism can slow down your application.</p>
<p>This is important to remember when introducing any threading to applications. Always test your code before and after introducing concurrency or parallelism to ensure that the performance gains are worth the overhead of threading.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Beware of blocking the UI thread</h2>
<p>Remember that <code>Parallel.For</code> and <code>Parallel.ForEach</code> are <em class="italic">blocking calls</em>. If you use them on the UI thread, they will block the UI for the duration of the call. This blocking duration will be, at a minimum, the duration of the longest-running loop iteration.</p>
<p>As we discussed in the previous section, you can wrap the parallel code in a call to <code>Task.Run</code> to move the execution from the UI thread to a background thread on the thread pool.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Thread safety</h2>
<p>Do not make calls to .NET methods that are not thread-safe within parallel loops. The thread safety of each .NET type is documented on Microsoft Docs. Use the .NET API browser to quickly find information about specific .NET APIs: <a href="https://docs.microsoft.com/dotnet/api/">https://docs.microsoft.com/dotnet/api/</a>.</p>
<p>Limit the <a id="_idIndexMarker348"/>use of static .NET methods in parallel loops, even if they are marked as thread-safe. They will not cause errors or problems with data consistency, but they can negatively impact the loop performance. Even calls to <code>Console.WriteLine</code> should only be used for testing or demonstration purposes. Do not use these in production code.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>UI controls</h2>
<p>In Windows client <a id="_idIndexMarker349"/>applications, do not try to access UI controls within parallel loops. WinForms and WPF controls can only be accessed from the thread on which they were created. You can use <code>Dispatcher.Invoke</code> to invoke actions on other threads, but this will have performance implications. It is best to update the UI after your parallel loops have been completed.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>ThreadLocal data</h2>
<p>Remember to take advantage of <code>ThreadLocal</code> variables in your parallel loops. We illustrated how to do this in the <em class="italic">Parallel loops with thread-local variables</em> section earlier in this chapter.</p>
<p>That covers your introduction to parallel programming with C# and .NET. Let’s wrap up by reviewing everything we have learned in the chapter.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Summary</h1>
<p>In this chapter, we learned how to leverage parallel programming concepts in our .NET applications. We got hands-on with <code>Parallel.For</code>, <code>Parallel.ForEach</code>, and <code>Parallel.ForEachAsync</code> loops. In those sections, we learned how to safely aggregate data while maintaining thread safety. Next, we learned how to manage relationships between parent tasks and their parallel children. This will help to ensure your applications maintain an expected order of operations. </p>
<p>Finally, we covered some important pitfalls to avoid when implementing parallelism in our applications. Developers will want to pay close attention to avoid any of these pitfalls in their own applications.</p>
<p>To read more about data parallelism in .NET, the <em class="italic">Data Parallelism</em> documentation on Microsoft Docs is a great place to start: <a href="https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library">https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library</a>.</p>
<p>In the next chapter, we will continue our exploration of the TPL by learning how to leverage the various building blocks included in the TPL Dataflow Library.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Questions</h1>
<ol>
<li value="1">Which parallel loop executes a delegate in parallel for a given number of iterations?</li>
<li>Which parallel loop is the awaitable version of <code>Parallel.ForEach</code>?</li>
<li>Which parallel method can execute two or more provided actions in parallel?</li>
<li>Which <code>Task.Factory.StartNew</code> option can attach a child task’s completion to its parent?</li>
<li>Which <code>Task.Factory.StartNew</code> option can be provided to a parent task to prevent any child tasks from attaching?</li>
<li>Why should you never use <code>Task.Run</code> when using <code>TaskCreationOptions</code> to establish parent/child relationships?</li>
<li>Are parallel loops always faster than their traditional counterparts?</li>
</ol>
</div>
</div>
</body></html>