- en: Chapter 11. F# Expert Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 F#专家技巧
- en: So far in the book, we've dealt mostly with customary F# facilities that constitute
    the core of successful F# idiomatic use in diverse application fields. The common
    sign of (almost) all of the related usage patterns is that they are straightforward
    and ordinary. Their mastery is a must for any intermediate level F# practitioner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书主要介绍了构成成功F#惯用用法核心的常规F#功能。这些相关用法模式的共同特征是它们简单直接。对于任何中级F#实践者来说，掌握它们是必不可少的。
- en: In this chapter, I'm going to step out of the regular space where expressions
    always yield results, calculations take place sequentially, and code must be first
    written in order to be later used. I will walk you through some of expert level
    F# techniques, the area of exciting usage patterns that is often considered overcomplicated
    and error-prone in nonfunctional paradigms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将跳出常规空间，其中表达式总是产生结果，计算是顺序进行的，代码必须先编写才能被后续使用。我将向您介绍一些专家级别的F#技巧，这是在非函数范式中被认为过于复杂且容易出错的令人兴奋的使用模式领域。
- en: 'In this chapter I will cover the following topics in the context of F# idiomatic
    use:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将从F#惯用用法的角度介绍以下主题：
- en: Type providers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提供者
- en: Concurrent programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程
- en: Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Metaprogramming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程
- en: I will approach each of these subjects by giving a brief overview accompanied
    with a concise usage sample taken from the enterprise trenches. I will attempt
    to show that these features are not really mind-bending and usually offer developers
    a strong safety net. However, please do not expect any sort of deep dive into
    these subjects. Consider the contents of this chapter more a roadmap to become
    skillful in these F# use patterns, as stimuli and practical application teasers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过提供简要概述和从企业实战中摘取的简洁用法示例来逐一介绍这些主题。我将尝试表明，这些功能并非真正令人费解，通常为开发者提供强大的安全网。然而，请不要期待对这些主题进行深入探讨。将本章内容视为成为熟练掌握这些F#使用模式的路线图，作为刺激和实际应用提示。
- en: A note on custom computation expressions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于自定义计算表达式的说明
- en: I've decided not to cover arbitrary **F# Computation Expressions** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions)
    ) in this book despite F# itself having this mechanism baked in under the hood
    of significant language features, such as *sequence expressions* (covered in [Chapter
    6](text00053.html#ch06 "Chapter 6.  Sequences - The Core of Data Processing Patterns")
    , *Sequences - The Core of Data Processing Patterns* ), *query expressions* (covered
    in [Chapter 9](text00068.html#ch09 "Chapter 9. More Data Crunching") , *More Data
    Crunching* ), and *asynchronous expressions* (to be addressed in this chapter).
    Although custom computation expressions allow crafting very elegant code in some
    cases, I feel that covering this feature here may divert us from the practicality
    path we are pursuing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定不在本书中涵盖任意的**F#计算表达式**([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions)
    )，尽管F#本身在诸如*序列表达式*（在第6章中介绍，*序列 - 数据处理模式的核心*）、*查询表达式*（在第9章中介绍，*更多数据处理*）和*异步表达式*（将在本章中讨论）等重要的语言特性之下内置了这种机制。尽管自定义计算表达式在某些情况下可以编写非常优雅的代码，但我感觉在这里介绍这个特性可能会让我们偏离我们追求的实用性道路。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Those of you interested in a solid understanding and mastery of the F# computation
    expressions may turn to this excellent detailed reading on the subject by Scott
    Wlaschin: **The "Computation Expressions" series** ([https://fsharpforfunandprofit.com/series/computation-expressions.html](https://fsharpforfunandprofit.com/series/computation-expressions.html)
    ).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对F#计算表达式有深入理解和掌握兴趣的人来说，可以参考Scott Wlaschin关于此主题的出色详细阅读材料：**“计算表达式”系列** ([https://fsharpforfunandprofit.com/series/computation-expressions.html](https://fsharpforfunandprofit.com/series/computation-expressions.html)
    )。
- en: Exploring type providers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索类型提供者
- en: Frankly, I consider **type providers** as one of the most exciting, powerful,
    and pragmatic F# features. Ability to apply type providers is, in my opinion,
    among the strongest arguments for the usage of F# in enterprise software development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，我认为**类型提供者**是 F# 中最激动人心、最强大和最实用的特性之一。在我看来，应用类型提供者的能力是使用 F# 进行企业级软件开发的最强有力的论据之一。
- en: The feature review
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能回顾
- en: Type providers in F# represent a pretty unique *practical* pattern of manipulating
    various data sources in a strongly typed manner. This manipulation is accomplished
    via types, methods, and properties that were derived from the data source features
    and built at compile-time in a fully automated fashion. The developer is not required
    to author and/or maintain these automatically *provided* data manipulation means.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的类型提供者代表了一种相当独特的**实用**模式，以强类型方式操作各种数据源。这种操作是通过从数据源特征派生出的类型、方法和属性来完成的，这些类型、方法和属性在编译时以完全自动化的方式构建。开发者不需要编写和/或维护这些自动提供的**数据操作**手段。
- en: The idea of automatic code generation itself is as old as pyramids, but what
    makes the difference is versatility, ease of usage, and a painless experience.
    Those who've ever wrestled with **SqlMetal** ([https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx)
    ) or **WSDLTool** ([https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx](https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx)
    ) would appreciate the way of type providers a lot.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自动代码生成的想法本身和金字塔一样古老，但使其与众不同的因素是它的通用性、易用性和无痛苦的使用体验。那些曾经与**SqlMetal** ([https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110).aspx)
    ) 或 **WSDLTool** ([https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx](https://msdn.microsoft.com/en-us/library/7h3ystb6(v=vs.100).aspx)
    ) 作斗争的人会非常欣赏类型提供者的方式。
- en: It is also true that *creating* a useful type provider of production quality
    may require a lot of skill and effort. Nevertheless, once created, the type provider
    component can be used without any limits, so the usage benefits overweigh the
    construction pains by many times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，*创建*一个具有生产质量的实用类型提供者可能需要大量的技能和努力。然而，一旦创建，类型提供者组件就可以无限制地使用，因此使用的好处远远超过了构建的痛苦。
- en: It is also worth mentioning that since the introduction of type providers in
    F# 3.0, many valuable data source kinds have already been covered. Since the initial
    wave of type provider construction mentioned in **Twelve F# type providers in
    action** ([https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/](https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/)
    ), the available providers have gotten significantly more mature, providing a
    slick and smooth usage experience.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，自从 F# 3.0 中引入类型提供者以来，许多有价值的数据源种类已经被涵盖。自从在**《Twelve F# type providers
    in action》**（[https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/](https://blogs.msdn.microsoft.com/dsyme/2013/01/30/twelve-f-type-providers-in-action/)）中提到的类型提供者构建的初期浪潮以来，可用的提供者已经变得更加成熟，提供了流畅且顺畅的使用体验。
- en: 'Enough talking; let''s first take a look at the big picture of F# type provider
    workings. This is shown in the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 言归正传；让我们首先看看 F# 类型提供者工作原理的大致情况。这将在以下图中展示：
- en: '![The feature review](img/Image00053.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![功能回顾](img/Image00053.jpg)'
- en: F# type provider workings
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: F# 类型提供者的工作原理
- en: 'Without pretending to cover all potential external data sources, I am mentioning
    the following ones here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不假装涵盖所有潜在的外部数据源，我在这里提到了以下几种：
- en: Files of many specific formats (Excel, comma-separated, JSON, and so on) frequently
    utilized in enterprise development
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在企业开发中经常使用的多种特定格式的文件（Excel、逗号分隔、JSON 等等）
- en: Database engines (Microsoft SQL Server, Oracle, MySQL, and so on)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库引擎（Microsoft SQL Server、Oracle、MySQL 等等）
- en: A variety of web APIs implementing different protocols and data presentation
    formats
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不同协议和数据展示格式的各种 Web API
- en: A variety of application engines (Python, R, MatLab, and so on) that can be
    remotely controlled in order to implement the desired processing and yielding
    results being given input data
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以远程控制以实现所需处理并给出输入数据的各种应用程序引擎（Python、R、MatLab 等等）
- en: 'The magic begins at compile-time, when the developer references code type(s)
    that are expected to be provided from the given data source(s) within the F# application:
    results of a given query against a database, tabular data from some Excel file,
    clustering results of certain data; you name it. The F# compiler needs the corresponding
    type provider(s) to be available in the form of library packages. Reaching out
    to given data sources for the required metadata at compile-time, the type provider
    in concert with the F# compiler builds provided types, methods, and properties
    that allow you to treat external data on the fly in a strongly typed manner.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法从编译时开始，当开发者引用在F#应用程序中预期从给定数据源提供的代码类型时：对数据库的给定查询的结果，某些Excel文件的表格数据，某些数据的聚类结果；你叫它什么。F#编译器需要相应的类型提供者以库包的形式可用。在编译时从给定数据源获取所需的元数据，类型提供者与F#编译器一起构建提供类型、方法和属性，允许你以强类型方式即时处理外部数据。
- en: For example, **SQLClient type provider** ([http://fsprojects.github.io/FSharp.Data.SqlClient](http://fsprojects.github.io/FSharp.Data.SqlClient)
    ) takes compile-time connection strings, connects *during compilation* to the
    given data engine instance, and having the text of the given query in T-SQL on
    hand uses certain system stored procedures in order to find types associated with
    the columns of the to-be-returned result set. This type information translates
    into a built-on-the-fly type associated with the query. As a result, if we are
    compiling under Visual Studio, we are getting Intellisense with regard to the
    fields associated with the result set that is present as the F# sequence of the
    compiler-provided type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**SQLClient类型提供者**([http://fsprojects.github.io/FSharp.Data.SqlClient](http://fsprojects.github.io/FSharp.Data.SqlClient)
    )使用编译时连接字符串，在**编译期间**连接到给定的数据引擎实例，并使用T-SQL中给定查询的文本，利用某些系统存储过程来查找与即将返回的结果集的列相关联的类型。这种类型信息转化为与查询关联的即时构建的类型。因此，如果我们是在Visual
    Studio下编译，我们将获得与编译器提供的类型相关的F#序列的结果集字段的Intellisense。
- en: If at run-time we shoot the same query against *some other* data engine that
    has data with table schemas similar to the table(s) participating in the compiled
    query, the provided data access type will still be good for data transformations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行时对**其他**具有与编译查询中参与表类似的表架构的数据引擎执行相同的查询，提供的数据库访问类型仍然适用于数据转换。
- en: It is important to understand that the correspondence between database schemas
    and the query associated with the provided type is kept under static typing scrutiny;
    if any part of this equation (either the query expression or the involved schemas)
    changes, the code simply does not compile.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，数据库模式与提供的类型相关的查询之间的对应关系是在静态类型审查下保持的；如果这个方程式的任何一部分（无论是查询表达式还是涉及的架构）发生变化，代码将无法编译。
- en: This is simultaneously a fault and a blessing as it reliably protects from potential
    mishaps between the application code and the data layer. However, the necessity
    of having access to the SQL data engine at compile-time complicates arrangements
    such as builds, continuous integration, and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这既是缺陷也是祝福，因为它可以可靠地保护应用程序代码和数据层之间的潜在错误。然而，在编译时需要访问SQL数据引擎的必要性使得构建、持续集成等安排变得复杂。
- en: Personally, I am a big fan of the aforementioned type provider and found it
    interesting that often, people do not realize the delineation that exists between
    compile-time and run-time and effectively confining the possibilities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我是上述类型提供者的忠实粉丝，并发现一个有趣的现象，那就是人们往往没有意识到编译时和运行时之间的区别，实际上限制了可能性。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some developers ask from time to time whether the query associated with the
    provided type can be changed at run-time. Apparently, the answer is a big *no*
    as that would require you to change the already generated type-specific code.
    At the same time, it is just fine (and expected) to change the connection string
    at run-time in order to access the target data engine where the data to be processed
    resides. Usually, the latter may be achieved with the provided type constructor
    having the run-time connection string as an argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者时不时地会问，是否可以在运行时更改与提供的类型相关的查询。显然，答案是绝对的**不**可以，因为这需要你更改已经生成的特定类型的代码。同时，在运行时更改连接字符串以访问数据要处理的目标数据引擎是完全可以（并且是预期的）。通常，后者可以通过提供具有运行时连接字符串作为参数的类型构造函数来实现。
- en: I'm going to use this type provider for demo purposes later in this chapter,
    so you will have a chance to check your understanding.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面使用这个类型提供者进行演示，所以你将有机会检查你的理解。
- en: The demo problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示问题
- en: 'When picking a demo problem for type provider subject, I was initially doubtful
    whether it''s feasible to delve into the type provider creation process or whether
    this book''s format limits me to using only the existing type providers. I even
    solicited an opinion from a group of colleagues on whether it''s possible to implement
    a practically sound type provider not exceeding 20 lines of F# code. The answer
    turned out to be affirmative, thanks to one of the authors of the aforementioned
    SQLClient type provider, who pointed out the interesting side problem this provider
    brought to light: the relationship between SQL code and the F# code.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择类型提供者主题的示例问题时，我最初怀疑是否可行深入探讨类型提供者创建过程，或者这本书的格式是否限制我只能使用现有的类型提供者。我甚至征求了一群同事的意见，看看是否可以实施一个不超过
    20 行 F# 代码的实用类型提供者。结果证明是肯定的，多亏了上述 SQLClient 类型提供者的作者之一，他指出了这个提供者带来的有趣问题：SQL 代码与
    F# 代码之间的关系。
- en: From the separation of concerns standpoint, it is not an impeccable proposition
    to have T-SQL queries belonging to an application embedded into the F# code as
    literals. Ideally, it would be great to keep these queries separately from the
    F# code in a separate SQL script directory, having designated `.sql` file per
    each query. But how can such an arrangement be possible if we need the contents
    of these files to be represented as string literals in the application code at
    compile-time?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从关注点分离的角度来看，将属于应用程序的 T-SQL 查询作为字面量嵌入到 F# 代码中并不是一个完美的提议。理想情况下，最好将这些查询与 F# 代码分开，存放在一个单独的
    SQL 脚本目录中，并为每个查询指定一个 `.sql` 文件。但如果我们需要在编译时将这些文件的內容作为字符串字面量表示在应用程序代码中，这种安排又如何可能呢？
- en: Eureka! The way out would be using just another type provider!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！出路就是再使用另一个类型提供者！
- en: An internal "file reader" type provider may associate a corresponding *provided*
    type with the SQL query text stored there as a literal field with each SQL query
    file at compile-time. The literal field does not anyhow differ from the literal
    string constant in the text. Such an elegant approach indeed!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个内部“文件读取器”类型提供者可以在编译时将相应的 *提供* 类型与存储在该处的 SQL 查询文本关联起来，作为字面量字段与每个 SQL 查询文件相关联。这个字面量字段在文本中与字面量字符串常量没有区别。这种优雅的方法确实很棒！
- en: Taking into account an apparent didactic value behind this clear delineation
    between compile-time and run-time considerations, I decided to come up with something
    similar.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种在编译时和运行时考虑之间的清晰划分背后的明显教学价值，我决定提出类似的东西。
- en: 'Imagine that we want to protect the execution of an application with a secret
    key but do not want to have the key value present anywhere in the source code.
    Instead, the secret may be kept in a key vault of some sort and be associated
    with the application only during the build. The deficiency of such protection
    is apparent as the secret value would be still present somewhere in the compiled
    application assembly. But that is not the point of the exercise. The requirement
    is this: there should be no secret key value in the source code.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要用密钥来保护应用程序的执行，但又不想让密钥值出现在源代码的任何地方。相反，密钥可能被保存在某种类型的密钥库中，并在构建期间与应用程序相关联。这种保护的不足之处很明显，因为密钥值仍然会出现在编译后的应用程序程序集的某个地方。但这不是练习的重点。要求是：源代码中不应有任何密钥值。
- en: The demo solution
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示解决方案
- en: Our solution would be to create a type provider that, given a reference to the
    external repository that contains the secret key, would provide a type with the
    `string` secret value extracted from the repository and stored as a literal field.
    This means that such a field can be used as a case value in the `match...with`
    F# expression without revealing the underlying value in any manner. Also, you
    would acquire a firm understanding of the inner type provider workings as well
    as a sticky pattern to recall each time when in doubt about what activity happens
    when in type providing scenarios.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案是创建一个类型提供者，给定一个指向包含密钥的外部存储库的引用，它会提供一个具有从存储库中提取的 `string` 密钥值的类型，并将其作为字面量字段存储。这意味着这样的字段可以用作
    `match...with` F# 表达式中的案例值，而不会以任何方式泄露底层值。此外，你还会对内部类型提供者的工作原理有一个牢固的理解，以及一个在不确定类型提供场景中发生什么活动时可以回忆的粘性模式。
- en: 'I''m ready to jump upon the implementation. Writing a type provider in 2016
    is a breeze compared to how it was in 2012, when the feature was first delivered
    to the masses. Thanks to the open source effort of the amazing F# community for
    assembling together and packaging a sort of SDK in the form of the NuGet package
    for the creation of F# type providers, namely **FSharp.TypeProviders.StarterPack **
    ([https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack](https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack)
    ). Bear with me. Just perform the following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经准备好开始实现。在 2016 年编写类型提供者比 2012 年首次向大众推出该功能时容易得多。感谢惊人的 F# 社区的开源努力，他们共同组装并打包了一个
    SDK，以 NuGet 包的形式提供 F# 类型提供者的创建，即 **FSharp.TypeProviders.StarterPack** ([https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack](https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack)）。请耐心等待。只需执行以下步骤：
- en: Shoot out a new Visual Studio project to create the F# library named **KeyTypeProvider**
    .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Visual Studio 项目以创建名为 **KeyTypeProvider** 的 F# 库。
- en: Get rid of the two generated files with the `.fs` and `.fsx` extensions.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除两个具有 `.fs` 和 `.fsx` 扩展名的生成文件。
- en: Using **Package Manager Console** , add the Type Provider Starter Pack NuGet
    package to the just created project, issuing the `Install-Package FSharp.TypeProviders.StarterPack`
    command and observing a bunch of source code files added to the project (`ProvidedTypes.fsi`
    , `ProvidedTypes.fs` , and `DebugProvidedTypes.fs` ).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **包管理控制台**，将类型提供者启动包 NuGet 包添加到刚刚创建的项目中，输入 `Install-Package FSharp.TypeProviders.StarterPack`
    命令，并观察项目添加了一堆源代码文件（`ProvidedTypes.fsi`、`ProvidedTypes.fs` 和 `DebugProvidedTypes.fs`）。
- en: Add a new F# source code file named `KeyTypeProvider.fs` and place it *below*
    the last of injected files listed in the previous bullet (remember that the order
    in which the F# source code files are introduced to the compiler matters a lot).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `KeyTypeProvider.fs` 的新 F# 源代码文件，并将其放置在上一条项目符号中列出的注入文件列表的最后一个文件之下（记住，F#
    源代码文件被引入编译器的顺序非常重要）。
- en: 'That''s it; we are ready to craft the type provider code into the latter file.
    I am placing the snippet with the corresponding code as follows (`KeyTypeProvider.fs`
    ):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们准备好将类型提供者代码编织到后面的文件中。我将相应的代码片段放置如下（`KeyTypeProvider.fs`）：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's not exactly 20 lines of code, but it's quite close. I will just outline
    the purpose of the bits and pieces in the preceding snippet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 exactly 20 行代码，但相当接近。我将只概述前面代码片段中各个部分的目的。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Those of you willing to tinker with the code of such sort may walk through
    **Tutorial: Creating a Type Provider** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider)
    ) as a supplementary helper.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 愿意对这类代码进行修改的各位可以参考 **教程：创建类型提供者** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider)），作为辅助工具。
- en: After referring the pertinent libraries, the definition of our `KeyStringProvider`
      *type provider type* (yes, type provider has its own type, sure thing) follows
    decorated with the `[<TypeProvider>]` attribute and inherited from the `TypeProviderForNamespaces`
    type, which is defined elsewhere in these auto-inserted code files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用相关库之后，我们的 `KeyStringProvider` 类型提供者类型（是的，类型提供者有自己的类型，当然）的定义紧随 `[<TypeProvider>]`
    属性之后，并从 `TypeProviderForNamespaces` 类型继承，该类型定义在这些自动插入的代码文件中的其他地方。
- en: 'The next three lines of code define the name and location of the provided type:
    `FSharp.IO.SecretKey` and the run-time assembly.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三行代码定义了提供类型的名和位置：`FSharp.IO.SecretKey` 和运行时程序集。
- en: The body of the following `do` expression is the meat of the implementation.
    It defines that the provided type will have a single `Path` static parameter of
    type `string` , and most importantly, upon instantiation, the provider will read
    the text contained in the file referred by the `Path` and make the ingested string
    the value of the provided type's literal static field named `Key` . Right, I agree
    that the local text file is not the most reliable of key vaults, but this design
    choice is taken for brevity; the way the secret is kept is completely irrelevant
    to the subject. This part may be implemented in principle in any other manner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`do`表达式的主体是实现的核心。它定义了提供的类型将有一个单一的`Path`静态参数，其类型为`string`，最重要的是，在实例化时，提供者将读取由`Path`引用的文件中的文本，并将摄入的字符串作为提供类型字面静态字段`Key`的值。是的，我同意本地文本文件不是最可靠的密钥库，但这个设计选择是为了简洁；密钥的保存方式与主题完全无关。这部分原则上可以用任何其他方式实现。
- en: The final `do()` expression decorated with the `[<assembly:TypeProviderAssembly()>]`
    attribute is just a type provider-specific assembly marker for the .NET assembly-loading
    machinery.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`do()`表达式被`[<assembly:TypeProviderAssembly()>]`属性装饰，这只是类型提供者特定的.NET程序集加载机具的标记。
- en: We are done. Building our project should produce `KeyTypeProvider.dll` in the
    target `bin` directory. Our type provider is ready to be put to work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。构建我们的项目应该在目标`bin`目录中产生`KeyTypeProvider.dll`。我们的类型提供者已经准备好投入使用。
- en: 'I''ve created the following short F# script for this purpose (`Ch11_2.fsx`
    ):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个目的创建了一个简短的F#脚本（`Ch11_2.fsx`）：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order for this script to compile, it is required that you put the `Secret.txt`
    file referred in the type declaration of `Vault` using our demo provided type,
    `FSharp.IO.SecretKey` , into the project directory side by side with the preceding
    script in the file system. As soon as we do this, Intellisense in Visual Studio
    begins working, which is reflected in the following figure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个脚本编译，你需要将`Secret.txt`文件（在`Vault`的类型声明中使用我们提供的类型`FSharp.IO.SecretKey`引用）放入项目目录中，与文件系统中的前面脚本并排。一旦我们这样做，Visual
    Studio中的Intellisense就开始工作，这在下面的图中有所体现：
- en: '![The demo solution](img/Image00054.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![演示解决方案](img/Image00054.jpg)'
- en: Local file contents packaged as a type's static field literal value
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地文件内容打包为类型的静态字段字面值
- en: Note that the type provider revealed the contents of the secret (the `ABigSecret`
    string line) at compile-time via Intellisense. Nevertheless, the secret is not
    present in the source code whatsoever. Also, having the secret referred to as
    a `Vault.Key` case of the `function` expression without any objections from the
    F# compiler clearly indicates that the compiler fully buys into it being a genuine
    literal string!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型提供者在编译时通过Intellisense揭示了秘密的内容（`ABigSecret`字符串行）。尽管如此，秘密根本不存在于源代码中。此外，将秘密作为`Vault.Key`的`function`表达式的案例，并且没有来自F#编译器的任何反对意见，这清楚地表明编译器完全接受它是一个真正的字面字符串！
- en: Now, it is time to see how all this plays outside of the type provider development
    environment, within a separate FSI session. The results are presented in the following
    screenshot and are fully aligned with the expectations. Just recollect the workings
    of this fun F# type provider application every time you feel any confusion about
    the type provider pattern applicability and abilities it should help you sort
    things out.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看所有这些在类型提供者开发环境之外的表现了，在一个单独的FSI会话中。结果如下面的截图所示，完全符合预期。每次当你对类型提供者模式的适用性和它应该帮助你整理问题的能力感到困惑时，就回想一下这个有趣的F#类型提供者应用程序。
- en: '![The demo solution](img/Image00055.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![演示解决方案](img/Image00055.jpg)'
- en: Using the SecretKey type provider from the FSI script
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在FSI脚本中使用SecretKey类型提供者
- en: Wrapping up, F# type providers represent a rather unique idiomatic feature of
    automatic types generation that may deliver significant boosts in productivity
    and code quality.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，F# 类型提供者代表了一种相当独特的自动类型生成习惯用法，这可能会在生产力以及代码质量上带来显著的提升。
- en: Exploring concurrent computations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索并发计算
- en: To a great extent, the reinvigorated industrial attention on functional programming
    after many years of increased academic interest stems from the achieved capacities
    of electronics. On the one hand, the capabilities of contemporary computers make
    computer science findings considered more of a pure science savor thirty years
    ago quite practical today owing to an enormous increase in the speed and capacity
    of calculations. On the other hand, at the silicon level, the science has hit
    the physical limit for the further speeding-up of a single processor core operation.
    So the practical computation speed-up is happening along the lines of splitting
    a given amount of calculations between a group of processors working in a close
    concert.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多年学术兴趣增加之后，功能编程重新受到工业界的关注，这在很大程度上是由于电子技术的实现能力。一方面，当代计算机的能力使得三十年前被认为是纯科学的计算机科学发现，由于计算速度和容量的巨大增加，现在变得非常实用。另一方面，在硅层面上，科学已经达到了进一步加速单个处理器核心操作的物理极限。因此，实际的计算速度提升是通过将一定量的计算分配给一组紧密协作的处理器来实现的。
- en: The feature review
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性回顾
- en: The thing is that the brave new world of cheap multicore processors cannot afford
    expensive, error-prone, mentally onerous methods of programming. It is demanding
    the concurrency taming abstractions of a much higher level than the programming
    primitives for it that were developed by computer science in the era of the extensive
    growth of computing power.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个充满活力的新世界——廉价的多人核心处理器，无法承担昂贵、易出错、精神负担沉重的编程方法。它要求有比计算机科学在计算能力广泛增长时代开发的编程原语更高层次的并发驯服抽象。
- en: These primitives have played their role in exposing the major problem behind
    concurrent calculations - such calculations are much less deterministic than we
    are accustomed to by dealing with sequential calculations. If the indeterminism
    in sequential calculations is usually associated with the imperfections of ambient
    physical environment materializing the former, the lack of determinism in concurrent
    calculations is intrinsic. This means that error-prone manipulation of programming
    primitives for synchronization between multiple co-executed calculations offers
    plenty of ways to shoot yourself in the foot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原语在揭示并发计算背后的主要问题中发挥了作用——这种计算比我们习惯的顺序计算要少确定性得多。如果顺序计算中的非确定性通常与实现前者的环境物理环境的缺陷有关，那么并发计算中的非确定性是内在的。这意味着，在多个并发执行的计算之间进行同步的编程原语的易出错操作提供了许多自毁前程的方式。
- en: The most prominent example of self-imposed indeterminism is **deadlock** ([https://en.wikipedia.org/wiki/Deadlock](https://en.wikipedia.org/wiki/Deadlock)
    ) when concurrent program parts lacking proper synchronization over shared resources
    may, under some conditions, mutually lock each other.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自我强加的非确定性的最突出例子是**死锁**（[https://en.wikipedia.org/wiki/Deadlock](https://en.wikipedia.org/wiki/Deadlock)），当并发程序部分在共享资源上缺乏适当的同步时，在某些条件下可能会相互锁定。
- en: Much trickier (and potentially much more dangerous) are cases where the concurrent
    code may misbehave only under extremely rare conditions. This may be really dangerous
    because such conditions may not introduce themselves during quality assurance
    and user acceptance testing. Then, the defective code basically carrying a "bomb"
    gets released into production, and in full accordance with Murphy's Law, blows
    up at the most inappropriate obstacles.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更为复杂（并且可能更加危险）的情况是，并发代码可能在极其罕见的情况下出现异常行为。这可能是非常危险的，因为这种条件可能不会在质量保证和用户验收测试期间自行出现。然后，带有“炸弹”的缺陷代码基本上被发布到生产环境中，并且完全符合墨菲定律，在最不合适的时候发生爆炸。
- en: The functional programming promise for better quality concurrent programs is
    so dear to the industry today that many mainstream programming languages are getting
    supplied with add-on functional features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 功能编程对提高并发程序质量的承诺对行业来说如此宝贵，以至于许多主流编程语言都增加了附加的功能特性。
- en: 'Before we look deeper into what F# offers to tame concurrency indeterminism,
    let''s take a look at the distinctive facets under the common concurrency umbrella
    that are important to recognize:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解F#如何驯服并发非确定性之前，让我们看看在常见的并发伞下，需要认识到的独特方面：
- en: '**Synchronous and asynchronous** : The first one, given a few expressions to
    evaluate, does not start the evaluation of the next expression before the previous
    one has been evaluated. The second one allows you to move between some half-evaluated
    expressions.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步与异步**：前者在评估下一个表达式之前，不会开始评估前一个表达式。后者允许你在一些半评估的表达式之间切换。'
- en: '**Concurrent and parallel** : Parallelism assumes simultaneous evaluation of
    more than one expression using multiple processing units, while concurrency may
    be asynchronous partial evaluation of a few expressions by a single processing
    unit.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发与并行**：并行假设使用多个处理单元同时评估多个表达式，而并发可能是一个处理单元对几个表达式的异步部分评估。'
- en: '**Interactive and reactive** : The former drives the external environment,
    while the latter responds to external environment demands.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式与响应式**：前者驱动外部环境，而后者响应外部环境的需求。'
- en: 'F# offers usage patterns taming concurrency using a uniform mechanism of **asynchronous
    expressions/workflows** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows)
    ). Concisely, an asynchronous expression, which is a particular specific form
    of the computation expression mentioned earlier, is written in this form:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: F#提供了一种使用**异步表达式/工作流**（[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/asynchronous-workflows)）的统一机制来驯服并发。简而言之，异步表达式，即前面提到的计算表达式的特定形式，是以这种形式编写的：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It has the generic type of `Async<'T>` . In turn, the `Async` class has a bunch
    of functions that trigger actual asynchronous evaluation of the preceding expression
    following a few scenarios.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有`Async<'T>`的泛型类型。反过来，`Async`类提供了一组函数，这些函数在几种情况下触发前面表达式的实际异步评估。
- en: 'This is a very elegant and straightforward mechanism indeed. It allows you
    to conceal the fact that evaluation is going to be concurrent behind familiar
    forms of function composition. For example, take into account this innocuous code
    snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个非常优雅且直接的机制。它允许你在熟悉的功能组合形式下隐藏评估将并发进行的这一事实。例如，考虑以下无害的代码片段：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It performs a rather loaded function composition with intermediary types presented
    as line comments, where the first line using a list comprehension expression yields
    a `list` of `Async<int>` , which then with the help of the `Async.Parallel` combinator
    fans out into `Async<int []>` parallel calculations that, in turn, with another
    `Async.RunSynchronously` combinator, join their asynchronously calculated expressions
    into the `int []` array of results, yielding 10 numbers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行了一个相当复杂的函数组合，中间类型以行注释的形式呈现，其中第一行使用列表推导表达式产生一个`Async<int>`的`list`，然后借助`Async.Parallel`组合器扩展成`Async<int[]>`的并行计算，这些并行计算随后通过另一个`Async.RunSynchronously`组合器将它们异步计算的表达式合并到结果的`int[]`数组中，得到10个数字：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I will not attempt to prove to you that the preceding snippet will allow you
    to demonstrate performance gains from calculation parallelization. The preceding
    evaluation is so simple that the parallel snippet must in fact be *slower* than
    just sequential calculation analog:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会尝试向你证明前面的代码片段能够让你展示出通过计算并行化带来的性能提升。前面的评估如此简单，以至于并行代码片段实际上必须比仅仅顺序计算的类似代码要**慢**。
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is because the parallel CPU asynchronous arrangement should introduce an
    overhead in comparison with a straightforward sequential list comprehension evaluation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为与直接的顺序列表推导评估相比，并行CPU异步安排应该会引入额外的开销。
- en: However, it all changes when we step into territory that is dear to enterprise
    development, namely begin dealing with parallel I/O. Performance gains from the
    I/O parallelization are going to be the subject of the following demo problem
    illustrating the design pattern enabled by F# asynchronous calculations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们进入企业开发领域所珍视的领域时，一切都会改变，即开始处理并行I/O。I/O并行化带来的性能提升将是下一个演示问题的主题，该问题展示了由F#异步计算所启用的设计模式。
- en: The demo problem
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示问题
- en: Let me build an I/O-bound application that would allow the demonstration of
    a really overwhelming speedup when F# parallel I/O async pattern is applied. A
    good use case for this would be SQL Server with its scaling capabilities allowing
    you to reach persuasive improvements in comparison with multiple demos of concurrent
    web requests that F# authors and bloggers usually provide.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我构建一个I/O密集型应用程序，这将允许演示当应用F#并行I/O异步模式时，可以实现的真正惊人的加速。一个很好的用例是SQL Server，它具有扩展能力，允许你在与F#作者和博客作者通常提供的多个并发Web请求演示相比时，实现有说服力的改进。
- en: As an asynchronous concurrency vehicle, I'll be using the feature of the `FSharp.Data.SqlClient`
    type provider's **SQLCommandProvider** ([https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs](https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs)
    ), which allows asynchronous querying with the help of the `AsyncExecute()` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为异步并发工具，我将使用`FSharp.Data.SqlClient`类型提供者的`SqlCommandProvider`功能（[https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs](https://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/src/SqlClient/SqlCommandProvider.fs)），它允许使用`AsyncExecute()`方法进行异步查询。
- en: I will create synchronous and asynchronous implementations of the same task
    of extracting data from SQL Server and then carrying out a performance comparison
    to detect and measure gains secured by F# asynchronous I/O usage pattern application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建同步和异步的相同任务，从SQL Server提取数据，然后执行性能比较，以检测和测量F#异步I/O使用模式应用所获得的好处。
- en: The demo solution
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示解决方案
- en: 'For the sake of conciseness, the SQL-related part is going to be extremely
    simple. Executing the following T-SQL script against the instance of the `(localdb)\ProjectsV12`
    database engine accompanying the installation of Visual Studio 2013 or any other
    Microsoft SQL Server installation available to you, given it fulfills the type
    provider **system requirements** ([http://fsprojects.github.io/FSharp.Data.SqlClient/](http://fsprojects.github.io/FSharp.Data.SqlClient/)
    ), will create the necessary database components from scratch (`Ch11_1.sql` ):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，SQL相关部分将非常简单。在Visual Studio 2013或任何其他可用的Microsoft SQL Server安装中，针对`(localdb)\ProjectsV12`数据库引擎实例执行以下T-SQL脚本，前提是它满足类型提供者的**系统要求**（[http://fsprojects.github.io/FSharp.Data.SqlClient/](http://fsprojects.github.io/FSharp.Data.SqlClient/)），将从零开始创建必要的数据库组件（`Ch11_1.sql`）：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the part marked `(1)` creates and prepares for use the instance of the
    `demo` database, and the part marked `(2)` puts the `dbo.MockQuery` stored procedure
    into this database. This stored procedure, which lacks input arguments, implements
    an extremely simple query. Specifically, first, it introduces a time delay of
    1 second, mocking some data search activity and then it returns a single data
    row with the integer `1` as the execution result.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标记为`(1)`的部分创建并准备使用`demo`数据库的实例，而标记为`(2)`的部分将`dbo.MockQuery`存储过程放入此数据库。这个没有输入参数的存储过程实现了一个非常简单的查询。具体来说，首先，它引入了1秒的时间延迟，模拟了一些数据搜索活动，然后返回一个包含整数`1`作为执行结果的单一数据行。
- en: 'Now, I turn to commenting the F# script for the demo solution (`Ch11_1.fsx`
    ):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将转向注释演示解决方案的F#脚本（`Ch11_1.fsx`）：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Consider that the preceding F# code taken literally will not compile because
    of a few line wraps introduced by typesetting. Instead, use the code part accompanying
    the book as the source of working F# code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述F#代码直接使用将无法编译，因为排版引入了几行换行。相反，请使用书中附带的代码部分作为工作F#代码的来源。
- en: After loading the type provider package and opening the required libraries,
    the `connStr` value decorated with the `[<Literal>]` attribute signifies both
    design-time and execution-time SQL server connection strings. This line might
    require modifications if you are using some other version of database engine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载类型提供者包并打开所需的库之后，带有`[<Literal>]`属性的`connStr`值表示了设计时和执行时的SQL服务器连接字符串。如果使用其他版本的数据库引擎，此行可能需要修改。
- en: The next line delivers the type provider magic by introducing the `SqlCommandProvider`
    provided type `Mock` ensuring statically typed access to the results of the wrapped
    query that is represented by the stored procedure call, `exec MockQuery` , over
    our `connStr` connection string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行通过引入由`SqlCommandProvider`提供的类型`Mock`，展示了类型提供者魔法，确保了对由存储过程调用`exec MockQuery`表示的包装查询结果的静态类型访问，该调用是通过我们的`connStr`连接字符串进行的。
- en: The following `querySync` function ensures sequential execution of the `cmd`
    command represented by the instance of the provided `Mock` type given the number
    of times `nReq` yields a sequence of query results (each is just `1` from the
    single row of the result set) and then aggregates this sequence with `Seq.sum`
    . If we evaluate the `querySync 10` expression, we may expect a bit above a 10
    second delay in getting back a single number, `10` .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`querySync`函数确保了由提供的`Mock`类型实例表示的`cmd`命令的顺序执行。给定`nReq`次数，它产生一系列查询结果（每个都是结果集的单行中的`1`），然后使用`Seq.sum`聚合这个序列。如果我们评估`querySync
    10`表达式，我们可能期望得到一个略高于10秒的延迟，以返回一个单一的数字，`10`。
- en: So far, so good. The following `query` function takes any argument and returns
    an asynchronous computation of type `Async<int>` . I put this function within
    the combined expression wrapped into the `queryAsync` function, effectively representing
    the concurrent variant of `querySync` . Specifically, the array of `nReq` numbers
    is mapped into an `Async<int>` array of the same size, and then they are all fanned
    out by `Async.Parallel` , joined back after completion with `Async.RunSynchronously`
    and eventually aggregated by `Array.sum` into a single number.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。下面的`query`函数接受任何参数并返回一个类型为`Async<int>`的异步计算。我将这个函数放在`queryAsync`函数包裹的复合表达式中，有效地代表了`querySync`的并发变体。具体来说，`nReq`数字的数组被映射成相同大小的`Async<int>`数组，然后通过`Async.Parallel`全部展开，完成后通过`Async.RunSynchronously`重新连接，最终通过`Array.sum`聚合成一个单一的数字。
- en: The last piece is an instrumentation higher-order `timing` function that just
    measures and outputs the evaluation of the `f args` computation duration in milliseconds.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分是一个高阶的**计时**函数，它只是测量并输出`f args`计算持续时间的毫秒数。
- en: 'Alright; now, it is time to take our script for a spin. I put the code into
    FSI and measure the duration of executing `querySync` and `queryAsync` 100 times.
    You can see the measurement results in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；现在，是时候对我们的脚本进行测试了。我将代码放入FSI中，并测量`querySync`和`queryAsync`执行100次的时间。您可以在下面的屏幕截图中看到测量结果：
- en: '![The demo solution](img/Image00056.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![演示解决方案](img/Image00056.jpg)'
- en: Measuring synchronous versus asynchronous SQL querying
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 测量同步与异步SQL查询
- en: Are you as impressed as I am? Results show that I/O parallelization in the case
    of SQL queries allowed improved performance approximately 100-fold!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你和我一样印象深刻吗？结果显示，在SQL查询的情况下，I/O并行化允许性能提高大约100倍！
- en: This demo is quite persuasive and I strongly recommend that you master and use
    this and other F# idiomatic concurrency patterns in your practical work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示非常令人信服，我强烈建议您掌握并使用这个以及其他F#惯用并发模式在实际工作中。
- en: Exploring reactive computations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索反应式计算
- en: Reactive computations are the part of concurrent computations' scope. They just
    stress a slightly different matter, namely the processing of general events. The
    processing of events may be genuinely concurrent, when one or more of simultaneously
    occurring events are processed without any sort of serialization or genuinely
    sequential if a new event is not processed until the processing of the previous
    one has finished.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式计算是并发计算范围的一部分。它们只是强调了一个稍微不同的问题，即通用事件的处理。事件的处理可能是真正并发的，当同时发生的一个或多个事件被处理而没有任何形式的序列化，或者如果新事件在处理完前一个事件之前不被处理，则可能是真正顺序的。
- en: The feature review
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能审查
- en: Usually, the event processing view akin to concurrency takes roots at the development
    of the systems that have **user interface** ( **UI** ) component(s) when sluggish
    processing of data coming from input devices and/or data reflecting the visual
    state of graphic UI components is simply unacceptable as it creates a terrible
    **user experience** ( **UX** ).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，类似于并发的**事件处理**视图在具有**用户界面**（**UI**）组件的系统开发中根深蒂固，当来自输入设备的数据处理缓慢或反映图形UI组件视觉状态的数据时，这种处理简单是不可接受的，因为它会创建一个糟糕的**用户体验**（**UX**）。
- en: This is all good and true, but let's concentrate on an aspect not directly related
    to UI/UX, namely the conceptual consideration of **event processing** taking place.
    As this consideration is tied to F#, I will limit the review with .NET boundaries.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，但让我们集中关注一个与UI/UX不直接相关的方面，即正在进行的**事件处理**的概念性考虑。由于这个考虑与F#相关，我将限制审查的范围在.NET边界内。
- en: Historically, the development of interactive operating systems such as Windows coined
    the concept of **callback** ([https://en.wikipedia.org/wiki/Callback_(computer_programming)](https://en.wikipedia.org/wiki/Callback_(computer_programming))
    ), which brought to consideration **events** and **event handlers** . This is
    the lowest conceptual level of reactive programming, where the developer's responsibility
    is to provide the handlers for each event class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，交互式操作系统（如Windows）的发展提出了**回调**（[https://en.wikipedia.org/wiki/Callback_(computer_programming)](https://en.wikipedia.org/wiki/Callback_(computer_programming)））的概念，这考虑到了**事件**和**事件处理器**。这是反应式编程最低的概念层次，其中开发者的责任是为每个事件类提供处理器。
- en: The next abstraction level in reactive computations came with object-oriented
    programming and is manifested by the  **Observer design pattern** ([https://en.wikipedia.org/wiki/Observer_pattern](https://en.wikipedia.org/wiki/Observer_pattern)
    ). Now, the developer may think of a specific event type processing flow as an
    interaction between the event type (in other words, **subject** ) source named
    **Observable** and zero or more parties interested in the processing of this subject
    event named **Observers** . Observers manifest their interest in the subject by
    dynamically **registering** and **unregistering** with the corresponding Observable.
    As soon as the next event belonging to the subject comes into existence, all Observers
    registered at the moment with the corresponding Observer get notified about the
    chance of processing the event and then continue waiting for the next one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式计算的下一个抽象层次是面向对象编程，这体现在**观察者设计模式**（[https://en.wikipedia.org/wiki/Observer_pattern](https://en.wikipedia.org/wiki/Observer_pattern)）上。现在，开发者可以将特定的事件类型处理流程视为名为**Observable**的事件类型（换句话说，**主题**）源与零个或多个对处理此主题事件感兴趣的部分（名为**观察者**）之间的交互。观察者通过动态**注册**和**注销**到相应的Observable来表明对主题的兴趣。一旦出现属于主题的下一个事件，当时注册的相应观察者都会收到处理事件的提醒，然后继续等待下一个事件。
- en: Finally, the conceptual quintessence for reactive computations took place with
    the seminal work of a group headed by computer scientist **Erik Meijer** ([https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)](https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist))
    ), who created **Reactive Extensions (Rx) for .NET** ([https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx)
    ).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反应式计算的概念精髓在计算机科学家**Erik Meijer**（[https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)](https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)））领导的团队的开创性工作中得到了体现，他创建了**.NET的Reactive
    Extensions (Rx)**（[https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx)）。
- en: The key idea behind Rx is concentrating on **pushing** versus **pulling** data
    sequences by introducing a fundamental `IObservable` interface that is a reversal
    of `IEnumerable` in the way it exposes the event data stream. This is similar
    to how "normal" data sequences, after being enumerated, can be pulled-composed
    by higher-order functions and queried using LINQ--and observable event sequences
    (event streams) may be received--composed with higher-order functions and processed
    by LINQ.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Rx背后的关键思想是通过引入一个基本的`IObservable`接口来集中处理**推送**与**拉取**数据序列，这个接口与`IEnumerable`相反，因为它暴露了事件数据流。这与“正常”数据序列在被枚举后可以通过高阶函数进行拉取式组合，并使用LINQ进行查询类似——而可观察的事件序列（事件流）可以通过高阶函数进行接收式组合，并由LINQ进行处理。
- en: F# supports all three of the preceding abstractions, throwing in some improvements
    in comparison with other programming languages of the .NET platform.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: F#支持上述所有三种抽象，并且与.NET平台上的其他编程语言相比，还有一些改进。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This subject matter is very well documented and I refer you to related F#-specific
    documentation on the `Microsoft.FSharp.Control` namespace pieces and `Reactive
    Extensions (Rx)` for details: **Event module** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d)
    ). **Observable module** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d)
    ). **Reactive Extensions** ([https://msdn.microsoft.com/en-us/data/gg577609.aspx](https://msdn.microsoft.com/en-us/data/gg577609.aspx)
    ).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题已经得到了很好的记录，我建议您参考有关`Microsoft.FSharp.Control`命名空间组件和`Reactive Extensions
    (Rx)`的F#特定文档以获取详细信息：**事件模块**（[https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d)）。**可观察模块**（[https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.observable-module-%5bfsharp%5d)）。**反应式扩展**（[https://msdn.microsoft.com/en-us/data/gg577609.aspx](https://msdn.microsoft.com/en-us/data/gg577609.aspx)）。
- en: Instead of retelling the preceding documentation, I will take F# reactive computation
    features for a spin, implementing a relevant practical task. I will try to make
    the implementation self-contained.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会重复前面的文档内容，而是将F#反应式计算功能付诸实践，实现一个相关的实际任务。我会尽量使实现自包含。
- en: The demo problem
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示问题
- en: 'Let''s consider the following **integration pattern ** ( [http://www.enterpriseintegrationpatterns.com/patterns/messaging/](http://www.enterpriseintegrationpatterns.com/patterns/messaging/)
    ) that is quite typical for the enterprise: document message exchange over two
    point-to-point channels. We are a client of an external service that communicates
    with us using a pair of dedicated channels. If we need to send a document message,
    we just push it into the outbound channel and the remote service somehow consumes
    it. If the service sends a message(s) back to us, they are delivered into the
    inbound channel. As soon as we pull a document message from the inbound channel,
    it gets removed from there. The following figure illustrates this interaction.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下**集成模式**（[http://www.enterpriseintegrationpatterns.com/patterns/messaging/](http://www.enterpriseintegrationpatterns.com/patterns/messaging/)），这在企业中相当典型：通过两个点对点通道进行文档消息交换。我们是外部服务的客户端，该服务通过一对专用通道与我们通信。如果我们需要发送文档消息，我们只需将其推入出站通道，远程服务就会以某种方式消费它。如果服务向我们发送消息（s），它们会被投递到入站通道。当我们从入站通道拉取文档消息时，它就会从那里移除。以下图示说明了这种交互。
- en: '![The demo problem](img/Image00057.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![演示问题](img/Image00057.jpg)'
- en: Enterprise two-way document exchange
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 企业双向文档交换
- en: Those of you who get involved in Enterprise LOB development have perhaps already
    recognized a typical case of peer-to-peer **Electronic Data Interchange (EDI)**
    ([https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer](https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer)
    ). Often, providers are quite conservative in choosing specific transfer protocols
    and prefer sticking to "old but gold" technologies such as **SSH File Transfer
    Protocol (SFTP)** ([https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol](https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol)
    ) for a reasonably inexpensive way of integration when data security is a requirement.
    As an enterprise may be involved into EDI with multiple remote service providers,
    the amount of such arrangements may be quite significant.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那些参与企业LOB开发的人可能已经识别出典型的**电子数据交换（EDI）**（[https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer](https://en.wikipedia.org/wiki/Electronic_data_interchange#Peer-to-Peer)）对等案例。通常，提供商在选择特定的传输协议时相当保守，并倾向于坚持“老而金”的技术，如**SSH文件传输协议（SFTP）**（[https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol](https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol)），这是一种合理低成本的集成方式，当数据安全是要求时。由于企业可能需要与多个远程服务提供商进行EDI，这种安排的数量可能相当可观。
- en: Nevertheless, I'm not going to concentrate on building a configurable library
    that allows the addition of a new EDI provider with a few lines of code. Instead,
    I will address the semantics layer that usually stands outside of architectural
    considerations, namely relations that may need to be enforced between bidirectional
    document message exchanges that, for SFTP transfer, translate into pushing and
    pulling formatted files to/from the service provider.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我并不打算专注于构建一个可配置的库，该库允许通过几行代码添加新的 EDI 提供商。相反，我将解决语义层，这通常位于架构考虑之外，即可能需要在双向文档消息交换中强制执行的关系，对于
    SFTP 传输，这转化为将格式化文件推送到或从服务提供商那里拉取。
- en: 'To be a bit more specific, I offer to your attention a real case from the **Jet.com**
    ([https://jet.com/](https://jet.com/) ) Finance realm, where I at the moment write
    F# code for a living. Let''s consider the payment system as a client and the bank
    as a service provider. The service gist is to execute payment advices and deliver
    remittances to the bank accounts of legal and physical entities with whom Jet.com
    gets into temporary "I owe you" relations: suppliers and vendors, merchants of
    the marketplace, employees with outstanding reimbursable business expenses and
    the like.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体一些，我提供给您一个来自 **Jet.com** ([https://jet.com/](https://jet.com/) ) 财务领域的真实案例，我在那里目前以编写
    F# 代码为生。让我们考虑支付系统作为客户端，银行作为服务提供商。服务的大致内容是执行付款建议并将汇款交付给 Jet.com 与其建立临时“我欠你”关系的法律实体和自然人账户：供应商和批发商、市场商人、有未报销业务费用的员工等等。
- en: Now, let's assume that we have built our communication code around SFTP, which
    pushes remittances to the bank, gets back statements, originations and the like,
    all retries are in place, and all wheels are rotating smoothly. Are we doing fine?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们已经围绕 SFTP 构建了我们的通信代码，将付款推送到银行，获取回执、原始凭证等，所有重试都到位，所有轮子都在平稳运转。我们做得好吗？
- en: Turns out the answer is "not really". We silently assume at this point that
    the bank's implementation is free of problems based on a whole slew of fallacies,
    such as "it's about finance", "the bank would not survive if it had bugs", "it
    is too big to allow failures" and similar. However, the bank's software is just
    software and is susceptible to all kinds of human errors. We may expect its reliability
    to be overall higher than in a random start-up minimal viable product code constituting
    a web application implementing a hot business idea and written in a garage during
    few hackathons. On the other hand, each bank's software release carries the next
    "last bug" in it, doesn't it?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明答案实际上是“并不真的”。在这个时候，我们默默地假设银行的实现没有问题，基于一系列谬误，例如“这是关于金融的”，“如果银行有错误，它将无法生存”，“它太大，不允许失败”等等。然而，银行的软件只是软件，容易受到各种人为错误的影响。我们可能期望它的可靠性总体上高于一个随机初创公司最小可行产品代码，该代码构成一个实现热门商业想法的
    Web 应用程序，在几次黑客马拉松期间在车库中编写。另一方面，每个银行的软件发布都包含下一个“最后一个错误”，不是吗？
- en: 'It so happened one day that Jet''s bank client software did not provision for
    the following scenario: what if the bank correctly accepts and executes each payment
    advice, but once in a while it does not communicate the deferred final payment
    status back to us? The payment recipients are all happy with remittance cash hitting
    their accounts and no communication errors taking place. If we take the successful
    outcome of our deliverable payment advices for granted, this bug may stay there
    forever! This is a low probability scenario but not absolutely improbable. In
    fact, a similar defect went unnoticed in Jet''s payment arrangement for a short
    time until marketplace reports started showing a growing amount of deferred payments.
    That was embarrassing!'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，Jet 的银行客户端软件没有考虑到以下场景：如果银行正确接受并执行每笔付款建议，但偶尔不向我们传达延迟的最终付款状态，会发生什么？付款接收者都对汇款现金进入他们的账户以及没有通信错误感到满意。如果我们假设我们的交付付款建议的成功结果，这个错误可能永远存在！这是一个低概率场景，但并非绝对不可能。事实上，在
    Jet 的支付安排中，一个类似的缺陷在一段时间内未被注意到，直到市场报告开始显示延迟付款的数量不断增加。这真是尴尬！
- en: Can we fix this by being proactive with our "pull" data transfer part? Keep
    reading for the outline of the potential solution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否通过主动处理我们的“拉”数据传输部分来解决这个问题？继续阅读以了解潜在解决方案的概述。
- en: The demo solution
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示解决方案
- en: One of the (overly simplified) potential solutions would be to mix the flow
    of "heartbeat" events with the flow of guarded events. As the generalization of
    guarding a single event of a certain type to any number events of a similar type
    is not challenging, let me consider a single guarded event of a type for brevity.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一种（过于简化的）潜在解决方案是将“心跳”事件流与受保护的事件流混合。由于将单个特定类型的事件的保护泛化到任何类似类型的事件并不具有挑战性，让我考虑一个单一的保护事件类型以简化问题。
- en: Within this guarded event flow mix, we establish a threshold upon how many heartbeats
    are considered healthy between the start of guarding the event and the actual
    occurrence of the guarded event. For example (the specific numbers do not anyhow
    coincide with real ones), we may say that if the ACH payment is being sent and
    after following three heartbeat events, `ACHOrigination` event is still not received,
    this should be the indication of a problem and the responsible personnel must
    be alerted of the deviation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个受保护事件流混合中，我们设定了一个阈值，即在保护事件开始和实际发生受保护事件之间，认为多少次心跳是健康的。例如（具体的数字并不一定与实际情况相符），我们可以说如果
    ACH 付款正在发送，并且随后有三个心跳事件后，`ACHOrigination` 事件仍未收到，这应该是问题的迹象，并且必须通知相关责任人员。
- en: 'Now let me implement the preceding using Reactive Extensions (`Ch11_3.fsx`
    ):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我使用反应式扩展（`Ch11_3.fsx`）实现前面的内容：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After loading a slew of required components from the corresponding NuGet libraries,
    I introduce the `PaymentFlowEvent` type reflecting the mix of the previously mentioned
    three events.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在从相应的 NuGet 库加载一系列所需组件后，我引入了反映先前提到的三种事件混合的 `PaymentFlowEvent` 类型。
- en: Next, the `GuardACHOrigination` class combines the stream of `PaymentFlowEvent`
    events set by argument `flow` , which is also known as `Subject` , `alerter` for
    the carrying out of notifications, and business logic combining all these parts
    together. **Subject** ([https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx)
    ) is a combination of the observable sequence and Observer, and it plays the central
    role in the preceding implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`GuardACHOrigination` 类结合了由参数 `flow` 设置的 `PaymentFlowEvent` 事件流，该参数也称为 `Subject`，`alerter`
    用于执行通知，以及将这些部分组合在一起的业务逻辑。**Subject** ([https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242970(v=vs.103).aspx)
    ) 是可观察序列和观察者的组合，在先前的实现中扮演着核心角色。
- en: The `Guard()` method takes `flow` , and with the help of its `Subscribe` method,
    sets a simple state machine tracking of what is going on upon the arrival of each
    instance of flowing through events of type `PaymentFlowEvents` . Given that the
    abnormality is recognized, the diagnostics notification is pushed into `alerter`
    .
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guard()` 方法接受 `flow`，并借助其 `Subscribe` 方法，在流通过事件类型 `PaymentFlowEvents` 的每个实例到达时设置简单的状态机跟踪正在发生的事情。鉴于异常已被识别，诊断通知被推入
    `alerter`。'
- en: 'Now, I create the required bits and pieces: `paymentFlow` representing the
    event stream of interest, `alerter` to receive notifications within `Guard()`
    , `notifier` to act upon notification events from `alerter` , and finally, fireup
    everything to life with `GuardACHOrigination(paymentFlow,alerter).Guard()` .'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我创建了所需的各个部分：`paymentFlow` 代表感兴趣的的事件流，`alerter` 用于在 `Guard()` 中接收通知，`notifier`
    用于对 `alerter` 的通知事件采取行动，最后，使用 `GuardACHOrigination(paymentFlow,alerter).Guard()`
    启动一切。
- en: 'Great; now it''s time to push a stream of events into the built arrangement
    and observe the reactive behavior in FSI. The following screenshot reflects that
    the code behavior is completely aligned with the expected: timely guarded events
    pass smoothly, overdue guarded events trigger alerts, and unguarded events get
    disregarded:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 很好；现在是我们将事件流推入构建好的安排中，并观察 FSI 中的反应性行为的时候了。下面的截图反映了代码行为完全符合预期：及时的保护事件顺利通过，过期的保护事件触发警报，未受保护的事件被忽略：
- en: '![The demo solution](img/Image00058.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![演示解决方案](img/Image00058.jpg)'
- en: Guarding the event flow with the F# reactive code
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 F# 反应式代码保护事件流
- en: The demonstrated pattern of applying F# in a reactive manner is an important tool
    belt skill that should be mastered by enterprise practitioners.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式方式中应用 F# 的演示模式是企业从业者应该掌握的重要工具技能。
- en: Exploring quotations and metaprogramming
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索引言和元编程
- en: The last feature I want to cover among the advanced patterns of F# use is **Code
    Quotations**  ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations)
    ). This feature is quite mind-bending, allowing you to work with the program code
    as if it is data, and evaluate these "program as data" pieces when needed and
    in the needed manner.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要在 F# 使用的先进模式中涵盖的最后一个功能是**代码引用** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations)
    )。这个特性非常令人费解，它允许你像处理数据一样处理程序代码，并在需要时以及以需要的方式评估这些“程序作为数据”的部分。
- en: The feature review
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能回顾
- en: Looking at this feature from the more operational angle, a program piece may
    be represented as an expression tree representing the code but without running
    the code generation off this representation. This allows for arbitrary execution
    behavior when the expression tree is to be evaluated. It can be evaluated as F#
    code or as source to generate JavaScript code or even as GPU-executed code or
    in any other feasible manner.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从更操作的角度来看这个特性，一个程序片段可能被表示为一个表达式树，它代表代码但不从这个表示中生成代码。这允许在表达式树被评估时具有任意执行行为。它可以被评估为
    F# 代码，或作为生成 JavaScript 代码的源，甚至作为 GPU 执行的代码，或以任何其他可行的方式。
- en: The cool thing about quoted expressions is that they are typed, they can be
    spliced together from parts, or they can be decomposed into parts using active
    patterns, among other features. Without delving into too much detail, I want to
    demonstrate that if required, F# offers this extra layer of flexibility by allowing
    you to tweak the program code and evaluate the tweaked code programmatically.
    For this purpose, I will be using **F# Quotations Evaluator** ([http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html](http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html)
    ).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 引用表达式的酷之处在于它们是类型化的，可以从部分拼接在一起，或者使用主动模式分解成部分，以及其他特性。不深入细节，我想展示的是，如果需要，F# 通过允许你以编程方式调整程序代码并评估调整后的代码，提供了这一额外的灵活性层。为此，我将使用**F#
    引用评估器** ([http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html](http://fsprojects.github.io/FSharp.Quotations.Evaluator/index.html)
    )。
- en: 'A very brief demonstration of the feature abilities is as follows (`Ch11_4.fsx`
    ):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性的能力非常简短地演示如下 (`Ch11_4.fsx` )：
- en: 'Get the required library support:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所需的库支持：
- en: '[PRE9]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `mutable` quoted `divider` value:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可变的引用 `divider` 值：
- en: '[PRE10]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create and compile a function with `divider` spliced into this:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并编译一个将 `divider` 拼接到其中的函数：
- en: '[PRE11]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Apply the compiled `is5Divisor` function to a few arguments:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编译的 `is5Divisor` 函数应用于几个参数：
- en: '[PRE12]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Change the spliced `divider` value:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改拼接的 `divider` 值：
- en: '[PRE13]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that `is5Divisor` workings did not change:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，`is5Divisor` 的工作方式没有改变：
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Recompile the spliced `divider` value into another function:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将拼接的 `divider` 值重新编译到另一个函数中：
- en: '[PRE15]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Apply the newly compiled `is7divisor` function:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用新编译的 `is7divisor` 函数：
- en: '[PRE16]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Equipped with some understanding of how quotations work, let me now apply the
    feature to a sizable demo problem.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在对引用的工作原理有了些了解之后，现在让我将这个特性应用到一个大型的演示问题中。
- en: The demo problem
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示问题
- en: 'While looking for a demo problem, I turn to the finance space again. Let''s
    look at the matter of invoice total adjustment based on the timeliness of payment.
    Paying an outstanding invoice early may bring some savings, while being late on
    it may impose penalties. When a vendor or supplier establishes payment terms,
    any combination of premiums and/or penalties may be set: neither premium nor penalty,
    just a premium, just a penalty, and both premium and penalty. It would be great
    to have an arrangement that would allow you to easily and naturally handle this
    variety. In other words, an adjustment is sought - for that, when applied to the
    invoice total and the payment date, finds out what the actual payment amount aligned
    with the payment terms would be.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找演示问题时，我再次转向金融领域。让我们看看基于支付及时性的发票总额调整问题。提前支付未结发票可能会节省一些费用，而延迟支付可能会产生罚款。当供应商或供应商设定支付条款时，可以设置任何组合的溢价和/或罚款：既无溢价也无罚款，只有溢价，只有罚款，以及溢价和罚款都有。有一个安排可以让你轻松自然地处理这种多样性会很好。换句话说，寻求一个调整——为此，当应用于发票总额和支付日期时，找出与支付条款一致的实际支付金额。
- en: The demo solution
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示解决方案
- en: 'Here is the script implementing the sought adjustment object (`Ch11_4.fsx`
    ):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现所寻求的调整对象的脚本 (`Ch11_4.fsx` )：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first thing to note is that the the necessary library is loaded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，必要的库已被加载。
- en: Then the `Adjustment` type is defined, which is either `Absent` or `Premium`
    /`Penalty` with the structure of the `System.TimeSpan*decimal` tuple, where the
    `TimeSpan` part defines the amount of time between invoice issuance and payment
    dates and `decimal` sets the adjustment multiplier. For `Premium` , the tuple
    is interpreted as "if the number of days between the invoice issuance and payment
    is less or equal to `TimeSpan` , then the amount of payment should be decreased
    by the `decimal` multiplier". For `Penalty` , it is "if the number of days between
    the invoice issuance and payment is greater or equal to `TimeSpan` , then the
    amount of payment should be increased by the `decimal` multiplier".
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义`Adjustment`类型，它可以是`Absent`或`Premium`/`Penalty`，其结构为`System.TimeSpan*decimal`元组，其中`TimeSpan`部分定义了发票开具日期和付款日期之间的时间量，而`decimal`设置了调整乘数。对于`Premium`，元组被解释为“如果发票开具日期和付款日期之间的天数小于或等于`TimeSpan`，则应付款项应减少`decimal`乘数”。对于`Penalty`，它是“如果发票开具日期和付款日期之间的天数大于或等于`TimeSpan`，则应付款项应增加`decimal`乘数”。
- en: The `Terms` type captures the adjustment terms within the `Adjust` method. Using
    F# quotations, it defines payment adjustment functions for each potential combination
    of terms, and then it either implements the prescribed adjustment or it doesn't.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Terms` 类型捕获了`Adjust`方法中的调整项。使用F#引言，它为每个可能的项组合定义了支付调整函数，然后它要么实现规定的调整，要么不实现。'
- en: 'Now, in order to see how it would work, we need a test bed. Let''s define a
    record representing invoice:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到它是如何工作的，我们需要一个测试平台。让我们定义一个表示发票的记录：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s also define test list of invoices:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也定义一个测试发票列表：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The function deriving the amount of payment due is now based on terms, and
    the invoice may look like the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确定应付款项金额的函数现在基于条款，发票可能看起来如下：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, it is time to define a full variety of the possible terms:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候定义可能的条款的完整种类了：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, we can observe in the following screenshot how all this plays
    together after being applied to test invoices by applying each payment term to
    the same invoice group:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在以下屏幕截图中观察到，在将每个支付条款应用于相同的发票组后，所有这些是如何结合在一起的：
- en: '![The demo solution](img/Image00059.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![演示解决方案](img/Image00059.jpg)'
- en: Using F# quotations
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用F#引言
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we assayed a few features of advanced F# usage category. I
    hope I was able to demonstrate that even for the advanced features, F# continues
    to keep the promise of "solving complex problems with simple code".
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们测试了高级F#使用类别的一些特性。我希望我能够证明，即使是对于高级特性，F#仍然保持着“用简单的代码解决复杂问题”的承诺。
- en: Now is a good time to pay further attention to the subject constituting this
    book's title. The content so far did not in any way cross the traditional view
    of design patterns usually associated with the contents of **Gang of Four Book**
    ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
    ). In the next chapter, I will justify the taken approach by observing the "classic"
    design patterns and principles from a functional-first view point.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进一步关注构成本书标题的主题的好时机。到目前为止的内容并没有以任何方式跨越与**四人帮书籍**（[https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)）内容通常相关联的传统设计模式视图。在下一章中，我将通过观察“经典”设计模式和原则的功能优先视角来证明所采取的方法。
