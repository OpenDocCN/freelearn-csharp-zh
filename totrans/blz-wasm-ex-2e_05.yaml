- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Local Storage Service Using JavaScript Interoperability (JS Interop)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Blazor WebAssembly framework makes it possible for us to run C# code on
    the browser. However, there are some scenarios that C# simply cannot handle, and
    for those scenarios, we need to use JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use JavaScript with Blazor WebAssembly.
    We will learn how to invoke a JavaScript function from a .NET method with and
    without a return value. Conversely, we will learn how to invoke a .NET method
    from a JavaScript function. We will accomplish both scenarios by using **JavaScript
    interop** (**JS interop**). Finally, we will learn how to store data on the browser
    by using the Web Storage API for JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The project that we will create in this chapter will be a local storage service
    that will read and write to the application’s local storage. To access the application’s
    local storage, we will use JavaScript. We will also create a test component to
    test the local storage service. The test component will use JavaScript to display
    text in a JavaScript alert box.
  prefs: []
  type: TYPE_NORMAL
- en: It is sad, but true.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We may not like JavaScript,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: but we still need it!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring JS interop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the local storage service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this project, you need to have Visual Studio 2022 installed on your
    PC. For instructions on how to install the free Community Edition of Visual Studio
    2022, refer to *Chapter 1*, *Introduction to Blazor WebAssembly*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Blazor-WebAssembly-by-Example-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Blazor-WebAssembly-by-Example-Second-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video is available here: [https://packt.link/Ch5](https://packt.link/Ch5).'
  prefs: []
  type: TYPE_NORMAL
- en: Why use JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Blazor WebAssembly, we can create robust applications without writing any
    JavaScript. However, there are some scenarios that require the use of JavaScript.
    For example, we may have a favorite JavaScript library that we want to continue
    to use. Also, without JavaScript, we can’t manipulate the DOM or call any of the
    JavaScript APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a partial list of things that we do not have access to directly from
    the Blazor WebAssembly framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DOM manipulation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Media Capture and Streams API**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **WebGL API** (2D and 3D graphics for the web)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Web Storage API** (`localStorage` and `sessionStorage`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Geolocation API**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript pop-up boxes (an alert box, a confirm box, and a prompt box)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The online status of the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser’s history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chart.js**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other third-party JavaScript libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list is not at all comprehensive since there are hundreds of JavaScript
    libraries that are currently available. However, the key point to remember is
    that we cannot manipulate the DOM without using JavaScript. Therefore, we will
    probably always need to use some JavaScript in our web apps. Luckily, by using
    JS interop, this is easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring JS interop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To invoke a JavaScript function from .NET, we use the `IJSRuntime` abstraction.
    This abstraction represents an instance of a JavaScript runtime that the framework
    can call into. To use `IJSRuntime`, we must first inject it into our component
    using dependency injection. For more information on dependency injection, refer
    to *Chapter 7*, *Building a Shopping Cart Using Application State*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@inject` directive is used to inject a dependency into a component. The
    following code injects `IJSRuntime` into the current component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IJSRuntime` abstraction has two methods that we can use to invoke JavaScript
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InvokeAsync**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InvokeVoidAsync**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods are asynchronous. The difference between these two methods is that
    one of them returns a value and the other does not. We can downcast an instance
    of `IJSRuntime` to an instance of `IJSInProcessRuntime` to run the method synchronously.
    Finally, we can invoke a .NET method from JavaScript by decorating the method
    with `JsInvokable`. We will look at examples of each of these methods later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we can invoke a JavaScript method, we need to load the JavaScript
    into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Loading JavaScript code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways to load JavaScript code into a Blazor WebAssembly app.
    One way is to enter the JavaScript code directly into a `script` element in the
    `body` element of the `wwwroot/index.html` file. However, instead of entering
    the JavaScript code directly into the .`html` file, we recommend using an external
    JavaScript file for your JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add an external file by referencing it in the `wwwroot./index.html`
    file. The following code references a file called `btwInterop.js` that is in the
    `wwwroot/scripts` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A better way to organize scripts is to collocate an external JavaScript file
    with a specific component. To add a JavaScript file that is collocated with a
    specific component, create a JavaScript file in the same folder as the component
    with the same name as the component, but with a JavaScript file extension. For
    example, the `MyComponent` component that is defined in the `MyComponent.razor`
    file would use `MyComponent.razor.js` as its collocated JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the component to reference the code in the JavaScript file, the file must
    be imported into the component during the `OnAfterRenderAsync` method of the component.
    In the following example, the `import` identifier is used to import a JavaScript
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the JavaScript file that is being imported is in the
    `Pages` folder and is named `MyComponent.razor.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: The collocated JavaScript files will be automatically moved to the `wwwroot`
    folder when the application is published. This approach is called JavaScript isolation
    and it makes downloading the JavaScript file lazy.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code uses the `InvokeAsync` method of `IJSRuntime` to invoke the
    JavaScript `import` function from .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a JavaScript function from a .NET method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two different methods of `IJSRutime` that we can use to invoke JavaScript
    from .NET asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InvokeAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvokeVoidAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To invoke a JavaScript function from .NET synchronously, `IJSRutime` must be
    downcast to `IJSInProcessRuntime`.
  prefs: []
  type: TYPE_NORMAL
- en: InvokeAsync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `InvokeAsync` method is an asynchronous method that is used to invoke a
    JavaScript function that returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `InvokeAsync` method of `IJSRuntime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first argument is the identifier for the JavaScript
    function, and the second argument is an array of JSON-serializable arguments.
    The second argument is optional. The `InvokeAsync` method returns a `ValueTask`
    of the `TValue` type. `TValue` is a JSON-deserialized instance of the JavaScript’s
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, the `Window` object represents the browser’s window. To determine
    the width and height of the current window, we use the `innerWidth` and `innerHeight`
    properties of the `Window` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following JavaScript code includes a method called `getWindowSize` that
    returns the width and height of the `Window` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wwwroot/bweInterop.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the `bweInterop` namespace for our JavaScript code
    to both structure our code and minimize the risk of naming conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the definition of the `WindowSize` class that is used to store the
    size of the window in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `Index` component invokes the `GetWindowSize` method from the
    `bweInterop.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pages/Index.razor**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `IJSRuntime` is injected into the component. When the
    **Get Window Size** button is clicked, the `GetWindowSize` method uses the `InvokeAsync`
    method of `IJSRuntime` to invoke the `getWindowSize` JavaScript function. The
    `GetWindowSize` JavaScript function returns the width and height of the window
    to the `windowSize` property. Finally, the component regenerates its render tree
    and applies any changes to the browser’s DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a screenshot of the page after the **Get Window Size** button has been
    clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Window size example'
  prefs: []
  type: TYPE_NORMAL
- en: The `InvokeSync` method of `IJSRuntime` is used to call JavaScript functions
    that return a value. If we do not need to return a value, we can use the `InvokeAsync`
    method instead.
  prefs: []
  type: TYPE_NORMAL
- en: InvokeVoidAsync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `InvokeVoidAsync` method is an asynchronous method that is used to invoke
    a JavaScript function that does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `InvokeVoidAsync` method of `IJSRuntime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `InvokeAsync` method, the first argument is the identifier for
    the JavaScript function that is being called, and the second argument is an array
    of JSON-serializable arguments. The second argument is optional.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, the `Document` object represents the root node of the HTML document.
    The `title` property of the `Document` object is used to specify the text that
    appears in the browser’s title bar. Assume that we want to update the browser’s
    title as we navigate between the components in our Blazor WebAssembly app. To
    do that, we need to use JavaScript to update the `title` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following JavaScript code exports a function called `setDocumentTitle`
    that sets the `title` property of the `Document` object to the value provided
    by the `title` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared/Document.razor.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses an `export` statement to export the `setDocumentTitle`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: The `export` statement in JavaScript is used to export functions from JavaScript
    to be imported into other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Document` component uses the `setDocumentTitle` JavaScript function
    to update the browser’s title bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared/Document.razor**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `IJSRuntime` is injected into the component. Then, the
    `OnAfterRenderAsync` method uses the `InvokeAsync` method to import the JavaScript
    code and the `InvokeVoidAsync` method to invoke the `setDocumentTitle` JavaScript
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: We are not using the `bweInterop` namespace in the collocated JavaScript code
    to emphasize that it is only referenced by one component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following markup uses the `Document` component to update the browser’s
    title bar to `Home – My App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the resulting document title:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18471_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Updated document title'
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the built-in `PageTitle` component to set the title of the page.
  prefs: []
  type: TYPE_NORMAL
- en: By default, JS interop calls are asynchronous. To make synchronous JS interop
    calls, we need to use `IJSInProcessRuntime`.
  prefs: []
  type: TYPE_NORMAL
- en: IJSInProcessRuntime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far in this chapter, we have only looked at invoking JavaScript functions
    asynchronously. But we can also invoke JavaScript functions synchronously. We
    do that by downcasting `IJSRuntime` to `IJSInProcessRuntime`. `IJSInProcessRuntime`
    allows our .NET code to invoke JS interop calls synchronously. This can be advantageous
    because these calls have less overhead than their asynchronous counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the synchronous methods of `IJsInProcessRuntime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoke`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvokeVoid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code uses `IJSInProcessRuntime` to invoke a JavaScript function
    synchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `IJsRuntime` instance has been downcast to an `IJSInProcessRuntime`
    instance. The `Invoke` method of the `IJSInProcessRuntime` instance is used to
    invoke the `getGuid` JavaScript method.
  prefs: []
  type: TYPE_NORMAL
- en: The `IJSRuntime` abstraction provides methods to invoke JavaScript functions
    directly from .NET methods. They can be invoked either asynchronously or synchronously.
    Invoking a .NET method directly from a JavaScript function requires a special
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a .NET method from a JavaScript function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can invoke a public .NET method from JavaScript by decorating the method
    with the `JSInvokable` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following .NET method is decorated with the `JSInvokable` attribute to
    enable it to be invoked from JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `windowSize` property is updated each time the `GetWindowSize`
    method is invoked from JavaScript. After the `windowSize` property is updated,
    the component’s `StateHasChanged` method is called to notify the component that
    its state has changed, and therefore, the component should be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: The `StateHasChanged` method of a component is only called automatically for
    `EventCallback` methods. In other cases, it must be called manually to notify
    the UI that it may need to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: To invoke a .NET method from JavaScript, we must create a `DotNetObjectReference`
    class for JavaScript to use to locate the .NET method. The `DotNetObjectReference`
    class wraps a JS interop argument, indicating that the value should not be serialized
    as JSON but instead, should be passed as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid memory leaks and allow garbage collection on a component that creates
    a `DotNetObjectReference` class, you must diligently dispose of each instance
    of `DotNetObjectReference`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a `DotNetObjectReference` instance that wraps the
    `Resize` component. The reference is then passed to the JavaScript method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can invoke a method in a .NET component from JavaScript using a reference
    to the component created with `DotNetObjectReference`. In the following JavaScript,
    the `registerResizeHandler` function creates the `resizeHandler` function that
    is called at initialization, and every time the window is resized.
  prefs: []
  type: TYPE_NORMAL
- en: '**bweInterop.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `invokeMethodAsync` function is used to invoke
    the `GetWindowSize` .NET method that was decorated with the `JSInvokable` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: You can use either the `invokeMethod` function or the `invokeMethodAsync` function
    to invoke .NET instance methods from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the complete .NET code for the `Resize` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resize.razor**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code for the `Resize` component displays the current width and
    height of the browser. As you resize the browser, the displayed values are automatically
    updated. Also, the `DotNetObjectReference` object is disposed of when the component
    is disposed. To test the `Resize` component, press *Ctrl*+*F5* to start the application
    without debugging. After the application starts, navigate to the `/resize` page
    and resize the window.
  prefs: []
  type: TYPE_NORMAL
- en: The `IJSRuntime` abstraction provides us with a way to invoke JavaScript functions
    from .NET and to invoke .NET methods from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using JavaScript’s Web Storage API to complete the project in this
    chapter. But before we can use it, we need to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Using local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web Storage API for JavaScript provides mechanisms for browsers to store
    key/value pairs. For each web browser, the size of data that can be stored in
    web storage is at least 5 MB per origin. The `localStorage` mechanism is defined
    in the Web Storage API for JavaScript. We need to use JS interop to access the
    application’s local storage because the Web Storage API requires the use of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The application’s local storage is scoped to a particular URL. If the user reloads
    the page or closes and reopens the browser, the contents of local storage are
    retained. If the user opens multiple tabs, each tab shares the same local storage.
    The data in local storage is retained until it is explicitly cleared, since it
    does not have an expiration date.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Data in a `localStorage` object that is created when using an *InPrivate* window
    or *Incognito* window is cleared when the last tab is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the methods of `localStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**key**: This method returns the name of the indicated key based on its position
    in `localStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getItem**: This method returns the value for the indicated key from `localStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setItem**: This method takes a key and value pair and adds them to `localStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**removeItem**: This method removes the indicated key from `localStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**clear**: This method clears `localStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '`sessionStorage` is also defined in the Web Storage API. Unlike `localStorage`,
    which shares its value between multiple browser tabs, `sesssionStorage` is scoped
    to an individual browser tab. Therefore, if the user reloads the page, the data
    persists, but if the user closes the tab (or the browser), the data is cleared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the contents of the application’s local storage, open the browser’s
    developer tools by pressing *F12* and selecting the **Application** tab. Select
    **Local Storage** in the **Storage** section of the menu on the left. The following
    screenshot shows the **Application** tab of the **DevTools** dialog in Microsoft
    Edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Local Storage'
  prefs: []
  type: TYPE_NORMAL
- en: By using the Web Storage API, it is easy to store data in the browser and retrieve
    it. Now, let’s get a quick overview of the project that we are going to build
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the local storage service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a local storage service. The service will both
    write to and read from the application’s local storage. We will use JS interop
    to accomplish this. We will use the `InvokeVoidAsync` method to write to local
    storage and the `InvokeAsync` method to read from local storage. Finally, we will
    create a component to test our service.
  prefs: []
  type: TYPE_NORMAL
- en: The test component will both read and write local storage. It will use JS interop
    to display the contents of local storage in a JavaScript alert box.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows both the test component and the application’s
    local storage. When the **Save to Local Storage** button is clicked, the value
    of the text in the **localStorageData** textbox is saved to local storage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Local Storage Service test page'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the **Read from Local Storage** button is clicked, the value of **localStorageData**
    is displayed in a JavaScript alert box. The following screenshot shows a sample
    of an alert that is displaying the value in local storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18471_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Read from Local Storage'
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is approximately 60 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LocalStorage` project will be created by using Microsoft’s **Blazor WebAssembly
    App Empty** project template to create an empty Blazor WebAssembly project. First,
    we will add a JavaScript file with the JavaScript functions that our service will
    need to use to update the application’s local storage. Next, we will create the
    interface and class with the .NET methods that will invoke the JavaScript functions.
    Finally, we will test our service by adding a collocated JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create a new Blazor WebAssembly app. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio 2022.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create a new project** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Alt*+*S* to enter the **Search for templates** textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Blazor` and press the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Blazor WebAssembly App Empty** project
    template:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18471_05_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.6: Blazor WebAssembly App Empty project template'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Blazor WebAssembly App Empty** project template and click the **Next**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `LocalStorage` in the **Project name** textbox and click the **Next**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a screenshot of the dialog used to configure our new project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.7: Configure your new project dialog'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding example, we placed the `LocalStorage` project into the `E:/Blazor`
    folder. However, the location of this project is not important.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **.NET 7.0** as the **Framework** version to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Configure for HTTPS** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **ASP.NET Core Hosted** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Progressive Web Application** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a screenshot of the dialog used to collect additional information about
    our new project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18471_05_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.8: Additional information dialog'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created an empty `LocalStorage` Blazor WebAssembly project. Let’s now
    start adding the JavaScript functions that we will need for reading and writing
    to local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Writing JavaScript to access local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to write the JavaScript functions that will read to and write from
    the application’s local storage. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `wwwroot` folder and select the **Add**, **New Folder** option
    from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new folder `scripts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `scripts` folder and select the **Add**, **New Item** option
    from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `javascript` in the **Search** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **JavaScript File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the JavaScript file `bweInterop.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding JavaScript includes a `setLocalStorage` function that writes to
    local storage, and the `getLocalStorage` function, which reads from local storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `wwwroot/index.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following markup to the bottom of the `body` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: In the `wwwroot/index.html` file, the `script` tag that references your custom
    Java-Script should be after the Blazor script reference.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to add the .NET code that will invoke these JavaScript functions.
    First, we will create the interface for our service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ILocalStorageService interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create an interface for our service. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `LocalStorage` project and select the **Add**, **New Folder**
    option from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new folder `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Services** folder and then select the **Add**, **New Item**
    option from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `interface` in the **Search** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `ILocalStorageService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `ILocalStorageService` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding methods will be used to set the value of local storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `Program.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code after the code that registers `HttpClient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code registers the `LocalStorageService` in the dependency injection
    container. For more information on dependency injection, refer to *Chapter 7*,
    *Building a Shopping Cart Using Application State.*
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the abstract methods of the service and registered it with the
    application. Now it’s time to create the `LocalStorageService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the LocalStorageService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create a new class based on the interface we just created. We do
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the **Services** folder and select the **Add**, **Class** option
    from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `LocalStorageService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `LocalStorageService` class to inherit from `ILocalStorageService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `LocalStorageService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines the constructor for the `LocalStorageService` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `SetItemAsync` method to the `LocalStorageService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SetItemAsync` method invokes the `bweInterop.setLocalStorage` JavaScript
    function with a key and a serialized version of the item to be stored in `localStorage`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `GetItemAsync` method to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetItemAsync` method invokes the `bweInterop.getLocalStorage` JavaScript
    function with a key. If `bweInterop.getLocalStorage` returns a value, that value
    is deserialized and returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have completed our service. Now we need to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DataInfo class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DataInfo` class will be used to hold the data that we read and write from
    the application’s local storage:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `LocalStorage` project and select the **Add**, **New Folder**
    option from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new folder `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Models** folder and select the **Add**, **Class** option from
    the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `DataInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to the `DataInfo` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DataInfo` class includes the data, information about the length of the
    data, and the date and time the data was updated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined an object to hold our data, it’s time to test writing
    data to the application’s local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to test writing to the application’s local storage using our local
    storage service. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Pages/Index.razor` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `H1` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding markup adds a textbox to enter the data to be saved to the application’s
    local storage and a button to call the `SaveToLocalStorageAsync` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click the **Pages** folder and select the **Add**, **Class** option from
    the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `Index.razor.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class into a partial class by adding the `partial` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code injects the `LocalStorageService` into the component and
    defines the `SaveToLocalStorageAsync` method. The `SaveToLocalStorageAsync` method
    uses **localStorageData** as the key when saving the data to `localStorage`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Ctrl*+*F5* to start the application without debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18471_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Local Storage Service test page'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the word `Test` into the **localStorageData** textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Save to Local Storage** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F12* to open the browser’s developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Application** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `Local Storage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a different word into the **localStorageData** textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Save to Local Storage** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the application’s local storage has been updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have used the Web Storage API to save data to the application’s local storage.
    Next, we need to learn how to read from the application’s local storage. Since
    we will be displaying the data in a JavaScript alert box, we need to add some
    JavaScript code to call the alert function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collocated JavaScript file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add a collocated JavaScript file to contain the JavaScript code
    that will call the alert function. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Return to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Pages** folder and select the **Add**, **New Item** option
    from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `javascript` in the **Search** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **JavaScript File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the JavaScript file `Index.razor.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following JavaScript to the `Index.razor.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code exports the `showLocalStorage` function that opens an alert
    box, containing the text that is specified by the `data` parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `Pages/Index.razor.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject an instance of `IJSRuntime` into the `Index` component by adding the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `OnAfterRenderAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The JavaScript functions that are in the `Pages/Index.razor.js` file can now
    be invoked from the `Index` component.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to test reading from the application’s local storage using our local
    storage service. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Pages/Index.razor` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following button beneath the existing button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding markup adds a button that calls the `ReadFromLocalStorageAsync`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the Pages/Index.razor.cs file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ReadFromLocalStorageAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReadFromLocalStorageAsync` method uses the `localStorageData` key when
    accessing the application’s local storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Ctrl*+*F5* to start the application without debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Read from Local Storage** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the contents of the alert box match the contents of the application’s
    local storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ReadFromLocalStorage` method invoked the `showLocalStorage` function in
    the collocated JavaScript file. We have now completed the testing of our local
    storage service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be able to create a local storage service by using JS interop
    to invoke JavaScript functions from your Blazor WebAssembly application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explained why you may still need to use JavaScript and how
    to use the `IJSRuntime` abstraction to invoke JavaScript functions from .NET,
    both asynchronously and synchronously. Conversely, we explained how to invoke
    .NET methods from JavaScript functions. Finally, we explained how to store data
    in the browser by using the application’s local storage.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we used the `Blazor WebAssembly App Empty` project template to create
    a new project. We added a couple of JavaScript functions to read and write the
    application’s local storage. Then, we added a class to invoke those JavaScript
    functions. In the last part of the chapter, we tested our local storage service
    by adding a collocated JavaScript file that opened a JavaScript alert box.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest benefits of using Blazor WebAssembly is that all the code
    runs on the browser. This means that a web app built using Blazor WebAssembly
    can run offline. In the next chapter, we will leverage this advantage to create
    a progressive web app.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions are provided for your consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: Can `IJSRuntime` be used to render a UI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you add our local storage service to a Razor class library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a collocated JavaScript file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you think that you will still use JavaScript? If so, what will you use it
    for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what scenarios do you need to invoke JavaScript asynchronously rather than
    synchronously?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide more information regarding the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on using JavaScript, refer to [https://www.w3schools.com/js](https://www.w3schools.com/js).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more detailed information on JavaScript, refer to [https://developer.mozilla.org/en-US/docs/Web/javascript](https://developer.mozilla.org/en-US/docs/Web/javascript).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the JavaScript reference, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on `localStorage`, refer to [https://www.w3.org/TR/webstorage/#the-localstorage-attribute](https://www.w3.org/TR/webstorage/#the-localstorage-attribute).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Microsoft Edge (Chromium) Developer Tools, refer to
    [https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
