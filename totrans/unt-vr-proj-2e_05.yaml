- en: Handy Interactables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You're in a virtual world with all this cool stuff; it is our nature to try
    to reach out and touch something. While gaze-based selection, as we saw in the
    previous chapter, is a good first step for interacting with virtual scenes, most
    people intuitively want to use their hands. Most VR devices provide a hand controller
    to select, grab, and interact with virtual objects in the scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we introduce practices for capturing user input in Unity,
    illustrating how to use them in a simple VR scene. Everyone loves balloons, so
    in this project we will make balloons. We may even pop a few. We will continue
    from the previous chapter, using C# programming for basic scripting, and explore
    several software design patterns for user input. We will discuss the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Polling for input device data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using scriptable data objects for storing and retrieving input state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking and subscribing to input events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interactable components provided with device-specific Unity packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important lesson we will learn in this chapter is there is not just one way
    to handle user input for your VR application. There isn't even one *best way*.
    Unity includes several mechanisms for handling user input and, in general, messaging
    between objects. VR device manufacturers provide their own input controller objects
    and scripts for their SDK.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, VR manufacturers and others offer convenient framework toolkits
    with higher-level components and prefabs. We recommend you become familiar with
    the toolkits provided for your target device. Study the demo scenes to see how
    the components work and their recommended practices, as we will do at the end
    of this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: That said, in this chapter we will start with the very simple button press input,
    and progress from there, showing various design patterns. You won't always want
    to roll your own, but you should have an understanding of how things work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scene
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin our exploration of input mechanisms, let's set up our scene. The plan
    is to let players create balloons. Everyone loves balloons!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scene, you could start with a new scene (File | New Scene) and then
    add the MyMyselfEye prefab we built in the previous chapter. Instead, I''ve decided
    to start with the Diorama scene created in the previous chapter, and remove all
    but the GroundPlane and PhotoPlane, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Open the Diorama scene
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all the objects, except for MyMyselfEye, Directional Light, GroundPlane
    and PhotoPlane
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the MeMyselfEye at the scene origin, Position (0, 0, 0)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select File | Save Scene As and give it a name, such as "Balloons"
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a balloon
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the balloon, you can simply use a standard Unity sphere 3D primitive if
    you choose. Or you can find an object in the Unity Asset Store or elsewhere. We
    are using a low poly balloon object that we found on Google Poly ([https://poly.google.com/view/a01Rp51l-L3](https://poly.google.com/view/a01Rp51l-L3))
    and which is provided with the download files for this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, please parent the object so its origin (pivot point) is at the
    bottom, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create an empty object (Create | Create Empty) and name it "Balloon".
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its transform (Transform | gear-icon | Reset), then Position it at (0,
    1, 1).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the balloon prefab into the Hierarchy as a child object of Balloon (mine
    is found in the `Assets/Poly/Assets/` folder).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you do not have a balloon model, use a sphere (Create | 3D Object | Sphere).
    And add a material, like the "Blue Material" we created in the previous chapter.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the child object's Position to (0, 0.5, 0) so its origin (pivot point) is
    at its bottom when referenced from the parent.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The scene should look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7881a110-f890-4d78-bdc3-6132de13f1d1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Making it a prefab
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our intent is to instantiate new balloons from a prefab when your player presses
    a button on their controller. And when the button is released, the balloon gets
    released and it floats away.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s scale and position the balloon initially in the scene at a starting
    size and workable distance. We will also give it some physics properties by adding
    a `RigidBody` component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: We discuss RigidBodies and Unity physics in more detail in [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing with Physics and Fire*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Select your Balloon object in Hierarchy
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, set its Transform Scale to (0.1, 0.1, 0.1)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to (0, 1, 1)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Add Component to add a Rigid Body
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Use Gravity checkbox
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My balloon object now has the following properties:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15b70c9b-e8c5-4068-8f0a-0c94473f641e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Make it a prefab as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Drag the balloon object into your `Prefabs/ `folder to make it a prefab object
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original balloon object from your Hierarchy
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay. Now let's play around with controller buttons.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: If you ever want to modify a prefab, drag an instance of it back into the scene.
    Make the changes you want. Then, use the Apply button to save the changes back
    onto the prefab of the object. Delete the temporary instance from the Hierarchy
    if it's no longer needed in the scene.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Basic button input
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity includes a standard Input Manager for accessing traditional game controller,
    keyboard, mouse, and mobile touchscreen input. This can include specific button
    presses, joystick axes, and the device accelerometer, for example. It also supports
    input from VR and AR systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The Input Manager provides an abstraction layer over the physical input devices.
    For example, you can reference logical inputs, such as the `Fire1` button, which
    is mapped to a physical button. The mappings for your project can be set up and
    modified in Edit | Project Settings | Input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: For a general overview and details of Unity Input Manager, see [https://docs.unity3d.com/Manual/ConventionalGameInput.html](https://docs.unity3d.com/Manual/ConventionalGameInput.html). 
    For scripting the Input class, see [https://docs.unity3d.com/ScriptReference/Input.html](https://docs.unity3d.com/ScriptReference/Input.html).
    Input mapping for various VR devices can be found at [https://docs.unity3d.com/Manual/vr-input.html](https://docs.unity3d.com/Manual/vr-input.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look. To start, we will write a test script to get a specific button
    state and see how the Unity Input class works. A common logical button is the
    one named "Fire1." Let's see which button your input device uses for "Fire1."
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Using the Fire1 button
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now write a script, `MyInputController`, to detect when your user has
    pressed the `Fire1` button. Add the script to your `MeMyselfEye` object as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select the MyMyselfEye object
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, click Add Component, then New Script
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `MyInputController` and press Create And Add
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `MyInputController` script to open it for editing
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this script, in each frame Update, we call a private function, `ButtonTest`.
    This function builds a message string named `msg` that reports whether the `Fire1`
    button has just been pressed down or released. The call to `Input.GetButtonDown("Fire1")`,
    for example, will return a Boolean (true or false) value, which we check in the
    `if` statement. When either of these situations are true, the `msg` string is
    not empty (null) and gets printed to the Unity Console window:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Press Play in the Unity editor to run the scene
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you press the Fire1 button on your input controller, you will see the
    Input: Fire1 down message as output'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you release the Fire1 button, you will see the Input: Fire1 up message,
    as shown here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28bb4769-3388-4884-b766-d1a4741302e1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: You can use even use this script to identify which physical button on your input
    controller maps to the logical `Fire1` button. Using OpenVR, for example, `Fire1`
    is triggered with the menu button on a Vive controller or the **B** button on
    the Oculus Touch controller ("Button.Two") as shown on the Unity Input System
    Mappings section in the Input for OpenVR Controllers page of the Unity manual 
    ([https://docs.unity3d.com/Manual/OpenVRControllers.html](https://docs.unity3d.com/Manual/OpenVRControllers.html)).
    Feel free to experiment with using other logical input names, and/or modifying
    the mappings using the Input project settings (Edit | Project Settings | Input).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using Unity logical inputs, it is also common to access the device
    directly through SDK components. Let's look into that in the  next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: OpenVR trigger button
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a VR device supported by OpenVR (HTC Vive, Oculus Rift, or Windows
    MR), let's modify the `ButtonTest` function to check for a pull and release of
    the trigger button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we need to provide our script with the specific input component
    that we want to query. In OpenVR, this is represented by the `SteamVR_TrackedObject`
    component, as shown in the following variation of our script:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After saving this script, we need to populate the `rightHand` variable:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, select MeMyselfEye so you can see the My Input Controller in the Inspector
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, unfold the [CameraRig] object
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Controller (Right) child object and drag it onto the My Input Controller's
    Right Hand slot in the Inspector
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given the `rightHand` object, we reference its `SteamVR_TrackedObject` component
    directly. In the `ButtonTest` function, we get the *device* data using the right
    hand's device ID (`rightHand.index`), and check specifically for the trigger press
    status. As a bonus, I've shown you how to also provide a haptic buzz pulse on
    the device when the trigger is pressed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Now when you press Play, pulling the controller trigger will be recognized.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Using the SDK components like this, you can access other inputs specific to
    the device not supported by the Unity Input Manager. The trigger on some controllers
    are not just pressed/unpressed but can return a percentage of press, represented
    as a value between 0.0 and 1.0\. Another example is the touch-sensitive grips,
    buttons, and thumb pad on the Oculus Touch controllers and other controllers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Try modifying the script to recognize the controller `Grip` button instead,
    or other inputs. Hint: try *SteamVR_Controller.ButtonMask.**Grip*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Daydream controller clicks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Daydream VR on Android may not respond, by default, to `Fire1` events.
    The following code shows how to access controller clicks directly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we call the `GvrControllerInput` class static functions `ClickButtonDown`
    and `ClickButtonUp`. There is no need to identify a specific controller object
    because `GvrControllerInput` is a *singleton*. That is why we're guaranteed to
    have only one instance of it in the scene, so we can reference its data directly.
    This makes sense because on Daydream there will only be one hand controller, whereas
    on OpenVR there will be two.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Polling for clicks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to obtain user input is just *get* the current data from an
    input component. We''ve already seen this using the Input class and VR SDK. Presently,
    we will write our own input component that maps the Unity (or SDK) input to our
    own simple API in `MyInputController`. Then, we''ll write a `BalloonController`
    that polls the input, as illustrated:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65788305-5dad-48b6-aba4-387704e3ee6e.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Our own button interface functions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that the `MeMyselfEye` player rig may have device-specific toolkit
    child objects for a particular VR SDK. The version for OpenVR, for example, has
    their [CameraRig] prefab. The version for Daydream has the Daydream Player prefab.
    It makes sense to add our `MyInputController` component to `MeMyselfEye`, as it
    may make device-specific SDK calls. In this way, should you want to maintain camera
    rig prefabs for a variety of platforms, and swap them in and out as you build
    the project for a different VR target, the API that is exposed to the rest of
    your application will be consistent and independent of the specific device toolkit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Our input controller will expose two custom API Functions, `ButtonDown `and `ButtonUp`.
    The implementation of these functions will be hidden from the components that
    call them. For example, we could write it to handle `Fire1` button presses as
    first but later change it to use a trigger press instead, or make a version for
    Daydream that does not use `Fire1`. Let''s update the `MyInputController` by adding
    the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or you can modify the preceding code to use the button interface that works
    for you. For example, for Daydream you might use this instead:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we'll use our little `ButtonUp`/`ButtonDown` input API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Creating and releasing balloons
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create a `BalloonController` that will be the application component
    that creates and controls balloons. It will reference our `MyInputController`.
    Follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create an empty game object, reset its Transform, and name it
    `BalloonController`
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new script on the object named `BalloonController` and open it for
    editing as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the skeleton of the controller. Given a reference to the `MeMyselfEye`
    object, the `Start()` function gets its `MyInputController` component and assigns
    it to the `inputController `variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`Update()` is called each frame while your game is running. It will call `inputController.ButtonDown`
    or `ButtonUp` to see if the user has changed their input, and in response, either
    create or release a balloon. We''ll write the functions next.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've also included a placeholder (as a comment) where we'll add the
    `GrowBalloon` function too.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the balloon prefab, the `BalloonController` can create new instances
    of it in our scene, by calling the Unity `Instantiate` function. Add the following
    `public` variable declaration at the top of your controller class for the balloon
    prefab:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add a `private` variable to hold the current instance of the balloon:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the `NewBalloon` function, which is called when the player presses the
    button, references the prefab and instantiates it as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `ReleaseBalloon` function is called when the player releases the button.
    It will apply a gentle upward force on the balloon so it floats skyward. We''ll
    define a floatStrength variable and apply it to the object''s RigidBody (the Unity
    physics engine and RigidBodies are explained in a later chapter):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we also clear the balloon variable (setting it to null), getting
    it ready for the next button press.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and in Unity:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Drag the MeMyselfEye object from Hierarchy onto the BalloonController's Me Myself
    Eye slot in Inspector
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Ballon prefab from the Project's `Assets` folder onto the BalloonController's
    Balloon Prefab slot in Inspector
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''re ready, press Play. Inside VR, when you press the `Fire1` button
    (or whichever you programmed), a new balloon is instantiated. When you release
    it, the balloon floats upwards. In the following game window, I have pressed the
    button multiple times in succession, creating a series of balloons:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db562021-0983-467f-ad46-ad884fc34a20.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Hierarchy of the same game state, showing the cloned balloons in
    the Hierarchy (my prefab''s name is `Balloon-poly`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afc206b2-54f7-4659-aa3e-e565dfb26bce.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Inflating a balloon while pressed
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we want to do is inflate the balloon while you''re still holding
    the button. We can do this by checking whether there''s a current balloon instance
    from a button press, and modifying its scale each update by a specified grow rate.
    Let''s define that first, to grow by 150% each second the button is held down
    (1.5 times):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, modify the Update function with a third `else if` condition as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And add the `GrowBalloon` function like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `GrowBalloon` function will modify the balloon's local scale by a percentage
    of its current size. `growRate` is the rate of growth per second. So, we multiply
    that by the current fraction of a second in this frame (`Time.deltaTime`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Press Play in Unity. When you press the controller button, you'll create a balloon,
    which continues to inflate until you release the button. Then the balloon floats
    up. Wow, that's actually pretty fun!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to refactor our code to use a different software pattern for
    getting user input, using scriptable objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: No one writes code without expecting to change it. Programming is a dynamic
    art as you rethink how to do things, as requirements grow, and problems get fixed.
    Sometimes, these changes are not necessarily to add a new feature or fix a bug
    but to make the code cleaner, easier to use, and easier to maintain. This is called
    **refactoring**, when you change or rewrite parts of a program but do not necessarily
    change how the feature works from the player's perspective.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Using scriptable objects for input
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will further decouple our application from the underlying
    input device using a technique called **scriptable** **objects****.** These are
    data objects used for holding information such as game state, player preferences,
    or any other data that is not necessarily graphical. Scriptable objects are instantiated
    during runtime, much like MonoBehaviour ones, but do not live in the Hierarchy,
    have no Transform, nor other physics and rendering behaviors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: It's useful to think of scriptable objects as *data containers* in your projects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous implementation, `BalloonController` requires a reference to
    the `MeMyselfEye` object to use its `MyInputController` component. Although the
    input controller component does separate you from the underlying SDK calls, if
    you modify your application to use a different `MeMyselfEye` (for example, from
    OpenVR to Daydream), you will need to find and replace all references to one `MeMyselfEye`
    in the scene and replace them with the new one. Here''s will have the input controller
    populate a scriptable object, and then our `BalloonController` reference that
    object for the data, as illustrated here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec4cf25f-0253-44ae-ac25-a67e3a53c83e.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: The process of implementing scriptable objects is a little more involved than
    game objects with components. But not much. Let's go!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind this is just one example how to use scriptable objects and serves
    as an introduction to this powerful design pattern in Unity. For more information,
    see the Unity Tutorial *Introduction to* s*criptable* obj*ects* at [https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects](https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects). Also,
    see [Chapter 9](232442fa-b5ba-4e11-9734-905b243e34a5.xhtml), Exploring Interactive
    Spaces, for another example of scriptable objects for data management in a project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scriptable object
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, our object will just have one variable, for the current button
    action. We''ll say the button can have one of three possible values: `PressedDown`,
    `ReleasedUp`, or `None`. We''ll define the action as having occurred current during
    the current `Update`, then it''s cleared to `None`. That is, rather than record
    the current button state (for example, is pressed), we are capturing the current
    button action (was just pressed), to be consistent with other examples in this
    chapter.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s useful to keep scriptable objects in their own folder in the Project
    `Assets`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** window, create a new folder under *Assets* named `ScriptableObjects`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new folder, right-click and select Create | C# Script
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the script `MyInputAction`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open the `MyInputAction.cs` script for editing
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `MyInputAction.cs` script as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rather than inheriting from `MonoBehaviour`, we will define the class as a `ScriptableObject`.
    We represent the action using an enum to restrict its possible values to the selection
    list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '"The **enum** keyword is used to declare an enumeration, a distinct type that
    consists of a set of named constants called the enumerator list." - [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the first line of the preceding script. We provide a *property attribute*
    which generates a menu item in the Unity Editor for our object. Since scriptable
    objects are not added to the scene Hierarchy, we need a way to create them in
    the project. Using this attribute makes it easy, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and return to Unity.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Unity editor main menu, navigate to Assets | Create.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a new item, My Objects, with a submenu with an item Input Action,
    as directed in the `CreateAssetsMenu` property attribute in our script. The menu
    is shown next.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Input Action to create an instance. By default, it will be created in
    the currently selected Project Assets folder. So if you have the `ScriptableObjects`
    folder open, it will be created there.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the object `My Input Action Data`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6eb1b9b9-4382-4b39-9893-091da7609977.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'If you select the new `My Input Action Data` object in your `ScriptableObjects/`
    folder, you can see its properties in the Inspector. In the following screen capture,
    I have clicked the **Button Action** drop-down list to reveal the possible enum
    values we''ve specified in our code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f2f8d3f-50fa-435a-b1fa-ec685effef86.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Populating the input action object
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to change `MyInputController.cs` to populate the input data
    object, using a reference to the object, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The script uses its own `ButtonDown` and `ButtonUp` functions to set the `buttonAction`
    as appropriate. These could even be changed from *public* to *private* to further
    encapsulate it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script. Then in Unity:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Select **MeMyselfEye** object in Hierarchy
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the My Input Action Data object in your `ScriptableObjects` folder
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag it onto the My Input slot of the My Input Controller (Script) component,
    as shown here for my Steam version of `MeMyselfEye`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15e864f6-a58f-4dbf-8412-4b55731d4b69.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Accessing the input action object
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the `BalloonController` can access the input data object rather than `MeMyselfEye`.
    Otherwise is very similar and a simple refactor. Modify `BalloonController.cs`
    as follows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: First, we can remove any references to `MeMyselfEye` in the `BalloonController`,
    including the public variable and the entire `Start()` function (we do not need
    the `GetComponent<MyInputController>`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a variable for the input data object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And reference it in the `Update` conditions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save the script. Then in Unity, as we did previously for `MyInputController`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Select the BalloonController object in Hierarchy
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the My Input Action Data object in your `ScriptableObjects` folder
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it onto the My Input slot of the Balloon Controller component
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Play**. The app should work just like before. Press the button to create
    a balloon, hold the button to inflate it, and release the button to release the
    balloon.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Simulation testing with scriptable objects
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting advantage of this architecture is how it facilitates testing.
    Having completely decoupled our application objects from the input device, we
    can simulate input actions without actually using physical input controllers.
    For example, try this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Select MeMyselfEye in Hierarchy. Then in Inspector, temporarily disable the
    **My Input Controller** component by unchecking its checkbox.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the My Input Action Data object in the Project `ScriptableObjects/` folder
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Play.**
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the game is running, in Inspector, change the Button Action from None
    to PressedDown.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The BalloonController thinks a PressedDown action has occurred. It creates a
    new balloon and begins inflating it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, change the Input Action to PressedUp.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The BalloonController sees a **PressedUp** action has occurred and releases
    the current balloon.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you're done testing, don't forget to re-enable the input controller component!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: This kind of manual setup of object states for development and testing can be
    very helpful, especially as your project grows and gets more complex.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity events for input
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third software pattern we will explore using Unity Events. Events allow
    decoupling of the source of the event from the consumer of the event. Basically,
    events are a messaging system where one object triggers an event. Any other objects
    in the project can listen for the event. It can subscribe a specific function
    to be called when the event occurs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You can set this up using drag-and-drop via the Unity Inspector. Or you can
    subscribe listener functions in scripts. In this example, we will minimize the
    scripting involved, and use the Unity editor to subscribe to events.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Events are a very rich topic and we can only introduce them here. For more information
    on using Unity Events, there are a lot of good references online, including the
    Unity tutorials [https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events) and [https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system](https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the relationship between our input controller,
    which invokes events, and the balloon controller, which subscribes to the events:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7ee0d95-05b4-4178-9d2a-f2c8f77d113f.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: It's important to note that, unlike normal events, these events do not need
    to be unsubscribed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If you are a developer and familiar with .NET, it may help to know that Unity
    Events are delegates. As explained in the Unity Manual, "UnityEvents can be added
    to any MonoBehaviour and are executed from code like a standard .net delegate.
    When a UnityEvent is added to a MonoBehaviour it appears in the Inspector and
    persistent callbacks can be added."
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Invoking our input action events
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement our example using events, we'll first have the `MyInputController`
    trigger events when a button is pressed and another event when the button is released.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: First, at the top of the script we need to declare that we are using the Unity
    event API. The we declare the two UnityEvents we will invoke. The `Update()` function
    only needs to invoke one event or the other as they happen.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire `MyInputController.cs` is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's it for this side of the equation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to input events
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using events, `BalloonController` does not need to check for input actions each
    frame Update. All that conditional logic can be bypassed. Instead, we'll drag
    and drop the components to subscribe them to events. The `Update` function now
    only needs to grow the balloon if it's already instantiated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire `BalloonController.cs` now looks like this. Aside from being less
    code, please note that we changed the `NewBalloon` and `ReleaseBalloon` functions
    from `private` to `public` so we can reference them in the Inspector:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To wire up the input events to our balloon controller:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Select MeMyselfEye and look at its Inspector window
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see the My Input Controller component now has two event lists, as we
    declared in its script
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Button Down Event list, press the + in the lower-right to create a new
    item.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the BalloonController from Hierarchy into the empty Object slot
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function select list, choose **BalloonController** | **NewBalloon**
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the process for the Button Up Event as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: On the Button Up Event list, press the + in the lower-right to create a new
    item
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the BalloonController from Hierarchy into the empty Object slot
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function select list, choose **BalloonController** | **ReleaseBalloon**
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The component should now look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58469bd5-2930-4ff0-9177-4f6d833f1acb.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Now when you press Play and press a button, the input controller invokes an
    event. The *NewBalloon* function is listening for these events and gets called.
    Likewise for the Button Up event.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This wiring can also be done entirely with scripting. We will not go into it
    here. As a developer, we more often are "users" of event systems set up by others.
    As your experience grows, you may find yourself implementing your own custom events.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: For another detailed example of using Unity Events for user interface, consider
    *Augmented Reality for Developers*, a Unity projects book from Packt Publishing
    co-authored by the author of this book, Jonathan Linowes, and Krystian Babilinski.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Really using your hands
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last couple of things we'll explore in the chapter involve getting your
    hands even more into virtual reality. In addition to buttons and touch pads, VR
    hand controllers can be tracked in 3D space along with your head. PC- and console-based
    VR, such as Rift, Vive, MR, and PSVR, are really very good at this, with full
    positionally tracked hand controllers for both left and right hands. Lower-end
    mobile VR, such as Daydream, has a single hand controller with limited tracking,
    but better than nothing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: To start, we'll take advantage of positional tracking by simply parenting the
    balloon to your hand model. On VR, without actual positional tracking, like Daydream,
    the location of your hand controller is approximated by the SDK software, but
    useful enough.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Parenting balloons to your hand
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose when you press the button, rather than creating the new balloon at a
    fixed position in space, it spawns and grows from your hand position. One way
    to accomplish this is to make the balloon instance a child of your hand controller
    object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The BalloonController will need to know which hand pressed the button and parent
    the balloon to that controller object. Specifically, we''ll pass the hand Game
    Object to the `NewBalloon` function as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that in this function we added an extra test for (`balloon == null`), just
    to make sure we haven't called `NewBalloon` twice in a row without releasing the
    first one yet.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Like before, we instantiate a new balloon from the prefab.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set its parent to the `parentHand` object. This is comparable to dragging
    one object to become a child of another in the Hierarchy. The parent-child relationships
    between game objects are handled by the built-in *Transform* component so the
    API functions are on the transform.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we reset the local position of the balloon. If you recall, the prefab
    was positioned at (0, 1, 1) or something like that. As a child of the hand, we
    want it attached directly at the pivot point of the hand model. (Alternatively,
    you could offset the balloon origin to a different attachment point as needed.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Worth noting, there are variations of the *Instantiate* function that let you
    specify the parent and transforms all in one call. See [https://docs.unity3d.com/ScriptReference/Object.Instantiate.html](https://docs.unity3d.com/ScriptReference/Object.Instantiate.html) .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the `ReleaseBalloon` detaches the balloon from the hand before send
    it on its way, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'How do we pass the hand game object to NewBalloon? Assuming your project is
    presently using the Unity Events we setup in the previous topic, it''s very easy. In
    Inspector we need to update the Button Down Event function, since it now requires
    the game object argument:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In Unity editor, select the MeMyselfEye object
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Button Down Event list, the function may now say something like `Missing
    BalloonController.NewBalloon`
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the function dropdown and choose BalloonController | NewBalloon(GameObject)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the MeMyselfEye object in Hierarchy and look for the hand model, then
    drag it onto the empty Game Object slot
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using OpenVR, the hand will be called Controller (right)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Daydream, the hand will be called GvrControllerPointer
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a screenshot of me generating a bunch of balloons flying "over" the
    Grand Canyon, fun!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a1140e8-35eb-42ae-b30f-556bc0639af3.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Popping balloons
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be honest, it's really hard to think about creating balloons without also
    wanting to pop them! For fun, let's do a quick implementation. You can come up
    with your own ideas how to improve on it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity physics engine can detect when two object collide. To do this, each
    object must have a *Collider* component attached. You can then have the collision
    trigger an event. And we can subscribe that event to make something else happen,
    like play an explosion effect. This gets set up on the balloon prefab. So when
    two balloons collide, they''ll explode. Let''s do that:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of your Balloon prefab from Project `Assets prefabs` folder into
    the scene Hierarchy**.**
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | Physics | Sphere Collider.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To scale and center the collider into position, click the Edit Collider icon
    in its component.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Scene** window, the green collider outline has small anchor points
    you can click to edit. Note that the *Alt* key pins the center position and *Shift*
    locks the scale ratio.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Or, you can edit the **Center** and Radius values directly. I like Radius 0.25
    and Center (0, 0.25, 0) on my balloon.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will add a script to handle the collision events.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Add Component to create a new C# script,
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Poppable`
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And open it for editing
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Poppable` script will provide a callback function for `OnCollisionEnter`
    events. When another object with a collider enters this object''s collider, our
    function will get called. At that point, we''ll call `PopBalloon` which instantiates
    the explosion and destroys the balloon:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that the `OnCollisionEnter` gets a `Collision` argument with information
    including what game object collided with it. We will ignore this here but you
    might explore it more: [https://docs.unity3d.com/ScriptReference/Collision.html](https://docs.unity3d.com/ScriptReference/Collision.html).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script. Now, back in Unity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Select a particle system prefab from **Project** Assets, such as `Assets/Standard
    Assets/ParticleSystems/Prefabs/Explosion` (this is the one we used to kill Ethan
    in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based Control*)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the effects prefab onto the Poppable's `Pop Effect` slot
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save these changes back to the prefab by pressing Apply
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now delete the **Balloon** from the Hierarchy
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alright, let's try it. Press Play. Create a balloon. Then, reach out and push
    the button again so a new balloon collides with that one. Does it explode? Yikes!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Interactable items
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directly interacting with objects in VR, such as grabbing items and using them
    to perform other actions, is a bit more complex. And, it can be tricky to get
    right. So it doesn't make sense, especially in this book, to grow our own interaction
    system. Unfortunately, there is not a single standard toolkit either. But, there
    are more than a few very good toolkits you can use, albeit most are specific to
    individual target platforms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the architecture is similar among these solutions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Provides prefabs for the player camera rig
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera rig includes objects for your hands, including input controller components
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hand objects include components that trigger events when interactions occur
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interactable component is added to any objects in the scene that can be interacted
    with using input events
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional components and options extend the interactable behaviors
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toolkits will include a number of demo scenes which provide rich examples how
    to use the particular toolkit. Often, it is more informative to study the demos
    to see how to use the toolkits than the actual documentation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduce a grabbing and throwing mechanic using two toolkits,
    the *SteamVR InteractionSystem* and the *Daydream VR Elements*. The technique
    is similar for other platforms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: For Oculus SDK (without OpenVR), you will need to integrate the Oculus Avatar
    SDK (see [Chapter 12](721ca227-9208-4342-b6ac-a12799adbb2b.xhtml), *Social VR
    Metaverse*, for details on Oculus Avatars). Also, here's a quick video showing
    how to add an `OVR Grabber` component to your `OVRCameraRig` controllers: [https://www.youtube.com/watch?v=sxvKGVDmYfY](https://www.youtube.com/watch?v=sxvKGVDmYfY).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Interactables using SteamVR Interaction System
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SteamVR Unity package includes an Interaction System, originally developed
    and used for minigames and scenes from Steam's impressive demo VR application,
    *The Lab* ([http://store.steampowered.com/app/450390/The_Lab/](http://store.steampowered.com/app/450390/The_Lab/)).
    It can be found in the `Assets/SteamVR/InteractionSystem/` folder. We recommend
    you explore the example scenes, prefabs, and scripts.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The Interaction System includes its own Player camera rig which replaces the
    default [CameraRig] we have been using. The Player hierarchy is shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eee0c315-01b3-405a-9a23-6b36fb920243.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: It includes a *VRCamera*, two hands (*Hand1* and *Hand2*), and other useful
    objects. Each hand includes an attach point (*Attach_ControllerTip*), a hover
    highlight (*ControllerHoverHighlight*), and a tooltips object (*ControllerButtonHints*).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Locate the **Player** prefab in `SteamVR/InteractionSystem/Core/Prefabs `and
    drag it as a child of MyMyselfEye in your scene Hierarchy
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or disable the [CameraRig] object
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For compatibility with the current scene, we also need to update the **NewBalloon**
    argument in **Button Down Event**:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Unfold the Player object in Hierarchy so you can see the Hand1 and Hand2 objects
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the MeMyselfEye in Hierarchy
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag Hand2 (or Hand1) from **Hierarchy** onto the GameObject argument slot in
    the Button Down Event on the My Input Controller component
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, for interactable objects there is a large collection of components available.
    Review the `SteamVR/InteractionSystem/Core/Scripts` folder contents. We will use
    the *Throwable* one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'First, lets try this on a basic Cube. Then, we''ll make the balloons grabbable
    and throwable too:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create a cube (Create | 3D Object | Cube).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale and position it within reaching distance of the Player. For example, Scale
    (0.3, 0.3, 0.3) and **Position** (-0.25, 1.3, -0.25) may work.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Cube selected, Add Component `Throwable` from the Interaction System.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice this will automatically add other required components, including the
    base Interactable and a RigidBody.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the RigidBody component, uncheck the Use Gravity checkbox, so it hangs in
    the air rather than falling to the ground when you play.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you press Play, reach out to the Cube so your controller penetrates
    (collides) it. Then, using the Trigger on your controller, grab the Cube and throw
    it *outta here*!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the balloons throwable, we modify the prefab:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of the Balloon prefab from the Project window into the scene Hierarchy
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component the Steam Throwable
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Apply** to save the prefab
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And delete the Balloon from the Hierarchy
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. Press the Fire1 button to create and inflate a balloon. Release
    it. Then, grab it with the trigger. Throw the balloon. If you implemented the
    *Poppable* explosion earlier, it'll even explode like a projectile when it hits
    something, like the ground or the photo plane!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Interactables using Daydream VR Elements
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The base GoogleVR package does not include interactables, but you can find
    them in the Daydream Elements package. This package is a collection of demo scenes,
    components, and prefabs for using Daydream VR from the engineers at Google. To
    get the package:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Visit the Daydream Elements' Github Releases page at [https://github.com/googlevr/daydream-elements/releases](https://github.com/googlevr/daydream-elements/releases)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download `DaydreamElements.unitypackage`
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import it into your project using **Assets** | **Import Package** | **Custom
    Package...**
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The package includes a prefab named `ObjectManipulationPointer` which is a
    drop-in replacement for the `GvrControllerPointer` we have been using:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, unfold your MeMyselfEye and drill down to the Player object
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select GvrControllerPointer and disable it in Inspector
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project window, navigate to the `Assets/DaydreamElements/Elements/ObjectManipulationDemo/Prefabs/UI/`
    folder
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the ObjectManipulationPointer prefab into Hierarchy as a sibling of GvrControllerPointer
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For compatibility with the current scene, we also need to update the NewBalloon argument
    in Button Down Event:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Select the MeMyselfEye in Hierarchy
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag ObjectManipulationPointer from Hierarchy onto the GameObject argument slot
    in the Button Down Event on the My Input Controller component
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, for interactable objects we add a `MoveablePhysicsObject` component, found
    in `Assets/DaydreamElements/Elements/ObjectManipulationDemo/Scripts/`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Additional information on Daydream Elements object manipulation can be found
    at [https://developers.google.com/vr/elements/object-manipulation](https://developers.google.com/vr/elements/object-manipulation).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'First, lets try this on a basic Cube. Then, we''ll make the balloons grabbable
    and throwable too:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create a cube (Create | 3D Object | Cube).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale and position it within reaching distance of the Player. For example, Scale (0.25,
    0.25, 0.25) and Position (-0.4, 0.75, -0.3) may work.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Cube selected, Add Component `MoveablePhysicsObject`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice this will automatically add a `RigidBody` component if not present.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `RigidBody` component, uncheck the Use Gravity checkbox, so it hangs
    in the air rather than falling to the ground when you play.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you press Play, use your controller so its laser beam hits the cube.
    Then, press the clicker button on your controller to grab it. Move it around and
    press again to release it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Since the app is presently using the same button to create new balloons and
    manipulate the laser pointer, we get a balloon each time we use the button. Consider
    that a bug in your application. We will leave this as an exercise for you to implement
    the logic, for example, to tell *MyInputController* to not invoke events if the
    *MoveablePhysicsObject* is busy moving something.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: you could add a script component to Cube that checks the MoveablePhysicsObject
    state and disables MyInputController actions when the object is Selected. This
    is not well documented but look at the source code for MoveablePhysicsObjects.cs
    and its base class, BaseInteractiveObjects.cs.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the balloons throwable, we modify the prefab:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of the Balloon prefab from the Project window into the scene Hierarchy
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Componen**t** the MoveablePhysicsObject
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Apply to save the prefab
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And delete the Balloon from Hierarchy
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. Press the button to create and inflate a balloon. Release it. Then,
    try to grab it with the laser pointer. If you implemented the *Poppable* explosion
    earlier, it'll even explode like a projectile when it hits something!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a variety of software patterns for handling user
    input for your VR projects. The player uses a controller button to create, inflate,
    and release balloons into the scene. First, we tried the standard Input class
    for detecting logical button clicks, like the "Fire1" button, and then learned
    how to access device-specific SDK input, such as the OpenVR trigger button with
    haptic feedback.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, we implemented a simple input component for polling the button
    actions. Then, we refactored the code to use scriptable objects to hold the input
    action data. In the third implementation, we used Unity Events to message input
    actions to listening components. We also enhanced the scene to attach the balloon
    to your virtual hand position, and added the ability to pop the balloons as  explosive
    projectiles! Lastly, we used an interactable framework (for SteamVR and Daydream)
    to implement grabbing and throwing mechanics, using components provided in given
    toolkits rather than attempting to write our own.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们实现了一个简单的输入组件来轮询按钮动作。然后，我们对代码进行了重构，使用可脚本化的对象来存储输入动作数据。在第三次实现中，我们使用了Unity事件将输入动作消息传递给监听组件。我们还增强了场景，将气球附着到你的虚拟手部位置，并添加了弹出气球作为爆炸性投射物的能力！最后，我们使用了一个交互框架（用于SteamVR和Daydream）来实现抓取和投掷机制，使用给定工具包中提供的组件，而不是尝试编写自己的代码。
- en: In the next chapter, we will further explore user interactions, using the Unity
    UI (user interface) system for implementing information canvases, buttons, and
    other UI controls.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨用户交互，使用Unity UI（用户界面）系统来实现信息画布、按钮和其他UI控件。
