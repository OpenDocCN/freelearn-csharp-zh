<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-81"><a id="_idTextAnchor082"/>6</h1>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/>Exploring Validation and Mapping</h1>
<p>In this chapter of the book, we will discuss how to perform data validation and mapping with minimal APIs, showing what features we currently have, what is missing, and what the most interesting alternatives are. Learning about these concepts will help us to develop more robust and maintainable applications.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Handling validation</li>
<li>Mapping data to and from APIs</li>
</ul>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Technical requirements</h1>
<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core 6.0 Web API application. Refer to the <em class="italic">Technical requirements</em> section in <a href="B17902_02.xhtml#_idTextAnchor023"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Minimal APIs and Their Advantages</em>, for instructions on how to do so.</p>
<p>If you’re using your console, shell, or bash terminal to create the API, remember to change your working directory to the current chapter number (<code>Chapter06</code>).</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06</a>.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>Handling validation</h1>
<p><code>Person</code> object has both the <code>FirstName</code> and <code>LastName</code> properties defined, an email address is valid, or an appointment date isn’t in the past.</p>
<p>In controller-based projects, we can perform these checks, also termed <code>ApiController</code> attribute <a id="_idIndexMarker301"/>that is placed on a controller makes model validation errors automatically trigger a <code>400 Bad Request</code> response if one or more validation rules fail. Therefore, in <a id="_idIndexMarker302"/>controller-based projects, we typically don’t need to perform explicit model validation at all: if the validation fails, our endpoint will never be invoked.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>ApiController</code> attribute enables <a id="_idIndexMarker303"/>the automatic model validation behavior using the <code>ModelStateInvalidFilter</code> action filter.</p>
<p>Unfortunately, minimal APIs do not provide built-in support for validation. The <code>IModelValidator</code> interface and all related objects cannot be used. Thus, we don’t have a <code>ModelState</code>; we can’t prevent the execution of our endpoint if there is a validation error and must explicitly return a <code>400 Bad Request</code> response.</p>
<p>So, for example, let’s see the following code:</p>
<pre class="source-code">
app.MapPost("/people", (Person person) =&gt;
{
    return Results.NoContent();
});
public class Person
{
    [Required]
    [MaxLength(30)]
    public string FirstName { get; set; }
    [Required]
    [MaxLength(30)]
    public string LastName { get; set; }
    [EmailAddress]
    [StringLength(100, MinimumLength = 6)]
    public string Email { get; set; }
}</pre>
<p>As we can see, the endpoint will be invoked even if the <code>Person</code> argument does not respect the validation rules. There is only one exception: if we use <code>400 Bad Request</code> response. As mentioned in <a href="B17902_02.xhtml#_idTextAnchor023"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Minimal APIs and Their Advantages</em>, nullable reference types are enabled by default in .NET 6.0 projects. </p>
<p>If we want to accept a <code>null</code> body (if ever there was a need), we need to declare the parameter as <code>Person?</code>. But, as long as there is a body, the endpoint will always be invoked.</p>
<p>So, with minimal APIs, it is necessary to perform validation inside each route handler and return the appropriate <a id="_idIndexMarker305"/>response if some rules fail. We can either implement a validation library compatible with the existing attributes so that we can perform validation using the classic data annotations approach, as described in the next section, or use a third-party solution such as <code>FluentValidation</code>, as we will see in the <em class="italic">Integrating FluentValidation</em> section.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Performing validation with data annotations</h2>
<p>If we want to use the <a id="_idIndexMarker306"/>common validation pattern <a id="_idIndexMarker307"/>based on data annotations, we need to rely on <code>IsValid</code> methods, which are provided by the <code>ValidationAttribute</code> base class. </p>
<p>This behavior is a simplification of what ASP.NET Core actually does to handle validations. However, this is the way validation in controller-based projects works.</p>
<p>While we <a id="_idIndexMarker309"/>can also manually implement <a id="_idIndexMarker310"/>a solution of this kind with minimal APIs, if we decide to use data annotations for validation, we can leverage a small <a id="_idIndexMarker311"/>but interesting library, <code>MiniValidation</code>, which <a id="_idIndexMarker312"/>is available on GitHub (<a href="https://github.com/DamianEdwards/MiniValidation">https://github.com/DamianEdwards/MiniValidation</a>) and NuGet (<a href="https://www.nuget.org/packages/MiniValidation">https://www.nuget.org/packages/MiniValidation</a>).</p>
<p class="callout-heading">Important note</p>
<p class="callout">At the time of writing, <code>MiniValidation</code> is available on NuGet as a prerelease.</p>
<p>We can add this library to our project in one of the following ways:</p>
<ul>
<li><code>MiniValidation</code>. Be sure to check the <strong class="bold">Include prerelease</strong> option and click <strong class="bold">Install</strong>.</li>
<li><strong class="bold">Option 2</strong>: Open the <strong class="bold">Package Manager Console</strong> if you’re inside Visual Studio 2022, or open your console, shell, or bash terminal, go to your project directory, and execute the following command:<pre><strong class="bold">dotnet add package MiniValidation --prerelease</strong></pre></li>
</ul>
<p>Now, we can validate a <code>Person</code> object using the following code:</p>
<pre class="source-code">
app.MapPost("/people", (Person person) =&gt;
{
    var isValid = MiniValidator.TryValidate(person, 
      out var errors);
    if (!isValid)
    {
        return Results.ValidationProblem(errors);
    }
    return Results.NoContent();
});</pre>
<p>As we can see, the <code>MiniValidator.TryValidate</code> static method provided by <code>MiniValidation</code> takes an object as input and automatically verifies all the validation rules that <a id="_idIndexMarker313"/>are defined on its properties. If <a id="_idIndexMarker314"/>the validation fails, it returns <code>false</code> and populates the <code>out</code> parameter with all the validation errors that have occurred. In this case, because it is our responsibility to return the appropriate response code, we use <code>Results.ValidationProblem</code>, which produces a <code>400 Bad Request</code> response with a <code>ProblemDetails</code> object (as described in <a href="B17902_03.xhtml#_idTextAnchor038"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Minimal APIs</em>) and also contains the validation issues.</p>
<p>Now, as an example, we can invoke the endpoint using the following invalid input:</p>
<pre class="source-code">
{
  "lastName": "MyLastName",
  "email": "email"
}</pre>
<p>This is the response we will obtain:</p>
<pre class="source-code">
{
  "type": 
    "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "FirstName": [
      "The FirstName field is required."
    ],
    "Email": [
      "The Email field is not a valid e-mail address.",
      "The field Email must be a string with a minimum
       length of 6 and a maximum length of 100."
    ]
  }
}</pre>
<p>In this way, besides the fact that we need to execute validation manually, we can implement <a id="_idIndexMarker315"/>the approach of using data annotations <a id="_idIndexMarker316"/>on our models in the same way we were accustomed to in previous versions of ASP.NET Core. We can also customize error messages and define custom rules by creating classes that inherit from <code>ValidationAttribute</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The full list of validation attributes <a id="_idIndexMarker317"/>available in ASP.NET Core 6.0 is published at <a href="https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations">https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations</a>. If you’re <a id="_idIndexMarker318"/>interested in creating custom attributes, you can refer to <a href="https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes">https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes</a>.</p>
<p>Although data annotations are the most used solution, we can also handle validations using a so-called fluent approach, which has the benefit of completely decoupling validation rules from the model, as we’ll see in the next section.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>Integrating FluentValidation</h2>
<p>In every application, it is important to correctly organize our code. This is also true for validation. While <a id="_idIndexMarker319"/>data annotations are a working solution, we should think about alternatives that can help us write more maintainable projects. This is the purpose of <code>FluentValidation</code> – a library, part of the <strong class="bold">.NET Foundation</strong>, that allows <a id="_idIndexMarker320"/>us to build validation rules using a fluent interface <a id="_idIndexMarker321"/>with lambda expressions. The library is available on GitHub (<a href="https://github.com/FluentValidation/FluentValidation">https://github.com/FluentValidation/FluentValidation</a>) and NuGet (<a href="https://www.nuget.org/packages/FluentValidation">https://www.nuget.org/packages/FluentValidation</a>). This library can be used in any <a id="_idIndexMarker322"/>kind of project, but when working with ASP.NET Core, there is an ad-hoc NuGet package (<a href="https://www.nuget.org/packages/FluentValidation.AspNetCore">https://www.nuget.org/packages/FluentValidation.AspNetCore</a>) that contains useful methods that help to integrate it.</p>
<p class="callout-heading">Note</p>
<p class="callout">.NET Foundation is an independent organization that aims to support open source software development <a id="_idIndexMarker323"/>and collaboration around the .NET platform. You <a id="_idIndexMarker324"/>can learn more at <a href="https://dotnetfoundation.org">https://dotnetfoundation.org</a>.</p>
<p>As stated before, with this library, we can decouple validation rules from the model to create a more structured application. Moreover, <code>FluentValidation</code> allows us to define even more complex rules with a fluent syntax without the need to create custom classes based on <code>ValidationAttribute</code>. The library also natively supports the localization of standard error messages.</p>
<p>So, let’s see how we <a id="_idIndexMarker325"/>can integrate <code>FluentValidation</code> into a minimal API project. First, we need to add this library to our project in one of the following ways:</p>
<ul>
<li><code>FluentValidation.DependencyInjectionExtensions</code> and click <strong class="bold">Install</strong>.</li>
<li><strong class="bold">Option 2</strong>: Open <strong class="bold">Package Manager Console</strong> if you’re inside Visual Studio 2022, or open your console, shell, or bash terminal, go to your project directory, and execute the following command:<pre><strong class="bold">dotnet add package FluentValidation.DependencyInjectionExtensions</strong></pre></li>
</ul>
<p>Now, we can rewrite the validation rules for the <code>Person</code> object and put them in a <code>PersonValidator</code> class:</p>
<pre class="source-code">
public class PersonValidator : AbstractValidator&lt;Person&gt;
{
    public PersonValidator() 
    {
        RuleFor(p =&gt;
          p.FirstName).NotEmpty().MaximumLength(30);
        RuleFor(p =&gt; 
          p.LastName).NotEmpty().MaximumLength(30);
        RuleFor(p =&gt; p.Email).EmailAddress().Length(6,
          100);
    }
}</pre>
<p><code>PersonValidator</code> inherits from <code>AbstractValidator&lt;T&gt;</code>, a base class provided by <code>FluentValidation</code> that contains all the methods we need to define the validation rules. For example, we <em class="italic">fluently</em> say that we have a rule for the <code>FirstName</code> property, which <a id="_idIndexMarker326"/>is that it must not be empty and it can have a maximum length of <code>30</code> characters.</p>
<p>The next step is to register the validator in the service provider so that we can use it in our route handlers. We can perform this task with a simple instruction:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
//...
builder.Services.AddValidatorsFromAssemblyContaining&lt;Program&gt;();</pre>
<p>The <code>AddValidatorsFromAssemblyContaining</code> method automatically registers all the validators derived from <code>AbstractValidator</code> within the assembly containing the specified type. In particular, this method registers the validators and makes them accessible through dependency injection via the <code>IValidator&lt;T&gt;</code> interface, which in turn, is implemented by the <code>AbstractValidator&lt;T&gt;</code> class. If we have multiple validators, we can register them all with this single instruction. We can also easily put our validators in external assemblies.</p>
<p>Now that <a id="_idIndexMarker327"/>everything is in place, remembering that with minimal APIs we don’t have automatic model validation, we must update our route handler in this way:</p>
<pre class="source-code">
app.MapPost("/people", async (Person person, IValidator&lt;Person&gt; validator) =&gt;
{
    var validationResult = 
      await validator.ValidateAsync(person);
    if (!validationResult.IsValid)
    {
        var errors = validationResult.ToDictionary();
        return Results.ValidationProblem(errors);
    }
    return Results.NoContent();
});</pre>
<p>We have added an <code>IValidator&lt;Person&gt;</code> argument in the route handler parameter list, so now we can invoke its <code>ValidateAsync</code> method to apply the validation rules against the input <code>Person</code> object. If the validation fails, we extract all the error messages and return them to the client with the usual <code>Results.ValidationProblem</code> method, as described in the previous section.</p>
<p>In conclusion, let’s see what happens if we try to invoke the endpoint using the following input as before:</p>
<pre class="source-code">
{
  "lastName": "MyLastName",
  "email": "email"
}</pre>
<p>We’ll get the following response:</p>
<pre class="source-code">
{
  "type": 
    "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "FirstName": [
      "'First Name' non può essere vuoto."
    ],
    "Email": [
      "'Email' non è un indirizzo email valido.",
      "'Email' deve essere lungo tra i 6 e 100 caratteri.
        Hai inserito 5 caratteri."
    ]
  }
}</pre>
<p>As mentioned <a id="_idIndexMarker328"/>earlier, <code>FluentValidation</code> provides translations for standard error messages, so this is the response you get when running on an Italian system. Of course, we can completely customize the messages with the typical fluent approach, using the <code>WithMessage</code> method chained to the validation methods defined in the validator. For example, see the following:</p>
<pre class="source-code">
RuleFor(p =&gt; p.FirstName).NotEmpty().WithMessage("You must provide the first name");</pre>
<p>We’ll talk about localization in further detail in <a href="B17902_09.xhtml#_idTextAnchor125"><em class="italic">Chapter 9</em></a>, <em class="italic">Leveraging Globalization and Localization</em>.</p>
<p>This is just a quick example of how to define validation rules with <code>FluentValidation</code> and use <a id="_idIndexMarker329"/>them with minimal APIs. This library allows many more complex scenarios that are comprehensively described in the official documentation available at <a href="https://fluentvalidation.net">https://fluentvalidation.net</a>.</p>
<p>Now that we have seen how to add validation to our route handlers, it is important to understand how we can update the documentation created by <strong class="bold">Swagger</strong> with this information.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>Adding validation information to Swagger</h2>
<p>Regardless of the <a id="_idIndexMarker330"/>solution that has been chosen <a id="_idIndexMarker331"/>to handle validation, it is important to update the OpenAPI definition with the indication that a handler can produce a validation problem response, calling the <code>ProducesValidationProblem</code> method after the endpoint declaration:</p>
<pre class="source-code">
app.MapPost("/people", (Person person) =&gt;
{
    //...
})
.Produces(StatusCodes.Status204NoContent)
.ProducesValidationProblem();</pre>
<p>In this way, a new response type for the <code>400 Bad Request</code> status code will be added to Swagger, as we can see in <em class="italic">Figure 6.1</em>:</p>
<div><div><img alt="Figure 6.1 – The validation problem response added to Swagger " height="668" src="img/Figure_6.1_B17902.jpg" width="429"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The validation problem response added to Swagger</p>
<p>Moreover, the <strong class="bold">JSON schemas</strong> that are <a id="_idIndexMarker332"/>shown at the bottom of the Swagger UI can show the rules <a id="_idIndexMarker333"/>of the corresponding models. One of the <a id="_idIndexMarker334"/>benefits of defining validation rules using data annotations is that they are automatically reflected in these schemas:</p>
<div><div><img alt="Figure 6.2 – The validation rules for the Person object in Swagger " height="406" src="img/Figure_6.2_B17902.jpg" width="365"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The validation rules for the Person object in Swagger</p>
<p>Unfortunately, validation rules defined with <code>FluentValidation</code> aren’t automatically <a id="_idIndexMarker335"/>shown in the JSON schema <a id="_idIndexMarker336"/>of Swagger. We can overcome this limitation by using <code>MicroElements.Swashbuckle.FluentValidation</code>, a small library <a id="_idIndexMarker337"/>that, as usual, is available on GitHub (<a href="https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation">https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation</a>) and NuGet (<a href="https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation">https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation</a>). After adding it to our project, following the same steps described before for the other NuGet packages we have introduced, we just need to call the <code>AddFluentValidationRulesToSwagger</code> extension method:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
//...
builder.Services.AddFluentValidationRulesToSwagger();</pre>
<p>In this way, the JSON schema shown in Swagger will reflect the validation rules, as with the data <a id="_idIndexMarker338"/>annotations. However, it’s worth <a id="_idIndexMarker339"/>remembering that, at the time of writing, this library does not support all the validators available in <code>FluentValidation</code>. For more information, we can refer to the GitHub page of the library.</p>
<p>This ends our overview of validation in minimal APIs. In the next section, we’ll analyze another important theme of every API: how to correctly handle the ma<a id="_idTextAnchor089"/>pping of data to and from our services.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor090"/>Mapping data to and from APIs</h1>
<p>When dealing with APIs that can be called by any system, there is one golden rule: <em class="italic">we should never expose our internal objects to the callers</em>. If we don’t follow this decoupling idea <a id="_idIndexMarker340"/>and, for some reason, need to change our internal data <a id="_idIndexMarker341"/>structures, we could end up breaking all the clients that <a id="_idIndexMarker342"/>interact with us. Both the internal data structures and the objects <a id="_idIndexMarker343"/>that are used to dialog with the clients must be able to evolve independently from one another.</p>
<p>This requirement for dialog is the reason why <strong class="bold">mapping</strong> is so important. We need to transform input objects of <a id="_idIndexMarker344"/>one type into output objects of a different type <a id="_idIndexMarker345"/>and vice versa. In this way, we can achieve two objectives: </p>
<ul>
<li>Evolve our internal data structures without introducing breaking changes with the contracts that are exposed to the callers</li>
<li>Modify the format of the objects used to communicate with the clients without the need to change the way these objects are handled internally</li>
</ul>
<p>In other words, mapping means transforming one object into another, literally, by copying and converting an object’s properties from a source to a destination. However, mapping code is boring, and testing mapping code is even more boring. Nevertheless, we need to fully understand that the process is crucial and strive to adopt it in all scenarios.</p>
<p>So, let’s consider the following object, which could represent a person saved in a database using Entity Framework Core:</p>
<pre class="source-code">
public class PersonEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime BirthDate { get; set; }
    public string City { get; set; }
}</pre>
<p>We have set endpoints for getting a list of people or retrieving a specific person. </p>
<p>The first <a id="_idIndexMarker346"/>thought could be to directly return <code>PersonEntity</code> to the <a id="_idIndexMarker347"/>caller. The following code is highly <a id="_idIndexMarker348"/>simplified, enough <a id="_idIndexMarker349"/>for us to understand the scenario:</p>
<pre class="source-code">
app.MapGet("/people/{id:int}", (int id) =&gt;
{
    // In a real application, this entity could be
    // retrieved from a database, checking if the person
    // with the given ID exists.
    var person = new PersonEntity();
    return Results.Ok(person);
})
.Produces(StatusCodes.Status200OK, typeof(PersonEntity));</pre>
<p>What happens if we need to modify the schema of the database, adding, for example, the creation date <a id="_idIndexMarker350"/>of the entity? In this case, we need to change <code>PersonEntity</code> with <a id="_idIndexMarker351"/>a new property that maps the <a id="_idIndexMarker352"/>relevant date. However, the callers also get this information now, which <a id="_idIndexMarker353"/>we probably don’t want <a id="_idIndexMarker354"/>to be exposed. Instead, if we use a so-called <strong class="bold">data transformation object</strong> (<strong class="bold">DTO</strong>) to expose the person, this problem will be redundant:</p>
<pre class="source-code">
public class PersonDto
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime BirthDate { get; set; }
    public string City { get; set; }
}</pre>
<p>This means that our API should return an object of the <code>PersonDto</code> type instead of <code>PersonEntity</code>, performing a conversion between the two objects. At first sight, the exercise appears to be a useless duplication of code, as the two classes contain the same properties. However, if we consider the fact that <code>PersonEntity</code> could evolve with new properties that are necessary for the database, or change structure with a new semantic that the caller shouldn’t know, the importance of mapping becomes clear. An example is storing the city in a separate table and exposing it through an <code>Address</code> property. Or suppose that, for security reasons, we don’t want to expose the exact birth date anymore, only the age of the person. Using an ad-hoc DTO, we can easily change the schema and update the mapping without touching our entity, having a better separation of concerns.</p>
<p>Of course, mapping can be bidirectional. In our example, we need to convert <code>PersonEntity</code> to <code>PersonDto</code> before returning it to the client. However, we could also do the opposite – that is, convert the <code>PersonDto</code> type that comes from a client into <code>PersonEntity</code> to save it to a database. All the solutions we’re talking about are valid for both scenarios.</p>
<p>We can either perform <a id="_idIndexMarker355"/>mapping manually or adopt a third-party library that <a id="_idIndexMarker356"/>provides us with this feature. In the following <a id="_idIndexMarker357"/>sections, we’ll analyze both approaches, understanding the <a id="_idIndexMarker358"/>pros and cons of the available solutions.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Performing manual mapping</h2>
<p>In the previous section, we said that mapping essentially means copying the properties of a source object into <a id="_idIndexMarker359"/>the properties of a destination and applying some sort of conversion. The easiest and most effective way to perform this task is to do it manually. </p>
<p>With this approach, we need to take care of all the mapping code by ourselves. From this point of view, there is nothing much more to say; we need a method that takes an object as input and transforms it into another as output, remembering to apply mapping recursively if a class contains a complex property that must be mapped in turn. The only suggestion is to use an extension method so that we can easily call it everywhere we need.</p>
<p>A full example of this mapping process is available in the GitHub repository: <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06</a>.</p>
<p>This solution guarantees the best performance because we explicitly write all mapping instructions without relying on an automatic system (such as reflection). However, the manual method has a drawback: every time we add a property in the entity that must be mapped to a DTO, we need to change the mapping code. On the other hand, some approaches can simplify mapping, but at the cost of performance overhead. In the next section, we look at one such approach using <code>AutoMapper</code>.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/>Mapping with AutoMapper</h2>
<p><code>AutoMapper</code> is probably <a id="_idIndexMarker360"/>one the most famous mapping framework for .NET. It uses a <a id="_idIndexMarker361"/>fluent configuration API that works with a <a id="_idIndexMarker362"/>convention-based matching algorithm to match source values to destination values. As with <code>FluentValidation</code>, the framework <a id="_idIndexMarker363"/>is part of the .NET Foundation and is available either on GitHub (<a href="https://github.com/AutoMapper/AutoMapper">https://github.com/AutoMapper/AutoMapper</a>) or NuGet (<a href="https://www.nuget.org/packages/AutoMapper">https://www.nuget.org/packages/AutoMapper</a>). Again, in this case, we have a specific NuGet package, <a href="https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection">https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection</a>, that simplifies its integration into ASP.NET Core projects.</p>
<p>Let’s take a quick look at how to integrate <code>AutoMapper</code> in a minimal API project, showing its main features. The full documentation of the library is available at <a href="https://docs.automapper.org">https://docs.automapper.org</a>.</p>
<p>As usual, the first thing to do is to add the library to our project, following the same instructions we used in the previous sections. Then, we need to configure <code>AutoMapper</code>, telling it how to perform mapping. There are several ways to perform this task, but the recommended approach is to create classes that are inherited from the <code>Profile</code> base class provided by the library and put the configuration into the constructor:</p>
<pre class="source-code">
public class PersonProfile : Profile
{
    public PersonProfile()
    {
        CreateMap&lt;PersonEntity, PersonDto&gt;();
    }
}</pre>
<p>That’s all we need to start: a single instruction to indicate that we want to map <code>PersonEntity</code> to <code>PersonDto</code>, without any other details. We have said that <code>AutoMapper</code> is convention-based. This means that, by default, it maps properties with the same name from the source to the destination, while also performing automatic conversions into compatible types, if necessary. For example, an <code>int</code> property on the source can be automatically mapped to a <code>double</code> property with the same name on the destination. In other <a id="_idIndexMarker364"/>words, if source and destination objects have the same <a id="_idIndexMarker365"/>property, there is no need for any explicit mapping instruction. However, in our case, we need to perform some transformations, so we can add them fluently after <code>CreateMap</code>:</p>
<pre class="source-code">
public class PersonProfile : Profile
{
    public PersonProfile()
    {
        CreateMap&lt;PersonEntity, PersonDto&gt;()
            .ForMember(dst =&gt; dst.Age, opt =&gt;
           opt.MapFrom(src =&gt; CalculateAge(src.BirthDate)))
            .ForMember(dst =&gt; dst.City, opt =&gt; 
              opt.MapFrom(src =&gt; src.Address.City));
    }
    private static int CalculateAge(DateTime dateOfBirth)
    {
        var today = DateTime.Today;
        var age = today.Year - dateOfBirth.Year;
        if (today.DayOfYear &lt; dateOfBirth.DayOfYear)
        {
            age--;
        }
        return age;
    }
}</pre>
<p>With the <code>ForMember</code> method, we can specify how to map destination properties, <code>dst.Age</code> and <code>dst.City</code>, using conversion expressions. We still don’t need to explicitly map the <code>Id</code>, <code>FirstName</code>, or <code>LastName</code> properties because they exist with these names at both the source and destination.</p>
<p>Now that we <a id="_idIndexMarker366"/>have defined the mapping profile, we need to register it at <a id="_idIndexMarker367"/>startup so that ASP.NET Core can use it. As with <code>FluentValidation</code>, we can invoke an extension method on <code>IServiceCollection</code>:</p>
<pre class="source-code">
builder.Services.AddAutoMapper(typeof(Program).Assembly);</pre>
<p>With this line of code, we automatically register all the profiles that are contained in the specified assembly. If we add more profiles to our project, such as a separate <code>Profile</code> class for every entity to map, we don’t need to change the registration instructions.</p>
<p>In this way, we can now use the <code>IMapper</code> interface through dependency injection:</p>
<pre class="source-code">
app.MapGet("/people/{id:int}", (int id, IMapper mapper) =&gt;
{
    var personEntity = new PersonEntity();
    //...
    var personDto = mapper.Map&lt;PersonDto&gt;(personEntity);
    return Results.Ok(personDto);
})
.Produces(StatusCodes.Status200OK, typeof(PersonDto));</pre>
<p>After retrieving <code>PersonEntity</code>, for example, from a database using Entity Framework Core, we call the <code>Map</code> method on the <code>IMapper</code> interface, specifying the type of the resulting object and the input class. With this line of code, <code>AutoMapper</code> will use the corresponding profile to convert <code>PersonEntity</code> into a <code>PersonDto</code> instance. </p>
<p>With this solution in place, mapping is now much easier to maintain because, as long as we add properties with the same name on the source and destination, we don’t need to change the profile at all. Moreover, <code>AutoMapper</code> supports list mapping and recursive mapping too. So, if we have an entity that must be mapped, such as a property of the <code>AddressEntity</code> type on the <code>PersonEntity</code> class, and the corresponding profile is available, the conversion is again performed automatically.</p>
<p>The drawback of this approach is a performance overhead. <code>AutoMapper</code> works by dynamically executing <a id="_idIndexMarker368"/>mapping code at runtime, so it uses reflection under the <a id="_idIndexMarker369"/>hood. Profiles are created the first time they are used and then they are cached to speed up subsequent mappings. However, profiles are always applied dynamically, so there is a cost for the operation that is dependent on the complexity of the mapping code itself. We have only seen a basic example of <code>AutoMapper</code>. The library is very powerful and can manage quite complex mappings. However, we need to be careful not to abuse it – otherwise, we can negatively impact the performance of our application. </p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor093"/>Summary</h1>
<p>Validation and mapping are two important features that we need to take into account when developing APIs to build more robust and maintainable applications. Minimal APIs do not provide any built-in way to perform these tasks, so it is important to know how we can add support for this kind of feature. We have seen that we can perform validations with data annotations or using <code>FluentValidation</code> and how to add validation information to Swagger. We have also talked about the significance of data mapping and shown how to either leverage manual mapping or the <code>AutoMapper</code> library, describing the pros and cons of each approach.</p>
<p>In the next chapter, we will talk about how to integrate minimal APIs with a <strong class="bold">data access layer</strong>, showing, for example, how to access a database using Entity Framework Core.</p>
</div>
</div></body></html>