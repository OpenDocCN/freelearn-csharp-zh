- en: Chapter 9. Functional Programming Techniques for Better State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：用于更好状态管理的函数式编程技术
- en: 'While writing concurrent/parallel code, handling state is difficult in an imperative
    program (something that you would have seen by now). Modern languages and platforms
    borrow idioms and practices that enable better state management and facilitate
    strong concurrency models from the functional programming community. In this chapter,
    we will see what those are and try to understand, through code samples, how to
    best leverage some of those features (striving for coverage would stretch this
    chapter to an entire book) to our advantage. We would also see how C# has evolved
    as a language to bring the best of both worlds (imperative and functional), and
    to help you apply functional thinking to model real-world scenarios. This chapter
    will also cover **Language Integrated Query** (**LINQ**) as a mechanism for writing
    compositional code. Through this journey, we will uncover some good design practices,
    leveraging the functional constructs in the language (primarily C#). We hope this
    chapter serves as a starter kit by providing you with some of the techniques and
    tools to tackle programming tasks in a functional way. Some of the ideas covered
    include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写并发/并行代码时，在命令式程序中处理状态是困难的（你现在可能已经看到了这一点）。现代语言和平台借鉴了来自函数式编程社区的习惯和做法，以实现更好的状态管理和促进强大的并发模型。在本章中，我们将探讨这些做法，并通过代码示例尝试理解如何最好地利用这些特性（追求全面性将使本章内容扩展到整本书）以发挥我们的优势。我们还将看到C#语言是如何演变成一种结合了命令式和函数式最佳特性的语言，以及如何帮助你将函数式思维应用于现实世界的场景。本章还将涵盖**语言集成查询**（**LINQ**）作为编写组合代码的机制。通过这次旅程，我们将揭示一些良好的设计实践，利用语言中的函数式结构（主要是C#）。我们希望本章能作为一个入门工具包，为你提供一些技术和工具，以函数式方式处理编程任务。其中涉及的一些想法包括：
- en: Being functional
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式
- en: Referential transparency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性
- en: First class functions (also higher order functions)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类函数（也称为高阶函数）
- en: Lambda calculus and anonymous functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉姆达演算和匿名函数
- en: Currying and partial function application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化和部分函数应用
- en: A brief overview of how LINQ works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ 的工作原理简要概述
- en: Being functional
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式
- en: Functional programming is a programming paradigm that involves algorithm composition,
    to be dealt on the same lines as mathematical function evaluations. This implies
    that the output of these functions would purely depend on the inputs provided.
    Moreover, any applicable data structures that the algorithm would need to create
    the output would be transient, having a lifetime within the function scope, and
    thus help in avoiding state mutation. It is also a powerful declarative programming
    paradigm, which involves leveraging expressions for readable code in place of
    procedural in-line statements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种编程范式，它涉及算法组合，与数学函数评估处于同一层面。这意味着这些函数的输出将纯粹取决于提供的输入。此外，算法在创建输出所需的所有适用数据结构都是瞬时的，其生命周期在函数作用域内，从而有助于避免状态突变。它也是一种强大的声明式编程范式，它涉及利用表达式来代替过程式内联语句，以实现可读的代码。
- en: Referential transparency
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Let's delve a bit deeper to understand the consequences of being functional,
    as illustrated by the definitions given in the preceding section. Now, when we
    try to relate functions from both these worlds (mathematical and imperative programming),
    we see a strong disparity, as the latter mutates state with commands in the source
    language, thereby bringing in side effects (though desirable from an imperative
    programming standpoint). This violates one of the fundamental pre-requisites of
    functional programming - that of referential transparency, that is, the same expressions
    (when run at different times) yield different values with respect to the executing
    program's state. This affects the predictability of the program, which is definitely
    not desirable. On the other hand, pure functions (say *f*, one without such side
    effects) in the mathematical world would yield the same result *f(x)* each time
    with the same value of *x*, say *sin(x)*. This characteristic is attributed to
    idempotency in software behavior (delivers consistency). Now you understand how
    this characteristic became so fundamental to functional programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下，了解函数式编程的后果，正如前述章节中给出的定义所示。现在，当我们尝试将这两个世界（数学和命令式编程）中的函数联系起来时，我们看到一个强烈的差异，因为后者在源语言中使用命令来改变状态，从而引入了副作用（尽管从命令式编程的角度来看是可取的）。这违反了函数式编程的一个基本前提——引用透明性，即相同的表达式（在运行不同时间时）根据执行程序的状态产生不同的值。这影响了程序的可预测性，这绝对是不希望的。另一方面，数学世界中的纯函数（比如
    *f*，一个没有这种副作用的功能）每次都会产生相同的结果 *f(x)*，其中 *x* 的值相同，比如 *sin(x)*。这种特性归因于软件行为中的幂等性（提供一致性）。现在你理解了这种特性为什么对函数式编程如此基本。
- en: 'Let''s understand the consequence of this by looking at two functions: one
    which is referentially opaque (with side effects), and the other which is referentially
    transparent:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过观察两个函数来了解这一后果：一个是有副作用的引用不透明函数，另一个是引用透明函数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function `AddOneRT` is referentially transparent, which means that `AddOneRT
    (x) = AddOneRT (y)` if `x = y`. However, we can't say any such thing for `AddOneRO`,
    because it uses a global variable (`i`) that it modifies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `AddOneRT` 是引用透明的，这意味着如果 `x = y`，则 `AddOneRT (x) = AddOneRT (y)`。然而，对于 `AddOneRO`
    我们不能说任何这样的话，因为它使用一个它修改的全局变量（`i`）。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now since `AddOneRO (x) <> AddOneRO (y)` if `x = y`, this further implies `AddOneRO
    (x) - AddOneRO (x) <> 0`, thus invalidating the fundamental mathematical identity
    (`x - x = 0`)!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于 `AddOneRO (x) <> AddOneRO (y)` 当 `x = y` 时，这进一步意味着 `AddOneRO (x) - AddOneRO
    (x) <> 0`，从而违反了基本的数学恒等式（`x - x = 0`）！
- en: This has major consequences in terms of code robustness and optimization by
    means of memorization (caching intermediate results), common subexpression elimination
    (where the result of a pure expression can be substituted in place of repeated
    evaluations without affecting the program behavior), lazy evaluation, or parallelization.
    So, in order to reap the benefits of these consequences from functional computation,
    one needs to strive to get the functions to be as referentially transparent (that
    is, free from the side effects of memory and I/O) as a mathematical function.
    With this, we come to the next important functional programming feature where
    functions become first-class citizens.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在代码健壮性和通过记忆（缓存中间结果）、公共子表达式消除（纯表达式的结果可以替换重复评估，而不影响程序行为）、惰性评估或并行化等方式进行优化方面有重大影响。因此，为了从函数计算中获得这些后果的好处，需要努力使函数尽可能具有引用透明性（即，没有内存和I/O的副作用），就像数学函数一样。有了这一点，我们就来到了下一个重要的函数式编程特性，即函数成为一等公民。
- en: First-class and higher-order functions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等函数与高阶函数
- en: Functions are the fundamental processing units in functional programming, and
    since they can be used like any other value, functions can be stored in variables,
    properties, objects, and collections. The term first-class function was created
    by Christopher Strachey.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是函数式编程中的基本处理单元，由于它们可以被像任何其他值一样使用，因此函数可以被存储在变量、属性、对象和集合中。术语“一等函数”是由克里斯托弗·斯特雷奇创造的。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Higher-order functions are functions that can either take other functions as
    arguments or return them as results.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是那些可以接受其他函数作为参数或者返回函数作为结果的函数。
- en: C# supports higher-order functions (both named and anonymous), which are treated
    like ordinary variables with a function type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持高阶函数（包括命名和匿名），它们被当作具有函数类型的普通变量来处理。
- en: Function type
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: C# provides the capability to define both generic functions and strongly typed
    delegates. The delegate type carries the method signature of a function prototype,
    and its instances become function pointers. Thus, you can manipulate a function
    variable whose function method signature matches with that of the function prototype.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了定义泛型函数和强类型委托的能力。委托类型携带函数原型的函数签名，其实例成为函数指针。因此，你可以操作一个函数变量，其函数方法签名与函数原型相匹配。
- en: 'In addition to generic function types, C# 2.0 introduced anonymous methods/delegates
    and iterators (with the `yield return` statement which lets you create iterator/continuation
    methods that return sequences based on the caller''s demand/pull. That is, you
    get the benefit of deferred execution without incurring storage allocation overheads
    for the input and output sequences), which provided more flexibility and compositional
    capability. We can also use the following three generic function types that C#
    provides:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了泛型函数类型之外，C# 2.0 引入了匿名方法/委托和迭代器（通过 `yield return` 语句，它允许你创建基于调用者需求/拉取的迭代器/延续方法，从而在不产生输入和输出序列的存储分配开销的情况下获得延迟执行的好处），这提供了更多的灵活性和组合能力。我们还可以使用
    C# 提供的以下三种泛型函数类型：
- en: 'A function that takes multiple type arguments, and returns result of a particular
    type:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受多个类型参数并返回特定类型结果的函数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A procedure that takes multiple type arguments, and performs action/s without
    returning any result:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受多个类型参数并执行动作/但不返回任何结果的程序：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A function that takes multiple type arguments, and returns a Boolean result:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受多个类型参数并返回布尔结果的函数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see the preceding function types in action as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式看到前面提到的函数类型在行动中的表现：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A client using the anonymous delegate syntax would consume the preceding static
    methods as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名委托语法的客户端会像下面这样消耗前面的静态方法：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, this deferred execution model makes your algorithms use less
    storage space and compose better than traditional imperative methods. More importantly,
    with functional purity you'll be able to leverage parallelism by assigning different
    operations to different CPU cores, thereby improving throughput.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种延迟执行模型使你的算法使用的存储空间更少，并且比传统的命令式方法组合得更好。更重要的是，通过函数纯度，你将能够通过将不同的操作分配给不同的
    CPU 核心来利用并行性，从而提高吞吐量。
- en: Now it's time to look at a core functional programming concept which was adopted
    in C# 3.0, that is, lambda expressions that facilitated wide adoption of functional
    programming practices (with little or no knowledge on it's consequences) in the
    imperative world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看 C# 3.0 采纳的核心函数式编程概念了，即 lambda 表达式，它促进了函数式编程实践（几乎不需要了解其后果）在命令式世界中的广泛采用。
- en: Lambda (λ) calculus
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉姆达（λ）演算
- en: λ-calculus is a mathematical formalism for denoting computation in an abstract
    form using functions. This brings forth a formal notation and transformation rules
    for representation (function abstraction) and manipulation (function application)
    of lambda terms. The key to this formalism is variable binding and substitution.
    **Alonzo Church** created lambda calculus in an attempt to prove mathematical
    logic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: λ-演算是一种使用函数在抽象形式中表示计算的数学形式化方法。这为表示（函数抽象）和操作（函数应用）λ项提供了正式的符号和变换规则。这个形式化的关键是变量绑定和替换。**阿隆佐·丘奇**创建了λ-演算，试图证明数学逻辑。
- en: 'The λ-calculus provides a simple semantics for computation using computable
    functions based on **Church-Turing** thesis (readers are urged to take a look
    at the history of lambda calculus, its motivation, and mathematical implications
    at a little deeper level to better appreciate this formalism and its consequences,
    as opposed to just being sheer consumers) by incorporating the following simplifications
    and concepts:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: λ-演算通过结合以下简化和概念为基于可计算函数的计算提供了一个简单的语义，这些函数基于 **丘奇-图灵** 假设（读者被敦促深入了解 λ-演算的历史、其动机和数学含义，以更好地欣赏这种形式化和其后果，而不仅仅是作为纯粹的消费者）：
- en: Anonymous functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'This involves treating functions as anonymous, without giving them explicit
    names. For example, take this simple `static` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到将函数视为匿名，不给予它们显式的名称。例如，考虑这个简单的 `static` 方法：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you rewrite the preceding static method, the equivalent representation as
    an anonymous delegate would be what is highlighted in the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重写前面的静态方法，对应的匿名委托表示法将在以下代码中突出显示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the corresponding lambda expression would be the one highlighted in this
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相应的拉姆达表达式将是以下代码中突出显示的：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another lambda expression that follows the same function signature, yet bringing
    in a polymorphic behavior, is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个遵循相同函数签名的拉姆达表达式，但引入了多态行为，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you can see the formal syntax that lambda expressions obey, as stated in
    the definitions given earlier, which denotes that variables `x` and `y` are bound
    to the lambda term `x + y`. You just witnessed the lambda abstraction for the
    function *f(x, y) = x + y*. The function definitions (`AddOperation` and `ConcatOperation`)
    with this lambda abstraction just sets up the function without invocation. An
    application in lambda calculus parlance, with respect to the preceding example,
    would signify applying inputs `x` and `y` to the function *f*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到拉姆达表达式遵循的正式语法，如前面给出的定义所述，这表明变量`x`和`y`被绑定到拉姆达项`x + y`。你刚刚见证了函数*f(x, y)
    = x + y*的拉姆达抽象。具有这种拉姆达抽象的函数定义（`AddOperation`和`ConcatOperation`）只是设置函数而不调用。在拉姆达演算的术语中，相对于前面的例子，应用将意味着将输入`x`和`y`应用于函数*f*。
- en: Function application in lambda calculus is achieved through **beta reduction**
    (a continuous reduction process involving substitution of bound variables to the
    lambda terms till no applications remain for reduction). A function application
    in lambda calculus is analogous to method invocation in the imperative world,
    except that the consequences are totally different, which you would have understood
    by now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 拉姆达演算中的函数应用是通过**β-归约**（一个涉及将绑定变量替换到λ项中的连续归约过程，直到没有应用剩余为止）来实现的。拉姆达演算中的函数应用与命令式世界中的方法调用类似，但后果完全不同，你现在应该已经理解了。
- en: Closures
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: As mentioned earlier, the key to formalism is variable binding and substitution.
    Bound variables are the ones that fall within the scope of an abstraction. The
    remaining variables are said to be free (from the context of that specific abstraction).
    A closed lambda expression is one with no free variables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，形式化的关键是变量绑定和替换。绑定变量是那些位于抽象作用域内的变量。其余的变量被称为自由（从特定抽象的上下文来看）。一个封闭的拉姆达表达式是一个没有自由变量的表达式。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Something to note here is that a variable is bound by its nearest abstraction,
    which means that a free variable, with respect to an abstraction, would eventually
    be bound to higher abstractions in the hierarchy. And this free or unbound variable
    (with its associated references and values), which gets captured in the context
    of an abstraction (that is, the lexical Scope), constitutes a closure (again pertaining
    to that abstraction).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，一个变量被其最近的上层抽象所绑定，这意味着相对于一个抽象，一个自由变量最终会被绑定到层次结构中的更高抽象。而这个自由或未绑定的变量（及其相关的引用和值），在抽象的上下文中被捕获（即，词法作用域），构成了一个闭包（再次与那个抽象相关）。
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code clearly shows a closure in action. Here, the closure object
    (which constitutes of variable `x` and its target method) helps to share data
    between the functions. The use of this higher-order `sum` function (where new
    functions are composed and returned) is illustrated clearly in the following code
    snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码清晰地展示了闭包的作用。在这里，闭包对象（由变量`x`及其目标方法构成）有助于在函数之间共享数据。以下代码片段清楚地展示了这种高阶`sum`函数（其中新函数被组合并返回）的使用：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Currying and partial application
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化和偏应用
- en: Partial application and currying are two distinct techniques, yet loosely depicted.
    It is facilitated by the capability of higher-order functions, wherein their partial
    application (against one or multiple arguments) returns new functions (that accept
    the remaining arguments) with lesser arity (compared to the original function).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 偏应用和柯里化是两种不同的技术，但描述得比较宽松。它们是通过高阶函数的能力来实现的，其中它们的偏应用（针对一个或多个参数）返回新的函数（接受剩余的参数），其阶数（与原始函数相比）较低。
- en: Let's now understand the difference between currying and partial application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下柯里化与偏应用之间的区别。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Currying is a natural consequence of lambda calculus, where functions employ
    only a single input. This technique primarily involves conversion of a function
    evaluation that accepts multiple arguments (as in any practical function) into
    a series of function evaluations that accept one argument at a time. Currying
    got its name from Haskell Curry, who developed it following the work of Gottlob
    Frege and Moses Schönfinkel.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是λ演算的自然结果，其中函数仅使用单个输入。这种技术主要涉及将接受多个参数的函数评估（如任何实际函数）转换为一系列一次接受一个参数的函数评估。柯里化得名于哈斯克尔·柯里，他在戈特洛布·弗雷格和摩西·舒恩菲克尔的工作之后开发了它。
- en: Without much ado, let's see these in action.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不多言，让我们看看这些功能在实际中的应用。
- en: Currying
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Let''s go back to our old example here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前的例子：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now this is a simple and practical function we employ mostly. Let''s see how
    this is deftly curried to generate functions that accept one argument at a time,
    and yet leverage the core function for function application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个简单实用的函数，我们通常都会用到。让我们看看它是如何巧妙地柯里化以生成一次接受一个参数的函数，同时利用核心函数进行函数应用的：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Any client would leverage the curried function this way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端都可以这样利用柯里化函数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There''s another interesting way to curry functions; as a matter of fact, we
    can curry any arbitrary function using the function definition (delegate in our
    case). Here we leverage e**xtension methods** (a language feature introduced in
    version 3.0) to provide innate currying capability to a generic function definition:
    `Func<T1, T2, TReturn>`. This means you can apply currying to any function that
    has this method signature. See the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种有趣的方式来柯里化函数；事实上，我们可以使用函数定义（在我们的例子中是委托）来柯里化任何任意函数。在这里，我们利用扩展方法（在3.0版本中引入的语言特性）为通用函数定义`Func<T1,
    T2, TReturn>`提供固有的柯里化能力：这意味着你可以将柯里化应用于任何具有此方法签名的函数。请看以下代码：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The keyword `this` in the highlighted code enables the extension method magic
    for you (which essentially decorates the generic delegate type `Func<T1, T2, TReturn`)
    with the curry function. **Voila**! We finally have imparted innate currying capability
    to any function that conforms to this definition. Take a look at the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮代码中的关键字`this`为您开启了扩展方法魔法（这本质上是用柯里化函数装饰了通用委托类型`Func<T1, T2, TReturn>`）。**哇**！我们终于为符合此定义的任何函数赋予了固有的柯里化能力。看看以下代码：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now to replicate the same thing in the polymorphic function below:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在下面的多态函数中复制相同的功能：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You could continue (as shown in the next code) to create more curry function
    overloads to support additional function definitions (that has more than two input
    parameters):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续（如下一代码所示）创建更多的柯里化函数重载，以支持更多的函数定义（具有超过两个输入参数）：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Partial application
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分应用
- en: Now let's look at partial application which is distinctively different from
    currying, though highly confusing to many programmers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看部分应用，它与柯里化截然不同，尽管对许多程序员来说非常令人困惑。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Partial application (or partial function application) is yet another consequence
    of lambda calculus where functions employ a fixed set of inputs. This technique
    primarily involves conversion of a function evaluation that accepts multiple arguments
    (as in any practical function) into a function that accepts a fixed number of
    arguments, which in turn yields yet another function that accepts the remaining
    arguments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用（或部分函数应用）是λ演算的另一个结果，其中函数使用一组固定的输入。这种技术主要涉及将接受多个参数的函数评估（如任何实际函数）转换为接受固定数量参数的函数，进而产生另一个接受剩余参数的函数。
- en: 'The following code says it all:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了这一切：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Applying currying and partial application
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用柯里化和部分应用
- en: 'Let''s see these two in action in a real programming scenario. The scenario
    we would look at is a classic mathematical conundrum - that of determining the
    Pythagorean Triples within a given range. As the name suggests, the Pythagorean
    triple constitutes the set of numbers that satisfy the Pythagorean theorem (*a²
    + b² = c²*). The conventional method to find the triples is shown in the following
    code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实际的编程场景中看看这两个功能的实际应用。我们将关注的场景是一个经典的数学难题——在给定范围内确定毕达哥拉斯三元组。正如其名所示，毕达哥拉斯三元组是由满足毕达哥拉斯定理（*a²
    + b² = c²*）的数字组成的集合。找到这些三元组的传统方法如下所示：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This preceding code continuously yields the triplets as and when it is discovered.
    Another interesting thing about the brute force approach here is that it returns
    duplicates (for example-[3, 4, 5] and [4, 3, 5], [6, 8, 10] and [8, 6, 10], and
    so on. The filter (highlighted code), in conjunction with the **HashSet**, helps
    eliminate these duplicates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会连续产生在发现三元组时。这里暴力方法的一个有趣之处在于它返回重复项（例如-[3, 4, 5]和[4, 3, 5]，[6, 8, 10]和[8,
    6, 10]，等等。与**HashSet**结合使用的过滤器（突出显示的代码）有助于消除这些重复项。
- en: 'Now let''s see the same code leveraging curried functions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看利用柯里化函数的相同代码：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case the curried function is created, based on the formula that proves
    the Pythagorean theorem, which would accept a valid input for `a`, `b`, and `c`
    consecutively, and final evaluation is done when the last argument is received.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，基于证明勾股定理的公式创建了一个柯里化函数，该函数将依次接受`a`、`b`和`c`的有效输入，并在接收到最后一个参数时进行最终评估。
- en: 'Now let''s check out partial application usage in this same scenario:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查在这个相同场景下部分应用的使用情况：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, you can clearly see the distinction between currying and partial application.
    The result yielded by partial application becomes a closure (gets captured) for
    reuse in place of function captures in the currying approach. This early evaluation
    (*a²* and *b²*) in the case of partial application would give an advantage for
    reuse in subsequent iterations in place of repeated deferred evaluations with
    respect to currying. The real use of currying and partial application is seen
    when inputs are generated asynchronously for consumption by a grand computation
    function. You could capture or partially compute as and when these inputs are
    generated, and trigger the final evaluation on obtaining the last input. Another
    thing to note is that partial application can accept more than one arguments (unlike
    the example shown here where it accepts one as in currying). A typical consumer
    client would be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以清楚地看到柯里化和部分应用之间的区别。部分应用产生的结果成为闭包（被捕获），以便在柯里化方法中替代函数捕获。在部分应用的情况下，这种早期评估（*a²*和*b²*）将给后续迭代中的重用带来优势，而不是与柯里化相关的重复延迟评估。柯里化和部分应用的真实用途在于当输入异步生成以供大型计算函数消费时。你可以随着这些输入的生成而捕获或部分计算，并在获得最后一个输入时触发最终评估。另一个需要注意的是，部分应用可以接受多个参数（与这里显示的示例不同，它接受一个参数，就像柯里化一样）。一个典型的消费者客户端如下：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, we guess no more confusions on these two concepts from now on! Another
    adventure (if you''re game; yes, we dare you) is to do the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们猜测从现在开始对这些两个概念不再有混淆！另一个冒险（如果你愿意；是的，我们向你挑战）是做以下事情：
- en: Optimize this algorithm (now you know there are *range3* iterations and the
    performance impact is huge when you go beyond the range of 1,000).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化这个算法（现在你知道有*range3*次迭代，当你超过1,000的范围时性能影响巨大）。
- en: Making the filter operation lazily evaluated as part of the LINQ consumer query
    which would yield duplicates (without the HashSet in the first place). And again,
    nothing actually stops you from figuring out a way to generate triplets without
    duplicates!
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将过滤器操作作为LINQ消费者查询的一部分进行懒加载评估，这将产生重复项（最初没有使用HashSet）。再次强调，实际上没有什么阻止你找到一种方法来生成不重复的三元组！
- en: Figure out a way to generate triples forever as they are detected (without the
    limitation of a range, loop, or any computation limits (such as reaching the max
    value for a 64-bit signed integer).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想出一个方法，在检测到三元组时永远生成它们（没有范围、循环或任何计算限制（例如64位有符号整数的最大值）的限制）。
- en: Expression trees
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式树
- en: By now you have seen how to create delegates from a lambda expression (anonymous
    function). You can also opt to create expression tree types. Expression trees
    are analogous to **Abstract Syntax Tree** (**AST**) in the compiler construction
    realm, and they embody code in a tree data structure, where each node is represented
    as an expression. Using expression trees, you can compile and run code, thereby
    gaining powerful ability to dynamically modify executable code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经看到了如何从lambda表达式（匿名函数）创建委托。你也可以选择创建表达式树类型。表达式树在编译器构建领域中类似于**抽象语法树（AST**），并且它们以树形数据结构体现代码，其中每个节点都表示为一个表达式。使用表达式树，你可以编译和运行代码，从而获得强大的动态修改可执行代码的能力。
- en: '|   | *Expression trees are also used in the Dynamic Language Runtime (DLR)
    to provide interoperability between dynamic languages and the .NET Framework and
    to enable compiler writers to emit expression trees instead of Microsoft Intermediate
    language (MSIL).* |   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|    | *表达式树也用于动态语言运行时（DLR），以提供动态语言和.NET Framework之间的互操作性，并允许编译器编写器发出表达式树而不是微软中间语言（MSIL）。*
    |    |'
- en: '|   | --*MSDN* |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|    | --*MSDN* |'
- en: Expression trees are inherently immutable. All that we need to get the compiler
    emit the code for an expression tree is to assign the lambda expression to a variable
    of type `Expression<TDelegate>`. The .NET framework provides a rich API (expression
    class under **System.Linq.Expressions Namespace**) for parsing, creation, and
    manipulation (of course recreating with appropriate tree visitors). The API supports
    most of the language grammar.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树本质上是不可变的。我们只需要将lambda表达式赋值给类型为`Expression<TDelegate>`的变量，编译器就会发出表达式树的代码。.NET框架提供了一个丰富的API（在**System.Linq.Expressions命名空间**下的表达式类），用于解析、创建和操作（当然，使用适当的树访问者重新创建）。该API支持大多数语言语法。
- en: Altogether, this becomes a very powerful construct that can be leveraged for
    code/dependency injection, **Domain-Specific Language** (**DSL**) creation, and
    associated language translations (all you would need to do in such a case is to
    let your dynamic language **lexer** and **parser** to generate the **Abstract
    Syntax Tree** (**AST)**, which in our case is the expression tree itself, and
    DLR would do the rest. Don't think twice before embarking on your next DSL adventure.
    There is inherent platform support!)You finally understand how a lambda expression
    (an anonymous function) can be used to create delegates or expression tree types.
    By using lambda expressions, you can write local functions that can be passed
    as arguments or returned as the value of function calls.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这变成了一种非常强大的结构，可以用于代码/依赖注入、**领域特定语言**（**DSL**）的创建以及相关的语言翻译（在这种情况下，你所需要做的就是让你的动态语言**词法分析器**和**解析器**生成**抽象语法树**（**AST**），在我们的例子中，就是表达式树本身，而DLR会完成剩下的工作。在你开始下一次DSL冒险之前，不要犹豫！平台本身就有内在的支持！你终于理解了如何使用lambda表达式（一个匿名函数）来创建代表或表达式树类型。通过使用lambda表达式，你可以编写局部函数，这些函数可以作为参数传递或作为函数调用的返回值。
- en: Recursion
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'Recursions are no alien feature to any programmer worth his salt. Recursions
    are leveraged in functional programming to accomplish iteration/looping. Recursive
    functions invoke themselves, performing an operation repeatedly till the base
    case is reached. Tail call-based recursions are a common phenomenon. Recursion
    typically involves adding stack frames to the call stack, thus growing the stack.
    You can run out of stack space during deep recursions. The compiler does its own
    share of optimizations (predominantly tail call optimization/elimination) to conserve
    stack space and improve throughput. But the functional world (with its first-class
    and higher-order functions) gives us more flexibility to wire such optimizations
    in our recursive functions. Let''s see how this is achieved with the following
    factorial example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 递归对于任何有价值的程序员来说都不是陌生的特性。递归在函数式编程中被用来实现迭代/循环。递归函数调用自身，重复执行操作直到达到基本情况。基于尾调用的递归是一种常见现象。递归通常涉及向调用栈添加栈帧，从而增加栈的大小。在深度递归过程中，可能会耗尽栈空间。编译器会进行自己的优化（主要是尾调用优化/消除），以节省栈空间并提高吞吐量。但函数式世界（及其一等和高级函数）给了我们在递归函数中实现这些优化更多的灵活性。让我们通过以下阶乘示例来看看这是如何实现的：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unlike the classical example, you see how recursion is put to work by lambda
    expressions as well, which makes you use these anonymous functions as higher order
    functions (where they are dynamically created or passed as arguments). You can
    also notice the use of a wrapper function (factorial in this case), which is directly
    called, but does not recurse itself, and instead, leverages an auxiliary function
    (`fIterator` in this case) to do the actual recursion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典示例不同，你看到递归是如何通过lambda表达式来使用的，这让你使用这些匿名函数作为高阶函数（它们是动态创建或作为参数传递的）。你还可以注意到包装函数的使用（在这个例子中是阶乘），它被直接调用，但不会递归自身，而是利用一个辅助函数（在这个例子中是`fIterator`）来进行实际的递归。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The wrapper function becomes handy for performing parameter validations, error
    handling, memorization, and so forth.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 包装函数对于执行参数验证、错误处理、记忆化等操作非常有用。
- en: 'In order to conserve stack space, we can opt for a tail call elimination technique
    known as tail recursion as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省栈空间，我们可以选择一种称为尾递归的尾调用消除技术，如下所示：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, no state, except for the calling function's address, needs to
    be saved either on the stack or on the heap, and the call stack frame for `fIterator`
    is reused for storage of the intermediate results. Another thing to note is the
    addition of an accumulator argument (product in this case).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，除了调用函数的地址外，不需要在栈或堆上保存任何状态，`fIterator`的调用栈帧被重用来存储中间结果。另一个需要注意的事项是累加器参数（在这种情况下是乘积）的添加。
- en: 'Tail recursion can be achieved by another technique called **trampolining**,
    where functions are called by a `trampoline` function as opposed to functions
    calling each other directly. All the needed payload (function pointer and arguments)
    for the function call is provided to the `trampoline` function, which then places
    the call on the caller''s behalf. This ensures that the stack does not grow and
    iteration can continue indefinitely:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归可以通过另一种称为**跳跃**的技术来实现，其中函数通过`trampoline`函数调用，而不是函数直接相互调用。所有函数调用所需的有效负载（函数指针和参数）都提供给`trampoline`函数，然后它代表调用者进行调用。这确保了栈不会增长，迭代可以无限期地继续：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following image depicts the supporting language constructs that have evolved
    to make these functional programming features available for consumption:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了支持这些函数式编程特性所演变出的语言结构：
- en: '![Recursion](img/B05691_09_01-1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![递归](img/B05691_09_01-1.jpg)'
- en: Sample programs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例程序
- en: Now that we have taken a detailed look at the core functional programming constructs,
    it's time to indulge in power play (with code of course). Let's learn to play
    the game with some hardcore sample programs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细地研究了核心函数式编程结构，是时候沉迷于强大的游戏（当然是通过代码）了。让我们学习如何通过一些硬核的示例程序来玩游戏。
- en: Spell checker
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拼写检查器
- en: This was inspired by Peter Norvig's (former Research Director at Google) technical
    blog on *How to Write a Spelling Corrector*. What is interesting is the way the
    solution has been envisaged. The solution employs the probability theory at its
    core to find all possible corrections for a word of length *n*, by accounting
    for user errors in the form of typos arising because of omissions (deletes), characters
    misplaced (replaces and transposes), and inserted (inserts).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这受到了Peter Norvig（前谷歌研究总监）关于*如何编写拼写检查器*的技术博客的启发。有趣的是，解决方案是如何构思的。该解决方案的核心采用了概率论，通过考虑用户错误（由于遗漏（删除）、字符位置错误（替换和交换）和插入）的形式，来找到长度为*n*的单词的所有可能的修正。
- en: 'You can refer to this technical blog on *How to Write a Spelling Corrector*
     by Peter Norvig for the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考Peter Norvig关于*如何编写拼写检查器*的技术博客，了解以下内容：
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a word of length *n*, there will be *n* deletions, *n-1* transpositions,
    *26n* replacements, and *26(n+1)* insertions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长度为*n*的单词，将有*n*个删除，*n-1*个交换，*26n*个替换，以及*26(n+1)*个插入。
- en: To have fair shot at determining the corrections, we do find all possible corrections
    that are 1 (`edits1` function) and 2 (`edits2` function) distance away. You would
    be able to see the function compositions in the code given next using LINQ queries
    that yield these possible corrections in a breeze. This demonstrates the expressive
    and declarative power of lambda expressions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公平地确定修正，我们确实找到了所有可能的修正，这些修正距离为1（`edits1`函数）和2（`edits2`函数）。您将能够通过LINQ查询轻松地看到代码中给出的函数组合，这些查询会生成这些可能的修正。这展示了lambda表达式表达性和声明性力量的体现。
- en: What is most important, and to ensure the right filtering of this huge set (for
    meaningful corrections), is to determine what are the known or meaningful words.
    For this a dictionary is either fed or created (in our case) from a corpus of
    free text from Project Gutenberg, and lists of the most frequent words from Wiktionary
    and the British National Corpus. The text is extracted, concatenated, and provided
    in the text file `NSC_Training_Model.txt` (you could also directly obtain this
    from [http://norvig.com/big.txt](http://norvig.com/big.txt)). The `known` function
    does this filtering for you.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，为了确保对如此庞大的集合（有意义的修正）进行正确的过滤，需要确定已知或有意义的单词是什么。为此，可以从Project Gutenberg的免费文本语料库中提供或创建（在我们的案例中）字典，以及来自Wiktionary和英国国家语料库的最频繁单词列表。文本被提取、连接并提供在文本文件`NSC_Training_Model.txt`中（您也可以直接从[http://norvig.com/big.txt](http://norvig.com/big.txt)获取此文件）。`known`函数为您进行此过滤。
- en: Now, to determine the list of corrections in the order of recommendation, we
    employ the probability of occurrence of the known corrections in the dictionary
    created out of the corpus (as it becomes a good indication of common usage). Now
    you know how personalized spelling correctors work on your mobile device! (Yes,
    you guessed it right, it certainly is based on the probability of the list of
    possible corrections in the order of your usage of words).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了按推荐顺序确定更正列表，我们使用从语料库中创建的字典中已知更正的发生概率（因为它成为常用性的良好指示）。现在你知道了你的移动设备上的个性化拼写更正器是如何工作的了！（是的，你猜对了，它当然是基于你使用单词的顺序的可能更正列表的概率）。
- en: The authors encourage the readers to visit the site ([http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html)),
    and take a look at the detailed explanation of the solution. One of the authors
    has his JavaScript implementation published on the site as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作者鼓励读者访问网站([http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html))，并查看解决方案的详细解释。其中一位作者还在该网站上发布了他的JavaScript实现。
- en: 'The function `NorvigSpellChecker` shown below returns a list of potential corrections
    based on the word and count (maximum items in list) specified:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`NorvigSpellChecker`函数根据指定的单词和计数（列表中的最大项数）返回可能的更正列表：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A declarative style of coding with lambda expressions has been employed fluidly
    in realizing this spell checker. You could see how the algorithm is composed using
    LINQ expressions. Closures, concurrency, and parallelism (in the form of PLINQ)
    has been employed in realizing this function. A typical consumer of this spell
    checker would be the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这个拼写检查器时，已经流畅地采用了带有lambda表达式的声明式编程风格。你可以看到算法是如何使用LINQ表达式组成的。在实现这个功能时，使用了闭包、并发和并行性（以PLINQ的形式）。这个拼写检查器的典型用户如下：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We urge interested developers to explore options to further parallelize the
    algorithm/steps, and see the results (at least from a performance standpoint).
    It would be a worthwhile journey to understand that the parallelization constructs
    at your disposal (especially PLINQ and TPL) are not mere silver bullets!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敦促感兴趣的开发商探索进一步并行化算法/步骤的选项，并查看结果（至少从性能角度来看）。理解你手中的并行化构造（特别是PLINQ和TPL）不仅仅是银弹将是一次有价值的旅程！
- en: Subset generation
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子集生成
- en: 'This problem has a classical implication on a variety of NP-complete problems
    that we are exposed to in daily life. The procedural and generic serial implementation
    is shown as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在日常生活中我们接触到的各种NP完全问题上有经典的意义。以下展示了过程式和通用的串行实现：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you see, the preceding algorithm leverages Boolean logic to determine the
    unique sets. The possible *ON (1)* states of the gates determine the sets, and
    we just need to determine the index of the element in the array (that has the
    complete list of elements whose sets need to be determined) that yields a state
    of 1.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的算法利用布尔逻辑来确定唯一的集合。门可能的*ON（1）*状态决定了集合，我们只需要确定数组（其中包含需要确定集合的所有元素的完整列表）中元素的索引，该索引产生状态1。
- en: 'The declarative equivalent of the preceding implementation has been realized
    with PLINQ as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个实现的声明式等价形式已经通过PLINQ实现，如下所示：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, to take this to the next level, since this has a limit (9,223,372,036,854,775,807
    - max value for a 64-bit signed integer) on the `_mask`, that is, computing the
    total possible combinations, we would have to trade this algorithm for another
    which can continuously generate subsets, that too, forever. This is the power
    of deferred execution and continuation methods (supported by the `yield return`
    keyword). Let''s see this algorithm (again optimized for some amount of parallelism
    which becomes significant for large set generation). This also employs Boolean
    logic but in a different way. It computes 1- bit addition forever, in this case
    using the full adder logic (as the resulting bits directly represent the set):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了达到下一个层次，由于这个算法对`_mask`有限制（9,223,372,036,854,775,807 - 64位有符号整数的最大值），即计算所有可能的组合，我们必须用另一个算法来替换它，该算法可以持续生成子集，而且永远如此。这是延迟执行和延续方法（由`yield
    return`关键字支持）的力量。让我们看看这个算法（再次优化了一些并行性，这对于大量生成集合来说变得很重要）。这也使用了布尔逻辑，但方式不同。它永远计算1位加法，在这种情况下使用全加器逻辑（因为结果位直接表示集合）：
- en: '![Subset generation](img/B05691_09_02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![子集生成](img/B05691_09_02.jpg)'
- en: 'The parallelization done here is to chunk the binary additions for each `overFlow`
    (as the code indicates). For example, say there are three elements namely, 10,
    20, and 30\. The process of determining the sets (including chunking) would happen
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所做的并行化是将每个 `overFlow` 的二进制加法进行分块（如代码所示）。例如，假设有三个元素，分别是10、20和30。确定集合（包括分块）的过程将如下进行：
- en: '| **Bits** | **Chunks** | **Resulting set** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **比特** | **块** | **结果集** |'
- en: '| 0 - 0 - 1 | 1 | [30] |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 0 - 1 | 1 | [30] |'
- en: '| 0 - 1 - 0 | 2 | [20] |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 1 - 0 | 2 | [20] |'
- en: '| 0 - 1 - 1 | 2 | [20, 30] |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 1 - 1 | 2 | [20, 30] |'
- en: '| 1 - 0 - 0 | 3 | [10] |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 1 - 0 - 0 | 3 | [10] |'
- en: '| 1 - 0 - 1 | 3 | [10, 30] |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 1 - 0 - 1 | 3 | [10, 30] |'
- en: '| 1 - 1 - 0 | 3 | [10, 20] |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 1 - 1 - 0 | 3 | [10, 20] |'
- en: '| 1 - 1 - 1 | 3 | [10, 20, 30] |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 1 - 1 - 1 | 3 | [10, 20, 30] |'
- en: 'The initial set of bit (*0-0-0*) which yields an empty set is ignored here.
    The overflows are indicated by the high-lighted rows, and the bits that shift
    are represented as bold. The throughput was observed to be ~three times faster
    than the serial implementation on a quad-Core computer! In case you''re wondering
    why parallelization has been restricted to one level, the authors urge you to
    find out the effect of parallelizing/optimizing further. This is a NP-complete
    problem that would demand *2n* cores for the ultimate parallelization! It would
    be interesting to see how these sets could be applied for packing algorithms:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的比特集（*0-0-0*）产生一个空集，在这里被忽略。溢出由高亮行表示，移动的比特用粗体表示。在四核计算机上观察到的吞吐量比串行实现快约三倍！如果你想知道为什么并行化被限制在一级，作者敦促你找出进一步并行化/优化的影响。这是一个NP完全问题，最终并行化需要*2n*个核心！将很有趣地看到这些集合如何应用于装箱算法：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just in case you are wondering how this could help in solving packing problems
    (of course with smaller sets), see this client given next, which generates the
    various ways in which the following packages (having weights 3, 1, 1, 2, 2, and
    1 kg) could be packed in boxes that can accommodate 5 kg. We believe this opens
    up a window of possibilities for any interested developer:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想这如何有助于解决装箱问题（当然，是使用更小的集合），请看下面给出的这个客户端，它生成了以下包装（重量分别为3、1、1、2、2和1千克）可以装入5千克容量的箱子中的各种方式。我们相信这为任何感兴趣的开发商打开了一扇可能性之窗：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How does LINQ work?
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ是如何工作的？
- en: 'Before we conclude this chapter, we would like to give you a rough idea about
    how **Language Integrated Query** (**LINQ**) works under the hood, in a schematic
    manner. As we know, LINQ is a declarative language embedded inside a multi-paradigm
    language. The primary advantage of LINQ is the alignment to the rich type system
    of C#. Syntactically, LINQ is very similar to SQL language and the evaluation
    model is very similar to an SQL engine. As an example, let us explore a LINQ query
    which retrieves information regarding a set of employees by querying `Employee`
    and `Department` table. The query returns an anonymous type consisting of employee
    name, department name and location of the employee. We are using the comprehension
    syntax in this particular example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，我们想给你一个关于**语言集成查询**（**LINQ**）在底层如何工作的粗略概念，以图示的方式。正如我们所知，LINQ是一种嵌入在多范式语言中的声明性语言。LINQ的主要优势是与C#丰富的类型系统的对齐。在语法上，LINQ与SQL语言非常相似，评估模型与SQL引擎非常相似。作为一个例子，让我们探索一个LINQ查询，该查询通过查询
    `Employee` 和 `Department` 表来检索有关一组员工的信息。查询返回一个匿名类型，包括员工姓名、部门名称和员工的地点。在这个特定的例子中，我们使用了理解语法：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: While evaluating this LINQ statement, even though documentation states about
    outer sequence and inner sequence, schematically speaking, a cartesian product
    (aka cross join in database parlance) will be performed between `Employee` and
    `Department` table. The resulting data set will be filtered based on the join
    clause (on `emp.deptid` equals `dept.nid`), resulting in yet another data set.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估这个LINQ语句时，尽管文档中提到了外部序列和内部序列，但从图示的角度来看，将在 `Employee` 和 `Department` 表之间执行笛卡尔积（在数据库术语中称为交叉连接）。结果数据集将根据连接子句（`emp.deptid`
    等于 `dept.nid`）进行筛选，从而产生另一个数据集。
- en: 'Then, a project operation will be performed (`select new { <data> }`) to create
    an instance of new anonymous type, to add into a collection. The anonymous type
    will be synthesized by the C# compiler during the compile time. The above example
    uses comprehension style syntax and it will be transformed into a lambda expression
    syntax by the C# compiler, before generating the code. When we evaluate comprehension
    queries or mixed mode queries, the C# compiler transforms everything to lambda
    syntax before generating the code. The core algorithm for evaluation of LINQ queries
    are:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将执行一个投影操作（`select new { <data> }`）来创建一个新的匿名类型实例，并将其添加到集合中。匿名类型将由 C# 编译器在编译时合成。上面的示例使用了理解式语法，它将被
    C# 编译器转换为 lambda 表达式语法，然后再生成代码。当我们评估理解式查询或混合模式查询时，C# 编译器将所有内容转换为 lambda 语法，然后再生成代码。LINQ
    查询评估的核心算法是：
- en: Cartesian product (of data sets involved)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笛卡尔积（涉及的数据集）
- en: Restrict or filter (where predicate)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制或过滤（where 谓词）
- en: Order by
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Group operations
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组操作
- en: Projection (technical name for selecting subsets of fields, in a result)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影（选择结果集中字段子集的技术名称）
- en: 'To understand more about the query evaluation process, one can consult a book
    which deals with relational database theory, as this topics warrants another book!
    The LINQ was introduced with C# with version 3.0 of the language and the designers
    of language introduced the following features to the language to facilitate the
    implementation of LINQ. They are:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解查询评估过程，可以查阅一本关于关系数据库理论的书籍，因为这个主题需要另一本书来详细阐述！LINQ 是随着 C# 语言的 3.0 版本一起引入的，语言的设计者向语言中引入了以下特性以促进
    LINQ 的实现。它们是：
- en: '**Lambda expressions and functions**: To facilitate the passing of predicates
    and transformations as parameters to LINQ operator functions'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda 表达式和函数**：为了便于将谓词和转换作为参数传递给 LINQ 操作符函数'
- en: '**Extension methods**: To avoid the syntactic clutter while nesting LINQ operators
    (transformation of nested queries to fluent interface style)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展方法**：为了避免在嵌套 LINQ 操作符（将嵌套查询转换为流畅接口风格）时的语法混乱'
- en: '**Anonymous types**: To allow developers to project the contents of a data
    set to types which are not declared ahead of time by the developers'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名类型**：允许开发者将数据集的内容投影到开发者事先未声明的类型'
- en: '**Type inference**: This feature was mandated because of the difficulty for
    programmers to identify the type of result from a LINQ operations'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型推断**：这个特性是强制性的，因为程序员很难从 LINQ 操作中识别出结果类型'
- en: Try to understand in detail what has been covered in this section. If you are
    able to comprehend what has been dealt here tersely, it can help improve the competence
    as a developer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能详细地理解本节所涵盖的内容。如果你能够简洁地理解这里所讨论的内容，这有助于提高作为开发者的能力。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional programming model and its idioms help a programmer to write better
    code in the many-core architecture of the modern CPUs. C# programming language
    and the .NET platform has incorporated FP constructs into the language to help
    write certain kind of code in a functional manner. The mastery of lambda expressions
    and functions, type inference, expression trees, LINQ, and so on helps structure
    our code better if used judiciously by mixing the OOP and FP codes. Mixing of
    OOP and FP to write code is termed as object/functional programming, and most
    modern day languages like C#, Scala, Java (after version 8), Ruby, and so on support
    this idiom. In the next chapter, we will implement some GoF design patterns using
    object/functional programming, and also pick up some OOP/FP programming idioms
    such as map/reduce.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程模型及其惯用用法有助于程序员在现代多核 CPU 架构中编写更好的代码。C# 编程语言和 .NET 平台将 FP 构造纳入语言中，以帮助以函数式方式编写某些类型的代码。熟练掌握
    lambda 表达式和函数、类型推断、表达式树、LINQ 等特性，如果明智地混合 OOP 和 FP 代码，将有助于更好地构建我们的代码结构。将 OOP 和
    FP 混合起来编写代码被称为对象/函数式编程，并且大多数现代语言如 C#、Scala、Java（从版本 8 开始）、Ruby 等都支持这种惯用用法。在下一章中，我们将使用对象/函数式编程实现一些
    GoF 设计模式，并学习一些 OOP/FP 编程惯用用法，如 map/reduce。
