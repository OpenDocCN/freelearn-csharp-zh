<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-221"><a id="_idTextAnchor220"/>14</h1>
<h1 id="_idParaDest-222"><a id="_idTextAnchor221"/>Creating Your Own Conventions</h1>
<p>Correlation is one of the most important parts of observability. Distributed tracing bring correlation by propagating trace context, allowing us to follow individual operations, and consistent attributes enable correlation across traces and other telemetry signals.</p>
<p>In <a href="B19423_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Best Practices</em>, we talked about the importance of reusing standard attributes and following OpenTelemetry semantic conventions. Sometimes we need to go further and define our own conventions. Here, we’re going to explore how to define custom attributes and conventions and use them across the system.</p>
<p>First, we’ll list properties that should be standardized across the system, and then we’ll explore how to populate them with shared code. Finally, we’ll look at OpenTelemetry’s semantic convention schema and see how it can simplify documenting and validating custom conventions.</p>
<p>In this chapter, you’ll learn how to do the following:</p>
<ul>
<li>Identify and document common attributes and conventions</li>
<li>Share instrumentation and custom conventions across the system</li>
<li>Use OpenTelemetry tooling to create conventions</li>
</ul>
<p>With this, you should be able to create easy-to-use processes and tools to keep custom telemetry and attributes consistent and stable.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor222"/>Technical requirements</h1>
<p>The code for this chapter is available in the book’s repository on GitHub at <a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14</a>.</p>
<p>To run the examples and perform analysis, we’ll need the following tools:</p>
<ul>
<li>.NET SDK 7.0 or later</li>
<li>Docker and <code>docker-compose</code></li>
</ul>
<h1 id="_idParaDest-224"><a id="_idTextAnchor223"/>Defining custom conventions</h1>
<p>There are multiple ways to express even the most basic things. If we take our meme application example from <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and Control Plane</em>, we enriched all spans with the <a id="_idIndexMarker708"/>meme name attribute so that we can find when the meme was uploaded or how frequently it’s accessed.</p>
<p>We chose that approach, but we could instead write a log with the meme name once, and then use slightly more complicated queries to find all traces related to that meme. We could come up with something else, but what’s important is to keep the approach consistent across the system.</p>
<p>Even with a custom attribute added to each span, there are still plenty of things to consider when recording such an attribute:</p>
<ul>
<li><code>meme_name</code>, <code>meme.name</code>, and <code>memeName</code> are different attributes. Unless we document <a id="_idIndexMarker709"/>the exact name and define it as a constant somewhere, someone will eventually use the wrong variation of it.</li>
<li><strong class="bold">Type</strong>: The meme<a id="_idIndexMarker710"/> name is just a string. What if we wanted to capture the size or the image format? We need to document the type and maybe provide helper methods to record attributes so that it’s easier to set them correctly.</li>
<li><code>image/png</code> or as an enumeration?</li>
</ul>
<p>When recording a meme name, we extract it from the uploaded filename, and we need to document what should be recorded on the attribute value (absolute or relative path, filename, with or without extension). If, when writing business logic, we sanitize or escape the meme name, or generate a unique one, we probably want to capture the one used by the business logic. We may also record the original name just once for debugging purposes.</p>
<ul>
<li><strong class="bold">When to populate the attribute</strong>: Document on which metrics, spans, and logs the attribute should be recorded. For example, meme names have high cardinality and do not belong on metrics. The meme name attribute can be recorded on spans and logs, but which ones? In our example in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and Control Plane</em>, we recorded the meme name on all spans and a couple of specific log records.</li>
</ul>
<p>There are other aspects<a id="_idIndexMarker712"/> you might want to document: relationships between spans, event names, whether to record exceptions on spans, attribute cardinality, stability, and so on.</p>
<p>We’ll see how to formally define attributes in the <em class="italic">Using OpenTelemetry schemas and tools</em> section of this chapter. Now, let’s focus on naming.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Naming attributes</h2>
<p>Naming is known to be one of the<a id="_idIndexMarker713"/> hardest problems in computer science.</p>
<p>If we named the meme name attribute <code>document.id</code>, it might precisely match a property in the database schema. However, it would be very generic and have a high chance of collision with another similar concept in the system. People who are not familiar with the internals but analyze business data might have a hard time understanding what <code>document.id</code> represents.</p>
<p><code>meme_name</code> seems to be intuitive, short, and descriptive, and the chances of a collision with something else are low. It seems fine, but we’ll probably have other attributes and should put them into an application-specific or company-specific namespace.</p>
<h3>Namespaces</h3>
<p>Namespaces allow us to set <a id="_idIndexMarker714"/>unique, specific, descriptive, and consistent names.</p>
<p>Since we have called our system <code>memes</code>, let’s use it as the root namespace. This will help us understand that all attributes in this space come from our customizations and are not set by some auto-instrumentation.</p>
<p>This helps us navigate between telemetry and makes it possible to do filtering, redaction, and other post-processing in telemetry pipelines. For example, if we want to remove unknown attributes from logs, we can consider everything in the <code>memes</code> namespace (http, <code>db</code>, and so on) to be known.</p>
<p>We can have nested namespaces. Since we’d like to record <a id="_idIndexMarker715"/>other meme properties, such as size and type, we can end up with the following set of attributes: <code>memes.meme.name</code>, <code>memes.meme.size</code>, and <code>memes.meme.type</code>. We can easily add other properties as we see fit, such as <code>memes.meme.author</code> or <code>memes.meme.description</code>.</p>
<p>While <code>memes.meme</code> might look repetitive, it’ll start to make more sense once we add something such as <code>memes.user.name</code> or <code>memes.tag.description</code>.</p>
<p>The OpenTelemetry naming convention (available at <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md">https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md</a>) uses a dot (<code>.</code>) as a separator between namespaces.</p>
<p>For multi-word namespaces or attributes, OpenTelemetry recommends <code>snake_case</code>: for example, we could introduce <code>memes.meme.creation_date</code>.</p>
<p>Following this convention for our custom attributes allows us to stay consistent across all attributes. It will also reduce the chance of mistakes while writing queries.</p>
<p>Having a schema defined and documented in some form is an essential step. But how can we keep it in sync with the code and ensure all services follow it? One way to do so is by capturing it in code and reusing it across the system.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Sharing common schema and code</h1>
<p>Consistent telemetry reporting applies to <a id="_idIndexMarker716"/>telemetry collection configuration. First, we need to enable a basic layer of instrumentation on all services, which should include resource utilization metrics, traces, and metrics for HTTP, gRPC, or any other RPC protocol used in your system.</p>
<p>We should also configure sampling and resource attributes, add enrichment processors, and set up context propagators.</p>
<p>Individual services should be able to customize configuration to some extent: add more instrumentations, enable custom activity sources and meters, or control log verbosity.</p>
<p>The easiest way to unify configuration is to ship corresponding code as a common library (or a set of them) shared across all the services in your system. Such libraries would define configuration options, provide helper methods to enable telemetry collection, implement common<a id="_idIndexMarker717"/> enrichment processors, declare cross-service events, and so on. Let’s go ahead and implement such a configuration helper.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>Sharing setup code</h2>
<p>In <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and Control Plane</em>, and other chapters where we used meme application, we applied OpenTelemetry configuration individually in each service.</p>
<p>We’d never do this in production <a id="_idIndexMarker718"/>code – it’s hard to keep our configurations, instrumentation options, OpenTelemetry package versions, and anything else in sync.</p>
<p>To fix this, we can start extracting common pieces of instrumentation code into a shared library. Since the configuration can slightly vary from service to service, we’ll need to define some configuration options.</p>
<p>We need are options that would help us to set the service name, specify the sampling rate or strategy, enable additional instrumentations, and more. You can find an example of such options in the <code>MemesTelemetryConfiguration</code> class in the book’s repository.</p>
<p>Then we can declare a helper method that takes care of the OpenTelemetry configuration. Here’s an example of this method:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">OpenTelemetryExtensions.cs</p>
<pre class="source-code">
public static void ConfigureTelemetry(
  this WebApplicationBuilder builder,
  MemesTelemetryConfiguration config)
{
  var resourceBuilder = GetResourceBuilder(config);
  var sampler = GetSampler(config.SamplingStrategy,
    config.SamplingProbability);
  builder.Services.AddOpenTelemetry()
    .WithTracing(builder =&gt; builder
      .SetSampler(sampler)
      .AddProcessor&lt;MemeNameEnrichingProcessor&gt;()
      .SetResourceBuilder(resourceBuilder)
      .AddHttpClientInstrumentation(o =&gt;
        o.ConfigureHttpClientCollection(
          config.RecordHttpExceptions))
      .AddAspNetCoreInstrumentation(o =&gt;
         o.ConfigureAspNetCoreCollection(
           config.RecordHttpExceptions,
           config.AspNetCoreRequestFilter))
      .AddCustomInstrumentations(config.ConfigureTracing)
      .AddOtlpExporter())
  ...
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs</a></p>
<p>All services that use this method <a id="_idIndexMarker719"/>will have the same basic level of instrumentation applied and enriched consistently.</p>
<p>Here’s an example of using this method in the <strong class="bold">storage</strong> service:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">storage/Program.cs</p>
<pre class="source-code">
var config = new MemesTelemetryConfiguration();
builder.Configuration.GetSection("Telemetry").Bind(config);
config.ConfigureTracing = o =&gt; o
  .AddEntityFrameworkCoreInstrumentation();
builder.ConfigureTelemetry(config);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs</a></p>
<p>Here, we read the telemetry <a id="_idIndexMarker720"/>options from the <code>Telemetry</code> section of the ASP.NET Core configuration, which you can populate in any way that works for you.</p>
<p>Then, we add the Entity Framework instrumentation. Only the <strong class="bold">storage</strong> service needs it.</p>
<p class="callout-heading">Note</p>
<p class="callout">Having a central library that enables collection helps to reduce version hell. By having a dependency on it, individual service packages get a transitive dependency on OpenTelemetry packages and should never add them as direct dependencies. Services that need an uncommon instrumentation library would still need to install the corresponding NuGet package.</p>
<p>Now that we have a common setup, let’s see what we can do to help services follow our custom semantic conventions.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>Codifying conventions</h2>
<p>In the previous example, we started <a id="_idIndexMarker721"/>recording the meme name attribute – we enabled <code>MemeNameEnrichingProcessor</code>, which sets the <code>memes.meme.name</code> attribute on each span. Individual services don’t need to do anything to enable it and cannot set the wrong attribute name.</p>
<p>Still, we might need to use the attribute directly in some other parts (for example, on logs), so it’s important to declare the attribute name as a constant and never use a string literal in the code. Here’s an example demonstrating how attribute names can be declared:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">SemanticConventions.cs</p>
<pre class="source-code">
public class SemanticConventions
{
    public const string MemeNameKey = "memes.meme.name";
    public const string MemeSizeKey = "memes.meme.size";
    public const string MemeTypeKey = "memes.meme.type";
    …
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs</a></p>
<p>OpenTelemetry also provides the <code>OpenTelemetry.SemanticConventions</code> NuGet package, which declares common attributes defined in the specification. It might make sense to add a dependency to it when reusing common attributes.</p>
<p>So, we have now <a id="_idIndexMarker722"/>defined constants for the attribute names, and we have a processor that populates the meme name. Can we do more?</p>
<p>We can provide helpers to report common events in a performant and consistent manner. Let’s look at how we can use the high-performance logging we explored in <a href="B19423_08.xhtml#_idTextAnchor131"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Structured and Correlated Logs</em>, to populate our attributes:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">EventService.cs</p>
<pre class="source-code">
private static readonly Action&lt;ILogger, string, string?,
  long?, string, string, Exception&gt; LogDownload =
    LoggerMessage.Define&lt;string, string?,
      long?, string, string&gt;(
    LogLevel.Information,
    new EventId(1),
    $"download {{{SemanticConventions.MemeNameKey}}}
    {{{SemanticConventions.MemeTypeKey}}}
    {{{SemanticConventions.MemeSizeKey}}}
    {{{SemanticConventions.EventNameKey}}}
    {{{SemanticConventions.EventDomainKey}}}");
  …
  public void DownloadMemeEvent(string memeName,
    MemeContentType type,
    long? memeSize) =&gt;
  LogDownload(_logger,
    memeName,
    ContentTypeToString(type),
    memeSize,
    SemanticConventions.DownloadMemeEventName,
    SemanticConventions.MemesEventDomain,
    default!);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs</a></p>
<p>Here, we have <a id="_idIndexMarker723"/>some difficult-to-read code. It defines a log record representing the meme download event by following the OpenTelemetry conventions and our own conventions. We would not want to write this code every time we needed to log something.</p>
<p>Implementing this event once in the common library and making it easy to reuse is the best way to record the event consistently and with a low performance overhead.</p>
<p>Now, anyone can use the <code>DownloadMemeEvent</code> method, as shown in the following example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">StorageService.cs</p>
<pre class="source-code">
_events.DownloadMemeEvent(name, MemeContentType.PNG,
    response.Content.Headers.ContentLength);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs</a></p>
<p>This is easy to use and performant, and there is no need to worry about attributes, their types, or any conventions at all. If attributes are renamed, there is no need to update the service code – it’s all hidden in the shared library.</p>
<p>If we follow this approach, we can define other events and add helper methods to populate attribute groups on metrics and traces.</p>
<p>If we need any custom instrumentations, like we had for gRPC or messaging, we should put them into shared <a id="_idIndexMarker724"/>libraries and apply all the attributes there instead of in the service code.</p>
<p>Separating telemetry-related code from business logic makes them both easier to read and maintain. It also makes telemetry-related code testable and helps us to keep it in sync with documentation. It also becomes easy to enforce conventions with tests and notice during code review when shared code changes something controlled by semantic conventions and breaks them.</p>
<p>Defining semantic conventions in code is sufficient for some applications. Others, which may use different languages or have some other constraints, cannot rely on shared code alone. Either way, telemetry can be used by everyone in the company for business reporting and for any non-technical needs. So, it’s important to document it separately from code.</p>
<p>Let’s see how we can do this using OpenTelemetry tooling.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/>Using OpenTelemetry schemas and tools</h1>
<p>It does not really matter how we<a id="_idIndexMarker725"/> document custom semantic conventions. The goal is to have a consistent and specific convention that’s easy to read and follow. Let’s see how the OpenTelemetry semantic conventions schema may help with this.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>Semantic conventions schema</h2>
<p>So far, when we have talked about semantic conventions, we have referred to Markdown files such as <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md">https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md</a>. These files are the source of truth, but here, we’re<a id="_idIndexMarker726"/> going to take a look at the implementation details behind them.</p>
<p>The tables describing the attributes in these files are usually auto-generated. Attributes are defined in YAML files that follow OpenTelemetry’s semantic convention schema.</p>
<p>YAML files could be shared across different semantic conventions and signals and then consistently written to all Markdown files with a script.</p>
<p>Let’s see how our meme attributes can be defined in a YAML file to get an impression of the schema:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">memes-common.yaml</p>
<pre class="source-code">
groups:
  - id: memes.meme
    type: attribute_group
    brief: "Describes memes attributes."
    <strong class="bold">prefix: memes.meme</strong>
    attributes:
      <strong class="bold">- id: name</strong>
      <strong class="bold">  type: string</strong>
      <strong class="bold">  requirement_level: required</strong>
        brief: 'Unique and sanitized meme name'
        examples: ["this is fine"]</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml</a></p>
<p>Here, we defined the <code>name</code> attribute with a <code>string</code> type inside the <code>memes.meme</code> namespace (defined by the <code>prefix</code> property). It’s a required attribute since, in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and Control Plane</em>, we decided to record the meme name attribute on all the spans.</p>
<p>OpenTelemetry supports several requirement levels:</p>
<ul>
<li><code>required</code>: Any telemetry item that follows this convention must set the attribute.</li>
<li><code>conditionally_required</code>: The attribute must be populated when a condition is met. For example, http.route is only populated when routing is enabled and a route is available.</li>
<li><code>recommended</code>: The <a id="_idIndexMarker727"/>attribute should be populated, but may be removed or disabled. Observability backends and tools should not rely on it being available. This is the default level.</li>
<li><code>opt_in</code>: The attribute is not populated by default, but is known and documented, and it can be added when it’s explicitly enabled.</li>
</ul>
<p>Let’s see how we can define the <code>size</code> attribute:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">memes-common.yaml</p>
<pre class="source-code">
<strong class="bold">- id: size</strong>
<strong class="bold">  type: int</strong>
<strong class="bold">  requirement_level: opt_in</strong>
  brief: 'Meme size in bytes.'
  examples: [49335, 12345]</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml</a></p>
<p>The <code>size</code> attribute has the <code>int</code> type (and maps to <code>int64</code> or <code>long</code>) and an <code>opt-in</code> level as we don’t want to record it on all telemetry by default.</p>
<p>Finally, we can define the <code>type</code> attribute:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">memes-common.yaml</p>
<pre class="source-code">
<strong class="bold">- id: type</strong>
<strong class="bold">  type:</strong>
<strong class="bold">  members:</strong>
<strong class="bold">    - id: png</strong>
<strong class="bold">      value: "png"</strong>
<strong class="bold">      brief: 'PNG image type.'</strong>
<strong class="bold">    - id: jpg</strong>
<strong class="bold">      value: "jpg"</strong>
<strong class="bold">      brief: 'JPG image type.'</strong>
<strong class="bold">    - id: unknown</strong>
<strong class="bold">      value: "unknown"</strong>
<strong class="bold">      brief: 'unknown type.'</strong>
  requirement_level: opt_in
  brief: 'Meme image type.'
  examples: ['png', 'jpg']</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml</a></p>
<p>Here, we define <code>type</code> as an enumeration. Instrumentation must use one of the values defined here or set <code>type</code> to <code>unknown</code>.</p>
<p>I hope your team won’t <a id="_idIndexMarker728"/>spend too much time deciding between JPEG and JPG – either is fine. What’s important is to pick and document one option.</p>
<p>You can find the full schema definition in the OpenTelemetry build tools repository on GitHub (https://github.com/open-telemetry/build-tools/blob/main/semantic-conventions/syntax.md). It also contains the schema definition that your IDE may use to autocomplete and validate schema files.</p>
<p>Now that we have defined a few attributes, let’s use another OpenTelemetry tool to validate the schema<a id="_idIndexMarker729"/> file and generate content in a Markdown file.</p>
<p>If you look at the raw <code>memes.md</code> file in the book repository, it contains documentation with the following annotations:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">memes.md</p>
<pre class="source-code">
&lt;!-- semconv memes.meme --&gt;
...
&lt;!-- endsemconv --&gt;</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md</a></p>
<p>Content in between these lines is auto-generated from the YAML group that has the <code>memes.meme</code> identifier. We can regenerate this content with the following command (make sure to specify the path):</p>
<pre class="console">
chapter14$ docker run \
  -v /path/to/chapter14/semconv:/source \
  -v /path/to/chapter14/semconv:/destination \
  otel/semconvgen:latest \
  -f /source markdown -md /destination</pre>
<p>Here, we use the Markdown generator from the <code>otel/semconvgen</code> image. We mount the <code>source</code> and <code>destination</code> volumes. The generator recursively parses all YAML files found in the <code>source</code> folder and then generates attribute tables in Markdown files available in the <code>destination</code> folder based on the <code>semconv</code> annotations we saw earlier.</p>
<p>The generation is the cherry on top of the cake, and you might not need it initially. Still, if you decide to use OpenTelemetry semantic convention schemas, make sure to use the <code>otel/semconvgen</code> tool to <em class="italic">validate</em> YAML files, which you can do as a part of your CI run; just add the <code>–md-check</code> flag to the previous command.</p>
<p>The tooling also supports generating attribute definitions in code using Jinja templates (https://jinja.palletsprojects.com). All we need is to create a Jinja template for the <code>SemanticConventions.cs</code> file and run the <code>otel/semconvgen</code> generator.</p>
<p>We can also define tracing, metrics, or <a id="_idIndexMarker730"/>event-specific conventions. Let’s do it for events.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/>Defining event conventions</h2>
<p>Meme upload and download <a id="_idIndexMarker731"/>events are important for business reporting. We can’t really expose them as metrics – meme names have high cardinality and we’re interested in finding the most popular ones or measuring other per-meme things.</p>
<p>To avoid breaking business reporting, we need to make sure events are defined precisely enough and are well documented. To achieve this, we can declare an event in the following way:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">memes-events.yaml</p>
<pre class="source-code">
- id: meme.download.event
  <strong class="bold">type: event</strong>
  <strong class="bold">prefix: download_meme</strong>
  brief: "Describes meme download event."
  Attributes:
    - ref: memes.meme.name
    <strong class="bold">- ref: memes.meme.size</strong>
    <strong class="bold">  requirement_level: required</strong>
    - ref: memes.meme.type
      requirement_level: required</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml</a></p>
<p>Here, we declare a group with the <code>event</code> type (previously, we used <code>attribute_group</code>, which is signal agnostic). We provided a prefix (<code>download_name</code>) that documents the event name. We added references to attributes defined previously, but now require the presence of the <code>size</code> and <code>type</code> attributes on these events only.</p>
<p>You might have noticed that the <a id="_idIndexMarker732"/>event name does not contain a namespace – here, we follow the <code>event</code> semantic convention. If you look at the corresponding code snippet for the <code>EventService</code> class, we also record the <code>event.domain</code> attribute, which serves as a namespace.</p>
<p>With this approach, we can define spans or metric conventions that reuse the same common attributes.</p>
<p>These schemas or corresponding Markdown files would define and document the contract between telemetry producers and consumers regardless of the language they use.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/>Summary</h1>
<p>In this chapter, we talked about different ways to keep custom telemetry and attributes consistent across your system. We identified attribute properties to be documented and learned about attribute naming conventions.</p>
<p>Keeping telemetry consistent is a challenge. We explored how to make it easier by sharing common instrumentation code, including OpenTelemetry setup and utility methods that report attributes with the right names and types.</p>
<p>Finally, we learned about the OpenTelemetry semantic conventions schema and tooling, which may help you define, validate, and automate the documentation process for custom conventions.</p>
<p>Defining a common schema for telemetry during the early stages of a project is going to save your organization a lot of time down the road, and now you have the knowledge and tools to do it. In the next chapter, we’ll talk about brownfield systems, where new solutions coexist with legacy ones, and we’ll see how difficult it can be to align different standards and conventions.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/>Questions</h1>
<ol>
<li>It’s likely that alerts, dashboards, and usage reporting depend on custom telemetry and rely on conventions. How would you approach evolving conventions to prevent breaking something critical?</li>
<li>Is it possible to validate that telemetry coming from some service follows defined semantic conventions?</li>
</ol>
</div>
</body></html>