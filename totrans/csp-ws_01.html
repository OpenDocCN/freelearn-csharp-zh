<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-31"><a id="_idTextAnchor032"/>1. Hello C#</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">This chapter introduces you to the basics of C#. You will start by learning about the basics of the .NET Command-Line Interface (CLI) and how to use Visual Studio Code (VS Code) as a basic Integrated Development Environment (IDE). You will then learn about the various C# data types and how to declare variables for these types, before moving on to a section about arithmetic and logical operators. By the end of the chapter, you will know how to handle exceptions and errors and be able to write simple programs in C#.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Introduction</h1>
<p>C# is a programming language created in the early 2000s by a team at Microsoft led by Anders Hejlsberg, who is also among the creators of some other popular languages, such as Delphi and Turbo Pascal, both widely used in the 1990s. Over the last 20 years, C# has grown and evolved, and today it is one of the most widely used programming languages globally, according to Stack Overflow's 2020 insights.</p>
<p>It has its reasons for holding such an honorable place in the tech community. C# allows you to write applications for a wide segment of markets and devices. From the banking industry, with its high-security standards, to e-commerce companies, which hold enormous volumes of transactions, it is a language trusted by companies that need both performance and reliability. Besides that, C# also makes it possible to write web, desktop, mobile, and even IoT applications, allowing you to develop for almost every kind of device.</p>
<p>C# was initially limited to work only on Windows; however, there have been concerted efforts by the C# team over the past few years to make it cross-platform compatible. Today, it can be used with all major OS distributions, namely, Windows, Linux, and macOS. The goal is simple: to develop, build, and run C# anywhere, letting each developer and team choose their most productive or favorite environment.</p>
<p>Another remarkable characteristic of C# is that it is a strongly typed programming language. You will dive into this more deeply in the upcoming sections, and you will see that strong typing enables better data security while programming.</p>
<p>Besides that, C# has become open source over the last few years, with Microsoft as its principal maintainer. This is highly advantageous, as it allows the language to receive continuous improvements from around the globe, with a solid backing company that both promotes and invests in it. C# is also a multi-paradigm language, meaning that you can use it to write software in many programming styles, in a beautiful, concise, and proper manner.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Running and Developing C# with the .NET CLI</h1>
<p>One term you'll hear a lot in the C# world is .NET. It is the foundation of C#, a framework that the language is built on top of. It has both a Software Development Kit (SDK) that allows the language to be developed and a runtime that allows the language to run.</p>
<p>That said, to start developing with C#, you only need to install the .NET SDK. This installation will provide both a compiler and the runtime on the development environment. In this section, you will cover the basic steps of preparing your environment for developing and running C# locally.</p>
<p class="callout-heading">Note</p>
<p class="callout">Please refer to the <em class="italic">Preface</em> of this book for step-by-step instructions on how to download the .NET 6.0 SDK and install it on your machine.</p>
<p>Once the installation of the .NET 6.0 SDK is completed, you will have something called the .NET CLI. This Command-Line Interface (CLI) allows you to create new projects, compile them, and run them with very simple commands that you can run directly from your terminal.</p>
<p>After the installation, run the following command on your favorite terminal:</p>
<pre>dotnet --list-sdks</pre>
<p>You should see an output like this:</p>
<pre>6.0.100 [/usr/local/share/dotnet/sdk]</pre>
<p>This output shows that you have the 6.0.100 version of the SDK installed on your computer. That means you are ready to start developing your applications. If you type <code>dotnet -–help</code>, you will notice that several commands will appear for you as options to run within the CLI. In this section, you will cover the most basic ones that you need to create and run applications: <code>new</code>, <code>build</code>, and <code>run</code>.</p>
<p>The <code>dotnet new</code> command allows you to create a bootstrap project to start developing. The CLI has several built-in templates, which are nothing more than basic bootstraps for various types of applications: web apps, desktop apps, and so on. You must specify two things in the <code>dotnet new</code> command:</p>
<ul>
<li>The template name</li>
<li>The project name</li>
</ul>
<p>The name is passed as an argument, which means you should specify it with a <code>-n</code> or <code>–name</code> flag. The command is as follows:</p>
<pre>dotnet new TYPE -n NAME</pre>
<p>For instance, to create a new console application named <code>MyConsoleApp</code> you can simply type:</p>
<pre>dotnet new console -n MyConsoleApp</pre>
<p>This will generate a new folder with a file named <code>MyConsoleApp.csproj</code>, which is the C# project file that contains all the metadata needed by the compiler to build your project, and some files needed for the application to be built and run.</p>
<p>Next, the <code>dotnet build</code> command allows you to build an application and make it ready to run. This command should be placed only in two locations:</p>
<ul>
<li>A project folder, containing a <code>.csproj</code> file.</li>
<li>A folder containing a <code>.sln</code> file.</li>
</ul>
<p>Solution (<code>.sln</code>) files are files that contain the metadata of one or more project files. They are used to organize multiple project files into single builds.</p>
<p>Finally, the third important command is dotnet <code>run</code>. This command allows you to properly run an application. It can be called without any arguments from the folder that contains the <code>.csproj</code> file of your .NET app, or without passing the project folder with the <code>-–project</code> flag on the CLI. The <code>run</code> command also automatically builds the application prior to the run.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Creating Programs with the CLI and VS Code</h2>
<p>While working through this book, you will use Visual Studio Code (VS Code) as your code editor. It works on all platforms, and you can download the version for your OS at https://code.visualstudio.com/. Although VS Code is not a complete Integrated Development Environment (IDE), it has a lot of extensions that make it a powerful tool to develop and do proper C# coding, regardless of the OS being used.</p>
<p>To properly develop C# code, you will primarily need to install the Microsoft C# extension. It equips VS Code with the ability to do code completion and identify errors and is available at <a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Before proceeding, it is recommended that you install VS Code and the Microsoft C# extension. You can find a step-by-step breakdown of the installation process in the <em class="italic">Preface</em> of this book.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Basic Anatomy of a C# Program</h2>
<p>In order to run, every C# program needs something called an entry point. In C#, the standard entry point for a program is the <code>Main</code> method. Regardless of your program type, whether it is a web application, desktop application, or even a simple console one, the <code>Main</code> method will be the <strong class="bold">entry point</strong> for your C# program. This means that each time an application runs, the runtime searches for this method within your code and executes the code blocks inside it.</p>
<p>This structure is created for you by the CLI, with the <code>new</code> command. A <code>Program.cs</code> file contains a class named <code>Program</code>, with a method named <code>Main</code>, which, in turn, contains a single instruction that will be executed after the program is built and running. You will learn more about methods and classes later, but for now, just know that a class is something that usually contains a set of data and that can perform actions on this data through these <strong class="bold">methods</strong>.</p>
<p>Another important thing to note regarding basic C# concepts is <code>//</code>.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>Exercise 1.01: Creating a Console App that Says "Hello World"</h2>
<p>In this exercise, you will see the CLI commands you learned about in the previous section, as you build your first ever C# program. It will be a simple console app that will print <code>Hello World</code> to the console.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li>Open the VS Code integrated terminal and type the following:<pre>dotnet new console -n Exercise1_01 </pre></li>
</ol>
<p>This command will create a new console application in the <code>Exercise1_01</code> folder.</p>
<ol>
<li value="2">On the command line, type the following:<pre>dotnet run --project Exercise1_01</pre></li>
</ol>
<p>You should see the following output:</p>
<div><div><img alt="Figure 1.1: &quot;Hello World&quot; output on the console " height="618" src="img/B16835_01_01.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.1: "Hello World" output on the console</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/HErU6">https://packt.link/HErU6</a>.</p>
<p>In this exercise, you created the most basic program possible with C#, a console application that prints some text to the prompt. You also learned how to use .NET CLI, which is the mechanism built within the .NET SDK to create and manage .NET projects.</p>
<p>Now proceed to the next section to grasp how top-level statements are written.</p>
<h3 id="_idParaDest-37"><a id="_idTextAnchor038"/>Top-Level Statements</h3>
<p>You must have noticed in <em class="italic">Exercise 1.01</em> that, by default, when you create a console application, you have a <code>Program.cs</code> file that contains the following:</p>
<ul>
<li>A class named <code>Program</code>.</li>
<li>The static void <code>Main</code> keywords.</li>
</ul>
<p>You will learn about classes and methods in detail later, but for now, for the sake of simplicity, you do not need these resources to create and execute programs with C#. The latest version (.NET 6) introduced a feature that makes writing simple programs much easier and less verbose. For instance, consider the following:</p>
<pre>using System;
namespace Exercise1_01
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}</pre>
<p>You can simply replace this snippet with two lines of code, as follows:</p>
<pre>using System;
Console.WriteLine("Hello World!");</pre>
<p>By using such top-level statements, you can write concise programs. You can simply put the statements to be executed at the top of the program. This is also useful for speeding up the learning curve with C#, as you need not worry about advanced concepts upfront. The only thing to look out for here is that the project can have only one file with top-level statements.</p>
<p>That is why in this chapter, you will find that all exercises will use this format, to make things as clear as possible.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>Declaring Variables</h2>
<p>You will now take your first steps in creating your own programs. This section will delve into the concept of variables—what they are and how to use them.</p>
<p>A variable is a name given to a computer memory location that holds some data that may vary. For a variable to exist, it first must be <strong class="bold">declared</strong> with a type and a name. It can also have a value assigned to it. The declaration of a variable can be achieved in a few different ways.</p>
<p>There are some basic considerations regarding naming conventions for variables in C#:</p>
<ul>
<li>The names must be unique, starting with a letter, and should contain only letters, digits, and the underscore character (<code>_</code>). The names can also begin with an underscore character.</li>
<li>The names are case-sensitive; thus, <code>myVariable</code> and <code>MyVariable</code> are different names.</li>
<li>Reserved keywords, such as <code>int</code> or <code>string</code>, cannot be used as names (this is a compiler restriction) unless you put an <code>@</code> symbol in front of the name, such as <code>@int</code> or <code>@string</code>.</li>
</ul>
<p>Variables can be declared in two ways: explicitly and implicitly. Both styles of the declaration have their pros and cons, which you will explore in the next section.</p>
<h3 id="_idParaDest-39"><a id="_idTextAnchor040"/>Declaring Variables Explicitly</h3>
<p>A variable can be declared explicitly by writing both its type and value. Suppose you want to create two variables, <code>a</code> and <code>b</code>, both containing integers. Doing so explicitly would look like this:</p>
<pre>int a = 0;
int b = 0;</pre>
<p>Before a variable is used, it must have a value assigned. Otherwise, the C# compiler will give an error while building your program. The following example illustrates that:</p>
<pre>int a;
int b = a; // The compiler will prompt an error on this line: Use of unassigned local variable</pre>
<p>It is also possible to declare multiple variables in the same line, like in the following snippet, where you are declaring three variables; two hold the value <code>100</code> and one holds the value <code>10</code>:</p>
<pre>int a, b = 100, c = 10;</pre>
<h3 id="_idParaDest-40"><a id="_idTextAnchor041"/>Declaring Variables Implicitly</h3>
<p>Remember that C# is a strongly typed programming language; this means that a variable will always have a type associated with it. It does not matter whether the type is declared implicitly or explicitly. With the <code>var</code> keyword, the C# compiler will infer the variable type based on the value that has been assigned to it.</p>
<p>Consider that you want to create a variable that holds some text using this method. This can be done with the following statement:</p>
<pre>var name = "Elon Musk";</pre>
<p>For storing text in a variable, you should start and end the text with double quotes (<code>"</code>). In the preceding example, by looking at the value that was assigned to <code>name</code>, C# knows that the type this variable holds is a string, even though the type is not mentioned in the statement.</p>
<h3 id="_idParaDest-41"><a id="_idTextAnchor042"/>Explicit versus Implicit Declaration</h3>
<p>Explicit declarations enhance readability with the type declared, and this is one of the main advantages of this technique. On the other hand, they tend to let the code become more verbose, especially when working with some data types (that you will see further ahead), such as <code>Collections</code>. </p>
<p>Essentially, deciding on the style of declaration depends on the personal preferences of the programmer, and may be influenced by the company's guidelines in some cases. In this journey of learning, it is recommended that you pick one that makes your learning path smoother, as there are few substantial differences from a purely technical standpoint.</p>
<p>In the next exercise, you will do this yourself by assigning variables to inputs that come from a user's interaction with a console application, where the user will be asked to input their name. To complete this exercise, you will make use of the following built-in methods that C# provides, which you will be using frequently in your C# journey:</p>
<ul>
<li><code>Console.ReadLine()</code>: This allows you to retrieve a value that the user prompted on the console.</li>
<li><code>Console.WriteLine()</code>: This writes the value passed as an argument as an output to the console.</li>
</ul>
<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Exercise 1.02: Assigning Variables to User Inputs</h2>
<p>In this exercise, you will create an interactive console application. The app should ask you for your name, and once provided, it should display a greeting with your name in it.</p>
<p>To complete this exercise, perform the following steps:</p>
<ol>
<li value="1">Open Command Prompt and type the following:<pre>dotnet new console -n Exercise1_02</pre></li>
</ol>
<p>This command creates a new console application in the <code>Exercise1_02</code> folder.</p>
<ol>
<li value="2">Open the <code>Program.cs</code> file. Paste the following inside the <code>Main</code> method:<pre>Console.WriteLine("Hi! I'm your first Program. What is your name?");
var name = Console.ReadLine();
Console.WriteLine($"Hi {name}, it is very nice to meet you. We have a really fun journey ahead.");</pre></li>
<li>Save the file. On the command line, type the following:<pre>dotnet run --project Exercise1_02</pre></li>
</ol>
<p>This outputs the following:</p>
<pre>Hi! I'm your first Program. What is your name?</pre>
<ol>
<li value="4">Now, type your name into the console and hit <code>Enter</code> on your keyboard. For example, if you type in <code>Mateus</code>, the following will be the output:<pre>Hi! I'm your first Program. What is your name?
Mateus
Hi Mateus, it is very nice to meet you. We have a really fun journey ahead.</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/1fbVH">https://packt.link/1fbVH</a>.</p></li>
</ol>
<p>You are more familiar with what variables are, how to declare them, and how to assign values to them. Now it is time to start talking about what data these variables can store and, more specifically, what types of data there are.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor044"/>Data Types</h1>
<p>In this section, you will talk about the main data types within C# and their functionalities.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Strings</h2>
<p>C# uses the <code>string</code> keyword to identify data that stores text as a sequence of characters. You can declare a string in several ways, as shown in the following snippet. However, when assigning some value to a string variable, you must place the content between a pair of double quotes, as you can see in the last two examples:</p>
<pre>// Declare without initializing.
string message1;
// Initialize to null.
string message2 = null;
// Initialize as an empty string
string message3 = System.String.Empty;
// Will have the same content as the above one
string message4 = "";
// With implicit declaration
var message4 = "A random message"     ;</pre>
<p>One simple but effective technique (that you used in the preceding <em class="italic">Exercise 1.02</em>) is one called string interpolation. With this technique, it is very simple to mix plain text values with variable values, so that the text is combined among these two. You can combine two or more strings by following these steps:</p>
<ol>
<li value="1">Before the initial quotes, insert a <code>$</code> symbol.</li>
<li>Now, inside the strings, place curly brackets and the name of the variable that you want to put into the string. In this case, this is done by putting <code>{name}</code> inside the initial string:<pre>$"Hi {name}, it is very nice to meet you. We have a really fun journey ahead.");</pre></li>
</ol>
<p>Another important fact to remember about strings is that they are immutable. This means that a string object cannot be changed after its creation. This happens because strings in C# are an array of characters. Arrays are data structures that gather objects of the same type and have a fixed length. You will cover arrays in detail in an upcoming section.</p>
<p>In the next exercise, you will explore string immutability.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Exercise 1.03: Checking String Immutability</h2>
<p>In this exercise, you will use two strings to demonstrate that string references are always immutable. Perform the following steps to do so:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<pre>dotnet new console -n Exercise1_03</pre></li>
<li>Open the <code>Program.cs</code> file and create a method with the <code>void</code> return type, which replaces part of a string like so:<pre>static void FormatString(string stringToFormat)
{
stringToFormat.Replace("World", "Mars");
}</pre></li>
</ol>
<p>In the preceding snippet, the <code>Replace</code> function is used to replace the first string (<code>World</code>, in this case) with the second one (<code>Mars</code>).</p>
<ol>
<li value="3">Now, create a method that does the same thing but returns the result instead:<pre>static string FormatReturningString(string stringToFormat)
{
return stringToFormat.Replace("Earth", "Mars");
}</pre></li>
<li>Now insert the following after the previous methods. Here, you create two string variables and observe their behavior after trying to modify them with the methods created previously:<pre>var greetings = "Hello World!";
FormatString(greetings);
Console.WriteLine(greetings);
var anotherGreetings = "Good morning Earth!";
Console.WriteLine(FormatReturningString(anotherGreetings));</pre></li>
<li>Finally, call <code>dotnet run --project Exercise1_03</code> from the command line. You should see the following output on the console:<pre>dotnet run
Hello World!
Good morning Mars!</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/ZoNiw">https://packt.link/ZoNiw</a>.</p></li>
</ol>
<p>With this exercise, you saw the concept of string immutability in action. When you passed a string that was a reference type (<code>Hello World!</code>) as a method argument, it was not modified. That is what happens when you use the <code>FormatString</code> method, which returns <code>void</code>. Due to string immutability, a new string is created but not allocated to any variable, and the original string stays the same. With the second method, it returns a new string, and this string is then printed to the console.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>Comparing Strings</h2>
<p>Even though strings are reference values, when you use the <code>.Equals()</code> method, the equality operator (<code>==</code>), and other operators (such as <code>!=</code>), you are actually comparing the values of the strings, as can be seen in the following example:</p>
<pre>string first = "Hello.";
string second = first;
first = null;</pre>
<p>Now you can compare these values and call <code>Console.WriteLine()</code> to output the result, like so:</p>
<pre>Console.WriteLine(first == second);
Console.WriteLine(string.Equals(first, second));</pre>
<p>Running the preceding code results in the following output:</p>
<pre>False
False</pre>
<p>You get this output because, even though strings are reference types, both the <code>==</code> and <code>.Equals</code> comparisons run against string values. Also, remember that strings are immutable. This means that when you assign <code>second</code> to <code>first</code> and set <code>first</code> as <code>null</code>, a new value is created for <code>first</code> and, therefore, the reference for <code>second</code> does not change.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>Numeric Types</h2>
<p>C# has its numeric types subdivided into two main categories—integral and floating-point type numbers. The integral number types are as follows:</p>
<ul>
<li><code>sbyte</code>: Holds values from -128 to 127</li>
<li><code>short</code>: Holds values from -32,768 to 32,767</li>
<li><code>int</code>: Holds values from -2,147,483,648 to 2,147,483,647</li>
<li><code>long</code>: Holds values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</li>
</ul>
<p>Deciding which type of integral type to use depends on the size of the values you want to store.</p>
<p>All these types are called signed values. This means that they can store both negative and positive numbers. There is also another range of types called unsigned types. Unsigned types are <code>byte</code>, <code>ushort</code>, <code>uint</code>, and <code>ulong</code>. The main difference between them is that signed types can store negative numbers and unsigned types can store only numbers greater than or equal to zero. You will use signed types most of the time, so do not worry about remembering this all at once.</p>
<p>The other category, namely, floating-point types, refers to the types used to store numbers with one or more decimal points. There are three floating-point types in C#:</p>
<ul>
<li><code>float</code>: This occupies four bytes and can store numbers from ± 1.5 x 10−45 to ± 3.4 x 1038 with a precision range of six to nine digits. To declare a float number using <code>var</code>, you can simply append <code>f</code> to the end of the number, like so:<pre>var myFloat = 10f;</pre></li>
<li><code>double</code>: This occupies eight bytes and can store numbers from ± 5.0 × 10−324 to ± 1.7 × 1030 with a precision range of 15 to 17 digits. To declare a double number using var, you can append d to the end of the number, like so:<pre>var myDouble = 10d;</pre></li>
<li><code>decimal</code>: This occupies 16 bytes and can store numbers from ± 1.0 x 10-28 to ± 7.9228 x 1028 with a precision range from 28 to 29 digits. To declare a decimal number using var, you must simply append m to the end of the number, like so:<pre>var myDecimal = 10m;</pre></li>
</ul>
<p>Choosing the floating-point type depends mainly on the degree of precision required. For instance, <code>decimal</code> is mostly used for financial applications that need a very high degree of precision and cannot rely on rounding for accurate calculations. With GPS coordinates, <code>double</code> variables might be appropriate if you want to deal with sub-meter precisions that usually have 10 digits.</p>
<p>Another relevant point to consider when choosing numeric types is performance. The larger the memory space allocated to a variable, the less performant the operations with these variables are. Therefore, if high precision is not a requirement, <code>float</code> variables will be better performers than <code>doubles</code>, which, in turn, will be better performers than decimals.</p>
<p>Here you grasped what variables are and their main types. Now you will perform some basic calculations with them, such as addition, subtraction, and multiplication. This can be done using the arithmetic operators available in C#, such as <code>+</code>, <code>-</code>, <code>/</code>, and <code>*</code>. So, move on to the next exercise where you will create a basic calculator using these operators.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Exercise 1.04: Using the Basic Arithmetic Operators</h2>
<p>In this exercise, you will create a simple calculator that receives two inputs and shows the results between them, based on which arithmetic operation is selected.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<pre>dotnet new console -n Exercise1_04</pre></li>
<li>Navigate to the project folder, open the <code>Program.cs</code> file, and inside the <code>Main</code> method, declare two variables that read the user input, like so:<pre>Console.WriteLine("Type a value for a: ");
var a = int.Parse(Console.ReadLine());
Console.WriteLine("Now type a value for b: ");
var b = int.Parse(Console.ReadLine());</pre></li>
</ol>
<p>The preceding snippet uses the <code>.ReadLine</code> method to read the input. This method, however, gives a <code>string</code>, and you need to evaluate a number. Therefore, the <code>Parse</code> method has been used here. All the numeric types have a method called Parse, which receives a string and converts it into a number.</p>
<ol>
<li value="3">Next, you need to write the output of these basic operators to the console. Add the following code to the <code>Main</code> method:<pre>Console.WriteLine($"The value for a is { a } and for b is { b }");
Console.WriteLine($"Sum: { a + b}");
Console.WriteLine($"Multiplication: { a * b}");
Console.WriteLine($"Subtraction: { a - b}");
Console.WriteLine($"Division: { a / b}"); </pre></li>
<li>Run the program using the <code>dotnet run</code> command, and you should see the following output, if you input <code>10</code> and <code>20</code>, for instance:<pre>Type a value for a:
10
Now type a value for b:
20
The value for a is 10 and b is 20
Sum: 30
Multiplication: 200
Subtraction: -10
Division: 0</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/ldWVv">https://packt.link/ldWVv</a>.</p></li>
</ol>
<p>Thus, you have built a simple calculator app in C# using the arithmetic operators. You also learned about the concept of parsing, which is used to convert strings to numbers. In the next section, you will briefly cover the topic of classes, one of the core concepts of programming in C#.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Classes</h1>
<p>Classes are an integral part of coding in C# and will be covered comprehensively in <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>. This section touches upon the basics of classes so that you can begin using them in your programs.</p>
<p>The reserved <code>class</code> keyword within C# is used when you want to define the type of an object. An object, which can also be called an instance, is nothing more than a block of memory that has been allocated to store information. Given this definition, what a class does is act as a blueprint for an object by having some properties to describe this object and specifying the actions that this object can perform through methods.</p>
<p>For example, consider that you have a class named <code>Person</code>, with two properties, <code>Name</code> and <code>Age</code>, and a method that checks whether <code>Person</code> is a child. Methods are where logic can be placed to perform some action. They can return a value of a certain type or have the special <code>void</code> keyword, which indicates that they do not return anything but just execute some action. You can also have methods calling other methods:</p>
<pre>public class Person
{
	public Person() { }
	public Person(string name, int age)
{
	Name = name;
	Age = age;
}
	public string Name { get; set; }
	public int Age { get; set; }
	public void GetInfo()
{
	Console.WriteLine($"Name: {Name} – IsChild? {IsChild()}");
}
	public bool IsChild()
{
	return Age &lt; 12;
}
}</pre>
<p>One question remains, though. Since classes act as blueprints (or definitions if you prefer), how do you actually allocate memory to store the information defined by a class? This is done through a process called instantiation. When you instantiate an object, you allocate some space in memory for it in a reserved area called the heap. When you assign a variable to an object, you are setting the variable to have the address of this memory space, so that each time you manipulate this variable, it points to and manipulates the data allocated at this memory space. The following is a simple example of instantiation:</p>
<pre>var person = new Person();</pre>
<p>Note that <code>Person</code> has properties that have two magic keywords—<code>get</code> and <code>set</code>. Getters define that a property value can be retrieved, and setters define that a property value can be set.</p>
<p>Another important concept here is the concept of a constructor. A constructor is a method with no return type, usually present at the top level of the class for better readability. It specifies what is needed for an object to be created. By default, a class will always have a parameter-less constructor. If another constructor with parameters is defined, the class will be constrained to only this one. In that case, if you still want to have a parameter-less constructor, you must specify one. This is quite useful, as classes can have multiple constructors.</p>
<p>That said, you can assign values to an object property that has a setter in the following ways:</p>
<ul>
<li>At the time of creation, via its constructor:<pre>var person = new Person("John", 10);</pre></li>
<li>At the time of creation, with direct variable assignment:<pre>var person = new Person() { Name = "John", Age = 10 };</pre></li>
<li>After the object is created, as follows:<pre>var person = new Person();
person.Name = "John";
person.Age = 10;</pre></li>
</ul>
<p>There is a lot more to classes that you will see further on. For now, the main ideas are as follows:</p>
<ul>
<li>Classes are blueprints of objects and can have both properties and methods that describe these objects.</li>
<li>Objects need to be instantiated so that you can perform operations with them.</li>
<li>Classes have one parameter-less constructor by default, but can have many customized ones as required.</li>
<li>Object variables are references that contain the memory address of a special memory space allocated to the object inside a dedicated memory section named the heap.</li>
</ul>
<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Dates</h1>
<p>A date can be represented in C# using the <code>DateTime</code> value type. It is a struct with two static properties called <code>MinValue</code>, which is January 1, 0001 00:00:00, and <code>MaxValue</code>, which is December 31, 9999 11:59:59 P.M. As the names suggest, both these values represent the minimum and maximum dates according to the Gregorian calendar date format. The default value for <code>DateTime</code> objects is <code>MinValue</code>.</p>
<p>It is possible to construct a <code>DateTime</code> variable in various ways. Some of the most common ways are as follows:</p>
<ul>
<li>Assigning the current time as follows:<pre>var now = DateTime.Now;</pre></li>
</ul>
<p>This sets the variable to the current date and time on the calling computer, expressed as the local time.</p>
<pre>var now = DateTime.UtcNow;</pre>
<p>This sets the variable to the current date and time on this computer, expressed as the Coordinated Universal Time (UTC).</p>
<ul>
<li>You can also use constructors for passing days, months, years, hours, minutes, and even seconds and milliseconds.</li>
<li>There is also a special property available for <code>DateTime</code> objects called <code>Ticks</code>. It is a measure of the number of 100 nanoseconds elapsed since <code>DateTime.MinValue</code>. Every time you have an object of this type, you can call the <code>Ticks</code> property to get such a value.</li>
<li>Another special type for dates is the <code>TimeSpan</code> struct. A <code>TimeSpan</code> object represents a time interval as days, hours, minutes, and seconds. It is useful when fetching intervals between dates. You will now see what this looks like in practice.</li>
</ul>
<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Exercise 1.05: Using Date Arithmetic</h2>
<p>In this exercise, you will use the <code>TimeSpan</code> method/struct to calculate the difference between your local time and the UTC time. To complete this exercise, perform the following steps:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<pre>dotnet new console -n Exercise1_05</pre></li>
<li>Open the <code>Program.cs</code> file.</li>
<li>Paste the following inside the <code>Main</code> method and save the file:<pre>Console.WriteLine("Are the local and utc dates equal? {0}", DateTime.Now.Date == DateTime.UtcNow.Date);
Console.WriteLine("\nIf the dates are equal, does it mean that there's no TimeSpan interval between them? {0}",
(DateTime.Now.Date - DateTime.UtcNow.Date) == TimeSpan.Zero);
DateTime localTime = DateTime.Now;
DateTime utcTime = DateTime.UtcNow;
TimeSpan interval = (localTime - utcTime);
Console.WriteLine("\nDifference between the {0} Time and {1} Time: {2}:{3} hours",
    localTime.Kind.ToString(),
    utcTime.Kind.ToString(),
    interval.Hours,
    interval.Minutes);
Console.Write("\nIf we jump two days to the future on {0} we'll be on {1}",
    new DateTime(2020, 12, 31).ToShortDateString(),
    new DateTime(2020, 12, 31).AddDays(2).ToShortDateString());</pre></li>
</ol>
<p>In the preceding snippet, you first checked whether the current local date and UTC dates were equal. Then you checked for the interval between them, if any, using the <code>TimeSpan</code> method. Next, it printed the difference between the local and UTC time and printed the date two days ahead of the current one (<code>31/12/ 2020</code>, in this case).</p>
<ol>
<li value="4">Save the file. On the command line, type the following:<pre>dotnet run --project Exercise1_05</pre></li>
</ol>
<p>You should see an output like the following:</p>
<pre>Are the local and utc dates equal? True
If the dates are equal, does it mean there's no TimeSpan interval between them? True
Difference between the Local Time and Utc Time: 0:0 hours
If we jump two days to the future on 31/12/2020 we'll be on 02/01/2021</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/WIScZ">https://packt.link/WIScZ</a>.</p>
<p>Note that depending on your time zone, you will likely see different output.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Formatting Dates</h2>
<p>It is also possible to format <code>DateTime</code> values to localized strings. That means formatting a <code>DateTime</code> instance according to a special concept within the C# language called a culture, which is a representation of your local time. For instance, dates are represented differently in different countries. Now take a look at the following examples, where dates are outputted in both the format used in France and the format used in the United States:</p>
<pre>var frenchDate = new DateTime(2008, 3, 1, 7, 0, 0);
Console.WriteLine(frenchDate.ToString(System.Globalization.CultureInfo.
  CreateSpecificCulture("fr-FR")));
// Displays 01/03/2008 07:00:00
var usDate = new DateTime(2008, 3, 1, 7, 0, 0);
Console.WriteLine(frenchDate.ToString(System.Globalization.CultureInfo.CreateSpecificCulture("en-US")));
// For en-US culture, displays 3/1/2008 7:00:00 AM</pre>
<p>It is also possible to explicitly define the format you want the date to be output in, as in the following example, where you pass the <code>yyyyMMddTHH:mm:ss</code> value to say that you want the date to be output as year, then month, then day, then hour, then minutes preceded by a colon, and finally, seconds, also preceded by a colon:</p>
<pre>var date1 = new DateTime(2008, 3, 1, 7, 0, 0);
Console.WriteLine(date1.ToString("yyyyMMddTHH:mm:ss"));</pre>
<p>The following output gets displayed:</p>
<pre>     20080301T07:00:00</pre>
<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/>Logical Operators and Boolean Expressions</h1>
<p>You are already familiar with these. Recall that in the preceding exercise, you did the following comparison:</p>
<pre>var now = DateTime.Now.Date == DateTime.UtcNow.Date;</pre>
<p>This output assigns the value <code>true</code> to <code>now</code> if the dates are equal. But as you know, they might not necessarily be the same. Therefore, if the dates are different, a <code>false</code> value will be assigned. These two values are the result of such Boolean expressions and are called Boolean values. That is why the <code>now</code> variable has the type of <code>bool</code>.</p>
<p>Boolean expressions are the base for every logical comparison in every program. Based on these comparisons, a computer can execute a certain behavior in a program. Here are some other examples of Boolean expressions and variable assignments:</p>
<ul>
<li>Assigning the result of a comparison that checks whether <code>a</code> is greater than <code>b</code>:<pre>var basicComparison = a &gt; b;</pre></li>
<li>Assigning the result of a comparison that checks whether <code>b</code> is greater than or equal to <code>a</code>:<pre>bool anotherBasicComparison = b &gt;= a; </pre></li>
<li>Checking whether two strings are equal and assigning the result of this comparison to a variable:<pre>var animal1 = "Leopard";
var animal2 = "Lion";
bool areTheseAnimalsSame = animal1 == animal2;</pre></li>
</ul>
<p>Clearly, the result of the previous comparison would be <code>false</code> and this value will be assigned to the <code>areTheseAnimalsSame</code> variable.</p>
<p>Now that you have learned what Booleans are and how they work, it is time to look at some logical operators you can use to compare Boolean variables and expressions:</p>
<ul>
<li>The <code>&amp;&amp;</code> (AND) operator: This operator will perform an equality comparison. It will return <code>true</code> if both are equal and <code>false</code> if they are not. Consider the following example, where you check whether two strings have the length <code>0</code>:<pre>bool areTheseStringsWithZeroLength = "".Length == 0 &amp;&amp; " ".Length == 0; 
Console.WriteLine(areTheseStringsWithZeroLength);// will return false</pre></li>
<li>The <code>||</code> (OR) operator: This operator will check whether either of the values being compared is <code>true</code>. For example, here you are checking whether at least one of the strings has zero length:<pre>bool isOneOfTheseStringsWithZeroLength = "".Length == 0 || " ".Length == 0;
Console.WriteLine(isOneOfTheseStringsWithZeroLength); // will return true</pre></li>
<li>The <code>!</code> (NOT) operator: This operator takes a Boolean expression or value and negates it; that is, it returns the opposite value. For example, consider the following example, where you negate the result of a comparison that checks whether one of the strings has zero length:<pre>bool isOneOfTheseStringsWithZeroLength = "".Length == 0 || " ".Length == 0; 
bool areYouReallySure = !isOneOfTheseStringsWithZeroLength;
Console.WriteLine(areYouReallySure); // will return false</pre></li>
</ul>
<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Using if-else Statements</h2>
<p>Up till now, you have learned about types, variables, and operators. Now it is time to go into the mechanisms that help you to use these concepts in real-world problems—that is, decision-making statements.</p>
<p>In C#, <code>if-else</code> statements are some of the most popular choices for implementing branching in code, which means telling the code to follow one path if a condition is satisfied, else follow another path. They are logical statements that evaluate a Boolean expression and continue the program's execution based on this evaluation result.</p>
<p>For example, you can use <code>if-else</code> statements to check whether the password entered satisfies certain criteria (such as having at least six characters and one digit). In the next exercise, you will do exactly that, in a simple console application.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Exercise 1.06: Branching with if-else</h2>
<p>In this exercise, you will use <code>if-else</code> statements to write a simple credentials check program. The application should ask the user to enter their username; unless this value is at least six characters in length, the user cannot proceed. Once this condition is met, the user should be asked for a password. The password should also have a minimum of six characters containing at least one digit. Only after both these criteria are met should the program display a success message, such as <code>User successfully registered</code>.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Inside the VS Code integrated terminal, create a new console project called <code>Exercise1_06</code>:<pre>dotnet new console -n Exercise1_06</pre></li>
<li>Inside the <code>Main</code> method, add the following code to ask the user for a username, and assign the value to a variable:<pre>Console.WriteLine("Please type a username. It must have at least 6 characters: ");
var username = Console.ReadLine();</pre></li>
<li>Next, the program needs to check whether the username has more than six characters and if not, write an error message to the console:<pre>if (username.Length &lt; 6)
{
Console.WriteLine($"The username {username} is not valid.");
}</pre></li>
<li>Now, within an <code>else</code> clause, you will continue the verification and ask the user to type a password. Once the user has entered a password, three points need to be checked. The first condition to check is whether the password has at least six characters and then whether there is at least one number. Then, if either of these conditions fails, the console should display an error message; else, it should display a success message. Add the following code for this:<pre>else
{
Console.WriteLine("Now type a 
password. It must have a length of at least 6 characters and also contain a number.");
var password = Console.ReadLine();
     
if (password.Length &lt; 6)
     {
     		Console.WriteLine("The password must have at least 6 characters.");
}
     else if (!password.Any(c =&gt; char.IsDigit©))
     {
     		Console.WriteLine("The password must contain at least one number.");
}
else
     {
             Console.WriteLine("User successfully registered.");
}
}</pre></li>
</ol>
<p>From the preceding snippet, you can see that if the user enters fewer than six characters, an error message is displayed as <code>The password must have at least 6 characters.</code>. If the password doesn't contain a single digit but satisfies the preceding condition, another error message is displayed as <code>The password must contain at least one number.</code>.</p>
<p>Notice the logical condition used for this, which is <code>!password.Any(c =&gt; char.IsDi©(c))</code>. You will learn more about the <code>=&gt;</code> notation in <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>, but for now, you just need to know that this line checks every character in the password and uses the <code>IsDigit</code> function to check whether the character is a digit. This is done for every character, and if no digit is found, the error message is displayed. If all the conditions are met, a success message is displayed as <code>User successfully registered.</code>.</p>
<ol>
<li value="5">Run the program using <code>dotnet run</code>. You should see an output like the following:<pre>Please type a username. It must have at least 6 characters:
thekingjames
Now type a password. It must have at least 6 characters and a number.
James123!"#
User successfully registered</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/3Q7oK">https://packt.link/3Q7oK</a>.</p></li>
</ol>
<p>In this exercise, you worked with if-else branching statements to implement a simple user registration program.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>The Ternary Operator</h2>
<p>Another simple-to-use, yet effective, decision-making operator is the ternary operator. It allows you to set the value of a variable based on a Boolean comparison. For example, consider the following example:</p>
<pre>var gift = person.IsChild() ? "Toy" : "Clothes";</pre>
<p>Here, you are using the <code>?</code> symbol to check whether the Boolean condition placed before it is valid. The compiler runs the <code>IsChild</code> function for the <code>person</code> object. If the method returns <code>true</code>, the first value (before the <code>:</code> symbol) will be assigned to the <code>gift</code> variable. If the method returns <code>false</code>, the second value (after the <code>:</code> symbol) will be assigned to the <code>gift</code> variable.</p>
<p>The ternary operator is simple and makes assignments based on simple Boolean verifications even more concise. You will be using this quite often in your C# journey.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Reference and Value Types</h2>
<p>There are two types of variables in C#, namely, reference types and value types. Variables of value types, such as structs, contain the values themselves, as the name suggests. These values are stored in a memory space called the stack. When a variable of such a type is declared, specific memory space is allocated to store this value, as illustrated in the following figure:</p>
<div><div><img alt="Figure 1.2: Memory allocation for a value type variable " height="224" src="img/B16835_01_02.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.2: Memory allocation for a value type variable</p>
<p>Here, the value of the variable, which is <code>5</code>, is stored in memory at the location <code>0x100</code> in the RAM. The built-in value types for C# are <code>bool</code>, <code>byte</code>, <code>char</code>, <code>decimal</code>, <code>double</code>, <code>enum</code>, <code>float</code>, <code>int</code>, <code>long</code>, <code>sbyte</code>, <code>short</code>, <code>struct</code>, <code>uint</code>, <code>ulong</code>, and <code>ushort</code>.</p>
<p>The scenario for reference type variables is different, though. The three main reference types you need to know about in this chapter are <code>string</code>, array, and <code>class</code>. When a new reference type variable is assigned, what is stored in memory is not the value itself, but instead a memory address where the value gets allocated. For example, consider the following diagram:</p>
<div><div><img alt="Figure 1.3: Memory allocation for a reference type variable " height="236" src="img/B16835_01_03.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.3: Memory allocation for a reference type variable</p>
<p>Here, instead of the value of the string variable (<code>Hello</code>), the address where it is allocated (<code>0x100</code>) is stored in memory. For brevity, you will not dive deep into this topic, but it is important to know the following points:</p>
<ul>
<li>When value type variables are passed as parameters or assigned as the value of another variable, the .NET runtime copies the value of the variable to the other object. This means that the original variable is not affected by any changes made in the newer and subsequent variables, as the values were literally copied from one place to another.</li>
<li>When reference type variables are passed as parameters or assigned as the value of another variable, .NET passes the heap memory address instead of the value. This means that every subsequent change made in this variable inside a method will be reflected outside.</li>
</ul>
<p>For instance, consider the following code, which deals with integers. Here, you declare an <code>int</code> variable named <code>a</code> and assign the value <code>100</code> to it. Later, you create another <code>int</code> variable named <code>b</code> and assign the value of <code>a</code> to it. Finally, you modify <code>b</code>, to be incremented by <code>100</code>:</p>
<pre>using System;
int a = 100;
Console.WriteLine($"Original value of a: {a}");
int b = a;
Console.WriteLine($"Original value of b: {b}");
b = b + 100;
Console.WriteLine($"Value of a after modifying b: {a}");
Console.WriteLine($"Value of b after modifying b: {b}");</pre>
<p>The values of <code>a</code> and <code>b</code> will be displayed in the following output:</p>
<pre>Original value of a: 100
Original value of b: 100
Value of a after modifying b: 100
Value of b after modifying b: 200</pre>
<p>In this example, the value from <code>a</code> was copied into <code>b</code>. From this point, any other modification you do on <code>b</code> will reflect changes only in <code>b</code> and <code>a</code> will continue to have its original value.</p>
<p>Now, what if you pass reference types as method arguments? Consider the following program. Here, you have a class named <code>Car</code> with two properties—<code>Name</code> and <code>GearType</code>. Inside the program is a method called <code>UpgradeGearType</code> that receives an object of the <code>Car</code> type and changes its <code>GearType</code> to <code>Automatic</code>:</p>
<pre>using System;
var car = new Car();
car.Name = "Super Brand New Car";
car.GearType = "Manual";
Console.WriteLine($"This is your current configuration for the car {car.Name}: Gea–Type - {car.GearType}");
UpgradeGearType(car);
Console.WriteLine($"You have upgraded your car {car.Name} for the GearType {car.GearType}");
void UpgradeGearType(Car car)
{
    car.GearType = "Automatic";
}
class Car
{
    public string Name { get; set; }
    public string GearType { get; set; }
}</pre>
<p>After you create a <code>Car</code> <code>UpgradeGearType()</code> method, the output will be as the follows:</p>
<pre>This is your current configuration for the car Super Brand New Car: GearType – Manual
You have upgraded your car Super Brand New Car for the GearType Automatic</pre>
<p>Thus, you see that if you pass an <code>car</code> in this case) as an argument to a method (<code>UpgradeGearType</code> in this example), every change made inside this <strong class="bold">object</strong> is reflected after and outside the method call. This is because reference types refer to a specific location in memory.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Exercise 1.07: Grasping Value and Reference Equality </h2>
<p>In this exercise, you will see how equality comparison is different for value types and reference types. Perform the following steps to do so:</p>
<ol>
<li value="1">In VS Code, open the integrated terminal and type the following:<pre>dotnet new console -n Exercise1_07</pre></li>
<li>Open the <code>Program.cs</code> file. In the same file, create a struct named <code>GoldenRetriever</code> with a <code>Name</code> property, as follows:<pre>struct GoldenRetriever
{
    public string Name { get; set; }
}</pre></li>
<li>Still in the same file, create one more class named <code>BorderCollie</code> with a similar <code>Name</code> property:<pre>class BorderCollie
{
    public string Name { get; set; }
}</pre></li>
<li>One final class must be created, a class named <code>Bernese</code>, also having the <code>Name</code> property, but with an extra override of the native <code>Equals</code> method:<pre>class Bernese
{
    public string Name { get; set; }
    public override bool Equals(object obj)
    {
        if (obj is Bernese borderCollie &amp;&amp; obj != null)
        {
            return this.Name == borderCollie.Name;
        }
        return false;
    }
}</pre></li>
</ol>
<p>Here, the <code>this</code> keyword is used to refer to the current <code>borderCollie</code> class.</p>
<ol>
<li value="5">Finally, in the <code>Program.cs</code> file, you will create some objects for these types. Note that since you are using <strong class="bold">top-level statements</strong>, these declarations should be above the class and the struct declarations:<pre>        var aGolden = new GoldenRetriever() { Name = "Aspen" };
        var anotherGolden = new GoldenRetriever() { Name = "Aspen" };
        var aBorder = new BorderCollie() { Name = "Aspen" };
        var anotherBorder = new BorderCollie() { Name = "Aspen" };
        var aBernese = new Bernese() { Name = "Aspen" };
        var anotherBernese = new Bernese() { Name = "Aspen" };</pre></li>
<li>Now, right after the previous declarations, compare these values using the <code>Equals</code> method and assign the result to some variables:<pre>var goldenComparison = aGolden.Equals(anotherGolden) ? "These Golden Retrievers have the same name." : "These Goldens have different names.";
var borderComparison = aBorder.Equals(anotherBorder) ? "These Border Collies have the same name." : "These Border Collies have different names.";
var berneseComparison = aBernese.Equals(anotherBernese) ? "These Bernese dogs have the same name." : "These Bernese dogs have different names.";</pre></li>
<li>Finally, print the comparison results to the console with the following:<pre>          Console.WriteLine(goldenComparison);
          Console.WriteLine(borderComparison);
          Console.WriteLine(berneseComparison);</pre></li>
<li>Run the program from the command line using <code>dotnet run</code> and you will see the following output:<pre>These Golden Retrievers have the same name.
These Border Collies have different names.
These Bernese dogs have the same name.</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/xcWN9">https://packt.link/xcWN9</a>.</p></li>
</ol>
<p>As mentioned earlier, structs are value types. Therefore, when two objects of the same struct are compared with <code>Equals</code>, .NET internally checks all the struct properties. If those properties have equal values, then <code>true</code> is returned. With <code>Golden Retrievers</code>, for instance, if you had a <code>FamilyName</code> property and this property was different between the two objects, the result of the equality comparison would be <code>false</code>.</p>
<p>For classes and all other reference types, the equality comparison is quite different. By default, object reference is checked on equality comparison. If the references are different (and they will be, unless the two variables are assigned to the same object), the equality comparison will return <code>false</code>. This explains the result you see for <code>Border Collies</code> in the example that the references were different for the two instances.</p>
<p>However, there is a method that can be implemented in reference types called Equals. Given two objects, the <code>Equals</code> method can be used for comparison following the logic placed inside the method. That is exactly what happened with the Bernese dogs example.</p>
<h3 id="_idParaDest-59"><a id="_idTextAnchor060"/>Default Value Types</h3>
<p>Now that you have dealt with value and reference types, you will briefly explore the default value types. In C#, every type has a default value, as specified in the following table:</p>
<div><div><img alt="Figure 1.4: Default value types table " height="450" src="img/B16835_01_04.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.4: Default value types table</p>
<p>These default values can be assigned to a variable using the <code>default</code> keyword. To use this word in a variable declaration, you must explicitly declare the variable type before its name. For example, consider the following snippet, where you are assigning the <code>default</code> value to two <code>int</code> variables:</p>
<pre>int a = default;
int b = default;</pre>
<p>Both <code>a</code> and <code>b</code> will be assigned the value <code>0</code> in this case. Note that it is not possible to use <code>var</code> in this case. This is because, for implicitly declared variables, the compiler needs a value assigned to the variable in order to infer its type. So, the following snippet will lead to an error because no type was set, either through an explicit declaration or by variable assignment:</p>
<pre>var a = default;
var b = default;</pre>
<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Enhancing Decision Making with the switch Statement</h2>
<p>The <code>switch</code> statement is often used as an alternative to the if-else construct if a single expression is to be tested against three or more conditions, that is, when you want to select one of many code sections to be executed, such as the following:</p>
<pre>switch (matchingExpression) 
{
  case firstCondition:
    // code section
    break;
  case secondCondition:
    // code section
    break;
  case thirdCondition:
    // code section
    break;
  default:
    // code section
    break;
}</pre>
<p>The matching expression should return a value that is of one of the following types: <code>char</code>, <code>string</code>, <code>bool</code>, <code>numbers</code>, <code>enum</code>, and <code>object</code>. This value will then be evaluated within one of the matching case clauses or within the default clause if it does not match any prior clause.</p>
<p>It is important to say that only one <code>switch</code> section in a <code>switch</code> statement will be executed. C# doesn't allow execution to continue from one <code>switch</code> section to the next. However, a <code>switch</code> statement does not know how to stop by itself. You can either use the <code>break</code> keyword if you only wish to execute something without returning or return something if that is the case.</p>
<p>Also, the <code>default</code> keyword on a <code>switch</code> statement is where the execution goes if none of the other options are matched. In the next exercise, you will use a <code>switch</code> statement to create a restaurant menu app.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Exercise 1.08: Using switch to Order Food</h2>
<p>In this exercise, you will create a console app that lets the user select from a menu of food items available at a restaurant. The app should display an acknowledgment receipt for the order. You will use the <code>switch</code> statement to implement the logic. </p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Create a new console project called <code>Exercise1_08</code>.</li>
<li>Now, create an <code>System.Text.StringBuilder</code>. This is a class that helps build strings in many ways. Here, you are building strings line by line so that they can be properly displayed on the console:<pre>var menuBuilder = new System.Text.StringBuilder();
menuBuilder.AppendLine("Welcome to the Burger Joint. ");
menuBuilder.AppendLine(string.Empty);
menuBuilder.AppendLine("1) Burgers and Fries - 5 USD");
menuBuilder.AppendLine("2) Cheeseburger - 7 USD");
menuBuilder.AppendLine("3) Double-cheeseburger - 9 USD");
menuBuilder.AppendLine("4) Coke - 2 USD");
menuBuilder.AppendLine(string.Empty);
menuBuilder.AppendLine("Note that every burger option comes with fries and ketchup!");</pre></li>
<li>Display the menu on the console and ask the user to choose one of the options:<pre>Console.WriteLine(menuBuilder.ToString());
Console.WriteLine("Please type one of the following options to order:");</pre></li>
<li>Read the key that the user presses and assign it to a variable with the <code>Console.ReadKey()</code> method. This method works similarly to <code>ReadLine()</code>, which you have used before, with the difference that it reads the key that is immediately pressed after calling the method. Add the following code for this:<pre>var option = Console.ReadKey();</pre></li>
<li>Now it is time to use the <code>switch</code> statement. Use <code>option.KeyChar.ToString()</code> as the matching expression of the <code>switch</code> clause here. Keys <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code> should result in orders accepted for <code>burgers</code>, <code>cheeseburgers</code>, <code>double cheeseburgers</code>, and <code>Coke</code>, respectively:<pre>switch (option.KeyChar.ToString())
{
    case "1":
        {
            Console.WriteLine("\nAlright, some burgers on the go. Please pay the cashier.");
            break;
        }
    case "2":
        {
            Console.WriteLine("\nThank you for ordering cheeseburgers. Please pay the cashier.");
            break;
        }
    case "3":
        {
            Console.WriteLine("\nThank you for ordering double cheeseburgers, hope you enjoy them. Please pay the cashier!");</pre></li>
</ol>
<p>Any other input, however, should be considered invalid and a message gets displayed, letting you know you have selected an invalid option:</p>
<pre>            break;
        }
    case "4":
        {
            Console.WriteLine("\nThank you for ordering Coke. Please pay the cashier.");
            break;
        }
    default:
        {
            Console.WriteLine("\nSorry, you chose an invalid option.");
            break;
        }
}</pre>
<ol>
<li value="6">Finally, run the program with <code>dotnet run --project Exercise1_08</code> and interact with the console to see the possible outputs. For example, if you type <code>1</code>, you should see an output like the following:<pre>Welcome to the Burger Joint. 
1) Burgers and Fries – 5 USD
2) Cheeseburger – 7 USD
3) Double-cheeseburger – 9 USD
4) Coke – 2 USD
Note that every burger option comes with fries and ketchup!
Please type one of the follow options to order:
1
Alright, some burgers on the go! Please pay on the following cashier!</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/x1Mvn">https://packt.link/x1Mvn</a>.</p></li>
</ol>
<p>Similarly, you should get the output for the other options as well. You have learned about branching statements in C#. There is another type of statement that you will use often while programming using C#, called iteration statements. The next section covers this topic in detail.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Iteration Statements</h2>
<p>Iteration statements, also called loops, are types of statements that are useful in the real world, as you often need to continuously repeat some logical execution in your applications <code>while</code> or <code>until</code> some condition is met, such as operating with a number that must be incremented until a certain value. C# offers numerous ways of implementing such iterations, and in this section, you will examine each of these in detail.</p>
<h3 id="_idParaDest-63"><a id="_idTextAnchor064"/>while</h3>
<p>The first iteration statement you will consider is the <code>while</code> statement. This statement allows a C# program to execute a set of instructions while a certain Boolean expression is evaluated to be <code>true</code>. It has one of the most basic structures. Consider the following snippet:</p>
<pre>int i = 0;
while (i &lt; 10)
{
Console.WriteLine(i);
i = i +1;
}</pre>
<p>The preceding snippet shows how you can use the <code>while</code> statement. Note that the <code>while</code> keyword is followed by a pair of brackets enclosing a logical condition; in this case, the condition is that the value of <code>i</code> must be less than <code>10</code>. The code written inside the curly braces will be executed until this condition is <code>true</code>.</p>
<p>Thus, the preceding code will print the value of <code>i</code>, starting with <code>0</code>, up to <code>10</code>. This is fairly simplistic code; in the next exercise, you will use the <code>while</code> statement for something a little more complex, such as checking whether a number entered by you is a prime number.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Exercise 1.09: Checking Whether a Number is Prime with a while Loop</h2>
<p>In this exercise, you will use a <code>while</code> loop to check whether a number you enter is prime. To do so, the <code>while</code> loop will check whether the counter is less than or equal to the integer result of the division of the number by <code>2</code>. When this condition is satisfied, you check whether the remainder of the division of the number by the counter is <code>0</code>. If not, you increment the counter and continue until the loop condition is not met. If it is met, it means the number is not <code>false</code> and the loop can stop.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Inside the VS Code integrated terminal, create a new console project called <code>Exercise1_09</code>.</li>
<li>Inside the <code>Program.cs</code> file, create the following method, which will perform the logic you introduced at the beginning of the exercise:<pre>static bool IsPrime(int number)
{
if (number ==0 || number ==1) return false;
bool isPrime = true;
int counter = 2;
while (counter &lt;= Math.Sqrt(number))
     {
     		if (number % counter == 0)
           {
           	isPrime = false;
                break;
}
counter++;
}
     return isPrime;
}</pre></li>
<li>Now, input a number, so you can check whether it is prime:<pre>Console.Write("Enter a number to check whether it is Prime: ");
var input = int.Parse(Console.ReadLine());</pre></li>
<li>Now, check whether the number is prime and print the result:<pre>Console.WriteLine($"{input} is prime? {IsPrime(input)}.");</pre></li>
<li>Finally, on the VS Code integrated terminal, call <code>dotnet run --project Exercise1_09</code> and interact with the program. For example, try entering <code>29</code> as an input:<pre>Enter a number to check whether it is Prime:
29
29 is prime? True</pre></li>
</ol>
<p>As expected, the result for <code>29</code> is <code>true</code> since it is a prime number.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/5oNg5">https://packt.link/5oNg5</a>.</p>
<p>The preceding exercise aimed to show you the simple structure of a <code>while</code> loop with some more complex logic. It checks a number (named <code>input</code>) and prints whether it is a prime number. Here, you have seen the <code>break</code> keyword used again to stop program execution. Now proceed to learn about jump statements.</p>
<h3 id="_idParaDest-65"><a id="_idTextAnchor066"/>Jump Statements</h3>
<p>There are some other important keywords used within loops that are worth mentioning as well. These keywords are called jump statements and are used to transfer program executions to another part. For instance, you could rewrite the <code>IsPrime</code> method as follows:</p>
<pre>static bool IsPrimeWithContinue(int number)
        {
        if (number == 0 || number ==1) return false;
            bool isPrime = true;
            int counter = 2;
            while (counter &lt;= Math.Sqrt(number))
            {
                if (number % counter != 0)
                {
                    counter++;
                    continue;
                }
                isPrime = false;
                break;
            }
            return isPrime;
        }</pre>
<p>Here, you have inverted the logical check. Instead of checking whether the remainder is zero and then breaking the program execution, you have checked that the remainder is not zero and, if so, have used the <code>continue</code> statement to pass the execution to the next iteration.</p>
<p>Now look at how you can rewrite this using another special keyword, <code>goto</code>:</p>
<pre>static bool IsPrimeWithGoTo(int number)
        {
        if (number == 0 || number ==1) return false;
bool isPrime = true;
            int counter = 2;
            while (counter &lt;= Math.Sqrt(number))
            {
                if (number % counter == 0)
                {
                    isPrime = false;
                    goto isNotAPrime; 
                }
                counter++;
            }
            isNotAPrime:
            return isPrime;
        }</pre>
<p>The <code>goto</code> keyword can be used to jump from one part of the code to another one defined by what is called a label. In this case, the label was named <code>isNotAPrime</code>. Finally, take a look at one last way of writing this logic:</p>
<pre>static bool IsPrimeWithReturn(int number)
        {
        if (number == 0 || number ==1) return false;
            int counter = 2;
            while (counter &lt;= Math.Sqrt(number))
            {
                if (number % counter == 0)
                {
                    return false;
                }
                counter ++;
            }
            return true;
        }</pre>
<p>Now, instead of using <code>break</code> or <code>continue</code> to stop the program execution, you simply use <code>return</code> to break the loop execution since the result that you were looking for was already found.</p>
<h3 id="_idParaDest-66"><a id="_idTextAnchor067"/>do-while</h3>
<p>The <code>do-while</code> loop is like the previous one, but with one subtle difference: it executes the logic at least once, while a simple <code>while</code> statement may never be executed if the condition is not met at the first execution. It has the following structure:</p>
<pre>int t = 0;
do
{
    Console.WriteLine(t);
    t++;
} while (t &lt; 5);</pre>
<p>In this example, you write the value of <code>t</code>, starting from <code>0</code>, and keep incrementing it while it is smaller than <code>5</code>. Before jumping into the next type of loop, learn about a new concept called arrays.</p>
<h3 id="_idParaDest-67"><a id="_idTextAnchor068"/>Arrays</h3>
<p>An array is a data structure used to store many objects of the same type. For instance, the following example is a variable declared as an array of integer numbers:</p>
<pre>int[] numbers = { 1, 2, 3, 4, 5 };</pre>
<p>The first important thing to note about arrays is that they have a fixed capacity. This means that an array will have the length defined at the time of its creation and this length cannot change. The length can be determined in various ways. In the preceding example, the length is inferred by counting the number of objects in the array. However, another way of creating an array is like this:</p>
<pre>var numbers = new int[5];</pre>
<p>Here, you are creating an array that has the capacity of <code>5</code> integers, but you do not specify any value for the array elements. When an array of any data type is created without adding elements to it, the default values for that value type are set for each position of the array. For example, consider the following figure:</p>
<div><div><img alt="Figure 1.5: Value type array with no index assigned " height="131" src="img/B16835_01_05.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.5: Value type array with no index assigned</p>
<p>The preceding figure shows that when you create an integer array of five elements, without assigning a value to any element, the array is automatically filled with the default value at every position. In this case, the default value is <code>0</code>. Now consider the following figure:</p>
<div><div><img alt="Figure 1.6: Reference type array with fixed size and only one index assigned " height="293" src="img/B16835_01_06.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 1.6: Reference type array with fixed size and only one index assigned</p>
<p>In the preceding example, you have created an array of five objects and assigned the <code>"Hello"</code> string value to the element at index <code>1</code>. The other positions of the array are automatically assigned the default value for objects, which is <code>null</code>.</p>
<p>Finally, it is worth noting that all arrays have indexes, which refers to the positions of the individual array elements. The first position will always have an index <code>0</code>. Thus, the positions in an array of size <code>n</code> can be specified from index <code>0</code> to <code>n-1</code>. Therefore, if you call <code>numbers[2]</code>, this means that you are trying to access the element in position <code>2</code> inside the numbers array.</p>
<h3 id="_idParaDest-68"><a id="_idTextAnchor069"/>for Loops</h3>
<p>A <code>for</code> loop executes a set of instructions while a Boolean expression matches a specified condition. Just like <code>while</code> loops, jump statements can be used to stop a loop execution. It has the following structure:</p>
<pre>for (initializer; condition; iterator)
{
	[statements]
}</pre>
<p>The initializer statement is executed before the loop starts. It is used to declare and assign a local variable that will be used only inside the scope of the loop.</p>
<p>But in more complex scenarios, it can be used to combine other statement expressions as well. The condition specifies a Boolean condition that indicates when the loop should either continue or exit. The iterator is usually used to increment or decrement the variable created in the initializer section. Take the following example, where a <code>for</code> loop is used to print the elements of an integer array:</p>
<pre>int[] array = { 1, 2, 3, 4, 5 };
for (int j = 0; j &lt; array.Length - 1; j++)
{
Console.WriteLine(array[j]);
}</pre>
<p>In this example, an initializer variable, <code>j</code>, has been created that is assigned <code>0</code> initially. The <code>for</code> loop will keep executing while <code>j</code> is smaller than the array length minus <code>1</code> (remember that indexes always start at <code>0</code>). After each iteration, the value of <code>j</code> is incremented by <code>1</code>. In this way, the <code>for</code> loop goes through the entire array and performs the given action, that is, printing the value of the current array element.</p>
<p>C# also allows the usage of <strong class="bold">nested loops</strong>, that is, a <strong class="bold">loop within a loop</strong>, as you will see in the next exercise.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Exercise 1.10: Ordering an Array Using Bubble Sort</h2>
<p>In this exercise, you will execute one of the simplest sorting algorithms. Bubble sort consists of going through every pair of elements inside an array and swapping them if they are unordered. In the end, the expectation is to have an array ordered in ascending order. You will use nested <code>for</code> loops to implement this algorithm.</p>
<p>To begin with, the array to be sorted should be passed as a parameter to this method. For each element of this array, if the current element is greater than the next, their positions should be swapped. This swap occurs by storing the value of the next element in a temporary variable, assigning the value of the current element to the next element, and finally, setting the value of the current element with the temporary value stored. Once the first element is compared to all others, a comparison starts for the second element and so on, till finally, the array is sorted.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">Create a new console project using the following command:<pre>dotnet new console -n Exercise1_10</pre></li>
<li>Inside the <code>Program.cs</code> file, create the method to implement the sorting algorithm. Add the following code:<pre>static int[] BubbleSort(int[] array)
{
    int temp;
    // Iterate over the array
    for (int j = 0; j &lt; array.Length - 1; j++)
    {
        // If the last j elements are already ordered, skip them
        for (int i = 0; i &lt; array.Length - j - 1; i++)
        {
            if (array[i] &gt; array[i + 1])
            {
                temp = array[i + 1];
                array[i + 1] = array[i];
                array[i] = temp;
            }
        }
    }
    return array;
}</pre></li>
<li>Now create an <strong class="bold">array</strong> with some numbers, as follows:<pre>int[] randomNumbers = { 123, 22, 53, 91, 787, 0, -23, 5 };</pre></li>
<li>Call the <code>BubbleSort</code> method, passing the array as an argument, and assign the result to a variable, as follows:<pre>int[] sortedArray = BubbleSort(randomNumbers);</pre></li>
<li>Finally, you need to print the message that the array was sorted. To do so, iterate over it, printing the array elements:<pre>Console.WriteLine("Sorted:");
for (int i = 0; i &lt; sortedArray.Length; i++)
{
    Console.Write(sortedArray[i] + " ");
}</pre></li>
<li>Run the program with the <code>dotnet run --project Exercise1_10</code> command. You should see the following output on your screen:<pre>Sorted:
-23 0 5 22 53 91 123 787</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cJs8y">https://packt.link/cJs8y</a>.</p></li>
</ol>
<p>In this exercise, you used the two concepts learned in the last two sections: arrays and for loops. You manipulated arrays, accessing their values through indexes, and used for loops to move through these indexes.</p>
<p>There is another way to go through every element of an array or <code>foreach</code> statements. You will explore this in the following section.</p>
<h3 id="_idParaDest-70"><a id="_idTextAnchor071"/>foreach Statements</h3>
<p>A <code>foreach</code> statement executes a set of instructions for each element of a collection. Just like a <code>for</code> loop, the <code>break</code>, <code>continue</code>, <code>goto</code>, and <code>return</code> keywords can also be used with <code>foreach</code> statements. Consider the following example, in which you iterate over every element of an array and write it to the console as the output:</p>
<pre>var items = new int[] { 1, 2, 3, 4, 5 };
foreach (int element in items)
{
Console.WriteLine(element);
}</pre>
<p>The preceding snippet prints the numbers from <code>1</code> to <code>5</code> to the console. You can use <code>foreach</code> statements with much more than arrays; they can also be used with lists, collections, and spans, which are other data structures that will be covered in later chapters.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>File Handling</h2>
<p>So far, you have been creating programs that interact mostly with CPU and memory. This section will focus on I/O operations, that is, input and output operations, on the physical disk. A great example of this type of operation is file handling.</p>
<p>C# has several classes that help you perform I/O operations. Some of these are as follows:</p>
<ul>
<li><code>File</code>: This class provides methods for the manipulation of files, that is, reading, writing, creating, deleting, copying, and moving files on the disk.</li>
<li><code>Directory</code>: Like the <code>File</code> class, this class includes methods to create, move, and enumerate directories and subdirectories on the disk.</li>
<li><code>Path</code>: This provides utilities to deal with absolute and relative paths of files and directories on the disk. A relative path is always related to some path inside the current directory where the application is being executed, and an absolute path refers to an absolute location inside the hard drive.</li>
<li><code>DriveInfo</code>: This provides information about a disk drive, such as <code>Name</code>, <code>DriveType</code>, <code>VolumeLabel</code>, and <code>DriveFormat</code>.</li>
</ul>
<p>You already know that files are mostly some sets of data located somewhere in a hard drive that can be opened for reading or writing by some program. When you open a file in a C# application, your program reads the file as a sequence of bytes through a communication channel. This communication channel is called a stream. Streams can be of two types:</p>
<ul>
<li>The input streams are used for reading operations.</li>
<li>The output streams are used for writing operations.</li>
</ul>
<p>The <code>Stream</code> class is an abstract class in C# that enables common operations regarding this byte flow. For file handling on a hard disk, you will use the <code>FileStream</code> class, designed specifically for this purpose. The following are two important properties of this class: <code>FileAccess</code> and <code>FileMode</code>.</p>
<h3 id="_idParaDest-72"><a id="_idTextAnchor073"/>FileAccess</h3>
<p>This is an <code>enum</code> that provides you with options to choose a level of access when opening a specified file:</p>
<ul>
<li><code>Read</code>: This opens a file in read-only mode.</li>
<li><code>ReadWrite</code>: This opens a file in read and write mode.</li>
<li><code>Write</code>: This opens a file in write-only mode. This is rarely used, as you usually do some reading along with the writing.</li>
</ul>
<h3 id="_idParaDest-73"><a id="_idTextAnchor074"/>FileMode</h3>
<p>This is an <code>enum</code> that specifies the operations that can be performed on a file. It should be used along with the access mode as some modes only work with some levels of access. Take a look at the options, as follows:</p>
<ul>
<li><code>Append</code>: Use this when you want to add content at the end of the file. If the file does not exist, a new one will be created. For this operation, the file must have write permission; otherwise, any attempt to read fails and throws a <code>NotSupportedException</code> exception. Exceptions are an important concept that will be covered later in this chapter.</li>
<li><code>Create</code>: Use this to create a new file or overwrite an existing one. For this option, too, write permission is required. In Windows, if the file exists but is hidden, an <code>UnauthorizedAccessException</code> exception is thrown.</li>
<li><code>CreateNew</code>: This is like <code>Create</code> but is used to create new files and also requires write permission. However, if the file already exists, an <code>IOException</code> exception is thrown.</li>
<li><code>Open</code>: As the name suggests, this mode is used to open a file. The file must have read or read and write permissions. If the file does not exist, a <code>FileNotFoundException</code> exception is thrown.</li>
<li><code>OpenOrCreate</code>: This is like <code>Open</code>, except it creates a new file if it does not already exist.</li>
</ul>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Exercise 1.11: Reading Content from Text Files</h2>
<p>In this exercise, you will read text from a Comma-Separated Values (CSV) file. CSV files simply contain data represented by strings and separated either by colons or semicolons.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Open Command Prompt and type the following:<pre>dotnet new console -n Exercise1_11</pre></li>
<li>At the <code>Exercise1_11</code> project folder location in your computer, create a file named <code>products.csv</code> and paste the following content inside it:<pre>Mo<a id="_idTextAnchor076"/>del;Memory;Storage;USB Ports;Screen;Condition;Price USD
Macbook Pro Mid 2012;8GB;500GB HDD;USB 2.0x2;13" screen;Refurbished;400
Macbook Pro Mid 2014;8GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;750
Macbook Pro Late 2019;16GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;1250</pre></li>
<li>Open the <code>Program.cs</code> file and replace its contents with the following:<pre>using System;
using System.IO;
using System.Threading.Tasks;
namespace Exercise1_11
{
    public class Program
    {
        public static async Task Main()
        {
        using (var fileStream = new FileStream("products.csv", FileMode.Open, FileAccess.Read))
        {
            using (var reader = new StreamReader(fileStream))
            {
                var content = await reader.ReadToEndAsync();
                var lines = content.Split(Environment.NewLine);
                foreach (var line in lines)
                {
                    Console.WriteLine(line);
                }
            }
        }
        }
    }
}</pre></li>
<li>Call <code>dotnet run</code> in Command Prompt and you will get an output that is the same as the contents of the CSV file you have created.<p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/5flid">https://packt.link/5flid</a>.</p></li>
</ol>
<p>This exercise has some pretty interesting outcomes, which you are going to learn step by step. First, you opened a file using the <code>FileStream</code> class. This allows you to start streaming bytes from a file with two special properties, namely, <code>FileMode</code> and <code>FileAccess</code>. It will return a <code>StreamReader</code> class. This class enables you to read these bytes as text characters.</p>
<p>Notice also that your <code>Main</code> method changed from <code>void</code> to <code>async</code> Task. Additionally, the <code>await</code> keyword has been used, which is used for asynchronous operations. You will learn more about these topics in upcoming chapters. For now, you only need to know that an async operation is something that does not block the program execution. This means that you can output lines as they are being read; that is, you do not have to wait for all of them to be read.</p>
<p>In the next section, learn about the special keyword that handles files, databases, and network connections.</p>
<h3 id="_idParaDest-75"><a id="_idTextAnchor077"/>Disposable Objects</h3>
<p>Another special thing about the preceding exercise was the <code>using</code> keyword. It is a keyword used to clean up unmanaged resources from memory. These resources are special objects that handle some operational system resources, such as files, databases, and network connections. They are called <strong class="bold">special</strong> because they do what is called I/O operations; that is, they interact with the real resources of the machine, such as network and hard drives, not just with memory spaces.</p>
<p>The memory used by objects in C# is handled by something called the garbage collector. By default, C# handles the memory space in the stack and the heap. The only types of objects that do not perform this cleanup are called unmanaged objects.</p>
<p>Cleaning these objects from memory means that the resources will be free to be used by another process in the computer. That means a file can be handled by another one, a database connection is free to be used again by a connection pool, and so on. Those types of resources are called disposable resources. Every time you deal with a disposable resource, you can use the <code>using</code> keyword when creating an object. Then, the compiler knows that when the <code>using</code> statement closes, it can automatically free these resources.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Exercise 1.12: Writing to a Text File</h2>
<p>In this exercise, you will write some text into a CSV file, again using the <code>FileStream</code> class.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Open the VS Code integrated terminal and type the following:<pre>dotnet new console -n Exercise1_12</pre></li>
<li>At a preferred location on your computer, copy the <code>products.csv</code> file from the previous exercise and paste it into this exercise's folder.</li>
<li>In <code>Program.cs</code>, create a method named <code>ReadFile</code> that will receive a <code>FileStream</code> file and iterate over the file lines to output the result to the console:<pre>static async Task ReadFile(FileStream fileStream)
    {
        using (var reader = new StreamReader(fileStream))
        {
            var content = await reader.ReadToEndAsync();
            var lines = content.Split(Environment.NewLine);
            foreach (var line in lines)
            {
                Console.WriteLine(line);
            }
        }
    }</pre></li>
<li>Now, in your program, open the <code>products.csv</code> file with <code>StreamWriter</code> and add some more information to it, as follows:<pre>        using (var file = new StreamWriter("products.csv", append: true))
        {
            file.Write("\nOne more macbook without details.");
        }</pre></li>
<li>Finally, read the contents of the file after modification:<pre>using (var fileStream = new FileStream("products.csv", FileMode.Open,
            FileAccess.Read))
        {
            await ReadFile(fileStream);
        }</pre></li>
<li>Call <code>dotnet run --project Exercise1_12</code> in the VS Code integrated terminal and you will be able to see the contents of the CSV file you just created, in addition to the line you just appended:<pre>Model;Memory;Storage;USB Ports;Screen;Condition;Price USD
Macbook Pro Mid 2012;8GB;500GB HDD;USB 2.0x2;13" screen;Refurbished;400
Macbook Pro Mid 2014;8GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;750
Macbook Pro Late 2019;16GB;512GB SSD;USB 3.0x3;15" screen;Refurbished;1250
One more macbook without details.</pre></li>
</ol>
<p>Note that for each run, the program will append a new line, so you will see more lines being added.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/dUk2z">https://packt.link/dUk2z</a>.</p>
<p>Sometimes your program will fail to execute at some point and may not provide an output. Such an instance is called an exception error. The next section details all about such an error.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Exceptions</h2>
<p>Exceptions indicate that a program has failed to execute at some point for some reason and can be raised by either the code itself or the .NET runtime. Usually, an exception is a severe failure and can even terminate your program's execution. Fortunately, C# provides a special way of handling exceptions, which is <code>try/catch</code> blocks:</p>
<pre>try
{
// some logic that might throw an exception
}
catch
{
// error handling
}</pre>
<p>Inside the <code>try</code> clause, you call the code that might throw an exception, and inside the <code>catch</code> clause, you can treat the exception that was raised. For instance, consider the following example:</p>
<pre>double Divide(int a, int b) =&gt; a/b;</pre>
<p>This method takes two integers and returns the result of a division between them. However, what will happen if <code>b</code> is <code>0</code>? In such a case, the runtime will throw <code>System.DivideByZeroException</code>, indicating that it is not possible to execute the division. How could you handle this exception in a real-world program? You will explore this in the next exercise.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor080"/>Exercise 1.13: Handling Invalid User Inputs with try/catch</h2>
<p>In this exercise, you will create a console app that takes two inputs from you, divides the first number by the second one, and outputs the result. If you enter an invalid character, the app should throw an exception, and all of this should be handled inside the program logic.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Inside the VS Code integrated terminal, create a new console app called <code>Exercise1_13</code>.</li>
<li>Create the following method inside the <code>Program.cs</code> file:<pre>static double Divide(int a, int b)
{
    return a / b;
}</pre></li>
<li>Now, create a Boolean variable to indicate whether the division was properly executed. Assign <code>false</code> to it as its initial value:<pre>bool divisionExecuted = false;</pre></li>
<li>Write a <code>while</code> loop that will check whether the division happened successfully. If it did, the program should terminate. If not, the program should prompt you to input valid data and perform the division again. Add the following code to do this:<pre>while (!divisionExecuted)
{
    try
    {
        Console.WriteLine("Please input a number");
        var a = int.Parse(Console.ReadLine());
        Console.WriteLine("Please input another number");
        var b = int.Parse(Console.ReadLine());
        var result = Divide(a, b);
        Console.WriteLine($"Result: {result}");
        divisionExecuted = true;
    }
    catch (System.FormatException)
    {
        Console.WriteLine("You did not input a number. Let's start again ... \n");
        continue;
    }
    catch (System.DivideByZeroException)
    {
        Console.WriteLine("Tried to divide by zero. Let's start again ... \n");
        continue;
    }
}</pre></li>
<li>Finally, execute the program using the <code>dotnet run</code> command and interact with the console. Try to insert strings instead of numbers and see what output you get. Look at the following output as an example:<pre>Please input a number
5
Please input another number
0
Tried to divide by zero. Let's start again …
Please input a number
5
Please input another number
s
You did not input a number. Let's start again …
Please input a number
5
Please input another number
1
Result: 5</pre><p class="callout-heading">Note</p><p class="callout">You can find the code used for this exercise at <a href="https://packt.link/EVsrJ">https://packt.link/EVsrJ</a>.</p></li>
</ol>
<p>In this exercise, you handled two types of exceptions that are as follows:</p>
<ul>
<li>The <code>int.Parse(string str)</code> method throws <code>System.FormatException</code> if it is not possible to convert the <code>string</code> variable into an integer.</li>
<li>The <code>double Divide(int a, int b)</code> method throws <code>System.DivideByZeroException</code> if b is 0.</li>
</ul>
<p>Now that you have seen how exceptions are handled, it is important to note a rule of thumb that will help you in your C# journey, which is that <em class="italic">you should only catch what you can or what you need to handle</em>. There are only a few situations where exception handling is really needed, as follows:</p>
<ul>
<li>When you want to <strong class="bold">mask</strong> an exception, that is, catch it and pretend that nothing happened. This is known as exception suppression. That should take place when the exception that is thrown does not impact the flow of your program.</li>
<li>When you want to control your program's execution flow to perform some alternate actions, as you did in the preceding exercise</li>
<li>When you want to catch a type of exception to throw it as another type. For instance, when communicating with your web API, you might see an exception of type <code>HttpException</code> that indicates that the destination is unreachable. You could make use of a custom exception here, such as <code>IntegrationException</code>, to indicate more clearly that it happened in a part of your application that performs some integrations with external APIs.</li>
</ul>
<p>The <code>throw</code> keyword can also be used to intentionally stop the program execution flow in certain cases. For example, consider that you are creating a <code>Person</code> object and that the <code>Name</code> property should not be <code>null</code> at the time of creation. You can enforce on this class a <code>System.ArgumentException</code> or <code>System.ArgumentNullException</code>, as in the following snippet, which uses <code>ArgumentNullException</code> to do so:</p>
<pre>class Person
{
Person(string name)
     {
if (string.IsNullOrWhiteSpace(name)) throw new ArgumentNullException(nameof(name));
Name = name;
     }
    String Name { get ; set; }
}</pre>
<p>Here, if the value of the <code>name</code> argument is <code>null</code> or if you only enter space characters, <code>ArgumentNullException</code> is thrown, and the program does not execute successfully. The null/white space condition is checked with the help of the <code>IsNullOrWhiteSpace</code> function, which can be used for string variables.</p>
<p>Now it's time to practice all that you learned in the previous sections through an activity.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>Activity 1.01: Creating a Guessing Game</h2>
<p>To complete this activity, you need to create a guessing game using the concepts you have learned about and practiced so far in this chapter. In this game, first, a random number from one to 10 must be generated, not to be output to the console. The console should then prompt the user to input a number and then guess which random number has been generated, and the user should get a maximum of five chances. </p>
<p>Upon every incorrect input, a warning message should be displayed, letting the user know how many chances they have left, and if all five chances are exhausted with incorrect guesses, the program terminates. However, once the user guesses correctly, a success message should be displayed, before the program terminates.</p>
<p>The following steps will help you complete this activity:</p>
<ol>
<li value="1">Create a variable called <code>numberToBeGuessed</code> that is assigned to a random number within C#. You can use the following snippet to do so:<pre>new Random().Next(0, 10)</pre></li>
</ol>
<p>This generates a random number for you, between <code>0</code> and <code>10</code>. You could replace <code>10</code> with a higher number if you wanted to make the game a little more difficult, or with a smaller number to make it easier, but for this activity, you will use <code>10</code> as the maximum value.</p>
<ol>
<li value="2">Create a variable called <code>remainingChances</code> that will store the remaining number of chances that the user has.</li>
<li>Create a <code>numberFound</code> variable and assign a <code>false</code> value to it.</li>
<li>Now, create a <code>while</code> loop that will execute while there are still some chances remaining. Within this loop, add code to output the number of chances remaining, until the correct guess is made. Then, create a variable called <code>number</code> that will receive the <code>number</code> variable is the correct guess, and assign the value <code>true</code> to the <code>numberFound</code> variable if so. If not, the number of remaining chances should be reduced by <code>1</code>.</li>
<li>Finally, add code to inform users whether they have guessed the number correctly. You can output something such as <code>Congrats! You've guessed the number with {remainingChanges} chances left!</code> if they guessed correctly. If they ran out of chances, output <code>You're out of chances. The number was {numberToBeGuessed}.</code>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p></li>
</ol>
<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Summary</h1>
<p>This chapter gave you an overview of the fundamentals of C# and what it looks like to write programs with it. You explored everything from the variable declaration, data types, and basic arithmetic and logical operators to file and exception handling. You also explored how C# allocates memory while dealing with value and reference types.</p>
<p>In the exercises and activities in this chapter, you were able to solve some real-world problems and think of solutions that can be implemented with this language and its resources. You learned how to prompt for user inputs in console apps, how to handle files within a system, and finally, how to deal with unexpected inputs through exception handling. </p>
<p>The next chapter will cover the essentials of Object-oriented programming, diving deeper into the concept of classes and objects. You will also learn about the importance of writing clean, concise code that is easy to maintain, and the principles you can follow for writing such code.</p>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div>
</body></html>