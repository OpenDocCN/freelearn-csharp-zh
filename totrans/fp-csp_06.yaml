- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Higher-Order Functions and Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into higher-order functions and delegates in C#.
    These concepts are crucial in functional programming and will help you write more
    flexible and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions are simply functions that can take other functions as
    arguments or return a function. This might sound complex, but don’t worry; we’ll
    break it down with clear examples and explanations. Higher-order functions are
    a key part of functional programming, allowing you to write code that’s both more
    concise and more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegates in C# are closely related to higher-order functions. They are like
    variables for methods, allowing you to pass methods as arguments or store them
    as values. This chapter will help you understand how to use delegates to implement
    higher-order functions in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates, actions, funcs, and predicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks, events, and anonymous methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harnessing LINQ methods as higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study – putting it all together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices and common pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In keeping with the tradition of our previous chapters, we’ll start this one
    with a brief self-evaluation. Below are three tasks designed to test your understanding
    of the concepts that will be discussed in this chapter. If you hesitate or struggle
    with these tasks, I recommend that you pay close attention to this chapter. However,
    if you find them easy, it might be a good opportunity to focus on areas where
    your knowledge isn’t as strong. So, let’s look at the tasks now.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Sorting function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that uses a higher-order function to sort a list of towers in
    Steve’s game based on their damage output. The sorting function should be passed
    as a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Task 2 – Customized calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a method that takes an `Action` and a list of enemies. The `Action` should
    perform a calculation on each enemy’s health and print the result. Test your method
    using several different `Action`s, such as calculating damage taken from different
    tower types.
  prefs: []
  type: TYPE_NORMAL
- en: Task 3 – Comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement a method that uses a `Func` delegate to compare two towers based on
    their range. The method should return the tower with the longer range.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, a higher-order function is simply a function that
    does at least one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes one or more functions as parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function as a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, you heard it right! Higher-order functions treat functions as data, to
    be passed around like any other value. This leads to an unprecedented level of
    abstraction and code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a video management system in a YouTube-like platform, where efficiently
    handling a large collection of videos is crucial. Instead of writing separate
    functions for each type of video filtering, we can utilize higher-order functions
    for a more elegant and reusable solution. A higher-order function can abstract
    the filtering logic, making the code more modular and maintainable. Here’s a simplified
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this system, we have a collection of `Video` objects. We want to filter these
    videos based on different criteria such as visibility, length, or genre. To achieve
    this, we create a higher-order function called `FilterVideos`. This function takes
    a collection of videos and returns another function. The returned function is
    capable of filtering the videos based on a provided predicate – a function that
    defines the filtering criteria. This design allows us to easily create various
    filters without duplicating the filtering logic, thereby enhancing code reuse
    and readability.
  prefs: []
  type: TYPE_NORMAL
- en: The power of higher-order functions in functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-order functions are a cornerstone of functional programming, offering
    robustness and flexibility. Their ability to treat functions as data, and the
    resulting abstraction and versatility, can be seen in various facets of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability of higher-order functions to abstract and encapsulate behaviors
    is unparalleled, leading to significant code reuse. For instance, consider a scenario
    in a mobile tower defense game where we need various types of unit transformations.
    Instead of repeating transformation logic, we can abstract this through a higher-order
    function. Here’s an illustrative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `CreateTransformation` is a higher-order function that returns
    a new function, encapsulating the transformation behavior. It promotes code reuse
    and abstraction by providing a flexible way to apply different transformations
    to game units.
  prefs: []
  type: TYPE_NORMAL
- en: Creating versatile code with fewer errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-order functions also contribute to writing generic and versatile code,
    leading to fewer errors. By encapsulating a generic behavior, these functions
    reduce the amount of code written, which is then more frequently tested and less
    prone to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function for applying effects to units in a tower defense game.
    Using a higher-order function, we can pass different effects as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ApplyEffect` allows for various effects to be applied to game units,
    simplifying the code base and reducing potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting a more declarative coding style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Higher-order functions foster a declarative style of coding. You describe what
    you want to achieve rather than how to achieve it, making code more readable and
    maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: In the game effect example, we declaratively specify that we want to apply an
    effect to a unit. The specifics of how the effect is applied are abstracted within
    the `ApplyEffect` function.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, higher-order functions in functional programming are invaluable.
    They enable code reuse, reduce errors, and support a declarative coding style,
    making them a powerful tool in any programmer’s toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates, actions, funcs, and predicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegates are essentially type-safe function pointers, holding references to
    functions. This type of safety is crucial as it ensures that the function’s signature
    aligns with the delegate’s defined signature. Delegates enable methods to be passed
    as parameters, returned from functions, and stored in data structures, making
    them indispensable for event handling and other dynamic functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s apply the concept of delegates to a book publishing system. Imagine we
    need to notify different departments when a new book is published.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define a delegate matching the notification function’s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class to manage book publishing that accepts a delegate in its
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any function that matches the delegate’s signature can be passed into
    `PublishBook` and will be called when a new book is published:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, any function that matches the `BookPublishedNotification` delegate’s
    signature can be passed to `PublishBook` and will be invoked when a book is published.
    This demonstrates the flexibility and dynamism of delegates in a practical scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In functional programming, `Actions` are a type of delegate that does not return
    a value. They are ideal for executing methods that perform actions but do not
    need to return a result. This simplicity makes `Actions` a versatile tool in various
    programming scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a mobile tower defense game where certain events, such as spawning
    enemies and triggering effects, do not require a return value. We can use an `Action`
    delegate to handle these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `OnEnemySpawned` is an `Action` delegate used to notify when
    an enemy is spawned. The simplicity of `Action` delegates allows for clean and
    clear event handling in the game’s logic.
  prefs: []
  type: TYPE_NORMAL
- en: Funcs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Funcs`, another kind of built-in delegate, are used when a return value is
    needed. They can have between 0 and 16 input parameters, with the last parameter
    type always being the return type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the same tower defense game, imagine we need a function to
    calculate the score based on various game parameters. This is where `Funcs` become
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CalculateScore` is a `Func` delegate, allowing for a flexible and customizable
    way to calculate the game’s score based on dynamic gameplay factors. `Funcs` provide
    a powerful way to define operations with return values, enhancing the flexibility
    and reusability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Predicate<T>` is a delegate that represents a method containing a set of criteria
    and checks whether the passed parameter meets those criteria. A predicate delegate
    method must take one input parameter and return a `bool` value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a YouTube-like video management system, we might use `Predicate<Video>`
    to filter videos based on certain criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `GetVideosMatching` takes a `Predicate<Video>` delegate to
    filter videos. The method iterates through the list of videos and adds those meeting
    the criteria defined by the predicate to the result list. It could be written
    as a one-liner using `Where`, but using `yield return` makes it more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, summarizing all we’ve learned about delegates, actions, funcs, and predicates,
    we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delegates**: The foundational elements, allowing methods to be referenced
    and passed around, vital to creating higher-order functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Specialized delegates for methods that perform actions but don’t
    return values, simplifying task encapsulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Funcs**: Delegates that return a result, useful for computations and transformations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predicates**: A form of func always returning a Boolean, standardizing condition
    checks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These constructs collectively can enhance our programming, enabling code reuse,
    higher abstraction, and a flexible, functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue with even more exciting constructs next.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks, events, and anonymous methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callbacks are a pivotal concept in asynchronous and event-driven programming.
    They are essentially delegates that point to a method, allowing it to be called
    at a later time. This facilitates non-blocking code execution, crucial for responsive
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a book publishing system where we need to perform actions such as sending
    notifications after a book is published. Here, a callback can notify other parts
    of the system once the publishing process is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the callback is invoked after a book is published, providing
    a flexible and decoupled way of handling post-publishing processes.
  prefs: []
  type: TYPE_NORMAL
- en: The role of delegates in events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Events, built on the publisher-subscriber model, are another powerful application
    of delegates. They allow objects to notify others about occurrences of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book publishing system can be further enhanced by using events, providing
    a more robust and flexible mechanism for notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this version, `OnBookPublished` is an event that subscribers can listen to.
    When a book is published, the event is raised, and all subscribed methods are
    invoked. This model enhances modularity and reduces coupling between the publishing
    logic and its subsequent actions.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anonymous methods are methods that are not bound to a specific name. They are
    defined using the `delegate` keyword and can be used to create instances of a
    delegate. Anonymous methods provide a way to define methods in place where they
    are called, making your code more concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple anonymous method that filters a list of video objects
    based on a specific criterion, such as videos that are longer than a certain duration.
    We’ll use an anonymous method with the `FindAll` method to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `delegate(Video video) {...}` is an anonymous method used to
    define the criteria for the `FindAll` method, filtering videos based on their
    duration. This demonstrates how anonymous methods can be employed in practical
    scenarios such as filtering data in a video management system.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging delegates to create callbacks, handle events, and define anonymous
    methods, we gain a powerful set of tools that allow us to write more flexible
    and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing LINQ methods as higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Language Integrated Query** (**LINQ**) in C# integrates query capabilities
    into the language, functioning primarily through extension methods. These methods,
    adhering to functional programming principles, allow for concise and expressive
    data manipulation. We’ll explore how LINQ can be effectively used in different
    systems for data filtering, transformation, and aggregation.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a video management system, we might need to filter videos based on their
    view count. Using the `Where` method, we can easily achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Data transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a publishing system, converting book titles to uppercase for a uniform catalog
    display can be done using the `Select` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Data aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a mobile tower defense game, calculating the average damage of all towers
    can be efficiently done using the `Average` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These examples showcase the power of LINQ as higher-order functions, demonstrating
    how they can be used to handle complex data operations in various real-world applications,
    making code more readable, maintainable, and enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we’ll bring together all the elements we’ve discussed so far: higher-order
    functions, delegates, actions, funcs, predicates, and LINQ methods. We’ll provide
    a comprehensive, real-world example and analyze the code, step by step.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we are developing a mobile tower defense game. This game involves managing
    towers, handling enemy waves, and upgrading tower capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an outline of the classes we’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Tower` class here represents the basic building block of the game – the
    towers. Each tower has a type, a damage level, and a status indicating whether
    it has been upgraded. This class is a cornerstone for the game’s mechanics, as
    different towers might have various effects and strategies associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Game` class acts as a central hub for managing the game’s logic. It contains
    a list of all towers in the game. The class demonstrates advanced functional programming
    techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FilterTowers` method is a quintessential example of using higher-order
    functions in a real-world application. By accepting a `Func<Tower, bool>` as a
    predicate, it provides a flexible way to filter towers based on dynamic criteria,
    such as damage level, range, or upgrade status. This method makes use of LINQ,
    showcasing its power in simplifying data manipulation tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TowerUpgraded` event, coupled with the `UpgradeTower` method, demonstrates
    the use of actions and delegates. This event-driven approach allows for reactive
    programming, where different parts of the game can respond to changes in tower
    states, such as triggering animations, sounds, or game logic updates when a tower
    is upgraded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step-by-step walk-through and analysis of the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s add some logic to our methods and write the code that uses them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FilterTowers` method uses a predicate (a `Func` that returns a `bool`) to
    select towers based on specific criteria, illustrating higher-order functions
    and LINQ:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach allows for dynamic tower filtering, adapting to various game scenarios
    and player strategies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TowerUpgraded` event demonstrates how delegates facilitate event handling
    in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This mechanism is crucial for notifying different parts of the game about tower
    upgrades and maintaining game state consistency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Interacting with the game**: Finally, let’s see how a user might interact
    with the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this snippet, we see the practical application of the game’s functional programming
    features. From filtering towers based on damage to handling tower upgrades, the
    code is concise, expressive, and effective.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This case study demonstrates the use of predicates, events, delegates, and higher-order
    functions in a practical scenario. It showcases how functional programming principles
    can enhance the development and operation of a complex mobile game, leading to
    more efficient, expressive, and powerful programming. The integration of these
    concepts provides a solid foundation for building engaging and robust game mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and common pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section takes a closer look at best practices when working with higher-order
    functions, delegates, actions, funcs, predicates, and LINQ. We’ll also discuss
    common mistakes that developers make and offer solutions on how to avoid these
    pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices to use while working with higher-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim for stateless functions**: For consistency and predictability, strive
    to ensure that the functions you pass as arguments are stateless, meaning they
    don’t rely on or change the state of anything outside themselves. This makes them
    more predictable and less prone to side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embrace immutability**: One of the core principles of functional programming
    is immutability. When passing objects to your higher-order functions, consider
    whether they can be made immutable to ensure that the function doesn’t alter their
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use descriptive names**: As you are passing around functions, it’s easy to
    lose track of what each one does. Therefore, use descriptive names for your functions
    and parameters to improve readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the common pitfalls are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderBy`, `Reverse`, and `Count`, may be costly. Always measure the performance
    of your queries and consider alternative approaches if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ignoring type safety with delegates**: While delegates are powerful, they
    can also bypass type safety if not used with care. Always ensure the delegate
    signature matches the method it points to avoid runtime errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NullReferenceException`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Misuse of anonymous functions**: Anonymous functions can lead to cleaner
    code, but they can also hide complexity and make code harder to test. If an anonymous
    function is more than a few lines long, or if it’s complex enough to require testing
    on its own, it should probably be a named function instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these best practices and avoiding common mistakes, you can write
    clean, efficient, and maintainable code, harnessing the power of functional programming
    constructs to the fullest.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The theory and concepts are only half the learning journey. Now, it’s time to
    get your hands dirty with some practical exercises. This chapter provides a series
    of challenging problems to test your understanding of the concepts learned and
    to reinforce them. Following each problem, you’ll find a proposed solution with
    detailed explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program that uses a higher-order function to sort a list of towers in
    Steve’s game based on their damage output. The sorting function should be passed
    as a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a method that takes an `Action` and a list of enemies. The `Action` should
    perform a calculation on each enemy’s health and print the result. Test your method
    using several different `Action`s, such as calculating damage taken from different
    tower types.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement a method that uses a `Func` delegate to compare two towers based on
    their range. The method should return the tower with the longer range.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve implemented a sorting function for towers using a delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This solution creates a `CompareTowers` delegate that takes two `Tower` objects
    and returns an `int`. The `SortTowers` method then uses this delegate to sort
    the list of towers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For enemy health calculations, Steve created this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This solution iterates over a list of enemies and applies the passed action
    to each.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a solution to the third problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This solution uses a `Func` delegate to compare the ranges of two towers and
    returns the longer-range one.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, while these solutions work, there may be other equally valid approaches.
    These exercises are about reinforcing the concepts learned and exploring different
    ways to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude this chapter on higher-order functions and delegates in the
    context of functional programming in C#, let’s pause to reflect on the key concepts
    we’ve delved into and anticipate what’s next on our journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Higher-order functions**: These functions, capable of receiving other functions
    as parameters or returning them, are foundational in promoting code reusability,
    abstraction, and a more declarative coding style. Their versatility enhances the
    expressiveness of our code, allowing us to write more with less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegates, actions, funcs, and predicates**: Our exploration of these pivotal
    functional programming constructs revealed their unique roles and differences.
    We saw how they contribute to crafting versatile and reliable code, each playing
    a specific part in the broader functional paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegates for callbacks, events, and anonymous methods**: Delegates are the
    backbone of creating callbacks, managing events, and defining anonymous methods.
    They enable flexible, event-driven programming structures, crucial for responsive
    and interactive applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ as higher-order functions**: We uncovered the immense power of the LINQ
    library in processing data collections. The emphasis was on how LINQ methods exemplify
    higher-order functions, offering elegant solutions for complex data manipulation
    and querying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices and pitfalls**: We rounded off with vital best practices for
    employing these concepts effectively and avoiding common mistakes. These insights
    are crucial for writing clean, efficient, and maintainable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, this chapter has illuminated how the principles of functional programming
    can be effectively harnessed in C#. We’ve seen that by embracing these concepts,
    developers can achieve greater readability, maintainability, and robustness in
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: As we turn the page to the next chapter, our journey into the depths of functional
    programming continues. We will delve into the intriguing world of functors and
    monads. These advanced concepts will unlock new levels of abstraction and composability
    for you. Stay tuned; it will be interesting!
  prefs: []
  type: TYPE_NORMAL
