- en: Overview of OOP in .NET Core and C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core和C#中OOP概述
- en: For over 20 years, the most popular programming languages have been based on
    the principles of **object-oriented programming** (**OOP**). The rise in popularity
    of OOP languages is largely to do with the benefits of being able to abstract
    complex logic into a structure, called an object, that can be more easily explained,
    and, more importantly, reused within an application. In essence, OOP is a software
    design approach, that is, a pattern for developing software using the concept
    of objects that contain data and functionality. As the software industry matured,
    patterns appeared in OOP for commonly occurring problems, as they were effective
    in solving the same problems but across different contexts and industries. As
    software moved from the mainframe to client servers and then to the cloud, additional
    patterns have emerged to help in reducing development costs and improving reliability.
    This book will explore design patterns, from the foundation of OOP to the architecture
    design patterns for cloud-based software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 20多年来，最受欢迎的编程语言都是基于**面向对象编程**（**OOP**）的原则。OOP语言受欢迎的上升很大程度上归功于能够将复杂逻辑抽象成一个结构，即对象，这使得解释更加容易，更重要的是，可以在应用程序中重用。本质上，OOP是一种软件开发方法，即使用包含数据和功能的概念来开发软件的模式。随着软件行业的成熟，OOP中出现了针对常见问题的模式，因为它们在不同环境和行业中有效解决了相同的问题。随着软件从主机迁移到客户端服务器，再到云计算，出现了更多的模式来帮助降低开发成本和提高可靠性。本书将探讨设计模式，从OOP的基础到基于云软件的架构设计模式。
- en: OOP is based on the concept of an object. This object generally contains data,
    referred to as properties and fields, and code or behavior referred to as methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OOP基于对象的概念。这个对象通常包含数据，称为属性和字段，以及称为方法的代码或行为。
- en: '**Design patterns** are solutions to general problems that software programmers
    face during development, and are built from the experience of what works and what
    doesn''t. These solutions are trialed and tested by numerous developers in various
    situations. The benefits of using a pattern based on this previous activity ensure
    that the same efforts are not repeated again and again. In addition to this, using
    a pattern adds a sense of reliability that the problem will be solved without
    introducing a defect or issue.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**是软件开发人员在开发过程中遇到的一般问题的解决方案，并基于成功和失败的经验构建。这些解决方案经过众多开发者在各种情况下的试验和测试。基于先前活动的模式使用的好处确保了相同的努力不会反复进行。此外，使用模式增加了问题将在不引入缺陷或问题的前提下得到解决的可靠性。'
- en: 'This chapter reviews OOP and how it applies to C#. Note that this is simply
    intended as a brief introduction and it is not meant to be a complete primer for
    OOP or C#; instead, the chapter will cover aspects of both in enough detail to
    introduce you to the design patterns that will be covered in subsequent chapters.
    This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾OOP及其在C#中的应用。请注意，这只是一个简短的介绍，并不旨在成为OOP或C#的完整入门指南；相反，本章将详细涵盖这两个方面，以便您了解后续章节中将要介绍的设计模式。本章将涵盖以下主题：
- en: A discussion of OOP and how classes and objects work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于OOP以及类和对象如何工作的讨论
- en: Inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain these concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释这些概念。代码保持简单，仅用于演示目的。大多数示例涉及用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    version 3 or later)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本运行应用程序）
- en: .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用的是Express版）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'In order to run these code examples, you will need to install Visual Studio
    or later (you can also use your preferred IDE). To do this, follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这些代码示例，您需要安装Visual Studio或更高版本（您也可以使用您偏好的IDE）。为此，请按照以下说明操作：
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included in the link. Multiple versions
    of Visual Studio are available; in this chapter, we are using Visual Studio for
    Windows.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循链接中包含的安装说明。有多种版本的Visual Studio可用；在本章中，我们使用Windows版本的Visual Studio。
- en: Setting up .NET Core
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，您需要遵循以下说明：
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: 'Follow the installation instructions in the related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请遵循相关库中的安装说明：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete, so it is recommended that you retrieve the source
    code in order to run the examples ([https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上获得。章节中显示的源代码可能不完整，因此建议您检索源代码以运行示例（[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1)）。
- en: The models used in this book
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书所使用的模型
- en: As a learning aid, this book will contain many code samples in C# alongside
    diagrams and images to help describe specific concepts where possible. This is
    not a **Unified Modeling Language** (**UML**) book; however, for those with a
    knowledge of UML, many of the diagrams should seem familiar. This section provides
    a description of the class diagrams that will be used in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为学习辅助，本书将包含许多C#代码示例，以及图表和图像，以帮助描述尽可能具体的概念。这不是一本**统一建模语言**（**UML**）的书籍；然而，对于那些了解UML的人来说，许多图表应该看起来很熟悉。本节提供了将在这本书中使用的类图的描述。
- en: 'Here, a class will be defined as including both fields and methods separated
    by a dashed line. If important to the discussion, then accessibility will be indicated
    as `-` for private, `+` for public, `#` for protected, and `~` for internal. The
    following screenshot illustrates this by showing a `Car` class with a private
    `_name` variable and a public `GetName()` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个类将被定义为包括字段和方法，字段和方法之间用虚线分隔。如果对讨论很重要，则可访问性将表示为`-`表示私有，`+`表示公共，`#`表示受保护，`~`表示内部。以下屏幕截图通过显示一个具有私有`_name`变量和公共`GetName()`方法的`Car`类来说明这一点：
- en: '![](img/3d37335f-9e59-494a-bdf4-67d30cd832d0.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d37335f-9e59-494a-bdf4-67d30cd832d0.png)'
- en: 'When showing relationships between objects, an association is shown with a
    solid line, an aggregation is shown with an open diamond, and a composition is
    shown with a filled diamond. When important to the discussion, multiplicity will
    be shown next to the class in question. The following diagram illustrates the
    `Car` class as having a single **Owner**, and up to three **Passengers**; it consists
    of four **Wheels**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示对象之间的关系时，关联用实线表示，聚合用开放菱形表示，组合用填充菱形表示。如果对讨论很重要，则多重性将显示在相关的类旁边。以下图说明了`Car`类有一个单一的**所有者**，最多有三个**乘客**；它由四个**轮子**组成：
- en: '![](img/cc1fc18d-dc06-4b38-ae24-f7898b19c050.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc1fc18d-dc06-4b38-ae24-f7898b19c050.png)'
- en: '**Inheritance** is shown using an open triangle on the base class using a solid
    line. The following diagram shows the relationship between an `Account` base class
    and the `CheckingAccount` and `SavingsAccount` child classes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**使用基类底部的开放三角形，并通过实线显示。以下图显示了`Account`基类与`CheckingAccount`和`SavingsAccount`子类之间的关系：'
- en: '![](img/7fe47763-223e-4667-8003-38f5116f7c82.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fe47763-223e-4667-8003-38f5116f7c82.png)'
- en: '**Interfaces** are shown in a similar manner to inheritance, but they use a
    dashed line as well as an additional `<<interface>>` label, as shown in the following
    diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**以与继承类似的方式显示，但它们使用虚线以及额外的`<<interface>>`标签，如下面的图所示：'
- en: '![](img/b9fa7abd-7fda-4877-acf8-971a8c3fc429.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9fa7abd-7fda-4877-acf8-971a8c3fc429.png)'
- en: This section provides an overview of the models used in this book. This style/approach
    was chosen because, hopefully, it will be familiar to the majority of readers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了本书中使用的模型。这种风格/方法被选择是因为，希望它对大多数读者来说将是熟悉的。
- en: OOP and how classes and objects work
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程以及类和对象的工作原理
- en: OOP refers to a software programming approach that uses objects defined as classes.
    These definitions include fields, sometimes called attributes, to store data and
    methods in order to provide functionality. The first OOP language was a simulation
    of real systems known as Simula ([https://en.wikipedia.org/wiki/Simula](https://en.wikipedia.org/wiki/Simula))
    and was developed at the Norwegian Computing Center in 1960\. The first pure OOP
    language came into existence in 1970 as the Smalltalk ([https://en.wikipedia.org/wiki/Smalltalk](https://en.wikipedia.org/wiki/Smalltalk))
    language. This language was designed to program the Dynabook ([http://history-computer.com/ModernComputer/Personal/Dynabook.html](http://history-computer.com/ModernComputer/Personal/Dynabook.html)),
    which is a personal computer created by Alan Kay. Several OOP languages evolved
    from there, with the most popular being Java, C++, Python, and C#.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是指使用定义为类的对象进行软件编程的方法。这些定义包括字段，有时称为属性，用于存储数据，以及方法以提供功能。第一种面向对象编程语言是名为Simula的模拟真实系统的语言（[https://en.wikipedia.org/wiki/Simula](https://en.wikipedia.org/wiki/Simula)），于1960年在挪威计算中心开发。第一种纯面向对象编程语言是在1970年作为Smalltalk语言出现的。这种语言被设计用来编程Dynabook（[http://history-computer.com/ModernComputer/Personal/Dynabook.html](http://history-computer.com/ModernComputer/Personal/Dynabook.html)），这是由艾伦·凯创建的个人计算机。从那时起，发展出了几种面向对象编程语言，其中最流行的是Java、C++、Python和C#。
- en: OOP is based on objects that contain data. The OOP paradigm allows developers
    to arrange/organize code into an abstract or logical structure called an object.
    An object can contain both data and behavior.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）基于包含数据的对象。OOP范式允许开发者将代码组织/安排成一个称为对象的抽象或逻辑结构。一个对象可以包含数据和行为。
- en: 'With the use of the OOP approach, we are doing the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象的方法，我们正在做以下事情：
- en: '**Modularizing**: Here, an application is decomposed into different modules.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：在这里，一个应用程序被分解成不同的模块。'
- en: '**Reusing the software**: Here, we rebuild or compose an application from different
    (that is, existing or new) modules.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件重用**：在这里，我们重新构建或组合应用程序来自不同的（即，现有或新的）模块。'
- en: In the following sections, we will discuss and understand the concepts of OOP
    in more detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细讨论和理解面向对象编程的概念。
- en: Explaining OOP
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释面向对象编程
- en: Earlier, programming approaches had limitations and they often became difficult
    to maintain. OOP offered a new paradigm in software development that had advantages
    over other approaches. The concept of organizing code into objects is not difficult
    to explain and this is a huge advantage for the adoption of a new pattern. Many
    examples can be taken from the real world in order to explain the concept. Complex
    systems can also be described using smaller building blocks (that is, an *objects*).
    These allow developers to look at sections of the solution individually while
    understanding how they fit into the entire solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的编程方法有局限性，它们往往变得难以维护。面向对象编程为软件开发提供了一种新的范式，它比其他方法具有优势。将代码组织到对象中的概念并不难解释，这对于新模式的采用是一个巨大的优势。可以从现实世界中提取许多例子来解释这个概念。复杂的系统也可以使用较小的构建块（即，*对象*）来描述。这允许开发者单独查看解决方案的部分，同时理解它们如何融入整个解决方案。
- en: 'With this in mind, let''s define a program as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们如下定义程序：
- en: '"A program is a list of instructions that instructs the language compiler on
    what to do."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '"程序是一系列指令，指示语言编译器执行什么操作。"'
- en: As you can see, an object is a way of organizing a list of instructions in a
    logical manner. Going back to the example of the house, the architect's instructions
    help us to build a house, but they are not the house itself. Instead the architect's
    instructions are an abstract representation of a house. A class is similar as
    it defines the features of an object. An object is then created from the definition
    of a class. This is often called **instantiating the object***.*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，对象是以逻辑方式组织指令列表的一种方式。回到房子的例子，建筑师的设计指导帮助我们建造房子，但它们本身不是房子。相反，建筑师的设计指导是房子的抽象表示。类类似，它定义了对象的特征。然后，根据类的定义创建对象。这通常被称为**实例化对象**。
- en: 'To understand OOP more closely, we should mention two other significant programming
    approaches:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解OOP，我们应该提及两种其他重要的编程方法：
- en: '**Structured programming**: This is a term coined by Edsger W. Dijkstra in
    1966\. Structured programming is a programming paradigm that solves a problem
    to handle 1,000 lines of code and divides these into small parts. These small
    parts are mostly called **subroutines**, **block structures**, **for** and **while**
    loops, and more. Languages that use structured programming techniques include
    ALGOL, Pascal, PL/I, and more.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化编程**：这是一个由Edsger W. Dijkstra在1966年提出的术语。结构化编程是一种编程范式，它通过将问题分解成小部分来解决处理1,000行代码的问题。这些小部分通常被称为**子程序**、**块结构**、**for**和**while**循环等。使用结构化编程技术的语言包括ALGOL、Pascal、PL/I等。'
- en: '**Procedural programming**: This is a paradigm derived from structured programming
    and is simply based on how we make a call (also known as a **procedu****ral call**).
    Languages that use procedural programming techniques include COBOL, Pascal, and
    C. A recent example of the Go programming language was published in 2009.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程式编程**：这是一种从结构化编程衍生出来的范式，它简单地基于我们如何进行调用（也称为**过程调用**）。使用过程式编程技术的语言包括COBOL、Pascal和C。Go编程语言的一个近期例子是在2009年发布的。'
- en: Procedural calls
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 过程调用
- en: A procedural call is where a collection of statements, known as a *procedure*,is
    activated. This is sometimes referred to as a procedure that is *invoked*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 过程调用是指激活一组称为**过程**的语句。这有时也被称为被**调用**的过程。
- en: 'The main problem with these two approaches is that programs are not easily
    manageable once they grow. Programs with more complex and larger code bases strain
    these two approaches, leading to difficult-to-understand and difficult-to-maintain
    applications. To overcome such problems, OOP provides the following features:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的主要问题是，一旦程序变得庞大，程序就难以管理。更复杂和更大的代码库的程序会拉伸这两种方法，导致难以理解和维护的应用程序。为了克服这些问题，OOP提供了以下特性：
- en: Inheritance
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: In the following sections, we will discuss these features in more detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地讨论这些特性。
- en: Inheritance, encapsulation, and polymorphism are sometimes referred to as the
    three pillars of OOP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 继承、封装和多态有时被称为OOP的三大支柱。
- en: Before we begin, let's discuss some structures that are found in OOP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们讨论一些在面向对象编程（OOP）中常见的结构。
- en: A class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: A **class** is a group or template definition of the methods and variables that
    describe an object. In other words, a class is a blueprint, containing the definition
    of the variables and the methods that are common to all instances of the class
    called objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是一组或模板定义，描述了对象的属性和方法。换句话说，类是一个蓝图，包含了所有类实例（称为对象）共有的变量和方法定义。'
- en: 'Let''s take a look at the following code example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码示例：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have a `PetAnimal` class that has two private fields
    called `PetName` and `PetColor`, and one method called `MyPet()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个名为`PetAnimal`的类，它有两个私有字段，分别称为`PetName`和`PetColor`，以及一个名为`MyPet()`的方法。
- en: An object
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: 'In the real world, objects share two characteristics, that is, state and behavior.
    In other words, we can say that every object has a name, color, and more; these
    characteristics are simply the state of an object. Let''s take the example of
    any type of pet: a dog and a cat will both have a name by which they called. So,
    in this way, my dog is named Ace and my cat is named Clementine. Similarly, dogs
    and cats have specific behaviors, for example, dogs barks and cats meow.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，对象有两个共同的特征，即状态和行为。换句话说，我们可以这样说，每个对象都有一个名称、颜色等；这些特征仅仅是对象的状态。让我们以任何类型的宠物为例：狗和猫都会有一个名字，人们会叫它。所以，以这种方式，我的狗名叫Ace，我的猫名叫Clementine。同样，狗和猫都有特定的行为，例如，狗会吠叫，猫会喵喵叫。
- en: In the *Explaining OOP* section, we discussed that OOP is a programming model
    that is supposed to combine a state or structure (data) and the behavior (method)
    to deliver software functionality. In the previous example, the different states
    of pets make up the actual data, while the behavior of the pets is the method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*解释OOP*部分，我们讨论了OOP是一种旨在结合状态或结构（数据）和行为（方法）以提供软件功能的编程模型。在先前的例子中，宠物的不同状态构成了实际的数据，而宠物的行为则是方法。
- en: An object stores the information (which is simply data) in attributes and discloses
    its behavior through methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对象将信息（即数据）存储在属性中，并通过方法展示其行为。
- en: In terms of an OOP language such as C#, an object is an instance of a class.
    In our previous example, the real-world object, `Dog`, would be an object of the
    `PetAnimal` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言，如C#中，对象是类的实例。在我们之前的例子中，现实世界的对象`Dog`将是`PetAnimal`类的一个对象。
- en: Objects can be concrete (that is, a real-world object, such as a dog or cat,
    or any type of file, such as physical file or a computer file) or they can be
    conceptual, such as database schemas or code blueprints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以是具体的（即现实世界的对象，如狗或猫，或任何类型的文件，如物理文件或计算机文件），也可以是概念性的，如数据库模式或代码蓝图。
- en: 'The following code snippet shows how an object contains data and a method,
    and how you can use it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了对象如何包含数据和方法，以及如何使用它：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous code snippet, we have created two objects: `dog` and `cat`.
    These objects are two different instances of a `PetAnimal` class. You can see
    that the fields or properties that contain data about the animal are given values
    using the constructor method. The constructor method is a special method used
    to create an instance of the class.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们创建了两个对象：`dog`和`cat`。这些对象是`PetAnimal`类的两个不同实例。您可以看到，包含有关动物数据的字段或属性是通过构造函数方法赋予值的。构造函数方法是一个特殊的方法，用于创建类的实例。
- en: 'Let''s visualize this example in the following diagram:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下图中可视化这个例子：
- en: '![](img/831ba13f-467e-4a85-9819-0d19dad2a714.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831ba13f-467e-4a85-9819-0d19dad2a714.png)'
- en: The preceding diagram is a pictorial representation of our previous code example,
    where we created two different `Dog` and `Cat` objects of the `PetAnimal` class.
    The diagram is relatively self-explanatory; it tells us that the object of `Dog`
    class is an instance of the `PetAnimal` class, as is the `Cat` object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是之前代码示例的图形表示，其中我们创建了两个不同的`Dog`和`Cat`对象，它们都是`PetAnimal`类的实例。该图相对自解释；它告诉我们`Dog`类的对象是`PetAnimal`类的一个实例，`Cat`对象也是如此。
- en: Associations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: Object associations are an important feature of OOP. Relationships exist between
    objects in the real world, and, in OOP, an association allows us to define a *has-a*
    relationship; for example, a bicycle *has a* rider or a cat *has a* nose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对象关联是面向对象的一个重要特性。现实世界中的对象之间存在关系，在面向对象中，关联允许我们定义`has-a`关系；例如，自行车`有`骑手或猫`有`鼻子`。
- en: 'The types of *has-a* relationship are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`has-a`关系类型的例子：
- en: '**Association**: An association is used to describe a relationship between
    objects so that there is no ownership described, for example, the relationship
    between a car and a person. The car and person have a relationship described,
    such as a driver. A person can drive multiple cars and a car can be driven by
    multiple people.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联**：关联用于描述对象之间的关系，这样就不会描述所有者关系，例如，汽车和人的关系。汽车和人之间的关系被描述，例如司机。一个人可以驾驶多辆车，一辆车也可以被多个人驾驶。'
- en: '**Aggregation**: An aggregation is a specialized form of association. Similar
    to associations, objects have their own life cycle in aggregations, but it involves
    ownership. This means that a child object cannot belong to another parent object.
    Aggregation is a one-way relationship where the lives of the objects are independent
    from each other. For example, the child and parent relationship is an aggregation,
    because every child has a parent but it''s not necessary that every parent has
    a child.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：聚合是一种特殊的关联形式。类似于关联，对象在聚合中也有它们自己的生命周期，但它涉及所有者关系。这意味着子对象不能属于另一个父对象。聚合是一种单向关系，其中对象的生命是相互独立的。例如，子父关系是一种聚合，因为每个孩子都有一个父母，但并非每个父母都有一个孩子。'
- en: '**Composition**: A composition refers to a relationship of death; it represents
    the relationship between two objects where one object (child) depends on another
    object (parent). If the parent object is deleted, all its children automatically
    get deleted. Let''s consider a house and a room as an example. One house has multiple
    rooms, but a single room cannot belong to multiple houses. If we demolished the
    house, the rooms will automatically be deleted.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：组合指的是死亡关系；它表示两个对象之间的关系，其中一个对象（子对象）依赖于另一个对象（父对象）。如果父对象被删除，所有子对象将自动被删除。让我们以房屋和房间为例。一个房屋可以有多个房间，但一个房间不能属于多个房屋。如果我们拆除了房屋，房间将自动被删除。'
- en: Let's illustrate these concepts in C# by extending the previous pet example
    and introducing a `PetOwner` class. The `PetOwner` class could be associated with
    one or more `PetAnimal` instances. As the `PetAnimal` class can exist with or
    without having an owner, the relationship is an aggregation. `PetAnimal` is related
    to `PetColor` and, in this system, `PetColor` only exists if it is related to
    `PetAnimal`, making the association a composition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过扩展之前的宠物示例并引入一个`PetOwner`类来在C#中说明这些概念。`PetOwner`类可以关联一个或多个`PetAnimal`实例。由于`PetAnimal`类可以有无所有者而存在，这种关系是聚合关系。`PetAnimal`与`PetColor`相关联，在这个系统中，只有当它与`PetAnimal`相关联时，`PetColor`才存在，这使得关联成为组合。
- en: 'The following diagram illustrates both aggregation and composition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了聚合和组合：
- en: '![](img/d132053d-f041-4a26-a000-436ad74ddaa6.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d132053d-f041-4a26-a000-436ad74ddaa6.png)'
- en: The preceding model is based on UML and might not be familiar to you; so, let's
    point out some important things about the diagram. The class is represented by
    a box containing the class name as well as its attributes and methods (separated
    by a dashed line). For now, ignore the symbol before the name, for example, `+`
    or `-`, as we will cover access modifiers when we discuss encapsulation later.
    The associations are shown with a line connecting the classes. In the case of
    compositions, a solid diamond on the side of the parent is used, whereas an open
    diamond on the side of the parent is used to show aggregations. Additionally,
    note that the diagram supports a multiplicity value that indicates the number
    of possible children. In the diagram, a `PetOwner` class can have `0` or more
    `PetAnimal` classes (note that ***** indicates no enforced limit to the number
    of associations).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模型基于UML，可能对您来说并不熟悉；因此，让我们指出关于该图的一些重要事项。类由一个包含类名以及其属性和方法的框表示（通过虚线分隔）。现在，忽略名称前的符号，例如`+`或`-`，因为我们将在讨论封装时介绍访问修饰符。关联通过连接类的线条表示。在组合的情况下，父类的一侧使用实心菱形，而父类的一侧使用开放菱形来表示聚合。此外，请注意，该图支持表示可能子数目的多值。在图中，`PetOwner`类可以有`0`个或更多`PetAnimal`类（注意，*****表示没有强制限制关联的数量）。
- en: UML
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UML
- en: The UML is a modeling language specifically developed for software engineering.
    It was developed over 20 years and is managed by the **Object Management Group**
    (**OMG**). You can refer to [http://www.uml.org/](http://www.uml.org/) for more
    details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: UML是一种专门为软件工程开发的建模语言。它经过20多年的发展，由**对象管理组**（**OMG**）管理。您可以参考[http://www.uml.org/](http://www.uml.org/)获取更多详细信息。
- en: An interface
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: In C#, an **interface** defines what an object contains, or its contract; in
    particular, the methods, properties, events, or indices of the object. However,
    the interface does not provide implementation. Interfaces cannot contain attributes.
    This is in contrast to a base class, where the base class provides both the contract
    and the implementation. A class that implements an interface must implement everything
    specified in the interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，**接口**定义了一个对象包含的内容，或其合同；特别是对象的方法、属性、事件或索引。然而，接口不提供实现。接口不能包含属性。这与基类形成对比，基类既提供合同也提供实现。实现接口的类必须实现接口中指定的所有内容。
- en: An abstract class
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class is a bit of a hybrid between the interface and base class
    as it provides both implementations and attributes as well as methods that must
    be defined in the child classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类在接口和基类之间是一种混合体，因为它提供了实现和属性，以及必须在子类中定义的方法。
- en: Signature
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 签名
- en: The term *signature* can also be used to describe the contract of an object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*签名*也可以用来描述一个对象的合同。
- en: Inheritance
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: One of the most important concepts in OOP is inheritance. Inheritance between
    classes allows us to define an *is-a-type-of relationship*; for example, a car
    *is a type of* vehicle. The importance of this concept is that it allows for objects
    of the same type to share similar features. Let's say that we have a system for
    managing different products of an online bookstore. We might have one class for
    storing information about a physical book and a different one for storing information
    about a digital or online book. The features that are similar between the two,
    such as the name, publisher, and author, could be stored in another class. Both
    the physical and digital book classes could then inherit from the other class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中最重要的概念之一就是继承。类之间的继承关系允许我们定义一个*类型关系*；例如，汽车*是一种*交通工具。这个概念的重要性在于它允许相同类型的对象共享相似的特征。假设我们有一个在线书店不同产品管理的系统。我们可能有一个类用于存储关于实体书的详细信息，另一个类用于存储关于数字或在线书的详细信息。两个类之间相似的特征，如名称、出版社和作者，可以存储在另一个类中。实体书和数字书类然后可以继承自这个其他类。
- en: 'There are different terms to describe classes in inheritance: a *child* or
    *derived* class inherits from another class while the class being inherited from
    can be called the *parent* or *base* class.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的术语来描述继承中的类：一个*子*或*派生*类从另一个类继承，而正在被继承的类可以被称为*父*或*基*类。
- en: In the following sections, we will discuss inheritance in more detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地讨论继承。
- en: Types of inheritance
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的类型
- en: Inheritance helps us to define a child class. This child class inherits the
    behavior of the parent or base class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 继承帮助我们定义一个子类。这个子类继承了父类或基类的行为。
- en: In C#, inheritance is symbolically defined using a colon (`:`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，继承使用冒号（`:`）进行符号定义。
- en: 'Let''s take a look at the different types of inheritance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的继承类型：
- en: '**Single inheritance**: As the most common type of inheritance, single inheritance
    describes a single class that is is derived from another class.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单继承**：作为最常见的继承类型，单继承描述了一个从另一个类派生出来的单个类。'
- en: 'Let''s revisit the `PetAnimal` class previously mentioned and, instead, use
    inheritance to define our `Dog` and `Cat` classes. With inheritance, we can define
    some attributes that are common for both. For example, the name of the pet and
    the color of the pet would be common, so they would be located in a base class.
    The specifics of a cat or a dog would then be defined in a specific class; for
    example, the sound the cat and dog make. The following diagram illustrates a `PetAnimal`
    base class with two child classes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前提到的 `PetAnimal` 类，然后使用继承来定义我们的 `Dog` 和 `Cat` 类。使用继承，我们可以定义一些两个类都共有的属性。例如，宠物的名字和宠物的颜色是共有的，所以它们会被放在一个基类中。猫或狗的具体特征然后会在特定的类中定义；例如，猫和狗发出的声音。以下图表展示了具有两个子类的
    `PetAnimal` 基类：
- en: '![](img/dcf9f6cd-c935-4973-a43a-4139b3d6ff1d.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf9f6cd-c935-4973-a43a-4139b3d6ff1d.png)'
- en: C# only supports single inheritance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C# 只支持单继承。
- en: '**Multiple inheritance**: Multiple inheritance happens when a derived class
    inherits multiple base classes. Languages such as C++ support multiple inheritance.
    C# does not support multiple inheritance, but we can achieve behaviors similar
    to multiple inheritance with the help of interfaces.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重继承**：当一个派生类从多个基类继承时，发生多重继承。例如，C++ 语言支持多重继承。C# 不支持多重继承，但我们可以通过接口的帮助实现类似多重继承的行为。'
- en: 'You can refer to the following post for more information about C# and multiple
    inheritance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下帖子以获取有关 C# 和多重继承的更多信息：
- en: '[https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/).'
- en: '**Hierarchical inheritance**: Hierarchical inheritance happens when more than
    one class inherits from another class.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次继承**：当多个类从另一个类继承时，发生层次继承。'
- en: '**Multilevel inheritance**: When a class is derived from a class that is already
    a derived class, it is called multilevel inheritance.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多层继承**：当一个类从已经是一个派生类的类派生时，它被称为多层继承。'
- en: '**Hybrid inheritance**: Hybrid inheritance is a combination of more than one
    inheritance.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合继承**：混合继承是多种继承的组合。'
- en: C# does not support hybrid inheritance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C# 不支持混合继承。
- en: '**Implicit inheritance**: All the types in .NET Core implicitly inherit from
    the `System.Object` class and its derived classes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式继承**：.NET Core中的所有类型都隐式继承自`System.Object`类及其派生类。'
- en: Encapsulation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is another fundamental concept in OOP where the details of a class,
    that is, the attributes and methods, can be visible or not visible outside the
    object. With encapsulation, a developer is providing guidance on how a class should
    be used as well as helping to prevent a class from being handled incorrectly.
    For example, let's say we wanted to only allow adding `PetAnimal` objects by using
    the `AddPet(PetAnimal)` method. We would do this by having the `PetOwner` class's
    `AddPet(PetAnimal)` method available while having the `Pets` attribute restricted
    to anything outside the `PetAnimal` class. In C#, this is possible by making the
    `Pets` attribute private. One reason for doing this would be if additional logic
    was required whenever a `PetAnimal` class was added, such as logging or validating
    that the `PetOwner` class could have a pet.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程中的另一个基本概念，其中类的细节，即属性和方法，可以在对象外部可见或不可见。通过封装，开发者提供了关于如何使用类的指导，同时帮助防止类被错误处理。例如，假设我们只想通过使用`AddPet(PetAnimal)`方法来添加`PetAnimal`对象。我们会通过使`PetOwner`类的`AddPet(PetAnimal)`方法可用，同时将`Pets`属性限制为`PetAnimal`类之外的所有内容来实现这一点。在C#中，这是通过将`Pets`属性设置为私有来实现的。这样做的一个原因可能是，每当添加`PetAnimal`类时，都需要额外的逻辑，例如记录或验证`PetOwner`类是否可以有宠物。
- en: 'C# supports different levels of access that can be set on an item. An item
    could be a class, a class''s attribute or method, or an enumeration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持可以在项目上设置的不同的访问级别。项目可以是类、类的属性或方法，或枚举：
- en: '**Public**: This indicates that access is available outside the item.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：这表示可以在项目外部进行访问。'
- en: '**Private**: This indicates that only the object has access to the item.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：这表示只有对象可以访问项目。'
- en: '**Protected**: This indicates that only the object (and objects of classes
    that extended the class) can access the attribute or method.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的**：这表示只有对象（以及扩展了该类的对象）可以访问属性或方法。'
- en: '**Internal**: This indicates that only objects within the same assembly have
    access to the item.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：这表示只有同一组件内的对象可以访问项目。'
- en: '**Protected Internal**: This indicates that only the object (and objects of
    classes that extended the class) can access the attribute or method within the
    same assembly.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的内部**：这表示只有对象（以及扩展了该类的对象）可以访问同一组件内的属性或方法。'
- en: 'In the following diagram, access modifiers have been applied to `PetAnimal`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，对`PetAnimal`应用了访问修饰符：
- en: '![](img/d4bb8946-f4a2-416c-938c-f39dc212a197.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4bb8946-f4a2-416c-938c-f39dc212a197.png)'
- en: As an example, the name of the pet and the color were made private to prevent
    access from outside the `PetAnimal` class. In this example, we are restricting
    the `PetName` and `PetColor` properties so only the `PetAnimal` class can access
    them in order to ensure that only the base class, `PetAnimal`, can change their
    values. The constructor of `PetAnimal` was protected to ensure only a child class
    could access it. In this application, only classes within the same library as
    the `Dog` class have access to the `RegisterInObedienceSchool()` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，宠物的名称和颜色被设置为私有，以防止从`PetAnimal`类外部访问。在这个例子中，我们限制了`PetName`和`PetColor`属性，以确保只有`PetAnimal`类可以访问它们，从而确保只有基类`PetAnimal`可以更改它们的值。`PetAnimal`的构造函数被设置为受保护的，以确保只有子类可以访问它。在这个应用程序中，只有与`Dog`类位于同一库中的类可以访问`RegisterInObedienceSchool()`方法。
- en: Polymorphism
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: 'The ability to handle different objects using the same interface is called
    polymorphism. This provides developers with the ability to build flexibility into
    applications by writing a single piece of functionality that can be applied to
    different forms as long as they share a common interface. There are different
    definitions of polymorphism in OOP, and we will distinguish between two main types:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的接口处理不同对象的能力称为多态。这为开发者提供了将灵活性构建到应用程序中的能力，通过编写一个可以应用于不同形式的功能，只要它们共享一个公共接口即可。在面向对象编程（OOP）中，多态有不同的定义，我们将区分两种主要类型：
- en: '**Static or early binding**: This form of polymorphism happens when the application
    is compiled.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态或早期绑定**：这种多态发生在应用程序编译时。'
- en: '**Dynamic or late binding**: This form of polymorphism happens when the application
    is running.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态或晚期绑定**：这种形式的多态发生在应用程序运行时。'
- en: Static polymorphism
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态多态
- en: 'Static or early binding polymorphism happens at compile time and it primarily
    consists of method overloading, where a class has multiple methods with the same
    name but with different parameters. This is often useful to convey a meaning behind
    the method or to simplify the code. For example, in a calculator, it is more readable
    to have multiple methods for adding different types of number rather than having
    a different method name for each scenario; let''s compare the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 静态或早期绑定多态发生在编译时，它主要是由方法重载组成，即一个类有多个具有相同名称但参数不同的方法。这通常有助于传达方法的含义或简化代码。例如，在计算器中，有多个方法用于添加不同类型的数字比每个场景都有不同的方法名称更易于阅读；让我们比较以下代码：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following, the code is shown again with the same functionality, but
    without overloading the `Add()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，代码再次展示了相同的功能，但没有重载`Add()`方法：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the pet example, an owner will use different food to feed objects of the
    `cat` and `dog` class. We can define this as the `PetOwner` class with two methods
    for `Feed()`, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在宠物示例中，主人会使用不同的食物来喂养`cat`和`dog`类的对象。我们可以定义一个`PetOwner`类，其中包含两个`Feed()`方法，如下所示：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both methods use a `PetFeeder` class to feed the pet, while the `dog` class
    is given `Kibble` and the `cat` instance is given `Fish`. The `PetFeeder` class
    is described in the *Generics* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都使用一个`PetFeeder`类来喂养宠物，而`dog`类被赋予`Kibble`，`cat`实例则被赋予`Fish`。`PetFeeder`类在*泛型*部分有所描述。
- en: Dynamic polymorphism
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态多态
- en: 'Dynamic or late binding polymorphism happens while the application is running.
    There are multiple situations where this can occur and we''ll cover three common
    forms in C#: interface, inheritance, and generics.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 动态或晚期绑定多态发生在应用程序运行时。有多个情况可以发生，我们将涵盖C#中的三种常见形式：接口、继承和泛型。
- en: Interface polymorphism
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口多态
- en: 'An interface defines the signature that a class must implement. In the `PetAnimal`
    example, imagine that we define pet food as providing an amount of energy, as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了一个类必须实现的签名。在`PetAnimal`示例中，想象我们定义宠物食品提供能量量，如下所示：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By itself, the interface cannot be instantiated but describes what an instance
    of `IPetFood` must implement. For example, `Kibble` and `Fish` might provide different
    levels of energy, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 界面本身不能被实例化，但它描述了`IPetFood`实例必须实现的内容。例如，`Kibble`和`Fish`可能提供不同水平的能量，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, `Kibble` provides less energy than `Fish`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Kibble`提供的能量比`Fish`少。
- en: Inheritance polymorphism
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承多态
- en: 'Inheritance polymorphism allows for functionality to be determined at runtime
    in a similar way to an interface but applies to class inheritance. In our example,
    a pet can be fed, so we can define this as having a new `Feed(IPetFood)` method,
    which uses the interface that was defined previously:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 继承多态允许在运行时以类似于接口的方式确定功能，但应用于类继承。在我们的例子中，宠物可以被喂养，因此我们可以定义一个新的`Feed(IPetFood)`方法，它使用之前定义的接口：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code indicates that all implementations of `PetAnimal` will have
    a `Feed(IPetFood)` method and child classes can provide a different implementation.
    `Eat(IPetFood food)` is not marked as virtual, as it is intended that all `PetAnimal`
    objects will use the method without needing to override its behavior. It is also
    marked as protected to prevent it being accessed from outside the object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表明，所有`PetAnimal`的实现都将有一个`Feed(IPetFood)`方法，并且子类可以提供不同的实现。`Eat(IPetFood food)`没有被标记为虚拟，因为预期所有`PetAnimal`对象都将使用该方法，而不需要覆盖其行为。它也被标记为受保护的，以防止从对象外部访问。
- en: A virtual method does not have to be defined in a child class; this differs
    from an interface, where all methods in an interface must be implemented.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法不需要在子类中定义；这与接口不同，在接口中所有方法都必须实现。
- en: '`PetDog` will not override the behavior of the base class as a dog will eat
    both `Kibble` and `Fish`. A cat is more discerning, as shown in the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetDog`不会覆盖基类的行为，因为狗会吃`Kibble`和`Fish`。猫则更为挑剔，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the override keyword, `PetCat` will change the behavior of the base class,
    resulting in a cat only eating fish.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`override`关键字，`PetCat`将改变基类的行为，使得猫只能吃鱼。
- en: Generics
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: A generic defines a behavior that can be applied to a class. A commonly used
    form of this is in collections, where the same approach to handling an object
    can be applied regardless of the type of object. For example, a list of strings
    or a list of integers can be handled using the same logic without having to differentiate
    between the specific types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型定义了一种可以应用于类的行为。这种形式最常见的应用是在集合中，其中可以应用相同的处理对象的方法，而不管对象的类型如何。例如，字符串列表或整数列表可以使用相同的逻辑进行处理，而无需区分具体的类型。
- en: 'Going back to pets, we could define a generic class for feeding a pet. This
    class simply feeds a pet given both the pet and some food, as shown in the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回到宠物的话题，我们可以定义一个用于喂养宠物的泛型类。这个类简单地根据提供的宠物和食物来喂养宠物，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a couple of interesting thing to point out here. First of all, the
    class does not have to be instantiated as both the class and method are marked
    as static. The generic method is described using the method signature, `FeedPet<TP,
    TF>`. The `where` keyword is used to indicate additional requirements as to what
    `TP` and `TF` must be. In this example, the `where` keyword defines `TP` as having
    to be a type of `PetAnimal`, while `TF` must implement the `IPetFood` interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一些有趣的事情需要指出。首先，由于类和方法都被标记为静态，因此不需要实例化这个类。泛型方法使用方法签名`FeedPet<TP, TF>`进行描述。`where`关键字用于指示对`TP`和`TF`的额外要求。在这个例子中，`where`关键字定义`TP`必须是一个`PetAnimal`类型的类型，而`TF`必须实现`IPetFood`接口。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed OOP and its three main features: inheritance,
    encapsulation, and polymorphism. Using these features, the classes within an application
    can be abstracted to provide definitions that are both easy to understand and
    protected against being used in a manner that is inconsistent with its purpose.
    This is an essential difference between OOP and some earlier types of software
    development language such as structural and procedural programming. With the ability
    to abstract functionality, the ability to reuse and maintain code is increased.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了面向对象编程（OOP）及其三个主要特性：继承、封装和多态。使用这些特性，应用程序中的类可以被抽象化，以提供既易于理解又受保护的定义，防止以与其目的不一致的方式使用。这是面向对象编程与一些早期的软件开发语言（如结构化和过程化编程）之间的基本区别。通过抽象功能的能力，代码的重用和维护能力得到了提高。
- en: In the next chapter, we will discuss various patterns used in enterprise software
    development. We will cover programming patterns as well as software development
    principles and patterns used in the **Software Development Life Cycle** (**SDLC**).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在企业软件开发中使用的各种模式。我们将涵盖编程模式以及**软件开发生命周期**（**SDLC**）中使用的软件开发原则和模式。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: What do the terms late and early binding refer to?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 晚绑定和早绑定这两个术语指的是什么？
- en: Does C# support multiple inheritance?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#支持多重继承吗？
- en: In C#, what level of encapsulation could be used to prevent access to a class
    from outside the library?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中，可以使用什么级别的封装来防止从库外部访问类？
- en: What is the difference between aggregation and composition?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合和组合之间的区别是什么？
- en: Can interfaces contain properties? (This is a bit of a trick question.)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以包含属性吗？（这是一个有点狡猾的问题。）
- en: Do dogs eat fish?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 狗吃鱼吗？
