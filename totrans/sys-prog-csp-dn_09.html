<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-207"><a id="_idTextAnchor208"/>9</h1>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor209"/>The One with the  Hardware Handshakes</h1>
			<p><em class="italic">Hardware interaction </em><em class="italic">and control</em></p>
			<p>As system programmers, we never deal with users. We deal with other software. That other software could be on the same machine, or it could be on another machine. And sometimes, we deal with hardware. That hardware could be part of our machine, hardware attached to our machine, or hardware somewhere else.</p>
			<p>In this chapter, we will look into all of these options. We will look at interacting with hardware directly and connecting to remote devices, and we will dive deep into the world of serial communications.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Connecting to a serial port on Windows.</li>
				<li>Setting up an Arduino device</li>
				<li>Programming a simple program on an Arduino</li>
				<li>Getting data from a serial port</li>
				<li>Handling events from the outside</li>
				<li>Debugging code depending on external devices</li>
				<li>Make this sort of code as reliable as possible</li>
				<li>All in all, we have much ground to cover. Join me in exploring this new land of exotic hardware!</li>
			</ul>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/>Technical requirements</h1>
			<p>In this chapter, we will dive into some external hardware. I will show you how to talk to an <strong class="bold">Arduino microcontroller</strong> through a serial connection.</p>
			<p>If you do not have access to such a device, do not worry. I will also talk about how to mock these devices so that you can test your code before deploying it on an actual device. You can follow along and try out the code if you encounter these devices later.</p>
			<p>As always, you can download the source code for these samples from the GitHub repository at   <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter09"> https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter09</a>.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor211"/>Connecting to serial ports</h1>
			<p>It is time to have some fun. Let’s <a id="_idIndexMarker670"/>break out of the confinements of the machine we are working on and step into the world of peripherals.</p>
			<p>However, before we look at the code, we have to see how software communicates with hardware.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>The path to the hardware</h2>
			<p>Let’s say we have an application<a id="_idIndexMarker671"/> connecting to some hardware. It doesn’t matter what kind of hardware, but let’s say we want to send data to a USB port.</p>
			<p>Sending data from our application to the device involves several steps where the data is transformed. It is slightly like the OSI layer we discussed in the previous chapter.</p>
			<p>It all starts with our application. We devised the C# code to send data to the USB device. We have downloaded the correct NuGet packages, installed the frameworks, written the code, and compiled it into an executable.</p>
			<p>When that executable runs, that code is called the correct code in the .NET libraries installed on your machine when you installed the runtime or the SDK. The BCL has a class called <code>SerialPort</code> that receives the commands from your code and translates them to the next layer, where the .NET runtime hands over the commands to the operating system. In our case, that is Windows. Windows looks at the data and where it needs to go and decides it cannot handle it. It is hardware, so the operating system calls upon the device driver for the USB port.</p>
			<p>The device driver ensures it has everything needed for the specific hardware it is written for. It knows about baud <a id="_idIndexMarker672"/>rates, parity, stop bits, and so on. Once that is all figured out, the device driver sends the data to the USB/serial controller. This controller is a bit of hardware that physically connects to the port.</p>
			<p>Once the data has come that far, it leaves our system on a set of wires, out of our machine, and on its way to some other hardware.</p>
			<p>A lot is going on, but we hardly see it. All we see in our code is the following:</p>
			<pre class="source-code">
using var serialPort = new SerialPort(
    "COM3",
    9600,
    Parity.None,
    8,
    StopBits.One);
serialPort.Open();
try
{
    serialPort.Write([42],0, 1);
}
finally
{
    serialPort.Close();
}</pre>			<p>We create an instance of the <code>SerialPort</code> class. We give it the parameters it expects. First, we need to specify which port we want to talk to. Computers usually have more than one serial port. In the old days, computers did have a minimal number of physical ports. They were either parallel ports, capable of sending multiple bits simultaneously, or serial ports, which could only process one bit simultaneously. The serial ports were also called <strong class="bold">Communication Ports</strong>, shortened<a id="_idIndexMarker673"/> to <strong class="bold">COMs</strong>. In my example, we connect to the third one because I <a id="_idIndexMarker674"/>happen to know there is hardware attached to that port that I can talk to.</p>
			<p>I also give it the speed – in my case, 9,600 baud.</p>
			<p class="callout-heading">Baud versus bits per second</p>
			<p class="callout">There is a common misconception about the best way to describe the speed of communications. We used <strong class="bold">baud</strong> for the older<a id="_idIndexMarker675"/> COM ports. The term <em class="italic">baud</em> is named after the French scientist Jean-Maurice-Emile Baudot (1845–1903), who worked on a system to allow multiple transmissions of a single telegraph wire. Baud stands for the number of signal changes per second.</p>
			<p class="callout"><em class="italic">Bits per second</em> means just that – how many bits per second can we send? Since baud is analog and can combine signals, there is no direct relationship between baud and bits per second.</p>
			<p class="callout">However, in most cases, they are pretty close. 9,600 baud can be considered to be around 9,600 bits per second. But don’t rely on it!</p>
			<p class="callout">On a related note, a byte does not have to be 8 bits. A byte transmitted over a wire can be as long as 12 bits, depending on the communication settings.</p>
			<p>We also define <strong class="bold">parity as none</strong>. We set the data packet to be 8 bits. We also add 1 stop bit.</p>
			<p>The settings I have given here (no parity, 8 bits, and 1 stop bit) are the default settings, but you could have omitted them. However, you must ensure the device on the other side of the line uses the same settings. You can imagine what a mess it would be if you send 10 bits per byte, some of which are for error checking, and the other side expects only 8 bits to be sent per byte. It is better to be clear about this sort of thing.</p>
			<p>Once we have <code>SerialPort</code>, we can open the connection. And when that is done, we send 1 byte over the wire. Somewhere in the chain from our application to the actual wires, the parity, conversion to the correct number of bits, and stop bits are added or converted, but we have nothing to do with that. The BCL, OS, and device drivers take care of it.</p>
			<p>Of course, we finalize it all by closing the port again.</p>
			<p>Receiving data is just as <a id="_idIndexMarker676"/>simple, but we will look at that later on.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>Why do we care?</h2>
			<p>Serial communication, especially over COM ports, is old-school technology. These days, we use a wired network, Wi-Fi, Bluetooth, or USB if we want to connect to other hardware. Or, at least, that is what you might think.</p>
			<p>For most software developers, this is true. They will hardly ever encounter a thing such as a serial port. But we<a id="_idIndexMarker677"/> system programmers are not like most software developers. We deal with hardware. And often, that hardware is old. Or at least the design of that hardware is old.</p>
			<p>For instance, many factories have robots. A lot of them communicate over serial ports. Medical devices are another example. It takes a very long time to certify medical equipment, so the manufacturer is usually very reluctant to change part of the hardware just because a new kind of cable has been announced. They tend to stick to what works. As long as serial communications work well enough, they keep using them.</p>
			<p>Industrial CNC machines, barcode scanners, and GPS receivers are all examples of hardware still used widely today that rely on serial ports. We system programmers are the developers most likely to encounter those devices.</p>
			<p>So, it’s crucial that you know what serial communication is and what it does. But, of course, how can you program for it?</p>
			<p>Although you are not likely to see actual D-Port-style serial connectors on computers anymore (unless you specifically add one), serial ports are still a thing. The difference between those older ports and what we use today is that we use virtual COM ports.</p>
			<p>The operating system and the device drivers channel communication through the USB port to the outside world, mimicking the older ports. The D-style ports had multiple pins for power, ground, data, TX signals, and much more. These days, the USB devices take care of that. But if you want to connect to one of these older machines, you can get cheap and simple USB-to-serial (or, technically, RS232) converters.</p>
			<p>I suspect we will have serial ports for a long time to come. That is why I’m spending so much time discussing them here in this chapter.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor214"/>A word about parity, data sizes, and stop bits</h2>
			<p>We set the serial port in the previous sample to use no parity, 8 data bits, and 1 stop bit. But what does that mean?</p>
			<p>Usually, you do not need to care about how the actual hardware communicates. If you want to load a file from your storage medium, you are not bothered by the internal workings. You do not care whether the <a id="_idIndexMarker678"/>medium is a super-fast SSD or a slow SD card inserted somewhere. You choose where to store your data, and you are good to go. The operating system and device drivers take care of the rest.</p>
			<p>For COMs, this isn’t an <a id="_idIndexMarker679"/>option. You do not have to worry about the voltages across the wires, but you have to know a bit more about how the devices want to communicate. Oh, in case <a id="_idIndexMarker680"/>you are wondering, for low-speed USB devices, the voltages are between 0.0V and 0.3V for a zero and between 2.8V and 3.6V for a one. Now you know.</p>
			<p>So, what do we need to know if we want to communicate over a serial communication line? Well, there are four parameters we need to decide on. Both the sender and the recipient need to agree on this. The serial protocol does not care: it only knows how to put ones and zeros on that line. We need to tell our software what that data means.</p>
			<p>The parameters we need to set are the speed, whether we want to use parity, the size of a data packet, and whether we want to use stop bits.</p>
			<h3>Speed</h3>
			<p>Speed is essential. We specify the <a id="_idIndexMarker681"/>speed as the number of changes in voltages per second. We do not specify it in bits per second. This distinction is important because a bit is a discrete unit. A bit is a bit. Nothing more, nothing less. But a bit does not exist in the world of electronics; all we can deal with is a flow of electrons, making up voltages (I am really oversimplifying things here, but the basic idea is valid).</p>
			<p>If a wire has a high voltage for a second, followed by a low voltage for a second, we have no idea what that means. It is just that – one second of high voltage, followed by one second of low voltage.</p>
			<p>But if we establish that we can do four changes per second, we can determine that we got eight changes; the first four were high, and the second four were low. Then, we can agree that we had four 1s, followed by four 0s. Thus, in two seconds, we transmitted the bits 11110000. But if we would <a id="_idIndexMarker682"/>have established that we can do eight changes per second, the data would have been 11111111 00000000. And that is an entirely different number.</p>
			<p>The baud rate, which we use to specify the speed, tells a system how much data is transmitted in a certain time or how long it takes to send one element (OK, this is a bit) over the wire.</p>
			<p>It’s all about timing, which can help hardware do some rudimentary error checking. I will explain this when we talk about stop bits.</p>
			<h3>Parity</h3>
			<p>Sometimes, data gets messed up. We are<a id="_idIndexMarker683"/> dealing with electrical connections here, which can sometimes be unreliable. Sometimes, the voltage drops or a spike occurs, getting in the way of the data we want to send. There are several advanced ways to handle this, but the oldest and easiest way to do some rudimentary checking is by using parity.</p>
			<p>Three kinds of parity checks exist – <strong class="bold">even, odd, and none</strong>. None is the simplest – we do not want any checks.</p>
			<p>The other two, even and odd, mean we add one extra bit to each data packet. That extra bit is either a one or a zero, so the total number of ones in the packages, including the parity bit, is an even or odd number.</p>
			<p>Let’s say we want to transmit the following sequence of 4 bits – 1011. If the parity is set to even, the system counts the number of ones in that message. It notices there are three, which is an odd number. We need to make it even, so the system adds a one to the package and sends that over the wire, resulting in the bits 10111.</p>
			<p>If we had chosen to send 1001 over the wire, the number of ones is already even, so there is no need for an extra one. The system adds a zero and sends 10010 over the wire.</p>
			<p>On the receiving end, the system counts the numbers of one in the package and checks to see whether it is indeed an even number. If that is not the case, something has gone wrong. The system can then ignore that package or request a resend.</p>
			<p>Of course, if we had set the parity to odd, it would have only added a one if the number of ones in the data package was even.</p>
			<p>If two bits flip instead of just one, the <a id="_idIndexMarker684"/>system falls apart. There is no way to tell that that happened with this simple setup. There are other ways to do that, but you must implement them yourself.</p>
			<p>Parity does add data to a package, slowing communications down slightly.</p>
			<h3>The data size</h3>
			<p>How significant is a byte? I guess you <a id="_idIndexMarker685"/>are inclined to say 8 bits. But in the early days of computing, this was not a fixed number. There were lots of 10-bit-based computers. Data transmission was slow and expensive back then, so they decided they could get away with sending only 7 bytes if they wanted to send text. After all, most ASCII characters fit in 7 bits. So why send extra data? I know that these days, it is hard to imagine people worrying about an extra bit, but remember that times change. For instance, the first modem I used to connect my computer to the outside world had a transmission speed of 1200/75. That means it could receive with a speed of around 1,200 bits per second, or roughly 120 bytes per second. But I could only upload with 75 baud. That is around 10 bytes per second. Removing one bit can make a big difference in those cases!</p>
			<p><code>SerialPort</code> allows you to choose the size of your data package. This size is the number of bits each package contains, not counting the parity bit or any stop bits. You can choose between 7 or 8 bits. Technically, you could specify other sizes. In reality, you never encounter that in practice.</p>
			<p>7 bits is enough for ASCII characters. If you use 8 bits, you double the amount of information you can transmit in one single go, but you also make it a bit slower. In the world of serial communication, this can be important.</p>
			<p>The default is 8 bits, but if you want to really get the most out of your system, 7 bits might be a good idea.</p>
			<h3>Stop bits</h3>
			<p>Then, we have <strong class="bold">stop bits</strong>. Stop bits <a id="_idIndexMarker686"/>are added to a data package to signal that it is the end of <a id="_idIndexMarker687"/>that package. You can decide between 1, 1.5, or 2 stop bits. The system adds these bits to the end of the package, usually ones. Adding data achieves three things – first, it signals the end of the package. It helps detect timing issues or errors and allows the hardware to catch up.</p>
			<p>Stop bits are not actual bits; they are not data. They do not reach the software at the end of the chain. Instead, they are a fixed amount of time when the voltage is high. This explains why we can have 1.5 stop bits. There is no <em class="italic">half a bit</em>, but you can set the voltage high for half the time it takes to transmit<a id="_idIndexMarker688"/> one bit. Remember when I said that timing can help detect errors? This is what I was talking about.</p>
			<p>If the receiving system thinks it has<a id="_idIndexMarker689"/> received the agreed-upon 8 data bits and parity bits, it expects a stop bit (assuming we set the stop bit to 1). If the voltage on the line is low, something has gone wrong. Combined with the parity bit, this can detect simple errors.</p>
			<p>The stop bits can be 1, 1.5, or 2 <em class="italic">bits</em> long (remember that they are not bits but the amount of time it takes to send a bit). Adding extra time between two packets means that a receiving system has time to process the bits it got, calculate the parity, and pass it on to the rest of the system before the next package arrives. Again, in these days of ultra-fast hardware, it seems weird to take that into account, but when serial communication was devised, adding 1, 1.5, or even 2 <em class="italic">bits</em> of pause could mean the difference between an excellent working system or a barrage of errors.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor215"/>Working with an Arduino</h2>
			<p>I do not have a medical MRI <a id="_idIndexMarker690"/>machine nearby, so I cannot show you how to connect to one of those using the discussed techniques. However, I do have another device lying around – an Arduino Uno.</p>
			<p>Arduinos are really cheap microcontrollers. Although an actual Arduino can set you back $20 to $30; comparable devices with the same capabilities can be found for about $5 to $7. For that price, you get a good running microcontroller that you can connect to your computer, program against, and use to hook up all sorts of hardware.</p>
			<p>The hardware is simple – a CPU, a USB connector, a little memory, and an EEPROM that can hold your program. Also, an Arduino has pins that you can use to connect to other hardware.</p>
			<p>You can program your Arduino with a<a id="_idIndexMarker691"/> free tool called the Arduino IDE. Now, this book is about systems programming with C# and .NET, and not about Arduino. But I need to talk about this briefly in case you decide to get an Arduino and follow along. If you do, great! If you don’t, continue reading until we get to the part about faking hardware.</p>
			<p>I chose Arduino because it uses a serial port to communicate with your computer. It is cheap, and many people <a id="_idIndexMarker692"/>have one lying around somewhere. Then, we can build an elementary device to talk to and have it talk to us. Do not worry if you have no experience with these devices; I will explain everything you need to know to follow along.</p>
			<p>We need to write some software for the Arduino. The code is simple and included in the GitHub repo that accompanies this book.</p>
			<p>But before we look at the code, let me explain the device we will create.</p>
			<h3>The device</h3>
			<p>I want our Windows machine to be<a id="_idIndexMarker693"/> more susceptible to the world outside its enclosure. I want it to be aware of sounds. I want a device that warns Windows when a loud noise is detected.</p>
			<p>We could use a microphone and plug that into the correct ports, but a microphone is complicated. It can record sounds in high fidelity. I do not want that; I only want to know whether there is a loud sound, not what kind of sound it is. Furthermore, we can only have one microphone in use at a time. So, if we were to use the microphone, we would not be able to use our machines to make Teams calls or anything like that.</p>
			<p>It’s best to offload that work to a separate device. To do that, we need a couple of things:</p>
			<ul>
				<li>An Arduino or a compatible device</li>
				<li>A breadboard. This is a piece of plastic with wires, allowing us to plug in hardware and connect them without soldering.</li>
				<li>A KY-037 sound detector. This very simple device puts out a voltage as soon as it “hears” a noise. They cost anywhere between $1.50 and $3.00.</li>
				<li>An LED and a 200 ohm resistor (optional). I thought it would be fun to light up an LED when the device hears a sound. You do not need this; the Arduino has a built-in LED we can also use.</li>
				<li>A USB cable to connect it all to our machine.</li>
				<li>Some wires to connect the different parts.</li>
			</ul>
			<p>The schematics for this <a id="_idIndexMarker694"/>device look like this:</p>
			<div><div><img alt="Figure ﻿9.1: The sound detector schematics" src="img/B20924_10_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: The sound detector schematics</p>
			<p>If you have never worked with this sort of electronics before, do not worry. It is not as scary as you might think. The thing at the bottom of the preceding figure is the Arduino. As I stated earlier, it has pins we can connect wires to hook it up with other hardware. I have used four wires here. The one from the bottom to the breadboard (the white piece of plastic) is connected to a 5-volt power supply from the Arduino. I have connected it to the lowest row on the breadboard.</p>
			<p>The breadboard works like this – all the little holes on the lowest row are electrically connected. That means if I plug in a wire with 5 volts on one of the holes in that row, all the other holes in that same horizontal row will also have 5 volts. The same happens with the second row from the bottom; they are also all horizontally connected. I use this for the ground connections. I hook<a id="_idIndexMarker695"/> one of the holes up with the Arduino’s <strong class="bold">GND</strong> (meaning <strong class="bold">ground</strong>) pins. All the wires I plug into the second row are connected to the ground.</p>
			<p>The red piece of electronics you see is connected to the breadboard. Except for the lowest two rows of the breadboard, each column is also connected. That means if I plug something into the hole in the first column (above the two bottom rows), all the holes above it are also connected. Columns are isolated from each other.</p>
			<p>The breadboard consists of two halves – a bottom and a top half. These two halves are entirely isolated; no wires run from one half to another. So, the top half of the breadboard is a mirror of the bottom half.</p>
			<p>I plugged the KY-037 (the red thing in the schematic) into the breadboard. I connected the 5-volt from the first row to the correct column. I did the same for the GND signal. Then, I connected a wire from the leftmost pin of the KY-037 directly to pin 8 of the Arduino.</p>
			<p>I did a similar thing for the LED; the plus side of the LED is connected to pin 13 of the Arduino, and the negative side is connected to a 200-ohm resistor that, in turn, is connected to the GND row of the breadboard (and, thus, to the GND of the Arduino).</p>
			<p>Are you with me so far?</p>
			<p>The idea is simple – if the KY-037 detects a sound, it will (if powered by the 5 volts from the Arduino) put a voltage on the D0 line connected to pin 8 on the Arduino. If that happens, the microprocessor can pick that up and put a voltage on pin 13. That will light up the LED.</p>
			<p>If the sound is dropped, the voltage on pin 8 will also go to LOW, and we can program the Arduino to stop the LED. That is, of course, achieved by removing the voltage from pin 13.</p>
			<h3>The Arduino software</h3>
			<p>We need to instruct the Arduino on how to<a id="_idIndexMarker696"/> behave. That means we have to program it. We can use the free Arduino IDE to write and deploy our software to the device. The device itself is simple; it can only have one program. That program starts as soon as the device is powered on and does not stop until the power is removed. There is no real operating system, no loading, and no multitasking.</p>
			<p>The program itself is also straightforward. It consists of two parts. The first part is a method called <code>setup()</code>. This method is called as soon as the program starts (or as soon as the Arduino powers up). It is called only once and is a good place to do some initialization.</p>
			<p>There is another method called <code>loop()</code>. This method is, as the name suggests, a loop. The Arduino goes through the code in <code>loop()</code>, and restarts at the beginning of <code>loop()</code> as soon as it <a id="_idIndexMarker697"/>reaches the end. And that’s it. Of course, you can (and should) write your own methods and functions, but this is needed to get the device going.</p>
			<p>The programming is done in C (technically, it can be C++, but let’s not go there). The IDE can compile the code for you and deploy it to an attached Arduino. When you connect your Arduino through a USB cable to your machine, the IDE recognizes it and knows how to talk to the microcontroller.</p>
			<p>The software I want to use looks like this:</p>
			<pre class="source-code">
#define LedPin 13
#define SoundPin 8
int _prevResult = LOW;
void setup() {
  pinMode(LedPin, OUTPUT);
  pinMode(SoundPin, INPUT);
  Serial.begin(9600);
}
void loop() {
  int soundPinData = digitalRead(SoundPin);
  if(soundPinData != _prevResult){
    _prevResult = soundPinData;
    if(soundPinData == HIGH)
    {
      Serial.write(1);
      digitalWrite(LED_BUILTIN, HIGH);
    }
    else
    {
      Serial.write("0");
      digitalWrite(LED_BUILTIN, LOW);
    }
    delay(100);
  }
}</pre>			<p>And that’s it.</p>
			<p>Let’s explore it.</p>
			<p>First, I define some constants. I create the <code>LedPin</code> constant and set it to 13. This pin 13 is the number of the pin we connect the LED to see whether sound is detected. I chose pin 13 because most Arduino<a id="_idIndexMarker698"/> devices have a built-in LED on the board, connected to pin 13. So, if you do not want an external LED, you can look at the board and see the same effect.</p>
			<p>I also define the pin that the KY-037 uses to send the signal back to us, pin 8, and I call it <code>SoundPin</code>. There is no specific reason I chose pin 8; it was conveniently located on the Arduino, so I could easily attach it to the breadboard.</p>
			<p>Then, we have the <code>setup()</code> method. Again, this is used to initialize the system. We do three things here:</p>
			<ul>
				<li>We set the direction of pin 13 to <code>OUTPUT</code>; we do this by calling <code>pinMode(LedPin, OUTPUT)</code>. This direction means that the Arduino can use this pin to write to. We need this to turn the LED on or off.</li>
				<li>We set the direction of pin 8 to <code>INPUT</code>, by calling <code>pinMode(SoundPin, INPUT)</code>. Now, the Arduino knows we want to read from that pin instead of writing to it.</li>
				<li>We open the serial port. We do that by calling <code>Serial.begin(9600)</code>. This opens the serial connection through the USB connector to whatever it connects. We tell it we have a speed of 9600 baud. We could have specified the parity, packet size, and the number of stop bits, but the defaults (no parity, 8 bits, and 1 stop bit) are good enough<a id="_idIndexMarker699"/> for us. We need to remember these settings, as we will need them at the receiving end as well.</li>
			</ul>
			<p>Then, we can look at the <code>loop()</code> method.</p>
			<p>We begin with reading from the <code>SoundPin</code> pin. We do that by calling <code>digitalRead(SoundPin)</code>. Remember that the KY-037 adds voltage to the device when it hears a sound. We can read that result; the voltage level is translated into a one or a zero. We compare that with the results of the previous reading; if the value is different than before, we suddenly hear something (or stop hearing something). If that is the case, we determine whether there was a sound and add that information to the serial bus; we use <code>Serial.write(1)</code> or <code>Serial.write(0)</code> to send that value. You can as quickly send a string over the serial port by calling <code>Serial.PrintLn("My data")</code>. However, we do not need that in this case.</p>
			<p>Then, depending on the conditions, we turn the LED on or off. Just like we used <code>digitalRead()</code> to read the state of a pin, we can now use <code>digitalWrite()</code> to set the state.</p>
			<p>Finally, we call <code>delay(100)</code> to give the sound 100 milliseconds to die out.</p>
			<p>And then it starts all over again; we are in a loop after all.</p>
			<p>That’s it. Upload that program to the Arduino and watch what happens. If you make a noise, you will see the LED light up. You haven’t seen the effect of a <code>serial.print()</code> yet, but we will fix that next.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor216"/>Receiving serial data with .NET</h2>
			<p>We have done a lot already. But that was just<a id="_idIndexMarker700"/> the setup to get to where we really want to be as system programmers – dealing with code in our C# programs.</p>
			<p>I have written a sample that does just<a id="_idIndexMarker701"/> that; it opens the serial port, and it gets data. That in itself is not too hard; I have shown you how to open <code>SerialPort</code> and write data to it. Reading data from that same port is just as easy; <code>SerialPort.ReadLine()</code>, for instance, is one way of doing it.</p>
			<p>However, there are a lot more considerations when dealing with other hardware, and that’s what we will discuss here.</p>
			<p>First, the sample I provide is not a console application. It is a worker service. I chose this template because I want this code to work quietly in the background and only do something when data comes in on the serial bus. This is the closest we can get to writing a device driver in .NET. Second, USB and serial ports are brittle. It’s not that they fail a lot, but it is extremely easy to remove a device and plug it in again. You can never be sure that the device you need is attached to your computer.</p>
			<p>Users rarely remove their primary hard drive. Network adapters tend to stay inside. Network cables can be removed but hardly ever are. USB devices, however, are plugged in and removed again<a id="_idIndexMarker702"/> all the time. Sometimes, that happens intentionally, and sometimes, your cat decides to play around with that thing with blinky lights and wires hanging out of it (yes, that happened to me when I was writing this chapter).</p>
			<p>If we cannot rely on the presence of the device we want to talk with, we need to make sure it is there before we do something. We also need to handle a scenario where the device gets unplugged while working with it.</p>
			<p>Luckily, we already know how to do this. In previous chapters, we looked into <strong class="bold">Windows Management Instrumentation</strong> (<strong class="bold">WMI</strong>). That allowed us to investigate the hardware attached to our machine, and we<a id="_idIndexMarker703"/> saw that it could raise events if something changed. That sounds like something we can use here.</p>
			<h3>Watching the COM ports</h3>
			<p>I created a class called <code>ComPortWatcher</code>. As the name suggests, this watches the <code>IComPortWatcher</code> interface, which<a id="_idIndexMarker705"/> looks like this:</p>
			<pre class="source-code">
public interface IComPortWatcher : Idisposable
{
    event EventHandler&lt;ComPortChangedEventArgs&gt;? ComportAddedEvent;
    event EventHandler&lt;ComPortChangedEventArgs&gt;? ComportDeletedEvent;
    void Start();
    void Stop();
    string FindMatchingComPort(string partialMatch);
}</pre>			<p>The interface declares two events. These events get called when a device we are interested in is plugged into a computer or when such a device is removed again. Other classes can subscribe to these events and take action.</p>
			<p>We have a method called <code>Start()</code> that starts watching the ports. <code>Stop()</code> does the opposite – it stops watching the ports.</p>
			<p>I also added a method called <code>FindMatchingComPort</code>(<code>string partialMatch</code>). All devices have a set of properties, sometimes including the Caption. That Caption contains some information about the device attached to our machine. In the case of the Arduino, <code>Caption</code> contains the <code>Arduino</code> string and the actual COM port. This method tries to find that string and extracts the correct COM port, so we can use that to open the serial connection.</p>
			<p>Let’s look at the implementation. We will start with the easiest, <code>FindMatchingComPort(string partialMatch)</code>. This is what that looks like:</p>
			<pre class="source-code">
public string FindMatchingComPort(string partialMatch)
{
    string comPortName;
    var searcher = new ManagementObjectSearcher(
        @$"Select * From Win32_PnPEntity Where Caption Like           '%{partialMatch}%'");
    var devices = searcher.Get();
    if ( devices.Count &gt; 0)
    {
        var firstDevice = devices.Cast&lt;ManagementObject&gt;().First();
        comPortName = GetComPortName(firstDevice["Caption"].          ToString());
    }
    else
    {
        comPortName = string.Empty;
    }
    return comPortName;
}</pre>			<p>I am skipping a lot of error checking and safeguarding; otherwise, the code becomes too long to read. I am sure that you<a id="_idIndexMarker706"/> can spot what I left out and figure out how to do that yourself. Here I have focussed on only the essential parts.</p>
			<p>First, I create a new instance of the <code>ManagementObjectSearcher</code> class. I give it the <code>"Select * From Win32_PnPEntity Where Caption Like '%{partialMatch}%'"</code> search string. This searches through all Plug and Play devices and tries to match the caption of those devices with whatever string we pass in. Again, in my case, I give it the <code>Arduino</code> string.</p>
			<p>If there are no matches, we simply return an empty string, stating that no Arduino devices are found. However, if one is found (I only check for one; this is one of those areas you can improve a lot on), I take that caption and use some <code>GetComPortName()</code> method) to extract the name of the COM port.</p>
			<p>That RegEx code looks like this:</p>
			<pre class="source-code">
private string GetComPortName(string foundCaption)
{
    var regExPattern = @"(COM\d+)";
    var match = Regex.Match(foundCaption, regExPattern);
    return match.Success? Match.Groups[1].Value : string.Empty;}</pre>			<p>This code is pretty straightforward. We take the <code>"(COM\d+)"</code> RegEx pattern, which means we look for the string COM, followed by one or more numbers. Then, we return that part of the string. The caption of the port on my machine looks like <code>Arduino Uno (COM4),</code> so this method<a id="_idIndexMarker707"/> returns, in my case, the <code>COM4</code> string.</p>
			<p>The <code>Start()</code> method of this class sets up the watchers. We have two private members in the class:</p>
			<pre class="source-code">
private ManagementEventWatcher? _comPortDeletedWatcher;
private ManagementEventWatcher? _comPortInsertedWatcher;</pre>			<p>These are the WMI watchers that can trigger events when something interesting happens. What we define as interesting is specified in the <code>Start()</code> method. Here it goes:</p>
			<pre class="source-code">
public void Start()
{
    if (_isRunning)
        return;
    var queryInsert = "SELECT * FROM __InstanceCreationEvent WITHIN 1                       " +
                      "WHERE TargetInstance ISA 'Win32_PnPEntity' " +
                      "AND TargetInstance.Caption  LIKE
                      '%Arduino%'";
    var queryDelete = "SELECT * FROM __InstanceDeletionEvent WITHIN 1                       " +
                      "WHERE TargetInstance ISA
                      'Win32_PnPEntity' " +
                      "AND TargetInstance.Caption  LIKE
                      '%Arduino%'";
    _comPortInsertedWatcher = new
       ManagementEventWatcher(queryInsert);
    _comPortInsertedWatcher.EventArrived += HandleInsertEvent;
    _comPortInsertedWatcher.Start();
    _comPortDeletedWatcher = new ManagementEventWatcher(queryDelete);
    _comPortDeletedWatcher.EventArrived += HandleDeleteEvent;
    _comPortDeletedWatcher.Start();
    _isRunning = true;
}</pre>			<p>First, I check to see whether this is not already<a id="_idIndexMarker708"/> running. There is no point in doing this twice. Then, I define the query string that defines the searches for both inserting and deleting devices.</p>
			<p>When a device is inserted, the <code>__InstanceCreatedEvent</code> class in the operating system gets information about that device. We query for that class, but only if the target is a Plug and Play device (<code>Win32_PnpEntity</code>) and <code>Caption</code> contains <em class="italic">Arduino</em>. I am not interested in any other device.</p>
			<p>I create a similar query string for the deletion event.</p>
			<p>Then, I create an instance of <a id="_idIndexMarker709"/>that <code>Watcher</code> class, give it the query, and set up the event handlers. Finally, I call <code>Start()</code> on the watchers so that they start doing what they are meant to do.</p>
			<p>The <code>Stop()</code> method stops the watchers and cleans them up. There is nothing special there, but you can look at the code in the GitHub repository for further details.</p>
			<p>The event handlers are slightly more interesting than the <code>Stop()</code> method. Have a look:</p>
			<pre class="source-code">
private void HandleInsertEvent(object sender, EventArrivedEventArgs e)
{
    var newInstance = e.NewEvent["TargetInstance"] as       ManagementBaseObject;
    var comPortName = GetComPortName(newInstance["Caption"].      ToString());
    Task.Run(() =&gt; ComportAddedEvent?.Invoke(this, new       ComPortChangedEventArgs(comPortName)));
}</pre>			<p>This method is called when the watcher sees an exciting event in the operating system. We take <code>EventArgs</code> (of type <code>EventArrivedEventArgs</code>), take the <code>NewEvent</code> property, and get the <code>TargetInstance</code> member. We cast that to its correct type, <code>ManagementBaseObject</code>, and remove the caption. Then, we extract the COM port name and call any attached event handler. Since I know the attached event handler will start the serial communication, I wrap it in a <code>Task.Run()</code> method, making it work asynchronously and, thus, stopping it from blocking the current thread. Remember that all things that take time, such as I/O, should be written as asynchronous code.</p>
			<p>The event handler for the delete event looks similar.</p>
			<p>With this class in place, we can sit back and relax. We can ensure a COM port is available when needed, and we can take<a id="_idIndexMarker710"/> action if it gets unplugged.</p>
			<h3>Wrapping the serial port</h3>
			<p>There is a slight problem with the <a id="_idIndexMarker711"/>serial port class in .NET. It is not written for this day and age. It is a leftover from a much slower world. It is not asynchronous. And that can be a problem. Serial communications are slow enough already, and all calls to it block the thread it runs on. We need to wrap the class into something more modern.</p>
			<p>I created an interface that shows us how to do this:</p>
			<pre class="source-code">
public interface IasyncSerial
{
    bool IsOpen { get; }
    void Open(string portName,
        int baudRate = 9600,
        Parity parity = Parity.None,
        int dataBits = 8,
        StopBits stopBits = StopBits.One);
    void Close();
    Task&lt;byte&gt; ReadByteAsync(CancellationToken stoppingToken);
}</pre>			<p>The interface has an <code>IsOpen</code> property that can help us prevent more than one connection from opening. We have the <code>Open()</code> method, and I wrote it so that the parameters are there, but when a user of this class omits them, the serial port gets created with the default settings.</p>
			<p>We have a <code>Close()</code> method that closes the connection.</p>
			<p>I also added a <code>ReadByteAsync()</code> method that reads 1 byte from the device. I do not need more; our sound detector<a id="_idIndexMarker712"/> device only sends 1 byte at a time.</p>
			<p>Let’s look at the implementation.</p>
			<p>First, I have a private member in the class:</p>
			<pre class="source-code">
private SerialPort? _serialPort;</pre>			<p>We have already encountered the <code>SerialPort</code> class, so the implementation of the <code>Open()</code> method should be familiar:</p>
			<pre class="source-code">
public void Open(
    string portName,
    int baudRate = 9600,
    Parity parity = Parity.None,
    int dataBits = 8,
    StopBits stopBits = StopBits.One)
{
    if (IsOpen) throw new InvalidOperationException("Serial port is       already open");
    _serialPort = new SerialPort(
        portName,
        baudRate,
        parity,
        dataBits,
        stopBits);
    _serialPort.Open();
    IsOpen = true;
}</pre>			<p>Nothing special happens here – we create an instance of the <code>SerialPort</code> class, give it the correct parameters, and then<a id="_idIndexMarker713"/> open it. That’s it.</p>
			<p><code>Close()</code> is even simpler – it only calls <code>Close()</code> on the <code>_serialPort</code> member. OK, it does that and a bit of cleaning up.</p>
			<p><code>ReadByteAsycn()</code> is a lot more interesting. It is the reason we wrote this class. Here it is:</p>
			<pre class="source-code">
public Task&lt;byte&gt; ReadByteAsync(CancellationToken stoppingToken)
{
    return Task.Run(() =&gt;
    {
        if (!IsOpen) throw new InvalidOperationException("Serial port           is not open");
        var buffer = new byte[1];
        try
        {
            _serialPort?.Read(buffer, 0, 1);
        }
        catch (OperationCanceledException)
        {
            // This happens when the device has been unplugged
            // We pass it a 0xFF to indicate that the device is no             // longer available
            buffer[0] = 255;
        }
        return buffer[0];
    }, stoppingToken);
}</pre>			<p>Again, we wrap the synchronous calls in <code>Task.Run()</code> so that the whole thing becomes asynchronous. We return that <code>Task</code> to the caller.</p>
			<p>We call <code>_serialPort?.Read(buffer,0,1)</code>. This results in one byte of data, if available. If no data is available, this call is blocked until the data is there. That is why we use <code>Task.Run()</code> – we do not want to block our entire system and wait for a single byte to come in.</p>
			<p>However, if the device is removed from our system while waiting for that data, we get <code>OperationCanceledException</code>. That makes sense; we are waiting for data from a device that no longer exists. We catch that exception and return the <code>0xFF</code> byte. Since we know we can only get a <code>0</code> or a <code>1</code> from the <a id="_idIndexMarker714"/>Arduino board (that’s how we programmed it), we can safely use this magical number here to indicate an error.</p>
			<p>Let’s see how we can use these two classes.</p>
			<h3>Making it all work together</h3>
			<p>I mentioned that we are building a <a id="_idIndexMarker715"/>worker service. This service runs in the background and does not influence other codes or programs. The default template gives you a class called <code>Worker</code>, where we can do the actual work. We shall add our code to this <code>Worker</code> class.</p>
			<p>But before doing that, we need to change the <code>Program</code> class slightly. One of the nice things about the worker service template is that it gives you dependency injection for free, out of the box. We can use that to register our <code>IAsyncSerial</code> and <code>IComPortWatcher</code> interfaces and their accompanying classes. That way, we do not have to create instances ourselves.</p>
			<p>The <code>Program</code> class needs to be changed to look like this:</p>
			<pre class="source-code">
var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddTransient&lt;IComPortWatcher, ComPortWatcher&gt;();
builder.Services.AddTransient&lt;IAsyncSerial, AsyncSerial&gt;();
builder.Services.AddHostedService&lt;Worker&gt;();
var host = builder.Build();
host.Run();</pre>			<p>As you can see, we registered <a id="_idIndexMarker716"/>our new interfaces and classes, making them available for anyone needing one. And that <em class="italic">anyone</em> in our case is the <code>Worker</code> class. Let’s look at the constructor:</p>
			<pre class="source-code">
public Worker(ILogger&lt;Worker&gt; logger,
    IAsyncSerial serial,
    IComPortWatcher comPortWatcher)
{
    _logger = logger;
    _serial = serial;
    _comPortWatcher = comPortWatcher;
    _comPortName = _comPortWatcher.FindMatchingComPort("Arduino");
    _deviceIsAvailable = !string.IsNullOrWhiteSpace(_comPortName);
    _comPortWatcher.ComportAddedEvent += HandleInsertEvent;
    _comPortWatcher.ComportDeletedEvent += HandleDeleteEvent;
    _comPortWatcher.Start();
    if (_deviceIsAvailable) StartSerialConnection();
}</pre>			<p>We set the incoming instances of our classes and then look for a COM port attached to an Arduino. If there is one, we can set the <code>_deviceIsAvailable</code> variable to true.</p>
			<p>We add the events that get called when the device is inserted or deleted. Then, if a device is already available, we start the serial connection.</p>
			<p>That method, <code>StartSerialConnection()</code>, looks like this:</p>
			<pre class="source-code">
private void StartSerialConnection()
{
    if (_serial.IsOpen)
        return;
    _serial.Open(_comPortName);
    _deviceIsAvailable = true;
}</pre>			<p>Since we have already done the <a id="_idIndexMarker717"/>hard work in the <code>AsyncSerial</code> class, we can simply call it <code>_serialOpen(_comPortName)</code>.</p>
			<p>The event handler for <code>ComportAddedEvent</code> does more or less the same thing:</p>
			<pre class="source-code">
private void HandleInsertEvent(object? sender, ComPortChangedEventArgs e)
{
    _comPortName = e.ComPortName;
    _logger.LogInformation($"New COM port detected: {_comPortName}");
    if (!string.IsNullOrEmpty(_comPortName))
        StartSerialConnection();
}</pre>			<p>The event gets the name of the COM port from the <code>ComPortWatcher</code> class. So, all we have to do here is save that name and start the communications.</p>
			<p>The actual work happens in the <code>ExecuteAsync</code> method of the worker. As you probably recall, the runtime calls this part of the class to do the actual work. Usually, this method contains a loop that gets repeated until <code>CancellationToken</code> signals that it needs to stop. Our version looks like this:</p>
			<pre class="source-code">
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        if (_deviceIsAvailable)
        {
            var receivedByte = await _serial?.              ReadByteAsync(stoppingToken);
            if (receivedByte == 0xFF)
            {
                StopSerialConnection();
                _logger.LogWarning("Device is ejected.");
            }
            else
            {
                _logger.LogInformation($"Data received:                   {receivedByte:X}");
            }
        }
        await Task.Delay(10, stoppingToken);
    }
}</pre>			<p>First, we check whether a device<a id="_idIndexMarker718"/> is available. There is no point in reading data if no device is attached, right?</p>
			<p>Call the new <code>ReadByteAsync()</code> method if there is a device, and check the results. If they return <code>0xFF</code>, we have a problem – the device is removed. Otherwise, we just display the data we have.</p>
			<p>And that’s all there is to it! That was quite a lot. We introduced the Arduino and built our own device from it. We learned what communication over serial ports looks like. We discussed extracting data from our serial ports and how to make it work asynchronously. All in all, I think you deserve a break. We covered a lot of ground here.</p>
			<p>Take a look at the complete sample in the GitHub repository to see the little details I left out here. However, with the information I just gave you, you have everything you need to start talking to serial devices!</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor217"/>Faking a serial device</h1>
			<p>I promised to discuss with you another thing – what to do if you have no device available. Well, there is a reason I used the <code>IComPortWatcher</code> and <code>IAsyncSerial</code> interfaces. We can mock them in <a id="_idIndexMarker719"/>a unit test and write fake code that mimics devices. And that is a pretty good idea, as serial communication is brittle and often fails. If you are developing your software, you want an environment you can rely on. Using these interfaces can help you.</p>
			<p>For instance, I can have another implementation of <code>IComPortWatcher</code> that contains a <code>Start()</code> method that looks like this:</p>
			<pre class="source-code">
public void Start()
{
    _timer = new Timer(2000);
    _timer.Elapsed += (sender, args) =&gt;
    {
        // Trigger the event every second
        if (_deviceIsAvailable)
        {
            ComportDeletedEvent?.Invoke(this, new               ComPortChangedEventArgs("COM4"));
        }
        else
        {
            ComportAddedEvent?.Invoke(this, new               ComPortChangedEventArgs("COM4"));
        }
        _deviceIsAvailable = !_deviceIsAvailable;
    };
    _timer.Start();
}</pre>			<p>If I plug this into <a id="_idIndexMarker720"/>my <code>Program</code> class, I can fake <code>ComPortWatcher</code>. The <code>Program</code> class looks like this:</p>
			<pre class="source-code">
#define FAKESERIAL
using _09_SerialMonitor;
using _09_SerialMonitor.Fakes;
var builder = Host.CreateApplicationBuilder(args);
#if FAKESERIAL
    builder.Services.AddTransient&lt;IComPortWatcher, FakeComPortWatcher&gt;();
    builder.Services.AddTransient&lt;IAsyncSerial, FakeAsyncSerial&gt;();
#else
    builder.Services.AddTransient&lt;IComPortWatcher, ComPortWatcher&gt;();
    builder.Services.AddTransient&lt;IAsyncSerial, AsyncSerial&gt;();
#endif
builder.Services.AddHostedService&lt;Worker&gt;();
var host = builder.Build();
host.Run();</pre>			<p>As you can see, I can easily switch between the real and fake code by defining the <code>FAKESERIAL</code>. Of course, you can do this better by <em class="italic">defining</em> this in your build profile and not in the source code. That way, you can choose which version you want to run.</p>
			<p>I will leave the implementation of <code>FakeAsyncSerial</code> to you.</p>
			<p>So, we have looked at programming your computer to send and receive data to and from the serial port, or COM ports. There are many ways to communicate with the outside world, but COM is still around. System programmers encounter that specific protocol quite often, and now you know how to work with it.</p>
			<p>We used an Arduino to mimic<a id="_idIndexMarker721"/> an external device. Of course, you might encounter many different kinds of devices. They all have their different use cases and ways of communicating. But they usually use a serial connection if they are attached to your machine through a cable. Now, you have seen how to set up such a connection and a test environment to fake a serial connection. But there is one more thing I want to discuss – how to make this sort of system more foolproof.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor218"/>Making it foolproof</h1>
			<p>We already saw that <a id="_idIndexMarker722"/>we can use WMI to intercept unwanted removal of devices. USB cables can be removed from a machine easily. One of their selling points is how easy it is to plug devices in and remove them again. From a user’s standpoint, that is great. But from a developer’s perspective, it is not so great.</p>
			<p>And even if the user (or your cat) doesn’t fiddle around with the cable, many things can get in the way of a reliable data stream.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor219"/>Reasons things go haywire</h2>
			<p>If your software fails, you can easily look up what happened. Well, not really easily – debugging software, especially low-level, multithreaded software, can be challenging. But it is doable.</p>
			<p>Dealing with issues from other hardware is much harder to solve. There are so many reasons things can go wrong. Let’s go <a id="_idIndexMarker723"/>through some of them.</p>
			<ul>
				<li><strong class="bold">Interference</strong>: The cables used for serial communication are simple – several copper wires carry the electrical signal. All cables are sensitive to interference, regardless of their use. Interference is the effect that happens when electrical signals cause a change in the electromagnetic field around them, which in turn can cause changes in other wires. In practice, you might notice errors if you have a long serial cable and leave that coiled up next to your device. The answer is to have shielded or shorter cables or ensure they are isolated from others.</li>
				<li><strong class="bold">Bad cables</strong>: Of course, even if you have a short, straight cable with no other cables nearby, you still might get errors. The cables might be damaged. The connectors might be faulty. The only way to test this is to use a metering device to check the cables and hardware. But even that does not always tell you all you need to know. Sometimes, the strains of copper are partially broken, meaning that sometimes they conduct the signals, and sometimes they don’t.</li>
				<li><strong class="bold">Incorrect baud rates</strong>: As explained earlier, the baud rate describes the number of signal changes per second. Both ends of the communication must use the same speed for their data. If you do not have that correctly set up, it might seem like everything works fine. However, you might get weird data streams instead of your expected valuable data.</li>
				<li><strong class="bold">Buffer overflows</strong>: Data streams need to be processed. Sometimes, that processing takes too long, so the driver must buffer the incoming data stream. The idea is simple – the device driver puts all data into a buffer as it comes in and passes that data on when the application asks for it. However, the buffer fills up if the application<a id="_idIndexMarker724"/> cannot handle that amount of data in time. Ultimately, the buffer is full; there is no unlimited amount of memory it can use. That will trigger errors on a very low system level, and the buffer overflows.</li>
				<li><strong class="bold">Driver issues</strong>: All hardware communicates through the driver. The driver is the last piece of software your commands or data pass through before they are translated into voltage differences. The driver is a piece of software written specifically for the hardware you have on your machine. It acts as a translator between the operating system and the hardware. But ultimately, it is software. And software can go wrong. Hence, drivers can also go wrong. If that happens, it is difficult to see why things do not work as expected. Drivers making mistakes are very hard to trace.</li>
				<li><strong class="bold">Port misconfiguration</strong>: As we saw, we need to set up a connection in a certain way. We must inform the system about the parity, the number of bits in a data package, and the number of stop bits we want. If we mix these settings up, we get data that does not make sense. Not all vendors of the devices you want to use are good at specifying the format they expect. Therefore, you might have to play around before it all works as it should.</li>
				<li><strong class="bold">Hardware failures</strong>: Ultimately, everything between your software and the device you talk to consists of many hardware components. And all of them can go wrong for several reasons. The port may be bad, or the barcode scanner might not work correctly. There could be so many things that go wrong when dealing with hardware.</li>
				<li><strong class="bold">Wrong data format</strong>: Serial communication is very basic. You get a stream of bits, and they can be grouped into a set of bytes. But then what? What does that mean? The format in which the data is translated must be clear at both ends; otherwise, you cannot understand each other.</li>
				<li><strong class="bold">Parity bit errors</strong>: Parity is an excellent way of detecting errors. But what if two bits <em class="italic">flip</em>? Parity does not help you there; if the sender sends 4 values of 1 over the wire, the parity bit <a id="_idIndexMarker725"/>might be set to 0 (if <em class="italic">parity = even</em> is used). But if one of these 1 values changes to 0, and a 0 value changes to 1, you still have a valid parity. However, the data might not make sense at all.</li>
				<li><strong class="bold">Cosmic radiation</strong>: This one is improbable, but it has happened. Cosmic radiation is, as the name suggests, radiation from space. It is around us all the time. It does not cause harm, but sometimes, every now and then, it hits a piece of hardware. And when that happens, 0 might become 1, or vice versa. This is even more unlikely to happen inside your computer; there is a lot of protection around your processor and memory. But this might happen a bit more often with a cheap serial cable.</li>
			</ul>
			<p>As you can see, there are a lot of things that can go wrong, and most of them are hard to prevent in your code. OK, I agree that the cosmic radiation issue is not a regular occurrence, at least not regular enough to worry about it (unless you write software that cannot go wrong under any circumstances, such as that used for medical equipment).</p>
			<p>There are ways to harden your code so that it doesn’t suffer too much from these potential issues. Let’s investigate what we can do.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor220"/>Hardening your code</h2>
			<p>There is very little you can do<a id="_idIndexMarker726"/> about failures on the hardware side. That just happens. But you can ensure your code doesn’t come to a screeching halt when the inevitable occurs.</p>
			<h3>Using Try…Catch</h3>
			<p>Using <code>Try…Catch</code> is one of the best ways to make sure your system stays in a predictable and manageable<a id="_idIndexMarker727"/> state. Do not try to catch <code>Exception</code>; instead, be <a id="_idIndexMarker728"/>more specific about the kinds of exceptions you catch and how you handle them.</p>
			<p>For instance, your code should look like this:</p>
			<pre class="source-code">
try
{
    // Attempt to read from the serial port
}
catch (TimeoutException)
{
    // Handle timeout, possibly retry
}
catch (IOException ex)
{
    // Handle I/O errors
    // Log or attempt recovery
}</pre>			<p>Catch all sorts of exceptions <a id="_idIndexMarker729"/>separately and deal with them.</p>
			<h3>Implementing a robust connection loop</h3>
			<p>I already mentioned this, but it is<a id="_idIndexMarker730"/> worth repeating – connections can get lost. Monitor the state of your connections, as we did earlier with the WMI objects. If something happens that should not have happened, deal with it and let the connection die gracefully.</p>
			<h3>Ensuring thread safety</h3>
			<p>If you are accessing your serial connections from multiple threads, use mechanisms such as a lock or semaphores to make your code as thread-safe as possible. You must prevent concurrent readings and <a id="_idIndexMarker731"/>writings in a system initially designed for a single-thread communication mechanism.</p>
			<h3>The use of CancellationToken</h3>
			<p>For long-running operations such <a id="_idIndexMarker732"/>as serial communication, ensure all<a id="_idIndexMarker733"/> methods carry <code>CancellationToken</code>. Then, when handling the data streams, keep a close eye on that token to see whether the system wants to cancel the operation.</p>
			<h3>Resource management</h3>
			<p>You only have a limited number of<a id="_idIndexMarker734"/> virtual serial ports and even fewer physical ports in your system. That is why you must be very careful to release the handles on the devices if you do not need them anymore. The best way to do this is to be sure you clean up after you are done; implement the <code>IDisposable</code> pattern. Try to limit the time you use a device, and always ensure you release it.</p>
			<h3>Logging and monitoring</h3>
			<p>As always, logging and monitoring are the best ways to keep track of what is going on. Without adequate logging, it is very hard or even impossible to trace what happens when things go wrong. Logging and <a id="_idIndexMarker735"/>monitoring are valuable tools to help you understand the specifics of an interaction with external hardware, especially during development. We discuss monitoring in <a href="B20924_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 10</em></a>, but remember that you need to do this, especially when dealing with external hardware.</p>
			<p>All in all, there are things you can do to make your software as robust as possible. But nothing comes for free; there is a performance overhead to all of this. But trust me – it is worth it. These days, software runs extremely fast, especially when compared to the slow speed at which most serial communications take place. You have plenty of time to check errors and ensure smooth communication. But do not make things too slow; as soon as you start getting buffer overflow errors, you are no longer helping a system. As always, test and measure before taking steps.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor221"/>Next steps</h1>
			<p>I hope you enjoyed our little field trip to devices outside the realm of our computer. Connecting other hardware to a machine can be much fun. As I said before, dealing with external devices is a very likely scenario for system programmers. The likelihood of encountering older, serial-based communication mechanisms is pretty high in our world.</p>
			<p>We have discussed what serial communications are and what devices use them. We examined their protocols, especially the parity, data packet size, and stop bits. We looked at an Arduino device that measured sounds and received data from that over a serial line. We also looked at what you can do if you do not have such a device at hand.</p>
			<p>We made the software testable and discussed the disasters that can or will happen when dealing with serial devices. Finally, we looked at some tips you can use to make your software more resilient against these failures.</p>
			<p>All in all, we did a lot of exploring. I repeatedly mentioned how important it is to log what is happening and that you should monitor your software, especially when dealing with external hardware; logging and monitoring are sometimes the only ways to figure out what went wrong.</p>
			<p>So, the next chapter is all about logging and monitoring. Are you ready for that?</p>
		</div>
	</body></html>