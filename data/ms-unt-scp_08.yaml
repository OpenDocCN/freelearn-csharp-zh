- en: Chapter 8. Customizing the Unity Editor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 定制Unity编辑器
- en: The Unity Editor is a powerful, general purpose game development tool. Nevertheless,
    there are times during development when you probably wished the editor offered
    a specific feature that it doesn't have or behaved in a particular way, simply
    because it would be more convenient for you and your specific game. Maybe you'd
    like the path editing features, batch renaming functionality, or mesh creation
    tools, among others. In such cases, you can search the Asset Store for add-ons
    that meet your needs. But even then, you may still not find what you need. Consequently,
    the focus then turns to how the editor can be adapted or customized to achieve
    your purpose. Thankfully, there are many ways Unity can be changed as a tool,
    and this chapter focuses on particular case studies. First, it explores how to
    create a **Batch Rename** tool for renaming multiple selected objects in one operation.
    Second, it covers how to create a color range field in the Object Inspector to
    blend between two colors using a slider. Third, it explores how to expose public
    C# properties in the Object Inspector for both setting and getting values. Lastly,
    it covers how to use C# attributes to create a localization toolkit that allows
    you to automatically change all in-game strings to a chosen language (English,
    French, and so on) at the touch of a button.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器是一个功能强大、通用的游戏开发工具。然而，在开发过程中，有时你可能希望编辑器提供一些它没有的功能，或者以特定的方式运行，仅仅是因为这对您和您的特定游戏来说会更加方便。也许您希望有路径编辑功能、批量重命名功能或网格创建工具等。在这种情况下，您可以在Asset
    Store中搜索满足您需求的插件。但即使如此，您可能仍然找不到您需要的东西。因此，关注点转向了如何调整或定制编辑器以实现您的目的。幸运的是，Unity作为工具有很多可以改变的地方，本章重点介绍了特定的案例研究。首先，它探讨了如何创建一个**批量重命名**工具，以便在一次操作中重命名多个选定的对象。其次，它涵盖了如何在对象检查器中创建一个颜色范围字段，使用滑块在两种颜色之间混合。第三，它探讨了如何在外部检查器中公开C#属性，以便设置和获取值。最后，它涵盖了如何使用C#属性创建一个本地化工具包，允许您通过点击按钮自动将所有游戏中的字符串更改为所选语言（英语、法语等）。
- en: Batch renaming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量重命名
- en: When creating scenes with multiple enemies, power-ups, props, or other object
    instances, you'll typically use the duplicate feature to clone objects (*Ctrl*
    + *D*). This leads to many objects sharing the same name. Now, while there's nothing
    technically wrong in name duplication per se, it's both inconvenient and untidy.
    It results in a hierarchy panel of many identically named objects, and it's practically
    impossible to distinguish between specific objects by their name alone. Furthermore,
    object searches in script using the `GameObject.Find` function cannot be relied
    on to retrieve the specific object that you need, since it could return any one
    of the identically named objects. The solution, then, is to name each object uniquely
    and appropriately. But doing this can be tedious, especially if you're working
    with many objects. Thus, there's a need for a Batch Rename tool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建包含多个敌人、增益物品、道具或其他对象实例的场景时，你通常会使用复制功能来克隆对象（*Ctrl* + *D*）。这会导致许多对象具有相同的名称。现在，虽然名称重复本身在技术上并没有错误，但它既不方便又杂乱无章。它会导致具有相同名称的对象层次面板，而且仅凭名称几乎无法区分特定的对象。此外，在脚本中使用`GameObject.Find`函数进行对象搜索时，不能依赖于检索到所需的特定对象，因为它可能返回任何具有相同名称的对象。因此，解决方案是为每个对象命名唯一且适当。但这样做可能会很繁琐，尤其是当你处理许多对象时。因此，需要一个批量重命名工具。
- en: 'This would, in theory, allow you to select multiple objects in the hierarchy
    panel and then to rename them automatically according to a numbered convention.
    The only technical problem with this is that Unity doesn''t natively support such
    a feature. But we can code it ourselves, as shown in the following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这将允许你在层次面板中选择多个对象，然后根据编号约定自动重命名它们。这个方法唯一的技術问题是Unity本身并不原生支持这样的功能。但我们可以自己编写代码来实现，如下面的截图所示：
- en: '![Batch renaming](img/0655OT_08_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![批量重命名](img/0655OT_08_01.jpg)'
- en: Creating a Batch Rename editor add-on
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创建批量重命名编辑器插件
- en: 'To begin customizing the Unity Editor, first create a folder named `Editor`
    inside the project. This is important. `Editor` is a special folder recognized
    by Unity as a place to house all the editor customizing scripts. Thus, if you
    plan on changing the Unity Editor, be sure all customizing scripts are inside
    the `Editor` folder. It doesn''t matter whether your project features multiple
    folders named `Editor`; the only thing that matters is that there''s at least
    one `Editor` folder and an editor script inside it, as shown here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始自定义 Unity 编辑器，首先在项目内创建一个名为 `Editor` 的文件夹。这很重要。`Editor` 是一个被 Unity 识别为存放所有自定义脚本的特殊文件夹。因此，如果你打算更改
    Unity 编辑器，请确保所有自定义脚本都位于 `Editor` 文件夹内。你的项目可以有多个名为 `Editor` 的文件夹，但唯一重要的是至少有一个 `Editor`
    文件夹，并且其中包含一个编辑器脚本，如下所示：
- en: '![Batch renaming](img/0655OT_08_02.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![批量重命名](img/0655OT_08_02.jpg)'
- en: Create an Editor folder for all editor scripts
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有编辑器脚本创建一个编辑器文件夹
- en: Next, we'll create a Batch Rename utility from the `ScriptableWizard` class.
    This class is an ancestor from which we derive new classes. All derived classes
    will work much like a pop-up utility dialog that can be launched from the Unity
    main menu. Their purpose is to present a set of options from which the user can
    choose before pressing a confirmation button that performs a one-time process.
    In other words, classes derived from `ScriptableWizard` are ideal for performing
    automated, one-time operations on single or multiple objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从 `ScriptableWizard` 类创建一个批量重命名实用工具。这个类是我们从中派生新类的一个祖先。所有派生类都将像可以从 Unity
    主菜单启动的弹出实用工具对话框一样工作。它们的目的是在用户按下执行一次性过程的确认按钮之前，向用户提供一组选项。换句话说，从 `ScriptableWizard`
    派生的类非常适合对单个或多个对象执行自动化的、一次性操作。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `ScriptableWizard` class can be found in the online
    Unity documentation at [http://docs.unity3d.com/ScriptReference/ScriptableWizard.html](http://docs.unity3d.com/ScriptReference/ScriptableWizard.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `ScriptableWizard` 类的信息可以在 Unity 在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/ScriptableWizard.html](http://docs.unity3d.com/ScriptReference/ScriptableWizard.html)。
- en: 'The following code sample 8-1 lists the complete source code for a Batch Rename
    utility:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例 8-1 列出了批量重命名实用工具的完整源代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the comments for code sample 8-1:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 8-1 的注释：
- en: '**Line 03**: The editor extensions should include the `UnityEditor` namespace
    that allows you to access editor classes and objects.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 03 行**：编辑器扩展应该包含 `UnityEditor` 命名空间，这允许你访问编辑器类和对象。'
- en: '**Line 06**: The `BatchRename` class derives not from `MonoBehaviour`, as with
    most script files, but from `ScriptableWizard`. Classes deriving from here will
    be treated by Unity like independent utilities that may be launched from the application
    menu.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 06 行**：`BatchRename` 类并非从 `MonoBehaviour` 继承，这与大多数脚本文件不同，而是从 `ScriptableWizard`
    继承。从这里继承的类将被 Unity 视为独立的工具，可以从应用程序菜单启动。'
- en: '**Lines 17-21**: The `MenuItem` attribute is prefixed to the `CreateWizard`
    function. This creates a menu entry in the application menu listed under **Edit/Batch
    Rename** and invokes the `CreateWizard` function when clicked on to display the
    **Batch Rename** window.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 17-21 行**：`MenuItem` 属性作为 `CreateWizard` 函数的前缀。这将在应用程序菜单中创建一个条目，列在 **编辑/批量重命名**
    下，并在点击时调用 `CreateWizard` 函数以显示 **批量重命名** 窗口。'
- en: '**Lines 8-16**: After `CreateWizard` is invoked, the `BatchRename` window shows.
    From here, all public class members (including **Base Name**, **Start Number**,
    and **Increment**) will automatically feature in the window as editable fields
    for the user.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 8-16 行**：在调用 `CreateWizard` 之后，`BatchRename` 窗口显示。从这里，所有公共类成员（包括 **基础名称**、**起始数字**和**增量**）将自动作为可编辑字段出现在窗口中，供用户编辑。'
- en: '**Lines 45-60**: The `OnWizardCreate` function is invoked as an event when
    the user presses the **Rename** button from the **Batch Rename** window. The button
    is called **Rename** in this case because of line 20\. The `OnWizardCreate` function
    iterates through all selected objects in the scene, if any, and renames them in
    sequence according to the **Base Name**, **Start Number**, and **Increment** fields,
    as shown here:![Batch renaming](img/0655OT_08_03.jpg)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 45-60 行**：当用户从 **批量重命名** 窗口中按下 **重命名** 按钮时，将调用 `OnWizardCreate` 函数作为事件。按钮被称为
    **重命名** 是因为第 20 行。`OnWizardCreate` 函数遍历场景中所有选定的对象（如果有），并根据 **基础名称**、**起始数字**和**增量**字段按顺序重命名它们，如下所示：![批量重命名](img/0655OT_08_03.jpg)'
- en: The Batch Rename tool
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 批量重命名工具
- en: 'To use the Batch Rename tool, just select a group of objects in the scene and
    then click on the **Batch Rename** option in **Edit** from the application menu.
    The **Base Name** field defines a string that needs to be prefixed to all object
    names, and the **Increment** field defines the amount by which an integer counter
    should increase that is prefixed to the base name. The **Start Number** value
    is the point from which all incrementing begins, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用批量重命名工具，只需在场景中选择一组对象，然后从应用程序菜单中的**编辑**选项点击**批量重命名**。**基础名称**字段定义了一个需要添加到所有对象名称前缀的字符串，而**增量**字段定义了整数计数器应该增加的量，该计数器将添加到基础名称前。**起始数字**值是所有增量开始的位置，如下面的截图所示：
- en: '![Batch renaming](img/0655OT_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![批量重命名](img/0655OT_08_04.jpg)'
- en: Renamed objects using the Batch Rename tool
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用批量重命名工具重命名的对象
- en: C# attributes and reflection
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#属性和反射
- en: 'From this point forward in the chapter, all editor extensions will rely heavily
    on the concepts of attributes and reflection. These concepts are not specific
    to Unity but refer to more general ideas in computer science, programming, and
    to their application in languages such as C# as well as in the .NET framework.
    Before proceeding to the next editor extension, let''s consider attributes and
    the related concept of reflection using the example of the `Range` attribute,
    which is native to Unity. Consider the following line of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章的这个点开始，所有编辑器扩展都将大量依赖属性和反射的概念。这些概念不仅限于Unity，而是指计算机科学、编程以及它们在C#语言以及.NET框架中的应用中的更一般性思想。在继续下一个编辑器扩展之前，让我们通过`Range`属性（这是Unity的固有属性）的例子来考虑属性和相关概念。考虑以下代码行：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This public variable will be displayed in the Object Inspector with an edit
    field that allows the user to type in any valid floating point number thereby
    setting the value of `MyNumber`, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公共变量将在对象检查器中显示，并带有允许用户输入任何有效浮点数的编辑字段，从而设置`MyNumber`的值，如下面的截图所示：
- en: '![C# attributes and reflection](img/0655OT_08_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![C#属性和反射](img/0655OT_08_05.jpg)'
- en: Entering in floating point values from the Object Inspector
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象检查器中输入浮点值
- en: 'This code works fine and is suitable in many cases, but there are times when
    it''s preferable to validate the numerical entry to within a range, clipping the
    numbers between a minimum and maximum. You can do this in the code using the `Mathf.Clamp`
    function but you can also validate the entry using an attribute. You can attach
    a `Range` attribute to the floating point variable (`MyNumber`) to display a slider
    instead of an edit box, as shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码运行良好，并且在许多情况下都适用，但有时验证数值输入到特定范围内（在最小值和最大值之间剪辑数字）更可取。您可以在代码中使用`Mathf.Clamp`函数来完成此操作，但您也可以使用属性来验证输入。您可以将`Range`属性附加到浮点变量（`MyNumber`）上，以显示滑块而不是编辑框，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on attributes can be found in the online Unity documentation
    at [http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes](http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于属性的信息可以在Unity在线文档中找到，请参阅[http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes](http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes)。
- en: When this code is compiled, the `MyNumber` variable displays differently in
    the Object Inspector, honoring the numerical range between `0` and `1`, as shown
    in the following screenshot. Notice that all numbers provided to the `Range` attribute
    as arguments must be explicit values known at compile time and not expressions,
    which depend on variables that can vary at runtime. All attribute values must
    be known at compile time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码编译时，`MyNumber`变量在对象检查器中的显示方式不同，遵循`0`和`1`之间的数值范围，如下面的截图所示。请注意，提供给`Range`属性作为参数的所有数字都必须是编译时已知的显式值，而不是依赖于变量（这些变量可以在运行时变化）的表达式。所有属性值都必须在编译时已知。
- en: '![C# attributes and reflection](img/0655OT_08_06.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![C#属性和反射](img/0655OT_08_06.jpg)'
- en: Using attributes to customize inspector display
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性自定义检查器显示
- en: 'So how do attributes work? In short, attributes are a form of metadata; they
    work like tags. Programmers can attach an attribute to a class, variable, or a
    method to associate data with it, which is known to the compiler. The attribute
    itself is entirely descriptive because it does nothing; it''s simply data. The
    importance of attributes arises because all the code based on .NET (or Mono) has
    the ability to step outside itself and become self-conscious, that is, the ability
    to look at all the classes and data types and instances contained inside the program.
    For each object in the program, its metadata (attributes) can be queried and examined.
    This ability of a program to "look at itself from the outside" is known as reflection
    as it''s like looking in a mirror. Of course, the program does not see itself
    in reverse or in distorted terms but rather as it truly is, including all its
    metadata. To give a quick example of reflection, try out the following code sample
    8-2\. This code will cycle through all the custom-made classes in your Unity application
    across all source files. Notice it doesn''t just list all the instances of classes
    in the scene but all classes themselves (that is, the blueprints, metaphorically
    speaking):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么属性是如何工作的呢？简而言之，属性是一种元数据的形式；它们就像标签。程序员可以将属性附加到类、变量或方法上，以将数据与之关联，这是编译器所知道的。属性本身完全是描述性的，因为它什么都不做；它只是数据。属性的重要性在于，所有基于.NET（或Mono）的代码都有能力跳出自身，变得有自我意识，也就是说，能够查看程序内部包含的所有类、数据类型和实例。对于程序中的每个对象，其元数据（属性）都可以被查询和检查。程序能够“从外部观察自己”的能力被称为反射，就像在镜子中观察一样。当然，程序并不是以相反或扭曲的方式看待自己，而是以它真正的方式，包括所有其元数据。为了快速举例说明反射，尝试以下代码示例8-2。此代码将遍历Unity应用程序中所有源文件中的所有自定义类。注意，它不仅列出了场景中类的所有实例，还列出了所有类本身（即蓝图，比喻来说）：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are the comments for code sample 8-2:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例8-2的注释：
- en: '**Lines 03-04**: Both the namespaces `System` and `System.Reflection` should
    be included as they feature all classes and objects necessary for performing reflection
    in .NET.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第03-04行**：应该包含`System`和`System.Reflection`这两个命名空间，因为它们包含执行.NET中反射所需的所有类和对象。'
- en: '**Line 12**: This `foreach` loop cycles through all classes (types) in the
    active assembly (that is, the compiled code, including all your custom made script
    files).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第12行**：这个`foreach`循环遍历活动程序集（即编译后的代码，包括所有自定义的脚本文件）中的所有类（类型）。'
- en: 'You can take the concept of reflection even further. For example, having listed
    all types from code sample 8-2, you can even list the methods, properties, and
    variables (`Fields`) for a type. Refer to the following code sample 8-3 that,
    given a specific type as an argument, will list all its public member variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将反射的概念进一步扩展。例如，在列出代码示例8-2中的所有类型之后，你甚至可以列出类型的所有方法、属性和变量（`Fields`）。参考以下代码示例8-3，它接受一个特定的类型作为参数，并将列出所有公共成员变量：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on bitwise operations, as used in this code sample, can be
    found online at [http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx](http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于位运算的更多信息，如本代码示例中所用，可以在以下网址找到：[http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx](http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx)。
- en: 'Most crucially, however, you can list the attributes assigned to a type too.
    This lets you query a type for its metadata and examine its properties at runtime
    as shown in the following code sample 8-4:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，你还可以列出分配给类型的属性。这让你可以在运行时查询类型的元数据并检查其属性，如下面的代码示例8-4所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code sample 8-4 demonstrates that all attribute data can be retrieved for
    a given data type in the code at runtime. This means data types and variables
    may have metadata associated with them, which can be retrieved and used to further
    influence how the objects should be handled. This is powerful for editor plugins
    because by creating our own custom-defined attributes that can be attached to
    data types and member variables, we can integrate our code with the Unity Editor
    without making its logical or runtime structure invalid. That is, we can tag variables
    in code with attributes to customize how they appear in the Unity Editor without
    invalidating or affecting it in terms of its logic or structure at runtime. Next,
    we'll see how to create custom attributes to customize the editor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例 8-4 展示了在运行时可以从代码中检索给定数据类型的所有属性数据。这意味着数据类型和变量可能与其关联元数据，这些元数据可以被检索并用于进一步影响对象的处理方式。这对于编辑器插件来说非常强大，因为通过创建可以附加到数据类型和成员变量上的自定义定义属性，我们可以在不破坏其逻辑或运行时结构的情况下将我们的代码与
    Unity 编辑器集成。也就是说，我们可以通过在代码中使用属性标记变量来自定义它们在 Unity 编辑器中的显示方式，而不会在运行时逻辑或结构上无效化或影响它。接下来，我们将看到如何创建自定义属性来自定义编辑器。
- en: Color blending
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色混合
- en: The `Range` attribute explored previously may be attached to integer and floating-point
    variables, by way of their declarations, to limit the accepted values for them
    between a minimum and maximum in the Unity Editor. In the Unity Editor, a slider
    control is substituted for an editable field that controls the accepted values
    for the variable. This does not, of course, affect the values assigned to the
    same variables in the code. In the code, at runtime, the `Range` attribute has
    no effect itself. Rather, the `Range` attribute simply controls how numerical
    public variables are presented in the Object Inspector, and how they are entered
    there via user input. Behind the scenes, an `Editor` class is querying object
    `Attribute` data through reflection to control how the data type is rendered in
    the Object Inspector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前探索的 `Range` 属性可以通过其声明方式附加到整数和浮点变量上，以限制在 Unity 编辑器中它们的最小值和最大值之间的接受值。在 Unity
    编辑器中，一个滑动控件代替了可编辑字段，用于控制变量的接受值。当然，这不会影响代码中分配给相同变量的值。在代码中，在运行时，`Range` 属性本身没有效果。相反，`Range`
    属性仅控制数值公共变量在对象检查器中的显示方式以及用户输入时如何输入。在幕后，一个 `Editor` 类通过反射查询对象的 `Attribute` 数据，以控制数据类型在对象检查器中的渲染方式。
- en: The `Range` attribute works well for numbers. But it'd be great to deploy similar
    behavior for other data types besides just numbers. For example, it's common to
    fade between different colors, such as fading from black to transparency to create
    fade-in and fade-out effects for scene transitions. This is known as Color Lerping
    (linear interpolation). That is, an intermediary color is generated between two
    extremes using a normalized float (between `0` and `1`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 属性在处理数字时表现良好。但若能将其类似行为应用于除数字之外的其他数据类型，那就更完美了。例如，在场景过渡时，从黑色渐变到透明度以创建淡入和淡出效果是很常见的。这被称为颜色线性插值（Color
    Lerping）。也就是说，通过一个归一化的浮点数（介于 `0` 和 `1` 之间）在两个极端颜色之间生成一个中间颜色。'
- en: 'An appropriate `Inspector` property for this data type would be a slider control
    as with the `Range` attribute, which controls the interpolated color between `0`
    and `1`, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类数据类型，合适的 `Inspector` 属性将是一个滑动控件，类似于 `Range` 属性，它控制 `0` 和 `1` 之间的插值颜色，如下所示：
- en: '![Color blending](img/0655OT_08_07.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![颜色混合](img/0655OT_08_07.jpg)'
- en: Lerping between two colors
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种颜色之间进行线性插值
- en: 'In essence then, we need to customize the editor such that whenever an object
    is selected in the scene, which has a public member of a custom type we specify,
    we''ll want to customize how the member is rendered inside the Object Inspector.
    This lets us present custom controls and inputs in the Object Inspector, which
    validates data entry for that member as opposed to simply accepting its defaults.
    To begin this process, let''s create a custom class and define all data for a
    total color blend. A color blend requires four variables, namely the `SourceColor`
    and `DestColor` marking the limits of the blend. Next, the `BlendFactor` is a
    normalized float between `0` and `1` (start and end) which determines which intermediary
    color should be generated through Lerping. And then, finally, the output color
    itself (`BlendedColor`). The complete class definition for this process is included
    in the following code sample 8-5:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，我们需要自定义编辑器，以便在场景中选中一个对象时，该对象具有我们指定的自定义类型的公共成员，我们希望自定义该成员在对象检查器中的渲染方式。这让我们能够在对象检查器中提供自定义控件和输入，从而验证该成员的数据输入，而不是简单地接受其默认值。为了开始这个过程，让我们创建一个自定义类，并定义整个颜色混合的所有数据。颜色混合需要四个变量，即标记混合范围的
    `SourceColor` 和 `DestColor`。接下来，`BlendFactor` 是一个介于 `0` 和 `1`（起始和结束）之间的归一化浮点数，它决定了应该通过插值生成哪个中间颜色。然后，最后，输出颜色本身（`BlendedColor`）。此过程的完整类定义包含在下面的代码示例
    8-5 中：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the `ColorBlend` class uses the `[System.Serializable]` attribute, Unity
    will automatically render the class and its members inside the Object Inspector
    when it''s added as a public member of a class. By default, all public members
    of `ColorBlend` will be rendered, and the `BlendFactor` field will be rendered
    as an editable field inside which numbers can be directly entered, including numbers
    outside `0` and `1`, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ColorBlend` 类使用了 `[System.Serializable]` 属性，当它作为类的公共成员添加时，Unity 将自动在对象检查器中渲染该类及其成员。默认情况下，`ColorBlend`
    的所有公共成员都将被渲染，`BlendFactor` 字段将作为一个可编辑的字段渲染，可以直接在其中输入数字，包括 `0` 和 `1` 之外的数字，如下所示：
- en: '![Color blending](img/0655OT_08_08.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![颜色混合](img/0655OT_08_08.jpg)'
- en: Exposing the Color Adjuster class by its defaults and by changing its properties
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过默认值和更改其属性来公开 `Color Adjuster` 类
- en: 'Let''s now start customizing how Unity should render this class inside the
    Object Inspector. Begin by creating a new attribute class called `ColorRangeAttribute`,
    as shown in the following code sample 8-6:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始自定义 Unity 如何在对象检查器中渲染此类。首先，创建一个新的属性类，命名为 `ColorRangeAttribute`，如下面的代码示例
    8-6 所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are the comments for code sample 8-6:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 8-6 的注释：
- en: '**Line 01**: The `ColorRangeAttribute` class defines a metadata structure that
    we can tag to other data types. Notice that it derives from `PropertyAttribute`.
    This signifies, above everything else, that `ColorRangeAttribute` is an attribute
    and metadata structure but not a regular class. It''s not supposed to be instantiated
    as a standard class is.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 01**: `ColorRangeAttribute` 类定义了一个元数据结构，我们可以将其标记到其他数据类型上。注意，它继承自 `PropertyAttribute`。这表明，除了其他一切之外，`ColorRangeAttribute`
    是一个属性和元数据结构，而不是一个常规类。它不应该像常规类那样被实例化。'
- en: '**Line 07**: The attribute has a constructor function that accepts eight floating-point
    values defining the RGBA channels for the source and destination colors of the
    Lerp. These will be used soon when attaching the attribute to a variable.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 07**: 该属性有一个构造函数，它接受八个浮点值，用于定义 Lerp 的源和目标颜色的 RGBA 通道。这些值将在将属性附加到变量时很快被使用。'
- en: 'Now, we''ll write a class declaring an instance of `ColorBlend` with the `ColorRangeAttribute`
    attribute attached. Even now, however, the addition of `ColorRangeAttribute` will
    do nothing per se because no `Editor` class has yet been written to handle it.
    We can see this in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个声明带有 `ColorRangeAttribute` 属性的 `ColorBlend` 实例的类。然而，即使现在，添加 `ColorRangeAttribute`
    本身也不会产生任何效果，因为没有编写处理它的 `Editor` 类。这可以在下面的代码中看到：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating an `Editor` class for rendering `ColorBlend` in the Object Inspector
    with a slider control involves handling the `ColorRangeAttribute` class. Specifically,
    Unity offers us the extension `PropertyDrawer` base class from which we can derive
    new classes to override the Object Inspector rendering for any specific attribute
    we add to our variables. In short, the `PropertyDrawer` class lets us customize
    inspector drawing for any and all variables tagged with a common attribute. Therefore,
    inside the `Editor` folder of your project, create a new `ColorRangeDrawer` class,
    as shown in the following code sample 8-7:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象检查器中使用滑动控件渲染 `ColorBlend` 的 `Editor` 类涉及处理 `ColorRangeAttribute` 类。具体来说，Unity
    提供了 `PropertyDrawer` 基类扩展，我们可以从中派生新类以覆盖任何添加到变量中的特定属性的 Object Inspector 渲染。简而言之，`PropertyDrawer`
    类让我们可以为带有公共属性的任何变量自定义检查器绘制。因此，在您的项目 `Editor` 文件夹中创建一个新的 `ColorRangeDrawer` 类，如下面的代码示例
    8-7 所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the comments for code sample 8-7:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 8-7 的注释：
- en: '**Line 01**: The `CustomPropertyDrawer` attribute is used here to associate
    the `PropertyDrawer` class with the `ColorRangeAttribute` attribute. The Unity
    Editor uses this metadata internally to determine which types require custom rendering
    in the Object Inspector. In this case, all members with `ColorRangeAttribute`
    will be drawn manually by the `OnGUI` function of the `PropertyDrawer` class.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第01行**: 这里使用 `CustomPropertyDrawer` 属性将 `PropertyDrawer` 类与 `ColorRangeAttribute`
    属性关联。Unity 编辑器使用此元数据内部确定哪些类型需要在对象检查器中进行自定义渲染。在这种情况下，所有带有 `ColorRangeAttribute`
    的成员都将由 `PropertyDrawer` 类的 `OnGUI` 函数手动绘制。'
- en: '**Line 11**: The `OnGUI` function is overridden from the base class to define
    how all fields with `ColorRangeAttribute` should be rendered in the Object Inspector.
    `EditorGUI` is a native Unity Editor utility class for drawing GUI elements, such
    as buttons, textboxes, and sliders. For more information on `EditorGUI`, see the
    online documentation at [http://docs.unity3d.com/ScriptReference/EditorGUI.html](http://docs.unity3d.com/ScriptReference/EditorGUI.html).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11行**: `OnGUI` 函数是从基类重写的，用于定义所有带有 `ColorRangeAttribute` 的字段在对象检查器中应该如何渲染。`EditorGUI`
    是一个原生的 Unity 编辑器实用工具类，用于绘制 GUI 元素，如按钮、文本框和滑动条。有关 `EditorGUI` 的更多信息，请参阅在线文档[http://docs.unity3d.com/ScriptReference/EditorGUI.html](http://docs.unity3d.com/ScriptReference/EditorGUI.html)。'
- en: '**Line 14**: The `OnGUI` function is called once, perhaps many times per second,
    for each unique member to render manually in the Object Inspector. The attribute
    data for `ColorRangeAttribute` is retrieved here with typecasting, and this gives
    us access directly to all its members for the current object being rendered. To
    access the member variables of the object itself (for read/write access), as opposed
    to its attribute, the `SerializedProperty` argument should be used, such as the
    `FindPropertyRelative` method. For more information, see the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/SerializedProperty.html](http://docs.unity3d.com/ScriptReference/SerializedProperty.html).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第14行**: `OnGUI` 函数会被调用一次，可能每秒调用多次，用于在对象检查器中手动渲染每个唯一的成员。在这里，使用类型转换检索 `ColorRangeAttribute`
    的属性数据，这使我们能够直接访问当前正在渲染的对象的所有成员。要访问对象本身的成员变量（用于读写访问），而不是其属性，应使用 `SerializedProperty`
    参数，例如 `FindPropertyRelative` 方法。有关更多信息，请参阅在线 Unity 文档[http://docs.unity3d.com/ScriptReference/SerializedProperty.html](http://docs.unity3d.com/ScriptReference/SerializedProperty.html)。'
- en: '**Line 24**: From here onwards, the `FindPropertyRelative` function is called
    to retrieve public member variables, such as the `SourceColor`, `DestColor`, and
    `BlendedColor` in the selected object. This is where the values are actually set
    by moving the slider component.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第24行**: 从这里开始，使用 `FindPropertyRelative` 函数来检索所选对象中的公共成员变量，例如 `SourceColor`、`DestColor`
    和 `BlendedColor`。这是通过移动滑动组件来实际设置值的。'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on the `PropertyDrawer` class can be found in the online Unity
    documentation at [http://docs.unity3d.com/Manual/editor-PropertyDrawers.html](http://docs.unity3d.com/Manual/editor-PropertyDrawers.html).
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 `PropertyDrawer` 类的更多信息，可以在在线 Unity 文档[http://docs.unity3d.com/Manual/editor-PropertyDrawers.html](http://docs.unity3d.com/Manual/editor-PropertyDrawers.html)中找到。
- en: 'The code sample 8-7 overrides the Object Inspector drawing for any `ColorBlend`
    instances when tagged with the `ColorRangeAttribute` attribute. This offers an
    accessible and easy-to-use way of creating blended colors. Remember, you can make
    your source and destination colors public, in order to be accessible from the
    **Inspector** tab, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例8-7在标记有`ColorRangeAttribute`属性时覆盖了任何`ColorBlend`实例的对象检查器绘制。这提供了一种易于访问和使用的创建混合颜色的方法。记住，你可以使源颜色和目标颜色公共，以便从**检查器**选项卡中访问，如下所示：
- en: '![Color blending](img/0655OT_08_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![颜色混合](img/0655OT_08_09.jpg)'
- en: Creating a ColorBlender display for the ColorBlend class
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为ColorBlend类创建ColorBlender显示
- en: Property exposing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性暴露
- en: 'By default, the Object Inspector displays all public member variables of a
    class unless it''s in **Debug** mode or a private member is explicitly marked
    with the `SerializeField` attribute and in these cases private member variables
    will be shown too:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对象检查器会显示类的所有公共成员变量，除非处于**调试**模式或私有成员被显式标记为具有`SerializeField`属性，在这些情况下，私有成员变量也会显示：
- en: '![Property exposing](img/0655OT_08_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![属性暴露](img/0655OT_08_10.jpg)'
- en: Property accessing from the Object Inspector
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象检查器访问属性
- en: However, C# properties will never be displayed by default, either in **Release**
    or **Debug** mode. As discussed in [Chapter 1](ch01.html "Chapter 1. Unity C#
    Refresher"), *Unity C# Refresher*, C# properties act like accessor functions to
    a variable. They essentially permit validation on each `get` and `set` operation
    because every `get` and `set` operation entails an internal function call. However,
    regardless of Unity's limitation in the Object Inspector, it's possible to write
    an editor extension that will show all properties for a class in the Object Inspector,
    which allows you to get and set the values directly. This section considers how
    in more detail. Again, we'll have reason to rely heavily on reflection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C#属性在默认情况下永远不会显示，无论是**发布**还是**调试**模式。如[第1章](ch01.html "第1章. Unity C# 快速入门")中所述，*Unity
    C# 快速入门*，C#属性类似于变量的访问器函数。它们本质上允许在每个`get`和`set`操作上进行验证，因为每个`get`和`set`操作都涉及内部函数调用。然而，无论Unity在对象检查器中的限制如何，都可以编写一个编辑器扩展，该扩展将在对象检查器中显示类的所有属性，从而允许直接获取和设置值。本节将更详细地考虑这一点。再次强调，我们将严重依赖反射。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `SerializeField` class can be found in the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/SerializeField.html](http://docs.unity3d.com/ScriptReference/SerializeField.html).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SerializeField`类的更多信息可以在Unity在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/SerializeField.html](http://docs.unity3d.com/ScriptReference/SerializeField.html)。
- en: 'Consider the following code sample 8-8 that features a few properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例8-8，其中包含一些属性：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This class will be used internally by a different class as a public member,
    as shown in the following code sample 8-9:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将作为公共成员由不同的类内部使用，如下面的代码示例8-9所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, the public `MyPropClass` member (although tagged as `System.Serializable`)
    will not show its members in the Object Inspector. This is because C# properties
    are not natively supported:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，公共`MyPropClass`成员（尽管标记为`System.Serializable`）在对象检查器中不会显示其成员。这是因为C#属性不是原生支持的：
- en: '![Property exposing](img/0655OT_08_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![属性暴露](img/0655OT_08_11.jpg)'
- en: By default, the Object Inspector will not render the C# properties
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对象检查器不会渲染C#属性
- en: 'To solve this issue, we can return to the `PropertyDrawer` class; this time
    associating the class with a specific class rather than an attribute, as shown
    in the following code sample 8-10:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以回到`PropertyDrawer`类；这次将类与一个特定的类相关联，而不是与一个属性相关联，如下面的代码示例8-10所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are the comments for code sample 8-10:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例8-10的注释：
- en: '**Line 08**: Notice that the `CustomPropertyDrawer` attribute is now associated
    with a regular class as opposed to an attribute. In this case, the rendering of
    a specific class is being customized for the Object Inspector as opposed to various
    properties of different types, which can share a common attribute.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第08行**：注意，`CustomPropertyDrawer`属性现在与一个常规类相关联，而不是一个属性。在这种情况下，特定类的渲染是为了对象检查器定制的，而不是不同类型的不同属性，这些属性可以共享一个公共属性。'
- en: '**Lines 12-18**: Some public members are declared, primarily to calculate the
    height (in pixels) of a single row in the Object Inspector. By default, the Object
    Inspector allocates one row (or line) for our custom rendering and all drawing
    is supposed to fit within that space. If the total height of our rendering exceeds
    the height of one line, all additional controls and data will overlap and mix
    with controls and widgets beneath. To address this problem, the `GetPropertyHeight`
    (at line 69) function can be used to return a pixel height allocated for our custom
    drawing.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 12-18 行**: 声明了一些公共成员，主要是为了计算对象检查器中单行的高度（以像素为单位）。默认情况下，对象检查器为我们的自定义渲染分配一行（或一行），并且所有绘图都应该适应这个空间。如果我们的渲染总高度超过一行的高度，所有额外的控件和数据都将重叠并混合在下面的控件和小部件中。为了解决这个问题，可以使用`GetPropertyHeight`（第
    69 行）函数来返回为我们的自定义绘图分配的像素高度。'
- en: '**Lines 26-27**: These lines are especially important. They use reflection
    to retrieve a type-correct object reference to the `ClassWithProperties` instance
    currently being drawn for this call to `OnGUI`. Specifically, a reference to `targetObject`
    is retrieved (the object selected), and then an instance to `ClassWithProperties`
    is retrieved from that. The result is that this code gives us direct and immediate
    access to the `ClassWithProperties` object.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 26-27 行**: 这些行特别重要。它们使用反射来检索对当前正在为`OnGUI`调用绘制的`ClassWithProperties`实例的正确类型对象引用。具体来说，检索到`targetObject`的引用（选中的对象），然后从该引用中检索到`ClassWithProperties`的实例。结果是，这段代码为我们提供了对`ClassWithProperties`对象的直接和即时访问。'
- en: '**Lines 37-58**: Each public property on the object is cycled in sequence,
    and for valid or supported data types, an inspector property is drawn that allows
    both read/write access to the property, provided the property itself supports
    both methods.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 37-58 行**: 对象上的每个公共属性按顺序循环，对于有效或支持的数据类型，绘制一个检查器属性，允许对属性的读写访问，前提是该属性本身支持这两种方法。'
- en: 'The following screenshot shows the C# properties:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了C#属性：
- en: '![Property exposing](img/0655OT_08_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![属性展示](img/0655OT_08_12.jpg)'
- en: Accessing C# properties
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 C# 属性
- en: Localization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化
- en: 'Perhaps one of the most underappreciated and underdocumented aspect of game
    development is localization. This refers to the broad range of technical, economic,
    and logistical measures a developer takes to support multiple natural languages
    in their game, such as English, French, German, Spanish, Esperanto, and so on.
    The technical aim is not so much to support this or that specific language, but
    rather to establish an infrastructure that could support any arbitrary language
    chosen at any time, now or later. The entire scope and role of localization in
    development is beyond the scope of this book, but here we''ll examine one way
    in which the Unity Editor can be customized to facilitate a quick and easy localization
    workflow. For example, consider the following sample XML file, in which game text
    for the buttons in a main menu system is defined in both English and a "spoof
    language" called Yoda:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发中最被低估和最缺乏文档记录的方面之一可能是本地化。这指的是开发者为了支持游戏中的多种自然语言而采取的广泛的技术、经济和物流措施，例如英语、法语、德语、西班牙语、世界语等等。技术目标并不是支持这个或那个特定的语言，而是建立一个可以支持在任何时候（现在或以后）选择的任何任意语言的架构。本地化在开发中的整个范围和作用超出了本书的范围，但在这里我们将探讨一种Unity编辑器可以定制以简化本地化工作流程的方法。例如，考虑以下示例XML文件，其中主菜单系统中按钮的游戏文本以英语和一种称为Yoda的“恶搞语言”定义：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice, the CDATA element encloses all custom text nodes to allow the use of
    any characters and symbols. More information on CDATA can be found online at [http://www.w3schools.com/xml/xml_cdata.asp](http://www.w3schools.com/xml/xml_cdata.asp).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CDATA 元素包围了所有自定义文本节点，以允许使用任何字符和符号。有关 CDATA 的更多信息，可以在网上找到：[http://www.w3schools.com/xml/xml_cdata.asp](http://www.w3schools.com/xml/xml_cdata.asp)。
- en: 'The XML defined earlier creates four text elements, one for each button on
    a sample user interface menu. Each text element is assigned a unique ID: `text_01`,
    `text_02`, `text_03`, and `text_04`. These IDs uniquely identify each item of
    text in the game and will match across all specified languages. The purpose here
    is to import the text file into Unity that allows the developer to switch between
    languages at the touch of a button, and have all relevant text elements in the
    game change automatically to accommodate the language switch. Let''s see how this
    works.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的XML创建了四个文本元素，每个元素对应于示例用户界面菜单上的一个按钮。每个文本元素都被分配了一个唯一的ID：`text_01`、`text_02`、`text_03`和`text_04`。这些ID唯一地标识了游戏中的每个文本项，并且将在所有指定的语言中匹配。这里的目的是将文本文件导入Unity，允许开发者通过点击按钮在语言之间切换，并且让游戏中的所有相关文本元素自动更改以适应语言切换。让我们看看它是如何工作的。
- en: First import the localized text into a `Resources` folder in a Unity project.
    Create a folder named `Resources` and then import the localized text file into
    it, as shown in the following screenshot. In code, this means any object or class
    can load or open the text file using a `Resources.Load` call, as we'll see soon.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将本地化文本导入Unity项目中的`Resources`文件夹。创建一个名为`Resources`的文件夹，然后将本地化文本文件导入其中，如图所示。在代码中，这意味着任何对象或类都可以使用`Resources.Load`调用加载或打开文本文件，正如我们很快将看到的。
- en: '![Localization](img/0655OT_08_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![本地化](img/0655OT_08_13.jpg)'
- en: Importing localized text into a project
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地化文本导入项目
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on resources can be found online at the Unity documentation
    at [http://docs.unity3d.com/ScriptReference/Resources.html](http://docs.unity3d.com/ScriptReference/Resources.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于资源的信息可以在Unity文档的在线资源中找到，请参阅[http://docs.unity3d.com/ScriptReference/Resources.html](http://docs.unity3d.com/ScriptReference/Resources.html)。
- en: 'The imported text file simply contains all text data to be included in the
    game, where each element is associated with its ID. Thus, each string value is
    married to an ID, and the ID is consistent across language schemes that allow
    a seamless transition between languages. The ID is the one common denominator
    that makes an automated localization possible. To implement the localization system
    in code, we''ll first create an attribute that should be applied to all localized
    strings. The attribute defines only the ID to be attached to a specific string
    variable, as shown in the following code sample 8-11:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文本文件简单地包含了要包含在游戏中的所有文本数据，其中每个元素都与它的ID相关联。因此，每个字符串值都与一个ID相关联，并且ID在语言方案中是一致的，这允许语言之间的无缝过渡。ID是使自动化本地化成为可能的一个共同分母。为了在代码中实现本地化系统，我们首先创建一个应该应用于所有本地化字符串的属性。该属性仅定义要附加到特定字符串变量的ID，如以下代码示例8-11所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the `LocalizationTextAttribute` attribute now created, we can apply it
    to string members in code, which associates them with a specific ID, as shown
    in the following code sample 8-12:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了`LocalizationTextAttribute`属性，我们可以在代码中将它应用于字符串成员，将它们与特定的ID关联起来，如以下代码示例8-12所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SampleGameMenu` class appears as a regular class in the Object Inspector,
    as shown in the following screenshot. Later, through our `Editor` class, we'll
    develop the ability to automatically change all string members to the selected
    language.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleGameMenu`类在对象检查器中显示为一个普通类，如图所示。稍后，通过我们的`Editor`类，我们将开发自动更改所有字符串成员到所选语言的能力。'
- en: '![Localization](img/0655OT_08_14.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![本地化](img/0655OT_08_14.jpg)'
- en: A SampleGameMenu class features all texture required for a sample menu screen
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: SampleGameMenu类包含示例菜单屏幕所需的所有纹理
- en: 'Now, we''ll code an `Editor` class to switch between languages. This class
    will add menu entries on the application menu, which when clicked will change
    the active language, as shown in the following code sample 8-13\. This sample
    draws on a range of related concepts we''ve seen already, including new ones.
    Specifically, it uses the `Reflection`, `Linq`, and `Editor` classes as well as
    the Mono Framework XML handling classes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个`Editor`类来在语言之间切换。这个类将在应用程序菜单上添加菜单项，当点击时将更改活动语言，如以下代码示例8-13所示。这个示例借鉴了我们已经看到的一系列相关概念，包括新的概念。具体来说，它使用了`Reflection`、`Linq`和`Editor`类以及Mono框架XML处理类：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the comments for code sample 8-13:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例8-13的注释：
- en: '**Lines 02-07**: Remember to include wide range of namespaces as shown here.
    Our code will rely on them all to some degree.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行02-07**：请记住包括广泛的使用范围，如所示。我们的代码将在某种程度上依赖于它们。'
- en: '**Lines 11-23**: For this sample application, the three languages: **English**,
    **French**, and **Yoda** are selectable from the application menu. For your own
    projects, your language list may be different. But crucially, based on the localization
    system given here, integration of additional languages, even at a much later time,
    is easy.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11-23行**：对于此示例应用程序，可以从应用程序菜单中选择三种语言：**英语**、**法语**和**Yoda**。对于您自己的项目，您的语言列表可能不同。但关键的是，根据此处提供的本地化系统，即使在较晚的时间，集成额外的语言也很容易。'
- en: '**Line 32**: The `Resources.Load` function is called here to open the XML text
    file from the `Resources` folder in the project that extracts its text contents
    into one single concatenated string variable.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第32行**：在此处调用`Resources.Load`函数以从项目中的`Resources`文件夹打开XML文本文件，并将其文本内容提取到一个单一的连接字符串变量中。'
- en: '**Lines 35-36**: The XML string is loaded into an `XmlDocument` object, which
    is a Mono class encapsulating a complete XML file, either on disk or in memory.
    The class also validates the document on loading, which means an exception will
    be generated here if the file contains syntax errors.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第35-36行**：XML字符串被加载到一个`XmlDocument`对象中，这是一个封装了完整XML文件的Mono类，无论是磁盘上的还是内存中的。该类在加载时还会验证文档，这意味着如果文件包含语法错误，将在此处生成异常。'
- en: '**Line 53**: Once a language is selected from the XML file, all child nodes
    of the language (each node a unique string) are cycled to find a matching ID.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第53行**：一旦从XML文件中选择了一种语言，就会遍历该语言的子节点（每个节点都是唯一的字符串）以找到匹配的ID。'
- en: '**Line 61**: For each string entry, all public string members for the text
    class are searched for an appropriate `LocalizationTextAttribute` and when found,
    the string ID is compared to check for a match. When a match is found, the string
    variable is assigned the corresponding localized string.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第61行**：对于每个字符串条目，都会在文本类的所有公共字符串成员中搜索合适的`LocalizationTextAttribute`，当找到时，将字符串ID与现有ID进行比较以检查匹配。当找到匹配项时，字符串变量将被分配相应的本地化字符串。'
- en: 'To use the localization framework given here, first add a `SampleGameMenu`
    object to the scene as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此处提供的本地化框架，首先将一个`SampleGameMenu`对象添加到场景中，如图所示：
- en: '![Localization](img/0655OT_08_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![本地化](img/0655OT_08_15.jpg)'
- en: Adding a Sample Game Menu object to the scene with localized text members
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将带有本地化文本成员的示例游戏菜单对象添加到场景中
- en: 'Then, choose a language from the application main menu by selecting **English**
    or **Yoda** from the **Localization** tab, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在**本地化**标签页中选择**英语**或**Yoda**，从应用程序主菜单中选择一种语言，如图所示：
- en: '![Localization](img/0655OT_08_16.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![本地化](img/0655OT_08_16.jpg)'
- en: Setting the active language for the game
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设置游戏的活动语言
- en: 'Once the active language is specified, all strings with the `LocalizationTextAttribute`
    attribute will be updated, as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了活动语言，所有带有`LocalizationTextAttribute`属性的字符串都将更新，如下面的屏幕截图所示：
- en: '![Localization](img/0655OT_08_17.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![本地化](img/0655OT_08_17.jpg)'
- en: Localized text is updated after selecting an active language
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 选择活动语言后更新本地化文本
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored in depth the relationship between reflection, as a concept,
    and its practical use for creating `Editor` classes that extended the editor behavior
    beyond its defaults to accommodate custom intentions. The ability to do this is
    not always essential to building Unity games themselves but it can make your work
    easier. Furthermore, it can lead to making money via the Asset Store, should you
    wish to develop custom add-ons that can help other developers. Here, you saw how
    to create a Batch Rename tool with the `ScriptableWizard` class and then a color
    blending property for the Object Inspector. Next, we made extensive use of reflection
    to expose all public C# properties in the Object Inspector that allowed us direct
    access to the set and get property values as if we'd accessed them at runtime.
    Further, we moved on to see how a localization framework could be implemented
    from XML files via the `Editor` classes that allow string variables to be automatically
    changed to match a selected language. For more information, you can visit [http://catlikecoding.com/unity/tutorials/editor/custom-data/](http://catlikecoding.com/unity/tutorials/editor/custom-data/)
    and [http://catlikecoding.com/unity/tutorials/editor/custom-list/](http://catlikecoding.com/unity/tutorials/editor/custom-list/).
    In the next chapter, we'll move our conceptual and technical baggage to explore
    the world of 2D from more unconventional angles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了作为概念的反射与其实际应用之间的关系，即创建扩展编辑器行为的`Editor`类，使其能够适应自定义意图，而不仅仅是默认行为。这种能力对于构建Unity游戏本身并非总是必需的，但它可以使你的工作更加轻松。此外，如果你希望开发能够帮助其他开发者的自定义插件，这也可以通过Asset
    Store带来盈利。在这里，你看到了如何使用`ScriptableWizard`类创建批量重命名工具，以及为对象检查器添加颜色混合属性。接下来，我们广泛使用了反射来暴露对象检查器中所有公共的C#属性，这使我们能够直接访问设置和获取属性值，就像我们在运行时访问它们一样。进一步地，我们探讨了如何通过`Editor`类从XML文件实现本地化框架，这些类允许字符串变量自动更改以匹配所选语言。更多信息，您可以访问[http://catlikecoding.com/unity/tutorials/editor/custom-data/](http://catlikecoding.com/unity/tutorials/editor/custom-data/)和[http://catlikecoding.com/unity/tutorials/editor/custom-list/](http://catlikecoding.com/unity/tutorials/editor/custom-list/)。在下一章中，我们将带着概念和技术上的负担，从更不寻常的角度探索2D世界。
