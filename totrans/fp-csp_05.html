<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-155" class="chapter-number"><a id="_idTextAnchor221"/>5</h1>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor222"/>Error Handling</h1>
			<p>Welcome to <a href="B21069_05.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>! You are doing great! In this chapter, we will discuss a new approach provided by functional programming to handle errors. We will do so through the help of the <span class="No-Break">following sections:</span></p>
			<ul>
				<li>Traditional error handling <span class="No-Break">in C#</span></li>
				<li>The <span class="No-Break">Result type</span></li>
				<li>Railway-Oriented <span class="No-Break">Programming (ROP)</span></li>
				<li>Designing your own <span class="No-Break">error-handling mechanisms</span></li>
				<li>Practical tips for functional <span class="No-Break">error handling</span></li>
				<li>Traditional versus functional error <span class="No-Break">handling comparison</span></li>
				<li>Patterns and anti-patterns in functional <span class="No-Break">error handling</span></li>
			</ul>
			<p>Steve is really upset today because he spent the last three days fixing errors and didn’t have time to write even a single line of new code. Moreover, benchmark tests showed that the code with try-catch blocks works much slower than the one without them and that there are a lot of these blocks in his code. So he decided to ask Julia whether there was a way to handle errors better with a functional approach. She sent Steve a big article about error handling using <span class="No-Break">functional programming.</span></p>
			<p>As you can see, this chapter delves into the functional techniques, which will help you not just handle errors but do so in a manner that’s clean, efficient, and maintainable. And before we dig in, let’s look at these three <span class="No-Break">self-assessment tasks.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor223"/>Task 1 – Custom error types and result usage</h1>
			<p>Here’s a <a id="_idIndexMarker259"/>function in Steve’s tower defense game that upgrades a tower <a id="_idIndexMarker260"/>and returns a boolean. Refactor it to return a <strong class="source-inline">Result</strong> type instead, with a custom error when the <span class="No-Break">upgrade fails:</span></p>
			<pre class="source-code">
public bool UpgradeTower(Tower tower)
{
     // Tower upgrading logic...
     if (/* upgrade fails */)
     {
                  return false;
     }
     return true;
}</pre>			<h1 id="_idParaDest-158"><a id="_idTextAnchor224"/>Task 2 – Utilizing ROP for validation and processing</h1>
			<p>Steve has <a id="_idIndexMarker261"/>a workflow that involves parsing, validating, and <a id="_idIndexMarker262"/>processing an enemy spawn. Refactor it <a id="_idIndexMarker263"/>using <strong class="bold">Railway-Oriented Programming</strong> (<strong class="bold">ROP</strong>) to improve the <span class="No-Break">error-handling flow:</span></p>
			<pre class="source-code">
public void ProcessEnemySpawn(string enemyData)
{
     var parsedData = ParseEnemyData(enemyData);
     if (parsedData.IsValid)
     {
                  var validation = ValidateEnemySpawn(parsedData);
                  if (validation.IsValid)
                  {
                      SpawnEnemy(validation.Enemy);
                  }
     }
}</pre>			<h1 id="_idParaDest-159"><a id="_idTextAnchor225"/>Task 3 – Implementing a Retry mechanism using functional techniques</h1>
			<p>Write <a id="_idIndexMarker264"/>a function that <a id="_idIndexMarker265"/>implements a retry mechanism for a flaky tower firing operation and returns a <strong class="source-inline">Result</strong> type. The function should retry the operation a specified number of times before returning <span class="No-Break">an error:</span></p>
			<pre class="source-code">
public bool TowerFire(Tower tower, Enemy enemy)
{
     // Sometimes works and returns true
     // sometimes doesn't and returns false
}</pre>			<p>If these tasks are easy for you, you are free to skip this chapter for now and return later when you have read all the others or have any questions about <span class="No-Break">error handling.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor226"/>Traditional error handling in C#</h1>
			<p>Every C# <a id="_idIndexMarker266"/>developer, whether a novice or an expert, has come across <a id="_idIndexMarker267"/>the try-catch block. It’s been the main protection against unexpected behaviors and system failures. Let’s revisit this conventional mechanism before understanding what the functional <span class="No-Break">paradigm offers.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor227"/>try-catch blocks</h2>
			<p>The try-catch <a id="_idIndexMarker268"/>block attempts an operation, and if it fails, the control is <a id="_idIndexMarker269"/>transferred to the catch block, ensuring the application doesn’t crash. For instance, let’s say we’re working with a simple <span class="No-Break">file-reading operation:</span></p>
			<pre class="source-code">
string content;
try
{
    content = File.ReadAllText("file.txt");
}
catch (FileNotFoundException ex)
{
    content = string.Empty;
    LogException(ex, "File not found. Check the file location.");
}
catch (IOException ex)
{
    content = string.Empty;
    LogException(ex, "An IO error occurred. Try again.");
}</pre>			<p>Here, we log <a id="_idIndexMarker270"/>different <a id="_idIndexMarker271"/>messages depending on the type of the <span class="No-Break">raised exception.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor228"/>Exceptions</h2>
			<p>C# offers <a id="_idIndexMarker272"/>two primary <a id="_idIndexMarker273"/>categories of <span class="No-Break">exception types:</span></p>
			<ul>
				<li><strong class="bold">System exceptions</strong>: These <a id="_idIndexMarker274"/>are predefined <a id="_idIndexMarker275"/>exceptions, such as <strong class="source-inline">NullReferenceException</strong>, <strong class="source-inline">IndexOutOfRangeException</strong>, or the ones we just <span class="No-Break">encountered: </span><span class="No-Break"><strong class="source-inline">FileNot</strong></span><strong class="source-inline">
FoundException</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">IOException</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Application exceptions</strong>: These are custom exceptions created for specific application <a id="_idIndexMarker276"/>needs. Let’s say you’re developing <a id="_idIndexMarker277"/>an e-commerce platform, and you need an exception for an out-of-stock item. Here’s how you might <span class="No-Break">design it:</span><pre class="source-code">
public class OutOfStockException : Exception
{
    public OutOfStockException(string itemName) : base($"{itemName} is out of stock.") { }
}</pre><p class="list-inset">Later, check the <span class="No-Break">item’s stock:</span></p><pre class="source-code">if(item.Stock &lt;= 0)
{
    throw new OutOfStockException(item.Name);
}</pre></li>			</ul>
			<p>Custom exceptions empower developers to communicate specific error scenarios, ensuring that error handling <span class="No-Break">is informative.</span></p>
			<p>Steve slumped in his chair, frustration etched on his face. He’d spent the last three days battling bugs in his tower defense game, and the codebase was becoming a maze of try-catch blocks. Just then, his phone buzzed. It was a message <span class="No-Break">from Julia.</span></p>
			<p>Julia: <em class="italic">How’s the game </em><span class="No-Break"><em class="italic">coming along?</em></span></p>
			<p>Steve: <em class="italic">Not great. I’m drowning in error handling. Got any functional programming wisdom </em><span class="No-Break"><em class="italic">for me?</em></span></p>
			<p>Julia: <em class="italic">As a matter of fact, I do. Let me tell you about a more elegant way to </em><span class="No-Break"><em class="italic">handle errors...</em></span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor229"/>The Result type</h1>
			<p>Instead of dealing with exceptions after they occur, what if we designed our code to anticipate <a id="_idIndexMarker278"/>and elegantly communicate errors? Please welcome the <strong class="source-inline">Result</strong> type, a cornerstone of functional <span class="No-Break">error handling.</span></p>
			<p>At its core, the <strong class="source-inline">Result</strong> type encapsulates either a successful value or an error. It might sound similar to exceptions, but there’s a key difference: errors become first-class citizens, directly influencing your <span class="No-Break">application’s flow.</span></p>
			<p>In contrast to the <strong class="source-inline">Option</strong> type that can only distinguish existing values from non-existing, the <strong class="source-inline">Result</strong> type describes the error that happened and, more importantly, can be used to chain methods application. We will discuss that technique later in <span class="No-Break">this chapter.</span></p>
			<p>For instance, traditionally, a method might return a value or throw <span class="No-Break">an exception:</span></p>
			<pre class="source-code">
public Product GetProduct(int id)
{
    var product = _productRepository.Get(id);
    if(product is null)
    {
        throw new ProductNotFoundException($"Product with ID {id} was not found.");
    }
    return product;
}</pre>			<p>In contrast, with the <strong class="source-inline">Result</strong> type, the method communicates both its intention and possible failure <span class="No-Break">more explicitly:</span></p>
			<pre class="source-code">
public Result&lt;Product, string&gt; GetProduct(int id)
{
    var product = _productRepository.Get(id);
    if(product is null)
    {
        return Result&lt;Product, string&gt;.Fail($"Product with ID {id} not found.");
    }
    return Result&lt;Product, string&gt;.Success(product);
}</pre>			<p>This code <a id="_idIndexMarker279"/>is more explicit. No hidden exceptions. No unexpected behaviors. Just clear, honest <span class="No-Break">communication.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor230"/>Implementing the Result type</h2>
			<p>Let’s dive <a id="_idIndexMarker280"/>a bit deeper and see what a general implementation of the <strong class="source-inline">Result</strong> type <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
public class Result&lt;T, E&gt;
{
    private T _value;
    private E _error;
    public bool IsSuccess { get; private set; }
    private Result(T value, E error, bool isSuccess)
    {
        _value = value;
        _error = error;
        IsSuccess = isSuccess;
    }
    public T Value
    {
        get
        {
            if (!IsSuccess) throw new InvalidOperationException("Cannot fetch Value from a failed result.");
            return _value;
        }
    }
    public E Error
    {
        get
        {
            if (IsSuccess) throw new InvalidOperationException("Cannot fetch Error from a successful result.");
            return _error;
        }
    }
    public static Result&lt;T, E&gt; Success(T value) =&gt; new Result&lt;T, E&gt;(value, default, true);
    public static Result&lt;T, E&gt; Fail(E error) =&gt; new Result&lt;T, E&gt;(default, error, false);
}</pre>			<h2 id="_idParaDest-165"><a id="_idTextAnchor231"/>Using the Result type</h2>
			<p>Usage <a id="_idIndexMarker281"/>of the <strong class="source-inline">Result</strong> type leads to a more systematic approach to <span class="No-Break">error handling:</span></p>
			<pre class="source-code">
var productResult = GetProduct(42);
if (productResult.IsSuccess)
{
    DisplayProduct(productResult.Value);
}
else
{
    ShowError(productResult.Error);
}</pre>			<p>No more scattered try-catch blocks. Now errors become just another path your code can take, leading to more predictable and <span class="No-Break">maintainable systems.</span></p>
			<p>The <strong class="source-inline">Result</strong> type fundamentally shifts how we view errors: not as sudden interruptions, but as anticipated outcomes. As we go further, you’ll see how this functional tool integrates with other advanced techniques, creating a new approach to <span class="No-Break">error management.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor232"/>Railway-Oriented Programming (ROP)</h1>
			<p>Steve <a id="_idIndexMarker282"/>was intrigued by the Result type, but he still <span class="No-Break">had questions.</span></p>
			<p>Steve: <em class="italic">This is great for individual operations, but what about when I have a series of steps that all need </em><span class="No-Break"><em class="italic">to succeed?</em></span></p>
			<p>Julia: <em class="italic">I’m glad you asked. Let me introduce you to </em><span class="No-Break"><em class="italic">Railway-Oriented Programming.</em></span></p>
			<p>At the heart of functional programming is the drive for predictability and clarity. Although traditional error-handling techniques are powerful, they often scatter the error-handling logic across the codebase. ROP, inspired by this railway track-switching analogy, offers a cohesive, structured approach to error handling, keeping your code both expressive <span class="No-Break">and streamlined.</span></p>
			<p>ROP provides <a id="_idIndexMarker283"/>a systematic way to manage errors in a sequence of operations. Think of it as managing two parallel tracks: the success track (happy path) and the error track. Operations run sequentially on the happy path. However, as soon as an error is encountered, the flow is diverted to the error track, bypassing <span class="No-Break">subsequent operations.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor233"/>The essence of Bind</h2>
			<p>Central to ROP is the Bind function. It takes an operation and a subsequent operation to execute if <a id="_idIndexMarker284"/>the first one succeeds. However, if an <a id="_idIndexMarker285"/>error occurs, it bypasses the second operation, and the error is <span class="No-Break">immediately propagated:</span></p>
			<pre class="source-code">
public static Result&lt;Tout, E&gt; Bind&lt;Tin, Tout, E&gt;(this Result&lt;Tin, E&gt; input, Func&lt;Tin, Result&lt;Tout, E&gt;&gt; bindFunc)
{
    return input.IsSuccess ? bindFunc(input.Value) : Result&lt;Tout, E&gt;.Fail(input.Error);
}</pre>			<h2 id="_idParaDest-168"><a id="_idTextAnchor234"/>Chaining operations with Bind</h2>
			<p>Imagine <a id="_idIndexMarker286"/>a series <a id="_idIndexMarker287"/>of steps where we do <span class="No-Break">the following:</span></p>
			<ol>
				<li><span class="No-Break">Parse input</span></li>
				<li>Validate <span class="No-Break">parsed data</span></li>
				<li>Transform <span class="No-Break">validated data</span></li>
				<li>Store <span class="No-Break">transformed data</span></li>
			</ol>
			<p>ROP lets <a id="_idIndexMarker288"/>us express <a id="_idIndexMarker289"/>these steps as a <span class="No-Break">cohesive chain:</span></p>
			<pre class="source-code">
public Result&lt;bool, string&gt; HandleData(string input)
{
    return ParseInput(input)
           .Bind(parsedData =&gt; ValidateData(parsedData))
           .Bind(validData =&gt; TransformData(validData))
           .Bind(transformedData =&gt; StoreData(transformedData));
}</pre>			<h2 id="_idParaDest-169"><a id="_idTextAnchor235"/>Composable error handling with ROP</h2>
			<p>A strength of ROP is that it fosters composable error handling. Each component of your application <a id="_idIndexMarker290"/>can define its own error scenarios, and when these components are chained together, the combined operation can handle a broader spectrum of errors without <span class="No-Break">losing granularity.</span></p>
			<p>Consider <a id="_idIndexMarker291"/>having separate components for user input, business logic, and database operations. Each component can have its own error definitions. When operations from these components are chained together, the system can seamlessly handle errors from any component, creating a unified <span class="No-Break">error-handling strategy.</span></p>
			<pre class="source-code">
public Result&lt;DBResponse, CompositeError&gt; ProcessUserRequest(string userInput)
{
    return GetUserInput(userInput)
           .Bind(inputData =&gt; ApplyBusinessLogic(inputData))
           .Bind(businessData =&gt; UpdateDatabase(businessData));
}</pre>			<p>Here, <strong class="source-inline">CompositeError</strong> might encapsulate errors from input validation, business logic violations, and <span class="No-Break">database failures.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor236"/>Handling diverse error types</h2>
			<p>One <a id="_idIndexMarker292"/>challenge with a straightforward ROP implementation is that it assumes a unified error type <a id="_idIndexMarker293"/>throughout the chain. However, real-world scenarios often involve diverse error types. To manage this, you can introduce a mechanism to convert or map <span class="No-Break">error types:</span></p>
			<pre class="source-code">
public static Result&lt;TOut, EOut&gt; Bind&lt;TIn, TOut, EIn, EOut&gt;(
    this Result&lt;TIn, EIn&gt; input,
    Func&lt;TIn, Result&lt;TOut, EOut&gt;&gt; bindFunc,
    Func&lt;EIn, EOut&gt; errorMap)
{
    return input.IsSuccess ? bindFunc(input.Value) : Result&lt;TOut, EOut&gt;.Fail(errorMap(input.Error));
}</pre>			<p>This enhanced <strong class="source-inline">Bind</strong> function maps one error type to another, enabling more complex and varied <span class="No-Break">error-handling scenarios.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor237"/>Benefits of isolation</h2>
			<p>ROP isolates error handling, ensuring that your main business logic remains uncluttered. When <a id="_idIndexMarker294"/>reading through the core operations, one can focus purely on the main logic without being distracted by <span class="No-Break">error-handling intricacies.</span></p>
			<p>For developers, this isolation simplifies cognitive load. They can trust the system to handle errors and focus on crafting the primary logic. When debugging, the structured nature of ROP makes it crystal clear where things might have gone off the rails, thus, simplifying the <span class="No-Break">troubleshooting process.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor238"/>Extending ROP for asynchronous operations</h2>
			<p>In <a id="_idIndexMarker295"/>modern applications, a lot <a id="_idIndexMarker296"/>of methods are asynchronous. ROP can be adapted <a id="_idIndexMarker297"/>to asynchronous operations using techniques such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">BindAsync</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public static async Task&lt;Result&lt;TOut, E&gt;&gt; BindAsync&lt;TIn, TOut, E&gt;(
    this Result&lt;TIn, E&gt; input,
    Func&lt;TIn, Task&lt;Result&lt;TOut, E&gt;&gt;&gt; bindFuncAsync)
{
    return input.IsSuccess ? await bindFuncAsync(input.Value) : Result&lt;TOut, E&gt;.Fail(input.Error);
}</pre>			<p>With <strong class="source-inline">BindAsync</strong>, you can now chain asynchronous operations just as easily, making ROP versatile in both synchronous and <span class="No-Break">asynchronous contexts.</span></p>
			<p>Having delved deep into ROP, we witness a paradigm shift in how we perceive and handle errors. Instead of treating errors as exceptional events, ROP integrates them into the very logic of our application, resulting in more robust, readable, and <span class="No-Break">maintainable code.</span></p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor239"/>Designing your own error-handling mechanisms</h1>
			<p>As Steve <a id="_idIndexMarker298"/>began refactoring his code, he realized that the pre-built solutions didn’t quite fit all his game’s <span class="No-Break">unique scenarios.</span></p>
			<p>Steve: <em class="italic">Julia, I think I need to create some custom error types for my game. Is </em><span class="No-Break"><em class="italic">that okay?</em></span></p>
			<p>Julia: <em class="italic">More than okay. In fact, let’s talk about how you can design your own error-handling mechanisms tailored to your </em><span class="No-Break"><em class="italic">game’s needs.</em></span></p>
			<p>When creating your own functional error handling, a <strong class="source-inline">Result</strong> type is a prime starting point. Let it <a id="_idIndexMarker299"/>be generic enough to cater to <span class="No-Break">different scenarios:</span></p>
			<pre class="source-code">
public class Result&lt;TSuccess, TFailure&gt;
{
    public TSuccess SuccessValue { get; }
    public TFailure FailureValue { get; }
    public bool IsSuccess { get; }
    //... Constructors and other methods ...
}</pre>			<h2 id="_idParaDest-174"><a id="_idTextAnchor240"/>Use factory methods for creation</h2>
			<p>Factory <a id="_idIndexMarker300"/>methods provide clarity and ease <span class="No-Break">of use:</span></p>
			<pre class="source-code">
public static class Result
{
    public static Result&lt;T, string&gt; Success&lt;T&gt;(T value) =&gt; new Result&lt;T, string&gt;(value, default, true);
    public static Result&lt;T, string&gt; Fail&lt;T&gt;(string error) =&gt; new Result&lt;T, string&gt;(default, error, false);
}</pre>			<p>The usage is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var successResult = Result.Success("Processed!");
var errorResult = Result.Fail("Oops! Something went wrong.");</pre>			<h2 id="_idParaDest-175"><a id="_idTextAnchor241"/>Extend with Bind</h2>
			<p>Use the <strong class="source-inline">Bind</strong> method <a id="_idIndexMarker301"/>to add <span class="No-Break">more fluency:</span></p>
			<pre class="source-code">
public Result&lt;TOut, TFailure&gt; Bind&lt;TOut&gt;(Func&lt;TSuccess, Result&lt;TOut, TFailure&gt;&gt; func)
{
    return IsSuccess ? func(SuccessValue) : new Result&lt;TOut, TFailure&gt;(default, FailureValue, false);
}</pre>			<h2 id="_idParaDest-176"><a id="_idTextAnchor242"/>Customize error types</h2>
			<p>Rather than <a id="_idIndexMarker302"/>just using strings, create specific error types to convey <span class="No-Break">detailed information:</span></p>
			<pre class="source-code">
public class ValidationError
{
    public string FieldName { get; }
    public string ErrorDescription { get; }
    //… Constructor and methods ...
}</pre>			<p>Then, use them <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public Result&lt;User, ValidationError&gt; ValidateUser(User user)
{
    if (string.IsNullOrEmpty(user.Name))
    {
        return Result.Fail&lt;User, ValidationError&gt;(new ValidationError("Name", "Name cannot be empty."));
    }
    //... Other validations ...
    return Result.Success&lt;User, ValidationError&gt;(user);
}</pre>			<h2 id="_idParaDest-177"><a id="_idTextAnchor243"/>Leverage extension methods</h2>
			<p>Extension <a id="_idIndexMarker303"/>methods can offer <span class="No-Break">enhanced readability:</span></p>
			<pre class="source-code">
public static class ResultExtensions
{
    public static bool IsFailure&lt;TSuccess, TFailure&gt;(this Result&lt;TSuccess, TFailure&gt; result)
    {
        return !result.IsSuccess;
    }
}</pre>			<p>Use them <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if (result.IsFailure())
{
    // Handle the failure scenario
}</pre>			<h2 id="_idParaDest-178"><a id="_idTextAnchor244"/>Integration with existing code</h2>
			<p>By wrapping <a id="_idIndexMarker304"/>legacy methods, we can seamlessly integrate with <span class="No-Break">non-functional code:</span></p>
			<pre class="source-code">
public static Result&lt;T, Exception&gt; TryExecute&lt;T&gt;(Func&lt;T&gt; action)
{
    try
    {
        return Result.Success(action());
    }
    catch (Exception ex)
    {
        return Result.Fail&lt;T, Exception&gt;(ex);
    }
}</pre>			<h2 id="_idParaDest-179"><a id="_idTextAnchor245"/>Always iterate and refine</h2>
			<p>Custom <a id="_idIndexMarker305"/>error mechanisms are living entities. As your application grows, keep iterating and refining based on feedback and <span class="No-Break">new requirements.</span></p>
			<p>Designing your own error-handling mechanisms not only empowers you with tailor-fit solutions but also deepens your understanding of the functional paradigm. Dive in, get hands-on, and watch as your applications become models of robustness <span class="No-Break">and clarity.</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor246"/>Practical tips for functional error handling</h1>
			<p>A week <a id="_idIndexMarker306"/>into refactoring, Steve was making progress, but he felt overwhelmed by all the <span class="No-Break">new concepts.</span></p>
			<p>Steve: <em class="italic">I’m not sure I’m doing </em><span class="No-Break"><em class="italic">this right…</em></span></p>
			<p>Julia: <em class="italic">Don’t worry, it’s normal to feel that way when learning a new paradigm. Let me share some practical tips that’ll help you navigate this </em><span class="No-Break"><em class="italic">new territory.</em></span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor247"/>Avoid null with options</h2>
			<p>Try to <a id="_idIndexMarker307"/>never return null. It sounds simple, yet it’s a pitfall waiting to trip up the unwary. Why? Because nulls are very easy to get, however, it is much harder to handle them properly and if you don’t do it well, it can lead to <span class="No-Break">cascading failures:</span></p>
			<pre class="source-code">
public User FindUser(string login)
{
    // This can return null!
    return users.FirstOrDefault(u =&gt; u.Login.Equals(login));
}</pre>			<p>Turn <span class="No-Break">this around:</span></p>
			<pre class="source-code">
public Option&lt;User&gt; FindUser(string login)
{
    var user = users.FirstOrDefault(u =&gt; u.Login.Equals(login));
    return user is not null ? Option.Some(user) : Option.None&lt;User&gt;();
}</pre>			<h2 id="_idParaDest-182"><a id="_idTextAnchor248"/>Logging errors</h2>
			<p>Logging <a id="_idIndexMarker308"/>is vital, but try to avoid side effects that ruin the functional approach. A good idea here is to delegate the act of logging, keeping <span class="No-Break">functions pure:</span></p>
			<pre class="source-code">
public Result&lt;Order, Error&gt; ProcessOrder(int id, Action&lt;string&gt; logError)
{
    if (invalid(id))
    {
        logError($"Invalid order id: {id}");
        return Result.Fail&lt;Order, Error&gt;(new Error("Invalid ID"));
    }
    // ... process further ...
}</pre>			<h2 id="_idParaDest-183"><a id="_idTextAnchor249"/>Two strategies To replace exceptions</h2>
			<p>I know <a id="_idIndexMarker309"/>that in some cases your first <a id="_idIndexMarker310"/>instinct might be to use a try-catch. Resist. Use these strategies to stick to the <span class="No-Break">functional paradigm.</span></p>
			<h3>Safe execution</h3>
			<p>Create a <a id="_idIndexMarker311"/>method that will execute any code in an <span class="No-Break">exception-free way:</span></p>
			<pre class="source-code">
public static Result&lt;T, E&gt; SafelyExecute&lt;T, E&gt;(Func&lt;T&gt; function, E error)
{
    try
    {
        return Result.Success(function());
    }
    catch
    {
        return Result.Fail&lt;T, E&gt;(error);
    }
}</pre>			<p>The <a id="_idIndexMarker312"/>usage is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var orderResult = SafelyExecute(() =&gt; GetOrder(orderId), new DatabaseError("Failed getting order"));</pre>			<h3>Fallback</h3>
			<p>For some <a id="_idIndexMarker313"/>operations, you can provide a <span class="No-Break">fallback result:</span></p>
			<pre class="source-code">
public Result&lt;Order, string&gt; GetOrderWithFallback(int orderId)
{
    var orderResult = GetOrder(orderId);
    return orderResult.IsSuccess ? orderResult : Result.Success(new DefaultOrder());
}</pre>			<h2 id="_idParaDest-184"><a id="_idTextAnchor250"/>Anticipate errors – make it predictable</h2>
			<p>Instead of <a id="_idIndexMarker314"/>waiting for errors, anticipate them. Validate your data before using it in processing. You can do it manually or with the help of <span class="No-Break">guard clauses:</span></p>
			<pre class="source-code">
public Result&lt;Order, string&gt; ProcessOrder(int id)
{
    if (id &lt; 0)
    {
        return Result.Fail&lt;Order, string&gt;("ID cannot be negative.");
    }
    // ... further processing ...
}</pre>			<h2 id="_idParaDest-185"><a id="_idTextAnchor251"/>Embrace composition</h2>
			<p>Use <a id="_idIndexMarker315"/>function composition for cleaner <a id="_idIndexMarker316"/><span class="No-Break">error handling:</span></p>
			<pre class="source-code">
var result = GetData()
             .Bind(Validate)
             .Bind(Process)
             .Bind(Save);</pre>			<h2 id="_idParaDest-186"><a id="_idTextAnchor252"/>Educate your team</h2>
			<p>Lastly, ensure <a id="_idIndexMarker317"/>everyone’s on board. A consistent approach to error handling ensures clarity <span class="No-Break">and reliability.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor253"/>Traditional versus functional error handling comparison</h1>
			<p>Every <a id="_idIndexMarker318"/>developer experiences it sooner or later: running into an error while coding. But as the coding world <a id="_idIndexMarker319"/>has changed, so has the way we deal with these problems. Let’s look at the clear differences between the old and new ways of handling errors in C# and understand why this new approach is becoming <span class="No-Break">more popular.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor254"/>The traditional way</h2>
			<p>In <a id="_idIndexMarker320"/>traditional OOP, exceptions are the <span class="No-Break">go-to mechanism:</span></p>
			<ul>
				<li><strong class="bold">Throwing exceptions</strong>: We <a id="_idIndexMarker321"/>rely on <a id="_idIndexMarker322"/>system or custom exceptions when things <span class="No-Break">go wrong:</span><pre class="source-code">
public User GetUser(int id)
{
    if (id &lt; 0)
        throw new ArgumentOutOfRangeException(nameof(id));
    // ... fetch the user ...
}</pre></li>				<li><strong class="bold">Catching exceptions</strong>: Use <a id="_idIndexMarker323"/>try-catch <a id="_idIndexMarker324"/>blocks to handle and possibly recover <span class="No-Break">from errors:</span><pre class="source-code">
try
{
    var user = GetUser(-5);
}
catch (ArgumentOutOfRangeException ex)
{
    Console.WriteLine(ex.Message);
}</pre></li>			</ul>
			<p>The <a id="_idIndexMarker325"/>benefits of the traditional way are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Most developers are accustomed to using exceptions, making it a <span class="No-Break">well-understood approach</span></li>
				<li>Fine-grained error handling is possible with different <span class="No-Break">exception types</span></li>
			</ul>
			<p>However, there <a id="_idIndexMarker326"/>are also <span class="No-Break">some drawbacks:</span></p>
			<ul>
				<li>Exceptions can disrupt the natural flow of <span class="No-Break">code execution</span></li>
				<li>Exception handling introduces a <span class="No-Break">performance overhead</span></li>
				<li>It can be hard to reason about and can lead to “<span class="No-Break">exception hell”</span></li>
			</ul>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor255"/>The functional way</h2>
			<p>Functional <a id="_idIndexMarker327"/>programming prefers a more graceful form of <a id="_idIndexMarker328"/><span class="No-Break">error handling:</span></p>
			<ul>
				<li><strong class="bold">Use constructs such as </strong><span class="No-Break"><strong class="bold">Result types</strong></span><span class="No-Break">:</span><pre class="source-code">
public Result&lt;User, string&gt; GetUser(int id)
{
    if (id &lt; 0)
    {
        return Result.Fail&lt;User, string&gt;("ID cannot be negative.");
    }
    // ... get and return the user ...
}</pre><p class="list-inset">Consuming <a id="_idIndexMarker329"/>the preceding function <span class="No-Break">becomes straightforward:</span></p><pre class="source-code">var userResult = GetUser(-5);
if (userResult.IsFailure)
{
    Console.WriteLine(userResult.Error);
}</pre></li>				<li><span class="No-Break"><strong class="bold">ROP</strong></span><span class="No-Break">:</span><pre class="source-code">
var result = GetData()
             .Bind(ValidateData)
             .Bind(ProcessData);</pre></li>			</ul>
			<p>The <a id="_idIndexMarker330"/>benefits of the functional way are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Clearer intent <span class="No-Break">and flow</span></li>
				<li>Avoids the exception <span class="No-Break">performance overhead</span></li>
				<li>Easier chaining <span class="No-Break">of operations</span></li>
			</ul>
			<p>There <a id="_idIndexMarker331"/>are also a couple <span class="No-Break">of drawbacks:</span></p>
			<ul>
				<li>Developers may be required t<a id="_idTextAnchor256"/>o learn <span class="No-Break">new concepts</span></li>
				<li>Less granularity compared to <span class="No-Break">traditional exceptions</span></li>
			</ul>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor257"/>Comparative analysis</h2>
			<p>Let’s <a id="_idIndexMarker332"/>take a closer look at <a id="_idIndexMarker333"/>the differences between traditional exception handling and functional programming when it comes to performance, readability, <span class="No-Break">and maintainability:</span></p>
			<ul>
				<li><strong class="bold">Performance</strong>: Traditional exception handling can be slower due to the overhead of creating exception objects and unwinding the stack. FP offers a more predictable <span class="No-Break">performance profile.</span></li>
				<li><strong class="bold">Readability</strong>: try-catch blocks can clutter code, making it less readable. Often these blocks contain also code that cannot throw exceptions. FP encapsulates errors within data, making code <span class="No-Break">flow apparent.</span></li>
				<li><strong class="bold">Maintainability</strong>: Traditional methods spread error handling, making maintenance complex. FP encourages isolated, pure functions, which simplifies debugging <span class="No-Break">and testing.</span></li>
			</ul>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor258"/>Making the shift</h2>
			<p>Starting <a id="_idIndexMarker334"/>with FP error handling might seem odd, especially if you’ve lived all your life in the traditional paradigm. But once you make the switch, the benefits are <span class="No-Break">profound. Remember:</span></p>
			<ul>
				<li>Start small. Refactor a section of your codebase and observe <span class="No-Break">the difference.</span></li>
				<li>Embrace pure functions. They’ll simplify your <span class="No-Break">error-handling story.</span></li>
				<li>Educate your team. A shared understanding <span class="No-Break">is pivotal.</span></li>
			</ul>
			<p>In conclusion, while <a id="_idIndexMarker335"/>traditional error handling has served us well for years, the functional paradigm offers a fresher, more systematic approach. By representing errors as first-class citizens within our data types, we write more maintainable code. The choice between the two often boils down to the problem domain, team familiarity, and project requirements. But if you want clarity and expressiveness, the functional route is <span class="No-Break">the way.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor259"/>Patterns and anti-patterns in functional error handling</h1>
			<p>Functional <a id="_idIndexMarker336"/>programming has redefined our approach to error handling. By bringing errors into the realm of data, we ensure safer, more predictable code. But as with any paradigm, there are right ways and pitfalls. Let’s look at the patterns that can help you and also <span class="No-Break">the anti-patterns.</span></p>
			<p>There are several patterns that can help you handle errors in a more functional way. These patterns are designed to enhance the quality, readability, and maintainability of your code. Here are some of the key patterns <span class="No-Break">to consider:</span></p>
			<ul>
				<li><strong class="bold">Rich custom </strong><span class="No-Break"><strong class="bold">error types</strong></span><p class="list-inset">Instead of generic strings or codes, use detailed types to <span class="No-Break">describe errors:</span></p><pre class="source-code">
public Result&lt;User, UserError&gt; GetUser(int id)
{
    if (id &lt; 0)
        return Result.Fail&lt;User, UserError&gt;(new InvalidIdError(id));
    // ... other checks and logic ...
}</pre></li>				<li><span class="No-Break"><strong class="bold">Leveraging composition</strong></span><p class="list-inset">Chain <a id="_idIndexMarker337"/>multiple functions seamlessly to maintain clear <span class="No-Break">logic flow:</span></p><pre class="source-code">
GetData()
    .Bind(Validate)
    .Bind(Process)
    .Bind(Store);</pre></li>				<li><strong class="bold">Pattern matching </strong><span class="No-Break"><strong class="bold">with errors</strong></span><p class="list-inset">This ensures every error scenario <span class="No-Break">is addressed:</span></p><pre class="source-code">
switch (GetUser(5))
{
    case Success&lt;User&gt; user:
        // Handle user
        break;
    case Failure&lt;UserError&gt; error when error.Value is InvalidIdError:
        // Handle invalid ID error
        break;
    // ... other cases ...
}</pre></li>				<li><strong class="bold">Isolating </strong><span class="No-Break"><strong class="bold">side effects</strong></span><p class="list-inset">Keep your <a id="_idIndexMarker338"/>core logic pure and handle side effects, such as logging or <span class="No-Break">I/O, separately:</span></p><pre class="source-code">
public Result&lt;TSuccess, TError&gt; ComputeValue&lt;TSuccess, TError&gt;(Data data)
{
    if (data.IsValid())
    {
        TSuccess value = PerformComputation(data);
        return new Result&lt;TSuccess, TError&gt;(value);
    }
    else
    {
        TError errorDetails = GetErrorDetails(data);
        return new Result&lt;TSuccess, TError&gt;(errorDetails);
    }
}</pre><p class="list-inset">The usage is <span class="No-Break">as follows:</span></p><pre class="source-code">var result = ComputeValue&lt;MySuccessType, MyErrorType&gt;(data);
if (result.IsSucces<a id="_idTextAnchor260"/>s)
{
    HandleSuccess(result.Value);
}
else
{
    HandleError(result.Error);
}</pre></li>			</ul>
			<p>There <a id="_idIndexMarker339"/>are also some anti-patterns that can make your error handling more complex <span class="No-Break">and error-prone:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Mixing paradigms</strong></span><p class="list-inset">Using exceptions within functions that return <strong class="source-inline">Result</strong> types can confuse other <span class="No-Break">software developers:</span></p><pre class="source-code">
public Result&lt;int, string&gt; Compute()
{
    if (condition)
    {
        throw new Exception("Oops!");
    }
    // ... return some result ...
}</pre></li>				<li><span class="No-Break"><strong class="bold">Unclear errors</strong></span><p class="list-inset">Returning vague errors eliminates the value of FP’s expressive <span class="No-Break">error handling:</span></p><pre class="source-code">
return Result.Fail&lt;User, string&gt;("Something went wrong.");</pre></li>				<li><span class="No-Break"><strong class="bold">Ignoring errors</strong></span><p class="list-inset">Just getting the value without addressing potential failures breaks the idea of FP error handling. An example is when you have a Result type as a method output, but don’t <span class="No-Break">check it:</span></p><pre class="source-code">
var result = GetData();
ProcessData(result.Value);</pre></li>				<li><strong class="bold">Overcomplicating with </strong><span class="No-Break"><strong class="bold">custom types</strong></span><p class="list-inset">While <a id="_idIndexMarker340"/>detailed error types are beneficial, creating one for every minor deviation can overcomplicate things. Please don’t do errors <span class="No-Break">like these:</span></p><pre class="source-code">
public class NameMissingFirstCharacterError : NameError { /* ... */ }
public class NameMissingLastCharacterError : NameError { /* ... */ }</pre></li>			</ul>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor261"/>Exercises</h2>
			<p>Steve was eager to apply his newfound knowledge of functional error handling to his tower defense game. Julia, impressed by his enthusiasm, presented him with three challenges to test his understanding and improve <span class="No-Break">his code.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor262"/>Exercise 1</h2>
			<p>Here’s the function that upgrades a tower and returns a boolean. Refactor it to return a <strong class="source-inline">Result</strong> type instead, with a custom error when the <span class="No-Break">payment fails:</span></p>
			<pre class="source-code">
public bool UpgradeTower(Tower tower)
{
     // Tower upgrading logic...
     if (/* upgrade fails */)
     {
                  return false;
     }
     return true;
}</pre>			<h2 id="_idParaDest-195"><a id="_idTextAnchor263"/>Exercise 2</h2>
			<p>Steve has a workflow that involves parsing, validating, and processing an enemy spawn. Refactor it using Railway-Oriented Programming to improve the <span class="No-Break">error-handling flow:</span></p>
			<pre class="source-code">
public void ProcessEnemySpawn(string enemyData)
{
     var parsedData = ParseEnemyData(enemyData);
     if (parsedData.IsValid)
     {
              var validation = ValidateEnemySpawn(parsedData);
              if (validation.IsValid)
              {
                  SpawnEnemy(validation.Enemy);
              }
     }
}</pre>			<h2 id="_idParaDest-196"><a id="_idTextAnchor264"/>Exercise 3</h2>
			<p>Write a function that implements a retry mechanism for a flaky operation and returns a <strong class="source-inline">Result</strong> type. The function should retry the operation a specified number of times before returning <span class="No-Break">an error:</span></p>
			<pre class="source-code">
public bool TowerFire(Tower tower, Enemy enemy)
{
     // Sometimes works and returns true
     // sometimes doesn't and returns false
}</pre>			<p>Try to do these exercises yourself, and when finished, you can check your work with the <span class="No-Break">following solutions.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor265"/>Solutions</h1>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor266"/>Exercise 1</h2>
			<p>Refactor the method to use a <strong class="source-inline">Result</strong> type with a custom error that encapsulates <span class="No-Break">failure details:</span></p>
			<pre class="source-code">
public enum TowerUpgradeError
{
     InsufficientResources,
     MaxLevelReached,
     TowerDestroyed
}
public Result&lt;bool, TowerUpgradeError&gt; UpgradeTower(Tower tower)
{
     // Tower upgrading logic...
     if (/* insufficient resources */)
     {
                  return Result.Fail&lt;bool, TowerUpgradeError&gt;(TowerUpgradeError.InsufficientResources);
     }
     else if (/* max level reached */)
     {
                  return Result.Fail&lt;bool, TowerUpgradeError&gt;(TowerUpgradeError.MaxLevelReached);
     }
     else if (/* tower is destroyed */)
     {
                  return Result.Fail&lt;bool, TowerUpgradeError&gt;(TowerUpgradeError.TowerDestroyed);
     }
     return Result.Ok&lt;bool, TowerUpgradeError&gt;(true);
}</pre>			<h2 id="_idParaDest-199"><a id="_idTextAnchor267"/>Exercise 2</h2>
			<p>Steve refactored his enemy spawning system using ROP, creating a clean pipeline for processing <span class="No-Break">enemy data:</span></p>
			<pre class="source-code">
public Result&lt;Enemy, EnemySpawnError&gt; ProcessEnemySpawn(string enemyData)
{
     return ParseEnemyData(enemyData)
                  .Bind(ValidateEnemySpawn)
                  .Bind(SpawnEnemy);
}
// Assume these methods are implemented to return Result&lt;T, EnemySpawnError&gt;
public Result&lt;ParsedEnemyData, EnemySpawnError&gt; ParseEnemyData(string data) { /* ... */ }
public Result&lt;ValidatedEnemy, EnemySpawnError&gt; ValidateEnemySpawn(ParsedEnemyData data) { /* ... */ }
public Result&lt;Enemy, EnemySpawnError&gt; SpawnEnemy(ValidatedEnemy enemy) { /* ... */ }</pre>			<h2 id="_idParaDest-200"><a id="_idTextAnchor268"/>Exercise 3</h2>
			<p>For the flaky tower firing mechanism, Steve implemented a retry function that attempts the operation multiple times before <span class="No-Break">giving up:</span></p>
			<pre class="source-code">
public Result&lt;bool, string&gt; TryTowerFire(Tower tower, Enemy enemy, int maxRetries)
{
     for (int attempt = 0; attempt &lt; maxRetries; attempt++)
     {
                  if (TowerFire(tower, enemy))
                  {
                      return Result.Ok&lt;bool, string&gt;(true);
                  }
     }
     return Result.Fail&lt;bool, string&gt;($"Tower firing failed after {maxRetries} attempts.");
}</pre>			<p>These exercises take you from understanding to applying functional principles in practical coding scenarios. They encourage you to think and code functionally, recognizing error handling not as an afterthought but as an integral part of the <span class="No-Break">coding process.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor269"/>Summary</h1>
			<p>In this chapter, we progressed from traditional methods of error handling to functional approaches. We identified the strengths, challenges, patterns, and anti-patterns of the <span class="No-Break">FP way.</span></p>
			<p>Functional programming offers not just a way to code, but a mindset shift. By treating errors as data, we benefit from type safety, expressiveness, <span class="No-Break">and predictability.</span></p>
			<p>However, our goal is not to get rid of all exceptions and nulls but to create more readable and resilient software. Luckily, with the development of C#, functional error handling is becoming easier and <span class="No-Break">more integrated.</span></p>
			<p>Like all paradigms, functional programming is not a silver bullet. While errors as data can be powerful, you have to remember the real world where your code runs. Networking failures, database outages, and hardware malfunctions are realities. Striking a balance between functional purity and real-world pragmatism <span class="No-Break">is key.</span></p>
			<p>A couple of times in this chapter, we used delegates, and in order to get a better understanding of them and their role in functional programming, in the next chapter we will delve into the concepts of higher-order functions <span class="No-Break">and delegates.</span></p>
		</div>
	</body></html>